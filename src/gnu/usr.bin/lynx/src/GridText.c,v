head	1.9;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.8
	tg-mergefixes-1-branch:1.8.0.4
	tg-mergefixes-1-base:1.8
	MIROS_X:1.8.0.2
	MIROS_X_BASE:1.8
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.9
	lynx-2_8_6dev_6:1.1.3.8
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.7
	lynx-2_8_6dev_5:1.1.3.6
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.4
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.5
	lynx-2_8_5:1.1.3.4
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.3
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.4.0.6
	MIRBSD_7:1.4.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.4
	MIRBSD_7_DEV:1.4.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2005.01.03.00.45.52;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.20.10.26.23;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.11.20.30.37;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.23.05.43.46;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.01.18.16.55.59;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.27.13.12.39;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.26;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.25;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.15;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.13;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.23;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.46.14;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.01.18.15.34.43;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.02.08.13.11.23;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.04.30.16.16.03;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.07.15.15.53.31;	author tg;	state Exp;
branches;
next	1.1.3.7;

1.1.3.7
date	2004.07.15.16.06.18;	author tg;	state Exp;
branches;
next	1.1.3.8;

1.1.3.8
date	2004.10.11.20.16.23;	author tg;	state Exp;
branches;
next	1.1.3.9;

1.1.3.9
date	2004.10.20.10.10.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@soft merge
@
text
@/*		Character grid hypertext object
 *		===============================
 */

#include <HTUtils.h>
#include <HTString.h>
#include <HTAccess.h>
#include <HTAnchor.h>
#include <HTParse.h>
#include <HTTP.h>
#include <HTAlert.h>
#include <HTCJK.h>
#include <HTFile.h>
#include <UCDefs.h>
#include <UCAux.h>
#include <HText.h>

#include <assert.h>

#include <GridText.h>
#include <LYCurses.h>
#include <LYUtils.h>
#include <LYStrings.h>
#include <LYStructs.h>
#include <LYGlobalDefs.h>
#include <LYGetFile.h>
#include <LYClean.h>
#include <LYMail.h>
#include <LYList.h>
#include <LYCharSets.h>
#include <LYCharUtils.h>	/* LYUCTranslateBack... */
#include <UCMap.h>
#include <LYEdit.h>
#include <LYPrint.h>
#include <LYPrettySrc.h>
#include <TRSTable.h>
#include <LYHistory.h>
#ifdef EXP_CHARTRANS_AUTOSWITCH
#include <UCAuto.h>
#endif /* EXP_CHARTRANS_AUTOSWITCH */

#include <LYexit.h>
#include <LYLeaks.h>

/*#define DEBUG_APPCH 1*/

#ifdef USE_COLOR_STYLE
#include <AttrList.h>
#include <LYHash.h>

unsigned int cached_styles[CACHEH][CACHEW];

#endif

#include <LYJustify.h>

#ifdef USE_CURSES_PADS
#  define DISPLAY_COLS    (LYwideLines ? MAX_COLS : LYcols)
#  define WRAP_COLS(text) ((text)->stbl ?				\
			   (LYtableCols <= 0				\
			    ? DISPLAY_COLS				\
			    : (LYtableCols * LYcols)/12) - LYbarWidth	\
			   : LYcolLimit)
#else
#  define DISPLAY_COLS    LYcols
#  define WRAP_COLS(text) LYcolLimit
#endif

#define FirstHTLine(text) ((text)->last_line->next)
#define LastHTLine(text)  ((text)->last_line)

static void HText_trimHightext(HText *text, BOOLEAN final,
			       int stop_before);

#ifdef USE_COLOR_STYLE
static void LynxResetScreenCache(void)
{
    int i, j;

    for (i = 1; (i < CACHEH && i <= display_lines); i++) {
	for (j = 0; j < CACHEW; j++)
	    cached_styles[i][j] = 0;
    }
}
#endif /* USE_COLOR_STYLE */

struct _HTStream {		/* only know it as object */
    const HTStreamClass *isa;
    /* ... */
};

#define TITLE_LINES  1

#define IS_UTF_EXTRA(ch) (text->T.output_utf8 && \
			  (UCH((ch))&0xc0) == 0x80)

#define IS_UTF8_EXTRA(ch) (!(text && text->T.output_utf8) || \
			  !is8bits(ch) || \
			  (UCH(line->data[i] & 0xc0) == 0xc0))

/* a test in compact form: how many extra UTF-8 chars after initial? - kw */
#define UTF8_XNEGLEN(c) (c&0xC0? 0 :c&32? 1 :c&16? 2 :c&8? 3 :c&4? 4 :c&2? 5:0)
#define UTF_XLEN(c) UTF8_XNEGLEN(((char)~(c)))

#ifdef KANJI_CODE_OVERRIDE
HTkcode last_kcode = NOKANJI;	/* 1997/11/14 (Fri) 09:09:26 */
#endif

#ifdef CJK_EX
#define CHAR_WIDTH 6
#else
#define CHAR_WIDTH 1
#endif

/*	Exports
*/
HText *HTMainText = NULL;	/* Equivalent of main window */
HTParentAnchor *HTMainAnchor = NULL;	/* Anchor for HTMainText */

const char *HTAppName = LYNX_NAME;	/* Application name */
const char *HTAppVersion = LYNX_VERSION;	/* Application version */

static int HTFormNumber = 0;
static int HTFormFields = 0;
static char *HTCurSelectGroup = NULL;	/* Form select group name */
static int HTCurSelectGroupCharset = -1;	/* ... and name's charset */
int HTCurSelectGroupType = F_RADIO_TYPE;	/* Group type */
char *HTCurSelectGroupSize = NULL;	/* Length of select */
static char *HTCurSelectedOptionValue = NULL;	/* Select choice */

const char *checked_box = "[X]";
const char *unchecked_box = "[ ]";
const char *checked_radio = "(*)";
const char *unchecked_radio = "( )";

static BOOLEAN underline_on = OFF;
static BOOLEAN bold_on = OFF;

#ifdef USE_SOURCE_CACHE
int LYCacheSource = SOURCE_CACHE_NONE;
int LYCacheSourceForAborted = SOURCE_CACHE_FOR_ABORTED_DROP;
#endif

#ifdef USE_SCROLLBAR
BOOLEAN LYShowScrollbar = FALSE;
BOOLEAN LYsb_arrow = TRUE;
int LYsb_begin = -1;
int LYsb_end = -1;
#endif

#ifndef VMS			/* VMS has a better way - right? - kw */
#define CHECK_FREE_MEM
#endif

#ifdef CHECK_FREE_MEM
static void *LY_check_calloc(size_t nmemb, size_t size);

#define LY_CALLOC LY_check_calloc
#else
  /* using the regular calloc */
#define LY_CALLOC calloc
#endif

/*
 * The HTPool.data[] array has to align the same as malloc() would, to make the
 * ALLOC_POOL scheme portable.  For many platforms, that is the same as the
 * number of bytes in a pointer.  It may be larger, e.g., on machines which
 * have more stringent requirements for floating point.  32-bits are plenty for
 * representing styles, but we may need 64-bit or 128-bit alignment.
 *
 * The real issue is that performance is degraded if the alignment is not met,
 * and some platforms such as Tru64 generate lots of warning messages.
 */
#ifndef ALIGN_SIZE
#define ALIGN_SIZE      sizeof(double)
#endif

typedef struct {
    unsigned int direction:2;	/* on or off */
    unsigned int horizpos:14;	/* horizontal position of this change */
    unsigned int style:16;	/* which style to change to */
} HTStyleChange;

#if defined(USE_COLOR_STYLE)
#define MAX_STYLES_ON_LINE   64
  /* buffers used when current line is being aggregated, in split_line() */
static HTStyleChange stylechanges_buffers[2][MAX_STYLES_ON_LINE];
#endif

typedef HTStyleChange pool_data;

enum {
    POOL_SIZE = ((8192
		  - 4 * sizeof(void *)
		  - sizeof(struct _HTPool *)
		  - sizeof(int))
		 / sizeof(pool_data))
};

typedef struct _HTPool {
    pool_data data[POOL_SIZE];
    struct _HTPool *prev;
    int used;
} HTPool;

/************************************************************************
These are generic macros for any pools (provided those structures have the
same members as HTPool).  Pools are used for allocation of groups of
objects of the same type T.  Pools are represented as a list of structures of
type P (called pool chunks here).  Structure P has an array of N objects of
type T named 'data' (the number N in the array can be chosen arbitrary),
pointer to the previous pool chunk named 'prev', and the number of used items
in that pool chunk named 'used'.  Here is a definition of the structure P:
	struct P
	{
	    T data[N];
	    struct P* prev;
	    int used;
	};
 It's recommended that sizeof(P) be memory page size minus 32 in order malloc'd
chunks to fit in machine page size.
 Allocation of 'n' items in the pool is implemented by incrementing member
'used' by 'n' if (used+n <= N), or malloc a new pool chunk and
allocating 'n' items in that new chunk.  It's the task of the programmer to
assert that 'n' is <= N.  Only entire pool may be freed - this limitation makes
allocation algorithms trivial and fast - so the use of pools is limited to
objects that are freed in batch, that are not deallocated not in the batch, and
not reallocated.
 Pools greatly reduce memory fragmentation and memory allocation/deallocation
speed due to the simple algorithms used.  Due to the fact that memory is
'allocated' in array, alignment overhead is minimal.  Allocating strings in a
pool provided their length will never exceed N and is much smaller than N seems
to be very efficient.
 [Several types of memory-hungry objects are stored in the pool now:  styles,
lines, anchors, and FormInfo. Arrays of HTStyleChange are stored as is,
other objects are stored using a cast.]

 Pool is referenced by the pointer to the last chunk that contains free slots.
Functions that allocate memory in the pool update that pointer if needed.
There are 3 functions - POOL_NEW, POOL_FREE, and ALLOC_IN_POOL.

      - VH

*************************************************************************/

#define POOLallocstyles(ptr, n)     ptr = ALLOC_IN_POOL(&HTMainText->pool, n * sizeof(pool_data))
#define POOLallocHTLine(ptr, size)  ptr = (HTLine*) ALLOC_IN_POOL(&HTMainText->pool, LINE_SIZE(size))
#define POOLallocstring(ptr, len)   ptr = (char*) ALLOC_IN_POOL(&HTMainText->pool, len + 1)
#define POOLtypecalloc(T, ptr)      ptr = (T*) ALLOC_IN_POOL(&HTMainText->pool, sizeof(T))

/**************************************************************************/
/*
 * Allocates 'n' items in the pool of type 'HTPool' pointed by 'poolptr'.
 * Returns a pointer to the "allocated" memory or NULL if fails.
 * Updates 'poolptr' if necessary.
 */
static pool_data *ALLOC_IN_POOL(HTPool ** ppoolptr, unsigned request)
{
    HTPool *pool = *ppoolptr;
    pool_data *ptr;
    unsigned n;
    unsigned j;

    if (!pool) {
	ptr = NULL;
    } else {
	n = request;
	if (n == 0)
	    n = 1;
	j = (n % ALIGN_SIZE);
	if (j != 0)
	    n += (ALIGN_SIZE - j);
	n /= sizeof(pool_data);

	if (POOL_SIZE >= (pool->used + n)) {
	    ptr = pool->data + pool->used;
	    pool->used += n;
	} else {
	    HTPool *newpool = (HTPool *) LY_CALLOC(1, sizeof(HTPool));

	    if (!newpool) {
		ptr = NULL;
	    } else {
		newpool->prev = pool;
		newpool->used = n;
		ptr = newpool->data;
		*ppoolptr = newpool;
	    }
	}
    }
    return ptr;
}

/*
 * Returns a pointer to initialized pool of type 'HTPool', or NULL if fails.
 */
static HTPool *POOL_NEW(void)
{
    HTPool *poolptr = (HTPool *) LY_CALLOC(1, sizeof(HTPool));

    if (poolptr) {
	poolptr->prev = NULL;
	poolptr->used = 0;
    }
    return poolptr;
}

/*
 * Frees a pool of type 'HTPool' pointed by poolptr.
 */
static void POOL_FREE(HTPool * poolptr)
{
    HTPool *cur = poolptr;
    HTPool *prev;

    while (cur) {
	prev = cur->prev;
	free(cur);
	cur = prev;
    }
}

/**************************************************************************/
/**************************************************************************/

typedef struct _line {
    struct _line *next;
    struct _line *prev;
    unsigned short offset;	/* Implicit initial spaces */
    unsigned short size;	/* Number of characters */
#if defined(USE_COLOR_STYLE)
    HTStyleChange *styles;
    unsigned short numstyles;
#endif
    char data[1];		/* Space for terminator at least! */
} HTLine;

#define LINE_SIZE(size) (sizeof(HTLine)+(size))		/* Allow for terminator */

#ifndef HTLINE_NOT_IN_POOL
#define HTLINE_NOT_IN_POOL 0	/* debug with this set to 1 */
#endif

#if HTLINE_NOT_IN_POOL
#define allocHTLine(ptr, size)  { ptr = (HTLine *)calloc(1, LINE_SIZE(size)); }
#define freeHTLine(self, ptr)   { \
	if (ptr && ptr != TEMP_LINE(self, 0) && ptr != TEMP_LINE(self, 1)) \
	    FREE(ptr); \
    }
#else
#define allocHTLine(ptr, size)  POOLallocHTLine(ptr, size)
#define freeHTLine(self, ptr)   {}
#endif

/*
 * Last line buffer; the second is used in split_line(). Not in pool!
 * We cannot wrap in middle of multibyte sequences, so allocate 2 extra
 * for a workspace.  This is stored in the HText, to prevent confusion
 * between different documents.  Note also that it is declared with an
 * HTLine at the beginning so pointers will be properly aligned.
 */
typedef struct {
    HTLine base;
    char data[MAX_LINE + 2];
} HTLineTemp;

#define TEMP_LINE(p,n) ((HTLine *)&(p->temp_line[n]))

typedef struct _TextAnchor {
    struct _TextAnchor *next;
    struct _TextAnchor *prev;	/* www_user_search only! */
    int number;			/* For user interface */
    int line_num;		/* Place in document */
    short line_pos;		/* Bytes/chars - extent too */
    short extent;		/* (see HText_trimHightext) */
    BOOL show_anchor;		/* Show the anchor? */
    BOOL inUnderline;		/* context is underlined */
    BOOL expansion_anch;	/* TEXTAREA edit new anchor */
    char link_type;		/* Normal, internal, or form? */
    FormInfo *input_field;	/* Info for form links */
    HiliteList lites;

    HTChildAnchor *anchor;
} TextAnchor;

typedef struct {
    char *name;			/* ID value of TAB */
    int column;			/* Zero-based column value */
} HTTabID;

typedef enum {
    S_text,
    S_esc,
    S_dollar,
    S_paren,
    S_nonascii_text,
    S_dollar_paren,
    S_jisx0201_text
} eGridState;			/* Escape sequence? */

#ifdef USE_TH_JP_AUTO_DETECT
typedef enum {			/* Detected Kanji code */
    DET_SJIS,
    DET_EUC,
    DET_NOTYET,
    DET_MIXED
} eDetectedKCode;

typedef enum {
    SJIS_state_neutral,
    SJIS_state_in_kanji,
    SJIS_state_has_bad_code
} eSJIS_status;

typedef enum {
    EUC_state_neutral,
    EUC_state_in_kanji,
    EUC_state_in_kana,
    EUC_state_has_bad_code
} eEUC_status;
#endif

/*	Notes on struct _Htext:
 *	next_line is valid if stale is false.
 *	top_of_screen line means the line at the top of the screen
 *			or just under the title if there is one.
 */
struct _HText {
    HTParentAnchor *node_anchor;

    HTLine *last_line;
    HTLineTemp temp_line[2];
    int Lines;			/* Number of them */
    TextAnchor *first_anchor;	/* double-linked on demand */
    TextAnchor *last_anchor;
    TextAnchor *last_anchor_before_stbl;
    TextAnchor *last_anchor_before_split;
    HTList *forms;		/* also linked internally */
    int last_anchor_number;	/* user number */
    BOOL source;		/* Is the text source? */
    BOOL toolbar;		/* Toolbar set? */
    HTList *tabs;		/* TAB IDs */
    HTList *hidden_links;	/* Content-less links ... */
    int hiddenlinkflag;		/*  ... and how to treat them */
    BOOL no_cache;		/* Always refresh? */
    char LastChar;		/* For absorbing white space */
    BOOL IgnoreExcess;		/* Ignore chars at wrap point */

/* For Internal use: */
    HTStyle *style;		/* Current style */
    int display_on_the_fly;	/* Lines left */
    int top_of_screen;		/* Line number */
    HTLine *top_of_screen_line;	/* Top */
    HTLine *next_line;		/* Bottom + 1 */
    unsigned permissible_split;	/* in last line */
    BOOL in_line_1;		/* of paragraph */
    BOOL stale;			/* Must refresh */
    BOOL page_has_target;	/* has target on screen */
    BOOL has_utf8;		/* has utf-8 on screen or line */
    BOOL had_utf8;		/* had utf-8 when last displayed */
#ifdef DISP_PARTIAL
    int first_lineno_last_disp_partial;
    int last_lineno_last_disp_partial;
#endif
    STable_info *stbl;
    HTList *enclosed_stbl;

    HTkcode kcode;		/* Kanji code? */
    HTkcode specified_kcode;	/* Specified Kanji code */
#ifdef USE_TH_JP_AUTO_DETECT
    eDetectedKCode detected_kcode;
    eSJIS_status SJIS_status;
    eEUC_status EUC_status;
#endif
    eGridState state;		/* Escape sequence? */
    int kanji_buf;		/* Lead multibyte */
    int in_sjis;		/* SJIS flag */
    int halted;			/* emergency halt */

    BOOL have_8bit_chars;	/* Any non-ASCII chars? */
    LYUCcharset *UCI;		/* node_anchor UCInfo */
    int UCLYhndl;		/* charset we are fed */
    UCTransParams T;

    HTStream *target;		/* Output stream */
    HTStreamClass targetClass;	/* Output routines */

    HTPool *pool;		/* this HText memory pool */

#ifdef USE_SOURCE_CACHE
    /*
     * Parse settings when this HText was generated.
     */
    BOOL clickable_images;
    BOOL pseudo_inline_alts;
    BOOL verbose_img;
    BOOL raw_mode;
    BOOL historical_comments;
    BOOL minimal_comments;
    BOOL soft_dquotes;
    short old_dtd;
    short keypad_mode;
    short disp_lines;		/* Screen size */
    short disp_cols;		/* Used for reports only */
#endif
};

/* exported */
void *HText_pool_calloc(HText *text, unsigned size)
{
    return (void *) ALLOC_IN_POOL(&text->pool, size);
}

static void HText_AddHiddenLink(HText *text, TextAnchor *textanchor);

#ifdef EXP_JUSTIFY_ELTS
BOOL can_justify_here;
BOOL can_justify_here_saved;

BOOL can_justify_this_line;	/* =FALSE if line contains form objects */
int wait_for_this_stacked_elt;	/* -1 if can justify contents of the

				   element on the op of stack. If positive - specifies minimal stack depth
				   plus 1 at which we can justify element (can be MAX_LINE+2 if
				   ok_justify ==FALSE or in psrcview. */
BOOL form_in_htext;		/*to indicate that we are in form (since HTML_FORM is

				   not stacked in the HTML.c */
BOOL in_DT = FALSE;

#ifdef DEBUG_JUSTIFY
BOOL can_justify_stack_depth;	/* can be 0 or 1 if all code is correct */
#endif

typedef struct {
    int byte_len;		/*length in bytes */
    int cell_len;		/*length in cells */
} ht_run_info;

static int justify_start_position;	/* this is an index of char from which

					   justification can start (eg after "* " preceeding <li> text) */

static int ht_num_runs;		/*the number of runs filled */
static ht_run_info ht_runs[MAX_LINE];
static BOOL this_line_was_split;
static TextAnchor *last_anchor_of_previous_line;
static BOOL have_raw_nbsps = FALSE;

void ht_justify_cleanup(void)
{
    wait_for_this_stacked_elt = !ok_justify
#  ifdef USE_PRETTYSRC
	|| psrc_view
#  endif
	? 30000 /*MAX_NESTING */  + 2	/*some unreachable value */
	: -1;
    can_justify_here = TRUE;
    can_justify_this_line = TRUE;
    form_in_htext = FALSE;

    last_anchor_of_previous_line = NULL;
    this_line_was_split = FALSE;
    in_DT = FALSE;
    have_raw_nbsps = FALSE;
}

void mark_justify_start_position(void *text)
{
    if (text && ((HText *) text)->last_line)
	justify_start_position = ((HText *) text)->last_line->size;
}

#define REALLY_CAN_JUSTIFY(text) ( (wait_for_this_stacked_elt<0) && \
	( text->style->alignment == HT_LEFT     || \
	  text->style->alignment == HT_JUSTIFY) && \
	HTCJK == NOCJK && !in_DT && \
	can_justify_here && can_justify_this_line && !form_in_htext )

#endif /* EXP_JUSTIFY_ELTS */

/*
 * Boring static variable used for moving cursor across
 */
#define UNDERSCORES(n) \
 ((n) >= MAX_LINE ? underscore_string : &underscore_string[(MAX_LINE-1)] - (n))

/*
 *	Memory leak fixed.
 *	05-29-94 Lynx 2-3-1 Garrett Arch Blythe
 *	Changed to arrays.
 */
static char underscore_string[MAX_LINE + 1];
char star_string[MAX_LINE + 1];

static int ctrl_chars_on_this_line = 0;		/* num of ctrl chars in current line */
static int utfxtra_on_this_line = 0;	/* num of UTF-8 extra bytes in line,

					   they *also* count as ctrl chars. */
#ifdef WIDEC_CURSES
#define UTFXTRA_ON_THIS_LINE 0
#else
#define UTFXTRA_ON_THIS_LINE utfxtra_on_this_line
#endif

static HTStyle default_style =
{0, "(Unstyled)", 0, "",
 (HTFont) 0, 1, HT_BLACK, 0, 0,
 0, 0, 0, HT_LEFT, 1, 0, 0,
 NO, NO, 0, 0, 0};

static HTList *loaded_texts = NULL;	/* A list of all those in memory */
HTList *search_queries = NULL;	/* isindex and whereis queries   */

#ifdef LY_FIND_LEAKS
static void free_all_texts(void);
#endif

static BOOL HText_TrueEmptyLine(HTLine *line, HText *text, BOOL IgnoreSpaces);

static int HText_TrueLineSize(HTLine *line, HText *text, BOOL IgnoreSpaces);

#ifdef CHECK_FREE_MEM

/*
 * text->halted = 1: have set fake 'Z' and output a message
 *		  2: next time when HText_appendCharacter is called
 *		     it will append *** MEMORY EXHAUSTED ***, then set
 *		     to 3.
 *		  3: normal text output will be suppressed (but not anchors,
 *		     form fields etc.)
 */
static void HText_halt(void)
{
    if (HTFormNumber > 0)
	HText_DisableCurrentForm();
    if (!HTMainText)
	return;
    if (HTMainText->halted < 2)
	HTMainText->halted = 2;
}

#define MIN_NEEDED_MEM 5000

/*
 * Check whether factor*min(bytes,MIN_NEEDED_MEM) is available,
 * or bytes if factor is 0.
 * MIN_NEEDED_MEM and factor together represent a security margin,
 * to take account of all the memory allocations where we don't check
 * and of buffers which may be emptied before HTCheckForInterupt()
 * is (maybe) called and other things happening, with some chance of
 * success.
 * This just tries to malloc() the to-be-checked-for amount of memory,
 * which might make the situation worse depending how allocation works.
 * There should be a better way...  - kw
 */
static BOOL mem_is_avail(size_t factor, size_t bytes)
{
    void *p;

    if (bytes < MIN_NEEDED_MEM && factor > 0)
	bytes = MIN_NEEDED_MEM;
    if (factor == 0)
	factor = 1;
    p = malloc(factor * bytes);
    if (p) {
	FREE(p);
	return YES;
    } else {
	return NO;
    }
}

/*
 * Replacement for calloc which checks for "enough" free memory
 * (with some security margins) and tries various recovery actions
 * if deemed necessary.  - kw
 */
static void *LY_check_calloc(size_t nmemb, size_t size)
{
    int i, n;

    if (mem_is_avail(4, nmemb * size)) {
	return (calloc(nmemb, size));
    }
    n = HTList_count(loaded_texts);
    for (i = n - 1; i > 0; i--) {
	HText *t = (HText *) HTList_objectAt(loaded_texts, i);

	CTRACE((tfp,
		"\nBUG *** Emergency freeing document %d/%d for '%s'%s!\n",
		i + 1, n,
		((t && t->node_anchor &&
		  t->node_anchor->address) ?
		 t->node_anchor->address : "unknown anchor"),
		((t && t->node_anchor &&
		  t->node_anchor->post_data) ?
		 " with POST data" : "")));
	HTList_removeObjectAt(loaded_texts, i);
	HText_free(t);
	if (mem_is_avail(4, nmemb * size)) {
	    return (calloc(nmemb, size));
	}
    }
    LYFakeZap(YES);
    if (!HTMainText || HTMainText->halted <= 1) {
	if (!mem_is_avail(2, nmemb * size)) {
	    HText_halt();
	    if (mem_is_avail(0, 700)) {
		HTAlert(gettext("Memory exhausted, display interrupted!"));
	    }
	} else {
	    if ((!HTMainText || HTMainText->halted == 0) &&
		mem_is_avail(0, 700)) {
		HTAlert(gettext("Memory exhausted, will interrupt transfer!"));
		if (HTMainText)
		    HTMainText->halted = 1;
	    }
	}
    }
    return (calloc(nmemb, size));
}

#endif /* CHECK_FREE_MEM */

/*
 * Clear highlight information for a given anchor
 * (text was allocated in the pool).
 */
static void LYClearHiText(TextAnchor *a)
{
    FREE(a->lites.hl_info);

    a->lites.hl_base.hl_text = NULL;
    a->lites.hl_len = 0;
}

#define LYFreeHiText(a)     FREE((a)->lites.hl_info)

/*
 * Set the initial highlight information for a given anchor.
 */
static void LYSetHiText(TextAnchor *a,
			const char *text,
			int len)
{
    if (text != NULL) {
	POOLallocstring(a->lites.hl_base.hl_text, len + 1);
	memcpy(a->lites.hl_base.hl_text, text, len);
	*(a->lites.hl_base.hl_text + len) = '\0';

	a->lites.hl_len = 1;
    }
}

/*
 * Add highlight information for the next line of a anchor.
 */
static void LYAddHiText(TextAnchor *a,
			const char *text,
			int x)
{
    HiliteInfo *have = a->lites.hl_info;
    unsigned need = (a->lites.hl_len - 1);
    unsigned want = (a->lites.hl_len += 1) * sizeof(HiliteInfo);

    if (have != NULL) {
	have = (HiliteInfo *) realloc(have, want);
    } else {
	have = (HiliteInfo *) malloc(want);
    }
    a->lites.hl_info = have;

    POOLallocstring(have[need].hl_text, strlen(text) + 1);
    strcpy(have[need].hl_text, text);
    have[need].hl_x = x;
}

/*
 * Return an offset to skip leading blanks in the highlighted link.  That is
 * needed to avoid having the color-style paint the leading blanks.
 */
#ifdef USE_COLOR_STYLE
static int LYAdjHiTextPos(TextAnchor *a, int count)
{
    char *result;

    if (count >= a->lites.hl_len)
	result = NULL;
    else if (count > 0)
	result = a->lites.hl_info[count - 1].hl_text;
    else
	result = a->lites.hl_base.hl_text;

    return (result != 0) ? (LYSkipBlanks(result) - result) : 0;
}
#else
#define LYAdjHiTextPos(a,count) 0
#endif

/*
 * Get the highlight text, counting from zero.
 */
static char *LYGetHiTextStr(TextAnchor *a, int count)
{
    char *result;

    if (count >= a->lites.hl_len)
	result = NULL;
    else if (count > 0)
	result = a->lites.hl_info[count - 1].hl_text;
    else
	result = a->lites.hl_base.hl_text;
    result += LYAdjHiTextPos(a, count);
    return result;
}

/*
 * Get the X-ordinate at which to draw the corresponding highlight-text
 */
static int LYGetHiTextPos(TextAnchor *a, int count)
{
    int result;

    if (count >= a->lites.hl_len)
	result = -1;
    else if (count > 0)
	result = a->lites.hl_info[count - 1].hl_x;
    else
	result = a->line_pos;
    result += LYAdjHiTextPos(a, count);
    return result;
}

/*
 * Copy highlighting information from anchor 'b' to 'a'.
 */
static void LYCopyHiText(TextAnchor *a, TextAnchor *b)
{
    int count;
    char *s;

    LYClearHiText(a);
    for (count = 0;; ++count) {
	if ((s = LYGetHiTextStr(b, count)) == NULL)
	    break;
	if (count == 0) {
	    LYSetHiText(a, s, strlen(s));
	} else {
	    LYAddHiText(a, s, LYGetHiTextPos(b, count));
	}
    }
}

static void HText_getChartransInfo(HText *me)
{
    me->UCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor, UCT_STAGE_HTEXT);
    if (me->UCLYhndl < 0) {
	int chndl = current_char_set;

	HTAnchor_setUCInfoStage(me->node_anchor, chndl,
				UCT_STAGE_HTEXT, UCT_SETBY_STRUCTURED);
	me->UCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor,
					    UCT_STAGE_HTEXT);
    }
    me->UCI = HTAnchor_getUCInfoStage(me->node_anchor, UCT_STAGE_HTEXT);
}

static void PerFormInfo_free(PerFormInfo * form)
{
    if (form) {
	FREE(form->accept_cs);
	FREE(form->thisacceptcs);
	FREE(form);
    }
}

static void free_form_fields(FormInfo * input_field)
{
    /*
     * Free form fields.
     */
    if (input_field->type == F_OPTION_LIST_TYPE &&
	input_field->select_list != NULL) {
	/*
	 * Free off option lists if present.
	 * It should always be present for F_OPTION_LIST_TYPE
	 * unless we had invalid markup which prevented
	 * HText_setLastOptionValue from finishing its job
	 * and left the input field in an insane state.  - kw
	 */
	OptionType *optptr = input_field->select_list;
	OptionType *tmp;

	while (optptr) {
	    tmp = optptr;
	    optptr = tmp->next;
	    FREE(tmp->name);
	    FREE(tmp->cp_submit_value);
	    FREE(tmp);
	}
	input_field->select_list = NULL;
	/*
	 * Don't free the value field on option
	 * lists since it points to a option value
	 * same for orig value.
	 */
	input_field->value = NULL;
	input_field->orig_value = NULL;
	input_field->cp_submit_value = NULL;
	input_field->orig_submit_value = NULL;
    } else {
	FREE(input_field->value);
	FREE(input_field->orig_value);
	FREE(input_field->cp_submit_value);
	FREE(input_field->orig_submit_value);
    }
    FREE(input_field->name);
    FREE(input_field->submit_action);
    FREE(input_field->submit_enctype);
    FREE(input_field->submit_title);

    FREE(input_field->accept_cs);
}

static void FormList_delete(HTList *forms)
{
    HTList *cur = forms;
    PerFormInfo *form;

    while ((form = (PerFormInfo *) HTList_nextObject(cur)) != NULL)
	PerFormInfo_free(form);
    HTList_delete(forms);
}

#ifdef DISP_PARTIAL
static void ResetPartialLinenos(HText *text)
{
    if (text != 0) {
	text->first_lineno_last_disp_partial = -1;
	text->last_lineno_last_disp_partial = -1;
    }
}
#endif

/*			Creation Method
 *			---------------
 */
HText *HText_new(HTParentAnchor *anchor)
{
#if defined(VMS) && defined(VAXC) && !defined(__DECC)
#include <lib$routines.h>
    int status, VMType = 3, VMTotal;
#endif /* VMS && VAXC && !__DECC */
    HTLine *line = NULL;
    HText *self = typecalloc(HText);

    if (!self)
	return self;

    CTRACE((tfp, "GridText: start HText_new\n"));

#if defined(VMS) && defined (VAXC) && !defined(__DECC)
    status = lib$stat_vm(&VMType, &VMTotal);
    CTRACE((tfp, "GridText: VMTotal = %d\n", VMTotal));
#endif /* VMS && VAXC && !__DECC */

    /*
     * If the previously shown text had UTF-8 characters on screen,
     * remember this in the newly created object.  Do this now, before
     * the previous object may become invalid.  - kw
     */
    if (HTMainText) {
	if (HText_hasUTF8OutputSet(HTMainText) &&
	    HTLoadedDocumentEightbit() &&
	    LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
	    self->had_utf8 = HTMainText->has_utf8;
	} else {
	    self->had_utf8 = HTMainText->has_utf8;
	}
	HTMainText->has_utf8 = NO;
    }

    if (!loaded_texts) {
	loaded_texts = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(free_all_texts);
#endif
    }

    /*
     * Links between anchors & documents are a 1-1 relationship.  If
     * an anchor is already linked to a document we didn't call
     * HTuncache_current_document(), so we'll check now
     * and free it before reloading.  - Dick Wesseling (ftu@@fi.ruu.nl)
     */
    if (anchor->document) {
	HTList_removeObject(loaded_texts, anchor->document);
	CTRACE((tfp, "GridText: Auto-uncaching\n"));

	HTAnchor_delete_links(anchor);
	((HText *) anchor->document)->node_anchor = NULL;
	HText_free((HText *) anchor->document);
	anchor->document = NULL;
    }

    HTList_addObject(loaded_texts, self);
#if defined(VMS) && defined(VAXC) && !defined(__DECC)
    while (HTList_count(loaded_texts) > HTCacheSize &&
	   VMTotal > HTVirtualMemorySize)
#else
    if (HTList_count(loaded_texts) > HTCacheSize)
#endif /* VMS && VAXC && !__DECC */
    {
	CTRACE((tfp, "GridText: Freeing off cached doc.\n"));
	HText_free((HText *) HTList_removeFirstObject(loaded_texts));
#if defined(VMS) && defined (VAXC) && !defined(__DECC)
	status = lib$stat_vm(&VMType, &VMTotal);
	CTRACE((tfp, "GridText: VMTotal reduced to %d\n", VMTotal));
#endif /* VMS && VAXC && !__DECC */
    }

    self->pool = POOL_NEW();
    if (!self->pool)
	outofmem(__FILE__, "HText_New");

    line = self->last_line = TEMP_LINE(self, 0);
    line->next = line->prev = line;
    line->offset = line->size = 0;
    line->data[line->size] = '\0';
#ifdef USE_COLOR_STYLE
    line->numstyles = 0;
    line->styles = stylechanges_buffers[0];
#endif
    self->Lines = 0;
    self->first_anchor = self->last_anchor = NULL;
    self->last_anchor_before_split = NULL;
    self->style = &default_style;
    self->top_of_screen = 0;
    self->node_anchor = anchor;
    self->last_anchor_number = 0;	/* Numbering of them for references */
    self->stale = YES;
    self->toolbar = NO;
    self->tabs = NULL;
#ifdef USE_SOURCE_CACHE
    /*
     * Remember the parse settings.
     */
    self->clickable_images = clickable_images;
    self->pseudo_inline_alts = pseudo_inline_alts;
    self->verbose_img = verbose_img;
    self->raw_mode = LYUseDefaultRawMode;
    self->historical_comments = historical_comments;
    self->minimal_comments = minimal_comments;
    self->soft_dquotes = soft_dquotes;
    self->old_dtd = Old_DTD;
    self->keypad_mode = keypad_mode;
    self->disp_lines = LYlines;
    self->disp_cols = DISPLAY_COLS;
#endif
    /*
     * If we are going to render the List Page, always merge in hidden
     * links to get the numbering consistent if form fields are numbered
     * and show up as hidden links in the list of links.
     * If we are going to render a bookmark file, also always merge in
     * hidden links, to get the link numbers consistent with the counting
     * in remove_bookmark_link().  Normally a bookmark file shouldn't
     * contain any entries with empty titles, but it might happen.  - kw
     */
    if (anchor->bookmark ||
	LYIsUIPage3(anchor->address, UIP_LIST_PAGE, 0) ||
	LYIsUIPage3(anchor->address, UIP_ADDRLIST_PAGE, 0))
	self->hiddenlinkflag = HIDDENLINKS_MERGE;
    else
	self->hiddenlinkflag = LYHiddenLinks;
    self->hidden_links = NULL;
    self->no_cache = ((anchor->no_cache ||
		       anchor->post_data)
		      ? YES
		      : NO);
    self->LastChar = '\0';
    self->IgnoreExcess = FALSE;

#ifndef USE_PRETTYSRC
    if (HTOutputFormat == WWW_SOURCE)
	self->source = YES;
    else
	self->source = NO;
#else
    /* mark_htext_as_source == TRUE if we are parsing html file (and psrc_view
     * is set temporary to false at creation time)
     *
     * psrc_view == TRUE if source of the text produced by some lynx module
     * (like ftp browsers) is requested).  - VH
     */
    self->source = (BOOL) (LYpsrc
			   ? mark_htext_as_source || psrc_view
			   : HTOutputFormat == WWW_SOURCE);
    mark_htext_as_source = FALSE;
#endif
    HTAnchor_setDocument(anchor, (HyperDoc *) self);
    HTFormNumber = 0;		/* no forms started yet */
    HTMainText = self;
    HTMainAnchor = anchor;
    self->display_on_the_fly = 0;
    self->kcode = NOKANJI;
    self->specified_kcode = NOKANJI;
#ifdef USE_TH_JP_AUTO_DETECT
    self->detected_kcode = DET_NOTYET;
    self->SJIS_status = SJIS_state_neutral;
    self->EUC_status = EUC_state_neutral;
#endif
    self->state = S_text;
    self->kanji_buf = '\0';
    self->in_sjis = 0;
    self->have_8bit_chars = NO;
    HText_getChartransInfo(self);
    UCSetTransParams(&self->T,
		     self->UCLYhndl, self->UCI,
		     current_char_set,
		     &LYCharSet_UC[current_char_set]);

    /*
     * Check the kcode setting if the anchor has a charset element.  -FM
     */
    HText_setKcode(self, anchor->charset,
		   HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT));

    /*
     * Memory leak fixed.
     * 05-29-94 Lynx 2-3-1 Garrett Arch Blythe
     * Check to see if our underline and star_string need initialization
     * if the underline is not filled with dots.
     */
    if (underscore_string[0] != '.') {
	/*
	 * Create an array of dots for the UNDERSCORES macro.  -FM
	 */
	memset(underscore_string, '.', (MAX_LINE - 1));
	underscore_string[(MAX_LINE - 1)] = '\0';
	underscore_string[MAX_LINE] = '\0';
	/*
	 * Create an array of underscores for the STARS macro.  -FM
	 */
	memset(star_string, '_', (MAX_LINE - 1));
	star_string[(MAX_LINE - 1)] = '\0';
	star_string[MAX_LINE] = '\0';
    }

    underline_on = FALSE;	/* reset */
    bold_on = FALSE;

#ifdef DISP_PARTIAL
    /*
     * By this function we create HText object
     * so we may start displaying the document while downloading. - LP
     */
    if (display_partial_flag) {
	display_partial = TRUE;	/* enable HTDisplayPartial() */
	NumOfLines_partial = 0;	/* initialize */
    }

    /*
     * These two fields should only be set to valid line numbers
     * by calls of display_page during partial displaying.  This
     * is just so that the FIRST display_page AFTER that can avoid
     * repainting the same lines on the screen.  - kw
     */
    ResetPartialLinenos(self);
#endif

#ifdef EXP_JUSTIFY_ELTS
    ht_justify_cleanup();
#endif
    return self;
}

/*			Creation Method 2
 *			---------------
 *
 *      Stream is assumed open and left open.
 */
HText *HText_new2(HTParentAnchor *anchor,
		  HTStream *stream)
{
    HText *result = HText_new(anchor);

    if (stream) {
	result->target = stream;
	result->targetClass = *stream->isa;	/* copy action procedures */
    }
    return result;
}

/*	Free Entire Text
 *	----------------
 */
void HText_free(HText *self)
{
    if (!self)
	return;

#if HTLINE_NOT_IN_POOL
    {
	HTLine *f = FirstHTLine(self);
	HTLine *l = self->last_line;

	while (l != f) {	/* Free off line array */
	    self->last_line = l->prev;
	    freeHTLine(self, l);
	    l = self->last_line;
	}
	freeHTLine(self, f);
    }
#endif

    while (self->first_anchor) {	/* Free off anchor array */
	TextAnchor *l = self->first_anchor;

	self->first_anchor = l->next;

	if (l->link_type == INPUT_ANCHOR && l->input_field) {
	    free_form_fields(l->input_field);
	}

	LYFreeHiText(l);
    }
    FormList_delete(self->forms);

    /*
     * Free the tabs list.  -FM
     */
    if (self->tabs) {
	HTTabID *Tab = NULL;
	HTList *cur = self->tabs;

	while (NULL != (Tab = (HTTabID *) HTList_nextObject(cur))) {
	    FREE(Tab->name);
	    FREE(Tab);
	}
	HTList_delete(self->tabs);
	self->tabs = NULL;
    }

    /*
     * Free the hidden links list.  -FM
     */
    if (self->hidden_links) {
	LYFreeStringList(self->hidden_links);
	self->hidden_links = NULL;
    }

    /*
     * Invoke HTAnchor_delete() to free the node_anchor
     * if it is not a destination of other links.  -FM
     */
    if (self->node_anchor) {
	HTAnchor_resetUCInfoStage(self->node_anchor, -1, UCT_STAGE_STRUCTURED,
				  UCT_SETBY_NONE);
	HTAnchor_resetUCInfoStage(self->node_anchor, -1, UCT_STAGE_HTEXT,
				  UCT_SETBY_NONE);
#ifdef USE_SOURCE_CACHE
	/* Remove source cache files and chunks always, even if the
	 * HTAnchor_delete call does not actually remove the anchor.
	 * Keeping them would just be a waste of space - they won't
	 * be used any more after the anchor has been disassociated
	 * from a HText structure. - kw
	 */
	HTAnchor_clearSourceCache(self->node_anchor);
#endif

	HTAnchor_delete_links(self->node_anchor);

	HTAnchor_setDocument(self->node_anchor, (HyperDoc *) 0);

	if (HTAnchor_delete(self->node_anchor->parent))
	    /*
	     * Make sure HTMainAnchor won't point
	     * to an invalid structure.  - KW
	     */
	    HTMainAnchor = NULL;
    }

    POOL_FREE(self->pool);
    FREE(self);
}

/*		Display Methods
 *		---------------
 */

/*	Output a line
 *	-------------
 */
static int display_line(HTLine *line, HText *text, int scrline GCC_UNUSED,
			const char *target GCC_UNUSED)
{
    register int i, j;
    char buffer[7];
    char *data;
    size_t utf_extra = 0;
    char LastDisplayChar = ' ';

#ifdef USE_COLOR_STYLE
    int current_style = 0;

#define inunderline NO
#define inbold NO
#else
    BOOL inbold = NO, inunderline = NO;
#endif
#if defined(SHOW_WHEREIS_TARGETS) && !defined(USE_COLOR_STYLE)
    const char *cp_tgt;
    int i_start_tgt = 0, i_after_tgt;
    int HitOffset, LenNeeded;
    BOOL intarget = NO;

#else
#define intarget NO
#endif /* SHOW_WHEREIS_TARGETS && !USE_COLOR_STYLE */

#if !(defined(NCURSES_VERSION) || defined(WIDEC_CURSES))
    text->has_utf8 = NO;	/* use as per-line flag, except with ncurses */
#endif

    /*
     * Set up the multibyte character buffer,
     * and clear the line to which we will be
     * writing.
     */
    buffer[0] = buffer[1] = buffer[2] = '\0';
    LYclrtoeol();

    /*
     * Add offset, making sure that we do not
     * go over the COLS limit on the display.
     */
    j = (int) line->offset;
    if (j >= DISPLAY_COLS)
	j = DISPLAY_COLS - 1;
#ifdef USE_SLANG
    SLsmg_forward(j);
    i = j;
#else
#ifdef USE_COLOR_STYLE
    if (line->size == 0)
	i = j;
    else
#endif
	for (i = 0; i < j; i++)
	    LYaddch(' ');
#endif /* USE_SLANG */

    /*
     * Add the data, making sure that we do not
     * go over the COLS limit on the display.
     */
    data = line->data;
    i++;

#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
    /*
     * If the target is on this line, it will be emphasized.
     */
    i_after_tgt = i;
    if (target) {
	cp_tgt = LYno_attr_mb_strstr(data,
				     target,
				     text->T.output_utf8, YES,
				     &HitOffset,
				     &LenNeeded);
	if (cp_tgt) {
	    if (((int) line->offset + LenNeeded) >= DISPLAY_COLS) {
		cp_tgt = NULL;
	    } else {
		text->page_has_target = YES;
		i_start_tgt = i + HitOffset;
		i_after_tgt = i + LenNeeded;
	    }
	}
    } else {
	cp_tgt = NULL;
    }
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */

    while ((i <= DISPLAY_COLS) && ((buffer[0] = *data) != '\0')) {

#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
	if (cp_tgt && i >= i_after_tgt) {
	    if (intarget) {
		cp_tgt = LYno_attr_mb_strstr(data,
					     target,
					     text->T.output_utf8, YES,
					     &HitOffset,
					     &LenNeeded);
		if (cp_tgt) {
		    i_start_tgt = i + HitOffset;
		    i_after_tgt = i + LenNeeded;
		}
		if (!cp_tgt || i_start_tgt != i) {
		    LYstopTargetEmphasis();
		    intarget = NO;
		    if (inbold)
			lynx_start_bold();
		    if (inunderline)
			lynx_start_underline();
		}
	    }
	}
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */

	data++;

#if defined(USE_COLOR_STYLE) || defined(SLSC)
#define CStyle line->styles[current_style]

	while (current_style < line->numstyles &&
	       i >= (int) (CStyle.horizpos + line->offset + 1)) {
	    LynxChangeStyle(CStyle.style, CStyle.direction);
	    current_style++;
	}
#endif
	switch (buffer[0]) {

#ifndef USE_COLOR_STYLE
	case LY_UNDERLINE_START_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		inunderline = YES;
		if (!intarget) {
#if defined(PDCURSES)
		    if (LYShowColor == SHOW_COLOR_NEVER)
			lynx_start_bold();
		    else
			lynx_start_underline();
#else
		    lynx_start_underline();
#endif /* PDCURSES */
		}
	    }
	    break;

	case LY_UNDERLINE_END_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		inunderline = NO;
		if (!intarget) {
#if defined(PDCURSES)
		    if (LYShowColor == SHOW_COLOR_NEVER)
			lynx_stop_bold();
		    else
			lynx_stop_underline();
#else
		    lynx_stop_underline();
#endif /* PDCURSES */
		}
	    }
	    break;

	case LY_BOLD_START_CHAR:
	    inbold = YES;
	    if (!intarget)
		lynx_start_bold();
	    break;

	case LY_BOLD_END_CHAR:
	    inbold = NO;
	    if (!intarget)
		lynx_stop_bold();
	    break;

#endif /* !USE_COLOR_STYLE */
	case LY_SOFT_NEWLINE:
	    if (!dump_output_immediately) {
		LYaddch('+');
		i++;
#if defined(SHOW_WHEREIS_TARGETS) && !defined(USE_COLOR_STYLE)
		i_after_tgt++;
#endif
	    }
	    break;

	case LY_SOFT_HYPHEN:
	    if (*data != '\0' ||
		isspace(UCH(LastDisplayChar)) ||
		LastDisplayChar == '-') {
		/*
		 * Ignore the soft hyphen if it is not the last
		 * character in the line.  Also ignore it if it
		 * first character following the margin, or if it
		 * is preceded by a white character (we loaded 'M'
		 * into LastDisplayChar if it was a multibyte
		 * character) or hyphen, though it should have
		 * been excluded by HText_appendCharacter() or by
		 * split_line() in those cases.  -FM
		 */
		break;
	    } else {
		/*
		 * Make it a hard hyphen and fall through.  -FM
		 */
		buffer[0] = '-';
	    }
	    /* FALLTHRU */

	default:
#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
	    if (!intarget && cp_tgt && i >= i_start_tgt) {
		/*
		 * Start the emphasis.
		 */
		if (data > cp_tgt) {
		    LYstartTargetEmphasis();
		    intarget = YES;
		}
	    }
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */
	    i++;
	    if (text->T.output_utf8 && is8bits(buffer[0])) {
		text->has_utf8 = YES;
		utf_extra = utf8_length(text->T.output_utf8, data - 1);
		LastDisplayChar = 'M';
	    }
	    if (utf_extra) {
		strncpy(&buffer[1], data, utf_extra);
		buffer[utf_extra + 1] = '\0';
		LYaddstr(buffer);
		buffer[1] = '\0';
		data += utf_extra;
		utf_extra = 0;
	    } else if (HTCJK != NOCJK && is8bits(buffer[0])
#ifndef CONV_JISX0201KANA_JISX0208KANA
		       && kanji_code != SJIS
#endif
		) {
		/*
		 * For CJK strings, by Masanobu Kimura.
		 */
		if (i < DISPLAY_COLS) {
		    buffer[1] = *data;
		    buffer[2] = '\0';
		    data++;
		    i++;
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		    /*
		     * For now, load 'M' into LastDisplayChar, but we should
		     * check whether it's white and if so, use ' '.  I don't
		     * know if there actually are white CJK characters, and
		     * we're loading ' ' for multibyte spacing characters in
		     * this code set, but this will become an issue when the
		     * development code set's multibyte character handling is
		     * used.  -FM
		     */
		    LastDisplayChar = 'M';
		}
	    } else {
		LYaddstr(buffer);
		LastDisplayChar = buffer[0];
	    }
	}			/* end of switch */
    }				/* end of while */

#if !(defined(NCURSES_VERSION) || defined(WIDEC_CURSES))
    if (text->has_utf8) {
	LYtouchline(scrline);
	text->has_utf8 = NO;	/* we had some, but have dealt with it. */
    }
#endif
    /*
     * Add the return.
     */
    LYaddch('\n');

#if defined(SHOW_WHEREIS_TARGETS) && !defined(USE_COLOR_STYLE)
    if (intarget)
	LYstopTargetEmphasis();
#else
#undef intarget
#endif /* SHOW_WHEREIS_TARGETS && !USE_COLOR_STYLE */
#ifndef USE_COLOR_STYLE
    lynx_stop_underline();
    lynx_stop_bold();
#else
    while (current_style < line->numstyles) {
	LynxChangeStyle(CStyle.style, CStyle.direction);
	current_style++;
    }
#undef CStyle
#endif
    return (0);
}

/*	Output the title line
 *	---------------------
 */
static void display_title(HText *text)
{
    char *title = NULL;
    char percent[20];
    unsigned char *tmp = NULL;
    int i = 0, j = 0, toolbar = 0;
    int limit;

    /*
     * Make sure we have a text structure.  -FM
     */
    if (!text)
	return;

    lynx_start_title_color();
#ifdef USE_COLOR_STYLE
/* turn the TITLE style on */
    if (last_colorattr_ptr > 0) {
	LynxChangeStyle(s_title, STACK_ON);
    } else {
	LynxChangeStyle(s_title, ABS_ON);
    }
#endif /* USE_COLOR_STYLE */

    /*
     * Load the title field.  -FM
     */
    StrAllocCopy(title,
		 (HTAnchor_title(text->node_anchor) ?
		  HTAnchor_title(text->node_anchor) : " "));	/* "" -> " " */
    LYReduceBlanks(title);

    /*
     * Generate the page indicator (percent) string.
     */
    limit = LYscreenWidth();
    if (limit < 10) {
	percent[0] = '\0';	/* Null string */
    } else if ((display_lines) <= 0 && LYlines > 0 &&
	       text->top_of_screen <= 99999 && text->Lines <= 999999) {
	sprintf(percent, " (l%d of %d)",
		text->top_of_screen, text->Lines);
    } else if ((text->Lines + 1) > (display_lines) &&
	       (display_lines) > 0) {
	/*
	 * In a small attempt to correct the number of pages counted....
	 * GAB 07-14-94
	 *
	 * In a bigger attempt (hope it holds up 8-)....
	 * FM 02-08-95
	 */
	int total_pages =
	(((text->Lines + 1) + (display_lines - 1)) / (display_lines));
	int start_of_last_page =
	((text->Lines + 1) < display_lines) ? 0 :
	((text->Lines + 1) - display_lines);

	sprintf(percent, " (p%d of %d)",
		((text->top_of_screen >= start_of_last_page) ?
		 total_pages :
		 ((text->top_of_screen + display_lines) / (display_lines))),
		total_pages);
    } else {
	percent[0] = '\0';	/* Null string */
    }

    /*
     * Generate and display the title string, with page indicator
     * if appropriate, preceded by the toolbar token if appropriate,
     * and truncated if necessary.  -FM & KW
     */
    if (HTCJK != NOCJK) {
	if (*title &&
	    (tmp = typecallocn(unsigned char, (strlen(title) + 256)))) {
	    if (kanji_code == EUC) {
		TO_EUC((unsigned char *) title, tmp);
	    } else if (kanji_code == SJIS) {
		TO_SJIS((unsigned char *) title, tmp);
	    } else {
		for (i = 0, j = 0; title[i]; i++) {
		    if (title[i] != CH_ESC) {	/* S/390 -- gil -- 1487 */
			tmp[j++] = title[i];
		    }
		}
		tmp[j] = '\0';
	    }
	    StrAllocCopy(title, (const char *) tmp);
	    FREE(tmp);
	}
    }
    LYmove(0, 0);
    LYclrtoeol();
#if defined(SH_EX) && defined(KANJI_CODE_OVERRIDE)
    LYaddstr(str_kcode(last_kcode));
#endif
    if (HText_hasToolbar(text)) {
	LYaddch('#');
	toolbar = 1;
    }
#ifdef USE_COLOR_STYLE
    if (s_forw_backw != NOSTYLE && (nhist || nhist_extra > 1)) {
	int c = nhist ? ACS_LARROW : ' ';

	/* turn the FORWBACKW.ARROW style on */
	LynxChangeStyle(s_forw_backw, STACK_ON);
	if (nhist) {
	    LYaddch(c);
	    LYaddch(c);
	    LYaddch(c);
	} else
	    LYmove(0, 3 + toolbar);
	if (nhist_extra > 1) {
	    LYaddch(ACS_RARROW);
	    LYaddch(ACS_RARROW);
	    LYaddch(ACS_RARROW);
	}
	LynxChangeStyle(s_forw_backw, STACK_OFF);
    }
#endif /* USE_COLOR_STYLE */
#ifdef WIDEC_CURSES
    i = limit - LYbarWidth - strlen(percent) - LYstrCells(title);
    if (i <= 0)
	i = 0;
    LYmove(0, i);
#else
    i = (limit - 1) - strlen(percent) - strlen(title);
    if (i >= CHAR_WIDTH) {
	LYmove(0, i);
    } else {
	/*
	 * Truncation takes into account the possibility that
	 * multibyte characters might be present.  -HS (H.  Senshu)
	 */
	int last;

	last = (int) strlen(percent) + CHAR_WIDTH;
	if (limit - 3 >= last) {
	    title[(limit - 3) - last] = '.';
	    title[(limit - 2) - last] = '.';
	    title[(limit - 1) - last] = '\0';
	} else {
	    title[(limit - 1) - last] = '\0';
	}
	LYmove(0, CHAR_WIDTH);
    }
#endif
    LYaddstr(title);
    if (percent[0] != '\0')
	LYaddstr(percent);
    LYaddch('\n');
    FREE(title);

#if defined(USE_COLOR_STYLE) && defined(CAN_CUT_AND_PASTE)
    if (s_hot_paste != NOSTYLE) {	/* Only if the user set the style */
	LYmove(0, LYcolLimit);
	LynxChangeStyle(s_hot_paste, STACK_ON);
	LYaddch(ACS_RARROW);
	LynxChangeStyle(s_hot_paste, STACK_OFF);
	LYmove(1, 0);		/* As after \n */
    }
#endif /* USE_COLOR_STYLE */

#ifdef USE_COLOR_STYLE
/* turn the TITLE style off */
    LynxChangeStyle(s_title, STACK_OFF);
#endif /* USE_COLOR_STYLE */
    lynx_stop_title_color();

    return;
}

/*	Output the scrollbar
 *	---------------------
 */
#ifdef USE_SCROLLBAR
static void display_scrollbar(HText *text)
{
    int i;
    int h = display_lines - 2 * (LYsb_arrow != 0);	/* Height of the scrollbar */
    int off = (LYsb_arrow != 0);	/* Start of the scrollbar */
    int top_skip, bot_skip, sh, shown;

    LYsb_begin = LYsb_end = -1;
    if (!LYShowScrollbar || !text || h <= 2
	|| (text->Lines + 1) <= display_lines)
	return;

    if (text->top_of_screen >= text->Lines + 1 - display_lines) {
	/* Only part of the screen shows actual text */
	shown = text->Lines + 1 - text->top_of_screen;

	if (shown <= 0)
	    shown = 1;
    } else
	shown = display_lines;
    /* Each cell of scrollbar represents text->Lines/h lines of text. */
    /* Always smaller than h */
    sh = (shown * h + text->Lines / 2) / (text->Lines + 1);
    if (sh <= 0)
	sh = 1;
    if (sh >= h - 1)
	sh = h - 2;		/* Position at ends indicates BEG and END */

    if (text->top_of_screen == 0)
	top_skip = 0;
    else if (text->Lines - (text->top_of_screen + display_lines - 1) <= 0)
	top_skip = h - sh;
    else {
	/* text->top_of_screen between 1 and text->Lines - display_lines
	   corresponds to top_skip between 1 and h - sh - 1 */
	/* Use rounding to get as many positions into top_skip==h - sh - 1
	   as into top_skip == 1:
	   1--->1, text->Lines - display_lines + 1--->h - sh. */
	top_skip = (int) (1 +
			  1. * (h - sh - 1) * text->top_of_screen
			  / (text->Lines - display_lines + 1));
    }
    bot_skip = h - sh - top_skip;

    LYsb_begin = top_skip;
    LYsb_end = h - bot_skip;

    if (LYsb_arrow) {
#ifdef USE_COLOR_STYLE
	int s = top_skip ? s_sb_aa : s_sb_naa;

	if (last_colorattr_ptr > 0) {
	    LynxChangeStyle(s, STACK_ON);
	} else {
	    LynxChangeStyle(s, ABS_ON);
	}
#endif /* USE_COLOR_STYLE */
	LYmove(1, LYcolLimit + LYshiftWin);
	addch_raw(ACS_UARROW);
#ifdef USE_COLOR_STYLE
	LynxChangeStyle(s, STACK_OFF);
#endif /* USE_COLOR_STYLE */
    }
#ifdef USE_COLOR_STYLE
    if (last_colorattr_ptr > 0) {
	LynxChangeStyle(s_sb_bg, STACK_ON);
    } else {
	LynxChangeStyle(s_sb_bg, ABS_ON);
    }
#endif /* USE_COLOR_STYLE */

    for (i = 1; i <= h; i++) {
#ifdef USE_COLOR_STYLE
	if (i - 1 <= top_skip && i > top_skip)
	    LynxChangeStyle(s_sb_bar, STACK_ON);
	if (i - 1 <= h - bot_skip && i > h - bot_skip)
	    LynxChangeStyle(s_sb_bar, STACK_OFF);
#endif /* USE_COLOR_STYLE */
	LYmove(i + off, LYcolLimit + LYshiftWin);
	if (i > top_skip && i <= h - bot_skip) {
	    LYaddch(ACS_BLOCK);
	} else {
	    LYaddch(ACS_CKBOARD);
	}
    }
#ifdef USE_COLOR_STYLE
    LynxChangeStyle(s_sb_bg, STACK_OFF);
#endif /* USE_COLOR_STYLE */

    if (LYsb_arrow) {
#ifdef USE_COLOR_STYLE
	int s = bot_skip ? s_sb_aa : s_sb_naa;

	if (last_colorattr_ptr > 0) {
	    LynxChangeStyle(s, STACK_ON);
	} else {
	    LynxChangeStyle(s, ABS_ON);
	}
#endif /* USE_COLOR_STYLE */
	LYmove(h + 2, LYcolLimit + LYshiftWin);
	addch_raw(ACS_DARROW);
#ifdef USE_COLOR_STYLE
	LynxChangeStyle(s, STACK_OFF);
#endif /* USE_COLOR_STYLE */
    }
    return;
}
#else
#define display_scrollbar(text)	/*nothing */
#endif /* USE_SCROLLBAR */

/*	Output a page
 *	-------------
 */
static void display_page(HText *text, int line_number,
			 const char *target)
{
    HTLine *line = NULL;
    int i;

#if defined(USE_COLOR_STYLE) && defined(SHOW_WHEREIS_TARGETS)
    const char *cp;
#endif
    char tmp[7];
    int last_screen;
    TextAnchor *Anchor_ptr = NULL;
    int stop_before_for_anchors;
    FormInfo *FormInfo_ptr;
    BOOL display_flag = FALSE;
    HTAnchor *link_dest;
    HTAnchor *link_dest_intl = NULL;
    static int last_nlinks = 0;
    static int charset_last_displayed = -1;

#ifdef DISP_PARTIAL
    int last_disp_partial = -1;
#endif

    lynx_mode = NORMAL_LYNX_MODE;

    if (text == NULL) {
	/*
	 * Check whether to force a screen clear to enable scrollback,
	 * or as a hack to fix a reverse clear screen problem for some
	 * curses packages.  - shf@@access.digex.net & seldon@@eskimo.com
	 */
	if (enable_scrollback) {
	    LYaddch('*');
	    LYrefresh();
	    LYclear();
	}
	LYaddstr("\n\nError accessing document!\nNo data available!\n");
	LYrefresh();
	nlinks = 0;		/* set number of links to 0 */
	return;
    }
#ifdef DISP_PARTIAL
    if (display_partial || recent_sizechange || text->stale) {
	/*  Reset them, will be set near end if all is okay. - kw */
	ResetPartialLinenos(text);
    }
#endif /* DISP_PARTIAL */

    tmp[0] = tmp[1] = tmp[2] = '\0';
    if (target && *target == '\0')
	target = NULL;
    text->page_has_target = NO;
    if (display_lines <= 0) {
	/* No screen space to display anything!
	 * returning here makes it more likely we will survive if
	 * an xterm is temporarily made very small.  - kw */
	return;
    }

    last_screen = text->Lines - (display_lines - 2);
    line = text->last_line->prev;

    /*
     * Constrain the line number to be within the document.
     */
    if (text->Lines < (display_lines))
	line_number = 0;
    else if (line_number > text->Lines)
	line_number = last_screen;
    else if (line_number < 0)
	line_number = 0;

    for (i = 0, line = FirstHTLine(text);	/* Find line */
	 i < line_number && (line != text->last_line);
	 i++, line = line->next) {	/* Loop */
#ifndef VMS
	if (!LYNoCore) {
	    assert(line->next != NULL);
	} else if (line->next == NULL) {
	    if (enable_scrollback) {
		LYaddch('*');
		LYrefresh();
		LYclear();
	    }
	    LYaddstr("\n\nError drawing page!\nBad HText structure!\n");
	    LYrefresh();
	    nlinks = 0;		/* set number of links to 0 */
	    return;
	}
#else
	assert(line->next != NULL);
#endif /* !VMS */
    }				/* Loop */

    if (LYlowest_eightbit[current_char_set] <= 255 &&
	(current_char_set != charset_last_displayed) &&
    /*
     * current_char_set has changed since last invocation,
     * and it's not just 7-bit.
     * Also we don't want to do this for -dump and -source etc.
     */
	LYCursesON) {
#ifdef EXP_CHARTRANS_AUTOSWITCH
	/*
	 * Currently implemented only for LINUX
	 */
	UCChangeTerminalCodepage(current_char_set,
				 &LYCharSet_UC[current_char_set]);
#endif /* EXP_CHARTRANS_AUTOSWITCH */
	charset_last_displayed = current_char_set;
    }

    /*
     * Check whether to force a screen clear to enable scrollback,
     * or as a hack to fix a reverse clear screen problem for some
     * curses packages.  - shf@@access.digex.net & seldon@@eskimo.com
     */
    if (enable_scrollback) {
	LYaddch('*');
	LYrefresh();
	LYclear();
    }
#ifdef USE_COLOR_STYLE
    /*
     * Reset stack of color attribute changes to avoid color leaking,
     * except if what we last displayed from this text was the previous
     * screenful, in which case carrying over the state might be beneficial
     * (although it shouldn't generally be needed any more).  - kw
     */
    if (text->stale ||
	line_number != text->top_of_screen + (display_lines)) {
	last_colorattr_ptr = 0;
    }
#endif

    text->top_of_screen = line_number;
    text->top_of_screen_line = line;
    display_title(text);	/* will move cursor to top of screen */
    display_flag = TRUE;

#ifdef USE_COLOR_STYLE
#ifdef DISP_PARTIAL
    if (display_partial ||
	line_number != text->first_lineno_last_disp_partial ||
	line_number > text->last_lineno_last_disp_partial)
#endif /* DISP_PARTIAL */
	LynxResetScreenCache();
#endif /* USE_COLOR_STYLE */

#ifdef DISP_PARTIAL
    if (display_partial && text->stbl) {
	stop_before_for_anchors = Stbl_getStartLineDeep(text->stbl);
	if (stop_before_for_anchors > line_number + (display_lines))
	    stop_before_for_anchors = line_number + (display_lines);
    } else
#endif
	stop_before_for_anchors = line_number + (display_lines);

    /*
     * Output the page.
     */
    if (line) {
#if defined(USE_COLOR_STYLE) && defined(SHOW_WHEREIS_TARGETS)
	char *data;
	int offset, LenNeeded;
#endif
#ifdef DISP_PARTIAL
	if (display_partial ||
	    line_number != text->first_lineno_last_disp_partial)
	    text->has_utf8 = NO;
#else
	text->has_utf8 = NO;
#endif
	for (i = 0; i < (display_lines); i++) {
	    /*
	     * Verify and display each line.
	     */
#ifndef VMS
	    if (!LYNoCore) {
		assert(line != NULL);
	    } else if (line == NULL) {
		if (enable_scrollback) {
		    LYaddch('*');
		    LYrefresh();
		    LYclear();
		}
		LYaddstr("\n\nError drawing page!\nBad HText structure!\n");
		LYrefresh();
		nlinks = 0;	/* set number of links to 0 */
		return;
	    }
#else
	    assert(line != NULL);
#endif /* !VMS */

#ifdef DISP_PARTIAL
	    if (!display_partial &&
		line_number == text->first_lineno_last_disp_partial &&
		i + line_number <= text->last_lineno_last_disp_partial)
		LYmove((i + 2), 0);
	    else
#endif
		display_line(line, text, i + 1, target);

#if defined(SHOW_WHEREIS_TARGETS)
#ifdef USE_COLOR_STYLE		/* otherwise done in display_line - kw */
	    /*
	     * If the target is on this line, recursively
	     * seek and emphasize it.  -FM
	     */
	    data = (char *) line->data;
	    offset = (int) line->offset;
	    while (non_empty(target) &&
		   (cp = LYno_attr_mb_strstr(data,
					     target,
					     text->T.output_utf8, YES,
					     NULL,
					     &LenNeeded)) != NULL &&
		   ((int) line->offset + LenNeeded) <= DISPLAY_COLS) {
		int itmp = 0;
		int written = 0;
		int x_pos = offset + (int) (cp - data);
		int len = strlen(target);
		size_t utf_extra = 0;
		int y;

		text->page_has_target = YES;

		/*
		 * Start the emphasis.
		 */
		LYstartTargetEmphasis();

		/*
		 * Output the target characters.
		 */
		for (;
		     written < len && (tmp[0] = data[itmp]) != '\0';
		     itmp++) {
		    if (IsSpecialAttrChar(tmp[0]) && tmp[0] != LY_SOFT_NEWLINE) {
			/*
			 * Ignore special characters.
			 */
			x_pos--;

		    } else if (&data[itmp] >= cp) {
			if (cp == &data[itmp]) {
			    /*
			     * First printable character of target.
			     */
			    LYmove((i + 1), x_pos);
			}
			/*
			 * Output all the printable target chars.
			 */
			utf_extra = utf8_length(text->T.output_utf8, data + itmp);
			if (utf_extra) {
			    strncpy(&tmp[1], &line->data[itmp + 1], utf_extra);
			    tmp[utf_extra + 1] = '\0';
			    itmp += utf_extra;
			    LYaddstr(tmp);
			    tmp[1] = '\0';
			    written += (utf_extra + 1);
			    utf_extra = 0;
			} else if (HTCJK != NOCJK && is8bits(tmp[0])) {
			    /*
			     * For CJK strings, by Masanobu Kimura.
			     */
			    tmp[1] = data[++itmp];
			    LYaddstr(tmp);
			    tmp[1] = '\0';
			    written += 2;
			} else {
			    LYaddstr(tmp);
			    written++;
			}
		    }
		}

		/*
		 * Stop the emphasis, and reset the offset and
		 * data pointer for our current position in the
		 * line.  -FM
		 */
		LYstopTargetEmphasis();
		LYGetYX(y, offset);
		data = (char *) &data[itmp];

		/*
		 * Adjust the cursor position, should we be at
		 * the end of the line, or not have another hit
		 * in it.  -FM
		 */
		LYmove((i + 2), 0);
	    }			/* end while */
#endif /* USE_COLOR_STYLE */
#endif /* SHOW_WHEREIS_TARGETS */

	    /*
	     * Stop if this is the last line.  Otherwise, make sure
	     * display_flag is set and process the next line.  -FM
	     */
	    if (line == text->last_line) {
		/*
		 * Clear remaining lines of display.
		 */
		for (i++; i < (display_lines); i++) {
		    LYmove((i + 1), 0);
		    LYclrtoeol();
		}
		break;
	    }
#ifdef DISP_PARTIAL
	    if (display_partial) {
		/*
		 * Remember as fully shown during last partial display,
		 * if it was not the last text line.  - kw
		 */
		last_disp_partial = i + line_number;
	    }
#endif /* DISP_PARTIAL */
	    display_flag = TRUE;
	    line = line->next;
	}			/* end of "Verify and display each line." loop */
    }
    /* end "Output the page." */
    text->next_line = line;	/* Line after screen */
    text->stale = NO;		/* Display is up-to-date */

    /*
     * Add the anchors to Lynx structures.
     */
    nlinks = 0;
    for (Anchor_ptr = text->first_anchor;
	 Anchor_ptr != NULL && Anchor_ptr->line_num <= stop_before_for_anchors;
	 Anchor_ptr = Anchor_ptr->next) {

	if (Anchor_ptr->line_num >= line_number
	    && Anchor_ptr->line_num < stop_before_for_anchors) {
	    char *hi_string = LYGetHiTextStr(Anchor_ptr, 0);

	    /*
	     * Load normal hypertext anchors.
	     */
	    if (Anchor_ptr->show_anchor
		&& non_empty(hi_string)
		&& (Anchor_ptr->link_type & HYPERTEXT_ANCHOR)) {
		int count;
		char *s;

		for (count = 0;; ++count) {
		    s = LYGetHiTextStr(Anchor_ptr, count);
		    if (count == 0)
			LYSetHilite(nlinks, s);
		    if (s == NULL)
			break;
		    if (count != 0) {
			LYAddHilite(nlinks, s, LYGetHiTextPos(Anchor_ptr, count));
		    }
		}

		links[nlinks].inUnderline = Anchor_ptr->inUnderline;

		links[nlinks].anchor_number = Anchor_ptr->number;
		links[nlinks].anchor_line_num = Anchor_ptr->line_num;

		link_dest = HTAnchor_followLink(Anchor_ptr->anchor);
		{
		    /*
		     * Memory leak fixed 05-27-94
		     * Garrett Arch Blythe
		     */
		    auto char *cp_AnchorAddress = NULL;

		    if (traversal)
			cp_AnchorAddress = stub_HTAnchor_address(link_dest);
		    else {
#ifndef DONT_TRACK_INTERNAL_LINKS
			if (Anchor_ptr->link_type == INTERNAL_LINK_ANCHOR) {
			    link_dest_intl = HTAnchor_followTypedLink(
									 Anchor_ptr->anchor, HTInternalLink);
			    if (link_dest_intl && link_dest_intl != link_dest) {

				CTRACE((tfp,
					"GridText: display_page: unexpected typed link to %s!\n",
					link_dest_intl->parent->address));
				link_dest_intl = NULL;
			    }
			} else
			    link_dest_intl = NULL;
			if (link_dest_intl) {
			    char *cp2 = HTAnchor_address(link_dest_intl);

			    cp_AnchorAddress = cp2;
			} else
#endif
			    cp_AnchorAddress = HTAnchor_address(link_dest);
		    }
		    FREE(links[nlinks].lname);

		    if (cp_AnchorAddress != NULL)
			links[nlinks].lname = cp_AnchorAddress;
		    else
			StrAllocCopy(links[nlinks].lname, empty_string);
		}

		links[nlinks].lx = Anchor_ptr->line_pos;
		links[nlinks].ly = ((Anchor_ptr->line_num + 1) - line_number);
		if (link_dest_intl)
		    links[nlinks].type = WWW_INTERN_LINK_TYPE;
		else
		    links[nlinks].type = WWW_LINK_TYPE;
		links[nlinks].target = empty_string;
		links[nlinks].l_form = NULL;

		nlinks++;
		display_flag = TRUE;

	    } else if (Anchor_ptr->link_type == INPUT_ANCHOR
		       && Anchor_ptr->input_field->type != F_HIDDEN_TYPE) {
		/*
		 * Handle form fields.
		 */
		lynx_mode = FORMS_LYNX_MODE;

		FormInfo_ptr = Anchor_ptr->input_field;

		links[nlinks].anchor_number = Anchor_ptr->number;
		links[nlinks].anchor_line_num = Anchor_ptr->line_num;

		links[nlinks].l_form = FormInfo_ptr;
		links[nlinks].lx = Anchor_ptr->line_pos;
		links[nlinks].ly = ((Anchor_ptr->line_num + 1) - line_number);
		links[nlinks].type = WWW_FORM_LINK_TYPE;
		links[nlinks].inUnderline = Anchor_ptr->inUnderline;
		links[nlinks].target = empty_string;
		StrAllocCopy(links[nlinks].lname, empty_string);

		if (FormInfo_ptr->type == F_RADIO_TYPE) {
		    LYSetHilite(nlinks,
				FormInfo_ptr->num_value
				? checked_radio
				: unchecked_radio);
		} else if (FormInfo_ptr->type == F_CHECKBOX_TYPE) {
		    LYSetHilite(nlinks,
				FormInfo_ptr->num_value
				? checked_box
				: unchecked_box);
		} else if (FormInfo_ptr->type == F_PASSWORD_TYPE) {
		    /* FIXME: use LYstrExtent, not strlen */
		    LYSetHilite(nlinks,
				STARS(strlen(FormInfo_ptr->value)));
		} else {	/* TEXT type */
		    LYSetHilite(nlinks,
				FormInfo_ptr->value);
		}

		nlinks++;
		/*
		 * Bold the link after incrementing nlinks.
		 */
		LYhighlight(OFF, (nlinks - 1), target);

		display_flag = TRUE;

	    } else {
		/*
		 * Not showing anchor.
		 */
		if (non_empty(hi_string))
		    CTRACE((tfp,
			    "\nGridText: Not showing link, hightext=%s\n",
			    hi_string));
	    }
	}

	if (nlinks == MAXLINKS) {
	    /*
	     * Links array is full.  If interactive, tell user
	     * to use half-page or two-line scrolling.  -FM
	     */
	    if (LYCursesON) {
		HTAlert(MAXLINKS_REACHED);
	    }
	    CTRACE((tfp, "\ndisplay_page: MAXLINKS reached.\n"));
	    break;
	}
    }				/* end of loop "Add the anchors to Lynx structures." */

    /*
     * Free any un-reallocated links[] entries
     * from the previous page draw.  -FM
     */
    LYFreeHilites(nlinks, last_nlinks);
    last_nlinks = nlinks;

    /*
     * If Anchor_ptr is not NULL and is not pointing to the last
     * anchor, then there are anchors farther down in the document,
     * and we need to flag this for traversals.
     */
    more_links = FALSE;
    if (traversal && Anchor_ptr) {
	if (Anchor_ptr->next)
	    more_links = TRUE;
    }

    if (!display_flag) {
	/*
	 * Nothing on the page.
	 */
	LYaddstr("\n     Document is empty");
    }
    display_scrollbar(text);

#ifdef DISP_PARTIAL
    if (display_partial && display_flag &&
	last_disp_partial >= text->top_of_screen &&
	!enable_scrollback &&
	!recent_sizechange) {	/*  really remember them if ok - kw  */
	text->first_lineno_last_disp_partial = text->top_of_screen;
	text->last_lineno_last_disp_partial = last_disp_partial;
    } else {
	ResetPartialLinenos(text);
    }
#endif /* DISP_PARTIAL */

#if !defined(WIDEC_CURSES)
    if (text->has_utf8 || text->had_utf8) {
	/*
	 * For other than ncurses, repainting is taken care of
	 * by touching lines in display_line and highlight.  - kw 1999-10-07
	 */
	text->had_utf8 = text->has_utf8;
	clearok(curscr, TRUE);
    } else if (HTCJK != NOCJK) {
	/*
	 * For non-multibyte curses.
	 *
	 * Full repainting is necessary, otherwise only part of a multibyte
	 * character sequence might be written because of curses output
	 * optimizations.
	 */
	clearok(curscr, TRUE);
    }
#endif /* WIDEC_CURSES */

    LYrefresh();
    return;
}

/*			Object Building methods
 *			-----------------------
 *
 *	These are used by a parser to build the text in an object
 */
void HText_beginAppend(HText *text)
{
    text->permissible_split = 0;
    text->in_line_1 = YES;

}

/* LYcols_cu is the notion that the display library has of the screen
   width.  Normally it is the same as LYcols, but there may be a
   difference via SLANG_MBCS_HACK.  Checks of the line length (as the
   non-UTF-8-aware display library would see it) against LYcols_cu are
   is used to try to prevent that lines with UTF-8 chars get wrapped
   by the library when they shouldn't.
   If there is no display library involved, i.e. dump_output_immediately,
   no such limit should be imposed.  MAX_COLS should be just as good
   as any other large value.  (But don't use INT_MAX or something close
   to it to, avoid over/underflow.) - kw */
#ifdef USE_SLANG
#define LYcols_cu(text) (dump_output_immediately ? MAX_COLS : SLtt_Screen_Cols)
#else
#ifdef WIDEC_CURSES
#define LYcols_cu(text) WRAP_COLS(text)
#else
#define LYcols_cu(text) (dump_output_immediately ? MAX_COLS : DISPLAY_COLS)
#endif
#endif

/*	Add a new line of text
 *	----------------------
 *
 * On entry,
 *
 *	split	is zero for newline function, else number of characters
 *		before split.
 *	text->display_on_the_fly
 *		may be set to indicate direct output of the finished line.
 * On exit,
 *		A new line has been made, justified according to the
 *		current style.  Text after the split (if split nonzero)
 *		is taken over onto the next line.
 *
 *		If display_on_the_fly is set, then it is decremented and
 *		the finished line is displayed.
 */
#define new_line(text) split_line(text, 0)

#define DEBUG_SPLITLINE

#ifdef DEBUG_SPLITLINE
#define CTRACE_SPLITLINE(p)	CTRACE(p)
#else
#define CTRACE_SPLITLINE(p)	/*nothing */
#endif

static int set_style_by_embedded_chars(char *s,
				       char *e,
				       unsigned char start_c,
				       unsigned char end_c)
{
    int ret = NO;

    while (--e >= s) {
	if (*e == end_c)
	    break;
	if (*e == start_c) {
	    ret = YES;
	    break;
	}
    }
    return ret;
}

static void move_anchors_in_region(HTLine *line, int line_number,
				   TextAnchor **prev_anchor,	/*updates++ */
				   int *prev_head_processed,
				   int sbyte,
				   int ebyte,
				   int shift)	/* Likewise */
{
    /*
     * Update anchor positions for anchors that start on this line.  Note:  we
     * rely on a->line_pos counting bytes, not characters.  That's one reason
     * why HText_trimHightext has to be prevented from acting on these anchors
     * in partial display mode before we get a chance to deal with them here.
     */
    TextAnchor *a;
    int head_processed = *prev_head_processed;

    /*
     * We need to know whether (*prev_anchor)->line_pos is "in new coordinates"
     * or in old ones.  If prev_anchor' head was touched on the previous
     * iteration, we set head_processed.  The tail may need to be treated now.
     */
    for (a = *prev_anchor;
	 a && a->line_num <= line_number;
	 a = a->next, head_processed = 0) {
	/* extent==0 needs to be special-cased; happens if no text for
	   the anchor was processed yet.  */
	/* Subtract one so that the space is not inserted at the end
	   of the anchor... */
	int last = a->line_pos + (a->extent ? a->extent - 1 : 0);

	/* Include the anchors started on the previous line */
	if (a->line_num < line_number - 1)
	    continue;
	if (a->line_num == line_number - 1)
	    last -= line->prev->size + 1;	/* Fake "\n" "between" lines counted too */
	if (last < sbyte)	/* Completely before the start */
	    continue;

	if (!head_processed	/* a->line_pos is not edited yet */
	    && a->line_num == line_number
	    && a->line_pos >= ebyte)	/* Completely after the end */
	    break;
	/* Now we know that the anchor context intersects the chunk */

	/* Fix the start */
	if (!head_processed && a->line_num == line_number
	    && a->line_pos >= sbyte) {
	    a->line_pos += shift;
	    a->extent -= shift;
	    head_processed = 1;
	}
	/* Fix the end */
	if (last < ebyte)
	    a->extent += shift;
	else
	    break;		/* Keep this `a' for the next step */
    }
    *prev_anchor = a;
    *prev_head_processed = head_processed;
}

/*
 * Given a line and two int arrays of old/now position, this function
 * creates a new line where spaces have been inserted/removed
 * in appropriate places - so that characters at/after the old
 * position end up at/after the new position, for each pair, if possible.
 * Some necessary changes for anchors starting on this line are also done
 * here if needed.  Updates 'prev_anchor' internally.
 * Returns a newly allocated HTLine* if changes were made
 * (caller has to free the old one).
 * Returns NULL if no changes needed.  (Remove-spaces code may be buggy...)
 * - kw
 */
static HTLine *insert_blanks_in_line(HTLine *line, int line_number,
				     HText *text,
				     TextAnchor **prev_anchor,	/*updates++ */
				     int ninserts,
				     int *oldpos,	/* Measured in cells */
				     int *newpos)	/* Likewise */
{
    int ioldc = 0;		/* count visible characters */
    int ip;			/* count insertion pairs */

#if defined(USE_COLOR_STYLE)
    int istyle = 0;
#endif
    int added_chars = 0;
    int shift = 0;
    int head_processed;
    HTLine *mod_line;
    char *newdata;
    char *s = line->data;
    char *pre = s;
    char *copied = line->data, *t;

    if (!(line && line->size && ninserts))
	return NULL;
    for (ip = 0; ip < ninserts; ip++)
	if (newpos[ip] > oldpos[ip] &&
	    (newpos[ip] - oldpos[ip]) > added_chars)
	    added_chars = newpos[ip] - oldpos[ip];
    if (line->size + added_chars > MAX_LINE - 2)
	return NULL;
    if (line == text->last_line) {
	if (line == TEMP_LINE(text, 0))
	    mod_line = TEMP_LINE(text, 1);
	else
	    mod_line = TEMP_LINE(text, 0);
    } else {
	allocHTLine(mod_line, line->size + added_chars);
    }
    if (!mod_line)
	return NULL;
    if (!*prev_anchor)
	*prev_anchor = text->first_anchor;
    head_processed = (*prev_anchor && (*prev_anchor)->line_num < line_number);
    memcpy(mod_line, line, LINE_SIZE(0));
    t = newdata = mod_line->data;
    ip = 0;
    while (ip <= ninserts) {
	/* line->size is in bytes, so it may be larger than needed... */
	int curlim = (ip < ninserts
		      ? oldpos[ip]
	/* Include'em all! */
		      : ((int) line->size <= MAX_LINE
			 ? MAX_LINE + 1
			 : (int) line->size + 1));

	pre = s;

	/* Fast forward to char==curlim or EOL.  Stop *before* the
	   style-change chars. */
	while (*s) {
	    if (text && text->T.output_utf8
		&& UCH(*s) >= 0x80 && UCH(*s) < 0xC0) {
		pre = s + 1;
	    } else if (!IsSpecialAttrChar(*s)) {	/* At a "displayed" char */
		if (ioldc >= curlim)
		    break;
		ioldc++;
		pre = s + 1;
	    }
	    s++;
	}

	/* Now s is at the "displayed" char, pre is before the style change */
	if (ip)			/* Fix anchor positions */
	    move_anchors_in_region(line, line_number, prev_anchor /*updates++ */ ,
				   &head_processed,
				   copied - line->data, pre - line->data,
				   shift);
#if defined(USE_COLOR_STYLE)	/* Move styles too */
#define NStyle mod_line->styles[istyle]
	for (;
	     istyle < line->numstyles && (int) NStyle.horizpos < curlim;
	     istyle++)
	    /* Should not we include OFF-styles at curlim? */
	    NStyle.horizpos += shift;
#endif
	while (copied < pre)	/* Copy verbatim to byte == pre */
	    *t++ = *copied++;
	if (ip < ninserts) {	/* Insert spaces */
	    int delta = newpos[ip] - oldpos[ip] - shift;

	    if (delta < 0) {	/* Not used yet? */
		while (delta++ < 0 && t > newdata && t[-1] == ' ')
		    t--, shift--;
	    } else
		shift = newpos[ip] - oldpos[ip];
	    while (delta-- > 0)
		*t++ = ' ';
	}
	ip++;
    }
    while (pre < s)		/* Copy remaining style-codes */
	*t++ = *pre++;
    /* Check whether the last anchor continues on the next line */
    if (head_processed && *prev_anchor && (*prev_anchor)->line_num == line_number)
	(*prev_anchor)->extent += shift;
    *t = '\0';
    mod_line->size = t - newdata;
    return mod_line;
}

#if defined(USE_COLOR_STYLE)
static HTStyleChange *skip_matched_and_correct_offsets(HTStyleChange *end,
						       HTStyleChange *start,
						       unsigned split_pos)
{				/* Found an OFF change not part of an adjacent matched pair.
				 * Walk backward looking for the corresponding ON change.
				 * Move everything after split_pos to be at split_pos.
				 * This can only work correctly if all changes are correctly
				 * nested!  If this fails, assume it is safer to leave whatever
				 * comes before the OFF on the previous line alone. */
    int level = 0;
    HTStyleChange *tmp = end;

    for (; tmp >= start; tmp--) {
	if (tmp->style == end->style) {
	    if (tmp->direction == STACK_OFF)
		level--;
	    else if (tmp->direction == STACK_ON) {
		if (++level == 0)
		    return tmp;
	    } else
		return 0;
	}
	if (tmp->horizpos > split_pos)
	    tmp->horizpos = split_pos;
    }
    return 0;
}
#endif /* USE_COLOR_STYLE */

static void split_line(HText *text, unsigned split)
{
    HTStyle *style = text->style;
    int spare;
    int indent = (text->in_line_1
		  ? text->style->indent1st
		  : text->style->leftIndent);
    short alignment;
    TextAnchor *a;
    int CurLine = text->Lines;
    int HeadTrim = 0;
    int SpecialAttrChars = 0;
    int TailTrim = 0;
    int s, s_post, s_pre, t_underline = underline_on, t_bold = bold_on;
    char *p;
    char *cp;
    int ctrl_chars_on_previous_line = 0;

#ifndef WIDEC_CURSES
    int utfxtra_on_previous_line = UTFXTRA_ON_THIS_LINE;
#endif

    HTLine *previous = text->last_line;
    HTLine *line;

    /*
     * Set new line.
     */
    if (previous == TEMP_LINE(text, 0))
	line = TEMP_LINE(text, 1);
    else
	line = TEMP_LINE(text, 0);
    if (line == NULL)
	return;
    memset(line, 0, LINE_SIZE(0));

    ctrl_chars_on_this_line = 0;	/*reset since we are going to a new line */
    utfxtra_on_this_line = 0;	/*reset too, we'll count them */
    text->LastChar = ' ';

#ifdef DEBUG_APPCH
    CTRACE((tfp, "GridText: split_line(%p,%d) called\n", text, split));
    CTRACE((tfp, "   bold_on=%d, underline_on=%d\n", bold_on, underline_on));
#endif

    cp = previous->data;
    /* Float LY_SOFT_NEWLINE to the start */
    if (cp[0] == LY_BOLD_START_CHAR
	|| cp[0] == LY_UNDERLINE_START_CHAR) {
	switch (cp[1]) {
	case LY_SOFT_NEWLINE:
	    cp[1] = cp[0];
	    cp[0] = LY_SOFT_NEWLINE;
	    break;
	case LY_BOLD_START_CHAR:
	case LY_UNDERLINE_START_CHAR:
	    if (cp[2] == LY_SOFT_NEWLINE) {
		cp[2] = cp[1];
		cp[1] = cp[0];
		cp[0] = LY_SOFT_NEWLINE;
	    }
	    break;
	}
    }
    if (split > previous->size) {
	CTRACE((tfp,
		"*** split_line: split==%d greater than last_line->size==%d !\n",
		split, previous->size));
	if (split > MAX_LINE) {
	    split = previous->size;
	    if ((cp = strrchr(previous->data, ' ')) &&
		cp - previous->data > 1)
		split = cp - previous->data;
	    CTRACE((tfp, "                split adjusted to %d.\n", split));
	}
    }

    text->Lines++;

    previous->next->prev = line;
    line->prev = previous;
    line->next = previous->next;
    previous->next = line;
    text->last_line = line;
    line->size = 0;
    line->offset = 0;
    text->permissible_split = 0;	/* 12/13/93 */
    line->data[0] = '\0';

    alignment = style->alignment;

    if (split > 0) {		/* Restore flags to the value at the splitting point */
	if (!(dump_output_immediately && use_underscore))
	    t_underline = set_style_by_embedded_chars(previous->data,
						      previous->data + split,
						      LY_UNDERLINE_START_CHAR, LY_UNDERLINE_END_CHAR);

	t_bold = set_style_by_embedded_chars(previous->data,
					     previous->data + split,
					     LY_BOLD_START_CHAR, LY_BOLD_END_CHAR);

    }

    if (!(dump_output_immediately && use_underscore) && t_underline) {
	line->data[line->size++] = LY_UNDERLINE_START_CHAR;
	line->data[line->size] = '\0';
	ctrl_chars_on_this_line++;
	SpecialAttrChars++;
    }
    if (t_bold) {
	line->data[line->size++] = LY_BOLD_START_CHAR;
	line->data[line->size] = '\0';
	ctrl_chars_on_this_line++;
	SpecialAttrChars++;
    }

    /*
     * Split at required point
     */
    if (split > 0) {		/* Delete space at "split" splitting line */
	char *prevdata = previous->data, *linedata = line->data;
	unsigned plen;
	int i;

	/* Split the line. -FM */
	prevdata[previous->size] = '\0';
	previous->size = split;

	/*
	 * Trim any spaces or soft hyphens from the beginning
	 * of our new line.  -FM
	 */
	p = prevdata + split;
	while (((*p == ' '
#ifdef EXP_JUSTIFY_ELTS
	/* if justification is allowed for prev line, then raw
	 * HT_NON_BREAK_SPACE are still present in data[] (they'll be
	 * substituted at the end of this function with ' ') - VH
	 */
		 || *p == HT_NON_BREAK_SPACE
#endif
		)
		&& (HeadTrim || text->first_anchor ||
		    underline_on || bold_on ||
		    alignment != HT_LEFT ||
		    style->wordWrap || style->freeFormat ||
		    style->spaceBefore || style->spaceAfter)) ||
	       *p == LY_SOFT_HYPHEN) {
	    p++;
	    HeadTrim++;
	}

	plen = strlen(p);
	if (plen) {		/* Count funny characters */
	    for (i = (plen - 1); i >= 0; i--) {
		if (p[i] == LY_UNDERLINE_START_CHAR ||
		    p[i] == LY_UNDERLINE_END_CHAR ||
		    p[i] == LY_BOLD_START_CHAR ||
		    p[i] == LY_BOLD_END_CHAR ||
		    p[i] == LY_SOFT_HYPHEN) {
		    ctrl_chars_on_this_line++;
		} else if (IS_UTF_EXTRA(p[i])) {
		    utfxtra_on_this_line++;
		}
		if (p[i] == LY_SOFT_HYPHEN && (int) text->permissible_split < i)
		    text->permissible_split = i + 1;
	    }
	    ctrl_chars_on_this_line += utfxtra_on_this_line;

	    /* Add the data to the new line. -FM */
	    strcat(linedata, p);
	    line->size += plen;
	}
    }

    /*
     * Economize on space.
     */
    p = previous->data + previous->size - 1;
    while (p >= previous->data
	   && (*p == ' '
#ifdef EXP_JUSTIFY_ELTS
    /* if justification is allowed for prev line, then raw
     * HT_NON_BREAK_SPACE are still present in data[] (they'll be
     * substituted at the end of this function with ' ') - VH
     */
	       || *p == HT_NON_BREAK_SPACE
#endif
	   )
#ifdef USE_PRETTYSRC
	   && !psrc_view	/*don't strip trailing whites - since next line can
				   start with LY_SOFT_NEWLINE - so we don't lose spaces when
				   'p'rinting this text to file -VH */
#endif
	   && (ctrl_chars_on_this_line || HeadTrim || text->first_anchor ||
	       underline_on || bold_on ||
	       alignment != HT_LEFT ||
	       style->wordWrap || style->freeFormat ||
	       style->spaceBefore || style->spaceAfter)) {
	p--;			/*  Strip trailers. */
    }
    TailTrim = previous->data + previous->size - 1 - p;		/*  Strip trailers. */
    previous->size -= TailTrim;
    p[1] = '\0';

    /*
     * s is the effective split position, given by either a non-zero
     * value of split or by the size of the previous line before
     * trimming.  - kw
     */
    if (split == 0) {
	s = previous->size + TailTrim;	/* the original size */
    } else {
	s = split;
    }
    s_post = s + HeadTrim;
    s_pre = s - TailTrim;

#ifdef DEBUG_SPLITLINE
#ifdef DEBUG_APPCH
    if (s != (int) split)
#endif
	CTRACE((tfp, "GridText: split_line(%d [now:%d]) called\n", split, s));
#endif

#if defined(USE_COLOR_STYLE)
    if (previous->styles == stylechanges_buffers[0])
	line->styles = stylechanges_buffers[1];
    else
	line->styles = stylechanges_buffers[0];
    line->numstyles = 0;
    {
	HTStyleChange *from = previous->styles + previous->numstyles - 1;
	HTStyleChange *to = line->styles + MAX_STYLES_ON_LINE - 1;
	HTStyleChange *scan, *at_end;

	/* Color style changes after the split position
	 * are transferred to the new line.  Ditto for changes
	 * in the trimming region, but we stop when we reach an OFF change.
	 * The second loop below may then handle remaining changes.  - kw */
	while (from >= previous->styles && to >= line->styles) {
	    *to = *from;
	    if ((int) to->horizpos > s_post)
		to->horizpos += -s_post + SpecialAttrChars;
	    else if ((int) to->horizpos > s_pre &&
		     (to->direction == STACK_ON ||
		      to->direction == ABS_ON))
		to->horizpos = ((int) to->horizpos < s) ? 0 : SpecialAttrChars;
	    else
		break;
	    to--;
	    from--;
	}
	/* FROM may be invalid, otherwise it is either an ON change at or
	   before s_pre, or is an OFF change at or before s_post.  */

	scan = from;
	at_end = from;
	/* Now on the previous line we have a correctly nested but
	   possibly non-terminated sequence of style changes.
	   Terminate it, and duplicate unterminated changes at the
	   beginning of the new line. */
	while (scan >= previous->styles && at_end >= previous->styles) {
	    /* The algorithm: scan back though the styles on the previous line.
	       a) If OFF, skip the matched group.
	       Report a bug on failure.
	       b) If ON, (try to) cancel the corresponding ON at at_end,
	       and the corresponding OFF at to;
	       If not, put the corresponding OFF at at_end, and copy to to;
	     */
	    if (scan->direction == STACK_OFF) {
		scan = skip_matched_and_correct_offsets(scan, previous->styles,
							s_pre);
		if (!scan) {
		    CTRACE((tfp, "BUG: styles improperly nested.\n"));
		    break;
		}
	    } else if (scan->direction == STACK_ON) {
		if (at_end->direction == STACK_ON
		    && at_end->style == scan->style
		    && (int) at_end->horizpos >= s_pre)
		    at_end--;
		else if (at_end >= previous->styles + MAX_STYLES_ON_LINE - 1) {
		    CTRACE((tfp, "BUG: style overflow before split_line.\n"));
		    break;
		} else {
		    at_end++;
		    at_end->direction = STACK_OFF;
		    at_end->style = scan->style;
		    at_end->horizpos = s_pre;
		}
		if (to < line->styles + MAX_STYLES_ON_LINE - 1
		    && to[1].direction == STACK_OFF
		    && to[1].horizpos <= (unsigned) SpecialAttrChars
		    && to[1].style == scan->style)
		    to++;
		else if (to >= line->styles) {
		    *to = *scan;
		    to->horizpos = SpecialAttrChars;
		    to--;
		} else {
		    CTRACE((tfp, "BUG: style overflow after split_line.\n"));
		    break;
		}
	    }
	    if ((int) scan->horizpos > s_pre)
		scan->horizpos = s_pre;
	    scan--;
	}
	line->numstyles = line->styles + MAX_STYLES_ON_LINE - 1 - to;
	if (line->numstyles > 0 && line->numstyles < MAX_STYLES_ON_LINE) {
	    int n;

	    for (n = 0; n < line->numstyles; n++)
		line->styles[n] = to[n + 1];
	} else if (line->numstyles == 0)
	    line->styles[0].horizpos = ~0;	/* ?!!! */
	previous->numstyles = at_end - previous->styles + 1;
	if (previous->numstyles == 0)
	    previous->styles[0].horizpos = ~0;	/* ?!!! */
    }
#endif /*USE_COLOR_STYLE */

    {
	HTLine *temp;

	allocHTLine(temp, previous->size);
	if (!temp)
	    outofmem(__FILE__, "split_line_2");
	memcpy(temp, previous, LINE_SIZE(previous->size));
#if defined(USE_COLOR_STYLE)
	POOLallocstyles(temp->styles, previous->numstyles);
	if (!temp->styles)
	    outofmem(__FILE__, "split_line_2");
	memcpy(temp->styles, previous->styles, sizeof(HTStyleChange) * previous->numstyles);
#endif
	previous = temp;
    }

    previous->prev->next = previous;	/* Link in new line */
    previous->next->prev = previous;	/* Could be same node of course */

    /*
     * Terminate finished line for printing.
     */
    previous->data[previous->size] = '\0';

    /*
     * Align left, right or center.
     */
    spare = 0;
    if (
#ifdef EXP_JUSTIFY_ELTS
	   this_line_was_split ||
#endif
	   (alignment == HT_CENTER ||
	    alignment == HT_RIGHT) || text->stbl) {
	/* Calculate spare character positions if needed */
	for (cp = previous->data; *cp; cp++) {
	    if (*cp == LY_UNDERLINE_START_CHAR ||
		*cp == LY_UNDERLINE_END_CHAR ||
		*cp == LY_BOLD_START_CHAR ||
		*cp == LY_BOLD_END_CHAR ||
#ifndef WIDEC_CURSES
		IS_UTF_EXTRA(*cp) ||
#endif
		*cp == LY_SOFT_HYPHEN) {
		ctrl_chars_on_previous_line++;
	    }
	}
	if ((previous->size > 0) &&
	    (int) (previous->data[previous->size - 1] == LY_SOFT_HYPHEN))
	    ctrl_chars_on_previous_line--;

	/* @@@@ first line indent */
#ifdef WIDEC_CURSES
	spare = WRAP_COLS(text) -
	    (int) style->rightIndent - indent +
	    ctrl_chars_on_previous_line - LYstrExtent2(previous->data, previous->size);
	if (spare < 0 && LYwideLines)	/* Can be wider than screen */
	    spare = 0;
#else
	spare = WRAP_COLS(text) -
	    (int) style->rightIndent - indent +
	    ctrl_chars_on_previous_line - previous->size;
	if (spare < 0 && LYwideLines)	/* Can be wider than screen */
	    spare = 0;

	if (spare > 0 && !dump_output_immediately &&
	    text->T.output_utf8 && ctrl_chars_on_previous_line) {
	    utfxtra_on_previous_line -= UTFXTRA_ON_THIS_LINE;
	    if (utfxtra_on_previous_line) {
		int spare_cu = (LYcols_cu(text) -
				utfxtra_on_previous_line - indent +
				ctrl_chars_on_previous_line - previous->size);

		/*
		 * Shift non-leftaligned UTF-8 lines that would be
		 * mishandled by the display library towards the left
		 * if this would make them fit.  The resulting display
		 * will not be as intended, but this is better than
		 * having them split by curses.  (Curses cursor movement
		 * optimization may still cause wrong positioning within
		 * the line, in particular after a sequence of spaces).
		 * - kw
		 */
		if (spare_cu < spare) {
		    if (spare_cu >= 0) {
			if (alignment == HT_CENTER &&
			    (int) (previous->offset + indent + spare / 2 +
				   previous->size)
			    - ctrl_chars_on_previous_line
			    + utfxtra_on_previous_line <= LYcols_cu(text))
			    /* do nothing - it still fits - kw */ ;
			else {
			    spare = spare_cu;
			    if (alignment == HT_CENTER) {
				/*
				 * Can't move toward center all the way,
				 * but at least make line contents appear
				 * as far right as possible.  - kw
				 */
				alignment = HT_RIGHT;
			    }
			}
		    } else if (indent + (int) previous->offset + spare_cu >= 0) {	/* subtract overdraft from effective indentation */
			indent += (int) previous->offset + spare_cu;
			previous->offset = 0;
			spare = 0;
		    }
		}
	    }
	}
#endif
    }

    switch (style->alignment) {
    case HT_CENTER:
	previous->offset = previous->offset + indent + spare / 2;
	break;
    case HT_RIGHT:
	previous->offset = previous->offset + indent + spare;
	break;
    case HT_LEFT:
    case HT_JUSTIFY:		/* Not implemented */
    default:
	previous->offset = previous->offset + indent;
	break;
    }				/* switch */

    if (text->stbl)
	/*
	 * Notify simple table stuff of line split, so that it can
	 * set the last cell's length.  The last cell should and
	 * its row should really end here, or on one of the following
	 * lines with no more characters added after the break.
	 * We don't know whether a cell has been started, so ignore
	 * errors here.
	 * This call is down here because we need the
	 * ctrl_chars_on_previous_line, which have just been re-
	 * counted above.  - kw
	 */
	Stbl_lineBreak(text->stbl,
		       text->Lines - 1,
		       previous->offset,
		       previous->size - ctrl_chars_on_previous_line);

    text->in_line_1 = NO;	/* unless caller sets it otherwise */

    /*
     * If we split the line, adjust the anchor
     * structure values for the new line.  -FM
     */

    if (s > 0) {		/* if not completely empty */
	int moved = 0;

	/* In the algorithm below we move or not move anchors between
	   lines using some heuristic criteria.  However, it is
	   desirable not to have two consequent anchors on different
	   lines *in a wrong order*!  (How can this happen?)
	   So when the "reasonable choice" is not unique, we use the
	   MOVED flag to choose one.
	 */
	/* Our operations can make a non-empty all-whitespace link
	   empty.  So what? */
	if ((a = text->last_anchor_before_split) == 0)
	    a = text->first_anchor;

	for (; a; a = a->next) {
	    if (a->line_num == CurLine) {
		int len = a->extent, n = a->number, start = a->line_pos;
		int end = start + len;

		text->last_anchor_before_split = a;

		/* Which anchors do we leave on the previous line?
		   a) empty finished (We need a cut-off value.
		   "Just because": those before s;
		   this is the only case when we use s, not s_pre/s_post);
		   b) Those which start before s_pre;
		 */
		if (start < s_pre) {
		    if (end <= s_pre)
			continue;	/* No problem */

		    CTRACE_SPLITLINE((tfp, "anchor %d: no relocation", n));
		    if (end > s_post) {
			CTRACE_SPLITLINE((tfp, " of the start.\n"));
			a->extent += -(TailTrim + HeadTrim) + SpecialAttrChars;
		    } else {
			CTRACE_SPLITLINE((tfp, ", cut the end.\n"));
			a->extent = s_pre - start;
		    }
		    continue;
		} else if (start < s && !len
			   && (!n || (a->show_anchor && !moved))) {
		    CTRACE_SPLITLINE((tfp,
				      "anchor %d: no relocation, empty-finished",
				      n));
		    a->line_pos = s_pre;	/* Leave at the end of line */
		    continue;
		}

		/* The rest we relocate */
		moved = 1;
		a->line_num++;
		CTRACE_SPLITLINE((tfp,
				  "anchor %d: (T,H,S)=(%d,%d,%d); (line,pos,ext):(%d,%d,%d), ",
				  n, TailTrim, HeadTrim, SpecialAttrChars,
				  a->line_num, a->line_pos, a->extent));
		if (end < s_post) {	/* Move the end to s_post */
		    CTRACE_SPLITLINE((tfp, "Move end +%d, ", s_post - end));
		    len += s_post - end;
		}
		if (start < s_post) {	/* Move the start to s_post */
		    CTRACE_SPLITLINE((tfp, "Move start +%d, ", s_post - start));
		    len -= s_post - start;
		    start = s_post;
		}
		a->line_pos = start - s_post + SpecialAttrChars;
		a->extent = len;

		CTRACE_SPLITLINE((tfp, "->(%d,%d,%d)\n",
				  a->line_num, a->line_pos, a->extent));
	    } else if (a->line_num > CurLine)
		break;
	}
    }
#ifdef EXP_JUSTIFY_ELTS
    /* now perform justification - by VH */

    if (this_line_was_split
	&& spare
	&& !text->stbl		/* We don't inform TRST on the cell width change yet */
	&& justify_max_void_percent > 0
	&& justify_max_void_percent <= 100
	&& justify_max_void_percent >= ((100 * spare)
					/ (WRAP_COLS(text)
					   - (int) style->rightIndent
					   - indent
					   + ctrl_chars_on_previous_line))) {
	/* this is the only case when we need justification */
	char *jp = previous->data + justify_start_position;
	ht_run_info *r = ht_runs;
	char c;
	int total_byte_len = 0, total_cell_len = 0;
	int d_, r_;
	HTLine *jline;

	ht_num_runs = 0;
	r->byte_len = r->cell_len = 0;

	for (; (c = *jp) != 0; ++jp) {
	    if (c == ' ') {
		total_byte_len += r->byte_len;
		total_cell_len += r->cell_len;
		++r;
		++ht_num_runs;
		r->byte_len = r->cell_len = 0;
		continue;
	    }
	    ++r->byte_len;
	    if (IsSpecialAttrChar(c))
		continue;

	    ++r->cell_len;
	    if (c == HT_NON_BREAK_SPACE) {
		*jp = ' ';	/* substitute it */
		continue;
	    }
	    if (text->T.output_utf8 && is8bits(c)) {
		int utf_extra = utf8_length(text->T.output_utf8, jp);

		r->byte_len += utf_extra;
		jp += utf_extra;
	    }
	}
	total_byte_len += r->byte_len;
	total_cell_len += r->cell_len;
	++ht_num_runs;

	if (ht_num_runs != 1) {
	    int *oldpos = (int *) malloc(sizeof(int) * 2 * (ht_num_runs - 1));
	    int *newpos = oldpos + ht_num_runs - 1;
	    int i = 1;

	    if (oldpos == NULL)
		outofmem(__FILE__, "split_line_3");

	    d_ = spare / (ht_num_runs - 1);
	    r_ = spare % (ht_num_runs - 1);

	    /* The first run is not moved, proceed to the second one */
	    oldpos[0] = justify_start_position + ht_runs[0].cell_len + 1;
	    newpos[0] = oldpos[0] + (d_ + (r_-- > 0));
	    while (i < ht_num_runs - 1) {
		int delta = ht_runs[i].cell_len + 1;

		oldpos[i] = oldpos[i - 1] + delta;
		newpos[i] = newpos[i - 1] + delta + (d_ + (r_-- > 0));
		i++;
	    }
	    jline = insert_blanks_in_line(previous, CurLine, text,
					  &last_anchor_of_previous_line /*updates++ */ ,
					  ht_num_runs - 1, oldpos, newpos);
	    free((char *) oldpos);
	    if (jline == NULL)
		outofmem(__FILE__, "split_line_4");
	    previous->next->prev = jline;
	    previous->prev->next = jline;

	    freeHTLine(text, previous);

	    previous = jline;
	} {			/* (ht_num_runs==1) */
	    if (justify_start_position) {
		char *p2 = previous->data;

		for (; p2 < previous->data + justify_start_position; ++p2)
		    *p2 = (*p2 == HT_NON_BREAK_SPACE ? ' ' : *p2);
	    }
	}
    } else {
	if (REALLY_CAN_JUSTIFY(text)) {
	    char *p2;

	    /* it was permitted to justify line, but this function was called
	     * to end paragraph - we must substitute HT_NON_BREAK_SPACEs with
	     * spaces in previous line
	     */
	    if (line->size && !text->stbl) {
		CTRACE((tfp,
			"BUG: justification: shouldn't happen - new line is not empty!\n\t'%.*s'\n",
			line->size, line->data));
	    }

	    for (p2 = previous->data; *p2; ++p2)
		if (*p2 == HT_NON_BREAK_SPACE)
		    *p2 = ' ';
	} else if (have_raw_nbsps) {
	    /* this is very rare case, that can happen in forms placed in
	       table cells */
	    unsigned i;

	    for (i = 0; i < previous->size; ++i)
		if (previous->data[i] == HT_NON_BREAK_SPACE)
		    previous->data[i] = ' ';

	    /*next line won't be justified, so substitute nbsps in it too */
	    for (i = 0; i < line->size; ++i)
		if (line->data[i] == HT_NON_BREAK_SPACE)
		    line->data[i] = ' ';
	}

	/* else HT_NON_BREAK_SPACEs were substituted with spaces in
	   HText_appendCharacter */
    }
    /* cleanup */
    can_justify_this_line = TRUE;
    justify_start_position = 0;
    this_line_was_split = FALSE;
    have_raw_nbsps = FALSE;
#endif /* EXP_JUSTIFY_ELTS */
    return;
}				/* split_line */

/*	Allow vertical blank space
 *	--------------------------
 */
static void blank_lines(HText *text, int newlines)
{
    if (HText_LastLineEmpty(text, FALSE)) {	/* No text on current line */
	HTLine *line = text->last_line->prev;

#ifdef USE_COLOR_STYLE
	/* Style-change petty requests at the start of the document: */
	if (line == text->last_line && newlines == 1)
	    return;		/* Do not add a blank line at start */
#endif

	while (line != NULL &&
	       line != text->last_line &&
	       HText_TrueEmptyLine(line, text, FALSE)) {
	    if (newlines == 0)
		break;
	    newlines--;		/* Don't bother: already blank */
	    line = line->prev;
	}
    } else {
	newlines++;		/* Need also to finish this line */
    }

    for (; newlines; newlines--) {
	new_line(text);
    }
    text->in_line_1 = YES;
}

/*	New paragraph in current style
 *	------------------------------
 * See also: setStyle.
 */
void HText_appendParagraph(HText *text)
{
    int after = text->style->spaceAfter;
    int before = text->style->spaceBefore;

    blank_lines(text, ((after > before) ? after : before));
}

/*	Set Style
 *	---------
 *
 *	Does not filter unnecessary style changes.
 */
void HText_setStyle(HText *text, HTStyle *style)
{
    int after, before;

    if (!style)
	return;			/* Safety */
    after = text->style->spaceAfter;
    before = style->spaceBefore;

    CTRACE((tfp, "GridText: Change to style %s\n", style->name));

    blank_lines(text, ((after > before) ? after : before));

    text->style = style;
}

/*	Append a character to the text object
 *	-------------------------------------
 */
void HText_appendCharacter(HText *text, int ch)
{
    HTLine *line;
    HTStyle *style;
    int indent;
    int limit = 0;
    int actual;

#ifdef DEBUG_APPCH
#ifdef CJK_EX
    static unsigned char save_ch = 0;
#endif

    if (TRACE) {
	char *special = NULL;	/* make trace a little more readable */

	switch (ch) {
	case HT_NON_BREAK_SPACE:
	    special = "HT_NON_BREAK_SPACE";
	    break;
	case HT_EN_SPACE:
	    special = "HT_EN_SPACE";
	    break;
	case LY_UNDERLINE_START_CHAR:
	    special = "LY_UNDERLINE_START_CHAR";
	    break;
	case LY_UNDERLINE_END_CHAR:
	    special = "LY_UNDERLINE_END_CHAR";
	    break;
	case LY_BOLD_START_CHAR:
	    special = "LY_BOLD_START_CHAR";
	    break;
	case LY_BOLD_END_CHAR:
	    special = "LY_BOLD_END_CHAR";
	    break;
	case LY_SOFT_HYPHEN:
	    special = "LY_SOFT_HYPHEN";
	    break;
	case LY_SOFT_NEWLINE:
	    special = "LY_SOFT_NEWLINE";
	    break;
	default:
	    special = NULL;
	    break;
	}

	if (special != NULL) {
	    CTRACE((tfp, "add(%s %d special char) %d/%d\n", special, ch,
		    HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
	} else {
#ifdef CJK_EX			/* 1998/08/30 (Sun) 13:26:23 */
	    if (save_ch == 0) {
		if (IS_SJIS_HI1(ch) || IS_SJIS_HI2(ch)) {
		    save_ch = ch;
		} else {
		    CTRACE((tfp, "add(%c) %d/%d\n", ch,
			    HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
		}
	    } else {
		CTRACE((tfp, "add(%c%c) %d/%d\n", save_ch, ch,
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
		save_ch = 0;
	    }
#else
	    if (UCH(ch) < 0x80) {
		CTRACE((tfp, "add(%c) %d/%d\n", UCH(ch),
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
	    } else {
		CTRACE((tfp, "add(%02x) %d/%d\n", UCH(ch),
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
	    }
#endif /* CJK_EX */
	}
    }				/* trace only */
#endif /* DEBUG_APPCH */

    /*
     * Make sure we don't crash on NULLs.
     */
    if (!text)
	return;

    if (text->halted > 1) {
	/*
	 * We should stop outputting more text, because low memory was
	 * detected.  - kw
	 */
	if (text->halted == 2) {
	    /*
	     * But if we haven't done so yet, first append a warning.
	     * We should still have a few bytes left for that :).
	     * We temporarily reset test->halted to 0 for this, since
	     * this function will get called recursively.  - kw
	     */
	    text->halted = 0;
	    text->kanji_buf = '\0';
	    HText_appendText(text, gettext(" *** MEMORY EXHAUSTED ***"));
	}
	text->halted = 3;
	return;
    }
#ifdef USE_TH_JP_AUTO_DETECT
    if ((HTCJK == JAPANESE) && (text->detected_kcode != DET_MIXED) &&
	(text->specified_kcode != SJIS) && (text->specified_kcode != EUC)) {
	unsigned char c;
	eDetectedKCode save_d_kcode;

	c = UCH(ch);
	save_d_kcode = text->detected_kcode;
	switch (text->SJIS_status) {
	case SJIS_state_has_bad_code:
	    break;
	case SJIS_state_neutral:
	    if (IS_SJIS_HI1(c) || IS_SJIS_HI2(c)) {
		text->SJIS_status = SJIS_state_in_kanji;
	    } else if ((c & 0x80) && !IS_SJIS_X0201KANA(c)) {
		text->SJIS_status = SJIS_state_has_bad_code;
		if (text->EUC_status == EUC_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_EUC;
	    }
	    break;
	case SJIS_state_in_kanji:
	    if (IS_SJIS_LO(c)) {
		text->SJIS_status = SJIS_state_neutral;
	    } else {
		text->SJIS_status = SJIS_state_has_bad_code;
		if (text->EUC_status == EUC_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_EUC;
	    }
	    break;
	}
	switch (text->EUC_status) {
	case EUC_state_has_bad_code:
	    break;
	case EUC_state_neutral:
	    if (IS_EUC_HI(c)) {
		text->EUC_status = EUC_state_in_kanji;
	    } else if (c == 0x8e) {
		text->EUC_status = EUC_state_in_kana;
	    } else if (c & 0x80) {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	case EUC_state_in_kanji:
	    if (IS_EUC_LOX(c)) {
		text->EUC_status = EUC_state_neutral;
	    } else {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	case EUC_state_in_kana:
	    if ((0xA1 <= c) && (c <= 0xDF)) {
		text->EUC_status = EUC_state_neutral;
	    } else {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	}
	if (save_d_kcode != text->detected_kcode) {
	    switch (text->detected_kcode) {
	    case DET_SJIS:
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode seems SJIS.\n"));
		break;
	    case DET_EUC:
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode seems EUC.\n"));
		break;
	    case DET_MIXED:
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode seems mixed!\n"));
		break;
	    default:
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode is unexpected!\n"));
		break;
	    }
	}
    }
#endif /* USE_TH_JP_AUTO_DETECT */
    /*
     * Make sure we don't hang on escape sequences.
     */
    if (ch == CH_ESC && HTCJK == NOCJK) {	/* decimal 27  S/390 -- gil -- 1504 */
	return;
    }
#ifndef USE_SLANG
    /*
     * Block 8-bit chars not allowed by the current display character
     * set if they are below what LYlowest_eightbit indicates.
     * Slang used its own replacements, so for USE_SLANG blocking here
     * is not necessary to protect terminals from those characters.
     * They should have been filtered out or translated by an earlier
     * processing stage anyway.  - kw
     */
#ifndef   EBCDIC		/* S/390 -- gil -- 1514 */
    if (is8bits(ch) && HTCJK == NOCJK &&
	!text->T.transp && !text->T.output_utf8 &&
	UCH(ch) < LYlowest_eightbit[current_char_set]) {
	return;
    }
#endif /* EBCDIC */
#endif /* !USE_SLANG */
    if (UCH(ch) == 155 && HTCJK == NOCJK) {	/* octal 233 */
	if (!HTPassHighCtrlRaw &&
	    !text->T.transp && !text->T.output_utf8 &&
	    (155 < LYlowest_eightbit[current_char_set])) {
	    return;
	}
    }

    line = text->last_line;
    style = text->style;

    indent = text->in_line_1 ? (int) style->indent1st : (int) style->leftIndent;

    if (HTCJK != NOCJK) {
	switch (text->state) {
	case S_text:
	    if (ch == CH_ESC) {	/* S/390 -- gil -- 1536 */
		/*
		 * Setting up for CJK escape sequence handling (based on
		 * Takuya ASADA's (asada@@three-a.co.jp) CJK Lynx).  -FM
		 */
		text->state = S_esc;
		text->kanji_buf = '\0';
		return;
	    }
	    break;

	case S_esc:
	    /*
	     * Expecting '$'or '(' following CJK ESC.
	     */
	    if (ch == '$') {
		text->state = S_dollar;
		return;
	    } else if (ch == '(') {
		text->state = S_paren;
		return;
	    } else {
		text->state = S_text;
	    }
	    /* FALLTHRU */

	case S_dollar:
	    /*
	     * Expecting '@@', 'B', 'A' or '(' after CJK "ESC$".
	     */
	    if (ch == '@@' || ch == 'B' || ch == 'A') {
		text->state = S_nonascii_text;
		if (ch == '@@' || ch == 'B')
		    text->kcode = JIS;
		return;
	    } else if (ch == '(') {
		text->state = S_dollar_paren;
		return;
	    } else {
		text->state = S_text;
	    }
	    break;

	case S_dollar_paren:
	    /*
	     * Expecting 'C' after CJK "ESC$(".
	     */
	    if (ch == 'C') {
		text->state = S_nonascii_text;
		return;
	    } else {
		text->state = S_text;
	    }
	    break;

	case S_paren:
	    /*
	     * Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(".
	     */
	    if (ch == 'B' || ch == 'J' || ch == 'T') {
		/*
		 * Can split here.  -FM
		 */
		text->permissible_split = text->last_line->size;
		text->state = S_text;
		return;
	    } else if (ch == 'I') {
		text->state = S_jisx0201_text;
		/*
		 * Can split here.  -FM
		 */
		text->permissible_split = text->last_line->size;
		text->kcode = JIS;
		return;
	    } else {
		text->state = S_text;
	    }
	    break;

	case S_nonascii_text:
	    /*
	     * Expecting CJK ESC after non-ASCII text.
	     */
	    if (ch == CH_ESC) {	/* S/390 -- gil -- 1553 */
		text->state = S_esc;
		text->kanji_buf = '\0';
		if (HTCJK == JAPANESE) {
		    text->kcode = NOKANJI;
		}
		return;
	    } else if (UCH(ch) < 32) {
		text->state = S_text;
		text->kanji_buf = '\0';
		if (HTCJK == JAPANESE) {
		    text->kcode = NOKANJI;
		}
	    } else {
		ch |= 0200;
	    }
	    break;

	    /*
	     * JIS X0201 Kana in JIS support.  - by ASATAKU
	     */
	case S_jisx0201_text:
	    if (ch == CH_ESC) {	/* S/390 -- gil -- 1570 */
		text->state = S_esc;
		text->kanji_buf = '\0';
		text->kcode = NOKANJI;
		return;
	    } else {
		text->kanji_buf = '\216';
		ch |= 0200;
	    }
	    break;
	}			/* end switch */

	if (!text->kanji_buf) {
	    if ((ch & 0200) != 0) {
		/*
		 * JIS X0201 Kana in SJIS support.  - by ASATAKU
		 */
		if ((text->kcode != JIS)
		    && (
#ifdef KANJI_CODE_OVERRIDE
			   (last_kcode == SJIS) ||
			   ((last_kcode == NOKANJI) &&
#endif
			    ((text->kcode == SJIS) ||
#ifdef USE_TH_JP_AUTO_DETECT
			     ((text->detected_kcode == DET_SJIS) &&
			      (text->specified_kcode == NOKANJI)) ||
#endif
			     ((text->kcode == NOKANJI) &&
			      (text->specified_kcode == SJIS)))
#ifdef KANJI_CODE_OVERRIDE
			   )
#endif
		    ) &&
		    (UCH(ch) >= 0xA1) &&
		    (UCH(ch) <= 0xDF)) {
#ifdef CONV_JISX0201KANA_JISX0208KANA
		    unsigned char c = UCH(ch);
		    unsigned char kb = UCH(text->kanji_buf);

		    JISx0201TO0208_SJIS(c,
					(unsigned char *) &kb,
					(unsigned char *) &c);
		    ch = (char) c;
		    text->kanji_buf = kb;
#endif
		    /* 1998/01/19 (Mon) 09:06:15 */
		    text->permissible_split = (int) text->last_line->size;
		} else {
		    text->kanji_buf = ch;
		    /*
		     * Can split here.  -FM
		     */
		    text->permissible_split = text->last_line->size;
		    return;
		}
	    }
	} else {
	    goto check_WrapSource;
	}
    } else if (ch == CH_ESC) {	/* S/390 -- gil -- 1587 */
	return;
    }
#ifdef CJK_EX			/* MOJI-BAKE Fix! 1997/10/12 -- 10/31 (Fri) 00:22:57 - JH7AYN */
    if (HTCJK != NOCJK &&	/* added condition - kw */
	(ch == LY_BOLD_START_CHAR || ch == LY_BOLD_END_CHAR)) {
	text->permissible_split = (int) line->size;	/* Can split here */
	if (HTCJK == JAPANESE)
	    text->kcode = NOKANJI;
    }
#endif

    if (IsSpecialAttrChar(ch) && ch != LY_SOFT_NEWLINE) {
#if !defined(USE_COLOR_STYLE) || !defined(NO_DUMP_WITH_BACKSPACES)
	if (line->size >= (MAX_LINE - 1)) {
	    return;
	}
#if defined(USE_COLOR_STYLE) && !defined(NO_DUMP_WITH_BACKSPACES)
	if (with_backspaces && HTCJK == NOCJK && !text->T.output_utf8) {
#endif
	    if (ch == LY_UNDERLINE_START_CHAR) {
		line->data[line->size++] = LY_UNDERLINE_START_CHAR;
		line->data[line->size] = '\0';
		underline_on = ON;
		if (!(dump_output_immediately && use_underscore))
		    ctrl_chars_on_this_line++;
		return;
	    } else if (ch == LY_UNDERLINE_END_CHAR) {
		line->data[line->size++] = LY_UNDERLINE_END_CHAR;
		line->data[line->size] = '\0';
		underline_on = OFF;
		if (!(dump_output_immediately && use_underscore))
		    ctrl_chars_on_this_line++;
		return;
	    } else if (ch == LY_BOLD_START_CHAR) {
		line->data[line->size++] = LY_BOLD_START_CHAR;
		line->data[line->size] = '\0';
		bold_on = ON;
		ctrl_chars_on_this_line++;
		return;
	    } else if (ch == LY_BOLD_END_CHAR) {
		line->data[line->size++] = LY_BOLD_END_CHAR;
		line->data[line->size] = '\0';
		bold_on = OFF;
		ctrl_chars_on_this_line++;
		return;
	    } else if (ch == LY_SOFT_HYPHEN) {
		int i;

		/*
		 * Ignore the soft hyphen if it is the first character
		 * on the line, or if it is preceded by a space or
		 * hyphen.  -FM
		 */
		if (line->size < 1 || text->permissible_split >= line->size) {
		    return;
		}

		for (i = (text->permissible_split + 1); line->data[i]; i++) {
		    if (!IsSpecialAttrChar(UCH(line->data[i])) &&
			!isspace(UCH(line->data[i])) &&
			UCH(line->data[i]) != '-' &&
			UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
			UCH(line->data[i]) != HT_EN_SPACE) {
			break;
		    }
		}
		if (line->data[i] == '\0') {
		    return;
		}
	    }
#if defined(USE_COLOR_STYLE) && !defined(NO_DUMP_WITH_BACKSPACES)
	} else {
	    /* if (with_backspaces && HTCJK==HTNOCJK && !text->T.output_utf8) */
	    return;
	}
#endif

#else
	return;
#endif
    } else if (ch == LY_SOFT_NEWLINE) {
	line->data[line->size++] = LY_SOFT_NEWLINE;
	line->data[line->size] = '\0';
	return;
    }

    if (text->T.output_utf8) {
	/*
	 * Some extra checks for UTF-8 output here to make sure
	 * memory is not overrun.  For a non-first char, append
	 * to the line here and return.  - kw
	 */
	if (IS_UTF_EXTRA(ch)) {
	    if ((line->size > (MAX_LINE - 1))
		|| (indent + (int) (line->offset + line->size)
		    + UTFXTRA_ON_THIS_LINE
		    - ctrl_chars_on_this_line
		    + ((line->size > 0) &&
		       (int) (line->data[line->size - 1] ==
			      LY_SOFT_HYPHEN ?
			      1 : 0)) >= LYcols_cu(text))
		) {
		if (!text->permissible_split || text->source) {
		    text->permissible_split = line->size;
		    while (text->permissible_split > 0 &&
			   IS_UTF_EXTRA(line->data[text->permissible_split - 1]))
			text->permissible_split--;
		    if (text->permissible_split &&
			(line->data[text->permissible_split - 1] & 0x80))
			text->permissible_split--;
		    if (text->permissible_split == line->size)
			text->permissible_split = 0;
		}
		split_line(text, text->permissible_split);
		line = text->last_line;
		if (text->source && line->size - ctrl_chars_on_this_line
		    + UTFXTRA_ON_THIS_LINE == 0)
		    HText_appendCharacter(text, LY_SOFT_NEWLINE);
	    }
	    line->data[line->size++] = (char) ch;
	    line->data[line->size] = '\0';
	    utfxtra_on_this_line++;
	    ctrl_chars_on_this_line++;
	    return;
	} else if (ch & 0x80) {	/* a first char of UTF-8 sequence - kw */
	    if ((line->size > (MAX_LINE - 7))) {
		if (!text->permissible_split || text->source) {
		    text->permissible_split = line->size;
		    while (text->permissible_split > 0 &&
			   (line->data[text->permissible_split - 1] & 0x80)
			   == 0xC0) {
			text->permissible_split--;
		    }
		    if (text->permissible_split == line->size)
			text->permissible_split = 0;
		}
		split_line(text, text->permissible_split);
		line = text->last_line;
		if (text->source && line->size - ctrl_chars_on_this_line
		    + UTFXTRA_ON_THIS_LINE == 0)
		    HText_appendCharacter(text, LY_SOFT_NEWLINE);
	    }
	}
    }

    /*
     * New Line.
     */
    if (ch == '\n') {
	new_line(text);
	text->in_line_1 = YES;	/* First line of new paragraph */
	/*
	 * There are some pages written in
	 * different kanji codes.  - TA & kw
	 */
	if (HTCJK == JAPANESE)
	    text->kcode = NOKANJI;
	return;
    }

    /*
     * Convert EN_SPACE to a space here so that it doesn't get collapsed.
     */
    if (ch == HT_EN_SPACE)
	ch = ' ';

#ifdef SH_EX			/* 1997/11/01 (Sat) 12:08:54 */
    if (ch == 0x0b) {		/* ^K ??? */
	ch = '\r';
    }
    if (ch == 0x1a) {		/* ^Z ??? */
	ch = '\r';
    }
#endif

    /*
     * I'm going to cheat here in a BIG way.  Since I know that all
     * \r's will be trapped by HTML_put_character I'm going to use
     * \r to mean go down a line but don't start a new paragraph.
     * i.e., use the second line indenting.
     */
    if (ch == '\r') {
	new_line(text);
	text->in_line_1 = NO;
	/*
	 * There are some pages written in
	 * different kanji codes.  - TA & kw
	 */
	if (HTCJK == JAPANESE)
	    text->kcode = NOKANJI;
	return;
    }

    /*
     * Tabs.
     */
    if (ch == '\t') {
	const HTTabStop *Tab;
	int target, target_cu;	/* Where to tab to */
	int here, here_cu;	/* in _cu we try to guess what curses thinks */

	if (line->size > 0 && line->data[line->size - 1] == LY_SOFT_HYPHEN) {
	    /*
	     * A tab shouldn't follow a soft hyphen, so
	     * if one does, we'll dump the soft hyphen.  -FM
	     */
	    line->data[--line->size] = '\0';
	    ctrl_chars_on_this_line--;
	}
	here = ((int) (line->size + line->offset) + indent)
	    - ctrl_chars_on_this_line;	/* Consider special chars GAB */
	here_cu = here + UTFXTRA_ON_THIS_LINE;
	if (style->tabs) {	/* Use tab table */
	    for (Tab = style->tabs;
		 Tab->position <= here;
		 Tab++) {
		if (!Tab->position) {
		    new_line(text);
		    return;
		}
	    }
	    target = Tab->position;
	} else if (text->in_line_1) {	/* Use 2nd indent */
	    if (here >= (int) style->leftIndent) {
		new_line(text);	/* wrap */
		return;
	    } else {
		target = (int) style->leftIndent;
	    }
	} else {		/* Default tabs align with left indent mod 8 */
#ifdef DEFAULT_TABS_8
	    target = (((int) line->offset + (int) line->size + 8) & (-8))
		+ (int) style->leftIndent;
#else
	    new_line(text);
	    return;
#endif
	}

	if (target >= here)
	    target_cu = target;
	else
	    target_cu = target + (here_cu - here);

	if (target > WRAP_COLS(text) - (int) style->rightIndent &&
	    HTOutputFormat != WWW_SOURCE) {
	    new_line(text);
	} else {
	    /*
	     * Can split here.  -FM
	     */
	    text->permissible_split = line->size;
	    if (target_cu > WRAP_COLS(text))
		target -= target_cu - WRAP_COLS(text);
	    if (line->size == 0) {
		line->offset = line->offset + target - here;
	    } else {
		for (; here < target; here++) {
		    /* Put character into line */
		    line->data[line->size++] = ' ';
		    line->data[line->size] = '\0';
		}
	    }
	}
	return;
    }
    /* if tab */
  check_WrapSource:
    if ((text->source || dont_wrap_pre) && text == HTMainText) {
	/*
	 * If we're displaying document source, wrap long lines to keep all of
	 * the source visible.
	 */
	int target = (int) (line->offset + line->size) - ctrl_chars_on_this_line;
	int target_cu = target + UTFXTRA_ON_THIS_LINE;

	if (target >= WRAP_COLS(text) - style->rightIndent -
	    (((HTCJK != NOCJK) && text->kanji_buf) ? 1 : 0) ||
	    (text->T.output_utf8 &&
	     target_cu + UTF_XLEN(ch) >= LYcols_cu(text))) {
	    int saved_kanji_buf;
	    eGridState saved_state;

	    new_line(text);
	    line = text->last_line;

	    saved_kanji_buf = text->kanji_buf;
	    saved_state = text->state;
	    text->kanji_buf = '\0';
	    text->state = S_text;
	    HText_appendCharacter(text, LY_SOFT_NEWLINE);
	    text->kanji_buf = saved_kanji_buf;
	    text->state = saved_state;
	}
    }

    if (ch == ' ') {
	/*
	 * Can split here.  -FM
	 */
	text->permissible_split = text->last_line->size;
	/*
	 * There are some pages written in
	 * different kanji codes.  - TA
	 */
	if (HTCJK == JAPANESE)
	    text->kcode = NOKANJI;
    }

    /*
     * Check if we should ignore characters at the wrap point.
     */
    if (text->IgnoreExcess) {
	int nominal = (indent + (int) (line->offset + line->size) - ctrl_chars_on_this_line);
	int number;

	limit = WRAP_COLS(text);
	if (fields_are_numbered()
	    && !number_fields_on_left
	    && text->last_anchor != 0
	    && (number = text->last_anchor->number) > 0) {
	    limit -= (number > 99999
		      ? 6
		      : (number > 9999
			 ? 5
			 : (number > 999
			    ? 4
			    : (number > 99
			       ? 3
			       : (number > 9
				  ? 2
				  : 1))))) + 2;
	}
	if ((nominal + (int) style->rightIndent) >= limit
	    || (nominal + UTFXTRA_ON_THIS_LINE) >= LYcols_cu(text)) {
	    return;
	}
    }

    /*
     * Check for end of line.
     */
    actual = ((indent + (int) line->offset + (int) line->size) +
	      ((line->size > 0) &&
	       (int) (line->data[line->size - 1] == LY_SOFT_HYPHEN ? 1 : 0)));

    if (text->T.output_utf8) {
	actual += (UTFXTRA_ON_THIS_LINE - ctrl_chars_on_this_line + UTF_XLEN(ch));
	limit = LYcols_cu(text);
    } else {
	actual +=
	    (int) style->rightIndent - ctrl_chars_on_this_line +
	    (((HTCJK != NOCJK) && text->kanji_buf) ? 1 : 0);
	limit = WRAP_COLS(text);
    }

    if (actual >= limit) {

	if (style->wordWrap && HTOutputFormat != WWW_SOURCE) {
#ifdef EXP_JUSTIFY_ELTS
	    if (REALLY_CAN_JUSTIFY(text))
		this_line_was_split = TRUE;
#endif
	    split_line(text, text->permissible_split);
	    if (ch == ' ') {
		return;		/* Ignore space causing split */
	    }

	} else if (HTOutputFormat == WWW_SOURCE) {
	    /*
	     * For source output we don't want to wrap this stuff
	     * unless absolutely necessary.  - LJM
	     * !
	     * If we don't wrap here we might get a segmentation fault.
	     * but let's see what happens
	     */
	    if ((int) line->size >= (int) (MAX_LINE - 1)) {
		new_line(text);	/* try not to linewrap */
	    }
	} else {
	    /*
	     * For normal stuff like pre let's go ahead and
	     * wrap so the user can see all of the text.
	     */
	    if ((dump_output_immediately || (crawl && traversal))
		&& dont_wrap_pre) {
		if ((int) line->size >= (int) (MAX_LINE - 1)) {
		    new_line(text);
		}
	    } else {
		new_line(text);
	    }
	}
    } else if ((int) line->size >= (int) (MAX_LINE - 1)) {
	/*
	 * Never overrun memory if DISPLAY_COLS is set to a large value - KW
	 */
	new_line(text);
    }

    /*
     * Insert normal characters.
     */
    if (ch == HT_NON_BREAK_SPACE
#ifdef EXP_JUSTIFY_ELTS
	&& !REALLY_CAN_JUSTIFY(text)
#endif
	)
	ch = ' ';
#ifdef EXP_JUSTIFY_ELTS
    else
	have_raw_nbsps = TRUE;
#endif

    /* we leave raw HT_NON_BREAK_SPACE otherwise (we'll substitute it later) */

    if (ch & 0x80)
	text->have_8bit_chars = YES;

    /*
     * Kanji charactor handling.
     */
    {
	HTFont font = style->font;
	unsigned char hi, lo, tmp[2];

	line = text->last_line;	/* May have changed */

	if (HTCJK != NOCJK && text->kanji_buf) {
	    hi = UCH(text->kanji_buf);
	    lo = UCH(ch);

	    if (HTCJK == JAPANESE) {
		if (text->kcode != JIS) {
		    if (IS_SJIS_2BYTE(hi, lo)) {
			if (IS_EUC(hi, lo)) {
#ifdef KANJI_CODE_OVERRIDE
			    if (last_kcode != NOKANJI)
				text->kcode = last_kcode;
			    else
#endif
			    if (text->specified_kcode != NOKANJI)
				text->kcode = text->specified_kcode;
#ifdef USE_TH_JP_AUTO_DETECT
			    else if (text->detected_kcode == DET_EUC)
				text->kcode = EUC;
			    else if (text->detected_kcode == DET_SJIS)
				text->kcode = SJIS;
#endif
			    else if (IS_EUC_X0201KANA(hi, lo) &&
				     (text->kcode != EUC))
				text->kcode = SJIS;
			} else
			    text->kcode = SJIS;
		    } else if (IS_EUC(hi, lo))
			text->kcode = EUC;
		    else
			text->kcode = NOKANJI;
		}

		switch (kanji_code) {
		case EUC:
		    if (text->kcode == SJIS) {
			SJIS_TO_EUC1(hi, lo, tmp);
			line->data[line->size++] = tmp[0];
			line->data[line->size++] = tmp[1];
		    } else if (IS_EUC(hi, lo)) {
#ifdef CONV_JISX0201KANA_JISX0208KANA
			JISx0201TO0208_EUC(hi, lo, &hi, &lo);
#endif
			line->data[line->size++] = hi;
			line->data[line->size++] = lo;
		    } else {
			CTRACE((tfp,
				"This character (%X:%X) doesn't seem Japanese\n",
				hi, lo));
			line->data[line->size++] = '=';
			line->data[line->size++] = '=';
		    }
		    break;

		case SJIS:
		    if ((text->kcode == EUC) || (text->kcode == JIS)) {
#ifndef CONV_JISX0201KANA_JISX0208KANA
			if (IS_EUC_X0201KANA(hi, lo))
			    line->data[line->size++] = lo;
			else
#endif
			{
			    EUC_TO_SJIS1(hi, lo, tmp);
			    line->data[line->size++] = tmp[0];
			    line->data[line->size++] = tmp[1];
			}
		    } else if (IS_SJIS_2BYTE(hi, lo)) {
			line->data[line->size++] = hi;
			line->data[line->size++] = lo;
		    } else {
			line->data[line->size++] = '=';
			line->data[line->size++] = '=';
			CTRACE((tfp,
				"This character (%X:%X) doesn't seem Japanese\n",
				hi, lo));
		    }
		    break;

		default:
		    break;
		}
	    } else {
		line->data[line->size++] = hi;
		line->data[line->size++] = lo;
	    }
	    text->kanji_buf = 0;
	}
#ifndef CONV_JISX0201KANA_JISX0208KANA
	else if ((HTCJK == JAPANESE) && IS_SJIS_X0201KANA(UCH((ch))) &&
		 (kanji_code == EUC)) {
	    line->data[line->size++] = UCH(0x8e);
	    line->data[line->size++] = ch;
	}
#endif
	else if (HTCJK != NOCJK) {
	    line->data[line->size++] = (char) ((kanji_code != NOKANJI) ?
					       ch :
					       (font & HT_CAPITALS) ?
					       TOUPPER(ch) : ch);
	} else {
	    line->data[line->size++] =	/* Put character into line */
		(char) (font & HT_CAPITALS ? TOUPPER(ch) : ch);
	}
	line->data[line->size] = '\0';
	if (font & HT_DOUBLE)	/* Do again if doubled */
	    HText_appendCharacter(text, HT_NON_BREAK_SPACE);
	/* NOT a permissible split */

	if (ch == LY_SOFT_HYPHEN) {
	    ctrl_chars_on_this_line++;
	    /*
	     * Can split here.  -FM
	     */
	    text->permissible_split = text->last_line->size;
	}
	if (ch == LY_SOFT_NEWLINE) {
	    ctrl_chars_on_this_line++;
	}
    }
    return;
}

#ifdef USE_COLOR_STYLE
/*  Insert a style change into the current line
 *  -------------------------------------------
 */
void _internal_HTC(HText *text, int style, int dir)
{
    HTLine *line;

    /* can't change style if we have no text to change style with */
    if (text != 0) {

	line = text->last_line;

	if (line->numstyles > 0 && dir == 0 &&
	    line->styles[line->numstyles - 1].direction &&
	    line->styles[line->numstyles - 1].style == (unsigned) style &&
	    (int) line->styles[line->numstyles - 1].horizpos
	    == (int) line->size - ctrl_chars_on_this_line) {
	    /*
	     * If this is an OFF change directly preceded by an
	     * ON for the same style, just remove the previous one.  - kw
	     */
	    line->numstyles--;
	} else if (line->numstyles < MAX_STYLES_ON_LINE) {
	    line->styles[line->numstyles].horizpos = line->size;
	    /*
	     * Special chars for bold and underlining usually don't
	     * occur with color style, but soft hyphen can.
	     * And in UTF-8 display mode all non-initial bytes are
	     * counted as ctrl_chars.  - kw
	     */
	    if ((int) line->styles[line->numstyles].horizpos >= ctrl_chars_on_this_line)
		line->styles[line->numstyles].horizpos -= ctrl_chars_on_this_line;
	    line->styles[line->numstyles].style = style;
	    line->styles[line->numstyles].direction = dir;
	    line->numstyles++;
	}
    }
}
#endif

/*	Set LastChar element in the text object.
 *	----------------------------------------
 */
void HText_setLastChar(HText *text, char ch)
{
    if (!text)
	return;

    text->LastChar = ch;
}

/*	Get LastChar element in the text object.
 *	----------------------------------------
 */
char HText_getLastChar(HText *text)
{
    if (!text)
	return ('\0');

    return ((char) text->LastChar);
}

/*	Set IgnoreExcess element in the text object.
 *	--------------------------------------------
 */
void HText_setIgnoreExcess(HText *text, BOOL ignore)
{
    if (!text)
	return;

    text->IgnoreExcess = ignore;
}

/*		Simple table handling - private
 *		-------------------------------
 */

/*
 * HText_insertBlanksInStblLines fixes up table lines when simple table
 * processing is closed, by calling insert_blanks_in_line for lines
 * that need fixup.  Also recalculates alignment for those lines,
 * does additional updating of anchor positions, and makes sure the
 * display of the lines on screen will be updated after partial display
 * upon return to mainloop.  - kw
 */
static int HText_insertBlanksInStblLines(HText *me, int ncols)
{
    HTLine *line;
    HTLine *mod_line, *first_line = NULL;
    int *oldpos;
    int *newpos;
    int ninserts, lineno;
    int first_lineno, last_lineno, first_lineno_pass2;

#ifdef EXP_NESTED_TABLES
    int last_nonempty = -1;
#endif
    int added_chars_before = 0;
    int lines_changed = 0;
    int max_width = 0, indent, spare, table_offset;
    HTStyle *style;
    short alignment;
    int i = 0;

    lineno = first_lineno = Stbl_getStartLine(me->stbl);
    if (lineno < 0 || lineno > me->Lines)
	return -1;
    /*
     * oldpos, newpos:  allocate space for two int arrays.
     */
    oldpos = typecallocn(int, 2 * ncols);
    if (!oldpos)
	return -1;
    else
	newpos = oldpos + ncols;
    for (line = FirstHTLine(me); i < lineno; line = line->next, i++) {
	if (!line) {
	    free(oldpos);
	    return -1;
	}
    }
    first_lineno_pass2 = last_lineno = me->Lines;
    for (; line && lineno <= last_lineno; line = line->next, lineno++) {
	ninserts = Stbl_getFixupPositions(me->stbl, lineno, oldpos, newpos);
	if (ninserts < 0)
	    continue;
	if (!first_line) {
	    first_line = line;
	    first_lineno_pass2 = lineno;
	    if (TRACE) {
		int ip;

		CTRACE((tfp, "line %d first to adjust  --  newpos:", lineno));
		for (ip = 0; ip < ncols; ip++)
		    CTRACE((tfp, " %d", newpos[ip]));
		CTRACE((tfp, "\n"));
	    }
	}
	if (line == me->last_line) {
	    if (line->size == 0 || HText_TrueEmptyLine(line, me, FALSE))
		continue;
	    /*
	     * Last ditch effort to end the table with a line break,
	     * if HTML_end_element didn't do it.  - kw
	     */
	    if (first_line == line)	/* obscure: all table on last line... */
		first_line = NULL;
	    new_line(me);
	    line = me->last_line->prev;
	    if (first_line == NULL)
		first_line = line;
	}
	if (ninserts == 0) {
	    /*  Do it also for no positions (but not error) */
	    int width = HText_TrueLineSize(line, me, FALSE);

	    if (width > max_width)
		max_width = width;
#ifdef EXP_NESTED_TABLES
	    if (nested_tables) {
		if (width && last_nonempty < lineno)
		    last_nonempty = lineno;
	    }
#endif
	    CTRACE((tfp, "line %d true/max width:%d/%d oldpos: NONE\n",
		    lineno, width, max_width));
	    continue;
	}
	mod_line = insert_blanks_in_line(line, lineno, me,
					 &me->last_anchor_before_stbl /*updates++ */ ,
					 ninserts, oldpos, newpos);
	if (mod_line) {
	    if (line == me->last_line) {
		me->last_line = mod_line;
	    } else {
		added_chars_before += (mod_line->size - line->size);
	    }
	    line->prev->next = mod_line;
	    line->next->prev = mod_line;
	    lines_changed++;
	    if (line == first_line)
		first_line = mod_line;
	    freeHTLine(me, line);
	    line = mod_line;
#ifdef DISP_PARTIAL
	    /*
	     * Make sure modified lines get fully re-displayed after
	     * loading with partial display is done.
	     */
	    if (me->first_lineno_last_disp_partial >= 0) {
		if (me->first_lineno_last_disp_partial >= lineno) {
		    ResetPartialLinenos(me);
		} else if (me->last_lineno_last_disp_partial >= lineno) {
		    me->last_lineno_last_disp_partial = lineno - 1;
		}
	    }
#endif
	} {
	    int width = HText_TrueLineSize(line, me, FALSE);

	    if (width > max_width)
		max_width = width;
#ifdef EXP_NESTED_TABLES
	    if (nested_tables) {
		if (width && last_nonempty < lineno)
		    last_nonempty = lineno;
	    }
#endif
	    if (TRACE) {
		int ip;

		CTRACE((tfp, "line %d true/max width:%d/%d oldpos:",
			lineno, width, max_width));
		for (ip = 0; ip < ninserts; ip++)
		    CTRACE((tfp, " %d", oldpos[ip]));
		CTRACE((tfp, "\n"));
	    }
	}
    }
    /*
     * Line offsets have been set based on the paragraph style, and
     * have already been updated for centering or right-alignment
     * for each line in split_line.  Here we want to undo all that, and
     * align the table as a whole (i.e.  all lines for which
     * Stbl_getFixupPositions returned >= 0).  All those lines have to
     * get the same offset, for the simple table formatting mechanism
     * to make sense, and that may not actually be the case at this point.
     *
     * What indentation and alignment do we want for the table as
     * a whole?  Let's take most style properties from me->style.
     * With some luck, it is the appropriate style for the element
     * enclosing the TABLE.  But let's take alignment from the attribute
     * of the TABLE itself instead, if it was specified.
     *
     * Note that this logic assumes that all lines have been finished
     * by split_line.  The order of calls made by HTML_end_element for
     * HTML_TABLE should take care of this.
     */
    style = me->style;
    alignment = Stbl_getAlignment(me->stbl);
    if (alignment == HT_ALIGN_NONE)
	alignment = style->alignment;
    indent = style->leftIndent;
    /* Calculate spare character positions */
    spare = WRAP_COLS(me) -
	(int) style->rightIndent - indent - max_width;
    if (spare < 0 && (int) style->rightIndent + spare >= 0) {
	/*
	 * Not enough room!  But we can fit if we ignore right indentation,
	 * so let's do that.
	 */
	spare = 0;
    } else if (spare < 0) {
	spare += style->rightIndent;	/* ignore right indent, but need more */
    }
    if (spare < 0 && indent + spare >= 0) {
	/*
	 * Still not enough room.  But we can move to the left.
	 */
	indent += spare;
	spare = 0;
    } else if (spare < 0) {
	/*
	 * Still not enough.  Something went wrong.  Try the best we
	 * can do.
	 */
	CTRACE((tfp,
		"BUG: insertBlanks: resulting table too wide by %d positions!\n",
		-spare));
	indent = spare = 0;
    }
    /*
     * Align left, right or center.
     */
    switch (alignment) {
    case HT_CENTER:
	table_offset = indent + spare / 2;
	break;
    case HT_RIGHT:
	table_offset = indent + spare;
	break;
    case HT_LEFT:
    case HT_JUSTIFY:
    default:
	table_offset = indent;
	break;
    }				/* switch */

    CTRACE((tfp, "changing offsets"));
    for (line = first_line, lineno = first_lineno_pass2;
	 line && lineno <= last_lineno && line != me->last_line;
	 line = line->next, lineno++) {
	ninserts = Stbl_getFixupPositions(me->stbl, lineno, oldpos, newpos);
	if (ninserts >= 0 && (int) line->offset != table_offset) {
#ifdef DISP_PARTIAL
	    /*  As above make sure modified lines get fully re-displayed */
	    if (me->first_lineno_last_disp_partial >= 0) {
		if (me->first_lineno_last_disp_partial >= lineno) {
		    ResetPartialLinenos(me);
		} else if (me->last_lineno_last_disp_partial >= lineno) {
		    me->last_lineno_last_disp_partial = lineno - 1;
		}
	    }
#endif
	    CTRACE((tfp, " %d:%d", lineno, table_offset - line->offset));
	    line->offset = table_offset;
	}
    }
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	if (max_width)
	    Stbl_update_enclosing(me->stbl, max_width, last_nonempty);
    }
#endif
    CTRACE((tfp, " %d:done\n", lineno));
    free(oldpos);
    return lines_changed;
}

/*		Simple table handling - public functions
 *		----------------------------------------
 */

/*	Cancel simple table handling
*/
void HText_cancelStbl(HText *me)
{
    if (!me || !me->stbl) {
	CTRACE((tfp, "cancelStbl: ignored.\n"));
	return;
    }
    CTRACE((tfp, "cancelStbl: ok, will do.\n"));
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	STable_info *stbl = me->stbl;

	while (stbl) {
	    STable_info *enclosing = Stbl_get_enclosing(stbl);

	    Stbl_free(stbl);
	    stbl = enclosing;
	}
    } else
#endif
	Stbl_free(me->stbl);
    me->stbl = NULL;
}

/*	Start simple table handling
*/
void HText_startStblTABLE(HText *me, short alignment)
{
#ifdef EXP_NESTED_TABLES
    STable_info *current = me->stbl;
#endif

    if (!me)
	return;

#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	if (current)
	    new_line(me);
    } else
#endif
    {
	if (me->stbl)
	    HText_cancelStbl(me);	/* auto cancel previously open table */
    }

    me->stbl = Stbl_startTABLE(alignment);
    if (me->stbl) {
	CTRACE((tfp, "startStblTABLE: started.\n"));
#ifdef EXP_NESTED_TABLES
	if (nested_tables) {
	    Stbl_set_enclosing(me->stbl, current, me->last_anchor_before_stbl);
	}
#endif
	me->last_anchor_before_stbl = me->last_anchor;
    } else {
	CTRACE((tfp, "startStblTABLE: failed.\n"));
    }
}

#ifdef EXP_NESTED_TABLES
static void free_enclosed_stbl(HText *me)
{
    if (me->enclosed_stbl != NULL) {
	HTList *list = me->enclosed_stbl;
	STable_info *stbl;

	while (NULL != (stbl = (STable_info *) HTList_nextObject(list))) {
	    CTRACE((tfp, "endStblTABLE: finally free %p\n", me->stbl));
	    Stbl_free(stbl);
	}
	HTList_delete(me->enclosed_stbl);
	me->enclosed_stbl = NULL;
    }
}

#else
#define free_enclosed_stbl(me)	/* nothing */
#endif

/*	Finish simple table handling
 *	Return TRUE if the table is nested inside another table.
 */
int HText_endStblTABLE(HText *me)
{
    int ncols, lines_changed = 0;
    STable_info *enclosing = NULL;

    if (!me || !me->stbl) {
	CTRACE((tfp, "endStblTABLE: ignored.\n"));
	free_enclosed_stbl(me);
	return FALSE;
    }
    CTRACE((tfp, "endStblTABLE: ok, will try.\n"));

    ncols = Stbl_finishTABLE(me->stbl);
    CTRACE((tfp, "endStblTABLE: ncols = %d.\n", ncols));

    if (ncols > 0) {
	lines_changed = HText_insertBlanksInStblLines(me, ncols);
	CTRACE((tfp, "endStblTABLE: changed %d lines, done.\n", lines_changed));
#ifdef DISP_PARTIAL
	/* allow HTDisplayPartial() to redisplay the changed lines.
	 * There is no harm if we got several stbl in the document, hope so.
	 */
	NumOfLines_partial -= lines_changed;	/* fake */
#endif /* DISP_PARTIAL */
    }
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	enclosing = Stbl_get_enclosing(me->stbl);
	me->last_anchor_before_stbl = Stbl_get_last_anchor_before(me->stbl);
	if (enclosing == NULL) {
	    Stbl_free(me->stbl);
	    free_enclosed_stbl(me);
	} else {
	    if (me->enclosed_stbl == NULL)
		me->enclosed_stbl = HTList_new();
	    HTList_addObject(me->enclosed_stbl, me->stbl);
	    CTRACE((tfp, "endStblTABLE: postpone free %p\n", me->stbl));
	}
	me->stbl = enclosing;
    } else {
	Stbl_free(me->stbl);
	me->stbl = NULL;
    }
#else
    Stbl_free(me->stbl);
    me->stbl = NULL;
#endif

    CTRACE((tfp, "endStblTABLE: have%s enclosing table (%p)\n",
	    enclosing == 0 ? " NO" : "", enclosing));

    return enclosing != 0;
}

/*	Start simple table row
*/
void HText_startStblTR(HText *me, short alignment)
{
    if (!me || !me->stbl)
	return;
    if (Stbl_addRowToTable(me->stbl, alignment, me->Lines) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Finish simple table row
*/
void HText_endStblTR(HText *me)
{
    if (!me || !me->stbl)
	return;
    /* should this do something?? */
}

/*	Start simple table cell
*/
void HText_startStblTD(HText *me, int colspan,
		       int rowspan,
		       short alignment,
		       BOOL isheader)
{
    if (!me || !me->stbl)
	return;
    if (colspan < 0)
	colspan = 1;
    if (colspan > TRST_MAXCOLSPAN) {
	CTRACE((tfp, "*** COLSPAN=%d is too large, ignored!\n", colspan));
	colspan = 1;
    }
    if (rowspan > TRST_MAXROWSPAN) {
	CTRACE((tfp, "*** ROWSPAN=%d is too large, ignored!\n", rowspan));
	rowspan = 1;
    }
    if (Stbl_addCellToTable(me->stbl, colspan, rowspan, alignment, isheader,
			    me->Lines,
			    HText_LastLineOffset(me),
			    HText_LastLineSize(me, FALSE)) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Finish simple table cell
*/
void HText_endStblTD(HText *me)
{
    if (!me || !me->stbl)
	return;
    if (Stbl_finishCellInTable(me->stbl, TRST_ENDCELL_ENDTD,
			       me->Lines,
			       HText_LastLineOffset(me),
			       HText_LastLineSize(me, FALSE)) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Remember COL info / Start a COLGROUP and remember info
*/
void HText_startStblCOL(HText *me, int span,
			short alignment,
			BOOL isgroup)
{
    if (!me || !me->stbl)
	return;
    if (span <= 0)
	span = 1;
    if (span > TRST_MAXCOLSPAN) {
	CTRACE((tfp, "*** SPAN=%d is too large, ignored!\n", span));
	span = 1;
    }
    if (Stbl_addColInfo(me->stbl, span, alignment, isgroup) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Finish a COLGROUP
*/
void HText_endStblCOLGROUP(HText *me)
{
    if (!me || !me->stbl)
	return;
    if (Stbl_finishColGroup(me->stbl) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Start a THEAD / TFOOT / TBODY - remember its alignment info
*/
void HText_startStblRowGroup(HText *me, short alignment)
{
    if (!me || !me->stbl)
	return;
    if (Stbl_addRowGroup(me->stbl, alignment) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*		Anchor handling
 *		---------------
 */
static void add_link_number(HText *text, TextAnchor *a, BOOL save_position)
{
    char marker[32];

    /*
     * If we are doing link_numbering add the link number.
     */
    if ((a->number > 0)
#ifdef USE_PRETTYSRC
	&& (text->source ? !psrcview_no_anchor_numbering : 1)
#endif
	&& links_are_numbered()) {
	char saved_lastchar = text->LastChar;
	int saved_linenum = text->Lines;

	sprintf(marker, "[%d]", a->number);
	HText_appendText(text, marker);
	if (saved_linenum && text->Lines && saved_lastchar != ' ')
	    text->LastChar = ']';	/* if marker not after space caused split */
	if (save_position) {
	    a->line_num = text->Lines;
	    a->line_pos = text->last_line->size;
	}
    }
}

/*	Start an anchor field
*/
int HText_beginAnchor(HText *text, BOOL underline,
		      HTChildAnchor *anc)
{
    TextAnchor *a;

    POOLtypecalloc(TextAnchor, a);

    if (a == NULL)
	outofmem(__FILE__, "HText_beginAnchor");
    a->inUnderline = underline;

    a->line_num = text->Lines;
    a->line_pos = text->last_line->size;
    if (text->last_anchor) {
	text->last_anchor->next = a;
    } else {
	text->first_anchor = a;
    }
    a->next = 0;
    a->anchor = anc;
    a->extent = 0;
    a->link_type = HYPERTEXT_ANCHOR;
    text->last_anchor = a;

#ifndef DONT_TRACK_INTERNAL_LINKS
    if (HTAnchor_followTypedLink(anc, HTInternalLink)) {
	a->number = ++(text->last_anchor_number);
	a->link_type = INTERNAL_LINK_ANCHOR;
    } else
#endif
    if (HTAnchor_followLink(anc)) {
	a->number = ++(text->last_anchor_number);
    } else {
	a->number = 0;
    }

    if (number_links_on_left)
	add_link_number(text, a, TRUE);
    return (a->number);
}

/* If !really, report whether the anchor is empty. */
static BOOL HText_endAnchor0(HText *text, int number,
			     int really)
{
    TextAnchor *a;

    /*
     * The number argument is set to 0 in HTML.c and
     * LYCharUtils.c when we want to end the anchor
     * for the immediately preceding HText_beginAnchor()
     * call.  If it's greater than 0, we want to handle
     * a particular anchor.  This allows us to set links
     * for positions indicated by NAME or ID attributes,
     * without needing to close any anchor with an HREF
     * within which that link might be embedded.  -FM
     */
    if (number <= 0 || number == text->last_anchor->number) {
	a = text->last_anchor;
    } else {
	for (a = text->first_anchor; a; a = a->next) {
	    if (a->number == number) {
		break;
	    }
	}
	if (a == NULL) {
	    /*
	     * There's no anchor with that number,
	     * so we'll default to the last anchor,
	     * and cross our fingers.  -FM
	     */
	    a = text->last_anchor;
	}
    }

    CTRACE((tfp, "GridText:HText_endAnchor0: number:%d link_type:%d\n",
	    a->number, a->link_type));
    if (a->link_type == INPUT_ANCHOR) {
	/*
	 * Shouldn't happen, but put test here anyway to be safe.  - LE
	 */

	CTRACE((tfp,
		"BUG: HText_endAnchor0: internal error: last anchor was input field!\n"));
	return FALSE;
    }

    if (a->number) {
	/*
	 * If it goes somewhere...
	 */
	int i, j, k, l;
	BOOL remove_numbers_on_empty = (BOOL) ((links_are_numbered() &&
						((text->hiddenlinkflag != HIDDENLINKS_MERGE)
						 || (LYNoISMAPifUSEMAP &&
						     !(text->node_anchor && text->node_anchor->bookmark)
						     && HTAnchor_isISMAPScript
						     (HTAnchor_followLink(a->anchor))))));
	HTLine *last = text->last_line;
	HTLine *prev = text->last_line->prev;
	HTLine *start = last;
	int CurBlankExtent = 0;
	int BlankExtent = 0;
	int extent_adjust = 0;

	/* Find the length taken by the anchor */
	l = text->Lines;	/* lineno of last */
	while (l > a->line_num) {
	    extent_adjust += start->size;
	    start = start->prev;
	    l--;
	}
	/* Now start is the start line of the anchor */
	extent_adjust += start->size - a->line_pos;
	start = last;		/* Used later */

	/*
	 * Check if the anchor content has only
	 * white and special characters, starting
	 * with the content on the last line.  -FM
	 */
	a->extent += extent_adjust;
	if (a->extent > (int) last->size) {
	    /*
	     * The anchor extends over more than one line,
	     * so set up to check the entire last line.  -FM
	     */
	    i = last->size;
	} else {
	    /*
	     * The anchor is restricted to the last line,
	     * so check from the start of the anchor.  -FM
	     */
	    i = a->extent;
	}
	k = j = (last->size - i);
	while (j < (int) last->size) {
	    if (!IsSpecialAttrChar(last->data[j]) &&
		!isspace(UCH(last->data[j])) &&
		last->data[j] != HT_NON_BREAK_SPACE &&
		last->data[j] != HT_EN_SPACE)
		break;
	    i--;
	    j++;
	}
	if (i == 0) {
	    if (a->extent > (int) last->size) {
		/*
		 * The anchor starts on a preceding line, and
		 * the last line has only white and special
		 * characters, so declare the entire extent
		 * of the last line as blank.  -FM
		 */
		CurBlankExtent = BlankExtent = last->size;
	    } else {
		/*
		 * The anchor starts on the last line, and
		 * has only white or special characters, so
		 * declare the anchor's extent as blank.  -FM
		 */
		CurBlankExtent = BlankExtent = a->extent;
	    }
	}
	/*
	 * While the anchor starts on a line preceding
	 * the one we just checked, and the one we just
	 * checked has only white and special characters,
	 * check whether the anchor's content on the
	 * immediately preceding line also has only
	 * white and special characters.  -FM
	 */
	while (i == 0 &&
	       (a->extent > CurBlankExtent ||
		(a->extent == CurBlankExtent &&
		 k == 0 &&
		 prev != text->last_line &&
		 (prev->size == 0 ||
		  prev->data[prev->size - 1] == ']')))) {
	    start = prev;
	    k = j = prev->size - a->extent + CurBlankExtent;
	    if (j < 0) {
		/*
		 * The anchor starts on a preceding line,
		 * so check all of this line.  -FM
		 */
		j = 0;
		i = prev->size;
	    } else {
		/*
		 * The anchor starts on this line.  -FM
		 */
		i = a->extent - CurBlankExtent;
	    }
	    while (j < (int) prev->size) {
		if (!IsSpecialAttrChar(prev->data[j]) &&
		    !isspace(UCH(prev->data[j])) &&
		    prev->data[j] != HT_NON_BREAK_SPACE &&
		    prev->data[j] != HT_EN_SPACE)
		    break;
		i--;
		j++;
	    }
	    if (i == 0) {
		if (a->extent > (CurBlankExtent + (int) prev->size) ||
		    (a->extent == CurBlankExtent + (int) prev->size &&
		     k == 0 &&
		     prev->prev != text->last_line &&
		     (prev->prev->size == 0 ||
		      prev->prev->data[prev->prev->size - 1] == ']'))) {
		    /*
		     * This line has only white and special
		     * characters, so treat its entire extent
		     * as blank, and decrement the pointer for
		     * the line to be analyzed.  -FM
		     */
		    CurBlankExtent += prev->size;
		    BlankExtent = CurBlankExtent;
		    prev = prev->prev;
		} else {
		    /*
		     * The anchor starts on this line, and it
		     * has only white or special characters, so
		     * declare the anchor's extent as blank.  -FM
		     */
		    BlankExtent = a->extent;
		    break;
		}
	    }
	}
	if (!really) {		/* Just report whether it is empty */
	    a->extent -= extent_adjust;
	    return (BOOL) (i == 0);
	}
	if (i == 0) {
	    /*
	     * It's an invisible anchor probably from an ALT=""
	     * or an ignored ISMAP attribute due to a companion
	     * USEMAP.  -FM
	     */
	    a->show_anchor = NO;

	    CTRACE((tfp,
		    "HText_endAnchor0: hidden (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
		    a->line_num, a->line_pos, a->extent,
		    BlankExtent));

	    /*
	     * If links are numbered, then try to get rid of the
	     * numbered bracket and adjust the anchor count.  -FM
	     *
	     * Well, let's do this only if -hiddenlinks=merged is not in
	     * effect, or if we can be reasonably sure that
	     * this is the result of an intentional non-generation of
	     * anchor text via NO_ISMAP_IF_USEMAP.  In other cases it can
	     * actually be a feature that numbered links alert the viewer
	     * to the presence of a link which is otherwise not selectable -
	     * possibly caused by HTML errors. - kw
	     */
	    if (remove_numbers_on_empty) {
		int NumSize = 0;
		TextAnchor *anc;

		/*
		 * Set start->data[j] to the close-square-bracket,
		 * or to the beginning of the line on which the
		 * anchor start.  -FM
		 */
		if (start == last) {
		    /*
		     * The anchor starts on the last line.  -FM
		     */
		    j = (last->size - a->extent - 1);
		} else {
		    /*
		     * The anchor starts on a previous line.  -FM
		     */
		    prev = start->prev;
		    j = (start->size - a->extent + CurBlankExtent - 1);
		}
		if (j < 0)
		    j = 0;
		i = j;

		/*
		 * If start->data[j] is a close-square-bracket, verify
		 * that it's the end of the numbered bracket, and if so,
		 * strip the numbered bracket.  If start->data[j] is not
		 * a close-square-bracket, check whether we had a wrap
		 * and the close-square-bracket is at the end of the
		 * previous line.  If so, strip the numbered bracket
		 * from that line.  -FM
		 */
		if (start->data[j] == ']') {
		    j--;
		    NumSize++;
		    while (j >= 0 && isdigit(UCH(start->data[j]))) {
			j--;
			NumSize++;
		    }
		    while (j < 0) {
			j++;
			NumSize--;
		    }
		    if (start->data[j] == '[') {
			/*
			 * The numbered bracket is entirely
			 * on this line.  -FM
			 */
			NumSize++;
			if (start == last && (int) text->permissible_split > j) {
			    if ((int) text->permissible_split - NumSize < j)
				text->permissible_split = j;
			    else
				text->permissible_split -= NumSize;
			}
			k = j + NumSize;
			while (k < (int) start->size)
			    start->data[j++] = start->data[k++];
			for (anc = a; anc; anc = anc->next) {
			    if (anc->line_num == a->line_num &&
				anc->line_pos >= NumSize) {
				anc->line_pos -= NumSize;
			    }
			}
			start->size = j;
			start->data[j++] = '\0';
			while (j < k)
			    start->data[j++] = '\0';
		    } else if (prev && prev->size > 1) {
			k = (i + 1);
			j = (prev->size - 1);
			while ((j >= 0) && IsSpecialAttrChar(prev->data[j]))
			    j--;
			i = (j + 1);
			while (j >= 0 &&
			       isdigit(UCH(prev->data[j]))) {
			    j--;
			    NumSize++;
			}
			while (j < 0) {
			    j++;
			    NumSize--;
			}
			if (prev->data[j] == '[') {
			    /*
			     * The numbered bracket started on the
			     * previous line, and part of it was
			     * wrapped to this line.  -FM
			     */
			    NumSize++;
			    l = (i - j);
			    while (i < (int) prev->size)
				prev->data[j++] = prev->data[i++];
			    prev->size = j;
			    prev->data[j] = '\0';
			    while (j < i)
				prev->data[j++] = '\0';
			    if (start == last && text->permissible_split > 0) {
				if ((int) text->permissible_split < k)
				    text->permissible_split = 0;
				else
				    text->permissible_split -= k;
			    }
			    j = 0;
			    i = k;
			    while (k < (int) start->size)
				start->data[j++] = start->data[k++];
			    for (anc = a; anc; anc = anc->next) {
				if (anc->line_num == a->line_num &&
				    anc->line_pos >= i) {
				    anc->line_pos -= i;
				}
			    }
			    start->size = j;
			    start->data[j++] = '\0';
			    while (j < k)
				start->data[j++] = '\0';
			} else {
			    /*
			     * Shucks!  We didn't find the
			     * numbered bracket.  -FM
			     */
			    a->show_anchor = YES;
			}
		    } else {
			/*
			 * Shucks!  We didn't find the
			 * numbered bracket.  -FM
			 */
			a->show_anchor = YES;
		    }
		} else if (prev && prev->size > 2) {
		    j = (prev->size - 1);
		    while ((j >= 0) && IsSpecialAttrChar(prev->data[j]))
			j--;
		    if (j < 0)
			j = 0;
		    i = (j + 1);
		    if ((j >= 2) &&
			(prev->data[j] == ']' &&
			 isdigit(UCH(prev->data[j - 1])))) {
			j--;
			NumSize++;
			k = (j + 1);
			while (j >= 0 &&
			       isdigit(UCH(prev->data[j]))) {
			    j--;
			    NumSize++;
			}
			while (j < 0) {
			    j++;
			    NumSize--;
			}
			if (prev->data[j] == '[') {
			    /*
			     * The numbered bracket is all on the
			     * previous line, and the anchor content
			     * was wrapped to the last line.  -FM
			     */
			    NumSize++;
			    k = j + NumSize;
			    while (k < (int) prev->size)
				prev->data[j++] = prev->data[k++];
			    prev->size = j;
			    prev->data[j++] = '\0';
			    while (j < k)
				prev->data[j++] = '\0';
			} else {
			    /*
			     * Shucks!  We didn't find the
			     * numbered bracket.  -FM
			     */
			    a->show_anchor = YES;
			}
		    } else {
			/*
			 * Shucks!  We didn't find the
			 * numbered bracket.  -FM
			 */
			a->show_anchor = YES;
		    }
		} else {
		    /*
		     * Shucks!  We didn't find the
		     * numbered bracket.  -FM
		     */
		    a->show_anchor = YES;
		}
	    }
	} else {
	    if (!number_links_on_left)
		add_link_number(text, a, FALSE);
	    /*
	     * The anchor's content is not restricted to only
	     * white and special characters, so we'll show it
	     * as a link.  -FM
	     */
	    a->show_anchor = YES;
	    if (BlankExtent) {
		CTRACE((tfp,
			"HText_endAnchor0: blanks (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
			a->line_num, a->line_pos, a->extent,
			BlankExtent));
	    }
	}
	if (a->show_anchor == NO) {
	    /*
	     * The anchor's content is restricted to white
	     * and special characters, so set its number
	     * and extent to zero, decrement the visible
	     * anchor number counter, and add this anchor
	     * to the hidden links list.  -FM
	     */
	    a->extent = 0;
	    if (text->hiddenlinkflag != HIDDENLINKS_MERGE) {
		a->number = 0;
		text->last_anchor_number--;
		HText_AddHiddenLink(text, a);
	    }
	} else {
	    /*
	     * The anchor's content is not restricted to white
	     * and special characters, so we'll display the
	     * content, but shorten its extent by any trailing
	     * blank lines we've detected.  -FM
	     */
	    a->extent -= ((BlankExtent < a->extent) ?
			  BlankExtent : 0);
	}
	if (BlankExtent || a->extent <= 0 || a->number <= 0) {
	    CTRACE((tfp,
		    "->[%d](%d,%d,%d,%d)\n",
		    a->number,
		    a->line_num, a->line_pos, a->extent,
		    BlankExtent));
	}
    } else {
	if (!really)		/* Just report whether it is empty */
	    return FALSE;
	/*
	 * It's a named anchor without an HREF, so it
	 * should be registered but not shown as a
	 * link.  -FM
	 */
	a->show_anchor = NO;
	a->extent = 0;
    }
    return FALSE;
}

void HText_endAnchor(HText *text, int number)
{
    HText_endAnchor0(text, number, 1);
}

/*
    This returns whether the given anchor has blank content. Shamelessly copied
    from HText_endAnchor. The values returned are meaningful only for "normal"
    links - like ones produced by <a href=".">foo</a>, no inputs, etc. - VH
*/
#ifdef MARK_HIDDEN_LINKS
BOOL HText_isAnchorBlank(HText *text, int number)
{
    return HText_endAnchor0(text, number, 0);
}
#endif /* MARK_HIDDEN_LINKS */

void HText_appendText(HText *text, const char *str)
{
    const char *p;

    if (str == NULL)
	return;

    if (text->halted == 3)
	return;

    for (p = str; *p; p++) {
	HText_appendCharacter(text, *p);
    }
}

static int remove_special_attr_chars(char *buf)
{
    register char *cp;
    register int soft_newline_count = 0;

    for (cp = buf; *cp != '\0'; cp++) {
	/*
	 * Don't print underline chars.
	 */
	soft_newline_count += (*cp == LY_SOFT_NEWLINE);
	if (!IsSpecialAttrChar(*cp)) {
	    *buf++ = *cp;
	}
    }
    *buf = '\0';
    return soft_newline_count;
}

/*
 *  This function trims blank lines from the end of the document, and
 *  then gets the hightext from the text by finding the char position,
 *  and brings the anchors in line with the text by adding the text
 *  offset to each of the anchors.
 */
void HText_endAppend(HText *text)
{
    HTLine *line_ptr;

    if (!text)
	return;

    CTRACE((tfp, "GridText: Entering HText_endAppend\n"));

    /*
     * Create a blank line at the bottom.
     */
    new_line(text);

    if (text->halted) {
	if (text->stbl)
	    HText_cancelStbl(text);
	/*
	 * If output was stopped because memory was low, and we made
	 * it to the end of the document, reset those flags and hope
	 * things are better now.  - kw
	 */
	LYFakeZap(NO);
	text->halted = 0;
    } else if (text->stbl) {
	/*
	 * Could happen if TABLE end tag was missing.
	 * Alternatively we could cancel in this case.  - kw
	 */
	HText_endStblTABLE(text);
    }

    /*
     * Get the first line.
     */
    line_ptr = FirstHTLine(text);

    /*
     * Remove the blank lines at the end of document.
     */
    while (text->last_line->data[0] == '\0' && text->Lines > 2) {
	HTLine *next_to_the_last_line = text->last_line->prev;

	CTRACE((tfp, "GridText: Removing bottom blank line: `%s'\n",
		text->last_line->data));
	/*
	 * line_ptr points to the first line.
	 */
	next_to_the_last_line->next = line_ptr;
	line_ptr->prev = next_to_the_last_line;
	freeHTLine(text, text->last_line);
	text->last_line = next_to_the_last_line;
	text->Lines--;
	CTRACE((tfp, "GridText: New bottom line: `%s'\n",
		text->last_line->data));
    }

    /*
     * Fix up the anchor structure values and
     * create the hightext strings.  -FM
     */
    HText_trimHightext(text, TRUE, -1);
}

/*
 *  This function gets the hightext from the text by finding the char
 *  position, and brings the anchors in line with the text by adding the text
 *  offset to each of the anchors.
 *
 *  `Forms input' fields cannot be displayed properly without this function
 *  to be invoked (detected in display_partial mode).
 *
 *  If final is set, this is the final fixup; if not set, we don't have
 *  to do everything because there should be another call later.
 *
 *  BEFORE this function has treated a TextAnchor, its line_pos and
 *  extent fields are counting bytes in the HTLine data, including
 *  invisible special attribute chars and counting UTF-8 multibyte
 *  characters as multiple bytes.
 *
 *  AFTER the adjustment, the anchor line_pos (and hightext offset if
 *  applicable) fields indicate x positions in terms of displayed character
 *  cells, and the extent field apparently is unimportant; the anchor text has
 *  been copied to the hightext fields (which should have been NULL up to that
 *  point), with special attribute chars removed.
 *
 *  This needs to be done so that display_page finds the anchors in the
 *  form it expects when it sets the links[] elements.
 */
static void HText_trimHightext(HText *text, BOOLEAN final,
			       int stop_before)
{
    int cur_line, cur_shift;
    TextAnchor *anchor_ptr;
    TextAnchor *prev_a = NULL;
    HTLine *line_ptr;
    HTLine *line_ptr2;
    unsigned char ch;
    char *hilite_str;
    int hilite_len;
    int actual_len;
    int count_line;

    if (!text)
	return;

    if (final) {
	CTRACE((tfp, "GridText: Entering HText_trimHightext (final)\n"));
    } else {
	if (stop_before < 0 || stop_before > text->Lines)
	    stop_before = text->Lines;
	CTRACE((tfp,
		"GridText: Entering HText_trimHightext (partial: 0..%d/%d)\n",
		stop_before, text->Lines));
    }

    /*
     * Get the first line.
     */
    line_ptr = FirstHTLine(text);
    cur_line = 0;

    /*
     * Fix up the anchor structure values and
     * create the hightext strings.  -FM
     */
    for (anchor_ptr = text->first_anchor;
	 anchor_ptr != NULL;
	 prev_a = anchor_ptr, anchor_ptr = anchor_ptr->next) {
	int anchor_col;

      re_parse:
	/*
	 * Find the right line.
	 */
	for (; anchor_ptr->line_num > cur_line;
	     line_ptr = line_ptr->next, cur_line++) {
	    ;			/* null body */
	}

	if (!final) {
	    /*
	     * If this is not the final call, stop when we have reached
	     * the last line, or the very end of preceding line.
	     * The last line is probably still not finished.  - kw
	     */
	    if (cur_line >= stop_before)
		break;
	    if (anchor_ptr->line_num >= text->Lines - 1
		&& anchor_ptr->line_pos >= (int) text->last_line->prev->size)
		break;
	    /*
	     * Also skip this anchor if it looks like HText_endAnchor
	     * is not yet done with it.  - kw
	     */
	    if (!anchor_ptr->extent && anchor_ptr->number &&
		(anchor_ptr->link_type & HYPERTEXT_ANCHOR) &&
		!anchor_ptr->show_anchor &&
		anchor_ptr->number == text->last_anchor_number)
		continue;
	}

	/*
	 * If hightext has already been set, then we must have already
	 * done the trimming & adjusting for this anchor, so avoid
	 * doing it a second time.  - kw
	 */
	if (LYGetHiTextStr(anchor_ptr, 0) != NULL)
	    continue;

	if (anchor_ptr->line_pos > (int) line_ptr->size) {
	    anchor_ptr->line_pos = line_ptr->size;
	}
	if (anchor_ptr->line_pos < 0) {
	    anchor_ptr->line_pos = 0;
	    anchor_ptr->line_num = cur_line;
	}
	CTRACE((tfp,
		"GridText: Anchor found on line:%d col:%d [%d] ext:%d\n",
		cur_line, anchor_ptr->line_pos,
		anchor_ptr->number, anchor_ptr->extent));

	cur_shift = 0;
	/*
	 * Strip off any spaces or SpecialAttrChars at the beginning,
	 * if they exist, but only on HYPERTEXT_ANCHORS.
	 */
	if (anchor_ptr->link_type & HYPERTEXT_ANCHOR) {
	    ch = UCH(line_ptr->data[anchor_ptr->line_pos]);
	    while (isspace(ch) ||
		   IsSpecialAttrChar(ch)) {
		anchor_ptr->line_pos++;
		anchor_ptr->extent--;
		cur_shift++;
		ch = UCH(line_ptr->data[anchor_ptr->line_pos]);
	    }
	}
	if (anchor_ptr->extent < 0) {
	    anchor_ptr->extent = 0;
	}

	CTRACE((tfp, "anchor text: '%s'\n", line_ptr->data));
	/*
	 * If the link begins with an end of line and we have more lines, then
	 * start the highlighting on the next line.  -FM.
	 *
	 * But if an empty anchor is at the end of line and empty, keep it
	 * where it is, unless the previous anchor in the list (if any) already
	 * starts later.  - kw
	 */
	if ((unsigned) anchor_ptr->line_pos >= strlen(line_ptr->data)) {
	    if (cur_line < text->Lines &&
		(anchor_ptr->extent ||
		 anchor_ptr->line_pos != (int) line_ptr->size ||
		 (prev_a &&	/* How could this happen? */
		  (prev_a->line_num > anchor_ptr->line_num)))) {
		anchor_ptr->line_num++;
		anchor_ptr->line_pos = 0;
		CTRACE((tfp, "found anchor at end of line\n"));
		goto re_parse;
	    } else {
		CTRACE((tfp, "found anchor at end of line, leaving it there\n"));
	    }
	}

	/*
	 * Copy the link name into the data structure.
	 */
	if (line_ptr->data
	    && anchor_ptr->extent > 0
	    && anchor_ptr->line_pos >= 0) {
	    int size = (int) line_ptr->size - anchor_ptr->line_pos;

	    if (size > anchor_ptr->extent)
		size = anchor_ptr->extent;
	    LYClearHiText(anchor_ptr);
	    LYSetHiText(anchor_ptr,
			&line_ptr->data[anchor_ptr->line_pos],
			size);
	} else {
	    LYClearHiText(anchor_ptr);
	    LYSetHiText(anchor_ptr, "", 0);
	}

	/*
	 * If the anchor extends over more than one line, copy that into the
	 * data structure.
	 */
	hilite_str = LYGetHiTextStr(anchor_ptr, 0);
	hilite_len = strlen(hilite_str);
	actual_len = anchor_ptr->extent;

	line_ptr2 = line_ptr;
	count_line = cur_line;
	while (actual_len > hilite_len) {
	    HTLine *old_line_ptr2 = line_ptr2;

	    count_line++;
	    line_ptr2 = line_ptr2->next;

	    if (!final
		&& count_line >= stop_before) {
		LYClearHiText(anchor_ptr);
		break;
	    } else if (old_line_ptr2 == text->last_line) {
		break;
	    }

	    /*
	     * Double check that we have a line pointer, and if so, copy into
	     * highlight text.
	     */
	    if (line_ptr2
		&& line_ptr2->size) {
		char *hi_string = NULL;
		int hi_offset = line_ptr2->offset;

		StrnAllocCopy(hi_string,
			      line_ptr2->data,
			      (actual_len - hilite_len));
		actual_len -= strlen(hi_string);
		/*handle LY_SOFT_NEWLINEs -VH */
		hi_offset += remove_special_attr_chars(hi_string);

		if (anchor_ptr->link_type & HYPERTEXT_ANCHOR) {
		    LYTrimTrailing(hi_string);
		}
		if (non_empty(hi_string)) {
		    LYAddHiText(anchor_ptr, hi_string, hi_offset);
		} else if (actual_len > hilite_len) {
		    LYAddHiText(anchor_ptr, "", hi_offset);
		}
		FREE(hi_string);
	    }
	}

	if (!final
	    && count_line >= stop_before) {
	    break;
	}

	hilite_str = LYGetHiTextStr(anchor_ptr, 0);
	remove_special_attr_chars(hilite_str);
	if (anchor_ptr->link_type & HYPERTEXT_ANCHOR) {
	    LYTrimTrailing(hilite_str);
	}

	/*
	 * Save the offset (bytes) of the anchor in the line's data.
	 */
	anchor_col = anchor_ptr->line_pos;

	/*
	 * Subtract any formatting characters from the x position of the link.
	 */
#ifdef WIDEC_CURSES
	if (anchor_ptr->line_pos > 0) {
	    /*
	     * LYstrExtent filters out the formatting characters, so we do not
	     * have to count them here.
	     *
	     * FIXME: do we have to count soft-newlines?
	     */
	    anchor_ptr->line_pos = LYstrExtent2(line_ptr->data, anchor_col);
	}
#else /* 8-bit curses, etc.  */
	if (anchor_ptr->line_pos > 0) {
	    register int offset = 0, i = 0;
	    int have_soft_newline_in_1st_line = 0;

	    for (; i < anchor_col; i++) {
		if (IS_UTF_EXTRA(line_ptr->data[i]) ||
		    IsSpecialAttrChar(line_ptr->data[i])) {
		    offset++;
		    have_soft_newline_in_1st_line += (line_ptr->data[i] == LY_SOFT_NEWLINE);
		}
	    }
	    anchor_ptr->line_pos -= offset;
	    /*handle LY_SOFT_NEWLINEs -VH */
	    anchor_ptr->line_pos += have_soft_newline_in_1st_line;
	}
#endif /* WIDEC_CURSES */

	/*
	 * Set the line number.
	 */
	anchor_ptr->line_pos += line_ptr->offset;
	anchor_ptr->line_num = cur_line;

	CTRACE((tfp, "GridText:     add link on line %d col %d [%d] %s\n",
		cur_line, anchor_ptr->line_pos,
		anchor_ptr->number, "in HText_trimHightext"));
    }
}

/*	Return the anchor associated with this node
*/
HTParentAnchor *HText_nodeAnchor(HText *text)
{
    return text->node_anchor;
}

/*				GridText specials
 *				=================
 */

/*
 * HText_childNextNumber() returns the anchor with index [number],
 * using a pointer from the previous number (=optimization) or NULL.
 */
HTChildAnchor *HText_childNextNumber(int number, void **prev)
{
    /* Sorry, TextAnchor is not declared outside this file, use a cast. */
    TextAnchor *a = (TextAnchor *) *prev;

    if (!HTMainText || number <= 0)
	return (HTChildAnchor *) 0;	/* Fail */
    if (number == 1 || !a)
	a = HTMainText->first_anchor;

    /* a strange thing:  positive a->number's are sorted,
     * and between them several a->number's may be 0 -- skip them
     */
    for (; a && a->number != number; a = a->next) ;

    if (!a)
	return (HTChildAnchor *) 0;	/* Fail */
    *prev = (void *) a;
    return a->anchor;
}

/*
 * HText_FormDescNumber() returns a description of the form field
 * with index N.  The index corresponds to the [number] we print
 * for the field.  -FM & LE
 */
void HText_FormDescNumber(int number,
			  const char **desc)
{
    TextAnchor *a;

    if (!desc)
	return;

    if (!(HTMainText && HTMainText->first_anchor) || number <= 0) {
	*desc = gettext("unknown field or link");
	return;
    }

    for (a = HTMainText->first_anchor; a; a = a->next) {
	if (a->number == number) {
	    if (!(a->input_field && a->input_field->type)) {
		*desc = gettext("unknown field or link");
		return;
	    }
	    break;
	}
    }

    switch (a->input_field->type) {
    case F_TEXT_TYPE:
	*desc = gettext("text entry field");
	return;
    case F_PASSWORD_TYPE:
	*desc = gettext("password entry field");
	return;
    case F_CHECKBOX_TYPE:
	*desc = gettext("checkbox");
	return;
    case F_RADIO_TYPE:
	*desc = gettext("radio button");
	return;
    case F_SUBMIT_TYPE:
	*desc = gettext("submit button");
	return;
    case F_RESET_TYPE:
	*desc = gettext("reset button");
	return;
    case F_OPTION_LIST_TYPE:
	*desc = gettext("popup menu");
	return;
    case F_HIDDEN_TYPE:
	*desc = gettext("hidden form field");
	return;
    case F_TEXTAREA_TYPE:
	*desc = gettext("text entry area");
	return;
    case F_RANGE_TYPE:
	*desc = gettext("range entry field");
	return;
    case F_FILE_TYPE:
	*desc = gettext("file entry field");
	return;
    case F_TEXT_SUBMIT_TYPE:
	*desc = gettext("text-submit field");
	return;
    case F_IMAGE_SUBMIT_TYPE:
	*desc = gettext("image-submit button");
	return;
    case F_KEYGEN_TYPE:
	*desc = gettext("keygen field");
	return;
    default:
	*desc = gettext("unknown form field");
	return;
    }
}

/* HTGetRelLinkNum returns the anchor number to which follow_link_number()
 * is to jump (input was 123+ or 123- or 123+g or 123-g or 123 or 123g)
 * num is the number specified
 * rel is 0 or '+' or '-'
 * cur is the current link
 */
int HTGetRelLinkNum(int num,
		    int rel,
		    int cur)
{
    TextAnchor *a, *l = 0;
    int scrtop = HText_getTopOfScreen();	/*XXX +1? */
    int curline = links[cur].anchor_line_num;
    int curpos = links[cur].lx;
    int on_screen = (curline >= scrtop && curline < (scrtop + display_lines));

    /* curanchor may or may not be the "current link", depending whether it's
     * on the current screen
     */
    int curanchor = links[cur].anchor_number;

    CTRACE((tfp, "HTGetRelLinkNum(%d,%d,%d) -- HTMainText=%p\n",
	    num, rel, cur, HTMainText));
    CTRACE((tfp,
	    "  scrtop=%d, curline=%d, curanchor=%d, display_lines=%d, %s\n",
	    scrtop, curline, curanchor, display_lines,
	    on_screen ? "on_screen" : "0"));
    if (!HTMainText)
	return 0;
    if (rel == 0)
	return num;

    /* if cur numbered link is on current page, use it */
    if (on_screen && curanchor) {
	CTRACE((tfp, "curanchor=%d at line %d on screen\n", curanchor, curline));
	if (rel == '+')
	    return curanchor + num;
	else if (rel == '-')
	    return curanchor - num;
	else
	    return num;		/* shouldn't happen */
    }

    /* no current link on screen, or current link is not numbered
     * -- find previous closest numbered link
     */
    for (a = HTMainText->first_anchor; a; a = a->next) {
	CTRACE((tfp, "  a->line_num=%d, a->number=%d\n", a->line_num, a->number));
	if (a->line_num >= scrtop)
	    break;
	if (a->number == 0)
	    continue;
	l = a;
	curanchor = l->number;
    }
    CTRACE((tfp, "  a=%p, l=%p, curanchor=%d\n", a, l, curanchor));
    if (on_screen) {		/* on screen but not a numbered link */
	for (; a; a = a->next) {
	    if (a->number) {
		l = a;
		curanchor = l->number;
	    }
	    if (curline == a->line_num && curpos == a->line_pos)
		break;
	}
    }
    if (rel == '+') {
	return curanchor + num;
    } else if (rel == '-') {
	if (l)
	    return curanchor + 1 - num;
	else {
	    for (; a && a->number == 0; a = a->next) ;
	    return a ? a->number - num : 0;
	}
    } else
	return num;		/* shouldn't happen */
}

/*
 * HTGetLinkInfo returns some link info based on the number.
 *
 * If want_go is not 0, caller requests to know a line number for
 * the link indicated by number.  It will be returned in *go_line, and
 * *linknum will be set to an index into the links[] array, to use after
 * the line in *go_line has been made the new top screen line.
 * *hightext and *lname are unchanged.  - KW
 *
 * If want_go is 0 and the number doesn't represent an input field, info
 * on the link indicated by number is deposited in *hightext and *lname.
 */
int HTGetLinkInfo(int number,
		  int want_go,
		  int *go_line,
		  int *linknum,
		  char **hightext,
		  char **lname)
{
    TextAnchor *a;
    HTAnchor *link_dest;

#ifndef DONT_TRACK_INTERNAL_LINKS
    HTAnchor *link_dest_intl = NULL;
#endif
    int anchors_this_line = 0, anchors_this_screen = 0;
    int prev_anchor_line = -1, prev_prev_anchor_line = -1;

    if (!HTMainText)
	return (NO);

    for (a = HTMainText->first_anchor; a; a = a->next) {
	/*
	 * Count anchors, first on current line if there is more
	 * than one.  We have to count all links, including form
	 * field anchors and others with a->number == 0, because
	 * they are or will be included in the links[] array.
	 * The exceptions are hidden form fields and anchors with
	 * show_anchor not set, because they won't appear in links[]
	 * and don't count towards nlinks.  - KW
	 */
	if ((a->show_anchor) &&
	    !(a->link_type == INPUT_ANCHOR
	      && a->input_field->type == F_HIDDEN_TYPE)) {
	    if (a->line_num == prev_anchor_line) {
		anchors_this_line++;
	    } else {
		/*
		 * This anchor is on a different line than the previous one.
		 * Remember which was the line number of the previous anchor,
		 * for use in screen positioning later.  - KW
		 */
		anchors_this_line = 1;
		prev_prev_anchor_line = prev_anchor_line;
		prev_anchor_line = a->line_num;
	    }
	    if (a->line_num >= HTMainText->top_of_screen) {
		/*
		 * Count all anchors starting with the top line of the
		 * currently displayed screen.  Just keep on counting
		 * beyond this screen's bottom line - we'll know whether
		 * a found anchor is below the current screen by a check
		 * against nlinks later.  - KW
		 */
		anchors_this_screen++;
	    }
	}

	if (a->number == number) {
	    /*
	     * We found it.  Now process it, depending
	     * on what kind of info is requested.  - KW
	     */
	    if (want_go || a->link_type == INPUT_ANCHOR) {
		if (a->show_anchor == NO) {
		    /*
		     * The number requested has been assigned to an anchor
		     * without any selectable text, so we cannot position
		     * on it.  The code for suppressing such anchors in
		     * HText_endAnchor() may not have applied, or it may
		     * have failed.  Return a failure indication so that
		     * the user will notice that something is wrong,
		     * instead of positioning on some other anchor which
		     * might result in inadvertent activation.  - KW
		     */
		    return (NO);
		}
		if (anchors_this_screen > 0 &&
		    anchors_this_screen <= nlinks &&
		    a->line_num >= HTMainText->top_of_screen &&
		    a->line_num < HTMainText->top_of_screen + (display_lines)) {
		    /*
		     * If the requested anchor is within the current screen,
		     * just set *go_line so that the screen window won't move
		     * (keep it as it is), and set *linknum to the index of
		     * this link in the current links[] array.  - KW
		     */
		    *go_line = HTMainText->top_of_screen;
		    if (linknum)
			*linknum = anchors_this_screen - 1;
		} else {
		    /*
		     * if the requested anchor is not within the currently
		     * displayed screen, set *go_line such that the top line
		     * will be either
		     *  (1) the line immediately below the previous
		     *      anchor, or
		     *  (2) about one third of a screenful above the line
		     *      with the target, or
		     *  (3) the first line of the document -
		     * whichever comes last.  In all cases the line with our
		     * target will end up being the first line with any links
		     * on the new screen, so that we can use the
		     * anchors_this_line counter to point to the anchor in
		     * the new links[] array.  - kw
		     */
		    int max_offset = SEARCH_GOAL_LINE - 1;

		    if (max_offset < 0)
			max_offset = 0;
		    else if (max_offset >= display_lines)
			max_offset = display_lines - 1;
		    *go_line = prev_anchor_line - max_offset;
		    if (*go_line <= prev_prev_anchor_line)
			*go_line = prev_prev_anchor_line + 1;
		    if (*go_line < 0)
			*go_line = 0;
		    if (linknum)
			*linknum = anchors_this_line - 1;
		}
		return (LINK_LINE_FOUND);
	    } else {
		*hightext = LYGetHiTextStr(a, 0);
		link_dest = HTAnchor_followLink(a->anchor);
		{
		    char *cp_freeme = NULL;

		    if (traversal) {
			cp_freeme = stub_HTAnchor_address(link_dest);
		    } else {
#ifndef DONT_TRACK_INTERNAL_LINKS
			if (a->link_type == INTERNAL_LINK_ANCHOR) {
			    link_dest_intl =
				HTAnchor_followTypedLink(a->anchor, HTInternalLink);
			    if (link_dest_intl && link_dest_intl != link_dest) {

				CTRACE((tfp,
					"HTGetLinkInfo: unexpected typed link to %s!\n",
					link_dest_intl->parent->address));
				link_dest_intl = NULL;
			    }
			}
			if (link_dest_intl) {
			    char *cp2 = HTAnchor_address(link_dest_intl);

			    FREE(*lname);
			    *lname = cp2;
			    return (WWW_INTERN_LINK_TYPE);
			} else
#endif
			    cp_freeme = HTAnchor_address(link_dest);
		    }
		    StrAllocCopy(*lname, cp_freeme);
		    FREE(cp_freeme);
		}
		return (WWW_LINK_TYPE);
	    }
	}
    }
    return (NO);
}

static BOOLEAN same_anchor_or_field(int numberA,
				    FormInfo * formA,
				    int numberB,
				    FormInfo * formB,
				    BOOLEAN ta_same)
{
    if (numberA > 0 || numberB > 0) {
	if (numberA == numberB)
	    return (YES);
	else if (!ta_same)
	    return (NO);
    }
    if (formA || formB) {
	if (formA == formB) {
	    return (YES);
	} else if (!ta_same) {
	    return (NO);
	} else if (!(formA && formB)) {
	    return (NO);
	}
    } else {
	return (NO);
    }
    if (formA->type != formB->type ||
	formA->type != F_TEXTAREA_TYPE ||
	formB->type != F_TEXTAREA_TYPE) {
	return (NO);
    }
    if (formA->number != formB->number)
	return (NO);
    if (!formA->name || !formB->name)
	return (YES);
    return (BOOL) (strcmp(formA->name, formB->name) == 0);
}

#define same_anchor_as_link(i,a,ta_same) (i >= 0 && a &&\
		same_anchor_or_field(links[i].anchor_number,\
		(links[i].type == WWW_FORM_LINK_TYPE) ? links[i].l_form : NULL,\
		a->number,\
		(a->link_type == INPUT_ANCHOR) ? a->input_field : NULL,\
		ta_same))
#define same_anchors(a1,a2,ta_same) (a1 && a2 &&\
		same_anchor_or_field(a1->number,\
		(a1->link_type == INPUT_ANCHOR) ? a1->input_field : NULL,\
		a2->number,\
		(a2->link_type == INPUT_ANCHOR) ? a2->input_field : NULL,\
		ta_same))

/*
 * Are there more textarea lines belonging to the same textarea before
 * (direction < 0) or after (direction > 0) the current one?
 * On entry, curlink must be the index in links[] of a textarea field.  - kw
 */
BOOL HText_TAHasMoreLines(int curlink,
			  int direction)
{
    TextAnchor *a;
    TextAnchor *prev_a = NULL;

    if (!HTMainText)
	return (NO);
    if (direction < 0) {
	for (a = HTMainText->first_anchor; a; prev_a = a, a = a->next) {
	    if (a->link_type == INPUT_ANCHOR &&
		links[curlink].l_form == a->input_field) {
		return same_anchors(a, prev_a, TRUE);
	    }
	    if (links[curlink].anchor_number &&
		a->number >= links[curlink].anchor_number)
		break;
	}
	return NO;
    } else {
	for (a = HTMainText->first_anchor; a; a = a->next) {
	    if (a->link_type == INPUT_ANCHOR &&
		links[curlink].l_form == a->input_field) {
		return same_anchors(a, a->next, TRUE);
	    }
	    if (links[curlink].anchor_number &&
		a->number >= links[curlink].anchor_number)
		break;
	}
	return NO;
    }
}

/*
 * HTGetLinkOrFieldStart - moving to previous or next link or form field.
 *
 * On input,
 *	curlink: current link, as index in links[] array (-1 if none)
 *	direction: whether to move up or down (or stay where we are)
 *	ta_skip: if FALSE, input fields belonging to the same textarea are
 *		 are treated as different fields, as usual;
 *		 if TRUE, fields of the same textarea are treated as a
 *		 group for skipping.
 * The caller wants a information for positioning on the new link to be
 * deposited in *go_line and (if linknum is not NULL) *linknum.
 *
 * On failure (no more links in the requested direction) returns NO
 * and doesn't change *go_line or *linknum.  Otherwise, LINK_DO_ARROWUP
 * may be returned, and *go_line and *linknum not changed, to indicate that
 * the caller should use a normal PREV_LINK or PREV_PAGE mechanism.
 * Otherwise:
 * The number (0-based counting) for the new top screen line will be returned
 * in *go_line, and *linknum will be set to an index into the links[] array,
 * to use after the line in *go_line has been made the new top screen
 * line.  - kw
 */
int HTGetLinkOrFieldStart(int curlink,
			  int *go_line,
			  int *linknum,
			  int direction,
			  BOOLEAN ta_skip)
{
    TextAnchor *a;
    int anchors_this_line = 0;
    int prev_anchor_line = -1, prev_prev_anchor_line = -1;

    struct agroup {
	TextAnchor *anc;
	int prev_anchor_line;
	int anchors_this_line;
	int anchors_this_group;
    } previous, current;
    struct agroup *group_to_go = NULL;

    if (!HTMainText)
	return (NO);

    previous.anc = current.anc = NULL;
    previous.prev_anchor_line = current.prev_anchor_line = -1;
    previous.anchors_this_line = current.anchors_this_line = 0;
    previous.anchors_this_group = current.anchors_this_group = 0;

    for (a = HTMainText->first_anchor; a; a = a->next) {
	/*
	 * Count anchors, first on current line if there is more
	 * than one.  We have to count all links, including form
	 * field anchors and others with a->number == 0, because
	 * they are or will be included in the links[] array.
	 * The exceptions are hidden form fields and anchors with
	 * show_anchor not set, because they won't appear in links[]
	 * and don't count towards nlinks.  - KW
	 */
	if ((a->show_anchor) &&
	    !(a->link_type == INPUT_ANCHOR
	      && a->input_field->type == F_HIDDEN_TYPE)) {
	    if (a->line_num == prev_anchor_line) {
		anchors_this_line++;
	    } else {
		/*
		 * This anchor is on a different line than the previous one.
		 * Remember which was the line number of the previous anchor,
		 * for use in screen positioning later.  - KW
		 */
		anchors_this_line = 1;
		prev_prev_anchor_line = prev_anchor_line;
		prev_anchor_line = a->line_num;
	    }

	    if (!same_anchors(current.anc, a, ta_skip)) {
		previous.anc = current.anc;
		previous.prev_anchor_line = current.prev_anchor_line;
		previous.anchors_this_line = current.anchors_this_line;
		previous.anchors_this_group = current.anchors_this_group;
		current.anc = a;
		current.prev_anchor_line = prev_prev_anchor_line;
		current.anchors_this_line = anchors_this_line;
		current.anchors_this_group = 1;
	    } else {
		current.anchors_this_group++;
	    }
	    if (curlink >= 0) {
		if (same_anchor_as_link(curlink, a, ta_skip)) {
		    if (direction == -1) {
			group_to_go = &previous;
			break;
		    } else if (direction == 0) {
			group_to_go = &current;
			break;
		    }
		} else if (direction > 0 &&
			   same_anchor_as_link(curlink, previous.anc, ta_skip)) {
		    group_to_go = &current;
		    break;
		}
	    } else {
		if (a->line_num >= HTMainText->top_of_screen) {
		    if (direction < 0) {
			group_to_go = &previous;
			break;
		    } else if (direction == 0) {
			if (previous.anc) {
			    group_to_go = &previous;
			    break;
			} else {
			    group_to_go = &current;
			    break;
			}
		    } else {
			group_to_go = &current;
			break;
		    }
		}
	    }
	}
    }
    if (!group_to_go && curlink < 0 && direction <= 0) {
	group_to_go = &current;
    }
    if (group_to_go) {
	a = group_to_go->anc;
	if (a) {
	    int max_offset;

	    /*
	     * We know where to go; most of the stuff below is just
	     * tweaks to try to position the new screen in a specific
	     * way.
	     *
	     * In some cases going to a previous link can be done
	     * via the normal LYK_PREV_LINK action, which may give
	     * better positioning of the new screen.  - kw
	     */
	    if (a->line_num < HTMainText->top_of_screen &&
		a->line_num >= HTMainText->top_of_screen - (display_lines)) {
		if ((curlink < 0 &&
		     group_to_go->anchors_this_group == 1) ||
		    (direction < 0 &&
		     group_to_go != &current &&
		     current.anc &&
		     current.anc->line_num >= HTMainText->top_of_screen &&
		     group_to_go->anchors_this_group == 1) ||
		    (a->next &&
		     a->next->line_num >= HTMainText->top_of_screen)) {
		    return (LINK_DO_ARROWUP);
		}
	    }
	    /*
	     * The fundamental limitation of the current anchors_this_line
	     * counter method is that we only can set *linknum to the right
	     * index into the future links[] array if the line with our link
	     * ends up being the first line with any links (that count) on
	     * the new screen.  Subject to that restriction we still have
	     * some vertical liberty (sometimes), and try to make the best
	     * of it.  It may be a question of taste though.  - kw
	     */
	    if (a->line_num <= (display_lines)) {
		max_offset = 0;
	    } else if (a->line_num < HTMainText->top_of_screen) {
		int screensback =
		(HTMainText->top_of_screen - a->line_num + (display_lines) - 1)
		/ (display_lines);

		max_offset = a->line_num - (HTMainText->top_of_screen -
					    screensback * (display_lines));
	    } else if (HTMainText->Lines - a->line_num <= (display_lines)) {
		max_offset = a->line_num - (HTMainText->Lines + 1
					    - (display_lines));
	    } else if (a->line_num >=
		       HTMainText->top_of_screen + (display_lines)) {
		int screensahead =
		(a->line_num - HTMainText->top_of_screen) / (display_lines);

		max_offset = a->line_num - HTMainText->top_of_screen -
		    screensahead * (display_lines);
	    } else {
		max_offset = SEARCH_GOAL_LINE - 1;
	    }

	    /* Stuff below should remain unchanged if line positioning
	       is tweaked. - kw */
	    if (max_offset < 0)
		max_offset = 0;
	    else if (max_offset >= display_lines)
		max_offset = display_lines - 1;
	    *go_line = a->line_num - max_offset;
	    if (*go_line <= group_to_go->prev_anchor_line)
		*go_line = group_to_go->prev_anchor_line + 1;

	    if (*go_line < 0)
		*go_line = 0;
	    if (linknum)
		*linknum = group_to_go->anchors_this_line - 1;
	    return (LINK_LINE_FOUND);
	}
    }
    return (NO);
}

/*
 * This function finds the line indicated by line_num in the
 * HText structure indicated by text, and searches that line
 * for the first hit with the string indicated by target.  If
 * there is no hit, FALSE is returned.  If there is a hit, then
 * a copy of the line starting at that first hit is loaded into
 * *data with all IsSpecial characters stripped, its offset and
 * the printable target length (without IsSpecial, or extra CJK
 * or utf8 characters) are loaded into *offset and *tLen, and
 * TRUE is returned.  -FM
 */
BOOL HText_getFirstTargetInLine(HText *text, int line_num,
				BOOL utf_flag,
				int *offset,
				int *tLen,
				char **data,
				const char *target)
{
    HTLine *line;
    char *LineData;
    int LineOffset, HitOffset, LenNeeded, i;
    const char *cp;

    /*
     * Make sure we have an HText structure, that line_num is
     * in its range, and that we have a target string.  -FM
     */
    if (!(text &&
	  line_num >= 0 &&
	  line_num <= text->Lines &&
	  non_empty(target))) {
	return (FALSE);
    }

    /*
     * Find the line and set up its data and offset -FM
     */
    for (i = 0, line = FirstHTLine(text);
	 i < line_num && (line != text->last_line);
	 i++, line = line->next) {
	if (line->next == NULL) {
	    return (FALSE);
	}
    }
    if (!line && line->data[0])
	return (FALSE);
    LineData = (char *) line->data;
    LineOffset = (int) line->offset;

    /*
     * If the target is on the line, load the offset of
     * its first character and the subsequent line data,
     * strip any special characters from the loaded line
     * data, and return TRUE.  -FM
     */
    if (((cp = LYno_attr_mb_strstr(LineData,
				   target,
				   utf_flag, YES,
				   &HitOffset,
				   &LenNeeded)) != NULL) &&
	(LineOffset + LenNeeded) <= DISPLAY_COLS) {
	/*
	 * We had a hit so load the results,
	 * remove IsSpecial characters from
	 * the allocated data string, and
	 * return TRUE.  -FM
	 */
	*offset = (LineOffset + HitOffset);
	*tLen = (LenNeeded - HitOffset);
	StrAllocCopy(*data, cp);
	remove_special_attr_chars(*data);
	return (TRUE);
    }

    /*
     * The line does not contain the target.  -FM
     */
    return (FALSE);
}

/*
 * HText_getNumOfLines returns the number of lines in the
 * current document.
 */
int HText_getNumOfLines(void)
{
    return (HTMainText ? HTMainText->Lines : 0);
}

/*
 * HText_getNumOfBytes returns the size of the document, as rendered.  This
 * may be different from the original filesize.
 */
int HText_getNumOfBytes(void)
{
    int result = -1;
    HTLine *line = NULL;

    if (HTMainText != 0) {
	for (line = FirstHTLine(HTMainText);
	     line != HTMainText->last_line;
	     line = line->next) {
	    result += 1 + strlen(line->data);
	}
    }
    return result;
}

/*
 * HText_getTitle returns the title of the
 * current document.
 */
const char *HText_getTitle(void)
{
    return (HTMainText ?
	    HTAnchor_title(HTMainText->node_anchor) : 0);
}

#ifdef USE_COLOR_STYLE
const char *HText_getStyle(void)
{
    return (HTMainText ?
	    HTAnchor_style(HTMainText->node_anchor) : 0);
}
#endif

/*
 * HText_getSugFname returns the suggested filename of the current
 * document (normally derived from a Content-Disposition header with
 * attachment; filename=name.suffix).  -FM
 */
const char *HText_getSugFname(void)
{
    return (HTMainText ?
	    HTAnchor_SugFname(HTMainText->node_anchor) : 0);
}

/*
 * HTCheckFnameForCompression receives the address of an allocated
 * string containing a filename, and an anchor pointer, and expands
 * or truncates the string's suffix if appropriate, based on whether
 * the anchor indicates that the file is compressed.  We assume
 * that the file was not uncompressed (as when downloading), and
 * believe the headers about whether it's compressed or not.  -FM
 *
 * Added third arg - if strip_ok is FALSE, we don't trust the anchor
 * info enough to remove a compression suffix if the anchor object
 * does not indicate compression.  - kw
 */
void HTCheckFnameForCompression(char **fname,
				HTParentAnchor *anchor,
				BOOL strip_ok)
{
    char *fn = *fname;
    char *dot = NULL;
    char *cp = NULL;
    const char *suffix = "";
    const char *ct = NULL;
    const char *ce = NULL;
    CompressFileType method = cftNone;
    CompressFileType second;

    /*
     * Make sure we have a string and anchor.  -FM
     */
    if (!(fn && anchor))
	return;

    /*
     * Make sure we have a file, not directory, name.  -FM
     */
    if (*(fn = LYPathLeaf(fn)) == '\0')
	return;

    /*
     * Check the anchor's content_type and content_encoding
     * elements for a gzip or Unix compressed file.  -FM
     */
    ct = HTAnchor_content_type(anchor);
    ce = HTAnchor_content_encoding(anchor);
    if (ce == NULL && ct != 0) {
	/*
	 * No Content-Encoding, so check
	 * the Content-Type.  -FM
	 */
	if (!strncasecomp(ct, "application/gzip", 16) ||
	    !strncasecomp(ct, "application/x-gzip", 18)) {
	    method = cftGzip;
	} else if (!strncasecomp(ct, "application/compress", 20) ||
		   !strncasecomp(ct, "application/x-compress", 22)) {
	    method = cftCompress;
	} else if (!strncasecomp(ct, "application/bzip2", 17) ||
		   !strncasecomp(ct, "application/x-bzip2", 19)) {
	    method = cftBzip2;
	}
    } else if (ce != 0) {
	method = HTEncodingToCompressType(ce);
    }

    /*
     * If no Content-Encoding has been detected via the anchor
     * pointer, but strip_ok is not set, there is nothing left
     * to do.  - kw
     */
    if ((method == cftNone) && !strip_ok)
	return;

    /*
     * Treat .tgz specially
     */
    if ((dot = strrchr(fn, '.')) != NULL
	&& !strcasecomp(dot, ".tgz")) {
	if (method == cftNone) {
	    strcpy(dot, ".tar");
	}
	return;
    }

    /*
     * Seek the last dot, and check whether
     * we have a gzip or compress suffix.  -FM
     */
    if ((dot = strrchr(fn, '.')) != NULL) {
	int rootlen = 0;

	if (HTCompressFileType(fn, ".", &rootlen) != cftNone) {
	    if (method == cftNone) {
		/*
		 * It has a suffix which signifies a gzipped
		 * or compressed file for us, but the anchor
		 * claims otherwise, so tweak the suffix.  -FM
		 */
		*dot = '\0';
	    }
	    return;
	}
	if ((second = HTCompressFileType(fn, "-_", &rootlen)) != cftNone) {
	    cp = fn + rootlen;
	    if (method == cftNone) {
		/*
		 * It has a tail which signifies a gzipped
		 * file for us, but the anchor claims otherwise,
		 * so tweak the suffix.  -FM
		 */
		if (cp == dot + 1)
		    cp--;
		*cp = '\0';
	    } else {
		/*
		 * The anchor claims it's gzipped, and we
		 * believe it, so force this tail to the
		 * conventional suffix.  -FM
		 */
#ifdef VMS
		*cp = '-';
#else
		*cp = '.';
#endif /* VMS */
		if (second == cftCompress)
		    LYUpperCase(cp);
		else
		    LYLowerCase(cp);
	    }
	    return;
	}
    }

    switch (method) {
    case cftNone:
	suffix = "";
	break;
    case cftCompress:
	suffix = ".Z";
	break;
    case cftDeflate:
	suffix = ".zz";
	break;
    case cftGzip:
	suffix = ".gz";
	break;
    case cftBzip2:
	suffix = ".bz2";
	break;
    }

    /*
     * Add the appropriate suffix.  -FM
     */
    if (*suffix) {
	if (!dot) {
	    StrAllocCat(*fname, suffix);
	} else if (*++dot == '\0') {
	    StrAllocCat(*fname, suffix + 1);
	} else {
	    StrAllocCat(*fname, suffix);
#ifdef VMS
	    (*fname)[strlen(*fname) - strlen(suffix)] = '-';
#endif /* !VMS */
	}
    }
}

/*
 * HText_getLastModified returns the Last-Modified header
 * if available, for the current document.  -FM
 */
const char *HText_getLastModified(void)
{
    return (HTMainText ?
	    HTAnchor_last_modified(HTMainText->node_anchor) : 0);
}

/*
 * HText_getDate returns the Date header
 * if available, for the current document.  -FM
 */
const char *HText_getDate(void)
{
    return (HTMainText ?
	    HTAnchor_date(HTMainText->node_anchor) : 0);
}

/*
 * HText_getServer returns the Server header
 * if available, for the current document.  -FM
 */
const char *HText_getServer(void)
{
    return (HTMainText ?
	    HTAnchor_server(HTMainText->node_anchor) : 0);
}

#ifdef EXP_HTTP_HEADERS
/*
 * Returns the full text of HTTP headers, if available, for the current
 * document.
 */
const char *HText_getHttpHeaders(void)
{
    return (HTMainText ?
	    HTAnchor_http_headers(HTMainText->node_anchor) : 0);
}
#endif

/*
 * HText_pageDisplay displays a screen of text
 * starting from the line 'line_num'-1.
 * This is the primary call for lynx.
 */
void HText_pageDisplay(int line_num,
		       char *target)
{
#ifdef DISP_PARTIAL
    if (debug_display_partial || (LYTraceLogFP != NULL)) {
	CTRACE((tfp, "GridText: HText_pageDisplay at line %d started\n", line_num));
    }

    if (display_partial) {
	int stop_before = -1;

	/*
	 * Garbage is reported from forms input fields in incremental mode.
	 * So we start HText_trimHightext() to forget this side effect.
	 * This function was split-out from HText_endAppend().
	 * It may not be the best solution but it works.  - LP
	 *
	 * (FALSE = indicate that we are in partial mode)
	 * Multiple calls of HText_trimHightext works without problem now.
	 */
	if (HTMainText && HTMainText->stbl)
	    stop_before = Stbl_getStartLineDeep(HTMainText->stbl);
	HText_trimHightext(HTMainText, FALSE, stop_before);
    }
#endif

    display_page(HTMainText, line_num - 1, target);

#ifdef DISP_PARTIAL
    if (display_partial && debug_display_partial)
	LYSleepMsg();
#endif

    is_www_index = HTAnchor_isIndex(HTMainAnchor);

#ifdef DISP_PARTIAL
    if (debug_display_partial || (LYTraceLogFP != NULL)) {
	CTRACE((tfp, "GridText: HText_pageDisplay finished\n"));
    }
#endif
}

/*
 * Return YES if we have a whereis search target on the displayed
 * page.  - kw
 */
BOOL HText_pageHasPrevTarget(void)
{
    if (!HTMainText)
	return NO;
    else
	return HTMainText->page_has_target;
}

/*
 * HText_LinksInLines returns the number of links in the
 * 'Lines' number of lines beginning with 'line_num'-1.  -FM
 */
int HText_LinksInLines(HText *text, int line_num,
		       int Lines)
{
    int total = 0;
    int start = (line_num - 1);
    int end = (start + Lines);
    TextAnchor *Anchor_ptr = NULL;

    if (!text)
	return total;

    for (Anchor_ptr = text->first_anchor;
	 Anchor_ptr != NULL && Anchor_ptr->line_num <= end;
	 Anchor_ptr = Anchor_ptr->next) {
	if (Anchor_ptr->line_num >= start &&
	    Anchor_ptr->line_num < end &&
	    Anchor_ptr->show_anchor &&
	    !(Anchor_ptr->link_type == INPUT_ANCHOR
	      && Anchor_ptr->input_field->type == F_HIDDEN_TYPE))
	    ++total;
    }

    return total;
}

void HText_setStale(HText *text)
{
    text->stale = YES;
}

void HText_refresh(HText *text)
{
    if (text->stale)
	display_page(text, text->top_of_screen, "");
}

int HText_sourceAnchors(HText *text)
{
    return (text ? text->last_anchor_number : -1);
}

BOOL HText_canScrollUp(HText *text)
{
    return (BOOL) (text->top_of_screen != 0);
}

BOOL HText_canScrollDown(void)
{
    HText *text = HTMainText;

    return (BOOL) ((text != 0)
		   && ((text->top_of_screen + display_lines) < text->Lines + 1));
}

/*		Scroll actions
*/
void HText_scrollTop(HText *text)
{
    display_page(text, 0, "");
}

void HText_scrollDown(HText *text)
{
    display_page(text, text->top_of_screen + display_lines, "");
}

void HText_scrollUp(HText *text)
{
    display_page(text, text->top_of_screen - display_lines, "");
}

void HText_scrollBottom(HText *text)
{
    display_page(text, text->Lines - display_lines, "");
}

/*		Browsing functions
 *		==================
 */

/* Bring to front and highlight it
*/
BOOL HText_select(HText *text)
{
    if (text != HTMainText) {
	/*
	 * Reset flag for whereis search string - cannot be true here
	 * since text is not our HTMainText.  - kw
	 */
	if (text)
	    text->page_has_target = NO;

#ifdef DISP_PARTIAL
	/* Reset these for the previous and current text. - kw */
	ResetPartialLinenos(text);
	ResetPartialLinenos(HTMainText);
#endif /* DISP_PARTIAL */

#ifdef CAN_SWITCH_DISPLAY_CHARSET
	/* text->UCLYhndl is not reset by META, so use a more circumvent way */
	if (text->node_anchor->UCStages->s[UCT_STAGE_HTEXT].LYhndl
	    != current_char_set)
	    Switch_Display_Charset(text->node_anchor->UCStages->s[UCT_STAGE_HTEXT].LYhndl, SWITCH_DISPLAY_CHARSET_MAYBE);
#endif
	if (HTMainText) {
	    if (HText_hasUTF8OutputSet(HTMainText) &&
		HTLoadedDocumentEightbit() &&
		LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
		text->had_utf8 = HTMainText->has_utf8;
	    } else {
		text->had_utf8 = NO;
	    }
	    HTMainText->has_utf8 = NO;
	    text->has_utf8 = NO;
	}

	HTMainText = text;
	HTMainAnchor = text->node_anchor;

	/*
	 * Make this text the most current in the loaded texts list.  -FM
	 */
	if (loaded_texts && HTList_removeObject(loaded_texts, text))
	    HTList_addObject(loaded_texts, text);
	/* let lynx do it */
	/* display_page(text, text->top_of_screen, ""); */
    }
    return YES;
}

/*
 * This function returns TRUE if doc's post_data, address
 * and isHEAD elements are identical to those of a loaded
 * (memory cached) text.  -FM
 */
BOOL HText_POSTReplyLoaded(DocInfo *doc)
{
    HText *text = NULL;
    HTList *cur = loaded_texts;
    bstring *post_data;
    char *address;
    BOOL is_head;

    /*
     * Make sure we have the structures.  -FM
     */
    if (!cur || !doc)
	return (FALSE);

    /*
     * Make sure doc is for a POST reply.  -FM
     */
    if ((post_data = doc->post_data) == NULL ||
	(address = doc->address) == NULL)
	return (FALSE);
    is_head = doc->isHEAD;

    /*
     * Loop through the loaded texts looking for a
     * POST reply match.  -FM
     */
    while (NULL != (text = (HText *) HTList_nextObject(cur))) {
	if (text->node_anchor &&
	    text->node_anchor->post_data &&
	    BINEQ(post_data, text->node_anchor->post_data) &&
	    text->node_anchor->address &&
	    !strcmp(address, text->node_anchor->address) &&
	    is_head == text->node_anchor->isHEAD) {
	    return (TRUE);
	}
    }

    return (FALSE);
}

BOOL HTFindPoundSelector(const char *selector)
{
    TextAnchor *a;

    for (a = HTMainText->first_anchor; a != 0; a = a->next) {

	if (a->anchor && a->anchor->tag) {
	    if (!strcmp(a->anchor->tag, selector)) {

		www_search_result = a->line_num + 1;

		CTRACE((tfp, "FindPound: Selecting anchor [%d] at line %d\n",
			a->number, www_search_result));
		if (!strcmp(selector, LYToolbarName)) {
		    --www_search_result;
		}
		return (YES);
	    }
	}
    }
    return (NO);
}

BOOL HText_selectAnchor(HText *text, HTChildAnchor *anchor)
{
    TextAnchor *a;

/* This is done later, hence HText_select is unused in GridText.c
   Should it be the contrary ? @@@@@@
    if (text != HTMainText) {
	HText_select(text);
    }
*/

    for (a = text->first_anchor; a; a = a->next) {
	if (a->anchor == anchor)
	    break;
    }
    if (!a) {
	CTRACE((tfp, "HText: No such anchor in this text!\n"));
	return NO;
    }

    if (text != HTMainText) {	/* Comment out by ??? */
	HTMainText = text;	/* Put back in by tbl 921208 */
	HTMainAnchor = text->node_anchor;
    } {
	int l = a->line_num;

	CTRACE((tfp, "HText: Selecting anchor [%d] at line %d\n",
		a->number, l));

	if (!text->stale &&
	    (l >= text->top_of_screen) &&
	    (l < text->top_of_screen + display_lines + 1))
	    return YES;

	www_search_result = l - (display_lines / 3);	/* put in global variable */
    }

    return YES;
}

/*		Editing functions		- NOT IMPLEMENTED
 *		=================
 *
 *	These are called from the application.  There are many more functions
 *	not included here from the original text object.
 */

/*	Style handling:
*/
/*	Apply this style to the selection
*/
void HText_applyStyle(HText *me GCC_UNUSED, HTStyle *style GCC_UNUSED)
{

}

/*	Update all text with changed style.
*/
void HText_updateStyle(HText *me GCC_UNUSED, HTStyle *style GCC_UNUSED)
{

}

/*	Return style of  selection
*/
HTStyle *HText_selectionStyle(HText *me GCC_UNUSED, HTStyleSheet *sheet GCC_UNUSED)
{
    return 0;
}

/*	Paste in styled text
*/
void HText_replaceSel(HText *me GCC_UNUSED, const char *aString GCC_UNUSED,
		      HTStyle *aStyle GCC_UNUSED)
{
}

/*	Apply this style to the selection and all similarly formatted text
 *	(style recovery only)
 */
void HTextApplyToSimilar(HText *me GCC_UNUSED, HTStyle *style GCC_UNUSED)
{

}

/*	Select the first unstyled run.
 *	(style recovery only)
 */
void HTextSelectUnstyled(HText *me GCC_UNUSED, HTStyleSheet *sheet GCC_UNUSED)
{

}

/*	Anchor handling:
*/
void HText_unlinkSelection(HText *me GCC_UNUSED)
{

}

HTAnchor *HText_referenceSelected(HText *me GCC_UNUSED)
{
    return 0;
}

int HText_getTopOfScreen(void)
{
    HText *text = HTMainText;

    return text != 0 ? text->top_of_screen : 0;
}

int HText_getLines(HText *text)
{
    return text->Lines;
}

HTAnchor *HText_linkSelTo(HText *me GCC_UNUSED,
			  HTAnchor * anchor GCC_UNUSED)
{
    return 0;
}

/*
 * Utility for freeing the list of previous isindex and whereis queries.  -FM
 */
void HTSearchQueries_free(void)
{
    LYFreeStringList(search_queries);
    search_queries = NULL;
}

/*
 * Utility for listing isindex and whereis queries, making
 * any repeated queries the most current in the list.  -FM
 */
void HTAddSearchQuery(char *query)
{
    char *new_query = NULL;
    char *old;
    HTList *cur;

    if (!non_empty(query))
	return;

    StrAllocCopy(new_query, query);

    if (!search_queries) {
	search_queries = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(HTSearchQueries_free);
#endif
	HTList_addObject(search_queries, new_query);
	return;
    }

    cur = search_queries;
    while (NULL != (old = (char *) HTList_nextObject(cur))) {
	if (!strcmp(old, new_query)) {
	    HTList_removeObject(search_queries, old);
	    FREE(old);
	    break;
	}
    }
    HTList_addObject(search_queries, new_query);

    return;
}

int do_www_search(DocInfo *doc)
{
    char searchstring[256], temp[256], *cp, *tmpaddress = NULL;
    int ch;
    RecallType recall;
    int QueryTotal;
    int QueryNum;
    BOOLEAN PreviousSearch = FALSE;

    /*
     * Load the default query buffer
     */
    if ((cp = strchr(doc->address, '?')) != NULL) {
	/*
	 * This is an index from a previous search.
	 * Use its query as the default.
	 */
	PreviousSearch = TRUE;
	LYstrncpy(searchstring, ++cp, sizeof(searchstring) - 1);
	for (cp = searchstring; *cp; cp++)
	    if (*cp == '+')
		*cp = ' ';
	HTUnEscape(searchstring);
	strcpy(temp, searchstring);
	/*
	 * Make sure it's treated as the most recent query.  -FM
	 */
	HTAddSearchQuery(searchstring);
    } else {
	/*
	 * New search; no default.
	 */
	searchstring[0] = '\0';
	temp[0] = '\0';
    }

    /*
     * Prompt for a query string.
     */
    if (searchstring[0] == '\0') {
	if (HTMainAnchor->isIndexPrompt)
	    _statusline(HTMainAnchor->isIndexPrompt);
	else
	    _statusline(ENTER_DATABASE_QUERY);
    } else
	_statusline(EDIT_CURRENT_QUERY);
    QueryTotal = (search_queries ? HTList_count(search_queries) : 0);
    recall = (((PreviousSearch && QueryTotal >= 2) ||
	       (!PreviousSearch && QueryTotal >= 1)) ? RECALL_URL : NORECALL);
    QueryNum = QueryTotal;
  get_query:
    if ((ch = LYgetstr(searchstring, VISIBLE,
		       sizeof(searchstring), recall)) < 0 ||
	*searchstring == '\0' || ch == UPARROW || ch == DNARROW) {
	if (recall && ch == UPARROW) {
	    if (PreviousSearch) {
		/*
		 * Use the second to last query in the list.  -FM
		 */
		QueryNum = 1;
		PreviousSearch = FALSE;
	    } else {
		/*
		 * Go back to the previous query in the list.  -FM
		 */
		QueryNum++;
	    }
	    if (QueryNum >= QueryTotal)
		/*
		 * Roll around to the last query in the list.  -FM
		 */
		QueryNum = 0;
	    if ((cp = (char *) HTList_objectAt(search_queries,
					       QueryNum)) != NULL) {
		LYstrncpy(searchstring, cp, sizeof(searchstring) - 1);
		if (*temp && !strcmp(temp, searchstring)) {
		    _statusline(EDIT_CURRENT_QUERY);
		} else if ((*temp && QueryTotal == 2) ||
			   (!(*temp) && QueryTotal == 1)) {
		    _statusline(EDIT_THE_PREV_QUERY);
		} else {
		    _statusline(EDIT_A_PREV_QUERY);
		}
		goto get_query;
	    }
	} else if (recall && ch == DNARROW) {
	    if (PreviousSearch) {
		/*
		 * Use the first query in the list.  -FM
		 */
		QueryNum = QueryTotal - 1;
		PreviousSearch = FALSE;
	    } else {
		/*
		 * Advance to the next query in the list.  -FM
		 */
		QueryNum--;
	    }
	    if (QueryNum < 0)
		/*
		 * Roll around to the first query in the list.  -FM
		 */
		QueryNum = QueryTotal - 1;
	    if ((cp = (char *) HTList_objectAt(search_queries,
					       QueryNum)) != NULL) {
		LYstrncpy(searchstring, cp, sizeof(searchstring) - 1);
		if (*temp && !strcmp(temp, searchstring)) {
		    _statusline(EDIT_CURRENT_QUERY);
		} else if ((*temp && QueryTotal == 2) ||
			   (!(*temp) && QueryTotal == 1)) {
		    _statusline(EDIT_THE_PREV_QUERY);
		} else {
		    _statusline(EDIT_A_PREV_QUERY);
		}
		goto get_query;
	    }
	}

	/*
	 * Search cancelled.
	 */
	HTInfoMsg(CANCELLED);
	return (NULLFILE);
    }

    /*
     * Strip leaders and trailers.  -FM
     */
    LYTrimLeading(searchstring);
    if (!(*searchstring)) {
	HTInfoMsg(CANCELLED);
	return (NULLFILE);
    }
    LYTrimTrailing(searchstring);

    /*
     * Don't resubmit the same query unintentionally.
     */
    if (!LYforce_no_cache && 0 == strcmp(temp, searchstring)) {
	HTUserMsg(USE_C_R_TO_RESUB_CUR_QUERY);
	return (NULLFILE);
    }

    /*
     * Add searchstring to the query list,
     * or make it the most current.  -FM
     */
    HTAddSearchQuery(searchstring);

    /*
     * Show the URL with the new query.
     */
    if ((cp = strchr(doc->address, '?')) != NULL)
	*cp = '\0';
    StrAllocCopy(tmpaddress, doc->address);
    StrAllocCat(tmpaddress, "?");
    StrAllocCat(tmpaddress, searchstring);
    user_message(WWW_WAIT_MESSAGE, tmpaddress);
#ifdef SYSLOG_REQUESTED_URLS
    LYSyslog(tmpaddress);
#endif
    FREE(tmpaddress);
    if (cp)
	*cp = '?';

    /*
     * OK, now we do the search.
     */
    if (HTSearch(searchstring, HTMainAnchor)) {
	/*
	 * Memory leak fixed.
	 * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
	 */
	auto char *cp_freeme = NULL;

	if (traversal)
	    cp_freeme = stub_HTAnchor_address((HTAnchor *) HTMainAnchor);
	else
	    cp_freeme = HTAnchor_address((HTAnchor *) HTMainAnchor);
	StrAllocCopy(doc->address, cp_freeme);
	FREE(cp_freeme);

	CTRACE((tfp, "\ndo_www_search: newfile: %s\n", doc->address));

	/*
	 * Yah, the search succeeded.
	 */
	return (NORMAL);
    }

    /*
     * Either the search failed (Yuk), or we got redirection.
     * If it's redirection, use_this_url_instead is set, and
     * mainloop() will deal with it such that security features
     * and restrictions are checked before acting on the URL, or
     * rejecting it.  -FM
     */
    return (NOT_FOUND);
}

static void write_offset(FILE *fp, HTLine *line)
{
    int i;

    if (line->data[0]) {
	for (i = 0; i < (int) line->offset; i++) {
	    fputc(' ', fp);
	}
    }
}

static void write_hyphen(FILE *fp)
{
    if (dump_output_immediately &&
	LYRawMode &&
	LYlowest_eightbit[current_char_set] <= 173 &&
	(LYCharSet_UC[current_char_set].enc == UCT_ENC_8859 ||
	 (LYCharSet_UC[current_char_set].like8859 & UCT_R_8859SPECL)) != 0) {
	fputc(0xad, fp);	/* the iso8859 byte for SHY */
    } else {
	fputc('-', fp);
    }
}

/*
 * Returns the length after trimming trailing blanks.  Modify the string as
 * needed so that any special character which follows a trailing blank is moved
 * before the (trimmed) blank, so the result which will be dumped has no
 * trailing blanks.
 */
static int TrimmedLength(char *string)
{
    int result = strlen(string);
    int adjust = result;
    int ch;

    while (adjust > 0) {
	ch = UCH(string[adjust - 1]);
	if (isspace(ch) || IsSpecialAttrChar(ch)) {
	    --adjust;
	} else {
	    break;
	}
    }
    if (result != adjust) {
	char *dst = string + adjust;
	char *src = dst;

	for (;;) {
	    src = LYSkipBlanks(src);
	    if ((*dst++ = *src++) == '\0')
		break;
	}
	result = (dst - string - 1);
    }
    return result;
}

/*
 * Print the contents of the file in HTMainText to
 * the file descriptor fp.
 * If is_email is TRUE add ">" before each "From " line.
 * If is_reply is TRUE add ">" to the beginning of each
 * line to specify the file is a reply to message.
 */
void print_wwwfile_to_fd(FILE *fp,
			 BOOLEAN is_email,
			 BOOLEAN is_reply)
{
    register int i;
    int first = TRUE;
    int limit;
    HTLine *line;

#ifndef NO_DUMP_WITH_BACKSPACES
    HText *text = HTMainText;
    BOOL in_b = FALSE;
    BOOL in_u = FALSE;
    BOOL bs = (BOOL) (!is_email && !is_reply
		      && text != 0
		      && with_backspaces
		      && HTCJK == NOCJK
		      && !text->T.output_utf8);
#endif

    if (!HTMainText)
	return;

    line = FirstHTLine(HTMainText);
    for (;; line = line->next) {
	if (first) {
	    first = FALSE;
	    if (is_reply) {
		fputc('>', fp);
	    } else if (is_email && !strncmp(line->data, "From ", 5)) {
		fputc('>', fp);
	    }
	} else if (line->data[0] != LY_SOFT_NEWLINE) {
	    fputc('\n', fp);
	    /*
	     * Add news-style quotation if requested.  -FM
	     */
	    if (is_reply) {
		fputc('>', fp);
	    } else if (is_email && !strncmp(line->data, "From ", 5)) {
		fputc('>', fp);
	    }
	}

	write_offset(fp, line);

	/*
	 * Add data.
	 */
	limit = TrimmedLength(line->data);
	for (i = 0; i < limit; i++) {
	    int ch = UCH(line->data[i]);

	    if (!IsSpecialAttrChar(ch)) {
#ifndef NO_DUMP_WITH_BACKSPACES
		if (in_b) {
		    fputc(ch, fp);
		    fputc('\b', fp);
		    fputc(ch, fp);
		} else if (in_u) {
		    fputc('_', fp);
		    fputc('\b', fp);
		    fputc(ch, fp);
		} else
#endif
		    fputc(ch, fp);
	    } else if (ch == LY_SOFT_HYPHEN &&
		       (i + 1) >= limit) {	/* last char on line */
		write_hyphen(fp);
	    } else if (dump_output_immediately && use_underscore) {
		switch (ch) {
		case LY_UNDERLINE_START_CHAR:
		case LY_UNDERLINE_END_CHAR:
		    fputc('_', fp);
		    break;
		case LY_BOLD_START_CHAR:
		case LY_BOLD_END_CHAR:
		    break;
		}
	    }
#ifndef NO_DUMP_WITH_BACKSPACES
	    else if (bs) {
		switch (ch) {
		case LY_UNDERLINE_START_CHAR:
		    if (!in_b)
			in_u = TRUE;	/*favor bold over underline */
		    break;
		case LY_UNDERLINE_END_CHAR:
		    in_u = FALSE;
		    break;
		case LY_BOLD_START_CHAR:
		    if (in_u)
			in_u = FALSE;	/* turn it off */
		    in_b = TRUE;
		    break;
		case LY_BOLD_END_CHAR:
		    in_b = FALSE;
		    break;
		}
	    }
#endif
	}

	if (line == HTMainText->last_line)
	    break;

#ifdef VMS
	if (HadVMSInterrupt)
	    break;
#endif /* VMS */
    }
    fputc('\n', fp);

}

/*
 * Print the contents of the file in HTMainText to
 * the file descriptor fp.
 * First output line is "thelink", ie, the URL for this file.
 */
void print_crawl_to_fd(FILE *fp, char *thelink,
		       char *thetitle)
{
    register int i;
    int first = TRUE;
    int limit;
    HTLine *line;

    if (!HTMainText)
	return;

    line = FirstHTLine(HTMainText);
    fprintf(fp, "THE_URL:%s\n", thelink);
    if (thetitle != NULL) {
	fprintf(fp, "THE_TITLE:%s\n", thetitle);
    }

    for (;; line = line->next) {
	if (!first && line->data[0] != LY_SOFT_NEWLINE)
	    fputc('\n', fp);
	first = FALSE;
	write_offset(fp, line);

	/*
	 * Add data.
	 */
	limit = TrimmedLength(line->data);
	for (i = 0; limit; i++) {
	    int ch = UCH(line->data[i]);

	    if (!IsSpecialAttrChar(ch)) {
		fputc(ch, fp);
	    } else if (ch == LY_SOFT_HYPHEN &&
		       (i + 1) >= limit) {	/* last char on line */
		write_hyphen(fp);
	    }
	}

	if (line == HTMainText->last_line) {
	    break;
	}
    }
    fputc('\n', fp);

    /*
     * Add the References list if appropriate
     */
    if ((no_list == FALSE) &&
	links_are_numbered()) {
	printlist(fp, FALSE);
    }
#ifdef VMS
    HadVMSInterrupt = FALSE;
#endif /* VMS */
}

static void adjust_search_result(DocInfo *doc, int tentative_result,
				 int start_line)
{
    if (tentative_result > 0) {
	int anch_line = -1;
	TextAnchor *a;
	int nl_closest = -1;
	int goal = SEARCH_GOAL_LINE;
	int max_offset;
	BOOL on_screen = (BOOL) (tentative_result > HTMainText->top_of_screen &&
				 tentative_result <= HTMainText->top_of_screen +
				 display_lines);

	if (goal < 1)
	    goal = 1;
	else if (goal > display_lines)
	    goal = display_lines;
	max_offset = goal - 1;

	if (on_screen && nlinks > 0) {
	    int i;

	    for (i = 0; i < nlinks; i++) {
		if (doc->line + links[i].ly - 1 <= tentative_result)
		    nl_closest = i;
		if (doc->line + links[i].ly - 1 >= tentative_result)
		    break;
	    }
	    if (nl_closest >= 0 &&
		doc->line + links[nl_closest].ly - 1 == tentative_result) {
		www_search_result = doc->line;
		doc->link = nl_closest;
		return;
	    }
	}

	/* find last anchor before or on target line */
	for (a = HTMainText->first_anchor;
	     a && a->line_num <= tentative_result - 1; a = a->next) {
	    anch_line = a->line_num + 1;
	}
	/* position such that the anchor found is on first screen line,
	   if it is not too far above the target line; but also try to
	   make sure we move forward. */
	if (anch_line >= 0 &&
	    anch_line >= tentative_result - max_offset &&
	    (anch_line > start_line ||
	     tentative_result <= HTMainText->top_of_screen)) {
	    www_search_result = anch_line;
	} else if (tentative_result - start_line > 0 &&
		   tentative_result - (start_line + 1) <= max_offset) {
	    www_search_result = start_line + 1;
	} else if (tentative_result > HTMainText->top_of_screen &&
		   tentative_result <= start_line &&	/* have wrapped */
		   tentative_result <= HTMainText->top_of_screen + goal) {
	    www_search_result = HTMainText->top_of_screen + 1;
	} else if (tentative_result <= goal)
	    www_search_result = 1;
	else
	    www_search_result = tentative_result - max_offset;
	if (www_search_result == doc->line) {
	    if (nl_closest >= 0) {
		doc->link = nl_closest;
		return;
	    }
	}
    }
}

static BOOL anchor_has_target(TextAnchor *a, char *target)
{
    OptionType *option;
    char *stars = NULL, *sp;
    const char *cp;
    int count;

    /*
     * Search the hightext strings, taking the case_sensitive setting into
     * account.  -FM
     */
    for (count = 0;; ++count) {
	if ((cp = LYGetHiTextStr(a, count)) == NULL)
	    break;
	if (LYno_attr_strstr(cp, target))
	    return TRUE;
    }

    /*
     * Search the relevant form fields, taking the
     * case_sensitive setting into account.  -FM
     */
    if ((a->input_field != NULL && a->input_field->value != NULL) &&
	a->input_field->type != F_HIDDEN_TYPE) {
	if (a->input_field->type == F_PASSWORD_TYPE) {
	    /*
	     * Check the actual, hidden password, and then
	     * the displayed string.  -FM
	     */
	    if (LYno_attr_strstr(a->input_field->value, target)) {
		return TRUE;
	    }
	    StrAllocCopy(stars, a->input_field->value);
	    for (sp = stars; *sp != '\0'; sp++)
		*sp = '*';
	    if (LYno_attr_strstr(stars, target)) {
		FREE(stars);
		return TRUE;
	    }
	    FREE(stars);
	} else if (a->input_field->type == F_OPTION_LIST_TYPE) {
	    /*
	     * Search the option strings that are displayed
	     * when the popup is invoked.  -FM
	     */
	    option = a->input_field->select_list;
	    while (option != NULL) {
		if (LYno_attr_strstr(option->name, target)) {
		    return TRUE;
		}
		option = option->next;
	    }
	} else if (a->input_field->type == F_RADIO_TYPE) {
	    /*
	     * Search for checked or unchecked parens.  -FM
	     */
	    if (a->input_field->num_value) {
		cp = checked_radio;
	    } else {
		cp = unchecked_radio;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else if (a->input_field->type == F_CHECKBOX_TYPE) {
	    /*
	     * Search for checked or unchecked square brackets.  -FM
	     */
	    if (a->input_field->num_value) {
		cp = checked_box;
	    } else {
		cp = unchecked_box;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else {
	    /*
	     * Check the values intended for display.  May have been found
	     * already via the hightext search, but make sure here that the
	     * entire value is searched.  -FM
	     */
	    if (LYno_attr_strstr(a->input_field->value, target)) {
		return TRUE;
	    }
	}
    }
    return FALSE;
}

static TextAnchor *line_num_to_anchor(int line_num)
{
    TextAnchor *a;

    if (HTMainText != 0) {
	a = HTMainText->first_anchor;
	while (a != 0 && a->line_num < line_num) {
	    a = a->next;
	}
    } else {
	a = 0;
    }
    return a;
}

static int line_num_in_text(HText *text, HTLine *line)
{
    int result = 1;
    HTLine *temp = FirstHTLine(text);

    while (temp != line) {
	temp = temp->next;
	++result;
    }
    return result;
}

/* Computes the 'prev' pointers on demand, and returns the one for the given
 * anchor.
 */
static TextAnchor *get_prev_anchor(TextAnchor *a)
{
    TextAnchor *p, *q;

    if (a->prev == 0) {
	if ((p = HTMainText->first_anchor) != 0) {
	    while ((q = p->next) != 0) {
		q->prev = p;
		p = q;
	    }
	}
    }
    return a->prev;
}

static int www_search_forward(int start_line,
			      DocInfo *doc,
			      char *target,
			      HTLine *line,
			      int count)
{
    int wrapped = 0;
    TextAnchor *a = line_num_to_anchor(count - 1);
    int tentative_result = -1;

    for (;;) {
	while ((a != NULL) && a->line_num == (count - 1)) {
	    if (a->show_anchor &&
		!(a->link_type == INPUT_ANCHOR
		  && a->input_field->type == F_HIDDEN_TYPE)) {
		if (anchor_has_target(a, target)) {
		    adjust_search_result(doc, count, start_line);
		    return 1;
		}
	    }
	    a = a->next;
	}

	if (LYno_attr_strstr(line->data, target)) {
	    tentative_result = count;
	    break;
	} else if ((count == start_line && wrapped) || wrapped > 1) {
	    HTUserMsg2(STRING_NOT_FOUND, target);
	    return -1;
	} else if (line == HTMainText->last_line) {
	    count = 0;
	    wrapped++;
	}
	line = line->next;
	count++;
    }
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
    }
    return 0;
}

static int www_search_backward(int start_line,
			       DocInfo *doc,
			       char *target,
			       HTLine *line,
			       int count)
{
    int wrapped = 0;
    TextAnchor *a = line_num_to_anchor(count - 1);
    int tentative_result = -1;

    for (;;) {
	while ((a != NULL) && a->line_num == (count - 1)) {
	    if (a->show_anchor &&
		!(a->link_type == INPUT_ANCHOR
		  && a->input_field->type == F_HIDDEN_TYPE)) {
		if (anchor_has_target(a, target)) {
		    adjust_search_result(doc, count, start_line);
		    return 1;
		}
	    }
	    a = get_prev_anchor(a);
	}

	if (LYno_attr_strstr(line->data, target)) {
	    tentative_result = count;
	    break;
	} else if ((count == start_line && wrapped) || wrapped > 1) {
	    HTUserMsg2(STRING_NOT_FOUND, target);
	    return -1;
	} else if (line == FirstHTLine(HTMainText)) {
	    count = line_num_in_text(HTMainText, LastHTLine(HTMainText)) + 1;
	    wrapped++;
	}
	line = line->prev;
	count--;
    }
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
    }
    return 0;
}

void www_user_search(int start_line,
		     DocInfo *doc,
		     char *target,
		     int direction)
{
    HTLine *line;
    int count;

    if (!HTMainText) {
	return;
    }

    /*
     * Advance to the start line.
     */
    line = FirstHTLine(HTMainText);
    if (start_line + direction > 0) {
	for (count = 1;
	     count < start_line + direction;
	     line = line->next, count++) {
	    if (line == HTMainText->last_line) {
		line = FirstHTLine(HTMainText);
		count = 1;
		break;
	    }
	}
    } else {
	line = HTMainText->last_line;
	count = line_num_in_text(HTMainText, line);
    }

    if (direction >= 0)
	www_search_forward(start_line, doc, target, line, count);
    else
	www_search_backward(start_line, doc, target, line, count);
}

void user_message(const char *message,
		  const char *argument)
{
    char *temp = NULL;

    if (message == NULL) {
	mustshow = FALSE;
	return;
    }

    HTSprintf0(&temp, message, NonNull(argument));

    statusline(temp);

    FREE(temp);
    return;
}

/*
 * HText_getOwner returns the owner of the
 * current document.
 */
const char *HText_getOwner(void)
{
    return (HTMainText ?
	    HTAnchor_owner(HTMainText->node_anchor) : 0);
}

/*
 * HText_setMainTextOwner sets the owner for the
 * current document.
 */
void HText_setMainTextOwner(const char *owner)
{
    if (!HTMainText)
	return;

    HTAnchor_setOwner(HTMainText->node_anchor, owner);
}

/*
 * HText_getRevTitle returns the RevTitle element of the
 * current document, used as the subject for mailto comments
 * to the owner.
 */
const char *HText_getRevTitle(void)
{
    return (HTMainText ?
	    HTAnchor_RevTitle(HTMainText->node_anchor) : 0);
}

/*
 * HText_getContentBase returns the Content-Base header
 * of the current document.
 */
const char *HText_getContentBase(void)
{
    return (HTMainText ?
	    HTAnchor_content_base(HTMainText->node_anchor) : 0);
}

/*
 * HText_getContentLocation returns the Content-Location header
 * of the current document.
 */
const char *HText_getContentLocation(void)
{
    return (HTMainText ?
	    HTAnchor_content_location(HTMainText->node_anchor) : 0);
}

/*
 * HText_getMessageID returns the Message-ID of the
 * current document.
 */
const char *HText_getMessageID(void)
{
    return (HTMainText ?
	    HTAnchor_messageID(HTMainText->node_anchor) : NULL);
}

void HTuncache_current_document(void)
{
    /*
     * Should remove current document from memory.
     */
    if (HTMainText) {
	HTParentAnchor *htmain_anchor = HTMainText->node_anchor;

	if (htmain_anchor) {
	    if (!(HTOutputFormat && HTOutputFormat == WWW_SOURCE)) {
		FREE(htmain_anchor->UCStages);
	    }
	}
	CTRACE((tfp, "\nHTuncache.. freeing document for '%s'%s\n",
		((htmain_anchor &&
		  htmain_anchor->address) ?
		 htmain_anchor->address : "unknown anchor"),
		((htmain_anchor &&
		  htmain_anchor->post_data)
		 ? " with POST data"
		 : "")));
	HTList_removeObject(loaded_texts, HTMainText);
	HText_free(HTMainText);
	HTMainText = NULL;
    } else {
	CTRACE((tfp, "HTuncache.. HTMainText already is NULL!\n"));
    }
}

#ifdef USE_SOURCE_CACHE

static HTProtocol scm =
{"source-cache-mem", 0, 0};	/* dummy - kw */

static BOOLEAN useSourceCache(void)
{
    BOOLEAN result = FALSE;

    if (LYCacheSource == SOURCE_CACHE_FILE) {
	result = (HTMainAnchor->source_cache_file != 0);
	CTRACE((tfp, "SourceCache: file-cache%s found\n",
		result ? "" : " not"));
    }
    return result;
}

static BOOLEAN useMemoryCache(void)
{
    BOOLEAN result = FALSE;

    if (LYCacheSource == SOURCE_CACHE_MEMORY) {
	result = (HTMainAnchor->source_cache_chunk != 0);
	CTRACE((tfp, "SourceCache: memory-cache%s found\n",
		result ? "" : " not"));
    }
    return result;
}

BOOLEAN HTreparse_document(void)
{
    BOOLEAN ok = FALSE;

    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE) {
	CTRACE((tfp, "HTreparse_document returns FALSE\n"));
	return FALSE;
    }

    if (useSourceCache()) {
	FILE *fp;
	HTFormat format;
	int ret;

	CTRACE((tfp, "SourceCache: Reparsing file %s\n",
		HTMainAnchor->source_cache_file));

	/*
	 * This magic FREE(anchor->UCStages) call
	 * stolen from HTuncache_current_document() above.
	 */
	if (!(HTOutputFormat && HTOutputFormat == WWW_SOURCE)) {
	    FREE(HTMainAnchor->UCStages);
	}

	/*
	 * This is more or less copied out of HTLoadFile(), except we don't
	 * get a content encoding.  This may be overkill.  -dsb
	 */
	if (HTMainAnchor->content_type) {
	    format = HTAtom_for(HTMainAnchor->content_type);
	} else {
	    format = HTFileFormat(HTMainAnchor->source_cache_file, NULL, NULL);
	    format = HTCharsetFormat(format, HTMainAnchor,
				     UCLYhndl_for_unspec);
	    /* not UCLYhndl_HTFile_for_unspec - we are talking about remote
	     * documents...
	     */
	}
	CTRACE((tfp, "  Content type is \"%s\"\n", format->name));

	fp = fopen(HTMainAnchor->source_cache_file, "r");
	if (!fp) {
	    CTRACE((tfp, "  Cannot read file %s\n", HTMainAnchor->source_cache_file));
	    LYRemoveTemp(HTMainAnchor->source_cache_file);
	    FREE(HTMainAnchor->source_cache_file);
	    return FALSE;
	}

	if (HText_HaveUserChangedForms(HTMainText)) {
	    /*
	     * Issue a warning.  Will not restore changed forms, currently.
	     */
	    HTAlert(RELOADING_FORM);
	}
	/* Set HTMainAnchor->protocol or HTMainAnchor->physical to convince
	 * the SourceCacheWriter to not regenerate the cache file (which
	 * would be an unnecessary "loop"). - kw
	 */
	HTAnchor_setProtocol(HTMainAnchor, &HTFile);
	ret = HTParseFile(format, HTOutputFormat, HTMainAnchor, fp, NULL);
	LYCloseInput(fp);
	if (ret == HT_PARTIAL_CONTENT) {
	    HTInfoMsg(gettext("Loading incomplete."));
	    CTRACE((tfp,
		    "SourceCache: `%s' has been accessed, partial content.\n",
		    HTLoadedDocumentURL()));
	}
	ok = (BOOL) (ret == HT_LOADED || ret == HT_PARTIAL_CONTENT);

	CTRACE((tfp, "Reparse file %s\n", (ok ? "succeeded" : "failed")));
    }

    if (useMemoryCache()) {
	HTFormat format = WWW_HTML;
	int ret;

	CTRACE((tfp, "SourceCache: Reparsing from memory chunk %p\n",
		(void *) HTMainAnchor->source_cache_chunk));

	/*
	 * This magic FREE(anchor->UCStages) call
	 * stolen from HTuncache_current_document() above.
	 */
	if (!(HTOutputFormat && HTOutputFormat == WWW_SOURCE)) {
	    FREE(HTMainAnchor->UCStages);
	}

	if (HTMainAnchor->content_type) {
	    format = HTAtom_for(HTMainAnchor->content_type);
	} else {
	    /*
	     * This is only done to make things aligned with SOURCE_CACHE_NONE and
	     * SOURCE_CACHE_FILE when switching to source mode since the original
	     * document's charset will be LYPushAssumed() and then LYPopAssumed().
	     * See LYK_SOURCE in mainloop if you change something here.  No
	     * user-visible benefits, seems just '=' Info Page will show source's
	     * effective charset as "(assumed)".
	     */
	    format = HTCharsetFormat(format, HTMainAnchor,
				     UCLYhndl_for_unspec);
	}
	/* not UCLYhndl_HTFile_for_unspec - we are talking about remote documents... */

	if (HText_HaveUserChangedForms(HTMainText)) {
	    /*
	     * Issue a warning.  Will not restore changed forms, currently.
	     */
	    HTAlert(RELOADING_FORM);
	}
	/* Set HTMainAnchor->protocol or HTMainAnchor->physical to convince
	 * the SourceCacheWriter to not regenerate the cache chunk (which
	 * would be an unnecessary "loop"). - kw
	 */
	HTAnchor_setProtocol(HTMainAnchor, &scm);	/* cheating -
							   anything != &HTTP or &HTTPS would do - kw */
	ret = HTParseMem(format, HTOutputFormat, HTMainAnchor,
			 HTMainAnchor->source_cache_chunk, NULL);
	ok = (BOOL) (ret == HT_LOADED);

	CTRACE((tfp, "Reparse memory %s\n", (ok ? "succeeded" : "failed")));
    }

    return ok;
}

BOOLEAN HTcan_reparse_document(void)
{
    BOOLEAN result = FALSE;

    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE) {
	result = FALSE;
    } else if (useSourceCache()) {
	result = LYCanReadFile(HTMainAnchor->source_cache_file);
    } else if (useMemoryCache()) {
	result = TRUE;
    }

    CTRACE((tfp, "HTcan_reparse_document -> %d\n", result));
    return result;
}

static void trace_setting_change(const char *name,
				 int prev_setting,
				 int new_setting)
{
    if (prev_setting != new_setting)
	CTRACE((tfp,
		"HTdocument_settings_changed: %s setting has changed (was %d, now %d)\n",
		name, prev_setting, new_setting));
}

BOOLEAN HTdocument_settings_changed(void)
{
    /*
     * Annoying Hack(TM):  If we don't have a source cache, we can't
     * reparse anyway, so pretend the settings haven't changed.
     */
    if (!HTMainText || !HTcan_reparse_document())
	return FALSE;

    if (TRACE) {
	/*
	 * If we're tracing, note everying that has changed.
	 */
	trace_setting_change("CLICKABLE_IMAGES",
			     HTMainText->clickable_images, clickable_images);
	trace_setting_change("PSEUDO_INLINE_ALTS",
			     HTMainText->pseudo_inline_alts,
			     pseudo_inline_alts);
	trace_setting_change("VERBOSE_IMG",
			     HTMainText->verbose_img,
			     verbose_img);
	trace_setting_change("RAW_MODE", HTMainText->raw_mode,
			     LYUseDefaultRawMode);
	trace_setting_change("HISTORICAL_COMMENTS",
			     HTMainText->historical_comments,
			     historical_comments);
	trace_setting_change("MINIMAL_COMMENTS",
			     HTMainText->minimal_comments, minimal_comments);
	trace_setting_change("SOFT_DQUOTES",
			     HTMainText->soft_dquotes, soft_dquotes);
	trace_setting_change("OLD_DTD", HTMainText->old_dtd, Old_DTD);
	trace_setting_change("KEYPAD_MODE",
			     HTMainText->keypad_mode, keypad_mode);
	if (HTMainText->disp_lines != LYlines || HTMainText->disp_cols != DISPLAY_COLS)
	    CTRACE((tfp,
		    "HTdocument_settings_changed: Screen size has changed (was %dx%d, now %dx%d)\n",
		    HTMainText->disp_cols,
		    HTMainText->disp_lines,
		    DISPLAY_COLS,
		    LYlines));
    }

    return (HTMainText->clickable_images != clickable_images ||
	    HTMainText->pseudo_inline_alts != pseudo_inline_alts ||
	    HTMainText->verbose_img != verbose_img ||
	    HTMainText->raw_mode != LYUseDefaultRawMode ||
	    HTMainText->historical_comments != historical_comments ||
	    (HTMainText->minimal_comments != minimal_comments &&
	     !historical_comments) ||
	    HTMainText->soft_dquotes != soft_dquotes ||
	    HTMainText->old_dtd != Old_DTD ||
	    HTMainText->keypad_mode != keypad_mode ||
	    HTMainText->disp_cols != DISPLAY_COLS);
}
#endif

int HTisDocumentSource(void)
{
    return (HTMainText != 0) ? HTMainText->source : FALSE;
}

const char *HTLoadedDocumentURL(void)
{
    if (!HTMainText)
	return ("");

    if (HTMainText->node_anchor && HTMainText->node_anchor->address)
	return (HTMainText->node_anchor->address);
    else
	return ("");
}

bstring *HTLoadedDocumentPost_data(void)
{
    if (HTMainText
	&& HTMainText->node_anchor
	&& HTMainText->node_anchor->post_data)
	return (HTMainText->node_anchor->post_data);
    else
	return (0);
}

const char *HTLoadedDocumentTitle(void)
{
    if (!HTMainText)
	return ("");

    if (HTMainText->node_anchor && HTMainText->node_anchor->title)
	return (HTMainText->node_anchor->title);
    else
	return ("");
}

BOOLEAN HTLoadedDocumentIsHEAD(void)
{
    if (!HTMainText)
	return (FALSE);

    if (HTMainText->node_anchor && HTMainText->node_anchor->isHEAD)
	return (HTMainText->node_anchor->isHEAD);
    else
	return (FALSE);
}

BOOLEAN HTLoadedDocumentIsSafe(void)
{
    if (!HTMainText)
	return (FALSE);

    if (HTMainText->node_anchor && HTMainText->node_anchor->safe)
	return (HTMainText->node_anchor->safe);
    else
	return (FALSE);
}

const char *HTLoadedDocumentCharset(void)
{
    if (!HTMainText)
	return (NULL);

    if (HTMainText->node_anchor && HTMainText->node_anchor->charset)
	return (HTMainText->node_anchor->charset);
    else
	return (NULL);
}

BOOL HTLoadedDocumentEightbit(void)
{
    if (!HTMainText)
	return (NO);
    else
	return (HTMainText->have_8bit_chars);
}

void HText_setNodeAnchorBookmark(const char *bookmark)
{
    if (!HTMainText)
	return;

    if (HTMainText->node_anchor)
	HTAnchor_setBookmark(HTMainText->node_anchor, bookmark);
}

const char *HTLoadedDocumentBookmark(void)
{
    if (!HTMainText)
	return (NULL);

    if (HTMainText->node_anchor && HTMainText->node_anchor->bookmark)
	return (HTMainText->node_anchor->bookmark);
    else
	return (NULL);
}

int HText_LastLineSize(HText *text, BOOL IgnoreSpaces)
{
    if (!text || !text->last_line || !text->last_line->size)
	return 0;
    return HText_TrueLineSize(text->last_line, text, IgnoreSpaces);
}

BOOL HText_LastLineEmpty(HText *text, BOOL IgnoreSpaces)
{
    if (!text || !text->last_line || !text->last_line->size)
	return TRUE;
    return HText_TrueEmptyLine(text->last_line, text, IgnoreSpaces);
}

int HText_LastLineOffset(HText *text)
{
    if (!text || !text->last_line)
	return 0;
    return text->last_line->offset;
}

int HText_PreviousLineSize(HText *text, BOOL IgnoreSpaces)
{
    HTLine *line;

    if (!text || !text->last_line)
	return 0;
    if (!(line = text->last_line->prev))
	return 0;
    return HText_TrueLineSize(line, text, IgnoreSpaces);
}

BOOL HText_PreviousLineEmpty(HText *text, BOOL IgnoreSpaces)
{
    HTLine *line;

    if (!text || !text->last_line)
	return TRUE;
    if (!(line = text->last_line->prev))
	return TRUE;
    return HText_TrueEmptyLine(line, text, IgnoreSpaces);
}

/*
 * Compute the "true" line size.
 */
static int HText_TrueLineSize(HTLine *line, HText *text, BOOL IgnoreSpaces)
{
    size_t i;
    int true_size = 0;

    if (!(line && line->size))
	return 0;

    if (IgnoreSpaces) {
	for (i = 0; i < line->size; i++) {
	    if (!IsSpecialAttrChar(UCH(line->data[i])) &&
		IS_UTF8_EXTRA(line->data[i]) &&
		!isspace(UCH(line->data[i])) &&
		UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
		UCH(line->data[i]) != HT_EN_SPACE) {
		true_size++;
	    }
	}
    } else {
	for (i = 0; i < line->size; i++) {
	    if (!IsSpecialAttrChar(line->data[i]) &&
		IS_UTF8_EXTRA(line->data[i])) {
		true_size++;
	    }
	}
    }
    return true_size;
}

/*
 * Tell if the line is really empty.  This is invoked much more often than
 * HText_TrueLineSize(), and most lines are not empty.  So it is faster to
 * do this check than to check if the line size happens to be zero.
 */
static BOOL HText_TrueEmptyLine(HTLine *line, HText *text, BOOL IgnoreSpaces)
{
    size_t i;

    if (!(line && line->size))
	return TRUE;

    if (IgnoreSpaces) {
	for (i = 0; i < line->size; i++) {
	    if (!IsSpecialAttrChar(UCH(line->data[i])) &&
		IS_UTF8_EXTRA(line->data[i]) &&
		!isspace(UCH(line->data[i])) &&
		UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
		UCH(line->data[i]) != HT_EN_SPACE) {
		return FALSE;
	    }
	}
    } else {
	for (i = 0; i < line->size; i++) {
	    if (!IsSpecialAttrChar(line->data[i]) &&
		IS_UTF8_EXTRA(line->data[i])) {
		return FALSE;
	    }
	}
    }
    return TRUE;
}

void HText_NegateLineOne(HText *text)
{
    if (text) {
	text->in_line_1 = NO;
    }
    return;
}

BOOL HText_inLineOne(HText *text)
{
    if (text) {
	return text->in_line_1;
    }
    return YES;
}

/*
 * This function is for removing the first of two
 * successive blank lines.  It should be called after
 * checking the situation with HText_LastLineSize()
 * and HText_PreviousLineSize().  Any characters in
 * the removed line (i.e., control characters, or it
 * wouldn't have tested blank) should have been
 * reiterated by split_line() in the retained blank
 * line.  -FM
 */
void HText_RemovePreviousLine(HText *text)
{
    HTLine *line, *previous;

    if (!(text && text->Lines > 1))
	return;

    line = text->last_line->prev;
    previous = line->prev;
    previous->next = text->last_line;
    text->last_line->prev = previous;
    text->Lines--;
    freeHTLine(text, line);
}

/*
 * NOTE:  This function presently is correct only if the
 *	  alignment is HT_LEFT.  The offset is still zero,
 *	  because that's not determined for HT_CENTER or
 *	  HT_RIGHT until subsequent characters are received
 *	  and split_line() is called. -FM
 */
int HText_getCurrentColumn(HText *text)
{
    int column = 0;
    BOOL IgnoreSpaces = FALSE;

    if (text) {
	column = (text->in_line_1 ?
		  (int) text->style->indent1st : (int) text->style->leftIndent)
	    + HText_LastLineSize(text, IgnoreSpaces)
	    + (int) text->last_line->offset;
    }
    return column;
}

int HText_getMaximumColumn(HText *text)
{
    int column = DISPLAY_COLS;

    if (text) {
	column -= (int) text->style->rightIndent;
    }
    return column;
}

/*
 * NOTE:  This function uses HText_getCurrentColumn() which
 *	  presently is correct only if the alignment is
 *	  HT_LEFT. -FM
 */
void HText_setTabID(HText *text, const char *name)
{
    HTTabID *Tab = NULL;
    HTList *cur = text->tabs;
    HTList *last = NULL;

    if (!text || isEmpty(name))
	return;

    if (!cur) {
	cur = text->tabs = HTList_new();
    } else {
	while (NULL != (Tab = (HTTabID *) HTList_nextObject(cur))) {
	    if (Tab->name && !strcmp(Tab->name, name))
		return;		/* Already set.  Keep the first value. */
	    last = cur;
	}
	if (last)
	    cur = last;
    }
    if (!Tab) {			/* New name.  Create a new node */
	Tab = typecalloc(HTTabID);
	if (Tab == NULL)
	    outofmem(__FILE__, "HText_setTabID");
	HTList_addObject(cur, Tab);
	StrAllocCopy(Tab->name, name);
    }
    Tab->column = HText_getCurrentColumn(text);
    return;
}

int HText_getTabIDColumn(HText *text, const char *name)
{
    int column = 0;
    HTTabID *Tab;
    HTList *cur = text->tabs;

    if (text && non_empty(name) && cur) {
	while (NULL != (Tab = (HTTabID *) HTList_nextObject(cur))) {
	    if (Tab->name && !strcmp(Tab->name, name))
		break;
	}
	if (Tab)
	    column = Tab->column;
    }
    return column;
}

/*
 * This function is for saving the address of a link
 * which had an attribute in the markup that resolved
 * to a URL (i.e., not just a NAME or ID attribute),
 * but was found in HText_endAnchor() to have no visible
 * content for use as a link name.  It loads the address
 * into text->hidden_links, whose count can be determined
 * via HText_HiddenLinks(), below.  The addresses can be
 * retrieved via HText_HiddenLinkAt(), below, based on
 * count.  -FM
 */
static void HText_AddHiddenLink(HText *text, TextAnchor *textanchor)
{
    HTAnchor *dest;

    /*
     * Make sure we have an HText structure and anchor.  -FM
     */
    if (!(text && textanchor && textanchor->anchor))
	return;

    /*
     * Create the hidden links list
     * if it hasn't been already.  -FM
     */
    if (text->hidden_links == NULL)
	text->hidden_links = HTList_new();

    /*
     * Store the address, in reverse list order
     * so that first in will be first out on
     * retrievals.  -FM
     */
    if ((dest = HTAnchor_followLink(textanchor->anchor)) &&
	(text->hiddenlinkflag != HIDDENLINKS_IGNORE ||
	 HTList_isEmpty(text->hidden_links))) {
	char *cp_freeme = NULL;

	HTList_appendObject(text->hidden_links, cp_freeme = HTAnchor_address(dest));
	FREE(cp_freeme);
    }

    return;
}

/*
 * This function returns the number of addresses
 * that are loaded in text->hidden_links.  -FM
 */
int HText_HiddenLinkCount(HText *text)
{
    int count = 0;

    if (text && text->hidden_links)
	count = HTList_count((HTList *) text->hidden_links);

    return (count);
}

/*
 * This function returns the address, corresponding to
 * a hidden link, at the position (zero-based) in the
 * text->hidden_links list of the number argument.  -FM
 */
const char *HText_HiddenLinkAt(HText *text, int number)
{
    char *href = NULL;

    if (text && text->hidden_links && number >= 0)
	href = (char *) HTList_objectAt((HTList *) text->hidden_links, number);

    return (href);
}

/*
 * Form methods
 * These routines are used to build forms consisting
 * of input fields
 */
static int HTFormMethod;
static char *HTFormAction = NULL;
static char *HTFormEnctype = NULL;
static char *HTFormTitle = NULL;
static char *HTFormAcceptCharset = NULL;
static BOOLEAN HTFormDisabled = FALSE;
static PerFormInfo *HTCurrentForm;

void HText_beginForm(char *action,
		     char *method,
		     char *enctype,
		     char *title,
		     const char *accept_cs)
{
    PerFormInfo *newform;

    HTFormMethod = URL_GET_METHOD;
    HTFormNumber++;
    HTFormFields = 0;
    HTFormDisabled = FALSE;

    /*
     * Check the ACTION.  -FM
     */
    if (action != NULL) {
	if (isMAILTO_URL(action)) {
	    HTFormMethod = URL_MAIL_METHOD;
	}
	StrAllocCopy(HTFormAction, action);
    } else
	StrAllocCopy(HTFormAction, HTLoadedDocumentURL());

    /*
     * Check the METHOD.  -FM
     */
    if (method != NULL && HTFormMethod != URL_MAIL_METHOD)
	if (!strcasecomp(method, "post") || !strcasecomp(method, "pget"))
	    HTFormMethod = URL_POST_METHOD;

    /*
     * Check the ENCTYPE.  -FM
     */
    if (non_empty(enctype)) {
	StrAllocCopy(HTFormEnctype, enctype);
	if (HTFormMethod != URL_MAIL_METHOD &&
	    !strncasecomp(enctype, "multipart/form-data", 19))
	    HTFormMethod = URL_POST_METHOD;
    } else {
	FREE(HTFormEnctype);
    }

    /*
     * Check the TITLE.  -FM
     */
    if (non_empty(title))
	StrAllocCopy(HTFormTitle, title);
    else
	FREE(HTFormTitle);

    /*
     * Check for an ACCEPT_CHARSET.  If present, store it and
     * convert to lowercase and collapse spaces.  - kw
     */
    if (accept_cs != NULL) {
	StrAllocCopy(HTFormAcceptCharset, accept_cs);
	LYRemoveBlanks(HTFormAcceptCharset);
	LYLowerCase(HTFormAcceptCharset);
    }

    /*
     * Create a new "PerFormInfo" structure to hold info on the current
     * form.  The HTForm* variables could all migrate there, currently
     * this isn't done (yet?) but it might be less confusing.
     * Currently the only data saved in this structure that will actually
     * be used is the accept_cs string.
     * This will be appended to the forms list kept by the HText object
     * if and when we reach a HText_endForm.  - kw
     */
    newform = typecalloc(PerFormInfo);
    if (newform == NULL)
	outofmem(__FILE__, "HText_beginForm");
    newform->number = HTFormNumber;

    PerFormInfo_free(HTCurrentForm);	/* shouldn't happen here - kw */
    HTCurrentForm = newform;

    CTRACE((tfp, "BeginForm: action:%s Method:%d%s%s%s%s%s%s\n",
	    HTFormAction, HTFormMethod,
	    (HTFormTitle ? " Title:" : ""),
	    NonNull(HTFormTitle),
	    (HTFormEnctype ? " Enctype:" : ""),
	    NonNull(HTFormEnctype),
	    (HTFormAcceptCharset ? " Accept-charset:" : ""),
	    NonNull(HTFormAcceptCharset)));
}

void HText_endForm(HText *text)
{
    if (HTFormFields == 1 && text && text->first_anchor) {
	/*
	 * Support submission of a single text input field in
	 * the form via <return> instead of a submit button.  -FM
	 */
	TextAnchor *a;

	/*
	 * Go through list of anchors and get our input field.  -FM
	 */
	for (a = text->first_anchor; a != NULL; a = a->next) {
	    if (a->link_type == INPUT_ANCHOR &&
		a->input_field->number == HTFormNumber &&
		a->input_field->type == F_TEXT_TYPE) {
		/*
		 * Got it.  Make it submitting.  -FM
		 */
		a->input_field->submit_action = NULL;
		StrAllocCopy(a->input_field->submit_action, HTFormAction);
		if (HTFormEnctype != NULL)
		    StrAllocCopy(a->input_field->submit_enctype,
				 HTFormEnctype);
		if (HTFormTitle != NULL)
		    StrAllocCopy(a->input_field->submit_title, HTFormTitle);
		a->input_field->submit_method = HTFormMethod;
		a->input_field->type = F_TEXT_SUBMIT_TYPE;
		if (HTFormDisabled)
		    a->input_field->disabled = TRUE;
		break;
	    }
	}
    }
    /*
     * Append info on the current form to the HText object's list of
     * forms.
     * HText_beginInput call will have set some of the data in the
     * PerFormInfo structure (if there were any form fields at all),
     * we also fill in the ACCEPT-CHARSET data now (this could have
     * been done earlier).  - kw
     */
    if (HTCurrentForm) {
	if (HTFormDisabled)
	    HTCurrentForm->disabled = TRUE;
	HTCurrentForm->accept_cs = HTFormAcceptCharset;
	HTFormAcceptCharset = NULL;
	if (!text->forms)
	    text->forms = HTList_new();
	HTList_appendObject(text->forms, HTCurrentForm);
	HTCurrentForm = NULL;
    } else {
	CTRACE((tfp, "endForm:    HTCurrentForm is missing!\n"));
    }

    FREE(HTCurSelectGroup);
    FREE(HTCurSelectGroupSize);
    FREE(HTCurSelectedOptionValue);
    FREE(HTFormAction);
    FREE(HTFormEnctype);
    FREE(HTFormTitle);
    FREE(HTFormAcceptCharset);
    HTFormFields = 0;
    HTFormDisabled = FALSE;
}

void HText_beginSelect(char *name,
		       int name_cs,
		       BOOLEAN multiple,
		       char *size)
{
    /*
     * Save the group name.
     */
    StrAllocCopy(HTCurSelectGroup, name);
    HTCurSelectGroupCharset = name_cs;

    /*
     * If multiple then all options are actually checkboxes.
     */
    if (multiple)
	HTCurSelectGroupType = F_CHECKBOX_TYPE;
    /*
     * If not multiple then all options are radio buttons.
     */
    else
	HTCurSelectGroupType = F_RADIO_TYPE;

    /*
     * Length of an option list.
     */
    StrAllocCopy(HTCurSelectGroupSize, size);

    CTRACE((tfp, "HText_beginSelect: name=%s type=%d size=%s\n",
	    ((HTCurSelectGroup == NULL) ?
	     "<NULL>" : HTCurSelectGroup),
	    HTCurSelectGroupType,
	    ((HTCurSelectGroupSize == NULL) ?
	     "<NULL>" : HTCurSelectGroupSize)));
    CTRACE((tfp, "HText_beginSelect: name_cs=%d \"%s\"\n",
	    HTCurSelectGroupCharset,
	    (HTCurSelectGroupCharset >= 0 ?
	     LYCharSet_UC[HTCurSelectGroupCharset].MIMEname : "<UNKNOWN>")));
}

/*
 *  This function returns the number of the option whose
 *  value currently is being accumulated for a select
 *  block. - LE && FM
 */
int HText_getOptionNum(HText *text)
{
    TextAnchor *a;
    OptionType *op;
    int n = 1;			/* start count at 1 */

    if (!(text && text->last_anchor))
	return (0);

    a = text->last_anchor;
    if (!(a->link_type == INPUT_ANCHOR && a->input_field &&
	  a->input_field->type == F_OPTION_LIST_TYPE))
	return (0);

    for (op = a->input_field->select_list; op; op = op->next)
	n++;
    CTRACE((tfp, "HText_getOptionNum: Got number '%d'.\n", n));
    return (n);
}

/*
 *  This function checks for a numbered option pattern
 *  as the prefix for an option value.  If present, and
 *  we are in the correct keypad mode, it returns a
 *  pointer to the actual value, following that prefix.
 *  Otherwise, it returns the original pointer.
 */
static char *HText_skipOptionNumPrefix(char *opname)
{
    /*
     * Check if we are in the correct keypad mode.
     */
    if (fields_are_numbered()) {
	/*
	 * Skip the option number embedded in the option name so the
	 * extra chars won't mess up cgi scripts processing the value.
	 * The format is (nnn)__ where nnn is a number and there is a
	 * minimum of 5 chars (no underscores if (nnn) exceeds 5 chars).
	 * See HTML.c.  If the chars don't exactly match this format,
	 * just use all of opname.  - LE
	 */
	char *cp = opname;

	if ((non_empty(cp) && *cp++ == '(') &&
	    *cp && isdigit(UCH(*cp++))) {
	    while (*cp && isdigit(UCH(*cp)))
		++cp;
	    if (*cp && *cp++ == ')') {
		int i = (cp - opname);

		while (i < 5) {
		    if (*cp != '_')
			break;
		    i++;
		    cp++;
		}
		if (i < 5) {
		    cp = opname;
		}
	    } else {
		cp = opname;
	    }
	} else {
	    cp = opname;
	}
	return (cp);
    }

    return (opname);
}

/*
 *  We couldn't set the value field for the previous option
 *  tag so we have to do it now.  Assume that the last anchor
 *  was the previous options tag.
 */
char *HText_setLastOptionValue(HText *text, char *value,
			       char *submit_value,
			       int order,
			       BOOLEAN checked,
			       int val_cs,
			       int submit_val_cs)
{
    char *cp, *cp1;
    char *ret_Value = NULL;
    unsigned char *tmp = NULL;
    int number = 0, i, j;

    if (!(value
	  && text
	  && text->last_anchor
	  && text->last_anchor->link_type == INPUT_ANCHOR)) {
	CTRACE((tfp, "HText_setLastOptionValue: invalid call!  value:%s!\n",
		(value ? value : "<NULL>")));
	return NULL;
    }

    CTRACE((tfp,
	    "Entering HText_setLastOptionValue: value:\"%s\", checked:%s\n",
	    value, (checked ? "on" : "off")));

    /*
     * Strip end spaces, newline is also whitespace.
     */
    if (*value) {
	cp = &value[strlen(value) - 1];
	while ((cp >= value) && (isspace(UCH(*cp)) ||
				 IsSpecialAttrChar(UCH(*cp))))
	    cp--;
	*(cp + 1) = '\0';
    }

    /*
     * Find first non space
     */
    cp = value;
    while (isspace(UCH(*cp)) ||
	   IsSpecialAttrChar(UCH(*cp)))
	cp++;
    if (HTCurSelectGroupType == F_RADIO_TYPE &&
	LYSelectPopups &&
	fields_are_numbered()) {
	/*
	 * Collapse any space between the popup option
	 * prefix and actual value.  -FM
	 */
	if ((cp1 = HText_skipOptionNumPrefix(cp)) > cp) {
	    i = 0, j = (cp1 - cp);
	    while (isspace(UCH(cp1[i])) ||
		   IsSpecialAttrChar(UCH(cp1[i]))) {
		i++;
	    }
	    if (i > 0) {
		while (cp1[i] != '\0')
		    cp[j++] = cp1[i++];
		cp[j] = '\0';
	    }
	}
    }

    if (HTCurSelectGroupType == F_CHECKBOX_TYPE) {
	StrAllocCopy(text->last_anchor->input_field->value, cp);
	text->last_anchor->input_field->value_cs = val_cs;
	/*
	 * Put the text on the screen as well.
	 */
	HText_appendText(text, cp);

    } else if (LYSelectPopups == FALSE) {
	StrAllocCopy(text->last_anchor->input_field->value,
		     (submit_value ? submit_value : cp));
	text->last_anchor->input_field->value_cs = (submit_value ?
						    submit_val_cs : val_cs);
	/*
	 * Put the text on the screen as well.
	 */
	HText_appendText(text, cp);

    } else {
	/*
	 * Create a linked list of option values.
	 */
	OptionType *op_ptr = text->last_anchor->input_field->select_list;
	OptionType *new_ptr = NULL;
	BOOLEAN first_option = FALSE;

	/*
	 * Deal with newlines or tabs.
	 */
	LYReduceBlanks(value);

	if (!op_ptr) {
	    /*
	     * No option items yet.
	     */
	    if (text->last_anchor->input_field->type != F_OPTION_LIST_TYPE) {
		CTRACE((tfp,
			"HText_setLastOptionValue: last input_field not F_OPTION_LIST_TYPE (%d)\n",
			F_OPTION_LIST_TYPE));
		CTRACE((tfp, "                          but %d, ignoring!\n",
			text->last_anchor->input_field->type));
		return NULL;
	    }

	    new_ptr = text->last_anchor->input_field->select_list =
		typecalloc(OptionType);
	    if (new_ptr == NULL)
		outofmem(__FILE__, "HText_setLastOptionValue");

	    first_option = TRUE;
	} else {
	    while (op_ptr->next) {
		number++;
		op_ptr = op_ptr->next;
	    }
	    number++;		/* add one more */

	    op_ptr->next = new_ptr = typecalloc(OptionType);
	    if (new_ptr == NULL)
		outofmem(__FILE__, "HText_setLastOptionValue");
	}

	new_ptr->name = NULL;
	new_ptr->cp_submit_value = NULL;
	new_ptr->next = NULL;
	/*
	 * Find first non-space again, convert_to_spaces above may have
	 * changed the string.  - kw
	 */
	cp = value;
	while (isspace(UCH(*cp)) ||
	       IsSpecialAttrChar(UCH(*cp)))
	    cp++;
	for (i = 0, j = 0; cp[i]; i++) {
	    if (cp[i] == HT_NON_BREAK_SPACE ||
		cp[i] == HT_EN_SPACE) {
		cp[j++] = ' ';
	    } else if (cp[i] != LY_SOFT_HYPHEN &&
		       !IsSpecialAttrChar(UCH(cp[i]))) {
		cp[j++] = cp[i];
	    }
	}
	cp[j] = '\0';
	if (HTCJK != NOCJK) {
	    if (cp &&
		(tmp = typecallocn(unsigned char, strlen(cp) + 1)) != 0) {
		if (tmp == NULL)
		    outofmem(__FILE__, "HText_setLastOptionValue");
		if (kanji_code == EUC) {
		    TO_EUC((unsigned char *) cp, tmp);
		    val_cs = current_char_set;
		} else if (kanji_code == SJIS) {
		    TO_SJIS((unsigned char *) cp, tmp);
		    val_cs = current_char_set;
		} else {
		    for (i = 0, j = 0; cp[i]; i++) {
			if (cp[i] != CH_ESC) {	/* S/390 -- gil -- 1604 */
			    tmp[j++] = cp[i];
			}
		    }
		}
		StrAllocCopy(new_ptr->name, (const char *) tmp);
		FREE(tmp);
	    }
	} else {
	    StrAllocCopy(new_ptr->name, cp);
	}
	StrAllocCopy(new_ptr->cp_submit_value,
		     (submit_value ? submit_value :
		      HText_skipOptionNumPrefix(new_ptr->name)));
	new_ptr->value_cs = (submit_value ? submit_val_cs : val_cs);

	if (first_option) {
	    FormInfo *last_input = text->last_anchor->input_field;

	    StrAllocCopy(HTCurSelectedOptionValue, new_ptr->name);
	    last_input->num_value = 0;
	    /*
	     * If this is the first option in a popup select list,
	     * HText_beginInput may have allocated the value and
	     * cp_submit_value fields, so free them now to avoid
	     * a memory leak.  - kw
	     */
	    FREE(last_input->value);
	    FREE(last_input->cp_submit_value);

	    last_input->value = last_input->select_list->name;
	    last_input->orig_value = last_input->select_list->name;
	    last_input->cp_submit_value = last_input->select_list->cp_submit_value;
	    last_input->orig_submit_value = last_input->select_list->cp_submit_value;
	    last_input->value_cs = new_ptr->value_cs;
	} else {
	    int newlen = strlen(new_ptr->name);
	    int curlen = (HTCurSelectedOptionValue
			  ? strlen(HTCurSelectedOptionValue)
			  : 0);

	    /*
	     * Make the selected Option Value as long as
	     * the longest option.
	     */
	    if (newlen > curlen)
		StrAllocCat(HTCurSelectedOptionValue,
			    UNDERSCORES(newlen - curlen));
	}

	if (checked) {
	    int curlen = strlen(new_ptr->name);
	    int newlen = strlen(HTCurSelectedOptionValue);
	    FormInfo *last_input = text->last_anchor->input_field;

	    /*
	     * Set the default option as this one.
	     */
	    last_input->num_value = number;
	    last_input->value = new_ptr->name;
	    last_input->orig_value = new_ptr->name;
	    last_input->cp_submit_value = new_ptr->cp_submit_value;
	    last_input->orig_submit_value = new_ptr->cp_submit_value;
	    last_input->value_cs = new_ptr->value_cs;
	    StrAllocCopy(HTCurSelectedOptionValue, new_ptr->name);
	    if (newlen > curlen)
		StrAllocCat(HTCurSelectedOptionValue,
			    UNDERSCORES(newlen - curlen));
	}

	/*
	 * Return the selected Option value to be sent to the screen.
	 */
	if (order == LAST_ORDER) {
	    /*
	     * Change the value.
	     */
	    text->last_anchor->input_field->size =
		strlen(HTCurSelectedOptionValue);
	    ret_Value = HTCurSelectedOptionValue;
	}
    }

    if (TRACE) {
	CTRACE((tfp, "HText_setLastOptionValue:%s value=\"%s\"\n",
		(order == LAST_ORDER) ? " LAST_ORDER" : "",
		value));
	CTRACE((tfp, "            val_cs=%d \"%s\"",
		val_cs,
		(val_cs >= 0 ?
		 LYCharSet_UC[val_cs].MIMEname : "<UNKNOWN>")));
	if (submit_value) {
	    CTRACE((tfp, " (submit_val_cs %d \"%s\") submit_value%s=\"%s\"\n",
		    submit_val_cs,
		    (submit_val_cs >= 0 ?
		     LYCharSet_UC[submit_val_cs].MIMEname : "<UNKNOWN>"),
		    (HTCurSelectGroupType == F_CHECKBOX_TYPE) ?
		    "(ignored)" : "",
		    submit_value));
	} else {
	    CTRACE((tfp, "\n"));
	}
    }
    return (ret_Value);
}

/*
 * Assign a form input anchor.
 * Returns the number of characters to leave
 * blank so that the input field can fit.
 */
int HText_beginInput(HText *text, BOOL underline,
		     InputFieldData * I)
{
    TextAnchor *a;
    FormInfo *f;
    const char *cp_option = NULL;
    char *IValue = NULL;
    unsigned char *tmp = NULL;
    int i, j;
    int adjust_marker = 0;
    int MaximumSize;
    char marker[16];

    CTRACE((tfp, "GridText: Entering HText_beginInput\n"));

    POOLtypecalloc(TextAnchor, a);

    POOLtypecalloc(FormInfo, f);
    if (a == NULL || f == NULL)
	outofmem(__FILE__, "HText_beginInput");

    a->inUnderline = underline;
    a->line_num = text->Lines;
    a->line_pos = text->last_line->size;

    /*
     * If this is a radio button, or an OPTION we're converting
     * to a radio button, and it's the first with this name, make
     * sure it's checked by default.  Otherwise, if it's checked,
     * uncheck the default or any preceding radio button with this
     * name that was checked.  -FM
     */
    if (I->type != NULL && !strcmp(I->type, "OPTION") &&
	HTCurSelectGroupType == F_RADIO_TYPE && LYSelectPopups == FALSE) {
	I->type = "RADIO";
	I->name = HTCurSelectGroup;
	I->name_cs = HTCurSelectGroupCharset;
    }
    if (I->name && I->type && !strcasecomp(I->type, "radio")) {
	if (!text->last_anchor) {
	    I->checked = TRUE;
	} else {
	    TextAnchor *b;
	    int i2 = 0;

	    for (b = text->first_anchor; b != NULL; b = b->next) {
		if (b->link_type == INPUT_ANCHOR &&
		    b->input_field->type == F_RADIO_TYPE &&
		    b->input_field->number == HTFormNumber) {
		    if (!strcmp(b->input_field->name, I->name)) {
			if (I->checked && b->input_field->num_value) {
			    b->input_field->num_value = 0;
			    StrAllocCopy(b->input_field->orig_value, "0");
			    break;
			}
			i2++;
		    }
		}
	    }
	    if (i2 == 0)
		I->checked = TRUE;
	}
    }

    a->next = 0;
    a->anchor = NULL;
    a->link_type = INPUT_ANCHOR;
    a->show_anchor = YES;

    LYClearHiText(a);
    a->extent = 2;

    a->input_field = f;

    f->select_list = 0;
    f->number = HTFormNumber;
    f->disabled = (HTFormDisabled ? TRUE : I->disabled);
    f->no_cache = NO;

    HTFormFields++;

    /*
     * Set the no_cache flag if the METHOD is POST.  -FM
     */
    if (HTFormMethod == URL_POST_METHOD)
	f->no_cache = TRUE;

    /*
     * Set up VALUE.
     */
    if (I->value)
	StrAllocCopy(IValue, I->value);
    if (IValue && HTCJK != NOCJK) {
	if ((tmp = typecallocn(unsigned char, strlen(IValue) + 1)) != 0) {
	    if (kanji_code == EUC) {
		TO_EUC((unsigned char *) IValue, tmp);
		I->value_cs = current_char_set;
	    } else if (kanji_code == SJIS) {
		TO_SJIS((unsigned char *) IValue, tmp);
		I->value_cs = current_char_set;
	    } else {
		for (i = 0, j = 0; IValue[i]; i++) {
		    if (IValue[i] != CH_ESC) {	/* S/390 -- gil -- 1621 */
			tmp[j++] = IValue[i];
		    }
		}
	    }
	    StrAllocCopy(IValue, (const char *) tmp);
	    FREE(tmp);
	}
    }

    /*
     * Special case of OPTION.
     * Is handled above if radio type and LYSelectPopups is FALSE.
     */
    /* set the values and let the parsing below do the work */
    if (I->type != NULL && !strcmp(I->type, "OPTION")) {
	cp_option = I->type;
	if (HTCurSelectGroupType == F_RADIO_TYPE)
	    I->type = "OPTION_LIST";
	else
	    I->type = "CHECKBOX";
	I->name = HTCurSelectGroup;
	I->name_cs = HTCurSelectGroupCharset;

	/*
	 * The option's size parameter actually gives the length and not
	 * the width of the list.  Perform the conversion here
	 * and get rid of the allocated HTCurSelect....
	 * 0 is ok as it means any length (arbitrary decision).
	 */
	if (HTCurSelectGroupSize != NULL) {
	    f->size_l = atoi(HTCurSelectGroupSize);
	    FREE(HTCurSelectGroupSize);
	}
    }

    /*
     * Set SIZE.
     */
    if (I->size != 0) {
	f->size = I->size;
	/*
	 * Leave at zero for option lists.
	 */
	if (f->size == 0 && cp_option == NULL) {
	    f->size = 20;	/* default */
	}
    } else {
	f->size = 20;		/* default */
    }

    /*
     * Set MAXLENGTH.
     */
    if (I->maxlength != NULL) {
	f->maxlength = atoi(I->maxlength);
    } else {
	f->maxlength = 0;	/* 0 means infinite */
    }

    /*
     * Set CHECKED
     * (num_value is only relevant to check and radio types).
     */
    if (I->checked == TRUE)
	f->num_value = 1;
    else
	f->num_value = 0;

    /*
     * Set TYPE.
     */
    if (I->type != NULL) {
	if (!strcasecomp(I->type, "password")) {
	    f->type = F_PASSWORD_TYPE;
	} else if (!strcasecomp(I->type, "checkbox")) {
	    f->type = F_CHECKBOX_TYPE;
	} else if (!strcasecomp(I->type, "radio")) {
	    f->type = F_RADIO_TYPE;
	} else if (!strcasecomp(I->type, "submit")) {
	    f->type = F_SUBMIT_TYPE;
	} else if (!strcasecomp(I->type, "image")) {
	    f->type = F_IMAGE_SUBMIT_TYPE;
	} else if (!strcasecomp(I->type, "reset")) {
	    f->type = F_RESET_TYPE;
	} else if (!strcasecomp(I->type, "OPTION_LIST")) {
	    f->type = F_OPTION_LIST_TYPE;
	} else if (!strcasecomp(I->type, "hidden")) {
	    f->type = F_HIDDEN_TYPE;
	    HTFormFields--;
	    f->size = 0;
	} else if (!strcasecomp(I->type, "textarea")) {
	    f->type = F_TEXTAREA_TYPE;
	} else if (!strcasecomp(I->type, "range")) {
	    f->type = F_RANGE_TYPE;
	} else if (!strcasecomp(I->type, "file")) {
	    f->type = F_FILE_TYPE;
	    CTRACE((tfp, "ok, got a file uploader\n"));
	} else if (!strcasecomp(I->type, "keygen")) {
	    f->type = F_KEYGEN_TYPE;
	} else {
	    /*
	     * Note that TYPE="scribble" defaults to TYPE="text".  -FM
	     */
	    f->type = F_TEXT_TYPE;	/* default */
	}
    } else {
	f->type = F_TEXT_TYPE;
    }

    /*
     * Set NAME.
     */
    if (I->name != NULL) {
	StrAllocCopy(f->name, I->name);
	f->name_cs = I->name_cs;
    } else {
	if (f->type == F_RESET_TYPE ||
	    f->type == F_SUBMIT_TYPE ||
	    f->type == F_IMAGE_SUBMIT_TYPE) {
	    /*
	     * Set name to empty string.
	     */
	    StrAllocCopy(f->name, "");
	} else {
	    /*
	     * Error!  NAME must be present.
	     */
	    CTRACE((tfp,
		    "GridText: No name present in input field; not displaying\n"));
	    FREE(IValue);
	    return (0);
	}
    }

    /*
     * Add this anchor to the anchor list
     */
    if (text->last_anchor) {
	text->last_anchor->next = a;
    } else {
	text->first_anchor = a;
    }

    /*
     * Set VALUE, if it exists.  Otherwise, if it's not
     * an option list make it a zero-length string.  -FM
     */
    if (IValue != NULL) {
	/*
	 * OPTION VALUE is not actually the value to be seen but is to
	 * be sent....
	 */
	if (f->type == F_OPTION_LIST_TYPE ||
	    f->type == F_CHECKBOX_TYPE) {
	    /*
	     * Fill both with the value.  The f->value may be
	     * overwritten in HText_setLastOptionValue....
	     */
	    StrAllocCopy(f->value, IValue);
	    StrAllocCopy(f->cp_submit_value, IValue);
	} else {
	    StrAllocCopy(f->value, IValue);
	}
	f->value_cs = I->value_cs;
    } else if (f->type != F_OPTION_LIST_TYPE) {
	StrAllocCopy(f->value, "");
	/*
	 * May be an empty INPUT field.  The text entered will then
	 * probably be in the current display character set.  - kw
	 */
	f->value_cs = current_char_set;
    }

    /*
     * Run checks and fill in necessary values.
     */
    if (f->type == F_RESET_TYPE) {
	if (non_empty(f->value)) {
	    f->size = strlen(f->value);
	} else {
	    StrAllocCopy(f->value, "Reset");
	    f->size = 5;
	}
    } else if (f->type == F_IMAGE_SUBMIT_TYPE ||
	       f->type == F_SUBMIT_TYPE) {
	if (non_empty(f->value)) {
	    f->size = strlen(f->value);
	} else if (f->type == F_IMAGE_SUBMIT_TYPE) {
	    StrAllocCopy(f->value, "[IMAGE]-Submit");
	    f->size = 14;
	} else {
	    StrAllocCopy(f->value, "Submit");
	    f->size = 6;
	}
	f->submit_action = NULL;
	StrAllocCopy(f->submit_action, HTFormAction);
	if (HTFormEnctype != NULL)
	    StrAllocCopy(f->submit_enctype, HTFormEnctype);
	if (HTFormTitle != NULL)
	    StrAllocCopy(f->submit_title, HTFormTitle);
	f->submit_method = HTFormMethod;

    } else if (f->type == F_RADIO_TYPE || f->type == F_CHECKBOX_TYPE) {
	f->size = 3;
	if (IValue == NULL)
	    StrAllocCopy(f->value, (f->type == F_CHECKBOX_TYPE ? "on" : ""));

    }
    FREE(IValue);

    /*
     * Set original values.
     */
    if (f->type == F_RADIO_TYPE || f->type == F_CHECKBOX_TYPE) {
	if (f->num_value)
	    StrAllocCopy(f->orig_value, "1");
	else
	    StrAllocCopy(f->orig_value, "0");
    } else if (f->type == F_OPTION_LIST_TYPE) {
	f->orig_value = NULL;
    } else {
	StrAllocCopy(f->orig_value, f->value);
    }

    /*
     * Store accept-charset if present, converting to lowercase
     * and collapsing spaces.  - kw
     */
    if (I->accept_cs) {
	StrAllocCopy(f->accept_cs, I->accept_cs);
	LYRemoveBlanks(f->accept_cs);
	LYLowerCase(f->accept_cs);
    }

    /*
     * Add numbers to form fields if needed.  - LE & FM
     */
    switch (f->type) {
	/*
	 * Do not supply number for hidden fields, nor
	 * for types that are not yet implemented.
	 */
    case F_HIDDEN_TYPE:
#ifndef USE_FILE_UPLOAD
    case F_FILE_TYPE:
#endif
    case F_RANGE_TYPE:
    case F_KEYGEN_TYPE:
	a->number = 0;
	break;

    default:
	if (fields_are_numbered())
	    a->number = ++(text->last_anchor_number);
	else
	    a->number = 0;
	break;
    }
    if (fields_are_numbered() && (a->number > 0)) {
	sprintf(marker, "[%d]", a->number);
	if (number_fields_on_left) {
	    BOOL had_bracket = (f->type == F_OPTION_LIST_TYPE);

	    HText_appendText(text, had_bracket ? (marker + 1) : marker);
	    if (had_bracket)
		HText_appendCharacter(text, '[');
	} else {
	    adjust_marker = strlen(marker);
	}
	a->line_num = text->Lines;
	a->line_pos = text->last_line->size;
    } else {
	*marker = '\0';
    }

    /*
     * Restrict SIZE to maximum allowable size.
     */
    MaximumSize = WRAP_COLS(text) + 1 - adjust_marker;
    switch (f->type) {

    case F_SUBMIT_TYPE:
    case F_IMAGE_SUBMIT_TYPE:
    case F_RESET_TYPE:
    case F_TEXT_TYPE:
    case F_TEXTAREA_TYPE:
	/*
	 * For submit and reset buttons, and for text entry
	 * fields and areas, we limit the size element to that
	 * of one line for the current style because that's
	 * the most we could highlight on overwrites, and/or
	 * handle in the line editor.  The actual values for
	 * text entry lines can be long, and will be scrolled
	 * horizontally within the editing window.  -FM
	 */
	MaximumSize -= (1 +
			(int) text->style->leftIndent +
			(int) text->style->rightIndent);

	/*  If we are numbering form links, place is taken by [nn]  */
	if (fields_are_numbered()) {
	    if (!number_fields_on_left
		&& f->type == F_TEXT_TYPE
		&& MaximumSize > a->line_pos + 10)
		MaximumSize -= a->line_pos;
	    else
		MaximumSize -= strlen(marker);
	}

	/*
	 * Save value for submit/reset buttons so they
	 * will be visible when printing the page.  - LE
	 */
	I->value = f->value;
	break;

    default:
	/*
	 * For all other fields we limit the size element to
	 * 10 less than the screen width, because either they
	 * are types with small placeholders, and/or are a
	 * type which is handled via a popup window.  -FM
	 */
	MaximumSize -= 10;
	break;
    }
    if (f->size > MaximumSize)
	f->size = MaximumSize;

    /*
     * Add this anchor to the anchor list
     */
    text->last_anchor = a;

    if (HTCurrentForm) {	/* should always apply! - kw */
	if (!HTCurrentForm->first_field) {
	    HTCurrentForm->first_field = f;
	}
	HTCurrentForm->last_field = f;
	HTCurrentForm->nfields++;	/* will count hidden fields - kw */
	/*
	 * Propagate form field's accept-charset attribute to enclosing
	 * form if the form itself didn't have an accept-charset - kw
	 */
	if (f->accept_cs && !HTFormAcceptCharset) {
	    StrAllocCopy(HTFormAcceptCharset, f->accept_cs);
	}
	if (!text->forms) {
	    text->forms = HTList_new();
	}
    } else {
	CTRACE((tfp, "beginInput: HTCurrentForm is missing!\n"));
    }

    CTRACE((tfp, "Input link: name=%s\nvalue=%s\nsize=%d\n",
	    f->name,
	    NonNull(f->value),
	    f->size));
    CTRACE((tfp, "Input link: name_cs=%d \"%s\" (from %d \"%s\")\n",
	    f->name_cs,
	    (f->name_cs >= 0 ?
	     LYCharSet_UC[f->name_cs].MIMEname : "<UNKNOWN>"),
	    I->name_cs,
	    (I->name_cs >= 0 ?
	     LYCharSet_UC[I->name_cs].MIMEname : "<UNKNOWN>")));
    CTRACE((tfp, "            value_cs=%d \"%s\" (from %d \"%s\")\n",
	    f->value_cs,
	    (f->value_cs >= 0 ?
	     LYCharSet_UC[f->value_cs].MIMEname : "<UNKNOWN>"),
	    I->value_cs,
	    (I->value_cs >= 0 ?
	     LYCharSet_UC[I->value_cs].MIMEname : "<UNKNOWN>")));

    /*
     * Return the SIZE of the input field.
     */
    return (f->size);
}

/*
 * If we're numbering fields on the right, do it.  Note that some fields may
 * be too long for the line - we'll lose the marker in that case rather than
 * truncate the field.
 */
void HText_endInput(HText *text)
{
    if (fields_are_numbered()
	&& !number_fields_on_left
	&& text != NULL
	&& text->last_anchor != NULL
	&& text->last_anchor->number > 0) {
	char marker[20];

	HText_setIgnoreExcess(text, FALSE);
	sprintf(marker, "[%d]", text->last_anchor->number);
	HText_appendText(text, marker);
    }
}

/*
 * Get a translation (properly:  transcoding) quality, factoring in
 * our ability to translate (an UCTQ_t) and a possible q parameter
 * on the given charset string, for cs_from -> givenmime.
 * The parsed input string will be mutilated on exit(!).
 * Note that results are not normalised to 1.0, but results from
 * different calls of this function can be compared.  - kw
 *
 * Obsolete, it was planned to use here a quality parametr UCTQ_t,
 * which is boolean now.
 */
static double get_trans_q(int cs_from,
			  char *givenmime)
{
    double df = 1.0;
    BOOL tq;
    char *p;

    if (!givenmime || !(*givenmime))
	return 0.0;
    if ((p = strchr(givenmime, ';')) != NULL) {
	*p++ = '\0';
    }
    if (!strcmp(givenmime, "*"))
	tq = UCCanTranslateFromTo(cs_from,
				  UCGetLYhndl_byMIME("utf-8"));
    else
	tq = UCCanTranslateFromTo(cs_from,
				  UCGetLYhndl_byMIME(givenmime));
    if (!tq)
	return 0.0;
    if (non_empty(p)) {
	char *pair, *field = p, *pval, *ptok;

	/* Get all the parameters to the Charset */
	while ((pair = HTNextTok(&field, ";", "\"", NULL)) != NULL) {
	    if ((ptok = HTNextTok(&pair, "= ", NULL, NULL)) != NULL &&
		(pval = HTNextField(&pair)) != NULL) {
		if (0 == strcasecomp(ptok, "q")) {
		    df = strtod(pval, NULL);
		    break;
		}
	    }
	}
	return (df * tq);
    } else {
	return tq;
    }
}

/*
 * Find the best charset for submission, if we have an ACCEPT_CHARSET
 * list.  It factors in how well we can translate (just as guess, and
 * not a very good one..) and possible ";q=" factors.  Yes this is
 * more general than it needs to be here.
 *
 * Input is cs_in and acceptstring.
 *
 * Will return charset handle as int.
 * best_csname will point to a newly allocated MIME string for the
 * charset corresponding to the return value if return value >= 0.
 * - kw
 */
static int find_best_target_cs(char **best_csname,
			       int cs_from,
			       const char *acceptstring)
{
    char *paccept = NULL;
    double bestq = -1.0;
    char *bestmime = NULL;
    char *field, *nextfield;

    StrAllocCopy(paccept, acceptstring);
    nextfield = paccept;
    while ((field = HTNextTok(&nextfield, ",", "\"", NULL)) != NULL) {
	double q;

	if (*field != '\0') {
	    /* Get the Charset */
	    q = get_trans_q(cs_from, field);
	    if (q > bestq) {
		bestq = q;
		bestmime = field;
	    }
	}
    }
    if (bestmime) {
	if (!strcmp(bestmime, "*"))	/* non-standard for HTML attribute.. */
	    StrAllocCopy(*best_csname, "utf-8");
	else
	    StrAllocCopy(*best_csname, bestmime);
	FREE(paccept);
	if (bestq > 0)
	    return (UCGetLYhndl_byMIME(*best_csname));
	else
	    return (-1);
    }
    FREE(paccept);
    return (-1);
}

#ifdef USE_FILE_UPLOAD
static void load_a_file(const char *val_used,
			bstring **result)
{
    FILE *fd;
    size_t bytes;
    char buffer[257];

    CTRACE((tfp, "Ok, about to convert %s to mime/thingy\n", val_used));

    if (*val_used) {		/* ignore empty form field */
	if ((fd = fopen(val_used, BIN_R)) == 0) {
	    HTAlert(gettext("Can't open file for uploading"));
	} else {
	    while ((bytes = fread(buffer, sizeof(char), 256, fd)) != 0) {
		HTSABCat(result, buffer, bytes);
	    }
	    LYCloseInput(fd);
	}
    }
}

static const char *guess_content_type(const char *filename)
{
    HTAtom *encoding;
    const char *desc;
    HTFormat format = HTFileFormat(filename, &encoding, &desc);

    return (format != 0 && non_empty(format->name))
	? format->name
	: "text/plain";
}
#endif /* USE_FILE_UPLOAD */

static void cannot_transcode(BOOL *had_warning,
			     const char *target_csname)
{
    if (*had_warning == NO) {
	*had_warning = YES;
	_user_message(CANNOT_TRANSCODE_FORM,
		      target_csname ? target_csname : "UNKNOWN");
	LYSleepAlert();
    }
}

#define SPECIAL_8BIT 1
#define SPECIAL_FORM 2

static unsigned check_form_specialchars(const char *value)
{
    unsigned result = 0;
    const char *p;

    for (p = value;
	 non_empty(p) && (result != (SPECIAL_8BIT | SPECIAL_FORM));
	 p++) {
	if ((*p == HT_NON_BREAK_SPACE) ||
	    (*p == HT_EN_SPACE) ||
	    (*p == LY_SOFT_HYPHEN)) {
	    result |= SPECIAL_FORM;
	} else if ((*p & 0x80) != 0) {
	    result |= SPECIAL_8BIT;
	}
    }
    return result;
}

/*
 * Scan the given data, adding characters to the MIME-boundary to keep it from
 * matching any part of the data.
 */
static void UpdateBoundary(char **Boundary,
			   bstring *data)
{
    int j;
    int have = strlen(*Boundary);
    int last = BStrLen(data);
    char *text = BStrData(data);
    char *want = *Boundary;

    for (j = 0; j <= (last - have); ++j) {
	if (want[0] == text[j]
	    && !memcmp(want, text + j, have)) {
	    char temp[2];

	    temp[0] = isdigit(text[have + j]) ? 'a' : '0';
	    temp[1] = '\0';
	    StrAllocCat(want, temp);
	    ++have;
	}
    }
    *Boundary = want;
}

/*
 * Convert a string to base64
 */
static char *convert_to_base64(const char *src,
			       int len)
{
#define B64_LINE       76

    static const char basis_64[] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    char *dest;
    int rlen;			/* length of result string */
    unsigned char c1, c2, c3;
    const char *eol;
    char *r;
    const char *str;
    int eollen;
    int chunk;

    str = src;
    eol = "\n";
    eollen = 1;

    /* calculate the length of the result */
    rlen = (len + 2) / 3 * 4;	/* encoded bytes */
    if (rlen) {
	/* add space for EOL */
	rlen += ((rlen - 1) / B64_LINE + 1) * eollen;
    }

    /* allocate a result buffer */
    if ((dest = (char *) malloc(rlen + 1)) == NULL) {
	outofmem(__FILE__, "convert_to_base64");
    }
    r = dest;

    /* encode */
    for (chunk = 0; len > 0; len -= 3, chunk++) {
	if (chunk == (B64_LINE / 4)) {
	    const char *c = eol;
	    const char *e = eol + eollen;

	    while (c < e)
		*r++ = *c++;
	    chunk = 0;
	}
	c1 = *str++;
	c2 = *str++;
	*r++ = basis_64[c1 >> 2];
	*r++ = basis_64[((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4)];
	if (len > 2) {
	    c3 = *str++;
	    *r++ = basis_64[((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6)];
	    *r++ = basis_64[c3 & 0x3F];
	} else if (len == 2) {
	    *r++ = basis_64[(c2 & 0xF) << 2];
	    *r++ = '=';
	} else {		/* len == 1 */
	    *r++ = '=';
	    *r++ = '=';
	}
    }
    if (rlen) {
	/* append eol to the result string */
	const char *c = eol;
	const char *e = eol + eollen;

	while (c < e)
	    *r++ = *c++;
    }
    *r = '\0';

    return dest;
}

typedef enum {
    NO_QUOTE			/* no quoting needed */
    ,QUOTE_MULTI		/* multipart */
    ,QUOTE_BASE64		/* encode as base64 */
    ,QUOTE_SPECIAL		/* escape special characters only */
} QuoteData;

typedef struct {
    int type;			/* the type of this field */
    BOOL first;			/* true if this begins a submission part */
    char *name;			/* the name of this field */
    char *value;		/* the nominal value of this field */
    bstring *data;		/* its data, which is usually the same as the value */
    QuoteData quote;		/* how to quote/translate the data */
} PostData;

static char *escape_or_quote_name(const char *name,
				  QuoteData quoting,
				  const char *MultipartContentType)
{
    char *escaped1 = NULL;

    switch (quoting) {
    case NO_QUOTE:
	StrAllocCopy(escaped1, name);
	break;
    case QUOTE_MULTI:
    case QUOTE_BASE64:
	StrAllocCopy(escaped1, "Content-Disposition: form-data");
	HTSprintf(&escaped1, "; name=\"%s\"", name);
	if (MultipartContentType)
	    HTSprintf(&escaped1, MultipartContentType, "text/plain");
	if (quoting == QUOTE_BASE64)
	    StrAllocCat(escaped1, "\r\nContent-Transfer-Encoding: base64");
	StrAllocCat(escaped1, "\r\n\r\n");
	break;
    case QUOTE_SPECIAL:
	escaped1 = HTEscapeSP(name, URL_XALPHAS);
	break;
    }
    return escaped1;
}

static char *escape_or_quote_value(const char *value,
				   QuoteData quoting)
{
    char *escaped2 = NULL;

    switch (quoting) {
    case NO_QUOTE:
    case QUOTE_MULTI:
	StrAllocCopy(escaped2, NonNull(value));
	break;
    case QUOTE_BASE64:
	/* FIXME: this is redundant */
	escaped2 = convert_to_base64(value, strlen(value));
	break;
    case QUOTE_SPECIAL:
	escaped2 = HTEscapeSP(value, URL_XALPHAS);
	break;
    }
    return escaped2;
}

/*
 * Check if we should encode the data in base64.  We can, only if we're using
 * a multipart content type.  We should, if we're sending mail and the data
 * contains long lines or nonprinting characters.
 */
static int check_if_base64_needed(int submit_method,
				  bstring *data)
{
    int width = 0;
    BOOL printable = TRUE;
    char *text = BStrData(data);

    if (text != 0) {
	int col = 0;
	int n;
	int length = BStrLen(data);

	for (n = 0; n < length; ++n) {
	    int ch = UCH(text[n]);

	    if (is8bits(ch) || ((ch < 32 && ch != '\n'))) {
		CTRACE((tfp, "nonprintable %d:%#x\n", n, ch));
		printable = FALSE;
	    }
	    if (ch == '\n' || ch == '\r') {
		if (width < col)
		    width = col;
		col = 0;
	    } else {
		++col;
	    }
	}
	if (width < col)
	    width = col;
    }
    return !printable && ((submit_method == URL_MAIL_METHOD) && (width > 72));
}

/*
 * HText_SubmitForm - generate submit data from form fields.
 * For mailto forms, send the data.
 * For other methods, set fields in structure pointed to by doc
 * appropriately for next request.
 * Returns 1 if *doc set appropriately for next request,
 * 0 otherwise.  - kw
 */
int HText_SubmitForm(FormInfo * submit_item, DocInfo *doc, char *link_name,
		     char *link_value)
{
    BOOL had_chartrans_warning = NO;
    BOOL have_accept_cs = NO;
    BOOL success;
    BOOLEAN PlainText = FALSE;
    BOOLEAN SemiColon = FALSE;
    BOOL skip_field = FALSE;
    const char *out_csname;
    const char *target_csname = NULL;
    PerFormInfo *thisform;
    PostData *my_data = NULL;
    TextAnchor *anchor_ptr;
    bstring *my_query = NULL;
    char *Boundary = NULL;
    char *MultipartContentType = NULL;
    char *content_type_out = NULL;
    char *copied_name_used = NULL;
    char *copied_val_used = NULL;
    char *escaped1 = NULL;
    char *escaped2 = NULL;
    char *last_textarea_name = NULL;
    const char *name_used = "";
    char *previous_blanks = NULL;
    const char *val_used = "";
    int anchor_count = 0;
    int anchor_limit = 0;
    int form_number = submit_item->number;
    int result = 0;
    int target_cs = -1;
    int textarea_lineno = 0;
    unsigned form_is_special = 0;

    CTRACE((tfp, "SubmitForm\n  link_name=%s\n  link_value=%s\n", link_name, link_value));
    if (!HTMainText)
	return 0;

    thisform = (PerFormInfo *) HTList_objectAt(HTMainText->forms, form_number
					       - 1);
    /*  Sanity check */
    if (!thisform) {
	CTRACE((tfp, "SubmitForm: form %d not in HTMainText's list!\n",
		form_number));
    } else if (thisform->number != form_number) {
	CTRACE((tfp, "SubmitForm: failed sanity check, %d!=%d !\n",
		thisform->number, form_number));
	thisform = NULL;
    }

    if (isEmpty(submit_item->submit_action)) {
	CTRACE((tfp, "SubmitForm: no action given\n"));
	return 0;
    }

    /*
     * If we're mailing, make sure it's a mailto ACTION.  -FM
     */
    if ((submit_item->submit_method == URL_MAIL_METHOD) &&
	!isMAILTO_URL(submit_item->submit_action)) {
	HTAlert(BAD_FORM_MAILTO);
	return 0;
    }

    /*
     * Check the ENCTYPE and set up the appropriate variables.  -FM
     */
    if (submit_item->submit_enctype &&
	!strncasecomp(submit_item->submit_enctype, "text/plain", 10)) {
	/*
	 * Do not hex escape, and use physical newlines
	 * to separate name=value pairs.  -FM
	 */
	PlainText = TRUE;
    } else if (submit_item->submit_enctype &&
	       !strncasecomp(submit_item->submit_enctype,
			     "application/sgml-form-urlencoded", 32)) {
	/*
	 * Use semicolons instead of ampersands as the
	 * separators for name=value pairs.  -FM
	 */
	SemiColon = TRUE;
    } else if (submit_item->submit_enctype &&
	       !strncasecomp(submit_item->submit_enctype,
			     "multipart/form-data", 19)) {
	/*
	 * Use the multipart MIME format.  Later we will ensure it does not
	 * occur within the content.
	 */
	Boundary = "xnyLAaB03X";
    }

    /*
     * Determine in what character encoding (aka.  charset) we should
     * submit.  We call this target_cs and the MIME name for it
     * target_csname.
     * TODO:   - actually use ACCEPT-CHARSET stuff from FORM
     * TODO:   - deal with list in ACCEPT-CHARSET, find a "best"
     *           charset to submit
     */

    /* Look at ACCEPT-CHARSET on the submitting field if we have one. */
    if (thisform && submit_item->accept_cs &&
	strcasecomp(submit_item->accept_cs, "UNKNOWN")) {
	have_accept_cs = YES;
	target_cs = find_best_target_cs(&thisform->thisacceptcs,
					current_char_set,
					submit_item->accept_cs);
    }
    /* Look at ACCEPT-CHARSET on form as a whole if submitting field
     * didn't have one. */
    if (thisform && !have_accept_cs && thisform->accept_cs &&
	strcasecomp(thisform->accept_cs, "UNKNOWN")) {
	have_accept_cs = YES;
	target_cs = find_best_target_cs(&thisform->thisacceptcs,
					current_char_set,
					thisform->accept_cs);
    }
    if (have_accept_cs && (target_cs >= 0) && thisform->thisacceptcs) {
	target_csname = thisform->thisacceptcs;
    }

    if (target_cs < 0 &&
	HTMainText->node_anchor->charset &&
	*HTMainText->node_anchor->charset) {
	target_cs = UCGetLYhndl_byMIME(HTMainText->node_anchor->charset);
	if (target_cs >= 0) {
	    target_csname = HTMainText->node_anchor->charset;
	} else {
	    target_cs = UCLYhndl_for_unspec;	/* always >= 0 */
	    target_csname = LYCharSet_UC[target_cs].MIMEname;
	}
    }
    if (target_cs < 0) {
	target_cs = UCLYhndl_for_unspec;	/* always >= 0 */
    }

    /*
     * Go through list of anchors and get a "max." charset parameter - kw
     */
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {

	if (anchor_ptr->link_type != INPUT_ANCHOR)
	    continue;

	if (anchor_ptr->input_field->number == form_number &&
	    !anchor_ptr->input_field->disabled) {

	    FormInfo *form_ptr = anchor_ptr->input_field;
	    char *val = form_ptr->cp_submit_value != NULL
	    ? form_ptr->cp_submit_value
	    : form_ptr->value;

	    unsigned field_is_special = check_form_specialchars(val);
	    unsigned name_is_special = check_form_specialchars(form_ptr->name);

	    form_is_special = (field_is_special | name_is_special);

	    if (field_is_special == 0) {
		/* already ok */
	    } else if (target_cs < 0) {
		/* already confused */
	    } else if ((field_is_special & SPECIAL_8BIT) == 0
		       && (LYCharSet_UC[target_cs].enc == UCT_ENC_8859
			   || (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
		/* those specials will be trivial */
	    } else if (UCNeedNotTranslate(form_ptr->value_cs, target_cs)) {
		/* already ok */
	    } else if (UCCanTranslateFromTo(form_ptr->value_cs, target_cs)) {
		/* also ok */
	    } else if (UCCanTranslateFromTo(target_cs, form_ptr->value_cs)) {
		target_cs = form_ptr->value_cs;		/* try this */
		target_csname = NULL;	/* will be set after loop */
	    } else {
		target_cs = -1;	/* don't know what to do */
	    }

	    /*  Same for name */
	    if (name_is_special == 0) {
		/* already ok */
	    } else if (target_cs < 0) {
		/* already confused */
	    } else if ((name_is_special & SPECIAL_8BIT) == 0
		       && (LYCharSet_UC[target_cs].enc == UCT_ENC_8859
			   || (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
		/* those specials will be trivial */
	    } else if (UCNeedNotTranslate(form_ptr->name_cs, target_cs)) {
		/* already ok */
	    } else if (UCCanTranslateFromTo(form_ptr->name_cs, target_cs)) {
		/* also ok */
	    } else if (UCCanTranslateFromTo(target_cs, form_ptr->name_cs)) {
		target_cs = form_ptr->value_cs;		/* try this */
		target_csname = NULL;	/* will be set after loop */
	    } else {
		target_cs = -1;	/* don't know what to do */
	    }

	    ++anchor_limit;
	} else if (anchor_ptr->input_field->number > form_number) {
	    break;
	}
    }

    /*
     * If we have input fields (we expect this), make an array of them so we
     * can organize the data.
     */
    if (anchor_limit != 0) {
	my_data = typecallocn(PostData, anchor_limit);
	if (my_data == 0)
	    outofmem(__FILE__, "HText_SubmitForm");
    }

    if (target_csname == NULL && target_cs >= 0) {
	if ((form_is_special & SPECIAL_8BIT) != 0) {
	    target_csname = LYCharSet_UC[target_cs].MIMEname;
	} else if ((form_is_special & SPECIAL_FORM) != 0) {
	    target_csname = LYCharSet_UC[target_cs].MIMEname;
	} else {
	    target_csname = "us-ascii";
	}
    }

    if (submit_item->submit_method == URL_GET_METHOD && Boundary == NULL) {
	char *temp = NULL;

	StrAllocCopy(temp, submit_item->submit_action);
	/*
	 * Method is GET.  Clip out any anchor in the current URL.
	 */
	strtok(temp, "#");
	/*
	 * Clip out any old query in the current URL.
	 */
	strtok(temp, "?");
	/*
	 * Add the lead question mark for the new URL.
	 */
	StrAllocCat(temp, "?");
	BStrCat0(my_query, temp);
    } else {
	/*
	 * We are submitting POST content to a server,
	 * so load content_type_out.  This will be put in
	 * the post_content_type element if all goes well.  -FM, kw
	 */
	if (SemiColon == TRUE) {
	    StrAllocCopy(content_type_out,
			 "application/sgml-form-urlencoded");
	} else if (PlainText == TRUE) {
	    StrAllocCopy(content_type_out,
			 "text/plain");
	} else if (Boundary != NULL) {
	    StrAllocCopy(content_type_out,
			 "multipart/form-data");
	} else {
	    StrAllocCopy(content_type_out,
			 "application/x-www-form-urlencoded");
	}

	/*
	 * If the ENCTYPE is not multipart/form-data, append the
	 * charset we'll be sending to the post_content_type, IF
	 *  (1) there was an explicit accept-charset attribute, OR
	 *  (2) we have 8-bit or special chars, AND the document had
	 *      an explicit (recognized and accepted) charset parameter,
	 *      AND it or target_csname is different from iso-8859-1,
	 *      OR
	 *  (3) we have 8-bit or special chars, AND the document had
	 *      no explicit (recognized and accepted) charset parameter,
	 *      AND target_cs is different from the currently effective
	 *      assumed charset (which should have been set by the user
	 *      so that it reflects what the server is sending, if the
	 *      document is rendered correctly).
	 * For multipart/form-data the equivalent will be done later,
	 * separately for each form field.  - kw
	 */
	if (have_accept_cs
	    || ((form_is_special & SPECIAL_8BIT) != 0
		|| (form_is_special & SPECIAL_FORM) != 0)) {
	    if (target_cs >= 0 && target_csname) {
		if (Boundary == NULL) {
		    if ((HTMainText->node_anchor->charset &&
			 (strcmp(HTMainText->node_anchor->charset,
				 "iso-8859-1") ||
			  strcmp(target_csname, "iso-8859-1"))) ||
			(!HTMainText->node_anchor->charset &&
			 target_cs != UCLYhndl_for_unspec)) {
			HTSprintf(&content_type_out, "; charset=%s", target_csname);
		    }
		}
	    } else {
		cannot_transcode(&had_chartrans_warning, target_csname);
	    }
	}
    }

    out_csname = target_csname;

    /*
     * Build up a list of the input fields and their associated values.
     */
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {

	if (anchor_ptr->link_type != INPUT_ANCHOR)
	    continue;

	if (anchor_ptr->input_field->number == form_number &&
	    !anchor_ptr->input_field->disabled) {

	    FormInfo *form_ptr = anchor_ptr->input_field;
	    int out_cs;
	    QuoteData quoting = (PlainText
				 ? NO_QUOTE
				 : (Boundary
				    ? QUOTE_MULTI
				    : QUOTE_SPECIAL));

	    if (form_ptr->type != F_TEXTAREA_TYPE)
		textarea_lineno = 0;

	    CTRACE((tfp, "SubmitForm[%d/%d]: ",
		    anchor_count + 1, anchor_limit));

	    name_used = NonNull(form_ptr->name);

	    switch (form_ptr->type) {
	    case F_RESET_TYPE:
		CTRACE((tfp, "reset\n"));
		break;
#ifdef USE_FILE_UPLOAD
	    case F_FILE_TYPE:
		val_used = NonNull(form_ptr->value);
		CTRACE((tfp, "I will submit %s (from %s)\n",
			val_used, name_used));
		break;
#endif
	    case F_SUBMIT_TYPE:
	    case F_TEXT_SUBMIT_TYPE:
	    case F_IMAGE_SUBMIT_TYPE:
		if (!(non_empty(form_ptr->name) &&
		      !strcmp(form_ptr->name, link_name))) {
		    CTRACE((tfp, "skipping submit field with "));
		    CTRACE((tfp, "name \"%s\" for link_name \"%s\", %s.\n",
			    form_ptr->name ? form_ptr->name : "???",
			    link_name ? link_name : "???",
			    non_empty(form_ptr->name) ?
			    "not current link" : "no field name"));
		    break;
		}
		if (!(form_ptr->type == F_TEXT_SUBMIT_TYPE ||
		      (non_empty(form_ptr->value) &&
		       !strcmp(form_ptr->value, link_value)))) {
		    CTRACE((tfp, "skipping submit field with "));
		    CTRACE((tfp, "name \"%s\" for link_name \"%s\", %s!\n",
			    form_ptr->name ? form_ptr->name : "???",
			    link_name ? link_name : "???",
			    "values are different"));
		    break;
		}
		/* FALLTHRU */
	    case F_RADIO_TYPE:
	    case F_CHECKBOX_TYPE:
	    case F_TEXTAREA_TYPE:
	    case F_PASSWORD_TYPE:
	    case F_TEXT_TYPE:
	    case F_OPTION_LIST_TYPE:
	    case F_HIDDEN_TYPE:
		/*
		 * Be sure to actually look at the option submit value.
		 */
		if (form_ptr->cp_submit_value != NULL) {
		    val_used = form_ptr->cp_submit_value;
		} else {
		    val_used = form_ptr->value;
		}

		/*
		 * Charset-translate value now, because we need to know the
		 * charset parameter for multipart bodyparts.  - kw
		 */
		if (check_form_specialchars(val_used) != 0) {
		    /*  We should translate back. */
		    StrAllocCopy(copied_val_used, val_used);
		    success = LYUCTranslateBackFormData(&copied_val_used,
							form_ptr->value_cs,
							target_cs, PlainText);
		    CTRACE((tfp, "field \"%s\" %d %s -> %d %s %s\n",
			    NonNull(form_ptr->name),
			    form_ptr->value_cs,
			    form_ptr->value_cs >= 0
			    ? LYCharSet_UC[form_ptr->value_cs].MIMEname
			    : "???",
			    target_cs,
			    target_csname ? target_csname : "???",
			    success ? "OK" : "FAILED"));
		    if (success) {
			val_used = copied_val_used;
		    }
		} else {	/* We can use the value directly. */
		    CTRACE((tfp, "field \"%s\" %d %s OK\n",
			    NonNull(form_ptr->name),
			    target_cs,
			    target_csname ? target_csname : "???"));
		    success = YES;
		}
		if (!success) {
		    cannot_transcode(&had_chartrans_warning, target_csname);
		    out_cs = form_ptr->value_cs;
		} else {
		    out_cs = target_cs;
		}
		if (out_cs >= 0)
		    out_csname = LYCharSet_UC[out_cs].MIMEname;
		if (Boundary) {
		    StrAllocCopy(MultipartContentType,
				 "\r\nContent-Type: %s");
		    if (!success && form_ptr->value_cs < 0) {
			/*  This is weird. */
			out_csname = "UNKNOWN-8BIT";
		    } else if (!success) {
			target_csname = NULL;
		    } else {
			if (!target_csname) {
			    target_csname = LYCharSet_UC[target_cs].MIMEname;
			}
		    }
		    if (strcmp(out_csname, "iso-8859-1"))
			HTSprintf(&MultipartContentType, "; charset=%s", out_csname);
		}

		/*
		 * Charset-translate name now, because we need to know the
		 * charset parameter for multipart bodyparts.  - kw
		 */
		if (form_ptr->type == F_TEXTAREA_TYPE) {
		    textarea_lineno++;
		    if (textarea_lineno > 1 &&
			last_textarea_name && form_ptr->name &&
			!strcmp(last_textarea_name, form_ptr->name)) {
			break;
		    }
		}

		if (check_form_specialchars(name_used) != 0) {
		    /*  We should translate back. */
		    StrAllocCopy(copied_name_used, name_used);
		    success = LYUCTranslateBackFormData(&copied_name_used,
							form_ptr->name_cs,
							target_cs, PlainText);
		    CTRACE((tfp, "name \"%s\" %d %s -> %d %s %s\n",
			    NonNull(form_ptr->name),
			    form_ptr->name_cs,
			    form_ptr->name_cs >= 0
			    ? LYCharSet_UC[form_ptr->name_cs].MIMEname
			    : "???",
			    target_cs,
			    target_csname ? target_csname : "???",
			    success ? "OK" : "FAILED"));
		    if (success) {
			name_used = copied_name_used;
		    }
		    if (Boundary) {
			if (!success) {
			    StrAllocCopy(MultipartContentType, "");
			    target_csname = NULL;
			} else {
			    if (!target_csname)
				target_csname = LYCharSet_UC[target_cs].MIMEname;
			}
		    }
		} else {	/* We can use the name directly. */
		    CTRACE((tfp, "name \"%s\" %d %s OK\n",
			    NonNull(form_ptr->name),
			    target_cs,
			    target_csname ? target_csname : "???"));
		    success = YES;
		    if (Boundary) {
			StrAllocCopy(copied_name_used, name_used);
		    }
		}
		if (!success) {
		    cannot_transcode(&had_chartrans_warning, target_csname);
		}
		if (Boundary) {
		    /*
		     * According to RFC 1867, Non-ASCII field names
		     * "should be encoded according to the prescriptions
		     * of RFC 1522 [...].  I don't think RFC 1522 actually
		     * is meant to apply to parameters like this, and it
		     * is unknown whether any server would make sense of
		     * it, so for now just use some quoting/escaping and
		     * otherwise leave 8-bit values as they are.
		     * Non-ASCII characters in form field names submitted
		     * as multipart/form-data can only occur if the form
		     * provider specifically asked for it anyway.  - kw
		     */
		    HTMake822Word(&copied_name_used, FALSE);
		    name_used = copied_name_used;
		}

		break;
	    default:
		CTRACE((tfp, "What type is %d?\n", form_ptr->type));
		break;
	    }

	    skip_field = FALSE;
	    my_data[anchor_count].first = TRUE;
	    my_data[anchor_count].type = form_ptr->type;

	    /*
	     * Using the values of 'name_used' and 'val_used' computed in the
	     * previous case-statement, compute the 'first' and 'data' values
	     * for the current input field.
	     */
	    switch (form_ptr->type) {

	    default:
		skip_field = TRUE;
		break;

#ifdef USE_FILE_UPLOAD
	    case F_FILE_TYPE:
		load_a_file(val_used, &(my_data[anchor_count].data));
		break;
#endif /* USE_FILE_UPLOAD */

	    case F_SUBMIT_TYPE:
	    case F_TEXT_SUBMIT_TYPE:
	    case F_IMAGE_SUBMIT_TYPE:
		if ((non_empty(form_ptr->name) &&
		     !strcmp(form_ptr->name, link_name)) &&
		    (form_ptr->type == F_TEXT_SUBMIT_TYPE ||
		     (non_empty(form_ptr->value) &&
		      !strcmp(form_ptr->value, link_value)))) {
		    ;
		} else {
		    skip_field = TRUE;
		}
		break;

	    case F_RADIO_TYPE:
	    case F_CHECKBOX_TYPE:
		/*
		 * Only add if selected.
		 */
		if (form_ptr->num_value) {
		    ;
		} else {
		    skip_field = TRUE;
		}
		break;

	    case F_TEXTAREA_TYPE:
		if (!last_textarea_name ||
		    strcmp(last_textarea_name, form_ptr->name)) {
		    textarea_lineno = 1;
		    last_textarea_name = form_ptr->name;
		} else {
		    my_data[anchor_count].first = FALSE;
		}
		break;

	    case F_PASSWORD_TYPE:
	    case F_TEXT_TYPE:
	    case F_OPTION_LIST_TYPE:
	    case F_HIDDEN_TYPE:
		break;
	    }

	    /*
	     * If we did not decide to skip the current field, populate the
	     * values in the array for it.
	     */
	    if (!skip_field) {
		StrAllocCopy(my_data[anchor_count].name, name_used);
		StrAllocCopy(my_data[anchor_count].value, val_used);
		if (my_data[anchor_count].data == 0)
		    BStrCat0(my_data[anchor_count].data, val_used);
		my_data[anchor_count].quote = quoting;
		if (quoting == QUOTE_MULTI
		    && check_if_base64_needed(submit_item->submit_method,
					      my_data[anchor_count].data)) {
		    CTRACE((tfp, "will encode as base64\n"));
		    my_data[anchor_count].quote = QUOTE_BASE64;
		    escaped2 =
			convert_to_base64(BStrData(my_data[anchor_count].data),
					  BStrLen(my_data[anchor_count].data));
		    BStrCopy0(my_data[anchor_count].data, escaped2);
		    FREE(escaped2);
		}
	    }
	    ++anchor_count;

	    FREE(copied_name_used);
	    FREE(copied_val_used);

	} else if (anchor_ptr->input_field->number > form_number) {
	    break;
	}
    }

    FREE(copied_name_used);

    if (my_data != 0) {
	BOOL first_one = TRUE;

	/*
	 * If we're using a MIME-boundary, make it unique.
	 */
	if (content_type_out != 0 && Boundary != 0) {
	    Boundary = 0;
	    StrAllocCopy(Boundary, "LYNX");
	    for (anchor_count = 0; anchor_count < anchor_limit; ++anchor_count) {
		if (my_data[anchor_count].data != 0) {
		    UpdateBoundary(&Boundary, my_data[anchor_count].data);
		}
	    }
	    HTSprintf(&content_type_out, "; boundary=%s", Boundary);
	}

	for (anchor_count = 0; anchor_count < anchor_limit; ++anchor_count) {

	    if (my_data[anchor_count].name != 0
		&& my_data[anchor_count].value != 0) {

		CTRACE((tfp,
			"processing [%d:%d] name=%s(first:%d, value=%s, data=%p)\n",
			anchor_count + 1,
			anchor_limit,
			NonNull(my_data[anchor_count].name),
			my_data[anchor_count].first,
			NonNull(my_data[anchor_count].value),
			my_data[anchor_count].data));

		if (my_data[anchor_count].first) {
		    if (first_one) {
			if (Boundary) {
			    HTBprintf(&my_query, "--%s\r\n", Boundary);
			}
			first_one = FALSE;
		    } else {
			if (PlainText) {
			    BStrCat0(my_query, "\n");
			} else if (SemiColon) {
			    BStrCat0(my_query, ";");
			} else if (Boundary) {
			    HTBprintf(&my_query, "\r\n--%s\r\n", Boundary);
			} else {
			    BStrCat0(my_query, "&");
			}
		    }
		}

		/* append a null to the string */
		HTSABCat(&(my_data[anchor_count].data), "", 1);
		name_used = my_data[anchor_count].name;
		val_used = my_data[anchor_count].value;

	    } else {
		/* there is no data to send */
		continue;
	    }

	    switch (my_data[anchor_count].type) {
	    case F_TEXT_TYPE:
	    case F_PASSWORD_TYPE:
	    case F_OPTION_LIST_TYPE:
	    case F_HIDDEN_TYPE:
		escaped1 = escape_or_quote_name(my_data[anchor_count].name,
						my_data[anchor_count].quote,
						MultipartContentType);

		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);

		HTBprintf(&my_query,
			  "%s%s%s%s%s",
			  escaped1,
			  (Boundary ? "" : "="),
			  (PlainText ? "\n" : ""),
			  escaped2,
			  ((PlainText && *escaped2) ? "\n" : ""));
		break;
	    case F_CHECKBOX_TYPE:
	    case F_RADIO_TYPE:
		escaped1 = escape_or_quote_name(my_data[anchor_count].name,
						my_data[anchor_count].quote,
						MultipartContentType);

		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);

		HTBprintf(&my_query,
			  "%s%s%s%s%s",
			  escaped1,
			  (Boundary ? "" : "="),
			  (PlainText ? "\n" : ""),
			  escaped2,
			  ((PlainText && *escaped2) ? "\n" : ""));
		break;
	    case F_SUBMIT_TYPE:
	    case F_TEXT_SUBMIT_TYPE:
	    case F_IMAGE_SUBMIT_TYPE:
		/*
		 * If it has a non-zero length name (e.g., because
		 * its IMAGE_SUBMIT_TYPE is to be handled homologously
		 * to an image map, or a SUBMIT_TYPE in a set of
		 * multiple submit buttons, or a single type="text"
		 * that's been converted to a TEXT_SUBMIT_TYPE),
		 * include the name=value pair, or fake name.x=0 and
		 * name.y=0 pairs for IMAGE_SUBMIT_TYPE.  -FM
		 */
		escaped1 = escape_or_quote_name(my_data[anchor_count].name,
						my_data[anchor_count].quote,
						MultipartContentType);

		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);

		if (my_data[anchor_count].type == F_IMAGE_SUBMIT_TYPE) {
		    /*
		     * It's a clickable image submit button.  Fake a 0,0
		     * coordinate pair, which typically returns the image's
		     * default.  -FM
		     */
		    if (Boundary) {
			*(strchr(escaped1, '=') + 1) = '\0';
			HTBprintf(&my_query,
				  "%s\"%s.x\"\r\n\r\n0\r\n--%s\r\n%s\"%s.y\"\r\n\r\n0",
				  escaped1,
				  my_data[anchor_count].name,
				  Boundary,
				  escaped1,
				  my_data[anchor_count].name);
		    } else {
			HTBprintf(&my_query,
				  "%s.x=0%s%s.y=0%s",
				  escaped1,
				  (PlainText ?
				   "\n" : (SemiColon ?
					   ";" : "&")),
				  escaped1,
				  ((PlainText && *escaped1) ?
				   "\n" : ""));
		    }
		} else {
		    /*
		     * It's a standard submit button.  Use the name=value
		     * pair.  = FM
		     */
		    HTBprintf(&my_query,
			      "%s%s%s%s%s",
			      escaped1,
			      (Boundary ? "" : "="),
			      (PlainText ? "\n" : ""),
			      escaped2,
			      ((PlainText && *escaped2) ? "\n" : ""));
		}
		break;
	    case F_RESET_TYPE:
		/* ignore */
		break;
	    case F_TEXTAREA_TYPE:
		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);

		if (my_data[anchor_count].first) {
		    textarea_lineno = 1;
		    /*
		     * Names are different so this is the first textarea or a
		     * different one from any before it.
		     */
		    if (PlainText) {
			FREE(previous_blanks);
		    } else if (Boundary) {
			StrAllocCopy(previous_blanks, "\r\n");
		    } else {
			StrAllocCopy(previous_blanks, "%0d%0a");
		    }
		    escaped1 = escape_or_quote_name(name_used,
						    my_data[anchor_count].quote,
						    MultipartContentType);

		    HTBprintf(&my_query,
			      "%s%s%s%s%s",
			      escaped1,
			      (Boundary ? "" : "="),
			      (PlainText ? "\n" : ""),
			      escaped2,
			      ((PlainText && *escaped2) ? "\n" : ""));
		} else {
		    const char *marker = (PlainText
					  ? "\n"
					  : (Boundary
					     ? "\r\n"
					     : "%0d%0a"));

		    /*
		     * This is a continuation of a previous textarea.
		     */
		    if (escaped2[0] != '\0') {
			if (previous_blanks) {
			    BStrCat0(my_query, previous_blanks);
			    FREE(previous_blanks);
			}
			BStrCat0(my_query, escaped2);
			if (PlainText || Boundary)
			    BStrCat0(my_query, marker);
			else
			    StrAllocCopy(previous_blanks, marker);
		    } else {
			StrAllocCat(previous_blanks, marker);
		    }
		}
		break;
	    case F_RANGE_TYPE:
		/* not implemented */
		break;
#ifdef USE_FILE_UPLOAD
	    case F_FILE_TYPE:
		if (PlainText) {
		    StrAllocCopy(escaped1, my_data[anchor_count].name);
		} else if (Boundary) {
		    const char *t = guess_content_type(val_used);

		    StrAllocCopy(escaped1, "Content-Disposition: form-data");
		    HTSprintf(&escaped1, "; name=\"%s\"",
			      my_data[anchor_count].name);
		    HTSprintf(&escaped1, "; filename=\"%s\"", val_used);
		    /* Should we take into account the encoding? */
		    HTSprintf(&escaped1, "\r\nContent-Type: %s", t);
		    if (my_data[anchor_count].quote == QUOTE_BASE64)
			StrAllocCat(escaped1,
				    "\r\nContent-Transfer-Encoding: base64");
		    StrAllocCat(escaped1, "\r\n\r\n");
		} else {
		    escaped1 = HTEscapeSP(my_data[anchor_count].name, URL_XALPHAS);
		}

		HTBprintf(&my_query,
			  "%s%s%s",
			  escaped1,
			  (Boundary ? "" : "="),
			  (PlainText ? "\n" : ""));
		/*
		 * If we have anything more than the trailing null we added,
		 * append the file-data to the query.
		 */
		if (BStrLen(my_data[anchor_count].data) > 1) {
		    HTSABCat(&my_query,
			     BStrData(my_data[anchor_count].data),
			     BStrLen(my_data[anchor_count].data) - 1);
		    if (PlainText)
			HTBprintf(&my_query, "\n");
		}
		break;
#endif /* USE_FILE_UPLOAD */
	    case F_KEYGEN_TYPE:
		/* not implemented */
		break;
	    }

	    FREE(escaped1);
	    FREE(escaped2);
	}
	if (Boundary) {
	    HTBprintf(&my_query, "\r\n--%s--\r\n", Boundary);
	}
	/*
	 * The data may contain a null - so we use fwrite().
	 */
	if (TRACE) {
	    CTRACE((tfp, "Query %d{", BStrLen(my_query)));
	    trace_bstring(my_query);
	    CTRACE((tfp, "}\n"));
	}
    }

    if (submit_item->submit_method == URL_MAIL_METHOD) {
	HTUserMsg2(gettext("Submitting %s"), submit_item->submit_action);
	HTSABCat(&my_query, "", 1);	/* append null */
	mailform((submit_item->submit_action + 7),
		 (isEmpty(submit_item->submit_title)
		  ? NonNull(HText_getTitle())
		  : submit_item->submit_title),
		 BStrData(my_query),
		 content_type_out);
	result = 0;
	BStrFree(my_query);
	FREE(content_type_out);
    } else {
	_statusline(SUBMITTING_FORM);

	if (submit_item->submit_method == URL_POST_METHOD || Boundary) {
	    LYFreePostData(doc);
	    doc->post_data = my_query;
	    doc->post_content_type = content_type_out;	/* don't free c_t_out */
	    CTRACE((tfp, "GridText - post_data set:\n%s\n", content_type_out));
	    StrAllocCopy(doc->address, submit_item->submit_action);
	} else {		/* GET_METHOD */
	    HTSABCat(&my_query, "", 1);		/* append null */
	    StrAllocCopy(doc->address, BStrData(my_query));	/* FIXME? */
	    LYFreePostData(doc);
	    FREE(content_type_out);
	}
	result = 1;
    }

    FREE(MultipartContentType);
    FREE(previous_blanks);
    FREE(Boundary);
    if (my_data != 0) {
	for (anchor_count = 0; anchor_count < anchor_limit; ++anchor_count) {
	    FREE(my_data[anchor_count].name);
	    FREE(my_data[anchor_count].value);
	    BStrFree(my_data[anchor_count].data);
	}
	FREE(my_data);
    }

    return (result);
}

void HText_DisableCurrentForm(void)
{
    TextAnchor *anchor_ptr;

    HTFormDisabled = TRUE;
    if (!HTMainText)
	return;

    /*
     * Go through list of anchors and set the disabled flag.
     */
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
	if (anchor_ptr->link_type == INPUT_ANCHOR &&
	    anchor_ptr->input_field->number == HTFormNumber) {

	    anchor_ptr->input_field->disabled = TRUE;
	}
    }

    return;
}

void HText_ResetForm(FormInfo * form)
{
    TextAnchor *anchor_ptr;

    _statusline(RESETTING_FORM);
    if (HTMainText == 0)
	return;

    /*
     * Go through list of anchors and reset values.
     */
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
	if (anchor_ptr->link_type == INPUT_ANCHOR) {
	    if (anchor_ptr->input_field->number == form->number) {

		if (anchor_ptr->input_field->type == F_RADIO_TYPE ||
		    anchor_ptr->input_field->type == F_CHECKBOX_TYPE) {

		    if (anchor_ptr->input_field->orig_value[0] == '0')
			anchor_ptr->input_field->num_value = 0;
		    else
			anchor_ptr->input_field->num_value = 1;

		} else if (anchor_ptr->input_field->type ==
			   F_OPTION_LIST_TYPE) {
		    anchor_ptr->input_field->value =
			anchor_ptr->input_field->orig_value;

		    anchor_ptr->input_field->cp_submit_value =
			anchor_ptr->input_field->orig_submit_value;

		} else {
		    StrAllocCopy(anchor_ptr->input_field->value,
				 anchor_ptr->input_field->orig_value);
		}
	    } else if (anchor_ptr->input_field->number > form->number) {
		break;
	    }
	}
    }
}

/*
 * This function is called before reloading/reparsing current document to find
 * whether any forms content was changed by user so any information will be
 * lost.
 */
BOOLEAN HText_HaveUserChangedForms(HText *text)
{
    TextAnchor *anchor_ptr;

    if (text == 0)
	return FALSE;

    /*
     * Go through list of anchors to check if any value was changed.
     * This code based on HText_ResetForm()
     */
    for (anchor_ptr = text->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
	if (anchor_ptr->link_type == INPUT_ANCHOR) {

	    if (anchor_ptr->input_field->type == F_RADIO_TYPE ||
		anchor_ptr->input_field->type == F_CHECKBOX_TYPE) {

		if ((anchor_ptr->input_field->orig_value[0] == '0' &&
		     anchor_ptr->input_field->num_value == 1) ||
		    (anchor_ptr->input_field->orig_value[0] != '0' &&
		     anchor_ptr->input_field->num_value == 0))
		    return TRUE;

	    } else if (anchor_ptr->input_field->type == F_OPTION_LIST_TYPE) {
		if (strcmp(anchor_ptr->input_field->value,
			   anchor_ptr->input_field->orig_value))
		    return TRUE;

		if (strcmp(anchor_ptr->input_field->cp_submit_value,
			   anchor_ptr->input_field->orig_submit_value))
		    return TRUE;

	    } else {
		if (strcmp(anchor_ptr->input_field->value,
			   anchor_ptr->input_field->orig_value))
		    return TRUE;
	    }
	}
    }
    return FALSE;
}

void HText_activateRadioButton(FormInfo * form)
{
    TextAnchor *anchor_ptr;
    int form_number = form->number;

    if (!HTMainText)
	return;
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
	if (anchor_ptr->link_type == INPUT_ANCHOR &&
	    anchor_ptr->input_field->type == F_RADIO_TYPE) {

	    if (anchor_ptr->input_field->number == form_number) {

		/* if it has the same name and its on */
		if (!strcmp(anchor_ptr->input_field->name, form->name) &&
		    anchor_ptr->input_field->num_value) {
		    anchor_ptr->input_field->num_value = 0;
		    break;
		}
	    } else if (anchor_ptr->input_field->number > form_number) {
		break;
	    }

	}
    }

    form->num_value = 1;
}

#ifdef LY_FIND_LEAKS
/*
 *	Purpose:	Free all currently loaded HText objects in memory.
 *	Arguments:	void
 *	Return Value:	void
 *	Remarks/Portability/Dependencies/Restrictions:
 *		Usage of this function should really be limited to program
 *			termination.
 *	Revision History:
 *		05-27-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void free_all_texts(void)
{
    HText *cur = NULL;

    if (!loaded_texts)
	return;

    /*
     * Simply loop through the loaded texts list killing them off.
     */
    while (loaded_texts && !HTList_isEmpty(loaded_texts)) {
	if ((cur = (HText *) HTList_removeLastObject(loaded_texts)) != NULL) {
	    HText_free(cur);
	}
    }

    /*
     * Get rid of the text list.
     */
    if (loaded_texts) {
	HTList_delete(loaded_texts);
    }

    /*
     * Insurance for bad HTML.
     */
    FREE(HTCurSelectGroup);
    FREE(HTCurSelectGroupSize);
    FREE(HTCurSelectedOptionValue);
    FREE(HTFormAction);
    FREE(HTFormEnctype);
    FREE(HTFormTitle);
    FREE(HTFormAcceptCharset);
    PerFormInfo_free(HTCurrentForm);

    return;
}
#endif /* LY_FIND_LEAKS */

/*
 *  stub_HTAnchor_address is like HTAnchor_address, but it returns the
 *  parent address for child links.  This is only useful for traversal's
 *  where one does not want to index a text file N times, once for each
 *  of N internal links.  Since the parent link has already been taken,
 *  it won't go again, hence the (incorrect) links won't cause problems.
 */
char *stub_HTAnchor_address(HTAnchor * me)
{
    char *addr = NULL;

    if (me)
	StrAllocCopy(addr, me->parent->address);
    return addr;
}

void HText_setToolbar(HText *text)
{
    if (text)
	text->toolbar = TRUE;
    return;
}

BOOL HText_hasToolbar(HText *text)
{
    return (BOOL) ((text && text->toolbar) ? TRUE : FALSE);
}

void HText_setNoCache(HText *text)
{
    if (text)
	text->no_cache = TRUE;
    return;
}

BOOL HText_hasNoCacheSet(HText *text)
{
    return (BOOL) ((text && text->no_cache) ? TRUE : FALSE);
}

BOOL HText_hasUTF8OutputSet(HText *text)
{
    return (BOOL) ((text && text->T.output_utf8) ? TRUE : FALSE);
}

/*
 *  Check charset and set the kcode element. -FM
 *  Info on the input charset may be passed in in two forms,
 *  as a string (if given explicitly) and as a pointer to
 *  a LYUCcharset (from chartrans mechanism); either can be NULL.
 *  For Japanese the kcode will be reset at a space or explicit
 *  line or paragraph break, so what we set here may not last for
 *  long.  It's potentially more important not to set HTCJK to
 *  NOCJK unless we are sure. - kw
 */
void HText_setKcode(HText *text, const char *charset,
		    LYUCcharset *p_in)
{
    BOOL charset_explicit;

    if (!text)
	return;

    /*
     * Check whether we have some kind of info.  - kw
     */
    if (!charset && !p_in) {
	return;
    }
    charset_explicit = charset ? TRUE : FALSE;
    /*
     * If no explicit charset string, use the implied one.  - kw
     */
    if (!charset || *charset == '\0') {
	charset = p_in->MIMEname;
    }
    /*
     * Check whether we have a specified charset.  -FM
     */
    if (!charset || *charset == '\0') {
	return;
    }

    /*
     * We've included the charset, and not forced a download offer,
     * only if the currently selected character set can handle it,
     * so check the charset value and set the text->kcode element
     * appropriately.  -FM
     */
    /*  If charset isn't specified explicitely nor assumed,
     * p_in->MIMEname would be set as display charset.
     * So text->kcode sholud be set as SJIS or EUC here only if charset
     * is specified explicitely, otherwise text->kcode would cause
     * mishandling Japanese strings.  -- TH
     */
    if (charset_explicit && (!strcmp(charset, "shift_jis") ||
			     !strcmp(charset, "x-sjis") ||	/* 1997/11/28 (Fri) 18:11:33 */
			     !strcmp(charset, "x-shift-jis"))) {
	text->kcode = SJIS;
    } else if (charset_explicit
#ifdef EXP_JAPANESEUTF8_SUPPORT
	       && strcmp(charset, "utf-8")
#endif
	       && ((p_in && (p_in->enc == UCT_ENC_CJK)) ||
		   !strcmp(charset, "x-euc") ||		/* 1997/11/28 (Fri) 18:11:24 */
		   !strcmp(charset, "euc-jp") ||
		   !strncmp(charset, "x-euc-", 6) ||
		   !strcmp(charset, "euc-kr") ||
		   !strcmp(charset, "iso-2022-kr") ||
		   !strcmp(charset, "big5") ||
		   !strcmp(charset, "cn-big5") ||
		   !strcmp(charset, "euc-cn") ||
		   !strcmp(charset, "gb2312") ||
		   !strncmp(charset, "cn-gb", 5) ||
		   !strcmp(charset, "iso-2022-cn"))) {
	text->kcode = EUC;
    } else {
	/*
	 * If we get to here, it's not CJK, so disable that if
	 * it is enabled.  But only if we are quite sure.  -FM & kw
	 */
	text->kcode = NOKANJI;
	if (HTCJK != NOCJK) {
	    if (!p_in || ((p_in->enc != UCT_ENC_CJK)
#ifdef EXP_JAPANESEUTF8_SUPPORT
			  && (p_in->enc != UCT_ENC_UTF8)
#endif
		)) {
		HTCJK = NOCJK;
	    }
	}
    }

    if (charset_explicit
#ifdef EXP_JAPANESEUTF8_SUPPORT
	&& strcmp(charset, "utf-8")
#endif
	) {
	text->specified_kcode = text->kcode;
    } else {
	if (UCAssume_MIMEcharset) {
	    if (!strcmp(UCAssume_MIMEcharset, "euc-jp"))
		text->kcode = text->specified_kcode = EUC;
	    else if (!strcmp(UCAssume_MIMEcharset, "shift_jis"))
		text->kcode = text->specified_kcode = SJIS;
	}
    }

    return;
}

/*
 *  Set a permissible split at the current end of the last line. -FM
 */
void HText_setBreakPoint(HText *text)
{
    if (!text)
	return;

    /*
     * Can split here.  -FM
     */
    text->permissible_split = text->last_line->size;

    return;
}

/*
 *  This function determines whether a document which
 *  would be sought via the a URL that has a fragment
 *  directive appended is otherwise identical to the
 *  currently loaded document, and if so, returns
 *  FALSE, so that any no_cache directives can be
 *  overridden "safely", on the grounds that we are
 *  simply acting on the equivalent of a paging
 *  command.  Otherwise, it returns TRUE, i.e, that
 *  the target document might differ from the current,
 *  based on any caching directives or analyses which
 *  claimed or suggested this. -FM
 */
BOOL HText_AreDifferent(HTParentAnchor *anchor,
			const char *full_address)
{
    HTParentAnchor *MTanc;
    char *MTaddress;
    char *MTpound;

    /*
     * Do we have a loaded document and both
     * arguments for this function?
     */
    if (!(HTMainText && anchor && full_address))
	return TRUE;

    /*
     * Do we have both URLs?
     */
    MTanc = HTMainText->node_anchor;
    if (!(MTanc->address && anchor->address))
	return (TRUE);

    /*
     * Do we have a fragment associated with the target?
     */
    if (findPoundSelector(full_address) == NULL)
	return (TRUE);

    /*
     * Always treat client-side image map menus
     * as potentially stale, so we'll create a
     * fresh menu from the LynxMaps HTList.
     */
    if (isLYNXIMGMAP(anchor->address))
	return (TRUE);

    /*
     * Do the docs differ in the type of request?
     */
    if (MTanc->isHEAD != anchor->isHEAD)
	return (TRUE);

    /*
     * Are the actual URLs different, after factoring
     * out a "LYNXIMGMAP:" leader in the MainText URL
     * and its fragment, if present?
     */
    MTaddress = (isLYNXIMGMAP(MTanc->address)
		 ? MTanc->address + LEN_LYNXIMGMAP
		 : MTanc->address);
    MTpound = trimPoundSelector(MTaddress);
    if (strcmp(MTaddress, anchor->address)) {
	restorePoundSelector(MTpound);
	return (TRUE);
    }
    restorePoundSelector(MTpound);

    /*
     * If the MainText is not an image map menu,
     * do the docs have different POST contents?
     */
    if (MTaddress == MTanc->address) {
	if (MTanc->post_data) {
	    if (anchor->post_data) {
		if (!BINEQ(MTanc->post_data, anchor->post_data)) {
		    /*
		     * Both have contents, and they differ.
		     */
		    return (TRUE);
		}
	    } else {
		/*
		 * The loaded document has content, but the
		 * target doesn't, so they're different.
		 */
		return (TRUE);
	    }
	} else if (anchor->post_data) {
	    /*
	     * The loaded document does not have content, but
	     * the target does, so they're different.
	     */
	    return (TRUE);
	}
    }

    /*
     * We'll assume the target is a position in the currently
     * displayed document, and thus can ignore any header, META,
     * or other directives not to use a cached rendition.  -FM
     */
    return (FALSE);
}

#define CanTrimTextArea(c) \
    (LYtrimInputFields ? isspace(c) : ((c) == '\r' || (c) == '\n'))

/*
 * Cleanup new lines coming into a TEXTAREA from an external editor, or a
 * file, such that they are in a suitable format for TEXTAREA rendering,
 * display, and manipulation.  That means trimming off trailing whitespace
 * from the line, expanding TABS into SPACES, and substituting a printable
 * character for control chars, and the like.
 *
 * --KED 02/24/99
 */
static void cleanup_line_for_textarea(char *line,
				      int len)
{
    char tbuf[MAX_LINE];

    char *cp;
    char *p;
    char *s;
    int i;
    int n;

    /*
     * Whack off trailing whitespace from the line.
     */
    for (i = len, p = line + (len - 1); i != 0; p--, i--) {
	if (CanTrimTextArea(UCH(*p)))
	    *p = '\0';
	else
	    break;
    }

    if (strlen(line) != 0) {
	/*
	 * Expand any tab's, since they won't render properly in a TEXTAREA.
	 *
	 * [Is that "by spec", or just a "lynxism"?  As may be, it seems that
	 * such chars may cause other problems, too ...  with cursor movement,
	 * submit'ing, etc.  Probably needs looking into more deeply.]
	 */
	p = line;
	s = tbuf;

	while (*p) {
	    if ((cp = strchr(p, '\t')) != 0) {
		i = cp - p;
		s = (strncpy(s, p, i)) + i;
		n = TABSTOP - (i % TABSTOP);
		s = (strncpy(s, SPACES, n)) + n;
		p += (i + 1);

	    } else {

		strcpy(s, p);
		break;
	    }
	}

	/*
	 * Replace control chars with something printable.  Note that char
	 * substitution above 0x7f is dependent on the charset being used,
	 * and then only applies to the contiguous run of char values that
	 * are between 0x80, and the 1st real high-order-bit-set character,
	 * as specified by the charset.  In general (ie, for many character
	 * sets), that usually means the so-called "C1 control chars" that
	 * range from 0x80 thru 0x9f.  For EBCDIC machines, we only trim the
	 * (control) chars below a space (x'40').
	 *
	 * The assumption in all this is that the charset used in the editor,
	 * is compatible with the charset specified in lynx.
	 *
	 * [At some point in time, when/if lynx ever supports multibyte chars
	 * internally (eg, UCS-2, UCS-4, UTF-16, etc), this kind of thing may
	 * well cause problems.  But then, supporting such char sets will
	 * require massive changes in (most) all parts of the lynx code, so
	 * until then, we do the rational thing with char values that would
	 * otherwise foul the display, if left alone.  If you're implementing
	 * multibyte character set support, consider yourself to have been
	 * warned.]
	 */
	for (p = line, s = tbuf; *s != '\0'; p++, s++) {
#ifndef EBCDIC
	    *p = ((UCH(*s) < UCH(' ')) ||
		  (UCH(*s) == UCH('\177')) ||
		  ((UCH(*s) > UCH('\177')) &&
		   (UCH(*s) <
		    UCH(LYlowest_eightbit[current_char_set]))))
		? (char) SPLAT : *s;
#else
	    *p = (UCH(*s) < UCH(' ')) ? SPLAT : *s;
#endif
	}
	*p = '\0';
    }

    return;
}

/*
 * Re-render the text of a tagged ("[123]") HTLine (arg1), with the tag
 * number incremented by some value (arg5).  The re-rendered string may
 * be allowed to expand in the event of a tag width change (eg, 99 -> 100)
 * as controlled by arg6 (CHOP or NOCHOP).  Arg4 is either (the address
 * of) a value which must match, in order for the tag to be incremented,
 * or (the address of) a 0-value, which will match any value, and cause
 * any valid tag to be incremented.  Arg2 is a pointer to the first/only
 * anchor that exists on the line; we may need to adjust their position(s)
 * on the line.  Arg3 when non-0 indicates the number of new digits that
 * were added to the 2nd line in a line crossing pair.
 *
 * All tags fields in a line which individually match an expected new value,
 * are incremented.  Line crossing [tags] are handled (PITA).
 *
 * Untagged or improperly tagged lines are not altered.
 *
 * Returns the number of chars added to the original string's length, if
 * any.
 *
 * --KED 02/03/99
 */
static int increment_tagged_htline(HTLine *ht, TextAnchor *a, int *lx_val,
				   int *old_val,
				   int incr,
				   int mode)
{
    char buf[MAX_LINE];
    char lxbuf[MAX_LINE * 2];

    TextAnchor *st_anchor = a;
    TextAnchor *nxt_anchor;

    char *p = ht->data;
    char *s = buf;
    char *lx = lxbuf;
    char *t;

    BOOLEAN plx = FALSE;
    BOOLEAN valid;

    int val;
    int n;
    int new_n;
    int pre_n;
    int post_n;
    int fixup = 0;

    /*
     * Cleanup for the 2nd half of a line crosser, whose number of tag
     * digits grew by some number of places (usually 1 when it does
     * happen, though it *could* be more).  The tag chars were already
     * rendered into the 2nd line of the pair, but the positioning and
     * other effects haven't been rippled through any other anchors on
     * the (2nd) line.  So we do that here, as a special case, since
     * the part of the tag that's in the 2nd line of the pair, will not
     * be found by the tag string parsing code.  Double PITA.
     *
     * [see comments below on line crosser caused problems]
     */
    if (*lx_val != 0) {
	nxt_anchor = st_anchor;
	while ((nxt_anchor) && (nxt_anchor->line_num == a->line_num)) {
	    nxt_anchor->line_pos += *lx_val;
	    nxt_anchor = nxt_anchor->next;
	}
	fixup = *lx_val;
	*lx_val = 0;
	if (st_anchor)
	    st_anchor = st_anchor->next;
    }

    /*
     * Walk thru the line looking for tags (ie, "[nnn]" strings).
     */
    while (*p != '\0') {
	if (*p != '[') {
	    *s++ = *p++;
	    continue;

	} else {
	    *s++ = *p++;
	    t = p;
	    n = 0;
	    valid = TRUE;	/* p = t = byte after '[' */

	    /*
	     * Make sure there are only digits between "[" and "]".
	     */
	    while (*t != ']') {
		if (*t == '\0') {	/* uhoh - we have a potential line crosser */
		    valid = FALSE;
		    plx = TRUE;
		    break;
		}
		if (isdigit(UCH(*t++))) {
		    n++;
		    continue;
		} else {
		    valid = FALSE;
		    break;
		}
	    }

	    /*
	     * If the format is OK, we check to see if the value is what
	     * we expect.  If not, we have a random [nn] string in the text,
	     * and leave it alone.
	     *
	     * [It is *possible* to have a false match here, *if* there are
	     * two identical [nn] strings (including the numeric value of
	     * nn), one of which is the [tag], and the other being part of
	     * a document.  In such a case, the 1st [nn] string will get
	     * incremented; the 2nd one won't, which makes it a 50-50 chance
	     * of being correct, if and when such an unlikely juxtaposition
	     * of text ever occurs.  Further validation tests of the [nnn]
	     * string are probably not possible, since little of the actual
	     * anchor-associated-text is retained in the TextAnchor or the
	     * FormInfo structs.  Fortunately, I think the current method is
	     * more than adequate to weed out 99.999% of any possible false
	     * matches, just as it stands.  Caveat emptor.]
	     */
	    if ((valid) && (n > 0)) {
		val = atoi(p);
		if ((val == *old_val) || (*old_val == 0)) {	/* 0 matches all */
		    if (*old_val != 0)
			(*old_val)++;
		    val += incr;
		    sprintf(s, "%d", val);
		    new_n = strlen(s);
		    s += new_n;
		    p += n;

		    /*
		     * If the number of digits in an existing [tag] increased
		     * (eg, [99] --> [100], etc), we need to "adjust" its
		     * horizontal position, and that of all subsequent tags
		     * that may be on the same line.  PITA.
		     *
		     * [This seems to work as long as a tag isn't a line
		     * crosser; when it is, the position of anchors on either
		     * side of the split tag, seem to "float" and try to be
		     * as "centered" as possible.  Which means that simply
		     * incrementing the line_pos by the fixed value of the
		     * number of digits that got added to some tag in either
		     * line doesn't work quite right, and the text for (say)
		     * a button may get stomped on by another copy of itself,
		     * but offset by a few chars, when it is selected (eg,
		     * "Box Office" may end up looking like "BoBox Office" or
		     * "Box Officece", etc.
		     *
		     * Dunno how to fix that behavior ATT, but at least the
		     * tag numbers themselves are correct.  -KED /\oo/\ ]
		     */
		    if ((new_n -= n) != 0) {
			nxt_anchor = st_anchor;
			while ((nxt_anchor) &&
			       (nxt_anchor->line_num == a->line_num)) {
			    nxt_anchor->line_pos += new_n;
			    nxt_anchor = nxt_anchor->next;
			}
			if (st_anchor)
			    st_anchor = st_anchor->next;
		    }
		}
	    }

	    /*
	     * Unfortunately, valid [tag] strings *can* be split across two
	     * lines.  Perhaps it would be best to just prevent that from
	     * happening, but a look into that code, makes me wonder.  Anyway,
	     * we can handle such tags without *too* much trouble in here [I
	     * think], though since such animals are rather rare, it makes it
	     * a bit difficult to test thoroughly (ie, Beyond here, there be
	     * Dragons).
	     *
	     * We use lxbuf[] to deal with the two lines involved.
	     */
	    pre_n = strlen(p);	/* count of 1st part chars in this line */
	    post_n = strlen(ht->next->data);
	    if (plx
		&& (pre_n + post_n + 2 < (int) sizeof(lxbuf))) {
		strcpy(lx, p);	/* <- 1st part of a possible lx'ing tag */
		strcat(lx, ht->next->data);	/* tack on NEXT line          */

		t = lx;
		n = 0;
		valid = TRUE;

		/*
		 * Go hunting again for just digits, followed by tag end ']'.
		 */
		while (*t != ']') {
		    if (isdigit(UCH(*t++))) {
			n++;
			continue;
		    } else {
			valid = FALSE;
			break;
		    }
		}

		/*
		 * It *looks* like a line crosser; now we value test it to
		 * find out for sure [but see the "false match" warning,
		 * above], and if it matches, increment it into the buffer,
		 * along with the 2nd line's text.
		 */
		if ((valid)
		    && (n > 0)
		    && (n + post_n + 2) < MAX_LINE) {
		    val = atoi(lx);
		    if ((val == *old_val) || (*old_val == 0)) {
			if (*old_val != 0)
			    (*old_val)++;
			val += incr;
			sprintf(lx, "%d", val);
			new_n = strlen(lx);
			strcat(lx, strchr(ht->next->data, ']'));

			/*
			 * We keep the the same number of chars from the
			 * adjusted tag number in the current line; any
			 * extra chars due to a digits increase, will be
			 * stuffed into the next line.
			 *
			 * Keep track of any digits added, for the next
			 * pass through.
			 */
			s = strncpy(s, lx, pre_n) + pre_n;
			lx += pre_n;
			strcpy(ht->next->data, lx);

			*lx_val = new_n - n;
		    }
		}
		break;		/* had an lx'er, so we're done with this line */
	    }
	}
    }

    *s = '\0';

    n = strlen(ht->data);
    if (mode == CHOP) {
	*(buf + n) = '\0';
    } else if (strlen(buf) > ht->size) {
	/* we didn't allocate enough space originally - increase it */
	HTLine *temp;

	allocHTLine(temp, strlen(buf));
	if (!temp)
	    outofmem(__FILE__, "increment_tagged_htline");
	memcpy(temp, ht, LINE_SIZE(0));
#if defined(USE_COLOR_STYLE)
	POOLallocstyles(temp->styles, ht->numstyles);
	if (!temp->styles)
	    outofmem(__FILE__, "increment_tagged_htline");
	memcpy(temp->styles, ht->styles, sizeof(HTStyleChange) * ht->numstyles);
#endif
	ht = temp;
	ht->prev->next = ht;	/* Link in new line */
	ht->next->prev = ht;	/* Could be same node of course */
    }
    strcpy(ht->data, buf);

    return (strlen(buf) - n + fixup);
}

/*
 * Creates a new anchor and associated struct's appropriate for a form
 * TEXTAREA, and links them into the lists following the current anchor
 * position (as specified by arg1).
 *
 * Exits with arg1 now pointing at the new TextAnchor, and arg2 pointing
 * at the new, associated HTLine.
 *
 * --KED 02/13/99
 */
static void insert_new_textarea_anchor(TextAnchor **curr_anchor, HTLine **exit_htline)
{
    TextAnchor *anchor = *curr_anchor;
    HTLine *htline;

    TextAnchor *a = 0;
    FormInfo *f = 0;
    HTLine *l = 0;

    int curr_tag = 0;		/* 0 ==> match any [tag] number */
    int lx = 0;			/* 0 ==> no line crossing [tag]; it's a new line */
    int i;

    /*
     * Find line in the text that matches ending anchorline of
     * the TEXTAREA.
     *
     * [Yes, Virginia ...  we *do* have to go thru this for each
     * anchor being added, since there is NOT a 1-to-1 mapping
     * between anchors and htlines.  I suppose we could create
     * YAS (Yet Another Struct), but there are too many structs{}
     * floating around in here, as it is.  IMNSHO.]
     */
    for (htline = FirstHTLine(HTMainText), i = 0;
	 anchor->line_num != i; i++) {
	htline = htline->next;
	if (htline == HTMainText->last_line)
	    break;
    }

    /*
     * Clone and initialize the struct's needed to add a new TEXTAREA
     * anchor.
     */
    allocHTLine(l, MAX_LINE);
    POOLtypecalloc(TextAnchor, a);

    POOLtypecalloc(FormInfo, f);
    if (a == NULL || l == NULL || f == NULL)
	outofmem(__FILE__, "insert_new_textarea_anchor");

    /*  Init all the fields in the new TextAnchor.                 */
    /*  [anything "special" needed based on ->show_anchor value ?] */
    a->next = anchor->next;
    a->number = anchor->number;
    a->line_pos = anchor->line_pos;
    a->extent = anchor->extent;
    a->line_num = anchor->line_num + 1;
    LYCopyHiText(a, anchor);
    a->link_type = anchor->link_type;
    a->input_field = f;
    a->show_anchor = anchor->show_anchor;
    a->inUnderline = anchor->inUnderline;
    a->expansion_anch = TRUE;
    a->anchor = NULL;

    /*  Just the (seemingly) relevant fields in the new FormInfo.  */
    /*  [do we need to do anything "special" based on ->disabled]  */
    StrAllocCopy(f->name, anchor->input_field->name);
    f->number = anchor->input_field->number;
    f->type = anchor->input_field->type;
    StrAllocCopy(f->orig_value, "");
    f->size = anchor->input_field->size;
    f->maxlength = anchor->input_field->maxlength;
    f->no_cache = anchor->input_field->no_cache;
    f->disabled = anchor->input_field->disabled;
    f->value_cs = current_char_set;	/* use current setting - kw */

    /*  Init all the fields in the new HTLine (but see the #if).   */
    l->next = htline->next;
    l->prev = htline;
    l->offset = htline->offset;
    l->size = htline->size;
#if defined(USE_COLOR_STYLE)
    /* dup styles[] if needed [no need in TEXTAREA (?); leave 0's] */
    l->numstyles = htline->numstyles;
    /*we fork the pointers! */
    l->styles = htline->styles;
#endif
    strcpy(l->data, htline->data);

    /*
     * Link in the new HTLine.
     */
    htline->next->prev = l;
    htline->next = l;

    if (fields_are_numbered()) {
	a->number++;
	increment_tagged_htline(l, a, &lx, &curr_tag, 1, CHOP);
    }

    /*
     * If we're at the tail end of the TextAnchor or HTLine list(s),
     * the new node becomes the last node.
     */
    if (anchor == HTMainText->last_anchor)
	HTMainText->last_anchor = a;
    if (htline == HTMainText->last_line)
	HTMainText->last_line = l;

    /*
     * Link in the new TextAnchor and point the entry anchor arg at it;
     * point the entry HTLine arg at it, too.
     */
    anchor->next = a;
    *curr_anchor = a;

    *exit_htline = l->next;

    return;
}

/*
 * If new anchors were added to expand a TEXTAREA, we need to ripple the
 * new line numbers [and char counts ?] thru the subsequent anchors.
 *
 * If form lines are getting [nnn] tagged, we need to update the displayed
 * tag values to match (which means rerendering them ...  sigh).
 *
 * Finally, we need to update various HTMainText and other counts, etc.
 *
 * [dunno if the char counts really *need* to be done, or if we're using
 * the exactly proper values/algorithms ...  seems to be OK though ...]
 *
 * --KED 02/13/99
 */
static void update_subsequent_anchors(int newlines,
				      TextAnchor *start_anchor,
				      HTLine *start_htline,
				      int start_tag)
{
    TextAnchor *anchor;
    HTLine *htline = start_htline;

    int line_adj = 0;
    int tag_adj = 0;
    int lx = 0;
    int hang = 0;		/* for HANG detection of a nasty intermittent */
    int hang_detect = 100000;	/* ditto */

    CTRACE((tfp, "GridText: adjusting struct's to add %d new line(s)\n", newlines));

    /*
     * Update numeric fields of the rest of the anchors.
     *
     * [We bypass bumping ->number if it has a value of 0, which takes care
     * of the ->input_field->type == F_HIDDEN_TYPE (as well as any other
     * "hidden" anchors, if such things exist).  Seems like the "right
     * thing" to do.  I think.]
     */
    anchor = start_anchor->next;	/* begin updating with the NEXT anchor */
    while (anchor) {
	if (fields_are_numbered() &&
	    (anchor->number != 0))
	    anchor->number += newlines;
	anchor->line_num += newlines;
	anchor = anchor->next;
    }

    /*
     * Update/rerender anchor [tags], if they are being numbered.
     *
     * [If a number tag (eg, "[177]") is itself broken across a line
     * boundary, this fixup only partially works.  While the tag
     * numbering is done properly across the pair of lines, the
     * horizontal positioning on *either* side of the split, can get
     * out of sync by a char or two when it gets selected.  See the
     * [comments] in increment_tagged_htline() for some more detail.
     *
     * I suppose THE fix is to prevent such tag-breaking in the first
     * place (dunno where yet, though).  Ah well ...  at least the tag
     * numbers themselves are correct from top to bottom now.
     *
     * All that said, about the only time this will be a problem in
     * *practice*, is when a page has near 1000 links or more (possibly
     * after a TEXTAREA expansion), and has line crossing tag(s), and
     * the tag numbers in a line crosser go from initially all 3 digit
     * numbers, to some mix of 3 and 4 digits (or all 4 digits) as a
     * result of the expansion process.  Oh, you also need a "clump" of
     * anchors all on the same lines.
     *
     * Yes, it *can* happen, but in real life, it probably won't be
     * seen very much ...]
     *
     * [This may also be an artifact of bumping into the right hand
     * screen edge (or RHS margin), since we don't even *think* about
     * relocating an anchor to the following line, when [tag] digits
     * expansion pushes things too far in that direction.]
     */
    if (fields_are_numbered()) {
	anchor = start_anchor->next;
	while (htline != FirstHTLine(HTMainText)) {

	    while (anchor) {
		if ((anchor->number - newlines) == start_tag)
		    break;

		/*** A HANG (infinite loop) *has* occurred here, with */
		/*** the values of anchor and anchor->next being the  */
		/*** the same, OR with anchor->number "magically" and */
		/*** suddenly taking on an anchor-pointer-like value. */
		/***                                                  */
		/*** The same code and same doc have both passed and  */
		/*** failed at different times, which indicates some  */
		/*** sort of content/html dependency, or some kind of */
		/*** a "race" condition, but I'll be damned if I can  */
		/*** find it after tons of CTRACE's, printf()'s, gdb  */
		/*** breakpoints and watchpoints, etc.                */
		/***                                                  */
		/*** I have added a hang detector (with error msg and */
		/*** beep) here, to break the loop and warn the user, */
		/*** until it can be isolated and fixed.              */
		/***                                                  */
		/*** [One UGLY intermittent .. gak ..!  02/22/99 KED] */

		hang++;
		if ((anchor == anchor->next) || (hang >= hang_detect))
		    goto hang_detected;

		anchor = anchor->next;
	    }

	    if (anchor) {
		line_adj = increment_tagged_htline(htline, anchor, &lx,
						   &start_tag, newlines,
						   NOCHOP);
		htline->size += line_adj;
		tag_adj += line_adj;

	    } else {

		break;		/* out of anchors ... we're done */
	    }

	    htline = htline->next;
	}
    }

  finish:
    /*
     * Fixup various global variables.
     */
    nlinks += newlines;
    HTMainText->Lines += newlines;
    HTMainText->last_anchor_number += newlines;

    more = HText_canScrollDown();

    CTRACE((tfp, "GridText: TextAnchor and HTLine struct's adjusted\n"));

    return;

  hang_detected:		/* ugliness has happened; inform user and do the best we can */

    HTAlert(gettext("Hang Detect: TextAnchor struct corrupted - suggest aborting!"));
    goto finish;
}

/*
 * Transfer the initial contents of a TEXTAREA to a temp file, invoke the
 * user's editor on that file, then transfer the contents of the resultant
 * edited file back into the TEXTAREA (expanding the size of the area, if
 * required).
 *
 * Returns the number of lines that the cursor should be moved so that it
 * will end up on the 1st blank line of whatever number of trailing blank
 * lines there are in the TEXTAREA (there will *always* be at least one).
 *
 * --KED 02/01/99
 */
int HText_ExtEditForm(LinkInfo * form_link)
{
    struct stat stat_info;
    size_t size;

    char *ed_temp;
    FILE *fp;

    TextAnchor *anchor_ptr;
    TextAnchor *start_anchor = NULL;
    TextAnchor *end_anchor = NULL;
    BOOLEAN firstanchor = TRUE;
    BOOLEAN wrapalert = FALSE;

    char ed_offset[10];
    int start_line = 0;
    int entry_line = form_link->anchor_line_num;
    int exit_line = 0;
    int orig_cnt = 0;
    int line_cnt = 1;

    FormInfo *form = form_link->l_form;
    char *areaname = form->name;
    int form_num = form->number;

    HTLine *htline = NULL;

    char *ebuf;
    char *line;
    char *lp;
    char *cp;
    int match_tag = 0;
    int newlines = 0;
    int len, len0, len_in;
    int wanted_fieldlen_wrap = -1;	/* not yet asked; 0 means don't. */
    char *skip_at = NULL;
    int skip_num = 0, i;

    CTRACE((tfp, "GridText: entered HText_ExtEditForm()\n"));

    ed_temp = (char *) malloc(LY_MAXPATH);
    if ((fp = LYOpenTemp(ed_temp, "", "w")) == 0) {
	FREE(ed_temp);
	return (0);
    }

    /*
     * Begin at the beginning, to find 1st anchor in the TEXTAREA, then
     * write all of its lines (anchors) out to the edit temp file.
     *
     * [Finding the TEXTAREA we're actually *in* with these attributes
     * isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     * and there *could* be TEXTAREA's with the same "name".  If that
     * should ever be true, we'll actually get the data from the *1st*
     * TEXTAREA in the page that matches.  We should probably assign
     * a unique id to each TEXTAREA in a page, and match on that, to
     * avoid this (potential) problem.
     *
     * Since the odds of "false matches" *actually* happening in real
     * life seem rather small though, we'll hold off doing this, for a
     * rainy day ...]
     */
    anchor_ptr = HTMainText->first_anchor;

    while (anchor_ptr) {

	if ((anchor_ptr->link_type == INPUT_ANCHOR) &&
	    (anchor_ptr->input_field->type == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num) &&
	    !strcmp(anchor_ptr->input_field->name, areaname)) {

	    if (firstanchor) {
		firstanchor = FALSE;
		start_anchor = anchor_ptr;
		start_line = anchor_ptr->line_num;
	    }
	    orig_cnt++;

	    /*
	     * Write the anchors' text to the temp edit file.
	     */
	    fputs(anchor_ptr->input_field->value, fp);
	    fputc('\n', fp);

	} else {

	    if (!firstanchor)
		break;
	}
	anchor_ptr = anchor_ptr->next;
    }
    LYCloseTempFP(fp);

    CTRACE((tfp, "GridText: TEXTAREA name=|%s| dumped to tempfile\n", areaname));
    CTRACE((tfp, "GridText: invoking editor (%s) on tempfile\n", editor));

    /*
     * Go edit the TEXTAREA temp file, with the initial editor line
     * corresponding to the TEXTAREA line the cursor is on (if such
     * positioning is supported by the editor [as lynx knows it]).
     */
    ed_offset[0] = 0;		/* pre-ANSI compilers don't initialize aggregates - TD */
    if (((entry_line - start_line) > 0) && editor_can_position())
	sprintf(ed_offset, "%d", ((entry_line - start_line) + 1));

    edit_temporary_file(ed_temp, ed_offset, NULL);

    CTRACE((tfp, "GridText: returned from editor (%s)\n", editor));

    /*
     * Read back the edited temp file into our buffer.
     */
    if ((stat(ed_temp, &stat_info) < 0) ||
	!S_ISREG(stat_info.st_mode) ||
	((size = stat_info.st_size) == 0)) {
	size = 0;
	ebuf = typecalloc(char);

	if (!ebuf)
	    outofmem(__FILE__, "HText_ExtEditForm");
    } else {
	ebuf = typecallocn(char, size + 1);

	if (!ebuf) {
	    /*
	     * This could be huge - don't exit if we don't have enough
	     * memory for it.  With some luck, the user may be even able
	     * to recover the file manually from the temp space while
	     * the lynx session is not over.  - kw
	     */
	    free(ed_temp);
	    HTAlwaysAlert(NULL, MEMORY_EXHAUSTED_FILE);
	    return 0;
	}

	fp = fopen(ed_temp, "r");
	size = fread(ebuf, 1, size, fp);
	LYCloseInput(fp);
	ebuf[size] = '\0';	/* Terminate! - kw */
    }

    /*
     * Nuke any blank lines from the end of the edited data.
     */
    while ((size != 0)
	   && (CanTrimTextArea(UCH(ebuf[size - 1])) || (ebuf[size - 1] == '\0')))
	ebuf[--size] = '\0';

    /*
     * Copy each line from the temp file into the corresponding anchor
     * struct.  Add new lines to the TEXTAREA if needed.  (Always leave
     * the user with a blank line at the end of the TEXTAREA.)
     */
    if ((line = (char *) malloc(MAX_LINE)) == 0)
	outofmem(__FILE__, "HText_ExtEditForm");

    anchor_ptr = start_anchor;
    if (anchor_ptr->input_field->size <= 4 ||
	anchor_ptr->input_field->size >= MAX_LINE)
	wanted_fieldlen_wrap = 0;

    len = len_in = 0;
    lp = ebuf;

    while ((line_cnt <= orig_cnt) || (*lp) || ((len != 0) && (*lp == '\0'))) {

	if (skip_at) {
	    len0 = skip_at - lp;
	    strncpy(line, lp, len0);
	    line[len0] = '\0';
	    lp = skip_at + skip_num;
	    skip_at = NULL;
	    skip_num = 0;
	} else {
	    len0 = 0;
	}
	line[len0] = '\0';

	if ((cp = strchr(lp, '\n')) != 0)
	    len = len_in = cp - lp;
	else
	    len = len_in = strlen(lp);

	if (wanted_fieldlen_wrap < 0 && !wrapalert &&
	    len0 + len >= start_anchor->input_field->size &&
	    (cp = strchr(lp, ' ')) != NULL &&
	    (cp - lp) < start_anchor->input_field->size - 1) {
	    LYFixCursesOn("ask for confirmation:");
	    LYerase();		/* don't show previous state */
	    if (HTConfirmDefault(gettext("Wrap lines to fit displayed area?"),
				 NO)) {
		wanted_fieldlen_wrap = start_anchor->input_field->size - 1;
	    } else {
		wanted_fieldlen_wrap = 0;
	    }
	}
	if (wanted_fieldlen_wrap > 0 && len0 + len > wanted_fieldlen_wrap) {
	    for (i = wanted_fieldlen_wrap - len0;
		 i + len0 >= wanted_fieldlen_wrap / 4; i--) {
		if (isspace(UCH(lp[i]))) {
		    len = i + 1;
		    cp = lp + i;
		    if (cp[1] != '\n' &&
			isspace(UCH(cp[1])) &&
			!isspace(UCH(cp[2]))) {
			len++;
			cp++;
		    }
		    if (!isspace(UCH(cp[1]))) {
			while (*cp && *cp != '\r' && *cp != '\n' &&
			       (cp - lp) <= len + (3 * wanted_fieldlen_wrap / 4))
			    cp++;	/* search for next line break */
			if (*cp == '\r' && cp[1] == '\n')
			    cp++;
			if (*cp == '\n' &&
			    (cp[1] == '\r' || cp[1] == '\n' ||
			     !isspace(UCH(cp[1])))) {
			    *cp = ' ';
			    while (isspace(UCH(*(cp - 1)))) {
				skip_num++;
				cp--;
			    }
			    skip_at = cp;
			}
		    }
		    break;
		}
	    }
	}
	if (wanted_fieldlen_wrap > 0 && len0 + len > wanted_fieldlen_wrap) {
	    i = len - 1;
	    while (len0 + i + 1 > wanted_fieldlen_wrap &&
		   isspace(UCH(lp[i])))
		i--;
	    if (len0 + i + 1 > wanted_fieldlen_wrap)
		len = wanted_fieldlen_wrap - len0;
	}

	if (len0 + len >= MAX_LINE) {
	    if (!wrapalert) {
		LYFixCursesOn("show alert:");
		HTAlert(gettext("Very long lines have been wrapped!"));
		wrapalert = TRUE;
	    }
	    /*
	     * First try to find a space character for wrapping - kw
	     */
	    for (i = MAX_LINE - len0 - 1; i > 0; i--) {
		if (isspace(UCH(lp[i]))) {
		    len = i;
		    break;
		}
	    }
	    if (len0 + len >= MAX_LINE)
		len = MAX_LINE - len0 - 1;
	}

	strncat(line, lp, len);
	*(line + len0 + len) = '\0';

	cleanup_line_for_textarea(line, len0 + len);

	/*
	 * If there are more lines in the edit buffer than were in the
	 * original TEXTAREA, we need to add a new line/anchor, continuing
	 * on until the edit buffer is empty.
	 */
	if (line_cnt > orig_cnt) {
	    insert_new_textarea_anchor(&end_anchor, &htline);
	    anchor_ptr = end_anchor;	/* make the new anchor current */
	    newlines++;
	}

	/*
	 * Finally copy the new line from the edit buffer into the anchor.
	 */
	StrAllocCopy(anchor_ptr->input_field->value, line);

	/*
	 * Keep track of 1st blank line in any trailing blank lines, for
	 * later cursor repositioning.
	 */
	if (len0 + len > 0)
	    exit_line = 0;
	else if (exit_line == 0)
	    exit_line = anchor_ptr->line_num;

	/*
	 * And do the next line of edited text, for the next anchor ...
	 */
	lp += len;
	if (*lp && isspace(UCH(*lp)))
	    lp++;

	end_anchor = anchor_ptr;
	anchor_ptr = anchor_ptr->next;

	if (anchor_ptr)
	    match_tag = anchor_ptr->number;

	line_cnt++;
    }

    CTRACE((tfp, "GridText: edited text inserted into lynx struct's\n"));

    /*
     * If we've added any new lines/anchors, we need to adjust various
     * things in all anchor-bearing lines following the last newly added
     * line/anchor.  The fun stuff starts here ...
     */
    if (newlines > 0)
	update_subsequent_anchors(newlines, end_anchor, htline, match_tag);

    /*
     * Cleanup time.
     */
    FREE(line);
    FREE(ebuf);
    LYRemoveTemp(ed_temp);
    FREE(ed_temp);

    CTRACE((tfp, "GridText: exiting HText_ExtEditForm()\n"));

    /*
     * Return the offset needed to move the cursor from its current
     * (on entry) line number, to the 1st blank line of the trailing
     * (group of) blank line(s), which is where we want to be.  Let
     * the caller deal with moving us there, however ...  :-) ...
     */
    return (exit_line - entry_line);
}

/*
 * Expand the size of a TEXTAREA by a fixed number of lines (as specified
 * by arg2).
 *
 * --KED 02/14/99
 */
void HText_ExpandTextarea(LinkInfo * form_link, int newlines)
{
    TextAnchor *anchor_ptr;
    TextAnchor *end_anchor = NULL;
    BOOLEAN firstanchor = TRUE;

    FormInfo *form = form_link->l_form;
    char *areaname = form->name;
    int form_num = form->number;

    HTLine *htline = NULL;

    int match_tag = 0;
    int i;

    CTRACE((tfp, "GridText: entered HText_ExpandTextarea()\n"));

    if (newlines < 1)
	return;

    /*
     * Begin at the beginning, to find the TEXTAREA, then on to find
     * the last line (anchor) in it.
     *
     * [Finding the TEXTAREA we're actually *in* with these attributes
     * isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     * and there *could* be TEXTAREA's with the same "name".  If that
     * should ever be true, we'll actually expand the *1st* TEXTAREA
     * in the page that matches.  We should probably assign a unique
     * id to each TEXTAREA in a page, and match on that, to avoid this
     * (potential) problem.
     *
     * Since the odds of "false matches" *actually* happening in real
     * life seem rather small though, we'll hold off doing this, for a
     * rainy day ...]
     */
    anchor_ptr = HTMainText->first_anchor;

    while (anchor_ptr) {

	if ((anchor_ptr->link_type == INPUT_ANCHOR) &&
	    (anchor_ptr->input_field->type == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num) &&
	    !strcmp(anchor_ptr->input_field->name, areaname)) {

	    if (firstanchor)
		firstanchor = FALSE;

	    end_anchor = anchor_ptr;

	} else {

	    if (!firstanchor)
		break;
	}
	anchor_ptr = anchor_ptr->next;
    }

    for (i = 1; i <= newlines; i++) {
	insert_new_textarea_anchor(&end_anchor, &htline);

	/*
	 * Make the new line blank.
	 */
	StrAllocCopy(end_anchor->input_field->value, "");

	/*
	 * And go add another line ...
	 */
	if (end_anchor->next)
	    match_tag = end_anchor->next->number;
    }

    CTRACE((tfp, "GridText: %d blank line(s) added to TEXTAREA name=|%s|\n",
	    newlines, areaname));

    /*
     * We need to adjust various things in all anchor bearing lines
     * following the last newly added line/anchor.  Fun stuff.
     */
    update_subsequent_anchors(newlines, end_anchor, htline, match_tag);

    CTRACE((tfp, "GridText: exiting HText_ExpandTextarea()\n"));

    return;
}

/*
 * Insert the contents of a file into a TEXTAREA between the cursor line,
 * and the line preceding it.
 *
 * Returns the number of lines that the cursor should be moved so that it
 * will end up on the 1st line in the TEXTAREA following the inserted file
 * (if we decide to do that).
 *
 * --KED 02/21/99
 */
int HText_InsertFile(LinkInfo * form_link)
{
    struct stat stat_info;
    size_t size;

    FILE *fp;
    char *fn;

    TextAnchor *anchor_ptr;
    TextAnchor *prev_anchor = NULL;
    TextAnchor *end_anchor = NULL;
    BOOLEAN firstanchor = TRUE;
    BOOLEAN truncalert = FALSE;

    FormInfo *form = form_link->l_form;
    char *areaname = form->name;
    int form_num = form->number;

    HTLine *htline = NULL;

    TextAnchor *a = 0;
    FormInfo *f = 0;
    HTLine *l = 0;

    char *fbuf;
    char *line;
    char *lp;
    char *cp;
    int entry_line = form_link->anchor_line_num;
    int file_cs;
    int match_tag = 0;
    int newlines = 0;
    int len;
    int i;

    CTRACE((tfp, "GridText: entered HText_InsertFile()\n"));

    /*
     * Get the filename of the insert file.
     */
    if (!(fn = GetFileName())) {
	HTInfoMsg(FILE_INSERT_CANCELLED);
	CTRACE((tfp,
		"GridText: file insert cancelled - no filename provided\n"));
	return (0);
    }
    if (no_dotfiles || !show_dotfiles) {
	if (*LYPathLeaf(fn) == '.') {
	    HTUserMsg(FILENAME_CANNOT_BE_DOT);
	    return (0);
	}
    }

    /*
     * Read it into our buffer (abort on 0-length file).
     */
    if ((stat(fn, &stat_info) < 0) ||
	((size = stat_info.st_size) == 0)) {
	HTInfoMsg(FILE_INSERT_0_LENGTH);
	CTRACE((tfp,
		"GridText: file insert aborted - file=|%s|- was 0-length\n",
		fn));
	FREE(fn);
	return (0);

    } else {

	if ((fbuf = typecallocn(char, size + 1)) == NULL) {
	    /*
	     * This could be huge - don't exit if we don't have enough
	     * memory for it.  - kw
	     */
	    free(fn);
	    HTAlert(MEMORY_EXHAUSTED_FILE);
	    return 0;
	}

	/* Try to make the same assumption for the charset of the inserted
	 * file as we would for normal loading of that file, i.e. taking
	 * assume_local_charset and suffix mappings into account.
	 * If there is a mismatch with the display character set, characters
	 * may be displayed wrong, too bad; but the user has a chance to
	 * correct this by editing the lines, which will update f->value_cs
	 * again. - kw
	 */
	LYGetFileInfo(fn, 0, 0, 0, 0, 0, &file_cs);

	fp = fopen(fn, "r");
	if (!fp) {
	    free(fbuf);
	    free(fn);
	    HTAlert(FILE_CANNOT_OPEN_R);
	    return 0;
	}
	size = fread(fbuf, 1, size, fp);
	LYCloseInput(fp);
	FREE(fn);
	fbuf[size] = '\0';	/* Terminate! - kw */
    }

    /*
     * Begin at the beginning, to find the TEXTAREA we're in, then
     * the current cursorline.
     *
     * [Finding the TEXTAREA we're actually *in* with these attributes
     * isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     * and there *could* be TEXTAREA's with the same "name".  If that
     * should ever be true, we'll actually insert data into the *1st*
     * TEXTAREA in the page that matches.  We should probably assign
     * a unique id to each TEXTAREA in a page, and match on that, to
     * avoid this (potential) problem.
     *
     * Since the odds of "false matches" *actually* happening in real
     * life seem rather small though, we'll hold off doing this, for a
     * rainy day ...]
     */
    anchor_ptr = HTMainText->first_anchor;

    while (anchor_ptr) {

	if ((anchor_ptr->link_type == INPUT_ANCHOR) &&
	    (anchor_ptr->input_field->type == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num) &&
	    !strcmp(anchor_ptr->input_field->name, areaname)) {

	    if (anchor_ptr->line_num == entry_line)
		break;
	}
	prev_anchor = anchor_ptr;
	anchor_ptr = anchor_ptr->next;
    }

    /*
     * Clone a new TEXTAREA line/anchor using the cursorline anchor as
     * a template, but link it in BEFORE the cursorline anchor/htline.
     *
     * [We can probably combine this with insert_new_textarea_anchor()
     * along with a flag to indicate "insert before" as we do here,
     * or the "normal" mode of operation (add after "current" anchor/
     * line).  Beware of the differences ...  some are a bit subtle to
     * notice.]
     */
    for (htline = FirstHTLine(HTMainText), i = 0;
	 anchor_ptr->line_num != i; i++) {
	htline = htline->next;
	if (htline == HTMainText->last_line)
	    break;
    }

    allocHTLine(l, MAX_LINE);
    POOLtypecalloc(TextAnchor, a);

    POOLtypecalloc(FormInfo, f);
    if (a == NULL || l == NULL || f == NULL)
	outofmem(__FILE__, "HText_InsertFile");

    /*  Init all the fields in the new TextAnchor.                 */
    /*  [anything "special" needed based on ->show_anchor value ?] */
    a->next = anchor_ptr;
    a->number = anchor_ptr->number;
    a->line_pos = anchor_ptr->line_pos;
    a->extent = anchor_ptr->extent;
    a->line_num = anchor_ptr->line_num;
    LYCopyHiText(a, anchor_ptr);
    a->link_type = anchor_ptr->link_type;
    a->input_field = f;
    a->show_anchor = anchor_ptr->show_anchor;
    a->inUnderline = anchor_ptr->inUnderline;
    a->expansion_anch = TRUE;
    a->anchor = NULL;

    /*  Just the (seemingly) relevant fields in the new FormInfo.  */
    /*  [do we need to do anything "special" based on ->disabled]  */
    StrAllocCopy(f->name, anchor_ptr->input_field->name);
    f->number = anchor_ptr->input_field->number;
    f->type = anchor_ptr->input_field->type;
    StrAllocCopy(f->orig_value, "");
    f->size = anchor_ptr->input_field->size;
    f->maxlength = anchor_ptr->input_field->maxlength;
    f->no_cache = anchor_ptr->input_field->no_cache;
    f->disabled = anchor_ptr->input_field->disabled;
    f->value_cs = (file_cs >= 0) ? file_cs : current_char_set;

    /*  Init all the fields in the new HTLine (but see the #if).   */
    l->offset = htline->offset;
    l->size = htline->size;
#if defined(USE_COLOR_STYLE)
    /* dup styles[] if needed [no need in TEXTAREA (?); leave 0's] */
    l->numstyles = htline->numstyles;
    /*we fork the pointers! */
    l->styles = htline->styles;
#endif
    strcpy(l->data, htline->data);

    /*
     * If we're at the head of the TextAnchor list, the new node becomes
     * the first node.
     */
    if (anchor_ptr == HTMainText->first_anchor)
	HTMainText->first_anchor = a;

    /*
     * Link in the new TextAnchor, and corresponding HTLine.
     */
    if (prev_anchor)
	prev_anchor->next = a;

    htline = htline->prev;
    l->next = htline->next;
    l->prev = htline;
    htline->next->prev = l;
    htline->next = l;

    /*
     * update_subsequent_anchors() expects htline to point to 1st potential
     * line needing fixup; we need to do this just in case the inserted file
     * was only a single line (yes, it's pathological ...  ).
     */
    htline = htline->next;	/* ->new (current) htline, for 1st inserted line  */
    htline = htline->next;	/* ->1st potential (following) [tag] fixup htline */

    anchor_ptr = a;
    newlines++;

    /*
     * Copy each line from the insert file into the corresponding anchor
     * struct.
     *
     * Begin with the new line/anchor we just added (above the cursorline).
     */
    if ((line = (char *) malloc(MAX_LINE)) == 0)
	outofmem(__FILE__, "HText_InsertFile");

    match_tag = anchor_ptr->number;

    len = 0;
    lp = fbuf;

    while (*lp) {

	if ((cp = strchr(lp, '\n')) != 0)
	    len = cp - lp;
	else
	    len = strlen(lp);

	if (len >= MAX_LINE) {
	    if (!truncalert) {
		HTAlert(gettext("Very long lines have been truncated!"));
		truncalert = TRUE;
	    }
	    len = MAX_LINE - 1;
	    if (lp[len])
		lp[len + 1] = '\0';	/* prevent next iteration */
	}
	strncpy(line, lp, len);
	*(line + len) = '\0';

	cleanup_line_for_textarea(line, len);

	/*
	 * If not the first line from the insert file, we need to add
	 * a new line/anchor, continuing on until the buffer is empty.
	 */
	if (!firstanchor) {
	    insert_new_textarea_anchor(&end_anchor, &htline);
	    anchor_ptr = end_anchor;	/* make the new anchor current */
	    newlines++;
	}

	/*
	 * Copy the new line from the buffer into the anchor.
	 */
	StrAllocCopy(anchor_ptr->input_field->value, line);

	/*
	 * insert_new_textarea_anchor always uses current_char_set,
	 * we may want something else, so fix it up.  - kw
	 */
	if (file_cs >= 0)
	    anchor_ptr->input_field->value_cs = file_cs;

	/*
	 * And do the next line of insert text, for the next anchor ...
	 */
	lp += len;
	if (*lp)
	    lp++;

	firstanchor = FALSE;
	end_anchor = anchor_ptr;
	anchor_ptr = anchor_ptr->next;
    }

    CTRACE((tfp, "GridText: file inserted into lynx struct's\n"));

    /*
     * Now adjust various things in all anchor-bearing lines following the
     * last newly added line/anchor.  Some say this is the fun part ...
     */
    update_subsequent_anchors(newlines, end_anchor, htline, match_tag);

    /*
     * Cleanup time.
     */
    FREE(line);
    FREE(fbuf);

    CTRACE((tfp, "GridText: exiting HText_InsertFile()\n"));

    return (newlines);
}

/*
 * This function draws the part of line 'line', pointed by 'str' (which can be
 * non terminated with null - i.e., is line->data+N) drawing 'len' bytes (not
 * characters) of it.  It doesn't check whether the 'len' bytes crosses a
 * character boundary (if multibyte chars are in string).  Assumes that the
 * cursor is positioned in the place where the 1st char of string should be
 * drawn.
 *
 * This code is based on display_line.  This code was tested with ncurses only
 * (since no support for lss is availble for Slang) -HV.
 */
#ifdef USE_COLOR_STYLE
static void redraw_part_of_line(HTLine *line, const char *str,
				int len,
				HText *text)
{
    register int i;
    char buffer[7];
    const char *data, *end_of_data;
    size_t utf_extra = 0;

#ifdef USE_COLOR_STYLE
    int current_style = 0;
#endif
    char LastDisplayChar = ' ';
    int YP, XP;

    LYGetYX(YP, XP);

    i = XP;

    /* Set up the multibyte character buffer  */
    buffer[0] = buffer[1] = buffer[2] = '\0';

    data = str;
    end_of_data = data + len;
    i++;

    /* this assumes that the part of line to be drawn fits in the screen */
    while (data < end_of_data) {
	buffer[0] = *data;
	data++;

#if defined(USE_COLOR_STYLE) || defined(SLSC)
#define CStyle line->styles[current_style]

	while (current_style < line->numstyles &&
	       i >= (int) (CStyle.horizpos + line->offset + 1)) {
	    LynxChangeStyle(CStyle.style, CStyle.direction);
	    current_style++;
	}
#endif
	switch (buffer[0]) {

#ifndef USE_COLOR_STYLE
	case LY_UNDERLINE_START_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		lynx_start_underline();
	    }
	    break;

	case LY_UNDERLINE_END_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		lynx_stop_underline();
	    }
	    break;

	case LY_BOLD_START_CHAR:
	    lynx_start_bold();
	    break;

	case LY_BOLD_END_CHAR:
	    lynx_stop_bold();
	    break;

#endif
	case LY_SOFT_NEWLINE:
	    if (!dump_output_immediately)
		LYaddch('+');
	    break;

	case LY_SOFT_HYPHEN:
	    if (*data != '\0' ||
		isspace(UCH(LastDisplayChar)) ||
		LastDisplayChar == '-') {
		/*
		 * Ignore the soft hyphen if it is not the last
		 * character in the line.  Also ignore it if it
		 * first character following the margin, or if it
		 * is preceded by a white character (we loaded 'M'
		 * into LastDisplayChar if it was a multibyte
		 * character) or hyphen, though it should have
		 * been excluded by HText_appendCharacter() or by
		 * split_line() in those cases.  -FM
		 */
		break;
	    } else {
		/*
		 * Make it a hard hyphen and fall through.  -FM
		 */
		buffer[0] = '-';
		i++;
	    }
	    /* FALLTHRU */

	default:
	    i++;
	    if (text->T.output_utf8 && is8bits(buffer[0])) {
		utf_extra = utf8_length(text->T.output_utf8, data - 1);
		LastDisplayChar = 'M';
	    }
	    if (utf_extra) {
		strncpy(&buffer[1], data, utf_extra);
		buffer[utf_extra + 1] = '\0';
		LYaddstr(buffer);
		buffer[1] = '\0';
		data += utf_extra;
		utf_extra = 0;
	    } else if (HTCJK != NOCJK && is8bits(buffer[0])) {
		/*
		 * For CJK strings, by Masanobu Kimura.
		 */
		buffer[1] = *data;
		data++;
		LYaddstr(buffer);
		buffer[1] = '\0';
		/*
		 * For now, load 'M' into LastDisplayChar,
		 * but we should check whether it's white
		 * and if so, use ' '.  I don't know if
		 * there actually are white CJK characters,
		 * and we're loading ' ' for multibyte
		 * spacing characters in this code set,
		 * but this will become an issue when
		 * the development code set's multibyte
		 * character handling is used.  -FM
		 */
		LastDisplayChar = 'M';
	    } else {
		LYaddstr(buffer);
		LastDisplayChar = buffer[0];
	    }
	}			/* end of switch */
    }				/* end of while */

#ifndef USE_COLOR_STYLE
    lynx_stop_underline();
    lynx_stop_bold();
#else

    while (current_style < line->numstyles) {
	LynxChangeStyle(CStyle.style, CStyle.direction);
	current_style++;
    }

#undef CStyle
#endif
    return;
}
#endif /* USE_COLOR_STYLE */

#ifndef USE_COLOR_STYLE
/*
 * Function move_to_glyph is called from LYMoveToLink and does all
 * the real work for it.
 * The pair LYMoveToLink()/move_to_glyph() is similar to the pair
 * redraw_lines_of_link()/redraw_part_of_line(), some key differences:
 * LYMoveToLink/move_to_glyph redraw_*
 * -----------------------------------------------------------------
 * - used without color style           - used with color style
 * - handles showing WHEREIS target     - WHEREIS handled elsewhere
 * - handles only one line              - handles first two lines for
 *                                        hypertext anchors
 * - right columns position for UTF-8
 *   by redrawing as necessary
 * - currently used for highlight       - currently used for highlight
 *   ON and OFF                         OFF
 *
 * Eventually the two sets of function should be unified, and should handle
 * UTF-8 positioning, both lines of hypertext anchors, and WHEREIS in all
 * cases.  If possible.  The complex WHEREIS target logic in highlight()
 * could then be completely removed.  - kw
 */
static void move_to_glyph(int YP,
			  int XP,
			  int XP_draw_min,
			  const char *data,
			  int datasize,
			  unsigned offset,
			  const char *target,
			  const char *hightext,
			  int flags,
			  BOOL utf_flag)
{
    char buffer[7];
    const char *end_of_data;
    size_t utf_extra = 0;

#if defined(SHOW_WHEREIS_TARGETS)
    const char *cp_tgt;
    int i_start_tgt = 0, i_after_tgt;
    int HitOffset, LenNeeded;
#endif /* SHOW_WHEREIS_TARGETS */
    BOOL intarget = NO;
    BOOL inunderline = NO;
    BOOL inbold = NO;
    BOOL drawing = NO;
    BOOL inU = NO;
    BOOL hadutf8 = NO;
    BOOL incurlink = NO;
    BOOL drawingtarget = NO;
    BOOL flag = NO;
    const char *sdata = data;
    char LastDisplayChar = ' ';

    int i = (int) offset;	/* FIXME: should be columns, not offset? */
    int last_i = DISPLAY_COLS;
    int XP_link = XP;		/* column of link */
    int XP_next = XP;		/* column to move to when done drawing */
    int linkvlen;

    int len;

    if (flags & 1)
	flag = YES;
    if (flags & 2)
	inU = YES;
    /* Set up the multibyte character buffer  */
    buffer[0] = buffer[1] = buffer[2] = '\0';
    /*
     * Add offset, making sure that we do not
     * go over the COLS limit on the display.
     */
    if (hightext != 0) {
#ifdef WIDEC_CURSES
	len = strlen(hightext);
	last_i = i + LYstrExtent2(data, datasize);
#endif
	linkvlen = LYmbcsstrlen(hightext, utf_flag, YES);
    } else {
	linkvlen = 0;
    }
    if (i >= last_i)
	i = last_i - 1;

    /*
     * Scan through the data, making sure that we do not
     * go over the COLS limit on the display etc.
     */
    len = datasize;
    end_of_data = data + len;

#if defined(SHOW_WHEREIS_TARGETS)
    /*
     * If the target overlaps with the part of this line that
     * we are drawing, it will be emphasized.
     */
    i_after_tgt = i;
    if (target) {
	cp_tgt = LYno_attr_mb_strstr(sdata,
				     target,
				     utf_flag, YES,
				     &HitOffset,
				     &LenNeeded);
	if (cp_tgt) {
	    if ((int) offset + LenNeeded > last_i ||
		((int) offset + HitOffset >= XP + linkvlen)) {
		cp_tgt = NULL;
	    } else {
		i_start_tgt = i + HitOffset;
		i_after_tgt = i + LenNeeded;
	    }
	}
    } else {
	cp_tgt = NULL;
    }
#endif /* SHOW_WHEREIS_TARGETS */

    /*
     * Iterate through the line data from the start, keeping track of
     * the display ("glyph") position in i.  Drawing will be turned
     * on when either the first UTF-8 sequence (that occurs after
     * XP_draw_min) is found, or when we reach the link itself (if
     * highlight is non-NULL).  - kw
     */
    while ((i <= last_i) && data < end_of_data && (*data != '\0')) {

	if (data && hightext && i >= XP && !incurlink) {

	    /*
	     * We reached the position of link itself, and hightext is
	     * non-NULL.  We switch data from being a pointer into the HTLine
	     * to being a pointer into hightext.  Normally (as long as this
	     * routine is applied to normal hyperlink anchors) the text in
	     * hightext will be identical to that part of the HTLine that
	     * data was already pointing to, except that special attribute
	     * chars LY_BOLD_START_CHAR etc., have been stripped out (see
	     * HText_trimHightext).  So the switching should not result in
	     * any different display, but it ensures that it doesn't go
	     * unnoticed if somehow hightext got messed up somewhere else.
	     * This is also useful in preparation for using this function
	     * for something else than normal hyperlink anchors, i.e., form
	     * fields.
	     * Turn on drawing here or make sure it gets turned on before the
	     * next actual normal character is handled.  - kw
	     */
	    data = hightext;
	    len = strlen(hightext);
	    end_of_data = hightext + len;
	    last_i = i + len;
	    XP_next += linkvlen;
	    incurlink = YES;
#ifdef SHOW_WHEREIS_TARGETS
	    if (cp_tgt) {
		if (flag && i_after_tgt >= XP)
		    i_after_tgt = XP - 1;
	    }
#endif
	    /*
	     * The logic of where to set in-target drawing target etc.
	     * and when to react to it should be cleaned up (here and
	     * further below).  For now this seems to work but isn't
	     * very clear.  The complications arise from reproducing
	     * the behavior (previously done in LYhighlight()) for target
	     * strings that fall into or overlap a link:  use target
	     * emphasis for the target string, except for the first
	     * and last character of the anchor text if the anchor is
	     * highlighted as "current link".  - kw
	     */
	    if (!drawing) {
#ifdef SHOW_WHEREIS_TARGETS
		if (intarget) {
		    if (i_after_tgt > i) {
			LYmove(YP, i);
			if (flag) {
			    drawing = YES;
			    drawingtarget = NO;
			    if (inunderline)
				inU = YES;
			    lynx_start_link_color(flag, inU);
			} else {
			    drawing = YES;
			    drawingtarget = YES;
			    LYstartTargetEmphasis();
			}
		    }
		}
#endif /* SHOW_WHEREIS_TARGETS */
	    } else {
#ifdef SHOW_WHEREIS_TARGETS
		if (intarget && i_after_tgt > i) {
		    if (flag && (data == hightext)) {
			drawingtarget = NO;
			LYstopTargetEmphasis();
		    }
		} else if (!intarget)
#endif /* SHOW_WHEREIS_TARGETS */
		{
		    if (inunderline)
			inU = YES;
		    if (inunderline)
			lynx_stop_underline();
		    if (inbold)
			lynx_stop_bold();
		    lynx_start_link_color(flag, inU);
		}

	    }
	}
	if (i >= last_i || data >= end_of_data)
	    break;
	if ((buffer[0] = *data) == '\0')
	    break;
#if defined(SHOW_WHEREIS_TARGETS)
	/*
	 * Look for a subsequent occurrence of the target string,
	 * if we had a previous one and have now stepped past it.  - kw
	 */
	if (cp_tgt && i >= i_after_tgt) {
	    if (intarget) {

		if (incurlink && flag && i == last_i - 1)
		    cp_tgt = NULL;
		else
		    cp_tgt = LYno_attr_mb_strstr(sdata,
						 target,
						 utf_flag, YES,
						 &HitOffset,
						 &LenNeeded);
		if (cp_tgt) {
		    i_start_tgt = i + HitOffset;
		    i_after_tgt = i + LenNeeded;
		    if (incurlink) {
			if (flag && i_start_tgt == XP_link)
			    i_start_tgt++;
			if (flag && i_start_tgt == last_i - 1)
			    i_start_tgt++;
			if (flag && i_after_tgt >= last_i)
			    i_after_tgt = last_i - 1;
			if (flag && i_start_tgt >= last_i)
			    cp_tgt = NULL;
		    } else if (i_start_tgt == last_i) {
			if (flag)
			    i_start_tgt++;
		    }
		}
		if (!cp_tgt || i_start_tgt != i) {
		    intarget = NO;
		    if (drawing) {
			if (drawingtarget) {
			    drawingtarget = NO;
			    LYstopTargetEmphasis();
			    if (incurlink) {
				lynx_start_link_color(flag, inU);
			    }
			}
			if (!incurlink) {
			    if (inbold)
				lynx_start_bold();
			    if (inunderline)
				lynx_start_underline();
			}
		    }
		}
	    }
	}
#endif /* SHOW_WHEREIS_TARGETS */

	/*
	 * Advance data to point to the next input char (for the
	 * next round).  Advance sdata, used for searching for a
	 * target string, so that they stay in synch.  As long
	 * as we are not within the highlight text, data and sdata
	 * have identical values.  After we have switched data to
	 * point into hightext, sdata remains a pointer into the
	 * HTLine (so that we don't miss a partial target match at
	 * the end of the anchor text).  So sdata has to sometimes
	 * skip additional special attribute characters that are
	 * not present in highlight in order to stay in synch.  - kw
	 */
	data++;
	if (incurlink) {
	    while (IsNormalChar(*sdata)) {
		++sdata;
	    }
	}

	switch (buffer[0]) {

	case LY_UNDERLINE_START_CHAR:
	    if (!drawing || !incurlink)
		inunderline = YES;
	    if (drawing && !intarget && !incurlink)
		lynx_start_underline();
	    break;

	case LY_UNDERLINE_END_CHAR:
	    inunderline = NO;
	    if (drawing && !intarget && !incurlink)
		lynx_stop_underline();
	    break;

	case LY_BOLD_START_CHAR:
	    if (!drawing || !incurlink)
		inbold = YES;
	    if (drawing && !intarget && !incurlink)
		lynx_start_bold();
	    break;

	case LY_BOLD_END_CHAR:
	    inbold = NO;
	    if (drawing && !intarget && !incurlink)
		lynx_stop_bold();
	    break;

	case LY_SOFT_NEWLINE:
	    if (drawing) {
		LYaddch('+');
	    }
	    i++;
	    break;

	case LY_SOFT_HYPHEN:
	    if (*data != '\0' ||
		isspace(UCH(LastDisplayChar)) ||
		LastDisplayChar == '-') {
		/*
		 * Ignore the soft hyphen if it is not the last
		 * character in the line.  Also ignore it if it
		 * first character following the margin, or if it
		 * is preceded by a white character (we loaded 'M'
		 * into LastDisplayChar if it was a multibyte
		 * character) or hyphen, though it should have
		 * been excluded by HText_appendCharacter() or by
		 * split_line() in those cases.  -FM
		 */
		break;
	    } else {
		/*
		 * Make it a hard hyphen and fall through.  -FM
		 */
		buffer[0] = '-';
	    }
	    /* FALLTHRU */

	default:
	    /*
	     * We have got an actual normal displayable character, or
	     * the start of one.  Before proceeding check whether
	     * drawing needs to be turned on now.  - kw
	     */
#if defined(SHOW_WHEREIS_TARGETS)
	    if (incurlink && intarget && flag && i_after_tgt > i) {
		if (i == last_i - 1) {
		    i_after_tgt = i;
		} else if (i == last_i - 2 && HTCJK != NOCJK &&
			   is8bits(buffer[0])) {
		    i_after_tgt = i;
		    cp_tgt = NULL;
		    if (drawing) {
			if (drawingtarget) {
			    LYstopTargetEmphasis();
			    drawingtarget = NO;
			    lynx_start_link_color(flag, inU);
			}
		    }
		}
	    }
	    if (cp_tgt && i >= i_start_tgt && sdata > cp_tgt) {
		if (!intarget ||
		    (intarget && incurlink && !drawingtarget)) {

		    if (incurlink && drawing &&
			!(flag &&
			  (i == XP_link || i == last_i - 1))) {
			lynx_stop_link_color(flag, inU);
		    }
		    if (incurlink && !drawing) {
			LYmove(YP, i);
			if (inunderline)
			    inU = YES;
			if (flag && (i == XP_link || i == last_i - 1)) {
			    lynx_start_link_color(flag, inU);
			    drawingtarget = NO;
			} else {
			    LYstartTargetEmphasis();
			    drawingtarget = YES;
			}
			drawing = YES;
		    } else if (incurlink && drawing &&
			       intarget && !drawingtarget &&
			       (flag &&
				(i == XP_link))) {
			if (inunderline)
			    inU = YES;
			lynx_start_link_color(flag, inU);
		    } else if (drawing &&
			       !(flag &&
				 (i == XP_link || (incurlink && i == last_i - 1)))) {
			LYstartTargetEmphasis();
			drawingtarget = YES;
		    }
		    intarget = YES;
		}
	    } else
#endif /* SHOW_WHEREIS_TARGETS */
	    if (incurlink) {
		if (!drawing) {
		    LYmove(YP, i);
		    if (inunderline)
			inU = YES;
		    lynx_start_link_color(flag, inU);
		    drawing = YES;
		}
	    }

	    i++;
#ifndef WIDEC_CURSES
	    if (utf_flag && is8bits(buffer[0])) {
		hadutf8 = YES;
		utf_extra = utf8_length(utf_flag, data - 1);
		LastDisplayChar = 'M';
	    }
#endif
	    if (utf_extra) {
		strncpy(&buffer[1], data, utf_extra);
		buffer[utf_extra + 1] = '\0';
		if (!drawing && i >= XP_draw_min) {
		    LYmove(YP, i - 1);
		    drawing = YES;
#if defined(SHOW_WHEREIS_TARGETS)
		    if (intarget) {
			drawingtarget = YES;
			LYstartTargetEmphasis();
		    } else
#endif /* SHOW_WHEREIS_TARGETS */
		    {
			if (inbold)
			    lynx_start_bold();
			if (inunderline)
			    lynx_start_underline();
		    }
		}
		LYaddstr(buffer);
		buffer[1] = '\0';
		sdata += utf_extra;
		data += utf_extra;
		utf_extra = 0;
	    } else if (HTCJK != NOCJK && is8bits(buffer[0])) {
		/*
		 * For CJK strings, by Masanobu Kimura.
		 */
		if (drawing && (i <= last_i)) {
		    buffer[1] = *data;
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		}
		i++;
		sdata++;
		data++;
		/*
		 * For now, load 'M' into LastDisplayChar, but we should
		 * check whether it's white and if so, use ' '.  I don't
		 * know if there actually are white CJK characters, and
		 * we're loading ' ' for multibyte spacing characters in
		 * this code set, but this will become an issue when the
		 * development code set's multibyte character handling is
		 * used.  -FM
		 */
		LastDisplayChar = 'M';
	    } else {
		if (drawing) {
		    LYaddstr(buffer);
		}
		LastDisplayChar = buffer[0];
	    }
	}			/* end of switch */
    }				/* end of while */

    if (!drawing) {
	LYmove(YP, XP_next);
	lynx_start_link_color(flag, inU);
    } else {
#if defined(SHOW_WHEREIS_TARGETS)
	if (drawingtarget) {
	    LYstopTargetEmphasis();
	    lynx_start_link_color(flag, inU);
	}
#endif /* SHOW_WHEREIS_TARGETS */
	if (hadutf8) {
	    LYtouchline(YP);
	}
    }
    return;
}
#endif /* !USE_COLOR_STYLE */

#ifndef USE_COLOR_STYLE
/*
 * Move cursor position to a link's place in the display.
 * The "moving to" is done by scanning through the line's
 * character data in the corresponding HTLine of HTMainText,
 * and starting to draw when a UTF-8 encoded non-ASCII character
 * is encountered before the link (with some protection against
 * overwriting form fields).  This refreshing of preceding data is
 * necessary for preventing curses's or slang's display logic from
 * getting too clever; their logic counts character positions wrong
 * since they don't know about multi-byte characters that take up
 * only one screen position.  So we have to make them forget their
 * idea of what's in a screen line drawn previously.
 * If hightext is non-NULL, it should be the anchor text for a normal
 * link as stored in a links[] element, and the anchor text will be
 * drawn too, with appropriate attributes.  - kw
 */
void LYMoveToLink(int cur,
		  const char *target,
		  const char *hightext,
		  int flag,
		  BOOL inU,
		  BOOL utf_flag)
{
#define pvtTITLE_HEIGHT 1
    HTLine *todr;
    int i, n = 0;
    int XP_draw_min = 0;
    int flags = ((flag == ON) ? 1 : 0) | (inU ? 2 : 0);

    /*
     * We need to protect changed form text fields preceding this
     * link on the same line against overwriting.  - kw
     */
    for (i = cur - 1; i >= 0; i++) {
	if (links[i].ly < links[cur].ly)
	    break;
	if (links[i].type == WWW_FORM_LINK_TYPE) {
	    XP_draw_min = links[i].ly + links[i].l_form->size;
	    break;
	}
    }

    /*  Find the right HTLine. */
    if (!HTMainText) {
	todr = NULL;
    } else if (HTMainText->stale) {
	todr = FirstHTLine(HTMainText);
	n = links[cur].ly - pvtTITLE_HEIGHT + HTMainText->top_of_screen;
    } else {
	todr = HTMainText->top_of_screen_line;
	n = links[cur].ly - pvtTITLE_HEIGHT;
    }
    for (i = 0; i < n && todr; i++) {
	todr = (todr == HTMainText->last_line) ? NULL : todr->next;
    }
    if (todr) {
	if (target && *target == '\0')
	    target = NULL;
	move_to_glyph(links[cur].ly, links[cur].lx, XP_draw_min,
		      todr->data, todr->size, todr->offset,
		      target, hightext, flags, utf_flag);
    } else {
	/*  This should not happen. */
	move_to_glyph(links[cur].ly, links[cur].lx, XP_draw_min,
		      "", 0, links[cur].lx,
		      target, hightext, flags, utf_flag);
	/* LYmove(links[cur].ly, links[cur].lx); */
    }
}
#endif /* !USE_COLOR_STYLE */

/*
 * This is used only if compiled with lss support.  It's called to draw regular
 * link (1st two lines of link) when it's being unhighlighted in LYhighlight().
 */
void redraw_lines_of_link(int cur GCC_UNUSED)
{
#ifdef USE_COLOR_STYLE
#define pvtTITLE_HEIGHT 1
    HTLine *todr1;
    int lines_back;
    int row, col, count;
    const char *text;

    if (HTMainText->next_line == HTMainText->last_line) {
	/* we are at the last page - that is partially filled */
	lines_back = HTMainText->Lines - (links[cur].ly - pvtTITLE_HEIGHT +
					  HTMainText->top_of_screen);
    } else {
	lines_back = display_lines - (links[cur].ly - pvtTITLE_HEIGHT);
    }
    todr1 = HTMainText->next_line;
    while (lines_back-- > 0)
	todr1 = todr1->prev;

    row = links[cur].ly;
    for (count = 0;
	 row <= display_lines && (text = LYGetHiliteStr(cur, count)) != NULL;
	 ++count) {
	col = LYGetHilitePos(cur, count);
	LYmove(row++, col);
	redraw_part_of_line(todr1, text, strlen(text), HTMainText);
	todr1 = todr1->next;
    }
#undef pvtTITLE_HEIGHT
#else
    /* no dead code ! */
#endif
    return;
}

#ifdef USE_PRETTYSRC
void HTMark_asSource(void)
{
    if (HTMainText)
	HTMainText->source = TRUE;
}
#endif

HTkcode HText_getKcode(HText *text)
{
    return text->kcode;
}

void HText_updateKcode(HText *text, HTkcode kcode)
{
    text->kcode = kcode;
}

HTkcode HText_getSpecifiedKcode(HText *text)
{
    return text->specified_kcode;
}

void HText_updateSpecifiedKcode(HText *text, HTkcode kcode)
{
    text->specified_kcode = kcode;
}

int HTMainText_Get_UCLYhndl(void)
{
    return (HTMainText ?
	    HTAnchor_getUCLYhndl(HTMainText->node_anchor, UCT_STAGE_MIME)
	    : -1);
}
@


1.8
log
@automatic merge
@
text
@d120 2
a121 2
char *HTAppName = LYNX_NAME;	/* Application name */
char *HTAppVersion = LYNX_VERSION;	/* Application version */
d125 1
a125 1
char *HTCurSelectGroup = NULL;	/* Form select group name */
d131 4
a134 4
char *checked_box = "[X]";
char *unchecked_box = "[ ]";
char *checked_radio = "(*)";
char *unchecked_radio = "( )";
d340 1
d342 1
d391 32
d471 5
a475 27
    enum _detected_kcode {
	DET_SJIS,
	DET_EUC,
	DET_NOTYET,
	DET_MIXED
    } detected_kcode;		/* Detected Kanji code */
    enum _SJIS_status {
	SJIS_state_neutral,
	SJIS_state_in_kanji,
	SJIS_state_has_bad_code
    } SJIS_status;
    enum _EUC_status {
	EUC_state_neutral,
	EUC_state_in_kanji,
	EUC_state_in_kana,
	EUC_state_has_bad_code
    } EUC_status;
#endif
    enum grid_state {
	S_text,
	S_esc,
	S_dollar,
	S_paren,
	S_nonascii_text,
	S_dollar_paren,
	S_jisx0201_text
    } state;			/* Escape sequence? */
d492 1
a492 1
       * Parse settings when this HText was generated.
d743 2
a744 1
static void LYSetHiText(TextAnchor *a, char *text,
d759 2
a760 1
static void LYAddHiText(TextAnchor *a, char *text,
d936 10
d1169 1
a1169 2
    self->first_lineno_last_disp_partial =
	self->last_lineno_last_disp_partial = -1;
d1186 1
a1186 1
    HText *this = HText_new(anchor);
d1189 2
a1190 2
	this->target = stream;
	this->targetClass = *stream->isa;	/* copy action procedures */
d1192 1
a1192 1
    return this;
d1249 1
a1249 6
	char *href = NULL;
	HTList *cur = self->hidden_links;

	while (NULL != (href = (char *) HTList_nextObject(cur)))
	    FREE(href);
	HTList_delete(self->hidden_links);
a1610 1
    char *cp = NULL;
d1637 1
a1637 11

    /*
     * There shouldn't be any \n in the title field,
     * but if there is, lets kill it now.  Also trim
     * any trailing spaces.  -FM
     */
    if ((cp = strchr(title, '\n')) != NULL)
	*cp = '\0';
    i = (*title ? (strlen(title) - 1) : 0);
    while ((i >= 0) && title[i] == ' ')
	title[i--] = '\0';
d1897 1
a1897 1
			 char *target)
d1903 1
a1903 1
    char *cp;
d1941 1
a1941 2
	text->first_lineno_last_disp_partial =
	    text->last_lineno_last_disp_partial = -1;
d2253 1
a2253 1
		    if (count != 0)
d2255 1
d2390 1
a2390 4
    for (i = nlinks; i < last_nlinks; i++) {
	LYSetHilite(i, NULL);
	FREE(links[i].lname);
    }
d2420 1
a2420 2
	text->first_lineno_last_disp_partial =
	    text->last_lineno_last_disp_partial = -1;
d3392 2
a3393 1
			"BUG: justification: shouldn't happen - new line is not empty!\n"));
d3599 1
a3599 1
	enum _detected_kcode save_d_kcode;
d4176 1
a4176 1
	    int saved_state;
d4636 1
a4636 2
		    me->first_lineno_last_disp_partial =
			me->last_lineno_last_disp_partial = -1;
d4743 1
a4743 2
		    me->first_lineno_last_disp_partial =
			me->last_lineno_last_disp_partial = -1;
d5888 2
d5972 1
a5972 1
    TextAnchor *a = *prev;
d5996 1
a5996 1
			  char **desc)
d6630 1
a6630 1
    char *cp;
d6699 19
d6765 1
a6765 1
    char *suffix = "";
d6832 3
a6834 1
	if (HTCompressFileType(fn, ".", &cp) != cftNone) {
d6845 2
a6846 1
	if ((second = HTCompressFileType(fn, "-_", &cp)) != cftNone) {
d7110 2
a7111 6
	text->first_lineno_last_disp_partial =
	    text->last_lineno_last_disp_partial = -1;
	if (HTMainText) {
	    HTMainText->first_lineno_last_disp_partial =
		HTMainText->last_lineno_last_disp_partial = -1;
	}
a7210 1

a7211 1

d7342 1
a7342 10
    char *query;
    HTList *cur = search_queries;

    if (!cur)
	return;

    while (NULL != (query = (char *) HTList_nextObject(cur))) {
	FREE(query);
    }
    HTList_delete(search_queries);
a7343 1
    return;
d7386 2
a7387 1
    int ch, recall;
d7541 1
a7541 1
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
d7543 1
a7543 1
#endif /* !VMS && SYSLOG_REQUESTED_URLS */
d7608 34
d7648 2
a7649 1
void print_wwwfile_to_fd(FILE *fp, BOOLEAN is_email,
d7654 1
d7697 5
a7701 2
	for (i = 0; line->data[i] != '\0'; i++) {
	    if (!IsSpecialAttrChar(line->data[i])) {
d7704 1
a7704 1
		    fputc(line->data[i], fp);
d7706 1
a7706 1
		    fputc(line->data[i], fp);
d7710 1
a7710 1
		    fputc(line->data[i], fp);
d7713 3
a7715 3
		    fputc(line->data[i], fp);
	    } else if (line->data[i] == LY_SOFT_HYPHEN &&
		       line->data[i + 1] == '\0') {	/* last char on line */
d7718 1
a7718 1
		switch (line->data[i]) {
d7730 1
a7730 1
		switch (line->data[i]) {
d7773 1
d7794 8
a7801 5
	for (i = 0; line->data[i] != '\0'; i++) {
	    if (!IsSpecialAttrChar(line->data[i])) {
		fputc(line->data[i], fp);
	    } else if (line->data[i] == LY_SOFT_HYPHEN &&
		       line->data[i + 1] == '\0') {	/* last char on line */
d7896 2
a7897 1
    char *stars = NULL, *cp;
d7926 2
a7927 2
	    for (cp = stars; *cp != '\0'; cp++)
		*cp = '*';
d8501 1
a8501 1
char *HTLoadedDocumentURL(void)
d8522 1
a8522 1
char *HTLoadedDocumentTitle(void)
d8555 1
a8555 1
char *HTLoadedDocumentCharset(void)
d8583 1
a8583 1
char *HTLoadedDocumentBookmark(void)
d8862 6
a8867 2
	 HTList_isEmpty(text->hidden_links)))
	HTList_appendObject(text->hidden_links, HTAnchor_address(dest));
d8891 1
a8891 1
char *HText_HiddenLinkAt(HText *text, int number)
d9281 1
a9281 1
	convert_to_spaces(value, FALSE);
d10063 1
a10063 1
static void load_a_file(char *val_used,
d10110 1
a10110 1
static unsigned check_form_specialchars(char *value)
d10113 1
a10113 1
    char *p;
d10159 1
a10159 1
static char *convert_to_base64(char *src,
d10170 3
a10172 1
    char *eol, *r, *str;
d10196 2
a10197 2
	    char *c = eol;
	    char *e = eol + eollen;
d10221 2
a10222 2
	char *c = eol;
	char *e = eol + eollen;
d10248 1
a10248 1
static char *escape_or_quote_name(char *name,
d10250 1
a10250 1
				  char *MultipartContentType)
d10275 1
a10275 1
static char *escape_or_quote_value(char *value,
d10365 1
a10365 1
    char *name_used = "";
d10367 1
a10367 1
    char *val_used = "";
d10380 2
a10381 1
    thisform = HTList_objectAt(HTMainText->forms, form_number - 1);
d11139 5
a11143 5
		    char *marker = (PlainText
				    ? "\n"
				    : (Boundary
				       ? "\r\n"
				       : "%0d%0a"));
d11527 1
a11527 1
    BOOL explicit;
d11538 1
a11538 1
    explicit = charset ? TRUE : FALSE;
d11564 3
a11566 3
    if (explicit && (!strcmp(charset, "shift_jis") ||
		     !strcmp(charset, "x-sjis") ||	/* 1997/11/28 (Fri) 18:11:33 */
		     !strcmp(charset, "x-shift-jis"))) {
d11568 1
a11568 1
    } else if (explicit
d11602 1
a11602 1
    if (explicit
d13150 1
a13150 1
static void redraw_part_of_line(HTLine *line, char *str,
d13156 1
a13156 1
    char *data, *end_of_data;
d13330 1
a13330 1
			  char *data,
d13334 1
a13334 1
			  char *hightext,
d13356 1
a13356 1
    char *sdata = data;
d13820 1
a13820 1
		  char *hightext,
d13884 1
a13884 1
    char *text;
@


1.7
log
@automatic merge; regen configure
@
text
@d6740 3
a6742 2
    char *dot = NULL, *cp = NULL;
    char *suffix;
d6782 1
a6782 10
	if (!strcasecomp(ce, "gzip") ||
	    !strcasecomp(ce, "x-gzip")) {
	    method = cftGzip;
	} else if (!strcasecomp(ce, "compress") ||
		   !strcasecomp(ce, "x-compress")) {
	    method = cftCompress;
	} else if (!strcasecomp(ce, "bzip2") ||
		   !strcasecomp(ce, "x-bzip2")) {
	    method = cftBzip2;
	}
d6851 1
a6851 1
    default:
d6857 3
d9541 2
a9542 2
    if (I->size != NULL) {
	f->size = atoi(I->size);
@


1.6
log
@back out the -iz patch; slashdot.org and symlink.lu look
way different (not the front page, but the articles), and
also on www.heise.de/newsticker/ there is no left spacing
at the left side of the text, which is confusing in a
full-screen xterm
@
text
@d16 1
d58 1
a58 1
#  define DISPLAY_COLS (LYwideLines ? MAX_COLS : LYcols)
d61 3
a63 2
			    ? DISPLAY_COLS : (LYtableCols * LYcols)/12)	\
			   : LYcols)
d65 2
a66 2
#  define DISPLAY_COLS LYcols
#  define WRAP_COLS(text) LYcols
d108 1
d123 2
a124 2
int HTFormNumber = 0;
int HTFormFields = 0;
d1321 2
a1322 2
    if (j > (int) DISPLAY_COLS - 1)
	j = (int) DISPLAY_COLS - 1;
d1370 1
a1370 1
    while ((i < DISPLAY_COLS) && ((buffer[0] = *data) != '\0')) {
d1462 1
a1462 1
#endif
d1531 18
a1548 21
		if (i >= DISPLAY_COLS)
		    goto after_while;

		buffer[1] = *data;
		buffer[2] = '\0';
		data++;
		i++;
		LYaddstr(buffer);
		buffer[1] = '\0';
		/*
		 * For now, load 'M' into LastDisplayChar,
		 * but we should check whether it's white
		 * and if so, use ' '.  I don't know if
		 * there actually are white CJK characters,
		 * and we're loading ' ' for multibyte
		 * spacing characters in this code set,
		 * but this will become an issue when
		 * the development code set's multibyte
		 * character handling is used.  -FM
		 */
		LastDisplayChar = 'M';
a1555 1
  after_while:
d1719 6
d1745 1
d1754 1
a1754 1
	LYmove(0, LYcols - 1);
d1832 1
a1832 1
	LYmove(1, LYcols + LYshiftWin - 1);
d1853 1
a1853 1
	LYmove(i + off, LYcols + LYshiftWin - 1);
d1874 1
a1874 1
	LYmove(h + 2, LYcols + LYshiftWin - 1);
d2109 1
a2109 1
		   ((int) line->offset + LenNeeded) < DISPLAY_COLS) {
d2339 1
d2442 1
d2740 3
a2742 2
    int indent = text->in_line_1 ?
    text->style->indent1st : text->style->leftIndent;
d2751 1
d2753 2
d2756 1
a2756 1
    char *cp;
d3099 1
d3101 1
d3111 8
a3118 1
	spare = (WRAP_COLS(text) - 1) -
d3128 3
a3130 3
		int spare_cu = (LYcols_cu(text) - 1) -
		utfxtra_on_previous_line - indent +
		ctrl_chars_on_previous_line - previous->size;
d3148 1
a3148 1
			    + utfxtra_on_previous_line <= (LYcols_cu(text) - 1))
d3154 1
a3154 1
				 * Can't move towars center all the way,
d3169 1
d3294 1
a3294 1
					/ ((WRAP_COLS(text) - 1)
d3991 1
a3991 1
			      1 : 0)) >= (LYcols_cu(text) - 1))
d4135 1
a4135 1
	if (target > (WRAP_COLS(text) - 1) - (int) style->rightIndent &&
d4143 2
a4144 2
	    if (target_cu > (WRAP_COLS(text) - 1))
		target -= target_cu - (WRAP_COLS(text) - 1);
d4167 1
a4167 1
	if (target >= (WRAP_COLS(text) - 1) - style->rightIndent -
d4170 1
a4170 1
	     target_cu + UTF_XLEN(ch) >= (LYcols_cu(text) - 1))) {
d4207 1
a4207 1
	limit = (WRAP_COLS(text) - 1);
d4225 1
a4225 1
	    || (nominal + UTFXTRA_ON_THIS_LINE) >= (LYcols_cu(text) - 1)) {
d4239 1
a4239 1
	limit = (LYcols_cu(text) - 1);
d4244 1
a4244 1
	limit = (WRAP_COLS(text) - 1);
d4686 1
a4686 1
    spare = (WRAP_COLS(me) - 1) -
d5604 1
a5604 1
    CTRACE((tfp, "Gridtext: Entering HText_endAppend\n"));
d5704 1
a5704 1
	CTRACE((tfp, "Gridtext: Entering HText_trimHightext (final)\n"));
d5709 1
a5709 1
		"Gridtext: Entering HText_trimHightext (partial: 0..%d/%d)\n",
d5726 1
a5726 1
	int have_soft_newline_in_1st_line = 0;
d5775 1
a5775 1
		"Gridtext: Anchor found on line:%d col:%d [%d] ext:%d\n",
d5903 5
d5910 11
d5923 1
d5925 1
a5925 1
	    for (; i < anchor_ptr->line_pos; i++) {
d5933 2
d5936 1
d5939 1
a5939 1
	 * Add the offset, and set the line number.
a5943 3
	/*handle LY_SOFT_NEWLINEs -VH */
	anchor_ptr->line_pos += have_soft_newline_in_1st_line;

d6665 1
a6665 1
	(LineOffset + LenNeeded) < DISPLAY_COLS) {
d7766 1
a7766 1
    if ((nolist == FALSE) &&
d8214 24
d8242 2
a8243 5
    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE ||
	(LYCacheSource == SOURCE_CACHE_FILE &&
	 !HTMainAnchor->source_cache_file) ||
	(LYCacheSource == SOURCE_CACHE_MEMORY &&
	 !HTMainAnchor->source_cache_chunk))
d8245 1
d8247 1
a8247 1
    if (LYCacheSource == SOURCE_CACHE_FILE && HTMainAnchor->source_cache_file) {
d8307 2
d8311 1
a8311 2
    if (LYCacheSource == SOURCE_CACHE_MEMORY &&
	HTMainAnchor->source_cache_chunk) {
d8357 2
a8360 2
    CTRACE((tfp, "Reparse %s\n", (ok ? "succeeded" : "failed")));

d8366 1
a8366 6
    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE ||
	(LYCacheSource == SOURCE_CACHE_FILE &&
	 !HTMainAnchor->source_cache_file) ||
	(LYCacheSource == SOURCE_CACHE_MEMORY &&
	 !HTMainAnchor->source_cache_chunk))
	return FALSE;
d8368 6
a8373 2
    if (LYCacheSource == SOURCE_CACHE_FILE && HTMainAnchor->source_cache_file) {
	return LYCanReadFile(HTMainAnchor->source_cache_file);
d8376 2
a8377 6
    if (LYCacheSource == SOURCE_CACHE_MEMORY &&
	HTMainAnchor->source_cache_chunk) {
	return TRUE;
    }

    return FALSE;		/* if came to here */
d8396 1
a8396 5
    if (!HTMainAnchor || !HTMainText || LYCacheSource == SOURCE_CACHE_NONE ||
	(LYCacheSource == SOURCE_CACHE_FILE &&
	 !HTMainAnchor->source_cache_file) ||
	(LYCacheSource == SOURCE_CACHE_MEMORY &&
	 !HTMainAnchor->source_cache_chunk))
d8716 1
a8716 1
    int column = (DISPLAY_COLS - 2);
d8719 1
a8719 2
	column = ((int) text->style->rightIndent ? (DISPLAY_COLS - 2) :
		  ((DISPLAY_COLS - 1) - (int) text->style->rightIndent));
d9786 1
a9786 1
    MaximumSize = WRAP_COLS(text) - adjust_marker;
a13280 1
    register int i;
d13290 9
a13298 3
    BOOL intarget = NO, inunderline = NO, inbold = NO;
    BOOL drawing = NO, inU = NO, hadutf8 = NO;
    BOOL incurlink = NO, drawingtarget = NO, flag = NO;
d13301 5
a13305 1
    int XP_link = XP;
d13320 11
a13330 5
    i = (int) offset;
    if (i > (int) DISPLAY_COLS - 1)
	i = (int) DISPLAY_COLS - 1;

    linkvlen = hightext ? LYmbcsstrlen(hightext, utf_flag, YES) : 0;
d13352 1
a13352 1
	    if ((int) offset + LenNeeded >= DISPLAY_COLS ||
d13372 1
a13372 1
    while ((i < DISPLAY_COLS - 1) && data < end_of_data && (*data != '\0')) {
d13383 1
a13383 1
	     * chars LY_BOLD_START_CHAR etc.  have been stripped out (see
d13388 1
a13388 1
	     * for something else than normal hyperlink anchors, i.e. form
d13396 2
a13397 1
	    XP += linkvlen;	/* from now on XP includes hightext chars */
d13406 1
a13406 1
	     * The logic of where to set intarget drawingtarget etc.
d13456 1
a13456 1
	if (i >= XP || data >= end_of_data)
a13459 1

d13468 1
a13468 1
		if (incurlink && flag && i == XP - 1)
d13482 1
a13482 1
			if (flag && i_start_tgt == XP - 1)
d13484 3
a13486 3
			if (flag && i_after_tgt >= XP)
			    i_after_tgt = XP - 1;
			if (flag && i_start_tgt >= XP)
d13488 1
a13488 1
		    } else if (i_start_tgt == XP) {
d13518 1
a13518 1
	 * target string, so that they stays in synch.  As long
d13528 4
a13531 5
	if (*sdata) {
	    do
		sdata++;
	    while (incurlink && *sdata && sdata != data &&
		   IsSpecialAttrChar(*(sdata - 1)));
d13600 1
a13600 1
		if (i == XP - 1) {
d13602 1
a13602 1
		} else if (i == XP - 2 && HTCJK != NOCJK &&
d13621 1
a13621 1
			  (i == XP_link || i == XP - 1))) {
d13628 1
a13628 1
			if (flag && (i == XP_link || i == XP - 1)) {
d13645 1
a13645 1
				 (i == XP_link || (incurlink && i == XP - 1)))) {
d13664 1
d13670 1
d13699 1
a13699 1
		if (drawing && (i < DISPLAY_COLS - 1)) {
d13727 1
a13727 1
	LYmove(YP, i);
@


1.5
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d2 2
a3 2
**		===============================
*/
a45 4
#ifdef USE_SOURCE_CACHE
#include <HTFile.h>
#endif

d70 2
a71 4
PRIVATE void HText_trimHightext PARAMS((
	HText *		text,
	BOOLEAN		final,
	int		stop_before));
d74 1
a74 1
PRIVATE void LynxResetScreenCache NOARGS
d85 2
a86 2
struct _HTStream {			/* only know it as object */
    CONST HTStreamClass *       isa;
d104 1
a104 1
PUBLIC HTkcode last_kcode = NOKANJI;	/* 1997/11/14 (Fri) 09:09:26 */
d114 2
a115 2
PUBLIC HText * HTMainText = NULL;		/* Equivalent of main window */
PUBLIC HTParentAnchor * HTMainAnchor = NULL;	/* Anchor for HTMainText */
d117 2
a118 2
PUBLIC char * HTAppName = LYNX_NAME;		/* Application name */
PUBLIC char * HTAppVersion = LYNX_VERSION;	/* Application version */
d120 12
a131 12
PUBLIC int HTFormNumber = 0;
PUBLIC int HTFormFields = 0;
PUBLIC char * HTCurSelectGroup = NULL;		/* Form select group name */
PRIVATE int HTCurSelectGroupCharset = -1;	/* ... and name's charset */
PUBLIC int HTCurSelectGroupType = F_RADIO_TYPE;	/* Group type */
PUBLIC char * HTCurSelectGroupSize = NULL;	/* Length of select */
PRIVATE char * HTCurSelectedOptionValue = NULL;	/* Select choice */

PUBLIC char * checked_box = "[X]";
PUBLIC char * unchecked_box = "[ ]";
PUBLIC char * checked_radio = "(*)";
PUBLIC char * unchecked_radio = "( )";
d133 2
a134 2
PRIVATE BOOLEAN underline_on = OFF;
PRIVATE BOOLEAN bold_on      = OFF;
d137 2
a138 2
PUBLIC int LYCacheSource = SOURCE_CACHE_NONE;
PUBLIC int LYCacheSourceForAborted = SOURCE_CACHE_FOR_ABORTED_DROP;
d142 4
a145 4
PUBLIC BOOLEAN LYShowScrollbar = FALSE;
PUBLIC BOOLEAN LYsb_arrow = TRUE;
PUBLIC int LYsb_begin = -1;
PUBLIC int LYsb_end = -1;
d153 2
a154 1
PRIVATE void * LY_check_calloc PARAMS((size_t nmemb, size_t size));
d176 3
a178 3
	unsigned int	direction:2;   /* on or off */
	unsigned int	horizpos:14;   /* horizontal position of this change */
	unsigned int	style:16;      /* which style to change to */
d189 7
a195 1
enum { POOL_SIZE = (8192 - 4*sizeof(void*) - sizeof(struct _HTPool*) - sizeof(int)) / sizeof(pool_data) };
d198 2
a199 2
    pool_data  data[POOL_SIZE];
    struct _HTPool* prev;
d250 5
a254 7
 *   Allocates 'n' items in the pool of type 'HTPool' pointed by 'poolptr'.
 *   Returns a pointer to the "allocated" memory or NULL if fails.
 *   Updates 'poolptr' if necessary.
 */
PRIVATE pool_data* ALLOC_IN_POOL ARGS2(
	HTPool**,	ppoolptr,
	unsigned,	request)
d256 2
a257 2
    HTPool* pool = *ppoolptr;
    pool_data* ptr;
d276 2
a277 1
	    HTPool* newpool = (HTPool*)LY_CALLOC(1, sizeof(HTPool));
d285 1
a285 1
	   }
d292 1
a292 1
 *   Returns a pointer to initialized pool of type 'HTPool', or NULL if fails.
d294 1
a294 1
PRIVATE HTPool* POOL_NEW NOARGS
d296 2
a297 1
    HTPool* poolptr = (HTPool*)LY_CALLOC(1, sizeof(HTPool));
d306 1
a306 1
 *   Frees a pool of type 'HTPool' pointed by poolptr.
d308 1
a308 2
PRIVATE void POOL_FREE ARGS1(
	HTPool*,	poolptr)
d310 3
a312 2
    HTPool* cur = poolptr;
    HTPool* prev;
d324 4
a327 4
	struct _line    *next;
	struct _line    *prev;
	unsigned short	offset;	/* Implicit initial spaces */
	unsigned short	size;	/* Number of characters */
d329 2
a330 2
	HTStyleChange*  styles;
	unsigned short  numstyles;
d332 1
a332 1
	char	data[1];	/* Space for terminator at least! */
d335 1
a335 2

#define LINE_SIZE(size) (sizeof(HTLine)+(size))   /* Allow for terminator */
d358 2
a359 2
	HTLine	base;
	char    data[MAX_LINE+2];
d365 12
a376 12
	struct _TextAnchor *	next;
	struct _TextAnchor *	prev;		/* www_user_search only! */
	int			number;		/* For user interface */
	int			line_num;	/* Place in document */
	short			line_pos;	/* Bytes/chars - extent too */
	short			extent;		/* (see HText_trimHightext) */
	BOOL			show_anchor;	/* Show the anchor? */
	BOOL			inUnderline;	/* context is underlined */
	BOOL			expansion_anch; /* TEXTAREA edit new anchor */
	char			link_type;	/* Normal, internal, or form? */
	FormInfo *		input_field;	/* Info for form links */
	HiliteList		lites;
d378 1
a378 1
	HTChildAnchor *		anchor;
d382 2
a383 2
	char *			name;		/* ID value of TAB */
	int			column;		/* Zero-based column value */
a385 1

d387 4
a390 4
**	next_line is valid if stale is false.
**	top_of_screen line means the line at the top of the screen
**			or just under the title if there is one.
*/
d392 1
a392 1
	HTParentAnchor *	node_anchor;
d394 17
a410 17
	HTLine *		last_line;
	HTLineTemp		temp_line[2];
	int			Lines;		/* Number of them */
	TextAnchor *		first_anchor;	/* double-linked on demand */
	TextAnchor *		last_anchor;
	TextAnchor *		last_anchor_before_stbl;
	TextAnchor *		last_anchor_before_split;
	HTList *		forms;		/* also linked internally */
	int			last_anchor_number;	/* user number */
	BOOL			source;		/* Is the text source? */
	BOOL			toolbar;	/* Toolbar set? */
	HTList *		tabs;		/* TAB IDs */
	HTList *		hidden_links;	/* Content-less links ... */
	int			hiddenlinkflag; /*  ... and how to treat them */
	BOOL			no_cache;	/* Always refresh? */
	char			LastChar;	/* For absorbing white space */
	BOOL			IgnoreExcess;	/* Ignore chars at wrap point */
d413 11
a423 11
	HTStyle *		style;			/* Current style */
	int			display_on_the_fly;	/* Lines left */
	int			top_of_screen;		/* Line number */
	HTLine *		top_of_screen_line;	/* Top */
	HTLine *		next_line;		/* Bottom + 1 */
	unsigned		permissible_split;	/* in last line */
	BOOL			in_line_1;		/* of paragraph */
	BOOL			stale;			/* Must refresh */
	BOOL			page_has_target; /* has target on screen */
	BOOL			has_utf8; /* has utf-8 on screen or line */
	BOOL			had_utf8; /* had utf-8 when last displayed */
d425 2
a426 2
	int			first_lineno_last_disp_partial;
	int			last_lineno_last_disp_partial;
d428 2
a429 2
	STable_info *		stbl;
	HTList *		enclosed_stbl;
d431 2
a432 2
	HTkcode			kcode;			/* Kanji code? */
	HTkcode			specified_kcode;	/* Specified Kanji code */
d434 35
a468 20
	enum _detected_kcode  { DET_SJIS, DET_EUC, DET_NOTYET, DET_MIXED }
				detected_kcode;		/* Detected Kanji code */
	enum _SJIS_status     { SJIS_state_neutral, SJIS_state_in_kanji,
				SJIS_state_has_bad_code } SJIS_status;
	enum _EUC_status      { EUC_state_neutral, EUC_state_in_kanji,
				EUC_state_in_kana, EUC_state_has_bad_code }
				EUC_status;
#endif
	enum grid_state       { S_text, S_esc, S_dollar, S_paren,
				S_nonascii_text, S_dollar_paren,
				S_jisx0201_text }
				state;		/* Escape sequence? */
	int			kanji_buf;	/* Lead multibyte */
	int			in_sjis;	/* SJIS flag */
	int			halted;		/* emergency halt */

	BOOL			have_8bit_chars; /* Any non-ASCII chars? */
	LYUCcharset *		UCI;		/* node_anchor UCInfo */
	int			UCLYhndl;	/* charset we are fed */
	UCTransParams		T;
d470 2
a471 2
	HTStream *		target;		/* Output stream */
	HTStreamClass		targetClass;	/* Output routines */
d473 1
a473 1
	HTPool*			pool;		/* this HText memory pool */
d476 14
a489 14
	/*
	* Parse settings when this HText was generated.
	*/
	BOOL			clickable_images;
	BOOL			pseudo_inline_alts;
	BOOL			verbose_img;
	BOOL			raw_mode;
	BOOL			historical_comments;
	BOOL			minimal_comments;
	BOOL			soft_dquotes;
	short			old_dtd;
	short			keypad_mode;
	short			disp_lines;	/* Screen size */
	short			disp_cols;	/* Used for reports only */
d494 1
a494 3
PUBLIC void* HText_pool_calloc ARGS2(
	HText *,	text,
	unsigned,	size)
d496 1
a496 1
    return (void*) ALLOC_IN_POOL(&text->pool, size);
d499 1
a499 1
PRIVATE void HText_AddHiddenLink PARAMS((HText *text, TextAnchor *textanchor));
d502 13
a514 2
PUBLIC BOOL can_justify_here;
PUBLIC BOOL can_justify_here_saved;
a515 8
PUBLIC BOOL can_justify_this_line;/* =FALSE if line contains form objects */
PUBLIC int wait_for_this_stacked_elt;/* -1 if can justify contents of the
    element on the op of stack. If positive - specifies minimal stack depth
    plus 1 at which we can justify element (can be MAX_LINE+2 if
    ok_justify ==FALSE or in psrcview. */
PUBLIC BOOL form_in_htext;/*to indicate that we are in form (since HTML_FORM is
  not stacked in the HTML.c */
PUBLIC BOOL in_DT = FALSE;
d517 1
a517 1
PUBLIC BOOL can_justify_stack_depth;/* can be 0 or 1 if all code is correct*/
a519 1

d521 2
a522 2
    int byte_len;		/*length in bytes*/
    int cell_len;		/*length in cells*/
d525 1
a525 2
static int justify_start_position;/* this is an index of char from which
    justification can start (eg after "* " preceeding <li> text) */
d527 3
a529 1
static int ht_num_runs;/*the number of runs filled*/
d532 1
a532 1
static TextAnchor* last_anchor_of_previous_line;
d535 1
a535 1
PUBLIC void ht_justify_cleanup NOARGS
d541 2
a542 1
	? 30000/*MAX_NESTING*/+2 /*some unreachable value*/ : -1;
d553 1
a553 1
PUBLIC void mark_justify_start_position ARGS1(void*,text)
d555 2
a556 2
    if (text && ((HText*)text)->last_line)
	justify_start_position = ((HText*)text )->last_line->size;
a558 1

a566 2


d568 1
a568 1
 *  Boring static variable used for moving cursor across
d578 2
a579 2
PRIVATE char underscore_string[MAX_LINE + 1];
PUBLIC char star_string[MAX_LINE + 1];
d581 4
a584 3
PRIVATE int ctrl_chars_on_this_line = 0; /* num of ctrl chars in current line */
PRIVATE int utfxtra_on_this_line = 0; /* num of UTF-8 extra bytes in line,
				       they *also* count as ctrl chars. */
d591 5
a595 6
PRIVATE HTStyle default_style =
	{ 0,  "(Unstyled)", 0, "",
	(HTFont)0, 1, HT_BLACK,		0, 0,
	0, 0, 0, HT_LEFT,		1, 0,	0,
	NO, NO, 0, 0,			0 };

d597 2
a599 2
PRIVATE HTList * loaded_texts = NULL;	 /* A list of all those in memory */
PUBLIC  HTList * search_queries = NULL;  /* isindex and whereis queries   */
d601 1
a601 1
PRIVATE void free_all_texts NOARGS;
d604 3
a606 9
PRIVATE BOOL HText_TrueEmptyLine PARAMS((
	HTLine *	line,
	HText *		text,
	BOOL		IgnoreSpaces));

PRIVATE int HText_TrueLineSize PARAMS((
	HTLine *	line,
	HText *		text,
	BOOL		IgnoreSpaces));
d611 6
a616 6
 *  text->halted = 1: have set fake 'Z' and output a message
 *		   2: next time when HText_appendCharacter is called
 *		      it will append *** MEMORY EXHAUSTED ***, then set
 *		      to 3.
 *		   3: normal text output will be suppressed (but not anchors,
 *		      form fields etc.)
d618 1
a618 1
PRIVATE void HText_halt NOARGS
d631 12
a642 14
 *  Check whether factor*min(bytes,MIN_NEEDED_MEM) is available,
 *  or bytes if factor is 0.
 *  MIN_NEEDED_MEM and factor together represent a security margin,
 *  to take account of all the memory allocations where we don't check
 *  and of buffers which may be emptied before HTCheckForInterupt()
 *  is (maybe) called and other things happening, with some chance of
 *  success.
 *  This just tries to malloc() the to-be-checked-for amount of memory,
 *  which might make the situation worse depending how allocation works.
 *  There should be a better way... - kw
 */
PRIVATE BOOL mem_is_avail ARGS2(
    size_t,	factor,
    size_t,	bytes)
d645 1
d660 5
a664 7
 *  Replacement for calloc which checks for "enough" free memory
 *  (with some security margins) and tries various recovery actions
 *  if deemed necessary. - kw
 */
PRIVATE void * LY_check_calloc ARGS2(
    size_t,	nmemb,
    size_t,	size)
d667 1
d673 11
a683 9
	HText * t = (HText *) HTList_objectAt(loaded_texts, i);
	CTRACE((tfp, "\nBUG *** Emergency freeing document %d/%d for '%s'%s!\n",
		    i + 1, n,
		    ((t && t->node_anchor &&
		      t->node_anchor->address) ?
		     t->node_anchor->address : "unknown anchor"),
		    ((t && t->node_anchor &&
		      t->node_anchor->post_data) ?
		     " with POST data" : "")));
d715 1
a715 2
PRIVATE void LYClearHiText ARGS1(
	TextAnchor *,	a)
d722 1
d728 2
a729 4
PRIVATE void LYSetHiText ARGS3(
	TextAnchor *,	a,
	char *,		text,
	int,		len)
d743 2
a744 4
PRIVATE void LYAddHiText ARGS3(
	TextAnchor *,	a,
	char *,		text,
	int,		x)
d767 1
a767 3
PRIVATE int LYAdjHiTextPos ARGS2(
	TextAnchor *,	a,
	int,		count)
d787 1
a787 3
PRIVATE char *LYGetHiTextStr ARGS2(
	TextAnchor *,	a,
	int,		count)
d804 1
a804 3
PRIVATE int LYGetHiTextPos ARGS2(
	TextAnchor *,	a,
	int,		count)
d821 1
a821 3
PRIVATE void LYCopyHiText ARGS2(
	TextAnchor *,	a,
	TextAnchor *,	b)
d827 1
a827 1
    for (count = 0; ; ++count) {
d838 1
a838 2
PRIVATE void HText_getChartransInfo ARGS1(
	HText *,	me)
d843 1
d852 1
a852 2
PRIVATE void PerFormInfo_free ARGS1(
    PerFormInfo *,	form)
d861 1
a861 2
PRIVATE void free_form_fields ARGS1(
	FormInfo *,	input_field)
d864 1
a864 1
     *  Free form fields.
d869 5
a873 5
	 *  Free off option lists if present.
	 *  It should always be present for F_OPTION_LIST_TYPE
	 *  unless we had invalid markup which prevented
	 *  HText_setLastOptionValue from finishing its job
	 *  and left the input field in an insane state. - kw
d877 1
d887 3
a889 3
	 *  Don't free the value field on option
	 *  lists since it points to a option value
	 *  same for orig value.
d909 1
a909 2
PRIVATE void FormList_delete ARGS1(
    HTList *,		forms)
d913 2
a914 1
    while ((form = (PerFormInfo *)HTList_nextObject(cur)) != NULL)
d920 3
a922 4
**			---------------
*/
PUBLIC HText *	HText_new ARGS1(
	HTParentAnchor *,	anchor)
d926 1
a926 1
    int status, VMType=3, VMTotal;
d928 3
a930 2
    HTLine * line = NULL;
    HText * self = typecalloc(HText);
d942 3
a944 3
     *  If the previously shown text had UTF-8 characters on screen,
     *  remember this in the newly created object.  Do this now, before
     *  the previous object may become invalid. - kw
d957 1
a957 1
    if (!loaded_texts)	{
d965 4
a968 4
     *  Links between anchors & documents are a 1-1 relationship.  If
     *  an anchor is already linked to a document we didn't call
     *  HTuncache_current_document(),  so we'll check now
     *  and free it before reloading. - Dick Wesseling (ftu@@fi.ruu.nl)
d972 1
a972 1
	CTRACE((tfp, "GridText: Auto-uncaching\n")) ;
d975 2
a976 2
	((HText *)anchor->document)->node_anchor = NULL;
	HText_free((HText *)anchor->document);
d989 1
a989 1
	HText_free((HText *)HTList_removeFirstObject(loaded_texts));
d1035 7
a1041 7
     *  If we are going to render the List Page, always merge in hidden
     *  links to get the numbering consistent if form fields are numbered
     *  and show up as hidden links in the list of links.
     *  If we are going to render a bookmark file, also always merge in
     *	hidden links, to get the link numbers consistent with the counting
     *  in remove_bookmark_link().  Normally a bookmark file shouldn't
     *	contain any entries with empty titles, but it might happen. - kw
d1051 1
a1051 1
		      anchor->post_data)
d1063 5
a1067 4
    /*  mark_htext_as_source == TRUE if we are parsing html file (and psrc_view is
     *	    set temporary to false at creation time)
     *	psrc_view == TRUE if source of the text produced by some lynx module
     *	    (like ftp browsers) is requested). - VH
d1069 3
a1071 1
    self->source = (BOOL) (LYpsrc ? mark_htext_as_source || psrc_view : HTOutputFormat == WWW_SOURCE);
d1074 2
a1075 2
    HTAnchor_setDocument(anchor, (HyperDoc *)self);
    HTFormNumber = 0;  /* no forms started yet */
d1097 1
a1097 1
     *  Check the kcode setting if the anchor has a charset element. -FM
d1103 4
a1106 4
     *	Memory leak fixed.
     *  05-29-94 Lynx 2-3-1 Garrett Arch Blythe
     *	Check to see if our underline and star_string need initialization
     *		if the underline is not filled with dots.
d1110 1
a1110 1
	 *  Create an array of dots for the UNDERSCORES macro. -FM
d1112 2
a1113 2
	memset(underscore_string, '.', (MAX_LINE-1));
	underscore_string[(MAX_LINE-1)] = '\0';
d1116 1
a1116 1
	 *  Create an array of underscores for the STARS macro. -FM
d1118 2
a1119 2
	memset(star_string, '_', (MAX_LINE-1));
	star_string[(MAX_LINE-1)] = '\0';
d1123 1
a1123 1
    underline_on = FALSE; /* reset */
d1132 2
a1133 2
	display_partial = TRUE;	 /* enable HTDisplayPartial() */
	NumOfLines_partial = 0;	 /* initialize */
d1137 4
a1140 4
     *  These two fields should only be set to valid line numbers
     *  by calls of display_page during partial displaying.  This
     *  is just so that the FIRST display_page AFTER that can avoid
     *  repainting the same lines on the screen. - kw
d1153 6
a1158 8
**			---------------
**
**      Stream is assumed open and left open.
*/
PUBLIC HText *  HText_new2 ARGS2(
	HTParentAnchor *,	anchor,
	HTStream *,		stream)

d1160 1
a1160 1
    HText * this = HText_new(anchor);
d1170 3
a1172 4
**	----------------
*/
PUBLIC void HText_free ARGS1(
	HText *,	self)
d1191 3
a1193 2
    while (self->first_anchor) {		/* Free off anchor array */
	TextAnchor * l = self->first_anchor;
d1205 1
a1205 1
     *  Free the tabs list. -FM
d1208 2
a1209 2
	HTTabID * Tab = NULL;
	HTList * cur = self->tabs;
d1211 1
a1211 1
	while (NULL != (Tab = (HTTabID *)HTList_nextObject(cur))) {
d1220 1
a1220 1
     *  Free the hidden links list. -FM
d1223 2
a1224 2
	char * href = NULL;
	HTList * cur = self->hidden_links;
d1226 1
a1226 1
	while (NULL != (href = (char *)HTList_nextObject(cur)))
d1233 2
a1234 2
     *  Invoke HTAnchor_delete() to free the node_anchor
     *  if it is not a destination of other links. -FM
d1253 1
a1253 1
	HTAnchor_setDocument(self->node_anchor, (HyperDoc *)0);
d1257 2
a1258 2
	     *  Make sure HTMainAnchor won't point
	     *  to an invalid structure. - KW
d1268 2
a1269 3
**		---------------
*/

d1272 4
a1275 7
**	-------------
*/
PRIVATE int display_line ARGS4(
	HTLine *,	line,
	HText *,	text,
	int,		scrline GCC_UNUSED,
	CONST char*,	target GCC_UNUSED)
d1282 1
d1285 1
d1289 1
a1289 1
    BOOL inbold=NO, inunderline=NO;
d1292 2
a1293 2
    CONST char *cp_tgt;
    int i_start_tgt=0, i_after_tgt;
d1295 2
a1296 1
    BOOL intarget=NO;
d1302 1
a1302 1
    text->has_utf8 = NO; /* use as per-line flag, except with ncurses */
d1306 3
a1308 3
     *  Set up the multibyte character buffer,
     *  and clear the line to which we will be
     *  writing.
d1314 2
a1315 2
     *  Add offset, making sure that we do not
     *  go over the COLS limit on the display.
d1317 3
a1319 3
    j = (int)line->offset;
    if (j > (int)DISPLAY_COLS - 1)
	j = (int)DISPLAY_COLS - 1;
d1321 1
a1321 1
    SLsmg_forward (j);
d1329 2
a1330 2
    for (i = 0; i < j; i++)
	LYaddch (' ');
d1334 2
a1335 2
     *  Add the data, making sure that we do not
     *  go over the COLS limit on the display.
d1343 1
a1343 1
     *  If the target is on this line, it will be emphasized.
d1348 4
a1351 4
				       target,
				       text->T.output_utf8, YES,
				       &HitOffset,
				       &LenNeeded);
d1353 1
a1353 1
	    if (((int)line->offset + LenNeeded) >= DISPLAY_COLS) {
d1374 4
a1377 4
					    target,
					    text->T.output_utf8, YES,
					    &HitOffset,
					    &LenNeeded);
d1385 4
a1388 2
		    if (inbold)		start_bold();
		    if (inunderline)	start_underline();
d1401 2
a1402 3
	       i >= (int) (CStyle.horizpos + line->offset + 1))
	{
	    LynxChangeStyle (CStyle.style, CStyle.direction);
d1409 7
a1415 7
	    case LY_UNDERLINE_START_CHAR:
		if (dump_output_immediately && use_underscore) {
		    LYaddch('_');
		    i++;
		} else {
		    inunderline = YES;
		    if (!intarget) {
d1417 4
a1420 4
			if (LYShowColor == SHOW_COLOR_NEVER)
			    start_bold();
			else
			    start_underline();
d1422 2
a1423 3
			start_underline();
#endif	/* PDCURSES */
		    }
d1425 2
a1426 1
		break;
d1428 7
a1434 7
	    case LY_UNDERLINE_END_CHAR:
		if (dump_output_immediately && use_underscore) {
		    LYaddch('_');
		    i++;
		} else {
		    inunderline = NO;
		    if (!intarget) {
d1437 1
a1437 1
			stop_bold();
d1439 1
a1439 1
			stop_underline();
d1441 2
a1442 3
		    stop_underline();
#endif	/* PDCURSES */
		    }
d1444 2
a1445 1
		break;
d1447 5
a1451 5
	    case LY_BOLD_START_CHAR:
		inbold = YES;
		if (!intarget)
		    start_bold();
		break;
d1453 5
a1457 5
	    case LY_BOLD_END_CHAR:
		inbold = NO;
		if (!intarget)
		    stop_bold();
		break;
d1460 4
a1463 4
	    case LY_SOFT_NEWLINE:
		if (!dump_output_immediately) {
		    LYaddch('+');
		    i++;
d1465 1
a1465 1
		    i_after_tgt++;
d1467 17
a1483 1
		}
d1485 7
d1493 1
a1493 24
	    case LY_SOFT_HYPHEN:
		if (*data != '\0' ||
		    isspace(UCH(LastDisplayChar)) ||
		    LastDisplayChar == '-') {
		    /*
		     *  Ignore the soft hyphen if it is not the last
		     *  character in the line.  Also ignore it if it
		     *  first character following the margin, or if it
		     *  is preceded by a white character (we loaded 'M'
		     *  into LastDisplayChar if it was a multibyte
		     *  character) or hyphen, though it should have
		     *  been excluded by HText_appendCharacter() or by
		     *  split_line() in those cases. -FM
		     */
		    break;
		} else {
		    /*
		     *  Make it a hard hyphen and fall through. -FM
		     */
		    buffer[0] = '-';
		}
		/* FALLTHRU */

	    default:
d1496 7
a1502 8
		if (!intarget && cp_tgt && i >= i_start_tgt) {
		    /*
		     *  Start the emphasis.
		     */
		    if (data > cp_tgt) {
			LYstartTargetEmphasis();
			intarget = YES;
		    }
d1504 1
d1507 14
a1520 14
		i++;
		if (text->T.output_utf8 && is8bits(buffer[0])) {
		    text->has_utf8 = YES;
		    utf_extra = utf8_length(text->T.output_utf8, data-1);
		    LastDisplayChar = 'M';
		}
		if (utf_extra) {
		    strncpy(&buffer[1], data, utf_extra);
		    buffer[utf_extra+1] = '\0';
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		    data += utf_extra;
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && is8bits(buffer[0])
d1522 1
a1522 1
		    && kanji_code != SJIS
d1525 5
a1529 4
		    /*
		     *  For CJK strings, by Masanobu Kimura.
		     */
		    if (i >= DISPLAY_COLS) goto after_while;
d1531 24
a1554 24
		    buffer[1] = *data;
		    buffer[2] = '\0';
		    data++;
		    i++;
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		    /*
		     *  For now, load 'M' into LastDisplayChar,
		     *  but we should check whether it's white
		     *  and if so, use ' '.  I don't know if
		     *  there actually are white CJK characters,
		     *  and we're loading ' ' for multibyte
		     *  spacing characters in this code set,
		     *  but this will become an issue when
		     *  the development code set's multibyte
		     *  character handling is used. -FM
		     */
		    LastDisplayChar = 'M';
		} else {
		    LYaddstr(buffer);
		    LastDisplayChar = buffer[0];
		}
	} /* end of switch */
    } /* end of while */
d1556 1
a1556 1
after_while:
d1564 1
a1564 1
     *  Add the return.
d1575 2
a1576 2
    stop_underline();
    stop_bold();
d1578 2
a1579 3
    while (current_style < line->numstyles)
    {
	LynxChangeStyle (CStyle.style, CStyle.direction);
d1584 1
a1584 1
    return(0);
d1588 3
a1590 4
**	---------------------
*/
PRIVATE void display_title ARGS1(
	HText *,	text)
d1600 1
a1600 1
     *  Make sure we have a text structure. -FM
d1605 1
a1605 1
    lynx_start_title_color ();
d1616 1
a1616 1
     *  Load the title field. -FM
d1623 3
a1625 3
     *  There shouldn't be any \n in the title field,
     *  but if there is, lets kill it now.  Also trim
     *  any trailing spaces. -FM
d1627 1
a1627 1
    if ((cp = strchr(title,'\n')) != NULL)
d1634 1
a1634 1
     *  Generate the page indicator (percent) string.
d1640 1
a1640 1
	text->top_of_screen <= 99999 && text->Lines <= 999999) {
d1644 1
a1644 1
	(display_lines) > 0) {
d1646 2
a1647 2
	 *  In a small attempt to correct the number of pages counted....
	 *    GAB 07-14-94
d1649 2
a1650 2
	 *  In a bigger attempt (hope it holds up 8-)....
	 *    FM 02-08-95
d1653 1
a1653 1
		(((text->Lines + 1) + (display_lines - 1))/(display_lines));
d1655 2
a1656 2
		((text->Lines + 1) < display_lines) ? 0 :
		((text->Lines + 1) - display_lines);
d1660 2
a1661 2
						 total_pages :
		    ((text->top_of_screen + display_lines)/(display_lines))),
d1668 3
a1670 3
     *  Generate and display the title string, with page indicator
     *  if appropriate, preceded by the toolbar token if appropriate,
     *  and truncated if necessary. -FM & KW
d1676 1
a1676 1
		TO_EUC((unsigned char *)title, tmp);
d1678 1
a1678 1
		TO_SJIS((unsigned char *)title, tmp);
d1681 1
a1681 1
		    if (title[i] != CH_ESC) {  /* S/390 -- gil -- 1487 */
d1687 1
a1687 1
	    StrAllocCopy(title, (CONST char *)tmp);
d1707 3
a1709 1
	    LYaddch(c); LYaddch(c); LYaddch(c);
d1713 3
a1715 1
	    LYaddch(ACS_RARROW); LYaddch(ACS_RARROW); LYaddch(ACS_RARROW);
d1725 2
a1726 2
	 *  Truncation takes into account the possibility that
	 *  multibyte characters might be present. -HS (H. Senshu)
d1729 2
a1730 1
	last = (int)strlen(percent) + CHAR_WIDTH;
d1752 1
a1752 1
	LYmove(1, 0);			/* As after \n */
d1760 1
a1760 1
    lynx_stop_title_color ();
d1766 2
a1767 2
**	---------------------
*/
d1769 1
a1769 2
PRIVATE void display_scrollbar ARGS1(
	HText *,	text)
d1772 2
a1773 2
    int h = display_lines - 2 * (LYsb_arrow!=0); /* Height of the scrollbar */
    int off = (LYsb_arrow != 0);		 /* Start of the scrollbar */
d1791 1
a1791 1
    sh = (shown*h + text->Lines/2)/(text->Lines + 1);
d1808 2
a1809 2
	    1. * (h - sh - 1) * text->top_of_screen
		/ (text->Lines - display_lines + 1));
d1840 1
a1840 1
    for (i=1; i <= h; i++) {
d1842 1
a1842 1
	if (i-1 <= top_skip && i > top_skip)
d1844 1
a1844 1
	if (i-1 <= h - bot_skip && i > h - bot_skip)
d1877 1
a1877 1
#define display_scrollbar(text) /*nothing*/
a1879 1

d1881 4
a1884 6
**	-------------
*/
PRIVATE void display_page ARGS3(
	HText *,	text,
	int,		line_number,
	char *,		target)
d1886 1
a1886 1
    HTLine * line = NULL;
d1888 1
d1902 1
d1911 3
a1913 3
	 *  Check whether to force a screen clear to enable scrollback,
	 *  or as a hack to fix a reverse clear screen problem for some
	 *  curses packages. - shf@@access.digex.net & seldon@@eskimo.com
d1922 1
a1922 1
	nlinks = 0;  /* set number of links to 0 */
a1924 1

d1934 2
a1935 1
    if (target && *target == '\0') target = NULL;
d1938 3
a1940 3
	/*  No screen space to display anything!
	 *  returning here makes it more likely we will survive if
	 *  an xterm is temporarily made very small. - kw */
d1948 1
a1948 1
     *  Constrain the line number to be within the document.
d1957 1
a1957 1
    for (i = 0, line = FirstHTLine(text);		/* Find line */
d1959 1
a1959 1
	 i++, line = line->next) {			/* Loop */
d1971 1
a1971 1
	    nlinks = 0;  /* set number of links to 0 */
d1977 1
a1977 1
    } /* Loop */
d1981 5
a1985 5
	/*
	 *  current_char_set has changed since last invocation,
	 *  and it's not just 7-bit.
	 *  Also we don't want to do this for -dump and -source etc.
	 */
d1989 1
a1989 1
	 *  Currently implemented only for LINUX
d1998 3
a2000 3
     *  Check whether to force a screen clear to enable scrollback,
     *  or as a hack to fix a reverse clear screen problem for some
     *  curses packages. - shf@@access.digex.net & seldon@@eskimo.com
a2006 1

d2009 4
a2012 4
     *  Reset stack of color attribute changes to avoid color leaking,
     *  except if what we last displayed from this text was the previous
     *  screenful, in which case carrying over the state might be beneficial
     *  (although it shouldn't generally be needed any more). - kw
d2022 2
a2023 2
    display_title(text);  /* will move cursor to top of screen */
    display_flag=TRUE;
d2031 1
a2031 1
    LynxResetScreenCache();
d2037 2
a2038 2
	if (stop_before_for_anchors > line_number+(display_lines))
	    stop_before_for_anchors = line_number+(display_lines);
d2041 1
a2041 1
	stop_before_for_anchors = line_number+(display_lines);
d2044 1
a2044 1
     *  Output the page.
d2058 1
a2058 1
	for (i = 0; i < (display_lines); i++)  {
d2060 1
a2060 1
	     *  Verify and display each line.
d2073 1
a2073 1
		nlinks = 0;  /* set number of links to 0 */
d2087 1
a2087 1
	    display_line(line, text, i+1, target);
d2092 2
a2093 2
	     *  If the target is on this line, recursively
	     *  seek and emphasize it. -FM
d2095 2
a2096 2
	    data = (char *)line->data;
	    offset = (int)line->offset;
d2098 6
a2103 6
		    (cp = LYno_attr_mb_strstr(data,
					      target,
					      text->T.output_utf8, YES,
					      NULL,
					      &LenNeeded)) != NULL &&
		   ((int)line->offset + LenNeeded) < DISPLAY_COLS) {
d2106 1
a2106 1
		int x_pos = offset + (int)(cp - data);
d2114 1
a2114 1
		 *  Start the emphasis.
d2119 1
a2119 1
		 *  Output the target characters.
d2123 1
a2123 1
		     itmp++)  {
d2126 1
a2126 1
			 *  Ignore special characters.
d2133 1
a2133 1
			     *  First printable character of target.
d2138 1
a2138 1
			 *  Output all the printable target chars.
d2142 2
a2143 2
			    strncpy(&tmp[1], &line->data[itmp+1], utf_extra);
			    tmp[utf_extra+1] = '\0';
d2151 1
a2151 1
			     *  For CJK strings, by Masanobu Kimura.
d2165 3
a2167 3
		 *  Stop the emphasis, and reset the offset and
		 *  data pointer for our current position in the
		 *  line. -FM
d2171 1
a2171 1
		data = (char *)&data[itmp];
d2174 3
a2176 3
		 *  Adjust the cursor position, should we be at
		 *  the end of the line, or not have another hit
		 *  in it. -FM
d2179 1
a2179 1
	    } /* end while */
d2184 2
a2185 2
	     *  Stop if this is the last line.  Otherwise, make sure
	     *  display_flag is set and process the next line. -FM
d2189 1
a2189 1
		 *  Clear remaining lines of display.
d2200 2
a2201 2
		 *  Remember as fully shown during last partial display,
		 *  if it was not the last text line. - kw
d2208 3
a2210 3
	} /* end of "Verify and display each line." loop */
    } /* end "Output the page." */

d2215 1
a2215 1
     *  Add the anchors to Lynx structures.
d2223 1
a2223 1
	 && Anchor_ptr->line_num < stop_before_for_anchors) {
d2227 1
a2227 1
	     *  Load normal hypertext anchors.
d2230 2
a2231 2
	     && non_empty(hi_string)
	     && (Anchor_ptr->link_type & HYPERTEXT_ANCHOR)) {
d2235 1
a2235 1
		for (count = 0; ; ++count) {
d2253 2
a2254 2
		     *	Memory leak fixed 05-27-94
		     *	Garrett Arch Blythe
d2257 1
d2264 1
a2264 1
				Anchor_ptr->anchor, HTInternalLink);
d2268 2
a2269 2
		    "GridText: display_page: unexpected typed link to %s!\n",
					    link_dest_intl->parent->address));
d2276 1
d2303 1
a2303 1
		    && Anchor_ptr->input_field->type != F_HIDDEN_TYPE) {
d2305 1
a2305 1
		 *  Handle form fields.
d2335 1
a2335 1
		} else {  /* TEXT type */
d2342 1
a2342 1
		 *  Bold the link after incrementing nlinks.
d2350 1
a2350 1
		 *  Not showing anchor.
d2361 2
a2362 2
	     *  Links array is full.  If interactive, tell user
	     *  to use half-page or two-line scrolling. -FM
d2370 1
a2370 1
    } /* end of loop "Add the anchors to Lynx structures." */
d2373 2
a2374 2
     *  Free any un-reallocated links[] entries
     *  from the previous page draw. -FM
d2383 3
a2385 3
     *  If Anchor_ptr is not NULL and is not pointing to the last
     *  anchor, then there are anchors farther down in the document,
     *  and we need to flag this for traversals.
d2395 1
a2395 1
	 *  Nothing on the page.
d2417 2
a2418 2
	 *  For other than ncurses, repainting is taken care of
	 *  by touching lines in display_line and highlight. - kw 1999-10-07
d2424 1
a2424 1
	 *  For non-multibyte curses.
d2426 3
a2428 3
	 *  Full repainting is necessary, otherwise only part of a multibyte
	 *  character sequence might be written because of curses output
	 *  optimizations.
a2436 1

d2438 5
a2442 6
**			-----------------------
**
**	These are used by a parser to build the text in an object
*/
PUBLIC void HText_beginAppend ARGS1(
	HText *,	text)
a2448 1

d2470 16
a2485 16
**	----------------------
**
** On entry,
**
**	split	is zero for newline function, else number of characters
**		before split.
**	text->display_on_the_fly
**		may be set to indicate direct output of the finished line.
** On exit,
**		A new line has been made, justified according to the
**		current style.  Text after the split (if split nonzero)
**		is taken over onto the next line.
**
**		If display_on_the_fly is set, then it is decremented and
**		the finished line is displayed.
*/
d2493 1
a2493 1
#define CTRACE_SPLITLINE(p)	/*nothing*/
d2496 4
a2499 5
PRIVATE int set_style_by_embedded_chars ARGS4(
	char *,		s,
	char *,		e,
	unsigned char,	start_c,
	unsigned char,	end_c)
d2514 6
a2519 8
PRIVATE void move_anchors_in_region ARGS7(
    HTLine *,		line,
    int,		line_number,
    TextAnchor **,	prev_anchor,	/*updates++*/
    int *,		prev_head_processed,
    int,		sbyte,
    int,		ebyte,
    int,		shift)		/* Likewise */
d2548 2
a2549 2
	    last -= line->prev->size + 1; /* Fake "\n" "between" lines counted too */
	if (last < sbyte)		/* Completely before the start */
d2552 3
a2554 3
	if ( !head_processed		/* a->line_pos is not edited yet */
	     && a->line_num == line_number
	     && a->line_pos >= ebyte)	/* Completely after the end */
d2559 2
a2560 2
	if ( !head_processed && a->line_num == line_number
	     && a->line_pos >= sbyte ) {
d2566 1
a2566 1
	if ( last < ebyte )
d2569 1
a2569 1
	    break;			/* Keep this `a' for the next step */
d2576 9
a2584 9
 *  Given a line and two int arrays of old/now position, this function
 *  creates a new line where spaces have been inserted/removed
 *  in appropriate places - so that characters at/after the old
 *  position end up at/after the new position, for each pair, if possible.
 *  Some necessary changes for anchors starting on this line are also done
 *  here if needed. Updates 'prev_anchor' internally.
 *  Returns a newly allocated HTLine* if changes were made
 *    (caller has to free the old one).
 *  Returns NULL if no changes needed.  (Remove-spaces code may be buggy...)
d2587 6
a2592 8
PRIVATE HTLine * insert_blanks_in_line ARGS7(
    HTLine *,		line,
    int,		line_number,
    HText *,		text,
    TextAnchor **,	prev_anchor,	/*updates++*/
    int,		ninserts,
    int *,		oldpos,		/* Measured in cells */
    int *,		newpos)		/* Likewise */
d2594 3
a2596 2
    int ioldc = 0;			/* count visible characters */
    int ip;				/* count insertion pairs */
d2603 1
a2603 1
    HTLine * mod_line;
d2619 1
a2619 1
	   mod_line = TEMP_LINE(text, 1);
d2621 1
a2621 1
	   mod_line = TEMP_LINE(text, 0);
d2637 5
a2641 4
		      /* Include'em all! */
		      : ((int)line->size <= MAX_LINE
			  ? MAX_LINE+1
			  : (int)line->size+1));
d2647 2
a2648 2
	    if ( text && text->T.output_utf8
		 && UCH(*s) >= 0x80 && UCH(*s) <  0xC0 ) {
d2650 1
a2650 1
	    } else if (!IsSpecialAttrChar(*s)) { /* At a "displayed" char */
d2660 2
a2661 2
	if (ip)				/* Fix anchor positions */
	    move_anchors_in_region(line, line_number, prev_anchor /*updates++*/,
d2667 3
a2669 1
	for (; istyle < line->numstyles && (int) NStyle.horizpos < curlim ; istyle++)
d2688 1
a2688 1
    while (pre < s)	/* Copy remaining style-codes */
d2699 9
a2707 10
PRIVATE HTStyleChange * skip_matched_and_correct_offsets ARGS3(
	HTStyleChange *,	end,
	HTStyleChange *,	start,
	unsigned,		split_pos)
{ /* Found an OFF change not part of an adjacent matched pair.
   * Walk backward looking for the corresponding ON change.
   * Move everything after split_pos to be at split_pos.
   * This can only work correctly if all changes are correctly
   * nested!  If this fails, assume it is safer to leave whatever
   * comes before the OFF on the previous line alone. */
d2728 1
a2728 3
PRIVATE void split_line ARGS2(
	HText *,	text,
	unsigned,	split)
d2730 1
a2730 1
    HTStyle * style = text->style;
d2733 1
a2733 1
	  text->style->indent1st : text->style->leftIndent;
d2735 1
a2735 1
    TextAnchor * a;
d2744 1
a2744 1
    char * cp;
d2746 2
a2747 2
    HTLine * previous = text->last_line;
    HTLine * line;
d2750 1
a2750 1
     *  Set new line.
d2760 2
a2761 2
    ctrl_chars_on_this_line = 0; /*reset since we are going to a new line*/
    utfxtra_on_this_line = 0;	/*reset too, we'll count them*/
d2765 2
a2766 2
    CTRACE((tfp,"GridText: split_line(%p,%d) called\n", text, split));
    CTRACE((tfp,"   bold_on=%d, underline_on=%d\n", bold_on, underline_on));
d2772 1
a2772 1
     || cp[0] == LY_UNDERLINE_START_CHAR) {
d2774 8
a2781 1
	    case LY_SOFT_NEWLINE:
d2784 2
a2785 9
		break;
	    case LY_BOLD_START_CHAR:
	    case LY_UNDERLINE_START_CHAR:
		if (cp[2] == LY_SOFT_NEWLINE) {
		    cp[2] = cp[1];
		    cp[1] = cp[0];
		    cp[0] = LY_SOFT_NEWLINE;
		}
		break;
d2790 2
a2791 2
	       "*** split_line: split==%d greater than last_line->size==%d !\n",
	       split, previous->size));
d2810 1
a2810 1
    text->permissible_split = 0;  /* 12/13/93 */
d2815 1
a2815 1
    if (split > 0) { /* Restore flags to the value at the splitting point */
d2817 7
a2823 7
	    t_underline = set_style_by_embedded_chars(
		previous->data, previous->data + split,
		LY_UNDERLINE_START_CHAR, LY_UNDERLINE_END_CHAR);

	t_bold = set_style_by_embedded_chars(
	    previous->data, previous->data + split,
	    LY_BOLD_START_CHAR, LY_BOLD_END_CHAR);
d2841 1
a2841 1
     *  Split at required point
d2843 1
a2843 1
    if (split > 0) {	/* Delete space at "split" splitting line */
d2853 2
a2854 2
	 *  Trim any spaces or soft hyphens from the beginning
	 *  of our new line. -FM
d2857 1
a2857 2
	while ((
		(*p == ' '
d2859 4
a2862 4
		/* if justification is allowed for prev line, then raw
		 * HT_NON_BREAK_SPACE are still present in data[] (they'll be
		 * substituted at the end of this function with ' ') - VH
		 */
d2871 1
a2871 1
		*p == LY_SOFT_HYPHEN) {
d2877 1
a2877 1
	if (plen) {			/* Count funny characters */
d2888 1
a2888 1
		if (p[i] == LY_SOFT_HYPHEN && (int)text->permissible_split < i)
d2900 1
a2900 1
     *  Economize on space.
d2906 4
a2909 4
	    /* if justification is allowed for prev line, then raw
	     * HT_NON_BREAK_SPACE are still present in data[] (they'll be
	     * substituted at the end of this function with ' ') - VH
	     */
d2912 1
a2912 1
	      )
d2914 3
a2916 3
	   && !psrc_view /*don't strip trailing whites - since next line can
		start with LY_SOFT_NEWLINE - so we don't lose spaces when
		'p'rinting this text to file -VH */
d2923 1
a2923 1
	p--;	/*  Strip trailers. */
d2925 1
a2925 1
    TailTrim = previous->data + previous->size - 1 - p;	/*  Strip trailers. */
d2930 3
a2932 3
     *  s is the effective split position, given by either a non-zero
     *  value of split or by the size of the previous line before
     *  trimming. - kw
d2935 1
a2935 1
	s = previous->size + TailTrim; /* the original size */
d2940 1
a2940 1
    s_pre  = s - TailTrim;
d2944 1
a2944 1
    if (s != (int)split)
d2946 1
a2946 1
	CTRACE((tfp,"GridText: split_line(%d [now:%d]) called\n", split, s));
d2960 4
a2963 4
	/*  Color style changes after the split position
	 *  are transferred to the new line.  Ditto for changes
	 *  in the trimming region, but we stop when we reach an OFF change.
	 *  The second loop below may then handle remaining changes. - kw */
d2967 1
a2967 1
		to->horizpos += - s_post + SpecialAttrChars;
d2989 1
a2989 1
		  Report a bug on failure.
d2991 2
a2992 2
		  and the corresponding OFF at to;
		  If not, put the corresponding OFF at at_end, and copy to to;
d3002 3
a3004 3
		if ( at_end->direction == STACK_ON
		     && at_end->style == scan->style
		     && (int) at_end->horizpos >= s_pre )
d3015 4
a3018 4
		if ( to < line->styles + MAX_STYLES_ON_LINE - 1
		     && to[1].direction == STACK_OFF
		     && to[1].horizpos <= (unsigned) SpecialAttrChars
		     && to[1].style == scan->style )
d3040 1
a3040 1
	    line->styles[0].horizpos = ~0; /* ?!!! */
d3045 1
a3045 1
#endif /*USE_COLOR_STYLE*/
d3048 6
a3053 5
    HTLine* temp;
    allocHTLine(temp, previous->size);
    if (!temp)
	outofmem(__FILE__, "split_line_2");
    memcpy(temp, previous, LINE_SIZE(previous->size));
d3055 4
a3058 4
    POOLallocstyles(temp->styles, previous->numstyles);
    if (!temp->styles)
	outofmem(__FILE__, "split_line_2");
    memcpy(temp->styles, previous->styles, sizeof(HTStyleChange)*previous->numstyles);
d3060 1
a3060 1
    previous = temp;
d3067 1
a3067 1
     *  Terminate finished line for printing.
d3072 1
a3072 1
     *  Align left, right or center.
d3077 1
a3077 1
	this_line_was_split ||
d3079 2
a3080 2
	(alignment == HT_CENTER ||
	 alignment == HT_RIGHT) || text->stbl) {
d3093 1
a3093 1
		(int)(previous->data[previous->size-1] == LY_SOFT_HYPHEN))
d3097 2
a3098 2
	spare =  (WRAP_COLS(text)-1) -
	    (int)style->rightIndent - indent +
d3107 14
a3120 13
		int spare_cu = (LYcols_cu(text)-1) -
		    utfxtra_on_previous_line - indent +
		    ctrl_chars_on_previous_line - previous->size;
		    /*
		     *  Shift non-leftaligned UTF-8 lines that would be
		     *  mishandled by the display library towards the left
		     *  if this would make them fit.  The resulting display
		     *  will not be as intended, but this is better than
		     *  having them split by curses.  (Curses cursor movement
		     *  optimization may still cause wrong positioning within
		     *  the line, in particular after a sequence of spaces).
		     * - kw
		     */
d3124 2
a3125 2
			    (int)(previous->offset + indent + spare/2 +
				  previous->size)
d3128 1
a3128 1
			    /* do nothing - it still fits - kw */;
d3133 3
a3135 3
				 *  Can't move towars center all the way,
				 *  but at least make line contents appear
				 *  as far right as possible. - kw
d3140 2
a3141 3
		    } else if (indent + (int)previous->offset + spare_cu >= 0)
		    { /* subtract overdraft from effective indentation */
			indent += (int)previous->offset + spare_cu;
d3151 12
a3162 12
	case HT_CENTER :
	    previous->offset = previous->offset + indent + spare/2;
	    break;
	case HT_RIGHT :
	    previous->offset = previous->offset + indent + spare;
	    break;
	case HT_LEFT :
	case HT_JUSTIFY :		/* Not implemented */
	default:
	    previous->offset = previous->offset + indent;
	    break;
    } /* switch */
d3166 9
a3174 9
	 *  Notify simple table stuff of line split, so that it can
	 *  set the last cell's length.  The last cell should and
	 *  its row should really end here, or on one of the following
	 *  lines with no more characters added after the break.
	 *  We don't know whether a cell has been started, so ignore
	 *  errors here.
	 *  This call is down here because we need the
	 *  ctrl_chars_on_previous_line, which have just been re-
	 *  counted above. - kw
d3181 1
a3181 1
    text->in_line_1 = NO;		/* unless caller sets it otherwise */
d3184 2
a3185 2
     *  If we split the line, adjust the anchor
     *  structure values for the new line. -FM
d3188 1
a3188 1
    if (s > 0) {			/* if not completely empty */
d3203 1
a3203 1
	for ( ; a; a = a->next) {
d3212 2
a3213 2
		      "Just because": those before s;
		      this is the only case when we use s, not s_pre/s_post);
d3231 2
a3232 1
		    CTRACE_SPLITLINE((tfp, "anchor %d: no relocation, empty-finished",
d3234 1
a3234 1
		    a->line_pos = s_pre; /* Leave at the end of line */
d3241 4
a3244 3
		CTRACE_SPLITLINE((tfp, "anchor %d: (T,H,S)=(%d,%d,%d); (line,pos,ext):(%d,%d,%d), ",
		       n, TailTrim,HeadTrim,SpecialAttrChars,
		       a->line_num,a->line_pos,a->extent));
d3258 1
a3258 1
		       a->line_num,a->line_pos,a->extent));
a3262 1

d3267 12
a3278 12
     && spare
     && !text->stbl	/* We don't inform TRST on the cell width change yet */
     && justify_max_void_percent > 0
     && justify_max_void_percent <= 100
     && justify_max_void_percent >= ((100*spare)
				  / ((WRAP_COLS(text) - 1)
				   - (int)style->rightIndent
				   - indent
				   + ctrl_chars_on_previous_line))) {
	/* this is the only case when we need justification*/
	char* jp = previous->data + justify_start_position;
	ht_run_info* r = ht_runs;
d3282 1
a3282 1
	HTLine * jline;
d3287 1
a3287 1
	for(; (c = *jp) != 0; ++jp) {
d3297 1
a3297 1
	    if ( IsSpecialAttrChar(c) )
d3307 1
d3317 1
a3317 1
	    int *oldpos = (int*)malloc(sizeof(int)*2*(ht_num_runs - 1));
d3324 2
a3325 2
	    d_ = spare/(ht_num_runs-1);
	    r_ = spare % (ht_num_runs-1);
d3329 1
a3329 1
	    newpos[0] = oldpos[0] + ( d_ + ( r_--  > 0 ) );
d3333 2
a3334 2
		oldpos[i] = oldpos[i-1] + delta;
		newpos[i] = newpos[i-1] + delta + ( d_ + ( r_--  > 0 ) );
d3338 1
a3338 1
					  &last_anchor_of_previous_line /*updates++*/,
d3340 1
a3340 1
	    free((char*)oldpos);
d3349 1
a3349 2
	}
	{ /* (ht_num_runs==1) */
d3351 3
a3353 2
		char* p2 = previous->data;
		for( ; p2 < previous->data + justify_start_position; ++p2)
d3358 2
a3359 2
	if (REALLY_CAN_JUSTIFY(text) ) {
	    char* p2;
d3366 2
a3367 1
		  CTRACE((tfp,"BUG: justification: shouldn't happen - new line is not empty!\n"));
d3370 1
a3370 1
	    for (p2=previous->data;*p2;++p2)
d3375 1
a3375 1
	       table cells*/
d3378 1
a3378 1
	    for (i = 0; i< previous->size; ++i)
d3383 1
a3383 1
	    for (i = 0; i< line->size; ++i)
d3391 1
a3391 1
	/* cleanup */
d3398 1
a3398 2
} /* split_line */

d3401 3
a3403 5
**	--------------------------
*/
PRIVATE void blank_lines ARGS2(
	HText *,	text,
	int,		newlines)
d3405 2
a3406 2
    if (HText_LastLineEmpty(text, FALSE)) { /* No text on current line */
	HTLine * line = text->last_line->prev;
d3411 1
a3411 1
	    return;			/* Do not add a blank line at start */
d3423 1
a3423 1
	newlines++;			/* Need also to finish this line */
a3431 1

d3433 4
a3436 5
**	------------------------------
** See also: setStyle.
*/
PUBLIC void HText_appendParagraph ARGS1(
	HText *,	text)
d3440 1
a3443 1

d3445 5
a3449 7
**	---------
**
**	Does not filter unnecessary style changes.
*/
PUBLIC void HText_setStyle ARGS2(
	HText *,	text,
	HTStyle *,	style)
d3454 1
a3454 1
	return;				/* Safety */
d3460 1
a3460 1
    blank_lines (text, ((after > before) ? after : before));
d3466 3
a3468 5
**	-------------------------------------
*/
PUBLIC void HText_appendCharacter ARGS2(
	HText *,	text,
	int,		ch)
d3470 2
a3471 2
    HTLine * line;
    HTStyle * style;
d3482 3
a3484 2
	char * special = NULL;  /* make trace a little more readable */
	switch(ch) {
d3486 2
a3487 2
		special = "HT_NON_BREAK_SPACE";
		break;
d3489 2
a3490 2
		special = "HT_EN_SPACE";
		break;
d3492 2
a3493 2
		special = "LY_UNDERLINE_START_CHAR";
		break;
d3495 2
a3496 2
		special = "LY_UNDERLINE_END_CHAR";
		break;
d3498 2
a3499 2
		special = "LY_BOLD_START_CHAR";
		break;
d3501 2
a3502 2
		special = "LY_BOLD_END_CHAR";
		break;
d3504 2
a3505 2
		special = "LY_SOFT_HYPHEN";
		break;
d3507 2
a3508 2
		special = "LY_SOFT_NEWLINE";
		break;
d3510 2
a3511 2
		special = NULL;
		break;
d3516 1
a3516 1
		   HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
d3518 1
a3518 1
#ifdef CJK_EX	/* 1998/08/30 (Sun) 13:26:23 */
d3524 1
a3524 1
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
d3539 1
a3539 1
#endif	/* CJK_EX */
d3541 1
a3541 1
    } /* trace only */
d3545 1
a3545 1
     *  Make sure we don't crash on NULLs.
d3552 2
a3553 2
	 *  We should stop outputting more text, because low memory was
	 *  detected.  - kw
d3557 4
a3560 4
	     *  But if we haven't done so yet, first append a warning.
	     *  We should still have a few bytes left for that :).
	     *  We temporarily reset test->halted to 0 for this, since
	     *  this function will get called recursively. - kw
d3583 1
a3583 2
	    }
	    else if ((c & 0x80) && !IS_SJIS_X0201KANA(c)) {
d3594 1
a3594 2
	    }
	    else {
d3609 1
a3609 2
	    }
	    else if (c == 0x8e) {
d3611 1
a3611 2
	    }
	    else if (c & 0x80) {
d3622 1
a3622 2
	    }
	    else {
d3631 1
a3631 1
	    if ((0xA1<=c)&&(c<=0xDF)) {
d3633 1
a3633 2
	    }
	    else {
d3645 2
a3646 1
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode seems SJIS.\n"));
d3649 2
a3650 1
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode seems EUC.\n"));
d3653 2
a3654 1
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode seems mixed!\n"));
d3657 2
a3658 1
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode is unexpected!\n"));
d3665 1
a3665 1
     *  Make sure we don't hang on escape sequences.
d3667 1
a3667 1
    if (ch == CH_ESC && HTCJK == NOCJK) {		/* decimal 27  S/390 -- gil -- 1504 */
d3672 6
a3677 6
     *  Block 8-bit chars not allowed by the current display character
     *  set if they are below what LYlowest_eightbit indicates.
     *  Slang used its own replacements, so for USE_SLANG blocking here
     *  is not necessary to protect terminals from those characters.
     *  They should have been filtered out or translated by an earlier
     *  processing stage anyway. - kw
d3679 1
a3679 1
#ifndef   EBCDIC  /* S/390 -- gil -- 1514 */
d3698 1
a3698 1
    indent = text->in_line_1 ? (int)style->indent1st : (int)style->leftIndent;
d3701 3
a3703 14
	switch(text->state) {
	    case S_text:
		if (ch == CH_ESC) {  /* S/390 -- gil -- 1536 */
		    /*
		    **  Setting up for CJK escape sequence handling (based on
		    **  Takuya ASADA's (asada@@three-a.co.jp) CJK Lynx). -FM
		    */
		    text->state = S_esc;
		    text->kanji_buf = '\0';
		    return;
		}
		break;

	    case S_esc:
d3705 2
a3706 1
		 *  Expecting '$'or '(' following CJK ESC.
d3708 37
a3744 10
		if (ch == '$') {
		    text->state = S_dollar;
		    return;
		} else if (ch == '(') {
		    text->state = S_paren;
		    return;
		} else {
		    text->state = S_text;
		}
		/* FALLTHRU */
d3746 11
a3756 16
	    case S_dollar:
		/*
		 *  Expecting '@@', 'B', 'A' or '(' after CJK "ESC$".
		 */
		if (ch == '@@' || ch == 'B' || ch=='A') {
		    text->state = S_nonascii_text;
		    if (ch == '@@' || ch == 'B')
			text->kcode = JIS;
		    return;
		} else if (ch == '(') {
		    text->state = S_dollar_paren;
		    return;
		} else {
		    text->state = S_text;
		}
		break;
d3758 5
a3762 1
	    case S_dollar_paren:
d3764 1
a3764 1
		 * Expecting 'C' after CJK "ESC$(".
d3766 5
a3770 9
		if (ch == 'C') {
		    text->state = S_nonascii_text;
		    return;
		} else {
		    text->state = S_text;
		}
		break;

	    case S_paren:
d3772 1
a3772 1
		 *  Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(".
d3774 7
a3780 19
		if (ch == 'B' || ch == 'J' || ch == 'T')  {
		    /*
		     *  Can split here. -FM
		     */
		    text->permissible_split = text->last_line->size;
		    text->state = S_text;
		    return;
		} else if (ch == 'I')  {
		    text->state = S_jisx0201_text;
		    /*
		     *  Can split here. -FM
		     */
		    text->permissible_split = text->last_line->size;
		    text->kcode = JIS;
		    return;
		} else {
		    text->state = S_text;
		}
		break;
d3782 9
a3790 19
	    case S_nonascii_text:
		/*
		 *  Expecting CJK ESC after non-ASCII text.
		 */
		if (ch == CH_ESC) {  /* S/390 -- gil -- 1553 */
		    text->state = S_esc;
		    text->kanji_buf = '\0';
		    if (HTCJK == JAPANESE) {
			text->kcode = NOKANJI;
		    }
		    return;
		} else if (UCH(ch) < 32) {
		    text->state = S_text;
		    text->kanji_buf = '\0';
		    if (HTCJK == JAPANESE) {
			text->kcode = NOKANJI;
		    }
		} else {
		    ch |= 0200;
d3792 5
a3796 9
		break;

		/*
		 *  JIS X0201 Kana in JIS support. - by ASATAKU
		 */
	    case S_jisx0201_text:
		if (ch == CH_ESC) {  /* S/390 -- gil -- 1570 */
		    text->state = S_esc;
		    text->kanji_buf = '\0';
a3797 4
		    return;
		} else {
		    text->kanji_buf = '\216';
		    ch |= 0200;
d3799 20
a3818 2
		break;
	} /* end switch */
d3823 1
a3823 1
		 *  JIS X0201 Kana in SJIS support. - by ASATAKU
d3826 1
a3826 1
		 && (
d3828 2
a3829 2
		    (last_kcode == SJIS) ||
		     ((last_kcode == NOKANJI) &&
d3831 1
a3831 1
		      ((text->kcode == SJIS) ||
d3833 2
a3834 2
		       ((text->detected_kcode == DET_SJIS) &&
			(text->specified_kcode == NOKANJI)) ||
d3836 2
a3837 2
		       ((text->kcode == NOKANJI) &&
			(text->specified_kcode == SJIS)) )
d3839 1
a3839 1
		     )
d3847 1
d3849 3
a3851 3
					(unsigned char *)&kb,
					(unsigned char *)&c);
		    ch = (char)c;
d3855 1
a3855 1
		    text->permissible_split = (int)text->last_line->size;
d3859 1
a3859 1
		     *  Can split here. -FM
d3868 1
a3868 1
    } else if (ch == CH_ESC) {  /* S/390 -- gil -- 1587 */
d3871 1
a3871 2

#ifdef CJK_EX	/* MOJI-BAKE Fix! 1997/10/12 -- 10/31 (Fri) 00:22:57 - JH7AYN */
d3874 1
a3874 1
	text->permissible_split = (int)line->size;	/* Can split here */
d3882 1
a3882 1
	if (line->size >= (MAX_LINE-1)) {
d3886 1
a3886 1
	if (with_backspaces && HTCJK==NOCJK && !text->T.output_utf8) {
d3888 18
a3905 5
	if (ch == LY_UNDERLINE_START_CHAR) {
	    line->data[line->size++] = LY_UNDERLINE_START_CHAR;
	    line->data[line->size] = '\0';
	    underline_on = ON;
	    if (!(dump_output_immediately && use_underscore))
d3907 5
a3911 6
	    return;
	} else if (ch == LY_UNDERLINE_END_CHAR) {
	    line->data[line->size++] = LY_UNDERLINE_END_CHAR;
	    line->data[line->size] = '\0';
	    underline_on = OFF;
	    if (!(dump_output_immediately && use_underscore))
d3913 3
a3915 15
	    return;
	} else if (ch == LY_BOLD_START_CHAR) {
	    line->data[line->size++] = LY_BOLD_START_CHAR;
	    line->data[line->size] = '\0';
	    bold_on = ON;
	    ctrl_chars_on_this_line++;
	    return;
	} else if (ch == LY_BOLD_END_CHAR) {
	    line->data[line->size++] = LY_BOLD_END_CHAR;
	    line->data[line->size] = '\0';
	    bold_on = OFF;
	    ctrl_chars_on_this_line++;
	    return;
	} else if (ch == LY_SOFT_HYPHEN) {
	    int i;
d3917 8
a3924 8
	    /*
	     *  Ignore the soft hyphen if it is the first character
	     *  on the line, or if it is preceded by a space or
	     *  hyphen. -FM
	     */
	    if (line->size < 1 || text->permissible_split >= line->size) {
		return;
	    }
d3926 11
a3936 7
	    for (i = (text->permissible_split + 1); line->data[i]; i++) {
		if (!IsSpecialAttrChar(UCH(line->data[i])) &&
		    !isspace(UCH(line->data[i])) &&
		    UCH(line->data[i]) != '-' &&
		    UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
		    UCH(line->data[i]) != HT_EN_SPACE) {
		    break;
a3938 4
	    if (line->data[i] == '\0') {
		return;
	    }
	}
d3940 2
a3941 2
	} /* if (with_backspaces && HTCJK==HTNOCJK && !text->T.output_utf8) */
	 else {
d3943 1
a3943 1
	 }
d3957 3
a3959 3
	 *  Some extra checks for UTF-8 output here to make sure
	 *  memory is not overrun.  For a non-first char, append
	 *  to the line here and return. - kw
d3962 2
a3963 2
	    if ((line->size > (MAX_LINE-1))
		|| (indent + (int)(line->offset + line->size)
d3967 3
a3969 3
		       (int)(line->data[line->size-1] ==
				LY_SOFT_HYPHEN ?
					     1 : 0)) >= (LYcols_cu(text)-1))
d3974 1
a3974 1
			   IS_UTF_EXTRA(line->data[text->permissible_split-1]))
d3977 1
a3977 1
			(line->data[text->permissible_split-1] & 0x80))
d3986 1
a3986 1
		    HText_appendCharacter (text, LY_SOFT_NEWLINE);
d3994 1
a3994 1
	    if ((line->size > (MAX_LINE-7))) {
d3998 1
a3998 1
			   (line->data[text->permissible_split-1] & 0x80)
d4009 1
a4009 1
		    HText_appendCharacter (text, LY_SOFT_NEWLINE);
d4015 1
a4015 1
     *  New Line.
d4021 2
a4022 2
	 *  There are some pages written in
	 *  different kanji codes. - TA & kw
d4030 1
a4030 1
     *  Convert EN_SPACE to a space here so that it doesn't get collapsed.
d4035 2
a4036 2
#ifdef SH_EX	/* 1997/11/01 (Sat) 12:08:54 */
    if (ch == 0x0b) {	/* ^K ??? */
d4039 1
a4039 1
    if (ch == 0x1a) {	/* ^Z ??? */
d4045 4
a4048 4
     *  I'm going to cheat here in a BIG way.  Since I know that all
     *  \r's will be trapped by HTML_put_character I'm going to use
     *  \r to mean go down a line but don't start a new paragraph.
     *  i.e., use the second line indenting.
d4054 2
a4055 2
	 *  There are some pages written in
	 *  different kanji codes. - TA & kw
d4063 1
a4063 1
     *  Tabs.
d4066 1
a4066 1
	CONST HTTabStop * Tab;
d4070 1
a4070 1
	if (line->size > 0 && line->data[line->size-1] == LY_SOFT_HYPHEN) {
d4072 2
a4073 2
	     *  A tab shouldn't follow a soft hyphen, so
	     *  if one does, we'll dump the soft hyphen. -FM
d4078 2
a4079 2
	here = ((int)(line->size + line->offset) + indent)
		- ctrl_chars_on_this_line; /* Consider special chars GAB */
d4083 2
a4084 2
		Tab->position <= here;
		Tab++) {
d4092 2
a4093 2
	    if (here >= (int)style->leftIndent) {
		new_line(text); /* wrap */
d4096 1
a4096 1
		target = (int)style->leftIndent;
d4100 2
a4101 2
	    target = (((int)line->offset + (int)line->size + 8) & (-8))
			+ (int)style->leftIndent;
d4113 1
a4113 1
	if (target > (WRAP_COLS(text)-1) - (int)style->rightIndent &&
d4118 1
a4118 1
	     *  Can split here. -FM
d4121 2
a4122 2
	    if (target_cu > (WRAP_COLS(text)-1))
		target -= target_cu - (WRAP_COLS(text)-1);
d4126 1
a4126 1
		for (; here<target; here++) {
d4134 4
a4137 4
    } /* if tab */

check_WrapSource:
    if ( (text->source || dont_wrap_pre) && text == HTMainText) {
d4142 1
a4142 1
	int target = (int)(line->offset + line->size) - ctrl_chars_on_this_line;
d4144 2
a4145 1
	if (target >= (WRAP_COLS(text)-1) - style->rightIndent -
d4148 1
a4148 1
	     target_cu + UTF_XLEN(ch) >= (LYcols_cu(text)-1))) {
d4159 1
a4159 1
	    HText_appendCharacter (text, LY_SOFT_NEWLINE);
d4167 1
a4167 1
	 *  Can split here. -FM
d4171 2
a4172 2
	 *  There are some pages written in
	 *  different kanji codes. - TA
d4179 1
a4179 1
     *  Check if we should ignore characters at the wrap point.
d4182 1
a4182 1
	int nominal = (indent + (int)(line->offset + line->size) - ctrl_chars_on_this_line);
d4187 3
a4189 3
	 && !number_fields_on_left
	 && text->last_anchor != 0
	 && (number = text->last_anchor->number) > 0) {
d4191 10
a4200 10
			? 6
			: (number > 9999
			    ? 5
			    : (number > 999
				? 4
				: (number > 99
				    ? 3
				    : (number > 9
					? 2
					: 1))))) + 2;
d4202 2
a4203 2
	if ((nominal + (int)style->rightIndent) >= limit
	 || (nominal + UTFXTRA_ON_THIS_LINE) >= (LYcols_cu(text) - 1)) {
d4209 1
a4209 1
     *  Check for end of line.
d4211 1
a4211 1
    actual = ((indent + (int)line->offset + (int)line->size) +
d4213 1
a4213 1
	       (int)(line->data[line->size-1] == LY_SOFT_HYPHEN ? 1 : 0)));
d4220 2
a4221 2
	 (int)style->rightIndent - ctrl_chars_on_this_line +
	 (((HTCJK != NOCJK) && text->kanji_buf) ? 1 : 0);
d4234 1
a4234 1
		return;	/* Ignore space causing split */
d4239 5
a4243 5
	     *  For source output we don't want to wrap this stuff
	     *  unless absolutely necessary. - LJM
	     *  !
	     *  If we don't wrap here we might get a segmentation fault.
	     *  but let's see what happens
d4245 2
a4246 2
	    if ((int)line->size >= (int)(MAX_LINE-1)) {
		new_line(text);  /* try not to linewrap */
d4250 2
a4251 2
	     *  For normal stuff like pre let's go ahead and
	     *  wrap so the user can see all of the text.
d4253 3
a4255 3
	    if ( (dump_output_immediately|| (crawl && traversal) )
		 && dont_wrap_pre) {
		if ((int)line->size >= (int)(MAX_LINE-1)) {
d4262 1
a4262 1
    } else if ((int)line->size >= (int)(MAX_LINE-1)) {
d4264 1
a4264 1
	 *  Never overrun memory if DISPLAY_COLS is set to a large value - KW
d4270 1
a4270 1
     *  Insert normal characters.
d4274 1
a4274 1
     && !REALLY_CAN_JUSTIFY(text)
d4276 1
a4276 1
     )
d4295 1
a4295 1
	line = text->last_line; /* May have changed */
d4310 2
a4311 2
				if (text->specified_kcode != NOKANJI)
				    text->kcode = text->specified_kcode;
d4313 9
a4321 9
				else if (text->detected_kcode == DET_EUC)
				    text->kcode = EUC;
				else if (text->detected_kcode == DET_SJIS)
				    text->kcode = SJIS;
#endif
				else if (IS_EUC_X0201KANA(hi, lo) && (text->kcode != EUC))
				    text->kcode = SJIS;
			}
			else
d4323 1
a4323 2
		    }
		    else if (IS_EUC(hi, lo))
d4342 3
a4344 1
			CTRACE((tfp, "This character (%X:%X) doesn't seem Japanese\n", hi, lo));
d4351 1
a4351 2
		    if ((text->kcode == EUC) || (text->kcode == JIS))
		    {
d4368 3
a4370 1
			CTRACE((tfp, "This character (%X:%X) doesn't seem Japanese\n", hi, lo));
d4391 4
a4394 5
	    line->data[line->size++] = (char) (
				       (kanji_code != NOKANJI) ?
							    ch :
					  (font & HT_CAPITALS) ?
						   TOUPPER(ch) : ch);
d4400 1
a4400 1
	if (font & HT_DOUBLE)		/* Do again if doubled */
d4402 1
a4402 1
	    /* NOT a permissible split */
d4407 1
a4407 1
	     *  Can split here. -FM
d4420 3
a4422 3
**  -------------------------------------------
*/
PUBLIC void _internal_HTC ARGS3(HText *,text, int,style, int,dir)
d4424 1
a4424 1
    HTLine* line;
d4432 4
a4435 4
	    line->styles[line->numstyles-1].direction &&
	    line->styles[line->numstyles-1].style == (unsigned) style &&
	    (int) line->styles[line->numstyles-1].horizpos
	    == (int)line->size - ctrl_chars_on_this_line) {
d4437 2
a4438 2
	     *  If this is an OFF change directly preceded by an
	     *	ON for the same style, just remove the previous one. - kw
d4442 1
a4442 1
	    line->styles[line->numstyles].horizpos  = line->size;
d4444 4
a4447 4
	     *  Special chars for bold and underlining usually don't
	     *  occur with color style, but soft hyphen can.
	     *  And in UTF-8 display mode all non-initial bytes are
	     *  counted as ctrl_chars. - kw
d4451 1
a4451 1
	    line->styles[line->numstyles].style     = style;
a4458 2


d4460 3
a4462 5
**	----------------------------------------
*/
PUBLIC void HText_setLastChar ARGS2(
	HText *,	text,
	char,		ch)
d4471 3
a4473 4
**	----------------------------------------
*/
PUBLIC char HText_getLastChar ARGS1(
	HText *,	text)
d4476 1
a4476 1
	return('\0');
d4478 1
a4478 1
    return((char)text->LastChar);
d4482 3
a4484 5
**	--------------------------------------------
*/
PUBLIC void HText_setIgnoreExcess ARGS2(
	HText *,	text,
	BOOL,		ignore)
d4493 2
a4494 2
**		-------------------------------
*/
d4497 8
a4504 10
 *  HText_insertBlanksInStblLines fixes up table lines when simple table
 *  processing is closed, by calling insert_blanks_in_line for lines
 *  that need fixup.  Also recalculates alignment for those lines,
 *  does additional updating of anchor positions, and makes sure the
 *  display of the lines on screen will be updated after partial display
 *  upon return to mainloop. - kw
 */
PRIVATE int HText_insertBlanksInStblLines ARGS2(
    HText *,		me,
    int,		ncols)
d4508 5
a4512 4
    int *	oldpos;
    int *	newpos;
    int		ninserts, lineno;
    int		first_lineno, last_lineno, first_lineno_pass2;
d4514 1
a4514 1
    int		last_nonempty = -1;
d4516 1
a4516 1
    int		added_chars_before = 0;
d4527 1
a4527 1
     *  oldpos, newpos: allocate space for two int arrays.
d4550 1
d4561 2
a4562 2
	     *  Last ditch effort to end the table with a line break,
	     *  if HTML_end_element didn't do it. - kw
d4564 1
a4564 1
	    if (first_line == line) /* obscure: all table on last line... */
d4574 1
d4584 1
a4584 1
		   lineno, width, max_width));
d4588 1
a4588 1
					 &me->last_anchor_before_stbl /*updates++*/,
d4605 2
a4606 2
	     *  Make sure modified lines get fully re-displayed after
	     *  loading with partial display is done.
d4617 1
a4617 2
	}
	{
d4619 1
d4630 1
d4632 1
a4632 1
		       lineno, width, max_width));
d4640 7
a4646 7
     *  Line offsets have been set based on the paragraph style, and
     *  have already been updated for centering or right-alignment
     *  for each line in split_line.  Here we want to undo all that, and
     *  align the table as a whole (i.e. all lines for which
     *  Stbl_getFixupPositions returned >= 0).  All those lines have to
     *  get the same offset, for the simple table formatting mechanism
     *  to make sense, and that may not actually be the case at this point.
d4648 5
a4652 5
     *  What indentation and alignment do we want for the table as
     *  a whole?  Let's take most style properties from me->style.
     *  With some luck, it is the appropriate style for the element
     *  enclosing the TABLE.  But let's take alignment from the attribute
     *  of the TABLE itself instead, if it was specified.
d4654 3
a4656 3
     *  Note that this logic assumes that all lines have been finished
     *  by split_line.  The order of calls made by HTML_end_element for
     *  HTML_TABLE should take care of this.
d4664 3
a4666 3
    spare = (WRAP_COLS(me)-1) -
	(int)style->rightIndent - indent - max_width;
    if (spare < 0 && (int)style->rightIndent + spare >= 0) {
d4668 2
a4669 2
	 *  Not enough room!  But we can fit if we ignore right indentation,
	 *  so let's do that.
d4673 1
a4673 1
	spare += style->rightIndent; /* ignore right indent, but need more */
d4677 1
a4677 1
	 *  Still not enough room.  But we can move to the left.
d4683 2
a4684 2
	 *  Still not enough.  Something went wrong.  Try the best we
	 *  can do.
d4686 3
a4688 2
	CTRACE((tfp, "BUG: insertBlanks: resulting table too wide by %d positions!\n",
	       -spare));
d4692 1
a4692 1
     *  Align left, right or center.
d4695 12
a4706 12
	case HT_CENTER :
	    table_offset = indent + spare/2;
	    break;
	case HT_RIGHT :
	    table_offset = indent + spare;
	    break;
	case HT_LEFT :
	case HT_JUSTIFY :
	default:
	    table_offset = indent;
	    break;
    } /* switch */
d4741 2
a4742 2
**		----------------------------------------
*/
d4746 1
a4746 2
PUBLIC void HText_cancelStbl ARGS1(
	HText *,	me)
d4756 1
d4759 1
d4765 1
a4765 1
    Stbl_free(me->stbl);
d4771 1
a4771 3
PUBLIC void HText_startStblTABLE ARGS2(
	HText *,	me,
	short,		alignment)
d4806 1
a4806 2
PRIVATE void free_enclosed_stbl ARGS1(
	HText *,	me)
d4811 2
a4812 1
	while (NULL != (stbl = (STable_info *)HTList_nextObject(list))) {
d4820 1
d4822 1
a4822 1
#define free_enclosed_stbl(me) /* nothing */
d4828 1
a4828 2
PUBLIC int HText_endStblTABLE ARGS1(
	HText *,	me)
d4850 2
a4851 2
	NumOfLines_partial -= lines_changed;  /* fake */
#endif  /* DISP_PARTIAL */
a4852 1

d4884 1
a4884 3
PUBLIC void HText_startStblTR ARGS2(
	HText *,	me,
	short,		alignment)
d4894 1
a4894 2
PUBLIC void HText_endStblTR ARGS1(
	HText *,	me)
d4903 4
a4906 6
PUBLIC void HText_startStblTD ARGS5(
	HText *,	me,
	int,		colspan,
	int,		rowspan,
	short,		alignment,
	BOOL,		isheader)
d4921 3
a4923 1
			    me->Lines, HText_LastLineOffset(me), HText_LastLineSize(me,FALSE)) < 0)
d4929 1
a4929 2
PUBLIC void HText_endStblTD ARGS1(
	HText *,	me)
d4934 3
a4936 1
			       me->Lines, HText_LastLineOffset(me), HText_LastLineSize(me,FALSE)) < 0)
d4942 3
a4944 5
PUBLIC void HText_startStblCOL ARGS4(
	HText *,	me,
	int,		span,
	short,		alignment,
	BOOL,		isgroup)
d4960 1
a4960 2
PUBLIC void HText_endStblCOLGROUP ARGS1(
	HText *,	me)
d4970 1
a4970 3
PUBLIC void HText_startStblRowGroup ARGS2(
	HText *,	me,
	short,		alignment)
d4979 3
a4981 6
**		---------------
*/
PRIVATE void add_link_number ARGS3(
    HText *,		text,
    TextAnchor *,	a,
    BOOL,		save_position)
d4986 1
a4986 1
     *  If we are doing link_numbering add the link number.
d4990 1
a4990 1
     && (text->source ? !psrcview_no_anchor_numbering : 1 )
d4992 1
a4992 1
     && links_are_numbered()) {
d4995 2
a4996 1
	sprintf(marker,"[%d]", a->number);
d4999 1
a4999 1
	    text->LastChar = ']'; /* if marker not after space caused split */
d5009 2
a5010 4
PUBLIC int HText_beginAnchor ARGS3(
	HText *,		text,
	BOOL,			underline,
	HTChildAnchor *,	anc)
d5012 1
a5012 1
    TextAnchor * a;
d5015 1
d5047 1
a5047 1
    return(a->number);
d5051 2
a5052 4
PRIVATE BOOL HText_endAnchor0 ARGS3(
	HText *,	text,
	int,		number,
	int,		really)
d5057 8
a5064 8
     *  The number argument is set to 0 in HTML.c and
     *  LYCharUtils.c when we want to end the anchor
     *  for the immediately preceding HText_beginAnchor()
     *  call.  If it's greater than 0, we want to handle
     *  a particular anchor.  This allows us to set links
     *  for positions indicated by NAME or ID attributes,
     *  without needing to close any anchor with an HREF
     *  within which that link might be embedded. -FM
d5076 3
a5078 3
	     *  There's no anchor with that number,
	     *  so we'll default to the last anchor,
	     *  and cross our fingers. -FM
d5085 1
a5085 1
			a->number, a->link_type));
d5088 1
a5088 1
	 *  Shouldn't happen, but put test here anyway to be safe. - LE
d5092 1
a5092 1
	   "BUG: HText_endAnchor0: internal error: last anchor was input field!\n"));
d5098 1
a5098 1
	 *  If it goes somewhere...
d5101 6
a5106 7
	BOOL remove_numbers_on_empty = (BOOL) (
	    (links_are_numbered() &&
	     (text->hiddenlinkflag != HIDDENLINKS_MERGE ||
	      (LYNoISMAPifUSEMAP &&
	       !(text->node_anchor && text->node_anchor->bookmark) &&
	       HTAnchor_isISMAPScript(
		   HTAnchor_followLink(a->anchor))))));
d5115 1
a5115 1
	l = text->Lines;		/* lineno of last */
d5123 1
a5123 1
	start = last;			/* Used later */
d5126 3
a5128 3
	 *  Check if the anchor content has only
	 *  white and special characters, starting
	 *  with the content on the last line. -FM
d5131 1
a5131 1
	if (a->extent > (int)last->size) {
d5133 2
a5134 2
	     *  The anchor extends over more than one line,
	     *  so set up to check the entire last line. -FM
d5139 2
a5140 2
	     *  The anchor is restricted to the last line,
	     *  so check from the start of the anchor. -FM
d5145 1
a5145 1
	while (j < (int)last->size) {
d5155 1
a5155 1
	    if (a->extent > (int)last->size) {
d5157 4
a5160 4
		 *  The anchor starts on a preceding line, and
		 *  the last line has only white and special
		 *  characters, so declare the entire extent
		 *  of the last line as blank. -FM
d5165 3
a5167 3
		 *  The anchor starts on the last line, and
		 *  has only white or special characters, so
		 *  declare the anchor's extent as blank. -FM
d5173 6
a5178 6
	 *  While the anchor starts on a line preceding
	 *  the one we just checked, and the one we just
	 *  checked has only white and special characters,
	 *  check whether the anchor's content on the
	 *  immediately preceding line also has only
	 *  white and special characters. -FM
d5191 2
a5192 2
		 *  The anchor starts on a preceding line,
		 *  so check all of this line. -FM
d5198 1
a5198 1
		 *  The anchor starts on this line. -FM
d5202 1
a5202 1
	    while (j < (int)prev->size) {
d5212 2
a5213 2
		if (a->extent > (CurBlankExtent + (int)prev->size) ||
		    (a->extent == CurBlankExtent + (int)prev->size &&
d5219 4
a5222 4
		     *  This line has only white and special
		     *  characters, so treat its entire extent
		     *  as blank, and decrement the pointer for
		     *  the line to be analyzed. -FM
d5229 3
a5231 3
		     *  The anchor starts on this line, and it
		     *  has only white or special characters, so
		     *  declare the anchor's extent as blank. -FM
d5238 1
a5238 1
	if (!really) {			/* Just report whether it is empty */
d5240 1
a5240 1
	    return (BOOL)(i == 0);
d5244 3
a5246 3
	     *  It's an invisible anchor probably from an ALT=""
	     *  or an ignored ISMAP attribute due to a companion
	     *  USEMAP. -FM
d5251 3
a5253 3
		   "HText_endAnchor0: hidden (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
		   a->line_num, a->line_pos, a->extent,
		   BlankExtent));
d5256 2
a5257 2
	     *  If links are numbered, then try to get rid of the
	     *  numbered bracket and adjust the anchor count. -FM
d5272 3
a5274 3
		 *  Set start->data[j] to the close-square-bracket,
		 *  or to the beginning of the line on which the
		 *  anchor start. -FM
d5278 1
a5278 1
		     *  The anchor starts on the last line. -FM
d5283 1
a5283 1
		     *  The anchor starts on a previous line. -FM
d5293 7
a5299 7
		 *  If start->data[j] is a close-square-bracket, verify
		 *  that it's the end of the numbered bracket, and if so,
		 *  strip the numbered bracket.  If start->data[j] is not
		 *  a close-square-bracket, check whether we had a wrap
		 *  and the close-square-bracket is at the end of the
		 *  previous line.  If so, strip the numbered bracket
		 *  from that line. -FM
d5314 2
a5315 2
			 *  The numbered bracket is entirely
			 *  on this line. -FM
d5318 2
a5319 2
			if (start==last && (int)text->permissible_split > j) {
			    if ((int)text->permissible_split - NumSize < j)
d5325 1
a5325 1
			while (k < (int)start->size)
d5336 1
a5336 1
			     start->data[j++] = '\0';
d5354 3
a5356 3
			     *  The numbered bracket started on the
			     *  previous line, and part of it was
			     *  wrapped to this line. -FM
d5360 1
a5360 1
			    while (i < (int)prev->size)
d5367 1
a5367 1
				if ((int)text->permissible_split < k)
d5374 1
a5374 1
			    while (k < (int)start->size)
d5388 2
a5389 2
			     *  Shucks!  We didn't find the
			     *  numbered bracket. -FM
d5395 2
a5396 2
			 *  Shucks!  We didn't find the
			 *  numbered bracket. -FM
d5424 3
a5426 3
			     *  The numbered bracket is all on the
			     *  previous line, and the anchor content
			     *  was wrapped to the last line. -FM
d5430 1
a5430 1
			    while (k < (int)prev->size)
d5438 2
a5439 2
			     *  Shucks!  We didn't find the
			     *  numbered bracket. -FM
d5445 2
a5446 2
			 *  Shucks!  We didn't find the
			 *  numbered bracket. -FM
d5452 2
a5453 2
		     *  Shucks!  We didn't find the
		     *  numbered bracket. -FM
d5462 3
a5464 3
	     *  The anchor's content is not restricted to only
	     *  white and special characters, so we'll show it
	     *  as a link. -FM
d5469 3
a5471 3
		   "HText_endAnchor0: blanks (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
		   a->line_num,a->line_pos,a->extent,
		   BlankExtent));
d5476 5
a5480 5
	     *  The anchor's content is restricted to white
	     *  and special characters, so set its number
	     *  and extent to zero, decrement the visible
	     *  anchor number counter, and add this anchor
	     *  to the hidden links list. -FM
d5490 4
a5493 4
	     *  The anchor's content is not restricted to white
	     *  and special characters, so we'll display the
	     *  content, but shorten its extent by any trailing
	     *  blank lines we've detected. -FM
d5496 1
a5496 1
					BlankExtent : 0);
d5500 4
a5503 4
		   "->[%d](%d,%d,%d,%d)\n",
		   a->number,
		   a->line_num,a->line_pos,a->extent,
		   BlankExtent));
d5506 1
a5506 1
	if (!really)			/* Just report whether it is empty */
d5509 3
a5511 3
	 *  It's a named anchor without an HREF, so it
	 *  should be registered but not shown as a
	 *  link. -FM
d5519 1
a5519 3
PUBLIC void HText_endAnchor ARGS2(
	HText *,	text,
	int,		number)
d5530 1
a5530 3
PUBLIC BOOL HText_isAnchorBlank ARGS2(
	HText *,	text,
	int,		number)
d5536 1
a5536 3
PUBLIC void HText_appendText ARGS2(
	HText *,	text,
	CONST char *,	str)
d5538 1
a5538 1
    CONST char *p;
d5551 1
a5551 3

PRIVATE int remove_special_attr_chars ARGS1(
	char *,		buf)
d5556 1
a5556 1
    for (cp = buf; *cp != '\0' ; cp++) {
d5558 1
a5558 1
	 *  Don't print underline chars.
d5562 1
a5562 1
	   *buf++ = *cp;
a5568 1

d5570 6
a5575 7
**  This function trims blank lines from the end of the document, and
**  then gets the hightext from the text by finding the char position,
**  and brings the anchors in line with the text by adding the text
**  offset to each of the anchors.
*/
PUBLIC void HText_endAppend ARGS1(
	HText *,	text)
d5582 1
a5582 1
    CTRACE((tfp,"Gridtext: Entering HText_endAppend\n"));
d5585 1
a5585 1
     *  Create a  blank line at the bottom.
d5593 3
a5595 3
	 *  If output was stopped because memory was low, and we made
	 *  it to the end of the document, reset those flags and hope
	 *  things are better now. - kw
d5601 2
a5602 2
	 *  Could happen if TABLE end tag was missing.
	 *  Alternatively we could cancel in this case. - kw
d5608 1
a5608 1
     *  Get the first line.
d5613 1
a5613 1
     *  Remove the blank lines at the end of document.
d5619 1
a5619 1
			    text->last_line->data));
d5621 1
a5621 1
	 *  line_ptr points to the first line.
d5629 1
a5629 1
			    text->last_line->data));
d5633 2
a5634 2
     *  Fix up the anchor structure values and
     *  create the hightext strings. -FM
a5638 1

d5640 26
a5665 28
**  This function gets the hightext from the text by finding the char
**  position, and brings the anchors in line with the text by adding the text
**  offset to each of the anchors.
**
**  `Forms input' fields cannot be displayed properly without this function
**  to be invoked (detected in display_partial mode).
**
**  If final is set, this is the final fixup; if not set, we don't have
**  to do everything because there should be another call later.
**
**  BEFORE this function has treated a TextAnchor, its line_pos and
**  extent fields are counting bytes in the HTLine data, including
**  invisible special attribute chars and counting UTF-8 multibyte
**  characters as multiple bytes.
**
**  AFTER the adjustment, the anchor line_pos (and hightext offset if
**  applicable) fields indicate x positions in terms of displayed character
**  cells, and the extent field apparently is unimportant; the anchor text has
**  been copied to the hightext fields (which should have been NULL up to that
**  point), with special attribute chars removed.
**
**  This needs to be done so that display_page finds the anchors in the
**  form it expects when it sets the links[] elements.
*/
PRIVATE void HText_trimHightext ARGS3(
	HText *,	text,
	BOOLEAN,	final,
	int,		stop_before)
d5687 2
a5688 2
	       "Gridtext: Entering HText_trimHightext (partial: 0..%d/%d)\n",
	       stop_before, text->Lines));
d5692 1
a5692 1
     *  Get the first line.
d5698 2
a5699 2
     *  Fix up the anchor structure values and
     *  create the hightext strings. -FM
d5702 2
a5703 2
	anchor_ptr != NULL;
	prev_a = anchor_ptr, anchor_ptr = anchor_ptr->next) {
d5705 2
a5706 1
re_parse:
d5708 1
a5708 1
	 *  Find the right line.
d5711 2
a5712 2
	       line_ptr = line_ptr->next, cur_line++) {
	    ; /* null body */
d5717 3
a5719 3
	     *  If this is not the final call, stop when we have reached
	     *  the last line, or the very end of preceding line.
	     *  The last line is probably still not finished. - kw
d5723 2
a5724 2
	    if ( anchor_ptr->line_num >= text->Lines - 1
		 && anchor_ptr->line_pos >= (int) text->last_line->prev->size )
d5727 2
a5728 2
	     *  Also skip this anchor if it looks like HText_endAnchor
	     *  is not yet done with it. - kw
d5738 3
a5740 3
	 *  If hightext has already been set, then we must have already
	 *  done the trimming & adjusting for this anchor, so avoid
	 *  doing it a second time. - kw
d5753 3
a5755 3
	       "Gridtext: Anchor found on line:%d col:%d [%d] ext:%d\n",
	       cur_line, anchor_ptr->line_pos,
	       anchor_ptr->number, anchor_ptr->extent));
d5759 2
a5760 2
	 *  Strip off any spaces or SpecialAttrChars at the beginning,
	 *  if they exist, but only on HYPERTEXT_ANCHORS.
d5785 1
a5785 1
	if ((unsigned)anchor_ptr->line_pos >= strlen(line_ptr->data)) {
d5788 2
a5789 2
		 anchor_ptr->line_pos != (int)line_ptr->size ||
		 (prev_a && /* How could this happen? */
d5804 2
a5805 2
	 && anchor_ptr->extent > 0
	 && anchor_ptr->line_pos >= 0) {
d5807 1
d5836 1
a5836 1
	     && count_line >= stop_before) {
d5848 1
a5848 1
	     && line_ptr2->size) {
d5870 1
a5870 1
	 && count_line >= stop_before) {
d5885 1
d5897 1
a5897 1
	 *  Add the offset, and set the line number.
d5900 1
a5900 1
	anchor_ptr->line_num  = cur_line;
d5906 2
a5907 2
	       cur_line, anchor_ptr->line_pos,
	       anchor_ptr->number, "in HText_trimHightext"));
a5910 1

d5913 1
a5913 2
PUBLIC HTParentAnchor * HText_nodeAnchor ARGS1(
	HText *,	text)
d5919 2
a5920 2
**				=================
*/
d5923 2
a5924 2
 *  HText_childNextNumber() returns the anchor with index [number],
 *  using a pointer from the previous number (=optimization) or NULL.
d5926 1
a5926 3
PUBLIC HTChildAnchor * HText_childNextNumber ARGS2(
	int,		number,
	void**,		prev)
d5929 1
a5929 1
    TextAnchor * a = *prev;
d5932 1
a5932 1
	return (HTChildAnchor *)0;	/* Fail */
d5939 1
a5939 2
    for( ; a && a->number != number; a = a->next)
	;
d5942 2
a5943 2
	return (HTChildAnchor *)0;	/* Fail */
    *prev = (void*)a;
d5948 6
a5953 7
 *  HText_FormDescNumber() returns a description of the form field
 *  with index N.  The index corresponds to the [number] we print
 *  for the field. -FM & LE
 */
PUBLIC void HText_FormDescNumber ARGS2(
	int,		number,
	char **,	desc)
d5955 1
a5955 1
    TextAnchor * a;
d5961 2
a5962 2
	 *desc = gettext("unknown field or link");
	 return;
d5976 45
a6020 45
	case F_TEXT_TYPE:
	    *desc = gettext("text entry field");
	    return;
	case F_PASSWORD_TYPE:
	    *desc = gettext("password entry field");
	    return;
	case F_CHECKBOX_TYPE:
	    *desc = gettext("checkbox");
	    return;
	case F_RADIO_TYPE:
	    *desc = gettext("radio button");
	    return;
	case F_SUBMIT_TYPE:
	    *desc = gettext("submit button");
	    return;
	case F_RESET_TYPE:
	    *desc = gettext("reset button");
	    return;
	case F_OPTION_LIST_TYPE:
	    *desc = gettext("popup menu");
	    return;
	case F_HIDDEN_TYPE:
	    *desc = gettext("hidden form field");
	    return;
	case F_TEXTAREA_TYPE:
	    *desc = gettext("text entry area");
	    return;
	case F_RANGE_TYPE:
	    *desc = gettext("range entry field");
	    return;
	case F_FILE_TYPE:
	    *desc = gettext("file entry field");
	    return;
	case F_TEXT_SUBMIT_TYPE:
	    *desc = gettext("text-submit field");
	    return;
	case F_IMAGE_SUBMIT_TYPE:
	    *desc = gettext("image-submit button");
	    return;
	case F_KEYGEN_TYPE:
	    *desc = gettext("keygen field");
	    return;
	default:
	    *desc = gettext("unknown form field");
	    return;
d6025 1
a6025 1
 *    is to jump (input was 123+ or 123- or 123+g or 123-g or 123 or 123g)
d6030 3
a6032 4
PUBLIC int HTGetRelLinkNum ARGS3(
	int,	num,
	int,	rel,
	int,	cur)
d6035 1
a6035 1
    int scrtop = HText_getTopOfScreen(); /*XXX +1? */
d6038 2
a6039 1
    int on_screen = ( curline >= scrtop && curline < (scrtop + display_lines) );
d6046 9
a6054 6
	   num, rel, cur, HTMainText));
    CTRACE((tfp,"  scrtop=%d, curline=%d, curanchor=%d, display_lines=%d, %s\n",
	   scrtop, curline, curanchor, display_lines,
	   on_screen ? "on_screen" : "0"));
    if (!HTMainText) return 0;
    if ( rel==0 ) return num;
d6057 8
a6064 5
    if ( on_screen && curanchor ) {
	CTRACE((tfp,"curanchor=%d at line %d on screen\n",curanchor,curline));
	if ( rel == '+' ) return curanchor + num;
	else if ( rel == '-' ) return curanchor - num;
	else return num; /* shouldn't happen */
d6071 5
a6075 3
	CTRACE((tfp,"  a->line_num=%d, a->number=%d\n", a->line_num, a->number));
	if ( a->line_num >= scrtop ) break;
	if ( a->number == 0 ) continue;
d6079 9
a6087 5
    CTRACE((tfp,"  a=%p, l=%p, curanchor=%d\n",a,l,curanchor));
    if ( on_screen ) { /* on screen but not a numbered link */
	for ( ;  a;  a = a->next ) {
	    if ( a->number ) { l = a; curanchor = l->number; }
	    if ( curline == a->line_num && curpos == a->line_pos ) break;
d6090 1
a6090 1
    if ( rel == '+' ) {
d6092 2
a6093 2
    } else if ( rel == '-' ) {
	if ( l )
d6096 1
a6096 1
	    for ( ;  a && a->number==0;  a = a->next ) ;
d6099 2
a6100 2
    }
    else return num; /* shouldn't happen */
d6104 1
a6104 1
 *  HTGetLinkInfo returns some link info based on the number.
d6106 5
a6110 5
 *  If want_go is not 0, caller requests to know a line number for
 *  the link indicated by number.  It will be returned in *go_line, and
 *  *linknum will be set to an index into the links[] array, to use after
 *  the line in *go_line has been made the new top screen line.
 *  *hightext and *lname are unchanged. - KW
d6112 2
a6113 2
 *  If want_go is 0 and the number doesn't represent an input field, info
 *  on the link indicated by number is deposited in *hightext and *lname.
d6115 6
a6120 7
PUBLIC int HTGetLinkInfo ARGS6(
	int,		number,
	int,		want_go,
	int *,		go_line,
	int *,		linknum,
	char **,	hightext,
	char **,	lname)
d6124 1
d6132 1
a6132 1
	return(NO);
d6136 7
a6142 7
	 *  Count anchors, first on current line if there is more
	 *  than one.  We have to count all links, including form
	 *  field anchors and others with a->number == 0, because
	 *  they are or will be included in the links[] array.
	 *  The exceptions are hidden form fields and anchors with
	 *  show_anchor not set, because they won't appear in links[]
	 *  and don't count towards nlinks. - KW
d6151 3
a6153 3
		 *  This anchor is on a different line than the previous one.
		 *  Remember which was the line number of the previous anchor,
		 *  for use in screen positioning later. - KW
d6161 5
a6165 5
		 *  Count all anchors starting with the top line of the
		 *  currently displayed screen.  Just keep on counting
		 *  beyond this screen's bottom line - we'll know whether
		 *  a found anchor is below the current screen by a check
		 *  against nlinks later. - KW
d6173 2
a6174 2
	     *  We found it.  Now process it, depending
	     *  on what kind of info is requested. - KW
d6179 8
a6186 8
		     *  The number requested has been assigned to an anchor
		     *  without any selectable text, so we cannot position
		     *  on it.  The code for suppressing such anchors in
		     *  HText_endAnchor() may not have applied, or it may
		     *  have failed.  Return a failure indication so that
		     *  the user will notice that something is wrong,
		     *  instead of positioning on some other anchor which
		     *  might result in inadvertent activation. - KW
d6188 1
a6188 1
		    return(NO);
d6193 1
a6193 1
		    a->line_num < HTMainText->top_of_screen+(display_lines)) {
d6195 4
a6198 4
		     *  If the requested anchor is within the current screen,
		     *  just set *go_line so that the screen window won't move
		     *  (keep it as it is), and set *linknum to the index of
		     *  this link in the current links[] array. - KW
d6205 3
a6207 3
		     *  if the requested anchor is not within the currently
		     *  displayed screen, set *go_line such that the top line
		     *  will be either
d6213 5
a6217 5
		     *  whichever comes last.  In all cases the line with our
		     *  target will end up being the first line with any links
		     *  on the new screen, so that we can use the
		     *  anchors_this_line counter to point to the anchor in
		     *  the new links[] array.  - kw
d6220 1
d6233 1
a6233 1
		return(LINK_LINE_FOUND);
d6239 1
d6245 2
a6246 2
			    link_dest_intl = HTAnchor_followTypedLink(
				a->anchor, HTInternalLink);
d6249 3
a6251 2
				CTRACE((tfp, "HTGetLinkInfo: unexpected typed link to %s!\n",
					    link_dest_intl->parent->address));
d6257 1
d6260 1
a6260 1
			    return(WWW_INTERN_LINK_TYPE);
d6268 1
a6268 1
		return(WWW_LINK_TYPE);
d6272 1
a6272 1
    return(NO);
d6275 5
a6279 6
PRIVATE BOOLEAN same_anchor_or_field ARGS5(
    int,		numberA,
    FormInfo *,		formA,
    int,		numberB,
    FormInfo *,		formB,
    BOOLEAN,		ta_same)
d6283 1
a6283 1
	    return(YES);
d6285 1
a6285 1
	    return(NO);
d6289 1
a6289 1
	    return(YES);
d6291 1
a6291 1
	    return(NO);
d6293 1
a6293 1
	    return(NO);
d6296 1
a6296 1
	return(NO);
d6301 1
a6301 1
	return(NO);
d6304 1
a6304 1
	return(NO);
d6306 1
a6306 1
	return(YES);
d6324 6
a6329 7
 *  Are there more textarea lines belonging to the same textarea before
 *  (direction < 0) or after (direction > 0) the current one?
 *  On entry, curlink must be the index in links[] of a textarea field. - kw
 */
PUBLIC BOOL HText_TAHasMoreLines ARGS2(
	int,		curlink,
	int,		direction)
d6335 1
a6335 1
	return(NO);
d6362 1
a6362 1
 *  HTGetLinkOrFieldStart - moving to previous or next link or form field.
d6364 1
a6364 1
 *  On input,
d6371 2
a6372 2
 *  The caller wants a information for positioning on the new link to be
 *  deposited in *go_line and (if linknum is not NULL) *linknum.
d6374 15
a6388 16
 *  On failure (no more links in the requested direction) returns NO
 *  and doesn't change *go_line or *linknum.  Otherwise, LINK_DO_ARROWUP
 *  may be returned, and *go_line and *linknum not changed, to indicate that
 *  the caller should use a normal PREV_LINK or PREV_PAGE mechanism.
 *  Otherwise:
 *  The number (0-based counting) for the new top screen line will be returned
 *  in *go_line, and *linknum will be set to an index into the links[] array,
 *  to use after the line in *go_line has been made the new top screen
 *  line. - kw
 */
PUBLIC int HTGetLinkOrFieldStart ARGS5(
	int,		curlink,
	int *,		go_line,
	int *,		linknum,
	int,		direction,
	BOOLEAN,	ta_skip)
d6403 1
a6403 1
	return(NO);
d6412 7
a6418 7
	 *  Count anchors, first on current line if there is more
	 *  than one.  We have to count all links, including form
	 *  field anchors and others with a->number == 0, because
	 *  they are or will be included in the links[] array.
	 *  The exceptions are hidden form fields and anchors with
	 *  show_anchor not set, because they won't appear in links[]
	 *  and don't count towards nlinks. - KW
d6427 3
a6429 3
		 *  This anchor is on a different line than the previous one.
		 *  Remember which was the line number of the previous anchor,
		 *  for use in screen positioning later. - KW
d6449 1
a6449 1
		if (same_anchor_as_link(curlink,a, ta_skip)) {
d6458 1
a6458 1
			   same_anchor_as_link(curlink,previous.anc, ta_skip)) {
d6490 1
d6492 3
a6494 3
	     *  We know where to go; most of the stuff below is just
	     *  tweaks to try to position the new screen in a specific
	     *  way.
d6496 3
a6498 3
	     *  In some cases going to a previous link can be done
	     *  via the normal LYK_PREV_LINK action, which may give
	     *  better positioning of the new screen. - kw
d6501 1
a6501 1
		a->line_num >= HTMainText->top_of_screen-(display_lines)) {
d6511 1
a6511 1
		    return(LINK_DO_ARROWUP);
d6515 7
a6521 7
	     *  The fundamental limitation of the current anchors_this_line
	     *  counter method is that we only can set *linknum to the right
	     *  index into the future links[] array if the line with our link
	     *  ends up being the first line with any links (that count) on
	     *  the new screen.  Subject to that restriction we still have
	     *  some vertical liberty (sometimes), and try to make the best
	     *  of it.  It may be a question of taste though. - kw
d6527 3
a6529 2
		    (HTMainText->top_of_screen - a->line_num + (display_lines) - 1)
		    / (display_lines);
d6536 1
a6536 1
		       HTMainText->top_of_screen+(display_lines)) {
d6538 2
a6539 1
		    (a->line_num - HTMainText->top_of_screen) / (display_lines);
d6560 1
a6560 1
	    return(LINK_LINE_FOUND);
d6563 1
a6563 1
    return(NO);
d6567 16
a6582 18
 *  This function finds the line indicated by line_num in the
 *  HText structure indicated by text, and searches that line
 *  for the first hit with the string indicated by target.  If
 *  there is no hit, FALSE is returned.  If there is a hit, then
 *  a copy of the line starting at that first hit is loaded into
 *  *data with all IsSpecial characters stripped, its offset and
 *  the printable target length (without IsSpecial, or extra CJK
 *  or utf8 characters) are loaded into *offset and *tLen, and
 *  TRUE is returned. -FM
 */
PUBLIC BOOL HText_getFirstTargetInLine ARGS7(
	HText *,	text,
	int,		line_num,
	BOOL,		utf_flag,
	int *,		offset,
	int *,		tLen,
	char **,	data,
	CONST char *,	target)
d6590 2
a6591 2
     *  Make sure we have an HText structure, that line_num is
     *  in its range, and that we have a target string. -FM
d6594 4
a6597 4
	line_num >= 0 &&
	line_num <= text->Lines &&
	non_empty(target))) {
	return(FALSE);
d6601 1
a6601 1
     *  Find the line and set up its data and offset -FM
d6607 1
a6607 1
	    return(FALSE);
d6611 3
a6613 3
	return(FALSE);
    LineData = (char *)line->data;
    LineOffset = (int)line->offset;
d6616 4
a6619 4
     *  If the target is on the line, load the offset of
     *  its first character and the subsequent line data,
     *  strip any special characters from the loaded line
     *  data, and return TRUE. -FM
d6628 4
a6631 4
	 *  We had a hit so load the results,
	 *  remove IsSpecial characters from
	 *  the allocated data string, and
	 *  return TRUE. -FM
d6635 3
a6637 3
	 StrAllocCopy(*data, cp);
	 remove_special_attr_chars(*data);
	 return(TRUE);
d6641 1
a6641 1
     *  The line does not contain the target. -FM
d6643 1
a6643 1
    return(FALSE);
d6647 2
a6648 2
 *  HText_getNumOfLines returns the number of lines in the
 *  current document.
d6650 1
a6650 1
PUBLIC int HText_getNumOfLines NOARGS
d6652 1
a6652 1
    return(HTMainText ? HTMainText->Lines : 0);
d6656 2
a6657 2
 *  HText_getTitle returns the title of the
 *  current document.
d6659 1
a6659 1
PUBLIC CONST char * HText_getTitle NOARGS
d6661 2
a6662 2
    return(HTMainText ?
	  HTAnchor_title(HTMainText->node_anchor) : 0);
d6666 1
a6666 1
PUBLIC CONST char *HText_getStyle NOARGS
d6668 2
a6669 2
   return(HTMainText ?
	  HTAnchor_style(HTMainText->node_anchor) : 0);
d6674 3
a6676 3
 *  HText_getSugFname returns the suggested filename of the current
 *  document (normally derived from a Content-Disposition header with
 *  attachment; filename=name.suffix). -FM
d6678 1
a6678 1
PUBLIC CONST char * HText_getSugFname NOARGS
d6680 2
a6681 2
    return(HTMainText ?
	  HTAnchor_SugFname(HTMainText->node_anchor) : 0);
d6685 6
a6690 6
 *  HTCheckFnameForCompression receives the address of an allocated
 *  string containing a filename, and an anchor pointer, and expands
 *  or truncates the string's suffix if appropriate, based on whether
 *  the anchor indicates that the file is compressed.  We assume
 *  that the file was not uncompressed (as when downloading), and
 *  believe the headers about whether it's compressed or not. -FM
d6692 7
a6698 8
 *  Added third arg - if strip_ok is FALSE, we don't trust the anchor
 *  info enough to remove a compression suffix if the anchor object
 *  does not indicate compression. - kw
 */
PUBLIC void HTCheckFnameForCompression ARGS3(
	char **,		fname,
	HTParentAnchor *,	anchor,
	BOOL,			strip_ok)
d6703 2
a6704 2
    CONST char *ct = NULL;
    CONST char *ce = NULL;
d6709 1
a6709 1
     *  Make sure we have a string and anchor. -FM
d6715 1
a6715 1
     *  Make sure we have a file, not directory, name. -FM
d6721 2
a6722 2
     *  Check the anchor's content_type and content_encoding
     *  elements for a gzip or Unix compressed file. -FM
d6728 2
a6729 2
	 *  No Content-Encoding, so check
	 *  the Content-Type. -FM
d6755 3
a6757 3
     *  If no Content-Encoding has been detected via the anchor
     *  pointer, but strip_ok is not set, there is nothing left
     *  to do. - kw
d6766 1
a6766 1
     && !strcasecomp(dot, ".tgz")) {
d6774 2
a6775 2
     *  Seek the last dot, and check whether
     *  we have a gzip or compress suffix. -FM
d6781 3
a6783 3
		 *  It has a suffix which signifies a gzipped
		 *  or compressed file for us, but the anchor
		 *  claims otherwise, so tweak the suffix. -FM
d6792 3
a6794 3
		 *  It has a tail which signifies a gzipped
		 *  file for us, but the anchor claims otherwise,
		 *  so tweak the suffix. -FM
d6796 1
a6796 1
		if (cp == dot+1)
d6801 3
a6803 3
		 *  The anchor claims it's gzipped, and we
		 *  believe it, so force this tail to the
		 *  conventional suffix. -FM
d6835 1
a6835 1
     *  Add the appropriate suffix. -FM
d6852 2
a6853 2
 *  HText_getLastModified returns the Last-Modified header
 *  if available, for the current document. -FM
d6855 1
a6855 1
PUBLIC CONST char * HText_getLastModified NOARGS
d6857 2
a6858 2
    return(HTMainText ?
	  HTAnchor_last_modified(HTMainText->node_anchor) : 0);
d6862 2
a6863 2
 *  HText_getDate returns the Date header
 *  if available, for the current document. -FM
d6865 1
a6865 1
PUBLIC CONST char * HText_getDate NOARGS
d6867 2
a6868 2
    return(HTMainText ?
	  HTAnchor_date(HTMainText->node_anchor) : 0);
d6872 2
a6873 2
 *  HText_getServer returns the Server header
 *  if available, for the current document. -FM
d6875 1
a6875 1
PUBLIC CONST char * HText_getServer NOARGS
d6877 2
a6878 2
    return(HTMainText ?
	  HTAnchor_server(HTMainText->node_anchor) : 0);
d6881 1
d6883 2
a6884 3
 *  HText_pageDisplay displays a screen of text
 *  starting from the line 'line_num'-1.
 *  This is the primary call for lynx.
d6886 14
a6899 3
PUBLIC void HText_pageDisplay ARGS2(
	int,		line_num,
	char *,		target)
d6908 1
d6910 8
a6917 8
	**  Garbage is reported from forms input fields in incremental mode.
	**  So we start HText_trimHightext() to forget this side effect.
	**  This function was split-out from HText_endAppend().
	**  It may not be the best solution but it works. - LP
	**
	**  (FALSE =  indicate that we are in partial mode)
	**  Multiple calls of HText_trimHightext works without problem now.
	*/
d6924 1
a6924 1
    display_page(HTMainText, line_num-1, target);
d6941 2
a6942 2
 *  Return YES if we have a whereis search target on the displayed
 *  page. - kw
d6944 1
a6944 1
PUBLIC BOOL HText_pageHasPrevTarget NOARGS
d6953 2
a6954 2
 *  HText_LinksInLines returns the number of links in the
 *  'Lines' number of lines beginning with 'line_num'-1. -FM
d6956 2
a6957 4
PUBLIC int HText_LinksInLines ARGS3(
	HText *,	text,
	int,		line_num,
	int,		Lines)
d6981 1
a6981 2
PUBLIC void HText_setStale ARGS1(
	HText *,	text)
d6986 1
a6986 2
PUBLIC void HText_refresh ARGS1(
	HText *,	text)
d6992 1
a6992 2
PUBLIC int HText_sourceAnchors ARGS1(
	HText *,	text)
d6997 1
a6997 2
PUBLIC BOOL HText_canScrollUp ARGS1(
	HText *,	text)
d7002 1
a7002 1
PUBLIC BOOL HText_canScrollDown NOARGS
d7004 1
a7004 1
    HText * text = HTMainText;
d7007 1
a7007 1
     && ((text->top_of_screen + display_lines) < text->Lines+1));
d7012 1
a7012 2
PUBLIC void HText_scrollTop ARGS1(
	HText *,	text)
d7017 1
a7017 2
PUBLIC void HText_scrollDown ARGS1(
	HText *,	text)
d7022 1
a7022 2
PUBLIC void HText_scrollUp ARGS1(
	HText *,	text)
d7027 1
a7027 2
PUBLIC void HText_scrollBottom ARGS1(
	HText *,	text)
a7031 1

d7033 2
a7034 2
**		==================
*/
d7038 1
a7038 2
PUBLIC BOOL HText_select ARGS1(
	HText *,	text)
d7042 2
a7043 2
	 *  Reset flag for whereis search string - cannot be true here
	 *  since text is not our HTMainText. - kw
d7060 2
a7061 2
	if ( text->node_anchor->UCStages->s[UCT_STAGE_HTEXT].LYhndl
	     != current_char_set )
d7080 1
a7080 1
	 *  Make this text the most current in the loaded texts list. -FM
d7084 2
a7085 2
	    /* let lynx do it */
	    /* display_page(text, text->top_of_screen, ""); */
d7091 3
a7093 3
 *  This function returns TRUE if doc's post_data, address
 *  and isHEAD elements are identical to those of a loaded
 *  (memory cached) text. -FM
d7095 1
a7095 2
PUBLIC BOOL HText_POSTReplyLoaded ARGS1(
	DocInfo *,	doc)
d7104 1
a7104 1
     *  Make sure we have the structures. -FM
d7107 1
a7107 1
	return(FALSE);
d7110 1
a7110 1
     *  Make sure doc is for a POST reply. -FM
d7114 1
a7114 1
	return(FALSE);
d7118 2
a7119 2
     *  Loop through the loaded texts looking for a
     *  POST reply match. -FM
d7121 1
a7121 1
    while (NULL != (text = (HText *)HTList_nextObject(cur))) {
d7128 1
a7128 1
	    return(TRUE);
d7132 1
a7132 1
    return(FALSE);
d7135 1
a7135 2
PUBLIC BOOL HTFindPoundSelector ARGS1(
	CONST char *,		selector)
d7137 1
a7137 1
    TextAnchor * a;
d7144 1
a7144 1
		www_search_result = a->line_num+1;
d7147 1
a7147 1
			     a->number, www_search_result));
d7151 1
a7151 1
		return(YES);
d7156 1
a7156 1
    return(NO);
d7160 1
a7160 3
PUBLIC BOOL HText_selectAnchor ARGS2(
	HText *,		text,
	HTChildAnchor *,	anchor)
d7162 1
a7162 1
    TextAnchor * a;
d7171 3
a7173 2
    for (a=text->first_anchor; a; a=a->next) {
	if (a->anchor == anchor) break;
d7180 2
a7181 2
    if (text != HTMainText) {		/* Comment out by ??? */
	HTMainText = text;		/* Put back in by tbl 921208 */
d7183 5
a7187 1
    }
d7189 4
a7192 9
    {
	 int l = a->line_num;
	 CTRACE((tfp, "HText: Selecting anchor [%d] at line %d\n",
		      a->number, l));

	if ( !text->stale &&
	     (l >= text->top_of_screen) &&
	     ( l < text->top_of_screen + display_lines+1))
		 return YES;
d7194 1
a7194 1
	www_search_result = l - (display_lines/3); /* put in global variable */
a7199 1

d7201 5
a7205 5
**		=================
**
**	These are called from the application.  There are many more functions
**	not included here from the original text object.
*/
d7211 1
a7211 3
PUBLIC void HText_applyStyle ARGS2(
	HText *,	me GCC_UNUSED,
	HTStyle *,	style GCC_UNUSED)
a7215 1

d7218 1
a7218 3
PUBLIC void HText_updateStyle ARGS2(
	HText *,	me GCC_UNUSED,
	HTStyle *,	style GCC_UNUSED)
a7222 1

d7225 1
a7225 3
PUBLIC HTStyle * HText_selectionStyle ARGS2(
	HText *,		me GCC_UNUSED,
	HTStyleSheet *,		sheet GCC_UNUSED)
a7229 1

d7232 2
a7233 4
PUBLIC void HText_replaceSel ARGS3(
	HText *,	me GCC_UNUSED,
	CONST char *,	aString GCC_UNUSED,
	HTStyle *,	aStyle GCC_UNUSED)
a7236 1

d7238 3
a7240 5
**	(style recovery only)
*/
PUBLIC void HTextApplyToSimilar ARGS2(
	HText *,	me GCC_UNUSED,
	HTStyle *,	style GCC_UNUSED)
a7244 1

d7246 3
a7248 5
**	(style recovery only)
*/
PUBLIC void HTextSelectUnstyled ARGS2(
	HText *,		me GCC_UNUSED,
	HTStyleSheet *,		sheet GCC_UNUSED)
a7252 1

d7255 1
a7255 2
PUBLIC void HText_unlinkSelection ARGS1(
	HText *,	me GCC_UNUSED)
d7260 1
a7260 2
PUBLIC HTAnchor * HText_referenceSelected ARGS1(
	HText *,	me GCC_UNUSED)
d7262 1
a7262 1
     return 0;
d7265 3
a7268 3
PUBLIC int HText_getTopOfScreen NOARGS
{
    HText * text = HTMainText;
d7272 1
a7272 2
PUBLIC int HText_getLines ARGS1(
	HText *,	text)
d7277 2
a7278 3
PUBLIC HTAnchor * HText_linkSelTo ARGS2(
	HText *,	me GCC_UNUSED,
	HTAnchor *,	anchor GCC_UNUSED)
d7284 1
a7284 1
 *  Utility for freeing the list of previous isindex and whereis queries. -FM
d7286 1
a7286 1
PUBLIC void HTSearchQueries_free NOARGS
d7294 1
a7294 1
    while (NULL != (query = (char *)HTList_nextObject(cur))) {
d7303 2
a7304 2
 *  Utility for listing isindex and whereis queries, making
 *  any repeated queries the most current in the list. -FM
d7306 1
a7306 2
PUBLIC void HTAddSearchQuery ARGS1(
	char *,		query)
d7327 1
a7327 1
    while (NULL != (old = (char *)HTList_nextObject(cur))) {
d7339 1
a7339 2
PUBLIC int do_www_search ARGS1(
	DocInfo *,	doc)
d7348 1
a7348 1
     *  Load the default query buffer
d7350 1
a7350 1
    if ((cp=strchr(doc->address, '?')) != NULL) {
d7352 2
a7353 2
	 *  This is an index from a previous search.
	 *  Use its query as the default.
d7356 2
a7357 2
	LYstrncpy(searchstring, ++cp, sizeof(searchstring)-1);
	for (cp=searchstring; *cp; cp++)
d7363 1
a7363 1
	 *  Make sure it's treated as the most recent query. -FM
d7368 1
a7368 1
	 *  New search; no default.
d7375 1
a7375 1
     *  Prompt for a query string.
d7388 3
a7390 3
get_query:
    if ((ch=LYgetstr(searchstring, VISIBLE,
		     sizeof(searchstring), recall)) < 0 ||
d7395 1
a7395 1
		 *  Use the second to last query in the list. -FM
d7401 1
a7401 1
		 *  Go back to the previous query in the list. -FM
d7407 1
a7407 1
		 *  Roll around to the last query in the list. -FM
d7410 3
a7412 3
	    if ((cp=(char *)HTList_objectAt(search_queries,
					    QueryNum)) != NULL) {
		LYstrncpy(searchstring, cp, sizeof(searchstring)-1);
d7426 1
a7426 1
		 *  Use the first query in the list. -FM
d7432 1
a7432 1
		 *  Advance to the next query in the list. -FM
d7438 1
a7438 1
		 *  Roll around to the first query in the list. -FM
d7441 3
a7443 3
	    if ((cp=(char *)HTList_objectAt(search_queries,
					    QueryNum)) != NULL) {
		LYstrncpy(searchstring, cp, sizeof(searchstring)-1);
d7457 1
a7457 1
	 *  Search cancelled.
d7460 1
a7460 1
	return(NULLFILE);
d7464 1
a7464 1
     *  Strip leaders and trailers. -FM
d7469 1
a7469 1
	return(NULLFILE);
d7474 1
a7474 1
     *  Don't resubmit the same query unintentionally.
d7478 1
a7478 1
	return(NULLFILE);
d7482 2
a7483 2
     *  Add searchstring to the query list,
     *  or make it the most current. -FM
d7488 1
a7488 1
     *  Show the URL with the new query.
d7490 1
a7490 1
    if ((cp=strchr(doc->address, '?')) != NULL)
d7504 1
a7504 1
     *  OK, now we do the search.
d7508 2
a7509 2
	 *	Memory leak fixed.
	 *	05-28-94 Lynx 2-3-1 Garrett Arch Blythe
d7512 1
d7514 1
a7514 1
	    cp_freeme = stub_HTAnchor_address((HTAnchor *)HTMainAnchor);
d7516 1
a7516 1
	    cp_freeme = HTAnchor_address((HTAnchor *)HTMainAnchor);
d7520 1
a7520 1
	CTRACE((tfp,"\ndo_www_search: newfile: %s\n",doc->address));
d7523 1
a7523 1
	 *  Yah, the search succeeded.
d7525 1
a7525 1
	return(NORMAL);
d7529 5
a7533 5
     *  Either the search failed (Yuk), or we got redirection.
     *  If it's redirection, use_this_url_instead is set, and
     *  mainloop() will deal with it such that security features
     *  and restrictions are checked before acting on the URL, or
     *  rejecting it. -FM
d7535 1
a7535 1
    return(NOT_FOUND);
d7538 1
a7538 3
PRIVATE void write_offset ARGS2(
	FILE *,		fp,
	HTLine *,	line)
d7543 2
a7544 2
	for (i = 0; i < (int)line->offset; i++) {
	     fputc(' ', fp);
d7549 1
a7549 2
PRIVATE void write_hyphen ARGS1(
	FILE *,		fp)
d7556 1
a7556 1
	fputc(0xad, fp); /* the iso8859 byte for SHY */
d7563 8
a7570 8
 *  Print the contents of the file in HTMainText to
 *  the file descriptor fp.
 *  If is_reply is TRUE add ">" to the beginning of each
 *  line to specify the file is a reply to message.
 */
PUBLIC void print_wwwfile_to_fd ARGS2(
	FILE *,		fp,
	BOOLEAN,	is_reply)
d7574 2
a7575 1
    HTLine * line;
d7577 1
a7577 1
    HText* text = HTMainText;
d7580 5
a7584 5
    BOOL bs = (BOOL)(!is_reply
		&& text != 0
		&& with_backspaces
		&& HTCJK == NOCJK
		&& !text->T.output_utf8);
d7595 3
a7597 1
		fputc('>',fp);
d7600 1
a7600 1
	    fputc('\n',fp);
d7602 1
a7602 1
	     *  Add news-style quotation if requested. -FM
d7605 3
a7607 1
		fputc('>',fp);
d7614 1
a7614 1
	 *  Add data.
d7621 1
a7621 1
		    fputc('\b',fp);
d7624 2
a7625 2
		    fputc('_',fp);
		    fputc('\b',fp);
d7629 1
a7629 1
		fputc(line->data[i], fp);
d7631 1
a7631 1
		line->data[i + 1] == '\0') { /* last char on line */
d7635 7
a7641 7
		    case LY_UNDERLINE_START_CHAR:
		    case LY_UNDERLINE_END_CHAR:
			fputc('_', fp);
			break;
		    case LY_BOLD_START_CHAR:
		    case LY_BOLD_END_CHAR:
			break;
d7647 15
a7661 15
		    case LY_UNDERLINE_START_CHAR:
			if (!in_b)
			    in_u = TRUE; /*favor bold over underline*/
			break;
		    case LY_UNDERLINE_END_CHAR:
			in_u = FALSE;
			break;
		    case LY_BOLD_START_CHAR:
			if (in_u)
			    in_u = FALSE; /* turn it off*/
			in_b = TRUE;
			break;
		    case LY_BOLD_END_CHAR:
			in_b = FALSE;
			break;
d7675 1
a7675 1
    fputc('\n',fp);
d7680 3
a7682 3
 *  Print the contents of the file in HTMainText to
 *  the file descriptor fp.
 *  First output line is "thelink", ie, the URL for this file.
d7684 2
a7685 4
PUBLIC void print_crawl_to_fd ARGS3(
	FILE *,		fp,
	char *,		thelink,
	char *,		thetitle)
d7689 1
a7689 1
    HTLine * line;
d7702 1
a7702 1
	    fputc('\n',fp);
d7707 1
a7707 1
	 *  Add data.
d7713 1
a7713 1
		line->data[i + 1] == '\0') { /* last char on line */
d7722 1
a7722 1
    fputc('\n',fp);
d7725 1
a7725 1
     *  Add the References list if appropriate
d7729 1
a7729 1
	printlist(fp,FALSE);
a7730 1

d7736 2
a7737 4
PRIVATE void adjust_search_result ARGS3(
    DocInfo *,	doc,
    int,	tentative_result,
    int,	start_line)
d7741 1
a7741 1
	TextAnchor * a;
d7746 3
a7748 1
	    tentative_result <= HTMainText->top_of_screen+display_lines);
d7757 1
d7774 1
a7774 1
	     a && a->line_num <= tentative_result-1; a = a->next) {
d7783 1
a7783 1
		tentative_result <= HTMainText->top_of_screen)) {
d7785 2
a7786 3
	} else
	if (tentative_result - start_line > 0 &&
	    tentative_result - (start_line + 1) <= max_offset) {
d7788 3
a7790 4
	} else
	if (tentative_result > HTMainText->top_of_screen &&
	    tentative_result <= start_line && /* have wrapped */
	    tentative_result <= HTMainText->top_of_screen+goal) {
d7792 1
a7792 2
	} else
	if (tentative_result <= goal)
d7805 1
a7805 3
PRIVATE BOOL anchor_has_target ARGS2(
	TextAnchor *,	a,
	char *,		target)
d7807 1
a7807 1
    OptionType * option;
d7815 1
a7815 1
    for (count = 0; ; ++count) {
d7823 2
a7824 2
     *  Search the relevant form fields, taking the
     *  case_sensitive setting into account. -FM
d7830 2
a7831 2
	     *  Check the actual, hidden password, and then
	     *  the displayed string. -FM
d7846 2
a7847 2
	     *  Search the option strings that are displayed
	     *  when the popup is invoked. -FM
d7858 1
a7858 1
	     *  Search for checked or unchecked parens. -FM
d7870 1
a7870 1
	     *  Search for checked or unchecked square brackets. -FM
d7894 1
a7894 2
PRIVATE TextAnchor *line_num_to_anchor ARGS1(
    int,	line_num)
d7909 1
a7909 3
PRIVATE int line_num_in_text ARGS2(
    HText *,		text,
    HTLine *,		line)
d7924 1
a7924 2
PRIVATE TextAnchor *get_prev_anchor ARGS1(
    TextAnchor *,	a)
d7939 5
a7943 6
PRIVATE int www_search_forward ARGS5(
	int,		start_line,
	DocInfo *,	doc,
	char *,		target,
	HTLine *,	line,
	int,		count)
d7981 5
a7985 6
PRIVATE int www_search_backward ARGS5(
	int,		start_line,
	DocInfo *,	doc,
	char *,		target,
	HTLine *,	line,
	int,		count)
d8023 4
a8026 5
PUBLIC void www_user_search ARGS4(
	int,		start_line,
	DocInfo *,	doc,
	char *,		target,
	int,		direction)
d8028 1
a8028 1
    HTLine * line;
d8036 1
a8036 1
     *  Advance to the start line.
d8040 3
a8042 1
	for (count = 1; count < start_line + direction; line = line->next, count++) {
d8060 2
a8061 3
PUBLIC void user_message ARGS2(
	CONST char *,	message,
	CONST char *,	argument)
d8079 2
a8080 2
 *  HText_getOwner returns the owner of the
 *  current document.
d8082 1
a8082 1
PUBLIC CONST char * HText_getOwner NOARGS
d8084 2
a8085 2
    return(HTMainText ?
	   HTAnchor_owner(HTMainText->node_anchor) : 0);
d8089 2
a8090 2
 *  HText_setMainTextOwner sets the owner for the
 *  current document.
d8092 1
a8092 2
PUBLIC void HText_setMainTextOwner ARGS1(
	CONST char *,	owner)
d8101 3
a8103 3
 *  HText_getRevTitle returns the RevTitle element of the
 *  current document, used as the subject for mailto comments
 *  to the owner.
d8105 1
a8105 1
PUBLIC CONST char * HText_getRevTitle NOARGS
d8107 2
a8108 2
    return(HTMainText ?
	   HTAnchor_RevTitle(HTMainText->node_anchor) : 0);
d8112 2
a8113 2
 *  HText_getContentBase returns the Content-Base header
 *  of the current document.
d8115 1
a8115 1
PUBLIC CONST char * HText_getContentBase NOARGS
d8117 2
a8118 2
    return(HTMainText ?
	   HTAnchor_content_base(HTMainText->node_anchor) : 0);
d8122 2
a8123 2
 *  HText_getContentLocation returns the Content-Location header
 *  of the current document.
d8125 1
a8125 1
PUBLIC CONST char * HText_getContentLocation NOARGS
d8127 2
a8128 2
    return(HTMainText ?
	   HTAnchor_content_location(HTMainText->node_anchor) : 0);
d8132 2
a8133 2
 *  HText_getMessageID returns the Message-ID of the
 *  current document.
d8135 1
a8135 1
PUBLIC CONST char * HText_getMessageID NOARGS
d8137 2
a8138 2
    return(HTMainText ?
	   HTAnchor_messageID(HTMainText->node_anchor) : NULL);
d8141 1
a8141 1
PUBLIC void HTuncache_current_document NOARGS
d8144 1
a8144 1
     *  Should remove current document from memory.
d8147 1
a8147 1
	HTParentAnchor * htmain_anchor = HTMainText->node_anchor;
d8155 7
a8161 7
			    ((htmain_anchor &&
			      htmain_anchor->address) ?
			       htmain_anchor->address : "unknown anchor"),
			    ((htmain_anchor &&
			      htmain_anchor->post_data)
			      ? " with POST data"
			      : "")));
d8172 2
a8173 1
PRIVATE HTProtocol scm = { "source-cache-mem", 0, 0 }; /* dummy - kw */
d8175 1
a8175 1
PUBLIC BOOLEAN HTreparse_document NOARGS
d8181 1
a8181 1
	!HTMainAnchor->source_cache_file) ||
d8183 1
a8183 1
	!HTMainAnchor->source_cache_chunk))
d8187 1
a8187 1
	FILE * fp;
d8192 1
a8192 1
	      HTMainAnchor->source_cache_file));
d8211 1
a8211 1
					     UCLYhndl_for_unspec);
d8241 2
a8242 1
	    CTRACE((tfp, "SourceCache: `%s' has been accessed, partial content.\n",
d8254 1
a8254 1
		    (void *)HTMainAnchor->source_cache_chunk));
d8267 8
a8274 8
	/*
	 * This is only done to make things aligned with SOURCE_CACHE_NONE and
	 * SOURCE_CACHE_FILE when switching to source mode since the original
	 * document's charset will be LYPushAssumed() and then LYPopAssumed().
	 * See LYK_SOURCE in mainloop if you change something here.  No
	 * user-visible benefits, seems just '=' Info Page will show source's
	 * effective charset as "(assumed)".
	 */
d8276 1
a8276 1
					     UCLYhndl_for_unspec);
d8290 2
a8291 2
	HTAnchor_setProtocol(HTMainAnchor, &scm); /* cheating -
				   anything != &HTTP or &HTTPS would do - kw */
d8293 1
a8293 1
			HTMainAnchor->source_cache_chunk, NULL);
d8302 1
a8302 1
PUBLIC BOOLEAN HTcan_reparse_document NOARGS
d8306 1
a8306 1
	!HTMainAnchor->source_cache_file) ||
d8308 1
a8308 1
	!HTMainAnchor->source_cache_chunk))
d8320 1
a8320 1
    return FALSE;  /* if came to here */
d8323 3
a8325 4
PRIVATE void trace_setting_change ARGS3(
	CONST char *,	name,
	int,		prev_setting,
	int,		new_setting)
d8328 3
a8330 2
	CTRACE((tfp, "HTdocument_settings_changed: %s setting has changed (was %d, now %d)\n",
	       name, prev_setting, new_setting));
d8333 1
a8333 1
PUBLIC BOOLEAN HTdocument_settings_changed NOARGS
d8341 1
a8341 1
	!HTMainAnchor->source_cache_file) ||
d8343 1
a8343 1
	!HTMainAnchor->source_cache_chunk))
d8356 2
a8357 2
			    HTMainText->verbose_img,
			    verbose_img);
d8372 5
a8376 2
		   "HTdocument_settings_changed: Screen size has changed (was %dx%d, now %dx%d)\n",
		   HTMainText->disp_cols, HTMainText->disp_lines, DISPLAY_COLS, LYlines));
d8393 1
a8393 1
PUBLIC int HTisDocumentSource NOARGS
d8398 1
a8398 1
PUBLIC char * HTLoadedDocumentURL NOARGS
d8404 1
a8404 1
	return(HTMainText->node_anchor->address);
d8409 1
a8409 1
PUBLIC bstring * HTLoadedDocumentPost_data NOARGS
d8412 3
a8414 3
     && HTMainText->node_anchor
     && HTMainText->node_anchor->post_data)
	return(HTMainText->node_anchor->post_data);
d8419 1
a8419 1
PUBLIC char * HTLoadedDocumentTitle NOARGS
d8425 1
a8425 1
	return(HTMainText->node_anchor->title);
d8430 1
a8430 1
PUBLIC BOOLEAN HTLoadedDocumentIsHEAD NOARGS
d8436 1
a8436 1
	return(HTMainText->node_anchor->isHEAD);
d8441 1
a8441 1
PUBLIC BOOLEAN HTLoadedDocumentIsSafe NOARGS
d8447 1
a8447 1
	return(HTMainText->node_anchor->safe);
d8452 1
a8452 1
PUBLIC char * HTLoadedDocumentCharset NOARGS
d8458 1
a8458 1
	return(HTMainText->node_anchor->charset);
d8463 1
a8463 1
PUBLIC BOOL HTLoadedDocumentEightbit NOARGS
d8471 1
a8471 2
PUBLIC void HText_setNodeAnchorBookmark ARGS1(
	CONST char *,	bookmark)
d8480 1
a8480 1
PUBLIC char * HTLoadedDocumentBookmark NOARGS
d8486 1
a8486 1
	return(HTMainText->node_anchor->bookmark);
d8491 1
a8491 3
PUBLIC int HText_LastLineSize ARGS2(
	HText *,	text,
	BOOL,		IgnoreSpaces)
d8498 1
a8498 3
PUBLIC BOOL HText_LastLineEmpty ARGS2(
	HText *,	text,
	BOOL,		IgnoreSpaces)
d8505 1
a8505 2
PUBLIC int HText_LastLineOffset ARGS1(
	HText *,	text)
d8509 1
a8509 1
    return  text->last_line->offset;
d8512 1
a8512 3
PUBLIC int HText_PreviousLineSize ARGS2(
	HText *,	text,
	BOOL,		IgnoreSpaces)
d8514 1
a8514 1
    HTLine * line;
d8523 1
a8523 3
PUBLIC BOOL HText_PreviousLineEmpty ARGS2(
	HText *,	text,
	BOOL,		IgnoreSpaces)
d8525 1
a8525 1
    HTLine * line;
d8537 1
a8537 4
PRIVATE int HText_TrueLineSize ARGS3(
	HTLine *,	line,
	HText *,	text,
	BOOL,		IgnoreSpaces)
d8571 1
a8571 4
PRIVATE BOOL HText_TrueEmptyLine ARGS3(
	HTLine *,	line,
	HText *,	text,
	BOOL,		IgnoreSpaces)
d8599 1
a8599 2
PUBLIC void HText_NegateLineOne ARGS1(
	HText *,	text)
d8607 1
a8607 2
PUBLIC BOOL HText_inLineOne ARGS1(
	HText *,	text)
d8616 8
a8623 8
 *  This function is for removing the first of two
 *  successive blank lines.  It should be called after
 *  checking the situation with HText_LastLineSize()
 *  and HText_PreviousLineSize().  Any characters in
 *  the removed line (i.e., control characters, or it
 *  wouldn't have tested blank) should have been
 *  reiterated by split_line() in the retained blank
 *  line. -FM
d8625 1
a8625 2
PUBLIC void HText_RemovePreviousLine ARGS1(
	HText *,	text)
d8641 1
a8641 1
 *  NOTE: This function presently is correct only if the
d8647 1
a8647 2
PUBLIC int HText_getCurrentColumn ARGS1(
	HText *,	text)
d8654 3
a8656 3
		  (int)text->style->indent1st : (int)text->style->leftIndent)
		  + HText_LastLineSize(text, IgnoreSpaces)
		  + (int)text->last_line->offset;
d8661 1
a8661 2
PUBLIC int HText_getMaximumColumn ARGS1(
	HText *,	text)
d8663 2
a8664 1
    int column = (DISPLAY_COLS-2);
d8666 2
a8667 2
	column = ((int)text->style->rightIndent ? (DISPLAY_COLS-2) :
		  ((DISPLAY_COLS-1) - (int)text->style->rightIndent));
d8673 1
a8673 1
 *  NOTE: This function uses HText_getCurrentColumn() which
d8677 5
a8681 7
PUBLIC void HText_setTabID ARGS2(
	HText *,	text,
	CONST char *,	name)
{
    HTTabID * Tab = NULL;
    HTList * cur = text->tabs;
    HTList * last = NULL;
d8689 1
a8689 1
	while (NULL != (Tab = (HTTabID *)HTList_nextObject(cur))) {
d8691 1
a8691 1
		return; /* Already set.  Keep the first value. */
d8697 1
a8697 1
    if (!Tab) { /* New name.  Create a new node */
d8708 1
a8708 3
PUBLIC int HText_getTabIDColumn ARGS2(
	HText *,	text,
	CONST char *,	name)
d8711 2
a8712 2
    HTTabID * Tab;
    HTList * cur = text->tabs;
d8715 1
a8715 1
	while (NULL != (Tab = (HTTabID *)HTList_nextObject(cur))) {
d8726 11
a8736 13
 *  This function is for saving the address of a link
 *  which had an attribute in the markup that resolved
 *  to a URL (i.e., not just a NAME or ID attribute),
 *  but was found in HText_endAnchor() to have no visible
 *  content for use as a link name.  It loads the address
 *  into text->hidden_links, whose count can be determined
 *  via HText_HiddenLinks(), below.  The addresses can be
 *  retrieved via HText_HiddenLinkAt(), below, based on
 *  count. -FM
 */
PRIVATE void HText_AddHiddenLink ARGS2(
	HText *,	text,
	TextAnchor *,	textanchor)
d8741 1
a8741 1
     *  Make sure we have an HText structure and anchor. -FM
d8747 2
a8748 2
     *  Create the hidden links list
     *  if it hasn't been already. -FM
d8754 3
a8756 3
     *  Store the address, in reverse list order
     *  so that first in will be first out on
     *  retrievals. -FM
d8767 2
a8768 2
 *  This function returns the number of addresses
 *  that are loaded in text->hidden_links. -FM
d8770 1
a8770 2
PUBLIC int HText_HiddenLinkCount ARGS1(
	HText *,	text)
d8775 1
a8775 1
	count = HTList_count((HTList *)text->hidden_links);
d8777 1
a8777 1
    return(count);
d8781 3
a8783 3
 *  This function returns the address, corresponding to
 *  a hidden link, at the position (zero-based) in the
 *  text->hidden_links list of the number argument. -FM
d8785 1
a8785 3
PUBLIC char * HText_HiddenLinkAt ARGS2(
	HText *,	text,
	int,		number)
d8790 1
a8790 1
	href = (char *)HTList_objectAt((HTList *)text->hidden_links, number);
d8792 1
a8792 1
    return(href);
a8794 1

d8796 3
a8798 3
 *  Form methods
 *    These routines are used to build forms consisting
 *    of input fields
d8800 7
a8806 7
PRIVATE int HTFormMethod;
PRIVATE char * HTFormAction = NULL;
PRIVATE char * HTFormEnctype = NULL;
PRIVATE char * HTFormTitle = NULL;
PRIVATE char * HTFormAcceptCharset = NULL;
PRIVATE BOOLEAN HTFormDisabled = FALSE;
PRIVATE PerFormInfo * HTCurrentForm;
d8808 5
a8812 6
PUBLIC void HText_beginForm ARGS5(
	char *,		action,
	char *,		method,
	char *,		enctype,
	char *,		title,
	CONST char *,	accept_cs)
d8814 2
a8815 1
    PerFormInfo * newform;
d8822 1
a8822 1
     *  Check the ACTION. -FM
d8829 1
a8829 2
    }
    else
d8833 1
a8833 1
     *  Check the METHOD. -FM
d8836 1
a8836 1
	if (!strcasecomp(method,"post") || !strcasecomp(method,"pget"))
d8840 1
a8840 1
     *  Check the ENCTYPE. -FM
d8852 1
a8852 1
     *  Check the TITLE. -FM
d8860 2
a8861 2
     *  Check for an ACCEPT_CHARSET.  If present, store it and
     *  convert to lowercase and collapse spaces. - kw
d8870 7
a8876 7
     *  Create a new "PerFormInfo" structure to hold info on the current
     *  form.  The HTForm* variables could all migrate there, currently
     *  this isn't done (yet?) but it might be less confusing.
     *  Currently the only data saved in this structure that will actually
     *  be used is the accept_cs string.
     *  This will be appended to the forms list kept by the HText object
     *  if and when we reach a HText_endForm. - kw
d8880 1
a8880 1
	outofmem(__FILE__,"HText_beginForm");
d8883 1
a8883 1
    PerFormInfo_free(HTCurrentForm); /* shouldn't happen here - kw */
d8887 7
a8893 7
		HTFormAction, HTFormMethod,
		(HTFormTitle ? " Title:" : ""),
		NonNull(HTFormTitle),
		(HTFormEnctype ? " Enctype:" : ""),
		NonNull(HTFormEnctype),
		(HTFormAcceptCharset ? " Accept-charset:" : ""),
		NonNull(HTFormAcceptCharset)));
d8896 1
a8896 2
PUBLIC void HText_endForm ARGS1(
	HText *,	text)
d8900 2
a8901 2
	 *  Support submission of a single text input field in
	 *  the form via <return> instead of a submit button. -FM
d8903 2
a8904 1
	TextAnchor * a;
d8906 1
a8906 1
	 *  Go through list of anchors and get our input field. -FM
d8913 1
a8913 1
		 *  Got it.  Make it submitting. -FM
d8931 6
a8936 6
     *  Append info on the current form to the HText object's list of
     *  forms.
     *  HText_beginInput call will have set some of the data in the
     *  PerFormInfo structure (if there were any form fields at all),
     *  we also fill in the ACCEPT-CHARSET data now (this could have
     *  been done earlier). - kw
d8962 4
a8965 5
PUBLIC void HText_beginSelect ARGS4(
	char *,		name,
	int,		name_cs,
	BOOLEAN,	multiple,
	char *,		size)
d8968 1
a8968 1
     *  Save the group name.
d8974 1
a8974 1
     *  If multiple then all options are actually checkboxes.
d8979 1
a8979 1
     *  If not multiple then all options are radio buttons.
d8985 1
a8985 1
     *  Length of an option list.
d8989 10
a8998 10
    CTRACE((tfp,"HText_beginSelect: name=%s type=%d size=%s\n",
	       ((HTCurSelectGroup == NULL) ?
				  "<NULL>" : HTCurSelectGroup),
		HTCurSelectGroupType,
	       ((HTCurSelectGroupSize == NULL) ?
				      "<NULL>" : HTCurSelectGroupSize)));
    CTRACE((tfp,"HText_beginSelect: name_cs=%d \"%s\"\n",
		HTCurSelectGroupCharset,
		(HTCurSelectGroupCharset >= 0 ?
		 LYCharSet_UC[HTCurSelectGroupCharset].MIMEname : "<UNKNOWN>")));
d9002 5
a9006 6
**  This function returns the number of the option whose
**  value currently is being accumulated for a select
**  block. - LE && FM
*/
PUBLIC int HText_getOptionNum ARGS1(
	HText *,	text)
d9010 1
a9010 1
    int n = 1; /* start count at 1 */
d9013 1
a9013 1
	return(0);
d9018 1
a9018 1
	return(0);
d9023 1
a9023 1
    return(n);
d9027 7
a9033 8
**  This function checks for a numbered option pattern
**  as the prefix for an option value.  If present, and
**  we are in the correct keypad mode, it returns a
**  pointer to the actual value, following that prefix.
**  Otherwise, it returns the original pointer.
*/
PRIVATE char * HText_skipOptionNumPrefix ARGS1(
	char *,		opname)
d9036 1
a9036 1
     *  Check if we are in the correct keypad mode.
d9040 6
a9045 6
	 *  Skip the option number embedded in the option name so the
	 *  extra chars won't mess up cgi scripts processing the value.
	 *  The format is (nnn)__ where nnn is a number and there is a
	 *  minimum of 5 chars (no underscores if (nnn) exceeds 5 chars).
	 *  See HTML.c.  If the chars don't exactly match this format,
	 *  just use all of opname.  - LE
d9062 1
a9062 1
		if (i < 5 ) {
d9071 1
a9071 1
	return(cp);
d9074 1
a9074 1
    return(opname);
d9078 10
a9087 12
**  We couldn't set the value field for the previous option
**  tag so we have to do it now.  Assume that the last anchor
**  was the previous options tag.
*/
PUBLIC char * HText_setLastOptionValue ARGS7(
	HText *,	text,
	char *,		value,
	char*,		submit_value,
	int,		order,
	BOOLEAN,	checked,
	int,		val_cs,
	int,		submit_val_cs)
d9095 3
a9097 3
      && text
      && text->last_anchor
      && text->last_anchor->link_type == INPUT_ANCHOR)) {
d9099 1
a9099 1
		    (value ? value : "<NULL>")));
d9103 3
a9105 2
    CTRACE((tfp, "Entering HText_setLastOptionValue: value:\"%s\", checked:%s\n",
		value, (checked ? "on" : "off")));
d9108 1
a9108 1
     *  Strip end spaces, newline is also whitespace.
d9111 1
a9111 1
	cp = &value[strlen(value)-1];
d9115 1
a9115 1
	*(cp+1) = '\0';
d9119 1
a9119 1
     *  Find first non space
d9129 2
a9130 2
	 *  Collapse any space between the popup option
	 *  prefix and actual value. -FM
d9150 1
a9150 1
	 *  Put the text on the screen as well.
d9160 1
a9160 1
	 *  Put the text on the screen as well.
d9166 1
a9166 1
	 *  Create a linked list of option values.
d9168 2
a9169 2
	OptionType * op_ptr = text->last_anchor->input_field->select_list;
	OptionType * new_ptr = NULL;
d9173 1
a9173 1
	 *  Deal with newlines or tabs.
d9179 1
a9179 1
	     *  No option items yet.
d9182 3
a9184 2
		CTRACE((tfp, "HText_setLastOptionValue: last input_field not F_OPTION_LIST_TYPE (%d)\n",
			    F_OPTION_LIST_TYPE));
d9186 1
a9186 1
			    text->last_anchor->input_field->type));
d9191 1
a9191 1
				typecalloc(OptionType);
d9201 1
a9201 1
	    number++;  /* add one more */
d9212 2
a9213 2
	 *  Find first non-space again, convert_to_spaces above may have
	 *  changed the string. - kw
d9231 1
a9231 1
		(tmp = typecallocn(unsigned char, strlen(cp)+1)) != 0) {
d9235 1
a9235 1
		    TO_EUC((unsigned char *)cp, tmp);
d9238 1
a9238 1
		    TO_SJIS((unsigned char *)cp, tmp);
d9247 1
a9247 1
		StrAllocCopy(new_ptr->name, (CONST char *)tmp);
d9264 4
a9267 4
	     *  If this is the first option in a popup select list,
	     *  HText_beginInput may have allocated the value and
	     *  cp_submit_value fields, so free them now to avoid
	     *  a memory leak. - kw
d9272 3
a9274 3
	    last_input->value             = last_input->select_list->name;
	    last_input->orig_value        = last_input->select_list->name;
	    last_input->cp_submit_value   = last_input->select_list->cp_submit_value;
d9276 1
a9276 1
	    last_input->value_cs          = new_ptr->value_cs;
d9279 8
a9286 5
	    int curlen = HTCurSelectedOptionValue ? strlen(HTCurSelectedOptionValue) : 0;
		/*
		 *  Make the selected Option Value as long as
		 *  the longest option.
		 */
d9289 1
a9289 1
			    UNDERSCORES(newlen-curlen));
d9296 1
d9298 1
a9298 1
	     *  Set the default option as this one.
d9300 4
a9303 4
	    last_input->num_value	  = number;
	    last_input->value		  = new_ptr->name;
	    last_input->orig_value	  = new_ptr->name;
	    last_input->cp_submit_value	  = new_ptr->cp_submit_value;
d9305 1
a9305 1
	    last_input->value_cs	  = new_ptr->value_cs;
d9309 1
a9309 1
			    UNDERSCORES(newlen-curlen));
d9313 1
a9313 1
	 *  Return the selected Option value to be sent to the screen.
d9317 1
a9317 1
	     *  Change the value.
d9320 1
a9320 1
				strlen(HTCurSelectedOptionValue);
d9329 4
a9332 4
	CTRACE((tfp,"            val_cs=%d \"%s\"",
			val_cs,
			(val_cs >= 0 ?
			 LYCharSet_UC[val_cs].MIMEname : "<UNKNOWN>")));
d9339 1
a9339 1
						  "(ignored)" : "",
d9341 2
a9342 3
	}
	else {
	    CTRACE((tfp,"\n"));
d9345 1
a9345 1
    return(ret_Value);
d9349 3
a9351 3
 *  Assign a form input anchor.
 *  Returns the number of characters to leave
 *  blank so that the input field can fit.
d9353 2
a9354 4
PUBLIC int HText_beginInput ARGS3(
	HText *,		text,
	BOOL,			underline,
	InputFieldData *,	I)
d9356 3
a9358 3
    TextAnchor * a;
    FormInfo * f;
    CONST char *cp_option = NULL;
d9369 1
d9379 5
a9383 5
     *  If this is a radio button, or an OPTION we're converting
     *  to a radio button, and it's the first with this name, make
     *  sure it's checked by default.  Otherwise, if it's checked,
     *  uncheck the default or any preceding radio button with this
     *  name that was checked. -FM
d9385 1
a9385 1
    if (I->type != NULL && !strcmp(I->type,"OPTION") &&
d9395 1
a9395 1
	    TextAnchor * b;
d9397 1
d9413 1
a9413 1
	       I->checked = TRUE;
d9435 1
a9435 1
     *  Set the no_cache flag if the METHOD is POST. -FM
d9441 1
a9441 1
     *  Set up VALUE.
d9448 1
a9448 1
		TO_EUC((unsigned char *)IValue, tmp);
d9451 1
a9451 1
		TO_SJIS((unsigned char *)IValue, tmp);
d9455 1
a9455 1
		    if (IValue[i] != CH_ESC) {  /* S/390 -- gil -- 1621 */
d9460 1
a9460 1
	    StrAllocCopy(IValue, (CONST char *)tmp);
d9466 2
a9467 2
     *  Special case of OPTION.
     *  Is handled above if radio type and LYSelectPopups is FALSE.
d9470 1
a9470 1
    if (I->type != NULL && !strcmp(I->type,"OPTION")) {
d9480 4
a9483 4
	 *  The option's size parameter actually gives the length and not
	 *    the width of the list.  Perform the conversion here
	 *    and get rid of the allocated HTCurSelect....
	 *  0 is ok as it means any length (arbitrary decision).
d9492 1
a9492 1
     *  Set SIZE.
d9497 1
a9497 1
	 *  Leave at zero for option lists.
d9500 1
a9500 1
	    f->size = 20;  /* default */
d9503 1
a9503 1
	f->size = 20;  /* default */
d9507 1
a9507 1
     *  Set MAXLENGTH.
d9512 1
a9512 1
	f->maxlength = 0;  /* 0 means infinite */
d9516 2
a9517 2
     *  Set CHECKED
     *  (num_value is only relevant to check and radio types).
d9525 1
a9525 1
     *  Set TYPE.
d9528 1
a9528 1
	if (!strcasecomp(I->type,"password")) {
d9530 1
a9530 1
	} else if (!strcasecomp(I->type,"checkbox")) {
d9532 1
a9532 1
	} else if (!strcasecomp(I->type,"radio")) {
d9534 1
a9534 1
	} else if (!strcasecomp(I->type,"submit")) {
d9536 1
a9536 1
	} else if (!strcasecomp(I->type,"image")) {
d9538 1
a9538 1
	} else if (!strcasecomp(I->type,"reset")) {
d9540 1
a9540 1
	} else if (!strcasecomp(I->type,"OPTION_LIST")) {
d9542 1
a9542 1
	} else if (!strcasecomp(I->type,"hidden")) {
d9546 1
a9546 1
	} else if (!strcasecomp(I->type,"textarea")) {
d9548 1
a9548 1
	} else if (!strcasecomp(I->type,"range")) {
d9550 1
a9550 1
	} else if (!strcasecomp(I->type,"file")) {
d9553 1
a9553 1
	} else if (!strcasecomp(I->type,"keygen")) {
d9557 1
a9557 1
	     *  Note that TYPE="scribble" defaults to TYPE="text". -FM
d9559 1
a9559 1
	    f->type = F_TEXT_TYPE; /* default */
d9566 1
a9566 1
     *  Set NAME.
d9569 1
a9569 1
	StrAllocCopy(f->name,I->name);
d9576 1
a9576 1
	     *  Set name to empty string.
d9581 1
a9581 1
	     *  Error!  NAME must be present.
d9584 1
a9584 1
		  "GridText: No name present in input field; not displaying\n"));
d9586 1
a9586 1
	    return(0);
d9591 1
a9591 1
     *  Add this anchor to the anchor list
d9600 2
a9601 2
     *  Set VALUE, if it exists.  Otherwise, if it's not
     *  an option list make it a zero-length string. -FM
d9605 2
a9606 2
	 *  OPTION VALUE is not actually the value to be seen but is to
	 *    be sent....
d9611 2
a9612 2
	     *  Fill both with the value.  The f->value may be
	     *  overwritten in HText_setLastOptionValue....
d9623 2
a9624 2
	 *  May be an empty INPUT field.  The text entered will then
	 *  probably be in the current display character set. - kw
d9630 1
a9630 1
     *  Run checks and fill in necessary values.
d9659 1
a9659 1
	f->size=3;
d9667 1
a9667 1
     *  Set original values.
d9669 1
a9669 1
    if (f->type == F_RADIO_TYPE || f->type == F_CHECKBOX_TYPE ) {
d9681 2
a9682 2
     *  Store accept-charset if present, converting to lowercase
     *  and collapsing spaces. - kw
d9691 1
a9691 1
     *  Add numbers to form fields if needed. - LE & FM
d9695 2
a9696 2
	 *  Do not supply number for hidden fields, nor
	 *  for types that are not yet implemented.
d9698 1
a9698 1
	case F_HIDDEN_TYPE:
d9700 1
a9700 1
	case F_FILE_TYPE:
d9702 9
a9710 2
	case F_RANGE_TYPE:
	case F_KEYGEN_TYPE:
d9712 1
a9712 8
	    break;

	default:
	    if (fields_are_numbered())
		a->number = ++(text->last_anchor_number);
	    else
		a->number = 0;
	    break;
d9715 1
a9715 1
	sprintf(marker,"[%d]", a->number);
d9732 1
a9732 1
     *  Restrict SIZE to maximum allowable size.
d9737 27
a9763 27
	case F_SUBMIT_TYPE:
	case F_IMAGE_SUBMIT_TYPE:
	case F_RESET_TYPE:
	case F_TEXT_TYPE:
	case F_TEXTAREA_TYPE:
	    /*
	     *  For submit and reset buttons, and for text entry
	     *  fields and areas, we limit the size element to that
	     *  of one line for the current style because that's
	     *  the most we could highlight on overwrites, and/or
	     *  handle in the line editor.  The actual values for
	     *  text entry lines can be long, and will be scrolled
	     *  horizontally within the editing window. -FM
	     */
	    MaximumSize -= (1 +
			  (int)text->style->leftIndent +
			  (int)text->style->rightIndent);

	    /*  If we are numbering form links, place is taken by [nn]  */
	    if (fields_are_numbered()) {
		if (!number_fields_on_left
		 && f->type == F_TEXT_TYPE
		 && MaximumSize > a->line_pos + 10)
		    MaximumSize -= a->line_pos;
		else
		    MaximumSize -= strlen(marker);
	    }
d9765 6
a9770 6
	    /*
	     *  Save value for submit/reset buttons so they
	     *  will be visible when printing the page. - LE
	     */
	    I->value = f->value;
	    break;
d9772 9
a9780 9
	default:
	    /*
	     *  For all other fields we limit the size element to
	     *  10 less than the screen width, because either they
	     *  are types with small placeholders, and/or are a
	     *  type which is handled via a popup window. -FM
	     */
	    MaximumSize -= 10;
	    break;
d9786 1
a9786 1
     *  Add this anchor to the anchor list
d9795 1
a9795 1
	HTCurrentForm->nfields++; /* will count hidden fields - kw */
d9797 2
a9798 2
	 *  Propagate form field's accept-charset attribute to enclosing
	 *  form if the form itself didn't have an accept-charset - kw
d9811 3
a9813 3
			f->name,
			NonNull(f->value),
			f->size));
d9815 6
a9820 6
			f->name_cs,
			(f->name_cs >= 0 ?
			 LYCharSet_UC[f->name_cs].MIMEname : "<UNKNOWN>"),
			I->name_cs,
			(I->name_cs >= 0 ?
			 LYCharSet_UC[I->name_cs].MIMEname : "<UNKNOWN>")));
d9822 6
a9827 6
			f->value_cs,
			(f->value_cs >= 0 ?
			 LYCharSet_UC[f->value_cs].MIMEname : "<UNKNOWN>"),
			I->value_cs,
			(I->value_cs >= 0 ?
			 LYCharSet_UC[I->value_cs].MIMEname : "<UNKNOWN>")));
d9830 1
a9830 1
     *  Return the SIZE of the input field.
d9832 1
a9832 1
    return(f->size);
d9840 1
a9840 2
PUBLIC void HText_endInput ARGS1(
	HText *,		text)
d9843 4
a9846 4
     && !number_fields_on_left
     && text != NULL
     && text->last_anchor != NULL
     && text->last_anchor->number > 0) {
d9848 1
d9850 1
a9850 1
	sprintf(marker,"[%d]", text->last_anchor->number);
d9856 6
a9861 6
 *  Get a translation (properly: transcoding) quality, factoring in
 *  our ability to translate (an UCTQ_t) and a possible q parameter
 *  on the given charset string, for cs_from -> givenmime.
 *  The parsed input string will be mutilated on exit(!).
 *  Note that results are not normalised to 1.0, but results from
 *  different calls of this function can be compared. - kw
d9863 2
a9864 2
 *  Obsolete, it was planned to use here a quality parametr UCTQ_t,
 *  which is boolean now.
d9866 2
a9867 3
PRIVATE double get_trans_q ARGS2(
    int,		cs_from,
    char *,		givenmime)
d9872 1
d9875 1
a9875 1
    if ((p = strchr(givenmime,';')) != NULL) {
d9888 1
d9893 1
a9893 1
		if (0==strcasecomp(ptok,"q")) {
d9906 4
a9909 4
 *  Find the best charset for submission, if we have an ACCEPT_CHARSET
 *  list.  It factors in how well we can translate (just as guess, and
 *  not a very good one..) and possible  ";q=" factors.  Yes this is
 *  more general than it needs to be here.
d9911 1
a9911 1
 *  Input is cs_in and acceptstring.
d9913 8
a9920 9
 *  Will return charset handle as int.
 *  best_csname will point to a newly allocated MIME string for the
 *  charset corresponding to the return value if return value >= 0.
 *  - kw
 */
PRIVATE int find_best_target_cs ARGS3(
    char **,		best_csname,
    int,		cs_from,
    CONST char *,	acceptstring)
d9926 1
d9931 1
d9933 1
a9933 1
	    /* Get the Charset*/
d9942 1
a9942 1
	if (!strcmp(bestmime, "*")) /* non-standard for HTML attribute.. */
d9957 2
a9958 3
PRIVATE void load_a_file ARGS2(
    char *,	val_used,
    bstring **,	result)
d9978 1
a9978 1
PRIVATE CONST char *guess_content_type ARGS1(CONST char *, filename)
d9981 3
a9983 2
    CONST char *desc;
    HTFormat format = HTFileFormat (filename, &encoding, &desc);
d9985 2
a9986 2
	    ? format->name
	    : "text/plain";
d9990 2
a9991 4

PRIVATE void cannot_transcode ARGS2(
    BOOL *,		had_warning,
    CONST char *,	target_csname)
d9996 1
a9996 1
	    target_csname ? target_csname : "UNKNOWN");
d10004 1
a10004 2
PRIVATE unsigned check_form_specialchars ARGS1(
    char *,	value)
d10010 1
a10010 1
	 non_empty(p) && (result != (SPECIAL_8BIT|SPECIAL_FORM));
d10027 2
a10028 3
PRIVATE void UpdateBoundary ARGS2(
	char **,	Boundary,
	bstring *,	data)
d10038 1
a10038 1
	 && !memcmp(want, text + j, have)) {
d10040 1
d10053 2
a10054 3
PRIVATE char * convert_to_base64 ARGS2(
	char *,		src,
	int,		len)
d10058 2
a10059 2
    static CONST char basis_64[] =
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
d10062 1
a10062 1
    int rlen;   /* length of result string */
d10073 1
a10073 1
    rlen = (len+2) / 3 * 4;	/* encoded bytes */
d10076 1
a10076 1
	rlen += ((rlen-1) / B64_LINE + 1) * eollen;
d10086 2
a10087 2
    for (chunk=0; len > 0; len -= 3, chunk++) {
	if (chunk == (B64_LINE/4)) {
d10090 1
d10097 2
a10098 2
	*r++ = basis_64[c1>>2];
	*r++ = basis_64[((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4)];
d10101 1
a10101 1
	    *r++ = basis_64[((c2 & 0xF) << 2) | ((c3 & 0xC0) >>6)];
d10106 1
a10106 1
	} else { /* len == 1 */
d10115 1
d10125 4
a10128 4
    NO_QUOTE		/* no quoting needed */
    , QUOTE_MULTI	/* multipart */
    , QUOTE_BASE64	/* encode as base64 */
    , QUOTE_SPECIAL	/* escape special characters only */
d10132 6
a10137 6
    int type;		/* the type of this field */
    BOOL first;		/* true if this begins a submission part */
    char *name;		/* the name of this field */
    char *value;	/* the nominal value of this field */
    bstring *data;	/* its data, which is usually the same as the value */
    QuoteData quote;	/* how to quote/translate the data */
d10140 3
a10142 4
PRIVATE char *escape_or_quote_name ARGS3(
	char *,		name,
	QuoteData,	quoting,
	char *,		MultipartContentType)
d10148 2
a10149 2
       StrAllocCopy(escaped1, name);
       break;
d10167 2
a10168 3
PRIVATE char *escape_or_quote_value ARGS2(
	char *,		value,
	QuoteData,	quoting)
d10193 2
a10194 3
PRIVATE int check_if_base64_needed ARGS2(
	int,		submit_method,
	bstring *,	data)
d10207 1
d10227 9
a10235 12
 *  HText_SubmitForm - generate submit data from form fields.
 *  For mailto forms, send the data.
 *  For other methods, set fields in structure pointed to by doc
 *  appropriately for next request.
 *  Returns 1 if *doc set appropriately for next request,
 *	    0 otherwise. - kw
 */
PUBLIC int HText_SubmitForm ARGS4(
	FormInfo *,	submit_item,
	DocInfo *,	doc,
	char *,		link_name,
	char *,		link_value)
d10243 2
a10244 2
    CONST char *out_csname;
    CONST char *target_csname = NULL;
d10276 1
a10276 1
		    form_number));
d10279 1
a10279 1
		    thisform->number, form_number));
d10289 1
a10289 1
     *  If we're mailing, make sure it's a mailto ACTION. -FM
d10298 1
a10298 1
     *  Check the ENCTYPE and set up the appropriate variables. -FM
d10303 2
a10304 2
	 *  Do not hex escape, and use physical newlines
	 *  to separate name=value pairs. -FM
d10311 2
a10312 2
	 *  Use semicolons instead of ampersands as the
	 *  separators for name=value pairs. -FM
d10319 2
a10320 2
	 *  Use the multipart MIME format.  Later we will ensure it does not
	 *  occur within the content.
d10326 6
a10331 6
     *  Determine in what character encoding (aka. charset) we should
     *  submit.  We call this target_cs and the MIME name for it
     *  target_csname.
     *  TODO:   - actually use ACCEPT-CHARSET stuff from FORM
     *  TODO:   - deal with list in ACCEPT-CHARSET, find a "best"
     *		  charset to submit
d10362 1
a10362 1
	    target_cs = UCLYhndl_for_unspec; /* always >= 0 */
d10367 1
a10367 1
	target_cs = UCLYhndl_for_unspec;  /* always >= 0 */
d10381 1
a10381 1
		    !anchor_ptr->input_field->disabled) {
d10384 3
a10386 3
	    char * val = form_ptr->cp_submit_value != NULL
			    ? form_ptr->cp_submit_value
			    : form_ptr->value;
d10398 2
a10399 2
	     && (LYCharSet_UC[target_cs].enc == UCT_ENC_8859
	      || (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
d10406 2
a10407 2
		target_cs = form_ptr->value_cs;	/* try this */
		target_csname = NULL; /* will be set after loop */
d10409 1
a10409 1
		target_cs = -1; /* don't know what to do */
d10418 2
a10419 2
	     && (LYCharSet_UC[target_cs].enc == UCT_ENC_8859
	      || (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
d10426 2
a10427 2
		target_cs = form_ptr->value_cs;	/* try this */
		target_csname = NULL; /* will be set after loop */
d10429 1
a10429 1
		target_cs = -1; /* don't know what to do */
d10463 1
a10463 1
	 *  Method is GET.  Clip out any anchor in the current URL.
d10465 1
a10465 1
	strtok (temp, "#");
d10467 1
a10467 1
	 *  Clip out any old query in the current URL.
d10469 1
a10469 1
	strtok (temp, "?");
d10471 1
a10471 1
	 *  Add the lead question mark for the new URL.
d10473 1
a10473 1
	StrAllocCat(temp,"?");
d10477 3
a10479 3
	 *  We are submitting POST content to a server,
	 *  so load content_type_out.  This will be put in
	 *  the post_content_type element if all goes well. -FM, kw
d10496 2
a10497 2
	 *  If the ENCTYPE is not multipart/form-data, append the
	 *  charset we'll be sending to the post_content_type, IF
d10501 1
a10501 1
	 *	AND it or target_csname is different from iso-8859-1,
d10505 6
a10510 6
	 *	AND target_cs is different from the currently effective
	 *	assumed charset (which should have been set by the user
	 *	so that it reflects what the server is sending, if the
	 *	document is rendered correctly).
	 *  For multipart/form-data the equivalent will be done later,
	 *  separately for each form field. - kw
d10513 2
a10514 2
	 || ((form_is_special & SPECIAL_8BIT) != 0
	  || (form_is_special & SPECIAL_FORM) != 0)) {
d10545 1
a10545 1
		    !anchor_ptr->input_field->disabled) {
d10559 1
a10559 1
		   anchor_count + 1, anchor_limit));
d10563 1
a10563 1
	    switch(form_ptr->type) {
d10571 1
a10571 1
			     val_used, name_used));
d10581 4
a10584 4
				 form_ptr->name ? form_ptr->name : "???",
				 link_name ? link_name : "???",
				 non_empty(form_ptr->name) ?
				 "not current link" : "no field name"));
d10588 2
a10589 2
		    (non_empty(form_ptr->value) &&
		     !strcmp(form_ptr->value, link_value)))) {
d10592 3
a10594 3
				 form_ptr->name ? form_ptr->name : "???",
				 link_name ? link_name : "???",
				 "values are different"));
d10625 8
a10632 8
				 NonNull(form_ptr->name),
				 form_ptr->value_cs,
				 form_ptr->value_cs >= 0
				     ? LYCharSet_UC[form_ptr->value_cs].MIMEname
				     : "???",
				 target_cs,
				 target_csname ? target_csname : "???",
				 success ? "OK" : "FAILED"));
d10636 1
a10636 1
		} else {  /* We can use the value directly. */
d10638 3
a10640 3
				 NonNull(form_ptr->name),
				 target_cs,
				 target_csname ? target_csname : "???"));
d10688 8
a10695 8
				 NonNull(form_ptr->name),
				 form_ptr->name_cs,
				 form_ptr->name_cs >= 0
				     ? LYCharSet_UC[form_ptr->name_cs].MIMEname
				     : "???",
				 target_cs,
				 target_csname ? target_csname : "???",
				 success ? "OK" : "FAILED"));
d10708 1
a10708 1
		} else {  /* We can use the name directly. */
d10710 3
a10712 3
				NonNull(form_ptr->name),
				target_cs,
				target_csname ? target_csname : "???"));
d10723 10
a10732 10
		     *  According to RFC 1867, Non-ASCII field names
		     *  "should be encoded according to the prescriptions
		     *  of RFC 1522 [...].  I don't think RFC 1522 actually
		     *  is meant to apply to parameters like this, and it
		     *  is unknown whether any server would make sense of
		     *  it, so for now just use some quoting/escaping and
		     *  otherwise leave 8-bit values as they are.
		     *  Non-ASCII characters in form field names submitted
		     *  as multipart/form-data can only occur if the form
		     *  provider specifically asked for it anyway. - kw
d10753 1
a10753 1
	    switch(form_ptr->type) {
d10769 4
a10772 4
		    !strcmp(form_ptr->name, link_name)) &&
		   (form_ptr->type == F_TEXT_SUBMIT_TYPE ||
		    (non_empty(form_ptr->value) &&
		     !strcmp(form_ptr->value, link_value)))) {
d10782 1
a10782 1
		 *  Only add if selected.
d10819 2
a10820 2
		 && check_if_base64_needed(submit_item->submit_method,
					   my_data[anchor_count].data)) {
d10823 3
a10825 3
		    escaped2 = convert_to_base64(
				BStrData(my_data[anchor_count].data),
				BStrLen(my_data[anchor_count].data));
d10862 1
a10862 1
	     && my_data[anchor_count].value != 0) {
d10864 2
a10865 1
		CTRACE((tfp, "processing [%d:%d] name=%s(first:%d, value=%s, data=%p)\n",
d10915 6
a10920 6
			"%s%s%s%s%s",
			escaped1,
			(Boundary ? "" : "="),
			(PlainText ? "\n" : ""),
			escaped2,
			((PlainText && *escaped2) ? "\n" : ""));
d10932 6
a10937 6
			"%s%s%s%s%s",
			escaped1,
			(Boundary ? "" : "="),
			(PlainText ? "\n" : ""),
			escaped2,
			((PlainText && *escaped2) ? "\n" : ""));
d10943 7
a10949 7
		 *  If it has a non-zero length name (e.g., because
		 *  its IMAGE_SUBMIT_TYPE is to be handled homologously
		 *  to an image map, or a SUBMIT_TYPE in a set of
		 *  multiple submit buttons, or a single type="text"
		 *  that's been converted to a TEXT_SUBMIT_TYPE),
		 *  include the name=value pair, or fake name.x=0 and
		 *  name.y=0 pairs for IMAGE_SUBMIT_TYPE. -FM
d10975 8
a10982 8
				"%s.x=0%s%s.y=0%s",
				escaped1,
				(PlainText ?
				      "\n" : (SemiColon ?
						    ";" : "&")),
				escaped1,
				((PlainText && *escaped1) ?
						     "\n" : ""));
d10990 6
a10995 6
			    "%s%s%s%s%s",
			    escaped1,
			    (Boundary ? "" : "="),
			    (PlainText ? "\n" : ""),
			    escaped2,
			    ((PlainText && *escaped2) ? "\n" : ""));
d11023 6
a11028 6
			    "%s%s%s%s%s",
			    escaped1,
			    (Boundary ? "" : "="),
			    (PlainText ? "\n" : ""),
			    escaped2,
			    ((PlainText && *escaped2) ? "\n" : ""));
d11035 1
d11062 1
a11062 1
		    CONST char *t = guess_content_type(val_used);
d11065 2
a11066 1
		    HTSprintf(&escaped1, "; name=\"%s\"", my_data[anchor_count].name);
d11071 2
a11072 1
			StrAllocCat(escaped1, "\r\nContent-Transfer-Encoding: base64");
d11120 1
a11120 1
	mailform((submit_item->submit_action+7),
d11122 2
a11123 2
		   ? NonNull(HText_getTitle())
		   : submit_item->submit_title),
d11135 1
a11135 1
	    doc->post_content_type = content_type_out; /* don't free c_t_out */
d11138 2
a11139 2
	} else { /* GET_METHOD */
	    HTSABCat(&my_query, "", 1);	/* append null */
d11162 1
a11162 1
PUBLIC void HText_DisableCurrentForm NOARGS
d11164 1
a11164 1
    TextAnchor * anchor_ptr;
d11171 1
a11171 1
     *  Go through list of anchors and set the disabled flag.
d11186 1
a11186 2
PUBLIC void HText_ResetForm ARGS1(
	FormInfo *,	form)
d11188 1
a11188 1
    TextAnchor * anchor_ptr;
d11195 1
a11195 1
     *  Go through list of anchors and reset values.
d11214 1
a11214 1
				anchor_ptr->input_field->orig_value;
d11217 1
a11217 1
				anchor_ptr->input_field->orig_submit_value;
d11235 1
a11235 2
PUBLIC BOOLEAN HText_HaveUserChangedForms ARGS1(
	HText *,	text)
d11237 1
a11237 1
    TextAnchor * anchor_ptr;
d11243 2
a11244 2
     *  Go through list of anchors to check if any value was changed.
     *  This code based on HText_ResetForm()
d11279 1
a11279 2
PUBLIC void HText_activateRadioButton ARGS1(
	FormInfo *,	form)
d11281 1
a11281 1
    TextAnchor * anchor_ptr;
d11290 1
a11290 1
		anchor_ptr->input_field->type == F_RADIO_TYPE) {
d11294 3
a11296 3
		    /* if it has the same name and its on */
		 if (!strcmp(anchor_ptr->input_field->name, form->name) &&
		     anchor_ptr->input_field->num_value) {
d11299 1
a11299 1
		 }
d11301 1
a11301 1
		    break;
d11305 1
a11305 1
   }
d11307 1
a11307 1
   form->num_value = 1;
d11321 1
a11321 1
PRIVATE void free_all_texts NOARGS
d11329 1
a11329 1
     *  Simply loop through the loaded texts list killing them off.
d11332 1
a11332 1
	if ((cur = (HText *)HTList_removeLastObject(loaded_texts)) != NULL) {
d11338 1
a11338 1
     *  Get rid of the text list.
d11345 1
a11345 1
     *  Insurance for bad HTML.
d11361 7
a11367 8
**  stub_HTAnchor_address is like HTAnchor_address, but it returns the
**  parent address for child links.  This is only useful for traversal's
**  where one does not want to index a text file N times, once for each
**  of N internal links.  Since the parent link has already been taken,
**  it won't go again, hence the (incorrect) links won't cause problems.
*/
PUBLIC char * stub_HTAnchor_address ARGS1(
	HTAnchor *,	me)
d11370 1
d11372 1
a11372 1
	StrAllocCopy (addr, me->parent->address);
d11376 1
a11376 2
PUBLIC void HText_setToolbar ARGS1(
	HText *,	text)
d11383 1
a11383 2
PUBLIC BOOL HText_hasToolbar ARGS1(
	HText *,	text)
d11388 1
a11388 2
PUBLIC void HText_setNoCache ARGS1(
	HText *,	text)
d11395 1
a11395 2
PUBLIC BOOL HText_hasNoCacheSet ARGS1(
	HText *,	text)
d11400 1
a11400 2
PUBLIC BOOL HText_hasUTF8OutputSet ARGS1(
	HText *,	text)
d11406 11
a11416 13
**  Check charset and set the kcode element. -FM
**  Info on the input charset may be passed in in two forms,
**  as a string (if given explicitly) and as a pointer to
**  a LYUCcharset (from chartrans mechanism); either can be NULL.
**  For Japanese the kcode will be reset at a space or explicit
**  line or paragraph break, so what we set here may not last for
**  long.  It's potentially more important not to set HTCJK to
**  NOCJK unless we are sure. - kw
*/
PUBLIC void HText_setKcode ARGS3(
	HText *,	text,
	CONST char *,	charset,
	LYUCcharset *,	p_in)
d11424 2
a11425 2
    **  Check whether we have some kind of info. - kw
    */
d11431 2
a11432 2
    **  If no explicit charset string, use the implied one. - kw
    */
d11437 2
a11438 2
    **  Check whether we have a specified charset. -FM
    */
d11444 5
a11448 5
    **  We've included the charset, and not forced a download offer,
    **  only if the currently selected character set can handle it,
    **  so check the charset value and set the text->kcode element
    **  appropriately. -FM
    */
d11450 4
a11453 4
     *  p_in->MIMEname would be set as display charset.
     *  So text->kcode sholud be set as SJIS or EUC here only if charset
     *  is specified explicitely, otherwise text->kcode would cause
     *  mishandling Japanese strings. -- TH
d11456 2
a11457 3
	!strcmp(charset, "x-sjis") ||		/* 1997/11/28 (Fri) 18:11:33 */
	!strcmp(charset, "x-shift-jis")))
    {
d11459 16
a11474 12
    } else if (explicit && ((p_in && (p_in->enc == UCT_ENC_CJK)) ||
	       !strcmp(charset, "x-euc") ||	/* 1997/11/28 (Fri) 18:11:24 */
	       !strcmp(charset, "euc-jp") ||
	       !strncmp(charset, "x-euc-", 6) ||
	       !strcmp(charset, "euc-kr") ||
	       !strcmp(charset, "iso-2022-kr") ||
	       !strcmp(charset, "big5") ||
	       !strcmp(charset, "cn-big5") ||
	       !strcmp(charset, "euc-cn") ||
	       !strcmp(charset, "gb2312") ||
	       !strncmp(charset, "cn-gb", 5) ||
	       !strcmp(charset, "iso-2022-cn"))) {
d11478 3
a11480 3
	**  If we get to here, it's not CJK, so disable that if
	**  it is enabled.  But only if we are quite sure. -FM & kw
	*/
d11483 5
a11487 1
	    if (!p_in || p_in->enc != UCT_ENC_CJK)
d11489 1
d11492 6
a11497 1
    if (explicit)
d11499 1
a11499 1
    else {
d11512 3
a11514 4
**  Set a permissible split at the current end of the last line. -FM
*/
PUBLIC void HText_setBreakPoint ARGS1(
	HText *,	text)
d11520 1
a11520 1
     *  Can split here. -FM
d11528 14
a11541 15
**  This function determines whether a document which
**  would be sought via the a URL that has a fragment
**  directive appended is otherwise identical to the
**  currently loaded document, and if so, returns
**  FALSE, so that any no_cache directives can be
**  overridden "safely", on the grounds that we are
**  simply acting on the equivalent of a paging
**  command.  Otherwise, it returns TRUE, i.e, that
**  the target document might differ from the current,
**  based on any caching directives or analyses which
**  claimed or suggested this. -FM
*/
PUBLIC BOOL HText_AreDifferent ARGS2(
	HTParentAnchor *,	anchor,
	CONST char *,		full_address)
d11548 2
a11549 2
     *  Do we have a loaded document and both
     *  arguments for this function?
d11555 1
a11555 1
     *  Do we have both URLs?
d11562 1
a11562 1
     *  Do we have a fragment associated with the target?
d11568 3
a11570 3
     *  Always treat client-side image map menus
     *  as potentially stale, so we'll create a
     *  fresh menu from the LynxMaps HTList.
d11576 1
a11576 1
     *  Do the docs differ in the type of request?
d11582 3
a11584 3
     *  Are the actual URLs different, after factoring
     *  out a "LYNXIMGMAP:" leader in the MainText URL
     *  and its fragment, if present?
d11587 2
a11588 2
		? MTanc->address + LEN_LYNXIMGMAP
		: MTanc->address);
d11592 1
a11592 1
	return(TRUE);
d11597 2
a11598 2
     *  If the MainText is not an image map menu,
     *  do the docs have different POST contents?
d11605 1
a11605 1
		     *  Both have contents, and they differ.
d11607 1
a11607 1
		    return(TRUE);
d11611 2
a11612 2
		 *  The loaded document has content, but the
		 *  target doesn't, so they're different.
d11614 1
a11614 1
		return(TRUE);
d11618 2
a11619 2
	     *  The loaded document does not have content, but
	     *  the target does, so they're different.
d11621 1
a11621 1
	    return(TRUE);
d11626 3
a11628 3
     *  We'll assume the target is a position in the currently
     *  displayed document, and thus can ignore any header, META,
     *  or other directives not to use a cached rendition. -FM
d11630 1
a11630 1
    return(FALSE);
d11637 5
a11641 5
 *  Cleanup new lines coming into a TEXTAREA from an external editor, or a
 *  file, such that they are in a suitable format for TEXTAREA rendering,
 *  display, and manipulation.  That means trimming off trailing whitespace
 *  from the line, expanding TABS into SPACES, and substituting a printable
 *  character for control chars, and the like.
d11643 1
a11643 1
 *  --KED  02/24/99
d11645 2
a11646 3
PRIVATE void cleanup_line_for_textarea ARGS2(
	     char *,  line,
	     int,     len)
d11648 1
a11648 1
    char  tbuf[MAX_LINE];
d11653 2
a11654 3
    int   i;
    int   n;

d11657 1
a11657 1
     *  Whack off trailing whitespace from the line.
d11666 1
a11666 1
    if (strlen (line) != 0) {
d11668 1
a11668 1
	 *  Expand any tab's, since they won't render properly in a TEXTAREA.
d11670 3
a11672 3
	 *  [Is that "by spec", or just a "lynxism"?  As may be, it seems that
	 *   such chars may cause other problems, too ... with cursor movement,
	 *   submit'ing, etc.  Probably needs looking into more deeply.]
d11678 5
a11682 5
	    if ((cp = strchr (p, '\t')) != 0) {
		i  = cp - p;
		s  = (strncpy (s, p, i))      + i;
		n  = TABSTOP - (i % TABSTOP);
		s  = (strncpy (s, SPACES, n)) + n;
d11687 1
a11687 1
		strcpy (s, p);
d11693 8
a11700 8
	 *  Replace control chars with something printable.  Note that char
	 *  substitution above 0x7f is dependent on the charset being used,
	 *  and then only applies to the contiguous run of char values that
	 *  are between 0x80, and the 1st real high-order-bit-set character,
	 *  as specified by the charset.  In general (ie, for many character
	 *  sets), that usually means the so-called "C1 control chars" that
	 *  range from 0x80 thru 0x9f.  For EBCDIC machines, we only trim the
	 *  (control) chars below a space (x'40').
d11702 2
a11703 2
	 *  The assumption in all this is that the charset used in the editor,
	 *  is compatible with the charset specified in lynx.
d11705 8
a11712 8
	 *  [At some point in time, when/if lynx ever supports multibyte chars
	 *   internally (eg, UCS-2, UCS-4, UTF-16, etc), this kind of thing may
	 *   well cause problems.  But then, supporting such char sets will
	 *   require massive changes in (most) all parts of the lynx code, so
	 *   until then, we do the rational thing with char values that would
	 *   otherwise foul the display, if left alone.  If you're implementing
	 *   multibyte character set support, consider yourself to have been
	 *   warned.]
d11716 2
a11717 2
	    *p = ((UCH(*s)  < UCH(' '))       ||
		  (UCH(*s) == UCH('\177'))    ||
d11721 1
a11721 1
		 ? (char) SPLAT : *s;
a11731 1

d11733 10
a11742 10
 *  Re-render the text of a tagged ("[123]") HTLine (arg1), with the tag
 *  number incremented by some value (arg5).  The re-rendered string may
 *  be allowed to expand in the event of a tag width change (eg, 99 -> 100)
 *  as controlled by arg6 (CHOP or NOCHOP).  Arg4 is either (the address
 *  of) a value which must match, in order for the tag to be incremented,
 *  or (the address of) a 0-value, which will match any value, and cause
 *  any valid tag to be incremented.  Arg2 is a pointer to the first/only
 *  anchor that exists on the line; we may need to adjust their position(s)
 *  on the line.  Arg3 when non-0 indicates the number of new digits that
 *  were added to the 2nd line in a line crossing pair.
d11744 2
a11745 2
 *  All tags fields in a line which individually match an expected new value,
 *  are incremented.  Line crossing [tags] are handled (PITA).
d11747 1
a11747 1
 *  Untagged or improperly tagged lines are not altered.
d11749 2
a11750 2
 *  Returns the number of chars added to the original string's length, if
 *  any.
d11752 1
a11752 1
 *  --KED  02/03/99
d11754 4
a11757 7
PRIVATE int increment_tagged_htline ARGS6(
	HTLine *,	ht,
	TextAnchor *,   a,
	int *,		lx_val,
	int *,		old_val,
	int,		incr,
	int,		mode)
d11759 2
a11760 2
    char    buf[MAX_LINE];
    char  lxbuf[MAX_LINE * 2];
d11762 1
a11762 1
    TextAnchor *st_anchor  = a;
d11765 3
a11767 3
    char *p   = ht->data;
    char *s   = buf;
    char *lx  = lxbuf;
d11770 2
a11771 2
    BOOLEAN   plx    = FALSE;
    BOOLEAN   valid;
d11773 16
a11788 17
    int   val;
    int   n;
    int   new_n;
    int   pre_n;
    int   post_n;
    int   fixup = 0;


    /*
     *  Cleanup for the 2nd half of a line crosser, whose number of tag
     *  digits grew by some number of places (usually 1 when it does
     *  happen, though it *could* be more).  The tag chars were already
     *  rendered into the 2nd line of the pair, but the positioning and
     *  other effects haven't been rippled through any other anchors on
     *  the (2nd) line.  So we do that here, as a special case, since
     *  the part of the tag that's in the 2nd line of the pair, will not
     *  be found by the tag string parsing code.  Double PITA.
d11790 1
a11790 1
     *  [see comments below on line crosser caused problems]
d11798 1
a11798 1
	fixup  = *lx_val;
d11800 2
a11801 1
	if (st_anchor) st_anchor = st_anchor->next;
d11805 1
a11805 1
     *  Walk thru the line looking for tags (ie, "[nnn]" strings).
d11807 2
a11808 2
    while  (*p != '\0') {
	if (*p != '[')	{
d11813 4
a11816 4
	    *s++  = *p++;
	    t     = p;
	    n     = 0;
	    valid = TRUE;   /* p = t = byte after '[' */
d11819 1
a11819 1
	     *  Make sure there are only digits between "[" and "]".
d11821 2
a11822 2
	    while  (*t != ']')  {
		if (*t == '\0') { /* uhoh - we have a potential line crosser */
d11824 1
a11824 1
		    plx   = TRUE;
d11837 3
a11839 3
	     *  If the format is OK, we check to see if the value is what
	     *  we expect.  If not, we have a random [nn] string in the text,
	     *  and leave it alone.
d11841 12
a11852 12
	     *  [It is *possible* to have a false match here, *if* there are
	     *   two identical [nn] strings (including the numeric value of
	     *   nn), one of which is the [tag], and the other being part of
	     *   a document.  In such a case, the 1st [nn] string will get
	     *   incremented; the 2nd one won't, which makes it a 50-50 chance
	     *   of being correct, if and when such an unlikely juxtaposition
	     *   of text ever occurs.  Further validation tests of the [nnn]
	     *   string are probably not possible, since little of the actual
	     *   anchor-associated-text is retained in the TextAnchor or the
	     *   FormInfo structs.  Fortunately, I think the current method is
	     *   more than adequate to weed out 99.999% of any possible false
	     *   matches, just as it stands.  Caveat emptor.]
d11855 2
a11856 2
		val = atoi (p);
		if ((val == *old_val) || (*old_val == 0)) { /* 0 matches all */
d11860 2
a11861 2
		    sprintf (s, "%d", val);
		    new_n = strlen (s);
d11866 4
a11869 4
		     *  If the number of digits in an existing [tag] increased
		     *  (eg, [99] --> [100], etc), we need to "adjust" its
		     *  horizontal position, and that of all subsequent tags
		     *  that may be on the same line.  PITA.
d11871 11
a11881 11
		     *  [This seems to work as long as a tag isn't a line
		     *   crosser; when it is, the position of anchors on either
		     *   side of the split tag, seem to "float" and try to be
		     *   as "centered" as possible.  Which means that simply
		     *   incrementing the line_pos by the fixed value of the
		     *   number of digits that got added to some tag in either
		     *   line doesn't work quite right, and the text for (say)
		     *   a button may get stomped on by another copy of itself,
		     *   but offset by a few chars, when it is selected (eg,
		     *   "Box Office" may end up looking like "BoBox Office" or
		     *   "Box Officece", etc.
d11883 2
a11884 2
		     *   Dunno how to fix that behavior ATT, but at least the
		     *   tag numbers themselves are correct.  -KED  /\oo/\ ]
d11888 1
a11888 1
			while ((nxt_anchor)			      &&
d11893 2
a11894 1
			if (st_anchor) st_anchor = st_anchor->next;
d11900 7
a11906 7
	     *  Unfortunately, valid [tag] strings *can* be split across two
	     *  lines.  Perhaps it would be best to just prevent that from
	     *  happening, but a look into that code, makes me wonder.  Anyway,
	     *  we can handle such tags without *too* much trouble in here [I
	     *  think], though since such animals are rather rare, it makes it
	     *  a bit difficult to test thoroughly (ie, Beyond here, there be
	     *  Dragons).
d11908 1
a11908 1
	     *  We use lxbuf[] to deal with the two lines involved.
d11910 1
a11910 1
	    pre_n = strlen (p);	/* count of 1st part chars in this line */
d11913 3
a11915 3
	     && (pre_n + post_n + 2 < (int) sizeof(lxbuf))) {
		strcpy (lx, p);      /* <- 1st part of a possible lx'ing tag */
		strcat (lx, ht->next->data);   /* tack on NEXT line	     */
d11917 2
a11918 2
		t     = lx;
		n     = 0;
d11922 1
a11922 1
		 *  Go hunting again for just digits, followed by tag end ']'.
d11935 4
a11938 4
		 *  It *looks* like a line crosser; now we value test it to
		 *  find out for sure [but see the "false match" warning,
		 *  above], and if it matches, increment it into the buffer,
		 *  along with the 2nd line's text.
d11941 3
a11943 3
		 && (n > 0)
		 && (n + post_n + 2) < MAX_LINE) {
		    val = atoi (lx);
d11948 3
a11950 3
			sprintf (lx, "%d", val);
			new_n = strlen (lx);
			strcat (lx, strchr (ht->next->data, ']'));
d11953 4
a11956 4
			 *  We keep the the same number of chars from the
			 *  adjusted tag number in the current line; any
			 *  extra chars due to a digits increase, will be
			 *  stuffed into the next line.
d11958 2
a11959 2
			 *  Keep track of any digits added, for the next
			 *  pass through.
d11961 1
a11961 1
			s   = strncpy (s, lx, pre_n) + pre_n;
d11963 1
a11963 1
			strcpy (ht->next->data, lx);
d11968 1
a11968 1
		break;	/* had an lx'er, so we're done with this line */
d11975 1
a11975 1
    n = strlen (ht->data);
d11980 2
a11981 1
	HTLine* temp;
d11990 1
a11990 1
	memcpy(temp->styles, ht->styles, sizeof(HTStyleChange)*ht->numstyles);
d11996 1
a11996 1
    strcpy (ht->data, buf);
d11998 1
a11998 1
    return (strlen (buf) - n + fixup);
a12000 1

d12002 3
a12004 3
 *  Creates a new anchor and associated struct's appropriate for a form
 *  TEXTAREA, and links them into the lists following the current anchor
 *  position (as specified by arg1).
d12006 2
a12007 2
 *  Exits with arg1 now pointing at the new TextAnchor, and arg2 pointing
 *  at the new, associated HTLine.
d12009 1
a12009 1
 *  --KED  02/13/99
d12011 1
a12011 3
PRIVATE void insert_new_textarea_anchor ARGS2(
	TextAnchor **,   curr_anchor,
	HTLine **,       exit_htline)
d12014 1
a12014 1
    HTLine     *htline;
d12017 2
a12018 2
    FormInfo   *f = 0;
    HTLine     *l = 0;
d12020 2
a12021 2
    int curr_tag  = 0;   /* 0 ==> match any [tag] number */
    int lx	  = 0;	 /* 0 ==> no line crossing [tag]; it's a new line */
a12023 1

d12025 2
a12026 2
     *  Find line in the text that matches ending anchorline of
     *  the TEXTAREA.
d12028 5
a12032 5
     *  [Yes, Virginia ... we *do* have to go thru this for each
     *   anchor being added, since there is NOT a 1-to-1 mapping
     *   between anchors and htlines.  I suppose we could create
     *   YAS (Yet Another Struct), but there are too many structs{}
     *   floating around in here, as it is.  IMNSHO.]
d12035 1
a12035 1
	 anchor->line_num != i;                i++) {
d12042 2
a12043 2
     *  Clone and initialize the struct's needed to add a new TEXTAREA
     *  anchor.
d12047 1
d12054 5
a12058 5
    a->next	       = anchor->next;
    a->number	       = anchor->number;
    a->line_pos	       = anchor->line_pos;
    a->extent	       = anchor->extent;
    a->line_num	       = anchor->line_num + 1;
d12060 6
a12065 6
    a->link_type       = anchor->link_type;
    a->input_field     = f;
    a->show_anchor     = anchor->show_anchor;
    a->inUnderline     = anchor->inUnderline;
    a->expansion_anch  = TRUE;
    a->anchor	       = NULL;
d12069 9
a12077 9
    StrAllocCopy (f->name, anchor->input_field->name);
    f->number	       = anchor->input_field->number;
    f->type	       = anchor->input_field->type;
    StrAllocCopy (f->orig_value, "");
    f->size	       = anchor->input_field->size;
    f->maxlength       = anchor->input_field->maxlength;
    f->no_cache        = anchor->input_field->no_cache;
    f->disabled        = anchor->input_field->disabled;
    f->value_cs        = current_char_set; /* use current setting - kw */
d12080 4
a12083 4
    l->next	       = htline->next;
    l->prev	       = htline;
    l->offset	       = htline->offset;
    l->size	       = htline->size;
d12086 2
a12087 2
    l->numstyles       = htline->numstyles;
    /*we fork the pointers!*/
d12090 1
a12090 1
    strcpy (l->data,     htline->data);
d12093 1
a12093 1
     *  Link in the new HTLine.
d12096 1
a12096 1
    htline->next       = l;
d12100 1
a12100 1
	increment_tagged_htline (l, a, &lx, &curr_tag, 1, CHOP);
d12104 2
a12105 2
     *  If we're at the tail end of the TextAnchor or HTLine list(s),
     *  the new node becomes the last node.
d12113 2
a12114 2
     *  Link in the new TextAnchor and point the entry anchor arg at it;
     *  point the entry HTLine arg at it, too.
d12117 1
a12117 1
   *curr_anchor  = a;
d12119 1
a12119 1
   *exit_htline        = l->next;
a12123 1

d12125 2
a12126 2
 *  If new anchors were added to expand a TEXTAREA, we need to ripple the
 *  new line numbers [and char counts ?] thru the subsequent anchors.
d12128 2
a12129 2
 *  If form lines are getting [nnn] tagged, we need to update the displayed
 *  tag values to match (which means rerendering them ... sigh).
d12131 1
a12131 1
 *  Finally, we need to update various HTMainText and other counts, etc.
d12133 2
a12134 2
 *  [dunno if the char counts really *need* to be done, or if we're using
 *   the exactly proper values/algorithms ... seems to be OK though ...]
d12136 1
a12136 1
 *  --KED  02/13/99
d12138 4
a12141 5
PRIVATE void update_subsequent_anchors ARGS4(
	int,		 newlines,
	TextAnchor *,	 start_anchor,
	HTLine *,	 start_htline,
	int,		 start_tag)
d12144 1
a12144 7
    HTLine     *htline = start_htline;

    int		line_adj = 0;
    int		tag_adj	 = 0;
    int		lx	 = 0;
    int	     hang	 = 0;  /* for HANG detection of a nasty intermittent */
    int      hang_detect = 100000;  /* ditto */
d12146 5
d12155 1
a12155 1
     *  Update numeric fields of the rest of the anchors.
d12157 4
a12160 4
     *  [We bypass bumping ->number if it has a value of 0, which takes care
     *   of the ->input_field->type == F_HIDDEN_TYPE (as well as any other
     *   "hidden" anchors, if such things exist).  Seems like the "right
     *   thing" to do.  I think.]
d12162 1
a12162 1
    anchor = start_anchor->next;   /* begin updating with the NEXT anchor */
d12167 1
a12167 1
	anchor->line_num  += newlines;
d12172 1
a12172 1
     *  Update/rerender anchor [tags], if they are being numbered.
d12174 6
a12179 6
     *  [If a number tag (eg, "[177]") is itself broken across a line
     *   boundary, this fixup only partially works.  While the tag
     *   numbering is done properly across the pair of lines, the
     *   horizontal positioning on *either* side of the split, can get
     *   out of sync by a char or two when it gets selected.  See the
     *   [comments] in  increment_tagged_htline()  for some more detail.
d12181 3
a12183 3
     *   I suppose THE fix is to prevent such tag-breaking in the first
     *   place (dunno where yet, though).  Ah well ... at least the tag
     *   numbers themselves are correct from top to bottom now.
d12185 7
a12191 7
     *   All that said, about the only time this will be a problem in
     *   *practice*, is when a page has near 1000 links or more (possibly
     *   after a TEXTAREA expansion), and has line crossing tag(s), and
     *   the tag numbers in a line crosser go from initially all 3 digit
     *   numbers, to some mix of 3 and 4 digits (or all 4 digits) as a
     *   result of the expansion process.  Oh, you also need a "clump" of
     *   anchors all on the same lines.
d12193 2
a12194 2
     *   Yes, it *can* happen, but in real life, it probably won't be
     *   seen very much ...]
d12196 4
a12199 4
     *  [This may also be an artifact of bumping into the right hand
     *   screen edge (or RHS margin), since we don't even *think* about
     *   relocating an anchor to the following line, when [tag] digits
     *   expansion pushes things too far in that direction.]
d12235 3
a12237 3
		line_adj = increment_tagged_htline (htline,  anchor,  &lx,
						    &start_tag, newlines,
						    NOCHOP);
d12239 1
a12239 1
		tag_adj      += line_adj;
d12243 1
a12243 1
		break;	/* out of anchors ... we're done */
d12250 1
a12250 1
finish:
d12252 1
a12252 1
     *  Fixup various global variables.
d12254 2
a12255 2
    nlinks                         += newlines;
    HTMainText->Lines              += newlines;
d12264 1
a12264 1
hang_detected:  /* ugliness has happened; inform user and do the best we can */
a12269 1

d12271 4
a12274 4
 *  Transfer the initial contents of a TEXTAREA to a temp file, invoke the
 *  user's editor on that file, then transfer the contents of the resultant
 *  edited file back into the TEXTAREA (expanding the size of the area, if
 *  required).
d12276 3
a12278 3
 *  Returns the number of lines that the cursor should be moved so that it
 *  will end up on the 1st blank line of whatever number of trailing blank
 *  lines there are in the TEXTAREA (there will *always* be at least one).
d12280 1
a12280 1
 *  --KED  02/01/99
d12282 1
a12282 2
PUBLIC int HText_ExtEditForm ARGS1(
	   LinkInfo *,	form_link)
d12285 1
a12285 1
    size_t	size;
d12287 2
a12288 2
    char       *ed_temp;
    FILE       *fp;
d12291 3
a12293 3
    TextAnchor *start_anchor  = NULL;
    TextAnchor *end_anchor    = NULL;
    BOOLEAN	firstanchor   = TRUE;
d12296 23
a12318 23
    char	ed_offset[10];
    int		start_line    = 0;
    int		entry_line    = form_link->anchor_line_num;
    int		exit_line     = 0;
    int		orig_cnt      = 0;
    int		line_cnt      = 1;

    FormInfo   *form	 = form_link->l_form;
    char       *areaname = form->name;
    int		form_num = form->number;

    HTLine     *htline	 = NULL;

    char       *ebuf;
    char       *line;
    char       *lp;
    char       *cp;
    int		match_tag = 0;
    int		newlines  = 0;
    int		len, len0, len_in;
    int		wanted_fieldlen_wrap = -1; /* not yet asked; 0 means don't. */
    char       *skip_at = NULL;
    int		skip_num = 0, i;
d12322 2
a12323 2
    ed_temp = (char *) malloc (LY_MAXPATH);
    if ((fp = LYOpenTemp (ed_temp, "", "w")) == 0) {
d12329 2
a12330 2
     *	Begin at the beginning, to find 1st anchor in the TEXTAREA, then
     *	write all of its lines (anchors) out to the edit temp file.
d12332 7
a12338 7
     *	[Finding the TEXTAREA we're actually *in* with these attributes
     *	 isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     *	 and there *could* be TEXTAREA's with the same "name".	If that
     *	 should ever be true, we'll actually get the data from the *1st*
     *	 TEXTAREA in the page that matches.  We should probably assign
     *	 a unique id to each TEXTAREA in a page, and match on that, to
     *	 avoid this (potential) problem.
d12340 3
a12342 3
     *	 Since the odds of "false matches" *actually* happening in real
     *	 life seem rather small though, we'll hold off doing this, for a
     *	 rainy day ...]
d12348 4
a12351 4
	if ((anchor_ptr->link_type	     == INPUT_ANCHOR)    &&
	    (anchor_ptr->input_field->type   == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num)	 &&
	    !strcmp (anchor_ptr->input_field->name, areaname))   {
d12354 1
a12354 1
		firstanchor  = FALSE;
d12356 1
a12356 1
		start_line   = anchor_ptr->line_num;
d12361 1
a12361 1
	     *  Write the anchors' text to the temp edit file.
d12363 2
a12364 2
	    fputs (anchor_ptr->input_field->value, fp);
	    fputc ('\n', fp);
d12366 1
a12366 1
	 } else {
d12370 2
a12371 2
	 }
	 anchor_ptr = anchor_ptr->next;
d12373 1
a12373 1
    LYCloseTempFP (fp);
d12379 3
a12381 3
     *	Go edit the TEXTAREA temp file, with the initial editor line
     *  corresponding to the TEXTAREA line the cursor is on (if such
     *  positioning is supported by the editor [as lynx knows it]).
d12383 1
a12383 1
    ed_offset[0] = 0; /* pre-ANSI compilers don't initialize aggregates - TD */
d12385 1
a12385 1
	sprintf (ed_offset, "%d", ((entry_line - start_line) + 1));
d12392 1
a12392 1
     *	Read back the edited temp file into our buffer.
d12394 2
a12395 2
    if ((stat (ed_temp, &stat_info) < 0)   ||
	!S_ISREG(stat_info.st_mode)        ||
d12398 2
a12399 1
	ebuf = typecalloc (char);
d12404 1
d12407 4
a12410 4
	     *  This could be huge - don't exit if we don't have enough
	     *  memory for it.  With some luck, the user may be even able
	     *  to recover the file manually from the temp space while
	     *  the lynx session is not over. - kw
d12417 3
a12419 3
	fp = fopen (ed_temp, "r");
	size = fread (ebuf, 1, size, fp);
	LYCloseInput (fp);
d12424 1
a12424 1
     *	Nuke any blank lines from the end of the edited data.
d12427 1
a12427 1
     && (CanTrimTextArea(UCH(ebuf[size-1])) || (ebuf[size-1] == '\0')))
d12431 3
a12433 3
     *	Copy each line from the temp file into the corresponding anchor
     *  struct.  Add new lines to the TEXTAREA if needed.  (Always leave
     *  the user with a blank line at the end of the TEXTAREA.)
d12435 1
a12435 1
    if ((line = (char *) malloc (MAX_LINE)) == 0)
d12444 1
a12444 1
    lp  = ebuf;
d12460 2
a12461 2
	if ((cp = strchr (lp, '\n')) != 0)
	   len = len_in = cp - lp;
d12463 1
a12463 2
	   len = len_in = strlen (lp);

d12466 1
a12466 1
	    len0+len >= start_anchor->input_field->size &&
d12468 1
a12468 1
	    (cp-lp) < start_anchor->input_field->size - 1) {
d12478 3
a12480 3
	if (wanted_fieldlen_wrap > 0 && len0+len > wanted_fieldlen_wrap) {
	    for (i = wanted_fieldlen_wrap-len0;
		 i+len0 >= wanted_fieldlen_wrap/4; i--) {
d12492 1
a12492 1
			       (cp - lp) <= len + (3 * wanted_fieldlen_wrap/4))
d12500 1
a12500 1
			    while (isspace(UCH(*(cp-1)))) {
d12511 3
a12513 3
	if (wanted_fieldlen_wrap > 0 && len0+len > wanted_fieldlen_wrap) {
	    i = len-1;
	    while (len0+i+1 > wanted_fieldlen_wrap &&
d12516 1
a12516 1
	    if (len0+i+1 > wanted_fieldlen_wrap)
d12520 1
a12520 1
	if (len0+len >= MAX_LINE) {
d12527 1
a12527 1
	     *  First try to find a space character for wrapping - kw
d12535 1
a12535 1
	    if (len0+len >= MAX_LINE)
d12539 2
a12540 2
	strncat (line, lp, len);
	*(line + len0+len) = '\0';
d12542 1
a12542 1
	cleanup_line_for_textarea (line, len0+len);
d12545 3
a12547 3
	 *  If there are more lines in the edit buffer than were in the
	 *  original TEXTAREA, we need to add a new line/anchor, continuing
	 *  on until the edit buffer is empty.
d12550 2
a12551 2
	    insert_new_textarea_anchor (&end_anchor, &htline);
	    anchor_ptr = end_anchor;   /* make the new anchor current */
d12556 1
a12556 1
	 *  Finally copy the new line from the edit buffer into the anchor.
d12561 2
a12562 2
	 *  Keep track of 1st blank line in any trailing blank lines, for
	 *  later cursor repositioning.
d12564 1
a12564 1
	if (len0+len > 0)
d12570 1
a12570 1
	 *  And do the next line of edited text, for the next anchor ...
d12573 2
a12574 1
	if (*lp && isspace(UCH(*lp))) lp++;
d12588 3
a12590 3
     *	If we've added any new lines/anchors, we need to adjust various
     *  things in all anchor-bearing lines following the last newly added
     *  line/anchor.  The fun stuff starts here ...
d12593 1
a12593 1
	update_subsequent_anchors (newlines, end_anchor, htline, match_tag);
d12596 1
a12596 1
     *  Cleanup time.
d12600 1
a12600 1
    LYRemoveTemp (ed_temp);
d12606 4
a12609 4
     *  Return the offset needed to move the cursor from its current
     *  (on entry) line number, to the 1st blank line of the trailing
     *  (group of) blank line(s), which is where we want to be.  Let
     *  the caller deal with moving us there, however ... :-) ...
a12613 1

d12615 2
a12616 2
 *  Expand the size of a TEXTAREA by a fixed number of lines (as specified
 *  by arg2).
d12618 1
a12618 1
 *  --KED  02/14/99
d12620 1
a12620 3
PUBLIC void HText_ExpandTextarea ARGS2(
	    LinkInfo *,	form_link,
	    int,	newlines)
d12623 2
a12624 2
    TextAnchor *end_anchor    = NULL;
    BOOLEAN	firstanchor   = TRUE;
d12626 3
a12628 3
    FormInfo *form      = form_link->l_form;
    char     *areaname  = form->name;
    int       form_num  = form->number;
d12630 1
a12630 4
    HTLine   *htline    = NULL;

    int       match_tag = 0;
    int       i;
d12632 2
d12637 2
a12638 1
    if (newlines < 1) return;
d12641 2
a12642 2
     *	Begin at the beginning, to find the TEXTAREA, then on to find
     *	the last line (anchor) in it.
d12644 7
a12650 7
     *	[Finding the TEXTAREA we're actually *in* with these attributes
     *	 isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     *	 and there *could* be TEXTAREA's with the same "name".	If that
     *	 should ever be true, we'll actually expand the *1st* TEXTAREA
     *	 in the page that matches.  We should probably assign a unique
     *	 id to each TEXTAREA in a page, and match on that, to avoid this
     *	 (potential) problem.
d12652 3
a12654 3
     *	 Since the odds of "false matches" *actually* happening in real
     *	 life seem rather small though, we'll hold off doing this, for a
     *	 rainy day ...]
d12660 4
a12663 4
	if ((anchor_ptr->link_type	     == INPUT_ANCHOR)    &&
	    (anchor_ptr->input_field->type   == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num)	 &&
	    !strcmp (anchor_ptr->input_field->name, areaname))   {
d12670 1
a12670 1
	 } else {
d12674 2
a12675 2
	 }
	 anchor_ptr = anchor_ptr->next;
d12679 1
a12679 1
	insert_new_textarea_anchor (&end_anchor, &htline);
d12682 1
a12682 1
	 *  Make the new line blank.
d12687 1
a12687 1
	 *  And go add another line ...
d12690 1
a12690 1
	   match_tag = end_anchor->next->number;
d12694 1
a12694 1
		newlines, areaname));
d12697 2
a12698 2
     *	We need to adjust various things in all anchor bearing lines
     *	following the last newly added line/anchor.  Fun stuff.
d12700 1
a12700 1
    update_subsequent_anchors (newlines, end_anchor, htline, match_tag);
a12706 1

d12708 2
a12709 2
 *  Insert the contents of a file into a TEXTAREA between the cursor line,
 *  and the line preceding it.
d12711 3
a12713 3
 *  Returns the number of lines that the cursor should be moved so that it
 *  will end up on the 1st line in the TEXTAREA following the inserted file
 *  (if we decide to do that).
d12715 1
a12715 1
 *  --KED  02/21/99
d12717 1
a12717 2
PUBLIC int HText_InsertFile ARGS1(
	   LinkInfo *,	form_link)
d12720 1
a12720 1
    size_t	size;
d12722 2
a12723 2
    FILE       *fp;
    char       *fn;
d12727 2
a12728 2
    TextAnchor *end_anchor  = NULL;
    BOOLEAN	firstanchor = TRUE;
d12731 3
a12733 3
    FormInfo   *form	 = form_link->l_form;
    char       *areaname = form->name;
    int		form_num = form->number;
d12735 1
a12735 1
    HTLine     *htline	 = NULL;
d12738 2
a12739 13
    FormInfo   *f = 0;
    HTLine     *l = 0;

    char       *fbuf;
    char       *line;
    char       *lp;
    char       *cp;
    int		entry_line = form_link->anchor_line_num;
    int		file_cs;
    int		match_tag  = 0;
    int		newlines   = 0;
    int		len;
    int		i;
d12741 10
d12758 3
a12760 2
	HTInfoMsg (FILE_INSERT_CANCELLED);
	CTRACE((tfp, "GridText: file insert cancelled - no filename provided\n"));
d12771 1
a12771 1
     *	Read it into our buffer (abort on 0-length file).
d12773 1
a12773 1
    if ((stat (fn, &stat_info) < 0)        ||
d12775 4
a12778 3
	HTInfoMsg (FILE_INSERT_0_LENGTH);
	CTRACE((tfp, "GridText: file insert aborted - file=|%s|- was 0-length\n",
		    fn));
d12786 3
a12788 3
	     *  This could be huge - don't exit if we don't have enough
	     *  memory for it. - kw
	     */ /*outofmem(__FILE__, "HText_InsertFile");*/
d12804 1
a12804 1
	fp   = fopen (fn, "r");
d12811 2
a12812 2
	size = fread (fbuf, 1, size, fp);
	LYCloseInput (fp);
a12816 1

d12818 2
a12819 2
     *	Begin at the beginning, to find the TEXTAREA we're in, then
     *	the current cursorline.
d12821 7
a12827 7
     *	[Finding the TEXTAREA we're actually *in* with these attributes
     *	 isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     *	 and there *could* be TEXTAREA's with the same "name".	If that
     *	 should ever be true, we'll actually insert data into the *1st*
     *	 TEXTAREA in the page that matches.  We should probably assign
     *	 a unique id to each TEXTAREA in a page, and match on that, to
     *	 avoid this (potential) problem.
d12829 3
a12831 3
     *	 Since the odds of "false matches" *actually* happening in real
     *	 life seem rather small though, we'll hold off doing this, for a
     *	 rainy day ...]
d12837 4
a12840 4
	if ((anchor_ptr->link_type	     == INPUT_ANCHOR)    &&
	    (anchor_ptr->input_field->type   == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num)	 &&
	    !strcmp (anchor_ptr->input_field->name, areaname))   {
d12842 2
a12843 2
	   if (anchor_ptr->line_num == entry_line)
	      break;
d12846 1
a12846 1
	anchor_ptr  = anchor_ptr->next;
a12848 1

d12850 2
a12851 2
     *  Clone a new TEXTAREA line/anchor using the cursorline anchor as
     *  a template, but link it in BEFORE the cursorline anchor/htline.
d12853 5
a12857 5
     *  [We can probably combine this with insert_new_textarea_anchor()
     *   along with a flag to indicate "insert before" as we do here,
     *   or the "normal" mode of operation (add after "current" anchor/
     *   line).  Beware of the differences ... some are a bit subtle to
     *   notice.]
d12860 1
a12860 1
	 anchor_ptr->line_num != i;            i++) {
d12868 1
d12875 5
a12879 5
    a->next	       = anchor_ptr;
    a->number	       = anchor_ptr->number;
    a->line_pos	       = anchor_ptr->line_pos;
    a->extent	       = anchor_ptr->extent;
    a->line_num	       = anchor_ptr->line_num;
d12881 6
a12886 6
    a->link_type       = anchor_ptr->link_type;
    a->input_field     = f;
    a->show_anchor     = anchor_ptr->show_anchor;
    a->inUnderline     = anchor_ptr->inUnderline;
    a->expansion_anch  = TRUE;
    a->anchor	       = NULL;
d12890 9
a12898 9
    StrAllocCopy (f->name, anchor_ptr->input_field->name);
    f->number	       = anchor_ptr->input_field->number;
    f->type	       = anchor_ptr->input_field->type;
    StrAllocCopy (f->orig_value, "");
    f->size	       = anchor_ptr->input_field->size;
    f->maxlength       = anchor_ptr->input_field->maxlength;
    f->no_cache        = anchor_ptr->input_field->no_cache;
    f->disabled        = anchor_ptr->input_field->disabled;
    f->value_cs        = (file_cs >= 0) ? file_cs : current_char_set;
d12901 2
a12902 2
    l->offset	       = htline->offset;
    l->size	       = htline->size;
d12905 2
a12906 2
    l->numstyles       = htline->numstyles;
    /*we fork the pointers!*/
d12909 1
a12909 1
    strcpy (l->data,     htline->data);
d12912 2
a12913 2
     *  If we're at the head of the TextAnchor list, the new node becomes
     *  the first node.
d12919 1
a12919 1
     *  Link in the new TextAnchor, and corresponding HTLine.
d12924 5
a12928 5
    htline		= htline->prev;
    l->next		= htline->next;
    l->prev		= htline;
    htline->next->prev	= l;
    htline->next	= l;
d12931 3
a12933 3
     *  update_subsequent_anchors() expects htline to point to 1st potential
     *  line needing fixup; we need to do this just in case the inserted file
     *  was only a single line (yes, it's pathological ... ).
d12935 2
a12936 2
    htline = htline->next; /* ->new (current) htline, for 1st inserted line  */
    htline = htline->next; /* ->1st potential (following) [tag] fixup htline */
a12940 1

d12942 2
a12943 2
     *	Copy each line from the insert file into the corresponding anchor
     *  struct.
d12945 1
a12945 1
     *  Begin with the new line/anchor we just added (above the cursorline).
d12947 1
a12947 1
    if ((line = (char *) malloc (MAX_LINE)) == 0)
d12953 1
a12953 1
    lp  = fbuf;
d12957 2
a12958 2
	if ((cp = strchr (lp, '\n')) != 0)
	   len = cp - lp;
d12960 1
a12960 1
	   len = strlen (lp);
d12969 1
a12969 1
		lp[len+1] = '\0'; /* prevent next iteration */
d12971 1
a12971 1
	strncpy (line, lp, len);
d12974 1
a12974 1
	cleanup_line_for_textarea (line, len);
d12977 2
a12978 2
	 *  If not the first line from the insert file, we need to add
	 *  a new line/anchor, continuing on until the buffer is empty.
d12981 3
a12983 3
	   insert_new_textarea_anchor (&end_anchor, &htline);
	   anchor_ptr = end_anchor;   /* make the new anchor current */
	   newlines++;
d12987 1
a12987 1
	 *  Copy the new line from the buffer into the anchor.
d12992 2
a12993 2
	 *  insert_new_textarea_anchor always uses current_char_set,
	 *  we may want something else, so fix it up. - kw
d12995 2
a12996 2
	 if (file_cs >= 0)
	     anchor_ptr->input_field->value_cs = file_cs;
d12999 1
a12999 1
	 *  And do the next line of insert text, for the next anchor ...
d13002 2
a13003 1
	if (*lp) lp++;
d13006 2
a13007 2
	end_anchor  = anchor_ptr;
	anchor_ptr  = anchor_ptr->next;
d13013 2
a13014 2
     *	Now adjust various things in all anchor-bearing lines following the
     *  last newly added line/anchor.  Some say this is the fun part ...
d13016 1
a13016 1
    update_subsequent_anchors (newlines, end_anchor, htline, match_tag);
d13019 1
a13019 1
     *  Cleanup time.
d13041 3
a13043 5
PRIVATE void redraw_part_of_line ARGS4(
	HTLine *,	line,
	char*,		str,
	int,		len,
	HText *,	text)
d13047 1
a13047 1
    char *data,*end_of_data;
d13049 1
d13054 1
a13054 1
    int YP,XP;
d13056 1
a13056 1
    LYGetYX(YP,XP);
d13067 2
a13068 2
    /* this assumes that the part of line to be drawn fits in the screen*/
    while (  data < end_of_data ) {
d13076 3
a13078 4
	       i >= (int) (CStyle.horizpos + line->offset + 1))
	{
		LynxChangeStyle (CStyle.style,CStyle.direction);
		current_style++;
d13084 8
a13091 8
	    case LY_UNDERLINE_START_CHAR:
		if (dump_output_immediately && use_underscore) {
		    LYaddch('_');
		    i++;
		} else {
		    start_underline();
		}
		break;
d13093 8
a13100 8
	    case LY_UNDERLINE_END_CHAR:
		if (dump_output_immediately && use_underscore) {
		    LYaddch('_');
		    i++;
		} else {
		    stop_underline();
		}
		break;
d13102 3
a13104 3
	    case LY_BOLD_START_CHAR:
		start_bold();
		break;
d13106 3
a13108 3
	    case LY_BOLD_END_CHAR:
		stop_bold ();
		break;
d13111 19
a13129 3
	    case LY_SOFT_NEWLINE:
		if (!dump_output_immediately)
		    LYaddch('+');
d13131 8
d13140 39
a13178 63
	    case LY_SOFT_HYPHEN:
		if (*data != '\0' ||
		    isspace(UCH(LastDisplayChar)) ||
		    LastDisplayChar == '-') {
		    /*
		     *  Ignore the soft hyphen if it is not the last
		     *  character in the line.  Also ignore it if it
		     *  first character following the margin, or if it
		     *  is preceded by a white character (we loaded 'M'
		     *  into LastDisplayChar if it was a multibyte
		     *  character) or hyphen, though it should have
		     *  been excluded by HText_appendCharacter() or by
		     *  split_line() in those cases. -FM
		     */
		    break;
		} else {
		    /*
		     *  Make it a hard hyphen and fall through. -FM
		     */
		    buffer[0] = '-';
		    i++;
		}
		/* FALLTHRU */

	    default:
		i++;
		if (text->T.output_utf8 && is8bits(buffer[0])) {
		    utf_extra = utf8_length(text->T.output_utf8, data-1);
		    LastDisplayChar = 'M';
		}
		if (utf_extra) {
		    strncpy(&buffer[1], data, utf_extra);
		    buffer[utf_extra+1] = '\0';
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		    data += utf_extra;
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && is8bits(buffer[0])) {
		    /*
		     *  For CJK strings, by Masanobu Kimura.
		     */
		    buffer[1] = *data;
		    data++;
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		    /*
		     *  For now, load 'M' into LastDisplayChar,
		     *  but we should check whether it's white
		     *  and if so, use ' '.  I don't know if
		     *  there actually are white CJK characters,
		     *  and we're loading ' ' for multibyte
		     *  spacing characters in this code set,
		     *  but this will become an issue when
		     *  the development code set's multibyte
		     *  character handling is used. -FM
		     */
		    LastDisplayChar = 'M';
		} else {
		    LYaddstr(buffer);
		    LastDisplayChar = buffer[0];
		}
	} /* end of switch */
    } /* end of while */
d13181 2
a13182 2
    stop_underline();
    stop_bold();
d13185 2
a13186 3
    while (current_style < line->numstyles)
    {
	LynxChangeStyle (CStyle.style, CStyle.direction);
d13198 14
a13211 14
 *  Function move_to_glyph is called from LYMoveToLink and does all
 *  the real work for it.
 *  The pair LYMoveToLink()/move_to_glyph() is similar to the pair
 *  redraw_lines_of_link()/redraw_part_of_line(), some key differences:
 *   LYMoveToLink/move_to_glyph		redraw_*
 *   -----------------------------------------------------------------
 *   - used without color style         - used with color style
 *   - handles showing WHEREIS target	- WHEREIS handled elsewhere
 *   - handles only one line		- handles first two lines for
 *					  hypertext anchors
 *   - right columns position for UTF-8
 *     by redrawing as necessary
 *   - currently used for highlight	- currently used for highlight
 *     ON and OFF			  OFF
d13213 15
a13227 16
 *  Eventually the two sets of function should be unified, and should handle
 *  UTF-8 positioning, both lines of hypertext anchors, and WHEREIS in all
 *  cases.  If possible.  The complex WHEREIS target logic in highlight()
 *  could then be completely removed. - kw
 */
PRIVATE void move_to_glyph ARGS10(
	int,		YP,
	int,		XP,
	int,		XP_draw_min,
	char *,		data,
	int,		datasize,
	unsigned,	offset,
	CONST char *,	target,
	char *,		hightext,
	int,		flags,
	BOOL,		utf_flag)
d13231 1
a13231 1
    CONST char *end_of_data;
d13233 1
d13235 2
a13236 2
    CONST char *cp_tgt;
    int i_start_tgt=0, i_after_tgt;
d13247 1
a13247 1
    int	len;
d13256 2
a13257 2
     *  Add offset, making sure that we do not
     *  go over the COLS limit on the display.
d13259 3
a13261 3
    i = (int)offset;
    if (i > (int)DISPLAY_COLS - 1)
	i = (int)DISPLAY_COLS - 1;
d13266 2
a13267 2
     *  Scan through the data, making sure that we do not
     *  go over the COLS limit on the display etc.
d13274 2
a13275 2
     *  If the target overlaps with the part of this line that
     *  we are drawing, it will be emphasized.
d13285 2
a13286 2
	    if ((int)offset + LenNeeded >= DISPLAY_COLS ||
		((int)offset + HitOffset >= XP + linkvlen)) {
a13297 1

d13299 5
a13303 5
     *  Iterate through the line data from the start, keeping track of
     *  the display ("glyph") position in i.  Drawing will be turned
     *  on when either the first UTF-8 sequence (that occurs after
     *  XP_draw_min) is found, or when we reach the link itself (if
     *  highlight is non-NULL). - kw
d13309 17
a13325 17
	/*
	 *  We reached the position of link itself, and hightext is
	 *  non-NULL.  We switch data from being a pointer into the HTLine
	 *  to being a pointer into hightext.  Normally (as long as this
	 *  routine is applied to normal hyperlink anchors) the text in
	 *  hightext will be identical to that part of the HTLine that
	 *  data was already pointing to, except that special attribute
	 *  chars LY_BOLD_START_CHAR etc. have been stripped out (see
	 *  HText_trimHightext).  So the switching should not result in
	 *  any different display, but it ensures that it doesn't go
	 *  unnoticed if somehow hightext got messed up somewhere else.
	 *  This is also useful in preparation for using this function
	 *  for something else than normal hyperlink anchors, i.e. form
	 *  fields.
	 *  Turn on drawing here or make sure it gets turned on before the
	 *  next actual normal character is handled. - kw
	 */
d13338 9
a13346 9
	     *  The logic of where to set intarget drawingtarget etc.
	     *  and when to react to it should be cleaned up (here and
	     *  further below).  For now this seems to work but isn't
	     *  very clear.  The complications arise from reproducing
	     *  the behavior (previously done in LYhighlight()) for target
	     *  strings that fall into or overlap a link: use target
	     *  emphasis for the target string, except for the first
	     *  and last character of the anchor text if the anchor is
	     *  highlighted as "current link". - kw
d13356 3
a13358 2
			    if (inunderline)	inU = YES;
			    lynx_start_link_color (flag, inU);
d13377 7
a13383 4
		    if (inunderline)	inU = YES;
		    if (inunderline)	stop_underline();
		    if (inbold)		stop_bold();
		    lynx_start_link_color (flag, inU);
a13392 1

d13395 2
a13396 2
	 *  Look for a subsequent occurrence of the target string,
	 *  if we had a previous one and have now stepped past it. - kw
d13433 1
a13433 1
				lynx_start_link_color (flag, inU);
d13437 4
a13440 2
			    if (inbold)		start_bold();
			    if (inunderline)	start_underline();
d13449 10
a13458 10
	 *  Advance data to point to the next input char (for the
	 *  next round).  Advance sdata, used for searching for a
	 *  target string, so that they stays in synch.  As long
	 *  as we are not within the highlight text, data and sdata
	 *  have identical values.  After we have switched data to
	 *  point into hightext, sdata remains a pointer into the
	 *  HTLine (so that we don't miss a partial target match at
	 *  the end of the anchor text).  So sdata has to sometimes
	 *  skip additional special attribute characters that are
	 *  not present in highlight in order to stay in synch. - kw
d13462 4
a13465 3
	    do sdata++;
		while (incurlink && *sdata && sdata != data &&
		       IsSpecialAttrChar(*(sdata-1)));
d13470 12
a13481 5
	    case LY_UNDERLINE_START_CHAR:
		if (!drawing || !incurlink) inunderline = YES;
		if (drawing && !intarget && !incurlink)
		    start_underline();
		break;
d13483 6
a13488 5
	    case LY_UNDERLINE_END_CHAR:
		inunderline = NO;
		if (drawing && !intarget && !incurlink)
		    stop_underline();
		break;
d13490 5
a13494 5
	    case LY_BOLD_START_CHAR:
		if (!drawing || !incurlink) inbold = YES;
		if (drawing && !intarget && !incurlink)
		    start_bold();
		break;
d13496 6
a13501 5
	    case LY_BOLD_END_CHAR:
		inbold = NO;
		if (drawing && !intarget && !incurlink)
		    stop_bold();
		break;
d13503 14
a13516 5
	    case LY_SOFT_NEWLINE:
		if (drawing) {
		    LYaddch('+');
		}
		i++;
d13518 1
a13518 25

	    case LY_SOFT_HYPHEN:
		if (*data != '\0' ||
		    isspace(UCH(LastDisplayChar)) ||
		    LastDisplayChar == '-') {
		    /*
		     *  Ignore the soft hyphen if it is not the last
		     *  character in the line.  Also ignore it if it
		     *  first character following the margin, or if it
		     *  is preceded by a white character (we loaded 'M'
		     *  into LastDisplayChar if it was a multibyte
		     *  character) or hyphen, though it should have
		     *  been excluded by HText_appendCharacter() or by
		     *  split_line() in those cases. -FM
		     */
		    break;
		} else {
		    /*
		     *  Make it a hard hyphen and fall through. -FM
		     */
		    buffer[0] = '-';
		}
		/* FALLTHRU */

	    default:
d13520 1
a13520 3
		 *  We have got an actual normal displayable character, or
		 *  the start of one.  Before proceeding check whether
		 *  drawing needs to be turned on now. - kw
d13522 10
d13533 12
a13544 13
		if (incurlink && intarget && flag && i_after_tgt > i) {
		    if (i == XP - 1) {
			i_after_tgt = i;
		    } else if (i == XP - 2 && HTCJK != NOCJK &&
			       is8bits(buffer[0])) {
			i_after_tgt = i;
			cp_tgt = NULL;
			if (drawing) {
			    if (drawingtarget) {
				LYstopTargetEmphasis();
				drawingtarget = NO;
				lynx_start_link_color (flag, inU);
			    }
d13548 18
a13565 29
		if (cp_tgt && i >= i_start_tgt && sdata > cp_tgt) {
		    if (!intarget ||
			(intarget && incurlink && !drawingtarget)) {

			if (incurlink && drawing &&
			    !(flag &&
			      (i == XP_link || i == XP - 1))) {
			    lynx_stop_link_color (flag, inU);
			}
			if (incurlink && !drawing) {
			    LYmove(YP, i);
			    if (inunderline)	inU = YES;
			    if (flag && (i == XP_link || i == XP - 1)) {
				lynx_start_link_color (flag, inU);
				drawingtarget = NO;
			    } else {
				LYstartTargetEmphasis();
				drawingtarget = YES;
			    }
			    drawing = YES;
			} else if (incurlink && drawing &&
				   intarget && !drawingtarget &&
				   (flag &&
				    (i == XP_link))) {
			    if (inunderline)	inU = YES;
			    lynx_start_link_color (flag, inU);
			} else if (drawing &&
				   !(flag &&
				     (i == XP_link || (incurlink && i == XP - 1)))) {
d13569 13
a13581 1
			intarget = YES;
d13583 3
a13585 1
		} else
d13587 9
a13595 8
		    if (incurlink) {
			if (!drawing) {
			    LYmove(YP, i);
			    if (inunderline)	inU = YES;
			    lynx_start_link_color (flag, inU);
			    drawing = YES;
			}
		    }
d13597 12
a13608 12
		i++;
		if (utf_flag && is8bits(buffer[0])) {
		    hadutf8 = YES;
		    utf_extra = utf8_length(utf_flag, data-1);
		    LastDisplayChar = 'M';
		}
		if (utf_extra) {
		    strncpy(&buffer[1], data, utf_extra);
		    buffer[utf_extra+1] = '\0';
		    if (!drawing && i >= XP_draw_min) {
			LYmove(YP, i - 1);
			drawing = YES;
d13610 4
a13613 4
			if (intarget) {
			    drawingtarget = YES;
			    LYstartTargetEmphasis();
			} else
d13615 18
a13632 7
			{
			    if (inbold)
				start_bold();
			    if (inunderline)
				start_underline();
			}
		    }
a13634 28
		    sdata += utf_extra; data += utf_extra;
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && is8bits(buffer[0])) {
		    /*
		     *  For CJK strings, by Masanobu Kimura.
		     */
		    if (drawing && (i < DISPLAY_COLS - 1)) {
			buffer[1] = *data;
			LYaddstr(buffer);
			buffer[1] = '\0';
		    }
		    i++;
		    sdata++; data++;
		    /*
		     * For now, load 'M' into LastDisplayChar, but we should
		     * check whether it's white and if so, use ' '.  I don't
		     * know if there actually are white CJK characters, and
		     * we're loading ' ' for multibyte spacing characters in
		     * this code set, but this will become an issue when the
		     * development code set's multibyte character handling is
		     * used.  -FM
		     */
		    LastDisplayChar = 'M';
		} else {
		    if (drawing) {
			LYaddstr(buffer);
		    }
		    LastDisplayChar = buffer[0];
d13636 21
a13656 2
	} /* end of switch */
    } /* end of while */
d13660 1
a13660 1
	lynx_start_link_color (flag, inU);
d13665 1
a13665 1
	    lynx_start_link_color (flag, inU);
d13678 21
a13698 22
 *  Move cursor position to a link's place in the display.
 *  The "moving to" is done by scanning through the line's
 *  character data in the corresponding HTLine of HTMainText,
 *  and starting to draw when a UTF-8 encoded non-ASCII character
 *  is encountered before the link (with some protection against
 *  overwriting form fields).  This refreshing of preceding data is
 *  necessary for preventing curses's or slang's display logic from
 *  getting too clever; their logic counts character positions wrong
 *  since they don't know about multi-byte characters that take up
 *  only one screen position.  So we have to make them forget their
 *  idea of what's in a screen line drawn previously.
 *  If hightext is non-NULL, it should be the anchor text for a normal
 *  link as stored in a links[] element, and the anchor text will be
 *  drawn too, with appropriate attributes. - kw
 */
PUBLIC void LYMoveToLink ARGS6(
	int,		cur,
	CONST char *,	target,
	char *,		hightext,
	int,		flag,
	BOOL,		inU,
	BOOL,		utf_flag)
d13701 2
a13702 2
    HTLine* todr;
    int i, n=0;
d13707 2
a13708 2
     *  We need to protect changed form text fields preceding this
     *  link on the same line against overwriting. - kw
d13710 1
a13710 1
    for (i = cur-1; i >= 0; i++) {
d13733 2
a13734 1
	if (target && *target == '\0') target = NULL;
d13752 1
a13752 2
PUBLIC void redraw_lines_of_link ARGS1(
	int,		cur GCC_UNUSED)
d13756 1
a13756 1
    HTLine* todr1;
d13762 3
a13764 3
    /* we are at the last page - that is partially filled */
	lines_back = HTMainText->Lines - ( links[cur].ly - pvtTITLE_HEIGHT+
	HTMainText->top_of_screen);
d13773 3
a13775 1
    for (count = 0; row <= display_lines && (text = LYGetHiliteStr(cur, count)) != NULL; ++count) {
d13778 1
a13778 1
	redraw_part_of_line (todr1, text, strlen(text), HTMainText);
d13783 1
a13783 1
    /* no dead code !*/
d13789 1
a13789 1
PUBLIC void HTMark_asSource NOARGS
d13796 1
a13796 2
PUBLIC HTkcode HText_getKcode ARGS1(
	HText *,	text)
d13801 1
a13801 3
PUBLIC void HText_updateKcode ARGS2(
	HText *,	text,
	HTkcode,	kcode)
d13806 1
a13806 2
PUBLIC HTkcode HText_getSpecifiedKcode ARGS1(
	HText *,	text)
d13811 1
a13811 3
PUBLIC void HText_updateSpecifiedKcode ARGS2(
	HText *,	text,
	HTkcode,	kcode)
d13816 1
a13816 1
PUBLIC int HTMainText_Get_UCLYhndl NOARGS
@


1.4
log
@First step of lynx-2.8.5-dev16c merger
@
text
@d46 1
a46 1
#ifdef SOURCE_CACHE
d142 1
a142 1
#ifdef SOURCE_CACHE
d245 1
a245 1
#define POOLtypecalloc(T,ptr)	    ptr = (T*) ALLOC_IN_POOL(&HTMainText->pool, sizeof(T))
d335 14
a348 1
#define LINE_SIZE(l) (sizeof(HTLine)+(l))	/* Allow for terminator */
d461 1
a461 1
#ifdef SOURCE_CACHE
a600 3
PRIVATE void HText_RemoveEmptyLastLine PARAMS((
	HText *		text));

a668 2
	if (t == HTMainText)
	    t = NULL;		/* shouldn't happen */
d716 1
d727 1
a727 1
	POOLallocstring(a->lites.hl_base.hl_text, len);
d754 1
a754 1
    POOLallocstring(have[need].hl_text, strlen(text));
d867 48
d973 1
a973 2
     *  HTuncache_current_document(), e.g., for the showinfo, options,
     *  download, print, etc., temporary file URLs, so we'll check now
d1024 1
a1024 1
#ifdef SOURCE_CACHE
d1183 14
d1202 1
a1202 43
	    /*
	     *  Free form fields.
	     */
	    if (l->input_field->type == F_OPTION_LIST_TYPE &&
		l->input_field->select_list != NULL) {
		/*
		 *  Free off option lists if present.
		 *  It should always be present for F_OPTION_LIST_TYPE
		 *  unless we had invalid markup which prevented
		 *  HText_setLastOptionValue from finishing its job
		 *  and left the input field in an insane state. - kw
		 */
		OptionType *optptr = l->input_field->select_list;
		OptionType *tmp;
		while (optptr) {
		    tmp = optptr;
		    optptr = tmp->next;
		    FREE(tmp->name);
		    FREE(tmp->cp_submit_value);
		    FREE(tmp);
		}
		l->input_field->select_list = NULL;
		/*
		 *  Don't free the value field on option
		 *  lists since it points to a option value
		 *  same for orig value.
		 */
		l->input_field->value = NULL;
		l->input_field->orig_value = NULL;
		l->input_field->cp_submit_value = NULL;
		l->input_field->orig_submit_value = NULL;
	    } else {
		FREE(l->input_field->value);
		FREE(l->input_field->orig_value);
		FREE(l->input_field->cp_submit_value);
		FREE(l->input_field->orig_submit_value);
	    }
	    FREE(l->input_field->name);
	    FREE(l->input_field->submit_action);
	    FREE(l->input_field->submit_enctype);
	    FREE(l->input_field->submit_title);

	    FREE(l->input_field->accept_cs);
d1205 1
a1205 1
	LYClearHiText(l);
d1246 1
a1246 1
#ifdef SOURCE_CACHE
a2492 4
#define AT_START_OF_CELL(text)	\
  (text->stbl			\
   && Stbl_at_start_of_cell(text->stbl, text->Lines, text->last_line->size))

d2591 1
a2591 1
 *    (lines allocated in pool, caller should not free the old one).
d2632 1
a2632 1
	POOLallocHTLine(mod_line, line->size + added_chars);
a2703 26
PRIVATE void reset_cached_linedata ARGS3(
	HText *,	text,
	char *,		p,
	unsigned,	plen)
{			/* Count funny characters */
    int i;

    text->permissible_split = ctrl_chars_on_this_line =
	utfxtra_on_this_line = 0;
    for (i = (plen - 1); i >= 0; i--) {
	if (p[i] == LY_UNDERLINE_START_CHAR ||
	    p[i] == LY_UNDERLINE_END_CHAR ||
	    p[i] == LY_BOLD_START_CHAR ||
	    p[i] == LY_BOLD_END_CHAR ||
	    p[i] == LY_SOFT_HYPHEN) {
	    ctrl_chars_on_this_line++;
	} else if (IS_UTF_EXTRA(p[i])) {
	    utfxtra_on_this_line++;
	}
	if (p[i] == LY_SOFT_HYPHEN && (int)text->permissible_split < i)
	    text->permissible_split = i + 1;
    }
    ctrl_chars_on_this_line += utfxtra_on_this_line;
}


d2855 1
d2888 14
a2901 1
	    reset_cached_linedata(text,	p, plen);
d3059 1
a3059 1
    POOLallocHTLine(temp, previous->size);
d3353 2
d3423 3
a3425 2
	while (line != text->last_line &&
			HText_TrueEmptyLine(line, text, FALSE)) {
a3430 2
    } else if (AT_START_OF_CELL(text)) {
	newlines = 1;			/* New line to get a correct offset */
d3451 1
a3451 2
    if (!AT_START_OF_CELL(text))
	blank_lines(text, ((after > before) ? after : before));
a4033 2
	if (AT_START_OF_CELL(text))
	    return;
a4066 2
	if (AT_START_OF_CELL(text))
	    return;
d4621 1
a4842 66
/*	Remove trailing blank lines from the last cell.  */
PUBLIC int HText_trimCellLines ARGS1(
	HText *,	text)
{
    int ret = 0;
    HTLine *lastline;
#if defined(USE_COLOR_STYLE)
    HTStyleChange *laststyles;
#endif

    if (!(text && text->stbl))
	return 0;

    lastline = text->last_line;
#if defined(USE_COLOR_STYLE)
    laststyles = lastline->styles;
#endif
    while ( text->last_line && text->Lines >= 1
	    && HText_LastLineSize(text, FALSE) == 0 ) {
	/* Empty line should survive only if
	   a) It is a first line of a row;
	   b) This is not a fake row.
	   */
	if (Stbl_trimFakeRows(text->stbl, text->Lines, text->last_line->size))
	    ret++, HText_RemoveEmptyLastLine(text);
	else
	    break;
    }

    if (!ret)
	return 0;

#ifndef FIXME_FIXME_XXXX
    /* De-POOL the line */
    memcpy(lastline, text->last_line, LINE_SIZE(text->last_line->size));
#if defined(USE_COLOR_STYLE)
    /* De-POOL the style buffers */
    memcpy(laststyles, lastline->styles,
	   sizeof(HTStyleChange)*lastline->numstyles);
    lastline->styles = laststyles;
#endif

    if (text->last_line->next == text->last_line)
	lastline->next = lastline->prev = lastline;
    text->last_line = lastline;
    lastline->prev->next = lastline;	/* Link in new line */
    lastline->next->prev = lastline;	/* Could be same node of course */

#endif	/* FIXME_FIXME_XXXX */

    /* Fix global state for the last line */
    reset_cached_linedata(text, text->last_line->data,
			  text->last_line->size);
#if 0
    /* XXXX This is not enough.  Actually we need also to clear the
       me->in_word flag of HTML.c.  Since this is not
       possible, fake a real space. */
    text->LastChar = (text->last_line->size
		      ? text->last_line->data[text->last_line->size - 1]
		      : ' ');
#else
    HText_appendCharacter(text, ' ');
#endif
    return ret;
}

d4919 3
a4921 2
    if (me && me->stbl)
	Stbl_finishRowInTable(me->stbl);
a4956 1
    HText_trimCellLines(me);
d5668 1
d5851 3
d5857 1
a5857 1
			anchor_ptr->extent);
a8224 7
	if (HText_HaveUserChangedForms()) {
	    /*
	     * Issue a warning.  User forms content will be lost.
	     */
	    HTAlert(RELOADING_FORM);
	}

d8246 1
a8246 1
#ifdef SOURCE_CACHE
d8301 1
a8301 1
	if (HText_HaveUserChangedForms()) {
d8354 1
a8354 1
	if (HText_HaveUserChangedForms()) {
d8719 1
a8719 1
    if (!(text && text->Lines >= 1))	/* Lines is 0-based */
d8727 1
a8727 23
}

/*
 *  This function is for removing the last blank lines.
 *  It should be called after
 *  checking the situation with HText_LastLineSize().
 *  With POOLed allocation is should be wrapped into code restoring the
 *  expected POOLed/unPOOLed state of the line chain.
 */
PRIVATE void HText_RemoveEmptyLastLine ARGS1(
	HText *,	text)
{
    HTLine *line, *previous;

    if (!(text && text->Lines >= 1))	/* Lines is 0-based */
	return;

    line = text->last_line;
    previous = line->prev;
    previous->next = line->next;
    previous->next->prev = previous;
    text->last_line = previous;
    text->Lines--;
d9801 1
a9801 1
#ifndef EXP_FILE_UPLOAD
d10056 1
a10056 1
#ifdef EXP_FILE_UPLOAD
d10067 8
a10074 5
    if ((fd = fopen(val_used, BIN_R)) == 0) {
	HTAlert(gettext("Can't open file for uploading"));
    } else {
	while ((bytes = fread(buffer, sizeof(char), 256, fd)) != 0) {
	    HTSABCat(result, buffer, bytes);
a10075 1
	LYCloseInput(fd);
d10088 1
a10088 1
#endif /* EXP_FILE_UPLOAD */
d10674 1
a10674 1
#ifdef EXP_FILE_UPLOAD
d10866 1
a10866 1
#ifdef EXP_FILE_UPLOAD
d10870 1
a10870 1
#endif /* EXP_FILE_UPLOAD */
d10935 1
a10935 1
	        }
d11162 1
a11162 1
#ifdef EXP_FILE_UPLOAD
d11198 1
a11198 1
#endif /* EXP_FILE_UPLOAD */
d11339 2
a11340 1
PUBLIC BOOLEAN HText_HaveUserChangedForms NOARGS
d11344 1
a11344 1
    if (HTMainText == 0)
d11351 1
a11351 1
    for (anchor_ptr = HTMainText->first_anchor;
d12083 1
a12083 1
    if (mode == CHOP)
d12085 17
d12155 1
a12155 1
    POOLallocHTLine(l, MAX_LINE);
d12200 7
d12223 1
a12223 1
     *  link in the new HTLine and point the entry htline arg at it, too.
a12227 2
    htline->next->prev = l;
    htline->next       = l;
d12984 1
a12984 1
    POOLallocHTLine(l, MAX_LINE);
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@a789 1
    CTRACE((tfp, "FIXME text '%s'\n", result));
a808 1
    CTRACE((tfp, "FIXME cols '%d'\n", result));
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a6 1
#include <HTFont.h>
d13 1
a18 6
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
#include <syslog.h>
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */

d35 2
d44 1
a44 1
#undef DEBUG_APPCH
d58 1
a58 4
#ifdef USE_COLOR_STYLE_UNUSED
void LynxClearScreenCache NOARGS
{
    int i,j;
d60 9
a68 5
    CTRACE(tfp, "flushing cached screen styles\n");
    for (i=0;i<CACHEH;i++)
	for (j=0;j<CACHEW;j++)
	    cached_styles[i][j]=s_a;
}
d70 9
d82 1
a82 1
    int i,j;
d84 3
a86 3
    for (i=1; (i<CACHEH && i <= display_lines); i++) {
	for (j=0;j<CACHEW;j++)
	    cached_styles[i][j]=0;
d97 1
d99 5
a103 1
			  ((unsigned char)(ch)&0xc0) == 0x80)
d105 12
a116 3
extern BOOL HTPassHighCtrlRaw;
extern HTkcode kanji_code;
extern HTCJKlang HTCJK;
d139 2
a140 2
PUBLIC BOOLEAN underline_on = OFF;
PUBLIC BOOLEAN bold_on      = OFF;
a142 2
PUBLIC char * source_cache_filename = NULL;
PUBLIC HTChunk * source_cache_chunk = NULL;
d144 34
a177 1
PUBLIC BOOLEAN from_source_cache = FALSE;  /* mutable */
d180 6
d187 131
a317 1
#define MAX_STYLES_ON_LINE 64
d319 2
a320 7
typedef struct _stylechange {
	int	horizpos;	/* horizontal position of this change */
	int	style;		/* which style to change to */
	int	direction;	/* on or off */
	int	previous;	/* previous style */
} HTStyleChange;
#endif
d323 4
a326 7
	struct _line	*next;
	struct _line	*prev;
	unsigned	offset;		/* Implicit initial spaces */
	unsigned	size;		/* Number of characters */
	BOOL	split_after;		/* Can we split after? */
	BOOL	bullet;			/* Do we bullet? */
	BOOL	expansion_line;		/* TEXTAREA edit new line flag */
d328 2
a329 2
	HTStyleChange	styles[MAX_STYLES_ON_LINE];
	int	numstyles;
d331 1
a331 1
	char	data[1];		/* Space for terminator at least! */
d334 1
d337 14
d353 1
a354 3
	int			start;		/* Characters */
	int			line_pos;	/* Position in text */
	int			extent;		/* Characters */
d356 2
a357 5
	char *			hightext;	/* The link text */
	char *			hightext2;	/* A second line*/
	int			hightext2offset;/* offset from left */
	int			link_type;	/* Normal, internal, or form? */
	FormInfo *		input_field;	/* Info for form links */
d361 4
d368 1
a368 1
typedef struct _HTTabID {
d375 1
a375 1
**	next_line is valid if state is false.
d381 1
a381 17
#ifdef SOURCE_CACHE
#undef	lines			/* FIXME */
	char *			source_cache_file;
	HTChunk *		source_cache_chunk;
	/*
	 * Parse settings when this HText was generated.
	 */
	BOOLEAN			clickable_images;
	BOOLEAN			pseudo_inline_alts;
	BOOLEAN			raw_mode;
	BOOLEAN			historical_comments;
	BOOLEAN			minimal_comments;
	BOOLEAN			soft_dquotes;
	BOOLEAN			old_dtd;
	int			lines;		/* Screen size */
	int			cols;
#endif
d383 1
d385 1
a385 2
	int			chars;		/* Number of them */
	TextAnchor *		first_anchor;	/* Singly linked list */
d387 2
d410 2
d416 2
d420 10
d433 8
a440 8
				state;			/* Escape sequence? */
	int			kanji_buf;		/* Lead multibyte */
	int			in_sjis;		/* SJIS flag */
	int			halted;			/* emergency halt */

	BOOL			have_8bit_chars;   /* Any non-ASCII chars? */
	LYUCcharset *		UCI;		   /* node_anchor UCInfo */
	int			UCLYhndl;	   /* charset we are fed */
d443 21
a463 2
	HTStream *		target;			/* Output stream */
	HTStreamClass		targetClass;		/* Output routines */
d466 8
d476 65
d556 7
d565 1
a565 1
	{ 0,  "(Unstyled)", "",
d577 6
d588 2
a589 3
#ifndef VMS			/* VMS has a better way - right? - kw */
#define CHECK_FREE_MEM
#endif
d658 1
a658 1
	HText * t = HTList_objectAt(loaded_texts, i);
d661 1
a661 2
	{
	CTRACE(tfp, "\r *** Emergency freeing document %d/%d for '%s'%s!\n",
d668 1
a668 2
		     " with POST data" : ""));
	}
d694 108
a801 1
#define LY_CALLOC LY_check_calloc
d803 10
a812 1
#else  /* CHECK_FREE_MEM */
d814 9
a822 2
  /* using the regular calloc */
#define LY_CALLOC calloc
d824 11
a834 1
#endif /* CHECK_FREE_MEM */
d881 1
a881 1
    HText * self = (HText *) calloc(1, sizeof(*self));
d885 2
d889 1
a889 1
    CTRACE(tfp, "GridText: VMTotal = %d\n", VMTotal);
d892 16
d924 3
a926 1
	CTRACE(tfp, "GridText: Auto-uncaching\n") ;
d940 1
a940 1
	CTRACE(tfp, "GridText: Freeing off cached doc.\n");
d944 1
a944 1
	CTRACE(tfp, "GridText: VMTotal reduced to %d\n", VMTotal);
d948 2
a949 2
    line = self->last_line = (HTLine *)calloc(1, LINE_SIZE(MAX_LINE));
    if (line == NULL)
d951 2
d955 1
d958 1
d960 1
a960 1
    self->Lines = self->chars = 0;
d962 1
a971 14
     * Yes, this is a Gross And Disgusting Hack(TM), I know...
     */
    self->source_cache_file = NULL;
    if (LYCacheSource == SOURCE_CACHE_FILE && source_cache_filename) {
      StrAllocCopy(self->source_cache_file, source_cache_filename);
      FREE(source_cache_filename);
    }
    self->source_cache_chunk = NULL;
    if (LYCacheSource == SOURCE_CACHE_MEMORY && source_cache_chunk) {
	self->source_cache_chunk = source_cache_chunk;
	source_cache_chunk = NULL;
    }

    /*
d976 1
d982 3
a984 2
    self->lines = LYlines;
    self->cols = LYcols;
d996 2
a997 1
	(anchor->address && !strcmp(anchor->address, LYlist_temp_url())))
d1002 4
a1005 2
    self->no_cache = ((anchor->no_cache || anchor->post_data) ?
							  YES : NO);
d1009 1
a1009 1
#ifndef PSRC_TEST
d1015 7
a1021 1
    self->source=( LYpsrc ? psrc_view : HTOutputFormat == WWW_SOURCE);
d1029 6
d1046 1
a1046 1
     *  Check the kcode setting if the anchor has a charset element. - FM
d1048 2
a1049 3
    if (anchor->charset)
	HText_setKcode(self, anchor->charset,
		       HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT));
d1059 1
a1059 1
	 *  Create an array of dots for the UNDERSCORES macro. - FM
d1065 1
a1065 1
	 *  Create an array of underscores for the STARS macro. - FM
d1077 1
a1077 1
     * By this function we create HText object and set new Lines counter
d1080 4
a1083 2
    if (display_partial)
	 NumOfLines_partial = 0;  /* enable HTDisplayPartial() */
d1095 3
a1097 2
    CTRACE(tfp, "GridText: start HText_new\n");

a1128 20
    HTAnchor_setDocument(self->node_anchor, (HyperDoc *)0);

    while (YES) {	/* Free off line array */
	HTLine * l = self->last_line;
	if (l) {
	    l->next->prev = l->prev;
	    l->prev->next = l->next;	/* Unlink l */
	    self->last_line = l->prev;
	    if (l != self->last_line) {
		FREE(l);
	    } else {
		free(l);
	    }
	}
	if (l == self->last_line) {	/* empty */
	    l = self->last_line = NULL;
	    break;
	}
    }

a1176 2

	    FREE(l->input_field);
d1179 1
a1179 4
	FREE(l->hightext);
	FREE(l->hightext2);

	FREE(l);
d1184 1
a1184 1
     *  Free the tabs list. - FM
d1199 1
a1199 1
     *  Free the hidden links list. - FM
d1213 1
a1213 1
     *  if it is not a destination of other links. - FM
d1220 15
a1234 1
	if (HTAnchor_delete(self->node_anchor))
d1242 1
a1242 17
#ifdef SOURCE_CACHE
    /*
     * Clean up the source cache, if any.
     */
    if (self->source_cache_file) {
	CTRACE(tfp, "Removing source cache file %s\n",
	       self->source_cache_file);
	LYRemoveTemp(self->source_cache_file);
	FREE(self->source_cache_file);
    }
    if (self->source_cache_chunk) {
	CTRACE(tfp, "Removing memory source cache %p\n",
	       (void *)self->source_cache_chunk);
	HTChunkFree(self->source_cache_chunk);
    }
#endif

d1254 1
a1254 1
PRIVATE int display_line ARGS2(
d1256 3
a1258 1
	HText *,	text)
d1264 1
d1267 16
a1283 1
    char LastDisplayChar = ' ';
d1291 1
a1291 1
    clrtoeol();
d1298 2
a1299 2
    if (j > (int)LYcols - 1)
	j = (int)LYcols - 1;
d1310 1
a1310 1
	addch (' ');
d1319 54
a1372 1
    while ((i < LYcols) && ((buffer[0] = *data) != '\0')) {
d1381 2
a1382 2
		LynxChangeStyle (CStyle.style,CStyle.direction,CStyle.previous);
		current_style++;
d1390 1
a1390 1
		    addch('_');
d1393 11
a1403 1
		    start_underline();
d1409 1
a1409 1
		    addch('_');
d1412 8
d1421 2
d1427 3
a1429 1
		start_bold();
d1433 3
a1435 1
		stop_bold ();
d1441 1
a1441 1
		    addch('+');
d1443 3
d1451 1
a1451 1
		    isspace((unsigned char)LastDisplayChar) ||
d1461 1
a1461 1
		     *  split_line() in those cases. - FM
d1466 1
a1466 1
		     *  Make it a hard hyphen and fall through. - FM
a1468 1
		    i++;
d1470 1
d1473 13
d1487 3
a1489 23
		if (text->T.output_utf8 && !isascii(buffer[0])) {
		    if ((*buffer & 0xe0) == 0xc0) {
			utf_extra = 1;
		    } else if ((*buffer & 0xf0) == 0xe0) {
			utf_extra = 2;
		    } else if ((*buffer & 0xf8) == 0xf0) {
			utf_extra = 3;
		    } else if ((*buffer & 0xfc) == 0xf8) {
			utf_extra = 4;
		    } else if ((*buffer & 0xfe) == 0xfc) {
			utf_extra = 5;
		    } else {
			 /*
			  *  Garbage.
			  */
			utf_extra = 0;
		    }
		    if (strlen(data) < utf_extra) {
			/*
			 *  Shouldn't happen.
			 */
			utf_extra = 0;
		    }
d1495 1
a1495 1
		    addstr(buffer);
d1499 5
a1503 1
		} else if (HTCJK != NOCJK && !isascii(buffer[0])) {
d1507 2
d1510 1
d1512 2
a1513 1
		    addstr(buffer);
d1524 1
a1524 1
		     *  character handling is used. - FM
d1528 1
a1528 1
		    addstr(buffer);
d1534 7
d1544 1
a1544 1
    addch('\n');
d1546 6
d1558 1
a1558 1
	LynxChangeStyle (CStyle.style, CStyle.direction, CStyle.previous);
d1576 2
a1577 1
    int i = 0, j = 0;
d1580 1
a1580 1
     *  Make sure we have a text structure. - FM
d1589 1
a1589 1
	LynxChangeStyle(s_title, STACK_ON, 0);
d1591 1
a1591 1
	LynxChangeStyle(s_title, ABS_ON, 0);
d1596 1
a1596 1
     *  Load the title field. - FM
d1600 1
a1600 1
		  HTAnchor_title(text->node_anchor) : ""));
d1605 1
a1605 1
     *  any trailing spaces. - FM
d1616 9
a1624 1
    if ((text->Lines + 1) > (display_lines)) {
d1650 1
a1650 1
     *  and truncated if necessary. - FM & KW
d1654 1
a1654 1
	    (tmp = (unsigned char *)calloc(1, (strlen(title) + 1)))) {
d1671 23
a1693 4
    move(0, 0);
    clrtoeol();
    if (text->top_of_screen > 0 && HText_hasToolbar(text)) {
	addch('#');
d1695 4
a1698 3
    i = (LYcols - 1) - strlen(percent) - strlen(title);
    if (i > 0) {
	move(0, i);
d1701 2
a1702 3
	 *  Note that this truncation is not taking into
	 *  account the possibility that multibyte
	 *  characters might be present. - FM
d1704 10
a1713 2
	title[((LYcols - 2) - strlen(percent))] = '\0';
	move(0, 1);
d1715 1
a1715 1
    addstr(title);
d1717 2
a1718 2
	addstr(percent);
    addch('\n');
d1721 10
d1733 1
a1733 1
    LynxChangeStyle(s_title, STACK_OFF, 0);
d1740 117
d1867 1
a1867 1
#if defined(FANCY_CURSES) || defined(USE_SLANG)
d1873 1
d1893 3
a1895 3
	    addch('*');
	    refresh();
	    clear();
d1897 2
a1898 2
	addstr("\n\nError accessing document!\nNo data available!\n");
	refresh();
d1912 1
d1914 7
d1934 1
a1934 1
    for (i = 0, line = text->last_line->next;		/* Find line */
d1942 3
a1944 3
		addch('*');
		refresh();
		clear();
d1946 2
a1947 2
	    addstr("\n\nError drawing page!\nBad HText structure!\n");
	    refresh();
a1963 1
	charset_last_displayed = current_char_set;
a1964 1
#ifdef LINUX
a1969 1
#endif /* LINUX */
d1971 1
d1980 3
a1982 3
	addch('*');
	refresh();
	clear();
d1999 1
d2012 9
d2025 1
a2025 1
#if defined(FANCY_CURSES) || defined(USE_SLANG)
d2027 8
a2034 1
	int offset, HitOffset, LenNeeded;
d2045 3
a2047 3
		    addch('*');
		    refresh();
		    clear();
d2049 2
a2050 2
		addstr("\n\nError drawing page!\nBad HText structure!\n");
		refresh();
d2062 1
a2062 1
		move((i + 2), 0);
d2065 1
a2065 1
	    display_line(line, text);
d2067 2
a2068 1
#if defined(FANCY_CURSES) || defined(USE_SLANG)
d2071 1
a2071 1
	     *  seek and emphasize it. - FM
d2075 7
a2081 13
	    while ((target && *target) &&
		   (case_sensitive ?
		    (cp = LYno_attr_mbcs_strstr(data,
						target,
						text->T.output_utf8,
						&HitOffset,
						&LenNeeded)) != NULL :
		    (cp = LYno_attr_mbcs_case_strstr(data,
						     target,
						text->T.output_utf8,
						&HitOffset,
						&LenNeeded)) != NULL) &&
		   ((int)line->offset + LenNeeded) < LYcols) {
d2108 2
a2109 38
		    } else if (cp == &data[itmp]) {
			/*
			 *  First printable character of target.
			 */
			move((i + 1), x_pos);
			if (text->T.output_utf8 && !isascii(tmp[0])) {
			    if ((*tmp & 0xe0) == 0xc0) {
				utf_extra = 1;
			    } else if ((*tmp & 0xf0) == 0xe0) {
				utf_extra = 2;
			    } else if ((*tmp & 0xf8) == 0xf0) {
				utf_extra = 3;
			    } else if ((*tmp & 0xfc) == 0xf8) {
				utf_extra = 4;
			    } else if ((*tmp & 0xfe) == 0xfc) {
				utf_extra = 5;
			    } else {
				/*
				 *  Garbage.
				 */
				utf_extra = 0;
			    }
			    if (strlen(&line->data[itmp+1]) < utf_extra) {
				/*
				 *  Shouldn't happen.
				 */
				utf_extra = 0;
			    }
			}
			if (utf_extra) {
			    strncpy(&tmp[1], &line->data[itmp+1], utf_extra);
			    tmp[utf_extra+1] = '\0';
			    itmp += utf_extra;
			    addstr(tmp);
			    tmp[1] = '\0';
			    written += (utf_extra + 1);
			    utf_extra = 0;
			} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
d2111 1
a2111 1
			     *  For CJK strings, by Masanobu Kimura.
d2113 1
a2113 7
			    tmp[1] = data[++itmp];
			    addstr(tmp);
			    tmp[1] = '\0';
			    written += 2;
			} else {
			    addstr(tmp);
			    written++;
a2114 2

		    } else if (&data[itmp] > cp) {
d2116 1
a2116 1
			 *  Output all the other printable target chars.
d2118 1
a2118 24
			if (text->T.output_utf8 && !isascii(tmp[0])) {
			    if ((*tmp & 0xe0) == 0xc0) {
				utf_extra = 1;
			    } else if ((*tmp & 0xf0) == 0xe0) {
				utf_extra = 2;
			    } else if ((*tmp & 0xf8) == 0xf0) {
				utf_extra = 3;
			    } else if ((*tmp & 0xfc) == 0xf8) {
				utf_extra = 4;
			    } else if ((*tmp & 0xfe) == 0xfc) {
				utf_extra = 5;
			    } else {
				/*
				 *  Garbage.
				 */
				utf_extra = 0;
			    }
			    if (strlen(&line->data[itmp+1]) < utf_extra) {
				/*
				 *  Shouldn't happen.
				 */
				utf_extra = 0;
			    }
			}
d2123 1
a2123 1
			    addstr(tmp);
d2127 1
a2127 1
			} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
d2132 1
a2132 1
			    addstr(tmp);
d2136 1
a2136 1
			    addstr(tmp);
d2145 1
a2145 1
		 *  line. - FM
d2154 1
a2154 1
		 *  in it. - FM
d2156 1
a2156 1
		move((i + 2), 0);
d2158 2
a2159 1
#endif /* FANCY CURSES || USE_SLANG */
d2163 1
a2163 1
	     *  display_flag is set and process the next line. - FM
d2170 2
a2171 2
		    move((i + 1), 0);
		    clrtoeol();
d2196 7
a2202 3
    for (Anchor_ptr=text->first_anchor;  Anchor_ptr != NULL &&
		Anchor_ptr->line_num <= line_number+(display_lines);
					    Anchor_ptr = Anchor_ptr->next) {
a2203 2
	if (Anchor_ptr->line_num >= line_number &&
		Anchor_ptr->line_num < line_number+(display_lines)) {
d2207 16
a2222 7
	    if (Anchor_ptr->show_anchor && Anchor_ptr->hightext &&
			strlen(Anchor_ptr->hightext) > 0 &&
			(Anchor_ptr->link_type & HYPERTEXT_ANCHOR)) {

		links[nlinks].hightext	= Anchor_ptr->hightext;
		links[nlinks].hightext2 = Anchor_ptr->hightext2;
		links[nlinks].hightext2_offset = Anchor_ptr->hightext2offset;
d2228 1
a2228 2
		link_dest = HTAnchor_followMainLink(
					     (HTAnchor *)Anchor_ptr->anchor);
d2241 1
a2241 1
				(HTAnchor *)Anchor_ptr->anchor, LINK_INTERNAL);
d2244 3
a2246 3
				CTRACE(tfp,
				    "display_page: unexpected typed link to %s!\n",
					    link_dest_intl->parent->address);
d2273 1
a2273 1
		links[nlinks].form = NULL;
d2279 1
a2279 1
			&& Anchor_ptr->input_field->type != F_HIDDEN_TYPE) {
d2290 1
a2290 1
		links[nlinks].form = FormInfo_ptr;
d2299 4
a2302 5
		    if (FormInfo_ptr->num_value)
			links[nlinks].hightext = checked_radio;
		    else
			links[nlinks].hightext = unchecked_radio;

d2304 4
a2307 5
		    if (FormInfo_ptr->num_value)
			links[nlinks].hightext = checked_box;
		    else
			links[nlinks].hightext = unchecked_box;

d2309 2
a2310 2
		    links[nlinks].hightext = STARS(strlen(FormInfo_ptr->value));

d2312 2
a2313 1
		    links[nlinks].hightext = FormInfo_ptr->value;
a2315 6
		/*
		 *  Never a second line on form types.
		 */
		links[nlinks].hightext2 = NULL;
		links[nlinks].hightext2_offset = 0;

d2320 1
a2320 1
		highlight(OFF, (nlinks - 1), target);
d2328 2
a2329 2
		if (Anchor_ptr->hightext && *Anchor_ptr->hightext)
		    CTRACE(tfp,
d2331 1
a2331 1
			    Anchor_ptr->hightext);
a2334 6
	if (Anchor_ptr == text->last_anchor)
	    /*
	     *  No more links in document. - FM
	     */
	    break;

d2338 1
a2338 1
	     *  to use half-page or two-line scrolling. - FM
d2343 1
a2343 1
	    CTRACE(tfp, "\ndisplay_page: MAXLINKS reached.\n");
d2350 1
a2350 1
     *  from the previous page draw. - FM
d2352 2
a2353 1
    for (i = nlinks; i < last_nlinks; i++)
d2355 1
d2373 1
a2373 1
	addstr("\n     Document is empty");
d2375 1
d2390 9
a2398 1
    if (HTCJK != NOCJK || text->T.output_utf8) {
d2401 4
d2406 1
a2406 1
	lynx_force_repaint();
d2408 1
a2408 1
    refresh();
d2410 1
d2428 20
d2467 272
a2743 1
    HTLine * temp;
a2744 3
#if defined(USE_COLOR_STYLE)
    int inew;
#endif
d2747 1
d2753 8
a2760 1
    int s;
a2761 1
#define DEBUG_SPLITLINE
d2763 1
a2763 1
     *  Make new line.
d2765 4
a2768 5
    HTLine * previous = text->last_line;
    int ctrl_chars_on_previous_line = 0;
    char * cp;
    /* can't wrap in middle of multibyte sequences, so allocate 2 extra */
    HTLine * line = (HTLine *)LY_CALLOC(1, LINE_SIZE(MAX_LINE)+2);
d2770 2
a2771 1
	outofmem(__FILE__, "split_line_1");
d2774 1
d2778 2
a2779 2
    CTRACE(tfp,"GridText: split_line(%p,%d) called\n", text, split);
    CTRACE(tfp,"   bold_on=%d, underline_on=%d\n", bold_on, underline_on);
d2782 19
d2802 1
a2802 1
	CTRACE(tfp,
d2804 1
a2804 1
	       split, previous->size);
d2810 1
a2810 1
	    CTRACE(tfp, "                split adjusted to %d.\n", split);
d2826 15
a2840 5
    /*
     *  If we are not splitting and need an underline char, add it now. - FM
     */
    if ((split < 1) &&
	!(dump_output_immediately && use_underscore) && underline_on) {
d2844 1
d2846 1
a2846 4
    /*
     *  If we are not splitting and need a bold char, add it now. - FM
     */
    if ((split < 1) && bold_on) {
d2850 1
d2857 1
a2857 1
	char *p, *prevdata = previous->data, *linedata = line->data;
a2858 1
	int i;
d2860 1
a2860 3
	/*
	 *  Split the line. - FM
	 */
d2866 1
a2866 1
	 *  of our new line. - FM
d2869 16
a2884 7
	while ((*p == ' ' &&
		(HeadTrim || text->first_anchor ||
		 underline_on || bold_on ||
		 text->style->alignment != HT_LEFT ||
		 text->style->wordWrap || text->style->freeFormat ||
		 text->style->spaceBefore || text->style->spaceAfter)) ||
	       *p == LY_SOFT_HYPHEN) {
d2888 1
d2890 8
d2899 29
a2927 99
	/*
	 *  Add underline char if needed. - FM
	 */
	if (!(dump_output_immediately && use_underscore)) {
	    /*
	     * Make sure our global flag is correct. - FM
	     */
	    underline_on = NO;
	    for (i = (split-1); i >= 0; i--) {
		if (prevdata[i] == LY_UNDERLINE_END_CHAR) {
		    break;
		}
		if (prevdata[i] == LY_UNDERLINE_START_CHAR) {
		    underline_on = YES;
		    break;
		}
	    }
	    /*
	     *  Act on the global flag if set above. - FM
	     */
	    if (underline_on && *p != LY_UNDERLINE_END_CHAR) {
		linedata[line->size++] = LY_UNDERLINE_START_CHAR;
		linedata[line->size] = '\0';
		ctrl_chars_on_this_line++;
		SpecialAttrChars++;
	    }
	    if (plen) {
		for (i = (plen - 1); i >= 0; i--) {
		    if (p[i] == LY_UNDERLINE_START_CHAR) {
			underline_on = YES;
			break;
		    }
		    if (p[i] == LY_UNDERLINE_END_CHAR) {
			underline_on = NO;
			break;
		    }
		}
		for (i = (plen - 1); i >= 0; i--) {
		    if (p[i] == LY_UNDERLINE_START_CHAR ||
			p[i] == LY_UNDERLINE_END_CHAR) {
			ctrl_chars_on_this_line++;
		    }
		}
	    }
	}

	/*
	 *  Add bold char if needed, first making
	 *  sure that our global flag is correct. - FM
	 */
	bold_on = NO;
	for (i = (split - 1); i >= 0; i--) {
	    if (prevdata[i] == LY_BOLD_END_CHAR) {
		break;
	    }
	    if (prevdata[i] == LY_BOLD_START_CHAR) {
		bold_on = YES;
		break;
	    }
	}
	/*
	 *  Act on the global flag if set above. - FM
	 */
	if (bold_on && *p != LY_BOLD_END_CHAR) {
	    linedata[line->size++] = LY_BOLD_START_CHAR;
	    linedata[line->size] = '\0';
	    ctrl_chars_on_this_line++;
	    SpecialAttrChars++;
	}
	if (plen) {
	    for (i = (plen - 1); i >= 0; i--) {
		if (p[i] == LY_BOLD_START_CHAR) {
		    bold_on = YES;
		    break;
		}
		if (p[i] == LY_BOLD_END_CHAR) {
		    bold_on = NO;
		    break;
		}
	    }
	    for (i = (plen - 1); i >= 0; i--) {
		if (p[i] == LY_BOLD_START_CHAR ||
		    p[i] == LY_BOLD_END_CHAR ||
		    IS_UTF_EXTRA(p[i]) ||
		    p[i] == LY_SOFT_HYPHEN) {
		    ctrl_chars_on_this_line++;
		}
		if (p[i] == LY_SOFT_HYPHEN && (int)text->permissible_split < i) {
		    text->permissible_split = i + 1;
		}
	    }
	}

	/*
	 *  Add the data to the new line. - FM
	 */
	strcat(linedata, p);
	line->size += plen;
    }
a2929 17
     *  Economize on space.
     */
    while ((previous->size > 0) &&
	   (previous->data[previous->size-1] == ' ') &&
	   (ctrl_chars_on_this_line || HeadTrim || text->first_anchor ||
	    underline_on || bold_on ||
	    text->style->alignment != HT_LEFT ||
	    text->style->wordWrap || text->style->freeFormat ||
	    text->style->spaceBefore || text->style->spaceAfter)) {
	/*
	 *  Strip trailers.
	 */
	previous->data[previous->size-1] = '\0';
	previous->size--;
	TailTrim++;
    }
    /*
d2939 3
d2946 1
a2946 1
	CTRACE(tfp,"GridText: split_line(%d [now:%d]) called\n", split, s);
d2950 4
a2953 1
#define LastStyle (previous->numstyles-1)
d2955 17
a2971 117
    inew = MAX_STYLES_ON_LINE - 1;
    /*
     *  Color style changes after the split position + possible trimmed
     *  head characters are transferred to the new line.  Ditto for changes
     *  within the trimming region, but be stop when we reach an OFF change.
     *  The second while loop below may then handle remaining changes. - kw
     */
    while (previous->numstyles && inew >= 0) {
	if (previous->styles[LastStyle].horizpos > s + HeadTrim) {
	    line->styles[inew].horizpos =
		previous->styles[LastStyle].horizpos
		- (s + HeadTrim) + SpecialAttrChars;
	    line->styles[inew].direction = previous->styles[LastStyle].direction;
	    line->styles[inew].style = previous->styles[LastStyle].style;
	    inew --;
	    line->numstyles ++;
	    previous->numstyles --;
	} else if (previous->styles[LastStyle].horizpos > s - TailTrim &&
		   (previous->styles[LastStyle].direction == STACK_ON ||
		    previous->styles[LastStyle].direction == ABS_ON)) {
	    line->styles[inew].horizpos =
		(previous->styles[LastStyle].horizpos < s) ?
		0 : SpecialAttrChars;
	    line->styles[inew].direction = previous->styles[LastStyle].direction;
	    line->styles[inew].style = previous->styles[LastStyle].style;
	    inew --;
	    line->numstyles ++;
	    previous->numstyles --;
	} else
	    break;
    }
    spare = previous->numstyles;
    while (previous->numstyles && inew >= 0) {
	if (previous->numstyles >= 2 &&
	    previous->styles[LastStyle].style
	    == previous->styles[previous->numstyles-2].style &&
	    previous->styles[LastStyle].horizpos
	    == previous->styles[previous->numstyles-2].horizpos &&
	    ((previous->styles[LastStyle].direction == STACK_OFF &&
	      previous->styles[previous->numstyles-2].direction == STACK_ON) ||
	     (previous->styles[LastStyle].direction == ABS_OFF &&
	      previous->styles[previous->numstyles-2].direction == ABS_ON) ||
	     (previous->styles[LastStyle].direction == ABS_ON &&
	      previous->styles[previous->numstyles-2].direction == ABS_OFF)
		)) {
	    /*
	     *  Discard pairs of ON/OFF for the same color style, but only
	     *  if they appear at the same position. - kw
	     */
	    previous->numstyles -= 2;
	    if (spare > previous->numstyles)
		spare = previous->numstyles;
	} else if (spare > 0 && previous->styles[spare - 1].direction &&
		   previous->numstyles < MAX_STYLES_ON_LINE) {
	    /*
	     *  The index variable spare walks backwards through the
	     *  list of color style changes on the previous line, trying
	     *  to find an ON change which isn't followed by a
	     *  corresponding OFF.  When it finds one, the missing OFF
	     *  change is appended to the end, and an ON change is added
	     *  at the beginning of the current line.  The OFF change
	     *  appended to the previous line may get removed again in
	     *  the next iteration. - kw
	     */
	    line->styles[inew].horizpos = 0;
	    line->styles[inew].direction = ON;
	    line->styles[inew].style = previous->styles[spare - 1].style;
	    inew --;
	    line->numstyles ++;
	    previous->styles[previous->numstyles].style = line->styles[inew + 1].style;

	    previous->styles[previous->numstyles].direction = ABS_OFF;
	    previous->styles[previous->numstyles].horizpos = previous->size;
	    previous->numstyles++;
	    spare --;
	} else if (spare >= 2 &&
		   previous->styles[spare - 1].style == previous->styles[spare - 2].style &&
		   ((previous->styles[spare - 1].direction == STACK_OFF &&
		     previous->styles[spare - 2].direction == STACK_ON) ||
		    (previous->styles[spare - 1].direction == ABS_OFF &&
		     previous->styles[spare - 2].direction == ABS_ON) ||
		    (previous->styles[spare - 1].direction == STACK_ON &&
		     previous->styles[spare - 2].direction == STACK_OFF) ||
		    (previous->styles[spare - 1].direction == ABS_ON &&
		     previous->styles[spare - 2].direction == ABS_OFF)
		       )) {
	       /*
		*  Skip pairs of adjacent ON/OFF or OFF/ON changes.
		*/
	    spare -= 2;
	} else if (spare && !previous->styles[spare - 1].direction) {
	    /*
	     *  Found an OFF change not part of an adjacent matched pair.
	     *  Walk backward looking for the corresponding ON change.
	     *  If we find it, skip the ON/OFF and everything in between.
	     *  This can only work correctly if all changes are correctly
	     *  nested!  If this fails, assume it is safer to leave whatever
	     *  comes before the OFF on the previous line alone.  Setting
	     *  spare to 0 ensures that it won't be used in a following
	     *  iteration. - kw
	     */
	    int level=-1;
	    int itmp;
	    for (itmp = spare-1; itmp > 0; itmp--) {
		if (previous->styles[itmp - 1].style
		    == previous->styles[spare - 1].style) {
		    if (previous->styles[itmp - 1].direction == STACK_OFF) {
			level--;
		    } else if (previous->styles[itmp - 1].direction == STACK_ON) {
			if (++level == 0)
			    break;
		    } else
			break;
		}
	    }
	    if (level == 0)
		spare = itmp - 1;
d2973 3
a2975 6
		spare = 0;
	} else {
	    /*
	     *  Nothing applied, so we are done with the loop. - kw
	     */
	    break;
d2977 2
a2978 2
    }
    if (previous->numstyles > 0 && previous->styles[LastStyle].direction) {
d2980 64
a3043 3
	CTRACE(tfp, "%s\n%s%s\n",
		    "........... Too many character styles on line:",
		    "........... ", previous->data);
a3044 11
    if (line->numstyles > 0 && line->numstyles < MAX_STYLES_ON_LINE) {
	int n;
	inew ++;
	for (n = 0; n < line->numstyles; n++)
		line->styles[n] = line->styles[n + inew];
    } else
	if (line->numstyles == 0)
	/* FIXME: RJP - shouldn't use 0xffffffff for largest integer */
	line->styles[0].horizpos = 0xffffffff;
    if (previous->numstyles == 0)
	previous->styles[0].horizpos = 0xffffffff;
d3047 4
a3050 2
    temp = (HTLine *)LY_CALLOC(1, LINE_SIZE(previous->size));
    if (temp == NULL)
d3053 6
a3058 1
    FREE(previous);
d3060 1
d3074 6
a3079 2
    if (style->alignment == HT_CENTER ||
	style->alignment == HT_RIGHT) {
d3087 1
a3087 1
		*cp == LY_SOFT_HYPHEN)
d3089 1
d3091 4
d3096 1
a3096 1
	spare =  (LYcols-1) -
d3098 49
a3146 5
	    ctrl_chars_on_previous_line - previous->size -
	    ((previous->size > 0) &&
	     (int)(previous->data[previous->size-1] ==
		   LY_SOFT_HYPHEN ?
		   1 : 0));
d3163 17
a3179 1
    text->chars = text->chars + previous->size + 1;	/* 1 for the line */
d3184 1
a3184 1
     *  structure values for the new line. - FM
d3187 16
a3202 3
    if (split > 0 || s > 0) {		/* if not completely empty */
	TextAnchor * prev_a = NULL;
	for (a = text->first_anchor; a; prev_a = a, a = a->next) {
d3204 22
a3225 8
		int old_e = a->extent;
		int a0 = a->line_pos, a1 = a->line_pos + a->extent;
		int S, d, new_pos, new_ext;
		if (a->link_type == INPUT_ANCHOR) {
		    if (a->line_pos >= s) {
			a->start += (1 + SpecialAttrChars - HeadTrim - TailTrim);
			a->line_pos -= (s - SpecialAttrChars + HeadTrim);
			a->line_num = text->Lines;
d3228 6
a3234 68
		if (a0 < s - TailTrim && a1 <= s - TailTrim) {
		    continue;	/* unaffected, leave it where it is. */
		}
		S = s + a->start - a->line_pos;
		d = S - s;	/* == a->start - a->line_pos */
		new_ext = old_e = a->extent;

		if (!old_e &&
		    (!a->number || a->show_anchor) &&
		    a0 <= s + HeadTrim) {
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "anchor %d case %d: ",
		       a->number,1);
#endif
		    /*
		     *  It is meant to be empty, and/or endAnchor
		     *  has seen it and recognized it as empty.
		     */
		    new_pos = (a0 <= s) ? s - TailTrim :
			s - TailTrim + 1;
		    if (prev_a && new_pos + d < prev_a->start) {
			if (prev_a->start <= S - TailTrim + 1 + SpecialAttrChars)
			    new_pos = prev_a->start - d;
			else
			    new_pos = s - TailTrim + 1 + SpecialAttrChars;
		    }
		} else if (old_e &&
		     a0 >= s - TailTrim && a0 <= s + HeadTrim &&
		     a1 <= s + HeadTrim) {
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "anchor %d case %d: ",
		       a->number,2);
#endif
		    /*
		     *  endAnchor has seen it, it is effectively empty
		     *  after our trimming, but endAnchor has for some
		     *  reason not recognized this.  In other words,
		     *  this should not happen.
		     *  Should we not adjust the extent and let it "leak"
		     *  into the new line?
		     */
		    new_pos = (a0 < s) ? s - TailTrim :
			s - TailTrim + 1;
		    if (prev_a && new_pos + d < prev_a->start) {
			if (prev_a->start <= S - TailTrim + 1 + SpecialAttrChars)
			    new_pos = prev_a->start - d;
			else
			    new_pos = s - TailTrim + 1 + SpecialAttrChars;
		    }
		    new_ext = 0;
		} else if (a0 >= s + HeadTrim) {
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "anchor %d case %d: ",
		       a->number,3);
#endif
		    /*
		     *  Completely after split, just shift.
		     */
		    new_pos = a0 - TailTrim + 1 - HeadTrim + SpecialAttrChars;
		} else if (!old_e) {
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "anchor %d case %d: ",
		       a->number,4);
#endif
		    /*
		     *  No extent set, we may still be growing it.
		     */
		    new_pos = s - TailTrim + 1 + SpecialAttrChars;
d3236 61
a3296 55
		    /*
		     *  Ok, it's neither empty, nor is it completely
		     *  before or after the split region (including trimmed
		     *  stuff).  So the anchor is either being split in
		     *  the middle, with stuff remaining on both lines,
		     *  or something is being nibbled off, either at
		     *  the end (anchor stays on previous line) or at
		     *  the beginning (anchor is on new line).  Let's
		     *  try in that order.
		     */
		} else if (a0 < s - TailTrim &&
			   a1 > s + HeadTrim) {
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "anchor %d case %d: ",
		       a->number,5);
#endif
		    new_pos = a0;
		    new_ext = old_e - TailTrim - HeadTrim + SpecialAttrChars;
		} else if (a0 < s - TailTrim) {
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "anchor %d case %d: ",
		       a->number,6);
#endif
		    new_pos = a0;
		    new_ext = s - TailTrim - a0;
		} else if (a1 > s + HeadTrim) {
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "anchor %d case %d: ",
		       a->number,7);
#endif
		    new_pos = s - TailTrim + 1 + SpecialAttrChars;
		    new_ext = old_e - (s + HeadTrim - a0);
		} else {
		    CTRACE(tfp, "split_line anchor %d line %d: This should not happen!\n",
			   a->number, a->line_num);
		    CTRACE(tfp,
			   "anchor %d: (T,H,S)=(%d,%d,%d); (line,start,pos,ext):(%d,%d,%d,%d)!\n",
			   a->number,
			   TailTrim,HeadTrim,SpecialAttrChars,
			   a->line_num,a->start,a->line_pos,a->extent);
		    continue;
		}
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "(T,H,S)=(%d,%d,%d); (line,start,pos,ext):(%d,%d,%d,%d",
		       TailTrim,HeadTrim,SpecialAttrChars,
		       a->line_num,a->start,a->line_pos,a->extent);
#endif
		if (new_pos != a->line_pos)
		    a->start = new_pos + d;
		if (new_pos > s - TailTrim) {
		    new_pos -= s - TailTrim + 1;
		    a->line_num = text->Lines;
		}
		a->line_pos = new_pos;
		a->extent = new_ext;
d3298 31
a3328 4
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, ")->(%d,%d,%d,%d)\n",
		       a->line_num,a->start,a->line_pos,a->extent);
#endif
d3330 20
d3352 40
a3391 1
    }
d3402 8
a3409 1
    BOOL IgnoreSpaces = FALSE;
d3411 2
a3412 4
    if (!HText_LastLineSize(text, IgnoreSpaces)) { /* No text on current line */
	HTLine * line = text->last_line->prev;
	while ((line != text->last_line) &&
	       (HText_TrueLineSize(line, text, IgnoreSpaces) == 0)) {
d3418 2
d3440 2
a3441 1
    blank_lines(text, ((after > before) ? after : before));
d3461 1
a3461 1
    CTRACE(tfp, "GridText: Change to style %s\n", style->name);
d3473 1
a3473 1
	char,		ch)
d3478 2
d3482 4
d3519 2
a3520 2
	    CTRACE(tfp, "add(%s %d special char) %d/%d\n", special, ch,
		   HTisDocumentSource(), HTOutputFormat != WWW_SOURCE);
d3522 22
a3543 2
	    CTRACE(tfp, "add(%c) %d/%d\n", ch,
		   HTisDocumentSource(), HTOutputFormat != WWW_SOURCE);
d3573 97
d3673 1
a3673 1
    if (ch == CH_ESC && HTCJK == NOCJK)			/* decimal 27  S/390 -- gil -- 1504 */
d3675 1
d3686 1
a3686 1
    if ((unsigned char)ch >= 128 && HTCJK == NOCJK &&
d3688 1
a3688 1
	(unsigned char)ch < LYlowest_eightbit[current_char_set])
d3690 1
d3693 1
a3693 1
    if ((unsigned char)ch == 155 && HTCJK == NOCJK) {	/* octal 233 */
d3712 1
a3712 1
		    **  Takuya ASADA's (asada@@three-a.co.jp) CJK Lynx). - FM
d3720 1
a3720 1
		case S_esc:
d3733 1
d3735 1
a3735 1
		case S_dollar:
d3741 2
d3752 1
a3752 1
		case S_dollar_paren:
d3764 1
a3764 1
		case S_paren:
d3770 1
a3770 1
		     *  Can split here. - FM
d3778 1
a3778 1
		     *  Can split here. - FM
d3781 1
d3788 1
a3788 1
		case S_nonascii_text:
d3795 3
d3799 6
d3813 1
a3813 1
		case S_jisx0201_text:
d3817 1
d3824 1
a3824 1
	}
d3831 22
a3852 5
		if ((text->kcode == SJIS) &&
		    ((unsigned char)ch >= 0xA1) &&
		    ((unsigned char)ch <= 0xDF)) {
		    unsigned char c = (unsigned char)ch;
		    unsigned char kb = (unsigned char)text->kanji_buf;
d3858 3
d3864 1
a3864 1
		     *  Can split here. - FM
d3871 1
a3871 1
	    goto check_IgnoreExcess;
d3877 9
d3887 7
a3893 2
#ifndef USE_COLOR_STYLE
	if (line->size >= (MAX_LINE-1)) return;
d3926 1
a3926 1
	     *  hyphen. - FM
d3928 1
a3928 1
	    if (line->size < 1 || text->permissible_split >= line->size)
d3930 1
d3933 5
a3937 5
		if (!IsSpecialAttrChar((unsigned char)line->data[i]) &&
		    !isspace((unsigned char)line->data[i]) &&
		    (unsigned char)line->data[i] != '-' &&
		    (unsigned char)line->data[i] != HT_NON_BREAK_SPACE &&
		    (unsigned char)line->data[i] != HT_EN_SPACE) {
d3945 7
d3961 57
a4017 5
    if (IS_UTF_EXTRA(ch)) {
	line->data[line->size++] = ch;
	line->data[line->size] = '\0';
	ctrl_chars_on_this_line++;
	return;
d4024 1
a4024 8
	    new_line(text);
	    text->in_line_1 = YES;	/* First line of new paragraph */
	    /*
	     *  There are some pages written in
	     *  different kanji codes. - TA & kw
	     */
	    if (HTCJK == JAPANESE)
		text->kcode = NOKANJI;
d4026 9
d4043 9
d4059 2
a4071 1

d4077 2
a4078 2
	int target;	/* Where to tab to */
	int here;
d4083 1
a4083 1
	     *  if one does, we'll dump the soft hyphen. - FM
d4090 1
d4118 6
a4123 1
	if (target > (LYcols-1) - (int)style->rightIndent &&
d4128 1
a4128 1
	     *  Can split here. - FM
d4131 2
d4145 3
a4147 1
    else {
d4152 9
a4160 3
	int target = (int)(line->offset + line->size);
	if ((target >= (LYcols-1) - style->rightIndent) &&
		HTisDocumentSource()) {
d4163 5
d4169 2
d4176 1
a4176 1
	 *  Can split here. - FM
d4190 26
a4215 5
check_IgnoreExcess:
    if (text->IgnoreExcess &&
	((indent + (int)line->offset + (int)line->size) +
	(int)style->rightIndent - ctrl_chars_on_this_line) >= (LYcols-1))
	return;
d4220 9
a4228 1
    if (((indent + (int)line->offset + (int)line->size) +
d4230 5
a4234 4
	 ((line->size > 0) &&
	  (int)(line->data[line->size-1] ==
				LY_SOFT_HYPHEN ?
					     1 : 0))) >= (LYcols - 1)) {
d4237 4
d4242 3
a4244 1
	    if (ch == ' ') return;	/* Ignore space causing split */
d4246 11
a4256 10
	}  else if (HTOutputFormat == WWW_SOURCE) {
		 /*
		  *  For source output we don't want to wrap this stuff
		  *  unless absolutely necessary. - LJM
		  *  !
		  *  If we don't wrap here we might get a segmentation fault.
		  *  but let's see what happens
		  */
		if ((int)line->size >= (int)(MAX_LINE-1))
		   new_line(text);  /* try not to linewrap */
d4258 10
a4267 4
		/*
		 *  For normal stuff like pre let's go ahead and
		 *  wrap so the user can see all of the text.
		 */
d4269 1
d4273 1
a4273 1
	 *  Never overrun memory if LYcols is set to a large value - KW
d4281 5
a4285 1
    if (ch == HT_NON_BREAK_SPACE) {
d4287 6
a4292 1
    }
d4297 3
d4305 1
d4307 76
a4382 8
	    hi = (unsigned char)text->kanji_buf, lo = (unsigned char)ch;
	    if (HTCJK == JAPANESE && text->kcode == NOKANJI) {
		if (IS_SJIS(hi, lo, text->in_sjis) && IS_EUC(hi, lo)) {
		    text->kcode = NOKANJI;
		} else if (IS_SJIS(hi, lo, text->in_sjis)) {
		    text->kcode = SJIS;
		} else if (IS_EUC(hi, lo)) {
		    text->kcode = EUC;
a4383 16
	    }
	    if (HTCJK == JAPANESE &&
		(kanji_code == EUC) && (text->kcode == SJIS)) {
		SJIS_TO_EUC1(hi, lo, tmp);
		line->data[line->size++] = tmp[0];
		line->data[line->size++] = tmp[1];
	    } else if (HTCJK == JAPANESE &&
		       (kanji_code == EUC) && (text->kcode == EUC)) {
		JISx0201TO0208_EUC(hi, lo, &hi, &lo);
		line->data[line->size++] = hi;
		line->data[line->size++] = lo;
	    } else if (HTCJK == JAPANESE &&
		       (kanji_code == SJIS) && (text->kcode == EUC)) {
		EUC_TO_SJIS1(hi, lo, tmp);
		line->data[line->size++] = tmp[0];
		line->data[line->size++] = tmp[1];
d4389 11
a4399 2
	} else if (HTCJK != NOCJK) {
	    line->data[line->size++] = (kanji_code != NOKANJI) ?
d4402 1
a4402 1
						   TOUPPER(ch) : ch;
d4405 1
a4405 1
		font & HT_CAPITALS ? TOUPPER(ch) : ch;
d4415 1
a4415 1
	     *  Can split here. - FM
d4423 1
d4437 507
a4943 7
	line = text->last_line;

	if (line->numstyles < MAX_STYLES_ON_LINE) {
	    line->styles[line->numstyles].horizpos  = line->size;
	    line->styles[line->numstyles].style     = style;
	    line->styles[line->numstyles].direction = dir;
	    line->numstyles++;
d4945 4
d4950 3
a4952 1
}
d4955 2
d4958 2
d4961 1
a4961 2
/*	Set LastChar element in the text object.
**	----------------------------------------
d4963 3
a4965 3
PUBLIC void HText_setLastChar ARGS2(
	HText *,	text,
	char,		ch)
d4967 1
a4967 1
    if (!text)
d4969 12
d4982 24
a5005 1
    text->LastChar = ch;
d5008 1
a5008 2
/*	Get LastChar element in the text object.
**	----------------------------------------
d5010 2
a5011 2
PUBLIC char HText_getLastChar ARGS1(
	HText *,	text)
d5013 7
a5019 2
    if (!text)
	return('\0');
d5021 18
a5038 1
    return((char)text->LastChar);
d5041 1
a5041 2
/*	Set IgnoreExcess element in the text object.
**	--------------------------------------------
d5043 2
a5044 3
PUBLIC void HText_setIgnoreExcess ARGS2(
	HText *,	text,
	BOOL,		ignore)
d5046 1
a5046 1
    if (!text)
d5048 3
d5052 10
a5061 1
    text->IgnoreExcess = ignore;
d5067 27
d5102 1
a5102 3
    char marker[32];

    TextAnchor * a = (TextAnchor *) calloc(1, sizeof(*a));
d5104 1
a5106 3
    a->hightext  = NULL;
    a->hightext2 = NULL;
    a->start = text->chars + text->last_line->size;
d5123 1
a5123 1
    if (HTAnchor_followTypedLink((HTAnchor*)anc, LINK_INTERNAL)) {
d5128 1
a5128 1
	if (HTAnchor_followMainLink((HTAnchor*)anc)) {
d5134 2
a5135 17
    /*
     *  If we are doing link_numbering add the link number.
     */
    if ((a->number > 0) &&
	(keypad_mode == LINKS_ARE_NUMBERED ||
	 keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED)) {
	char saved_lastchar = text->LastChar;
	int saved_linenum = text->Lines;
	sprintf(marker,"[%d]", a->number);
	HText_appendText(text, marker);
	if (saved_linenum && text->Lines && saved_lastchar != ' ')
	    text->LastChar = ']'; /* if marker not after space caused split */
	a->start = text->chars + text->last_line->size;
	a->line_num = text->Lines;
	a->line_pos = text->last_line->size;
    }

d5139 2
a5140 2

PUBLIC void HText_endAnchor ARGS2(
d5142 2
a5143 1
	int,		number)
d5155 1
a5155 1
     *  within which that link might be embedded. - FM
d5169 1
a5169 1
	     *  and cross our fingers. - FM
d5175 2
a5176 2
    CTRACE(tfp, "HText_endAnchor: number:%d link_type:%d\n",
			a->number, a->link_type);
d5182 3
a5184 3
	CTRACE(tfp,
	   "HText_endAnchor: internal error: last anchor was input field!\n");
	return;
d5186 1
d5192 2
a5193 3
	BOOL remove_numbers_on_empty =
	    ((keypad_mode == LINKS_ARE_NUMBERED ||
	      keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) &&
d5198 1
a5198 1
		   HTAnchor_followMainLink((HTAnchor *)a->anchor)))));
d5204 12
d5220 1
a5220 1
	 *  with the content on the last line. - FM
d5222 1
a5222 2
	a->extent += (text->chars + last->size) - a->start -
		     (text->Lines - a->line_num);
d5226 1
a5226 1
	     *  so set up to check the entire last line. - FM
d5232 1
a5232 1
	     *  so check from the start of the anchor. - FM
d5239 1
a5239 1
		!isspace((unsigned char)last->data[j]) &&
d5252 1
a5252 1
		 *  of the last line as blank. - FM
d5259 1
a5259 1
		 *  declare the anchor's extent as blank. - FM
d5270 1
a5270 1
	 *  white and special characters. - FM
d5284 1
a5284 1
		 *  so check all of this line. - FM
d5290 1
a5290 1
		 *  The anchor starts on this line. - FM
d5296 1
a5296 1
		    !isspace((unsigned char)prev->data[j]) &&
d5314 1
a5314 1
		     *  the line to be analyzed. - FM
d5323 1
a5323 1
		     *  declare the anchor's extent as blank. - FM
d5330 4
d5338 1
a5338 1
	     *  USEMAP. - FM
d5342 4
a5345 4
	    CTRACE(tfp,
		   "HText_endAnchor: hidden (line,start,pos,ext,BlankExtent):(%d,%d,%d,%d,%d)",
		   a->line_num,a->start,a->line_pos,a->extent,
		   BlankExtent);
d5349 1
a5349 1
	     *  numbered bracket and adjust the anchor count. - FM
d5366 1
a5366 1
		 *  anchor start. - FM
d5370 1
a5370 1
		     *  The anchor starts on the last line. - FM
d5375 1
a5375 1
		     *  The anchor starts on a previous line. - FM
d5391 1
a5391 1
		 *  from that line. - FM
d5396 1
a5396 1
		    while (j >= 0 && isdigit((unsigned char)start->data[j])) {
d5407 1
a5407 1
			 *  on this line. - FM
a5418 2
			if (start != last)
			    text->chars -= NumSize;
a5419 1
			    anc->start -= NumSize;
d5422 1
a5422 1
			    anc->line_pos -= NumSize;
d5436 1
a5436 1
			       isdigit((unsigned char)prev->data[j])) {
d5448 1
a5448 1
			     *  wrapped to this line. - FM
a5453 4
			    text->chars -= l;
			    for (anc = a; anc; anc = anc->next) {
				anc->start -= l;
			    }
a5467 2
			    if (start != last)
				text->chars -= i;
a5468 1
				anc->start -= i;
d5481 1
a5481 1
			     *  numbered bracket. - FM
d5488 1
a5488 1
			 *  numbered bracket. - FM
d5501 1
a5501 1
			 isdigit((unsigned char)prev->data[j - 1]))) {
d5506 1
a5506 1
			       isdigit((unsigned char)prev->data[j])) {
d5518 1
a5518 1
			     *  was wrapped to the last line. - FM
a5523 4
			    text->chars -= NumSize;
			    for (anc = a; anc; anc = anc->next) {
				anc->start -= NumSize;
			    }
d5531 1
a5531 1
			     *  numbered bracket. - FM
d5538 1
a5538 1
			 *  numbered bracket. - FM
d5545 1
a5545 1
		     *  numbered bracket. - FM
d5551 2
d5556 1
a5556 1
	     *  as a link. - FM
d5560 4
a5563 4
		CTRACE(tfp,
		   "HText_endAnchor: blanks (line,start,pos,ext,BlankExtent):(%d,%d,%d,%d,%d)",
		   a->line_num,a->start,a->line_pos,a->extent,
		   BlankExtent);
d5569 1
a5569 1
	     *  and special characters, so set it's number
d5572 1
a5572 1
	     *  to the hidden links list. - FM
d5584 2
a5585 2
	     *  content, but shorten it's extent by any trailing
	     *  blank lines we've detected. - FM
d5591 2
a5592 2
	    CTRACE(tfp,
		   "->[%d](%d,%d,%d,%d,%d)\n",
d5594 2
a5595 2
		   a->line_num,a->start,a->line_pos,a->extent,
		   BlankExtent);
d5598 2
d5603 1
a5603 1
	 *  link. - FM
d5608 8
d5618 13
d5650 1
a5650 1
PRIVATE void remove_special_attr_chars ARGS1(
d5654 1
d5660 1
d5662 1
a5662 2
	   *buf = *cp,
	   buf++;
d5666 1
d5684 1
a5684 1
    CTRACE(tfp,"Gridtext: Entering HText_endAppend\n");
d5692 2
d5701 6
d5712 1
a5712 1
    line_ptr = text->last_line->next;
d5720 2
a5721 3

	CTRACE(tfp, "GridText: Removing bottom blank line: %s\n",
			    text->last_line->data);
a5726 1
	FREE(text->last_line);
d5729 2
a5730 2
	CTRACE(tfp, "GridText: New bottom line: %s\n",
			    text->last_line->data);
d5735 1
a5735 1
     *  create the hightext strings. - FM
d5737 1
a5737 1
    HText_trimHightext(text, TRUE);
d5756 7
a5762 6
**  AFTER the adjustment, the anchor line_pos (and hightext2offset
**  if applicable) fields indicate x positions in terms of displayed
**  character cells, and the extent field apparently is unimportant;
**  the anchor text has been copied to the hightext (and possibly
**  hightext2) fields (which should be NULL up to this point), with
**  special attribute chars removed.
d5766 1
a5766 1
PUBLIC void HText_trimHightext ARGS2(
d5768 2
a5769 1
	BOOLEAN,	final)
d5771 1
a5771 1
    int cur_line, cur_char, cur_shift;
d5775 1
d5777 4
d5785 9
a5793 2
    CTRACE(tfp,"Gridtext: Entering HText_trimHightext %s\n",
	       final ? "(final)" : "(partial)");
d5798 1
a5798 2
    line_ptr = text->last_line->next;
    cur_char = line_ptr->size;
d5803 1
a5803 1
     *  create the hightext strings. - FM
d5806 3
a5808 2
	anchor_ptr;
	prev_a = anchor_ptr, anchor_ptr=anchor_ptr->next) {
d5813 2
a5814 4
	for (; anchor_ptr->start > cur_char;
	       line_ptr = line_ptr->next,
	       cur_char += line_ptr->size+1,
	       cur_line++) {
d5824 1
a5824 1
	    if (cur_line >= text->Lines)
d5826 2
a5827 1
	    if (anchor_ptr->start >= text->chars - 1)
d5845 1
a5845 1
	if (anchor_ptr->hightext)
d5848 1
a5848 1
	if (anchor_ptr->start == cur_char) {
a5849 3
	} else {
	    anchor_ptr->line_pos = anchor_ptr->start -
				   (cur_char - line_ptr->size);
a5851 1
	    anchor_ptr->start -= anchor_ptr->line_pos;
d5855 1
a5855 1
	CTRACE(tfp,
d5858 1
a5858 1
	       anchor_ptr->number, anchor_ptr->extent);
d5866 1
a5866 1
	    ch = (unsigned char)line_ptr->data[anchor_ptr->line_pos];
d5872 1
a5872 1
		ch = (unsigned char)line_ptr->data[anchor_ptr->line_pos];
a5877 1
	anchor_ptr->start += cur_shift;
d5879 1
a5879 2
	CTRACE(tfp, "anchor text: '%s'\n",
					   line_ptr->data);
d5881 6
a5886 5
	 *  If the link begins with an end of line and we have more
	 *  lines, then start the highlighting on the next line. - FM
	 *  But if an empty anchor is at the end of line and empty,
	 *  keep it where it is, unless the previous anchor in the list
	 *  (if any) already starts later. - kw
d5892 5
a5896 3
		 (prev_a && prev_a->start > anchor_ptr->start))) {
		anchor_ptr->start++;
		CTRACE(tfp, "found anchor at end of line\n");
d5899 1
a5899 1
		CTRACE(tfp, "found anchor at end of line, leaving it there\n");
d5904 1
a5904 1
	 *  Copy the link name into the data structure.
d5906 7
a5912 5
	if (line_ptr->data &&
	    anchor_ptr->extent > 0 && anchor_ptr->line_pos >= 0) {
	    StrnAllocCopy(anchor_ptr->hightext,
			  &line_ptr->data[anchor_ptr->line_pos],
			  anchor_ptr->extent);
d5914 2
a5915 1
	    StrAllocCopy(anchor_ptr->hightext, "");
d5919 2
a5920 2
	 *  If true the anchor extends over two lines,
	 *  copy that into the data structure.
d5922 8
a5929 2
	if ((unsigned)anchor_ptr->extent > strlen(anchor_ptr->hightext)) {
	    HTLine *line_ptr2 = line_ptr->next;
d5931 9
a5939 5
	    if (!final) {
		if (cur_line + 1 >= text->Lines) {
		    FREE(anchor_ptr->hightext); /* bail out */
		    break;
		}
d5941 1
d5943 2
a5944 2
	     *  Double check that we have a line pointer,
	     *  and if so, copy into hightext2.
d5946 6
a5951 2
	    if (line_ptr2) {
		StrnAllocCopy(anchor_ptr->hightext2,
d5953 5
a5957 4
			      (anchor_ptr->extent -
			       strlen(anchor_ptr->hightext)));
		anchor_ptr->hightext2offset = line_ptr2->offset;
		remove_special_attr_chars(anchor_ptr->hightext2);
d5959 4
a5962 5
		    LYTrimTrailing(anchor_ptr->hightext2);
		    if (anchor_ptr->hightext2[0] == '\0') {
			FREE(anchor_ptr->hightext2);
			anchor_ptr->hightext2offset = 0;
		    }
d5964 1
d5967 8
a5974 1
	remove_special_attr_chars(anchor_ptr->hightext);
d5976 1
a5976 1
	    LYTrimTrailing(anchor_ptr->hightext);
d5980 1
a5980 2
	 *  Subtract any formatting characters from the x position
	 *  of the link.
d5984 1
a5984 1
	    for (; i < anchor_ptr->line_pos; i++)
d5986 1
a5986 1
		    IsSpecialAttrChar(line_ptr->data[i]))
d5988 3
d6000 4
a6003 1
	CTRACE(tfp, "GridText:     add link on line %d col %d [%d] %s\n",
d6005 1
a6005 7
	       anchor_ptr->number, "in HText_trimHightext");

	/*
	 *  If this is the last anchor, we're done!
	 */
	if (anchor_ptr == text->last_anchor)
	    break;
a6009 9
/*	Dump diagnostics to tfp
*/
PUBLIC void HText_dump ARGS1(
	HText *,	text GCC_UNUSED)
{
    fprintf(tfp, "HText: Dump called\n");
}


d6021 1
d6023 2
a6024 2
 *  HTChildAnchor() returns the anchor with index N.
 *  The index corresponds to the [number] we print for the anchor.
d6026 3
a6028 2
PUBLIC HTChildAnchor * HText_childNumber ARGS1(
	int,		number)
d6030 2
a6031 1
    TextAnchor * a;
d6033 1
a6033 1
    if (!(HTMainText && HTMainText->first_anchor) || number <= 0)
d6035 8
d6044 4
a6047 5
    for (a = HTMainText->first_anchor; a; a = a->next) {
	if (a->number == number)
	    return(a->anchor);
    }
    return (HTChildAnchor *)0;	/* Fail */
d6053 1
a6053 1
 *  for the field. - FM & LE
d6149 3
a6151 3
    CTRACE(tfp, "HTGetRelLinkNum(%d,%d,%d) -- HTMainText=%p\n",
	   num, rel, cur, HTMainText);
    CTRACE(tfp,"  scrtop=%d, curline=%d, curanchor=%d, display_lines=%d, %s\n",
d6153 1
a6153 1
	   on_screen ? "on_screen" : "0");
d6159 1
a6159 1
	CTRACE(tfp,"curanchor=%d at line %d on screen\n",curanchor,curline);
d6169 1
a6169 1
	CTRACE(tfp,"  a->line_num=%d, a->number=%d\n",a->line_num,a->number);
d6175 1
a6175 1
    CTRACE(tfp,"  a=%p, l=%p, curanchor=%d\n",a,l,curanchor);
d6237 2
a6238 2
	    (a->link_type != INPUT_ANCHOR ||
	     a->input_field->type != F_HIDDEN_TYPE)) {
d6326 2
a6327 2
		*hightext= a->hightext;
		link_dest = HTAnchor_followMainLink((HTAnchor *)a->anchor);
d6336 1
a6336 1
				(HTAnchor *)a->anchor, LINK_INTERNAL);
d6339 2
a6340 2
				CTRACE(tfp, "HTGetLinkInfo: unexpected typed link to %s!\n",
					    link_dest_intl->parent->address);
d6388 2
a6389 1
	formA->type != F_TEXTAREA_TYPE || formB->type != F_TEXTAREA_TYPE) {
d6396 1
a6396 1
    return(strcmp(formA->name, formB->name) == 0);
d6399 1
a6399 1
#define same_anchor_as_link(i,a) (i >= 0 && a &&\
d6401 1
a6401 1
		(links[i].type == WWW_FORM_LINK_TYPE) ? links[i].form : NULL,\
d6404 2
a6405 2
		ta_skip))
#define same_anchors(a1,a2) (a1 && a2 &&\
d6410 40
a6449 1
		ta_skip))
d6512 2
a6513 2
	    (a->link_type != INPUT_ANCHOR ||
	     a->input_field->type != F_HIDDEN_TYPE)) {
d6527 1
a6527 1
	    if (!same_anchors(current.anc, a)) {
d6540 1
a6540 1
		if (same_anchor_as_link(curlink,a)) {
d6549 1
a6549 1
			   same_anchor_as_link(curlink,previous.anc)) {
a6643 7
#if 0
	    if (*go_line > HTMainText->top_of_screen &&
		*go_line < HTMainText->top_of_screen+(display_lines) &&
		HTMainText->top_of_screen+(display_lines) <= a->line_num &&
		HTMainText->top_of_screen+2*(display_lines) <= HTMainText->Lines)
		*go_line = HTMainText->top_of_screen+(display_lines);
#endif
d6660 1
a6660 1
 *  *data with all IsSpecial characters stripped, it's offset and
d6663 1
a6663 1
 *  TRUE is returned. - FM
d6672 1
a6672 1
	char *,		target)
d6681 1
a6681 1
     *  in its range, and that we have a target string. - FM
d6683 4
a6686 2
    if (!(text && line_num >= 0 && line_num <= text->Lines &&
	  target && *target))
d6688 1
d6691 1
a6691 1
     *  Find the line and set up its data and offset - FM
d6693 1
a6693 1
    for (i = 0, line = text->last_line->next;
d6709 1
a6709 1
     *  data, and return TRUE. - FM
d6711 6
a6716 12
    if ((case_sensitive ?
	 (cp = LYno_attr_mbcs_strstr(LineData,
				     target,
				     utf_flag,
				     &HitOffset,
				     &LenNeeded)) != NULL :
	 (cp = LYno_attr_mbcs_case_strstr(LineData,
				     target,
				     utf_flag,
				     &HitOffset,
				     &LenNeeded)) != NULL) &&
	(LineOffset + LenNeeded) < LYcols) {
d6721 1
a6721 1
	 *  return TRUE. - FM
d6731 1
a6731 1
     *  The line does not contain the target. - FM
d6755 1
a6755 1
#ifdef USE_HASH
d6766 1
a6766 1
 *  attachment; filename=name.suffix). - FM
d6780 1
a6780 1
 *  believe the headers about whether it's compressed or not. - FM
d6793 1
d6796 2
a6797 1
    BOOLEAN method = 0;
d6800 1
a6800 1
     *  Make sure we have a string and anchor. - FM
d6802 1
a6802 1
    if (!(fn && *fn && anchor))
d6808 2
a6809 6
    if ((cp = strrchr(fn, '/')) != NULL) {
	fn = (cp +1);
	if (*fn == '\0') {
	    return;
	}
    }
d6813 1
a6813 1
     *  elements for a gzip or Unix compressed file. - FM
d6817 1
a6817 1
    if (ce == NULL) {
d6820 1
a6820 1
	 *  the Content-Type. - FM
d6822 20
a6841 8
	if (!strncasecomp((ct ? ct : ""), "application/gzip", 16) ||
	    !strncasecomp((ct ? ct : ""), "application/x-gzip", 18)) {
	    method = 1;
	} else if (!strncasecomp((ct ? ct : ""),
				 "application/compress", 20) ||
		   !strncasecomp((ct ? ct : ""),
				 "application/x-compress", 22)) {
	    method = 2;
a6842 12
    } else if (!strcasecomp(ce, "gzip") ||
	       !strcasecomp(ce, "x-gzip")) {
	    /*
	     *  It's gzipped. - FM
	     */
	    method = 1;
    } else if (!strcasecomp(ce, "compress") ||
	       !strcasecomp(ce, "x-compress")) {
	    /*
	     *  It's Unix compressed. - FM
	     */
	    method = 2;
d6850 11
a6860 1
    if (method == 0 && !strip_ok)
d6862 1
d6866 1
a6866 1
     *  we have a gzip or compress suffix. - FM
d6869 2
a6870 4
	if (!strcasecomp(dot, ".tgz") ||
	    !strcasecomp(dot, ".gz") ||
	    !strcasecomp(dot, ".Z")) {
	    if (!method) {
d6874 1
a6874 1
		 *  claims otherwise, so tweak the suffix. - FM
a6875 1
		cp = (dot + 1);
a6876 3
		if (!strcasecomp(cp, "tgz")) {
		    StrAllocCat(*fname, ".tar");
		}
d6880 16
a6895 17
	if (strlen(dot) > 4) {
	    cp = ((dot + strlen(dot)) - 3);
	    if (!strcasecomp(cp, "-gz") ||
		!strcasecomp(cp, "_gz")) {
		if (!method) {
		    /*
		     *  It has a tail which signifies a gzipped
		     *  file for us, but the anchor claims otherwise,
		     *  so tweak the suffix. - FM
		     */
		    *dot = '\0';
		} else {
		    /*
		     *  The anchor claims it's gzipped, and we
		     *  believe it, so force this tail to the
		     *  conventional suffix. - FM
		     */
d6897 1
a6897 1
		    *cp = '-';
d6899 1
a6899 1
		    *cp = '.';
d6901 4
a6904 34
		    cp++;
		    *cp = TOLOWER(*cp);
		    cp++;
		    *cp = TOLOWER(*cp);
		}
		return;
	    }
	}
	if (strlen(dot) > 3) {
	    cp = ((dot + strlen(dot)) - 2);
	    if (!strcasecomp(cp, "-Z") ||
		!strcasecomp(cp, "_Z")) {
		if (!method) {
		    /*
		     *  It has a tail which signifies a compressed
		     *  file for us, but the anchor claims otherwise,
		     *  so tweak the suffix. - FM
		     */
		    *dot = '\0';
		} else {
		    /*
		     *  The anchor claims it's compressed, and
		     *  we believe it, so force this tail to the
		     *  conventional suffix. - FM
		     */
#ifdef VMS
		    *cp = '-';
#else
		    *cp = '.';
#endif /* VMS */
		    cp++;
		    *cp = TOUPPER(*cp);
		}
		return;
d6906 1
d6909 14
a6922 7
    if (!method) {
	/*
	 *  Don't know what compression method
	 *  was used, if any, so we won't do
	 *  anything. - FM
	 */
	return;
d6926 9
a6934 11
     *  Add the appropriate suffix. - FM
     */
    if (!dot) {
	StrAllocCat(*fname, ((method == 1) ? ".gz" : ".Z"));
	return;
    }
    dot++;
    if (*dot == '\0') {
	StrAllocCat(*fname, ((method == 1) ? "gz" : "Z"));
	return;
    }
d6936 1
a6936 3
    StrAllocCat(*fname, ((method == 1) ? "-gz" : "-Z"));
#else
    StrAllocCat(*fname, ((method == 1) ? ".gz" : ".Z"));
d6938 2
a6939 1
    return;
d6944 1
a6944 1
 *  if available, for the current document. - FM
d6954 1
a6954 1
 *  if available, for the current document. - FM
d6964 1
a6964 1
 *  if available, for the current document. - FM
d6983 1
a6983 1
	CTRACE(tfp, "GridText: HText_pageDisplay at line %d started\n", line_num);
d6987 1
d6997 3
a6999 1
	HText_trimHightext(HTMainText, FALSE);
d7007 1
a7007 1
	sleep(MessageSecs);
d7014 1
a7014 1
	CTRACE(tfp, "GridText: HText_pageDisplay finished\n");
d7033 1
a7033 1
 *  'Lines' number of lines beginning with 'line_num'-1. - FM
d7049 2
a7050 2
		Anchor_ptr != NULL && Anchor_ptr->line_num <= end;
			Anchor_ptr = Anchor_ptr->next) {
d7054 2
a7055 2
	    (Anchor_ptr->link_type != INPUT_ANCHOR ||
	     Anchor_ptr->input_field->type != F_HIDDEN_TYPE))
a7056 2
	if (Anchor_ptr == text->last_anchor)
	    break;
d7084 1
a7084 1
    return (text->top_of_screen != 0);
d7091 2
a7092 2
    return (text != 0)
     && ((text->top_of_screen + display_lines) < text->Lines+1);
d7126 2
a7127 18
/* Bring to front and highlight it
*/
PRIVATE int line_for_char ARGS2(
	HText *,	text,
	int,		char_num)
{
    int line_number = 0;
    int characters = 0;
    HTLine * line = text->last_line->next;
    for (;;) {
	if (line == text->last_line) return 0;	/* Invalid */
	characters = characters + line->size + 1;
	if (characters > char_num) return line_number;
	line_number ++;
	line = line->next;
    }
}

a7131 3
	HTMainText = text;
	HTMainAnchor = text->node_anchor;

d7149 21
d7171 1
a7171 1
	 *  Make this text the most current in the loaded texts list. - FM
d7175 2
a7176 2
	  /* let lynx do it */
	/* display_page(text, text->top_of_screen, ""); */
d7184 1
a7184 1
 *  (memory cached) text. - FM
d7187 1
a7187 1
	document *,	doc)
d7191 2
a7192 1
    char *post_data, *address;
d7196 1
a7196 1
     *  Make sure we have the structures. - FM
d7202 1
a7202 1
     *  Make sure doc is for a POST reply. - FM
d7211 1
a7211 1
     *  POST reply match. - FM
d7216 1
a7216 1
	    !strcmp(post_data, text->node_anchor->post_data) &&
d7228 1
a7228 1
	char *,		selector)
d7232 1
a7232 1
    for (a=HTMainText->first_anchor; a; a=a->next) {
d7234 1
a7234 1
	if (a->anchor && a->anchor->tag)
d7239 3
a7241 4
		CTRACE(tfp,
		       "HText: Selecting anchor [%d] at character %d, line %d\n",
				     a->number, a->start, www_search_result);
		if (!strcmp(selector, LYToolbarName))
d7243 2
a7244 2

		 return(YES);
d7246 1
d7270 1
a7270 1
	CTRACE(tfp, "HText: No such anchor in this text!\n");
d7280 3
a7282 4
	 int l = line_for_char(text, a->start);
	 CTRACE(tfp,
	    "HText: Selecting anchor [%d] at character %d, line %d\n",
	    a->number, a->start, l);
d7384 2
a7385 2
      HText * text = HTMainText;
      return text != 0 ? text->top_of_screen : 0;
d7391 1
a7391 1
      return text->Lines;
d7402 1
a7402 1
 *  Utility for freeing the list of previous isindex and whereis queries. - FM
d7422 1
a7422 1
 *  any repeated queries the most current in the list. - FM
d7427 1
a7427 1
    char *new;
d7431 1
a7431 1
    if (!(query && *query))
d7434 1
a7434 3
    if ((new = (char *)calloc(1, (strlen(query) + 1))) == NULL)
	outofmem(__FILE__, "HTAddSearchQuery");
    strcpy(new, query);
d7441 1
a7441 1
	HTList_addObject(search_queries, new);
d7447 1
a7447 1
	if (!strcmp(old, new)) {
d7453 1
a7453 1
    HTList_addObject(search_queries, new);
d7459 1
a7459 1
	document *,	doc)
d7476 1
a7476 1
	strcpy(searchstring, ++cp);
d7483 1
a7483 1
	 *  Make sure it's treated as the most recent query. - FM
d7506 1
a7506 1
	       (!PreviousSearch && QueryTotal >= 1)) ? RECALL : NORECALL);
d7515 1
a7515 1
		 *  Use the second to last query in the list. - FM
d7521 1
a7521 1
		 *  Go back to the previous query in the list. - FM
d7527 1
a7527 1
		 *  Roll around to the last query in the list. - FM
d7532 1
a7532 1
		strcpy(searchstring, cp);
d7546 1
a7546 1
		 *  Use the first query in the list. - FM
d7552 1
a7552 1
		 *  Advance to the next query in the list. - FM
d7558 1
a7558 1
		 *  Roll around to the first query in the list. - FM
d7563 1
a7563 1
		strcpy(searchstring, cp);
d7584 1
a7584 1
     *  Strip leaders and trailers. - FM
d7603 1
a7603 1
     *  or make it the most current. - FM
d7616 3
a7618 5
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
    syslog(LOG_INFO|LOG_LOCAL5, "%s", tmpaddress);
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */
d7639 1
a7639 1
	CTRACE(tfp,"\ndo_www_search: newfile: %s\n",doc->address);
d7652 1
a7652 1
     *  rejecting it. - FM
d7657 27
d7692 1
a7692 1
	int,		is_reply)
d7697 10
d7711 1
a7711 1
    line = HTMainText->last_line->next;
d7713 6
a7718 2
	if (!first
	 && line->data[0] != LY_SOFT_NEWLINE)
d7720 6
a7725 7
	first = FALSE;

	/*
	 *  Add news-style quotation if requested. - FM
	 */
	if (is_reply) {
	    fputc('>',fp);
d7728 1
a7728 6
	/*
	 *  Add offset.
	 */
	for (i = 0; i < (int)line->offset; i++) {
	     fputc(' ', fp);
	}
d7735 11
d7749 1
a7749 10
		if (dump_output_immediately &&
		    LYRawMode &&
		    LYlowest_eightbit[current_char_set] <= 173 &&
		    (LYCharSet_UC[current_char_set].enc == UCT_ENC_8859 ||
		     LYCharSet_UC[current_char_set].like8859 &
				  UCT_R_8859SPECL)) {
		    fputc(0xad, fp); /* the iso8859 byte for SHY */
		} else {
		    fputc('-', fp);
		}
d7761 21
d7813 1
a7813 1
    line = HTMainText->last_line->next;
d7820 1
a7820 2
	if (!first
	 && line->data[0] != LY_SOFT_NEWLINE)
d7823 1
a7823 6
	/*
	 *  Add offset.
	 */
	for (i = 0; i < (int)line->offset; i++) {
	    fputc(' ', fp);
	}
d7833 2
a7834 11
		if (dump_output_immediately &&
		    LYRawMode &&
		    LYlowest_eightbit[current_char_set] <= 173 &&
		    (LYCharSet_UC[current_char_set].enc == UCT_ENC_8859 ||
		     LYCharSet_UC[current_char_set].like8859 &
				  UCT_R_8859SPECL)) {
		    fputc(0xad, fp); /* the iso8859 byte for SHY */
		} else {
		    fputc('-', fp);
		}
	     }
d7847 1
a7847 2
	(keypad_mode == LINKS_ARE_NUMBERED ||
	 keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED)) {
d7857 1
a7857 1
    document *,	doc,
d7867 1
a7867 1
	BOOL on_screen = (tentative_result > HTMainText->top_of_screen &&
d7927 120
a8046 15
/*
   John Bley, April 1, 1999 (No joke)
   www_user_search_internals was spawned from www_user_search to
   remove a cut-n-paste coding hack: basically, this entire function
   was duplicated at the two points that www_user_search now calls it.
   And, because www_user_search has a return value defined as modification
   of the screen and some global values, and since it used an awkward for(;;)
   construct, this method has to distinguish between when it's "really"
   returning and when it's just falling through via a break; in the
   infinite-for-loop.  So, basically, we have a large amount of arguments
   since this loop used to be directly in www_user_search, and we return
   1 to say we're "really" returning and 0 to indicate we fell through.
   Also, due to exactly one difference between the first pass of this
   code and the second pass, we have the "firstpass" argument, which is
   true iff it's the first pass.
d8048 2
a8049 1
   I hate cut-n-paste coding.
d8051 17
a8067 2
PRIVATE int www_user_search_internals ARGS8(
	int,		firstpass,
d8069 1
a8069 1
	document *,	doc,
a8070 1
	TextAnchor *,	a,
d8072 1
a8072 2
	int *,		count,
	int *,		tentative_result)
d8074 3
a8076 2
    OptionType * option;
    char *stars = NULL, *cp;
d8079 1
a8079 1
	while ((a != NULL) && a->line_num == (*count - 1)) {
d8081 4
a8084 7
		(a->link_type != INPUT_ANCHOR ||
		 a->input_field->type != F_HIDDEN_TYPE)) {
		if (((a->hightext != NULL && case_sensitive == TRUE) &&
		     LYno_attr_char_strstr(a->hightext, target)) ||
		    ((a->hightext != NULL && case_sensitive == FALSE) &&
		     LYno_attr_char_case_strstr(a->hightext, target))) {
		    adjust_search_result(doc, *count, start_line);
d8087 41
a8127 5
		if (((a->hightext2 != NULL && case_sensitive == TRUE) &&
		     LYno_attr_char_strstr(a->hightext2, target)) ||
		    ((a->hightext2 != NULL && case_sensitive == FALSE) &&
		     LYno_attr_char_case_strstr(a->hightext2, target))) {
		    adjust_search_result(doc, *count, start_line);
a8129 104

		/*
		 *  Search the relevant form fields, taking the
		 *  case_sensitive setting into account. - FM
		 */
		if ((a->input_field != NULL && a->input_field->value != NULL) &&
		    a->input_field->type != F_HIDDEN_TYPE) {
		    if (a->input_field->type == F_PASSWORD_TYPE) {
			/*
			 *  Check the actual, hidden password, and then
			 *  the displayed string. - FM
			 */
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(a->input_field->value,
						   target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(a->input_field->value,
							target))) {
			    adjust_search_result(doc, *count, start_line);
			    return 1;
			}
			StrAllocCopy(stars, a->input_field->value);
			for (cp = stars; *cp != '\0'; cp++)
			    *cp = '*';
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(stars, target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(stars, target))) {
			    FREE(stars);
			    adjust_search_result(doc, *count, start_line);
			    return 1;
			}
			FREE(stars);
		   } else if (a->input_field->type == F_OPTION_LIST_TYPE) {
			/*
			 *  Search the option strings that are displayed
			 *  when the popup is invoked. - FM
			 */
			option = a->input_field->select_list;
			while (option != NULL) {
			    if (((option->name != NULL &&
				  case_sensitive == TRUE) &&
				 LYno_attr_char_strstr(option->name,
						       target)) ||
				((option->name != NULL &&
				  case_sensitive == FALSE) &&
				 LYno_attr_char_case_strstr(option->name,
							    target))) {
				adjust_search_result(doc, *count, start_line);
				return 1;
			    }
			    option = option->next;
			}
		    } else if (a->input_field->type == F_RADIO_TYPE) {
			/*
			 *  Search for checked or unchecked parens. - FM
			 */
			if (a->input_field->num_value) {
			    cp = checked_radio;
			} else {
			    cp = unchecked_radio;
			}
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(cp, target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(cp, target))) {
			    adjust_search_result(doc, *count, start_line);
			    return 1;
			}
		    } else if (a->input_field->type == F_CHECKBOX_TYPE) {
			/*
			 *  Search for checked or unchecked
			 *  square brackets. - FM
			 */
			if (a->input_field->num_value) {
			    cp = checked_box;
			} else {
			    cp = unchecked_box;
			}
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(cp, target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(cp, target))) {
			    adjust_search_result(doc, *count, start_line);
			    return 1;
			}
		    } else {
			/*
			 *  Check the values intended for display.
			 *  May have been found already via the
			 *  hightext search, but make sure here
			 *  that the entire value is searched. - FM
			 */
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(a->input_field->value,
						   target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(a->input_field->value,
							target))) {
			    adjust_search_result(doc, *count, start_line);
			    return 1;
			}
		    }
		}
d8131 1
a8131 4
	    a = a->next;
	}
	if (a != NULL && a->line_num <= (*count - 1)) {
	    a = a->next;
d8134 2
a8135 10
	if (case_sensitive && LYno_attr_char_strstr(line->data, target)) {
	    *tentative_result = *count;
	    break;
	} else if (!case_sensitive &&
		   LYno_attr_char_case_strstr(line->data, target)) {
	    *tentative_result = *count;
	    break;
	/* Note: this is where the two passes differ */
	} else if (firstpass && line == HTMainText->last_line) {
	    /* next line */
d8137 1
a8137 1
	} else if (!firstpass && *count > start_line) {
d8139 4
a8142 4
	    return 1;			/* end */
	} else {			/* end */
	    line = line->next;
	    (*count)++;
d8144 5
a8149 1
    /* No, man, we just fell through.  You want to call us again. */
d8153 1
a8153 1
PUBLIC void www_user_search ARGS3(
d8155 3
a8157 2
	document *,	doc,
	char *,		target)
a8160 2
    int tentative_result = -1;
    TextAnchor *a;
d8169 8
a8176 6
    line = HTMainText->last_line->next;
    for (count = 1; count <= start_line; line = line->next, count++) {
	if (line == HTMainText->last_line) {
	    line = HTMainText->last_line->next; /* set to first line */
	    count = 1;
	    break;
d8178 3
a8180 8
    }
    a = HTMainText->first_anchor;
    while (a && a->line_num < count - 1) {
	a = a->next;
    }
    if (www_user_search_internals(1, start_line, doc, target,
	a, line, &count, &tentative_result) == 1) {
	return; /* Return the www_user_search_internals result */
d8183 4
a8186 18
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
	return;
    }
    /* That didn't work, search from the beginning instead */
    line = HTMainText->last_line->next; /* set to first line */
    count = 1;
    a = HTMainText->first_anchor;
    while (a && a->line_num < count - 1) {
	a = a->next;
    }
    if (www_user_search_internals(0, start_line, doc, target,
	a, line, &count, &tentative_result) == 1) {
	return; /* Return the www_user_search_internals result */
    }
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
    }
d8200 1
a8200 1
    HTSprintf(&temp, message, (argument == 0) ? "" : argument);
d8292 1
a8292 1
	CTRACE(tfp, "\rHTuncache.. freeing document for '%s'%s\n",
d8297 3
a8299 2
			      htmain_anchor->post_data) ?
				      " with POST data" : ""));
d8304 1
a8304 1
	CTRACE(tfp, "HTuncache.. HTMainText already is NULL!\n");
d8309 3
d8316 1
a8316 1
    if (!HTMainText || LYCacheSource == SOURCE_CACHE_NONE ||
d8318 1
a8318 1
	 !HTMainText->source_cache_file) ||
d8320 1
a8320 1
	 !HTMainText->source_cache_chunk))
d8323 1
a8323 1
    if (LYCacheSource == SOURCE_CACHE_FILE && HTMainText->source_cache_file) {
d8328 10
a8337 2
	CTRACE(tfp, "Reparsing source cache file %s\n",
	       HTMainText->source_cache_file);
d8343 2
a8344 2
	if (HTMainText->node_anchor->content_type) {
	    format = HTAtom_for(HTMainText->node_anchor->content_type);
d8346 2
a8347 2
	    format = HTFileFormat(HTMainText->source_cache_file, NULL, NULL);
	    format = HTCharsetFormat(format, HTMainText->node_anchor,
d8353 1
a8353 1
	CTRACE(tfp, "  Content type is \"%s\"\n", format->name);
d8355 1
a8355 8
	/*
	 * Pass the source cache filename on to the next HText.  Mark it
	 * NULL here so that it won't get deleted by HText_free().
	 */
	source_cache_filename = HTMainText->source_cache_file;
	HTMainText->source_cache_file = NULL;

	fp = fopen(source_cache_filename, "r");
d8357 3
a8359 2
	    CTRACE(tfp, "  Cannot read file %s\n", source_cache_filename);
	    FREE(source_cache_filename);
d8362 1
a8362 4
#ifdef DISP_PARTIAL
	display_partial = display_partial_flag;  /* restore */
	Newline_partial = Newline;  /* initialize */
#endif
d8369 11
a8379 6
	ret = HTParseFile(format, HTOutputFormat, HTMainText->node_anchor,
			  fp, NULL);
	fclose(fp);
	ok = (ret == HT_LOADED);
	if (!ok) {
	    FREE(source_cache_filename);
d8381 1
d8385 1
a8385 1
	HTMainText->source_cache_chunk) {
d8389 10
a8398 2
	CTRACE(tfp, "Reparsing from source memory cache %p\n",
	       (void *)HTMainText->source_cache_chunk);
d8400 3
d8411 3
a8413 2
	format = HTCharsetFormat(format, HTMainText->node_anchor,
					 UCLYhndl_for_unspec);
a8415 11
	/*
	 * Pass the source cache HTChunk on to the next HText.  Clear it
	 * here so that it won't get deleted by HText_free().
	 */
	source_cache_chunk = HTMainText->source_cache_chunk;
	HTMainText->source_cache_chunk = NULL;

#ifdef DISP_PARTIAL
	display_partial = display_partial_flag;  /* restore */
	Newline_partial = Newline;  /* initialize */
#endif
d8422 9
a8430 7
	ret = HTParseMem(format, HTOutputFormat, HTMainText->node_anchor,
			 source_cache_chunk, NULL);
	ok = (ret == HT_LOADED);
	if (!ok) {
	    HTChunkFree(source_cache_chunk);
	    source_cache_chunk = NULL;
	}
d8433 1
a8433 5
    CTRACE(tfp, "Reparse %s\n", (ok ? "succeeded" : "failed"));

    if (ok)  {
	from_source_cache = TRUE;  /* flag for mainloop events */
    }
d8440 1
a8440 1
    if (!HTMainText || LYCacheSource == SOURCE_CACHE_NONE ||
d8442 1
a8442 1
	 !HTMainText->source_cache_file) ||
d8444 1
a8444 1
	 !HTMainText->source_cache_chunk))
d8447 2
a8448 9
    if (LYCacheSource == SOURCE_CACHE_FILE && HTMainText->source_cache_file) {
	FILE * fp;

	fp = fopen(HTMainText->source_cache_file, "r");
	if (!fp) {
	    return FALSE;
	}
	fclose(fp);
	return TRUE;
d8452 1
a8452 1
	HTMainText->source_cache_chunk) {
d8461 2
a8462 2
	BOOLEAN,	prev_setting,
	BOOLEAN,	new_setting)
d8465 2
a8466 2
	CTRACE(tfp, "HTdocument_settings_changed: %s setting has changed (was %s, now %s)\n",
	       name, prev_setting ? "ON" : "OFF", new_setting ? "ON" : "OFF");
d8475 1
a8475 1
    if (!HTMainText || LYCacheSource == SOURCE_CACHE_NONE ||
d8477 1
a8477 1
	 !HTMainText->source_cache_file) ||
d8479 1
a8479 1
	 !HTMainText->source_cache_chunk))
d8491 3
d8504 4
a8507 2
	if (HTMainText->lines != LYlines || HTMainText->cols != LYcols)
	    CTRACE(tfp,
d8509 1
a8509 1
		   HTMainText->cols, HTMainText->lines, LYcols, LYlines);
d8514 1
d8517 2
a8518 1
	    HTMainText->minimal_comments != minimal_comments ||
d8521 2
a8522 2
	    HTMainText->lines != LYlines ||
	    HTMainText->cols != LYcols);
d8540 1
a8540 6
}

PUBLIC char * HTLoadedDocumentPost_data NOARGS
{
    if (!HTMainText)
	return ("");
d8542 5
a8546 1
    if (HTMainText->node_anchor && HTMainText->node_anchor->post_data)
d8549 1
a8549 1
	return ("");
d8634 17
d8664 16
d8693 5
a8697 7
	    if (!IsSpecialAttrChar((unsigned char)line->data[i]) &&
		(!(text && text->T.output_utf8) ||
		 (unsigned char)line->data[i] < 128 ||
		 ((unsigned char)(line->data[i] & 0xc0) == 0xc0)) &&
		!isspace((unsigned char)line->data[i]) &&
		(unsigned char)line->data[i] != HT_NON_BREAK_SPACE &&
		(unsigned char)line->data[i] != HT_EN_SPACE) {
d8704 1
a8704 3
		(!(text && text->T.output_utf8) ||
		 (unsigned char)line->data[i] < 128 ||
		 ((unsigned char)(line->data[i] & 0xc0) == 0xc0))) {
d8712 36
d8774 1
a8774 1
 *  line. - FM
a8779 1
    char *data;
d8781 1
a8781 1
    if (!(text && text->Lines > 1))
a8784 1
    data = line->data;
a8787 2
    text->chars -= ((data && *data == '\0') ?
					  1 : strlen(line->data) + 1);
d8789 23
a8811 1
    FREE(line);
d8819 1
a8819 1
 *	  and split_line() is called. - FM
d8839 1
a8839 1
    int column = (LYcols-2);
d8841 2
a8842 2
	column = ((int)text->style->rightIndent ? (LYcols-2) :
		  ((LYcols-1) - (int)text->style->rightIndent));
d8850 1
a8850 1
 *	  HT_LEFT. - FM
d8860 1
a8860 1
    if (!text || !name || !*name)
d8875 1
a8875 1
	Tab = (HTTabID *)calloc(1, sizeof(HTTabID));
d8893 1
a8893 1
    if (text && name && *name && cur) {
d8913 1
a8913 1
 *  count. - FM
d8922 1
a8922 1
     *  Make sure we have an HText structure and anchor. - FM
d8929 1
a8929 1
     *  if it hasn't been already. - FM
d8937 1
a8937 1
     *  retrievals. - FM
d8939 1
a8939 1
    if ((dest = HTAnchor_followMainLink((HTAnchor *)textanchor->anchor)) &&
d8949 1
a8949 1
 *  that are loaded in text->hidden_links. - FM
d8965 1
a8965 1
 *  text->hidden_links list of the number argument. - FM
d9007 1
a9007 1
     *  Check the ACTION. - FM
d9010 1
a9010 1
	if (!strncmp(action, "mailto:", 7)) {
d9019 1
a9019 1
     *  Check the METHOD. - FM
d9026 1
a9026 1
     *  Check the ENCTYPE. - FM
d9028 1
a9028 1
    if ((enctype != NULL) && *enctype) {
d9038 1
a9038 1
     *  Check the TITLE. - FM
d9040 1
a9040 1
    if ((title != NULL) && *title)
d9064 1
a9064 1
    newform = (PerFormInfo *)calloc(1, sizeof(PerFormInfo));
d9072 1
a9072 1
    CTRACE(tfp, "BeginForm: action:%s Method:%d%s%s%s%s%s%s\n",
d9075 1
a9075 1
		(HTFormTitle ? HTFormTitle : ""),
d9077 1
a9077 1
		(HTFormEnctype ? HTFormEnctype : ""),
d9079 1
a9079 1
		(HTFormAcceptCharset ? HTFormAcceptCharset : ""));
d9088 1
a9088 1
	 *  the form via <return> instead of a submit button. - FM
d9090 1
a9090 1
	TextAnchor * a = text->first_anchor;
d9092 1
a9092 1
	 *  Go through list of anchors and get our input field. - FM
d9094 1
a9094 1
	while (a) {
d9099 1
a9099 1
		 *  Got it.  Make it submitting. - FM
a9113 3
	    if (a == text->last_anchor)
		break;
	    a = a->next;
d9134 1
a9134 1
	CTRACE(tfp, "endForm:    HTCurrentForm is missing!\n");
d9154 5
a9158 5
   /*
    *  Save the group name.
    */
   StrAllocCopy(HTCurSelectGroup, name);
   HTCurSelectGroupCharset = name_cs;
d9160 10
a9169 10
   /*
    *  If multiple then all options are actually checkboxes.
    */
   if (multiple)
      HTCurSelectGroupType = F_CHECKBOX_TYPE;
   /*
    *  If not multiple then all options are radio buttons.
    */
   else
      HTCurSelectGroupType = F_RADIO_TYPE;
d9176 1
a9176 1
    CTRACE(tfp,"HText_beginSelect: name=%s type=%d size=%s\n",
d9181 2
a9182 2
				      "<NULL>" : HTCurSelectGroupSize));
    CTRACE(tfp,"HText_beginSelect: name_cs=%d \"%s\"\n",
d9185 1
a9185 1
		 LYCharSet_UC[HTCurSelectGroupCharset].MIMEname : "<UNKNOWN>"));
d9210 1
a9210 1
    CTRACE(tfp, "HText_getOptionNum: Got number '%d'.\n", n);
d9227 1
a9227 1
    if (keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) {
d9238 3
a9240 3
	if ((cp && *cp && *cp++ == '(') &&
	    *cp && isdigit(*cp++)) {
	    while (*cp && isdigit(*cp))
d9285 6
a9290 4
    if (!(text && text->last_anchor &&
	  text->last_anchor->link_type == INPUT_ANCHOR)) {
	CTRACE(tfp, "HText_setLastOptionValue: invalid call!  value:%s!\n",
		    (value ? value : "<NULL>"));
d9294 2
a9295 2
    CTRACE(tfp, "Entering HText_setLastOptionValue: value:%s, checked:%s\n",
		value, (checked ? "on" : "off"));
d9302 2
a9303 2
	while ((cp >= value) && (isspace((unsigned char)*cp) ||
				 IsSpecialAttrChar((unsigned char)*cp)))
d9312 2
a9313 2
    while (isspace((unsigned char)*cp) ||
	   IsSpecialAttrChar((unsigned char)*cp))
d9317 1
a9317 1
	keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) {
d9320 1
a9320 1
	 *  prefix and actual value. - FM
d9324 2
a9325 2
	    while (isspace((unsigned char)cp1[i]) ||
		   IsSpecialAttrChar((unsigned char)cp1[i])) {
d9372 4
a9375 4
		CTRACE(tfp, "HText_setLastOptionValue: last input_field not F_OPTION_LIST_TYPE (%d)\n",
			    F_OPTION_LIST_TYPE);
		CTRACE(tfp, "                          but %d, ignoring!\n",
			    text->last_anchor->input_field->type);
d9380 1
a9380 1
				(OptionType *)calloc(1, sizeof(OptionType));
d9388 1
a9388 1
		op_ptr=op_ptr->next;
d9392 1
a9392 2
	    op_ptr->next = new_ptr =
				(OptionType *)calloc(1, sizeof(OptionType));
d9405 2
a9406 2
	while (isspace((unsigned char)*cp) ||
	       IsSpecialAttrChar((unsigned char)*cp))
d9413 1
a9413 1
		       !IsSpecialAttrChar((unsigned char)cp[i])) {
d9420 3
a9422 1
		(tmp = (unsigned char *)calloc(1, strlen(cp)+1))) {
d9448 2
d9451 1
a9451 1
	    text->last_anchor->input_field->num_value = 0;
d9458 2
a9459 2
	    FREE(text->last_anchor->input_field->value);
	    FREE(text->last_anchor->input_field->cp_submit_value);
d9461 5
a9465 10
	    text->last_anchor->input_field->value =
		text->last_anchor->input_field->select_list->name;
	    text->last_anchor->input_field->orig_value =
		text->last_anchor->input_field->select_list->name;
	    text->last_anchor->input_field->cp_submit_value =
		text->last_anchor->input_field->select_list->cp_submit_value;
	    text->last_anchor->input_field->orig_submit_value =
		text->last_anchor->input_field->select_list->cp_submit_value;
	    text->last_anchor->input_field->value_cs =
		new_ptr->value_cs;
d9468 1
a9468 1
	    int curlen = strlen(HTCurSelectedOptionValue);
d9481 1
d9485 6
a9490 9
	    text->last_anchor->input_field->num_value = number;
	    text->last_anchor->input_field->value = new_ptr->name;
	    text->last_anchor->input_field->orig_value = new_ptr->name;
	    text->last_anchor->input_field->cp_submit_value =
				   new_ptr->cp_submit_value;
	    text->last_anchor->input_field->orig_submit_value =
				   new_ptr->cp_submit_value;
	    text->last_anchor->input_field->value_cs =
		new_ptr->value_cs;
d9511 1
a9511 1
	fprintf(tfp,"HText_setLastOptionValue:%s value=%s",
d9513 2
a9514 2
		value);
	fprintf(tfp,"            val_cs=%d \"%s\"",
d9517 1
a9517 1
			 LYCharSet_UC[val_cs].MIMEname : "<UNKNOWN>"));
d9519 1
a9519 1
	    fprintf(tfp, " (submit_val_cs %d \"%s\") submit_value%s=%s\n",
d9525 1
a9525 1
		    submit_value);
d9528 1
a9528 1
	    fprintf(tfp,"\n");
d9544 2
a9545 3

    TextAnchor * a = (TextAnchor *) calloc(1, sizeof(*a));
    FormInfo * f = (FormInfo *) calloc(1, sizeof(*f));
d9550 3
d9554 1
a9554 1
    CTRACE(tfp,"Entering HText_beginInput\n");
d9556 2
a9560 1
    a->start = text->chars + text->last_line->size;
a9564 1

d9570 1
a9570 1
     *  name that was checked. - FM
d9582 1
a9582 1
	    TextAnchor * b = text->first_anchor;
d9584 1
a9584 1
	    while (b) {
a9596 6
		if (b == text->last_anchor) {
		    if (i2 == 0)
		       I->checked = TRUE;
		    break;
		}
		b = b->next;
d9598 2
d9608 1
a9608 1
    a->hightext = NULL;
a9619 1

d9621 1
a9621 1
     *  Set the no_cache flag if the METHOD is POST. - FM
d9632 1
a9632 1
	if ((tmp = (unsigned char *)calloc(1, (strlen(IValue) + 1)))) {
d9686 1
a9686 1
	   f->size = 20;  /* default */
d9738 1
d9743 1
a9743 1
	     *  Note that TYPE="scribble" defaults to TYPE="text". - FM
d9769 2
a9770 4
	    CTRACE(tfp,
		  "GridText: No name present in input field; not displaying\n");
	    FREE(a);
	    FREE(f);
d9787 1
a9787 1
     *  an option list make it a zero-length string. - FM
d9819 1
a9819 1
	if (f->value && *f->value != '\0') {
d9827 1
a9827 1
	if (f->value && *f->value != '\0') {
d9847 1
a9847 1
	   StrAllocCopy(f->value, (f->type == F_CHECKBOX_TYPE ? "on" : ""));
d9885 1
d9887 1
d9894 1
a9894 1
	    if (keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED)
d9900 4
a9903 2
    if (keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED && a->number > 0) {
	char marker[16];
d9905 6
a9910 14
	if (f->type != F_OPTION_LIST_TYPE)
	    /*
	     *  '[' was already put out for a popup menu
	     *  designator.  See HTML.c.
	     */
	    HText_appendCharacter(text, '[');
	sprintf(marker,"%d]", a->number);
	HText_appendText(text, marker);
	if (f->type == F_OPTION_LIST_TYPE)
	    /*
	     *  Add option list designation char.
	     */
	    HText_appendCharacter(text, '[');
	a->start = text->chars + text->last_line->size;
d9913 2
d9920 1
a9921 1
	int MaximumSize;
d9935 1
a9935 1
	     *  horizontally within the editing window. - FM
d9937 13
a9949 12
	    MaximumSize = (LYcols - 1) -
			  (int)text->style->leftIndent -
			  (int)text->style->rightIndent;

	    /*
	     *  If we are numbering form links, take that into
	     *  account as well. - FM
	     */
	    if (keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED)
		MaximumSize -= ((a->number/10) + 3);
	    if (f->size > MaximumSize)
		f->size = MaximumSize;
a9957 1

d9963 1
a9963 1
	     *  type which is handled via a popup window. - FM
d9965 1
a9965 2
	    if (f->size > LYcols-10)
		f->size = LYcols-10;  /* maximum */
d9968 2
d9993 1
a9993 1
	CTRACE(tfp, "beginInput: HTCurrentForm is missing!\n");
d9996 1
a9996 1
    CTRACE(tfp, "Input link: name=%s\nvalue=%s\nsize=%d\n",
d9998 3
a10000 3
			((f->value != NULL) ? f->value : ""),
			f->size);
    CTRACE(tfp, "Input link: name_cs=%d \"%s\" (from %d \"%s\")\n",
d10006 2
a10007 2
			 LYCharSet_UC[I->name_cs].MIMEname : "<UNKNOWN>"));
    CTRACE(tfp, "            value_cs=%d \"%s\" (from %d \"%s\")\n",
d10013 1
a10013 1
			 LYCharSet_UC[I->value_cs].MIMEname : "<UNKNOWN>"));
d10022 20
d10072 1
a10072 1
    if (p && *p) {
d10140 281
a10420 1
PUBLIC void HText_SubmitForm ARGS4(
d10422 1
a10422 1
	document *,	doc,
d10426 3
a10428 10
    TextAnchor *anchor_ptr;
    int form_number = submit_item->number;
    FormInfo *form_ptr;
    PerFormInfo *thisform;
    char *query = NULL;
    char *escaped1 = NULL, *escaped2 = NULL;
    int first_one = 1;
    char *last_textarea_name = NULL;
    int textarea_lineno = 0;
    char *previous_blanks = NULL;
d10431 7
d10440 6
a10445 3
    int target_cs = -1;
    CONST char *out_csname;
    CONST char *target_csname = NULL;
d10447 1
a10447 6
    BOOL form_has_8bit = NO, form_has_special = NO;
    BOOL field_has_8bit = NO, field_has_special = NO;
    BOOL name_has_8bit = NO, name_has_special = NO;
    BOOL have_accept_cs = NO;
    BOOL success;
    BOOL had_chartrans_warning = NO;
d10449 7
a10455 2
    char *copied_val_used = NULL;
    char *copied_name_used = NULL;
d10457 1
a10457 1
    CTRACE(tfp, "FIXME:SubmitForm\n");
d10459 1
a10459 1
	return;
d10464 2
a10465 2
	CTRACE(tfp, "SubmitForm: form %d not in HTMainText's list!\n",
		    form_number);
d10467 2
a10468 2
	CTRACE(tfp, "SubmitForm: failed sanity check, %d!=%d !\n",
		    thisform->number, form_number);
d10472 12
a10483 11
    if (submit_item->submit_action) {
	/*
	 *  If we're mailing, make sure it's a mailto ACTION. - FM
	 */
	if ((submit_item->submit_method == URL_MAIL_METHOD) &&
	    strncmp(submit_item->submit_action, "mailto:", 7)) {
	    HTAlert(BAD_FORM_MAILTO);
	    return;
	}
    } else {
	return;
d10487 1
a10487 1
     *  Check the ENCTYPE and set up the appropriate variables. - FM
d10493 1
a10493 1
	 *  to separate name=value pairs. - FM
d10501 1
a10501 1
	 *  separators for name=value pairs. - FM
d10508 2
a10509 4
	 *  Use the multipart MIME format.  We should generate
	 *  a boundary string which we are sure doesn't occur
	 *  in the content, but for now we'll just assume that
	 *  this string doesn't. - FM
d10560 1
a10560 1
     *  Go through list of anchors and get size first.
d10562 6
a10567 7
    /*
     *  also get a "max." charset parameter - kw
     */
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr) {
	if (anchor_ptr->link_type == INPUT_ANCHOR) {
	    if (anchor_ptr->input_field->number == form_number) {
d10569 2
a10570 52
		char *p;
		char * val;
		form_ptr = anchor_ptr->input_field;
		val = form_ptr->cp_submit_value != NULL ?
				    form_ptr->cp_submit_value : form_ptr->value;
		field_has_8bit = NO;
		field_has_special = NO;

		for (p = val;
		     p && *p && !(field_has_8bit && field_has_special);
		     p++)
		    if ((*p == HT_NON_BREAK_SPACE) ||
		       (*p == HT_EN_SPACE) ||
			(*p == LY_SOFT_HYPHEN)) {
			field_has_special = YES;
		    } else if ((*p & 0x80) != 0) {
			field_has_8bit = YES;
		    }
		for (p = form_ptr->name;
		     p && *p && !(name_has_8bit && name_has_special);
		     p++)
		    if ((*p == HT_NON_BREAK_SPACE) ||
			(*p == HT_EN_SPACE) ||
			(*p == LY_SOFT_HYPHEN)) {
			name_has_special = YES;
		    } else if ((*p & 0x80) != 0) {
			name_has_8bit = YES;
		    }

		if (field_has_8bit || name_has_8bit)
		    form_has_8bit = YES;
		if (field_has_special || name_has_special)
		    form_has_special = YES;

		if (!field_has_8bit && !field_has_special) {
		    /* already ok */
		} else if (target_cs < 0) {
		    /* already confused */
		} else if (!field_has_8bit &&
		    (LYCharSet_UC[target_cs].enc == UCT_ENC_8859 ||
		     (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
		    /* those specials will be trivial */
		} else if (UCNeedNotTranslate(form_ptr->value_cs, target_cs)) {
		    /* already ok */
		} else if (UCCanTranslateFromTo(form_ptr->value_cs, target_cs)) {
		    /* also ok */
		} else if (UCCanTranslateFromTo(target_cs, form_ptr->value_cs)) {
		    target_cs = form_ptr->value_cs;	/* try this */
		    target_csname = NULL; /* will be set after loop */
		} else {
		    target_cs = -1; /* don't know what to do */
		}
d10572 28
a10599 19
		/*  Same for name */
		if (!name_has_8bit && !name_has_special) {
		    /* already ok */
		} else if (target_cs < 0) {
		    /* already confused */
		} else if (!name_has_8bit &&
		    (LYCharSet_UC[target_cs].enc == UCT_ENC_8859 ||
		     (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
		    /* those specials will be trivial */
		} else if (UCNeedNotTranslate(form_ptr->name_cs, target_cs)) {
		    /* already ok */
		} else if (UCCanTranslateFromTo(form_ptr->name_cs, target_cs)) {
		    /* also ok */
		} else if (UCCanTranslateFromTo(target_cs, form_ptr->name_cs)) {
		    target_cs = form_ptr->value_cs;	/* try this */
		    target_csname = NULL; /* will be set after loop */
		} else {
		    target_cs = -1; /* don't know what to do */
		}
d10601 18
a10618 2
	    } else if (anchor_ptr->input_field->number > form_number) {
		break;
a10619 1
	}
d10621 2
a10622 1
	if (anchor_ptr == HTMainText->last_anchor)
d10624 2
d10627 8
a10634 1
	anchor_ptr = anchor_ptr->next;
d10638 1
a10638 1
	if (form_has_8bit) {
d10640 1
a10640 1
	} else if (form_has_special) {
d10648 3
a10650 1
	StrAllocCopy(query, submit_item->submit_action);
d10654 1
a10654 1
	strtok (query, "#");
d10658 1
a10658 1
	strtok (query, "?");
d10662 2
a10663 1
	StrAllocCat(query,"?");
d10667 2
a10668 1
	 *  so load the post_content_type element. - FM
d10671 1
a10671 1
	    StrAllocCopy(doc->post_content_type,
d10674 1
a10674 1
	    StrAllocCopy(doc->post_content_type,
d10677 2
a10678 3
	    StrAllocCopy(doc->post_content_type,
			 "multipart/form-data; boundary=");
	    StrAllocCat(doc->post_content_type, Boundary);
d10680 1
a10680 1
	    StrAllocCopy(doc->post_content_type,
d10701 3
a10703 2
	if (have_accept_cs ||
	    (form_has_8bit || form_has_special)) {
d10712 1
a10712 2
			StrAllocCat(doc->post_content_type, "; charset=");
			StrAllocCat(doc->post_content_type, target_csname);
d10716 1
a10716 5
		had_chartrans_warning = YES;
		_user_message(
		    CANNOT_TRANSCODE_FORM,
		    target_csname ? target_csname : "UNKNOWN");
		sleep(AlertSecs);
a10720 1

d10724 1
a10724 1
     *  Reset anchor->ptr.
d10726 6
a10731 10
    anchor_ptr = HTMainText->first_anchor;
    /*
     *  Go through list of anchors and assemble URL query.
     */
    while (anchor_ptr) {
	if (anchor_ptr->link_type == INPUT_ANCHOR) {
	    if (anchor_ptr->input_field->number == form_number) {
		char *p;
		int out_cs;
		form_ptr = anchor_ptr->input_field;
d10733 2
a10734 2
		if (form_ptr->type != F_TEXTAREA_TYPE)
		    textarea_lineno = 0;
d10736 48
a10783 2
		switch(form_ptr->type) {
		case F_RESET_TYPE:
d10785 66
a10850 25
		case F_SUBMIT_TYPE:
		case F_TEXT_SUBMIT_TYPE:
		case F_IMAGE_SUBMIT_TYPE:
		    if (!(form_ptr->name && *form_ptr->name != '\0' &&
			  !strcmp(form_ptr->name, link_name))) {
			CTRACE(tfp,
				    "SubmitForm: skipping submit field with ");
			CTRACE(tfp, "name \"%s\" for link_name \"%s\", %s.\n",
				    form_ptr->name ? form_ptr->name : "???",
				    link_name ? link_name : "???",
				    (form_ptr->name && *form_ptr->name) ?
				    "not current link" : "no field name");
			break;
		    }
		    if (!(form_ptr->type == F_TEXT_SUBMIT_TYPE ||
			(form_ptr->value && *form_ptr->value != '\0' &&
			 !strcmp(form_ptr->value, link_value)))) {
			if (TRACE) {
			    fprintf(tfp,
				    "SubmitForm: skipping submit field with ");
			    fprintf(tfp,
				    "name \"%s\" for link_name \"%s\", %s!\n",
				    form_ptr->name ? form_ptr->name : "???",
				    link_name ? link_name : "???",
				    "values are different");
a10851 17
			break;
		    }
		    /*  fall through  */
		case F_RADIO_TYPE:
		case F_CHECKBOX_TYPE:
		case F_TEXTAREA_TYPE:
		case F_PASSWORD_TYPE:
		case F_TEXT_TYPE:
		case F_OPTION_LIST_TYPE:
		case F_HIDDEN_TYPE:
		    /*
		     *	Be sure to actually look at the option submit value.
		     */
		    if (form_ptr->cp_submit_value != NULL) {
			val_used = form_ptr->cp_submit_value;
		    } else {
			val_used = form_ptr->value;
d10853 3
d10857 10
a10866 17
		    /*
		     *  Charset-translate value now, because we need
		     *  to know the charset parameter for multipart
		     *  bodyparts. - kw
		     */
		    field_has_8bit = NO;
		    field_has_special = NO;
		    for (p = val_used;
			 p && *p && !(field_has_8bit && field_has_special);
			 p++) {
			if ((*p == HT_NON_BREAK_SPACE) ||
			    (*p == HT_EN_SPACE) ||
			    (*p == LY_SOFT_HYPHEN)) {
			    field_has_special = YES;
			} else if ((*p & 0x80) != 0) {
			    field_has_8bit = YES;
			}
d10868 1
d10870 5
a10874 5
		    if (field_has_8bit || field_has_special) {
			/*  We should translate back. */
			StrAllocCopy(copied_val_used, val_used);
			success = LYUCTranslateBackFormData(&copied_val_used,
							form_ptr->value_cs,
d10876 11
a10886 30
			CTRACE(tfp, "SubmitForm: field \"%s\" %d %s -> %d %s %s\n",
				    form_ptr->name ? form_ptr->name : "",
				    form_ptr->value_cs,
				    form_ptr->value_cs >= 0 ?
				    LYCharSet_UC[form_ptr->value_cs].MIMEname :
									  "???",
				    target_cs,
				    target_csname ? target_csname : "???",
				    success ? "OK" : "FAILED");
			if (success) {
			    val_used = copied_val_used;
			}
		    } else {  /* We can use the value directly. */
			CTRACE(tfp, "SubmitForm: field \"%s\" %d %s OK\n",
				    form_ptr->name ? form_ptr->name : "",
				    target_cs,
				    target_csname ? target_csname : "???");
			success = YES;
		    }
		    if (!success) {
			if (!had_chartrans_warning) {
			    had_chartrans_warning = YES;
			    _user_message(
				CANNOT_TRANSCODE_FORM,
				target_csname ? target_csname : "UNKNOWN");
			    sleep(AlertSecs);
			}
			out_cs = form_ptr->value_cs;
		    } else {
			out_cs = target_cs;
a10887 2
		    if (out_cs >= 0)
			out_csname = LYCharSet_UC[out_cs].MIMEname;
d10889 2
a10890 9
			if (!success && form_ptr->value_cs < 0) {
			    /*  This is weird. */
			    StrAllocCopy(MultipartContentType,
					 "\r\nContent-Type: text/plain; charset=");
			    StrAllocCat(MultipartContentType, "UNKNOWN-8BIT");
			} else if (!success) {
			    StrAllocCopy(MultipartContentType,
					 "\r\nContent-Type: text/plain; charset=");
			    StrAllocCat(MultipartContentType, out_csname);
d10893 1
a10893 1
			    if (!target_csname) {
a10894 4
			    }
			    StrAllocCopy(MultipartContentType,
					 "\r\nContent-Type: text/plain; charset=");
			    StrAllocCat(MultipartContentType, out_csname);
d10897 14
a10910 1

d10912 10
a10921 3
		     *  Charset-translate name now, because we need
		     *  to know the charset parameter for multipart
		     *  bodyparts. - kw
d10923 20
a10942 10
		    if (form_ptr->type == F_TEXTAREA_TYPE) {
			textarea_lineno++;
			if (textarea_lineno > 1 &&
			    last_textarea_name && form_ptr->name &&
			    !strcmp(last_textarea_name, form_ptr->name)) {
			    break;
			}
		    }
		    name_used = (form_ptr->name ?
				 form_ptr->name : "");
d10944 3
a10946 13
		    name_has_8bit = NO;
		    name_has_special = NO;
		    for (p = name_used;
			 p && *p && !(name_has_8bit && name_has_special);
			 p++) {
			if ((*p == HT_NON_BREAK_SPACE) ||
			    (*p == HT_EN_SPACE) ||
			    (*p == LY_SOFT_HYPHEN)) {
			    name_has_special = YES;
			} else if ((*p & 0x80) != 0) {
			    name_has_8bit = YES;
			}
		    }
d10948 19
a10966 62
		    if (name_has_8bit || name_has_special) {
			/*  We should translate back. */
			StrAllocCopy(copied_name_used, name_used);
			success = LYUCTranslateBackFormData(&copied_name_used,
							form_ptr->name_cs,
							target_cs, PlainText);
			CTRACE(tfp, "SubmitForm: name \"%s\" %d %s -> %d %s %s\n",
				    form_ptr->name ? form_ptr->name : "",
				    form_ptr->name_cs,
				    form_ptr->name_cs >= 0 ?
				    LYCharSet_UC[form_ptr->name_cs].MIMEname :
									  "???",
				    target_cs,
				    target_csname ? target_csname : "???",
				    success ? "OK" : "FAILED");
			if (success) {
			    name_used = copied_name_used;
			}
			if (Boundary) {
			    if (!success) {
				StrAllocCopy(MultipartContentType, "");
				target_csname = NULL;
			    } else {
				if (!target_csname)
				    target_csname = LYCharSet_UC[target_cs].MIMEname;
			    }
			}
		    } else {  /* We can use the name directly. */
			CTRACE(tfp, "SubmitForm: name \"%s\" %d %s OK\n",
				    form_ptr->name ? form_ptr->name : "",
				    target_cs,
				    target_csname ? target_csname : "???");
			success = YES;
			if (Boundary) {
			    StrAllocCopy(copied_name_used, name_used);
			}
		    }
		    if (!success) {
			if (!had_chartrans_warning) {
			    had_chartrans_warning = YES;
			    _user_message(
				CANNOT_TRANSCODE_FORM,
				target_csname ? target_csname : "UNKNOWN");
			    sleep(AlertSecs);
			}
		    }
		    if (Boundary) {
			/*
			 *  According to RFC 1867, Non-ASCII field names
			 *  "should be encoded according to the prescriptions
			 *  of RFC 1522 [...].  I don't think RFC 1522 actually
			 *  is meant to apply to parameters like this, and it
			 *  is unknown whether any server would make sense of
			 *  it, so for now just use some quoting/escaping and
			 *  otherwise leave 8-bit values as they are.
			 *  Non-ASCII characters in form field names submitted
			 *  as multipart/form-data can only occur if the form
			 *  provider specifically asked for it anyway. - kw
			 */
			HTMake822Word(&copied_name_used);
			name_used = copied_name_used;
		    }
d10968 9
a10976 4
		    break;
		default:
		    CTRACE(tfp, "SubmitForm: What type is %d?\n",
				form_ptr->type);
d10978 1
d10980 9
a10988 1
		switch(form_ptr->type) {
d10990 6
a10995 2
		case F_RESET_TYPE:
		    break;
d10997 23
a11019 34
		case F_SUBMIT_TYPE:
		case F_TEXT_SUBMIT_TYPE:
		case F_IMAGE_SUBMIT_TYPE:
		    /*
		     *  If it has a non-zero length name (e.g., because
		     *  it's IMAGE_SUBMIT_TYPE to be handled homologously
		     *  to an image map, or a SUBMIT_TYPE in a set of
		     *  multiple submit buttons, or a single type="text"
		     *  that's been converted to a TEXT_SUBMIT_TYPE),
		     *  include the name=value pair, or fake name.x=0 and
		     *  name.y=0 pairs for IMAGE_SUBMIT_TYPE. - FM
		     */
		    if ((form_ptr->name && *form_ptr->name != '\0' &&
			!strcmp(form_ptr->name, link_name)) &&
		       (form_ptr->type == F_TEXT_SUBMIT_TYPE ||
			(form_ptr->value && *form_ptr->value != '\0' &&
			 !strcmp(form_ptr->value, link_value)))) {
			int cdisp_name_startpos = 0;
			if (first_one) {
			    if (Boundary) {
				HTSprintf(&query, "--%s\r\n", Boundary);
			    }
			    first_one=FALSE;
			} else {
			    if (PlainText) {
				StrAllocCat(query, "\n");
			    } else if (SemiColon) {
				StrAllocCat(query, ";");
			    } else if (Boundary) {
				HTSprintf(&query, "\r\n--%s\r\n", Boundary);
			    } else {
				StrAllocCat(query, "&");
			    }
			}
d11021 2
a11022 13
			if (PlainText) {
			    StrAllocCopy(escaped1, name_used);
			} else if (Boundary) {
			    StrAllocCopy(escaped1,
				    "Content-Disposition: form-data; name=");
			    cdisp_name_startpos = strlen(escaped1);
			    StrAllocCat(escaped1, name_used);
			    if (MultipartContentType)
				StrAllocCat(escaped1, MultipartContentType);
			    StrAllocCat(escaped1, "\r\n\r\n");
			} else {
			    escaped1 = HTEscapeSP(name_used, URL_XALPHAS);
			}
d11024 4
a11027 7
			if (PlainText || Boundary) {
			    StrAllocCopy(escaped2,
					 (val_used ?
					  val_used : ""));
			} else {
			    escaped2 = HTEscapeSP(val_used, URL_XALPHAS);
			}
d11029 1
a11029 46
			if (form_ptr->type == F_IMAGE_SUBMIT_TYPE) {
			    /*
			     *  It's a clickable image submit button.
			     *  Fake a 0,0 coordinate pair, which
			     *  typically returns the image's default. - FM
			     */
			    if (Boundary) {
				escaped1[cdisp_name_startpos] = '\0';
				HTSprintf(&query,
					"%s.x\r\n\r\n0\r\n--%s\r\n%s.y\r\n\r\n0",
					escaped1,
					Boundary,
					escaped1);
			    } else {
				HTSprintf(&query,
					"%s.x=0%s%s.y=0%s",
					escaped1,
					(PlainText ?
					      "\n" : (SemiColon ?
							    ";" : "&")),
					escaped1,
					((PlainText && *escaped1) ?
							     "\n" : ""));
			    }
			} else {
			    /*
			     *  It's a standard submit button.
			     *  Use the name=value pair. = FM
			     */
			    HTSprintf(&query,
				    "%s%s%s%s%s",
				    escaped1,
				    (Boundary ?
					   "" : "="),
				    (PlainText ?
					  "\n" : ""),
				    escaped2,
				    ((PlainText && *escaped2) ?
							 "\n" : ""));
			}
			FREE(escaped1);
			FREE(escaped2);
		    }
		    FREE(copied_name_used);
		    FREE(copied_val_used);
		    break;
d11031 2
a11032 23
		case F_RADIO_TYPE:
		case F_CHECKBOX_TYPE:
		    /*
		     *  Only add if selected.
		     */
		    if (form_ptr->num_value) {
			if (first_one) {
			    if (Boundary) {
				HTSprintf(&query,
					"--%s\r\n", Boundary);
			    }
			    first_one=FALSE;
			} else {
			    if (PlainText) {
				StrAllocCat(query, "\n");
			    } else if (SemiColon) {
				StrAllocCat(query, ";");
			    } else if (Boundary) {
				HTSprintf(&query, "\r\n--%s\r\n", Boundary);
			    } else {
				StrAllocCat(query, "&");
			    }
			}
d11034 13
a11046 20
			if (PlainText) {
			    StrAllocCopy(escaped1, name_used);
			} else if (Boundary) {
			    StrAllocCopy(escaped1,
				     "Content-Disposition: form-data; name=");
			    StrAllocCat(escaped1,
					name_used);
			    if (MultipartContentType)
				StrAllocCat(escaped1, MultipartContentType);
			    StrAllocCat(escaped1, "\r\n\r\n");
			} else {
			    escaped1 = HTEscapeSP(name_used, URL_XALPHAS);
			}
			if (PlainText || Boundary) {
			    StrAllocCopy(escaped2,
					 (val_used ?
					  val_used : ""));
			} else {
			    escaped2 = HTEscapeSP(val_used, URL_XALPHAS);
			}
d11048 1
a11048 16
			HTSprintf(&query,
				"%s%s%s%s%s",
				escaped1,
				(Boundary ?
				       "" : "="),
				(PlainText ?
				      "\n" : ""),
				escaped2,
				((PlainText && *escaped2) ?
						     "\n" : ""));
			FREE(escaped1);
			FREE(escaped2);
		    }
		    FREE(copied_name_used);
		    FREE(copied_val_used);
		    break;
d11050 2
a11051 8
		case F_TEXTAREA_TYPE:
		    if (PlainText || Boundary) {
			StrAllocCopy(escaped2,
				     (val_used ?
				      val_used : ""));
		    } else {
			escaped2 = HTEscapeSP(val_used, URL_XALPHAS);
		    }
d11053 7
a11059 83
		    if (!last_textarea_name ||
			strcmp(last_textarea_name, form_ptr->name)) {
			textarea_lineno = 1;
			/*
			 *  Names are different so this is the first
			 *  textarea or a different one from any before
			 *  it.
			 */
			if (Boundary) {
			    StrAllocCopy(previous_blanks, "\r\n");
			} else {
			    FREE(previous_blanks);
			}
			if (first_one) {
			    if (Boundary) {
				HTSprintf(&query, "--%s\r\n", Boundary);
			    }
			    first_one=FALSE;
			} else {
			    if (PlainText) {
				StrAllocCat(query, "\n");
			    } else if (SemiColon) {
				StrAllocCat(query, ";");
			    } else if (Boundary) {
				HTSprintf(&query, "\r\n--%s\r\n", Boundary);
			    } else {
				StrAllocCat(query, "&");
			    }
			}
			if (PlainText) {
			    StrAllocCopy(escaped1, name_used);
			} else if (Boundary) {
			    StrAllocCopy(escaped1,
				    "Content-Disposition: form-data; name=");
			    StrAllocCat(escaped1, name_used);
			    if (MultipartContentType)
				StrAllocCat(escaped1, MultipartContentType);
			    StrAllocCat(escaped1, "\r\n\r\n");
			} else {
			    escaped1 = HTEscapeSP(name_used, URL_XALPHAS);
			}
			HTSprintf(&query,
				"%s%s%s%s%s",
				escaped1,
				(Boundary ?
				       "" : "="),
				(PlainText ?
				      "\n" : ""),
				escaped2,
				((PlainText && *escaped2) ?
						     "\n" : ""));
			FREE(escaped1);
			last_textarea_name = form_ptr->name;
		    } else {
			/*
			 *  This is a continuation of a previous textarea
			 *  add %0a (\n) and the escaped string.
			 */
			if (escaped2[0] != '\0') {
			    if (previous_blanks) {
				StrAllocCat(query, previous_blanks);
				FREE(previous_blanks);
			    }
			    if (PlainText) {
				HTSprintf(&query, "%s\n", escaped2);
			    } else if (Boundary) {
				HTSprintf(&query, "%s\r\n", escaped2);
			    } else {
				HTSprintf(&query, "%%0a%s", escaped2);
			    }
			} else {
			    if (PlainText) {
				StrAllocCat(previous_blanks, "\n");
			    } else if (Boundary) {
				StrAllocCat(previous_blanks, "\r\n");
			    } else {
				StrAllocCat(previous_blanks, "%0a");
			    }
			}
		    }
		    FREE(escaped2);
		    FREE(copied_val_used);
		    break;
d11061 1
a11061 4
		case F_PASSWORD_TYPE:
		case F_TEXT_TYPE:
		case F_OPTION_LIST_TYPE:
		case F_HIDDEN_TYPE:
d11064 1
a11064 1
			    HTSprintf(&query, "--%s\r\n", Boundary);
d11066 1
a11066 1
			first_one=FALSE;
d11069 1
a11069 1
			    StrAllocCat(query, "\n");
d11071 1
a11071 1
			    StrAllocCat(query, ";");
d11073 1
a11073 1
			    HTSprintf(&query, "\r\n--%s\r\n", Boundary);
d11075 1
a11075 1
			    StrAllocCat(query, "&");
d11078 64
d11143 18
a11160 9
		    if (PlainText) {
		       StrAllocCopy(escaped1, name_used);
		    } else if (Boundary) {
			StrAllocCopy(escaped1,
				    "Content-Disposition: form-data; name=");
			StrAllocCat(escaped1, name_used);
			if (MultipartContentType)
			    StrAllocCat(escaped1, MultipartContentType);
			StrAllocCat(escaped1, "\r\n\r\n");
d11162 9
a11170 1
			escaped1 = HTEscapeSP(name_used, URL_XALPHAS);
d11172 20
d11193 10
a11202 4
		    if (PlainText || Boundary) {
			StrAllocCopy(escaped2,
				     (val_used ?
				      val_used : ""));
d11204 1
a11204 1
			escaped2 = HTEscapeSP(val_used, URL_XALPHAS);
d11206 3
d11210 1
a11210 1
		    HTSprintf(&query,
d11213 2
a11214 4
			    (Boundary ?
				   "" : "="),
			    (PlainText ?
				  "\n" : ""),
d11216 62
a11277 7
			    ((PlainText && *escaped2) ?
						 "\n" : ""));
		    FREE(escaped1);
		    FREE(escaped2);
		    FREE(copied_name_used);
		    FREE(copied_val_used);
		    break;
d11279 4
a11282 1
	    } else if (anchor_ptr->input_field->number > form_number) {
d11285 14
a11299 5

	if (anchor_ptr == HTMainText->last_anchor)
	    break;

	anchor_ptr = anchor_ptr->next;
a11300 8
    FREE(copied_name_used);
    if (Boundary) {
	FREE(MultipartContentType);
	HTSprintf(&query, "\r\n--%s--\r\n", Boundary);
    } else if (!query) {
	StrAllocCopy(query, "");
    }
    FREE(previous_blanks);
d11304 1
a11304 9
	CTRACE(tfp, "\nGridText - mailto_address: %s\n",
			    (submit_item->submit_action+7));
	CTRACE(tfp, "GridText - mailto_subject: %s\n",
			    ((submit_item->submit_title &&
			      *submit_item->submit_title) ?
			      (submit_item->submit_title) :
					(HText_getTitle() ?
					 HText_getTitle() : "")));
	CTRACE(tfp,"GridText - mailto_content: %s\n",query);
d11306 8
a11313 10
		 ((submit_item->submit_title &&
		   *submit_item->submit_title) ?
		   (submit_item->submit_title) :
			     (HText_getTitle() ?
			      HText_getTitle() : "")),
		 query,
		 doc->post_content_type);
	FREE(query);
	FREE(doc->post_content_type);
	return;
d11316 14
d11332 10
a11341 12
    if (submit_item->submit_method == URL_POST_METHOD || Boundary) {
	StrAllocCopy(doc->post_data, query);
	CTRACE(tfp,"GridText - post_data: %s\n",doc->post_data);
	StrAllocCopy(doc->address, submit_item->submit_action);
	FREE(query);
	return;
    } else { /* GET_METHOD */
	StrAllocCopy(doc->address, query);
	FREE(doc->post_data);
	FREE(doc->post_content_type);
	FREE(query);
	return;
d11343 2
d11358 3
a11360 2
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr) {
a11365 5

	if (anchor_ptr == HTMainText->last_anchor)
	    break;

	anchor_ptr = anchor_ptr->next;
d11383 3
a11385 2
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr != 0) {
a11412 5

	if (anchor_ptr == HTMainText->last_anchor)
	    break;

	anchor_ptr = anchor_ptr->next;
d11426 1
a11426 1
       return FALSE;
d11432 3
a11434 2
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr != 0) {
a11460 4
	if (anchor_ptr == HTMainText->last_anchor)
	   break;

	anchor_ptr = anchor_ptr->next;
d11473 3
a11475 2
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr) {
a11491 5

	if (anchor_ptr == HTMainText->last_anchor)
	    break;

	anchor_ptr = anchor_ptr->next;
a11519 2
	    if (cur->node_anchor && cur->node_anchor->underway)
		cur->node_anchor->underway = FALSE;
d11574 1
a11574 1
    return ((text && text->toolbar) ? TRUE : FALSE);
d11588 1
a11588 1
    return ((text && text->no_cache) ? TRUE : FALSE);
d11594 1
a11594 1
    return ((text && text->T.output_utf8) ? TRUE : FALSE);
d11598 1
a11598 1
**  Check charset and set the kcode element. - FM
d11612 2
d11623 1
d11631 1
a11631 1
    **  Check whether we have a specified charset. - FM
d11641 1
a11641 1
    **  appropriately. - FM
d11643 10
a11652 2
    if (!strcmp(charset, "shift_jis") ||
	!strcmp(charset, "x-shift-jis")) {
d11654 2
a11655 1
    } else if ((p_in && (p_in->enc == UCT_ENC_CJK)) ||
a11657 2
	       !strcmp(charset, "iso-2022-jp") ||
	       !strcmp(charset, "iso-2022-jp-2") ||
d11665 1
a11665 1
	       !strcmp(charset, "iso-2022-cn")) {
d11670 1
a11670 1
	**  it is enabled.  But only if we are quite sure. - FM & kw
d11678 10
d11693 1
a11693 1
**  Set a permissible split at the current end of the last line. - FM
d11702 1
a11702 1
     *  Can split here. - FM
d11720 1
a11720 1
**  claimed or suggested this. - FM
a11728 1
    char *TargetPound;
d11747 1
a11747 1
    if ((TargetPound = strchr(full_address, '#')) == NULL)
d11755 1
a11755 1
    if (!strncasecomp(anchor->address, "LYNXIMGMAP:", 11))
d11769 4
a11772 5
    MTaddress = (strncasecomp(MTanc->address,
			      "LYNXIMGMAP:", 11) ?
				  MTanc->address : (MTanc->address + 11));
    if ((MTpound = strchr(MTaddress, '#')) != NULL)
	*MTpound = '\0';
d11774 1
a11774 3
	if (MTpound != NULL) {
	    *MTpound = '#';
	}
d11777 1
a11777 3
    if (MTpound != NULL) {
	*MTpound = '#';
    }
d11786 1
a11786 1
		if (strcmp(MTanc->post_data, anchor->post_data)) {
d11811 1
a11811 1
     *  or other directives not to use a cached rendition. - FM
d11816 2
d11845 1
a11845 1
	if (isspace (*p))
d11899 1
a11899 1
	for (p = line, s = tbuf; *s != '\0'; p++, s++)
d11901 6
a11906 6
	    *p = (((unsigned char)*s  < (unsigned char)' ')       ||
		  ((unsigned char)*s == (unsigned char)'\177')    ||
		  (((unsigned char)*s > (unsigned char)'\177') &&
		   ((unsigned char)*s <
		    (unsigned char)LYlowest_eightbit[current_char_set])))
		 ? SPLAT : *s;
d11908 1
a11908 1
	    *p = ((unsigned char)*s < (unsigned char)' ') ? SPLAT : *s;
d11910 1
d11966 1
d12016 1
a12016 1
		if (isdigit (*t++) != 0) {
d12035 1
a12035 1
	     *   of being correct, if and when such an unlikely juxitposition
d12057 1
a12057 1
		     *  horizontal position, and that of all subsequant tags
d12075 1
a12075 1
		    if (new_n -= n) {
d12085 1
a12085 1
	   }
d12098 4
a12101 1
	    if (plx) {
a12102 1
		pre_n = strlen (p);  /* count of 1st part chars in this line */
d12113 1
a12113 1
		    if (isdigit (*t++) != 0) {
d12128 3
a12130 1
		if ((valid) && (n > 0)) {
d12208 1
a12208 1
    for (htline = HTMainText->last_line->next, i = 0;
d12219 4
a12222 3
    if (((a = (TextAnchor *) calloc (1, sizeof(*a)))          == 0)  ||
	((f = (FormInfo   *) calloc (1, sizeof(*f)))          == 0)  ||
	((l = (HTLine     *) calloc (1, LINE_SIZE(MAX_LINE))) == 0))
a12228 1
    a->start	       = anchor->start + anchor->input_field->size + 1;
d12232 1
a12232 3
    StrAllocCopy (a->hightext,  anchor->hightext);
    StrAllocCopy (a->hightext2, anchor->hightext2);
    a->hightext2offset = anchor->hightext2offset;
d12250 1
a12256 3
    l->split_after     = htline->split_after;
    l->bullet	       = htline->bullet;
    l->expansion_line  = TRUE;
d12260 2
d12264 1
a12264 1
    if (keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) {
d12308 1
a12308 1
	int,		 n,
d12310 1
a12310 1
	HTLine *,        start_htline,
d12316 4
a12319 5
    int form_chars_added = (start_anchor->input_field->size + 1) * n;
    int         line_adj = 0;
    int         tag_adj  = 0;
    int         lx       = 0;
    int      hang        = 0;  /* for HANG detection of a nasty intermittent */
d12323 1
a12323 1
    CTRACE(tfp, "GridText: adjusting struct's to add %d new line(s)\n", n);
d12335 1
a12335 1
	if ((keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) &&
d12337 2
a12338 3
	    anchor->number += n;
	anchor->line_num  += n;
	anchor->start	  += form_chars_added;
d12372 1
a12372 1
    if (keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) {
d12374 1
a12374 1
	while (htline != HTMainText->last_line->next) {
d12377 1
a12377 1
		if ((anchor->number - n) == start_tag)
d12380 17
a12396 17
	        /*** A HANG (infinite loop) *has* occurred here, with */
	        /*** the values of anchor and anchor->next being the  */
	        /*** the same, OR with anchor->number "magically" and */
	        /*** suddenly taking on an anchor-pointer-like value. */
	        /***                                                  */
	        /*** The same code and same doc have both passed and  */
	        /*** failed at different times, which indicates some  */
	        /*** sort of content/html dependency, or some kind of */
	        /*** a "race" condition, but I'll be damned if I can  */
	        /*** find it after tons of CTRACE's, printf()'s, gdb  */
	        /*** breakpoints and watchpoints, etc.                */
	        /***                                                  */
	        /*** I have added a hang detector (with error msg and */
	        /*** beep) here, to break the loop and warn the user, */
	        /*** until it can be isolated and fixed.              */
	        /***                                                  */
	        /*** [One UGLY intermittent .. gak ..!  02/22/99 KED] */
d12407 2
a12408 1
						    &start_tag, n,  NOCHOP);
d12421 1
a12421 1
exit:
d12425 3
a12427 4
    nlinks                         += n;
    HTMainText->Lines              += n;
    HTMainText->last_anchor_number += n;
    HTMainText->chars              += (form_chars_added + tag_adj);
d12431 1
a12431 1
    CTRACE(tfp, "GridText: TextAnchor and HTLine struct's adjusted\n");
d12435 1
a12435 1
hang_detected:  /* uglyness has happened; inform user and do the best we can */
d12437 2
a12438 5
    printf ("\007");  /* beep the user */
    fflush (NULL);
    HTAlert ("Hang Detect: TextAnchor struct corrupted - suggest aborting!");
    HTAlert ("Hang Detect: TextAnchor struct corrupted - suggest aborting!");
    goto exit;
d12455 1
a12455 1
	   struct link *,  form_link)
d12467 1
d12476 1
a12476 1
    FormInfo   *form	 = form_link->form;
a12482 1
    char       *tbuf = NULL;
d12486 1
a12486 1
    int         match_tag = 0;
d12488 4
a12491 1
    int		len;
d12493 1
a12493 2

    CTRACE(tfp, "GridText: entered HText_ExtEditForm()\n");
d12548 2
a12549 2
    CTRACE(tfp, "GridText: TEXTAREA name=|%s| dumped to tempfile\n", areaname);
    CTRACE(tfp, "GridText: invoking editor (%s) on tempfile\n", editor);
d12558 1
a12558 7
#ifdef VMS
	sprintf (ed_offset, "-%d", ((entry_line - start_line) + 1));
    HTSprintf0 (&tbuf, "%s %s %s", editor, ed_temp, ed_offset);
#else
	sprintf (ed_offset, "+%d", ((entry_line - start_line) + 1));
    HTSprintf0 (&tbuf, "%s %s %s", editor, ed_offset, ed_temp);
#endif
d12560 1
a12560 11
    LYSystem (tbuf);   /* finally the editor is called */

#ifdef UNIX
    /*
     *  Delete backup file, if that's your style.
     */
    HTSprintf0 (&tbuf, "%s~", ed_temp);
    if (stat (tbuf, &stat_info) == 0)
	remove (tbuf);
#endif
    FREE(tbuf);
d12562 1
a12562 1
    CTRACE(tfp, "GridText: returned from editor (%s)\n", editor);
d12571 3
a12573 1
	ebuf = (char *) calloc (1, 1);
d12575 12
a12586 1
	ebuf = (char *) calloc (size + 1, (sizeof(char)));
d12590 2
a12591 1
	fclose (fp);
a12592 2
    if (ebuf == 0)
	outofmem(__FILE__, "HText_ExtEditForm");
d12597 2
a12598 1
    while ((size != 0) && (isspace (ebuf[size-1]) || (ebuf[size-1] == '\0')))
d12610 3
d12614 1
a12614 1
    len = 0;
d12619 12
d12632 1
a12632 1
	   len = cp - lp;
d12634 76
a12709 1
	   len = strlen (lp);
d12711 2
a12712 2
	strncpy (line, lp, len);
	*(line + len) = '\0';
d12714 1
a12714 1
	cleanup_line_for_textarea (line, len);
d12736 1
a12736 1
	if (len > 0)
d12745 1
a12745 1
	if (*lp) lp++;
d12756 1
a12756 1
    CTRACE(tfp, "GridText: edited text inserted into lynx struct's\n");
d12774 1
a12774 1
    CTRACE(tfp, "GridText: exiting HText_ExtEditForm()\n");
d12793 2
a12794 2
	    struct link *,  form_link,
	    int,            newlines)
d12800 1
a12800 1
    FormInfo *form      = form_link->form;
d12810 1
a12810 1
    CTRACE(tfp, "GridText: entered HText_ExpandTextarea()\n");
d12840 1
a12840 1
	        firstanchor = FALSE;
d12867 2
a12868 2
    CTRACE(tfp, "GridText: %d blank line(s) added to TEXTAREA name=|%s|\n",
	        newlines, areaname);
d12876 1
a12876 1
    CTRACE(tfp, "GridText: exiting HText_ExpandTextarea()\n");
d12883 2
a12884 2
 *  Insert the contents of a file into a TEXTAREA between the cursorline,
 *  and the line preceeding it.
d12893 1
a12893 1
	   struct link *,  form_link)
d12905 1
d12907 1
a12907 1
    FormInfo   *form	 = form_link->form;
d12922 1
d12929 1
a12929 1
    CTRACE(tfp, "GridText: entered HText_InsertFile()\n");
d12936 1
a12936 1
	CTRACE(tfp, "GridText: file insert cancelled - no filename provided\n");
d12939 6
d12952 2
a12953 2
	CTRACE(tfp, "GridText: file insert aborted - file=|%s|- was 0-length\n",
		    fn);
d12959 19
a12977 2
	if ((fbuf = (char *) calloc (size + 1, (sizeof(char)))) == NULL)
	    outofmem(__FILE__, "HText_InsertFile");
d12980 6
d12987 1
a12987 1
	fclose (fp);
d12989 1
d13036 1
a13036 1
    for (htline = HTMainText->last_line->next, i = 0;
d13043 4
a13046 3
    if (((a = (TextAnchor *) calloc (1, sizeof(*a)))          == 0)  ||
	((f = (FormInfo   *) calloc (1, sizeof(*f)))          == 0)  ||
	((l = (HTLine     *) calloc (1, LINE_SIZE(MAX_LINE))) == 0))
a13052 1
    a->start	       = anchor_ptr->start;
d13056 1
a13056 3
    StrAllocCopy (a->hightext,  anchor_ptr->hightext);
    StrAllocCopy (a->hightext2, anchor_ptr->hightext2);
    a->hightext2offset = anchor_ptr->hightext2offset;
d13074 1
a13078 3
    l->split_after     = htline->split_after;
    l->bullet	       = htline->bullet;
    l->expansion_line  = TRUE;
d13082 2
d13100 5
a13104 5
    htline             = htline->prev;
    l->next	       = htline->next;
    l->prev	       = htline;
    htline->next->prev = l;
    htline->next       = l;
d13139 9
d13169 7
d13186 1
a13186 1
    CTRACE(tfp, "GridText: file inserted into lynx struct's\n");
a13193 1

d13200 1
a13200 1
    CTRACE(tfp, "GridText: exiting HText_InsertFile()\n");
d13211 2
a13212 2
 * drawn.  Currently used only in redraw_lines_of_link when
 *    defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
d13214 1
a13214 3
 * (since no support for lss is availble for Slang) and with
 * defined(USE_COLOR_STYLE).
 * -HV.
d13216 1
a13216 1
#if defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
d13255 1
a13255 1
		LynxChangeStyle (CStyle.style,CStyle.direction,CStyle.previous);
d13264 1
a13264 1
		    addch('_');
d13273 1
a13273 1
		    addch('_');
d13291 1
a13291 1
		    addch('+');
d13296 1
a13296 1
		    isspace((unsigned char)LastDisplayChar) ||
d13306 1
a13306 1
		     *  split_line() in those cases. - FM
d13311 1
a13311 1
		     *  Make it a hard hyphen and fall through. - FM
d13316 1
d13320 2
a13321 23
		if (text->T.output_utf8 && !isascii(buffer[0])) {
		    if ((*buffer & 0xe0) == 0xc0) {
			utf_extra = 1;
		    } else if ((*buffer & 0xf0) == 0xe0) {
			utf_extra = 2;
		    } else if ((*buffer & 0xf8) == 0xf0) {
			utf_extra = 3;
		    } else if ((*buffer & 0xfc) == 0xf8) {
			utf_extra = 4;
		    } else if ((*buffer & 0xfe) == 0xfc) {
			utf_extra = 5;
		    } else {
			 /*
			  *  Garbage.
			  */
			utf_extra = 0;
		    }
		    if (strlen(data) < utf_extra) {
			/*
			 *  Shouldn't happen.
			 */
			utf_extra = 0;
		    }
d13327 1
a13327 1
		    addstr(buffer);
d13331 1
a13331 1
		} else if (HTCJK != NOCJK && !isascii(buffer[0])) {
d13337 1
a13337 1
		    addstr(buffer);
d13348 1
a13348 1
		     *  character handling is used. - FM
d13352 1
a13352 1
		    addstr(buffer);
d13365 1
a13365 1
	LynxChangeStyle (CStyle.style, CStyle.direction, CStyle.previous);
d13373 469
a13841 1
#endif /* defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)  */
d13843 1
d13845 69
a13913 4
  This is used only if compiled with lss support. It's called to draw
  regular link (1st two lines of link) when it's being unhighlighted in
  highlight:LYUtils.
*/
d13915 4
d13922 1
a13922 1
#if defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
d13924 1
a13924 1
    HTLine* todr1, *todr2;
d13926 2
d13931 1
a13931 1
	lines_back = HTMainText->Lines - ( links[cur].ly-pvtTITLE_HEIGHT+
d13934 1
a13934 1
	lines_back = display_lines - (links[cur].ly-pvtTITLE_HEIGHT);
d13937 1
a13937 1
    while (lines_back--)
a13938 2
    todr2 = (links[cur].hightext2 && links[cur].ly < display_lines) ?
	    todr1->next : 0;
d13940 6
a13945 7
    move(links[cur].ly,  links[cur].lx);
    redraw_part_of_line (todr1, links[cur].hightext,
			 strlen(links[cur].hightext),  HTMainText);
    if (todr2) {
	move(links[cur].ly+1,links[cur].hightext2_offset);
	redraw_part_of_line (todr2, links[cur].hightext2,
			     strlen(links[cur].hightext2),  HTMainText);
a13946 1

d13954 1
a13954 1
#ifdef USE_PSRC
d13958 1
a13958 1
        HTMainText->source = TRUE;
d13962 26
d13990 3
a13992 1
    return (HTMainText ? HTMainText->node_anchor->UCStages->s[0].C.UChndl : 0);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 2
a3 2
 *		===============================
 */
d7 1
a13 1
#include <HTFile.h>
a15 1
#include <HText.h>
d19 6
a40 2
#include <TRSTable.h>
#include <LYHistory.h>
d48 5
a52 1
/*#define DEBUG_APPCH 1*/
d62 4
a65 1
#include <LYJustify.h>
d67 5
a71 10
#ifdef USE_CURSES_PADS
#  define DISPLAY_COLS    (LYwideLines ? MAX_COLS : LYcols)
#  define WRAP_COLS(text) ((text)->stbl ?				\
			   (LYtableCols <= 0				\
			    ? DISPLAY_COLS				\
			    : (LYtableCols * LYcols)/12) - LYbarWidth	\
			   : LYcolLimit)
#else
#  define DISPLAY_COLS    LYcols
#  define WRAP_COLS(text) LYcolLimit
a72 7

#define FirstHTLine(text) ((text)->last_line->next)
#define LastHTLine(text)  ((text)->last_line)

static void HText_trimHightext(HText *text, BOOLEAN final,
			       int stop_before);

d74 1
a74 1
static void LynxResetScreenCache(void)
d76 1
a76 1
    int i, j;
d78 3
a80 3
    for (i = 1; (i < CACHEH && i <= display_lines); i++) {
	for (j = 0; j < CACHEW; j++)
	    cached_styles[i][j] = 0;
d85 2
a86 2
struct _HTStream {		/* only know it as object */
    const HTStreamClass *isa;
a90 1

d92 1
a92 9
			  (UCH((ch))&0xc0) == 0x80)

#define IS_UTF8_EXTRA(ch) (!(text && text->T.output_utf8) || \
			  !is8bits(ch) || \
			  (UCH(line->data[i] & 0xc0) == 0xc0))

/* a test in compact form: how many extra UTF-8 chars after initial? - kw */
#define UTF8_XNEGLEN(c) (c&0xC0? 0 :c&32? 1 :c&16? 2 :c&8? 3 :c&4? 4 :c&2? 5:0)
#define UTF_XLEN(c) UTF8_XNEGLEN(((char)~(c)))
d94 3
a96 9
#ifdef KANJI_CODE_OVERRIDE
HTkcode last_kcode = NOKANJI;	/* 1997/11/14 (Fri) 09:09:26 */
#endif

#ifdef CJK_EX
#define CHAR_WIDTH 6
#else
#define CHAR_WIDTH 1
#endif
d100 2
a101 2
HText *HTMainText = NULL;	/* Equivalent of main window */
HTParentAnchor *HTMainAnchor = NULL;	/* Anchor for HTMainText */
d103 2
a104 2
const char *HTAppName = LYNX_NAME;	/* Application name */
const char *HTAppVersion = LYNX_VERSION;	/* Application version */
d106 21
a126 26
static int HTFormNumber = 0;
static int HTFormFields = 0;
static char *HTCurSelectGroup = NULL;	/* Form select group name */
static int HTCurSelectGroupCharset = -1;	/* ... and name's charset */
int HTCurSelectGroupType = F_RADIO_TYPE;	/* Group type */
char *HTCurSelectGroupSize = NULL;	/* Length of select */
static char *HTCurSelectedOptionValue = NULL;	/* Select choice */

const char *checked_box = "[X]";
const char *unchecked_box = "[ ]";
const char *checked_radio = "(*)";
const char *unchecked_radio = "( )";

static BOOLEAN underline_on = OFF;
static BOOLEAN bold_on = OFF;

#ifdef USE_SOURCE_CACHE
int LYCacheSource = SOURCE_CACHE_NONE;
int LYCacheSourceForAborted = SOURCE_CACHE_FOR_ABORTED_DROP;
#endif

#ifdef USE_SCROLLBAR
BOOLEAN LYShowScrollbar = FALSE;
BOOLEAN LYsb_arrow = TRUE;
int LYsb_begin = -1;
int LYsb_end = -1;
d129 2
a130 26
#ifndef VMS			/* VMS has a better way - right? - kw */
#define CHECK_FREE_MEM
#endif

#ifdef CHECK_FREE_MEM
static void *LY_check_calloc(size_t nmemb, size_t size);

#define LY_CALLOC LY_check_calloc
#else
  /* using the regular calloc */
#define LY_CALLOC calloc
#endif

/*
 * The HTPool.data[] array has to align the same as malloc() would, to make the
 * ALLOC_POOL scheme portable.  For many platforms, that is the same as the
 * number of bytes in a pointer.  It may be larger, e.g., on machines which
 * have more stringent requirements for floating point.  32-bits are plenty for
 * representing styles, but we may need 64-bit or 128-bit alignment.
 *
 * The real issue is that performance is degraded if the alignment is not met,
 * and some platforms such as Tru64 generate lots of warning messages.
 */
#ifndef ALIGN_SIZE
#define ALIGN_SIZE      sizeof(double)
#endif
d132 5
a136 4
typedef struct {
    unsigned int direction:2;	/* on or off */
    unsigned int horizpos:14;	/* horizontal position of this change */
    unsigned int style:16;	/* which style to change to */
a137 5

#if defined(USE_COLOR_STYLE)
#define MAX_STYLES_ON_LINE   64
  /* buffers used when current line is being aggregated, in split_line() */
static HTStyleChange stylechanges_buffers[2][MAX_STYLES_ON_LINE];
a139 136
typedef HTStyleChange pool_data;

enum {
    POOL_SIZE = ((8192
		  - 4 * sizeof(void *)
		  - sizeof(struct _HTPool *)
		  - sizeof(int))
		 / sizeof(pool_data))
};

typedef struct _HTPool {
    pool_data data[POOL_SIZE];
    struct _HTPool *prev;
    int used;
} HTPool;

/************************************************************************
These are generic macros for any pools (provided those structures have the
same members as HTPool).  Pools are used for allocation of groups of
objects of the same type T.  Pools are represented as a list of structures of
type P (called pool chunks here).  Structure P has an array of N objects of
type T named 'data' (the number N in the array can be chosen arbitrary),
pointer to the previous pool chunk named 'prev', and the number of used items
in that pool chunk named 'used'.  Here is a definition of the structure P:
	struct P
	{
	    T data[N];
	    struct P* prev;
	    int used;
	};
 It's recommended that sizeof(P) be memory page size minus 32 in order malloc'd
chunks to fit in machine page size.
 Allocation of 'n' items in the pool is implemented by incrementing member
'used' by 'n' if (used+n <= N), or malloc a new pool chunk and
allocating 'n' items in that new chunk.  It's the task of the programmer to
assert that 'n' is <= N.  Only entire pool may be freed - this limitation makes
allocation algorithms trivial and fast - so the use of pools is limited to
objects that are freed in batch, that are not deallocated not in the batch, and
not reallocated.
 Pools greatly reduce memory fragmentation and memory allocation/deallocation
speed due to the simple algorithms used.  Due to the fact that memory is
'allocated' in array, alignment overhead is minimal.  Allocating strings in a
pool provided their length will never exceed N and is much smaller than N seems
to be very efficient.
 [Several types of memory-hungry objects are stored in the pool now:  styles,
lines, anchors, and FormInfo. Arrays of HTStyleChange are stored as is,
other objects are stored using a cast.]

 Pool is referenced by the pointer to the last chunk that contains free slots.
Functions that allocate memory in the pool update that pointer if needed.
There are 3 functions - POOL_NEW, POOL_FREE, and ALLOC_IN_POOL.

      - VH

*************************************************************************/

#define POOLallocstyles(ptr, n)     ptr = ALLOC_IN_POOL(&HTMainText->pool, n * sizeof(pool_data))
#define POOLallocHTLine(ptr, size)  ptr = (HTLine*) ALLOC_IN_POOL(&HTMainText->pool, LINE_SIZE(size))
#define POOLallocstring(ptr, len)   ptr = (char*) ALLOC_IN_POOL(&HTMainText->pool, len + 1)
#define POOLtypecalloc(T, ptr)      ptr = (T*) ALLOC_IN_POOL(&HTMainText->pool, sizeof(T))

/**************************************************************************/
/*
 * Allocates 'n' items in the pool of type 'HTPool' pointed by 'poolptr'.
 * Returns a pointer to the "allocated" memory or NULL if fails.
 * Updates 'poolptr' if necessary.
 */
static pool_data *ALLOC_IN_POOL(HTPool ** ppoolptr, unsigned request)
{
    HTPool *pool = *ppoolptr;
    pool_data *ptr;
    unsigned n;
    unsigned j;

    if (!pool) {
	ptr = NULL;
    } else {
	n = request;
	if (n == 0)
	    n = 1;
	j = (n % ALIGN_SIZE);
	if (j != 0)
	    n += (ALIGN_SIZE - j);
	n /= sizeof(pool_data);

	if (POOL_SIZE >= (pool->used + n)) {
	    ptr = pool->data + pool->used;
	    pool->used += n;
	} else {
	    HTPool *newpool = (HTPool *) LY_CALLOC(1, sizeof(HTPool));

	    if (!newpool) {
		ptr = NULL;
	    } else {
		newpool->prev = pool;
		newpool->used = n;
		ptr = newpool->data;
		*ppoolptr = newpool;
	    }
	}
    }
    return ptr;
}

/*
 * Returns a pointer to initialized pool of type 'HTPool', or NULL if fails.
 */
static HTPool *POOL_NEW(void)
{
    HTPool *poolptr = (HTPool *) LY_CALLOC(1, sizeof(HTPool));

    if (poolptr) {
	poolptr->prev = NULL;
	poolptr->used = 0;
    }
    return poolptr;
}

/*
 * Frees a pool of type 'HTPool' pointed by poolptr.
 */
static void POOL_FREE(HTPool * poolptr)
{
    HTPool *cur = poolptr;
    HTPool *prev;

    while (cur) {
	prev = cur->prev;
	free(cur);
	cur = prev;
    }
}

/**************************************************************************/
/**************************************************************************/

d141 7
a147 4
    struct _line *next;
    struct _line *prev;
    unsigned short offset;	/* Implicit initial spaces */
    unsigned short size;	/* Number of characters */
d149 2
a150 2
    HTStyleChange *styles;
    unsigned short numstyles;
d152 1
a152 1
    char data[1];		/* Space for terminator at least! */
d155 1
a155 30
#define LINE_SIZE(size) (sizeof(HTLine)+(size))		/* Allow for terminator */

#ifndef HTLINE_NOT_IN_POOL
#define HTLINE_NOT_IN_POOL 0	/* debug with this set to 1 */
#endif

#if HTLINE_NOT_IN_POOL
#define allocHTLine(ptr, size)  { ptr = (HTLine *)calloc(1, LINE_SIZE(size)); }
#define freeHTLine(self, ptr)   { \
	if (ptr && ptr != TEMP_LINE(self, 0) && ptr != TEMP_LINE(self, 1)) \
	    FREE(ptr); \
    }
#else
#define allocHTLine(ptr, size)  POOLallocHTLine(ptr, size)
#define freeHTLine(self, ptr)   {}
#endif

/*
 * Last line buffer; the second is used in split_line(). Not in pool!
 * We cannot wrap in middle of multibyte sequences, so allocate 2 extra
 * for a workspace.  This is stored in the HText, to prevent confusion
 * between different documents.  Note also that it is declared with an
 * HTLine at the beginning so pointers will be properly aligned.
 */
typedef struct {
    HTLine base;
    char data[MAX_LINE + 2];
} HTLineTemp;

#define TEMP_LINE(p,n) ((HTLine *)&(p->temp_line[n]))
d158 15
a172 14
    struct _TextAnchor *next;
    struct _TextAnchor *prev;	/* www_user_search only! */
    int number;			/* For user interface */
    int line_num;		/* Place in document */
    short line_pos;		/* Bytes/chars - extent too */
    short extent;		/* (see HText_trimHightext) */
    BOOL show_anchor;		/* Show the anchor? */
    BOOL inUnderline;		/* context is underlined */
    BOOL expansion_anch;	/* TEXTAREA edit new anchor */
    char link_type;		/* Normal, internal, or form? */
    FormInfo *input_field;	/* Info for form links */
    HiliteList lites;

    HTChildAnchor *anchor;
d175 3
a177 3
typedef struct {
    char *name;			/* ID value of TAB */
    int column;			/* Zero-based column value */
a179 31
typedef enum {
    S_text,
    S_esc,
    S_dollar,
    S_paren,
    S_nonascii_text,
    S_dollar_paren,
    S_jisx0201_text
} eGridState;			/* Escape sequence? */

#ifdef USE_TH_JP_AUTO_DETECT
typedef enum {			/* Detected Kanji code */
    DET_SJIS,
    DET_EUC,
    DET_NOTYET,
    DET_MIXED
} eDetectedKCode;

typedef enum {
    SJIS_state_neutral,
    SJIS_state_in_kanji,
    SJIS_state_has_bad_code
} eSJIS_status;

typedef enum {
    EUC_state_neutral,
    EUC_state_in_kanji,
    EUC_state_in_kana,
    EUC_state_has_bad_code
} eEUC_status;
#endif
d182 4
a185 4
 *	next_line is valid if stale is false.
 *	top_of_screen line means the line at the top of the screen
 *			or just under the title if there is one.
 */
d187 33
a219 19
    HTParentAnchor *node_anchor;

    HTLine *last_line;
    HTLineTemp temp_line[2];
    int Lines;			/* Number of them */
    TextAnchor *first_anchor;	/* double-linked on demand */
    TextAnchor *last_anchor;
    TextAnchor *last_anchor_before_stbl;
    TextAnchor *last_anchor_before_split;
    HTList *forms;		/* also linked internally */
    int last_anchor_number;	/* user number */
    BOOL source;		/* Is the text source? */
    BOOL toolbar;		/* Toolbar set? */
    HTList *tabs;		/* TAB IDs */
    HTList *hidden_links;	/* Content-less links ... */
    int hiddenlinkflag;		/*  ... and how to treat them */
    BOOL no_cache;		/* Always refresh? */
    char LastChar;		/* For absorbing white space */
    BOOL IgnoreExcess;		/* Ignore chars at wrap point */
d222 9
a230 11
    HTStyle *style;		/* Current style */
    int display_on_the_fly;	/* Lines left */
    int top_of_screen;		/* Line number */
    HTLine *top_of_screen_line;	/* Top */
    HTLine *next_line;		/* Bottom + 1 */
    unsigned permissible_split;	/* in last line */
    BOOL in_line_1;		/* of paragraph */
    BOOL stale;			/* Must refresh */
    BOOL page_has_target;	/* has target on screen */
    BOOL has_utf8;		/* has utf-8 on screen or line */
    BOOL had_utf8;		/* had utf-8 when last displayed */
d232 2
a233 2
    int first_lineno_last_disp_partial;
    int last_lineno_last_disp_partial;
a234 2
    STable_info *stbl;
    HTList *enclosed_stbl;
d236 16
a251 38
    HTkcode kcode;		/* Kanji code? */
    HTkcode specified_kcode;	/* Specified Kanji code */
#ifdef USE_TH_JP_AUTO_DETECT
    eDetectedKCode detected_kcode;
    eSJIS_status SJIS_status;
    eEUC_status EUC_status;
#endif
    eGridState state;		/* Escape sequence? */
    int kanji_buf;		/* Lead multibyte */
    int in_sjis;		/* SJIS flag */
    int halted;			/* emergency halt */

    BOOL have_8bit_chars;	/* Any non-ASCII chars? */
    LYUCcharset *UCI;		/* node_anchor UCInfo */
    int UCLYhndl;		/* charset we are fed */
    UCTransParams T;

    HTStream *target;		/* Output stream */
    HTStreamClass targetClass;	/* Output routines */

    HTPool *pool;		/* this HText memory pool */

#ifdef USE_SOURCE_CACHE
    /*
     * Parse settings when this HText was generated.
     */
    BOOL clickable_images;
    BOOL pseudo_inline_alts;
    BOOL verbose_img;
    BOOL raw_mode;
    BOOL historical_comments;
    BOOL minimal_comments;
    BOOL soft_dquotes;
    short old_dtd;
    short keypad_mode;
    short disp_lines;		/* Screen size */
    short disp_cols;		/* Used for reports only */
#endif
d254 1
a254 73
/* exported */
void *HText_pool_calloc(HText *text, unsigned size)
{
    return (void *) ALLOC_IN_POOL(&text->pool, size);
}

static void HText_AddHiddenLink(HText *text, TextAnchor *textanchor);

#ifdef EXP_JUSTIFY_ELTS
BOOL can_justify_here;
BOOL can_justify_here_saved;

BOOL can_justify_this_line;	/* =FALSE if line contains form objects */
int wait_for_this_stacked_elt;	/* -1 if can justify contents of the

				   element on the op of stack. If positive - specifies minimal stack depth
				   plus 1 at which we can justify element (can be MAX_LINE+2 if
				   ok_justify ==FALSE or in psrcview. */
BOOL form_in_htext;		/*to indicate that we are in form (since HTML_FORM is

				   not stacked in the HTML.c */
BOOL in_DT = FALSE;

#ifdef DEBUG_JUSTIFY
BOOL can_justify_stack_depth;	/* can be 0 or 1 if all code is correct */
#endif

typedef struct {
    int byte_len;		/*length in bytes */
    int cell_len;		/*length in cells */
} ht_run_info;

static int justify_start_position;	/* this is an index of char from which

					   justification can start (eg after "* " preceeding <li> text) */

static int ht_num_runs;		/*the number of runs filled */
static ht_run_info ht_runs[MAX_LINE];
static BOOL this_line_was_split;
static TextAnchor *last_anchor_of_previous_line;
static BOOL have_raw_nbsps = FALSE;

void ht_justify_cleanup(void)
{
    wait_for_this_stacked_elt = !ok_justify
#  ifdef USE_PRETTYSRC
	|| psrc_view
#  endif
	? 30000 /*MAX_NESTING */  + 2	/*some unreachable value */
	: -1;
    can_justify_here = TRUE;
    can_justify_this_line = TRUE;
    form_in_htext = FALSE;

    last_anchor_of_previous_line = NULL;
    this_line_was_split = FALSE;
    in_DT = FALSE;
    have_raw_nbsps = FALSE;
}

void mark_justify_start_position(void *text)
{
    if (text && ((HText *) text)->last_line)
	justify_start_position = ((HText *) text)->last_line->size;
}

#define REALLY_CAN_JUSTIFY(text) ( (wait_for_this_stacked_elt<0) && \
	( text->style->alignment == HT_LEFT     || \
	  text->style->alignment == HT_JUSTIFY) && \
	HTCJK == NOCJK && !in_DT && \
	can_justify_here && can_justify_this_line && !form_in_htext )

#endif /* EXP_JUSTIFY_ELTS */
d257 1
a257 1
 * Boring static variable used for moving cursor across
d267 2
a268 2
static char underscore_string[MAX_LINE + 1];
char star_string[MAX_LINE + 1];
d270 1
a270 2
static int ctrl_chars_on_this_line = 0;		/* num of ctrl chars in current line */
static int utfxtra_on_this_line = 0;	/* num of UTF-8 extra bytes in line,
d272 5
a276 6
					   they *also* count as ctrl chars. */
#ifdef WIDEC_CURSES
#define UTFXTRA_ON_THIS_LINE 0
#else
#define UTFXTRA_ON_THIS_LINE utfxtra_on_this_line
#endif
a277 5
static HTStyle default_style =
{0, "(Unstyled)", 0, "",
 (HTFont) 0, 1, HT_BLACK, 0, 0,
 0, 0, 0, HT_LEFT, 1, 0, 0,
 NO, NO, 0, 0, 0};
a278 2
static HTList *loaded_texts = NULL;	/* A list of all those in memory */
HTList *search_queries = NULL;	/* isindex and whereis queries   */
d280 2
d283 1
a283 1
static void free_all_texts(void);
d285 4
d290 3
a292 3
static BOOL HText_TrueEmptyLine(HTLine *line, HText *text, BOOL IgnoreSpaces);

static int HText_TrueLineSize(HTLine *line, HText *text, BOOL IgnoreSpaces);
d297 6
a302 6
 * text->halted = 1: have set fake 'Z' and output a message
 *		  2: next time when HText_appendCharacter is called
 *		     it will append *** MEMORY EXHAUSTED ***, then set
 *		     to 3.
 *		  3: normal text output will be suppressed (but not anchors,
 *		     form fields etc.)
d304 1
a304 1
static void HText_halt(void)
d317 14
a330 12
 * Check whether factor*min(bytes,MIN_NEEDED_MEM) is available,
 * or bytes if factor is 0.
 * MIN_NEEDED_MEM and factor together represent a security margin,
 * to take account of all the memory allocations where we don't check
 * and of buffers which may be emptied before HTCheckForInterupt()
 * is (maybe) called and other things happening, with some chance of
 * success.
 * This just tries to malloc() the to-be-checked-for amount of memory,
 * which might make the situation worse depending how allocation works.
 * There should be a better way...  - kw
 */
static BOOL mem_is_avail(size_t factor, size_t bytes)
a332 1

d347 7
a353 5
 * Replacement for calloc which checks for "enough" free memory
 * (with some security margins) and tries various recovery actions
 * if deemed necessary.  - kw
 */
static void *LY_check_calloc(size_t nmemb, size_t size)
a355 1

d361 13
a373 11
	HText *t = (HText *) HTList_objectAt(loaded_texts, i);

	CTRACE((tfp,
		"\nBUG *** Emergency freeing document %d/%d for '%s'%s!\n",
		i + 1, n,
		((t && t->node_anchor &&
		  t->node_anchor->address) ?
		 t->node_anchor->address : "unknown anchor"),
		((t && t->node_anchor &&
		  t->node_anchor->post_data) ?
		 " with POST data" : "")));
d399 1
a399 9
#endif /* CHECK_FREE_MEM */

/*
 * Clear highlight information for a given anchor
 * (text was allocated in the pool).
 */
static void LYClearHiText(TextAnchor *a)
{
    FREE(a->lites.hl_info);
d401 1
a401 3
    a->lites.hl_base.hl_text = NULL;
    a->lites.hl_len = 0;
}
d403 2
a404 1
#define LYFreeHiText(a)     FREE((a)->lites.hl_info)
d406 1
a406 114
/*
 * Set the initial highlight information for a given anchor.
 */
static void LYSetHiText(TextAnchor *a,
			const char *text,
			int len)
{
    if (text != NULL) {
	POOLallocstring(a->lites.hl_base.hl_text, len + 1);
	memcpy(a->lites.hl_base.hl_text, text, len);
	*(a->lites.hl_base.hl_text + len) = '\0';

	a->lites.hl_len = 1;
    }
}

/*
 * Add highlight information for the next line of a anchor.
 */
static void LYAddHiText(TextAnchor *a,
			const char *text,
			int x)
{
    HiliteInfo *have = a->lites.hl_info;
    unsigned need = (a->lites.hl_len - 1);
    unsigned want = (a->lites.hl_len += 1) * sizeof(HiliteInfo);

    if (have != NULL) {
	have = (HiliteInfo *) realloc(have, want);
    } else {
	have = (HiliteInfo *) malloc(want);
    }
    a->lites.hl_info = have;

    POOLallocstring(have[need].hl_text, strlen(text) + 1);
    strcpy(have[need].hl_text, text);
    have[need].hl_x = x;
}

/*
 * Return an offset to skip leading blanks in the highlighted link.  That is
 * needed to avoid having the color-style paint the leading blanks.
 */
#ifdef USE_COLOR_STYLE
static int LYAdjHiTextPos(TextAnchor *a, int count)
{
    char *result;

    if (count >= a->lites.hl_len)
	result = NULL;
    else if (count > 0)
	result = a->lites.hl_info[count - 1].hl_text;
    else
	result = a->lites.hl_base.hl_text;

    return (result != 0) ? (LYSkipBlanks(result) - result) : 0;
}
#else
#define LYAdjHiTextPos(a,count) 0
#endif

/*
 * Get the highlight text, counting from zero.
 */
static char *LYGetHiTextStr(TextAnchor *a, int count)
{
    char *result;

    if (count >= a->lites.hl_len)
	result = NULL;
    else if (count > 0)
	result = a->lites.hl_info[count - 1].hl_text;
    else
	result = a->lites.hl_base.hl_text;
    result += LYAdjHiTextPos(a, count);
    return result;
}

/*
 * Get the X-ordinate at which to draw the corresponding highlight-text
 */
static int LYGetHiTextPos(TextAnchor *a, int count)
{
    int result;

    if (count >= a->lites.hl_len)
	result = -1;
    else if (count > 0)
	result = a->lites.hl_info[count - 1].hl_x;
    else
	result = a->line_pos;
    result += LYAdjHiTextPos(a, count);
    return result;
}

/*
 * Copy highlighting information from anchor 'b' to 'a'.
 */
static void LYCopyHiText(TextAnchor *a, TextAnchor *b)
{
    int count;
    char *s;

    LYClearHiText(a);
    for (count = 0;; ++count) {
	if ((s = LYGetHiTextStr(b, count)) == NULL)
	    break;
	if (count == 0) {
	    LYSetHiText(a, s, strlen(s));
	} else {
	    LYAddHiText(a, s, LYGetHiTextPos(b, count));
	}
    }
}
d408 2
a409 1
static void HText_getChartransInfo(HText *me)
a413 1

d422 2
a423 1
static void PerFormInfo_free(PerFormInfo * form)
d432 2
a433 49
static void free_form_fields(FormInfo * input_field)
{
    /*
     * Free form fields.
     */
    if (input_field->type == F_OPTION_LIST_TYPE &&
	input_field->select_list != NULL) {
	/*
	 * Free off option lists if present.
	 * It should always be present for F_OPTION_LIST_TYPE
	 * unless we had invalid markup which prevented
	 * HText_setLastOptionValue from finishing its job
	 * and left the input field in an insane state.  - kw
	 */
	OptionType *optptr = input_field->select_list;
	OptionType *tmp;

	while (optptr) {
	    tmp = optptr;
	    optptr = tmp->next;
	    FREE(tmp->name);
	    FREE(tmp->cp_submit_value);
	    FREE(tmp);
	}
	input_field->select_list = NULL;
	/*
	 * Don't free the value field on option
	 * lists since it points to a option value
	 * same for orig value.
	 */
	input_field->value = NULL;
	input_field->orig_value = NULL;
	input_field->cp_submit_value = NULL;
	input_field->orig_submit_value = NULL;
    } else {
	FREE(input_field->value);
	FREE(input_field->orig_value);
	FREE(input_field->cp_submit_value);
	FREE(input_field->orig_submit_value);
    }
    FREE(input_field->name);
    FREE(input_field->submit_action);
    FREE(input_field->submit_enctype);
    FREE(input_field->submit_title);

    FREE(input_field->accept_cs);
}

static void FormList_delete(HTList *forms)
d437 1
a437 2

    while ((form = (PerFormInfo *) HTList_nextObject(cur)) != NULL)
a441 10
#ifdef DISP_PARTIAL
static void ResetPartialLinenos(HText *text)
{
    if (text != 0) {
	text->first_lineno_last_disp_partial = -1;
	text->last_lineno_last_disp_partial = -1;
    }
}
#endif

d443 4
a446 3
 *			---------------
 */
HText *HText_new(HTParentAnchor *anchor)
d450 1
a450 1
    int status, VMType = 3, VMTotal;
d452 2
a453 3
    HTLine *line = NULL;
    HText *self = typecalloc(HText);

a456 2
    CTRACE((tfp, "GridText: start HText_new\n"));

d459 1
a459 1
    CTRACE((tfp, "GridText: VMTotal = %d\n", VMTotal));
d462 1
a462 17
    /*
     * If the previously shown text had UTF-8 characters on screen,
     * remember this in the newly created object.  Do this now, before
     * the previous object may become invalid.  - kw
     */
    if (HTMainText) {
	if (HText_hasUTF8OutputSet(HTMainText) &&
	    HTLoadedDocumentEightbit() &&
	    LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
	    self->had_utf8 = HTMainText->has_utf8;
	} else {
	    self->had_utf8 = HTMainText->has_utf8;
	}
	HTMainText->has_utf8 = NO;
    }

    if (!loaded_texts) {
d470 5
a474 4
     * Links between anchors & documents are a 1-1 relationship.  If
     * an anchor is already linked to a document we didn't call
     * HTuncache_current_document(), so we'll check now
     * and free it before reloading.  - Dick Wesseling (ftu@@fi.ruu.nl)
d478 3
a480 5
	CTRACE((tfp, "GridText: Auto-uncaching\n"));

	HTAnchor_delete_links(anchor);
	((HText *) anchor->document)->node_anchor = NULL;
	HText_free((HText *) anchor->document);
d492 2
a493 2
	CTRACE((tfp, "GridText: Freeing off cached doc.\n"));
	HText_free((HText *) HTList_removeFirstObject(loaded_texts));
d496 1
a496 1
	CTRACE((tfp, "GridText: VMTotal reduced to %d\n", VMTotal));
d500 2
a501 2
    self->pool = POOL_NEW();
    if (!self->pool)
a502 2

    line = self->last_line = TEMP_LINE(self, 0);
a504 1
    line->data[line->size] = '\0';
a506 1
    line->styles = stylechanges_buffers[0];
d508 1
a508 1
    self->Lines = 0;
a509 1
    self->last_anchor_before_split = NULL;
d517 15
a531 1
#ifdef USE_SOURCE_CACHE
a536 1
    self->verbose_img = verbose_img;
d542 2
a543 3
    self->keypad_mode = keypad_mode;
    self->disp_lines = LYlines;
    self->disp_cols = DISPLAY_COLS;
d546 7
a552 7
     * If we are going to render the List Page, always merge in hidden
     * links to get the numbering consistent if form fields are numbered
     * and show up as hidden links in the list of links.
     * If we are going to render a bookmark file, also always merge in
     * hidden links, to get the link numbers consistent with the counting
     * in remove_bookmark_link().  Normally a bookmark file shouldn't
     * contain any entries with empty titles, but it might happen.  - kw
d555 1
a555 2
	LYIsUIPage3(anchor->address, UIP_LIST_PAGE, 0) ||
	LYIsUIPage3(anchor->address, UIP_ADDRLIST_PAGE, 0))
d560 2
a561 4
    self->no_cache = ((anchor->no_cache ||
		       anchor->post_data)
		      ? YES
		      : NO);
d565 1
a565 1
#ifndef USE_PRETTYSRC
d571 1
a571 10
    /* mark_htext_as_source == TRUE if we are parsing html file (and psrc_view
     * is set temporary to false at creation time)
     *
     * psrc_view == TRUE if source of the text produced by some lynx module
     * (like ftp browsers) is requested).  - VH
     */
    self->source = (BOOL) (LYpsrc
			   ? mark_htext_as_source || psrc_view
			   : HTOutputFormat == WWW_SOURCE);
    mark_htext_as_source = FALSE;
d573 2
a574 2
    HTAnchor_setDocument(anchor, (HyperDoc *) self);
    HTFormNumber = 0;		/* no forms started yet */
a578 6
    self->specified_kcode = NOKANJI;
#ifdef USE_TH_JP_AUTO_DETECT
    self->detected_kcode = DET_NOTYET;
    self->SJIS_status = SJIS_state_neutral;
    self->EUC_status = EUC_state_neutral;
#endif
d590 1
a590 1
     * Check the kcode setting if the anchor has a charset element.  -FM
d592 3
a594 2
    HText_setKcode(self, anchor->charset,
		   HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT));
d597 4
a600 4
     * Memory leak fixed.
     * 05-29-94 Lynx 2-3-1 Garrett Arch Blythe
     * Check to see if our underline and star_string need initialization
     * if the underline is not filled with dots.
d604 1
a604 1
	 * Create an array of dots for the UNDERSCORES macro.  -FM
d606 2
a607 2
	memset(underscore_string, '.', (MAX_LINE - 1));
	underscore_string[(MAX_LINE - 1)] = '\0';
d610 1
a610 1
	 * Create an array of underscores for the STARS macro.  -FM
d612 2
a613 2
	memset(star_string, '_', (MAX_LINE - 1));
	star_string[(MAX_LINE - 1)] = '\0';
d617 1
a617 1
    underline_on = FALSE;	/* reset */
d622 1
a622 1
     * By this function we create HText object
d625 2
a626 4
    if (display_partial_flag) {
	display_partial = TRUE;	/* enable HTDisplayPartial() */
	NumOfLines_partial = 0;	/* initialize */
    }
d629 4
a632 4
     * These two fields should only be set to valid line numbers
     * by calls of display_page during partial displaying.  This
     * is just so that the FIRST display_page AFTER that can avoid
     * repainting the same lines on the screen.  - kw
d634 2
a635 1
    ResetPartialLinenos(self);
d638 2
a639 3
#ifdef EXP_JUSTIFY_ELTS
    ht_justify_cleanup();
#endif
d644 8
a651 6
 *			---------------
 *
 *      Stream is assumed open and left open.
 */
HText *HText_new2(HTParentAnchor *anchor,
		  HTStream *stream)
d653 1
a653 1
    HText *result = HText_new(anchor);
d656 2
a657 2
	result->target = stream;
	result->targetClass = *stream->isa;	/* copy action procedures */
d659 1
a659 1
    return result;
d663 4
a666 3
 *	----------------
 */
void HText_free(HText *self)
d671 1
a671 4
#if HTLINE_NOT_IN_POOL
    {
	HTLine *f = FirstHTLine(self);
	HTLine *l = self->last_line;
d673 5
a677 1
	while (l != f) {	/* Free off line array */
d679 9
a687 2
	    freeHTLine(self, l);
	    l = self->last_line;
a688 1
	freeHTLine(self, f);
a689 4
#endif

    while (self->first_anchor) {	/* Free off anchor array */
	TextAnchor *l = self->first_anchor;
d691 2
d696 45
a740 1
	    free_form_fields(l->input_field);
d743 4
a746 1
	LYFreeHiText(l);
d751 1
a751 1
     * Free the tabs list.  -FM
d754 2
a755 2
	HTTabID *Tab = NULL;
	HTList *cur = self->tabs;
d757 1
a757 1
	while (NULL != (Tab = (HTTabID *) HTList_nextObject(cur))) {
d766 1
a766 1
     * Free the hidden links list.  -FM
d769 6
a774 1
	LYFreeStringList(self->hidden_links);
d779 2
a780 2
     * Invoke HTAnchor_delete() to free the node_anchor
     * if it is not a destination of other links.  -FM
d787 1
a787 15
#ifdef USE_SOURCE_CACHE
	/* Remove source cache files and chunks always, even if the
	 * HTAnchor_delete call does not actually remove the anchor.
	 * Keeping them would just be a waste of space - they won't
	 * be used any more after the anchor has been disassociated
	 * from a HText structure. - kw
	 */
	HTAnchor_clearSourceCache(self->node_anchor);
#endif

	HTAnchor_delete_links(self->node_anchor);

	HTAnchor_setDocument(self->node_anchor, (HyperDoc *) 0);

	if (HTAnchor_delete(self->node_anchor->parent))
d789 2
a790 2
	     * Make sure HTMainAnchor won't point
	     * to an invalid structure.  - KW
d795 17
a811 1
    POOL_FREE(self->pool);
d816 3
a818 2
 *		---------------
 */
d821 5
a825 4
 *	-------------
 */
static int display_line(HTLine *line, HText *text, int scrline GCC_UNUSED,
			const char *target GCC_UNUSED)
a830 2
    char LastDisplayChar = ' ';

a832 18

#define inunderline NO
#define inbold NO
#else
    BOOL inbold = NO, inunderline = NO;
#endif
#if defined(SHOW_WHEREIS_TARGETS) && !defined(USE_COLOR_STYLE)
    const char *cp_tgt;
    int i_start_tgt = 0, i_after_tgt;
    int HitOffset, LenNeeded;
    BOOL intarget = NO;

#else
#define intarget NO
#endif /* SHOW_WHEREIS_TARGETS && !USE_COLOR_STYLE */

#if !(defined(NCURSES_VERSION) || defined(WIDEC_CURSES))
    text->has_utf8 = NO;	/* use as per-line flag, except with ncurses */
d834 1
d837 3
a839 3
     * Set up the multibyte character buffer,
     * and clear the line to which we will be
     * writing.
d842 1
a842 1
    LYclrtoeol();
d845 2
a846 2
     * Add offset, making sure that we do not
     * go over the COLS limit on the display.
d848 3
a850 3
    j = (int) line->offset;
    if (j >= DISPLAY_COLS)
	j = DISPLAY_COLS - 1;
d852 1
a852 1
    SLsmg_forward(j);
d860 2
a861 2
	for (i = 0; i < j; i++)
	    LYaddch(' ');
d865 2
a866 2
     * Add the data, making sure that we do not
     * go over the COLS limit on the display.
d870 1
a870 56

#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
    /*
     * If the target is on this line, it will be emphasized.
     */
    i_after_tgt = i;
    if (target) {
	cp_tgt = LYno_attr_mb_strstr(data,
				     target,
				     text->T.output_utf8, YES,
				     &HitOffset,
				     &LenNeeded);
	if (cp_tgt) {
	    if (((int) line->offset + LenNeeded) >= DISPLAY_COLS) {
		cp_tgt = NULL;
	    } else {
		text->page_has_target = YES;
		i_start_tgt = i + HitOffset;
		i_after_tgt = i + LenNeeded;
	    }
	}
    } else {
	cp_tgt = NULL;
    }
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */

    while ((i <= DISPLAY_COLS) && ((buffer[0] = *data) != '\0')) {

#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
	if (cp_tgt && i >= i_after_tgt) {
	    if (intarget) {
		cp_tgt = LYno_attr_mb_strstr(data,
					     target,
					     text->T.output_utf8, YES,
					     &HitOffset,
					     &LenNeeded);
		if (cp_tgt) {
		    i_start_tgt = i + HitOffset;
		    i_after_tgt = i + LenNeeded;
		}
		if (!cp_tgt || i_start_tgt != i) {
		    LYstopTargetEmphasis();
		    intarget = NO;
		    if (inbold)
			lynx_start_bold();
		    if (inunderline)
			lynx_start_underline();
		}
	    }
	}
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */

d877 4
a880 3
	       i >= (int) (CStyle.horizpos + line->offset + 1)) {
	    LynxChangeStyle(CStyle.style, CStyle.direction);
	    current_style++;
d886 6
a891 15
	case LY_UNDERLINE_START_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		inunderline = YES;
		if (!intarget) {
#if defined(PDCURSES)
		    if (LYShowColor == SHOW_COLOR_NEVER)
			lynx_start_bold();
		    else
			lynx_start_underline();
#else
		    lynx_start_underline();
#endif /* PDCURSES */
d893 1
a893 2
	    }
	    break;
d895 6
a900 15
	case LY_UNDERLINE_END_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		inunderline = NO;
		if (!intarget) {
#if defined(PDCURSES)
		    if (LYShowColor == SHOW_COLOR_NEVER)
			lynx_stop_bold();
		    else
			lynx_stop_underline();
#else
		    lynx_stop_underline();
#endif /* PDCURSES */
d902 1
a902 2
	    }
	    break;
d904 3
a906 5
	case LY_BOLD_START_CHAR:
	    inbold = YES;
	    if (!intarget)
		lynx_start_bold();
	    break;
d908 3
a910 5
	case LY_BOLD_END_CHAR:
	    inbold = NO;
	    if (!intarget)
		lynx_stop_bold();
	    break;
a911 7
#endif /* !USE_COLOR_STYLE */
	case LY_SOFT_NEWLINE:
	    if (!dump_output_immediately) {
		LYaddch('+');
		i++;
#if defined(SHOW_WHEREIS_TARGETS) && !defined(USE_COLOR_STYLE)
		i_after_tgt++;
d913 6
a918 2
	    }
	    break;
d920 22
a941 22
	case LY_SOFT_HYPHEN:
	    if (*data != '\0' ||
		isspace(UCH(LastDisplayChar)) ||
		LastDisplayChar == '-') {
		/*
		 * Ignore the soft hyphen if it is not the last
		 * character in the line.  Also ignore it if it
		 * first character following the margin, or if it
		 * is preceded by a white character (we loaded 'M'
		 * into LastDisplayChar if it was a multibyte
		 * character) or hyphen, though it should have
		 * been excluded by HText_appendCharacter() or by
		 * split_line() in those cases.  -FM
		 */
		break;
	    } else {
		/*
		 * Make it a hard hyphen and fall through.  -FM
		 */
		buffer[0] = '-';
	    }
	    /* FALLTHRU */
d943 26
a968 10
	default:
#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
	    if (!intarget && cp_tgt && i >= i_start_tgt) {
		/*
		 * Start the emphasis.
		 */
		if (data > cp_tgt) {
		    LYstartTargetEmphasis();
		    intarget = YES;
d970 11
a980 25
	    }
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */
	    i++;
	    if (text->T.output_utf8 && is8bits(buffer[0])) {
		text->has_utf8 = YES;
		utf_extra = utf8_length(text->T.output_utf8, data - 1);
		LastDisplayChar = 'M';
	    }
	    if (utf_extra) {
		strncpy(&buffer[1], data, utf_extra);
		buffer[utf_extra + 1] = '\0';
		LYaddstr(buffer);
		buffer[1] = '\0';
		data += utf_extra;
		utf_extra = 0;
	    } else if (HTCJK != NOCJK && is8bits(buffer[0])
#ifndef CONV_JISX0201KANA_JISX0208KANA
		       && kanji_code != SJIS
#endif
		) {
		/*
		 * For CJK strings, by Masanobu Kimura.
		 */
		if (i < DISPLAY_COLS) {
a981 1
		    buffer[2] = '\0';
d983 1
a983 2
		    i++;
		    LYaddstr(buffer);
d986 9
a994 7
		     * For now, load 'M' into LastDisplayChar, but we should
		     * check whether it's white and if so, use ' '.  I don't
		     * know if there actually are white CJK characters, and
		     * we're loading ' ' for multibyte spacing characters in
		     * this code set, but this will become an issue when the
		     * development code set's multibyte character handling is
		     * used.  -FM
d997 3
d1001 2
a1002 6
	    } else {
		LYaddstr(buffer);
		LastDisplayChar = buffer[0];
	    }
	}			/* end of switch */
    }				/* end of while */
a1003 6
#if !(defined(NCURSES_VERSION) || defined(WIDEC_CURSES))
    if (text->has_utf8) {
	LYtouchline(scrline);
	text->has_utf8 = NO;	/* we had some, but have dealt with it. */
    }
#endif
d1005 1
a1005 1
     * Add the return.
d1007 1
a1007 1
    LYaddch('\n');
a1008 6
#if defined(SHOW_WHEREIS_TARGETS) && !defined(USE_COLOR_STYLE)
    if (intarget)
	LYstopTargetEmphasis();
#else
#undef intarget
#endif /* SHOW_WHEREIS_TARGETS && !USE_COLOR_STYLE */
d1010 2
a1011 2
    lynx_stop_underline();
    lynx_stop_bold();
d1013 3
a1015 2
    while (current_style < line->numstyles) {
	LynxChangeStyle(CStyle.style, CStyle.direction);
d1020 1
a1020 1
    return (0);
d1024 4
a1027 3
 *	---------------------
 */
static void display_title(HText *text)
d1031 1
d1033 1
a1033 2
    int i = 0, j = 0, toolbar = 0;
    int limit;
d1036 1
a1036 1
     * Make sure we have a text structure.  -FM
d1041 1
a1041 1
    lynx_start_title_color();
d1045 1
a1045 1
	LynxChangeStyle(s_title, STACK_ON);
d1047 1
a1047 1
	LynxChangeStyle(s_title, ABS_ON);
d1052 1
a1052 1
     * Load the title field.  -FM
d1056 12
a1067 2
		  HTAnchor_title(text->node_anchor) : " "));	/* "" -> " " */
    LYReduceBlanks(title);
d1070 1
a1070 1
     * Generate the page indicator (percent) string.
d1072 1
a1072 9
    limit = LYscreenWidth();
    if (limit < 10) {
	percent[0] = '\0';	/* Null string */
    } else if ((display_lines) <= 0 && LYlines > 0 &&
	       text->top_of_screen <= 99999 && text->Lines <= 999999) {
	sprintf(percent, " (l%d of %d)",
		text->top_of_screen, text->Lines);
    } else if ((text->Lines + 1) > (display_lines) &&
	       (display_lines) > 0) {
d1074 2
a1075 2
	 * In a small attempt to correct the number of pages counted....
	 * GAB 07-14-94
d1077 2
a1078 2
	 * In a bigger attempt (hope it holds up 8-)....
	 * FM 02-08-95
d1081 1
a1081 1
	(((text->Lines + 1) + (display_lines - 1)) / (display_lines));
d1083 2
a1084 2
	((text->Lines + 1) < display_lines) ? 0 :
	((text->Lines + 1) - display_lines);
d1088 2
a1089 2
		 total_pages :
		 ((text->top_of_screen + display_lines) / (display_lines))),
d1096 3
a1098 3
     * Generate and display the title string, with page indicator
     * if appropriate, preceded by the toolbar token if appropriate,
     * and truncated if necessary.  -FM & KW
d1102 1
a1102 1
	    (tmp = typecallocn(unsigned char, (strlen(title) + 256)))) {
d1104 1
a1104 1
		TO_EUC((unsigned char *) title, tmp);
d1106 1
a1106 1
		TO_SJIS((unsigned char *) title, tmp);
d1109 1
a1109 1
		    if (title[i] != CH_ESC) {	/* S/390 -- gil -- 1487 */
d1115 1
a1115 1
	    StrAllocCopy(title, (const char *) tmp);
d1119 4
a1122 27
    LYmove(0, 0);
    LYclrtoeol();
#if defined(SH_EX) && defined(KANJI_CODE_OVERRIDE)
    LYaddstr(str_kcode(last_kcode));
#endif
    if (HText_hasToolbar(text)) {
	LYaddch('#');
	toolbar = 1;
    }
#ifdef USE_COLOR_STYLE
    if (s_forw_backw != NOSTYLE && (nhist || nhist_extra > 1)) {
	int c = nhist ? ACS_LARROW : ' ';

	/* turn the FORWBACKW.ARROW style on */
	LynxChangeStyle(s_forw_backw, STACK_ON);
	if (nhist) {
	    LYaddch(c);
	    LYaddch(c);
	    LYaddch(c);
	} else
	    LYmove(0, 3 + toolbar);
	if (nhist_extra > 1) {
	    LYaddch(ACS_RARROW);
	    LYaddch(ACS_RARROW);
	    LYaddch(ACS_RARROW);
	}
	LynxChangeStyle(s_forw_backw, STACK_OFF);
d1124 3
a1126 10
#endif /* USE_COLOR_STYLE */
#ifdef WIDEC_CURSES
    i = limit - LYbarWidth - strlen(percent) - LYstrCells(title);
    if (i <= 0)
	i = 0;
    LYmove(0, i);
#else
    i = (limit - 1) - strlen(percent) - strlen(title);
    if (i >= CHAR_WIDTH) {
	LYmove(0, i);
d1129 3
a1131 2
	 * Truncation takes into account the possibility that
	 * multibyte characters might be present.  -HS (H.  Senshu)
d1133 2
a1134 11
	int last;

	last = (int) strlen(percent) + CHAR_WIDTH;
	if (limit - 3 >= last) {
	    title[(limit - 3) - last] = '.';
	    title[(limit - 2) - last] = '.';
	    title[(limit - 1) - last] = '\0';
	} else {
	    title[(limit - 1) - last] = '\0';
	}
	LYmove(0, CHAR_WIDTH);
d1136 1
a1136 2
#endif
    LYaddstr(title);
d1138 2
a1139 2
	LYaddstr(percent);
    LYaddch('\n');
a1141 10
#if defined(USE_COLOR_STYLE) && defined(CAN_CUT_AND_PASTE)
    if (s_hot_paste != NOSTYLE) {	/* Only if the user set the style */
	LYmove(0, LYcolLimit);
	LynxChangeStyle(s_hot_paste, STACK_ON);
	LYaddch(ACS_RARROW);
	LynxChangeStyle(s_hot_paste, STACK_OFF);
	LYmove(1, 0);		/* As after \n */
    }
#endif /* USE_COLOR_STYLE */

d1144 1
a1144 98
    LynxChangeStyle(s_title, STACK_OFF);
#endif /* USE_COLOR_STYLE */
    lynx_stop_title_color();

    return;
}

/*	Output the scrollbar
 *	---------------------
 */
#ifdef USE_SCROLLBAR
static void display_scrollbar(HText *text)
{
    int i;
    int h = display_lines - 2 * (LYsb_arrow != 0);	/* Height of the scrollbar */
    int off = (LYsb_arrow != 0);	/* Start of the scrollbar */
    int top_skip, bot_skip, sh, shown;

    LYsb_begin = LYsb_end = -1;
    if (!LYShowScrollbar || !text || h <= 2
	|| (text->Lines + 1) <= display_lines)
	return;

    if (text->top_of_screen >= text->Lines + 1 - display_lines) {
	/* Only part of the screen shows actual text */
	shown = text->Lines + 1 - text->top_of_screen;

	if (shown <= 0)
	    shown = 1;
    } else
	shown = display_lines;
    /* Each cell of scrollbar represents text->Lines/h lines of text. */
    /* Always smaller than h */
    sh = (shown * h + text->Lines / 2) / (text->Lines + 1);
    if (sh <= 0)
	sh = 1;
    if (sh >= h - 1)
	sh = h - 2;		/* Position at ends indicates BEG and END */

    if (text->top_of_screen == 0)
	top_skip = 0;
    else if (text->Lines - (text->top_of_screen + display_lines - 1) <= 0)
	top_skip = h - sh;
    else {
	/* text->top_of_screen between 1 and text->Lines - display_lines
	   corresponds to top_skip between 1 and h - sh - 1 */
	/* Use rounding to get as many positions into top_skip==h - sh - 1
	   as into top_skip == 1:
	   1--->1, text->Lines - display_lines + 1--->h - sh. */
	top_skip = (int) (1 +
			  1. * (h - sh - 1) * text->top_of_screen
			  / (text->Lines - display_lines + 1));
    }
    bot_skip = h - sh - top_skip;

    LYsb_begin = top_skip;
    LYsb_end = h - bot_skip;

    if (LYsb_arrow) {
#ifdef USE_COLOR_STYLE
	int s = top_skip ? s_sb_aa : s_sb_naa;

	if (last_colorattr_ptr > 0) {
	    LynxChangeStyle(s, STACK_ON);
	} else {
	    LynxChangeStyle(s, ABS_ON);
	}
#endif /* USE_COLOR_STYLE */
	LYmove(1, LYcolLimit + LYshiftWin);
	addch_raw(ACS_UARROW);
#ifdef USE_COLOR_STYLE
	LynxChangeStyle(s, STACK_OFF);
#endif /* USE_COLOR_STYLE */
    }
#ifdef USE_COLOR_STYLE
    if (last_colorattr_ptr > 0) {
	LynxChangeStyle(s_sb_bg, STACK_ON);
    } else {
	LynxChangeStyle(s_sb_bg, ABS_ON);
    }
#endif /* USE_COLOR_STYLE */

    for (i = 1; i <= h; i++) {
#ifdef USE_COLOR_STYLE
	if (i - 1 <= top_skip && i > top_skip)
	    LynxChangeStyle(s_sb_bar, STACK_ON);
	if (i - 1 <= h - bot_skip && i > h - bot_skip)
	    LynxChangeStyle(s_sb_bar, STACK_OFF);
#endif /* USE_COLOR_STYLE */
	LYmove(i + off, LYcolLimit + LYshiftWin);
	if (i > top_skip && i <= h - bot_skip) {
	    LYaddch(ACS_BLOCK);
	} else {
	    LYaddch(ACS_CKBOARD);
	}
    }
#ifdef USE_COLOR_STYLE
    LynxChangeStyle(s_sb_bg, STACK_OFF);
d1146 1
a1147 16
    if (LYsb_arrow) {
#ifdef USE_COLOR_STYLE
	int s = bot_skip ? s_sb_aa : s_sb_naa;

	if (last_colorattr_ptr > 0) {
	    LynxChangeStyle(s, STACK_ON);
	} else {
	    LynxChangeStyle(s, ABS_ON);
	}
#endif /* USE_COLOR_STYLE */
	LYmove(h + 2, LYcolLimit + LYshiftWin);
	addch_raw(ACS_DARROW);
#ifdef USE_COLOR_STYLE
	LynxChangeStyle(s, STACK_OFF);
#endif /* USE_COLOR_STYLE */
    }
a1149 3
#else
#define display_scrollbar(text)	/*nothing */
#endif /* USE_SCROLLBAR */
d1152 6
a1157 4
 *	-------------
 */
static void display_page(HText *text, int line_number,
			 const char *target)
d1159 1
a1159 1
    HTLine *line = NULL;
d1161 2
a1162 3

#if defined(USE_COLOR_STYLE) && defined(SHOW_WHEREIS_TARGETS)
    const char *cp;
a1166 1
    int stop_before_for_anchors;
a1172 1

d1181 3
a1183 3
	 * Check whether to force a screen clear to enable scrollback,
	 * or as a hack to fix a reverse clear screen problem for some
	 * curses packages.  - shf@@access.digex.net & seldon@@eskimo.com
d1186 7
a1192 7
	    LYaddch('*');
	    LYrefresh();
	    LYclear();
	}
	LYaddstr("\n\nError accessing document!\nNo data available!\n");
	LYrefresh();
	nlinks = 0;		/* set number of links to 0 */
d1195 1
d1199 2
a1200 1
	ResetPartialLinenos(text);
a1204 2
    if (target && *target == '\0')
	target = NULL;
a1205 7
    if (display_lines <= 0) {
	/* No screen space to display anything!
	 * returning here makes it more likely we will survive if
	 * an xterm is temporarily made very small.  - kw */
	return;
    }

d1210 1
a1210 1
     * Constrain the line number to be within the document.
d1219 1
a1219 1
    for (i = 0, line = FirstHTLine(text);	/* Find line */
d1221 1
a1221 1
	 i++, line = line->next) {	/* Loop */
d1227 7
a1233 7
		LYaddch('*');
		LYrefresh();
		LYclear();
	    }
	    LYaddstr("\n\nError drawing page!\nBad HText structure!\n");
	    LYrefresh();
	    nlinks = 0;		/* set number of links to 0 */
d1239 1
a1239 1
    }				/* Loop */
d1243 5
a1247 5
    /*
     * current_char_set has changed since last invocation,
     * and it's not just 7-bit.
     * Also we don't want to do this for -dump and -source etc.
     */
d1249 1
d1251 1
d1253 1
a1253 1
	 * Currently implemented only for LINUX
d1257 1
a1258 1
	charset_last_displayed = current_char_set;
d1262 3
a1264 3
     * Check whether to force a screen clear to enable scrollback,
     * or as a hack to fix a reverse clear screen problem for some
     * curses packages.  - shf@@access.digex.net & seldon@@eskimo.com
d1267 3
a1269 3
	LYaddch('*');
	LYrefresh();
	LYclear();
d1271 1
d1274 4
a1277 4
     * Reset stack of color attribute changes to avoid color leaking,
     * except if what we last displayed from this text was the previous
     * screenful, in which case carrying over the state might be beneficial
     * (although it shouldn't generally be needed any more).  - kw
d1286 2
a1287 3
    text->top_of_screen_line = line;
    display_title(text);	/* will move cursor to top of screen */
    display_flag = TRUE;
d1295 1
a1295 1
	LynxResetScreenCache();
a1297 9
#ifdef DISP_PARTIAL
    if (display_partial && text->stbl) {
	stop_before_for_anchors = Stbl_getStartLineDeep(text->stbl);
	if (stop_before_for_anchors > line_number + (display_lines))
	    stop_before_for_anchors = line_number + (display_lines);
    } else
#endif
	stop_before_for_anchors = line_number + (display_lines);

d1299 1
a1299 1
     * Output the page.
d1302 1
a1302 1
#if defined(USE_COLOR_STYLE) && defined(SHOW_WHEREIS_TARGETS)
d1304 1
a1304 1
	int offset, LenNeeded;
d1306 1
a1306 8
#ifdef DISP_PARTIAL
	if (display_partial ||
	    line_number != text->first_lineno_last_disp_partial)
	    text->has_utf8 = NO;
#else
	text->has_utf8 = NO;
#endif
	for (i = 0; i < (display_lines); i++) {
d1308 1
a1308 1
	     * Verify and display each line.
d1315 7
a1321 7
		    LYaddch('*');
		    LYrefresh();
		    LYclear();
		}
		LYaddstr("\n\nError drawing page!\nBad HText structure!\n");
		LYrefresh();
		nlinks = 0;	/* set number of links to 0 */
d1332 1
a1332 1
		LYmove((i + 2), 0);
d1335 1
a1335 1
		display_line(line, text, i + 1, target);
d1337 1
a1337 2
#if defined(SHOW_WHEREIS_TARGETS)
#ifdef USE_COLOR_STYLE		/* otherwise done in display_line - kw */
d1339 2
a1340 2
	     * If the target is on this line, recursively
	     * seek and emphasize it.  -FM
d1342 15
a1356 9
	    data = (char *) line->data;
	    offset = (int) line->offset;
	    while (non_empty(target) &&
		   (cp = LYno_attr_mb_strstr(data,
					     target,
					     text->T.output_utf8, YES,
					     NULL,
					     &LenNeeded)) != NULL &&
		   ((int) line->offset + LenNeeded) <= DISPLAY_COLS) {
d1359 1
a1359 1
		int x_pos = offset + (int) (cp - data);
d1367 1
a1367 1
		 * Start the emphasis.
d1372 1
a1372 1
		 * Output the target characters.
d1376 1
a1376 1
		     itmp++) {
d1379 1
a1379 1
			 * Ignore special characters.
d1383 38
a1420 2
		    } else if (&data[itmp] >= cp) {
			if (cp == &data[itmp]) {
d1422 1
a1422 1
			     * First printable character of target.
d1424 7
a1430 1
			    LYmove((i + 1), x_pos);
d1432 2
d1435 1
a1435 1
			 * Output all the printable target chars.
d1437 24
a1460 1
			utf_extra = utf8_length(text->T.output_utf8, data + itmp);
d1462 2
a1463 2
			    strncpy(&tmp[1], &line->data[itmp + 1], utf_extra);
			    tmp[utf_extra + 1] = '\0';
d1465 1
a1465 1
			    LYaddstr(tmp);
d1469 1
a1469 1
			} else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d1471 1
a1471 1
			     * For CJK strings, by Masanobu Kimura.
d1474 1
a1474 1
			    LYaddstr(tmp);
d1478 1
a1478 1
			    LYaddstr(tmp);
d1485 3
a1487 3
		 * Stop the emphasis, and reset the offset and
		 * data pointer for our current position in the
		 * line.  -FM
d1491 1
a1491 1
		data = (char *) &data[itmp];
d1494 3
a1496 3
		 * Adjust the cursor position, should we be at
		 * the end of the line, or not have another hit
		 * in it.  -FM
d1498 3
a1500 4
		LYmove((i + 2), 0);
	    }			/* end while */
#endif /* USE_COLOR_STYLE */
#endif /* SHOW_WHEREIS_TARGETS */
d1503 2
a1504 2
	     * Stop if this is the last line.  Otherwise, make sure
	     * display_flag is set and process the next line.  -FM
d1508 1
a1508 1
		 * Clear remaining lines of display.
d1511 2
a1512 2
		    LYmove((i + 1), 0);
		    LYclrtoeol();
d1519 2
a1520 2
		 * Remember as fully shown during last partial display,
		 * if it was not the last text line.  - kw
d1527 3
a1529 3
	}			/* end of "Verify and display each line." loop */
    }
    /* end "Output the page." */
d1534 1
a1534 1
     * Add the anchors to Lynx structures.
d1537 16
a1552 28
    for (Anchor_ptr = text->first_anchor;
	 Anchor_ptr != NULL && Anchor_ptr->line_num <= stop_before_for_anchors;
	 Anchor_ptr = Anchor_ptr->next) {

	if (Anchor_ptr->line_num >= line_number
	    && Anchor_ptr->line_num < stop_before_for_anchors) {
	    char *hi_string = LYGetHiTextStr(Anchor_ptr, 0);

	    /*
	     * Load normal hypertext anchors.
	     */
	    if (Anchor_ptr->show_anchor
		&& non_empty(hi_string)
		&& (Anchor_ptr->link_type & HYPERTEXT_ANCHOR)) {
		int count;
		char *s;

		for (count = 0;; ++count) {
		    s = LYGetHiTextStr(Anchor_ptr, count);
		    if (count == 0)
			LYSetHilite(nlinks, s);
		    if (s == NULL)
			break;
		    if (count != 0) {
			LYAddHilite(nlinks, s, LYGetHiTextPos(Anchor_ptr, count));
		    }
		}

d1558 2
a1559 1
		link_dest = HTAnchor_followLink(Anchor_ptr->anchor);
d1562 2
a1563 2
		     * Memory leak fixed 05-27-94
		     * Garrett Arch Blythe
a1565 1

d1572 1
a1572 1
									 Anchor_ptr->anchor, HTInternalLink);
d1575 3
a1577 3
				CTRACE((tfp,
					"GridText: display_page: unexpected typed link to %s!\n",
					link_dest_intl->parent->address));
a1583 1

d1604 1
a1604 1
		links[nlinks].l_form = NULL;
d1610 1
a1610 1
		       && Anchor_ptr->input_field->type != F_HIDDEN_TYPE) {
d1612 1
a1612 1
		 * Handle form fields.
d1621 1
a1621 1
		links[nlinks].l_form = FormInfo_ptr;
d1630 5
a1634 4
		    LYSetHilite(nlinks,
				FormInfo_ptr->num_value
				? checked_radio
				: unchecked_radio);
d1636 5
a1640 4
		    LYSetHilite(nlinks,
				FormInfo_ptr->num_value
				? checked_box
				: unchecked_box);
d1642 4
a1645 6
		    /* FIXME: use LYstrExtent, not strlen */
		    LYSetHilite(nlinks,
				STARS(strlen(FormInfo_ptr->value)));
		} else {	/* TEXT type */
		    LYSetHilite(nlinks,
				FormInfo_ptr->value);
d1648 6
d1656 1
a1656 1
		 * Bold the link after incrementing nlinks.
d1658 1
a1658 1
		LYhighlight(OFF, (nlinks - 1), target);
d1664 1
a1664 1
		 * Not showing anchor.
d1666 2
a1667 2
		if (non_empty(hi_string))
		    CTRACE((tfp,
d1669 1
a1669 1
			    hi_string));
d1673 6
d1681 2
a1682 2
	     * Links array is full.  If interactive, tell user
	     * to use half-page or two-line scrolling.  -FM
d1687 1
a1687 1
	    CTRACE((tfp, "\ndisplay_page: MAXLINKS reached.\n"));
d1690 1
a1690 1
    }				/* end of loop "Add the anchors to Lynx structures." */
d1693 2
a1694 2
     * Free any un-reallocated links[] entries
     * from the previous page draw.  -FM
d1696 2
a1697 1
    LYFreeHilites(nlinks, last_nlinks);
d1701 3
a1703 3
     * If Anchor_ptr is not NULL and is not pointing to the last
     * anchor, then there are anchors farther down in the document,
     * and we need to flag this for traversals.
d1713 1
a1713 1
	 * Nothing on the page.
d1715 1
a1715 1
	LYaddstr("\n     Document is empty");
a1716 1
    display_scrollbar(text);
d1726 2
a1727 1
	ResetPartialLinenos(text);
d1731 1
a1731 9
#if !defined(WIDEC_CURSES)
    if (text->has_utf8 || text->had_utf8) {
	/*
	 * For other than ncurses, repainting is taken care of
	 * by touching lines in display_line and highlight.  - kw 1999-10-07
	 */
	text->had_utf8 = text->has_utf8;
	clearok(curscr, TRUE);
    } else if (HTCJK != NOCJK) {
d1733 1
a1733 5
	 * For non-multibyte curses.
	 *
	 * Full repainting is necessary, otherwise only part of a multibyte
	 * character sequence might be written because of curses output
	 * optimizations.
d1735 1
a1735 1
	clearok(curscr, TRUE);
d1737 1
a1737 1
#endif /* WIDEC_CURSES */
a1738 2
    LYrefresh();
    return;
d1741 1
d1743 6
a1748 5
 *			-----------------------
 *
 *	These are used by a parser to build the text in an object
 */
void HText_beginAppend(HText *text)
a1754 19
/* LYcols_cu is the notion that the display library has of the screen
   width.  Normally it is the same as LYcols, but there may be a
   difference via SLANG_MBCS_HACK.  Checks of the line length (as the
   non-UTF-8-aware display library would see it) against LYcols_cu are
   is used to try to prevent that lines with UTF-8 chars get wrapped
   by the library when they shouldn't.
   If there is no display library involved, i.e. dump_output_immediately,
   no such limit should be imposed.  MAX_COLS should be just as good
   as any other large value.  (But don't use INT_MAX or something close
   to it to, avoid over/underflow.) - kw */
#ifdef USE_SLANG
#define LYcols_cu(text) (dump_output_immediately ? MAX_COLS : SLtt_Screen_Cols)
#else
#ifdef WIDEC_CURSES
#define LYcols_cu(text) WRAP_COLS(text)
#else
#define LYcols_cu(text) (dump_output_immediately ? MAX_COLS : DISPLAY_COLS)
#endif
#endif
d1757 16
a1772 16
 *	----------------------
 *
 * On entry,
 *
 *	split	is zero for newline function, else number of characters
 *		before split.
 *	text->display_on_the_fly
 *		may be set to indicate direct output of the finished line.
 * On exit,
 *		A new line has been made, justified according to the
 *		current style.  Text after the split (if split nonzero)
 *		is taken over onto the next line.
 *
 *		If display_on_the_fly is set, then it is decremented and
 *		the finished line is displayed.
 */
d1775 3
a1777 12
#define DEBUG_SPLITLINE

#ifdef DEBUG_SPLITLINE
#define CTRACE_SPLITLINE(p)	CTRACE(p)
#else
#define CTRACE_SPLITLINE(p)	/*nothing */
#endif

static int set_style_by_embedded_chars(char *s,
				       char *e,
				       unsigned char start_c,
				       unsigned char end_c)
d1779 3
a1781 96
    int ret = NO;

    while (--e >= s) {
	if (*e == end_c)
	    break;
	if (*e == start_c) {
	    ret = YES;
	    break;
	}
    }
    return ret;
}

static void move_anchors_in_region(HTLine *line, int line_number,
				   TextAnchor **prev_anchor,	/*updates++ */
				   int *prev_head_processed,
				   int sbyte,
				   int ebyte,
				   int shift)	/* Likewise */
{
    /*
     * Update anchor positions for anchors that start on this line.  Note:  we
     * rely on a->line_pos counting bytes, not characters.  That's one reason
     * why HText_trimHightext has to be prevented from acting on these anchors
     * in partial display mode before we get a chance to deal with them here.
     */
    TextAnchor *a;
    int head_processed = *prev_head_processed;

    /*
     * We need to know whether (*prev_anchor)->line_pos is "in new coordinates"
     * or in old ones.  If prev_anchor' head was touched on the previous
     * iteration, we set head_processed.  The tail may need to be treated now.
     */
    for (a = *prev_anchor;
	 a && a->line_num <= line_number;
	 a = a->next, head_processed = 0) {
	/* extent==0 needs to be special-cased; happens if no text for
	   the anchor was processed yet.  */
	/* Subtract one so that the space is not inserted at the end
	   of the anchor... */
	int last = a->line_pos + (a->extent ? a->extent - 1 : 0);

	/* Include the anchors started on the previous line */
	if (a->line_num < line_number - 1)
	    continue;
	if (a->line_num == line_number - 1)
	    last -= line->prev->size + 1;	/* Fake "\n" "between" lines counted too */
	if (last < sbyte)	/* Completely before the start */
	    continue;

	if (!head_processed	/* a->line_pos is not edited yet */
	    && a->line_num == line_number
	    && a->line_pos >= ebyte)	/* Completely after the end */
	    break;
	/* Now we know that the anchor context intersects the chunk */

	/* Fix the start */
	if (!head_processed && a->line_num == line_number
	    && a->line_pos >= sbyte) {
	    a->line_pos += shift;
	    a->extent -= shift;
	    head_processed = 1;
	}
	/* Fix the end */
	if (last < ebyte)
	    a->extent += shift;
	else
	    break;		/* Keep this `a' for the next step */
    }
    *prev_anchor = a;
    *prev_head_processed = head_processed;
}

/*
 * Given a line and two int arrays of old/now position, this function
 * creates a new line where spaces have been inserted/removed
 * in appropriate places - so that characters at/after the old
 * position end up at/after the new position, for each pair, if possible.
 * Some necessary changes for anchors starting on this line are also done
 * here if needed.  Updates 'prev_anchor' internally.
 * Returns a newly allocated HTLine* if changes were made
 * (caller has to free the old one).
 * Returns NULL if no changes needed.  (Remove-spaces code may be buggy...)
 * - kw
 */
static HTLine *insert_blanks_in_line(HTLine *line, int line_number,
				     HText *text,
				     TextAnchor **prev_anchor,	/*updates++ */
				     int ninserts,
				     int *oldpos,	/* Measured in cells */
				     int *newpos)	/* Likewise */
{
    int ioldc = 0;		/* count visible characters */
    int ip;			/* count insertion pairs */

d1783 1
a1783 1
    int istyle = 0;
d1785 3
a1787 137
    int added_chars = 0;
    int shift = 0;
    int head_processed;
    HTLine *mod_line;
    char *newdata;
    char *s = line->data;
    char *pre = s;
    char *copied = line->data, *t;

    if (!(line && line->size && ninserts))
	return NULL;
    for (ip = 0; ip < ninserts; ip++)
	if (newpos[ip] > oldpos[ip] &&
	    (newpos[ip] - oldpos[ip]) > added_chars)
	    added_chars = newpos[ip] - oldpos[ip];
    if (line->size + added_chars > MAX_LINE - 2)
	return NULL;
    if (line == text->last_line) {
	if (line == TEMP_LINE(text, 0))
	    mod_line = TEMP_LINE(text, 1);
	else
	    mod_line = TEMP_LINE(text, 0);
    } else {
	allocHTLine(mod_line, line->size + added_chars);
    }
    if (!mod_line)
	return NULL;
    if (!*prev_anchor)
	*prev_anchor = text->first_anchor;
    head_processed = (*prev_anchor && (*prev_anchor)->line_num < line_number);
    memcpy(mod_line, line, LINE_SIZE(0));
    t = newdata = mod_line->data;
    ip = 0;
    while (ip <= ninserts) {
	/* line->size is in bytes, so it may be larger than needed... */
	int curlim = (ip < ninserts
		      ? oldpos[ip]
	/* Include'em all! */
		      : ((int) line->size <= MAX_LINE
			 ? MAX_LINE + 1
			 : (int) line->size + 1));

	pre = s;

	/* Fast forward to char==curlim or EOL.  Stop *before* the
	   style-change chars. */
	while (*s) {
	    if (text && text->T.output_utf8
		&& UCH(*s) >= 0x80 && UCH(*s) < 0xC0) {
		pre = s + 1;
	    } else if (!IsSpecialAttrChar(*s)) {	/* At a "displayed" char */
		if (ioldc >= curlim)
		    break;
		ioldc++;
		pre = s + 1;
	    }
	    s++;
	}

	/* Now s is at the "displayed" char, pre is before the style change */
	if (ip)			/* Fix anchor positions */
	    move_anchors_in_region(line, line_number, prev_anchor /*updates++ */ ,
				   &head_processed,
				   copied - line->data, pre - line->data,
				   shift);
#if defined(USE_COLOR_STYLE)	/* Move styles too */
#define NStyle mod_line->styles[istyle]
	for (;
	     istyle < line->numstyles && (int) NStyle.horizpos < curlim;
	     istyle++)
	    /* Should not we include OFF-styles at curlim? */
	    NStyle.horizpos += shift;
#endif
	while (copied < pre)	/* Copy verbatim to byte == pre */
	    *t++ = *copied++;
	if (ip < ninserts) {	/* Insert spaces */
	    int delta = newpos[ip] - oldpos[ip] - shift;

	    if (delta < 0) {	/* Not used yet? */
		while (delta++ < 0 && t > newdata && t[-1] == ' ')
		    t--, shift--;
	    } else
		shift = newpos[ip] - oldpos[ip];
	    while (delta-- > 0)
		*t++ = ' ';
	}
	ip++;
    }
    while (pre < s)		/* Copy remaining style-codes */
	*t++ = *pre++;
    /* Check whether the last anchor continues on the next line */
    if (head_processed && *prev_anchor && (*prev_anchor)->line_num == line_number)
	(*prev_anchor)->extent += shift;
    *t = '\0';
    mod_line->size = t - newdata;
    return mod_line;
}

#if defined(USE_COLOR_STYLE)
static HTStyleChange *skip_matched_and_correct_offsets(HTStyleChange *end,
						       HTStyleChange *start,
						       unsigned split_pos)
{				/* Found an OFF change not part of an adjacent matched pair.
				 * Walk backward looking for the corresponding ON change.
				 * Move everything after split_pos to be at split_pos.
				 * This can only work correctly if all changes are correctly
				 * nested!  If this fails, assume it is safer to leave whatever
				 * comes before the OFF on the previous line alone. */
    int level = 0;
    HTStyleChange *tmp = end;

    for (; tmp >= start; tmp--) {
	if (tmp->style == end->style) {
	    if (tmp->direction == STACK_OFF)
		level--;
	    else if (tmp->direction == STACK_ON) {
		if (++level == 0)
		    return tmp;
	    } else
		return 0;
	}
	if (tmp->horizpos > split_pos)
	    tmp->horizpos = split_pos;
    }
    return 0;
}
#endif /* USE_COLOR_STYLE */

static void split_line(HText *text, unsigned split)
{
    HTStyle *style = text->style;
    int spare;
    int indent = (text->in_line_1
		  ? text->style->indent1st
		  : text->style->leftIndent);
    short alignment;
    TextAnchor *a;
d1792 1
a1792 11
    int s, s_post, s_pre, t_underline = underline_on, t_bold = bold_on;
    char *p;
    char *cp;
    int ctrl_chars_on_previous_line = 0;

#ifndef WIDEC_CURSES
    int utfxtra_on_previous_line = UTFXTRA_ON_THIS_LINE;
#endif

    HTLine *previous = text->last_line;
    HTLine *line;
d1794 1
d1796 1
a1796 1
     * Set new line.
d1798 5
a1802 4
    if (previous == TEMP_LINE(text, 0))
	line = TEMP_LINE(text, 1);
    else
	line = TEMP_LINE(text, 0);
d1804 1
a1804 2
	return;
    memset(line, 0, LINE_SIZE(0));
d1806 1
a1806 2
    ctrl_chars_on_this_line = 0;	/*reset since we are going to a new line */
    utfxtra_on_this_line = 0;	/*reset too, we'll count them */
d1810 2
a1811 2
    CTRACE((tfp, "GridText: split_line(%p,%d) called\n", text, split));
    CTRACE((tfp, "   bold_on=%d, underline_on=%d\n", bold_on, underline_on));
a1813 19
    cp = previous->data;
    /* Float LY_SOFT_NEWLINE to the start */
    if (cp[0] == LY_BOLD_START_CHAR
	|| cp[0] == LY_UNDERLINE_START_CHAR) {
	switch (cp[1]) {
	case LY_SOFT_NEWLINE:
	    cp[1] = cp[0];
	    cp[0] = LY_SOFT_NEWLINE;
	    break;
	case LY_BOLD_START_CHAR:
	case LY_UNDERLINE_START_CHAR:
	    if (cp[2] == LY_SOFT_NEWLINE) {
		cp[2] = cp[1];
		cp[1] = cp[0];
		cp[0] = LY_SOFT_NEWLINE;
	    }
	    break;
	}
    }
d1815 3
a1817 3
	CTRACE((tfp,
		"*** split_line: split==%d greater than last_line->size==%d !\n",
		split, previous->size));
d1823 1
a1823 1
	    CTRACE((tfp, "                split adjusted to %d.\n", split));
d1836 1
a1836 1
    text->permissible_split = 0;	/* 12/13/93 */
d1839 5
a1843 15
    alignment = style->alignment;

    if (split > 0) {		/* Restore flags to the value at the splitting point */
	if (!(dump_output_immediately && use_underscore))
	    t_underline = set_style_by_embedded_chars(previous->data,
						      previous->data + split,
						      LY_UNDERLINE_START_CHAR, LY_UNDERLINE_END_CHAR);

	t_bold = set_style_by_embedded_chars(previous->data,
					     previous->data + split,
					     LY_BOLD_START_CHAR, LY_BOLD_END_CHAR);

    }

    if (!(dump_output_immediately && use_underscore) && t_underline) {
a1846 1
	SpecialAttrChars++;
d1848 4
a1851 1
    if (t_bold) {
a1854 1
	SpecialAttrChars++;
d1858 1
a1858 1
     * Split at required point
d1860 2
a1861 2
    if (split > 0) {		/* Delete space at "split" splitting line */
	char *prevdata = previous->data, *linedata = line->data;
d1865 3
a1867 1
	/* Split the line. -FM */
d1872 2
a1873 2
	 * Trim any spaces or soft hyphens from the beginning
	 * of our new line.  -FM
d1876 6
a1881 14
	while (((*p == ' '
#ifdef EXP_JUSTIFY_ELTS
	/* if justification is allowed for prev line, then raw
	 * HT_NON_BREAK_SPACE are still present in data[] (they'll be
	 * substituted at the end of this function with ' ') - VH
	 */
		 || *p == HT_NON_BREAK_SPACE
#endif
		)
		&& (HeadTrim || text->first_anchor ||
		    underline_on || bold_on ||
		    alignment != HT_LEFT ||
		    style->wordWrap || style->freeFormat ||
		    style->spaceBefore || style->spaceAfter)) ||
d1886 47
d1934 34
a1967 2
	plen = strlen(p);
	if (plen) {		/* Count funny characters */
d1969 1
a1969 3
		if (p[i] == LY_UNDERLINE_START_CHAR ||
		    p[i] == LY_UNDERLINE_END_CHAR ||
		    p[i] == LY_BOLD_START_CHAR ||
d1971 1
a1973 2
		} else if (IS_UTF_EXTRA(p[i])) {
		    utfxtra_on_this_line++;
d1975 1
a1975 1
		if (p[i] == LY_SOFT_HYPHEN && (int) text->permissible_split < i)
d1977 1
d1979 1
a1979 1
	    ctrl_chars_on_this_line += utfxtra_on_this_line;
d1981 5
a1985 4
	    /* Add the data to the new line. -FM */
	    strcat(linedata, p);
	    line->size += plen;
	}
d1989 1
a1989 1
     * Economize on space.
d1991 13
a2003 22
    p = previous->data + previous->size - 1;
    while (p >= previous->data
	   && (*p == ' '
#ifdef EXP_JUSTIFY_ELTS
    /* if justification is allowed for prev line, then raw
     * HT_NON_BREAK_SPACE are still present in data[] (they'll be
     * substituted at the end of this function with ' ') - VH
     */
	       || *p == HT_NON_BREAK_SPACE
#endif
	   )
#ifdef USE_PRETTYSRC
	   && !psrc_view	/*don't strip trailing whites - since next line can
				   start with LY_SOFT_NEWLINE - so we don't lose spaces when
				   'p'rinting this text to file -VH */
#endif
	   && (ctrl_chars_on_this_line || HeadTrim || text->first_anchor ||
	       underline_on || bold_on ||
	       alignment != HT_LEFT ||
	       style->wordWrap || style->freeFormat ||
	       style->spaceBefore || style->spaceAfter)) {
	p--;			/*  Strip trailers. */
a2004 4
    TailTrim = previous->data + previous->size - 1 - p;		/*  Strip trailers. */
    previous->size -= TailTrim;
    p[1] = '\0';

d2006 3
a2008 3
     * s is the effective split position, given by either a non-zero
     * value of split or by the size of the previous line before
     * trimming.  - kw
d2011 1
a2011 1
	s = previous->size + TailTrim;	/* the original size */
a2014 3
    s_post = s + HeadTrim;
    s_pre = s - TailTrim;

d2017 1
a2017 1
    if (s != (int) split)
d2019 1
a2019 1
	CTRACE((tfp, "GridText: split_line(%d [now:%d]) called\n", split, s));
d2023 1
a2023 4
    if (previous->styles == stylechanges_buffers[0])
	line->styles = stylechanges_buffers[1];
    else
	line->styles = stylechanges_buffers[0];
d2025 117
a2141 17
    {
	HTStyleChange *from = previous->styles + previous->numstyles - 1;
	HTStyleChange *to = line->styles + MAX_STYLES_ON_LINE - 1;
	HTStyleChange *scan, *at_end;

	/* Color style changes after the split position
	 * are transferred to the new line.  Ditto for changes
	 * in the trimming region, but we stop when we reach an OFF change.
	 * The second loop below may then handle remaining changes.  - kw */
	while (from >= previous->styles && to >= line->styles) {
	    *to = *from;
	    if ((int) to->horizpos > s_post)
		to->horizpos += -s_post + SpecialAttrChars;
	    else if ((int) to->horizpos > s_pre &&
		     (to->direction == STACK_ON ||
		      to->direction == ABS_ON))
		to->horizpos = ((int) to->horizpos < s) ? 0 : SpecialAttrChars;
d2143 6
a2148 3
		break;
	    to--;
	    from--;
a2149 67
	/* FROM may be invalid, otherwise it is either an ON change at or
	   before s_pre, or is an OFF change at or before s_post.  */

	scan = from;
	at_end = from;
	/* Now on the previous line we have a correctly nested but
	   possibly non-terminated sequence of style changes.
	   Terminate it, and duplicate unterminated changes at the
	   beginning of the new line. */
	while (scan >= previous->styles && at_end >= previous->styles) {
	    /* The algorithm: scan back though the styles on the previous line.
	       a) If OFF, skip the matched group.
	       Report a bug on failure.
	       b) If ON, (try to) cancel the corresponding ON at at_end,
	       and the corresponding OFF at to;
	       If not, put the corresponding OFF at at_end, and copy to to;
	     */
	    if (scan->direction == STACK_OFF) {
		scan = skip_matched_and_correct_offsets(scan, previous->styles,
							s_pre);
		if (!scan) {
		    CTRACE((tfp, "BUG: styles improperly nested.\n"));
		    break;
		}
	    } else if (scan->direction == STACK_ON) {
		if (at_end->direction == STACK_ON
		    && at_end->style == scan->style
		    && (int) at_end->horizpos >= s_pre)
		    at_end--;
		else if (at_end >= previous->styles + MAX_STYLES_ON_LINE - 1) {
		    CTRACE((tfp, "BUG: style overflow before split_line.\n"));
		    break;
		} else {
		    at_end++;
		    at_end->direction = STACK_OFF;
		    at_end->style = scan->style;
		    at_end->horizpos = s_pre;
		}
		if (to < line->styles + MAX_STYLES_ON_LINE - 1
		    && to[1].direction == STACK_OFF
		    && to[1].horizpos <= (unsigned) SpecialAttrChars
		    && to[1].style == scan->style)
		    to++;
		else if (to >= line->styles) {
		    *to = *scan;
		    to->horizpos = SpecialAttrChars;
		    to--;
		} else {
		    CTRACE((tfp, "BUG: style overflow after split_line.\n"));
		    break;
		}
	    }
	    if ((int) scan->horizpos > s_pre)
		scan->horizpos = s_pre;
	    scan--;
	}
	line->numstyles = line->styles + MAX_STYLES_ON_LINE - 1 - to;
	if (line->numstyles > 0 && line->numstyles < MAX_STYLES_ON_LINE) {
	    int n;

	    for (n = 0; n < line->numstyles; n++)
		line->styles[n] = to[n + 1];
	} else if (line->numstyles == 0)
	    line->styles[0].horizpos = ~0;	/* ?!!! */
	previous->numstyles = at_end - previous->styles + 1;
	if (previous->numstyles == 0)
	    previous->styles[0].horizpos = ~0;	/* ?!!! */
d2151 1
a2151 4
#endif /*USE_COLOR_STYLE */

    {
	HTLine *temp;
d2153 3
a2155 11
	allocHTLine(temp, previous->size);
	if (!temp)
	    outofmem(__FILE__, "split_line_2");
	memcpy(temp, previous, LINE_SIZE(previous->size));
#if defined(USE_COLOR_STYLE)
	POOLallocstyles(temp->styles, previous->numstyles);
	if (!temp->styles)
	    outofmem(__FILE__, "split_line_2");
	memcpy(temp->styles, previous->styles, sizeof(HTStyleChange) * previous->numstyles);
#endif
	previous = temp;
d2157 19
d2181 1
a2181 1
     * Terminate finished line for printing.
d2186 1
a2186 1
     * Align left, right or center.
d2189 2
a2190 6
    if (
#ifdef EXP_JUSTIFY_ELTS
	   this_line_was_split ||
#endif
	   (alignment == HT_CENTER ||
	    alignment == HT_RIGHT) || text->stbl) {
a2196 1
#ifndef WIDEC_CURSES
d2198 1
a2198 2
#endif
		*cp == LY_SOFT_HYPHEN) {
a2199 1
	    }
a2200 4
	if ((previous->size > 0) &&
	    (int) (previous->data[previous->size - 1] == LY_SOFT_HYPHEN))
	    ctrl_chars_on_previous_line--;

d2202 7
a2208 59
#ifdef WIDEC_CURSES
	spare = WRAP_COLS(text) -
	    (int) style->rightIndent - indent +
	    ctrl_chars_on_previous_line - LYstrExtent2(previous->data, previous->size);
	if (spare < 0 && LYwideLines)	/* Can be wider than screen */
	    spare = 0;
#else
	spare = WRAP_COLS(text) -
	    (int) style->rightIndent - indent +
	    ctrl_chars_on_previous_line - previous->size;
	if (spare < 0 && LYwideLines)	/* Can be wider than screen */
	    spare = 0;

	if (spare > 0 && !dump_output_immediately &&
	    text->T.output_utf8 && ctrl_chars_on_previous_line) {
	    utfxtra_on_previous_line -= UTFXTRA_ON_THIS_LINE;
	    if (utfxtra_on_previous_line) {
		int spare_cu = (LYcols_cu(text) -
				utfxtra_on_previous_line - indent +
				ctrl_chars_on_previous_line - previous->size);

		/*
		 * Shift non-leftaligned UTF-8 lines that would be
		 * mishandled by the display library towards the left
		 * if this would make them fit.  The resulting display
		 * will not be as intended, but this is better than
		 * having them split by curses.  (Curses cursor movement
		 * optimization may still cause wrong positioning within
		 * the line, in particular after a sequence of spaces).
		 * - kw
		 */
		if (spare_cu < spare) {
		    if (spare_cu >= 0) {
			if (alignment == HT_CENTER &&
			    (int) (previous->offset + indent + spare / 2 +
				   previous->size)
			    - ctrl_chars_on_previous_line
			    + utfxtra_on_previous_line <= LYcols_cu(text))
			    /* do nothing - it still fits - kw */ ;
			else {
			    spare = spare_cu;
			    if (alignment == HT_CENTER) {
				/*
				 * Can't move toward center all the way,
				 * but at least make line contents appear
				 * as far right as possible.  - kw
				 */
				alignment = HT_RIGHT;
			    }
			}
		    } else if (indent + (int) previous->offset + spare_cu >= 0) {	/* subtract overdraft from effective indentation */
			indent += (int) previous->offset + spare_cu;
			previous->offset = 0;
			spare = 0;
		    }
		}
	    }
	}
#endif
d2212 12
a2223 51
    case HT_CENTER:
	previous->offset = previous->offset + indent + spare / 2;
	break;
    case HT_RIGHT:
	previous->offset = previous->offset + indent + spare;
	break;
    case HT_LEFT:
    case HT_JUSTIFY:		/* Not implemented */
    default:
	previous->offset = previous->offset + indent;
	break;
    }				/* switch */

    if (text->stbl)
	/*
	 * Notify simple table stuff of line split, so that it can
	 * set the last cell's length.  The last cell should and
	 * its row should really end here, or on one of the following
	 * lines with no more characters added after the break.
	 * We don't know whether a cell has been started, so ignore
	 * errors here.
	 * This call is down here because we need the
	 * ctrl_chars_on_previous_line, which have just been re-
	 * counted above.  - kw
	 */
	Stbl_lineBreak(text->stbl,
		       text->Lines - 1,
		       previous->offset,
		       previous->size - ctrl_chars_on_previous_line);

    text->in_line_1 = NO;	/* unless caller sets it otherwise */

    /*
     * If we split the line, adjust the anchor
     * structure values for the new line.  -FM
     */

    if (s > 0) {		/* if not completely empty */
	int moved = 0;

	/* In the algorithm below we move or not move anchors between
	   lines using some heuristic criteria.  However, it is
	   desirable not to have two consequent anchors on different
	   lines *in a wrong order*!  (How can this happen?)
	   So when the "reasonable choice" is not unique, we use the
	   MOVED flag to choose one.
	 */
	/* Our operations can make a non-empty all-whitespace link
	   empty.  So what? */
	if ((a = text->last_anchor_before_split) == 0)
	    a = text->first_anchor;
d2225 2
a2226 4
	for (; a; a = a->next) {
	    if (a->line_num == CurLine) {
		int len = a->extent, n = a->number, start = a->line_pos;
		int end = start + len;
d2228 4
a2231 1
		text->last_anchor_before_split = a;
d2233 12
a2244 17
		/* Which anchors do we leave on the previous line?
		   a) empty finished (We need a cut-off value.
		   "Just because": those before s;
		   this is the only case when we use s, not s_pre/s_post);
		   b) Those which start before s_pre;
		 */
		if (start < s_pre) {
		    if (end <= s_pre)
			continue;	/* No problem */

		    CTRACE_SPLITLINE((tfp, "anchor %d: no relocation", n));
		    if (end > s_post) {
			CTRACE_SPLITLINE((tfp, " of the start.\n"));
			a->extent += -(TailTrim + HeadTrim) + SpecialAttrChars;
		    } else {
			CTRACE_SPLITLINE((tfp, ", cut the end.\n"));
			a->extent = s_pre - start;
d2247 110
a2356 6
		} else if (start < s && !len
			   && (!n || (a->show_anchor && !moved))) {
		    CTRACE_SPLITLINE((tfp,
				      "anchor %d: no relocation, empty-finished",
				      n));
		    a->line_pos = s_pre;	/* Leave at the end of line */
d2359 13
d2373 4
a2376 61
		/* The rest we relocate */
		moved = 1;
		a->line_num++;
		CTRACE_SPLITLINE((tfp,
				  "anchor %d: (T,H,S)=(%d,%d,%d); (line,pos,ext):(%d,%d,%d), ",
				  n, TailTrim, HeadTrim, SpecialAttrChars,
				  a->line_num, a->line_pos, a->extent));
		if (end < s_post) {	/* Move the end to s_post */
		    CTRACE_SPLITLINE((tfp, "Move end +%d, ", s_post - end));
		    len += s_post - end;
		}
		if (start < s_post) {	/* Move the start to s_post */
		    CTRACE_SPLITLINE((tfp, "Move start +%d, ", s_post - start));
		    len -= s_post - start;
		    start = s_post;
		}
		a->line_pos = start - s_post + SpecialAttrChars;
		a->extent = len;

		CTRACE_SPLITLINE((tfp, "->(%d,%d,%d)\n",
				  a->line_num, a->line_pos, a->extent));
	    } else if (a->line_num > CurLine)
		break;
	}
    }
#ifdef EXP_JUSTIFY_ELTS
    /* now perform justification - by VH */

    if (this_line_was_split
	&& spare
	&& !text->stbl		/* We don't inform TRST on the cell width change yet */
	&& justify_max_void_percent > 0
	&& justify_max_void_percent <= 100
	&& justify_max_void_percent >= ((100 * spare)
					/ (WRAP_COLS(text)
					   - (int) style->rightIndent
					   - indent
					   + ctrl_chars_on_previous_line))) {
	/* this is the only case when we need justification */
	char *jp = previous->data + justify_start_position;
	ht_run_info *r = ht_runs;
	char c;
	int total_byte_len = 0, total_cell_len = 0;
	int d_, r_;
	HTLine *jline;

	ht_num_runs = 0;
	r->byte_len = r->cell_len = 0;

	for (; (c = *jp) != 0; ++jp) {
	    if (c == ' ') {
		total_byte_len += r->byte_len;
		total_cell_len += r->cell_len;
		++r;
		++ht_num_runs;
		r->byte_len = r->cell_len = 0;
		continue;
	    }
	    ++r->byte_len;
	    if (IsSpecialAttrChar(c))
		continue;
a2377 10
	    ++r->cell_len;
	    if (c == HT_NON_BREAK_SPACE) {
		*jp = ' ';	/* substitute it */
		continue;
	    }
	    if (text->T.output_utf8 && is8bits(c)) {
		int utf_extra = utf8_length(text->T.output_utf8, jp);

		r->byte_len += utf_extra;
		jp += utf_extra;
d2380 2
a2381 8
	total_byte_len += r->byte_len;
	total_cell_len += r->cell_len;
	++ht_num_runs;

	if (ht_num_runs != 1) {
	    int *oldpos = (int *) malloc(sizeof(int) * 2 * (ht_num_runs - 1));
	    int *newpos = oldpos + ht_num_runs - 1;
	    int i = 1;
a2382 79
	    if (oldpos == NULL)
		outofmem(__FILE__, "split_line_3");

	    d_ = spare / (ht_num_runs - 1);
	    r_ = spare % (ht_num_runs - 1);

	    /* The first run is not moved, proceed to the second one */
	    oldpos[0] = justify_start_position + ht_runs[0].cell_len + 1;
	    newpos[0] = oldpos[0] + (d_ + (r_-- > 0));
	    while (i < ht_num_runs - 1) {
		int delta = ht_runs[i].cell_len + 1;

		oldpos[i] = oldpos[i - 1] + delta;
		newpos[i] = newpos[i - 1] + delta + (d_ + (r_-- > 0));
		i++;
	    }
	    jline = insert_blanks_in_line(previous, CurLine, text,
					  &last_anchor_of_previous_line /*updates++ */ ,
					  ht_num_runs - 1, oldpos, newpos);
	    free((char *) oldpos);
	    if (jline == NULL)
		outofmem(__FILE__, "split_line_4");
	    previous->next->prev = jline;
	    previous->prev->next = jline;

	    freeHTLine(text, previous);

	    previous = jline;
	} {			/* (ht_num_runs==1) */
	    if (justify_start_position) {
		char *p2 = previous->data;

		for (; p2 < previous->data + justify_start_position; ++p2)
		    *p2 = (*p2 == HT_NON_BREAK_SPACE ? ' ' : *p2);
	    }
	}
    } else {
	if (REALLY_CAN_JUSTIFY(text)) {
	    char *p2;

	    /* it was permitted to justify line, but this function was called
	     * to end paragraph - we must substitute HT_NON_BREAK_SPACEs with
	     * spaces in previous line
	     */
	    if (line->size && !text->stbl) {
		CTRACE((tfp,
			"BUG: justification: shouldn't happen - new line is not empty!\n\t'%.*s'\n",
			line->size, line->data));
	    }

	    for (p2 = previous->data; *p2; ++p2)
		if (*p2 == HT_NON_BREAK_SPACE)
		    *p2 = ' ';
	} else if (have_raw_nbsps) {
	    /* this is very rare case, that can happen in forms placed in
	       table cells */
	    unsigned i;

	    for (i = 0; i < previous->size; ++i)
		if (previous->data[i] == HT_NON_BREAK_SPACE)
		    previous->data[i] = ' ';

	    /*next line won't be justified, so substitute nbsps in it too */
	    for (i = 0; i < line->size; ++i)
		if (line->data[i] == HT_NON_BREAK_SPACE)
		    line->data[i] = ' ';
	}

	/* else HT_NON_BREAK_SPACEs were substituted with spaces in
	   HText_appendCharacter */
    }
    /* cleanup */
    can_justify_this_line = TRUE;
    justify_start_position = 0;
    this_line_was_split = FALSE;
    have_raw_nbsps = FALSE;
#endif /* EXP_JUSTIFY_ELTS */
    return;
}				/* split_line */
d2385 5
a2389 3
 *	--------------------------
 */
static void blank_lines(HText *text, int newlines)
d2391 1
a2391 2
    if (HText_LastLineEmpty(text, FALSE)) {	/* No text on current line */
	HTLine *line = text->last_line->prev;
d2393 4
a2396 9
#ifdef USE_COLOR_STYLE
	/* Style-change petty requests at the start of the document: */
	if (line == text->last_line && newlines == 1)
	    return;		/* Do not add a blank line at start */
#endif

	while (line != NULL &&
	       line != text->last_line &&
	       HText_TrueEmptyLine(line, text, FALSE)) {
d2403 1
a2403 1
	newlines++;		/* Need also to finish this line */
d2412 1
d2414 5
a2418 4
 *	------------------------------
 * See also: setStyle.
 */
void HText_appendParagraph(HText *text)
a2421 1

d2425 1
d2427 7
a2433 5
 *	---------
 *
 *	Does not filter unnecessary style changes.
 */
void HText_setStyle(HText *text, HTStyle *style)
d2438 1
a2438 1
	return;			/* Safety */
d2442 1
a2442 1
    CTRACE((tfp, "GridText: Change to style %s\n", style->name));
d2444 1
a2444 1
    blank_lines(text, ((after > before) ? after : before));
d2450 5
a2454 3
 *	-------------------------------------
 */
void HText_appendCharacter(HText *text, int ch)
d2456 2
a2457 2
    HTLine *line;
    HTStyle *style;
a2458 2
    int limit = 0;
    int actual;
a2460 4
#ifdef CJK_EX
    static unsigned char save_ch = 0;
#endif

d2462 2
a2463 3
	char *special = NULL;	/* make trace a little more readable */

	switch (ch) {
d2465 2
a2466 2
	    special = "HT_NON_BREAK_SPACE";
	    break;
d2468 2
a2469 2
	    special = "HT_EN_SPACE";
	    break;
d2471 2
a2472 2
	    special = "LY_UNDERLINE_START_CHAR";
	    break;
d2474 2
a2475 2
	    special = "LY_UNDERLINE_END_CHAR";
	    break;
d2477 2
a2478 2
	    special = "LY_BOLD_START_CHAR";
	    break;
d2480 2
a2481 2
	    special = "LY_BOLD_END_CHAR";
	    break;
d2483 2
a2484 2
	    special = "LY_SOFT_HYPHEN";
	    break;
d2486 2
a2487 2
	    special = "LY_SOFT_NEWLINE";
	    break;
d2489 2
a2490 2
	    special = NULL;
	    break;
d2494 2
a2495 2
	    CTRACE((tfp, "add(%s %d special char) %d/%d\n", special, ch,
		    HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
d2497 2
a2498 22
#ifdef CJK_EX			/* 1998/08/30 (Sun) 13:26:23 */
	    if (save_ch == 0) {
		if (IS_SJIS_HI1(ch) || IS_SJIS_HI2(ch)) {
		    save_ch = ch;
		} else {
		    CTRACE((tfp, "add(%c) %d/%d\n", ch,
			    HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
		}
	    } else {
		CTRACE((tfp, "add(%c%c) %d/%d\n", save_ch, ch,
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
		save_ch = 0;
	    }
#else
	    if (UCH(ch) < 0x80) {
		CTRACE((tfp, "add(%c) %d/%d\n", UCH(ch),
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
	    } else {
		CTRACE((tfp, "add(%02x) %d/%d\n", UCH(ch),
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
	    }
#endif /* CJK_EX */
d2500 1
a2500 1
    }				/* trace only */
d2504 1
a2504 1
     * Make sure we don't crash on NULLs.
d2511 2
a2512 2
	 * We should stop outputting more text, because low memory was
	 * detected.  - kw
d2516 4
a2519 4
	     * But if we haven't done so yet, first append a warning.
	     * We should still have a few bytes left for that :).
	     * We temporarily reset test->halted to 0 for this, since
	     * this function will get called recursively.  - kw
a2527 95
#ifdef USE_TH_JP_AUTO_DETECT
    if ((HTCJK == JAPANESE) && (text->detected_kcode != DET_MIXED) &&
	(text->specified_kcode != SJIS) && (text->specified_kcode != EUC)) {
	unsigned char c;
	eDetectedKCode save_d_kcode;

	c = UCH(ch);
	save_d_kcode = text->detected_kcode;
	switch (text->SJIS_status) {
	case SJIS_state_has_bad_code:
	    break;
	case SJIS_state_neutral:
	    if (IS_SJIS_HI1(c) || IS_SJIS_HI2(c)) {
		text->SJIS_status = SJIS_state_in_kanji;
	    } else if ((c & 0x80) && !IS_SJIS_X0201KANA(c)) {
		text->SJIS_status = SJIS_state_has_bad_code;
		if (text->EUC_status == EUC_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_EUC;
	    }
	    break;
	case SJIS_state_in_kanji:
	    if (IS_SJIS_LO(c)) {
		text->SJIS_status = SJIS_state_neutral;
	    } else {
		text->SJIS_status = SJIS_state_has_bad_code;
		if (text->EUC_status == EUC_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_EUC;
	    }
	    break;
	}
	switch (text->EUC_status) {
	case EUC_state_has_bad_code:
	    break;
	case EUC_state_neutral:
	    if (IS_EUC_HI(c)) {
		text->EUC_status = EUC_state_in_kanji;
	    } else if (c == 0x8e) {
		text->EUC_status = EUC_state_in_kana;
	    } else if (c & 0x80) {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	case EUC_state_in_kanji:
	    if (IS_EUC_LOX(c)) {
		text->EUC_status = EUC_state_neutral;
	    } else {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	case EUC_state_in_kana:
	    if ((0xA1 <= c) && (c <= 0xDF)) {
		text->EUC_status = EUC_state_neutral;
	    } else {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	}
	if (save_d_kcode != text->detected_kcode) {
	    switch (text->detected_kcode) {
	    case DET_SJIS:
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode seems SJIS.\n"));
		break;
	    case DET_EUC:
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode seems EUC.\n"));
		break;
	    case DET_MIXED:
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode seems mixed!\n"));
		break;
	    default:
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode is unexpected!\n"));
		break;
	    }
	}
    }
#endif /* USE_TH_JP_AUTO_DETECT */
d2529 1
a2529 1
     * Make sure we don't hang on escape sequences.
d2531 1
a2531 1
    if (ch == CH_ESC && HTCJK == NOCJK) {	/* decimal 27  S/390 -- gil -- 1504 */
a2532 1
    }
d2535 6
a2540 6
     * Block 8-bit chars not allowed by the current display character
     * set if they are below what LYlowest_eightbit indicates.
     * Slang used its own replacements, so for USE_SLANG blocking here
     * is not necessary to protect terminals from those characters.
     * They should have been filtered out or translated by an earlier
     * processing stage anyway.  - kw
d2542 2
a2543 2
#ifndef   EBCDIC		/* S/390 -- gil -- 1514 */
    if (is8bits(ch) && HTCJK == NOCJK &&
d2545 1
a2545 1
	UCH(ch) < LYlowest_eightbit[current_char_set]) {
a2546 1
    }
d2549 1
a2549 1
    if (UCH(ch) == 155 && HTCJK == NOCJK) {	/* octal 233 */
d2560 1
a2560 1
    indent = text->in_line_1 ? (int) style->indent1st : (int) style->leftIndent;
d2563 14
a2576 3
	switch (text->state) {
	case S_text:
	    if (ch == CH_ESC) {	/* S/390 -- gil -- 1536 */
d2578 1
a2578 2
		 * Setting up for CJK escape sequence handling (based on
		 * Takuya ASADA's (asada@@three-a.co.jp) CJK Lynx).  -FM
d2580 9
a2588 5
		text->state = S_esc;
		text->kanji_buf = '\0';
		return;
	    }
	    break;
d2590 14
a2603 14
	case S_esc:
	    /*
	     * Expecting '$'or '(' following CJK ESC.
	     */
	    if (ch == '$') {
		text->state = S_dollar;
		return;
	    } else if (ch == '(') {
		text->state = S_paren;
		return;
	    } else {
		text->state = S_text;
	    }
	    /* FALLTHRU */
d2605 11
a2615 16
	case S_dollar:
	    /*
	     * Expecting '@@', 'B', 'A' or '(' after CJK "ESC$".
	     */
	    if (ch == '@@' || ch == 'B' || ch == 'A') {
		text->state = S_nonascii_text;
		if (ch == '@@' || ch == 'B')
		    text->kcode = JIS;
		return;
	    } else if (ch == '(') {
		text->state = S_dollar_paren;
		return;
	    } else {
		text->state = S_text;
	    }
	    break;
d2617 22
a2638 11
	case S_dollar_paren:
	    /*
	     * Expecting 'C' after CJK "ESC$(".
	     */
	    if (ch == 'C') {
		text->state = S_nonascii_text;
		return;
	    } else {
		text->state = S_text;
	    }
	    break;
d2640 1
a2640 5
	case S_paren:
	    /*
	     * Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(".
	     */
	    if (ch == 'B' || ch == 'J' || ch == 'T') {
d2642 1
a2642 1
		 * Can split here.  -FM
d2644 9
a2652 5
		text->permissible_split = text->last_line->size;
		text->state = S_text;
		return;
	    } else if (ch == 'I') {
		text->state = S_jisx0201_text;
d2654 1
a2654 1
		 * Can split here.  -FM
d2656 8
a2663 17
		text->permissible_split = text->last_line->size;
		text->kcode = JIS;
		return;
	    } else {
		text->state = S_text;
	    }
	    break;

	case S_nonascii_text:
	    /*
	     * Expecting CJK ESC after non-ASCII text.
	     */
	    if (ch == CH_ESC) {	/* S/390 -- gil -- 1553 */
		text->state = S_esc;
		text->kanji_buf = '\0';
		if (HTCJK == JAPANESE) {
		    text->kcode = NOKANJI;
d2665 2
a2666 27
		return;
	    } else if (UCH(ch) < 32) {
		text->state = S_text;
		text->kanji_buf = '\0';
		if (HTCJK == JAPANESE) {
		    text->kcode = NOKANJI;
		}
	    } else {
		ch |= 0200;
	    }
	    break;

	    /*
	     * JIS X0201 Kana in JIS support.  - by ASATAKU
	     */
	case S_jisx0201_text:
	    if (ch == CH_ESC) {	/* S/390 -- gil -- 1570 */
		text->state = S_esc;
		text->kanji_buf = '\0';
		text->kcode = NOKANJI;
		return;
	    } else {
		text->kanji_buf = '\216';
		ch |= 0200;
	    }
	    break;
	}			/* end switch */
d2671 1
a2671 1
		 * JIS X0201 Kana in SJIS support.  - by ASATAKU
d2673 5
a2677 23
		if ((text->kcode != JIS)
		    && (
#ifdef KANJI_CODE_OVERRIDE
			   (last_kcode == SJIS) ||
			   ((last_kcode == NOKANJI) &&
#endif
			    ((text->kcode == SJIS) ||
#ifdef USE_TH_JP_AUTO_DETECT
			     ((text->detected_kcode == DET_SJIS) &&
			      (text->specified_kcode == NOKANJI)) ||
#endif
			     ((text->kcode == NOKANJI) &&
			      (text->specified_kcode == SJIS)))
#ifdef KANJI_CODE_OVERRIDE
			   )
#endif
		    ) &&
		    (UCH(ch) >= 0xA1) &&
		    (UCH(ch) <= 0xDF)) {
#ifdef CONV_JISX0201KANA_JISX0208KANA
		    unsigned char c = UCH(ch);
		    unsigned char kb = UCH(text->kanji_buf);

d2679 3
a2681 3
					(unsigned char *) &kb,
					(unsigned char *) &c);
		    ch = (char) c;
a2682 3
#endif
		    /* 1998/01/19 (Mon) 09:06:15 */
		    text->permissible_split = (int) text->last_line->size;
d2686 1
a2686 1
		     * Can split here.  -FM
d2693 1
a2693 1
	    goto check_WrapSource;
d2695 1
a2695 1
    } else if (ch == CH_ESC) {	/* S/390 -- gil -- 1587 */
a2697 8
#ifdef CJK_EX			/* MOJI-BAKE Fix! 1997/10/12 -- 10/31 (Fri) 00:22:57 - JH7AYN */
    if (HTCJK != NOCJK &&	/* added condition - kw */
	(ch == LY_BOLD_START_CHAR || ch == LY_BOLD_END_CHAR)) {
	text->permissible_split = (int) line->size;	/* Can split here */
	if (HTCJK == JAPANESE)
	    text->kcode = NOKANJI;
    }
#endif
d2700 8
a2707 2
#if !defined(USE_COLOR_STYLE) || !defined(NO_DUMP_WITH_BACKSPACES)
	if (line->size >= (MAX_LINE - 1)) {
d2709 5
a2713 22
	}
#if defined(USE_COLOR_STYLE) && !defined(NO_DUMP_WITH_BACKSPACES)
	if (with_backspaces && HTCJK == NOCJK && !text->T.output_utf8) {
#endif
	    if (ch == LY_UNDERLINE_START_CHAR) {
		line->data[line->size++] = LY_UNDERLINE_START_CHAR;
		line->data[line->size] = '\0';
		underline_on = ON;
		if (!(dump_output_immediately && use_underscore))
		    ctrl_chars_on_this_line++;
		return;
	    } else if (ch == LY_UNDERLINE_END_CHAR) {
		line->data[line->size++] = LY_UNDERLINE_END_CHAR;
		line->data[line->size] = '\0';
		underline_on = OFF;
		if (!(dump_output_immediately && use_underscore))
		    ctrl_chars_on_this_line++;
		return;
	    } else if (ch == LY_BOLD_START_CHAR) {
		line->data[line->size++] = LY_BOLD_START_CHAR;
		line->data[line->size] = '\0';
		bold_on = ON;
d2715 22
a2737 8
	    } else if (ch == LY_BOLD_END_CHAR) {
		line->data[line->size++] = LY_BOLD_END_CHAR;
		line->data[line->size] = '\0';
		bold_on = OFF;
		ctrl_chars_on_this_line++;
		return;
	    } else if (ch == LY_SOFT_HYPHEN) {
		int i;
d2739 7
a2745 20
		/*
		 * Ignore the soft hyphen if it is the first character
		 * on the line, or if it is preceded by a space or
		 * hyphen.  -FM
		 */
		if (line->size < 1 || text->permissible_split >= line->size) {
		    return;
		}

		for (i = (text->permissible_split + 1); line->data[i]; i++) {
		    if (!IsSpecialAttrChar(UCH(line->data[i])) &&
			!isspace(UCH(line->data[i])) &&
			UCH(line->data[i]) != '-' &&
			UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
			UCH(line->data[i]) != HT_EN_SPACE) {
			break;
		    }
		}
		if (line->data[i] == '\0') {
		    return;
d2748 3
a2750 4
#if defined(USE_COLOR_STYLE) && !defined(NO_DUMP_WITH_BACKSPACES)
	} else {
	    /* if (with_backspaces && HTCJK==HTNOCJK && !text->T.output_utf8) */
	    return;
a2751 2
#endif

d2761 5
a2765 57
    if (text->T.output_utf8) {
	/*
	 * Some extra checks for UTF-8 output here to make sure
	 * memory is not overrun.  For a non-first char, append
	 * to the line here and return.  - kw
	 */
	if (IS_UTF_EXTRA(ch)) {
	    if ((line->size > (MAX_LINE - 1))
		|| (indent + (int) (line->offset + line->size)
		    + UTFXTRA_ON_THIS_LINE
		    - ctrl_chars_on_this_line
		    + ((line->size > 0) &&
		       (int) (line->data[line->size - 1] ==
			      LY_SOFT_HYPHEN ?
			      1 : 0)) >= LYcols_cu(text))
		) {
		if (!text->permissible_split || text->source) {
		    text->permissible_split = line->size;
		    while (text->permissible_split > 0 &&
			   IS_UTF_EXTRA(line->data[text->permissible_split - 1]))
			text->permissible_split--;
		    if (text->permissible_split &&
			(line->data[text->permissible_split - 1] & 0x80))
			text->permissible_split--;
		    if (text->permissible_split == line->size)
			text->permissible_split = 0;
		}
		split_line(text, text->permissible_split);
		line = text->last_line;
		if (text->source && line->size - ctrl_chars_on_this_line
		    + UTFXTRA_ON_THIS_LINE == 0)
		    HText_appendCharacter(text, LY_SOFT_NEWLINE);
	    }
	    line->data[line->size++] = (char) ch;
	    line->data[line->size] = '\0';
	    utfxtra_on_this_line++;
	    ctrl_chars_on_this_line++;
	    return;
	} else if (ch & 0x80) {	/* a first char of UTF-8 sequence - kw */
	    if ((line->size > (MAX_LINE - 7))) {
		if (!text->permissible_split || text->source) {
		    text->permissible_split = line->size;
		    while (text->permissible_split > 0 &&
			   (line->data[text->permissible_split - 1] & 0x80)
			   == 0xC0) {
			text->permissible_split--;
		    }
		    if (text->permissible_split == line->size)
			text->permissible_split = 0;
		}
		split_line(text, text->permissible_split);
		line = text->last_line;
		if (text->source && line->size - ctrl_chars_on_this_line
		    + UTFXTRA_ON_THIS_LINE == 0)
		    HText_appendCharacter(text, LY_SOFT_NEWLINE);
	    }
	}
d2769 1
a2769 1
     * New Line.
d2772 9
a2780 9
	new_line(text);
	text->in_line_1 = YES;	/* First line of new paragraph */
	/*
	 * There are some pages written in
	 * different kanji codes.  - TA & kw
	 */
	if (HTCJK == JAPANESE)
	    text->kcode = NOKANJI;
	return;
d2784 1
a2784 1
     * Convert EN_SPACE to a space here so that it doesn't get collapsed.
a2788 9
#ifdef SH_EX			/* 1997/11/01 (Sat) 12:08:54 */
    if (ch == 0x0b) {		/* ^K ??? */
	ch = '\r';
    }
    if (ch == 0x1a) {		/* ^Z ??? */
	ch = '\r';
    }
#endif

d2790 4
a2793 4
     * I'm going to cheat here in a BIG way.  Since I know that all
     * \r's will be trapped by HTML_put_character I'm going to use
     * \r to mean go down a line but don't start a new paragraph.
     * i.e., use the second line indenting.
d2799 2
a2800 2
	 * There are some pages written in
	 * different kanji codes.  - TA & kw
d2807 1
d2809 1
a2809 1
     * Tabs.
d2812 3
a2814 3
	const HTTabStop *Tab;
	int target, target_cu;	/* Where to tab to */
	int here, here_cu;	/* in _cu we try to guess what curses thinks */
d2816 1
a2816 1
	if (line->size > 0 && line->data[line->size - 1] == LY_SOFT_HYPHEN) {
d2818 2
a2819 2
	     * A tab shouldn't follow a soft hyphen, so
	     * if one does, we'll dump the soft hyphen.  -FM
d2824 2
a2825 3
	here = ((int) (line->size + line->offset) + indent)
	    - ctrl_chars_on_this_line;	/* Consider special chars GAB */
	here_cu = here + UTFXTRA_ON_THIS_LINE;
d2828 2
a2829 2
		 Tab->position <= here;
		 Tab++) {
d2837 2
a2838 2
	    if (here >= (int) style->leftIndent) {
		new_line(text);	/* wrap */
d2841 1
a2841 1
		target = (int) style->leftIndent;
d2845 2
a2846 2
	    target = (((int) line->offset + (int) line->size + 8) & (-8))
		+ (int) style->leftIndent;
d2853 1
a2853 6
	if (target >= here)
	    target_cu = target;
	else
	    target_cu = target + (here_cu - here);

	if (target > WRAP_COLS(text) - (int) style->rightIndent &&
d2858 1
a2858 1
	     * Can split here.  -FM
a2860 2
	    if (target_cu > WRAP_COLS(text))
		target -= target_cu - WRAP_COLS(text);
d2864 1
a2864 1
		for (; here < target; here++) {
d2872 2
a2873 4
    }
    /* if tab */
  check_WrapSource:
    if ((text->source || dont_wrap_pre) && text == HTMainText) {
d2878 3
a2880 10
	int target = (int) (line->offset + line->size) - ctrl_chars_on_this_line;
	int target_cu = target + UTFXTRA_ON_THIS_LINE;

	if (target >= WRAP_COLS(text) - style->rightIndent -
	    (((HTCJK != NOCJK) && text->kanji_buf) ? 1 : 0) ||
	    (text->T.output_utf8 &&
	     target_cu + UTF_XLEN(ch) >= LYcols_cu(text))) {
	    int saved_kanji_buf;
	    eGridState saved_state;

d2883 1
a2883 8

	    saved_kanji_buf = text->kanji_buf;
	    saved_state = text->state;
	    text->kanji_buf = '\0';
	    text->state = S_text;
	    HText_appendCharacter(text, LY_SOFT_NEWLINE);
	    text->kanji_buf = saved_kanji_buf;
	    text->state = saved_state;
d2889 1
a2889 1
	 * Can split here.  -FM
d2893 2
a2894 2
	 * There are some pages written in
	 * different kanji codes.  - TA
d2901 1
a2901 1
     * Check if we should ignore characters at the wrap point.
d2903 5
a2907 26
    if (text->IgnoreExcess) {
	int nominal = (indent + (int) (line->offset + line->size) - ctrl_chars_on_this_line);
	int number;

	limit = WRAP_COLS(text);
	if (fields_are_numbered()
	    && !number_fields_on_left
	    && text->last_anchor != 0
	    && (number = text->last_anchor->number) > 0) {
	    limit -= (number > 99999
		      ? 6
		      : (number > 9999
			 ? 5
			 : (number > 999
			    ? 4
			    : (number > 99
			       ? 3
			       : (number > 9
				  ? 2
				  : 1))))) + 2;
	}
	if ((nominal + (int) style->rightIndent) >= limit
	    || (nominal + UTFXTRA_ON_THIS_LINE) >= LYcols_cu(text)) {
	    return;
	}
    }
d2910 1
a2910 1
     * Check for end of line.
d2912 6
a2917 15
    actual = ((indent + (int) line->offset + (int) line->size) +
	      ((line->size > 0) &&
	       (int) (line->data[line->size - 1] == LY_SOFT_HYPHEN ? 1 : 0)));

    if (text->T.output_utf8) {
	actual += (UTFXTRA_ON_THIS_LINE - ctrl_chars_on_this_line + UTF_XLEN(ch));
	limit = LYcols_cu(text);
    } else {
	actual +=
	    (int) style->rightIndent - ctrl_chars_on_this_line +
	    (((HTCJK != NOCJK) && text->kanji_buf) ? 1 : 0);
	limit = WRAP_COLS(text);
    }

    if (actual >= limit) {
a2919 4
#ifdef EXP_JUSTIFY_ELTS
	    if (REALLY_CAN_JUSTIFY(text))
		this_line_was_split = TRUE;
#endif
d2921 1
a2921 3
	    if (ch == ' ') {
		return;		/* Ignore space causing split */
	    }
d2923 10
a2932 11
	} else if (HTOutputFormat == WWW_SOURCE) {
	    /*
	     * For source output we don't want to wrap this stuff
	     * unless absolutely necessary.  - LJM
	     * !
	     * If we don't wrap here we might get a segmentation fault.
	     * but let's see what happens
	     */
	    if ((int) line->size >= (int) (MAX_LINE - 1)) {
		new_line(text);	/* try not to linewrap */
	    }
d2934 4
a2937 10
	    /*
	     * For normal stuff like pre let's go ahead and
	     * wrap so the user can see all of the text.
	     */
	    if ((dump_output_immediately || (crawl && traversal))
		&& dont_wrap_pre) {
		if ((int) line->size >= (int) (MAX_LINE - 1)) {
		    new_line(text);
		}
	    } else {
a2938 1
	    }
d2940 1
a2940 1
    } else if ((int) line->size >= (int) (MAX_LINE - 1)) {
d2942 1
a2942 1
	 * Never overrun memory if DISPLAY_COLS is set to a large value - KW
d2948 1
a2948 1
     * Insert normal characters.
d2950 1
a2950 5
    if (ch == HT_NON_BREAK_SPACE
#ifdef EXP_JUSTIFY_ELTS
	&& !REALLY_CAN_JUSTIFY(text)
#endif
	)
d2952 1
a2952 6
#ifdef EXP_JUSTIFY_ELTS
    else
	have_raw_nbsps = TRUE;
#endif

    /* we leave raw HT_NON_BREAK_SPACE otherwise (we'll substitute it later) */
a2956 3
    /*
     * Kanji charactor handling.
     */
d2961 1
a2961 2
	line = text->last_line;	/* May have changed */

d2963 8
a2970 78
	    hi = UCH(text->kanji_buf);
	    lo = UCH(ch);

	    if (HTCJK == JAPANESE) {
		if (text->kcode != JIS) {
		    if (IS_SJIS_2BYTE(hi, lo)) {
			if (IS_EUC(hi, lo)) {
#ifdef KANJI_CODE_OVERRIDE
			    if (last_kcode != NOKANJI)
				text->kcode = last_kcode;
			    else
#endif
			    if (text->specified_kcode != NOKANJI)
				text->kcode = text->specified_kcode;
#ifdef USE_TH_JP_AUTO_DETECT
			    else if (text->detected_kcode == DET_EUC)
				text->kcode = EUC;
			    else if (text->detected_kcode == DET_SJIS)
				text->kcode = SJIS;
#endif
			    else if (IS_EUC_X0201KANA(hi, lo) &&
				     (text->kcode != EUC))
				text->kcode = SJIS;
			} else
			    text->kcode = SJIS;
		    } else if (IS_EUC(hi, lo))
			text->kcode = EUC;
		    else
			text->kcode = NOKANJI;
		}

		switch (kanji_code) {
		case EUC:
		    if (text->kcode == SJIS) {
			SJIS_TO_EUC1(hi, lo, tmp);
			line->data[line->size++] = tmp[0];
			line->data[line->size++] = tmp[1];
		    } else if (IS_EUC(hi, lo)) {
#ifdef CONV_JISX0201KANA_JISX0208KANA
			JISx0201TO0208_EUC(hi, lo, &hi, &lo);
#endif
			line->data[line->size++] = hi;
			line->data[line->size++] = lo;
		    } else {
			CTRACE((tfp,
				"This character (%X:%X) doesn't seem Japanese\n",
				hi, lo));
			line->data[line->size++] = '=';
			line->data[line->size++] = '=';
		    }
		    break;

		case SJIS:
		    if ((text->kcode == EUC) || (text->kcode == JIS)) {
#ifndef CONV_JISX0201KANA_JISX0208KANA
			if (IS_EUC_X0201KANA(hi, lo))
			    line->data[line->size++] = lo;
			else
#endif
			{
			    EUC_TO_SJIS1(hi, lo, tmp);
			    line->data[line->size++] = tmp[0];
			    line->data[line->size++] = tmp[1];
			}
		    } else if (IS_SJIS_2BYTE(hi, lo)) {
			line->data[line->size++] = hi;
			line->data[line->size++] = lo;
		    } else {
			line->data[line->size++] = '=';
			line->data[line->size++] = '=';
			CTRACE((tfp,
				"This character (%X:%X) doesn't seem Japanese\n",
				hi, lo));
		    }
		    break;

		default:
		    break;
d2972 16
d2993 5
a2997 13
	}
#ifndef CONV_JISX0201KANA_JISX0208KANA
	else if ((HTCJK == JAPANESE) && IS_SJIS_X0201KANA(UCH((ch))) &&
		 (kanji_code == EUC)) {
	    line->data[line->size++] = UCH(0x8e);
	    line->data[line->size++] = ch;
	}
#endif
	else if (HTCJK != NOCJK) {
	    line->data[line->size++] = (char) ((kanji_code != NOKANJI) ?
					       ch :
					       (font & HT_CAPITALS) ?
					       TOUPPER(ch) : ch);
d3000 1
a3000 1
		(char) (font & HT_CAPITALS ? TOUPPER(ch) : ch);
d3003 1
a3003 1
	if (font & HT_DOUBLE)	/* Do again if doubled */
d3005 1
a3005 1
	/* NOT a permissible split */
d3010 1
a3010 1
	     * Can split here.  -FM
a3017 1
    return;
d3022 3
a3024 3
 *  -------------------------------------------
 */
void _internal_HTC(HText *text, int style, int dir)
d3026 1
a3026 1
    HTLine *line;
d3033 3
a3035 21
	if (line->numstyles > 0 && dir == 0 &&
	    line->styles[line->numstyles - 1].direction &&
	    line->styles[line->numstyles - 1].style == (unsigned) style &&
	    (int) line->styles[line->numstyles - 1].horizpos
	    == (int) line->size - ctrl_chars_on_this_line) {
	    /*
	     * If this is an OFF change directly preceded by an
	     * ON for the same style, just remove the previous one.  - kw
	     */
	    line->numstyles--;
	} else if (line->numstyles < MAX_STYLES_ON_LINE) {
	    line->styles[line->numstyles].horizpos = line->size;
	    /*
	     * Special chars for bold and underlining usually don't
	     * occur with color style, but soft hyphen can.
	     * And in UTF-8 display mode all non-initial bytes are
	     * counted as ctrl_chars.  - kw
	     */
	    if ((int) line->styles[line->numstyles].horizpos >= ctrl_chars_on_this_line)
		line->styles[line->numstyles].horizpos -= ctrl_chars_on_this_line;
	    line->styles[line->numstyles].style = style;
a3042 371
/*	Set LastChar element in the text object.
 *	----------------------------------------
 */
void HText_setLastChar(HText *text, char ch)
{
    if (!text)
	return;

    text->LastChar = ch;
}

/*	Get LastChar element in the text object.
 *	----------------------------------------
 */
char HText_getLastChar(HText *text)
{
    if (!text)
	return ('\0');

    return ((char) text->LastChar);
}

/*	Set IgnoreExcess element in the text object.
 *	--------------------------------------------
 */
void HText_setIgnoreExcess(HText *text, BOOL ignore)
{
    if (!text)
	return;

    text->IgnoreExcess = ignore;
}

/*		Simple table handling - private
 *		-------------------------------
 */

/*
 * HText_insertBlanksInStblLines fixes up table lines when simple table
 * processing is closed, by calling insert_blanks_in_line for lines
 * that need fixup.  Also recalculates alignment for those lines,
 * does additional updating of anchor positions, and makes sure the
 * display of the lines on screen will be updated after partial display
 * upon return to mainloop.  - kw
 */
static int HText_insertBlanksInStblLines(HText *me, int ncols)
{
    HTLine *line;
    HTLine *mod_line, *first_line = NULL;
    int *oldpos;
    int *newpos;
    int ninserts, lineno;
    int first_lineno, last_lineno, first_lineno_pass2;

#ifdef EXP_NESTED_TABLES
    int last_nonempty = -1;
#endif
    int added_chars_before = 0;
    int lines_changed = 0;
    int max_width = 0, indent, spare, table_offset;
    HTStyle *style;
    short alignment;
    int i = 0;

    lineno = first_lineno = Stbl_getStartLine(me->stbl);
    if (lineno < 0 || lineno > me->Lines)
	return -1;
    /*
     * oldpos, newpos:  allocate space for two int arrays.
     */
    oldpos = typecallocn(int, 2 * ncols);
    if (!oldpos)
	return -1;
    else
	newpos = oldpos + ncols;
    for (line = FirstHTLine(me); i < lineno; line = line->next, i++) {
	if (!line) {
	    free(oldpos);
	    return -1;
	}
    }
    first_lineno_pass2 = last_lineno = me->Lines;
    for (; line && lineno <= last_lineno; line = line->next, lineno++) {
	ninserts = Stbl_getFixupPositions(me->stbl, lineno, oldpos, newpos);
	if (ninserts < 0)
	    continue;
	if (!first_line) {
	    first_line = line;
	    first_lineno_pass2 = lineno;
	    if (TRACE) {
		int ip;

		CTRACE((tfp, "line %d first to adjust  --  newpos:", lineno));
		for (ip = 0; ip < ncols; ip++)
		    CTRACE((tfp, " %d", newpos[ip]));
		CTRACE((tfp, "\n"));
	    }
	}
	if (line == me->last_line) {
	    if (line->size == 0 || HText_TrueEmptyLine(line, me, FALSE))
		continue;
	    /*
	     * Last ditch effort to end the table with a line break,
	     * if HTML_end_element didn't do it.  - kw
	     */
	    if (first_line == line)	/* obscure: all table on last line... */
		first_line = NULL;
	    new_line(me);
	    line = me->last_line->prev;
	    if (first_line == NULL)
		first_line = line;
	}
	if (ninserts == 0) {
	    /*  Do it also for no positions (but not error) */
	    int width = HText_TrueLineSize(line, me, FALSE);

	    if (width > max_width)
		max_width = width;
#ifdef EXP_NESTED_TABLES
	    if (nested_tables) {
		if (width && last_nonempty < lineno)
		    last_nonempty = lineno;
	    }
#endif
	    CTRACE((tfp, "line %d true/max width:%d/%d oldpos: NONE\n",
		    lineno, width, max_width));
	    continue;
	}
	mod_line = insert_blanks_in_line(line, lineno, me,
					 &me->last_anchor_before_stbl /*updates++ */ ,
					 ninserts, oldpos, newpos);
	if (mod_line) {
	    if (line == me->last_line) {
		me->last_line = mod_line;
	    } else {
		added_chars_before += (mod_line->size - line->size);
	    }
	    line->prev->next = mod_line;
	    line->next->prev = mod_line;
	    lines_changed++;
	    if (line == first_line)
		first_line = mod_line;
	    freeHTLine(me, line);
	    line = mod_line;
#ifdef DISP_PARTIAL
	    /*
	     * Make sure modified lines get fully re-displayed after
	     * loading with partial display is done.
	     */
	    if (me->first_lineno_last_disp_partial >= 0) {
		if (me->first_lineno_last_disp_partial >= lineno) {
		    ResetPartialLinenos(me);
		} else if (me->last_lineno_last_disp_partial >= lineno) {
		    me->last_lineno_last_disp_partial = lineno - 1;
		}
	    }
#endif
	} {
	    int width = HText_TrueLineSize(line, me, FALSE);

	    if (width > max_width)
		max_width = width;
#ifdef EXP_NESTED_TABLES
	    if (nested_tables) {
		if (width && last_nonempty < lineno)
		    last_nonempty = lineno;
	    }
#endif
	    if (TRACE) {
		int ip;

		CTRACE((tfp, "line %d true/max width:%d/%d oldpos:",
			lineno, width, max_width));
		for (ip = 0; ip < ninserts; ip++)
		    CTRACE((tfp, " %d", oldpos[ip]));
		CTRACE((tfp, "\n"));
	    }
	}
    }
    /*
     * Line offsets have been set based on the paragraph style, and
     * have already been updated for centering or right-alignment
     * for each line in split_line.  Here we want to undo all that, and
     * align the table as a whole (i.e.  all lines for which
     * Stbl_getFixupPositions returned >= 0).  All those lines have to
     * get the same offset, for the simple table formatting mechanism
     * to make sense, and that may not actually be the case at this point.
     *
     * What indentation and alignment do we want for the table as
     * a whole?  Let's take most style properties from me->style.
     * With some luck, it is the appropriate style for the element
     * enclosing the TABLE.  But let's take alignment from the attribute
     * of the TABLE itself instead, if it was specified.
     *
     * Note that this logic assumes that all lines have been finished
     * by split_line.  The order of calls made by HTML_end_element for
     * HTML_TABLE should take care of this.
     */
    style = me->style;
    alignment = Stbl_getAlignment(me->stbl);
    if (alignment == HT_ALIGN_NONE)
	alignment = style->alignment;
    indent = style->leftIndent;
    /* Calculate spare character positions */
    spare = WRAP_COLS(me) -
	(int) style->rightIndent - indent - max_width;
    if (spare < 0 && (int) style->rightIndent + spare >= 0) {
	/*
	 * Not enough room!  But we can fit if we ignore right indentation,
	 * so let's do that.
	 */
	spare = 0;
    } else if (spare < 0) {
	spare += style->rightIndent;	/* ignore right indent, but need more */
    }
    if (spare < 0 && indent + spare >= 0) {
	/*
	 * Still not enough room.  But we can move to the left.
	 */
	indent += spare;
	spare = 0;
    } else if (spare < 0) {
	/*
	 * Still not enough.  Something went wrong.  Try the best we
	 * can do.
	 */
	CTRACE((tfp,
		"BUG: insertBlanks: resulting table too wide by %d positions!\n",
		-spare));
	indent = spare = 0;
    }
    /*
     * Align left, right or center.
     */
    switch (alignment) {
    case HT_CENTER:
	table_offset = indent + spare / 2;
	break;
    case HT_RIGHT:
	table_offset = indent + spare;
	break;
    case HT_LEFT:
    case HT_JUSTIFY:
    default:
	table_offset = indent;
	break;
    }				/* switch */

    CTRACE((tfp, "changing offsets"));
    for (line = first_line, lineno = first_lineno_pass2;
	 line && lineno <= last_lineno && line != me->last_line;
	 line = line->next, lineno++) {
	ninserts = Stbl_getFixupPositions(me->stbl, lineno, oldpos, newpos);
	if (ninserts >= 0 && (int) line->offset != table_offset) {
#ifdef DISP_PARTIAL
	    /*  As above make sure modified lines get fully re-displayed */
	    if (me->first_lineno_last_disp_partial >= 0) {
		if (me->first_lineno_last_disp_partial >= lineno) {
		    ResetPartialLinenos(me);
		} else if (me->last_lineno_last_disp_partial >= lineno) {
		    me->last_lineno_last_disp_partial = lineno - 1;
		}
	    }
#endif
	    CTRACE((tfp, " %d:%d", lineno, table_offset - line->offset));
	    line->offset = table_offset;
	}
    }
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	if (max_width)
	    Stbl_update_enclosing(me->stbl, max_width, last_nonempty);
    }
#endif
    CTRACE((tfp, " %d:done\n", lineno));
    free(oldpos);
    return lines_changed;
}

/*		Simple table handling - public functions
 *		----------------------------------------
 */

/*	Cancel simple table handling
*/
void HText_cancelStbl(HText *me)
{
    if (!me || !me->stbl) {
	CTRACE((tfp, "cancelStbl: ignored.\n"));
	return;
    }
    CTRACE((tfp, "cancelStbl: ok, will do.\n"));
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	STable_info *stbl = me->stbl;

	while (stbl) {
	    STable_info *enclosing = Stbl_get_enclosing(stbl);

	    Stbl_free(stbl);
	    stbl = enclosing;
	}
    } else
#endif
	Stbl_free(me->stbl);
    me->stbl = NULL;
}

/*	Start simple table handling
*/
void HText_startStblTABLE(HText *me, short alignment)
{
#ifdef EXP_NESTED_TABLES
    STable_info *current = me->stbl;
#endif

    if (!me)
	return;

#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	if (current)
	    new_line(me);
    } else
#endif
    {
	if (me->stbl)
	    HText_cancelStbl(me);	/* auto cancel previously open table */
    }

    me->stbl = Stbl_startTABLE(alignment);
    if (me->stbl) {
	CTRACE((tfp, "startStblTABLE: started.\n"));
#ifdef EXP_NESTED_TABLES
	if (nested_tables) {
	    Stbl_set_enclosing(me->stbl, current, me->last_anchor_before_stbl);
	}
#endif
	me->last_anchor_before_stbl = me->last_anchor;
    } else {
	CTRACE((tfp, "startStblTABLE: failed.\n"));
    }
}

#ifdef EXP_NESTED_TABLES
static void free_enclosed_stbl(HText *me)
{
    if (me->enclosed_stbl != NULL) {
	HTList *list = me->enclosed_stbl;
	STable_info *stbl;

	while (NULL != (stbl = (STable_info *) HTList_nextObject(list))) {
	    CTRACE((tfp, "endStblTABLE: finally free %p\n", me->stbl));
	    Stbl_free(stbl);
	}
	HTList_delete(me->enclosed_stbl);
	me->enclosed_stbl = NULL;
    }
}

#else
#define free_enclosed_stbl(me)	/* nothing */
#endif

/*	Finish simple table handling
 *	Return TRUE if the table is nested inside another table.
 */
int HText_endStblTABLE(HText *me)
{
    int ncols, lines_changed = 0;
    STable_info *enclosing = NULL;
a3043 58
    if (!me || !me->stbl) {
	CTRACE((tfp, "endStblTABLE: ignored.\n"));
	free_enclosed_stbl(me);
	return FALSE;
    }
    CTRACE((tfp, "endStblTABLE: ok, will try.\n"));

    ncols = Stbl_finishTABLE(me->stbl);
    CTRACE((tfp, "endStblTABLE: ncols = %d.\n", ncols));

    if (ncols > 0) {
	lines_changed = HText_insertBlanksInStblLines(me, ncols);
	CTRACE((tfp, "endStblTABLE: changed %d lines, done.\n", lines_changed));
#ifdef DISP_PARTIAL
	/* allow HTDisplayPartial() to redisplay the changed lines.
	 * There is no harm if we got several stbl in the document, hope so.
	 */
	NumOfLines_partial -= lines_changed;	/* fake */
#endif /* DISP_PARTIAL */
    }
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	enclosing = Stbl_get_enclosing(me->stbl);
	me->last_anchor_before_stbl = Stbl_get_last_anchor_before(me->stbl);
	if (enclosing == NULL) {
	    Stbl_free(me->stbl);
	    free_enclosed_stbl(me);
	} else {
	    if (me->enclosed_stbl == NULL)
		me->enclosed_stbl = HTList_new();
	    HTList_addObject(me->enclosed_stbl, me->stbl);
	    CTRACE((tfp, "endStblTABLE: postpone free %p\n", me->stbl));
	}
	me->stbl = enclosing;
    } else {
	Stbl_free(me->stbl);
	me->stbl = NULL;
    }
#else
    Stbl_free(me->stbl);
    me->stbl = NULL;
#endif

    CTRACE((tfp, "endStblTABLE: have%s enclosing table (%p)\n",
	    enclosing == 0 ? " NO" : "", enclosing));

    return enclosing != 0;
}

/*	Start simple table row
*/
void HText_startStblTR(HText *me, short alignment)
{
    if (!me || !me->stbl)
	return;
    if (Stbl_addRowToTable(me->stbl, alignment, me->Lines) < 0)
	HText_cancelStbl(me);	/* give up */
}
d3045 2
a3046 1
/*	Finish simple table row
d3048 3
a3050 1
void HText_endStblTR(HText *me)
d3052 1
a3052 1
    if (!me || !me->stbl)
a3053 2
    /* should this do something?? */
}
d3055 1
a3055 24
/*	Start simple table cell
*/
void HText_startStblTD(HText *me, int colspan,
		       int rowspan,
		       short alignment,
		       BOOL isheader)
{
    if (!me || !me->stbl)
	return;
    if (colspan < 0)
	colspan = 1;
    if (colspan > TRST_MAXCOLSPAN) {
	CTRACE((tfp, "*** COLSPAN=%d is too large, ignored!\n", colspan));
	colspan = 1;
    }
    if (rowspan > TRST_MAXROWSPAN) {
	CTRACE((tfp, "*** ROWSPAN=%d is too large, ignored!\n", rowspan));
	rowspan = 1;
    }
    if (Stbl_addCellToTable(me->stbl, colspan, rowspan, alignment, isheader,
			    me->Lines,
			    HText_LastLineOffset(me),
			    HText_LastLineSize(me, FALSE)) < 0)
	HText_cancelStbl(me);	/* give up */
d3058 2
a3059 1
/*	Finish simple table cell
d3061 2
a3062 1
void HText_endStblTD(HText *me)
d3064 2
a3065 8
    if (!me || !me->stbl)
	return;
    if (Stbl_finishCellInTable(me->stbl, TRST_ENDCELL_ENDTD,
			       me->Lines,
			       HText_LastLineOffset(me),
			       HText_LastLineSize(me, FALSE)) < 0)
	HText_cancelStbl(me);	/* give up */
}
d3067 1
a3067 16
/*	Remember COL info / Start a COLGROUP and remember info
*/
void HText_startStblCOL(HText *me, int span,
			short alignment,
			BOOL isgroup)
{
    if (!me || !me->stbl)
	return;
    if (span <= 0)
	span = 1;
    if (span > TRST_MAXCOLSPAN) {
	CTRACE((tfp, "*** SPAN=%d is too large, ignored!\n", span));
	span = 1;
    }
    if (Stbl_addColInfo(me->stbl, span, alignment, isgroup) < 0)
	HText_cancelStbl(me);	/* give up */
d3070 2
a3071 1
/*	Finish a COLGROUP
d3073 3
a3075 1
void HText_endStblCOLGROUP(HText *me)
d3077 1
a3077 1
    if (!me || !me->stbl)
a3078 3
    if (Stbl_finishColGroup(me->stbl) < 0)
	HText_cancelStbl(me);	/* give up */
}
d3080 1
a3080 8
/*	Start a THEAD / TFOOT / TBODY - remember its alignment info
*/
void HText_startStblRowGroup(HText *me, short alignment)
{
    if (!me || !me->stbl)
	return;
    if (Stbl_addRowGroup(me->stbl, alignment) < 0)
	HText_cancelStbl(me);	/* give up */
d3084 2
a3085 27
 *		---------------
 */
static void add_link_number(HText *text, TextAnchor *a, BOOL save_position)
{
    char marker[32];

    /*
     * If we are doing link_numbering add the link number.
     */
    if ((a->number > 0)
#ifdef USE_PRETTYSRC
	&& (text->source ? !psrcview_no_anchor_numbering : 1)
#endif
	&& links_are_numbered()) {
	char saved_lastchar = text->LastChar;
	int saved_linenum = text->Lines;

	sprintf(marker, "[%d]", a->number);
	HText_appendText(text, marker);
	if (saved_linenum && text->Lines && saved_lastchar != ' ')
	    text->LastChar = ']';	/* if marker not after space caused split */
	if (save_position) {
	    a->line_num = text->Lines;
	    a->line_pos = text->last_line->size;
	}
    }
}
d3089 4
a3092 2
int HText_beginAnchor(HText *text, BOOL underline,
		      HTChildAnchor *anc)
d3094 1
a3094 1
    TextAnchor *a;
d3096 1
a3096 1
    POOLtypecalloc(TextAnchor, a);
d3100 3
d3119 1
a3119 1
    if (HTAnchor_followTypedLink(anc, HTInternalLink)) {
d3124 1
a3124 1
    if (HTAnchor_followLink(anc)) {
d3130 18
a3147 3
    if (number_links_on_left)
	add_link_number(text, a, TRUE);
    return (a->number);
d3150 4
a3153 3
/* If !really, report whether the anchor is empty. */
static BOOL HText_endAnchor0(HText *text, int number,
			     int really)
d3158 8
a3165 8
     * The number argument is set to 0 in HTML.c and
     * LYCharUtils.c when we want to end the anchor
     * for the immediately preceding HText_beginAnchor()
     * call.  If it's greater than 0, we want to handle
     * a particular anchor.  This allows us to set links
     * for positions indicated by NAME or ID attributes,
     * without needing to close any anchor with an HREF
     * within which that link might be embedded.  -FM
d3177 3
a3179 3
	     * There's no anchor with that number,
	     * so we'll default to the last anchor,
	     * and cross our fingers.  -FM
d3185 2
a3186 2
    CTRACE((tfp, "GridText:HText_endAnchor0: number:%d link_type:%d\n",
	    a->number, a->link_type));
d3189 1
a3189 1
	 * Shouldn't happen, but put test here anyway to be safe.  - LE
d3192 3
a3194 3
	CTRACE((tfp,
		"BUG: HText_endAnchor0: internal error: last anchor was input field!\n"));
	return FALSE;
a3195 1

d3198 1
a3198 1
	 * If it goes somewhere...
d3201 8
a3208 6
	BOOL remove_numbers_on_empty = (BOOL) ((links_are_numbered() &&
						((text->hiddenlinkflag != HIDDENLINKS_MERGE)
						 || (LYNoISMAPifUSEMAP &&
						     !(text->node_anchor && text->node_anchor->bookmark)
						     && HTAnchor_isISMAPScript
						     (HTAnchor_followLink(a->anchor))))));
a3213 12
	int extent_adjust = 0;

	/* Find the length taken by the anchor */
	l = text->Lines;	/* lineno of last */
	while (l > a->line_num) {
	    extent_adjust += start->size;
	    start = start->prev;
	    l--;
	}
	/* Now start is the start line of the anchor */
	extent_adjust += start->size - a->line_pos;
	start = last;		/* Used later */
d3216 7
a3222 6
	 * Check if the anchor content has only
	 * white and special characters, starting
	 * with the content on the last line.  -FM
	 */
	a->extent += extent_adjust;
	if (a->extent > (int) last->size) {
d3224 2
a3225 2
	     * The anchor extends over more than one line,
	     * so set up to check the entire last line.  -FM
d3230 2
a3231 2
	     * The anchor is restricted to the last line,
	     * so check from the start of the anchor.  -FM
d3236 1
a3236 1
	while (j < (int) last->size) {
d3238 1
a3238 1
		!isspace(UCH(last->data[j])) &&
d3246 1
a3246 1
	    if (a->extent > (int) last->size) {
d3248 4
a3251 4
		 * The anchor starts on a preceding line, and
		 * the last line has only white and special
		 * characters, so declare the entire extent
		 * of the last line as blank.  -FM
d3256 3
a3258 3
		 * The anchor starts on the last line, and
		 * has only white or special characters, so
		 * declare the anchor's extent as blank.  -FM
d3264 6
a3269 6
	 * While the anchor starts on a line preceding
	 * the one we just checked, and the one we just
	 * checked has only white and special characters,
	 * check whether the anchor's content on the
	 * immediately preceding line also has only
	 * white and special characters.  -FM
d3282 2
a3283 2
		 * The anchor starts on a preceding line,
		 * so check all of this line.  -FM
d3289 1
a3289 1
		 * The anchor starts on this line.  -FM
d3293 1
a3293 1
	    while (j < (int) prev->size) {
d3295 1
a3295 1
		    !isspace(UCH(prev->data[j])) &&
d3303 2
a3304 2
		if (a->extent > (CurBlankExtent + (int) prev->size) ||
		    (a->extent == CurBlankExtent + (int) prev->size &&
d3310 4
a3313 4
		     * This line has only white and special
		     * characters, so treat its entire extent
		     * as blank, and decrement the pointer for
		     * the line to be analyzed.  -FM
d3320 3
a3322 3
		     * The anchor starts on this line, and it
		     * has only white or special characters, so
		     * declare the anchor's extent as blank.  -FM
a3328 4
	if (!really) {		/* Just report whether it is empty */
	    a->extent -= extent_adjust;
	    return (BOOL) (i == 0);
	}
d3331 3
a3333 3
	     * It's an invisible anchor probably from an ALT=""
	     * or an ignored ISMAP attribute due to a companion
	     * USEMAP.  -FM
d3337 4
a3340 4
	    CTRACE((tfp,
		    "HText_endAnchor0: hidden (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
		    a->line_num, a->line_pos, a->extent,
		    BlankExtent));
d3343 2
a3344 2
	     * If links are numbered, then try to get rid of the
	     * numbered bracket and adjust the anchor count.  -FM
d3359 3
a3361 3
		 * Set start->data[j] to the close-square-bracket,
		 * or to the beginning of the line on which the
		 * anchor start.  -FM
d3365 1
a3365 1
		     * The anchor starts on the last line.  -FM
d3370 1
a3370 1
		     * The anchor starts on a previous line.  -FM
d3380 7
a3386 7
		 * If start->data[j] is a close-square-bracket, verify
		 * that it's the end of the numbered bracket, and if so,
		 * strip the numbered bracket.  If start->data[j] is not
		 * a close-square-bracket, check whether we had a wrap
		 * and the close-square-bracket is at the end of the
		 * previous line.  If so, strip the numbered bracket
		 * from that line.  -FM
d3391 1
a3391 1
		    while (j >= 0 && isdigit(UCH(start->data[j]))) {
d3401 2
a3402 2
			 * The numbered bracket is entirely
			 * on this line.  -FM
d3405 2
a3406 2
			if (start == last && (int) text->permissible_split > j) {
			    if ((int) text->permissible_split - NumSize < j)
d3412 1
a3412 1
			while (k < (int) start->size)
d3414 2
d3417 1
d3420 1
a3420 1
				anc->line_pos -= NumSize;
d3426 1
a3426 1
			    start->data[j++] = '\0';
d3434 1
a3434 1
			       isdigit(UCH(prev->data[j]))) {
d3444 3
a3446 3
			     * The numbered bracket started on the
			     * previous line, and part of it was
			     * wrapped to this line.  -FM
d3450 1
a3450 1
			    while (i < (int) prev->size)
d3452 4
d3461 1
a3461 1
				if ((int) text->permissible_split < k)
d3468 1
a3468 1
			    while (k < (int) start->size)
d3470 2
d3473 1
d3485 2
a3486 2
			     * Shucks!  We didn't find the
			     * numbered bracket.  -FM
d3492 2
a3493 2
			 * Shucks!  We didn't find the
			 * numbered bracket.  -FM
d3506 1
a3506 1
			 isdigit(UCH(prev->data[j - 1])))) {
d3511 1
a3511 1
			       isdigit(UCH(prev->data[j]))) {
d3521 3
a3523 3
			     * The numbered bracket is all on the
			     * previous line, and the anchor content
			     * was wrapped to the last line.  -FM
d3527 1
a3527 1
			    while (k < (int) prev->size)
d3529 4
d3539 2
a3540 2
			     * Shucks!  We didn't find the
			     * numbered bracket.  -FM
d3546 2
a3547 2
			 * Shucks!  We didn't find the
			 * numbered bracket.  -FM
d3553 2
a3554 2
		     * Shucks!  We didn't find the
		     * numbered bracket.  -FM
a3559 2
	    if (!number_links_on_left)
		add_link_number(text, a, FALSE);
d3561 3
a3563 3
	     * The anchor's content is not restricted to only
	     * white and special characters, so we'll show it
	     * as a link.  -FM
d3567 4
a3570 4
		CTRACE((tfp,
			"HText_endAnchor0: blanks (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
			a->line_num, a->line_pos, a->extent,
			BlankExtent));
d3575 5
a3579 5
	     * The anchor's content is restricted to white
	     * and special characters, so set its number
	     * and extent to zero, decrement the visible
	     * anchor number counter, and add this anchor
	     * to the hidden links list.  -FM
d3589 4
a3592 4
	     * The anchor's content is not restricted to white
	     * and special characters, so we'll display the
	     * content, but shorten its extent by any trailing
	     * blank lines we've detected.  -FM
d3595 1
a3595 1
			  BlankExtent : 0);
d3598 5
a3602 5
	    CTRACE((tfp,
		    "->[%d](%d,%d,%d,%d)\n",
		    a->number,
		    a->line_num, a->line_pos, a->extent,
		    BlankExtent));
a3604 2
	if (!really)		/* Just report whether it is empty */
	    return FALSE;
d3606 3
a3608 3
	 * It's a named anchor without an HREF, so it
	 * should be registered but not shown as a
	 * link.  -FM
a3612 6
    return FALSE;
}

void HText_endAnchor(HText *text, int number)
{
    HText_endAnchor0(text, number, 1);
a3614 11
/*
    This returns whether the given anchor has blank content. Shamelessly copied
    from HText_endAnchor. The values returned are meaningful only for "normal"
    links - like ones produced by <a href=".">foo</a>, no inputs, etc. - VH
*/
#ifdef MARK_HIDDEN_LINKS
BOOL HText_isAnchorBlank(HText *text, int number)
{
    return HText_endAnchor0(text, number, 0);
}
#endif /* MARK_HIDDEN_LINKS */
d3616 3
a3618 1
void HText_appendText(HText *text, const char *str)
d3620 1
a3620 1
    const char *p;
d3633 3
a3635 1
static int remove_special_attr_chars(char *buf)
a3637 1
    register int soft_newline_count = 0;
d3639 1
a3639 1
    for (cp = buf; *cp != '\0'; cp++) {
d3641 1
a3641 1
	 * Don't print underline chars.
a3642 1
	soft_newline_count += (*cp == LY_SOFT_NEWLINE);
d3644 2
a3645 1
	    *buf++ = *cp;
a3648 1
    return soft_newline_count;
d3651 1
d3653 7
a3659 6
 *  This function trims blank lines from the end of the document, and
 *  then gets the hightext from the text by finding the char position,
 *  and brings the anchors in line with the text by adding the text
 *  offset to each of the anchors.
 */
void HText_endAppend(HText *text)
d3666 1
a3666 1
    CTRACE((tfp, "GridText: Entering HText_endAppend\n"));
d3669 1
a3669 1
     * Create a blank line at the bottom.
a3673 2
	if (text->stbl)
	    HText_cancelStbl(text);
d3675 3
a3677 3
	 * If output was stopped because memory was low, and we made
	 * it to the end of the document, reset those flags and hope
	 * things are better now.  - kw
a3680 6
    } else if (text->stbl) {
	/*
	 * Could happen if TABLE end tag was missing.
	 * Alternatively we could cancel in this case.  - kw
	 */
	HText_endStblTABLE(text);
d3684 1
a3684 1
     * Get the first line.
d3686 1
a3686 1
    line_ptr = FirstHTLine(text);
d3689 1
a3689 1
     * Remove the blank lines at the end of document.
d3694 3
a3696 2
	CTRACE((tfp, "GridText: Removing bottom blank line: `%s'\n",
		text->last_line->data));
d3698 1
a3698 1
	 * line_ptr points to the first line.
d3702 1
a3702 1
	freeHTLine(text, text->last_line);
d3705 2
a3706 2
	CTRACE((tfp, "GridText: New bottom line: `%s'\n",
		text->last_line->data));
d3710 2
a3711 2
     * Fix up the anchor structure values and
     * create the hightext strings.  -FM
d3713 1
a3713 1
    HText_trimHightext(text, TRUE, -1);
d3716 1
d3718 26
a3743 26
 *  This function gets the hightext from the text by finding the char
 *  position, and brings the anchors in line with the text by adding the text
 *  offset to each of the anchors.
 *
 *  `Forms input' fields cannot be displayed properly without this function
 *  to be invoked (detected in display_partial mode).
 *
 *  If final is set, this is the final fixup; if not set, we don't have
 *  to do everything because there should be another call later.
 *
 *  BEFORE this function has treated a TextAnchor, its line_pos and
 *  extent fields are counting bytes in the HTLine data, including
 *  invisible special attribute chars and counting UTF-8 multibyte
 *  characters as multiple bytes.
 *
 *  AFTER the adjustment, the anchor line_pos (and hightext offset if
 *  applicable) fields indicate x positions in terms of displayed character
 *  cells, and the extent field apparently is unimportant; the anchor text has
 *  been copied to the hightext fields (which should have been NULL up to that
 *  point), with special attribute chars removed.
 *
 *  This needs to be done so that display_page finds the anchors in the
 *  form it expects when it sets the links[] elements.
 */
static void HText_trimHightext(HText *text, BOOLEAN final,
			       int stop_before)
d3745 1
a3745 1
    int cur_line, cur_shift;
a3748 1
    HTLine *line_ptr2;
a3749 4
    char *hilite_str;
    int hilite_len;
    int actual_len;
    int count_line;
d3754 2
a3755 9
    if (final) {
	CTRACE((tfp, "GridText: Entering HText_trimHightext (final)\n"));
    } else {
	if (stop_before < 0 || stop_before > text->Lines)
	    stop_before = text->Lines;
	CTRACE((tfp,
		"GridText: Entering HText_trimHightext (partial: 0..%d/%d)\n",
		stop_before, text->Lines));
    }
d3758 1
a3758 1
     * Get the first line.
d3760 2
a3761 1
    line_ptr = FirstHTLine(text);
d3765 2
a3766 2
     * Fix up the anchor structure values and
     * create the hightext strings.  -FM
d3769 11
a3779 11
	 anchor_ptr != NULL;
	 prev_a = anchor_ptr, anchor_ptr = anchor_ptr->next) {
	int anchor_col;

      re_parse:
	/*
	 * Find the right line.
	 */
	for (; anchor_ptr->line_num > cur_line;
	     line_ptr = line_ptr->next, cur_line++) {
	    ;			/* null body */
d3784 3
a3786 3
	     * If this is not the final call, stop when we have reached
	     * the last line, or the very end of preceding line.
	     * The last line is probably still not finished.  - kw
d3788 1
a3788 1
	    if (cur_line >= stop_before)
d3790 1
a3790 2
	    if (anchor_ptr->line_num >= text->Lines - 1
		&& anchor_ptr->line_pos >= (int) text->last_line->prev->size)
d3793 2
a3794 2
	     * Also skip this anchor if it looks like HText_endAnchor
	     * is not yet done with it.  - kw
d3804 3
a3806 3
	 * If hightext has already been set, then we must have already
	 * done the trimming & adjusting for this anchor, so avoid
	 * doing it a second time.  - kw
d3808 1
a3808 1
	if (LYGetHiTextStr(anchor_ptr, 0) != NULL)
d3811 1
a3811 1
	if (anchor_ptr->line_pos > (int) line_ptr->size) {
d3813 3
d3818 1
d3822 4
a3825 4
	CTRACE((tfp,
		"GridText: Anchor found on line:%d col:%d [%d] ext:%d\n",
		cur_line, anchor_ptr->line_pos,
		anchor_ptr->number, anchor_ptr->extent));
d3829 2
a3830 2
	 * Strip off any spaces or SpecialAttrChars at the beginning,
	 * if they exist, but only on HYPERTEXT_ANCHORS.
d3833 1
a3833 1
	    ch = UCH(line_ptr->data[anchor_ptr->line_pos]);
d3839 1
a3839 1
		ch = UCH(line_ptr->data[anchor_ptr->line_pos]);
d3845 1
d3847 2
a3848 1
	CTRACE((tfp, "anchor text: '%s'\n", line_ptr->data));
d3850 5
a3854 6
	 * If the link begins with an end of line and we have more lines, then
	 * start the highlighting on the next line.  -FM.
	 *
	 * But if an empty anchor is at the end of line and empty, keep it
	 * where it is, unless the previous anchor in the list (if any) already
	 * starts later.  - kw
d3856 1
a3856 1
	if ((unsigned) anchor_ptr->line_pos >= strlen(line_ptr->data)) {
d3859 4
a3862 6
		 anchor_ptr->line_pos != (int) line_ptr->size ||
		 (prev_a &&	/* How could this happen? */
		  (prev_a->line_num > anchor_ptr->line_num)))) {
		anchor_ptr->line_num++;
		anchor_ptr->line_pos = 0;
		CTRACE((tfp, "found anchor at end of line\n"));
d3865 1
a3865 1
		CTRACE((tfp, "found anchor at end of line, leaving it there\n"));
d3870 1
a3870 1
	 * Copy the link name into the data structure.
d3872 5
a3876 11
	if (line_ptr->data
	    && anchor_ptr->extent > 0
	    && anchor_ptr->line_pos >= 0) {
	    int size = (int) line_ptr->size - anchor_ptr->line_pos;

	    if (size > anchor_ptr->extent)
		size = anchor_ptr->extent;
	    LYClearHiText(anchor_ptr);
	    LYSetHiText(anchor_ptr,
			&line_ptr->data[anchor_ptr->line_pos],
			size);
d3878 1
a3878 2
	    LYClearHiText(anchor_ptr);
	    LYSetHiText(anchor_ptr, "", 0);
d3882 2
a3883 2
	 * If the anchor extends over more than one line, copy that into the
	 * data structure.
d3885 2
a3886 3
	hilite_str = LYGetHiTextStr(anchor_ptr, 0);
	hilite_len = strlen(hilite_str);
	actual_len = anchor_ptr->extent;
d3888 5
a3892 14
	line_ptr2 = line_ptr;
	count_line = cur_line;
	while (actual_len > hilite_len) {
	    HTLine *old_line_ptr2 = line_ptr2;

	    count_line++;
	    line_ptr2 = line_ptr2->next;

	    if (!final
		&& count_line >= stop_before) {
		LYClearHiText(anchor_ptr);
		break;
	    } else if (old_line_ptr2 == text->last_line) {
		break;
a3893 1

d3895 2
a3896 2
	     * Double check that we have a line pointer, and if so, copy into
	     * highlight text.
d3898 2
a3899 6
	    if (line_ptr2
		&& line_ptr2->size) {
		char *hi_string = NULL;
		int hi_offset = line_ptr2->offset;

		StrnAllocCopy(hi_string,
d3901 4
a3904 5
			      (actual_len - hilite_len));
		actual_len -= strlen(hi_string);
		/*handle LY_SOFT_NEWLINEs -VH */
		hi_offset += remove_special_attr_chars(hi_string);

d3906 5
a3910 6
		    LYTrimTrailing(hi_string);
		}
		if (non_empty(hi_string)) {
		    LYAddHiText(anchor_ptr, hi_string, hi_offset);
		} else if (actual_len > hilite_len) {
		    LYAddHiText(anchor_ptr, "", hi_offset);
a3911 1
		FREE(hi_string);
d3914 1
a3914 8

	if (!final
	    && count_line >= stop_before) {
	    break;
	}

	hilite_str = LYGetHiTextStr(anchor_ptr, 0);
	remove_special_attr_chars(hilite_str);
d3916 1
a3916 1
	    LYTrimTrailing(hilite_str);
d3920 2
a3921 1
	 * Save the offset (bytes) of the anchor in the line's data.
a3922 16
	anchor_col = anchor_ptr->line_pos;

	/*
	 * Subtract any formatting characters from the x position of the link.
	 */
#ifdef WIDEC_CURSES
	if (anchor_ptr->line_pos > 0) {
	    /*
	     * LYstrExtent filters out the formatting characters, so we do not
	     * have to count them here.
	     *
	     * FIXME: do we have to count soft-newlines?
	     */
	    anchor_ptr->line_pos = LYstrExtent2(line_ptr->data, anchor_col);
	}
#else /* 8-bit curses, etc.  */
d3925 1
a3925 3
	    int have_soft_newline_in_1st_line = 0;

	    for (; i < anchor_col; i++) {
d3927 1
a3927 1
		    IsSpecialAttrChar(line_ptr->data[i])) {
a3928 3
		    have_soft_newline_in_1st_line += (line_ptr->data[i] == LY_SOFT_NEWLINE);
		}
	    }
a3929 2
	    /*handle LY_SOFT_NEWLINEs -VH */
	    anchor_ptr->line_pos += have_soft_newline_in_1st_line;
a3930 1
#endif /* WIDEC_CURSES */
d3933 1
a3933 1
	 * Set the line number.
d3936 5
a3940 1
	anchor_ptr->line_num = cur_line;
d3942 5
a3946 3
	CTRACE((tfp, "GridText:     add link on line %d col %d [%d] %s\n",
		cur_line, anchor_ptr->line_pos,
		anchor_ptr->number, "in HText_trimHightext"));
d3950 10
d3962 2
a3963 1
HTParentAnchor *HText_nodeAnchor(HText *text)
d3969 2
a3970 3
 *				=================
 */

d3972 2
a3973 2
 * HText_childNextNumber() returns the anchor with index [number],
 * using a pointer from the previous number (=optimization) or NULL.
d3975 2
a3976 1
HTChildAnchor *HText_childNextNumber(int number, void **prev)
d3978 1
a3978 2
    /* Sorry, TextAnchor is not declared outside this file, use a cast. */
    TextAnchor *a = (TextAnchor *) *prev;
d3980 2
a3981 4
    if (!HTMainText || number <= 0)
	return (HTChildAnchor *) 0;	/* Fail */
    if (number == 1 || !a)
	a = HTMainText->first_anchor;
d3983 5
a3987 9
    /* a strange thing:  positive a->number's are sorted,
     * and between them several a->number's may be 0 -- skip them
     */
    for (; a && a->number != number; a = a->next) ;

    if (!a)
	return (HTChildAnchor *) 0;	/* Fail */
    *prev = (void *) a;
    return a->anchor;
d3991 3
a3993 3
 * HText_FormDescNumber() returns a description of the form field
 * with index N.  The index corresponds to the [number] we print
 * for the field.  -FM & LE
d3995 3
a3997 2
void HText_FormDescNumber(int number,
			  const char **desc)
d3999 1
a3999 1
    TextAnchor *a;
d4005 2
a4006 2
	*desc = gettext("unknown field or link");
	return;
d4020 45
a4064 45
    case F_TEXT_TYPE:
	*desc = gettext("text entry field");
	return;
    case F_PASSWORD_TYPE:
	*desc = gettext("password entry field");
	return;
    case F_CHECKBOX_TYPE:
	*desc = gettext("checkbox");
	return;
    case F_RADIO_TYPE:
	*desc = gettext("radio button");
	return;
    case F_SUBMIT_TYPE:
	*desc = gettext("submit button");
	return;
    case F_RESET_TYPE:
	*desc = gettext("reset button");
	return;
    case F_OPTION_LIST_TYPE:
	*desc = gettext("popup menu");
	return;
    case F_HIDDEN_TYPE:
	*desc = gettext("hidden form field");
	return;
    case F_TEXTAREA_TYPE:
	*desc = gettext("text entry area");
	return;
    case F_RANGE_TYPE:
	*desc = gettext("range entry field");
	return;
    case F_FILE_TYPE:
	*desc = gettext("file entry field");
	return;
    case F_TEXT_SUBMIT_TYPE:
	*desc = gettext("text-submit field");
	return;
    case F_IMAGE_SUBMIT_TYPE:
	*desc = gettext("image-submit button");
	return;
    case F_KEYGEN_TYPE:
	*desc = gettext("keygen field");
	return;
    default:
	*desc = gettext("unknown form field");
	return;
d4069 1
a4069 1
 * is to jump (input was 123+ or 123- or 123+g or 123-g or 123 or 123g)
d4074 4
a4077 3
int HTGetRelLinkNum(int num,
		    int rel,
		    int cur)
d4080 1
a4080 1
    int scrtop = HText_getTopOfScreen();	/*XXX +1? */
d4083 1
a4083 2
    int on_screen = (curline >= scrtop && curline < (scrtop + display_lines));

d4089 7
a4095 10
    CTRACE((tfp, "HTGetRelLinkNum(%d,%d,%d) -- HTMainText=%p\n",
	    num, rel, cur, HTMainText));
    CTRACE((tfp,
	    "  scrtop=%d, curline=%d, curanchor=%d, display_lines=%d, %s\n",
	    scrtop, curline, curanchor, display_lines,
	    on_screen ? "on_screen" : "0"));
    if (!HTMainText)
	return 0;
    if (rel == 0)
	return num;
d4098 5
a4102 8
    if (on_screen && curanchor) {
	CTRACE((tfp, "curanchor=%d at line %d on screen\n", curanchor, curline));
	if (rel == '+')
	    return curanchor + num;
	else if (rel == '-')
	    return curanchor - num;
	else
	    return num;		/* shouldn't happen */
d4109 3
a4111 5
	CTRACE((tfp, "  a->line_num=%d, a->number=%d\n", a->line_num, a->number));
	if (a->line_num >= scrtop)
	    break;
	if (a->number == 0)
	    continue;
d4115 5
a4119 9
    CTRACE((tfp, "  a=%p, l=%p, curanchor=%d\n", a, l, curanchor));
    if (on_screen) {		/* on screen but not a numbered link */
	for (; a; a = a->next) {
	    if (a->number) {
		l = a;
		curanchor = l->number;
	    }
	    if (curline == a->line_num && curpos == a->line_pos)
		break;
d4122 1
a4122 1
    if (rel == '+') {
d4124 2
a4125 2
    } else if (rel == '-') {
	if (l)
d4128 1
a4128 1
	    for (; a && a->number == 0; a = a->next) ;
d4131 2
a4132 2
    } else
	return num;		/* shouldn't happen */
d4136 1
a4136 1
 * HTGetLinkInfo returns some link info based on the number.
d4138 5
a4142 5
 * If want_go is not 0, caller requests to know a line number for
 * the link indicated by number.  It will be returned in *go_line, and
 * *linknum will be set to an index into the links[] array, to use after
 * the line in *go_line has been made the new top screen line.
 * *hightext and *lname are unchanged.  - KW
d4144 2
a4145 2
 * If want_go is 0 and the number doesn't represent an input field, info
 * on the link indicated by number is deposited in *hightext and *lname.
d4147 7
a4153 6
int HTGetLinkInfo(int number,
		  int want_go,
		  int *go_line,
		  int *linknum,
		  char **hightext,
		  char **lname)
a4156 1

d4164 1
a4164 1
	return (NO);
d4168 7
a4174 7
	 * Count anchors, first on current line if there is more
	 * than one.  We have to count all links, including form
	 * field anchors and others with a->number == 0, because
	 * they are or will be included in the links[] array.
	 * The exceptions are hidden form fields and anchors with
	 * show_anchor not set, because they won't appear in links[]
	 * and don't count towards nlinks.  - KW
d4177 2
a4178 2
	    !(a->link_type == INPUT_ANCHOR
	      && a->input_field->type == F_HIDDEN_TYPE)) {
d4183 3
a4185 3
		 * This anchor is on a different line than the previous one.
		 * Remember which was the line number of the previous anchor,
		 * for use in screen positioning later.  - KW
d4193 5
a4197 5
		 * Count all anchors starting with the top line of the
		 * currently displayed screen.  Just keep on counting
		 * beyond this screen's bottom line - we'll know whether
		 * a found anchor is below the current screen by a check
		 * against nlinks later.  - KW
d4205 2
a4206 2
	     * We found it.  Now process it, depending
	     * on what kind of info is requested.  - KW
d4211 8
a4218 8
		     * The number requested has been assigned to an anchor
		     * without any selectable text, so we cannot position
		     * on it.  The code for suppressing such anchors in
		     * HText_endAnchor() may not have applied, or it may
		     * have failed.  Return a failure indication so that
		     * the user will notice that something is wrong,
		     * instead of positioning on some other anchor which
		     * might result in inadvertent activation.  - KW
d4220 1
a4220 1
		    return (NO);
d4225 1
a4225 1
		    a->line_num < HTMainText->top_of_screen + (display_lines)) {
d4227 4
a4230 4
		     * If the requested anchor is within the current screen,
		     * just set *go_line so that the screen window won't move
		     * (keep it as it is), and set *linknum to the index of
		     * this link in the current links[] array.  - KW
d4237 3
a4239 3
		     * if the requested anchor is not within the currently
		     * displayed screen, set *go_line such that the top line
		     * will be either
d4245 5
a4249 5
		     * whichever comes last.  In all cases the line with our
		     * target will end up being the first line with any links
		     * on the new screen, so that we can use the
		     * anchors_this_line counter to point to the anchor in
		     * the new links[] array.  - kw
a4251 1

d4264 1
a4264 1
		return (LINK_LINE_FOUND);
d4266 2
a4267 2
		*hightext = LYGetHiTextStr(a, 0);
		link_dest = HTAnchor_followLink(a->anchor);
a4269 1

d4275 2
a4276 2
			    link_dest_intl =
				HTAnchor_followTypedLink(a->anchor, HTInternalLink);
d4279 2
a4280 3
				CTRACE((tfp,
					"HTGetLinkInfo: unexpected typed link to %s!\n",
					link_dest_intl->parent->address));
a4285 1

d4288 1
a4288 1
			    return (WWW_INTERN_LINK_TYPE);
d4296 1
a4296 1
		return (WWW_LINK_TYPE);
d4300 1
a4300 1
    return (NO);
d4303 6
a4308 5
static BOOLEAN same_anchor_or_field(int numberA,
				    FormInfo * formA,
				    int numberB,
				    FormInfo * formB,
				    BOOLEAN ta_same)
d4312 1
a4312 1
	    return (YES);
d4314 1
a4314 1
	    return (NO);
d4318 1
a4318 1
	    return (YES);
d4320 1
a4320 1
	    return (NO);
d4322 1
a4322 1
	    return (NO);
d4325 1
a4325 1
	return (NO);
d4328 2
a4329 3
	formA->type != F_TEXTAREA_TYPE ||
	formB->type != F_TEXTAREA_TYPE) {
	return (NO);
d4332 1
a4332 1
	return (NO);
d4334 2
a4335 2
	return (YES);
    return (BOOL) (strcmp(formA->name, formB->name) == 0);
d4338 1
a4338 1
#define same_anchor_as_link(i,a,ta_same) (i >= 0 && a &&\
d4340 1
a4340 1
		(links[i].type == WWW_FORM_LINK_TYPE) ? links[i].l_form : NULL,\
d4343 2
a4344 2
		ta_same))
#define same_anchors(a1,a2,ta_same) (a1 && a2 &&\
d4349 1
a4349 1
		ta_same))
d4352 1
a4352 39
 * Are there more textarea lines belonging to the same textarea before
 * (direction < 0) or after (direction > 0) the current one?
 * On entry, curlink must be the index in links[] of a textarea field.  - kw
 */
BOOL HText_TAHasMoreLines(int curlink,
			  int direction)
{
    TextAnchor *a;
    TextAnchor *prev_a = NULL;

    if (!HTMainText)
	return (NO);
    if (direction < 0) {
	for (a = HTMainText->first_anchor; a; prev_a = a, a = a->next) {
	    if (a->link_type == INPUT_ANCHOR &&
		links[curlink].l_form == a->input_field) {
		return same_anchors(a, prev_a, TRUE);
	    }
	    if (links[curlink].anchor_number &&
		a->number >= links[curlink].anchor_number)
		break;
	}
	return NO;
    } else {
	for (a = HTMainText->first_anchor; a; a = a->next) {
	    if (a->link_type == INPUT_ANCHOR &&
		links[curlink].l_form == a->input_field) {
		return same_anchors(a, a->next, TRUE);
	    }
	    if (links[curlink].anchor_number &&
		a->number >= links[curlink].anchor_number)
		break;
	}
	return NO;
    }
}

/*
 * HTGetLinkOrFieldStart - moving to previous or next link or form field.
d4354 1
a4354 1
 * On input,
d4361 2
a4362 2
 * The caller wants a information for positioning on the new link to be
 * deposited in *go_line and (if linknum is not NULL) *linknum.
d4364 16
a4379 15
 * On failure (no more links in the requested direction) returns NO
 * and doesn't change *go_line or *linknum.  Otherwise, LINK_DO_ARROWUP
 * may be returned, and *go_line and *linknum not changed, to indicate that
 * the caller should use a normal PREV_LINK or PREV_PAGE mechanism.
 * Otherwise:
 * The number (0-based counting) for the new top screen line will be returned
 * in *go_line, and *linknum will be set to an index into the links[] array,
 * to use after the line in *go_line has been made the new top screen
 * line.  - kw
 */
int HTGetLinkOrFieldStart(int curlink,
			  int *go_line,
			  int *linknum,
			  int direction,
			  BOOLEAN ta_skip)
d4394 1
a4394 1
	return (NO);
d4403 7
a4409 7
	 * Count anchors, first on current line if there is more
	 * than one.  We have to count all links, including form
	 * field anchors and others with a->number == 0, because
	 * they are or will be included in the links[] array.
	 * The exceptions are hidden form fields and anchors with
	 * show_anchor not set, because they won't appear in links[]
	 * and don't count towards nlinks.  - KW
d4412 2
a4413 2
	    !(a->link_type == INPUT_ANCHOR
	      && a->input_field->type == F_HIDDEN_TYPE)) {
d4418 3
a4420 3
		 * This anchor is on a different line than the previous one.
		 * Remember which was the line number of the previous anchor,
		 * for use in screen positioning later.  - KW
d4427 1
a4427 1
	    if (!same_anchors(current.anc, a, ta_skip)) {
d4440 1
a4440 1
		if (same_anchor_as_link(curlink, a, ta_skip)) {
d4449 1
a4449 1
			   same_anchor_as_link(curlink, previous.anc, ta_skip)) {
a4480 1

d4482 3
a4484 3
	     * We know where to go; most of the stuff below is just
	     * tweaks to try to position the new screen in a specific
	     * way.
d4486 3
a4488 3
	     * In some cases going to a previous link can be done
	     * via the normal LYK_PREV_LINK action, which may give
	     * better positioning of the new screen.  - kw
d4491 1
a4491 1
		a->line_num >= HTMainText->top_of_screen - (display_lines)) {
d4501 1
a4501 1
		    return (LINK_DO_ARROWUP);
d4505 7
a4511 7
	     * The fundamental limitation of the current anchors_this_line
	     * counter method is that we only can set *linknum to the right
	     * index into the future links[] array if the line with our link
	     * ends up being the first line with any links (that count) on
	     * the new screen.  Subject to that restriction we still have
	     * some vertical liberty (sometimes), and try to make the best
	     * of it.  It may be a question of taste though.  - kw
d4517 2
a4518 3
		(HTMainText->top_of_screen - a->line_num + (display_lines) - 1)
		/ (display_lines);

d4525 1
a4525 1
		       HTMainText->top_of_screen + (display_lines)) {
d4527 1
a4527 2
		(a->line_num - HTMainText->top_of_screen) / (display_lines);

d4544 7
d4555 1
a4555 1
	    return (LINK_LINE_FOUND);
d4558 1
a4558 1
    return (NO);
d4562 18
a4579 16
 * This function finds the line indicated by line_num in the
 * HText structure indicated by text, and searches that line
 * for the first hit with the string indicated by target.  If
 * there is no hit, FALSE is returned.  If there is a hit, then
 * a copy of the line starting at that first hit is loaded into
 * *data with all IsSpecial characters stripped, its offset and
 * the printable target length (without IsSpecial, or extra CJK
 * or utf8 characters) are loaded into *offset and *tLen, and
 * TRUE is returned.  -FM
 */
BOOL HText_getFirstTargetInLine(HText *text, int line_num,
				BOOL utf_flag,
				int *offset,
				int *tLen,
				char **data,
				const char *target)
d4584 1
a4584 1
    const char *cp;
d4587 2
a4588 2
     * Make sure we have an HText structure, that line_num is
     * in its range, and that we have a target string.  -FM
d4590 3
a4592 6
    if (!(text &&
	  line_num >= 0 &&
	  line_num <= text->Lines &&
	  non_empty(target))) {
	return (FALSE);
    }
d4595 1
a4595 1
     * Find the line and set up its data and offset -FM
d4597 1
a4597 1
    for (i = 0, line = FirstHTLine(text);
d4601 1
a4601 1
	    return (FALSE);
d4605 3
a4607 3
	return (FALSE);
    LineData = (char *) line->data;
    LineOffset = (int) line->offset;
d4610 22
a4631 16
     * If the target is on the line, load the offset of
     * its first character and the subsequent line data,
     * strip any special characters from the loaded line
     * data, and return TRUE.  -FM
     */
    if (((cp = LYno_attr_mb_strstr(LineData,
				   target,
				   utf_flag, YES,
				   &HitOffset,
				   &LenNeeded)) != NULL) &&
	(LineOffset + LenNeeded) <= DISPLAY_COLS) {
	/*
	 * We had a hit so load the results,
	 * remove IsSpecial characters from
	 * the allocated data string, and
	 * return TRUE.  -FM
d4635 3
a4637 3
	StrAllocCopy(*data, cp);
	remove_special_attr_chars(*data);
	return (TRUE);
d4641 1
a4641 1
     * The line does not contain the target.  -FM
d4643 1
a4643 10
    return (FALSE);
}

/*
 * HText_getNumOfLines returns the number of lines in the
 * current document.
 */
int HText_getNumOfLines(void)
{
    return (HTMainText ? HTMainText->Lines : 0);
d4647 2
a4648 2
 * HText_getNumOfBytes returns the size of the document, as rendered.  This
 * may be different from the original filesize.
d4650 1
a4650 1
int HText_getNumOfBytes(void)
d4652 1
a4652 11
    int result = -1;
    HTLine *line = NULL;

    if (HTMainText != 0) {
	for (line = FirstHTLine(HTMainText);
	     line != HTMainText->last_line;
	     line = line->next) {
	    result += 1 + strlen(line->data);
	}
    }
    return result;
d4656 2
a4657 2
 * HText_getTitle returns the title of the
 * current document.
d4659 1
a4659 1
const char *HText_getTitle(void)
d4661 2
a4662 2
    return (HTMainText ?
	    HTAnchor_title(HTMainText->node_anchor) : 0);
d4665 2
a4666 2
#ifdef USE_COLOR_STYLE
const char *HText_getStyle(void)
d4668 2
a4669 2
    return (HTMainText ?
	    HTAnchor_style(HTMainText->node_anchor) : 0);
d4674 3
a4676 3
 * HText_getSugFname returns the suggested filename of the current
 * document (normally derived from a Content-Disposition header with
 * attachment; filename=name.suffix).  -FM
d4678 1
a4678 1
const char *HText_getSugFname(void)
d4680 2
a4681 2
    return (HTMainText ?
	    HTAnchor_SugFname(HTMainText->node_anchor) : 0);
d4685 6
a4690 6
 * HTCheckFnameForCompression receives the address of an allocated
 * string containing a filename, and an anchor pointer, and expands
 * or truncates the string's suffix if appropriate, based on whether
 * the anchor indicates that the file is compressed.  We assume
 * that the file was not uncompressed (as when downloading), and
 * believe the headers about whether it's compressed or not.  -FM
d4692 8
a4699 7
 * Added third arg - if strip_ok is FALSE, we don't trust the anchor
 * info enough to remove a compression suffix if the anchor object
 * does not indicate compression.  - kw
 */
void HTCheckFnameForCompression(char **fname,
				HTParentAnchor *anchor,
				BOOL strip_ok)
d4702 4
a4705 7
    char *dot = NULL;
    char *cp = NULL;
    const char *suffix = "";
    const char *ct = NULL;
    const char *ce = NULL;
    CompressFileType method = cftNone;
    CompressFileType second;
d4708 1
a4708 1
     * Make sure we have a string and anchor.  -FM
d4710 1
a4710 1
    if (!(fn && anchor))
d4714 1
a4714 1
     * Make sure we have a file, not directory, name.  -FM
d4716 6
a4721 2
    if (*(fn = LYPathLeaf(fn)) == '\0')
	return;
d4724 2
a4725 2
     * Check the anchor's content_type and content_encoding
     * elements for a gzip or Unix compressed file.  -FM
d4729 1
a4729 1
    if (ce == NULL && ct != 0) {
d4731 2
a4732 2
	 * No Content-Encoding, so check
	 * the Content-Type.  -FM
d4734 8
a4741 9
	if (!strncasecomp(ct, "application/gzip", 16) ||
	    !strncasecomp(ct, "application/x-gzip", 18)) {
	    method = cftGzip;
	} else if (!strncasecomp(ct, "application/compress", 20) ||
		   !strncasecomp(ct, "application/x-compress", 22)) {
	    method = cftCompress;
	} else if (!strncasecomp(ct, "application/bzip2", 17) ||
		   !strncasecomp(ct, "application/x-bzip2", 19)) {
	    method = cftBzip2;
d4743 12
a4754 2
    } else if (ce != 0) {
	method = HTEncodingToCompressType(ce);
d4758 3
a4760 9
     * If no Content-Encoding has been detected via the anchor
     * pointer, but strip_ok is not set, there is nothing left
     * to do.  - kw
     */
    if ((method == cftNone) && !strip_ok)
	return;

    /*
     * Treat .tgz specially
d4762 1
a4762 5
    if ((dot = strrchr(fn, '.')) != NULL
	&& !strcasecomp(dot, ".tgz")) {
	if (method == cftNone) {
	    strcpy(dot, ".tar");
	}
a4763 1
    }
d4766 2
a4767 2
     * Seek the last dot, and check whether
     * we have a gzip or compress suffix.  -FM
d4770 8
a4777 8
	int rootlen = 0;

	if (HTCompressFileType(fn, ".", &rootlen) != cftNone) {
	    if (method == cftNone) {
		/*
		 * It has a suffix which signifies a gzipped
		 * or compressed file for us, but the anchor
		 * claims otherwise, so tweak the suffix.  -FM
d4779 1
d4781 3
d4787 47
a4833 17
	if ((second = HTCompressFileType(fn, "-_", &rootlen)) != cftNone) {
	    cp = fn + rootlen;
	    if (method == cftNone) {
		/*
		 * It has a tail which signifies a gzipped
		 * file for us, but the anchor claims otherwise,
		 * so tweak the suffix.  -FM
		 */
		if (cp == dot + 1)
		    cp--;
		*cp = '\0';
	    } else {
		/*
		 * The anchor claims it's gzipped, and we
		 * believe it, so force this tail to the
		 * conventional suffix.  -FM
		 */
d4835 1
a4835 1
		*cp = '-';
d4837 1
a4837 1
		*cp = '.';
d4839 4
a4842 4
		if (second == cftCompress)
		    LYUpperCase(cp);
		else
		    LYLowerCase(cp);
a4843 1
	    return;
d4846 7
a4852 17

    switch (method) {
    case cftNone:
	suffix = "";
	break;
    case cftCompress:
	suffix = ".Z";
	break;
    case cftDeflate:
	suffix = ".zz";
	break;
    case cftGzip:
	suffix = ".gz";
	break;
    case cftBzip2:
	suffix = ".bz2";
	break;
d4856 11
a4866 9
     * Add the appropriate suffix.  -FM
     */
    if (*suffix) {
	if (!dot) {
	    StrAllocCat(*fname, suffix);
	} else if (*++dot == '\0') {
	    StrAllocCat(*fname, suffix + 1);
	} else {
	    StrAllocCat(*fname, suffix);
d4868 3
a4870 1
	    (*fname)[strlen(*fname) - strlen(suffix)] = '-';
d4872 1
a4872 12
	}
    }
}

/*
 * HText_getLastModified returns the Last-Modified header
 * if available, for the current document.  -FM
 */
const char *HText_getLastModified(void)
{
    return (HTMainText ?
	    HTAnchor_last_modified(HTMainText->node_anchor) : 0);
d4876 2
a4877 2
 * HText_getDate returns the Date header
 * if available, for the current document.  -FM
d4879 1
a4879 1
const char *HText_getDate(void)
d4881 2
a4882 2
    return (HTMainText ?
	    HTAnchor_date(HTMainText->node_anchor) : 0);
d4886 2
a4887 2
 * HText_getServer returns the Server header
 * if available, for the current document.  -FM
d4889 1
a4889 1
const char *HText_getServer(void)
d4891 2
a4892 2
    return (HTMainText ?
	    HTAnchor_server(HTMainText->node_anchor) : 0);
a4894 1
#ifdef EXP_HTTP_HEADERS
d4896 2
a4897 2
 * Returns the full text of HTTP headers, if available, for the current
 * document.
d4899 1
a4899 1
const char *HText_getHttpHeaders(void)
d4901 2
a4902 2
    return (HTMainText ?
	    HTAnchor_http_headers(HTMainText->node_anchor) : 0);
a4903 1
#endif
d4906 3
a4908 3
 * HText_pageDisplay displays a screen of text
 * starting from the line 'line_num'-1.
 * This is the primary call for lynx.
d4910 3
a4912 2
void HText_pageDisplay(int line_num,
		       char *target)
d4916 1
a4916 1
	CTRACE((tfp, "GridText: HText_pageDisplay at line %d started\n", line_num));
a4919 2
	int stop_before = -1;

d4921 9
a4929 11
	 * Garbage is reported from forms input fields in incremental mode.
	 * So we start HText_trimHightext() to forget this side effect.
	 * This function was split-out from HText_endAppend().
	 * It may not be the best solution but it works.  - LP
	 *
	 * (FALSE = indicate that we are in partial mode)
	 * Multiple calls of HText_trimHightext works without problem now.
	 */
	if (HTMainText && HTMainText->stbl)
	    stop_before = Stbl_getStartLineDeep(HTMainText->stbl);
	HText_trimHightext(HTMainText, FALSE, stop_before);
d4933 1
a4933 1
    display_page(HTMainText, line_num - 1, target);
d4937 1
a4937 1
	LYSleepMsg();
d4944 1
a4944 1
	CTRACE((tfp, "GridText: HText_pageDisplay finished\n"));
d4950 2
a4951 2
 * Return YES if we have a whereis search target on the displayed
 * page.  - kw
d4953 1
a4953 1
BOOL HText_pageHasPrevTarget(void)
d4962 2
a4963 2
 * HText_LinksInLines returns the number of links in the
 * 'Lines' number of lines beginning with 'line_num'-1.  -FM
d4965 4
a4968 2
int HText_LinksInLines(HText *text, int line_num,
		       int Lines)
d4979 2
a4980 2
	 Anchor_ptr != NULL && Anchor_ptr->line_num <= end;
	 Anchor_ptr = Anchor_ptr->next) {
d4984 2
a4985 2
	    !(Anchor_ptr->link_type == INPUT_ANCHOR
	      && Anchor_ptr->input_field->type == F_HIDDEN_TYPE))
d4987 2
d4994 2
a4995 1
void HText_setStale(HText *text)
d5000 2
a5001 1
void HText_refresh(HText *text)
d5007 2
a5008 1
int HText_sourceAnchors(HText *text)
d5013 2
a5014 1
BOOL HText_canScrollUp(HText *text)
d5016 1
a5016 1
    return (BOOL) (text->top_of_screen != 0);
d5019 1
a5019 1
BOOL HText_canScrollDown(void)
d5021 1
a5021 1
    HText *text = HTMainText;
d5023 2
a5024 2
    return (BOOL) ((text != 0)
		   && ((text->top_of_screen + display_lines) < text->Lines + 1));
d5029 2
a5030 1
void HText_scrollTop(HText *text)
d5035 2
a5036 1
void HText_scrollDown(HText *text)
d5041 2
a5042 1
void HText_scrollUp(HText *text)
d5047 2
a5048 1
void HText_scrollBottom(HText *text)
d5053 1
d5055 2
a5056 2
 *		==================
 */
d5060 18
a5077 1
BOOL HText_select(HText *text)
d5080 3
d5084 2
a5085 2
	 * Reset flag for whereis search string - cannot be true here
	 * since text is not our HTMainText.  - kw
d5092 2
a5093 10
	ResetPartialLinenos(text);
	ResetPartialLinenos(HTMainText);
#endif /* DISP_PARTIAL */

#ifdef CAN_SWITCH_DISPLAY_CHARSET
	/* text->UCLYhndl is not reset by META, so use a more circumvent way */
	if (text->node_anchor->UCStages->s[UCT_STAGE_HTEXT].LYhndl
	    != current_char_set)
	    Switch_Display_Charset(text->node_anchor->UCStages->s[UCT_STAGE_HTEXT].LYhndl, SWITCH_DISPLAY_CHARSET_MAYBE);
#endif
d5095 2
a5096 9
	    if (HText_hasUTF8OutputSet(HTMainText) &&
		HTLoadedDocumentEightbit() &&
		LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
		text->had_utf8 = HTMainText->has_utf8;
	    } else {
		text->had_utf8 = NO;
	    }
	    HTMainText->has_utf8 = NO;
	    text->has_utf8 = NO;
d5098 1
a5098 3

	HTMainText = text;
	HTMainAnchor = text->node_anchor;
d5101 1
a5101 1
	 * Make this text the most current in the loaded texts list.  -FM
d5105 1
a5105 1
	/* let lynx do it */
d5112 3
a5114 3
 * This function returns TRUE if doc's post_data, address
 * and isHEAD elements are identical to those of a loaded
 * (memory cached) text.  -FM
d5116 2
a5117 1
BOOL HText_POSTReplyLoaded(DocInfo *doc)
d5121 1
a5121 2
    bstring *post_data;
    char *address;
d5125 1
a5125 1
     * Make sure we have the structures.  -FM
d5128 1
a5128 1
	return (FALSE);
d5131 1
a5131 1
     * Make sure doc is for a POST reply.  -FM
d5135 1
a5135 1
	return (FALSE);
d5139 2
a5140 2
     * Loop through the loaded texts looking for a
     * POST reply match.  -FM
d5142 1
a5142 1
    while (NULL != (text = (HText *) HTList_nextObject(cur))) {
d5145 1
a5145 1
	    BINEQ(post_data, text->node_anchor->post_data) &&
d5149 1
a5149 1
	    return (TRUE);
d5153 1
a5153 1
    return (FALSE);
d5156 2
a5157 1
BOOL HTFindPoundSelector(const char *selector)
d5159 1
a5159 1
    TextAnchor *a;
d5161 1
a5161 1
    for (a = HTMainText->first_anchor; a != 0; a = a->next) {
d5163 1
a5163 1
	if (a->anchor && a->anchor->tag) {
d5166 1
a5166 1
		www_search_result = a->line_num + 1;
d5168 4
a5171 3
		CTRACE((tfp, "FindPound: Selecting anchor [%d] at line %d\n",
			a->number, www_search_result));
		if (!strcmp(selector, LYToolbarName)) {
d5173 2
a5174 2
		}
		return (YES);
a5175 1
	}
d5177 3
a5179 1
    return (NO);
d5182 3
a5184 1
BOOL HText_selectAnchor(HText *text, HTChildAnchor *anchor)
d5186 1
a5186 1
    TextAnchor *a;
d5195 2
a5196 3
    for (a = text->first_anchor; a; a = a->next) {
	if (a->anchor == anchor)
	    break;
d5199 1
a5199 1
	CTRACE((tfp, "HText: No such anchor in this text!\n"));
d5203 2
a5204 2
    if (text != HTMainText) {	/* Comment out by ??? */
	HTMainText = text;	/* Put back in by tbl 921208 */
d5206 1
a5206 2
    } {
	int l = a->line_num;
d5208 10
a5217 7
	CTRACE((tfp, "HText: Selecting anchor [%d] at line %d\n",
		a->number, l));

	if (!text->stale &&
	    (l >= text->top_of_screen) &&
	    (l < text->top_of_screen + display_lines + 1))
	    return YES;
d5219 1
a5219 1
	www_search_result = l - (display_lines / 3);	/* put in global variable */
d5225 1
d5227 5
a5231 5
 *		=================
 *
 *	These are called from the application.  There are many more functions
 *	not included here from the original text object.
 */
d5237 3
a5239 1
void HText_applyStyle(HText *me GCC_UNUSED, HTStyle *style GCC_UNUSED)
d5244 1
d5247 3
a5249 1
void HText_updateStyle(HText *me GCC_UNUSED, HTStyle *style GCC_UNUSED)
d5254 1
d5257 3
a5259 1
HTStyle *HText_selectionStyle(HText *me GCC_UNUSED, HTStyleSheet *sheet GCC_UNUSED)
d5264 1
d5267 4
a5270 2
void HText_replaceSel(HText *me GCC_UNUSED, const char *aString GCC_UNUSED,
		      HTStyle *aStyle GCC_UNUSED)
d5274 1
d5276 5
a5280 3
 *	(style recovery only)
 */
void HTextApplyToSimilar(HText *me GCC_UNUSED, HTStyle *style GCC_UNUSED)
d5285 1
d5287 5
a5291 3
 *	(style recovery only)
 */
void HTextSelectUnstyled(HText *me GCC_UNUSED, HTStyleSheet *sheet GCC_UNUSED)
d5296 1
d5299 2
a5300 1
void HText_unlinkSelection(HText *me GCC_UNUSED)
d5305 2
a5306 1
HTAnchor *HText_referenceSelected(HText *me GCC_UNUSED)
d5308 1
a5308 1
    return 0;
d5311 2
a5312 1
int HText_getTopOfScreen(void)
d5314 2
a5315 3
    HText *text = HTMainText;

    return text != 0 ? text->top_of_screen : 0;
d5318 2
a5319 1
int HText_getLines(HText *text)
d5321 1
a5321 1
    return text->Lines;
d5324 3
a5326 2
HTAnchor *HText_linkSelTo(HText *me GCC_UNUSED,
			  HTAnchor * anchor GCC_UNUSED)
d5332 1
a5332 1
 * Utility for freeing the list of previous isindex and whereis queries.  -FM
d5334 1
a5334 1
void HTSearchQueries_free(void)
d5336 10
a5345 1
    LYFreeStringList(search_queries);
d5347 1
d5351 2
a5352 2
 * Utility for listing isindex and whereis queries, making
 * any repeated queries the most current in the list.  -FM
d5354 2
a5355 1
void HTAddSearchQuery(char *query)
d5357 1
a5357 1
    char *new_query = NULL;
d5361 1
a5361 1
    if (!non_empty(query))
d5364 3
a5366 1
    StrAllocCopy(new_query, query);
d5373 1
a5373 1
	HTList_addObject(search_queries, new_query);
d5378 2
a5379 2
    while (NULL != (old = (char *) HTList_nextObject(cur))) {
	if (!strcmp(old, new_query)) {
d5385 1
a5385 1
    HTList_addObject(search_queries, new_query);
d5390 2
a5391 1
int do_www_search(DocInfo *doc)
d5394 1
a5394 2
    int ch;
    RecallType recall;
d5400 1
a5400 1
     * Load the default query buffer
d5402 1
a5402 1
    if ((cp = strchr(doc->address, '?')) != NULL) {
d5404 2
a5405 2
	 * This is an index from a previous search.
	 * Use its query as the default.
d5408 2
a5409 2
	LYstrncpy(searchstring, ++cp, sizeof(searchstring) - 1);
	for (cp = searchstring; *cp; cp++)
d5415 1
a5415 1
	 * Make sure it's treated as the most recent query.  -FM
d5420 1
a5420 1
	 * New search; no default.
d5427 1
a5427 1
     * Prompt for a query string.
d5438 1
a5438 1
	       (!PreviousSearch && QueryTotal >= 1)) ? RECALL_URL : NORECALL);
d5440 3
a5442 3
  get_query:
    if ((ch = LYgetstr(searchstring, VISIBLE,
		       sizeof(searchstring), recall)) < 0 ||
d5447 1
a5447 1
		 * Use the second to last query in the list.  -FM
d5453 1
a5453 1
		 * Go back to the previous query in the list.  -FM
d5459 1
a5459 1
		 * Roll around to the last query in the list.  -FM
d5462 3
a5464 3
	    if ((cp = (char *) HTList_objectAt(search_queries,
					       QueryNum)) != NULL) {
		LYstrncpy(searchstring, cp, sizeof(searchstring) - 1);
d5478 1
a5478 1
		 * Use the first query in the list.  -FM
d5484 1
a5484 1
		 * Advance to the next query in the list.  -FM
d5490 1
a5490 1
		 * Roll around to the first query in the list.  -FM
d5493 3
a5495 3
	    if ((cp = (char *) HTList_objectAt(search_queries,
					       QueryNum)) != NULL) {
		LYstrncpy(searchstring, cp, sizeof(searchstring) - 1);
d5509 1
a5509 1
	 * Search cancelled.
d5512 1
a5512 1
	return (NULLFILE);
d5516 1
a5516 1
     * Strip leaders and trailers.  -FM
d5521 1
a5521 1
	return (NULLFILE);
d5526 1
a5526 1
     * Don't resubmit the same query unintentionally.
d5530 1
a5530 1
	return (NULLFILE);
d5534 2
a5535 2
     * Add searchstring to the query list,
     * or make it the most current.  -FM
d5540 1
a5540 1
     * Show the URL with the new query.
d5542 1
a5542 1
    if ((cp = strchr(doc->address, '?')) != NULL)
d5548 1
d5550 3
a5552 2
    LYSyslog(tmpaddress);
#endif
d5558 1
a5558 1
     * OK, now we do the search.
d5562 2
a5563 2
	 * Memory leak fixed.
	 * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
a5565 1

d5567 1
a5567 1
	    cp_freeme = stub_HTAnchor_address((HTAnchor *) HTMainAnchor);
d5569 1
a5569 1
	    cp_freeme = HTAnchor_address((HTAnchor *) HTMainAnchor);
d5573 1
a5573 1
	CTRACE((tfp, "\ndo_www_search: newfile: %s\n", doc->address));
d5576 1
a5576 1
	 * Yah, the search succeeded.
d5578 1
a5578 1
	return (NORMAL);
d5582 5
a5586 5
     * Either the search failed (Yuk), or we got redirection.
     * If it's redirection, use_this_url_instead is set, and
     * mainloop() will deal with it such that security features
     * and restrictions are checked before acting on the URL, or
     * rejecting it.  -FM
d5588 1
a5588 59
    return (NOT_FOUND);
}

static void write_offset(FILE *fp, HTLine *line)
{
    int i;

    if (line->data[0]) {
	for (i = 0; i < (int) line->offset; i++) {
	    fputc(' ', fp);
	}
    }
}

static void write_hyphen(FILE *fp)
{
    if (dump_output_immediately &&
	LYRawMode &&
	LYlowest_eightbit[current_char_set] <= 173 &&
	(LYCharSet_UC[current_char_set].enc == UCT_ENC_8859 ||
	 (LYCharSet_UC[current_char_set].like8859 & UCT_R_8859SPECL)) != 0) {
	fputc(0xad, fp);	/* the iso8859 byte for SHY */
    } else {
	fputc('-', fp);
    }
}

/*
 * Returns the length after trimming trailing blanks.  Modify the string as
 * needed so that any special character which follows a trailing blank is moved
 * before the (trimmed) blank, so the result which will be dumped has no
 * trailing blanks.
 */
static int TrimmedLength(char *string)
{
    int result = strlen(string);
    int adjust = result;
    int ch;

    while (adjust > 0) {
	ch = UCH(string[adjust - 1]);
	if (isspace(ch) || IsSpecialAttrChar(ch)) {
	    --adjust;
	} else {
	    break;
	}
    }
    if (result != adjust) {
	char *dst = string + adjust;
	char *src = dst;

	for (;;) {
	    src = LYSkipBlanks(src);
	    if ((*dst++ = *src++) == '\0')
		break;
	}
	result = (dst - string - 1);
    }
    return result;
d5592 4
a5595 5
 * Print the contents of the file in HTMainText to
 * the file descriptor fp.
 * If is_email is TRUE add ">" before each "From " line.
 * If is_reply is TRUE add ">" to the beginning of each
 * line to specify the file is a reply to message.
d5597 3
a5599 3
void print_wwwfile_to_fd(FILE *fp,
			 BOOLEAN is_email,
			 BOOLEAN is_reply)
d5603 1
a5603 13
    int limit;
    HTLine *line;

#ifndef NO_DUMP_WITH_BACKSPACES
    HText *text = HTMainText;
    BOOL in_b = FALSE;
    BOOL in_u = FALSE;
    BOOL bs = (BOOL) (!is_email && !is_reply
		      && text != 0
		      && with_backspaces
		      && HTCJK == NOCJK
		      && !text->T.output_utf8);
#endif
d5608 1
a5608 1
    line = FirstHTLine(HTMainText);
d5610 17
a5626 17
	if (first) {
	    first = FALSE;
	    if (is_reply) {
		fputc('>', fp);
	    } else if (is_email && !strncmp(line->data, "From ", 5)) {
		fputc('>', fp);
	    }
	} else if (line->data[0] != LY_SOFT_NEWLINE) {
	    fputc('\n', fp);
	    /*
	     * Add news-style quotation if requested.  -FM
	     */
	    if (is_reply) {
		fputc('>', fp);
	    } else if (is_email && !strncmp(line->data, "From ", 5)) {
		fputc('>', fp);
	    }
d5629 18
a5646 25
	write_offset(fp, line);

	/*
	 * Add data.
	 */
	limit = TrimmedLength(line->data);
	for (i = 0; i < limit; i++) {
	    int ch = UCH(line->data[i]);

	    if (!IsSpecialAttrChar(ch)) {
#ifndef NO_DUMP_WITH_BACKSPACES
		if (in_b) {
		    fputc(ch, fp);
		    fputc('\b', fp);
		    fputc(ch, fp);
		} else if (in_u) {
		    fputc('_', fp);
		    fputc('\b', fp);
		    fputc(ch, fp);
		} else
#endif
		    fputc(ch, fp);
	    } else if (ch == LY_SOFT_HYPHEN &&
		       (i + 1) >= limit) {	/* last char on line */
		write_hyphen(fp);
d5648 8
a5655 28
		switch (ch) {
		case LY_UNDERLINE_START_CHAR:
		case LY_UNDERLINE_END_CHAR:
		    fputc('_', fp);
		    break;
		case LY_BOLD_START_CHAR:
		case LY_BOLD_END_CHAR:
		    break;
		}
	    }
#ifndef NO_DUMP_WITH_BACKSPACES
	    else if (bs) {
		switch (ch) {
		case LY_UNDERLINE_START_CHAR:
		    if (!in_b)
			in_u = TRUE;	/*favor bold over underline */
		    break;
		case LY_UNDERLINE_END_CHAR:
		    in_u = FALSE;
		    break;
		case LY_BOLD_START_CHAR:
		    if (in_u)
			in_u = FALSE;	/* turn it off */
		    in_b = TRUE;
		    break;
		case LY_BOLD_END_CHAR:
		    in_b = FALSE;
		    break;
a5657 1
#endif
d5668 1
a5668 1
    fputc('\n', fp);
d5673 3
a5675 3
 * Print the contents of the file in HTMainText to
 * the file descriptor fp.
 * First output line is "thelink", ie, the URL for this file.
d5677 4
a5680 2
void print_crawl_to_fd(FILE *fp, char *thelink,
		       char *thetitle)
d5684 1
a5684 2
    int limit;
    HTLine *line;
d5689 1
a5689 1
    line = FirstHTLine(HTMainText);
d5696 3
a5698 2
	if (!first && line->data[0] != LY_SOFT_NEWLINE)
	    fputc('\n', fp);
d5700 6
a5705 1
	write_offset(fp, line);
d5708 1
a5708 1
	 * Add data.
d5710 16
a5725 10
	limit = TrimmedLength(line->data);
	for (i = 0; limit; i++) {
	    int ch = UCH(line->data[i]);

	    if (!IsSpecialAttrChar(ch)) {
		fputc(ch, fp);
	    } else if (ch == LY_SOFT_HYPHEN &&
		       (i + 1) >= limit) {	/* last char on line */
		write_hyphen(fp);
	    }
d5732 1
a5732 1
    fputc('\n', fp);
d5735 1
a5735 1
     * Add the References list if appropriate
d5737 4
a5740 3
    if ((no_list == FALSE) &&
	links_are_numbered()) {
	printlist(fp, FALSE);
d5742 1
d5748 4
a5751 2
static void adjust_search_result(DocInfo *doc, int tentative_result,
				 int start_line)
d5755 1
a5755 1
	TextAnchor *a;
d5759 2
a5760 4
	BOOL on_screen = (BOOL) (tentative_result > HTMainText->top_of_screen &&
				 tentative_result <= HTMainText->top_of_screen +
				 display_lines);

a5768 1

d5785 1
a5785 1
	     a && a->line_num <= tentative_result - 1; a = a->next) {
d5794 1
a5794 1
	     tentative_result <= HTMainText->top_of_screen)) {
d5796 3
a5798 2
	} else if (tentative_result - start_line > 0 &&
		   tentative_result - (start_line + 1) <= max_offset) {
d5800 4
a5803 3
	} else if (tentative_result > HTMainText->top_of_screen &&
		   tentative_result <= start_line &&	/* have wrapped */
		   tentative_result <= HTMainText->top_of_screen + goal) {
d5805 2
a5806 1
	} else if (tentative_result <= goal)
d5819 27
a5845 182
static BOOL anchor_has_target(TextAnchor *a, char *target)
{
    OptionType *option;
    char *stars = NULL, *sp;
    const char *cp;
    int count;

    /*
     * Search the hightext strings, taking the case_sensitive setting into
     * account.  -FM
     */
    for (count = 0;; ++count) {
	if ((cp = LYGetHiTextStr(a, count)) == NULL)
	    break;
	if (LYno_attr_strstr(cp, target))
	    return TRUE;
    }

    /*
     * Search the relevant form fields, taking the
     * case_sensitive setting into account.  -FM
     */
    if ((a->input_field != NULL && a->input_field->value != NULL) &&
	a->input_field->type != F_HIDDEN_TYPE) {
	if (a->input_field->type == F_PASSWORD_TYPE) {
	    /*
	     * Check the actual, hidden password, and then
	     * the displayed string.  -FM
	     */
	    if (LYno_attr_strstr(a->input_field->value, target)) {
		return TRUE;
	    }
	    StrAllocCopy(stars, a->input_field->value);
	    for (sp = stars; *sp != '\0'; sp++)
		*sp = '*';
	    if (LYno_attr_strstr(stars, target)) {
		FREE(stars);
		return TRUE;
	    }
	    FREE(stars);
	} else if (a->input_field->type == F_OPTION_LIST_TYPE) {
	    /*
	     * Search the option strings that are displayed
	     * when the popup is invoked.  -FM
	     */
	    option = a->input_field->select_list;
	    while (option != NULL) {
		if (LYno_attr_strstr(option->name, target)) {
		    return TRUE;
		}
		option = option->next;
	    }
	} else if (a->input_field->type == F_RADIO_TYPE) {
	    /*
	     * Search for checked or unchecked parens.  -FM
	     */
	    if (a->input_field->num_value) {
		cp = checked_radio;
	    } else {
		cp = unchecked_radio;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else if (a->input_field->type == F_CHECKBOX_TYPE) {
	    /*
	     * Search for checked or unchecked square brackets.  -FM
	     */
	    if (a->input_field->num_value) {
		cp = checked_box;
	    } else {
		cp = unchecked_box;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else {
	    /*
	     * Check the values intended for display.  May have been found
	     * already via the hightext search, but make sure here that the
	     * entire value is searched.  -FM
	     */
	    if (LYno_attr_strstr(a->input_field->value, target)) {
		return TRUE;
	    }
	}
    }
    return FALSE;
}

static TextAnchor *line_num_to_anchor(int line_num)
{
    TextAnchor *a;

    if (HTMainText != 0) {
	a = HTMainText->first_anchor;
	while (a != 0 && a->line_num < line_num) {
	    a = a->next;
	}
    } else {
	a = 0;
    }
    return a;
}

static int line_num_in_text(HText *text, HTLine *line)
{
    int result = 1;
    HTLine *temp = FirstHTLine(text);

    while (temp != line) {
	temp = temp->next;
	++result;
    }
    return result;
}

/* Computes the 'prev' pointers on demand, and returns the one for the given
 * anchor.
 */
static TextAnchor *get_prev_anchor(TextAnchor *a)
{
    TextAnchor *p, *q;

    if (a->prev == 0) {
	if ((p = HTMainText->first_anchor) != 0) {
	    while ((q = p->next) != 0) {
		q->prev = p;
		p = q;
	    }
	}
    }
    return a->prev;
}

static int www_search_forward(int start_line,
			      DocInfo *doc,
			      char *target,
			      HTLine *line,
			      int count)
{
    int wrapped = 0;
    TextAnchor *a = line_num_to_anchor(count - 1);
    int tentative_result = -1;

    for (;;) {
	while ((a != NULL) && a->line_num == (count - 1)) {
	    if (a->show_anchor &&
		!(a->link_type == INPUT_ANCHOR
		  && a->input_field->type == F_HIDDEN_TYPE)) {
		if (anchor_has_target(a, target)) {
		    adjust_search_result(doc, count, start_line);
		    return 1;
		}
	    }
	    a = a->next;
	}

	if (LYno_attr_strstr(line->data, target)) {
	    tentative_result = count;
	    break;
	} else if ((count == start_line && wrapped) || wrapped > 1) {
	    HTUserMsg2(STRING_NOT_FOUND, target);
	    return -1;
	} else if (line == HTMainText->last_line) {
	    count = 0;
	    wrapped++;
	}
	line = line->next;
	count++;
    }
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
    }
    return 0;
}

static int www_search_backward(int start_line,
			       DocInfo *doc,
			       char *target,
			       HTLine *line,
			       int count)
d5847 2
a5848 3
    int wrapped = 0;
    TextAnchor *a = line_num_to_anchor(count - 1);
    int tentative_result = -1;
d5851 1
a5851 1
	while ((a != NULL) && a->line_num == (count - 1)) {
d5853 14
a5866 4
		!(a->link_type == INPUT_ANCHOR
		  && a->input_field->type == F_HIDDEN_TYPE)) {
		if (anchor_has_target(a, target)) {
		    adjust_search_result(doc, count, start_line);
d5869 104
d5974 4
a5977 1
	    a = get_prev_anchor(a);
d5980 10
a5989 2
	if (LYno_attr_strstr(line->data, target)) {
	    tentative_result = count;
d5991 1
a5991 1
	} else if ((count == start_line && wrapped) || wrapped > 1) {
d5993 4
a5996 4
	    return -1;
	} else if (line == FirstHTLine(HTMainText)) {
	    count = line_num_in_text(HTMainText, LastHTLine(HTMainText)) + 1;
	    wrapped++;
a5997 5
	line = line->prev;
	count--;
    }
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
d5999 1
d6003 4
a6006 4
void www_user_search(int start_line,
		     DocInfo *doc,
		     char *target,
		     int direction)
d6008 1
a6008 1
    HTLine *line;
d6010 2
d6018 1
a6018 1
     * Advance to the start line.
d6020 6
a6025 10
    line = FirstHTLine(HTMainText);
    if (start_line + direction > 0) {
	for (count = 1;
	     count < start_line + direction;
	     line = line->next, count++) {
	    if (line == HTMainText->last_line) {
		line = FirstHTLine(HTMainText);
		count = 1;
		break;
	    }
d6027 8
a6034 3
    } else {
	line = HTMainText->last_line;
	count = line_num_in_text(HTMainText, line);
d6037 18
a6054 4
    if (direction >= 0)
	www_search_forward(start_line, doc, target, line, count);
    else
	www_search_backward(start_line, doc, target, line, count);
d6057 3
a6059 2
void user_message(const char *message,
		  const char *argument)
d6068 1
a6068 1
    HTSprintf0(&temp, message, NonNull(argument));
d6077 2
a6078 2
 * HText_getOwner returns the owner of the
 * current document.
d6080 1
a6080 1
const char *HText_getOwner(void)
d6082 2
a6083 2
    return (HTMainText ?
	    HTAnchor_owner(HTMainText->node_anchor) : 0);
d6087 2
a6088 2
 * HText_setMainTextOwner sets the owner for the
 * current document.
d6090 2
a6091 1
void HText_setMainTextOwner(const char *owner)
d6100 3
a6102 3
 * HText_getRevTitle returns the RevTitle element of the
 * current document, used as the subject for mailto comments
 * to the owner.
d6104 1
a6104 1
const char *HText_getRevTitle(void)
d6106 2
a6107 2
    return (HTMainText ?
	    HTAnchor_RevTitle(HTMainText->node_anchor) : 0);
d6111 2
a6112 2
 * HText_getContentBase returns the Content-Base header
 * of the current document.
d6114 1
a6114 1
const char *HText_getContentBase(void)
d6116 2
a6117 2
    return (HTMainText ?
	    HTAnchor_content_base(HTMainText->node_anchor) : 0);
d6121 2
a6122 2
 * HText_getContentLocation returns the Content-Location header
 * of the current document.
d6124 1
a6124 1
const char *HText_getContentLocation(void)
d6126 2
a6127 2
    return (HTMainText ?
	    HTAnchor_content_location(HTMainText->node_anchor) : 0);
d6131 2
a6132 2
 * HText_getMessageID returns the Message-ID of the
 * current document.
d6134 1
a6134 1
const char *HText_getMessageID(void)
d6136 2
a6137 2
    return (HTMainText ?
	    HTAnchor_messageID(HTMainText->node_anchor) : NULL);
d6140 1
a6140 1
void HTuncache_current_document(void)
d6143 1
a6143 1
     * Should remove current document from memory.
d6146 8
a6153 1
	HTParentAnchor *htmain_anchor = HTMainText->node_anchor;
d6160 7
a6166 8
	CTRACE((tfp, "\nHTuncache.. freeing document for '%s'%s\n",
		((htmain_anchor &&
		  htmain_anchor->address) ?
		 htmain_anchor->address : "unknown anchor"),
		((htmain_anchor &&
		  htmain_anchor->post_data)
		 ? " with POST data"
		 : "")));
d6171 1
a6171 29
	CTRACE((tfp, "HTuncache.. HTMainText already is NULL!\n"));
    }
}

#ifdef USE_SOURCE_CACHE

static HTProtocol scm =
{"source-cache-mem", 0, 0};	/* dummy - kw */

static BOOLEAN useSourceCache(void)
{
    BOOLEAN result = FALSE;

    if (LYCacheSource == SOURCE_CACHE_FILE) {
	result = (HTMainAnchor->source_cache_file != 0);
	CTRACE((tfp, "SourceCache: file-cache%s found\n",
		result ? "" : " not"));
    }
    return result;
}

static BOOLEAN useMemoryCache(void)
{
    BOOLEAN result = FALSE;

    if (LYCacheSource == SOURCE_CACHE_MEMORY) {
	result = (HTMainAnchor->source_cache_chunk != 0);
	CTRACE((tfp, "SourceCache: memory-cache%s found\n",
		result ? "" : " not"));
a6172 1
    return result;
d6175 2
a6176 1
BOOLEAN HTreparse_document(void)
d6180 5
a6184 2
    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE) {
	CTRACE((tfp, "HTreparse_document returns FALSE\n"));
a6185 1
    }
d6187 2
a6188 2
    if (useSourceCache()) {
	FILE *fp;
d6192 2
a6193 10
	CTRACE((tfp, "SourceCache: Reparsing file %s\n",
		HTMainAnchor->source_cache_file));

	/*
	 * This magic FREE(anchor->UCStages) call
	 * stolen from HTuncache_current_document() above.
	 */
	if (!(HTOutputFormat && HTOutputFormat == WWW_SOURCE)) {
	    FREE(HTMainAnchor->UCStages);
	}
d6199 2
a6200 2
	if (HTMainAnchor->content_type) {
	    format = HTAtom_for(HTMainAnchor->content_type);
d6202 3
a6204 3
	    format = HTFileFormat(HTMainAnchor->source_cache_file, NULL, NULL);
	    format = HTCharsetFormat(format, HTMainAnchor,
				     UCLYhndl_for_unspec);
d6209 8
a6216 1
	CTRACE((tfp, "  Content type is \"%s\"\n", format->name));
d6218 1
a6218 1
	fp = fopen(HTMainAnchor->source_cache_file, "r");
d6220 2
a6221 3
	    CTRACE((tfp, "  Cannot read file %s\n", HTMainAnchor->source_cache_file));
	    LYRemoveTemp(HTMainAnchor->source_cache_file);
	    FREE(HTMainAnchor->source_cache_file);
d6224 5
a6228 2

	if (HText_HaveUserChangedForms(HTMainText)) {
d6234 6
a6239 12
	/* Set HTMainAnchor->protocol or HTMainAnchor->physical to convince
	 * the SourceCacheWriter to not regenerate the cache file (which
	 * would be an unnecessary "loop"). - kw
	 */
	HTAnchor_setProtocol(HTMainAnchor, &HTFile);
	ret = HTParseFile(format, HTOutputFormat, HTMainAnchor, fp, NULL);
	LYCloseInput(fp);
	if (ret == HT_PARTIAL_CONTENT) {
	    HTInfoMsg(gettext("Loading incomplete."));
	    CTRACE((tfp,
		    "SourceCache: `%s' has been accessed, partial content.\n",
		    HTLoadedDocumentURL()));
a6240 3
	ok = (BOOL) (ret == HT_LOADED || ret == HT_PARTIAL_CONTENT);

	CTRACE((tfp, "Reparse file %s\n", (ok ? "succeeded" : "failed")));
d6243 2
a6244 1
    if (useMemoryCache()) {
d6248 2
a6249 2
	CTRACE((tfp, "SourceCache: Reparsing from memory chunk %p\n",
		(void *) HTMainAnchor->source_cache_chunk));
d6252 6
a6257 2
	 * This magic FREE(anchor->UCStages) call
	 * stolen from HTuncache_current_document() above.
d6259 3
a6261 3
	if (!(HTOutputFormat && HTOutputFormat == WWW_SOURCE)) {
	    FREE(HTMainAnchor->UCStages);
	}
d6263 6
a6268 15
	if (HTMainAnchor->content_type) {
	    format = HTAtom_for(HTMainAnchor->content_type);
	} else {
	    /*
	     * This is only done to make things aligned with SOURCE_CACHE_NONE and
	     * SOURCE_CACHE_FILE when switching to source mode since the original
	     * document's charset will be LYPushAssumed() and then LYPopAssumed().
	     * See LYK_SOURCE in mainloop if you change something here.  No
	     * user-visible benefits, seems just '=' Info Page will show source's
	     * effective charset as "(assumed)".
	     */
	    format = HTCharsetFormat(format, HTMainAnchor,
				     UCLYhndl_for_unspec);
	}
	/* not UCLYhndl_HTFile_for_unspec - we are talking about remote documents... */
d6270 5
a6274 1
	if (HText_HaveUserChangedForms(HTMainText)) {
d6280 8
a6287 9
	/* Set HTMainAnchor->protocol or HTMainAnchor->physical to convince
	 * the SourceCacheWriter to not regenerate the cache chunk (which
	 * would be an unnecessary "loop"). - kw
	 */
	HTAnchor_setProtocol(HTMainAnchor, &scm);	/* cheating -
							   anything != &HTTP or &HTTPS would do - kw */
	ret = HTParseMem(format, HTOutputFormat, HTMainAnchor,
			 HTMainAnchor->source_cache_chunk, NULL);
	ok = (BOOL) (ret == HT_LOADED);
d6289 4
a6292 1
	CTRACE((tfp, "Reparse memory %s\n", (ok ? "succeeded" : "failed")));
d6298 1
a6298 1
BOOLEAN HTcan_reparse_document(void)
d6300 17
a6316 1
    BOOLEAN result = FALSE;
d6318 3
a6320 6
    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE) {
	result = FALSE;
    } else if (useSourceCache()) {
	result = LYCanReadFile(HTMainAnchor->source_cache_file);
    } else if (useMemoryCache()) {
	result = TRUE;
d6323 1
a6323 2
    CTRACE((tfp, "HTcan_reparse_document -> %d\n", result));
    return result;
d6326 4
a6329 3
static void trace_setting_change(const char *name,
				 int prev_setting,
				 int new_setting)
d6332 2
a6333 3
	CTRACE((tfp,
		"HTdocument_settings_changed: %s setting has changed (was %d, now %d)\n",
		name, prev_setting, new_setting));
d6336 1
a6336 1
BOOLEAN HTdocument_settings_changed(void)
d6342 5
a6346 1
    if (!HTMainText || !HTcan_reparse_document())
a6357 3
	trace_setting_change("VERBOSE_IMG",
			     HTMainText->verbose_img,
			     verbose_img);
d6368 4
a6371 9
	trace_setting_change("KEYPAD_MODE",
			     HTMainText->keypad_mode, keypad_mode);
	if (HTMainText->disp_lines != LYlines || HTMainText->disp_cols != DISPLAY_COLS)
	    CTRACE((tfp,
		    "HTdocument_settings_changed: Screen size has changed (was %dx%d, now %dx%d)\n",
		    HTMainText->disp_cols,
		    HTMainText->disp_lines,
		    DISPLAY_COLS,
		    LYlines));
a6375 1
	    HTMainText->verbose_img != verbose_img ||
d6378 1
a6378 2
	    (HTMainText->minimal_comments != minimal_comments &&
	     !historical_comments) ||
d6381 2
a6382 2
	    HTMainText->keypad_mode != keypad_mode ||
	    HTMainText->disp_cols != DISPLAY_COLS);
d6386 1
a6386 1
int HTisDocumentSource(void)
d6391 1
a6391 1
const char *HTLoadedDocumentURL(void)
d6397 1
a6397 1
	return (HTMainText->node_anchor->address);
d6402 1
a6402 1
bstring *HTLoadedDocumentPost_data(void)
d6404 5
a6408 4
    if (HTMainText
	&& HTMainText->node_anchor
	&& HTMainText->node_anchor->post_data)
	return (HTMainText->node_anchor->post_data);
d6410 1
a6410 1
	return (0);
d6413 1
a6413 1
const char *HTLoadedDocumentTitle(void)
d6419 1
a6419 1
	return (HTMainText->node_anchor->title);
d6424 1
a6424 1
BOOLEAN HTLoadedDocumentIsHEAD(void)
d6430 1
a6430 1
	return (HTMainText->node_anchor->isHEAD);
d6435 1
a6435 1
BOOLEAN HTLoadedDocumentIsSafe(void)
d6441 1
a6441 1
	return (HTMainText->node_anchor->safe);
d6446 1
a6446 1
const char *HTLoadedDocumentCharset(void)
d6452 1
a6452 1
	return (HTMainText->node_anchor->charset);
d6457 1
a6457 1
BOOL HTLoadedDocumentEightbit(void)
d6465 2
a6466 1
void HText_setNodeAnchorBookmark(const char *bookmark)
d6475 1
a6475 1
const char *HTLoadedDocumentBookmark(void)
d6481 1
a6481 1
	return (HTMainText->node_anchor->bookmark);
d6486 3
a6488 1
int HText_LastLineSize(HText *text, BOOL IgnoreSpaces)
d6495 3
a6497 8
BOOL HText_LastLineEmpty(HText *text, BOOL IgnoreSpaces)
{
    if (!text || !text->last_line || !text->last_line->size)
	return TRUE;
    return HText_TrueEmptyLine(text->last_line, text, IgnoreSpaces);
}

int HText_LastLineOffset(HText *text)
d6499 1
a6499 8
    if (!text || !text->last_line)
	return 0;
    return text->last_line->offset;
}

int HText_PreviousLineSize(HText *text, BOOL IgnoreSpaces)
{
    HTLine *line;
d6508 4
a6511 15
BOOL HText_PreviousLineEmpty(HText *text, BOOL IgnoreSpaces)
{
    HTLine *line;

    if (!text || !text->last_line)
	return TRUE;
    if (!(line = text->last_line->prev))
	return TRUE;
    return HText_TrueEmptyLine(line, text, IgnoreSpaces);
}

/*
 * Compute the "true" line size.
 */
static int HText_TrueLineSize(HTLine *line, HText *text, BOOL IgnoreSpaces)
d6521 7
a6527 5
	    if (!IsSpecialAttrChar(UCH(line->data[i])) &&
		IS_UTF8_EXTRA(line->data[i]) &&
		!isspace(UCH(line->data[i])) &&
		UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
		UCH(line->data[i]) != HT_EN_SPACE) {
d6534 3
a6536 1
		IS_UTF8_EXTRA(line->data[i])) {
d6544 2
a6545 34
/*
 * Tell if the line is really empty.  This is invoked much more often than
 * HText_TrueLineSize(), and most lines are not empty.  So it is faster to
 * do this check than to check if the line size happens to be zero.
 */
static BOOL HText_TrueEmptyLine(HTLine *line, HText *text, BOOL IgnoreSpaces)
{
    size_t i;

    if (!(line && line->size))
	return TRUE;

    if (IgnoreSpaces) {
	for (i = 0; i < line->size; i++) {
	    if (!IsSpecialAttrChar(UCH(line->data[i])) &&
		IS_UTF8_EXTRA(line->data[i]) &&
		!isspace(UCH(line->data[i])) &&
		UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
		UCH(line->data[i]) != HT_EN_SPACE) {
		return FALSE;
	    }
	}
    } else {
	for (i = 0; i < line->size; i++) {
	    if (!IsSpecialAttrChar(line->data[i]) &&
		IS_UTF8_EXTRA(line->data[i])) {
		return FALSE;
	    }
	}
    }
    return TRUE;
}

void HText_NegateLineOne(HText *text)
d6553 2
a6554 1
BOOL HText_inLineOne(HText *text)
d6563 8
a6570 8
 * This function is for removing the first of two
 * successive blank lines.  It should be called after
 * checking the situation with HText_LastLineSize()
 * and HText_PreviousLineSize().  Any characters in
 * the removed line (i.e., control characters, or it
 * wouldn't have tested blank) should have been
 * reiterated by split_line() in the retained blank
 * line.  -FM
d6572 2
a6573 1
void HText_RemovePreviousLine(HText *text)
d6576 1
d6582 1
d6586 2
d6589 1
a6589 1
    freeHTLine(text, line);
d6593 1
a6593 1
 * NOTE:  This function presently is correct only if the
d6597 1
a6597 1
 *	  and split_line() is called. -FM
d6599 2
a6600 1
int HText_getCurrentColumn(HText *text)
d6607 3
a6609 3
		  (int) text->style->indent1st : (int) text->style->leftIndent)
	    + HText_LastLineSize(text, IgnoreSpaces)
	    + (int) text->last_line->offset;
d6614 2
a6615 1
int HText_getMaximumColumn(HText *text)
d6617 1
a6617 2
    int column = DISPLAY_COLS;

d6619 2
a6620 1
	column -= (int) text->style->rightIndent;
d6626 1
a6626 1
 * NOTE:  This function uses HText_getCurrentColumn() which
d6628 1
a6628 1
 *	  HT_LEFT. -FM
d6630 3
a6632 1
void HText_setTabID(HText *text, const char *name)
d6634 3
a6636 3
    HTTabID *Tab = NULL;
    HTList *cur = text->tabs;
    HTList *last = NULL;
d6638 1
a6638 1
    if (!text || isEmpty(name))
d6644 1
a6644 1
	while (NULL != (Tab = (HTTabID *) HTList_nextObject(cur))) {
d6646 1
a6646 1
		return;		/* Already set.  Keep the first value. */
d6652 2
a6653 2
    if (!Tab) {			/* New name.  Create a new node */
	Tab = typecalloc(HTTabID);
d6663 3
a6665 1
int HText_getTabIDColumn(HText *text, const char *name)
d6668 2
a6669 2
    HTTabID *Tab;
    HTList *cur = text->tabs;
d6671 2
a6672 2
    if (text && non_empty(name) && cur) {
	while (NULL != (Tab = (HTTabID *) HTList_nextObject(cur))) {
d6683 13
a6695 11
 * This function is for saving the address of a link
 * which had an attribute in the markup that resolved
 * to a URL (i.e., not just a NAME or ID attribute),
 * but was found in HText_endAnchor() to have no visible
 * content for use as a link name.  It loads the address
 * into text->hidden_links, whose count can be determined
 * via HText_HiddenLinks(), below.  The addresses can be
 * retrieved via HText_HiddenLinkAt(), below, based on
 * count.  -FM
 */
static void HText_AddHiddenLink(HText *text, TextAnchor *textanchor)
d6700 1
a6700 1
     * Make sure we have an HText structure and anchor.  -FM
d6706 2
a6707 2
     * Create the hidden links list
     * if it hasn't been already.  -FM
d6713 3
a6715 3
     * Store the address, in reverse list order
     * so that first in will be first out on
     * retrievals.  -FM
d6717 1
a6717 1
    if ((dest = HTAnchor_followLink(textanchor->anchor)) &&
d6719 2
a6720 6
	 HTList_isEmpty(text->hidden_links))) {
	char *cp_freeme = NULL;

	HTList_appendObject(text->hidden_links, cp_freeme = HTAnchor_address(dest));
	FREE(cp_freeme);
    }
d6726 2
a6727 2
 * This function returns the number of addresses
 * that are loaded in text->hidden_links.  -FM
d6729 2
a6730 1
int HText_HiddenLinkCount(HText *text)
d6735 1
a6735 1
	count = HTList_count((HTList *) text->hidden_links);
d6737 1
a6737 1
    return (count);
d6741 3
a6743 3
 * This function returns the address, corresponding to
 * a hidden link, at the position (zero-based) in the
 * text->hidden_links list of the number argument.  -FM
d6745 3
a6747 1
const char *HText_HiddenLinkAt(HText *text, int number)
d6752 1
a6752 1
	href = (char *) HTList_objectAt((HTList *) text->hidden_links, number);
d6754 1
a6754 1
    return (href);
d6757 1
d6759 3
a6761 3
 * Form methods
 * These routines are used to build forms consisting
 * of input fields
d6763 7
a6769 7
static int HTFormMethod;
static char *HTFormAction = NULL;
static char *HTFormEnctype = NULL;
static char *HTFormTitle = NULL;
static char *HTFormAcceptCharset = NULL;
static BOOLEAN HTFormDisabled = FALSE;
static PerFormInfo *HTCurrentForm;
d6771 6
a6776 5
void HText_beginForm(char *action,
		     char *method,
		     char *enctype,
		     char *title,
		     const char *accept_cs)
d6778 1
a6778 2
    PerFormInfo *newform;

d6785 1
a6785 1
     * Check the ACTION.  -FM
d6788 1
a6788 1
	if (isMAILTO_URL(action)) {
d6792 2
a6793 1
    } else
d6797 1
a6797 1
     * Check the METHOD.  -FM
d6800 1
a6800 1
	if (!strcasecomp(method, "post") || !strcasecomp(method, "pget"))
d6804 1
a6804 1
     * Check the ENCTYPE.  -FM
d6806 1
a6806 1
    if (non_empty(enctype)) {
d6816 1
a6816 1
     * Check the TITLE.  -FM
d6818 1
a6818 1
    if (non_empty(title))
d6824 2
a6825 2
     * Check for an ACCEPT_CHARSET.  If present, store it and
     * convert to lowercase and collapse spaces.  - kw
d6834 7
a6840 7
     * Create a new "PerFormInfo" structure to hold info on the current
     * form.  The HTForm* variables could all migrate there, currently
     * this isn't done (yet?) but it might be less confusing.
     * Currently the only data saved in this structure that will actually
     * be used is the accept_cs string.
     * This will be appended to the forms list kept by the HText object
     * if and when we reach a HText_endForm.  - kw
d6842 1
a6842 1
    newform = typecalloc(PerFormInfo);
d6844 1
a6844 1
	outofmem(__FILE__, "HText_beginForm");
d6847 1
a6847 1
    PerFormInfo_free(HTCurrentForm);	/* shouldn't happen here - kw */
d6850 8
a6857 8
    CTRACE((tfp, "BeginForm: action:%s Method:%d%s%s%s%s%s%s\n",
	    HTFormAction, HTFormMethod,
	    (HTFormTitle ? " Title:" : ""),
	    NonNull(HTFormTitle),
	    (HTFormEnctype ? " Enctype:" : ""),
	    NonNull(HTFormEnctype),
	    (HTFormAcceptCharset ? " Accept-charset:" : ""),
	    NonNull(HTFormAcceptCharset)));
d6860 2
a6861 1
void HText_endForm(HText *text)
d6865 2
a6866 2
	 * Support submission of a single text input field in
	 * the form via <return> instead of a submit button.  -FM
d6868 1
a6868 2
	TextAnchor *a;

d6870 1
a6870 1
	 * Go through list of anchors and get our input field.  -FM
d6872 1
a6872 1
	for (a = text->first_anchor; a != NULL; a = a->next) {
d6877 1
a6877 1
		 * Got it.  Make it submitting.  -FM
d6892 3
d6898 6
a6903 6
     * Append info on the current form to the HText object's list of
     * forms.
     * HText_beginInput call will have set some of the data in the
     * PerFormInfo structure (if there were any form fields at all),
     * we also fill in the ACCEPT-CHARSET data now (this could have
     * been done earlier).  - kw
d6915 1
a6915 1
	CTRACE((tfp, "endForm:    HTCurrentForm is missing!\n"));
d6929 22
a6950 21
void HText_beginSelect(char *name,
		       int name_cs,
		       BOOLEAN multiple,
		       char *size)
{
    /*
     * Save the group name.
     */
    StrAllocCopy(HTCurSelectGroup, name);
    HTCurSelectGroupCharset = name_cs;

    /*
     * If multiple then all options are actually checkboxes.
     */
    if (multiple)
	HTCurSelectGroupType = F_CHECKBOX_TYPE;
    /*
     * If not multiple then all options are radio buttons.
     */
    else
	HTCurSelectGroupType = F_RADIO_TYPE;
d6953 1
a6953 1
     * Length of an option list.
d6957 10
a6966 10
    CTRACE((tfp, "HText_beginSelect: name=%s type=%d size=%s\n",
	    ((HTCurSelectGroup == NULL) ?
	     "<NULL>" : HTCurSelectGroup),
	    HTCurSelectGroupType,
	    ((HTCurSelectGroupSize == NULL) ?
	     "<NULL>" : HTCurSelectGroupSize)));
    CTRACE((tfp, "HText_beginSelect: name_cs=%d \"%s\"\n",
	    HTCurSelectGroupCharset,
	    (HTCurSelectGroupCharset >= 0 ?
	     LYCharSet_UC[HTCurSelectGroupCharset].MIMEname : "<UNKNOWN>")));
d6970 6
a6975 5
 *  This function returns the number of the option whose
 *  value currently is being accumulated for a select
 *  block. - LE && FM
 */
int HText_getOptionNum(HText *text)
d6979 1
a6979 1
    int n = 1;			/* start count at 1 */
d6982 1
a6982 1
	return (0);
d6987 1
a6987 1
	return (0);
d6991 2
a6992 2
    CTRACE((tfp, "HText_getOptionNum: Got number '%d'.\n", n));
    return (n);
d6996 8
a7003 7
 *  This function checks for a numbered option pattern
 *  as the prefix for an option value.  If present, and
 *  we are in the correct keypad mode, it returns a
 *  pointer to the actual value, following that prefix.
 *  Otherwise, it returns the original pointer.
 */
static char *HText_skipOptionNumPrefix(char *opname)
d7006 1
a7006 1
     * Check if we are in the correct keypad mode.
d7008 1
a7008 1
    if (fields_are_numbered()) {
d7010 6
a7015 6
	 * Skip the option number embedded in the option name so the
	 * extra chars won't mess up cgi scripts processing the value.
	 * The format is (nnn)__ where nnn is a number and there is a
	 * minimum of 5 chars (no underscores if (nnn) exceeds 5 chars).
	 * See HTML.c.  If the chars don't exactly match this format,
	 * just use all of opname.  - LE
d7019 3
a7021 3
	if ((non_empty(cp) && *cp++ == '(') &&
	    *cp && isdigit(UCH(*cp++))) {
	    while (*cp && isdigit(UCH(*cp)))
d7032 1
a7032 1
		if (i < 5) {
d7041 1
a7041 1
	return (cp);
d7044 1
a7044 1
    return (opname);
d7048 12
a7059 10
 *  We couldn't set the value field for the previous option
 *  tag so we have to do it now.  Assume that the last anchor
 *  was the previous options tag.
 */
char *HText_setLastOptionValue(HText *text, char *value,
			       char *submit_value,
			       int order,
			       BOOLEAN checked,
			       int val_cs,
			       int submit_val_cs)
d7066 4
a7069 6
    if (!(value
	  && text
	  && text->last_anchor
	  && text->last_anchor->link_type == INPUT_ANCHOR)) {
	CTRACE((tfp, "HText_setLastOptionValue: invalid call!  value:%s!\n",
		(value ? value : "<NULL>")));
d7073 2
a7074 3
    CTRACE((tfp,
	    "Entering HText_setLastOptionValue: value:\"%s\", checked:%s\n",
	    value, (checked ? "on" : "off")));
d7077 1
a7077 1
     * Strip end spaces, newline is also whitespace.
d7080 3
a7082 3
	cp = &value[strlen(value) - 1];
	while ((cp >= value) && (isspace(UCH(*cp)) ||
				 IsSpecialAttrChar(UCH(*cp))))
d7084 1
a7084 1
	*(cp + 1) = '\0';
d7088 1
a7088 1
     * Find first non space
d7091 2
a7092 2
    while (isspace(UCH(*cp)) ||
	   IsSpecialAttrChar(UCH(*cp)))
d7096 1
a7096 1
	fields_are_numbered()) {
d7098 2
a7099 2
	 * Collapse any space between the popup option
	 * prefix and actual value.  -FM
d7103 2
a7104 2
	    while (isspace(UCH(cp1[i])) ||
		   IsSpecialAttrChar(UCH(cp1[i]))) {
d7119 1
a7119 1
	 * Put the text on the screen as well.
d7129 1
a7129 1
	 * Put the text on the screen as well.
d7135 1
a7135 1
	 * Create a linked list of option values.
d7137 2
a7138 2
	OptionType *op_ptr = text->last_anchor->input_field->select_list;
	OptionType *new_ptr = NULL;
d7142 1
a7142 1
	 * Deal with newlines or tabs.
d7144 1
a7144 1
	LYReduceBlanks(value);
d7148 1
a7148 1
	     * No option items yet.
d7151 4
a7154 5
		CTRACE((tfp,
			"HText_setLastOptionValue: last input_field not F_OPTION_LIST_TYPE (%d)\n",
			F_OPTION_LIST_TYPE));
		CTRACE((tfp, "                          but %d, ignoring!\n",
			text->last_anchor->input_field->type));
d7159 1
a7159 1
		typecalloc(OptionType);
d7167 1
a7167 1
		op_ptr = op_ptr->next;
d7169 1
a7169 1
	    number++;		/* add one more */
d7171 2
a7172 1
	    op_ptr->next = new_ptr = typecalloc(OptionType);
d7181 2
a7182 2
	 * Find first non-space again, convert_to_spaces above may have
	 * changed the string.  - kw
d7185 2
a7186 2
	while (isspace(UCH(*cp)) ||
	       IsSpecialAttrChar(UCH(*cp)))
d7193 1
a7193 1
		       !IsSpecialAttrChar(UCH(cp[i]))) {
d7200 1
a7200 3
		(tmp = typecallocn(unsigned char, strlen(cp) + 1)) != 0) {
		if (tmp == NULL)
		    outofmem(__FILE__, "HText_setLastOptionValue");
d7202 1
a7202 1
		    TO_EUC((unsigned char *) cp, tmp);
d7205 1
a7205 1
		    TO_SJIS((unsigned char *) cp, tmp);
d7214 1
a7214 1
		StrAllocCopy(new_ptr->name, (const char *) tmp);
a7225 2
	    FormInfo *last_input = text->last_anchor->input_field;

d7227 1
a7227 1
	    last_input->num_value = 0;
d7229 18
a7246 13
	     * If this is the first option in a popup select list,
	     * HText_beginInput may have allocated the value and
	     * cp_submit_value fields, so free them now to avoid
	     * a memory leak.  - kw
	     */
	    FREE(last_input->value);
	    FREE(last_input->cp_submit_value);

	    last_input->value = last_input->select_list->name;
	    last_input->orig_value = last_input->select_list->name;
	    last_input->cp_submit_value = last_input->select_list->cp_submit_value;
	    last_input->orig_submit_value = last_input->select_list->cp_submit_value;
	    last_input->value_cs = new_ptr->value_cs;
d7249 5
a7253 8
	    int curlen = (HTCurSelectedOptionValue
			  ? strlen(HTCurSelectedOptionValue)
			  : 0);

	    /*
	     * Make the selected Option Value as long as
	     * the longest option.
	     */
d7256 1
a7256 1
			    UNDERSCORES(newlen - curlen));
a7261 2
	    FormInfo *last_input = text->last_anchor->input_field;

d7263 1
a7263 1
	     * Set the default option as this one.
d7265 9
a7273 6
	    last_input->num_value = number;
	    last_input->value = new_ptr->name;
	    last_input->orig_value = new_ptr->name;
	    last_input->cp_submit_value = new_ptr->cp_submit_value;
	    last_input->orig_submit_value = new_ptr->cp_submit_value;
	    last_input->value_cs = new_ptr->value_cs;
d7277 1
a7277 1
			    UNDERSCORES(newlen - curlen));
d7281 1
a7281 1
	 * Return the selected Option value to be sent to the screen.
d7285 1
a7285 1
	     * Change the value.
d7288 1
a7288 1
		strlen(HTCurSelectedOptionValue);
d7294 1
a7294 1
	CTRACE((tfp, "HText_setLastOptionValue:%s value=\"%s\"\n",
d7296 5
a7300 5
		value));
	CTRACE((tfp, "            val_cs=%d \"%s\"",
		val_cs,
		(val_cs >= 0 ?
		 LYCharSet_UC[val_cs].MIMEname : "<UNKNOWN>")));
d7302 1
a7302 1
	    CTRACE((tfp, " (submit_val_cs %d \"%s\") submit_value%s=\"%s\"\n",
d7307 5
a7311 4
		    "(ignored)" : "",
		    submit_value));
	} else {
	    CTRACE((tfp, "\n"));
d7314 1
a7314 1
    return (ret_Value);
d7318 3
a7320 3
 * Assign a form input anchor.
 * Returns the number of characters to leave
 * blank so that the input field can fit.
d7322 4
a7325 2
int HText_beginInput(HText *text, BOOL underline,
		     InputFieldData * I)
d7327 4
a7330 3
    TextAnchor *a;
    FormInfo *f;
    const char *cp_option = NULL;
a7333 3
    int adjust_marker = 0;
    int MaximumSize;
    char marker[16];
d7335 1
a7335 1
    CTRACE((tfp, "GridText: Entering HText_beginInput\n"));
a7336 3
    POOLtypecalloc(TextAnchor, a);

    POOLtypecalloc(FormInfo, f);
d7340 1
d7345 1
d7347 5
a7351 5
     * If this is a radio button, or an OPTION we're converting
     * to a radio button, and it's the first with this name, make
     * sure it's checked by default.  Otherwise, if it's checked,
     * uncheck the default or any preceding radio button with this
     * name that was checked.  -FM
d7353 1
a7353 1
    if (I->type != NULL && !strcmp(I->type, "OPTION") &&
d7363 1
a7363 1
	    TextAnchor *b;
d7365 1
a7365 2

	    for (b = text->first_anchor; b != NULL; b = b->next) {
d7378 6
a7384 2
	    if (i2 == 0)
		I->checked = TRUE;
d7393 1
a7393 1
    LYClearHiText(a);
d7405 1
d7407 1
a7407 1
     * Set the no_cache flag if the METHOD is POST.  -FM
d7413 1
a7413 1
     * Set up VALUE.
d7418 1
a7418 1
	if ((tmp = typecallocn(unsigned char, strlen(IValue) + 1)) != 0) {
d7420 1
a7420 1
		TO_EUC((unsigned char *) IValue, tmp);
d7423 1
a7423 1
		TO_SJIS((unsigned char *) IValue, tmp);
d7427 1
a7427 1
		    if (IValue[i] != CH_ESC) {	/* S/390 -- gil -- 1621 */
d7432 1
a7432 1
	    StrAllocCopy(IValue, (const char *) tmp);
d7438 2
a7439 2
     * Special case of OPTION.
     * Is handled above if radio type and LYSelectPopups is FALSE.
d7442 1
a7442 1
    if (I->type != NULL && !strcmp(I->type, "OPTION")) {
d7452 4
a7455 4
	 * The option's size parameter actually gives the length and not
	 * the width of the list.  Perform the conversion here
	 * and get rid of the allocated HTCurSelect....
	 * 0 is ok as it means any length (arbitrary decision).
d7464 1
a7464 1
     * Set SIZE.
d7466 2
a7467 2
    if (I->size != 0) {
	f->size = I->size;
d7469 1
a7469 1
	 * Leave at zero for option lists.
d7472 1
a7472 1
	    f->size = 20;	/* default */
d7475 1
a7475 1
	f->size = 20;		/* default */
d7479 1
a7479 1
     * Set MAXLENGTH.
d7484 1
a7484 1
	f->maxlength = 0;	/* 0 means infinite */
d7488 2
a7489 2
     * Set CHECKED
     * (num_value is only relevant to check and radio types).
d7497 1
a7497 1
     * Set TYPE.
d7500 1
a7500 1
	if (!strcasecomp(I->type, "password")) {
d7502 1
a7502 1
	} else if (!strcasecomp(I->type, "checkbox")) {
d7504 1
a7504 1
	} else if (!strcasecomp(I->type, "radio")) {
d7506 1
a7506 1
	} else if (!strcasecomp(I->type, "submit")) {
d7508 1
a7508 1
	} else if (!strcasecomp(I->type, "image")) {
d7510 1
a7510 1
	} else if (!strcasecomp(I->type, "reset")) {
d7512 1
a7512 1
	} else if (!strcasecomp(I->type, "OPTION_LIST")) {
d7514 1
a7514 1
	} else if (!strcasecomp(I->type, "hidden")) {
d7518 1
a7518 1
	} else if (!strcasecomp(I->type, "textarea")) {
d7520 1
a7520 1
	} else if (!strcasecomp(I->type, "range")) {
d7522 1
a7522 1
	} else if (!strcasecomp(I->type, "file")) {
d7524 1
a7524 2
	    CTRACE((tfp, "ok, got a file uploader\n"));
	} else if (!strcasecomp(I->type, "keygen")) {
d7528 1
a7528 1
	     * Note that TYPE="scribble" defaults to TYPE="text".  -FM
d7530 1
a7530 1
	    f->type = F_TEXT_TYPE;	/* default */
d7537 1
a7537 1
     * Set NAME.
d7540 1
a7540 1
	StrAllocCopy(f->name, I->name);
d7547 1
a7547 1
	     * Set name to empty string.
d7552 1
a7552 1
	     * Error!  NAME must be present.
d7554 4
a7557 2
	    CTRACE((tfp,
		    "GridText: No name present in input field; not displaying\n"));
d7559 1
a7559 1
	    return (0);
d7564 1
a7564 1
     * Add this anchor to the anchor list
d7573 2
a7574 2
     * Set VALUE, if it exists.  Otherwise, if it's not
     * an option list make it a zero-length string.  -FM
d7578 2
a7579 2
	 * OPTION VALUE is not actually the value to be seen but is to
	 * be sent....
d7584 2
a7585 2
	     * Fill both with the value.  The f->value may be
	     * overwritten in HText_setLastOptionValue....
d7596 2
a7597 2
	 * May be an empty INPUT field.  The text entered will then
	 * probably be in the current display character set.  - kw
d7603 1
a7603 1
     * Run checks and fill in necessary values.
d7606 1
a7606 1
	if (non_empty(f->value)) {
d7614 1
a7614 1
	if (non_empty(f->value)) {
d7632 1
a7632 1
	f->size = 3;
d7634 1
a7634 1
	    StrAllocCopy(f->value, (f->type == F_CHECKBOX_TYPE ? "on" : ""));
d7640 1
a7640 1
     * Set original values.
d7642 1
a7642 1
    if (f->type == F_RADIO_TYPE || f->type == F_CHECKBOX_TYPE) {
d7654 2
a7655 2
     * Store accept-charset if present, converting to lowercase
     * and collapsing spaces.  - kw
d7664 1
a7664 1
     * Add numbers to form fields if needed.  - LE & FM
d7668 2
a7669 2
	 * Do not supply number for hidden fields, nor
	 * for types that are not yet implemented.
d7671 6
a7676 8
    case F_HIDDEN_TYPE:
#ifndef USE_FILE_UPLOAD
    case F_FILE_TYPE:
#endif
    case F_RANGE_TYPE:
    case F_KEYGEN_TYPE:
	a->number = 0;
	break;
d7678 6
a7683 6
    default:
	if (fields_are_numbered())
	    a->number = ++(text->last_anchor_number);
	else
	    a->number = 0;
	break;
d7685 17
a7701 11
    if (fields_are_numbered() && (a->number > 0)) {
	sprintf(marker, "[%d]", a->number);
	if (number_fields_on_left) {
	    BOOL had_bracket = (f->type == F_OPTION_LIST_TYPE);

	    HText_appendText(text, had_bracket ? (marker + 1) : marker);
	    if (had_bracket)
		HText_appendCharacter(text, '[');
	} else {
	    adjust_marker = strlen(marker);
	}
a7703 2
    } else {
	*marker = '\0';
d7707 1
a7707 1
     * Restrict SIZE to maximum allowable size.
a7708 1
    MaximumSize = WRAP_COLS(text) + 1 - adjust_marker;
d7710 28
d7739 6
a7744 27
    case F_SUBMIT_TYPE:
    case F_IMAGE_SUBMIT_TYPE:
    case F_RESET_TYPE:
    case F_TEXT_TYPE:
    case F_TEXTAREA_TYPE:
	/*
	 * For submit and reset buttons, and for text entry
	 * fields and areas, we limit the size element to that
	 * of one line for the current style because that's
	 * the most we could highlight on overwrites, and/or
	 * handle in the line editor.  The actual values for
	 * text entry lines can be long, and will be scrolled
	 * horizontally within the editing window.  -FM
	 */
	MaximumSize -= (1 +
			(int) text->style->leftIndent +
			(int) text->style->rightIndent);

	/*  If we are numbering form links, place is taken by [nn]  */
	if (fields_are_numbered()) {
	    if (!number_fields_on_left
		&& f->type == F_TEXT_TYPE
		&& MaximumSize > a->line_pos + 10)
		MaximumSize -= a->line_pos;
	    else
		MaximumSize -= strlen(marker);
	}
a7745 6
	/*
	 * Save value for submit/reset buttons so they
	 * will be visible when printing the page.  - LE
	 */
	I->value = f->value;
	break;
d7747 10
a7756 9
    default:
	/*
	 * For all other fields we limit the size element to
	 * 10 less than the screen width, because either they
	 * are types with small placeholders, and/or are a
	 * type which is handled via a popup window.  -FM
	 */
	MaximumSize -= 10;
	break;
a7757 2
    if (f->size > MaximumSize)
	f->size = MaximumSize;
d7760 1
a7760 1
     * Add this anchor to the anchor list
d7769 1
a7769 1
	HTCurrentForm->nfields++;	/* will count hidden fields - kw */
d7771 2
a7772 2
	 * Propagate form field's accept-charset attribute to enclosing
	 * form if the form itself didn't have an accept-charset - kw
d7781 1
a7781 1
	CTRACE((tfp, "beginInput: HTCurrentForm is missing!\n"));
d7784 23
a7806 43
    CTRACE((tfp, "Input link: name=%s\nvalue=%s\nsize=%d\n",
	    f->name,
	    NonNull(f->value),
	    f->size));
    CTRACE((tfp, "Input link: name_cs=%d \"%s\" (from %d \"%s\")\n",
	    f->name_cs,
	    (f->name_cs >= 0 ?
	     LYCharSet_UC[f->name_cs].MIMEname : "<UNKNOWN>"),
	    I->name_cs,
	    (I->name_cs >= 0 ?
	     LYCharSet_UC[I->name_cs].MIMEname : "<UNKNOWN>")));
    CTRACE((tfp, "            value_cs=%d \"%s\" (from %d \"%s\")\n",
	    f->value_cs,
	    (f->value_cs >= 0 ?
	     LYCharSet_UC[f->value_cs].MIMEname : "<UNKNOWN>"),
	    I->value_cs,
	    (I->value_cs >= 0 ?
	     LYCharSet_UC[I->value_cs].MIMEname : "<UNKNOWN>")));

    /*
     * Return the SIZE of the input field.
     */
    return (f->size);
}

/*
 * If we're numbering fields on the right, do it.  Note that some fields may
 * be too long for the line - we'll lose the marker in that case rather than
 * truncate the field.
 */
void HText_endInput(HText *text)
{
    if (fields_are_numbered()
	&& !number_fields_on_left
	&& text != NULL
	&& text->last_anchor != NULL
	&& text->last_anchor->number > 0) {
	char marker[20];

	HText_setIgnoreExcess(text, FALSE);
	sprintf(marker, "[%d]", text->last_anchor->number);
	HText_appendText(text, marker);
    }
d7810 6
a7815 6
 * Get a translation (properly:  transcoding) quality, factoring in
 * our ability to translate (an UCTQ_t) and a possible q parameter
 * on the given charset string, for cs_from -> givenmime.
 * The parsed input string will be mutilated on exit(!).
 * Note that results are not normalised to 1.0, but results from
 * different calls of this function can be compared.  - kw
d7817 2
a7818 2
 * Obsolete, it was planned to use here a quality parametr UCTQ_t,
 * which is boolean now.
d7820 3
a7822 2
static double get_trans_q(int cs_from,
			  char *givenmime)
a7826 1

d7829 1
a7829 1
    if ((p = strchr(givenmime, ';')) != NULL) {
d7840 1
a7840 1
    if (non_empty(p)) {
a7841 1

d7846 1
a7846 1
		if (0 == strcasecomp(ptok, "q")) {
d7859 4
a7862 4
 * Find the best charset for submission, if we have an ACCEPT_CHARSET
 * list.  It factors in how well we can translate (just as guess, and
 * not a very good one..) and possible ";q=" factors.  Yes this is
 * more general than it needs to be here.
d7864 1
a7864 1
 * Input is cs_in and acceptstring.
d7866 9
a7874 8
 * Will return charset handle as int.
 * best_csname will point to a newly allocated MIME string for the
 * charset corresponding to the return value if return value >= 0.
 * - kw
 */
static int find_best_target_cs(char **best_csname,
			       int cs_from,
			       const char *acceptstring)
a7879 1

a7883 1

d7885 1
a7885 1
	    /* Get the Charset */
d7894 1
a7894 1
	if (!strcmp(bestmime, "*"))	/* non-standard for HTML attribute.. */
d7908 5
a7912 23
#ifdef USE_FILE_UPLOAD
static void load_a_file(const char *val_used,
			bstring **result)
{
    FILE *fd;
    size_t bytes;
    char buffer[257];

    CTRACE((tfp, "Ok, about to convert %s to mime/thingy\n", val_used));

    if (*val_used) {		/* ignore empty form field */
	if ((fd = fopen(val_used, BIN_R)) == 0) {
	    HTAlert(gettext("Can't open file for uploading"));
	} else {
	    while ((bytes = fread(buffer, sizeof(char), 256, fd)) != 0) {
		HTSABCat(result, buffer, bytes);
	    }
	    LYCloseInput(fd);
	}
    }
}

static const char *guess_content_type(const char *filename)
d7914 10
a7923 262
    HTAtom *encoding;
    const char *desc;
    HTFormat format = HTFileFormat(filename, &encoding, &desc);

    return (format != 0 && non_empty(format->name))
	? format->name
	: "text/plain";
}
#endif /* USE_FILE_UPLOAD */

static void cannot_transcode(BOOL *had_warning,
			     const char *target_csname)
{
    if (*had_warning == NO) {
	*had_warning = YES;
	_user_message(CANNOT_TRANSCODE_FORM,
		      target_csname ? target_csname : "UNKNOWN");
	LYSleepAlert();
    }
}

#define SPECIAL_8BIT 1
#define SPECIAL_FORM 2

static unsigned check_form_specialchars(const char *value)
{
    unsigned result = 0;
    const char *p;

    for (p = value;
	 non_empty(p) && (result != (SPECIAL_8BIT | SPECIAL_FORM));
	 p++) {
	if ((*p == HT_NON_BREAK_SPACE) ||
	    (*p == HT_EN_SPACE) ||
	    (*p == LY_SOFT_HYPHEN)) {
	    result |= SPECIAL_FORM;
	} else if ((*p & 0x80) != 0) {
	    result |= SPECIAL_8BIT;
	}
    }
    return result;
}

/*
 * Scan the given data, adding characters to the MIME-boundary to keep it from
 * matching any part of the data.
 */
static void UpdateBoundary(char **Boundary,
			   bstring *data)
{
    int j;
    int have = strlen(*Boundary);
    int last = BStrLen(data);
    char *text = BStrData(data);
    char *want = *Boundary;

    for (j = 0; j <= (last - have); ++j) {
	if (want[0] == text[j]
	    && !memcmp(want, text + j, have)) {
	    char temp[2];

	    temp[0] = isdigit(text[have + j]) ? 'a' : '0';
	    temp[1] = '\0';
	    StrAllocCat(want, temp);
	    ++have;
	}
    }
    *Boundary = want;
}

/*
 * Convert a string to base64
 */
static char *convert_to_base64(const char *src,
			       int len)
{
#define B64_LINE       76

    static const char basis_64[] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    char *dest;
    int rlen;			/* length of result string */
    unsigned char c1, c2, c3;
    const char *eol;
    char *r;
    const char *str;
    int eollen;
    int chunk;

    str = src;
    eol = "\n";
    eollen = 1;

    /* calculate the length of the result */
    rlen = (len + 2) / 3 * 4;	/* encoded bytes */
    if (rlen) {
	/* add space for EOL */
	rlen += ((rlen - 1) / B64_LINE + 1) * eollen;
    }

    /* allocate a result buffer */
    if ((dest = (char *) malloc(rlen + 1)) == NULL) {
	outofmem(__FILE__, "convert_to_base64");
    }
    r = dest;

    /* encode */
    for (chunk = 0; len > 0; len -= 3, chunk++) {
	if (chunk == (B64_LINE / 4)) {
	    const char *c = eol;
	    const char *e = eol + eollen;

	    while (c < e)
		*r++ = *c++;
	    chunk = 0;
	}
	c1 = *str++;
	c2 = *str++;
	*r++ = basis_64[c1 >> 2];
	*r++ = basis_64[((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4)];
	if (len > 2) {
	    c3 = *str++;
	    *r++ = basis_64[((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6)];
	    *r++ = basis_64[c3 & 0x3F];
	} else if (len == 2) {
	    *r++ = basis_64[(c2 & 0xF) << 2];
	    *r++ = '=';
	} else {		/* len == 1 */
	    *r++ = '=';
	    *r++ = '=';
	}
    }
    if (rlen) {
	/* append eol to the result string */
	const char *c = eol;
	const char *e = eol + eollen;

	while (c < e)
	    *r++ = *c++;
    }
    *r = '\0';

    return dest;
}

typedef enum {
    NO_QUOTE			/* no quoting needed */
    ,QUOTE_MULTI		/* multipart */
    ,QUOTE_BASE64		/* encode as base64 */
    ,QUOTE_SPECIAL		/* escape special characters only */
} QuoteData;

typedef struct {
    int type;			/* the type of this field */
    BOOL first;			/* true if this begins a submission part */
    char *name;			/* the name of this field */
    char *value;		/* the nominal value of this field */
    bstring *data;		/* its data, which is usually the same as the value */
    QuoteData quote;		/* how to quote/translate the data */
} PostData;

static char *escape_or_quote_name(const char *name,
				  QuoteData quoting,
				  const char *MultipartContentType)
{
    char *escaped1 = NULL;

    switch (quoting) {
    case NO_QUOTE:
	StrAllocCopy(escaped1, name);
	break;
    case QUOTE_MULTI:
    case QUOTE_BASE64:
	StrAllocCopy(escaped1, "Content-Disposition: form-data");
	HTSprintf(&escaped1, "; name=\"%s\"", name);
	if (MultipartContentType)
	    HTSprintf(&escaped1, MultipartContentType, "text/plain");
	if (quoting == QUOTE_BASE64)
	    StrAllocCat(escaped1, "\r\nContent-Transfer-Encoding: base64");
	StrAllocCat(escaped1, "\r\n\r\n");
	break;
    case QUOTE_SPECIAL:
	escaped1 = HTEscapeSP(name, URL_XALPHAS);
	break;
    }
    return escaped1;
}

static char *escape_or_quote_value(const char *value,
				   QuoteData quoting)
{
    char *escaped2 = NULL;

    switch (quoting) {
    case NO_QUOTE:
    case QUOTE_MULTI:
	StrAllocCopy(escaped2, NonNull(value));
	break;
    case QUOTE_BASE64:
	/* FIXME: this is redundant */
	escaped2 = convert_to_base64(value, strlen(value));
	break;
    case QUOTE_SPECIAL:
	escaped2 = HTEscapeSP(value, URL_XALPHAS);
	break;
    }
    return escaped2;
}

/*
 * Check if we should encode the data in base64.  We can, only if we're using
 * a multipart content type.  We should, if we're sending mail and the data
 * contains long lines or nonprinting characters.
 */
static int check_if_base64_needed(int submit_method,
				  bstring *data)
{
    int width = 0;
    BOOL printable = TRUE;
    char *text = BStrData(data);

    if (text != 0) {
	int col = 0;
	int n;
	int length = BStrLen(data);

	for (n = 0; n < length; ++n) {
	    int ch = UCH(text[n]);

	    if (is8bits(ch) || ((ch < 32 && ch != '\n'))) {
		CTRACE((tfp, "nonprintable %d:%#x\n", n, ch));
		printable = FALSE;
	    }
	    if (ch == '\n' || ch == '\r') {
		if (width < col)
		    width = col;
		col = 0;
	    } else {
		++col;
	    }
	}
	if (width < col)
	    width = col;
    }
    return !printable && ((submit_method == URL_MAIL_METHOD) && (width > 72));
}

/*
 * HText_SubmitForm - generate submit data from form fields.
 * For mailto forms, send the data.
 * For other methods, set fields in structure pointed to by doc
 * appropriately for next request.
 * Returns 1 if *doc set appropriately for next request,
 * 0 otherwise.  - kw
 */
int HText_SubmitForm(FormInfo * submit_item, DocInfo *doc, char *link_name,
		     char *link_value)
{
    BOOL had_chartrans_warning = NO;
    BOOL have_accept_cs = NO;
    BOOL success;
a7925 7
    BOOL skip_field = FALSE;
    const char *out_csname;
    const char *target_csname = NULL;
    PerFormInfo *thisform;
    PostData *my_data = NULL;
    TextAnchor *anchor_ptr;
    bstring *my_query = NULL;
d7928 12
a7939 1
    char *content_type_out = NULL;
a7940 14
    char *copied_val_used = NULL;
    char *escaped1 = NULL;
    char *escaped2 = NULL;
    char *last_textarea_name = NULL;
    const char *name_used = "";
    char *previous_blanks = NULL;
    const char *val_used = "";
    int anchor_count = 0;
    int anchor_limit = 0;
    int form_number = submit_item->number;
    int result = 0;
    int target_cs = -1;
    int textarea_lineno = 0;
    unsigned form_is_special = 0;
d7942 1
a7942 1
    CTRACE((tfp, "SubmitForm\n  link_name=%s\n  link_value=%s\n", link_name, link_value));
d7944 1
a7944 1
	return 0;
d7946 1
a7946 2
    thisform = (PerFormInfo *) HTList_objectAt(HTMainText->forms, form_number
					       - 1);
d7949 2
a7950 2
	CTRACE((tfp, "SubmitForm: form %d not in HTMainText's list!\n",
		form_number));
d7952 2
a7953 2
	CTRACE((tfp, "SubmitForm: failed sanity check, %d!=%d !\n",
		thisform->number, form_number));
d7957 11
a7967 12
    if (isEmpty(submit_item->submit_action)) {
	CTRACE((tfp, "SubmitForm: no action given\n"));
	return 0;
    }

    /*
     * If we're mailing, make sure it's a mailto ACTION.  -FM
     */
    if ((submit_item->submit_method == URL_MAIL_METHOD) &&
	!isMAILTO_URL(submit_item->submit_action)) {
	HTAlert(BAD_FORM_MAILTO);
	return 0;
d7971 1
a7971 1
     * Check the ENCTYPE and set up the appropriate variables.  -FM
d7976 2
a7977 2
	 * Do not hex escape, and use physical newlines
	 * to separate name=value pairs.  -FM
d7984 2
a7985 2
	 * Use semicolons instead of ampersands as the
	 * separators for name=value pairs.  -FM
d7992 4
a7995 2
	 * Use the multipart MIME format.  Later we will ensure it does not
	 * occur within the content.
d8001 6
a8006 6
     * Determine in what character encoding (aka.  charset) we should
     * submit.  We call this target_cs and the MIME name for it
     * target_csname.
     * TODO:   - actually use ACCEPT-CHARSET stuff from FORM
     * TODO:   - deal with list in ACCEPT-CHARSET, find a "best"
     *           charset to submit
d8037 1
a8037 1
	    target_cs = UCLYhndl_for_unspec;	/* always >= 0 */
d8042 1
a8042 1
	target_cs = UCLYhndl_for_unspec;	/* always >= 0 */
d8046 4
a8049 1
     * Go through list of anchors and get a "max." charset parameter - kw
d8051 4
a8054 3
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
d8056 52
a8107 2
	if (anchor_ptr->link_type != INPUT_ANCHOR)
	    continue;
d8109 19
a8127 2
	if (anchor_ptr->input_field->number == form_number &&
	    !anchor_ptr->input_field->disabled) {
d8129 2
a8130 47
	    FormInfo *form_ptr = anchor_ptr->input_field;
	    char *val = form_ptr->cp_submit_value != NULL
	    ? form_ptr->cp_submit_value
	    : form_ptr->value;

	    unsigned field_is_special = check_form_specialchars(val);
	    unsigned name_is_special = check_form_specialchars(form_ptr->name);

	    form_is_special = (field_is_special | name_is_special);

	    if (field_is_special == 0) {
		/* already ok */
	    } else if (target_cs < 0) {
		/* already confused */
	    } else if ((field_is_special & SPECIAL_8BIT) == 0
		       && (LYCharSet_UC[target_cs].enc == UCT_ENC_8859
			   || (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
		/* those specials will be trivial */
	    } else if (UCNeedNotTranslate(form_ptr->value_cs, target_cs)) {
		/* already ok */
	    } else if (UCCanTranslateFromTo(form_ptr->value_cs, target_cs)) {
		/* also ok */
	    } else if (UCCanTranslateFromTo(target_cs, form_ptr->value_cs)) {
		target_cs = form_ptr->value_cs;		/* try this */
		target_csname = NULL;	/* will be set after loop */
	    } else {
		target_cs = -1;	/* don't know what to do */
	    }

	    /*  Same for name */
	    if (name_is_special == 0) {
		/* already ok */
	    } else if (target_cs < 0) {
		/* already confused */
	    } else if ((name_is_special & SPECIAL_8BIT) == 0
		       && (LYCharSet_UC[target_cs].enc == UCT_ENC_8859
			   || (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
		/* those specials will be trivial */
	    } else if (UCNeedNotTranslate(form_ptr->name_cs, target_cs)) {
		/* already ok */
	    } else if (UCCanTranslateFromTo(form_ptr->name_cs, target_cs)) {
		/* also ok */
	    } else if (UCCanTranslateFromTo(target_cs, form_ptr->name_cs)) {
		target_cs = form_ptr->value_cs;		/* try this */
		target_csname = NULL;	/* will be set after loop */
	    } else {
		target_cs = -1;	/* don't know what to do */
d8132 1
d8134 1
a8134 2
	    ++anchor_limit;
	} else if (anchor_ptr->input_field->number > form_number) {
a8135 2
	}
    }
d8137 1
a8137 8
    /*
     * If we have input fields (we expect this), make an array of them so we
     * can organize the data.
     */
    if (anchor_limit != 0) {
	my_data = typecallocn(PostData, anchor_limit);
	if (my_data == 0)
	    outofmem(__FILE__, "HText_SubmitForm");
d8141 1
a8141 1
	if ((form_is_special & SPECIAL_8BIT) != 0) {
d8143 1
a8143 1
	} else if ((form_is_special & SPECIAL_FORM) != 0) {
d8151 1
a8151 3
	char *temp = NULL;

	StrAllocCopy(temp, submit_item->submit_action);
d8153 1
a8153 1
	 * Method is GET.  Clip out any anchor in the current URL.
d8155 1
a8155 1
	strtok(temp, "#");
d8157 1
a8157 1
	 * Clip out any old query in the current URL.
d8159 1
a8159 1
	strtok(temp, "?");
d8161 1
a8161 1
	 * Add the lead question mark for the new URL.
d8163 1
a8163 2
	StrAllocCat(temp, "?");
	BStrCat0(my_query, temp);
d8166 2
a8167 3
	 * We are submitting POST content to a server,
	 * so load content_type_out.  This will be put in
	 * the post_content_type element if all goes well.  -FM, kw
d8170 1
a8170 1
	    StrAllocCopy(content_type_out,
d8173 1
a8173 1
	    StrAllocCopy(content_type_out,
d8176 3
a8178 2
	    StrAllocCopy(content_type_out,
			 "multipart/form-data");
d8180 1
a8180 1
	    StrAllocCopy(content_type_out,
d8185 2
a8186 2
	 * If the ENCTYPE is not multipart/form-data, append the
	 * charset we'll be sending to the post_content_type, IF
d8190 1
a8190 1
	 *      AND it or target_csname is different from iso-8859-1,
d8194 9
a8202 10
	 *      AND target_cs is different from the currently effective
	 *      assumed charset (which should have been set by the user
	 *      so that it reflects what the server is sending, if the
	 *      document is rendered correctly).
	 * For multipart/form-data the equivalent will be done later,
	 * separately for each form field.  - kw
	 */
	if (have_accept_cs
	    || ((form_is_special & SPECIAL_8BIT) != 0
		|| (form_is_special & SPECIAL_FORM) != 0)) {
d8211 2
a8212 1
			HTSprintf(&content_type_out, "; charset=%s", target_csname);
d8216 5
a8220 1
		cannot_transcode(&had_chartrans_warning, target_csname);
d8225 1
d8229 1
a8229 1
     * Build up a list of the input fields and their associated values.
d8231 10
a8240 6
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {

	if (anchor_ptr->link_type != INPUT_ANCHOR)
	    continue;
d8242 2
a8243 2
	if (anchor_ptr->input_field->number == form_number &&
	    !anchor_ptr->input_field->disabled) {
d8245 2
a8246 38
	    FormInfo *form_ptr = anchor_ptr->input_field;
	    int out_cs;
	    QuoteData quoting = (PlainText
				 ? NO_QUOTE
				 : (Boundary
				    ? QUOTE_MULTI
				    : QUOTE_SPECIAL));

	    if (form_ptr->type != F_TEXTAREA_TYPE)
		textarea_lineno = 0;

	    CTRACE((tfp, "SubmitForm[%d/%d]: ",
		    anchor_count + 1, anchor_limit));

	    name_used = NonNull(form_ptr->name);

	    switch (form_ptr->type) {
	    case F_RESET_TYPE:
		CTRACE((tfp, "reset\n"));
		break;
#ifdef USE_FILE_UPLOAD
	    case F_FILE_TYPE:
		val_used = NonNull(form_ptr->value);
		CTRACE((tfp, "I will submit %s (from %s)\n",
			val_used, name_used));
		break;
#endif
	    case F_SUBMIT_TYPE:
	    case F_TEXT_SUBMIT_TYPE:
	    case F_IMAGE_SUBMIT_TYPE:
		if (!(non_empty(form_ptr->name) &&
		      !strcmp(form_ptr->name, link_name))) {
		    CTRACE((tfp, "skipping submit field with "));
		    CTRACE((tfp, "name \"%s\" for link_name \"%s\", %s.\n",
			    form_ptr->name ? form_ptr->name : "???",
			    link_name ? link_name : "???",
			    non_empty(form_ptr->name) ?
			    "not current link" : "no field name"));
d8248 41
a8288 73
		}
		if (!(form_ptr->type == F_TEXT_SUBMIT_TYPE ||
		      (non_empty(form_ptr->value) &&
		       !strcmp(form_ptr->value, link_value)))) {
		    CTRACE((tfp, "skipping submit field with "));
		    CTRACE((tfp, "name \"%s\" for link_name \"%s\", %s!\n",
			    form_ptr->name ? form_ptr->name : "???",
			    link_name ? link_name : "???",
			    "values are different"));
		    break;
		}
		/* FALLTHRU */
	    case F_RADIO_TYPE:
	    case F_CHECKBOX_TYPE:
	    case F_TEXTAREA_TYPE:
	    case F_PASSWORD_TYPE:
	    case F_TEXT_TYPE:
	    case F_OPTION_LIST_TYPE:
	    case F_HIDDEN_TYPE:
		/*
		 * Be sure to actually look at the option submit value.
		 */
		if (form_ptr->cp_submit_value != NULL) {
		    val_used = form_ptr->cp_submit_value;
		} else {
		    val_used = form_ptr->value;
		}

		/*
		 * Charset-translate value now, because we need to know the
		 * charset parameter for multipart bodyparts.  - kw
		 */
		if (check_form_specialchars(val_used) != 0) {
		    /*  We should translate back. */
		    StrAllocCopy(copied_val_used, val_used);
		    success = LYUCTranslateBackFormData(&copied_val_used,
							form_ptr->value_cs,
							target_cs, PlainText);
		    CTRACE((tfp, "field \"%s\" %d %s -> %d %s %s\n",
			    NonNull(form_ptr->name),
			    form_ptr->value_cs,
			    form_ptr->value_cs >= 0
			    ? LYCharSet_UC[form_ptr->value_cs].MIMEname
			    : "???",
			    target_cs,
			    target_csname ? target_csname : "???",
			    success ? "OK" : "FAILED"));
		    if (success) {
			val_used = copied_val_used;
		    }
		} else {	/* We can use the value directly. */
		    CTRACE((tfp, "field \"%s\" %d %s OK\n",
			    NonNull(form_ptr->name),
			    target_cs,
			    target_csname ? target_csname : "???"));
		    success = YES;
		}
		if (!success) {
		    cannot_transcode(&had_chartrans_warning, target_csname);
		    out_cs = form_ptr->value_cs;
		} else {
		    out_cs = target_cs;
		}
		if (out_cs >= 0)
		    out_csname = LYCharSet_UC[out_cs].MIMEname;
		if (Boundary) {
		    StrAllocCopy(MultipartContentType,
				 "\r\nContent-Type: %s");
		    if (!success && form_ptr->value_cs < 0) {
			/*  This is weird. */
			out_csname = "UNKNOWN-8BIT";
		    } else if (!success) {
			target_csname = NULL;
d8290 1
a8290 3
			if (!target_csname) {
			    target_csname = LYCharSet_UC[target_cs].MIMEname;
			}
a8291 3
		    if (strcmp(out_csname, "iso-8859-1"))
			HTSprintf(&MultipartContentType, "; charset=%s", out_csname);
		}
d8293 17
a8309 10
		/*
		 * Charset-translate name now, because we need to know the
		 * charset parameter for multipart bodyparts.  - kw
		 */
		if (form_ptr->type == F_TEXTAREA_TYPE) {
		    textarea_lineno++;
		    if (textarea_lineno > 1 &&
			last_textarea_name && form_ptr->name &&
			!strcmp(last_textarea_name, form_ptr->name)) {
			break;
a8310 1
		}
d8312 5
a8316 5
		if (check_form_specialchars(name_used) != 0) {
		    /*  We should translate back. */
		    StrAllocCopy(copied_name_used, name_used);
		    success = LYUCTranslateBackFormData(&copied_name_used,
							form_ptr->name_cs,
d8318 30
a8347 11
		    CTRACE((tfp, "name \"%s\" %d %s -> %d %s %s\n",
			    NonNull(form_ptr->name),
			    form_ptr->name_cs,
			    form_ptr->name_cs >= 0
			    ? LYCharSet_UC[form_ptr->name_cs].MIMEname
			    : "???",
			    target_cs,
			    target_csname ? target_csname : "???",
			    success ? "OK" : "FAILED"));
		    if (success) {
			name_used = copied_name_used;
d8349 2
d8352 9
a8360 2
			if (!success) {
			    StrAllocCopy(MultipartContentType, "");
d8363 1
a8363 1
			    if (!target_csname)
d8365 4
d8371 1
a8371 14
		} else {	/* We can use the name directly. */
		    CTRACE((tfp, "name \"%s\" %d %s OK\n",
			    NonNull(form_ptr->name),
			    target_cs,
			    target_csname ? target_csname : "???"));
		    success = YES;
		    if (Boundary) {
			StrAllocCopy(copied_name_used, name_used);
		    }
		}
		if (!success) {
		    cannot_transcode(&had_chartrans_warning, target_csname);
		}
		if (Boundary) {
d8373 3
a8375 10
		     * According to RFC 1867, Non-ASCII field names
		     * "should be encoded according to the prescriptions
		     * of RFC 1522 [...].  I don't think RFC 1522 actually
		     * is meant to apply to parameters like this, and it
		     * is unknown whether any server would make sense of
		     * it, so for now just use some quoting/escaping and
		     * otherwise leave 8-bit values as they are.
		     * Non-ASCII characters in form field names submitted
		     * as multipart/form-data can only occur if the form
		     * provider specifically asked for it anyway.  - kw
d8377 10
a8386 3
		    HTMake822Word(&copied_name_used, FALSE);
		    name_used = copied_name_used;
		}
d8388 13
a8400 5
		break;
	    default:
		CTRACE((tfp, "What type is %d?\n", form_ptr->type));
		break;
	    }
d8402 62
a8463 3
	    skip_field = FALSE;
	    my_data[anchor_count].first = TRUE;
	    my_data[anchor_count].type = form_ptr->type;
d8465 4
a8468 40
	    /*
	     * Using the values of 'name_used' and 'val_used' computed in the
	     * previous case-statement, compute the 'first' and 'data' values
	     * for the current input field.
	     */
	    switch (form_ptr->type) {

	    default:
		skip_field = TRUE;
		break;

#ifdef USE_FILE_UPLOAD
	    case F_FILE_TYPE:
		load_a_file(val_used, &(my_data[anchor_count].data));
		break;
#endif /* USE_FILE_UPLOAD */

	    case F_SUBMIT_TYPE:
	    case F_TEXT_SUBMIT_TYPE:
	    case F_IMAGE_SUBMIT_TYPE:
		if ((non_empty(form_ptr->name) &&
		     !strcmp(form_ptr->name, link_name)) &&
		    (form_ptr->type == F_TEXT_SUBMIT_TYPE ||
		     (non_empty(form_ptr->value) &&
		      !strcmp(form_ptr->value, link_value)))) {
		    ;
		} else {
		    skip_field = TRUE;
		}
		break;

	    case F_RADIO_TYPE:
	    case F_CHECKBOX_TYPE:
		/*
		 * Only add if selected.
		 */
		if (form_ptr->num_value) {
		    ;
		} else {
		    skip_field = TRUE;
a8469 1
		break;
d8471 1
a8471 9
	    case F_TEXTAREA_TYPE:
		if (!last_textarea_name ||
		    strcmp(last_textarea_name, form_ptr->name)) {
		    textarea_lineno = 1;
		    last_textarea_name = form_ptr->name;
		} else {
		    my_data[anchor_count].first = FALSE;
		}
		break;
d8473 2
a8474 6
	    case F_PASSWORD_TYPE:
	    case F_TEXT_TYPE:
	    case F_OPTION_LIST_TYPE:
	    case F_HIDDEN_TYPE:
		break;
	    }
d8476 34
a8509 23
	    /*
	     * If we did not decide to skip the current field, populate the
	     * values in the array for it.
	     */
	    if (!skip_field) {
		StrAllocCopy(my_data[anchor_count].name, name_used);
		StrAllocCopy(my_data[anchor_count].value, val_used);
		if (my_data[anchor_count].data == 0)
		    BStrCat0(my_data[anchor_count].data, val_used);
		my_data[anchor_count].quote = quoting;
		if (quoting == QUOTE_MULTI
		    && check_if_base64_needed(submit_item->submit_method,
					      my_data[anchor_count].data)) {
		    CTRACE((tfp, "will encode as base64\n"));
		    my_data[anchor_count].quote = QUOTE_BASE64;
		    escaped2 =
			convert_to_base64(BStrData(my_data[anchor_count].data),
					  BStrLen(my_data[anchor_count].data));
		    BStrCopy0(my_data[anchor_count].data, escaped2);
		    FREE(escaped2);
		}
	    }
	    ++anchor_count;
d8511 13
a8523 2
	    FREE(copied_name_used);
	    FREE(copied_val_used);
d8525 7
a8531 4
	} else if (anchor_ptr->input_field->number > form_number) {
	    break;
	}
    }
d8533 46
a8578 1
    FREE(copied_name_used);
d8580 23
a8602 2
    if (my_data != 0) {
	BOOL first_one = TRUE;
d8604 20
a8623 13
	/*
	 * If we're using a MIME-boundary, make it unique.
	 */
	if (content_type_out != 0 && Boundary != 0) {
	    Boundary = 0;
	    StrAllocCopy(Boundary, "LYNX");
	    for (anchor_count = 0; anchor_count < anchor_limit; ++anchor_count) {
		if (my_data[anchor_count].data != 0) {
		    UpdateBoundary(&Boundary, my_data[anchor_count].data);
		}
	    }
	    HTSprintf(&content_type_out, "; boundary=%s", Boundary);
	}
d8625 16
a8640 1
	for (anchor_count = 0; anchor_count < anchor_limit; ++anchor_count) {
d8642 8
a8649 2
	    if (my_data[anchor_count].name != 0
		&& my_data[anchor_count].value != 0) {
d8651 83
a8733 8
		CTRACE((tfp,
			"processing [%d:%d] name=%s(first:%d, value=%s, data=%p)\n",
			anchor_count + 1,
			anchor_limit,
			NonNull(my_data[anchor_count].name),
			my_data[anchor_count].first,
			NonNull(my_data[anchor_count].value),
			my_data[anchor_count].data));
d8735 4
a8738 1
		if (my_data[anchor_count].first) {
d8741 1
a8741 1
			    HTBprintf(&my_query, "--%s\r\n", Boundary);
d8743 1
a8743 1
			first_one = FALSE;
d8746 1
a8746 1
			    BStrCat0(my_query, "\n");
d8748 1
a8748 1
			    BStrCat0(my_query, ";");
d8750 1
a8750 1
			    HTBprintf(&my_query, "\r\n--%s\r\n", Boundary);
d8752 1
a8752 1
			    BStrCat0(my_query, "&");
a8754 114
		}

		/* append a null to the string */
		HTSABCat(&(my_data[anchor_count].data), "", 1);
		name_used = my_data[anchor_count].name;
		val_used = my_data[anchor_count].value;

	    } else {
		/* there is no data to send */
		continue;
	    }

	    switch (my_data[anchor_count].type) {
	    case F_TEXT_TYPE:
	    case F_PASSWORD_TYPE:
	    case F_OPTION_LIST_TYPE:
	    case F_HIDDEN_TYPE:
		escaped1 = escape_or_quote_name(my_data[anchor_count].name,
						my_data[anchor_count].quote,
						MultipartContentType);

		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);

		HTBprintf(&my_query,
			  "%s%s%s%s%s",
			  escaped1,
			  (Boundary ? "" : "="),
			  (PlainText ? "\n" : ""),
			  escaped2,
			  ((PlainText && *escaped2) ? "\n" : ""));
		break;
	    case F_CHECKBOX_TYPE:
	    case F_RADIO_TYPE:
		escaped1 = escape_or_quote_name(my_data[anchor_count].name,
						my_data[anchor_count].quote,
						MultipartContentType);

		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);

		HTBprintf(&my_query,
			  "%s%s%s%s%s",
			  escaped1,
			  (Boundary ? "" : "="),
			  (PlainText ? "\n" : ""),
			  escaped2,
			  ((PlainText && *escaped2) ? "\n" : ""));
		break;
	    case F_SUBMIT_TYPE:
	    case F_TEXT_SUBMIT_TYPE:
	    case F_IMAGE_SUBMIT_TYPE:
		/*
		 * If it has a non-zero length name (e.g., because
		 * its IMAGE_SUBMIT_TYPE is to be handled homologously
		 * to an image map, or a SUBMIT_TYPE in a set of
		 * multiple submit buttons, or a single type="text"
		 * that's been converted to a TEXT_SUBMIT_TYPE),
		 * include the name=value pair, or fake name.x=0 and
		 * name.y=0 pairs for IMAGE_SUBMIT_TYPE.  -FM
		 */
		escaped1 = escape_or_quote_name(my_data[anchor_count].name,
						my_data[anchor_count].quote,
						MultipartContentType);

		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);

		if (my_data[anchor_count].type == F_IMAGE_SUBMIT_TYPE) {
		    /*
		     * It's a clickable image submit button.  Fake a 0,0
		     * coordinate pair, which typically returns the image's
		     * default.  -FM
		     */
		    if (Boundary) {
			*(strchr(escaped1, '=') + 1) = '\0';
			HTBprintf(&my_query,
				  "%s\"%s.x\"\r\n\r\n0\r\n--%s\r\n%s\"%s.y\"\r\n\r\n0",
				  escaped1,
				  my_data[anchor_count].name,
				  Boundary,
				  escaped1,
				  my_data[anchor_count].name);
		    } else {
			HTBprintf(&my_query,
				  "%s.x=0%s%s.y=0%s",
				  escaped1,
				  (PlainText ?
				   "\n" : (SemiColon ?
					   ";" : "&")),
				  escaped1,
				  ((PlainText && *escaped1) ?
				   "\n" : ""));
		    }
		} else {
		    /*
		     * It's a standard submit button.  Use the name=value
		     * pair.  = FM
		     */
		    HTBprintf(&my_query,
			      "%s%s%s%s%s",
			      escaped1,
			      (Boundary ? "" : "="),
			      (PlainText ? "\n" : ""),
			      escaped2,
			      ((PlainText && *escaped2) ? "\n" : ""));
		}
		break;
	    case F_RESET_TYPE:
		/* ignore */
		break;
	    case F_TEXTAREA_TYPE:
		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);
a8755 6
		if (my_data[anchor_count].first) {
		    textarea_lineno = 1;
		    /*
		     * Names are different so this is the first textarea or a
		     * different one from any before it.
		     */
d8757 1
a8757 1
			FREE(previous_blanks);
d8759 6
a8764 1
			StrAllocCopy(previous_blanks, "\r\n");
d8766 1
a8766 1
			StrAllocCopy(previous_blanks, "%0d%0a");
a8767 17
		    escaped1 = escape_or_quote_name(name_used,
						    my_data[anchor_count].quote,
						    MultipartContentType);

		    HTBprintf(&my_query,
			      "%s%s%s%s%s",
			      escaped1,
			      (Boundary ? "" : "="),
			      (PlainText ? "\n" : ""),
			      escaped2,
			      ((PlainText && *escaped2) ? "\n" : ""));
		} else {
		    const char *marker = (PlainText
					  ? "\n"
					  : (Boundary
					     ? "\r\n"
					     : "%0d%0a"));
d8769 4
a8772 13
		    /*
		     * This is a continuation of a previous textarea.
		     */
		    if (escaped2[0] != '\0') {
			if (previous_blanks) {
			    BStrCat0(my_query, previous_blanks);
			    FREE(previous_blanks);
			}
			BStrCat0(my_query, escaped2);
			if (PlainText || Boundary)
			    BStrCat0(my_query, marker);
			else
			    StrAllocCopy(previous_blanks, marker);
d8774 1
a8774 1
			StrAllocCat(previous_blanks, marker);
a8775 25
		}
		break;
	    case F_RANGE_TYPE:
		/* not implemented */
		break;
#ifdef USE_FILE_UPLOAD
	    case F_FILE_TYPE:
		if (PlainText) {
		    StrAllocCopy(escaped1, my_data[anchor_count].name);
		} else if (Boundary) {
		    const char *t = guess_content_type(val_used);

		    StrAllocCopy(escaped1, "Content-Disposition: form-data");
		    HTSprintf(&escaped1, "; name=\"%s\"",
			      my_data[anchor_count].name);
		    HTSprintf(&escaped1, "; filename=\"%s\"", val_used);
		    /* Should we take into account the encoding? */
		    HTSprintf(&escaped1, "\r\nContent-Type: %s", t);
		    if (my_data[anchor_count].quote == QUOTE_BASE64)
			StrAllocCat(escaped1,
				    "\r\nContent-Transfer-Encoding: base64");
		    StrAllocCat(escaped1, "\r\n\r\n");
		} else {
		    escaped1 = HTEscapeSP(my_data[anchor_count].name, URL_XALPHAS);
		}
d8777 15
a8791 15
		HTBprintf(&my_query,
			  "%s%s%s",
			  escaped1,
			  (Boundary ? "" : "="),
			  (PlainText ? "\n" : ""));
		/*
		 * If we have anything more than the trailing null we added,
		 * append the file-data to the query.
		 */
		if (BStrLen(my_data[anchor_count].data) > 1) {
		    HTSABCat(&my_query,
			     BStrData(my_data[anchor_count].data),
			     BStrLen(my_data[anchor_count].data) - 1);
		    if (PlainText)
			HTBprintf(&my_query, "\n");
d8793 1
a8793 4
		break;
#endif /* USE_FILE_UPLOAD */
	    case F_KEYGEN_TYPE:
		/* not implemented */
d8796 4
d8801 8
a8808 14
	    FREE(escaped1);
	    FREE(escaped2);
	}
	if (Boundary) {
	    HTBprintf(&my_query, "\r\n--%s--\r\n", Boundary);
	}
	/*
	 * The data may contain a null - so we use fwrite().
	 */
	if (TRACE) {
	    CTRACE((tfp, "Query %d{", BStrLen(my_query)));
	    trace_bstring(my_query);
	    CTRACE((tfp, "}\n"));
	}
d8810 1
d8814 20
a8833 10
	HTSABCat(&my_query, "", 1);	/* append null */
	mailform((submit_item->submit_action + 7),
		 (isEmpty(submit_item->submit_title)
		  ? NonNull(HText_getTitle())
		  : submit_item->submit_title),
		 BStrData(my_query),
		 content_type_out);
	result = 0;
	BStrFree(my_query);
	FREE(content_type_out);
a8835 14

	if (submit_item->submit_method == URL_POST_METHOD || Boundary) {
	    LYFreePostData(doc);
	    doc->post_data = my_query;
	    doc->post_content_type = content_type_out;	/* don't free c_t_out */
	    CTRACE((tfp, "GridText - post_data set:\n%s\n", content_type_out));
	    StrAllocCopy(doc->address, submit_item->submit_action);
	} else {		/* GET_METHOD */
	    HTSABCat(&my_query, "", 1);		/* append null */
	    StrAllocCopy(doc->address, BStrData(my_query));	/* FIXME? */
	    LYFreePostData(doc);
	    FREE(content_type_out);
	}
	result = 1;
d8838 12
a8849 10
    FREE(MultipartContentType);
    FREE(previous_blanks);
    FREE(Boundary);
    if (my_data != 0) {
	for (anchor_count = 0; anchor_count < anchor_limit; ++anchor_count) {
	    FREE(my_data[anchor_count].name);
	    FREE(my_data[anchor_count].value);
	    BStrFree(my_data[anchor_count].data);
	}
	FREE(my_data);
a8850 2

    return (result);
d8853 1
a8853 1
void HText_DisableCurrentForm(void)
d8855 1
a8855 1
    TextAnchor *anchor_ptr;
d8862 1
a8862 1
     * Go through list of anchors and set the disabled flag.
d8864 2
a8865 3
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
d8871 5
d8881 2
a8882 1
void HText_ResetForm(FormInfo * form)
d8884 1
a8884 1
    TextAnchor *anchor_ptr;
d8891 1
a8891 1
     * Go through list of anchors and reset values.
d8893 2
a8894 3
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
d8909 1
a8909 1
			anchor_ptr->input_field->orig_value;
d8912 1
a8912 1
			anchor_ptr->input_field->orig_submit_value;
d8922 5
d8935 1
a8935 1
BOOLEAN HText_HaveUserChangedForms(HText *text)
d8937 1
a8937 1
    TextAnchor *anchor_ptr;
d8939 2
a8940 2
    if (text == 0)
	return FALSE;
d8943 2
a8944 2
     * Go through list of anchors to check if any value was changed.
     * This code based on HText_ResetForm()
d8946 2
a8947 3
    for (anchor_ptr = text->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
d8974 4
d8982 2
a8983 1
void HText_activateRadioButton(FormInfo * form)
d8985 1
a8985 1
    TextAnchor *anchor_ptr;
d8990 2
a8991 3
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
d8993 1
a8993 1
	    anchor_ptr->input_field->type == F_RADIO_TYPE) {
d8997 3
a8999 3
		/* if it has the same name and its on */
		if (!strcmp(anchor_ptr->input_field->name, form->name) &&
		    anchor_ptr->input_field->num_value) {
d9002 1
a9002 1
		}
d9004 1
a9004 1
		break;
a9007 1
    }
d9009 7
a9015 1
    form->num_value = 1;
d9029 1
a9029 1
static void free_all_texts(void)
d9037 1
a9037 1
     * Simply loop through the loaded texts list killing them off.
d9040 3
a9042 1
	if ((cur = (HText *) HTList_removeLastObject(loaded_texts)) != NULL) {
d9048 1
a9048 1
     * Get rid of the text list.
d9055 1
a9055 1
     * Insurance for bad HTML.
d9071 8
a9078 7
 *  stub_HTAnchor_address is like HTAnchor_address, but it returns the
 *  parent address for child links.  This is only useful for traversal's
 *  where one does not want to index a text file N times, once for each
 *  of N internal links.  Since the parent link has already been taken,
 *  it won't go again, hence the (incorrect) links won't cause problems.
 */
char *stub_HTAnchor_address(HTAnchor * me)
a9080 1

d9082 1
a9082 1
	StrAllocCopy(addr, me->parent->address);
d9086 2
a9087 1
void HText_setToolbar(HText *text)
d9094 2
a9095 1
BOOL HText_hasToolbar(HText *text)
d9097 1
a9097 1
    return (BOOL) ((text && text->toolbar) ? TRUE : FALSE);
d9100 2
a9101 1
void HText_setNoCache(HText *text)
d9108 2
a9109 1
BOOL HText_hasNoCacheSet(HText *text)
d9111 1
a9111 1
    return (BOOL) ((text && text->no_cache) ? TRUE : FALSE);
d9114 2
a9115 1
BOOL HText_hasUTF8OutputSet(HText *text)
d9117 1
a9117 1
    return (BOOL) ((text && text->T.output_utf8) ? TRUE : FALSE);
d9121 13
a9133 11
 *  Check charset and set the kcode element. -FM
 *  Info on the input charset may be passed in in two forms,
 *  as a string (if given explicitly) and as a pointer to
 *  a LYUCcharset (from chartrans mechanism); either can be NULL.
 *  For Japanese the kcode will be reset at a space or explicit
 *  line or paragraph break, so what we set here may not last for
 *  long.  It's potentially more important not to set HTCJK to
 *  NOCJK unless we are sure. - kw
 */
void HText_setKcode(HText *text, const char *charset,
		    LYUCcharset *p_in)
a9134 2
    BOOL charset_explicit;

d9139 2
a9140 2
     * Check whether we have some kind of info.  - kw
     */
a9143 1
    charset_explicit = charset ? TRUE : FALSE;
d9145 2
a9146 2
     * If no explicit charset string, use the implied one.  - kw
     */
d9151 2
a9152 2
     * Check whether we have a specified charset.  -FM
     */
d9158 7
a9164 14
     * We've included the charset, and not forced a download offer,
     * only if the currently selected character set can handle it,
     * so check the charset value and set the text->kcode element
     * appropriately.  -FM
     */
    /*  If charset isn't specified explicitely nor assumed,
     * p_in->MIMEname would be set as display charset.
     * So text->kcode sholud be set as SJIS or EUC here only if charset
     * is specified explicitely, otherwise text->kcode would cause
     * mishandling Japanese strings.  -- TH
     */
    if (charset_explicit && (!strcmp(charset, "shift_jis") ||
			     !strcmp(charset, "x-sjis") ||	/* 1997/11/28 (Fri) 18:11:33 */
			     !strcmp(charset, "x-shift-jis"))) {
d9166 13
a9178 16
    } else if (charset_explicit
#ifdef EXP_JAPANESEUTF8_SUPPORT
	       && strcmp(charset, "utf-8")
#endif
	       && ((p_in && (p_in->enc == UCT_ENC_CJK)) ||
		   !strcmp(charset, "x-euc") ||		/* 1997/11/28 (Fri) 18:11:24 */
		   !strcmp(charset, "euc-jp") ||
		   !strncmp(charset, "x-euc-", 6) ||
		   !strcmp(charset, "euc-kr") ||
		   !strcmp(charset, "iso-2022-kr") ||
		   !strcmp(charset, "big5") ||
		   !strcmp(charset, "cn-big5") ||
		   !strcmp(charset, "euc-cn") ||
		   !strcmp(charset, "gb2312") ||
		   !strncmp(charset, "cn-gb", 5) ||
		   !strcmp(charset, "iso-2022-cn"))) {
d9182 3
a9184 3
	 * If we get to here, it's not CJK, so disable that if
	 * it is enabled.  But only if we are quite sure.  -FM & kw
	 */
d9187 1
a9187 5
	    if (!p_in || ((p_in->enc != UCT_ENC_CJK)
#ifdef EXP_JAPANESEUTF8_SUPPORT
			  && (p_in->enc != UCT_ENC_UTF8)
#endif
		)) {
a9188 16
	    }
	}
    }

    if (charset_explicit
#ifdef EXP_JAPANESEUTF8_SUPPORT
	&& strcmp(charset, "utf-8")
#endif
	) {
	text->specified_kcode = text->kcode;
    } else {
	if (UCAssume_MIMEcharset) {
	    if (!strcmp(UCAssume_MIMEcharset, "euc-jp"))
		text->kcode = text->specified_kcode = EUC;
	    else if (!strcmp(UCAssume_MIMEcharset, "shift_jis"))
		text->kcode = text->specified_kcode = SJIS;
d9196 4
a9199 3
 *  Set a permissible split at the current end of the last line. -FM
 */
void HText_setBreakPoint(HText *text)
d9205 1
a9205 1
     * Can split here.  -FM
d9213 15
a9227 14
 *  This function determines whether a document which
 *  would be sought via the a URL that has a fragment
 *  directive appended is otherwise identical to the
 *  currently loaded document, and if so, returns
 *  FALSE, so that any no_cache directives can be
 *  overridden "safely", on the grounds that we are
 *  simply acting on the equivalent of a paging
 *  command.  Otherwise, it returns TRUE, i.e, that
 *  the target document might differ from the current,
 *  based on any caching directives or analyses which
 *  claimed or suggested this. -FM
 */
BOOL HText_AreDifferent(HTParentAnchor *anchor,
			const char *full_address)
d9232 1
d9235 2
a9236 2
     * Do we have a loaded document and both
     * arguments for this function?
d9242 1
a9242 1
     * Do we have both URLs?
d9249 1
a9249 1
     * Do we have a fragment associated with the target?
d9251 1
a9251 1
    if (findPoundSelector(full_address) == NULL)
d9255 3
a9257 3
     * Always treat client-side image map menus
     * as potentially stale, so we'll create a
     * fresh menu from the LynxMaps HTList.
d9259 1
a9259 1
    if (isLYNXIMGMAP(anchor->address))
d9263 1
a9263 1
     * Do the docs differ in the type of request?
d9269 9
a9277 8
     * Are the actual URLs different, after factoring
     * out a "LYNXIMGMAP:" leader in the MainText URL
     * and its fragment, if present?
     */
    MTaddress = (isLYNXIMGMAP(MTanc->address)
		 ? MTanc->address + LEN_LYNXIMGMAP
		 : MTanc->address);
    MTpound = trimPoundSelector(MTaddress);
d9279 7
a9285 2
	restorePoundSelector(MTpound);
	return (TRUE);
a9286 1
    restorePoundSelector(MTpound);
d9289 2
a9290 2
     * If the MainText is not an image map menu,
     * do the docs have different POST contents?
d9295 1
a9295 1
		if (!BINEQ(MTanc->post_data, anchor->post_data)) {
d9297 1
a9297 1
		     * Both have contents, and they differ.
d9299 1
a9299 1
		    return (TRUE);
d9303 2
a9304 2
		 * The loaded document has content, but the
		 * target doesn't, so they're different.
d9306 1
a9306 1
		return (TRUE);
d9310 2
a9311 2
	     * The loaded document does not have content, but
	     * the target does, so they're different.
d9313 1
a9313 1
	    return (TRUE);
d9318 3
a9320 3
     * We'll assume the target is a position in the currently
     * displayed document, and thus can ignore any header, META,
     * or other directives not to use a cached rendition.  -FM
d9322 1
a9322 1
    return (FALSE);
a9324 2
#define CanTrimTextArea(c) \
    (LYtrimInputFields ? isspace(c) : ((c) == '\r' || (c) == '\n'))
d9327 5
a9331 5
 * Cleanup new lines coming into a TEXTAREA from an external editor, or a
 * file, such that they are in a suitable format for TEXTAREA rendering,
 * display, and manipulation.  That means trimming off trailing whitespace
 * from the line, expanding TABS into SPACES, and substituting a printable
 * character for control chars, and the like.
d9333 1
a9333 1
 * --KED 02/24/99
d9335 3
a9337 2
static void cleanup_line_for_textarea(char *line,
				      int len)
d9339 1
a9339 1
    char tbuf[MAX_LINE];
d9344 3
a9346 2
    int i;
    int n;
d9349 1
a9349 1
     * Whack off trailing whitespace from the line.
d9352 1
a9352 1
	if (CanTrimTextArea(UCH(*p)))
d9358 1
a9358 1
    if (strlen(line) != 0) {
d9360 1
a9360 1
	 * Expand any tab's, since they won't render properly in a TEXTAREA.
d9362 3
a9364 3
	 * [Is that "by spec", or just a "lynxism"?  As may be, it seems that
	 * such chars may cause other problems, too ...  with cursor movement,
	 * submit'ing, etc.  Probably needs looking into more deeply.]
d9370 5
a9374 5
	    if ((cp = strchr(p, '\t')) != 0) {
		i = cp - p;
		s = (strncpy(s, p, i)) + i;
		n = TABSTOP - (i % TABSTOP);
		s = (strncpy(s, SPACES, n)) + n;
d9379 1
a9379 1
		strcpy(s, p);
d9385 8
a9392 8
	 * Replace control chars with something printable.  Note that char
	 * substitution above 0x7f is dependent on the charset being used,
	 * and then only applies to the contiguous run of char values that
	 * are between 0x80, and the 1st real high-order-bit-set character,
	 * as specified by the charset.  In general (ie, for many character
	 * sets), that usually means the so-called "C1 control chars" that
	 * range from 0x80 thru 0x9f.  For EBCDIC machines, we only trim the
	 * (control) chars below a space (x'40').
d9394 2
a9395 2
	 * The assumption in all this is that the charset used in the editor,
	 * is compatible with the charset specified in lynx.
d9397 8
a9404 8
	 * [At some point in time, when/if lynx ever supports multibyte chars
	 * internally (eg, UCS-2, UCS-4, UTF-16, etc), this kind of thing may
	 * well cause problems.  But then, supporting such char sets will
	 * require massive changes in (most) all parts of the lynx code, so
	 * until then, we do the rational thing with char values that would
	 * otherwise foul the display, if left alone.  If you're implementing
	 * multibyte character set support, consider yourself to have been
	 * warned.]
d9406 1
a9406 1
	for (p = line, s = tbuf; *s != '\0'; p++, s++) {
d9408 6
a9413 6
	    *p = ((UCH(*s) < UCH(' ')) ||
		  (UCH(*s) == UCH('\177')) ||
		  ((UCH(*s) > UCH('\177')) &&
		   (UCH(*s) <
		    UCH(LYlowest_eightbit[current_char_set]))))
		? (char) SPLAT : *s;
d9415 1
a9415 1
	    *p = (UCH(*s) < UCH(' ')) ? SPLAT : *s;
a9416 1
	}
d9423 1
d9425 10
a9434 10
 * Re-render the text of a tagged ("[123]") HTLine (arg1), with the tag
 * number incremented by some value (arg5).  The re-rendered string may
 * be allowed to expand in the event of a tag width change (eg, 99 -> 100)
 * as controlled by arg6 (CHOP or NOCHOP).  Arg4 is either (the address
 * of) a value which must match, in order for the tag to be incremented,
 * or (the address of) a 0-value, which will match any value, and cause
 * any valid tag to be incremented.  Arg2 is a pointer to the first/only
 * anchor that exists on the line; we may need to adjust their position(s)
 * on the line.  Arg3 when non-0 indicates the number of new digits that
 * were added to the 2nd line in a line crossing pair.
d9436 2
a9437 2
 * All tags fields in a line which individually match an expected new value,
 * are incremented.  Line crossing [tags] are handled (PITA).
d9439 1
a9439 1
 * Untagged or improperly tagged lines are not altered.
d9441 2
a9442 2
 * Returns the number of chars added to the original string's length, if
 * any.
d9444 1
a9444 1
 * --KED 02/03/99
d9446 7
a9452 4
static int increment_tagged_htline(HTLine *ht, TextAnchor *a, int *lx_val,
				   int *old_val,
				   int incr,
				   int mode)
d9454 2
a9455 2
    char buf[MAX_LINE];
    char lxbuf[MAX_LINE * 2];
d9457 1
a9457 1
    TextAnchor *st_anchor = a;
d9460 3
a9462 3
    char *p = ht->data;
    char *s = buf;
    char *lx = lxbuf;
d9465 2
a9466 2
    BOOLEAN plx = FALSE;
    BOOLEAN valid;
d9468 16
a9483 16
    int val;
    int n;
    int new_n;
    int pre_n;
    int post_n;
    int fixup = 0;

    /*
     * Cleanup for the 2nd half of a line crosser, whose number of tag
     * digits grew by some number of places (usually 1 when it does
     * happen, though it *could* be more).  The tag chars were already
     * rendered into the 2nd line of the pair, but the positioning and
     * other effects haven't been rippled through any other anchors on
     * the (2nd) line.  So we do that here, as a special case, since
     * the part of the tag that's in the 2nd line of the pair, will not
     * be found by the tag string parsing code.  Double PITA.
d9485 1
a9485 1
     * [see comments below on line crosser caused problems]
d9493 1
a9493 1
	fixup = *lx_val;
d9495 1
a9495 2
	if (st_anchor)
	    st_anchor = st_anchor->next;
d9499 1
a9499 1
     * Walk thru the line looking for tags (ie, "[nnn]" strings).
d9501 2
a9502 2
    while (*p != '\0') {
	if (*p != '[') {
d9507 4
a9510 4
	    *s++ = *p++;
	    t = p;
	    n = 0;
	    valid = TRUE;	/* p = t = byte after '[' */
d9513 1
a9513 1
	     * Make sure there are only digits between "[" and "]".
d9515 2
a9516 2
	    while (*t != ']') {
		if (*t == '\0') {	/* uhoh - we have a potential line crosser */
d9518 1
a9518 1
		    plx = TRUE;
d9521 1
a9521 1
		if (isdigit(UCH(*t++))) {
d9531 3
a9533 3
	     * If the format is OK, we check to see if the value is what
	     * we expect.  If not, we have a random [nn] string in the text,
	     * and leave it alone.
d9535 12
a9546 12
	     * [It is *possible* to have a false match here, *if* there are
	     * two identical [nn] strings (including the numeric value of
	     * nn), one of which is the [tag], and the other being part of
	     * a document.  In such a case, the 1st [nn] string will get
	     * incremented; the 2nd one won't, which makes it a 50-50 chance
	     * of being correct, if and when such an unlikely juxtaposition
	     * of text ever occurs.  Further validation tests of the [nnn]
	     * string are probably not possible, since little of the actual
	     * anchor-associated-text is retained in the TextAnchor or the
	     * FormInfo structs.  Fortunately, I think the current method is
	     * more than adequate to weed out 99.999% of any possible false
	     * matches, just as it stands.  Caveat emptor.]
d9549 2
a9550 2
		val = atoi(p);
		if ((val == *old_val) || (*old_val == 0)) {	/* 0 matches all */
d9554 2
a9555 2
		    sprintf(s, "%d", val);
		    new_n = strlen(s);
d9560 4
a9563 4
		     * If the number of digits in an existing [tag] increased
		     * (eg, [99] --> [100], etc), we need to "adjust" its
		     * horizontal position, and that of all subsequent tags
		     * that may be on the same line.  PITA.
d9565 11
a9575 11
		     * [This seems to work as long as a tag isn't a line
		     * crosser; when it is, the position of anchors on either
		     * side of the split tag, seem to "float" and try to be
		     * as "centered" as possible.  Which means that simply
		     * incrementing the line_pos by the fixed value of the
		     * number of digits that got added to some tag in either
		     * line doesn't work quite right, and the text for (say)
		     * a button may get stomped on by another copy of itself,
		     * but offset by a few chars, when it is selected (eg,
		     * "Box Office" may end up looking like "BoBox Office" or
		     * "Box Officece", etc.
d9577 2
a9578 2
		     * Dunno how to fix that behavior ATT, but at least the
		     * tag numbers themselves are correct.  -KED /\oo/\ ]
d9580 1
a9580 1
		    if ((new_n -= n) != 0) {
d9582 1
a9582 1
			while ((nxt_anchor) &&
d9587 1
a9587 2
			if (st_anchor)
			    st_anchor = st_anchor->next;
d9590 1
a9590 1
	    }
d9593 7
a9599 7
	     * Unfortunately, valid [tag] strings *can* be split across two
	     * lines.  Perhaps it would be best to just prevent that from
	     * happening, but a look into that code, makes me wonder.  Anyway,
	     * we can handle such tags without *too* much trouble in here [I
	     * think], though since such animals are rather rare, it makes it
	     * a bit difficult to test thoroughly (ie, Beyond here, there be
	     * Dragons).
d9601 1
a9601 1
	     * We use lxbuf[] to deal with the two lines involved.
d9603 4
a9606 6
	    pre_n = strlen(p);	/* count of 1st part chars in this line */
	    post_n = strlen(ht->next->data);
	    if (plx
		&& (pre_n + post_n + 2 < (int) sizeof(lxbuf))) {
		strcpy(lx, p);	/* <- 1st part of a possible lx'ing tag */
		strcat(lx, ht->next->data);	/* tack on NEXT line          */
d9608 2
a9609 2
		t = lx;
		n = 0;
d9613 1
a9613 1
		 * Go hunting again for just digits, followed by tag end ']'.
d9616 1
a9616 1
		    if (isdigit(UCH(*t++))) {
d9626 7
a9632 9
		 * It *looks* like a line crosser; now we value test it to
		 * find out for sure [but see the "false match" warning,
		 * above], and if it matches, increment it into the buffer,
		 * along with the 2nd line's text.
		 */
		if ((valid)
		    && (n > 0)
		    && (n + post_n + 2) < MAX_LINE) {
		    val = atoi(lx);
d9637 3
a9639 3
			sprintf(lx, "%d", val);
			new_n = strlen(lx);
			strcat(lx, strchr(ht->next->data, ']'));
d9642 4
a9645 4
			 * We keep the the same number of chars from the
			 * adjusted tag number in the current line; any
			 * extra chars due to a digits increase, will be
			 * stuffed into the next line.
d9647 2
a9648 2
			 * Keep track of any digits added, for the next
			 * pass through.
d9650 1
a9650 1
			s = strncpy(s, lx, pre_n) + pre_n;
d9652 1
a9652 1
			strcpy(ht->next->data, lx);
d9657 1
a9657 1
		break;		/* had an lx'er, so we're done with this line */
d9664 2
a9665 2
    n = strlen(ht->data);
    if (mode == CHOP) {
d9667 1
a9667 19
    } else if (strlen(buf) > ht->size) {
	/* we didn't allocate enough space originally - increase it */
	HTLine *temp;

	allocHTLine(temp, strlen(buf));
	if (!temp)
	    outofmem(__FILE__, "increment_tagged_htline");
	memcpy(temp, ht, LINE_SIZE(0));
#if defined(USE_COLOR_STYLE)
	POOLallocstyles(temp->styles, ht->numstyles);
	if (!temp->styles)
	    outofmem(__FILE__, "increment_tagged_htline");
	memcpy(temp->styles, ht->styles, sizeof(HTStyleChange) * ht->numstyles);
#endif
	ht = temp;
	ht->prev->next = ht;	/* Link in new line */
	ht->next->prev = ht;	/* Could be same node of course */
    }
    strcpy(ht->data, buf);
d9669 1
a9669 1
    return (strlen(buf) - n + fixup);
d9672 1
d9674 3
a9676 3
 * Creates a new anchor and associated struct's appropriate for a form
 * TEXTAREA, and links them into the lists following the current anchor
 * position (as specified by arg1).
d9678 2
a9679 2
 * Exits with arg1 now pointing at the new TextAnchor, and arg2 pointing
 * at the new, associated HTLine.
d9681 1
a9681 1
 * --KED 02/13/99
d9683 3
a9685 1
static void insert_new_textarea_anchor(TextAnchor **curr_anchor, HTLine **exit_htline)
d9688 1
a9688 1
    HTLine *htline;
d9691 2
a9692 2
    FormInfo *f = 0;
    HTLine *l = 0;
d9694 2
a9695 2
    int curr_tag = 0;		/* 0 ==> match any [tag] number */
    int lx = 0;			/* 0 ==> no line crossing [tag]; it's a new line */
d9698 1
d9700 2
a9701 2
     * Find line in the text that matches ending anchorline of
     * the TEXTAREA.
d9703 5
a9707 5
     * [Yes, Virginia ...  we *do* have to go thru this for each
     * anchor being added, since there is NOT a 1-to-1 mapping
     * between anchors and htlines.  I suppose we could create
     * YAS (Yet Another Struct), but there are too many structs{}
     * floating around in here, as it is.  IMNSHO.]
d9709 2
a9710 2
    for (htline = FirstHTLine(HTMainText), i = 0;
	 anchor->line_num != i; i++) {
d9717 2
a9718 2
     * Clone and initialize the struct's needed to add a new TEXTAREA
     * anchor.
d9720 3
a9722 5
    allocHTLine(l, MAX_LINE);
    POOLtypecalloc(TextAnchor, a);

    POOLtypecalloc(FormInfo, f);
    if (a == NULL || l == NULL || f == NULL)
d9727 15
a9741 12
    a->next = anchor->next;
    a->number = anchor->number;
    a->line_pos = anchor->line_pos;
    a->extent = anchor->extent;
    a->line_num = anchor->line_num + 1;
    LYCopyHiText(a, anchor);
    a->link_type = anchor->link_type;
    a->input_field = f;
    a->show_anchor = anchor->show_anchor;
    a->inUnderline = anchor->inUnderline;
    a->expansion_anch = TRUE;
    a->anchor = NULL;
d9745 8
a9752 9
    StrAllocCopy(f->name, anchor->input_field->name);
    f->number = anchor->input_field->number;
    f->type = anchor->input_field->type;
    StrAllocCopy(f->orig_value, "");
    f->size = anchor->input_field->size;
    f->maxlength = anchor->input_field->maxlength;
    f->no_cache = anchor->input_field->no_cache;
    f->disabled = anchor->input_field->disabled;
    f->value_cs = current_char_set;	/* use current setting - kw */
d9755 7
a9761 4
    l->next = htline->next;
    l->prev = htline;
    l->offset = htline->offset;
    l->size = htline->size;
d9764 1
a9764 3
    l->numstyles = htline->numstyles;
    /*we fork the pointers! */
    l->styles = htline->styles;
d9766 2
a9767 9
    strcpy(l->data, htline->data);

    /*
     * Link in the new HTLine.
     */
    htline->next->prev = l;
    htline->next = l;

    if (fields_are_numbered()) {
d9769 1
a9769 1
	increment_tagged_htline(l, a, &lx, &curr_tag, 1, CHOP);
d9773 2
a9774 2
     * If we're at the tail end of the TextAnchor or HTLine list(s),
     * the new node becomes the last node.
d9782 2
a9783 2
     * Link in the new TextAnchor and point the entry anchor arg at it;
     * point the entry HTLine arg at it, too.
d9786 1
a9786 1
    *curr_anchor = a;
d9788 3
a9790 1
    *exit_htline = l->next;
d9795 1
d9797 2
a9798 2
 * If new anchors were added to expand a TEXTAREA, we need to ripple the
 * new line numbers [and char counts ?] thru the subsequent anchors.
d9800 2
a9801 2
 * If form lines are getting [nnn] tagged, we need to update the displayed
 * tag values to match (which means rerendering them ...  sigh).
d9803 1
a9803 1
 * Finally, we need to update various HTMainText and other counts, etc.
d9805 2
a9806 2
 * [dunno if the char counts really *need* to be done, or if we're using
 * the exactly proper values/algorithms ...  seems to be OK though ...]
d9808 1
a9808 1
 * --KED 02/13/99
d9810 5
a9814 4
static void update_subsequent_anchors(int newlines,
				      TextAnchor *start_anchor,
				      HTLine *start_htline,
				      int start_tag)
d9817 8
a9824 1
    HTLine *htline = start_htline;
a9825 5
    int line_adj = 0;
    int tag_adj = 0;
    int lx = 0;
    int hang = 0;		/* for HANG detection of a nasty intermittent */
    int hang_detect = 100000;	/* ditto */
d9827 1
a9827 1
    CTRACE((tfp, "GridText: adjusting struct's to add %d new line(s)\n", newlines));
d9830 1
a9830 1
     * Update numeric fields of the rest of the anchors.
d9832 4
a9835 4
     * [We bypass bumping ->number if it has a value of 0, which takes care
     * of the ->input_field->type == F_HIDDEN_TYPE (as well as any other
     * "hidden" anchors, if such things exist).  Seems like the "right
     * thing" to do.  I think.]
d9837 1
a9837 1
    anchor = start_anchor->next;	/* begin updating with the NEXT anchor */
d9839 1
a9839 1
	if (fields_are_numbered() &&
d9841 3
a9843 2
	    anchor->number += newlines;
	anchor->line_num += newlines;
d9848 1
a9848 1
     * Update/rerender anchor [tags], if they are being numbered.
d9850 6
a9855 6
     * [If a number tag (eg, "[177]") is itself broken across a line
     * boundary, this fixup only partially works.  While the tag
     * numbering is done properly across the pair of lines, the
     * horizontal positioning on *either* side of the split, can get
     * out of sync by a char or two when it gets selected.  See the
     * [comments] in increment_tagged_htline() for some more detail.
d9857 3
a9859 3
     * I suppose THE fix is to prevent such tag-breaking in the first
     * place (dunno where yet, though).  Ah well ...  at least the tag
     * numbers themselves are correct from top to bottom now.
d9861 7
a9867 7
     * All that said, about the only time this will be a problem in
     * *practice*, is when a page has near 1000 links or more (possibly
     * after a TEXTAREA expansion), and has line crossing tag(s), and
     * the tag numbers in a line crosser go from initially all 3 digit
     * numbers, to some mix of 3 and 4 digits (or all 4 digits) as a
     * result of the expansion process.  Oh, you also need a "clump" of
     * anchors all on the same lines.
d9869 2
a9870 2
     * Yes, it *can* happen, but in real life, it probably won't be
     * seen very much ...]
d9872 4
a9875 4
     * [This may also be an artifact of bumping into the right hand
     * screen edge (or RHS margin), since we don't even *think* about
     * relocating an anchor to the following line, when [tag] digits
     * expansion pushes things too far in that direction.]
d9877 1
a9877 1
    if (fields_are_numbered()) {
d9879 1
a9879 1
	while (htline != FirstHTLine(HTMainText)) {
d9882 1
a9882 1
		if ((anchor->number - newlines) == start_tag)
d9885 17
a9901 17
		/*** A HANG (infinite loop) *has* occurred here, with */
		/*** the values of anchor and anchor->next being the  */
		/*** the same, OR with anchor->number "magically" and */
		/*** suddenly taking on an anchor-pointer-like value. */
		/***                                                  */
		/*** The same code and same doc have both passed and  */
		/*** failed at different times, which indicates some  */
		/*** sort of content/html dependency, or some kind of */
		/*** a "race" condition, but I'll be damned if I can  */
		/*** find it after tons of CTRACE's, printf()'s, gdb  */
		/*** breakpoints and watchpoints, etc.                */
		/***                                                  */
		/*** I have added a hang detector (with error msg and */
		/*** beep) here, to break the loop and warn the user, */
		/*** until it can be isolated and fixed.              */
		/***                                                  */
		/*** [One UGLY intermittent .. gak ..!  02/22/99 KED] */
d9911 2
a9912 3
		line_adj = increment_tagged_htline(htline, anchor, &lx,
						   &start_tag, newlines,
						   NOCHOP);
d9914 1
a9914 1
		tag_adj += line_adj;
d9918 1
a9918 1
		break;		/* out of anchors ... we're done */
d9925 1
a9925 1
  finish:
d9927 1
a9927 1
     * Fixup various global variables.
d9929 4
a9932 3
    nlinks += newlines;
    HTMainText->Lines += newlines;
    HTMainText->last_anchor_number += newlines;
d9936 1
a9936 1
    CTRACE((tfp, "GridText: TextAnchor and HTLine struct's adjusted\n"));
d9940 1
a9940 1
  hang_detected:		/* ugliness has happened; inform user and do the best we can */
d9942 5
a9946 2
    HTAlert(gettext("Hang Detect: TextAnchor struct corrupted - suggest aborting!"));
    goto finish;
d9949 1
d9951 4
a9954 4
 * Transfer the initial contents of a TEXTAREA to a temp file, invoke the
 * user's editor on that file, then transfer the contents of the resultant
 * edited file back into the TEXTAREA (expanding the size of the area, if
 * required).
d9956 3
a9958 3
 * Returns the number of lines that the cursor should be moved so that it
 * will end up on the 1st blank line of whatever number of trailing blank
 * lines there are in the TEXTAREA (there will *always* be at least one).
d9960 1
a9960 1
 * --KED 02/01/99
d9962 2
a9963 1
int HText_ExtEditForm(LinkInfo * form_link)
d9966 1
a9966 1
    size_t size;
d9968 2
a9969 2
    char *ed_temp;
    FILE *fp;
d9972 26
a9997 28
    TextAnchor *start_anchor = NULL;
    TextAnchor *end_anchor = NULL;
    BOOLEAN firstanchor = TRUE;
    BOOLEAN wrapalert = FALSE;

    char ed_offset[10];
    int start_line = 0;
    int entry_line = form_link->anchor_line_num;
    int exit_line = 0;
    int orig_cnt = 0;
    int line_cnt = 1;

    FormInfo *form = form_link->l_form;
    char *areaname = form->name;
    int form_num = form->number;

    HTLine *htline = NULL;

    char *ebuf;
    char *line;
    char *lp;
    char *cp;
    int match_tag = 0;
    int newlines = 0;
    int len, len0, len_in;
    int wanted_fieldlen_wrap = -1;	/* not yet asked; 0 means don't. */
    char *skip_at = NULL;
    int skip_num = 0, i;
d9999 1
a9999 1
    CTRACE((tfp, "GridText: entered HText_ExtEditForm()\n"));
d10001 2
a10002 2
    ed_temp = (char *) malloc(LY_MAXPATH);
    if ((fp = LYOpenTemp(ed_temp, "", "w")) == 0) {
d10008 2
a10009 2
     * Begin at the beginning, to find 1st anchor in the TEXTAREA, then
     * write all of its lines (anchors) out to the edit temp file.
d10011 7
a10017 7
     * [Finding the TEXTAREA we're actually *in* with these attributes
     * isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     * and there *could* be TEXTAREA's with the same "name".  If that
     * should ever be true, we'll actually get the data from the *1st*
     * TEXTAREA in the page that matches.  We should probably assign
     * a unique id to each TEXTAREA in a page, and match on that, to
     * avoid this (potential) problem.
d10019 3
a10021 3
     * Since the odds of "false matches" *actually* happening in real
     * life seem rather small though, we'll hold off doing this, for a
     * rainy day ...]
d10027 4
a10030 4
	if ((anchor_ptr->link_type == INPUT_ANCHOR) &&
	    (anchor_ptr->input_field->type == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num) &&
	    !strcmp(anchor_ptr->input_field->name, areaname)) {
d10033 1
a10033 1
		firstanchor = FALSE;
d10035 1
a10035 1
		start_line = anchor_ptr->line_num;
d10040 1
a10040 1
	     * Write the anchors' text to the temp edit file.
d10042 2
a10043 2
	    fputs(anchor_ptr->input_field->value, fp);
	    fputc('\n', fp);
d10045 1
a10045 1
	} else {
d10049 2
a10050 2
	}
	anchor_ptr = anchor_ptr->next;
d10052 1
a10052 1
    LYCloseTempFP(fp);
d10054 2
a10055 2
    CTRACE((tfp, "GridText: TEXTAREA name=|%s| dumped to tempfile\n", areaname));
    CTRACE((tfp, "GridText: invoking editor (%s) on tempfile\n", editor));
d10058 3
a10060 3
     * Go edit the TEXTAREA temp file, with the initial editor line
     * corresponding to the TEXTAREA line the cursor is on (if such
     * positioning is supported by the editor [as lynx knows it]).
d10062 1
a10062 1
    ed_offset[0] = 0;		/* pre-ANSI compilers don't initialize aggregates - TD */
d10064 9
a10072 1
	sprintf(ed_offset, "%d", ((entry_line - start_line) + 1));
d10074 9
a10082 1
    edit_temporary_file(ed_temp, ed_offset, NULL);
d10084 1
a10084 1
    CTRACE((tfp, "GridText: returned from editor (%s)\n", editor));
d10087 1
a10087 1
     * Read back the edited temp file into our buffer.
d10089 2
a10090 2
    if ((stat(ed_temp, &stat_info) < 0) ||
	!S_ISREG(stat_info.st_mode) ||
d10093 1
a10093 4
	ebuf = typecalloc(char);

	if (!ebuf)
	    outofmem(__FILE__, "HText_ExtEditForm");
d10095 1
a10095 13
	ebuf = typecallocn(char, size + 1);

	if (!ebuf) {
	    /*
	     * This could be huge - don't exit if we don't have enough
	     * memory for it.  With some luck, the user may be even able
	     * to recover the file manually from the temp space while
	     * the lynx session is not over.  - kw
	     */
	    free(ed_temp);
	    HTAlwaysAlert(NULL, MEMORY_EXHAUSTED_FILE);
	    return 0;
	}
d10097 3
a10099 4
	fp = fopen(ed_temp, "r");
	size = fread(ebuf, 1, size, fp);
	LYCloseInput(fp);
	ebuf[size] = '\0';	/* Terminate! - kw */
d10101 2
d10105 1
a10105 1
     * Nuke any blank lines from the end of the edited data.
d10107 1
a10107 2
    while ((size != 0)
	   && (CanTrimTextArea(UCH(ebuf[size - 1])) || (ebuf[size - 1] == '\0')))
d10111 3
a10113 3
     * Copy each line from the temp file into the corresponding anchor
     * struct.  Add new lines to the TEXTAREA if needed.  (Always leave
     * the user with a blank line at the end of the TEXTAREA.)
d10115 1
a10115 1
    if ((line = (char *) malloc(MAX_LINE)) == 0)
a10118 3
    if (anchor_ptr->input_field->size <= 4 ||
	anchor_ptr->input_field->size >= MAX_LINE)
	wanted_fieldlen_wrap = 0;
d10120 2
a10121 2
    len = len_in = 0;
    lp = ebuf;
d10125 2
a10126 14
	if (skip_at) {
	    len0 = skip_at - lp;
	    strncpy(line, lp, len0);
	    line[len0] = '\0';
	    lp = skip_at + skip_num;
	    skip_at = NULL;
	    skip_num = 0;
	} else {
	    len0 = 0;
	}
	line[len0] = '\0';

	if ((cp = strchr(lp, '\n')) != 0)
	    len = len_in = cp - lp;
d10128 1
a10128 1
	    len = len_in = strlen(lp);
d10130 2
a10131 73
	if (wanted_fieldlen_wrap < 0 && !wrapalert &&
	    len0 + len >= start_anchor->input_field->size &&
	    (cp = strchr(lp, ' ')) != NULL &&
	    (cp - lp) < start_anchor->input_field->size - 1) {
	    LYFixCursesOn("ask for confirmation:");
	    LYerase();		/* don't show previous state */
	    if (HTConfirmDefault(gettext("Wrap lines to fit displayed area?"),
				 NO)) {
		wanted_fieldlen_wrap = start_anchor->input_field->size - 1;
	    } else {
		wanted_fieldlen_wrap = 0;
	    }
	}
	if (wanted_fieldlen_wrap > 0 && len0 + len > wanted_fieldlen_wrap) {
	    for (i = wanted_fieldlen_wrap - len0;
		 i + len0 >= wanted_fieldlen_wrap / 4; i--) {
		if (isspace(UCH(lp[i]))) {
		    len = i + 1;
		    cp = lp + i;
		    if (cp[1] != '\n' &&
			isspace(UCH(cp[1])) &&
			!isspace(UCH(cp[2]))) {
			len++;
			cp++;
		    }
		    if (!isspace(UCH(cp[1]))) {
			while (*cp && *cp != '\r' && *cp != '\n' &&
			       (cp - lp) <= len + (3 * wanted_fieldlen_wrap / 4))
			    cp++;	/* search for next line break */
			if (*cp == '\r' && cp[1] == '\n')
			    cp++;
			if (*cp == '\n' &&
			    (cp[1] == '\r' || cp[1] == '\n' ||
			     !isspace(UCH(cp[1])))) {
			    *cp = ' ';
			    while (isspace(UCH(*(cp - 1)))) {
				skip_num++;
				cp--;
			    }
			    skip_at = cp;
			}
		    }
		    break;
		}
	    }
	}
	if (wanted_fieldlen_wrap > 0 && len0 + len > wanted_fieldlen_wrap) {
	    i = len - 1;
	    while (len0 + i + 1 > wanted_fieldlen_wrap &&
		   isspace(UCH(lp[i])))
		i--;
	    if (len0 + i + 1 > wanted_fieldlen_wrap)
		len = wanted_fieldlen_wrap - len0;
	}

	if (len0 + len >= MAX_LINE) {
	    if (!wrapalert) {
		LYFixCursesOn("show alert:");
		HTAlert(gettext("Very long lines have been wrapped!"));
		wrapalert = TRUE;
	    }
	    /*
	     * First try to find a space character for wrapping - kw
	     */
	    for (i = MAX_LINE - len0 - 1; i > 0; i--) {
		if (isspace(UCH(lp[i]))) {
		    len = i;
		    break;
		}
	    }
	    if (len0 + len >= MAX_LINE)
		len = MAX_LINE - len0 - 1;
	}
d10133 1
a10133 4
	strncat(line, lp, len);
	*(line + len0 + len) = '\0';

	cleanup_line_for_textarea(line, len0 + len);
d10136 3
a10138 3
	 * If there are more lines in the edit buffer than were in the
	 * original TEXTAREA, we need to add a new line/anchor, continuing
	 * on until the edit buffer is empty.
d10141 2
a10142 2
	    insert_new_textarea_anchor(&end_anchor, &htline);
	    anchor_ptr = end_anchor;	/* make the new anchor current */
d10147 1
a10147 1
	 * Finally copy the new line from the edit buffer into the anchor.
d10152 2
a10153 2
	 * Keep track of 1st blank line in any trailing blank lines, for
	 * later cursor repositioning.
d10155 1
a10155 1
	if (len0 + len > 0)
d10161 1
a10161 1
	 * And do the next line of edited text, for the next anchor ...
d10164 1
a10164 2
	if (*lp && isspace(UCH(*lp)))
	    lp++;
d10175 1
a10175 1
    CTRACE((tfp, "GridText: edited text inserted into lynx struct's\n"));
d10178 3
a10180 3
     * If we've added any new lines/anchors, we need to adjust various
     * things in all anchor-bearing lines following the last newly added
     * line/anchor.  The fun stuff starts here ...
d10183 1
a10183 1
	update_subsequent_anchors(newlines, end_anchor, htline, match_tag);
d10186 1
a10186 1
     * Cleanup time.
d10190 1
a10190 1
    LYRemoveTemp(ed_temp);
d10193 1
a10193 1
    CTRACE((tfp, "GridText: exiting HText_ExtEditForm()\n"));
d10196 4
a10199 4
     * Return the offset needed to move the cursor from its current
     * (on entry) line number, to the 1st blank line of the trailing
     * (group of) blank line(s), which is where we want to be.  Let
     * the caller deal with moving us there, however ...  :-) ...
d10204 1
d10206 2
a10207 2
 * Expand the size of a TEXTAREA by a fixed number of lines (as specified
 * by arg2).
d10209 1
a10209 1
 * --KED 02/14/99
d10211 3
a10213 1
void HText_ExpandTextarea(LinkInfo * form_link, int newlines)
d10216 2
a10217 2
    TextAnchor *end_anchor = NULL;
    BOOLEAN firstanchor = TRUE;
d10219 3
a10221 3
    FormInfo *form = form_link->l_form;
    char *areaname = form->name;
    int form_num = form->number;
d10223 4
a10226 1
    HTLine *htline = NULL;
a10227 2
    int match_tag = 0;
    int i;
d10229 1
a10229 1
    CTRACE((tfp, "GridText: entered HText_ExpandTextarea()\n"));
d10231 1
a10231 2
    if (newlines < 1)
	return;
d10234 2
a10235 2
     * Begin at the beginning, to find the TEXTAREA, then on to find
     * the last line (anchor) in it.
d10237 7
a10243 7
     * [Finding the TEXTAREA we're actually *in* with these attributes
     * isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     * and there *could* be TEXTAREA's with the same "name".  If that
     * should ever be true, we'll actually expand the *1st* TEXTAREA
     * in the page that matches.  We should probably assign a unique
     * id to each TEXTAREA in a page, and match on that, to avoid this
     * (potential) problem.
d10245 3
a10247 3
     * Since the odds of "false matches" *actually* happening in real
     * life seem rather small though, we'll hold off doing this, for a
     * rainy day ...]
d10253 4
a10256 4
	if ((anchor_ptr->link_type == INPUT_ANCHOR) &&
	    (anchor_ptr->input_field->type == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num) &&
	    !strcmp(anchor_ptr->input_field->name, areaname)) {
d10259 1
a10259 1
		firstanchor = FALSE;
d10263 1
a10263 1
	} else {
d10267 2
a10268 2
	}
	anchor_ptr = anchor_ptr->next;
d10272 1
a10272 1
	insert_new_textarea_anchor(&end_anchor, &htline);
d10275 1
a10275 1
	 * Make the new line blank.
d10280 1
a10280 1
	 * And go add another line ...
d10283 1
a10283 1
	    match_tag = end_anchor->next->number;
d10286 2
a10287 2
    CTRACE((tfp, "GridText: %d blank line(s) added to TEXTAREA name=|%s|\n",
	    newlines, areaname));
d10290 2
a10291 2
     * We need to adjust various things in all anchor bearing lines
     * following the last newly added line/anchor.  Fun stuff.
d10293 1
a10293 1
    update_subsequent_anchors(newlines, end_anchor, htline, match_tag);
d10295 1
a10295 1
    CTRACE((tfp, "GridText: exiting HText_ExpandTextarea()\n"));
d10300 1
d10302 2
a10303 2
 * Insert the contents of a file into a TEXTAREA between the cursor line,
 * and the line preceding it.
d10305 3
a10307 3
 * Returns the number of lines that the cursor should be moved so that it
 * will end up on the 1st line in the TEXTAREA following the inserted file
 * (if we decide to do that).
d10309 1
a10309 1
 * --KED 02/21/99
d10311 2
a10312 1
int HText_InsertFile(LinkInfo * form_link)
d10315 1
a10315 1
    size_t size;
d10317 2
a10318 2
    FILE *fp;
    char *fn;
d10322 6
a10327 7
    TextAnchor *end_anchor = NULL;
    BOOLEAN firstanchor = TRUE;
    BOOLEAN truncalert = FALSE;

    FormInfo *form = form_link->l_form;
    char *areaname = form->name;
    int form_num = form->number;
d10329 1
a10329 1
    HTLine *htline = NULL;
d10332 12
a10343 2
    FormInfo *f = 0;
    HTLine *l = 0;
a10344 10
    char *fbuf;
    char *line;
    char *lp;
    char *cp;
    int entry_line = form_link->anchor_line_num;
    int file_cs;
    int match_tag = 0;
    int newlines = 0;
    int len;
    int i;
d10346 1
a10346 1
    CTRACE((tfp, "GridText: entered HText_InsertFile()\n"));
d10352 2
a10353 3
	HTInfoMsg(FILE_INSERT_CANCELLED);
	CTRACE((tfp,
		"GridText: file insert cancelled - no filename provided\n"));
a10355 6
    if (no_dotfiles || !show_dotfiles) {
	if (*LYPathLeaf(fn) == '.') {
	    HTUserMsg(FILENAME_CANNOT_BE_DOT);
	    return (0);
	}
    }
d10358 1
a10358 1
     * Read it into our buffer (abort on 0-length file).
d10360 1
a10360 1
    if ((stat(fn, &stat_info) < 0) ||
d10362 3
a10364 4
	HTInfoMsg(FILE_INSERT_0_LENGTH);
	CTRACE((tfp,
		"GridText: file insert aborted - file=|%s|- was 0-length\n",
		fn));
d10370 2
a10371 19
	if ((fbuf = typecallocn(char, size + 1)) == NULL) {
	    /*
	     * This could be huge - don't exit if we don't have enough
	     * memory for it.  - kw
	     */
	    free(fn);
	    HTAlert(MEMORY_EXHAUSTED_FILE);
	    return 0;
	}

	/* Try to make the same assumption for the charset of the inserted
	 * file as we would for normal loading of that file, i.e. taking
	 * assume_local_charset and suffix mappings into account.
	 * If there is a mismatch with the display character set, characters
	 * may be displayed wrong, too bad; but the user has a chance to
	 * correct this by editing the lines, which will update f->value_cs
	 * again. - kw
	 */
	LYGetFileInfo(fn, 0, 0, 0, 0, 0, &file_cs);
d10373 3
a10375 9
	fp = fopen(fn, "r");
	if (!fp) {
	    free(fbuf);
	    free(fn);
	    HTAlert(FILE_CANNOT_OPEN_R);
	    return 0;
	}
	size = fread(fbuf, 1, size, fp);
	LYCloseInput(fp);
a10376 1
	fbuf[size] = '\0';	/* Terminate! - kw */
d10379 1
d10381 2
a10382 2
     * Begin at the beginning, to find the TEXTAREA we're in, then
     * the current cursorline.
d10384 7
a10390 7
     * [Finding the TEXTAREA we're actually *in* with these attributes
     * isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     * and there *could* be TEXTAREA's with the same "name".  If that
     * should ever be true, we'll actually insert data into the *1st*
     * TEXTAREA in the page that matches.  We should probably assign
     * a unique id to each TEXTAREA in a page, and match on that, to
     * avoid this (potential) problem.
d10392 3
a10394 3
     * Since the odds of "false matches" *actually* happening in real
     * life seem rather small though, we'll hold off doing this, for a
     * rainy day ...]
d10400 4
a10403 4
	if ((anchor_ptr->link_type == INPUT_ANCHOR) &&
	    (anchor_ptr->input_field->type == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num) &&
	    !strcmp(anchor_ptr->input_field->name, areaname)) {
d10405 2
a10406 2
	    if (anchor_ptr->line_num == entry_line)
		break;
d10409 1
a10409 1
	anchor_ptr = anchor_ptr->next;
d10412 1
d10414 2
a10415 2
     * Clone a new TEXTAREA line/anchor using the cursorline anchor as
     * a template, but link it in BEFORE the cursorline anchor/htline.
d10417 5
a10421 5
     * [We can probably combine this with insert_new_textarea_anchor()
     * along with a flag to indicate "insert before" as we do here,
     * or the "normal" mode of operation (add after "current" anchor/
     * line).  Beware of the differences ...  some are a bit subtle to
     * notice.]
d10423 2
a10424 2
    for (htline = FirstHTLine(HTMainText), i = 0;
	 anchor_ptr->line_num != i; i++) {
d10430 3
a10432 5
    allocHTLine(l, MAX_LINE);
    POOLtypecalloc(TextAnchor, a);

    POOLtypecalloc(FormInfo, f);
    if (a == NULL || l == NULL || f == NULL)
d10437 15
a10451 12
    a->next = anchor_ptr;
    a->number = anchor_ptr->number;
    a->line_pos = anchor_ptr->line_pos;
    a->extent = anchor_ptr->extent;
    a->line_num = anchor_ptr->line_num;
    LYCopyHiText(a, anchor_ptr);
    a->link_type = anchor_ptr->link_type;
    a->input_field = f;
    a->show_anchor = anchor_ptr->show_anchor;
    a->inUnderline = anchor_ptr->inUnderline;
    a->expansion_anch = TRUE;
    a->anchor = NULL;
d10455 8
a10462 9
    StrAllocCopy(f->name, anchor_ptr->input_field->name);
    f->number = anchor_ptr->input_field->number;
    f->type = anchor_ptr->input_field->type;
    StrAllocCopy(f->orig_value, "");
    f->size = anchor_ptr->input_field->size;
    f->maxlength = anchor_ptr->input_field->maxlength;
    f->no_cache = anchor_ptr->input_field->no_cache;
    f->disabled = anchor_ptr->input_field->disabled;
    f->value_cs = (file_cs >= 0) ? file_cs : current_char_set;
d10465 5
a10469 2
    l->offset = htline->offset;
    l->size = htline->size;
d10472 1
a10472 3
    l->numstyles = htline->numstyles;
    /*we fork the pointers! */
    l->styles = htline->styles;
d10474 1
a10474 1
    strcpy(l->data, htline->data);
d10477 2
a10478 2
     * If we're at the head of the TextAnchor list, the new node becomes
     * the first node.
d10484 1
a10484 1
     * Link in the new TextAnchor, and corresponding HTLine.
d10489 3
a10491 3
    htline = htline->prev;
    l->next = htline->next;
    l->prev = htline;
d10493 1
a10493 1
    htline->next = l;
d10496 3
a10498 3
     * update_subsequent_anchors() expects htline to point to 1st potential
     * line needing fixup; we need to do this just in case the inserted file
     * was only a single line (yes, it's pathological ...  ).
d10500 2
a10501 2
    htline = htline->next;	/* ->new (current) htline, for 1st inserted line  */
    htline = htline->next;	/* ->1st potential (following) [tag] fixup htline */
d10506 1
d10508 2
a10509 2
     * Copy each line from the insert file into the corresponding anchor
     * struct.
d10511 1
a10511 1
     * Begin with the new line/anchor we just added (above the cursorline).
d10513 1
a10513 1
    if ((line = (char *) malloc(MAX_LINE)) == 0)
d10519 1
a10519 1
    lp = fbuf;
d10523 2
a10524 2
	if ((cp = strchr(lp, '\n')) != 0)
	    len = cp - lp;
d10526 1
a10526 1
	    len = strlen(lp);
d10528 1
a10528 10
	if (len >= MAX_LINE) {
	    if (!truncalert) {
		HTAlert(gettext("Very long lines have been truncated!"));
		truncalert = TRUE;
	    }
	    len = MAX_LINE - 1;
	    if (lp[len])
		lp[len + 1] = '\0';	/* prevent next iteration */
	}
	strncpy(line, lp, len);
d10531 1
a10531 1
	cleanup_line_for_textarea(line, len);
d10534 2
a10535 2
	 * If not the first line from the insert file, we need to add
	 * a new line/anchor, continuing on until the buffer is empty.
d10538 3
a10540 3
	    insert_new_textarea_anchor(&end_anchor, &htline);
	    anchor_ptr = end_anchor;	/* make the new anchor current */
	    newlines++;
d10544 1
a10544 1
	 * Copy the new line from the buffer into the anchor.
d10549 1
a10549 8
	 * insert_new_textarea_anchor always uses current_char_set,
	 * we may want something else, so fix it up.  - kw
	 */
	if (file_cs >= 0)
	    anchor_ptr->input_field->value_cs = file_cs;

	/*
	 * And do the next line of insert text, for the next anchor ...
d10552 1
a10552 2
	if (*lp)
	    lp++;
d10555 2
a10556 2
	end_anchor = anchor_ptr;
	anchor_ptr = anchor_ptr->next;
d10559 1
a10559 1
    CTRACE((tfp, "GridText: file inserted into lynx struct's\n"));
d10562 2
a10563 2
     * Now adjust various things in all anchor-bearing lines following the
     * last newly added line/anchor.  Some say this is the fun part ...
d10565 2
a10566 1
    update_subsequent_anchors(newlines, end_anchor, htline, match_tag);
d10569 1
a10569 1
     * Cleanup time.
d10574 1
a10574 1
    CTRACE((tfp, "GridText: exiting HText_InsertFile()\n"));
d10585 2
a10586 2
 * drawn.
 *
d10588 10
a10597 6
 * (since no support for lss is availble for Slang) -HV.
 */
#ifdef USE_COLOR_STYLE
static void redraw_part_of_line(HTLine *line, const char *str,
				int len,
				HText *text)
d10601 1
a10601 1
    const char *data, *end_of_data;
a10602 1

d10607 1
a10607 1
    int YP, XP;
d10609 1
a10609 1
    LYGetYX(YP, XP);
d10620 2
a10621 2
    /* this assumes that the part of line to be drawn fits in the screen */
    while (data < end_of_data) {
d10629 4
a10632 3
	       i >= (int) (CStyle.horizpos + line->offset + 1)) {
	    LynxChangeStyle(CStyle.style, CStyle.direction);
	    current_style++;
d10638 8
a10645 8
	case LY_UNDERLINE_START_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		lynx_start_underline();
	    }
	    break;
d10647 8
a10654 8
	case LY_UNDERLINE_END_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		lynx_stop_underline();
	    }
	    break;
d10656 3
a10658 3
	case LY_BOLD_START_CHAR:
	    lynx_start_bold();
	    break;
d10660 3
a10662 3
	case LY_BOLD_END_CHAR:
	    lynx_stop_bold();
	    break;
d10665 3
a10667 19
	case LY_SOFT_NEWLINE:
	    if (!dump_output_immediately)
		LYaddch('+');
	    break;

	case LY_SOFT_HYPHEN:
	    if (*data != '\0' ||
		isspace(UCH(LastDisplayChar)) ||
		LastDisplayChar == '-') {
		/*
		 * Ignore the soft hyphen if it is not the last
		 * character in the line.  Also ignore it if it
		 * first character following the margin, or if it
		 * is preceded by a white character (we loaded 'M'
		 * into LastDisplayChar if it was a multibyte
		 * character) or hyphen, though it should have
		 * been excluded by HText_appendCharacter() or by
		 * split_line() in those cases.  -FM
		 */
a10668 8
	    } else {
		/*
		 * Make it a hard hyphen and fall through.  -FM
		 */
		buffer[0] = '-';
		i++;
	    }
	    /* FALLTHRU */
d10670 21
a10690 260
	default:
	    i++;
	    if (text->T.output_utf8 && is8bits(buffer[0])) {
		utf_extra = utf8_length(text->T.output_utf8, data - 1);
		LastDisplayChar = 'M';
	    }
	    if (utf_extra) {
		strncpy(&buffer[1], data, utf_extra);
		buffer[utf_extra + 1] = '\0';
		LYaddstr(buffer);
		buffer[1] = '\0';
		data += utf_extra;
		utf_extra = 0;
	    } else if (HTCJK != NOCJK && is8bits(buffer[0])) {
		/*
		 * For CJK strings, by Masanobu Kimura.
		 */
		buffer[1] = *data;
		data++;
		LYaddstr(buffer);
		buffer[1] = '\0';
		/*
		 * For now, load 'M' into LastDisplayChar,
		 * but we should check whether it's white
		 * and if so, use ' '.  I don't know if
		 * there actually are white CJK characters,
		 * and we're loading ' ' for multibyte
		 * spacing characters in this code set,
		 * but this will become an issue when
		 * the development code set's multibyte
		 * character handling is used.  -FM
		 */
		LastDisplayChar = 'M';
	    } else {
		LYaddstr(buffer);
		LastDisplayChar = buffer[0];
	    }
	}			/* end of switch */
    }				/* end of while */

#ifndef USE_COLOR_STYLE
    lynx_stop_underline();
    lynx_stop_bold();
#else

    while (current_style < line->numstyles) {
	LynxChangeStyle(CStyle.style, CStyle.direction);
	current_style++;
    }

#undef CStyle
#endif
    return;
}
#endif /* USE_COLOR_STYLE */

#ifndef USE_COLOR_STYLE
/*
 * Function move_to_glyph is called from LYMoveToLink and does all
 * the real work for it.
 * The pair LYMoveToLink()/move_to_glyph() is similar to the pair
 * redraw_lines_of_link()/redraw_part_of_line(), some key differences:
 * LYMoveToLink/move_to_glyph redraw_*
 * -----------------------------------------------------------------
 * - used without color style           - used with color style
 * - handles showing WHEREIS target     - WHEREIS handled elsewhere
 * - handles only one line              - handles first two lines for
 *                                        hypertext anchors
 * - right columns position for UTF-8
 *   by redrawing as necessary
 * - currently used for highlight       - currently used for highlight
 *   ON and OFF                         OFF
 *
 * Eventually the two sets of function should be unified, and should handle
 * UTF-8 positioning, both lines of hypertext anchors, and WHEREIS in all
 * cases.  If possible.  The complex WHEREIS target logic in highlight()
 * could then be completely removed.  - kw
 */
static void move_to_glyph(int YP,
			  int XP,
			  int XP_draw_min,
			  const char *data,
			  int datasize,
			  unsigned offset,
			  const char *target,
			  const char *hightext,
			  int flags,
			  BOOL utf_flag)
{
    char buffer[7];
    const char *end_of_data;
    size_t utf_extra = 0;

#if defined(SHOW_WHEREIS_TARGETS)
    const char *cp_tgt;
    int i_start_tgt = 0, i_after_tgt;
    int HitOffset, LenNeeded;
#endif /* SHOW_WHEREIS_TARGETS */
    BOOL intarget = NO;
    BOOL inunderline = NO;
    BOOL inbold = NO;
    BOOL drawing = NO;
    BOOL inU = NO;
    BOOL hadutf8 = NO;
    BOOL incurlink = NO;
    BOOL drawingtarget = NO;
    BOOL flag = NO;
    const char *sdata = data;
    char LastDisplayChar = ' ';

    int i = (int) offset;	/* FIXME: should be columns, not offset? */
    int last_i = DISPLAY_COLS;
    int XP_link = XP;		/* column of link */
    int XP_next = XP;		/* column to move to when done drawing */
    int linkvlen;

    int len;

    if (flags & 1)
	flag = YES;
    if (flags & 2)
	inU = YES;
    /* Set up the multibyte character buffer  */
    buffer[0] = buffer[1] = buffer[2] = '\0';
    /*
     * Add offset, making sure that we do not
     * go over the COLS limit on the display.
     */
    if (hightext != 0) {
#ifdef WIDEC_CURSES
	len = strlen(hightext);
	last_i = i + LYstrExtent2(data, datasize);
#endif
	linkvlen = LYmbcsstrlen(hightext, utf_flag, YES);
    } else {
	linkvlen = 0;
    }
    if (i >= last_i)
	i = last_i - 1;

    /*
     * Scan through the data, making sure that we do not
     * go over the COLS limit on the display etc.
     */
    len = datasize;
    end_of_data = data + len;

#if defined(SHOW_WHEREIS_TARGETS)
    /*
     * If the target overlaps with the part of this line that
     * we are drawing, it will be emphasized.
     */
    i_after_tgt = i;
    if (target) {
	cp_tgt = LYno_attr_mb_strstr(sdata,
				     target,
				     utf_flag, YES,
				     &HitOffset,
				     &LenNeeded);
	if (cp_tgt) {
	    if ((int) offset + LenNeeded > last_i ||
		((int) offset + HitOffset >= XP + linkvlen)) {
		cp_tgt = NULL;
	    } else {
		i_start_tgt = i + HitOffset;
		i_after_tgt = i + LenNeeded;
	    }
	}
    } else {
	cp_tgt = NULL;
    }
#endif /* SHOW_WHEREIS_TARGETS */

    /*
     * Iterate through the line data from the start, keeping track of
     * the display ("glyph") position in i.  Drawing will be turned
     * on when either the first UTF-8 sequence (that occurs after
     * XP_draw_min) is found, or when we reach the link itself (if
     * highlight is non-NULL).  - kw
     */
    while ((i <= last_i) && data < end_of_data && (*data != '\0')) {

	if (data && hightext && i >= XP && !incurlink) {

	    /*
	     * We reached the position of link itself, and hightext is
	     * non-NULL.  We switch data from being a pointer into the HTLine
	     * to being a pointer into hightext.  Normally (as long as this
	     * routine is applied to normal hyperlink anchors) the text in
	     * hightext will be identical to that part of the HTLine that
	     * data was already pointing to, except that special attribute
	     * chars LY_BOLD_START_CHAR etc., have been stripped out (see
	     * HText_trimHightext).  So the switching should not result in
	     * any different display, but it ensures that it doesn't go
	     * unnoticed if somehow hightext got messed up somewhere else.
	     * This is also useful in preparation for using this function
	     * for something else than normal hyperlink anchors, i.e., form
	     * fields.
	     * Turn on drawing here or make sure it gets turned on before the
	     * next actual normal character is handled.  - kw
	     */
	    data = hightext;
	    len = strlen(hightext);
	    end_of_data = hightext + len;
	    last_i = i + len;
	    XP_next += linkvlen;
	    incurlink = YES;
#ifdef SHOW_WHEREIS_TARGETS
	    if (cp_tgt) {
		if (flag && i_after_tgt >= XP)
		    i_after_tgt = XP - 1;
	    }
#endif
	    /*
	     * The logic of where to set in-target drawing target etc.
	     * and when to react to it should be cleaned up (here and
	     * further below).  For now this seems to work but isn't
	     * very clear.  The complications arise from reproducing
	     * the behavior (previously done in LYhighlight()) for target
	     * strings that fall into or overlap a link:  use target
	     * emphasis for the target string, except for the first
	     * and last character of the anchor text if the anchor is
	     * highlighted as "current link".  - kw
	     */
	    if (!drawing) {
#ifdef SHOW_WHEREIS_TARGETS
		if (intarget) {
		    if (i_after_tgt > i) {
			LYmove(YP, i);
			if (flag) {
			    drawing = YES;
			    drawingtarget = NO;
			    if (inunderline)
				inU = YES;
			    lynx_start_link_color(flag, inU);
			} else {
			    drawing = YES;
			    drawingtarget = YES;
			    LYstartTargetEmphasis();
			}
		    }
		}
#endif /* SHOW_WHEREIS_TARGETS */
	    } else {
#ifdef SHOW_WHEREIS_TARGETS
		if (intarget && i_after_tgt > i) {
		    if (flag && (data == hightext)) {
			drawingtarget = NO;
			LYstopTargetEmphasis();
		    }
		} else if (!intarget)
#endif /* SHOW_WHEREIS_TARGETS */
		{
		    if (inunderline)
			inU = YES;
		    if (inunderline)
			lynx_stop_underline();
		    if (inbold)
			lynx_stop_bold();
		    lynx_start_link_color(flag, inU);
d10693 18
a10710 55
	    }
	}
	if (i >= last_i || data >= end_of_data)
	    break;
	if ((buffer[0] = *data) == '\0')
	    break;
#if defined(SHOW_WHEREIS_TARGETS)
	/*
	 * Look for a subsequent occurrence of the target string,
	 * if we had a previous one and have now stepped past it.  - kw
	 */
	if (cp_tgt && i >= i_after_tgt) {
	    if (intarget) {

		if (incurlink && flag && i == last_i - 1)
		    cp_tgt = NULL;
		else
		    cp_tgt = LYno_attr_mb_strstr(sdata,
						 target,
						 utf_flag, YES,
						 &HitOffset,
						 &LenNeeded);
		if (cp_tgt) {
		    i_start_tgt = i + HitOffset;
		    i_after_tgt = i + LenNeeded;
		    if (incurlink) {
			if (flag && i_start_tgt == XP_link)
			    i_start_tgt++;
			if (flag && i_start_tgt == last_i - 1)
			    i_start_tgt++;
			if (flag && i_after_tgt >= last_i)
			    i_after_tgt = last_i - 1;
			if (flag && i_start_tgt >= last_i)
			    cp_tgt = NULL;
		    } else if (i_start_tgt == last_i) {
			if (flag)
			    i_start_tgt++;
		    }
		}
		if (!cp_tgt || i_start_tgt != i) {
		    intarget = NO;
		    if (drawing) {
			if (drawingtarget) {
			    drawingtarget = NO;
			    LYstopTargetEmphasis();
			    if (incurlink) {
				lynx_start_link_color(flag, inU);
			    }
			}
			if (!incurlink) {
			    if (inbold)
				lynx_start_bold();
			    if (inunderline)
				lynx_start_underline();
			}
d10712 5
a10716 102
		}
	    }
	}
#endif /* SHOW_WHEREIS_TARGETS */

	/*
	 * Advance data to point to the next input char (for the
	 * next round).  Advance sdata, used for searching for a
	 * target string, so that they stay in synch.  As long
	 * as we are not within the highlight text, data and sdata
	 * have identical values.  After we have switched data to
	 * point into hightext, sdata remains a pointer into the
	 * HTLine (so that we don't miss a partial target match at
	 * the end of the anchor text).  So sdata has to sometimes
	 * skip additional special attribute characters that are
	 * not present in highlight in order to stay in synch.  - kw
	 */
	data++;
	if (incurlink) {
	    while (IsNormalChar(*sdata)) {
		++sdata;
	    }
	}

	switch (buffer[0]) {

	case LY_UNDERLINE_START_CHAR:
	    if (!drawing || !incurlink)
		inunderline = YES;
	    if (drawing && !intarget && !incurlink)
		lynx_start_underline();
	    break;

	case LY_UNDERLINE_END_CHAR:
	    inunderline = NO;
	    if (drawing && !intarget && !incurlink)
		lynx_stop_underline();
	    break;

	case LY_BOLD_START_CHAR:
	    if (!drawing || !incurlink)
		inbold = YES;
	    if (drawing && !intarget && !incurlink)
		lynx_start_bold();
	    break;

	case LY_BOLD_END_CHAR:
	    inbold = NO;
	    if (drawing && !intarget && !incurlink)
		lynx_stop_bold();
	    break;

	case LY_SOFT_NEWLINE:
	    if (drawing) {
		LYaddch('+');
	    }
	    i++;
	    break;

	case LY_SOFT_HYPHEN:
	    if (*data != '\0' ||
		isspace(UCH(LastDisplayChar)) ||
		LastDisplayChar == '-') {
		/*
		 * Ignore the soft hyphen if it is not the last
		 * character in the line.  Also ignore it if it
		 * first character following the margin, or if it
		 * is preceded by a white character (we loaded 'M'
		 * into LastDisplayChar if it was a multibyte
		 * character) or hyphen, though it should have
		 * been excluded by HText_appendCharacter() or by
		 * split_line() in those cases.  -FM
		 */
		break;
	    } else {
		/*
		 * Make it a hard hyphen and fall through.  -FM
		 */
		buffer[0] = '-';
	    }
	    /* FALLTHRU */

	default:
	    /*
	     * We have got an actual normal displayable character, or
	     * the start of one.  Before proceeding check whether
	     * drawing needs to be turned on now.  - kw
	     */
#if defined(SHOW_WHEREIS_TARGETS)
	    if (incurlink && intarget && flag && i_after_tgt > i) {
		if (i == last_i - 1) {
		    i_after_tgt = i;
		} else if (i == last_i - 2 && HTCJK != NOCJK &&
			   is8bits(buffer[0])) {
		    i_after_tgt = i;
		    cp_tgt = NULL;
		    if (drawing) {
			if (drawingtarget) {
			    LYstopTargetEmphasis();
			    drawingtarget = NO;
			    lynx_start_link_color(flag, inU);
			}
d10718 1
d10720 11
a10730 86
	    }
	    if (cp_tgt && i >= i_start_tgt && sdata > cp_tgt) {
		if (!intarget ||
		    (intarget && incurlink && !drawingtarget)) {

		    if (incurlink && drawing &&
			!(flag &&
			  (i == XP_link || i == last_i - 1))) {
			lynx_stop_link_color(flag, inU);
		    }
		    if (incurlink && !drawing) {
			LYmove(YP, i);
			if (inunderline)
			    inU = YES;
			if (flag && (i == XP_link || i == last_i - 1)) {
			    lynx_start_link_color(flag, inU);
			    drawingtarget = NO;
			} else {
			    LYstartTargetEmphasis();
			    drawingtarget = YES;
			}
			drawing = YES;
		    } else if (incurlink && drawing &&
			       intarget && !drawingtarget &&
			       (flag &&
				(i == XP_link))) {
			if (inunderline)
			    inU = YES;
			lynx_start_link_color(flag, inU);
		    } else if (drawing &&
			       !(flag &&
				 (i == XP_link || (incurlink && i == last_i - 1)))) {
			LYstartTargetEmphasis();
			drawingtarget = YES;
		    }
		    intarget = YES;
		}
	    } else
#endif /* SHOW_WHEREIS_TARGETS */
	    if (incurlink) {
		if (!drawing) {
		    LYmove(YP, i);
		    if (inunderline)
			inU = YES;
		    lynx_start_link_color(flag, inU);
		    drawing = YES;
		}
	    }

	    i++;
#ifndef WIDEC_CURSES
	    if (utf_flag && is8bits(buffer[0])) {
		hadutf8 = YES;
		utf_extra = utf8_length(utf_flag, data - 1);
		LastDisplayChar = 'M';
	    }
#endif
	    if (utf_extra) {
		strncpy(&buffer[1], data, utf_extra);
		buffer[utf_extra + 1] = '\0';
		if (!drawing && i >= XP_draw_min) {
		    LYmove(YP, i - 1);
		    drawing = YES;
#if defined(SHOW_WHEREIS_TARGETS)
		    if (intarget) {
			drawingtarget = YES;
			LYstartTargetEmphasis();
		    } else
#endif /* SHOW_WHEREIS_TARGETS */
		    {
			if (inbold)
			    lynx_start_bold();
			if (inunderline)
			    lynx_start_underline();
		    }
		}
		LYaddstr(buffer);
		buffer[1] = '\0';
		sdata += utf_extra;
		data += utf_extra;
		utf_extra = 0;
	    } else if (HTCJK != NOCJK && is8bits(buffer[0])) {
		/*
		 * For CJK strings, by Masanobu Kimura.
		 */
		if (drawing && (i <= last_i)) {
d10732 2
a10733 1
		    LYaddstr(buffer);
d10735 15
d10751 2
a10752 39
		i++;
		sdata++;
		data++;
		/*
		 * For now, load 'M' into LastDisplayChar, but we should
		 * check whether it's white and if so, use ' '.  I don't
		 * know if there actually are white CJK characters, and
		 * we're loading ' ' for multibyte spacing characters in
		 * this code set, but this will become an issue when the
		 * development code set's multibyte character handling is
		 * used.  -FM
		 */
		LastDisplayChar = 'M';
	    } else {
		if (drawing) {
		    LYaddstr(buffer);
		}
		LastDisplayChar = buffer[0];
	    }
	}			/* end of switch */
    }				/* end of while */

    if (!drawing) {
	LYmove(YP, XP_next);
	lynx_start_link_color(flag, inU);
    } else {
#if defined(SHOW_WHEREIS_TARGETS)
	if (drawingtarget) {
	    LYstopTargetEmphasis();
	    lynx_start_link_color(flag, inU);
	}
#endif /* SHOW_WHEREIS_TARGETS */
	if (hadutf8) {
	    LYtouchline(YP);
	}
    }
    return;
}
#endif /* !USE_COLOR_STYLE */
d10755 3
a10757 28
/*
 * Move cursor position to a link's place in the display.
 * The "moving to" is done by scanning through the line's
 * character data in the corresponding HTLine of HTMainText,
 * and starting to draw when a UTF-8 encoded non-ASCII character
 * is encountered before the link (with some protection against
 * overwriting form fields).  This refreshing of preceding data is
 * necessary for preventing curses's or slang's display logic from
 * getting too clever; their logic counts character positions wrong
 * since they don't know about multi-byte characters that take up
 * only one screen position.  So we have to make them forget their
 * idea of what's in a screen line drawn previously.
 * If hightext is non-NULL, it should be the anchor text for a normal
 * link as stored in a links[] element, and the anchor text will be
 * drawn too, with appropriate attributes.  - kw
 */
void LYMoveToLink(int cur,
		  const char *target,
		  const char *hightext,
		  int flag,
		  BOOL inU,
		  BOOL utf_flag)
{
#define pvtTITLE_HEIGHT 1
    HTLine *todr;
    int i, n = 0;
    int XP_draw_min = 0;
    int flags = ((flag == ON) ? 1 : 0) | (inU ? 2 : 0);
d10759 4
a10762 11
    /*
     * We need to protect changed form text fields preceding this
     * link on the same line against overwriting.  - kw
     */
    for (i = cur - 1; i >= 0; i++) {
	if (links[i].ly < links[cur].ly)
	    break;
	if (links[i].type == WWW_FORM_LINK_TYPE) {
	    XP_draw_min = links[i].ly + links[i].l_form->size;
	    break;
	}
d10765 3
a10767 26
    /*  Find the right HTLine. */
    if (!HTMainText) {
	todr = NULL;
    } else if (HTMainText->stale) {
	todr = FirstHTLine(HTMainText);
	n = links[cur].ly - pvtTITLE_HEIGHT + HTMainText->top_of_screen;
    } else {
	todr = HTMainText->top_of_screen_line;
	n = links[cur].ly - pvtTITLE_HEIGHT;
    }
    for (i = 0; i < n && todr; i++) {
	todr = (todr == HTMainText->last_line) ? NULL : todr->next;
    }
    if (todr) {
	if (target && *target == '\0')
	    target = NULL;
	move_to_glyph(links[cur].ly, links[cur].lx, XP_draw_min,
		      todr->data, todr->size, todr->offset,
		      target, hightext, flags, utf_flag);
    } else {
	/*  This should not happen. */
	move_to_glyph(links[cur].ly, links[cur].lx, XP_draw_min,
		      "", 0, links[cur].lx,
		      target, hightext, flags, utf_flag);
	/* LYmove(links[cur].ly, links[cur].lx); */
    }
d10769 1
a10769 1
#endif /* !USE_COLOR_STYLE */
d10772 7
a10778 4
 * This is used only if compiled with lss support.  It's called to draw regular
 * link (1st two lines of link) when it's being unhighlighted in LYhighlight().
 */
void redraw_lines_of_link(int cur GCC_UNUSED)
d10780 1
a10780 1
#ifdef USE_COLOR_STYLE
d10782 1
a10782 1
    HTLine *todr1;
a10783 2
    int row, col, count;
    const char *text;
d10786 3
a10788 3
	/* we are at the last page - that is partially filled */
	lines_back = HTMainText->Lines - (links[cur].ly - pvtTITLE_HEIGHT +
					  HTMainText->top_of_screen);
d10790 1
a10790 1
	lines_back = display_lines - (links[cur].ly - pvtTITLE_HEIGHT);
d10793 1
a10793 1
    while (lines_back-- > 0)
d10795 2
d10798 7
a10804 8
    row = links[cur].ly;
    for (count = 0;
	 row <= display_lines && (text = LYGetHiliteStr(cur, count)) != NULL;
	 ++count) {
	col = LYGetHilitePos(cur, count);
	LYmove(row++, col);
	redraw_part_of_line(todr1, text, strlen(text), HTMainText);
	todr1 = todr1->next;
d10806 1
d10809 1
a10809 1
    /* no dead code ! */
d10814 2
a10815 2
#ifdef USE_PRETTYSRC
void HTMark_asSource(void)
d10818 1
a10818 1
	HTMainText->source = TRUE;
d10822 1
a10822 21
HTkcode HText_getKcode(HText *text)
{
    return text->kcode;
}

void HText_updateKcode(HText *text, HTkcode kcode)
{
    text->kcode = kcode;
}

HTkcode HText_getSpecifiedKcode(HText *text)
{
    return text->specified_kcode;
}

void HText_updateSpecifiedKcode(HText *text, HTkcode kcode)
{
    text->specified_kcode = kcode;
}

int HTMainText_Get_UCLYhndl(void)
d10824 1
a10824 3
    return (HTMainText ?
	    HTAnchor_getUCLYhndl(HTMainText->node_anchor, UCT_STAGE_MIME)
	    : -1);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d7 1
a13 1
#include <HTFile.h>
d19 6
a40 2
#include <TRSTable.h>
#include <LYHistory.h>
d48 1
a48 1
/*#define DEBUG_APPCH 1*/
d62 4
a65 1
#include <LYJustify.h>
d67 5
a71 9
#ifdef USE_CURSES_PADS
#  define DISPLAY_COLS (LYwideLines ? MAX_COLS : LYcols)
#  define WRAP_COLS(text) ((text)->stbl ?				\
			   (LYtableCols <= 0				\
			    ? DISPLAY_COLS : (LYtableCols * LYcols)/12)	\
			   : LYcols)
#else
#  define DISPLAY_COLS LYcols
#  define WRAP_COLS(text) LYcols
a72 9

#define FirstHTLine(text) ((text)->last_line->next)
#define LastHTLine(text)  ((text)->last_line)

PRIVATE void HText_trimHightext PARAMS((
	HText *		text,
	BOOLEAN		final,
	int		stop_before));

d76 1
a76 1
    int i, j;
d78 3
a80 3
    for (i = 1; (i < CACHEH && i <= display_lines); i++) {
	for (j = 0; j < CACHEW; j++)
	    cached_styles[i][j] = 0;
a90 1

d92 1
a92 5
			  (UCH((ch))&0xc0) == 0x80)

#define IS_UTF8_EXTRA(ch) (!(text && text->T.output_utf8) || \
			  !is8bits(ch) || \
			  (UCH(line->data[i] & 0xc0) == 0xc0))
d94 3
a96 12
/* a test in compact form: how many extra UTF-8 chars after initial? - kw */
#define UTF8_XNEGLEN(c) (c&0xC0? 0 :c&32? 1 :c&16? 2 :c&8? 3 :c&4? 4 :c&2? 5:0)
#define UTF_XLEN(c) UTF8_XNEGLEN(((char)~(c)))

#ifdef KANJI_CODE_OVERRIDE
PUBLIC HTkcode last_kcode = NOKANJI;	/* 1997/11/14 (Fri) 09:09:26 */
#endif
#ifdef CJK_EX
#define CHAR_WIDTH 6
#else
#define CHAR_WIDTH 1
#endif
d119 2
a120 2
PRIVATE BOOLEAN underline_on = OFF;
PRIVATE BOOLEAN bold_on      = OFF;
d123 2
d126 1
a126 1
PUBLIC int LYCacheSourceForAborted = SOURCE_CACHE_FOR_ABORTED_DROP;
d129 2
a130 6
#ifdef USE_SCROLLBAR
PUBLIC BOOLEAN LYShowScrollbar = FALSE;
PUBLIC BOOLEAN LYsb_arrow = TRUE;
PUBLIC int LYsb_begin = -1;
PUBLIC int LYsb_end = -1;
#endif
d132 6
a137 24
#ifndef VMS			/* VMS has a better way - right? - kw */
#define CHECK_FREE_MEM
#endif

#ifdef CHECK_FREE_MEM
PRIVATE void * LY_check_calloc PARAMS((size_t nmemb, size_t size));
#define LY_CALLOC LY_check_calloc
#else
  /* using the regular calloc */
#define LY_CALLOC calloc
#endif

/*
 * The HTPool.data[] array has to align the same as malloc() would, to make the
 * ALLOC_POOL scheme portable.  For many platforms, that is the same as the
 * number of bytes in a pointer.  It may be larger, e.g., on machines which
 * have more stringent requirements for floating point.  32-bits are plenty for
 * representing styles, but we may need 64-bit or 128-bit alignment.
 *
 * The real issue is that performance is degraded if the alignment is not met,
 * and some platforms such as Tru64 generate lots of warning messages.
 */
#ifndef ALIGN_SIZE
#define ALIGN_SIZE      sizeof(double)
a139 142
typedef struct {
	unsigned int	direction:2;   /* on or off */
	unsigned int	horizpos:14;   /* horizontal position of this change */
	unsigned int	style:16;      /* which style to change to */
} HTStyleChange;

#if defined(USE_COLOR_STYLE)
#define MAX_STYLES_ON_LINE   64
  /* buffers used when current line is being aggregated, in split_line() */
static HTStyleChange stylechanges_buffers[2][MAX_STYLES_ON_LINE];
#endif

typedef HTStyleChange pool_data;

enum { POOL_SIZE = (8192 - 4*sizeof(void*) - sizeof(struct _HTPool*) - sizeof(int)) / sizeof(pool_data) };

typedef struct _HTPool {
    pool_data  data[POOL_SIZE];
    struct _HTPool* prev;
    int used;
} HTPool;

/************************************************************************
These are generic macros for any pools (provided those structures have the
same members as HTPool).  Pools are used for allocation of groups of
objects of the same type T.  Pools are represented as a list of structures of
type P (called pool chunks here).  Structure P has an array of N objects of
type T named 'data' (the number N in the array can be chosen arbitrary),
pointer to the previous pool chunk named 'prev', and the number of used items
in that pool chunk named 'used'.  Here is a definition of the structure P:
	struct P
	{
	    T data[N];
	    struct P* prev;
	    int used;
	};
 It's recommended that sizeof(P) be memory page size minus 32 in order malloc'd
chunks to fit in machine page size.
 Allocation of 'n' items in the pool is implemented by incrementing member
'used' by 'n' if (used+n <= N), or malloc a new pool chunk and
allocating 'n' items in that new chunk.  It's the task of the programmer to
assert that 'n' is <= N.  Only entire pool may be freed - this limitation makes
allocation algorithms trivial and fast - so the use of pools is limited to
objects that are freed in batch, that are not deallocated not in the batch, and
not reallocated.
 Pools greatly reduce memory fragmentation and memory allocation/deallocation
speed due to the simple algorithms used.  Due to the fact that memory is
'allocated' in array, alignment overhead is minimal.  Allocating strings in a
pool provided their length will never exceed N and is much smaller than N seems
to be very efficient.
 [Several types of memory-hungry objects are stored in the pool now:  styles,
lines, anchors, and FormInfo. Arrays of HTStyleChange are stored as is,
other objects are stored using a cast.]

 Pool is referenced by the pointer to the last chunk that contains free slots.
Functions that allocate memory in the pool update that pointer if needed.
There are 3 functions - POOL_NEW, POOL_FREE, and ALLOC_IN_POOL.

      - VH

*************************************************************************/

#define POOLallocstyles(ptr, n)     ptr = ALLOC_IN_POOL(&HTMainText->pool, n * sizeof(pool_data))
#define POOLallocHTLine(ptr, size)  ptr = (HTLine*) ALLOC_IN_POOL(&HTMainText->pool, LINE_SIZE(size))
#define POOLallocstring(ptr, len)   ptr = (char*) ALLOC_IN_POOL(&HTMainText->pool, len + 1)
#define POOLtypecalloc(T,ptr)	    ptr = (T*) ALLOC_IN_POOL(&HTMainText->pool, sizeof(T))

/**************************************************************************/
/*
 *   Allocates 'n' items in the pool of type 'HTPool' pointed by 'poolptr'.
 *   Returns a pointer to the "allocated" memory or NULL if fails.
 *   Updates 'poolptr' if necessary.
 */
PRIVATE pool_data* ALLOC_IN_POOL ARGS2(
	HTPool**,	ppoolptr,
	unsigned,	request)
{
    HTPool* pool = *ppoolptr;
    pool_data* ptr;
    unsigned n;
    unsigned j;

    if (!pool) {
	ptr = NULL;
    } else {
	n = request;
	if (n == 0)
	    n = 1;
	j = (n % ALIGN_SIZE);
	if (j != 0)
	    n += (ALIGN_SIZE - j);
	n /= sizeof(pool_data);

	if (POOL_SIZE >= (pool->used + n)) {
	    ptr = pool->data + pool->used;
	    pool->used += n;
	} else {
	    HTPool* newpool = (HTPool*)LY_CALLOC(1, sizeof(HTPool));
	    if (!newpool) {
		ptr = NULL;
	    } else {
		newpool->prev = pool;
		newpool->used = n;
		ptr = newpool->data;
		*ppoolptr = newpool;
	   }
	}
    }
    return ptr;
}

/*
 *   Returns a pointer to initialized pool of type 'HTPool', or NULL if fails.
 */
PRIVATE HTPool* POOL_NEW NOARGS
{
    HTPool* poolptr = (HTPool*)LY_CALLOC(1, sizeof(HTPool));
    if (poolptr) {
	poolptr->prev = NULL;
	poolptr->used = 0;
    }
    return poolptr;
}

/*
 *   Frees a pool of type 'HTPool' pointed by poolptr.
 */
PRIVATE void POOL_FREE ARGS1(
	HTPool*,	poolptr)
{
    HTPool* cur = poolptr;
    HTPool* prev;
    while (cur) {
	prev = cur->prev;
	free(cur);
	cur = prev;
    }
}

/**************************************************************************/
/**************************************************************************/

d141 7
a147 4
	struct _line    *next;
	struct _line    *prev;
	unsigned short	offset;	/* Implicit initial spaces */
	unsigned short	size;	/* Number of characters */
d149 2
a150 2
	HTStyleChange*  styles;
	unsigned short  numstyles;
d152 1
a152 1
	char	data[1];	/* Space for terminator at least! */
a154 1

a156 14
/*
 * Last line buffer; the second is used in split_line(). Not in pool!
 * We cannot wrap in middle of multibyte sequences, so allocate 2 extra
 * for a workspace.  This is stored in the HText, to prevent confusion
 * between different documents.  Note also that it is declared with an
 * HTLine at the beginning so pointers will be properly aligned.
 */
typedef struct {
	HTLine	base;
	char    data[MAX_LINE+2];
} HTLineTemp;

#define TEMP_LINE(p,n) ((HTLine *)&(p->temp_line[n]))

a158 1
	struct _TextAnchor *	prev;		/* www_user_search only! */
d160 3
d164 5
a168 2
	short			line_pos;	/* Bytes/chars - extent too */
	short			extent;		/* (see HText_trimHightext) */
a171 4
	char			link_type;	/* Normal, internal, or form? */
	FormInfo *		input_field;	/* Info for form links */
	HiliteList		lites;

d175 1
a175 1
typedef struct {
d182 1
a182 1
**	next_line is valid if stale is false.
d188 17
a204 1

a205 1
	HTLineTemp		temp_line[2];
d207 2
a208 1
	TextAnchor *		first_anchor;	/* double-linked on demand */
a209 2
	TextAnchor *		last_anchor_before_stbl;
	TextAnchor *		last_anchor_before_split;
a230 2
	BOOL			has_utf8; /* has utf-8 on screen or line */
	BOOL			had_utf8; /* had utf-8 when last displayed */
a234 2
	STable_info *		stbl;
	HTList *		enclosed_stbl;
a236 10
	HTkcode			specified_kcode;	/* Specified Kanji code */
#ifdef USE_TH_JP_AUTO_DETECT
	enum _detected_kcode  { DET_SJIS, DET_EUC, DET_NOTYET, DET_MIXED }
				detected_kcode;		/* Detected Kanji code */
	enum _SJIS_status     { SJIS_state_neutral, SJIS_state_in_kanji,
				SJIS_state_has_bad_code } SJIS_status;
	enum _EUC_status      { EUC_state_neutral, EUC_state_in_kanji,
				EUC_state_in_kana, EUC_state_has_bad_code }
				EUC_status;
#endif
d240 8
a247 8
				state;		/* Escape sequence? */
	int			kanji_buf;	/* Lead multibyte */
	int			in_sjis;	/* SJIS flag */
	int			halted;		/* emergency halt */

	BOOL			have_8bit_chars; /* Any non-ASCII chars? */
	LYUCcharset *		UCI;		/* node_anchor UCInfo */
	int			UCLYhndl;	/* charset we are fed */
d250 2
a251 21
	HTStream *		target;		/* Output stream */
	HTStreamClass		targetClass;	/* Output routines */

	HTPool*			pool;		/* this HText memory pool */

#ifdef SOURCE_CACHE
	/*
	* Parse settings when this HText was generated.
	*/
	BOOL			clickable_images;
	BOOL			pseudo_inline_alts;
	BOOL			verbose_img;
	BOOL			raw_mode;
	BOOL			historical_comments;
	BOOL			minimal_comments;
	BOOL			soft_dquotes;
	short			old_dtd;
	short			keypad_mode;
	short			disp_lines;	/* Screen size */
	short			disp_cols;	/* Used for reports only */
#endif
a253 8
/* exported */
PUBLIC void* HText_pool_calloc ARGS2(
	HText *,	text,
	unsigned,	size)
{
    return (void*) ALLOC_IN_POOL(&text->pool, size);
}

a255 65
#ifdef EXP_JUSTIFY_ELTS
PUBLIC BOOL can_justify_here;
PUBLIC BOOL can_justify_here_saved;

PUBLIC BOOL can_justify_this_line;/* =FALSE if line contains form objects */
PUBLIC int wait_for_this_stacked_elt;/* -1 if can justify contents of the
    element on the op of stack. If positive - specifies minimal stack depth
    plus 1 at which we can justify element (can be MAX_LINE+2 if
    ok_justify ==FALSE or in psrcview. */
PUBLIC BOOL form_in_htext;/*to indicate that we are in form (since HTML_FORM is
  not stacked in the HTML.c */
PUBLIC BOOL in_DT = FALSE;
#ifdef DEBUG_JUSTIFY
PUBLIC BOOL can_justify_stack_depth;/* can be 0 or 1 if all code is correct*/
#endif


typedef struct {
    int byte_len;		/*length in bytes*/
    int cell_len;		/*length in cells*/
} ht_run_info;

static int justify_start_position;/* this is an index of char from which
    justification can start (eg after "* " preceeding <li> text) */

static int ht_num_runs;/*the number of runs filled*/
static ht_run_info ht_runs[MAX_LINE];
static BOOL this_line_was_split;
static TextAnchor* last_anchor_of_previous_line;
static BOOL have_raw_nbsps = FALSE;

PUBLIC void ht_justify_cleanup NOARGS
{
    wait_for_this_stacked_elt = !ok_justify
#  ifdef USE_PRETTYSRC
	|| psrc_view
#  endif
	? 30000/*MAX_NESTING*/+2 /*some unreachable value*/ : -1;
    can_justify_here = TRUE;
    can_justify_this_line = TRUE;
    form_in_htext = FALSE;

    last_anchor_of_previous_line = NULL;
    this_line_was_split = FALSE;
    in_DT = FALSE;
    have_raw_nbsps = FALSE;
}

PUBLIC void mark_justify_start_position ARGS1(void*,text)
{
    if (text && ((HText*)text)->last_line)
	justify_start_position = ((HText*)text )->last_line->size;
}


#define REALLY_CAN_JUSTIFY(text) ( (wait_for_this_stacked_elt<0) && \
	( text->style->alignment == HT_LEFT     || \
	  text->style->alignment == HT_JUSTIFY) && \
	HTCJK == NOCJK && !in_DT && \
	can_justify_here && can_justify_this_line && !form_in_htext )

#endif /* EXP_JUSTIFY_ELTS */



a270 7
PRIVATE int utfxtra_on_this_line = 0; /* num of UTF-8 extra bytes in line,
				       they *also* count as ctrl chars. */
#ifdef WIDEC_CURSES
#define UTFXTRA_ON_THIS_LINE 0
#else
#define UTFXTRA_ON_THIS_LINE utfxtra_on_this_line
#endif
d273 1
a273 1
	{ 0,  "(Unstyled)", 0, "",
a284 6

PRIVATE BOOL HText_TrueEmptyLine PARAMS((
	HTLine *	line,
	HText *		text,
	BOOL		IgnoreSpaces));

d290 3
a292 2
PRIVATE void HText_RemoveEmptyLastLine PARAMS((
	HText *		text));
d361 1
a361 1
	HText * t = (HText *) HTList_objectAt(loaded_texts, i);
d364 2
a365 1
	CTRACE((tfp, "\nBUG *** Emergency freeing document %d/%d for '%s'%s!\n",
d372 2
a373 1
		     " with POST data" : "")));
d399 1
a399 1
#endif /* CHECK_FREE_MEM */
d401 1
a401 8
/*
 * Clear highlight information for a given anchor
 * (text was allocated in the pool).
 */
PRIVATE void LYClearHiText ARGS1(
	TextAnchor *,	a)
{
    FREE(a->lites.hl_info);
d403 2
a404 3
    a->lites.hl_base.hl_text = NULL;
    a->lites.hl_len = 0;
}
d406 1
a406 126
/*
 * Set the initial highlight information for a given anchor.
 */
PRIVATE void LYSetHiText ARGS3(
	TextAnchor *,	a,
	char *,		text,
	int,		len)
{
    if (text != NULL) {
	POOLallocstring(a->lites.hl_base.hl_text, len);
	memcpy(a->lites.hl_base.hl_text, text, len);
	*(a->lites.hl_base.hl_text + len) = '\0';

	a->lites.hl_len = 1;
    }
}

/*
 * Add highlight information for the next line of a anchor.
 */
PRIVATE void LYAddHiText ARGS3(
	TextAnchor *,	a,
	char *,		text,
	int,		x)
{
    HiliteInfo *have = a->lites.hl_info;
    unsigned need = (a->lites.hl_len - 1);
    unsigned want = (a->lites.hl_len += 1) * sizeof(HiliteInfo);

    if (have != NULL) {
	have = (HiliteInfo *) realloc(have, want);
    } else {
	have = (HiliteInfo *) malloc(want);
    }
    a->lites.hl_info = have;

    POOLallocstring(have[need].hl_text, strlen(text));
    strcpy(have[need].hl_text, text);
    have[need].hl_x = x;
}

/*
 * Return an offset to skip leading blanks in the highlighted link.  That is
 * needed to avoid having the color-style paint the leading blanks.
 */
#ifdef USE_COLOR_STYLE
PRIVATE int LYAdjHiTextPos ARGS2(
	TextAnchor *,	a,
	int,		count)
{
    char *result;

    if (count >= a->lites.hl_len)
	result = NULL;
    else if (count > 0)
	result = a->lites.hl_info[count - 1].hl_text;
    else
	result = a->lites.hl_base.hl_text;

    return (result != 0) ? (LYSkipBlanks(result) - result) : 0;
}
#else
#define LYAdjHiTextPos(a,count) 0
#endif

/*
 * Get the highlight text, counting from zero.
 */
PRIVATE char *LYGetHiTextStr ARGS2(
	TextAnchor *,	a,
	int,		count)
{
    char *result;

    if (count >= a->lites.hl_len)
	result = NULL;
    else if (count > 0)
	result = a->lites.hl_info[count - 1].hl_text;
    else
	result = a->lites.hl_base.hl_text;
    result += LYAdjHiTextPos(a, count);
    CTRACE((tfp, "FIXME text '%s'\n", result));
    return result;
}

/*
 * Get the X-ordinate at which to draw the corresponding highlight-text
 */
PRIVATE int LYGetHiTextPos ARGS2(
	TextAnchor *,	a,
	int,		count)
{
    int result;

    if (count >= a->lites.hl_len)
	result = -1;
    else if (count > 0)
	result = a->lites.hl_info[count - 1].hl_x;
    else
	result = a->line_pos;
    result += LYAdjHiTextPos(a, count);
    CTRACE((tfp, "FIXME cols '%d'\n", result));
    return result;
}

/*
 * Copy highlighting information from anchor 'b' to 'a'.
 */
PRIVATE void LYCopyHiText ARGS2(
	TextAnchor *,	a,
	TextAnchor *,	b)
{
    int count;
    char *s;

    LYClearHiText(a);
    for (count = 0; ; ++count) {
	if ((s = LYGetHiTextStr(b, count)) == NULL)
	    break;
	if (count == 0) {
	    LYSetHiText(a, s, strlen(s));
	} else {
	    LYAddHiText(a, s, LYGetHiTextPos(b, count));
	}
    }
}
d453 1
a453 1
    HText * self = typecalloc(HText);
a456 2
    CTRACE((tfp, "GridText: start HText_new\n"));

d459 1
a459 1
    CTRACE((tfp, "GridText: VMTotal = %d\n", VMTotal));
a461 16
    /*
     *  If the previously shown text had UTF-8 characters on screen,
     *  remember this in the newly created object.  Do this now, before
     *  the previous object may become invalid. - kw
     */
    if (HTMainText) {
	if (HText_hasUTF8OutputSet(HTMainText) &&
	    HTLoadedDocumentEightbit() &&
	    LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
	    self->had_utf8 = HTMainText->has_utf8;
	} else {
	    self->had_utf8 = HTMainText->has_utf8;
	}
	HTMainText->has_utf8 = NO;
    }

d478 1
a478 3
	CTRACE((tfp, "GridText: Auto-uncaching\n")) ;

	HTAnchor_delete_links(anchor);
d492 1
a492 1
	CTRACE((tfp, "GridText: Freeing off cached doc.\n"));
d496 1
a496 1
	CTRACE((tfp, "GridText: VMTotal reduced to %d\n", VMTotal));
d500 2
a501 2
    self->pool = POOL_NEW();
    if (!self->pool)
a502 2

    line = self->last_line = TEMP_LINE(self, 0);
a504 1
    line->data[line->size] = '\0';
a506 1
    line->styles = stylechanges_buffers[0];
d508 1
a508 1
    self->Lines = 0;
a509 1
    self->last_anchor_before_split = NULL;
d519 14
a536 1
    self->verbose_img = verbose_img;
d542 2
a543 3
    self->keypad_mode = keypad_mode;
    self->disp_lines = LYlines;
    self->disp_cols = DISPLAY_COLS;
d555 1
a555 2
	LYIsUIPage3(anchor->address, UIP_LIST_PAGE, 0) ||
	LYIsUIPage3(anchor->address, UIP_ADDRLIST_PAGE, 0))
d560 2
a561 4
    self->no_cache = ((anchor->no_cache ||
		      anchor->post_data)
		      ? YES
		      : NO);
d565 1
a565 1
#ifndef USE_PRETTYSRC
d571 1
a571 7
    /*  mark_htext_as_source == TRUE if we are parsing html file (and psrc_view is
     *	    set temporary to false at creation time)
     *	psrc_view == TRUE if source of the text produced by some lynx module
     *	    (like ftp browsers) is requested). - VH
     */
    self->source = (BOOL) (LYpsrc ? mark_htext_as_source || psrc_view : HTOutputFormat == WWW_SOURCE);
    mark_htext_as_source = FALSE;
a578 6
    self->specified_kcode = NOKANJI;
#ifdef USE_TH_JP_AUTO_DETECT
    self->detected_kcode = DET_NOTYET;
    self->SJIS_status = SJIS_state_neutral;
    self->EUC_status = EUC_state_neutral;
#endif
d590 1
a590 1
     *  Check the kcode setting if the anchor has a charset element. -FM
d592 3
a594 2
    HText_setKcode(self, anchor->charset,
		   HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT));
d604 1
a604 1
	 *  Create an array of dots for the UNDERSCORES macro. -FM
d610 1
a610 1
	 *  Create an array of underscores for the STARS macro. -FM
d622 1
a622 1
     * By this function we create HText object
d625 2
a626 4
    if (display_partial_flag) {
	display_partial = TRUE;	 /* enable HTDisplayPartial() */
	NumOfLines_partial = 0;	 /* initialize */
    }
d638 2
a639 3
#ifdef EXP_JUSTIFY_ELTS
    ht_justify_cleanup();
#endif
d671 20
d739 2
d743 4
a746 1
	LYClearHiText(l);
d751 1
a751 1
     *  Free the tabs list. -FM
d766 1
a766 1
     *  Free the hidden links list. -FM
d780 1
a780 1
     *  if it is not a destination of other links. -FM
d787 1
a787 15
#ifdef SOURCE_CACHE
	/* Remove source cache files and chunks always, even if the
	 * HTAnchor_delete call does not actually remove the anchor.
	 * Keeping them would just be a waste of space - they won't
	 * be used any more after the anchor has been disassociated
	 * from a HText structure. - kw
	 */
	HTAnchor_clearSourceCache(self->node_anchor);
#endif

	HTAnchor_delete_links(self->node_anchor);

	HTAnchor_setDocument(self->node_anchor, (HyperDoc *)0);

	if (HTAnchor_delete(self->node_anchor->parent))
d795 17
a811 1
    POOL_FREE(self->pool);
d823 1
a823 1
PRIVATE int display_line ARGS4(
d825 1
a825 3
	HText *,	text,
	int,		scrline GCC_UNUSED,
	CONST char*,	target GCC_UNUSED)
a830 1
    char LastDisplayChar = ' ';
a832 16
#define inunderline NO
#define inbold NO
#else
    BOOL inbold=NO, inunderline=NO;
#endif
#if defined(SHOW_WHEREIS_TARGETS) && !defined(USE_COLOR_STYLE)
    CONST char *cp_tgt;
    int i_start_tgt=0, i_after_tgt;
    int HitOffset, LenNeeded;
    BOOL intarget=NO;
#else
#define intarget NO
#endif /* SHOW_WHEREIS_TARGETS && !USE_COLOR_STYLE */

#if !(defined(NCURSES_VERSION) || defined(WIDEC_CURSES))
    text->has_utf8 = NO; /* use as per-line flag, except with ncurses */
d834 1
d842 1
a842 1
    LYclrtoeol();
d849 2
a850 2
    if (j > (int)DISPLAY_COLS - 1)
	j = (int)DISPLAY_COLS - 1;
d861 1
a861 1
	LYaddch (' ');
d870 1
a870 54

#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
    /*
     *  If the target is on this line, it will be emphasized.
     */
    i_after_tgt = i;
    if (target) {
	cp_tgt = LYno_attr_mb_strstr(data,
				       target,
				       text->T.output_utf8, YES,
				       &HitOffset,
				       &LenNeeded);
	if (cp_tgt) {
	    if (((int)line->offset + LenNeeded) >= DISPLAY_COLS) {
		cp_tgt = NULL;
	    } else {
		text->page_has_target = YES;
		i_start_tgt = i + HitOffset;
		i_after_tgt = i + LenNeeded;
	    }
	}
    } else {
	cp_tgt = NULL;
    }
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */

    while ((i < DISPLAY_COLS) && ((buffer[0] = *data) != '\0')) {

#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
	if (cp_tgt && i >= i_after_tgt) {
	    if (intarget) {
		cp_tgt = LYno_attr_mb_strstr(data,
					    target,
					    text->T.output_utf8, YES,
					    &HitOffset,
					    &LenNeeded);
		if (cp_tgt) {
		    i_start_tgt = i + HitOffset;
		    i_after_tgt = i + LenNeeded;
		}
		if (!cp_tgt || i_start_tgt != i) {
		    LYstopTargetEmphasis();
		    intarget = NO;
		    if (inbold)		start_bold();
		    if (inunderline)	start_underline();
		}
	    }
	}
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */

d879 2
a880 2
	    LynxChangeStyle (CStyle.style, CStyle.direction);
	    current_style++;
d888 1
a888 1
		    LYaddch('_');
d891 1
a891 11
		    inunderline = YES;
		    if (!intarget) {
#if defined(PDCURSES)
			if (LYShowColor == SHOW_COLOR_NEVER)
			    start_bold();
			else
			    start_underline();
#else
			start_underline();
#endif	/* PDCURSES */
		    }
d897 1
a897 1
		    LYaddch('_');
a899 8
		    inunderline = NO;
		    if (!intarget) {
#if defined(PDCURSES)
		    if (LYShowColor == SHOW_COLOR_NEVER)
			stop_bold();
		    else
			stop_underline();
#else
a900 2
#endif	/* PDCURSES */
		    }
d905 1
a905 3
		inbold = YES;
		if (!intarget)
		    start_bold();
d909 1
a909 3
		inbold = NO;
		if (!intarget)
		    stop_bold();
d915 1
a915 1
		    LYaddch('+');
a916 3
#if defined(SHOW_WHEREIS_TARGETS) && !defined(USE_COLOR_STYLE)
		    i_after_tgt++;
#endif
d922 1
a922 1
		    isspace(UCH(LastDisplayChar)) ||
d932 1
a932 1
		     *  split_line() in those cases. -FM
d937 1
a937 1
		     *  Make it a hard hyphen and fall through. -FM
d940 1
a941 1
		/* FALLTHRU */
d944 23
a966 9
#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
		if (!intarget && cp_tgt && i >= i_start_tgt) {
		    /*
		     *  Start the emphasis.
		     */
		    if (data > cp_tgt) {
			LYstartTargetEmphasis();
			intarget = YES;
a967 7
		}
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */
		i++;
		if (text->T.output_utf8 && is8bits(buffer[0])) {
		    text->has_utf8 = YES;
		    utf_extra = utf8_length(text->T.output_utf8, data-1);
d973 1
a973 1
		    LYaddstr(buffer);
d977 1
a977 5
		} else if (HTCJK != NOCJK && is8bits(buffer[0])
#ifndef CONV_JISX0201KANA_JISX0208KANA
		    && kanji_code != SJIS
#endif
		) {
a980 2
		    if (i >= DISPLAY_COLS) goto after_while;

a981 1
		    buffer[2] = '\0';
d983 1
a983 2
		    i++;
		    LYaddstr(buffer);
d994 1
a994 1
		     *  character handling is used. -FM
d998 1
a998 1
		    LYaddstr(buffer);
a1003 7
after_while:
#if !(defined(NCURSES_VERSION) || defined(WIDEC_CURSES))
    if (text->has_utf8) {
	LYtouchline(scrline);
	text->has_utf8 = NO;	/* we had some, but have dealt with it. */
    }
#endif
d1007 1
a1007 1
    LYaddch('\n');
a1008 6
#if defined(SHOW_WHEREIS_TARGETS) && !defined(USE_COLOR_STYLE)
    if (intarget)
	LYstopTargetEmphasis();
#else
#undef intarget
#endif /* SHOW_WHEREIS_TARGETS && !USE_COLOR_STYLE */
d1015 1
a1015 1
	LynxChangeStyle (CStyle.style, CStyle.direction);
d1033 1
a1033 2
    int i = 0, j = 0, toolbar = 0;
    int limit;
d1036 1
a1036 1
     *  Make sure we have a text structure. -FM
d1045 1
a1045 1
	LynxChangeStyle(s_title, STACK_ON);
d1047 1
a1047 1
	LynxChangeStyle(s_title, ABS_ON);
d1052 1
a1052 1
     *  Load the title field. -FM
d1056 1
a1056 1
		  HTAnchor_title(text->node_anchor) : " "));	/* "" -> " " */
d1061 1
a1061 1
     *  any trailing spaces. -FM
d1072 1
a1072 9
    limit = LYscreenWidth();
    if (limit < 10) {
	percent[0] = '\0';	/* Null string */
    } else if ((display_lines) <= 0 && LYlines > 0 &&
	text->top_of_screen <= 99999 && text->Lines <= 999999) {
	sprintf(percent, " (l%d of %d)",
		text->top_of_screen, text->Lines);
    } else if ((text->Lines + 1) > (display_lines) &&
	(display_lines) > 0) {
d1098 1
a1098 1
     *  and truncated if necessary. -FM & KW
d1102 1
a1102 1
	    (tmp = typecallocn(unsigned char, (strlen(title) + 256)))) {
d1119 4
a1122 23
    LYmove(0, 0);
    LYclrtoeol();
#if defined(SH_EX) && defined(KANJI_CODE_OVERRIDE)
    LYaddstr(str_kcode(last_kcode));
#endif
    if (HText_hasToolbar(text)) {
	LYaddch('#');
	toolbar = 1;
    }
#ifdef USE_COLOR_STYLE
    if (s_forw_backw != NOSTYLE && (nhist || nhist_extra > 1)) {
	int c = nhist ? ACS_LARROW : ' ';

	/* turn the FORWBACKW.ARROW style on */
	LynxChangeStyle(s_forw_backw, STACK_ON);
	if (nhist) {
	    LYaddch(c); LYaddch(c); LYaddch(c);
	} else
	    LYmove(0, 3 + toolbar);
	if (nhist_extra > 1) {
	    LYaddch(ACS_RARROW); LYaddch(ACS_RARROW); LYaddch(ACS_RARROW);
	}
	LynxChangeStyle(s_forw_backw, STACK_OFF);
d1124 3
a1126 4
#endif /* USE_COLOR_STYLE */
    i = (limit - 1) - strlen(percent) - strlen(title);
    if (i >= CHAR_WIDTH) {
	LYmove(0, i);
d1129 3
a1131 2
	 *  Truncation takes into account the possibility that
	 *  multibyte characters might be present. -HS (H. Senshu)
d1133 2
a1134 10
	int last;
	last = (int)strlen(percent) + CHAR_WIDTH;
	if (limit - 3 >= last) {
	    title[(limit - 3) - last] = '.';
	    title[(limit - 2) - last] = '.';
	    title[(limit - 1) - last] = '\0';
	} else {
	    title[(limit - 1) - last] = '\0';
	}
	LYmove(0, CHAR_WIDTH);
d1136 1
a1136 1
    LYaddstr(title);
d1138 2
a1139 2
	LYaddstr(percent);
    LYaddch('\n');
a1141 10
#if defined(USE_COLOR_STYLE) && defined(CAN_CUT_AND_PASTE)
    if (s_hot_paste != NOSTYLE) {	/* Only if the user set the style */
	LYmove(0, LYcols - 1);
	LynxChangeStyle(s_hot_paste, STACK_ON);
	LYaddch(ACS_RARROW);
	LynxChangeStyle(s_hot_paste, STACK_OFF);
	LYmove(1, 0);			/* As after \n */
    }
#endif /* USE_COLOR_STYLE */

d1144 1
a1144 1
    LynxChangeStyle(s_title, STACK_OFF);
a1150 117
/*	Output the scrollbar
**	---------------------
*/
#ifdef USE_SCROLLBAR
PRIVATE void display_scrollbar ARGS1(
	HText *,	text)
{
    int i;
    int h = display_lines - 2 * (LYsb_arrow!=0); /* Height of the scrollbar */
    int off = (LYsb_arrow != 0);		 /* Start of the scrollbar */
    int top_skip, bot_skip, sh, shown;

    LYsb_begin = LYsb_end = -1;
    if (!LYShowScrollbar || !text || h <= 2
	|| (text->Lines + 1) <= display_lines)
	return;

    if (text->top_of_screen >= text->Lines + 1 - display_lines) {
	/* Only part of the screen shows actual text */
	shown = text->Lines + 1 - text->top_of_screen;

	if (shown <= 0)
	    shown = 1;
    } else
	shown = display_lines;
    /* Each cell of scrollbar represents text->Lines/h lines of text. */
    /* Always smaller than h */
    sh = (shown*h + text->Lines/2)/(text->Lines + 1);
    if (sh <= 0)
	sh = 1;
    if (sh >= h - 1)
	sh = h - 2;		/* Position at ends indicates BEG and END */

    if (text->top_of_screen == 0)
	top_skip = 0;
    else if (text->Lines - (text->top_of_screen + display_lines - 1) <= 0)
	top_skip = h - sh;
    else {
	/* text->top_of_screen between 1 and text->Lines - display_lines
	   corresponds to top_skip between 1 and h - sh - 1 */
	/* Use rounding to get as many positions into top_skip==h - sh - 1
	   as into top_skip == 1:
	   1--->1, text->Lines - display_lines + 1--->h - sh. */
	top_skip = (int) (1 +
	    1. * (h - sh - 1) * text->top_of_screen
		/ (text->Lines - display_lines + 1));
    }
    bot_skip = h - sh - top_skip;

    LYsb_begin = top_skip;
    LYsb_end = h - bot_skip;

    if (LYsb_arrow) {
#ifdef USE_COLOR_STYLE
	int s = top_skip ? s_sb_aa : s_sb_naa;

	if (last_colorattr_ptr > 0) {
	    LynxChangeStyle(s, STACK_ON);
	} else {
	    LynxChangeStyle(s, ABS_ON);
	}
#endif /* USE_COLOR_STYLE */
	LYmove(1, LYcols + LYshiftWin - 1);
	addch_raw(ACS_UARROW);
#ifdef USE_COLOR_STYLE
	LynxChangeStyle(s, STACK_OFF);
#endif /* USE_COLOR_STYLE */
    }
#ifdef USE_COLOR_STYLE
    if (last_colorattr_ptr > 0) {
	LynxChangeStyle(s_sb_bg, STACK_ON);
    } else {
	LynxChangeStyle(s_sb_bg, ABS_ON);
    }
#endif /* USE_COLOR_STYLE */

    for (i=1; i <= h; i++) {
#ifdef USE_COLOR_STYLE
	if (i-1 <= top_skip && i > top_skip)
	    LynxChangeStyle(s_sb_bar, STACK_ON);
	if (i-1 <= h - bot_skip && i > h - bot_skip)
	    LynxChangeStyle(s_sb_bar, STACK_OFF);
#endif /* USE_COLOR_STYLE */
	LYmove(i + off, LYcols + LYshiftWin - 1);
	if (i > top_skip && i <= h - bot_skip) {
	    LYaddch(ACS_BLOCK);
	} else {
	    LYaddch(ACS_CKBOARD);
	}
    }
#ifdef USE_COLOR_STYLE
    LynxChangeStyle(s_sb_bg, STACK_OFF);
#endif /* USE_COLOR_STYLE */

    if (LYsb_arrow) {
#ifdef USE_COLOR_STYLE
	int s = bot_skip ? s_sb_aa : s_sb_naa;

	if (last_colorattr_ptr > 0) {
	    LynxChangeStyle(s, STACK_ON);
	} else {
	    LynxChangeStyle(s, ABS_ON);
	}
#endif /* USE_COLOR_STYLE */
	LYmove(h + 2, LYcols + LYshiftWin - 1);
	addch_raw(ACS_DARROW);
#ifdef USE_COLOR_STYLE
	LynxChangeStyle(s, STACK_OFF);
#endif /* USE_COLOR_STYLE */
    }
    return;
}
#else
#define display_scrollbar(text) /*nothing*/
#endif /* USE_SCROLLBAR */


d1161 1
a1161 1
#if defined(USE_COLOR_STYLE) && defined(SHOW_WHEREIS_TARGETS)
a1166 1
    int stop_before_for_anchors;
d1186 3
a1188 3
	    LYaddch('*');
	    LYrefresh();
	    LYclear();
d1190 2
a1191 2
	LYaddstr("\n\nError accessing document!\nNo data available!\n");
	LYrefresh();
a1204 1
    if (target && *target == '\0') target = NULL;
a1205 7
    if (display_lines <= 0) {
	/*  No screen space to display anything!
	 *  returning here makes it more likely we will survive if
	 *  an xterm is temporarily made very small. - kw */
	return;
    }

d1219 1
a1219 1
    for (i = 0, line = FirstHTLine(text);		/* Find line */
d1227 3
a1229 3
		LYaddch('*');
		LYrefresh();
		LYclear();
d1231 2
a1232 2
	    LYaddstr("\n\nError drawing page!\nBad HText structure!\n");
	    LYrefresh();
d1249 1
d1251 1
d1257 1
a1258 1
	charset_last_displayed = current_char_set;
d1267 3
a1269 3
	LYaddch('*');
	LYrefresh();
	LYclear();
a1285 1
    text->top_of_screen_line = line;
a1297 9
#ifdef DISP_PARTIAL
    if (display_partial && text->stbl) {
	stop_before_for_anchors = Stbl_getStartLineDeep(text->stbl);
	if (stop_before_for_anchors > line_number+(display_lines))
	    stop_before_for_anchors = line_number+(display_lines);
    } else
#endif
	stop_before_for_anchors = line_number+(display_lines);

d1302 1
a1302 1
#if defined(USE_COLOR_STYLE) && defined(SHOW_WHEREIS_TARGETS)
d1304 1
a1304 8
	int offset, LenNeeded;
#endif
#ifdef DISP_PARTIAL
	if (display_partial ||
	    line_number != text->first_lineno_last_disp_partial)
	    text->has_utf8 = NO;
#else
	text->has_utf8 = NO;
d1315 3
a1317 3
		    LYaddch('*');
		    LYrefresh();
		    LYclear();
d1319 2
a1320 2
		LYaddstr("\n\nError drawing page!\nBad HText structure!\n");
		LYrefresh();
d1332 1
a1332 1
		LYmove((i + 2), 0);
d1335 1
a1335 1
	    display_line(line, text, i+1, target);
d1337 1
a1337 2
#if defined(SHOW_WHEREIS_TARGETS)
#ifdef USE_COLOR_STYLE		/* otherwise done in display_line - kw */
d1340 1
a1340 1
	     *  seek and emphasize it. -FM
d1344 13
a1356 7
	    while (non_empty(target) &&
		    (cp = LYno_attr_mb_strstr(data,
					      target,
					      text->T.output_utf8, YES,
					      NULL,
					      &LenNeeded)) != NULL &&
		   ((int)line->offset + LenNeeded) < DISPLAY_COLS) {
d1383 38
a1420 2
		    } else if (&data[itmp] >= cp) {
			if (cp == &data[itmp]) {
d1422 1
a1422 1
			     *  First printable character of target.
d1424 7
a1430 1
			    LYmove((i + 1), x_pos);
d1432 2
d1435 1
a1435 1
			 *  Output all the printable target chars.
d1437 24
a1460 1
			utf_extra = utf8_length(text->T.output_utf8, data + itmp);
d1465 1
a1465 1
			    LYaddstr(tmp);
d1469 1
a1469 1
			} else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d1474 1
a1474 1
			    LYaddstr(tmp);
d1478 1
a1478 1
			    LYaddstr(tmp);
d1487 1
a1487 1
		 *  line. -FM
d1496 1
a1496 1
		 *  in it. -FM
d1498 1
a1498 1
		LYmove((i + 2), 0);
d1500 1
a1500 2
#endif /* USE_COLOR_STYLE */
#endif /* SHOW_WHEREIS_TARGETS */
d1504 1
a1504 1
	     *  display_flag is set and process the next line. -FM
d1511 2
a1512 2
		    LYmove((i + 1), 0);
		    LYclrtoeol();
d1537 3
a1539 7
    for (Anchor_ptr = text->first_anchor;
	 Anchor_ptr != NULL && Anchor_ptr->line_num <= stop_before_for_anchors;
	 Anchor_ptr = Anchor_ptr->next) {

	if (Anchor_ptr->line_num >= line_number
	 && Anchor_ptr->line_num < stop_before_for_anchors) {
	    char *hi_string = LYGetHiTextStr(Anchor_ptr, 0);
d1541 2
d1546 7
a1552 16
	    if (Anchor_ptr->show_anchor
	     && non_empty(hi_string)
	     && (Anchor_ptr->link_type & HYPERTEXT_ANCHOR)) {
		int count;
		char *s;

		for (count = 0; ; ++count) {
		    s = LYGetHiTextStr(Anchor_ptr, count);
		    if (count == 0)
			LYSetHilite(nlinks, s);
		    if (s == NULL)
			break;
		    if (count != 0)
			LYAddHilite(nlinks, s, LYGetHiTextPos(Anchor_ptr, count));
		}

d1558 2
a1559 1
		link_dest = HTAnchor_followLink(Anchor_ptr->anchor);
d1572 1
a1572 1
				Anchor_ptr->anchor, HTInternalLink);
d1575 3
a1577 3
				CTRACE((tfp,
		    "GridText: display_page: unexpected typed link to %s!\n",
					    link_dest_intl->parent->address));
d1604 1
a1604 1
		links[nlinks].l_form = NULL;
d1610 1
a1610 1
		    && Anchor_ptr->input_field->type != F_HIDDEN_TYPE) {
d1621 1
a1621 1
		links[nlinks].l_form = FormInfo_ptr;
d1630 5
a1634 4
		    LYSetHilite(nlinks,
				FormInfo_ptr->num_value
				? checked_radio
				: unchecked_radio);
d1636 5
a1640 4
		    LYSetHilite(nlinks,
				FormInfo_ptr->num_value
				? checked_box
				: unchecked_box);
d1642 2
a1643 2
		    LYSetHilite(nlinks,
				STARS(strlen(FormInfo_ptr->value)));
d1645 1
a1645 2
		    LYSetHilite(nlinks,
				FormInfo_ptr->value);
d1648 6
d1658 1
a1658 1
		LYhighlight(OFF, (nlinks - 1), target);
d1666 2
a1667 2
		if (non_empty(hi_string))
		    CTRACE((tfp,
d1669 1
a1669 1
			    hi_string));
d1673 6
d1682 1
a1682 1
	     *  to use half-page or two-line scrolling. -FM
d1687 1
a1687 1
	    CTRACE((tfp, "\ndisplay_page: MAXLINKS reached.\n"));
d1694 1
a1694 1
     *  from the previous page draw. -FM
d1696 1
a1696 2
    for (i = nlinks; i < last_nlinks; i++) {
	LYSetHilite(i, NULL);
a1697 1
    }
d1715 1
a1715 1
	LYaddstr("\n     Document is empty");
a1716 1
    display_scrollbar(text);
d1731 1
a1731 9
#if !defined(WIDEC_CURSES)
    if (text->has_utf8 || text->had_utf8) {
	/*
	 *  For other than ncurses, repainting is taken care of
	 *  by touching lines in display_line and highlight. - kw 1999-10-07
	 */
	text->had_utf8 = text->has_utf8;
	clearok(curscr, TRUE);
    } else if (HTCJK != NOCJK) {
a1733 4
	 *
	 *  Full repainting is necessary, otherwise only part of a multibyte
	 *  character sequence might be written because of curses output
	 *  optimizations.
d1735 1
a1735 1
	clearok(curscr, TRUE);
d1737 1
a1737 1
#endif /* WIDEC_CURSES */
a1738 1
    LYrefresh();
a1755 20
/* LYcols_cu is the notion that the display library has of the screen
   width.  Normally it is the same as LYcols, but there may be a
   difference via SLANG_MBCS_HACK.  Checks of the line length (as the
   non-UTF-8-aware display library would see it) against LYcols_cu are
   is used to try to prevent that lines with UTF-8 chars get wrapped
   by the library when they shouldn't.
   If there is no display library involved, i.e. dump_output_immediately,
   no such limit should be imposed.  MAX_COLS should be just as good
   as any other large value.  (But don't use INT_MAX or something close
   to it to, avoid over/underflow.) - kw */
#ifdef USE_SLANG
#define LYcols_cu(text) (dump_output_immediately ? MAX_COLS : SLtt_Screen_Cols)
#else
#ifdef WIDEC_CURSES
#define LYcols_cu(text) WRAP_COLS(text)
#else
#define LYcols_cu(text) (dump_output_immediately ? MAX_COLS : DISPLAY_COLS)
#endif
#endif

a1774 272
#define AT_START_OF_CELL(text)	\
  (text->stbl			\
   && Stbl_at_start_of_cell(text->stbl, text->Lines, text->last_line->size))

#define DEBUG_SPLITLINE

#ifdef DEBUG_SPLITLINE
#define CTRACE_SPLITLINE(p)	CTRACE(p)
#else
#define CTRACE_SPLITLINE(p)	/*nothing*/
#endif

PRIVATE int set_style_by_embedded_chars ARGS4(
	char *,		s,
	char *,		e,
	unsigned char,	start_c,
	unsigned char,	end_c)
{
    int ret = NO;

    while (--e >= s) {
	if (*e == end_c)
	    break;
	if (*e == start_c) {
	    ret = YES;
	    break;
	}
    }
    return ret;
}

PRIVATE void move_anchors_in_region ARGS7(
    HTLine *,		line,
    int,		line_number,
    TextAnchor **,	prev_anchor,	/*updates++*/
    int *,		prev_head_processed,
    int,		sbyte,
    int,		ebyte,
    int,		shift)		/* Likewise */
{
    /*
     * Update anchor positions for anchors that start on this line.  Note:  we
     * rely on a->line_pos counting bytes, not characters.  That's one reason
     * why HText_trimHightext has to be prevented from acting on these anchors
     * in partial display mode before we get a chance to deal with them here.
     */
    TextAnchor *a;
    int head_processed = *prev_head_processed;

    /*
     * We need to know whether (*prev_anchor)->line_pos is "in new coordinates"
     * or in old ones.  If prev_anchor' head was touched on the previous
     * iteration, we set head_processed.  The tail may need to be treated now.
     */
    for (a = *prev_anchor;
	 a && a->line_num <= line_number;
	 a = a->next, head_processed = 0) {
	/* extent==0 needs to be special-cased; happens if no text for
	   the anchor was processed yet.  */
	/* Subtract one so that the space is not inserted at the end
	   of the anchor... */
	int last = a->line_pos + (a->extent ? a->extent - 1 : 0);

	/* Include the anchors started on the previous line */
	if (a->line_num < line_number - 1)
	    continue;
	if (a->line_num == line_number - 1)
	    last -= line->prev->size + 1; /* Fake "\n" "between" lines counted too */
	if (last < sbyte)		/* Completely before the start */
	    continue;

	if ( !head_processed		/* a->line_pos is not edited yet */
	     && a->line_num == line_number
	     && a->line_pos >= ebyte)	/* Completely after the end */
	    break;
	/* Now we know that the anchor context intersects the chunk */

	/* Fix the start */
	if ( !head_processed && a->line_num == line_number
	     && a->line_pos >= sbyte ) {
	    a->line_pos += shift;
	    a->extent -= shift;
	    head_processed = 1;
	}
	/* Fix the end */
	if ( last < ebyte )
	    a->extent += shift;
	else
	    break;			/* Keep this `a' for the next step */
    }
    *prev_anchor = a;
    *prev_head_processed = head_processed;
}

/*
 *  Given a line and two int arrays of old/now position, this function
 *  creates a new line where spaces have been inserted/removed
 *  in appropriate places - so that characters at/after the old
 *  position end up at/after the new position, for each pair, if possible.
 *  Some necessary changes for anchors starting on this line are also done
 *  here if needed. Updates 'prev_anchor' internally.
 *  Returns a newly allocated HTLine* if changes were made
 *    (lines allocated in pool, caller should not free the old one).
 *  Returns NULL if no changes needed.  (Remove-spaces code may be buggy...)
 * - kw
 */
PRIVATE HTLine * insert_blanks_in_line ARGS7(
    HTLine *,		line,
    int,		line_number,
    HText *,		text,
    TextAnchor **,	prev_anchor,	/*updates++*/
    int,		ninserts,
    int *,		oldpos,		/* Measured in cells */
    int *,		newpos)		/* Likewise */
{
    int ioldc = 0;			/* count visible characters */
    int ip;				/* count insertion pairs */
#if defined(USE_COLOR_STYLE)
    int istyle = 0;
#endif
    int added_chars = 0;
    int shift = 0;
    int head_processed;
    HTLine * mod_line;
    char *newdata;
    char *s = line->data;
    char *pre = s;
    char *copied = line->data, *t;

    if (!(line && line->size && ninserts))
	return NULL;
    for (ip = 0; ip < ninserts; ip++)
	if (newpos[ip] > oldpos[ip] &&
	    (newpos[ip] - oldpos[ip]) > added_chars)
	    added_chars = newpos[ip] - oldpos[ip];
    if (line->size + added_chars > MAX_LINE - 2)
	return NULL;
    if (line == text->last_line) {
	if (line == TEMP_LINE(text, 0))
	   mod_line = TEMP_LINE(text, 1);
	else
	   mod_line = TEMP_LINE(text, 0);
    } else {
	POOLallocHTLine(mod_line, line->size + added_chars);
    }
    if (!mod_line)
	return NULL;
    if (!*prev_anchor)
	*prev_anchor = text->first_anchor;
    head_processed = (*prev_anchor && (*prev_anchor)->line_num < line_number);
    memcpy(mod_line, line, LINE_SIZE(0));
    t = newdata = mod_line->data;
    ip = 0;
    while (ip <= ninserts) {
	/* line->size is in bytes, so it may be larger than needed... */
	int curlim = (ip < ninserts
		      ? oldpos[ip]
		      /* Include'em all! */
		      : ((int)line->size <= MAX_LINE
			  ? MAX_LINE+1
			  : (int)line->size+1));
	pre = s;

	/* Fast forward to char==curlim or EOL.  Stop *before* the
	   style-change chars. */
	while (*s) {
	    if ( text && text->T.output_utf8
		 && UCH(*s) >= 0x80 && UCH(*s) <  0xC0 ) {
		pre = s + 1;
	    } else if (!IsSpecialAttrChar(*s)) { /* At a "displayed" char */
		if (ioldc >= curlim)
		    break;
		ioldc++;
		pre = s + 1;
	    }
	    s++;
	}

	/* Now s is at the "displayed" char, pre is before the style change */
	if (ip)				/* Fix anchor positions */
	    move_anchors_in_region(line, line_number, prev_anchor /*updates++*/,
				   &head_processed,
				   copied - line->data, pre - line->data,
				   shift);
#if defined(USE_COLOR_STYLE)	/* Move styles too */
#define NStyle mod_line->styles[istyle]
	for (; istyle < line->numstyles && (int) NStyle.horizpos < curlim ; istyle++)
	    /* Should not we include OFF-styles at curlim? */
	    NStyle.horizpos += shift;
#endif
	while (copied < pre)	/* Copy verbatim to byte == pre */
	    *t++ = *copied++;
	if (ip < ninserts) {	/* Insert spaces */
	    int delta = newpos[ip] - oldpos[ip] - shift;

	    if (delta < 0) {	/* Not used yet? */
		while (delta++ < 0 && t > newdata && t[-1] == ' ')
		    t--, shift--;
	    } else
		shift = newpos[ip] - oldpos[ip];
	    while (delta-- > 0)
		*t++ = ' ';
	}
	ip++;
    }
    while (pre < s)	/* Copy remaining style-codes */
	*t++ = *pre++;
    /* Check whether the last anchor continues on the next line */
    if (head_processed && *prev_anchor && (*prev_anchor)->line_num == line_number)
	(*prev_anchor)->extent += shift;
    *t = '\0';
    mod_line->size = t - newdata;
    return mod_line;
}

PRIVATE void reset_cached_linedata ARGS3(
	HText *,	text,
	char *,		p,
	unsigned,	plen)
{			/* Count funny characters */
    int i;

    text->permissible_split = ctrl_chars_on_this_line =
	utfxtra_on_this_line = 0;
    for (i = (plen - 1); i >= 0; i--) {
	if (p[i] == LY_UNDERLINE_START_CHAR ||
	    p[i] == LY_UNDERLINE_END_CHAR ||
	    p[i] == LY_BOLD_START_CHAR ||
	    p[i] == LY_BOLD_END_CHAR ||
	    p[i] == LY_SOFT_HYPHEN) {
	    ctrl_chars_on_this_line++;
	} else if (IS_UTF_EXTRA(p[i])) {
	    utfxtra_on_this_line++;
	}
	if (p[i] == LY_SOFT_HYPHEN && (int)text->permissible_split < i)
	    text->permissible_split = i + 1;
    }
    ctrl_chars_on_this_line += utfxtra_on_this_line;
}


#if defined(USE_COLOR_STYLE)
PRIVATE HTStyleChange * skip_matched_and_correct_offsets ARGS3(
	HTStyleChange *,	end,
	HTStyleChange *,	start,
	unsigned,		split_pos)
{ /* Found an OFF change not part of an adjacent matched pair.
   * Walk backward looking for the corresponding ON change.
   * Move everything after split_pos to be at split_pos.
   * This can only work correctly if all changes are correctly
   * nested!  If this fails, assume it is safer to leave whatever
   * comes before the OFF on the previous line alone. */
    int level = 0;
    HTStyleChange *tmp = end;

    for (; tmp >= start; tmp--) {
	if (tmp->style == end->style) {
	    if (tmp->direction == STACK_OFF)
		level--;
	    else if (tmp->direction == STACK_ON) {
		if (++level == 0)
		    return tmp;
	    } else
		return 0;
	}
	if (tmp->horizpos > split_pos)
	    tmp->horizpos = split_pos;
    }
    return 0;
}
#endif /* USE_COLOR_STYLE */

d1780 1
d1782 3
a1786 1
    short alignment;
d1792 1
a1792 8
    int s, s_post, s_pre, t_underline = underline_on, t_bold = bold_on;
    char *p;
    int ctrl_chars_on_previous_line = 0;
    int utfxtra_on_previous_line = UTFXTRA_ON_THIS_LINE;
    char * cp;

    HTLine * previous = text->last_line;
    HTLine * line;
d1794 1
d1796 1
a1796 1
     *  Set new line.
d1798 5
a1802 4
    if (previous == TEMP_LINE(text, 0))
	line = TEMP_LINE(text, 1);
    else
	line = TEMP_LINE(text, 0);
d1804 1
a1804 2
	return;
    memset(line, 0, LINE_SIZE(0));
a1806 1
    utfxtra_on_this_line = 0;	/*reset too, we'll count them*/
d1810 2
a1811 2
    CTRACE((tfp,"GridText: split_line(%p,%d) called\n", text, split));
    CTRACE((tfp,"   bold_on=%d, underline_on=%d\n", bold_on, underline_on));
a1813 19
    cp = previous->data;
    /* Float LY_SOFT_NEWLINE to the start */
    if (cp[0] == LY_BOLD_START_CHAR
     || cp[0] == LY_UNDERLINE_START_CHAR) {
	switch (cp[1]) {
	    case LY_SOFT_NEWLINE:
		cp[1] = cp[0];
		cp[0] = LY_SOFT_NEWLINE;
		break;
	    case LY_BOLD_START_CHAR:
	    case LY_UNDERLINE_START_CHAR:
		if (cp[2] == LY_SOFT_NEWLINE) {
		    cp[2] = cp[1];
		    cp[1] = cp[0];
		    cp[0] = LY_SOFT_NEWLINE;
		}
		break;
	}
    }
d1815 1
a1815 1
	CTRACE((tfp,
d1817 1
a1817 1
	       split, previous->size));
d1823 1
a1823 1
	    CTRACE((tfp, "                split adjusted to %d.\n", split));
d1839 5
a1843 15
    alignment = style->alignment;

    if (split > 0) { /* Restore flags to the value at the splitting point */
	if (!(dump_output_immediately && use_underscore))
	    t_underline = set_style_by_embedded_chars(
		previous->data, previous->data + split,
		LY_UNDERLINE_START_CHAR, LY_UNDERLINE_END_CHAR);

	t_bold = set_style_by_embedded_chars(
	    previous->data, previous->data + split,
	    LY_BOLD_START_CHAR, LY_BOLD_END_CHAR);

    }

    if (!(dump_output_immediately && use_underscore) && t_underline) {
a1846 1
	SpecialAttrChars++;
d1848 4
a1851 1
    if (t_bold) {
a1854 1
	SpecialAttrChars++;
d1861 1
a1861 1
	char *prevdata = previous->data, *linedata = line->data;
d1863 1
d1865 3
a1867 1
	/* Split the line. -FM */
d1873 1
a1873 1
	 *  of our new line. -FM
d1876 7
a1882 16
	while ((
		(*p == ' '
#ifdef EXP_JUSTIFY_ELTS
		/* if justification is allowed for prev line, then raw
		 * HT_NON_BREAK_SPACE are still present in data[] (they'll be
		 * substituted at the end of this function with ' ') - VH
		 */
		 || *p == HT_NON_BREAK_SPACE
#endif
		)
		&& (HeadTrim || text->first_anchor ||
		    underline_on || bold_on ||
		    alignment != HT_LEFT ||
		    style->wordWrap || style->freeFormat ||
		    style->spaceBefore || style->spaceAfter)) ||
		*p == LY_SOFT_HYPHEN) {
a1885 1

a1886 2
	if (plen) {			/* Count funny characters */
	    reset_cached_linedata(text,	p, plen);
d1888 44
a1931 3
	    /* Add the data to the new line. -FM */
	    strcat(linedata, p);
	    line->size += plen;
d1933 53
d1991 14
a2004 27
    p = previous->data + previous->size - 1;
    while (p >= previous->data
	   && (*p == ' '
#ifdef EXP_JUSTIFY_ELTS
	    /* if justification is allowed for prev line, then raw
	     * HT_NON_BREAK_SPACE are still present in data[] (they'll be
	     * substituted at the end of this function with ' ') - VH
	     */
	       || *p == HT_NON_BREAK_SPACE
#endif
	      )
#ifdef USE_PRETTYSRC
	   && !psrc_view /*don't strip trailing whites - since next line can
		start with LY_SOFT_NEWLINE - so we don't lose spaces when
		'p'rinting this text to file -VH */
#endif
	   && (ctrl_chars_on_this_line || HeadTrim || text->first_anchor ||
	       underline_on || bold_on ||
	       alignment != HT_LEFT ||
	       style->wordWrap || style->freeFormat ||
	       style->spaceBefore || style->spaceAfter)) {
	p--;	/*  Strip trailers. */
    }
    TailTrim = previous->data + previous->size - 1 - p;	/*  Strip trailers. */
    previous->size -= TailTrim;
    p[1] = '\0';

a2014 3
    s_post = s + HeadTrim;
    s_pre  = s - TailTrim;

d2019 1
a2019 1
	CTRACE((tfp,"GridText: split_line(%d [now:%d]) called\n", split, s));
d2023 1
a2023 4
    if (previous->styles == stylechanges_buffers[0])
	line->styles = stylechanges_buffers[1];
    else
	line->styles = stylechanges_buffers[0];
d2025 117
a2141 17
    {
	HTStyleChange *from = previous->styles + previous->numstyles - 1;
	HTStyleChange *to = line->styles + MAX_STYLES_ON_LINE - 1;
	HTStyleChange *scan, *at_end;

	/*  Color style changes after the split position
	 *  are transferred to the new line.  Ditto for changes
	 *  in the trimming region, but we stop when we reach an OFF change.
	 *  The second loop below may then handle remaining changes. - kw */
	while (from >= previous->styles && to >= line->styles) {
	    *to = *from;
	    if ((int) to->horizpos > s_post)
		to->horizpos += - s_post + SpecialAttrChars;
	    else if ((int) to->horizpos > s_pre &&
		     (to->direction == STACK_ON ||
		      to->direction == ABS_ON))
		to->horizpos = ((int) to->horizpos < s) ? 0 : SpecialAttrChars;
d2143 6
a2148 3
		break;
	    to--;
	    from--;
d2150 2
a2151 2
	/* FROM may be invalid, otherwise it is either an ON change at or
	   before s_pre, or is an OFF change at or before s_post.  */
d2153 3
a2155 64
	scan = from;
	at_end = from;
	/* Now on the previous line we have a correctly nested but
	   possibly non-terminated sequence of style changes.
	   Terminate it, and duplicate unterminated changes at the
	   beginning of the new line. */
	while (scan >= previous->styles && at_end >= previous->styles) {
	    /* The algorithm: scan back though the styles on the previous line.
	       a) If OFF, skip the matched group.
		  Report a bug on failure.
	       b) If ON, (try to) cancel the corresponding ON at at_end,
		  and the corresponding OFF at to;
		  If not, put the corresponding OFF at at_end, and copy to to;
	     */
	    if (scan->direction == STACK_OFF) {
		scan = skip_matched_and_correct_offsets(scan, previous->styles,
							s_pre);
		if (!scan) {
		    CTRACE((tfp, "BUG: styles improperly nested.\n"));
		    break;
		}
	    } else if (scan->direction == STACK_ON) {
		if ( at_end->direction == STACK_ON
		     && at_end->style == scan->style
		     && (int) at_end->horizpos >= s_pre )
		    at_end--;
		else if (at_end >= previous->styles + MAX_STYLES_ON_LINE - 1) {
		    CTRACE((tfp, "BUG: style overflow before split_line.\n"));
		    break;
		} else {
		    at_end++;
		    at_end->direction = STACK_OFF;
		    at_end->style = scan->style;
		    at_end->horizpos = s_pre;
		}
		if ( to < line->styles + MAX_STYLES_ON_LINE - 1
		     && to[1].direction == STACK_OFF
		     && to[1].horizpos <= (unsigned) SpecialAttrChars
		     && to[1].style == scan->style )
		    to++;
		else if (to >= line->styles) {
		    *to = *scan;
		    to->horizpos = SpecialAttrChars;
		    to--;
		} else {
		    CTRACE((tfp, "BUG: style overflow after split_line.\n"));
		    break;
		}
	    }
	    if ((int) scan->horizpos > s_pre)
		scan->horizpos = s_pre;
	    scan--;
	}
	line->numstyles = line->styles + MAX_STYLES_ON_LINE - 1 - to;
	if (line->numstyles > 0 && line->numstyles < MAX_STYLES_ON_LINE) {
	    int n;

	    for (n = 0; n < line->numstyles; n++)
		line->styles[n] = to[n + 1];
	} else if (line->numstyles == 0)
	    line->styles[0].horizpos = ~0; /* ?!!! */
	previous->numstyles = at_end - previous->styles + 1;
	if (previous->numstyles == 0)
	    previous->styles[0].horizpos = ~0;	/* ?!!! */
d2157 11
d2170 2
a2171 4
    {
    HTLine* temp;
    POOLallocHTLine(temp, previous->size);
    if (!temp)
d2174 1
a2174 6
#if defined(USE_COLOR_STYLE)
    POOLallocstyles(temp->styles, previous->numstyles);
    if (!temp->styles)
	outofmem(__FILE__, "split_line_2");
    memcpy(temp->styles, previous->styles, sizeof(HTStyleChange)*previous->numstyles);
#endif
a2175 1
    }
d2189 2
a2190 6
    if (
#ifdef EXP_JUSTIFY_ELTS
	this_line_was_split ||
#endif
	(alignment == HT_CENTER ||
	 alignment == HT_RIGHT) || text->stbl) {
d2198 1
a2198 1
		*cp == LY_SOFT_HYPHEN) {
a2199 1
	    }
a2200 4
	if ((previous->size > 0) &&
		(int)(previous->data[previous->size-1] == LY_SOFT_HYPHEN))
	    ctrl_chars_on_previous_line--;

d2202 1
a2202 1
	spare =  (WRAP_COLS(text)-1) -
d2204 5
a2208 49
	    ctrl_chars_on_previous_line - previous->size;
	if (spare < 0 && LYwideLines)	/* Can be wider than screen */
	    spare = 0;

	if (spare > 0 && !dump_output_immediately &&
	    text->T.output_utf8 && ctrl_chars_on_previous_line) {
	    utfxtra_on_previous_line -= UTFXTRA_ON_THIS_LINE;
	    if (utfxtra_on_previous_line) {
		int spare_cu = (LYcols_cu(text)-1) -
		    utfxtra_on_previous_line - indent +
		    ctrl_chars_on_previous_line - previous->size;
		    /*
		     *  Shift non-leftaligned UTF-8 lines that would be
		     *  mishandled by the display library towards the left
		     *  if this would make them fit.  The resulting display
		     *  will not be as intended, but this is better than
		     *  having them split by curses.  (Curses cursor movement
		     *  optimization may still cause wrong positioning within
		     *  the line, in particular after a sequence of spaces).
		     * - kw
		     */
		if (spare_cu < spare) {
		    if (spare_cu >= 0) {
			if (alignment == HT_CENTER &&
			    (int)(previous->offset + indent + spare/2 +
				  previous->size)
			    - ctrl_chars_on_previous_line
			    + utfxtra_on_previous_line <= (LYcols_cu(text) - 1))
			    /* do nothing - it still fits - kw */;
			else {
			    spare = spare_cu;
			    if (alignment == HT_CENTER) {
				/*
				 *  Can't move towars center all the way,
				 *  but at least make line contents appear
				 *  as far right as possible. - kw
				 */
				alignment = HT_RIGHT;
			    }
			}
		    } else if (indent + (int)previous->offset + spare_cu >= 0)
		    { /* subtract overdraft from effective indentation */
			indent += (int)previous->offset + spare_cu;
			previous->offset = 0;
			spare = 0;
		    }
		}
	    }
	}
d2225 1
a2225 17
    if (text->stbl)
	/*
	 *  Notify simple table stuff of line split, so that it can
	 *  set the last cell's length.  The last cell should and
	 *  its row should really end here, or on one of the following
	 *  lines with no more characters added after the break.
	 *  We don't know whether a cell has been started, so ignore
	 *  errors here.
	 *  This call is down here because we need the
	 *  ctrl_chars_on_previous_line, which have just been re-
	 *  counted above. - kw
	 */
	Stbl_lineBreak(text->stbl,
		       text->Lines - 1,
		       previous->offset,
		       previous->size - ctrl_chars_on_previous_line);

d2230 1
a2230 1
     *  structure values for the new line. -FM
d2233 3
a2235 16
    if (s > 0) {			/* if not completely empty */
	int moved = 0;

	/* In the algorithm below we move or not move anchors between
	   lines using some heuristic criteria.  However, it is
	   desirable not to have two consequent anchors on different
	   lines *in a wrong order*!  (How can this happen?)
	   So when the "reasonable choice" is not unique, we use the
	   MOVED flag to choose one.
	 */
	/* Our operations can make a non-empty all-whitespace link
	   empty.  So what? */
	if ((a = text->last_anchor_before_split) == 0)
	    a = text->first_anchor;

	for ( ; a; a = a->next) {
d2237 8
a2244 22
		int len = a->extent, n = a->number, start = a->line_pos;
		int end = start + len;

		text->last_anchor_before_split = a;

		/* Which anchors do we leave on the previous line?
		   a) empty finished (We need a cut-off value.
		      "Just because": those before s;
		      this is the only case when we use s, not s_pre/s_post);
		   b) Those which start before s_pre;
		 */
		if (start < s_pre) {
		    if (end <= s_pre)
			continue;	/* No problem */

		    CTRACE_SPLITLINE((tfp, "anchor %d: no relocation", n));
		    if (end > s_post) {
			CTRACE_SPLITLINE((tfp, " of the start.\n"));
			a->extent += -(TailTrim + HeadTrim) + SpecialAttrChars;
		    } else {
			CTRACE_SPLITLINE((tfp, ", cut the end.\n"));
			a->extent = s_pre - start;
d2247 110
a2356 5
		} else if (start < s && !len
			   && (!n || (a->show_anchor && !moved))) {
		    CTRACE_SPLITLINE((tfp, "anchor %d: no relocation, empty-finished",
				      n));
		    a->line_pos = s_pre; /* Leave at the end of line */
d2359 13
d2373 4
a2376 24
		/* The rest we relocate */
		moved = 1;
		a->line_num++;
		CTRACE_SPLITLINE((tfp, "anchor %d: (T,H,S)=(%d,%d,%d); (line,pos,ext):(%d,%d,%d), ",
		       n, TailTrim,HeadTrim,SpecialAttrChars,
		       a->line_num,a->line_pos,a->extent));
		if (end < s_post) {	/* Move the end to s_post */
		    CTRACE_SPLITLINE((tfp, "Move end +%d, ", s_post - end));
		    len += s_post - end;
		}
		if (start < s_post) {	/* Move the start to s_post */
		    CTRACE_SPLITLINE((tfp, "Move start +%d, ", s_post - start));
		    len -= s_post - start;
		    start = s_post;
		}
		a->line_pos = start - s_post + SpecialAttrChars;
		a->extent = len;

		CTRACE_SPLITLINE((tfp, "->(%d,%d,%d)\n",
		       a->line_num,a->line_pos,a->extent));
	    } else if (a->line_num > CurLine)
		break;
	}
    }
a2377 89
#ifdef EXP_JUSTIFY_ELTS
    /* now perform justification - by VH */

    if (this_line_was_split
     && spare
     && !text->stbl	/* We don't inform TRST on the cell width change yet */
     && justify_max_void_percent > 0
     && justify_max_void_percent <= 100
     && justify_max_void_percent >= ((100*spare)
				  / ((WRAP_COLS(text) - 1)
				   - (int)style->rightIndent
				   - indent
				   + ctrl_chars_on_previous_line))) {
	/* this is the only case when we need justification*/
	char* jp = previous->data + justify_start_position;
	ht_run_info* r = ht_runs;
	char c;
	int total_byte_len = 0, total_cell_len = 0;
	int d_, r_;
	HTLine * jline;

	ht_num_runs = 0;
	r->byte_len = r->cell_len = 0;

	for(; (c = *jp) != 0; ++jp) {
	    if (c == ' ') {
		total_byte_len += r->byte_len;
		total_cell_len += r->cell_len;
		++r;
		++ht_num_runs;
		r->byte_len = r->cell_len = 0;
		continue;
	    }
	    ++r->byte_len;
	    if ( IsSpecialAttrChar(c) )
		continue;

	    ++r->cell_len;
	    if (c == HT_NON_BREAK_SPACE) {
		*jp = ' ';	/* substitute it */
		continue;
	    }
	    if (text->T.output_utf8 && is8bits(c)) {
		int utf_extra = utf8_length(text->T.output_utf8, jp);
		r->byte_len += utf_extra;
		jp += utf_extra;
	    }
	}
	total_byte_len += r->byte_len;
	total_cell_len += r->cell_len;
	++ht_num_runs;

	if (ht_num_runs != 1) {
	    int *oldpos = (int*)malloc(sizeof(int)*2*(ht_num_runs - 1));
	    int *newpos = oldpos + ht_num_runs - 1;
	    int i = 1;

	    if (oldpos == NULL)
		outofmem(__FILE__, "split_line_3");

	    d_ = spare/(ht_num_runs-1);
	    r_ = spare % (ht_num_runs-1);

	    /* The first run is not moved, proceed to the second one */
	    oldpos[0] = justify_start_position + ht_runs[0].cell_len + 1;
	    newpos[0] = oldpos[0] + ( d_ + ( r_--  > 0 ) );
	    while (i < ht_num_runs - 1) {
		int delta = ht_runs[i].cell_len + 1;

		oldpos[i] = oldpos[i-1] + delta;
		newpos[i] = newpos[i-1] + delta + ( d_ + ( r_--  > 0 ) );
		i++;
	    }
	    jline = insert_blanks_in_line(previous, CurLine, text,
					  &last_anchor_of_previous_line /*updates++*/,
					  ht_num_runs - 1, oldpos, newpos);
	    free((char*)oldpos);
	    if (jline == NULL)
		outofmem(__FILE__, "split_line_4");
	    previous->next->prev = jline;
	    previous->prev->next = jline;

	    previous = jline;
	}
	{ /* (ht_num_runs==1) */
	    if (justify_start_position) {
		char* p2 = previous->data;
		for( ; p2 < previous->data + justify_start_position; ++p2)
		    *p2 = (*p2 == HT_NON_BREAK_SPACE ? ' ' : *p2);
d2380 1
a2380 40
    } else {
	if (REALLY_CAN_JUSTIFY(text) ) {
	    char* p2;

	    /* it was permitted to justify line, but this function was called
	     * to end paragraph - we must substitute HT_NON_BREAK_SPACEs with
	     * spaces in previous line
	     */
	    if (line->size && !text->stbl) {
		  CTRACE((tfp,"BUG: justification: shouldn't happen - new line is not empty!\n"));
	    }

	    for (p2=previous->data;*p2;++p2)
		if (*p2 == HT_NON_BREAK_SPACE)
		    *p2 = ' ';
	} else if (have_raw_nbsps) {
	    /* this is very rare case, that can happen in forms placed in
	       table cells*/
	    unsigned i;

	    for (i = 0; i< previous->size; ++i)
		if (previous->data[i] == HT_NON_BREAK_SPACE)
		    previous->data[i] = ' ';

	    /*next line won't be justified, so substitute nbsps in it too */
	    for (i = 0; i< line->size; ++i)
		if (line->data[i] == HT_NON_BREAK_SPACE)
		    line->data[i] = ' ';
	}

	/* else HT_NON_BREAK_SPACEs were substituted with spaces in
	   HText_appendCharacter */
    }
	/* cleanup */
    can_justify_this_line = TRUE;
    justify_start_position = 0;
    this_line_was_split = FALSE;
    have_raw_nbsps = FALSE;
#endif /* EXP_JUSTIFY_ELTS */
    return;
d2391 3
a2393 1
    if (HText_LastLineEmpty(text, FALSE)) { /* No text on current line */
d2395 2
a2396 9

#ifdef USE_COLOR_STYLE
	/* Style-change petty requests at the start of the document: */
	if (line == text->last_line && newlines == 1)
	    return;			/* Do not add a blank line at start */
#endif

	while (line != text->last_line &&
			HText_TrueEmptyLine(line, text, FALSE)) {
a2401 2
    } else if (AT_START_OF_CELL(text)) {
	newlines = 1;			/* New line to get a correct offset */
d2422 1
a2422 2
    if (!AT_START_OF_CELL(text))
	blank_lines(text, ((after > before) ? after : before));
d2442 1
a2442 1
    CTRACE((tfp, "GridText: Change to style %s\n", style->name));
d2454 1
a2454 1
	int,		ch)
a2458 2
    int limit = 0;
    int actual;
a2460 4
#ifdef CJK_EX
    static unsigned char save_ch = 0;
#endif

d2494 2
a2495 2
	    CTRACE((tfp, "add(%s %d special char) %d/%d\n", special, ch,
		   HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
d2497 2
a2498 22
#ifdef CJK_EX	/* 1998/08/30 (Sun) 13:26:23 */
	    if (save_ch == 0) {
		if (IS_SJIS_HI1(ch) || IS_SJIS_HI2(ch)) {
		    save_ch = ch;
		} else {
		    CTRACE((tfp, "add(%c) %d/%d\n", ch,
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
		}
	    } else {
		CTRACE((tfp, "add(%c%c) %d/%d\n", save_ch, ch,
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
		save_ch = 0;
	    }
#else
	    if (UCH(ch) < 0x80) {
		CTRACE((tfp, "add(%c) %d/%d\n", UCH(ch),
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
	    } else {
		CTRACE((tfp, "add(%02x) %d/%d\n", UCH(ch),
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
	    }
#endif	/* CJK_EX */
a2527 97
#ifdef USE_TH_JP_AUTO_DETECT
    if ((HTCJK == JAPANESE) && (text->detected_kcode != DET_MIXED) &&
	(text->specified_kcode != SJIS) && (text->specified_kcode != EUC)) {
	unsigned char c;
	enum _detected_kcode save_d_kcode;

	c = UCH(ch);
	save_d_kcode = text->detected_kcode;
	switch (text->SJIS_status) {
	case SJIS_state_has_bad_code:
	    break;
	case SJIS_state_neutral:
	    if (IS_SJIS_HI1(c) || IS_SJIS_HI2(c)) {
		text->SJIS_status = SJIS_state_in_kanji;
	    }
	    else if ((c & 0x80) && !IS_SJIS_X0201KANA(c)) {
		text->SJIS_status = SJIS_state_has_bad_code;
		if (text->EUC_status == EUC_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_EUC;
	    }
	    break;
	case SJIS_state_in_kanji:
	    if (IS_SJIS_LO(c)) {
		text->SJIS_status = SJIS_state_neutral;
	    }
	    else {
		text->SJIS_status = SJIS_state_has_bad_code;
		if (text->EUC_status == EUC_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_EUC;
	    }
	    break;
	}
	switch (text->EUC_status) {
	case EUC_state_has_bad_code:
	    break;
	case EUC_state_neutral:
	    if (IS_EUC_HI(c)) {
		text->EUC_status = EUC_state_in_kanji;
	    }
	    else if (c == 0x8e) {
		text->EUC_status = EUC_state_in_kana;
	    }
	    else if (c & 0x80) {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	case EUC_state_in_kanji:
	    if (IS_EUC_LOX(c)) {
		text->EUC_status = EUC_state_neutral;
	    }
	    else {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	case EUC_state_in_kana:
	    if ((0xA1<=c)&&(c<=0xDF)) {
		text->EUC_status = EUC_state_neutral;
	    }
	    else {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	}
	if (save_d_kcode != text->detected_kcode) {
	    switch (text->detected_kcode) {
	    case DET_SJIS:
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode seems SJIS.\n"));
		break;
	    case DET_EUC:
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode seems EUC.\n"));
		break;
	    case DET_MIXED:
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode seems mixed!\n"));
		break;
	    default:
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode is unexpected!\n"));
		break;
	    }
	}
    }
#endif /* USE_TH_JP_AUTO_DETECT */
d2531 1
a2531 1
    if (ch == CH_ESC && HTCJK == NOCJK) {		/* decimal 27  S/390 -- gil -- 1504 */
a2532 1
    }
d2543 1
a2543 1
    if (is8bits(ch) && HTCJK == NOCJK &&
d2545 1
a2545 1
	UCH(ch) < LYlowest_eightbit[current_char_set]) {
a2546 1
    }
d2549 1
a2549 1
    if (UCH(ch) == 155 && HTCJK == NOCJK) {	/* octal 233 */
d2568 1
a2568 1
		    **  Takuya ASADA's (asada@@three-a.co.jp) CJK Lynx). -FM
d2576 1
a2576 1
	    case S_esc:
a2588 1
		/* FALLTHRU */
d2590 1
a2590 1
	    case S_dollar:
a2595 2
		    if (ch == '@@' || ch == 'B')
			text->kcode = JIS;
d2605 1
a2605 1
	    case S_dollar_paren:
d2617 1
a2617 1
	    case S_paren:
d2623 1
a2623 1
		     *  Can split here. -FM
d2631 1
a2631 1
		     *  Can split here. -FM
a2633 1
		    text->kcode = JIS;
d2640 1
a2640 1
	    case S_nonascii_text:
a2646 3
		    if (HTCJK == JAPANESE) {
			text->kcode = NOKANJI;
		    }
a2647 6
		} else if (UCH(ch) < 32) {
		    text->state = S_text;
		    text->kanji_buf = '\0';
		    if (HTCJK == JAPANESE) {
			text->kcode = NOKANJI;
		    }
d2656 1
a2656 1
	    case S_jisx0201_text:
a2659 1
		    text->kcode = NOKANJI;
d2666 1
a2666 1
	} /* end switch */
d2673 5
a2677 22
		if ((text->kcode != JIS)
		 && (
#ifdef KANJI_CODE_OVERRIDE
		    (last_kcode == SJIS) ||
		     ((last_kcode == NOKANJI) &&
#endif
		      ((text->kcode == SJIS) ||
#ifdef USE_TH_JP_AUTO_DETECT
		       ((text->detected_kcode == DET_SJIS) &&
			(text->specified_kcode == NOKANJI)) ||
#endif
		       ((text->kcode == NOKANJI) &&
			(text->specified_kcode == SJIS)) )
#ifdef KANJI_CODE_OVERRIDE
		     )
#endif
		    ) &&
		    (UCH(ch) >= 0xA1) &&
		    (UCH(ch) <= 0xDF)) {
#ifdef CONV_JISX0201KANA_JISX0208KANA
		    unsigned char c = UCH(ch);
		    unsigned char kb = UCH(text->kanji_buf);
a2682 3
#endif
		    /* 1998/01/19 (Mon) 09:06:15 */
		    text->permissible_split = (int)text->last_line->size;
d2686 1
a2686 1
		     *  Can split here. -FM
d2693 1
a2693 1
	    goto check_WrapSource;
a2698 9
#ifdef CJK_EX	/* MOJI-BAKE Fix! 1997/10/12 -- 10/31 (Fri) 00:22:57 - JH7AYN */
    if (HTCJK != NOCJK &&	/* added condition - kw */
	(ch == LY_BOLD_START_CHAR || ch == LY_BOLD_END_CHAR)) {
	text->permissible_split = (int)line->size;	/* Can split here */
	if (HTCJK == JAPANESE)
	    text->kcode = NOKANJI;
    }
#endif

d2700 2
a2701 7
#if !defined(USE_COLOR_STYLE) || !defined(NO_DUMP_WITH_BACKSPACES)
	if (line->size >= (MAX_LINE-1)) {
	    return;
	}
#if defined(USE_COLOR_STYLE) && !defined(NO_DUMP_WITH_BACKSPACES)
	if (with_backspaces && HTCJK==NOCJK && !text->T.output_utf8) {
#endif
d2734 1
a2734 1
	     *  hyphen. -FM
d2736 1
a2736 1
	    if (line->size < 1 || text->permissible_split >= line->size) {
a2737 1
	    }
d2740 5
a2744 5
		if (!IsSpecialAttrChar(UCH(line->data[i])) &&
		    !isspace(UCH(line->data[i])) &&
		    UCH(line->data[i]) != '-' &&
		    UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
		    UCH(line->data[i]) != HT_EN_SPACE) {
a2751 7
#if defined(USE_COLOR_STYLE) && !defined(NO_DUMP_WITH_BACKSPACES)
	} /* if (with_backspaces && HTCJK==HTNOCJK && !text->T.output_utf8) */
	 else {
	    return;
	 }
#endif

d2761 5
a2765 57
    if (text->T.output_utf8) {
	/*
	 *  Some extra checks for UTF-8 output here to make sure
	 *  memory is not overrun.  For a non-first char, append
	 *  to the line here and return. - kw
	 */
	if (IS_UTF_EXTRA(ch)) {
	    if ((line->size > (MAX_LINE-1))
		|| (indent + (int)(line->offset + line->size)
		    + UTFXTRA_ON_THIS_LINE
		    - ctrl_chars_on_this_line
		    + ((line->size > 0) &&
		       (int)(line->data[line->size-1] ==
				LY_SOFT_HYPHEN ?
					     1 : 0)) >= (LYcols_cu(text)-1))
		) {
		if (!text->permissible_split || text->source) {
		    text->permissible_split = line->size;
		    while (text->permissible_split > 0 &&
			   IS_UTF_EXTRA(line->data[text->permissible_split-1]))
			text->permissible_split--;
		    if (text->permissible_split &&
			(line->data[text->permissible_split-1] & 0x80))
			text->permissible_split--;
		    if (text->permissible_split == line->size)
			text->permissible_split = 0;
		}
		split_line(text, text->permissible_split);
		line = text->last_line;
		if (text->source && line->size - ctrl_chars_on_this_line
		    + UTFXTRA_ON_THIS_LINE == 0)
		    HText_appendCharacter (text, LY_SOFT_NEWLINE);
	    }
	    line->data[line->size++] = (char) ch;
	    line->data[line->size] = '\0';
	    utfxtra_on_this_line++;
	    ctrl_chars_on_this_line++;
	    return;
	} else if (ch & 0x80) {	/* a first char of UTF-8 sequence - kw */
	    if ((line->size > (MAX_LINE-7))) {
		if (!text->permissible_split || text->source) {
		    text->permissible_split = line->size;
		    while (text->permissible_split > 0 &&
			   (line->data[text->permissible_split-1] & 0x80)
			   == 0xC0) {
			text->permissible_split--;
		    }
		    if (text->permissible_split == line->size)
			text->permissible_split = 0;
		}
		split_line(text, text->permissible_split);
		line = text->last_line;
		if (text->source && line->size - ctrl_chars_on_this_line
		    + UTFXTRA_ON_THIS_LINE == 0)
		    HText_appendCharacter (text, LY_SOFT_NEWLINE);
	    }
	}
d2772 8
a2779 1
	if (AT_START_OF_CELL(text))
a2780 9
	new_line(text);
	text->in_line_1 = YES;	/* First line of new paragraph */
	/*
	 *  There are some pages written in
	 *  different kanji codes. - TA & kw
	 */
	if (HTCJK == JAPANESE)
	    text->kcode = NOKANJI;
	return;
a2788 9
#ifdef SH_EX	/* 1997/11/01 (Sat) 12:08:54 */
    if (ch == 0x0b) {	/* ^K ??? */
	ch = '\r';
    }
    if (ch == 0x1a) {	/* ^Z ??? */
	ch = '\r';
    }
#endif

a2795 2
	if (AT_START_OF_CELL(text))
	    return;
d2807 1
d2813 2
a2814 2
	int target, target_cu;	/* Where to tab to */
	int here, here_cu;	/* in _cu we try to guess what curses thinks */
d2819 1
a2819 1
	     *  if one does, we'll dump the soft hyphen. -FM
a2825 1
	here_cu = here + UTFXTRA_ON_THIS_LINE;
d2853 1
a2853 6
	if (target >= here)
	    target_cu = target;
	else
	    target_cu = target + (here_cu - here);

	if (target > (WRAP_COLS(text)-1) - (int)style->rightIndent &&
d2858 1
a2858 1
	     *  Can split here. -FM
a2860 2
	    if (target_cu > (WRAP_COLS(text)-1))
		target -= target_cu - (WRAP_COLS(text)-1);
d2873 1
a2873 3

check_WrapSource:
    if ( (text->source || dont_wrap_pre) && text == HTMainText) {
d2878 3
a2880 9
	int target = (int)(line->offset + line->size) - ctrl_chars_on_this_line;
	int target_cu = target + UTFXTRA_ON_THIS_LINE;
	if (target >= (WRAP_COLS(text)-1) - style->rightIndent -
	    (((HTCJK != NOCJK) && text->kanji_buf) ? 1 : 0) ||
	    (text->T.output_utf8 &&
	     target_cu + UTF_XLEN(ch) >= (LYcols_cu(text)-1))) {
	    int saved_kanji_buf;
	    int saved_state;

a2882 5

	    saved_kanji_buf = text->kanji_buf;
	    saved_state = text->state;
	    text->kanji_buf = '\0';
	    text->state = S_text;
a2883 2
	    text->kanji_buf = saved_kanji_buf;
	    text->state = saved_state;
d2889 1
a2889 1
	 *  Can split here. -FM
d2903 5
a2907 26
    if (text->IgnoreExcess) {
	int nominal = (indent + (int)(line->offset + line->size) - ctrl_chars_on_this_line);
	int number;

	limit = (WRAP_COLS(text) - 1);
	if (fields_are_numbered()
	 && !number_fields_on_left
	 && text->last_anchor != 0
	 && (number = text->last_anchor->number) > 0) {
	    limit -= (number > 99999
			? 6
			: (number > 9999
			    ? 5
			    : (number > 999
				? 4
				: (number > 99
				    ? 3
				    : (number > 9
					? 2
					: 1))))) + 2;
	}
	if ((nominal + (int)style->rightIndent) >= limit
	 || (nominal + UTFXTRA_ON_THIS_LINE) >= (LYcols_cu(text) - 1)) {
	    return;
	}
    }
d2912 1
a2912 9
    actual = ((indent + (int)line->offset + (int)line->size) +
	      ((line->size > 0) &&
	       (int)(line->data[line->size-1] == LY_SOFT_HYPHEN ? 1 : 0)));

    if (text->T.output_utf8) {
	actual += (UTFXTRA_ON_THIS_LINE - ctrl_chars_on_this_line + UTF_XLEN(ch));
	limit = (LYcols_cu(text) - 1);
    } else {
	actual +=
d2914 4
a2917 5
	 (((HTCJK != NOCJK) && text->kanji_buf) ? 1 : 0);
	limit = (WRAP_COLS(text) - 1);
    }

    if (actual >= limit) {
a2919 4
#ifdef EXP_JUSTIFY_ELTS
	    if (REALLY_CAN_JUSTIFY(text))
		this_line_was_split = TRUE;
#endif
d2921 1
a2921 3
	    if (ch == ' ') {
		return;	/* Ignore space causing split */
	    }
d2923 10
a2932 11
	} else if (HTOutputFormat == WWW_SOURCE) {
	    /*
	     *  For source output we don't want to wrap this stuff
	     *  unless absolutely necessary. - LJM
	     *  !
	     *  If we don't wrap here we might get a segmentation fault.
	     *  but let's see what happens
	     */
	    if ((int)line->size >= (int)(MAX_LINE-1)) {
		new_line(text);  /* try not to linewrap */
	    }
d2934 4
a2937 10
	    /*
	     *  For normal stuff like pre let's go ahead and
	     *  wrap so the user can see all of the text.
	     */
	    if ( (dump_output_immediately|| (crawl && traversal) )
		 && dont_wrap_pre) {
		if ((int)line->size >= (int)(MAX_LINE-1)) {
		    new_line(text);
		}
	    } else {
a2938 1
	    }
d2942 1
a2942 1
	 *  Never overrun memory if DISPLAY_COLS is set to a large value - KW
d2950 1
a2950 5
    if (ch == HT_NON_BREAK_SPACE
#ifdef EXP_JUSTIFY_ELTS
     && !REALLY_CAN_JUSTIFY(text)
#endif
     )
d2952 1
a2952 6
#ifdef EXP_JUSTIFY_ELTS
    else
	have_raw_nbsps = TRUE;
#endif

    /* we leave raw HT_NON_BREAK_SPACE otherwise (we'll substitute it later) */
a2956 3
    /*
     * Kanji charactor handling.
     */
a2961 1

d2963 8
a2970 76
	    hi = UCH(text->kanji_buf);
	    lo = UCH(ch);

	    if (HTCJK == JAPANESE) {
		if (text->kcode != JIS) {
		    if (IS_SJIS_2BYTE(hi, lo)) {
			if (IS_EUC(hi, lo)) {
#ifdef KANJI_CODE_OVERRIDE
			    if (last_kcode != NOKANJI)
				text->kcode = last_kcode;
			    else
#endif
				if (text->specified_kcode != NOKANJI)
				    text->kcode = text->specified_kcode;
#ifdef USE_TH_JP_AUTO_DETECT
				else if (text->detected_kcode == DET_EUC)
				    text->kcode = EUC;
				else if (text->detected_kcode == DET_SJIS)
				    text->kcode = SJIS;
#endif
				else if (IS_EUC_X0201KANA(hi, lo) && (text->kcode != EUC))
				    text->kcode = SJIS;
			}
			else
			    text->kcode = SJIS;
		    }
		    else if (IS_EUC(hi, lo))
			text->kcode = EUC;
		    else
			text->kcode = NOKANJI;
		}

		switch (kanji_code) {
		case EUC:
		    if (text->kcode == SJIS) {
			SJIS_TO_EUC1(hi, lo, tmp);
			line->data[line->size++] = tmp[0];
			line->data[line->size++] = tmp[1];
		    } else if (IS_EUC(hi, lo)) {
#ifdef CONV_JISX0201KANA_JISX0208KANA
			JISx0201TO0208_EUC(hi, lo, &hi, &lo);
#endif
			line->data[line->size++] = hi;
			line->data[line->size++] = lo;
		    } else {
			CTRACE((tfp, "This character (%X:%X) doesn't seem Japanese\n", hi, lo));
			line->data[line->size++] = '=';
			line->data[line->size++] = '=';
		    }
		    break;

		case SJIS:
		    if ((text->kcode == EUC) || (text->kcode == JIS))
		    {
#ifndef CONV_JISX0201KANA_JISX0208KANA
			if (IS_EUC_X0201KANA(hi, lo))
			    line->data[line->size++] = lo;
			else
#endif
			{
			    EUC_TO_SJIS1(hi, lo, tmp);
			    line->data[line->size++] = tmp[0];
			    line->data[line->size++] = tmp[1];
			}
		    } else if (IS_SJIS_2BYTE(hi, lo)) {
			line->data[line->size++] = hi;
			line->data[line->size++] = lo;
		    } else {
			line->data[line->size++] = '=';
			line->data[line->size++] = '=';
			CTRACE((tfp, "This character (%X:%X) doesn't seem Japanese\n", hi, lo));
		    }
		    break;

		default:
		    break;
d2972 16
d2993 2
a2994 11
	}
#ifndef CONV_JISX0201KANA_JISX0208KANA
	else if ((HTCJK == JAPANESE) && IS_SJIS_X0201KANA(UCH((ch))) &&
		 (kanji_code == EUC)) {
	    line->data[line->size++] = UCH(0x8e);
	    line->data[line->size++] = ch;
	}
#endif
	else if (HTCJK != NOCJK) {
	    line->data[line->size++] = (char) (
				       (kanji_code != NOKANJI) ?
d2997 1
a2997 1
						   TOUPPER(ch) : ch);
d3000 1
a3000 1
		(char) (font & HT_CAPITALS ? TOUPPER(ch) : ch);
d3010 1
a3010 1
	     *  Can split here. -FM
a3017 1
    return;
d3033 1
a3033 11
	if (line->numstyles > 0 && dir == 0 &&
	    line->styles[line->numstyles-1].direction &&
	    line->styles[line->numstyles-1].style == (unsigned) style &&
	    (int) line->styles[line->numstyles-1].horizpos
	    == (int)line->size - ctrl_chars_on_this_line) {
	    /*
	     *  If this is an OFF change directly preceded by an
	     *	ON for the same style, just remove the previous one. - kw
	     */
	    line->numstyles--;
	} else if (line->numstyles < MAX_STYLES_ON_LINE) {
a3034 8
	    /*
	     *  Special chars for bold and underlining usually don't
	     *  occur with color style, but soft hyphen can.
	     *  And in UTF-8 display mode all non-initial bytes are
	     *  counted as ctrl_chars. - kw
	     */
	    if ((int) line->styles[line->numstyles].horizpos >= ctrl_chars_on_this_line)
		line->styles[line->numstyles].horizpos -= ctrl_chars_on_this_line;
d3040 1
a3040 489
}
#endif



/*	Set LastChar element in the text object.
**	----------------------------------------
*/
PUBLIC void HText_setLastChar ARGS2(
	HText *,	text,
	char,		ch)
{
    if (!text)
	return;

    text->LastChar = ch;
}

/*	Get LastChar element in the text object.
**	----------------------------------------
*/
PUBLIC char HText_getLastChar ARGS1(
	HText *,	text)
{
    if (!text)
	return('\0');

    return((char)text->LastChar);
}

/*	Set IgnoreExcess element in the text object.
**	--------------------------------------------
*/
PUBLIC void HText_setIgnoreExcess ARGS2(
	HText *,	text,
	BOOL,		ignore)
{
    if (!text)
	return;

    text->IgnoreExcess = ignore;
}

/*		Simple table handling - private
**		-------------------------------
*/

/*
 *  HText_insertBlanksInStblLines fixes up table lines when simple table
 *  processing is closed, by calling insert_blanks_in_line for lines
 *  that need fixup.  Also recalculates alignment for those lines,
 *  does additional updating of anchor positions, and makes sure the
 *  display of the lines on screen will be updated after partial display
 *  upon return to mainloop. - kw
 */
PRIVATE int HText_insertBlanksInStblLines ARGS2(
    HText *,		me,
    int,		ncols)
{
    HTLine *line;
    HTLine *mod_line, *first_line = NULL;
    int *	oldpos;
    int *	newpos;
    int		ninserts, lineno;
    int		first_lineno, last_lineno, first_lineno_pass2;
#ifdef EXP_NESTED_TABLES
    int		last_nonempty = -1;
#endif
    int		added_chars_before = 0;
    int lines_changed = 0;
    int max_width = 0, indent, spare, table_offset;
    HTStyle *style;
    short alignment;
    int i = 0;

    lineno = first_lineno = Stbl_getStartLine(me->stbl);
    if (lineno < 0 || lineno > me->Lines)
	return -1;
    /*
     *  oldpos, newpos: allocate space for two int arrays.
     */
    oldpos = typecallocn(int, 2 * ncols);
    if (!oldpos)
	return -1;
    else
	newpos = oldpos + ncols;
    for (line = FirstHTLine(me); i < lineno; line = line->next, i++) {
	if (!line) {
	    free(oldpos);
	    return -1;
	}
    }
    first_lineno_pass2 = last_lineno = me->Lines;
    for (; line && lineno <= last_lineno; line = line->next, lineno++) {
	ninserts = Stbl_getFixupPositions(me->stbl, lineno, oldpos, newpos);
	if (ninserts < 0)
	    continue;
	if (!first_line) {
	    first_line = line;
	    first_lineno_pass2 = lineno;
	    if (TRACE) {
		int ip;
		CTRACE((tfp, "line %d first to adjust  --  newpos:", lineno));
		for (ip = 0; ip < ncols; ip++)
		    CTRACE((tfp, " %d", newpos[ip]));
		CTRACE((tfp, "\n"));
	    }
	}
	if (line == me->last_line) {
	    if (line->size == 0 || HText_TrueEmptyLine(line, me, FALSE))
		continue;
	    /*
	     *  Last ditch effort to end the table with a line break,
	     *  if HTML_end_element didn't do it. - kw
	     */
	    if (first_line == line) /* obscure: all table on last line... */
		first_line = NULL;
	    new_line(me);
	    line = me->last_line->prev;
	    if (first_line == NULL)
		first_line = line;
	}
	if (ninserts == 0) {
	    /*  Do it also for no positions (but not error) */
	    int width = HText_TrueLineSize(line, me, FALSE);
	    if (width > max_width)
		max_width = width;
#ifdef EXP_NESTED_TABLES
	    if (nested_tables) {
		if (width && last_nonempty < lineno)
		    last_nonempty = lineno;
	    }
#endif
	    CTRACE((tfp, "line %d true/max width:%d/%d oldpos: NONE\n",
		   lineno, width, max_width));
	    continue;
	}
	mod_line = insert_blanks_in_line(line, lineno, me,
					 &me->last_anchor_before_stbl /*updates++*/,
					 ninserts, oldpos, newpos);
	if (mod_line) {
	    if (line == me->last_line) {
		me->last_line = mod_line;
	    } else {
		added_chars_before += (mod_line->size - line->size);
	    }
	    line->prev->next = mod_line;
	    line->next->prev = mod_line;
	    lines_changed++;
	    if (line == first_line)
		first_line = mod_line;
	    line = mod_line;
#ifdef DISP_PARTIAL
	    /*
	     *  Make sure modified lines get fully re-displayed after
	     *  loading with partial display is done.
	     */
	    if (me->first_lineno_last_disp_partial >= 0) {
		if (me->first_lineno_last_disp_partial >= lineno) {
		    me->first_lineno_last_disp_partial =
			me->last_lineno_last_disp_partial = -1;
		} else if (me->last_lineno_last_disp_partial >= lineno) {
		    me->last_lineno_last_disp_partial = lineno - 1;
		}
	    }
#endif
	}
	{
	    int width = HText_TrueLineSize(line, me, FALSE);
	    if (width > max_width)
		max_width = width;
#ifdef EXP_NESTED_TABLES
	    if (nested_tables) {
		if (width && last_nonempty < lineno)
		    last_nonempty = lineno;
	    }
#endif
	    if (TRACE) {
		int ip;
		CTRACE((tfp, "line %d true/max width:%d/%d oldpos:",
		       lineno, width, max_width));
		for (ip = 0; ip < ninserts; ip++)
		    CTRACE((tfp, " %d", oldpos[ip]));
		CTRACE((tfp, "\n"));
	    }
	}
    }
    /*
     *  Line offsets have been set based on the paragraph style, and
     *  have already been updated for centering or right-alignment
     *  for each line in split_line.  Here we want to undo all that, and
     *  align the table as a whole (i.e. all lines for which
     *  Stbl_getFixupPositions returned >= 0).  All those lines have to
     *  get the same offset, for the simple table formatting mechanism
     *  to make sense, and that may not actually be the case at this point.
     *
     *  What indentation and alignment do we want for the table as
     *  a whole?  Let's take most style properties from me->style.
     *  With some luck, it is the appropriate style for the element
     *  enclosing the TABLE.  But let's take alignment from the attribute
     *  of the TABLE itself instead, if it was specified.
     *
     *  Note that this logic assumes that all lines have been finished
     *  by split_line.  The order of calls made by HTML_end_element for
     *  HTML_TABLE should take care of this.
     */
    style = me->style;
    alignment = Stbl_getAlignment(me->stbl);
    if (alignment == HT_ALIGN_NONE)
	alignment = style->alignment;
    indent = style->leftIndent;
    /* Calculate spare character positions */
    spare = (WRAP_COLS(me)-1) -
	(int)style->rightIndent - indent - max_width;
    if (spare < 0 && (int)style->rightIndent + spare >= 0) {
	/*
	 *  Not enough room!  But we can fit if we ignore right indentation,
	 *  so let's do that.
	 */
	spare = 0;
    } else if (spare < 0) {
	spare += style->rightIndent; /* ignore right indent, but need more */
    }
    if (spare < 0 && indent + spare >= 0) {
	/*
	 *  Still not enough room.  But we can move to the left.
	 */
	indent += spare;
	spare = 0;
    } else if (spare < 0) {
	/*
	 *  Still not enough.  Something went wrong.  Try the best we
	 *  can do.
	 */
	CTRACE((tfp, "BUG: insertBlanks: resulting table too wide by %d positions!\n",
	       -spare));
	indent = spare = 0;
    }
    /*
     *  Align left, right or center.
     */
    switch (alignment) {
	case HT_CENTER :
	    table_offset = indent + spare/2;
	    break;
	case HT_RIGHT :
	    table_offset = indent + spare;
	    break;
	case HT_LEFT :
	case HT_JUSTIFY :
	default:
	    table_offset = indent;
	    break;
    } /* switch */

    CTRACE((tfp, "changing offsets"));
    for (line = first_line, lineno = first_lineno_pass2;
	 line && lineno <= last_lineno && line != me->last_line;
	 line = line->next, lineno++) {
	ninserts = Stbl_getFixupPositions(me->stbl, lineno, oldpos, newpos);
	if (ninserts >= 0 && (int) line->offset != table_offset) {
#ifdef DISP_PARTIAL
	    /*  As above make sure modified lines get fully re-displayed */
	    if (me->first_lineno_last_disp_partial >= 0) {
		if (me->first_lineno_last_disp_partial >= lineno) {
		    me->first_lineno_last_disp_partial =
			me->last_lineno_last_disp_partial = -1;
		} else if (me->last_lineno_last_disp_partial >= lineno) {
		    me->last_lineno_last_disp_partial = lineno - 1;
		}
	    }
#endif
	    CTRACE((tfp, " %d:%d", lineno, table_offset - line->offset));
	    line->offset = table_offset;
	}
    }
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	if (max_width)
	    Stbl_update_enclosing(me->stbl, max_width, last_nonempty);
    }
#endif
    CTRACE((tfp, " %d:done\n", lineno));
    free(oldpos);
    return lines_changed;
}

/*		Simple table handling - public functions
**		----------------------------------------
*/

/*	Cancel simple table handling
*/
PUBLIC void HText_cancelStbl ARGS1(
	HText *,	me)
{
    if (!me || !me->stbl) {
	CTRACE((tfp, "cancelStbl: ignored.\n"));
	return;
    }
    CTRACE((tfp, "cancelStbl: ok, will do.\n"));
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	STable_info *stbl = me->stbl;
	while (stbl) {
	    STable_info *enclosing = Stbl_get_enclosing(stbl);
	    Stbl_free(stbl);
	    stbl = enclosing;
	}
    } else
#endif
    Stbl_free(me->stbl);
    me->stbl = NULL;
}

/*	Start simple table handling
*/
PUBLIC void HText_startStblTABLE ARGS2(
	HText *,	me,
	short,		alignment)
{
#ifdef EXP_NESTED_TABLES
    STable_info *current = me->stbl;
#endif

    if (!me)
	return;

#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	if (current)
	    new_line(me);
    } else
#endif
    {
	if (me->stbl)
	    HText_cancelStbl(me);	/* auto cancel previously open table */
    }

    me->stbl = Stbl_startTABLE(alignment);
    if (me->stbl) {
	CTRACE((tfp, "startStblTABLE: started.\n"));
#ifdef EXP_NESTED_TABLES
	if (nested_tables) {
	    Stbl_set_enclosing(me->stbl, current, me->last_anchor_before_stbl);
	}
#endif
	me->last_anchor_before_stbl = me->last_anchor;
    } else {
	CTRACE((tfp, "startStblTABLE: failed.\n"));
    }
}

#ifdef EXP_NESTED_TABLES
PRIVATE void free_enclosed_stbl ARGS1(
	HText *,	me)
{
    if (me->enclosed_stbl != NULL) {
	HTList *list = me->enclosed_stbl;
	STable_info *stbl;
	while (NULL != (stbl = (STable_info *)HTList_nextObject(list))) {
	    CTRACE((tfp, "endStblTABLE: finally free %p\n", me->stbl));
	    Stbl_free(stbl);
	}
	HTList_delete(me->enclosed_stbl);
	me->enclosed_stbl = NULL;
    }
}
#else
#define free_enclosed_stbl(me) /* nothing */
#endif

/*	Remove trailing blank lines from the last cell.  */
PUBLIC int HText_trimCellLines ARGS1(
	HText *,	text)
{
    int ret = 0;
    HTLine *lastline;
#if defined(USE_COLOR_STYLE)
    HTStyleChange *laststyles;
#endif

    if (!(text && text->stbl))
	return 0;

    lastline = text->last_line;
#if defined(USE_COLOR_STYLE)
    laststyles = lastline->styles;
#endif
    while ( text->last_line && text->Lines >= 1
	    && HText_LastLineSize(text, FALSE) == 0 ) {
	/* Empty line should survive only if
	   a) It is a first line of a row;
	   b) This is not a fake row.
	   */
	if (Stbl_trimFakeRows(text->stbl, text->Lines, text->last_line->size))
	    ret++, HText_RemoveEmptyLastLine(text);
	else
	    break;
    }

    if (!ret)
	return 0;

#ifndef FIXME_FIXME_XXXX
    /* De-POOL the line */
    memcpy(lastline, text->last_line, LINE_SIZE(text->last_line->size));
#if defined(USE_COLOR_STYLE)
    /* De-POOL the style buffers */
    memcpy(laststyles, lastline->styles,
	   sizeof(HTStyleChange)*lastline->numstyles);
    lastline->styles = laststyles;
#endif

    if (text->last_line->next == text->last_line)
	lastline->next = lastline->prev = lastline;
    text->last_line = lastline;
    lastline->prev->next = lastline;	/* Link in new line */
    lastline->next->prev = lastline;	/* Could be same node of course */

#endif	/* FIXME_FIXME_XXXX */

    /* Fix global state for the last line */
    reset_cached_linedata(text, text->last_line->data,
			  text->last_line->size);
#if 0
    /* XXXX This is not enough.  Actually we need also to clear the
       me->in_word flag of HTML.c.  Since this is not
       possible, fake a real space. */
    text->LastChar = (text->last_line->size
		      ? text->last_line->data[text->last_line->size - 1]
		      : ' ');
#else
    HText_appendCharacter(text, ' ');
#endif
    return ret;
}

/*	Finish simple table handling
 *	Return TRUE if the table is nested inside another table.
 */
PUBLIC int HText_endStblTABLE ARGS1(
	HText *,	me)
{
    int ncols, lines_changed = 0;
    STable_info *enclosing = NULL;

    if (!me || !me->stbl) {
	CTRACE((tfp, "endStblTABLE: ignored.\n"));
	free_enclosed_stbl(me);
	return FALSE;
    }
    CTRACE((tfp, "endStblTABLE: ok, will try.\n"));

    ncols = Stbl_finishTABLE(me->stbl);
    CTRACE((tfp, "endStblTABLE: ncols = %d.\n", ncols));

    if (ncols > 0) {
	lines_changed = HText_insertBlanksInStblLines(me, ncols);
	CTRACE((tfp, "endStblTABLE: changed %d lines, done.\n", lines_changed));
#ifdef DISP_PARTIAL
	/* allow HTDisplayPartial() to redisplay the changed lines.
	 * There is no harm if we got several stbl in the document, hope so.
	 */
	NumOfLines_partial -= lines_changed;  /* fake */
#endif  /* DISP_PARTIAL */
    }

#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	enclosing = Stbl_get_enclosing(me->stbl);
	me->last_anchor_before_stbl = Stbl_get_last_anchor_before(me->stbl);
	if (enclosing == NULL) {
	    Stbl_free(me->stbl);
	    free_enclosed_stbl(me);
	} else {
	    if (me->enclosed_stbl == NULL)
		me->enclosed_stbl = HTList_new();
	    HTList_addObject(me->enclosed_stbl, me->stbl);
	    CTRACE((tfp, "endStblTABLE: postpone free %p\n", me->stbl));
	}
	me->stbl = enclosing;
    } else {
	Stbl_free(me->stbl);
	me->stbl = NULL;
    }
#else
    Stbl_free(me->stbl);
    me->stbl = NULL;
a3042 2
    CTRACE((tfp, "endStblTABLE: have%s enclosing table (%p)\n",
	    enclosing == 0 ? " NO" : "", enclosing));
a3043 2
    return enclosing != 0;
}
d3045 2
a3046 1
/*	Start simple table row
d3048 3
a3050 3
PUBLIC void HText_startStblTR ARGS2(
	HText *,	me,
	short,		alignment)
d3052 1
a3052 1
    if (!me || !me->stbl)
a3053 3
    if (Stbl_addRowToTable(me->stbl, alignment, me->Lines) < 0)
	HText_cancelStbl(me);	/* give up */
}
d3055 1
a3055 7
/*	Finish simple table row
*/
PUBLIC void HText_endStblTR ARGS1(
	HText *,	me)
{
    if (me && me->stbl)
	Stbl_finishRowInTable(me->stbl);
d3058 2
a3059 1
/*	Start simple table cell
d3061 2
a3062 6
PUBLIC void HText_startStblTD ARGS5(
	HText *,	me,
	int,		colspan,
	int,		rowspan,
	short,		alignment,
	BOOL,		isheader)
d3064 2
a3065 16
    if (!me || !me->stbl)
	return;
    if (colspan < 0)
	colspan = 1;
    if (colspan > TRST_MAXCOLSPAN) {
	CTRACE((tfp, "*** COLSPAN=%d is too large, ignored!\n", colspan));
	colspan = 1;
    }
    if (rowspan > TRST_MAXROWSPAN) {
	CTRACE((tfp, "*** ROWSPAN=%d is too large, ignored!\n", rowspan));
	rowspan = 1;
    }
    if (Stbl_addCellToTable(me->stbl, colspan, rowspan, alignment, isheader,
			    me->Lines, HText_LastLineOffset(me), HText_LastLineSize(me,FALSE)) < 0)
	HText_cancelStbl(me);	/* give up */
}
d3067 1
a3067 11
/*	Finish simple table cell
*/
PUBLIC void HText_endStblTD ARGS1(
	HText *,	me)
{
    if (!me || !me->stbl)
	return;
    HText_trimCellLines(me);
    if (Stbl_finishCellInTable(me->stbl, TRST_ENDCELL_ENDTD,
			       me->Lines, HText_LastLineOffset(me), HText_LastLineSize(me,FALSE)) < 0)
	HText_cancelStbl(me);	/* give up */
d3070 2
a3071 1
/*	Remember COL info / Start a COLGROUP and remember info
d3073 3
a3075 5
PUBLIC void HText_startStblCOL ARGS4(
	HText *,	me,
	int,		span,
	short,		alignment,
	BOOL,		isgroup)
d3077 1
a3077 18
    if (!me || !me->stbl)
	return;
    if (span <= 0)
	span = 1;
    if (span > TRST_MAXCOLSPAN) {
	CTRACE((tfp, "*** SPAN=%d is too large, ignored!\n", span));
	span = 1;
    }
    if (Stbl_addColInfo(me->stbl, span, alignment, isgroup) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Finish a COLGROUP
*/
PUBLIC void HText_endStblCOLGROUP ARGS1(
	HText *,	me)
{
    if (!me || !me->stbl)
a3078 3
    if (Stbl_finishColGroup(me->stbl) < 0)
	HText_cancelStbl(me);	/* give up */
}
d3080 1
a3080 10
/*	Start a THEAD / TFOOT / TBODY - remember its alignment info
*/
PUBLIC void HText_startStblRowGroup ARGS2(
	HText *,	me,
	short,		alignment)
{
    if (!me || !me->stbl)
	return;
    if (Stbl_addRowGroup(me->stbl, alignment) < 0)
	HText_cancelStbl(me);	/* give up */
a3085 27
PRIVATE void add_link_number ARGS3(
    HText *,		text,
    TextAnchor *,	a,
    BOOL,		save_position)
{
    char marker[32];

    /*
     *  If we are doing link_numbering add the link number.
     */
    if ((a->number > 0)
#ifdef USE_PRETTYSRC
     && (text->source ? !psrcview_no_anchor_numbering : 1 )
#endif
     && links_are_numbered()) {
	char saved_lastchar = text->LastChar;
	int saved_linenum = text->Lines;
	sprintf(marker,"[%d]", a->number);
	HText_appendText(text, marker);
	if (saved_linenum && text->Lines && saved_lastchar != ' ')
	    text->LastChar = ']'; /* if marker not after space caused split */
	if (save_position) {
	    a->line_num = text->Lines;
	    a->line_pos = text->last_line->size;
	}
    }
}
d3094 3
a3096 1
    TextAnchor * a;
a3097 1
    POOLtypecalloc(TextAnchor, a);
d3100 3
d3119 1
a3119 1
    if (HTAnchor_followTypedLink(anc, HTInternalLink)) {
d3124 1
a3124 1
    if (HTAnchor_followLink(anc)) {
d3130 17
a3146 2
    if (number_links_on_left)
	add_link_number(text, a, TRUE);
d3150 2
a3151 2
/* If !really, report whether the anchor is empty. */
PRIVATE BOOL HText_endAnchor0 ARGS3(
d3153 1
a3153 2
	int,		number,
	int,		really)
d3165 1
a3165 1
     *  within which that link might be embedded. -FM
d3179 1
a3179 1
	     *  and cross our fingers. -FM
d3185 2
a3186 2
    CTRACE((tfp, "GridText:HText_endAnchor0: number:%d link_type:%d\n",
			a->number, a->link_type));
d3192 3
a3194 3
	CTRACE((tfp,
	   "BUG: HText_endAnchor0: internal error: last anchor was input field!\n"));
	return FALSE;
a3195 1

d3201 3
a3203 2
	BOOL remove_numbers_on_empty = (BOOL) (
	    (links_are_numbered() &&
d3208 1
a3208 1
		   HTAnchor_followLink(a->anchor))))));
a3213 12
	int extent_adjust = 0;

	/* Find the length taken by the anchor */
	l = text->Lines;		/* lineno of last */
	while (l > a->line_num) {
	    extent_adjust += start->size;
	    start = start->prev;
	    l--;
	}
	/* Now start is the start line of the anchor */
	extent_adjust += start->size - a->line_pos;
	start = last;			/* Used later */
d3218 1
a3218 1
	 *  with the content on the last line. -FM
d3220 2
a3221 1
	a->extent += extent_adjust;
d3225 1
a3225 1
	     *  so set up to check the entire last line. -FM
d3231 1
a3231 1
	     *  so check from the start of the anchor. -FM
d3238 1
a3238 1
		!isspace(UCH(last->data[j])) &&
d3251 1
a3251 1
		 *  of the last line as blank. -FM
d3258 1
a3258 1
		 *  declare the anchor's extent as blank. -FM
d3269 1
a3269 1
	 *  white and special characters. -FM
d3283 1
a3283 1
		 *  so check all of this line. -FM
d3289 1
a3289 1
		 *  The anchor starts on this line. -FM
d3295 1
a3295 1
		    !isspace(UCH(prev->data[j])) &&
d3313 1
a3313 1
		     *  the line to be analyzed. -FM
d3322 1
a3322 1
		     *  declare the anchor's extent as blank. -FM
a3328 4
	if (!really) {			/* Just report whether it is empty */
	    a->extent -= extent_adjust;
	    return (BOOL)(i == 0);
	}
d3333 1
a3333 1
	     *  USEMAP. -FM
d3337 4
a3340 4
	    CTRACE((tfp,
		   "HText_endAnchor0: hidden (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
		   a->line_num, a->line_pos, a->extent,
		   BlankExtent));
d3344 1
a3344 1
	     *  numbered bracket and adjust the anchor count. -FM
d3361 1
a3361 1
		 *  anchor start. -FM
d3365 1
a3365 1
		     *  The anchor starts on the last line. -FM
d3370 1
a3370 1
		     *  The anchor starts on a previous line. -FM
d3386 1
a3386 1
		 *  from that line. -FM
d3391 1
a3391 1
		    while (j >= 0 && isdigit(UCH(start->data[j]))) {
d3402 1
a3402 1
			 *  on this line. -FM
d3414 2
d3417 1
d3420 1
a3420 1
				anc->line_pos -= NumSize;
d3434 1
a3434 1
			       isdigit(UCH(prev->data[j]))) {
d3446 1
a3446 1
			     *  wrapped to this line. -FM
d3452 4
d3470 2
d3473 1
d3486 1
a3486 1
			     *  numbered bracket. -FM
d3493 1
a3493 1
			 *  numbered bracket. -FM
d3506 1
a3506 1
			 isdigit(UCH(prev->data[j - 1])))) {
d3511 1
a3511 1
			       isdigit(UCH(prev->data[j]))) {
d3523 1
a3523 1
			     *  was wrapped to the last line. -FM
d3529 4
d3540 1
a3540 1
			     *  numbered bracket. -FM
d3547 1
a3547 1
			 *  numbered bracket. -FM
d3554 1
a3554 1
		     *  numbered bracket. -FM
a3559 2
	    if (!number_links_on_left)
		add_link_number(text, a, FALSE);
d3563 1
a3563 1
	     *  as a link. -FM
d3567 4
a3570 4
		CTRACE((tfp,
		   "HText_endAnchor0: blanks (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
		   a->line_num,a->line_pos,a->extent,
		   BlankExtent));
d3576 1
a3576 1
	     *  and special characters, so set its number
d3579 1
a3579 1
	     *  to the hidden links list. -FM
d3591 2
a3592 2
	     *  content, but shorten its extent by any trailing
	     *  blank lines we've detected. -FM
d3598 2
a3599 2
	    CTRACE((tfp,
		   "->[%d](%d,%d,%d,%d)\n",
d3601 2
a3602 2
		   a->line_num,a->line_pos,a->extent,
		   BlankExtent));
a3604 2
	if (!really)			/* Just report whether it is empty */
	    return FALSE;
d3608 1
a3608 1
	 *  link. -FM
a3612 8
    return FALSE;
}

PUBLIC void HText_endAnchor ARGS2(
	HText *,	text,
	int,		number)
{
    HText_endAnchor0(text, number, 1);
a3614 13
/*
    This returns whether the given anchor has blank content. Shamelessly copied
    from HText_endAnchor. The values returned are meaningful only for "normal"
    links - like ones produced by <a href=".">foo</a>, no inputs, etc. - VH
*/
#ifdef MARK_HIDDEN_LINKS
PUBLIC BOOL HText_isAnchorBlank ARGS2(
	HText *,	text,
	int,		number)
{
    return HText_endAnchor0(text, number, 0);
}
#endif /* MARK_HIDDEN_LINKS */
d3634 1
a3634 1
PRIVATE int remove_special_attr_chars ARGS1(
a3637 1
    register int soft_newline_count = 0;
a3642 1
	soft_newline_count += (*cp == LY_SOFT_NEWLINE);
d3644 2
a3645 1
	   *buf++ = *cp;
a3648 1
    return soft_newline_count;
d3666 1
a3666 1
    CTRACE((tfp,"Gridtext: Entering HText_endAppend\n"));
a3673 2
	if (text->stbl)
	    HText_cancelStbl(text);
a3680 6
    } else if (text->stbl) {
	/*
	 *  Could happen if TABLE end tag was missing.
	 *  Alternatively we could cancel in this case. - kw
	 */
	HText_endStblTABLE(text);
d3686 1
a3686 1
    line_ptr = FirstHTLine(text);
d3694 3
a3696 2
	CTRACE((tfp, "GridText: Removing bottom blank line: `%s'\n",
			    text->last_line->data));
d3702 1
d3705 2
a3706 2
	CTRACE((tfp, "GridText: New bottom line: `%s'\n",
			    text->last_line->data));
d3711 1
a3711 1
     *  create the hightext strings. -FM
d3713 1
a3713 1
    HText_trimHightext(text, TRUE, -1);
d3732 6
a3737 7
**
**  AFTER the adjustment, the anchor line_pos (and hightext offset if
**  applicable) fields indicate x positions in terms of displayed character
**  cells, and the extent field apparently is unimportant; the anchor text has
**  been copied to the hightext fields (which should have been NULL up to that
**  point), with special attribute chars removed.
**
d3741 1
a3741 1
PRIVATE void HText_trimHightext ARGS3(
d3743 1
a3743 2
	BOOLEAN,	final,
	int,		stop_before)
d3745 1
a3745 1
    int cur_line, cur_shift;
a3748 1
    HTLine *line_ptr2;
a3749 4
    char *hilite_str;
    int hilite_len;
    int actual_len;
    int count_line;
d3754 2
a3755 9
    if (final) {
	CTRACE((tfp, "Gridtext: Entering HText_trimHightext (final)\n"));
    } else {
	if (stop_before < 0 || stop_before > text->Lines)
	    stop_before = text->Lines;
	CTRACE((tfp,
	       "Gridtext: Entering HText_trimHightext (partial: 0..%d/%d)\n",
	       stop_before, text->Lines));
    }
d3760 2
a3761 1
    line_ptr = FirstHTLine(text);
d3766 1
a3766 1
     *  create the hightext strings. -FM
d3769 2
a3770 3
	anchor_ptr != NULL;
	prev_a = anchor_ptr, anchor_ptr = anchor_ptr->next) {
	int have_soft_newline_in_1st_line = 0;
d3775 4
a3778 2
	for (; anchor_ptr->line_num > cur_line;
	       line_ptr = line_ptr->next, cur_line++) {
d3788 1
a3788 1
	    if (cur_line >= stop_before)
d3790 1
a3790 2
	    if ( anchor_ptr->line_num >= text->Lines - 1
		 && anchor_ptr->line_pos >= (int) text->last_line->prev->size )
d3808 1
a3808 1
	if (LYGetHiTextStr(anchor_ptr, 0) != NULL)
d3811 1
a3811 1
	if (anchor_ptr->line_pos > (int) line_ptr->size) {
d3813 3
d3818 1
d3822 1
a3822 1
	CTRACE((tfp,
d3825 1
a3825 1
	       anchor_ptr->number, anchor_ptr->extent));
d3833 1
a3833 1
	    ch = UCH(line_ptr->data[anchor_ptr->line_pos]);
d3839 1
a3839 1
		ch = UCH(line_ptr->data[anchor_ptr->line_pos]);
d3845 1
d3847 2
a3848 1
	CTRACE((tfp, "anchor text: '%s'\n", line_ptr->data));
d3850 5
a3854 6
	 * If the link begins with an end of line and we have more lines, then
	 * start the highlighting on the next line.  -FM.
	 *
	 * But if an empty anchor is at the end of line and empty, keep it
	 * where it is, unless the previous anchor in the list (if any) already
	 * starts later.  - kw
d3860 3
a3862 5
		 (prev_a && /* How could this happen? */
		  (prev_a->line_num > anchor_ptr->line_num)))) {
		anchor_ptr->line_num++;
		anchor_ptr->line_pos = 0;
		CTRACE((tfp, "found anchor at end of line\n"));
d3865 1
a3865 1
		CTRACE((tfp, "found anchor at end of line, leaving it there\n"));
d3870 1
a3870 1
	 * Copy the link name into the data structure.
d3872 5
a3876 7
	if (line_ptr->data
	 && anchor_ptr->extent > 0
	 && anchor_ptr->line_pos >= 0) {
	    LYClearHiText(anchor_ptr);
	    LYSetHiText(anchor_ptr,
			&line_ptr->data[anchor_ptr->line_pos],
			anchor_ptr->extent);
d3878 1
a3878 2
	    LYClearHiText(anchor_ptr);
	    LYSetHiText(anchor_ptr, "", 0);
d3882 2
a3883 2
	 * If the anchor extends over more than one line, copy that into the
	 * data structure.
d3885 2
a3886 3
	hilite_str = LYGetHiTextStr(anchor_ptr, 0);
	hilite_len = strlen(hilite_str);
	actual_len = anchor_ptr->extent;
d3888 5
a3892 14
	line_ptr2 = line_ptr;
	count_line = cur_line;
	while (actual_len > hilite_len) {
	    HTLine *old_line_ptr2 = line_ptr2;

	    count_line++;
	    line_ptr2 = line_ptr2->next;

	    if (!final
	     && count_line >= stop_before) {
		LYClearHiText(anchor_ptr);
		break;
	    } else if (old_line_ptr2 == text->last_line) {
		break;
a3893 1

d3895 2
a3896 2
	     * Double check that we have a line pointer, and if so, copy into
	     * highlight text.
d3898 2
a3899 6
	    if (line_ptr2
	     && line_ptr2->size) {
		char *hi_string = NULL;
		int hi_offset = line_ptr2->offset;

		StrnAllocCopy(hi_string,
d3901 4
a3904 5
			      (actual_len - hilite_len));
		actual_len -= strlen(hi_string);
		/*handle LY_SOFT_NEWLINEs -VH */
		hi_offset += remove_special_attr_chars(hi_string);

d3906 5
a3910 4
		    LYTrimTrailing(hi_string);
		}
		if (non_empty(hi_string)) {
		    LYAddHiText(anchor_ptr, hi_string, hi_offset);
a3911 1
		FREE(hi_string);
d3914 1
a3914 8

	if (!final
	 && count_line >= stop_before) {
	    break;
	}

	hilite_str = LYGetHiTextStr(anchor_ptr, 0);
	remove_special_attr_chars(hilite_str);
d3916 1
a3916 1
	    LYTrimTrailing(hilite_str);
d3920 2
a3921 1
	 * Subtract any formatting characters from the x position of the link.
d3925 1
a3925 1
	    for (; i < anchor_ptr->line_pos; i++) {
d3927 1
a3927 1
		    IsSpecialAttrChar(line_ptr->data[i])) {
a3928 3
		    have_soft_newline_in_1st_line += (line_ptr->data[i] == LY_SOFT_NEWLINE);
		}
	    }
d3938 3
a3940 2
	/*handle LY_SOFT_NEWLINEs -VH */
	anchor_ptr->line_pos += have_soft_newline_in_1st_line;
d3942 5
a3946 3
	CTRACE((tfp, "GridText:     add link on line %d col %d [%d] %s\n",
	       cur_line, anchor_ptr->line_pos,
	       anchor_ptr->number, "in HText_trimHightext"));
d3951 9
a3970 1

d3972 2
a3973 2
 *  HText_childNextNumber() returns the anchor with index [number],
 *  using a pointer from the previous number (=optimization) or NULL.
d3975 2
a3976 3
PUBLIC HTChildAnchor * HText_childNextNumber ARGS2(
	int,		number,
	void**,		prev)
d3978 1
a3978 2
    /* Sorry, TextAnchor is not declared outside this file, use a cast. */
    TextAnchor * a = *prev;
d3980 1
a3980 1
    if (!HTMainText || number <= 0)
a3981 2
    if (number == 1 || !a)
	a = HTMainText->first_anchor;
d3983 5
a3987 10
    /* a strange thing:  positive a->number's are sorted,
     * and between them several a->number's may be 0 -- skip them
     */
    for( ; a && a->number != number; a = a->next)
	;

    if (!a)
	return (HTChildAnchor *)0;	/* Fail */
    *prev = (void*)a;
    return a->anchor;
d3993 1
a3993 1
 *  for the field. -FM & LE
d4089 3
a4091 3
    CTRACE((tfp, "HTGetRelLinkNum(%d,%d,%d) -- HTMainText=%p\n",
	   num, rel, cur, HTMainText));
    CTRACE((tfp,"  scrtop=%d, curline=%d, curanchor=%d, display_lines=%d, %s\n",
d4093 1
a4093 1
	   on_screen ? "on_screen" : "0"));
d4099 1
a4099 1
	CTRACE((tfp,"curanchor=%d at line %d on screen\n",curanchor,curline));
d4109 1
a4109 1
	CTRACE((tfp,"  a->line_num=%d, a->number=%d\n", a->line_num, a->number));
d4115 1
a4115 1
    CTRACE((tfp,"  a=%p, l=%p, curanchor=%d\n",a,l,curanchor));
d4177 2
a4178 2
	    !(a->link_type == INPUT_ANCHOR
	      && a->input_field->type == F_HIDDEN_TYPE)) {
d4266 2
a4267 2
		*hightext = LYGetHiTextStr(a, 0);
		link_dest = HTAnchor_followLink(a->anchor);
d4276 1
a4276 1
				a->anchor, HTInternalLink);
d4279 2
a4280 2
				CTRACE((tfp, "HTGetLinkInfo: unexpected typed link to %s!\n",
					    link_dest_intl->parent->address));
d4328 1
a4328 2
	formA->type != F_TEXTAREA_TYPE ||
	formB->type != F_TEXTAREA_TYPE) {
d4335 1
a4335 1
    return (BOOL) (strcmp(formA->name, formB->name) == 0);
d4338 1
a4338 1
#define same_anchor_as_link(i,a,ta_same) (i >= 0 && a &&\
d4340 1
a4340 1
		(links[i].type == WWW_FORM_LINK_TYPE) ? links[i].l_form : NULL,\
d4343 2
a4344 2
		ta_same))
#define same_anchors(a1,a2,ta_same) (a1 && a2 &&\
d4349 1
a4349 40
		ta_same))

/*
 *  Are there more textarea lines belonging to the same textarea before
 *  (direction < 0) or after (direction > 0) the current one?
 *  On entry, curlink must be the index in links[] of a textarea field. - kw
 */
PUBLIC BOOL HText_TAHasMoreLines ARGS2(
	int,		curlink,
	int,		direction)
{
    TextAnchor *a;
    TextAnchor *prev_a = NULL;

    if (!HTMainText)
	return(NO);
    if (direction < 0) {
	for (a = HTMainText->first_anchor; a; prev_a = a, a = a->next) {
	    if (a->link_type == INPUT_ANCHOR &&
		links[curlink].l_form == a->input_field) {
		return same_anchors(a, prev_a, TRUE);
	    }
	    if (links[curlink].anchor_number &&
		a->number >= links[curlink].anchor_number)
		break;
	}
	return NO;
    } else {
	for (a = HTMainText->first_anchor; a; a = a->next) {
	    if (a->link_type == INPUT_ANCHOR &&
		links[curlink].l_form == a->input_field) {
		return same_anchors(a, a->next, TRUE);
	    }
	    if (links[curlink].anchor_number &&
		a->number >= links[curlink].anchor_number)
		break;
	}
	return NO;
    }
}
d4412 2
a4413 2
	    !(a->link_type == INPUT_ANCHOR
	      && a->input_field->type == F_HIDDEN_TYPE)) {
d4427 1
a4427 1
	    if (!same_anchors(current.anc, a, ta_skip)) {
d4440 1
a4440 1
		if (same_anchor_as_link(curlink,a, ta_skip)) {
d4449 1
a4449 1
			   same_anchor_as_link(curlink,previous.anc, ta_skip)) {
d4544 7
d4567 1
a4567 1
 *  *data with all IsSpecial characters stripped, its offset and
d4570 1
a4570 1
 *  TRUE is returned. -FM
d4579 1
a4579 1
	CONST char *,	target)
d4588 1
a4588 1
     *  in its range, and that we have a target string. -FM
d4590 2
a4591 4
    if (!(text &&
	line_num >= 0 &&
	line_num <= text->Lines &&
	non_empty(target))) {
a4592 1
    }
d4595 1
a4595 1
     *  Find the line and set up its data and offset -FM
d4597 1
a4597 1
    for (i = 0, line = FirstHTLine(text);
d4613 1
a4613 1
     *  data, and return TRUE. -FM
d4615 12
a4626 6
    if (((cp = LYno_attr_mb_strstr(LineData,
				   target,
				   utf_flag, YES,
				   &HitOffset,
				   &LenNeeded)) != NULL) &&
	(LineOffset + LenNeeded) < DISPLAY_COLS) {
d4631 1
a4631 1
	 *  return TRUE. -FM
d4641 1
a4641 1
     *  The line does not contain the target. -FM
d4665 1
a4665 1
#ifdef USE_COLOR_STYLE
d4676 1
a4676 1
 *  attachment; filename=name.suffix). -FM
d4690 1
a4690 1
 *  believe the headers about whether it's compressed or not. -FM
a4702 1
    char *suffix;
d4705 1
a4705 2
    CompressFileType method = cftNone;
    CompressFileType second;
d4708 1
a4708 1
     *  Make sure we have a string and anchor. -FM
d4710 1
a4710 1
    if (!(fn && anchor))
d4716 6
a4721 2
    if (*(fn = LYPathLeaf(fn)) == '\0')
	return;
d4725 1
a4725 1
     *  elements for a gzip or Unix compressed file. -FM
d4729 1
a4729 1
    if (ce == NULL && ct != 0) {
d4732 1
a4732 1
	 *  the Content-Type. -FM
d4734 8
a4741 20
	if (!strncasecomp(ct, "application/gzip", 16) ||
	    !strncasecomp(ct, "application/x-gzip", 18)) {
	    method = cftGzip;
	} else if (!strncasecomp(ct, "application/compress", 20) ||
		   !strncasecomp(ct, "application/x-compress", 22)) {
	    method = cftCompress;
	} else if (!strncasecomp(ct, "application/bzip2", 17) ||
		   !strncasecomp(ct, "application/x-bzip2", 19)) {
	    method = cftBzip2;
	}
    } else if (ce != 0) {
	if (!strcasecomp(ce, "gzip") ||
	    !strcasecomp(ce, "x-gzip")) {
	    method = cftGzip;
	} else if (!strcasecomp(ce, "compress") ||
		   !strcasecomp(ce, "x-compress")) {
	    method = cftCompress;
	} else if (!strcasecomp(ce, "bzip2") ||
		   !strcasecomp(ce, "x-bzip2")) {
	    method = cftBzip2;
d4743 12
d4762 1
a4762 11
    if ((method == cftNone) && !strip_ok)
	return;

    /*
     * Treat .tgz specially
     */
    if ((dot = strrchr(fn, '.')) != NULL
     && !strcasecomp(dot, ".tgz")) {
	if (method == cftNone) {
	    strcpy(dot, ".tar");
	}
a4763 1
    }
d4767 1
a4767 1
     *  we have a gzip or compress suffix. -FM
d4770 4
a4773 2
	if (HTCompressFileType(fn, ".", &cp) != cftNone) {
	    if (method == cftNone) {
d4777 1
a4777 1
		 *  claims otherwise, so tweak the suffix. -FM
d4779 1
d4781 3
d4787 47
a4833 16
	if ((second = HTCompressFileType(fn, "-_", &cp)) != cftNone) {
	    if (method == cftNone) {
		/*
		 *  It has a tail which signifies a gzipped
		 *  file for us, but the anchor claims otherwise,
		 *  so tweak the suffix. -FM
		 */
		if (cp == dot+1)
		    cp--;
		*cp = '\0';
	    } else {
		/*
		 *  The anchor claims it's gzipped, and we
		 *  believe it, so force this tail to the
		 *  conventional suffix. -FM
		 */
d4835 1
a4835 1
		*cp = '-';
d4837 1
a4837 1
		*cp = '.';
d4839 4
a4842 4
		if (second == cftCompress)
		    LYUpperCase(cp);
		else
		    LYLowerCase(cp);
a4843 1
	    return;
d4846 7
a4852 14

    switch (method) {
    default:
	suffix = "";
	break;
    case cftCompress:
	suffix = ".Z";
	break;
    case cftGzip:
	suffix = ".gz";
	break;
    case cftBzip2:
	suffix = ".bz2";
	break;
d4856 11
a4866 9
     *  Add the appropriate suffix. -FM
     */
    if (*suffix) {
	if (!dot) {
	    StrAllocCat(*fname, suffix);
	} else if (*++dot == '\0') {
	    StrAllocCat(*fname, suffix + 1);
	} else {
	    StrAllocCat(*fname, suffix);
d4868 3
a4870 1
	    (*fname)[strlen(*fname) - strlen(suffix)] = '-';
d4872 1
a4872 2
	}
    }
d4877 1
a4877 1
 *  if available, for the current document. -FM
d4887 1
a4887 1
 *  if available, for the current document. -FM
d4897 1
a4897 1
 *  if available, for the current document. -FM
d4916 1
a4916 1
	CTRACE((tfp, "GridText: HText_pageDisplay at line %d started\n", line_num));
a4919 1
	int stop_before = -1;
d4929 1
a4929 3
	if (HTMainText && HTMainText->stbl)
	    stop_before = Stbl_getStartLineDeep(HTMainText->stbl);
	HText_trimHightext(HTMainText, FALSE, stop_before);
d4937 1
a4937 1
	LYSleepMsg();
d4944 1
a4944 1
	CTRACE((tfp, "GridText: HText_pageDisplay finished\n"));
d4963 1
a4963 1
 *  'Lines' number of lines beginning with 'line_num'-1. -FM
d4979 2
a4980 2
	 Anchor_ptr != NULL && Anchor_ptr->line_num <= end;
	 Anchor_ptr = Anchor_ptr->next) {
d4984 2
a4985 2
	    !(Anchor_ptr->link_type == INPUT_ANCHOR
	      && Anchor_ptr->input_field->type == F_HIDDEN_TYPE))
d4987 2
d5016 1
a5016 1
    return (BOOL) (text->top_of_screen != 0);
d5023 2
a5024 2
    return (BOOL) ((text != 0)
     && ((text->top_of_screen + display_lines) < text->Lines+1));
d5055 20
a5074 2
**		==================
*/
a5075 2
/* Bring to front and highlight it
*/
d5080 3
a5099 21
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	/* text->UCLYhndl is not reset by META, so use a more circumvent way */
	if ( text->node_anchor->UCStages->s[UCT_STAGE_HTEXT].LYhndl
	     != current_char_set )
	    Switch_Display_Charset(text->node_anchor->UCStages->s[UCT_STAGE_HTEXT].LYhndl, SWITCH_DISPLAY_CHARSET_MAYBE);
#endif
	if (HTMainText) {
	    if (HText_hasUTF8OutputSet(HTMainText) &&
		HTLoadedDocumentEightbit() &&
		LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
		text->had_utf8 = HTMainText->has_utf8;
	    } else {
		text->had_utf8 = NO;
	    }
	    HTMainText->has_utf8 = NO;
	    text->has_utf8 = NO;
	}

	HTMainText = text;
	HTMainAnchor = text->node_anchor;

d5101 1
a5101 1
	 *  Make this text the most current in the loaded texts list. -FM
d5105 2
a5106 2
	    /* let lynx do it */
	    /* display_page(text, text->top_of_screen, ""); */
d5114 1
a5114 1
 *  (memory cached) text. -FM
d5117 1
a5117 1
	DocInfo *,	doc)
d5121 1
a5121 2
    bstring *post_data;
    char *address;
d5125 1
a5125 1
     *  Make sure we have the structures. -FM
d5131 1
a5131 1
     *  Make sure doc is for a POST reply. -FM
d5140 1
a5140 1
     *  POST reply match. -FM
d5145 1
a5145 1
	    BINEQ(post_data, text->node_anchor->post_data) &&
d5157 1
a5157 1
	CONST char *,		selector)
d5161 1
a5161 1
    for (a = HTMainText->first_anchor; a != 0; a = a->next) {
d5163 1
a5163 1
	if (a->anchor && a->anchor->tag) {
d5168 4
a5171 3
		CTRACE((tfp, "FindPound: Selecting anchor [%d] at line %d\n",
			     a->number, www_search_result));
		if (!strcmp(selector, LYToolbarName)) {
d5173 2
a5174 2
		}
		return(YES);
a5175 1
	}
d5199 1
a5199 1
	CTRACE((tfp, "HText: No such anchor in this text!\n"));
d5209 4
a5212 3
	 int l = a->line_num;
	 CTRACE((tfp, "HText: Selecting anchor [%d] at line %d\n",
		      a->number, l));
d5314 2
a5315 2
    HText * text = HTMainText;
    return text != 0 ? text->top_of_screen : 0;
d5321 1
a5321 1
    return text->Lines;
d5332 1
a5332 1
 *  Utility for freeing the list of previous isindex and whereis queries. -FM
d5352 1
a5352 1
 *  any repeated queries the most current in the list. -FM
d5357 1
a5357 1
    char *new_query = NULL;
d5361 1
a5361 1
    if (!non_empty(query))
d5364 3
a5366 1
    StrAllocCopy(new_query, query);
d5373 1
a5373 1
	HTList_addObject(search_queries, new_query);
d5379 1
a5379 1
	if (!strcmp(old, new_query)) {
d5385 1
a5385 1
    HTList_addObject(search_queries, new_query);
d5391 1
a5391 1
	DocInfo *,	doc)
d5408 1
a5408 1
	LYstrncpy(searchstring, ++cp, sizeof(searchstring)-1);
d5415 1
a5415 1
	 *  Make sure it's treated as the most recent query. -FM
d5438 1
a5438 1
	       (!PreviousSearch && QueryTotal >= 1)) ? RECALL_URL : NORECALL);
d5447 1
a5447 1
		 *  Use the second to last query in the list. -FM
d5453 1
a5453 1
		 *  Go back to the previous query in the list. -FM
d5459 1
a5459 1
		 *  Roll around to the last query in the list. -FM
d5464 1
a5464 1
		LYstrncpy(searchstring, cp, sizeof(searchstring)-1);
d5478 1
a5478 1
		 *  Use the first query in the list. -FM
d5484 1
a5484 1
		 *  Advance to the next query in the list. -FM
d5490 1
a5490 1
		 *  Roll around to the first query in the list. -FM
d5495 1
a5495 1
		LYstrncpy(searchstring, cp, sizeof(searchstring)-1);
d5516 1
a5516 1
     *  Strip leaders and trailers. -FM
d5535 1
a5535 1
     *  or make it the most current. -FM
d5548 5
a5552 3
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
    LYSyslog(tmpaddress);
#endif /* !VMS && SYSLOG_REQUESTED_URLS */
d5573 1
a5573 1
	CTRACE((tfp,"\ndo_www_search: newfile: %s\n",doc->address));
d5586 1
a5586 1
     *  rejecting it. -FM
a5590 27
PRIVATE void write_offset ARGS2(
	FILE *,		fp,
	HTLine *,	line)
{
    int i;

    if (line->data[0]) {
	for (i = 0; i < (int)line->offset; i++) {
	     fputc(' ', fp);
	}
    }
}

PRIVATE void write_hyphen ARGS1(
	FILE *,		fp)
{
    if (dump_output_immediately &&
	LYRawMode &&
	LYlowest_eightbit[current_char_set] <= 173 &&
	(LYCharSet_UC[current_char_set].enc == UCT_ENC_8859 ||
	 (LYCharSet_UC[current_char_set].like8859 & UCT_R_8859SPECL)) != 0) {
	fputc(0xad, fp); /* the iso8859 byte for SHY */
    } else {
	fputc('-', fp);
    }
}

d5599 1
a5599 1
	BOOLEAN,	is_reply)
a5603 10
#ifndef NO_DUMP_WITH_BACKSPACES
    HText* text = HTMainText;
    BOOL in_b = FALSE;
    BOOL in_u = FALSE;
    BOOL bs = (BOOL)(!is_reply
		&& text != 0
		&& with_backspaces
		&& HTCJK == NOCJK
		&& !text->T.output_utf8);
#endif
d5608 1
a5608 1
    line = FirstHTLine(HTMainText);
d5610 2
a5611 6
	if (first) {
	    first = FALSE;
	    if (is_reply) {
		fputc('>',fp);
	    }
	} else if (line->data[0] != LY_SOFT_NEWLINE) {
d5613 7
a5619 6
	    /*
	     *  Add news-style quotation if requested. -FM
	     */
	    if (is_reply) {
		fputc('>',fp);
	    }
d5622 6
a5627 1
	write_offset(fp, line);
a5633 11
#ifndef NO_DUMP_WITH_BACKSPACES
		if (in_b) {
		    fputc(line->data[i], fp);
		    fputc('\b',fp);
		    fputc(line->data[i], fp);
		} else if (in_u) {
		    fputc('_',fp);
		    fputc('\b',fp);
		    fputc(line->data[i], fp);
		} else
#endif
d5637 10
a5646 1
		write_hyphen(fp);
a5657 21
#ifndef NO_DUMP_WITH_BACKSPACES
	    else if (bs) {
		switch (line->data[i]) {
		    case LY_UNDERLINE_START_CHAR:
			if (!in_b)
			    in_u = TRUE; /*favor bold over underline*/
			break;
		    case LY_UNDERLINE_END_CHAR:
			in_u = FALSE;
			break;
		    case LY_BOLD_START_CHAR:
			if (in_u)
			    in_u = FALSE; /* turn it off*/
			in_b = TRUE;
			break;
		    case LY_BOLD_END_CHAR:
			in_b = FALSE;
			break;
		}
	    }
#endif
d5689 1
a5689 1
    line = FirstHTLine(HTMainText);
d5696 2
a5697 1
	if (!first && line->data[0] != LY_SOFT_NEWLINE)
d5700 6
a5705 1
	write_offset(fp, line);
d5715 11
a5725 2
		write_hyphen(fp);
	    }
d5738 2
a5739 1
	links_are_numbered()) {
d5749 1
a5749 1
    DocInfo *,	doc,
d5759 1
a5759 1
	BOOL on_screen = (BOOL) (tentative_result > HTMainText->top_of_screen &&
d5819 15
a5833 120
PRIVATE BOOL anchor_has_target ARGS2(
	TextAnchor *,	a,
	char *,		target)
{
    OptionType * option;
    char *stars = NULL, *cp;
    int count;

    /*
     * Search the hightext strings, taking the case_sensitive setting into
     * account.  -FM
     */
    for (count = 0; ; ++count) {
	if ((cp = LYGetHiTextStr(a, count)) == NULL)
	    break;
	if (LYno_attr_strstr(cp, target))
	    return TRUE;
    }

    /*
     *  Search the relevant form fields, taking the
     *  case_sensitive setting into account. -FM
     */
    if ((a->input_field != NULL && a->input_field->value != NULL) &&
	a->input_field->type != F_HIDDEN_TYPE) {
	if (a->input_field->type == F_PASSWORD_TYPE) {
	    /*
	     *  Check the actual, hidden password, and then
	     *  the displayed string. -FM
	     */
	    if (LYno_attr_strstr(a->input_field->value, target)) {
		return TRUE;
	    }
	    StrAllocCopy(stars, a->input_field->value);
	    for (cp = stars; *cp != '\0'; cp++)
		*cp = '*';
	    if (LYno_attr_strstr(stars, target)) {
		FREE(stars);
		return TRUE;
	    }
	    FREE(stars);
	} else if (a->input_field->type == F_OPTION_LIST_TYPE) {
	    /*
	     *  Search the option strings that are displayed
	     *  when the popup is invoked. -FM
	     */
	    option = a->input_field->select_list;
	    while (option != NULL) {
		if (LYno_attr_strstr(option->name, target)) {
		    return TRUE;
		}
		option = option->next;
	    }
	} else if (a->input_field->type == F_RADIO_TYPE) {
	    /*
	     *  Search for checked or unchecked parens. -FM
	     */
	    if (a->input_field->num_value) {
		cp = checked_radio;
	    } else {
		cp = unchecked_radio;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else if (a->input_field->type == F_CHECKBOX_TYPE) {
	    /*
	     *  Search for checked or unchecked square brackets. -FM
	     */
	    if (a->input_field->num_value) {
		cp = checked_box;
	    } else {
		cp = unchecked_box;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else {
	    /*
	     * Check the values intended for display.  May have been found
	     * already via the hightext search, but make sure here that the
	     * entire value is searched.  -FM
	     */
	    if (LYno_attr_strstr(a->input_field->value, target)) {
		return TRUE;
	    }
	}
    }
    return FALSE;
}

PRIVATE TextAnchor *line_num_to_anchor ARGS1(
    int,	line_num)
{
    TextAnchor *a;

    if (HTMainText != 0) {
	a = HTMainText->first_anchor;
	while (a != 0 && a->line_num < line_num) {
	    a = a->next;
	}
    } else {
	a = 0;
    }
    return a;
}

PRIVATE int line_num_in_text ARGS2(
    HText *,		text,
    HTLine *,		line)
{
    int result = 1;
    HTLine *temp = FirstHTLine(text);

    while (temp != line) {
	temp = temp->next;
	++result;
    }
    return result;
}
d5835 1
a5835 2
/* Computes the 'prev' pointers on demand, and returns the one for the given
 * anchor.
d5837 2
a5838 17
PRIVATE TextAnchor *get_prev_anchor ARGS1(
    TextAnchor *,	a)
{
    TextAnchor *p, *q;

    if (a->prev == 0) {
	if ((p = HTMainText->first_anchor) != 0) {
	    while ((q = p->next) != 0) {
		q->prev = p;
		p = q;
	    }
	}
    }
    return a->prev;
}

PRIVATE int www_search_forward ARGS5(
d5840 1
a5840 1
	DocInfo *,	doc,
d5842 1
d5844 2
a5845 1
	int,		count)
d5847 2
a5848 3
    int wrapped = 0;
    TextAnchor *a = line_num_to_anchor(count - 1);
    int tentative_result = -1;
d5851 1
a5851 1
	while ((a != NULL) && a->line_num == (count - 1)) {
d5853 7
a5859 4
		!(a->link_type == INPUT_ANCHOR
		  && a->input_field->type == F_HIDDEN_TYPE)) {
		if (anchor_has_target(a, target)) {
		    adjust_search_result(doc, count, start_line);
d5862 111
d5976 3
d5980 2
a5981 2
	if (LYno_attr_strstr(line->data, target)) {
	    tentative_result = count;
d5983 7
a5989 42
	} else if ((count == start_line && wrapped) || wrapped > 1) {
	    HTUserMsg2(STRING_NOT_FOUND, target);
	    return -1;
	} else if (line == HTMainText->last_line) {
	    count = 0;
	    wrapped++;
	}
	line = line->next;
	count++;
    }
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
    }
    return 0;
}

PRIVATE int www_search_backward ARGS5(
	int,		start_line,
	DocInfo *,	doc,
	char *,		target,
	HTLine *,	line,
	int,		count)
{
    int wrapped = 0;
    TextAnchor *a = line_num_to_anchor(count - 1);
    int tentative_result = -1;

    for (;;) {
	while ((a != NULL) && a->line_num == (count - 1)) {
	    if (a->show_anchor &&
		!(a->link_type == INPUT_ANCHOR
		  && a->input_field->type == F_HIDDEN_TYPE)) {
		if (anchor_has_target(a, target)) {
		    adjust_search_result(doc, count, start_line);
		    return 1;
		}
	    }
	    a = get_prev_anchor(a);
	}

	if (LYno_attr_strstr(line->data, target)) {
	    tentative_result = count;
d5991 1
a5991 1
	} else if ((count == start_line && wrapped) || wrapped > 1) {
d5993 4
a5996 4
	    return -1;
	} else if (line == FirstHTLine(HTMainText)) {
	    count = line_num_in_text(HTMainText, LastHTLine(HTMainText)) + 1;
	    wrapped++;
a5997 5
	line = line->prev;
	count--;
    }
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
d5999 1
d6003 1
a6003 1
PUBLIC void www_user_search ARGS4(
d6005 2
a6006 3
	DocInfo *,	doc,
	char *,		target,
	int,		direction)
d6010 2
d6020 6
a6025 8
    line = FirstHTLine(HTMainText);
    if (start_line + direction > 0) {
	for (count = 1; count < start_line + direction; line = line->next, count++) {
	    if (line == HTMainText->last_line) {
		line = FirstHTLine(HTMainText);
		count = 1;
		break;
	    }
d6027 8
a6034 3
    } else {
	line = HTMainText->last_line;
	count = line_num_in_text(HTMainText, line);
d6037 18
a6054 4
    if (direction >= 0)
	www_search_forward(start_line, doc, target, line, count);
    else
	www_search_backward(start_line, doc, target, line, count);
d6068 1
a6068 1
    HTSprintf0(&temp, message, NonNull(argument));
d6160 1
a6160 1
	CTRACE((tfp, "\nHTuncache.. freeing document for '%s'%s\n",
d6165 2
a6166 3
			      htmain_anchor->post_data)
			      ? " with POST data"
			      : "")));
d6171 1
a6171 1
	CTRACE((tfp, "HTuncache.. HTMainText already is NULL!\n"));
a6175 3

PRIVATE HTProtocol scm = { "source-cache-mem", 0, 0 }; /* dummy - kw */

d6180 1
a6180 1
    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE ||
d6182 1
a6182 1
	!HTMainAnchor->source_cache_file) ||
d6184 1
a6184 1
	!HTMainAnchor->source_cache_chunk))
d6187 1
a6187 1
    if (LYCacheSource == SOURCE_CACHE_FILE && HTMainAnchor->source_cache_file) {
d6192 2
a6193 10
	CTRACE((tfp, "SourceCache: Reparsing file %s\n",
	      HTMainAnchor->source_cache_file));

	/*
	 * This magic FREE(anchor->UCStages) call
	 * stolen from HTuncache_current_document() above.
	 */
	if (!(HTOutputFormat && HTOutputFormat == WWW_SOURCE)) {
	    FREE(HTMainAnchor->UCStages);
	}
d6199 2
a6200 2
	if (HTMainAnchor->content_type) {
	    format = HTAtom_for(HTMainAnchor->content_type);
d6202 2
a6203 2
	    format = HTFileFormat(HTMainAnchor->source_cache_file, NULL, NULL);
	    format = HTCharsetFormat(format, HTMainAnchor,
d6209 1
a6209 1
	CTRACE((tfp, "  Content type is \"%s\"\n", format->name));
d6211 8
a6218 1
	fp = fopen(HTMainAnchor->source_cache_file, "r");
d6220 2
a6221 3
	    CTRACE((tfp, "  Cannot read file %s\n", HTMainAnchor->source_cache_file));
	    LYRemoveTemp(HTMainAnchor->source_cache_file);
	    FREE(HTMainAnchor->source_cache_file);
d6224 4
a6227 1

d6234 6
a6239 11
	/* Set HTMainAnchor->protocol or HTMainAnchor->physical to convince
	 * the SourceCacheWriter to not regenerate the cache file (which
	 * would be an unnecessary "loop"). - kw
	 */
	HTAnchor_setProtocol(HTMainAnchor, &HTFile);
	ret = HTParseFile(format, HTOutputFormat, HTMainAnchor, fp, NULL);
	LYCloseInput(fp);
	if (ret == HT_PARTIAL_CONTENT) {
	    HTInfoMsg(gettext("Loading incomplete."));
	    CTRACE((tfp, "SourceCache: `%s' has been accessed, partial content.\n",
		    HTLoadedDocumentURL()));
a6240 1
	ok = (BOOL) (ret == HT_LOADED || ret == HT_PARTIAL_CONTENT);
d6244 1
a6244 1
	HTMainAnchor->source_cache_chunk) {
d6248 2
a6249 10
	CTRACE((tfp, "SourceCache: Reparsing from memory chunk %p\n",
		    (void *)HTMainAnchor->source_cache_chunk));

	/*
	 * This magic FREE(anchor->UCStages) call
	 * stolen from HTuncache_current_document() above.
	 */
	if (!(HTOutputFormat && HTOutputFormat == WWW_SOURCE)) {
	    FREE(HTMainAnchor->UCStages);
	}
a6250 3
	if (HTMainAnchor->content_type) {
	    format = HTAtom_for(HTMainAnchor->content_type);
	} else {
d6259 2
a6260 3
	    format = HTCharsetFormat(format, HTMainAnchor,
					     UCLYhndl_for_unspec);
	}
d6263 11
d6280 7
a6286 9
	/* Set HTMainAnchor->protocol or HTMainAnchor->physical to convince
	 * the SourceCacheWriter to not regenerate the cache chunk (which
	 * would be an unnecessary "loop"). - kw
	 */
	HTAnchor_setProtocol(HTMainAnchor, &scm); /* cheating -
				   anything != &HTTP or &HTTPS would do - kw */
	ret = HTParseMem(format, HTOutputFormat, HTMainAnchor,
			HTMainAnchor->source_cache_chunk, NULL);
	ok = (BOOL) (ret == HT_LOADED);
d6289 5
a6293 1
    CTRACE((tfp, "Reparse %s\n", (ok ? "succeeded" : "failed")));
d6300 1
a6300 1
    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE ||
d6302 1
a6302 1
	!HTMainAnchor->source_cache_file) ||
d6304 1
a6304 1
	!HTMainAnchor->source_cache_chunk))
d6307 9
a6315 2
    if (LYCacheSource == SOURCE_CACHE_FILE && HTMainAnchor->source_cache_file) {
	return LYCanReadFile(HTMainAnchor->source_cache_file);
d6319 1
a6319 1
	HTMainAnchor->source_cache_chunk) {
d6328 2
a6329 2
	int,		prev_setting,
	int,		new_setting)
d6332 2
a6333 2
	CTRACE((tfp, "HTdocument_settings_changed: %s setting has changed (was %d, now %d)\n",
	       name, prev_setting, new_setting));
d6342 1
a6342 1
    if (!HTMainAnchor || !HTMainText || LYCacheSource == SOURCE_CACHE_NONE ||
d6344 1
a6344 1
	!HTMainAnchor->source_cache_file) ||
d6346 1
a6346 1
	!HTMainAnchor->source_cache_chunk))
a6357 3
	trace_setting_change("VERBOSE_IMG",
			    HTMainText->verbose_img,
			    verbose_img);
d6368 2
a6369 4
	trace_setting_change("KEYPAD_MODE",
			     HTMainText->keypad_mode, keypad_mode);
	if (HTMainText->disp_lines != LYlines || HTMainText->disp_cols != DISPLAY_COLS)
	    CTRACE((tfp,
d6371 1
a6371 1
		   HTMainText->disp_cols, HTMainText->disp_lines, DISPLAY_COLS, LYlines));
a6375 1
	    HTMainText->verbose_img != verbose_img ||
d6378 1
a6378 2
	    (HTMainText->minimal_comments != minimal_comments &&
	     !historical_comments) ||
d6381 2
a6382 2
	    HTMainText->keypad_mode != keypad_mode ||
	    HTMainText->disp_cols != DISPLAY_COLS);
d6400 6
a6405 1
}
d6407 1
a6407 5
PUBLIC bstring * HTLoadedDocumentPost_data NOARGS
{
    if (HTMainText
     && HTMainText->node_anchor
     && HTMainText->node_anchor->post_data)
d6410 1
a6410 1
	return (0);
a6494 17
PUBLIC BOOL HText_LastLineEmpty ARGS2(
	HText *,	text,
	BOOL,		IgnoreSpaces)
{
    if (!text || !text->last_line || !text->last_line->size)
	return TRUE;
    return HText_TrueEmptyLine(text->last_line, text, IgnoreSpaces);
}

PUBLIC int HText_LastLineOffset ARGS1(
	HText *,	text)
{
    if (!text || !text->last_line)
	return 0;
    return  text->last_line->offset;
}

a6507 16
PUBLIC BOOL HText_PreviousLineEmpty ARGS2(
	HText *,	text,
	BOOL,		IgnoreSpaces)
{
    HTLine * line;

    if (!text || !text->last_line)
	return TRUE;
    if (!(line = text->last_line->prev))
	return TRUE;
    return HText_TrueEmptyLine(line, text, IgnoreSpaces);
}

/*
 * Compute the "true" line size.
 */
d6521 7
a6527 5
	    if (!IsSpecialAttrChar(UCH(line->data[i])) &&
		IS_UTF8_EXTRA(line->data[i]) &&
		!isspace(UCH(line->data[i])) &&
		UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
		UCH(line->data[i]) != HT_EN_SPACE) {
d6534 3
a6536 1
		IS_UTF8_EXTRA(line->data[i])) {
a6543 36
/*
 * Tell if the line is really empty.  This is invoked much more often than
 * HText_TrueLineSize(), and most lines are not empty.  So it is faster to
 * do this check than to check if the line size happens to be zero.
 */
PRIVATE BOOL HText_TrueEmptyLine ARGS3(
	HTLine *,	line,
	HText *,	text,
	BOOL,		IgnoreSpaces)
{
    size_t i;

    if (!(line && line->size))
	return TRUE;

    if (IgnoreSpaces) {
	for (i = 0; i < line->size; i++) {
	    if (!IsSpecialAttrChar(UCH(line->data[i])) &&
		IS_UTF8_EXTRA(line->data[i]) &&
		!isspace(UCH(line->data[i])) &&
		UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
		UCH(line->data[i]) != HT_EN_SPACE) {
		return FALSE;
	    }
	}
    } else {
	for (i = 0; i < line->size; i++) {
	    if (!IsSpecialAttrChar(line->data[i]) &&
		IS_UTF8_EXTRA(line->data[i])) {
		return FALSE;
	    }
	}
    }
    return TRUE;
}

d6570 1
a6570 1
 *  line. -FM
d6576 1
d6578 1
a6578 1
    if (!(text && text->Lines >= 1))	/* Lines is 0-based */
d6582 1
d6586 2
d6589 1
a6589 23
}

/*
 *  This function is for removing the last blank lines.
 *  It should be called after
 *  checking the situation with HText_LastLineSize().
 *  With POOLed allocation is should be wrapped into code restoring the
 *  expected POOLed/unPOOLed state of the line chain.
 */
PRIVATE void HText_RemoveEmptyLastLine ARGS1(
	HText *,	text)
{
    HTLine *line, *previous;

    if (!(text && text->Lines >= 1))	/* Lines is 0-based */
	return;

    line = text->last_line;
    previous = line->prev;
    previous->next = line->next;
    previous->next->prev = previous;
    text->last_line = previous;
    text->Lines--;
d6597 1
a6597 1
 *	  and split_line() is called. -FM
d6617 1
a6617 1
    int column = (DISPLAY_COLS-2);
d6619 2
a6620 2
	column = ((int)text->style->rightIndent ? (DISPLAY_COLS-2) :
		  ((DISPLAY_COLS-1) - (int)text->style->rightIndent));
d6628 1
a6628 1
 *	  HT_LEFT. -FM
d6638 1
a6638 1
    if (!text || isEmpty(name))
d6653 1
a6653 1
	Tab = typecalloc(HTTabID);
d6671 1
a6671 1
    if (text && non_empty(name) && cur) {
d6691 1
a6691 1
 *  count. -FM
d6700 1
a6700 1
     *  Make sure we have an HText structure and anchor. -FM
d6707 1
a6707 1
     *  if it hasn't been already. -FM
d6715 1
a6715 1
     *  retrievals. -FM
d6717 1
a6717 1
    if ((dest = HTAnchor_followLink(textanchor->anchor)) &&
d6727 1
a6727 1
 *  that are loaded in text->hidden_links. -FM
d6743 1
a6743 1
 *  text->hidden_links list of the number argument. -FM
d6785 1
a6785 1
     *  Check the ACTION. -FM
d6788 1
a6788 1
	if (isMAILTO_URL(action)) {
d6797 1
a6797 1
     *  Check the METHOD. -FM
d6804 1
a6804 1
     *  Check the ENCTYPE. -FM
d6806 1
a6806 1
    if (non_empty(enctype)) {
d6816 1
a6816 1
     *  Check the TITLE. -FM
d6818 1
a6818 1
    if (non_empty(title))
d6842 1
a6842 1
    newform = typecalloc(PerFormInfo);
d6850 1
a6850 1
    CTRACE((tfp, "BeginForm: action:%s Method:%d%s%s%s%s%s%s\n",
d6853 1
a6853 1
		NonNull(HTFormTitle),
d6855 1
a6855 1
		NonNull(HTFormEnctype),
d6857 1
a6857 1
		NonNull(HTFormAcceptCharset)));
d6866 1
a6866 1
	 *  the form via <return> instead of a submit button. -FM
d6868 1
a6868 1
	TextAnchor * a;
d6870 1
a6870 1
	 *  Go through list of anchors and get our input field. -FM
d6872 1
a6872 1
	for (a = text->first_anchor; a != NULL; a = a->next) {
d6877 1
a6877 1
		 *  Got it.  Make it submitting. -FM
d6892 3
d6915 1
a6915 1
	CTRACE((tfp, "endForm:    HTCurrentForm is missing!\n"));
d6935 5
a6939 5
    /*
     *  Save the group name.
     */
    StrAllocCopy(HTCurSelectGroup, name);
    HTCurSelectGroupCharset = name_cs;
d6941 10
a6950 10
    /*
     *  If multiple then all options are actually checkboxes.
     */
    if (multiple)
	HTCurSelectGroupType = F_CHECKBOX_TYPE;
    /*
     *  If not multiple then all options are radio buttons.
     */
    else
	HTCurSelectGroupType = F_RADIO_TYPE;
d6957 1
a6957 1
    CTRACE((tfp,"HText_beginSelect: name=%s type=%d size=%s\n",
d6962 2
a6963 2
				      "<NULL>" : HTCurSelectGroupSize)));
    CTRACE((tfp,"HText_beginSelect: name_cs=%d \"%s\"\n",
d6966 1
a6966 1
		 LYCharSet_UC[HTCurSelectGroupCharset].MIMEname : "<UNKNOWN>")));
d6991 1
a6991 1
    CTRACE((tfp, "HText_getOptionNum: Got number '%d'.\n", n));
d7008 1
a7008 1
    if (fields_are_numbered()) {
d7019 3
a7021 3
	if ((non_empty(cp) && *cp++ == '(') &&
	    *cp && isdigit(UCH(*cp++))) {
	    while (*cp && isdigit(UCH(*cp)))
d7066 4
a7069 6
    if (!(value
      && text
      && text->last_anchor
      && text->last_anchor->link_type == INPUT_ANCHOR)) {
	CTRACE((tfp, "HText_setLastOptionValue: invalid call!  value:%s!\n",
		    (value ? value : "<NULL>")));
d7073 2
a7074 2
    CTRACE((tfp, "Entering HText_setLastOptionValue: value:\"%s\", checked:%s\n",
		value, (checked ? "on" : "off")));
d7081 2
a7082 2
	while ((cp >= value) && (isspace(UCH(*cp)) ||
				 IsSpecialAttrChar(UCH(*cp))))
d7091 2
a7092 2
    while (isspace(UCH(*cp)) ||
	   IsSpecialAttrChar(UCH(*cp)))
d7096 1
a7096 1
	fields_are_numbered()) {
d7099 1
a7099 1
	 *  prefix and actual value. -FM
d7103 2
a7104 2
	    while (isspace(UCH(cp1[i])) ||
		   IsSpecialAttrChar(UCH(cp1[i]))) {
d7151 4
a7154 4
		CTRACE((tfp, "HText_setLastOptionValue: last input_field not F_OPTION_LIST_TYPE (%d)\n",
			    F_OPTION_LIST_TYPE));
		CTRACE((tfp, "                          but %d, ignoring!\n",
			    text->last_anchor->input_field->type));
d7159 1
a7159 1
				typecalloc(OptionType);
d7167 1
a7167 1
		op_ptr = op_ptr->next;
d7171 2
a7172 1
	    op_ptr->next = new_ptr = typecalloc(OptionType);
d7185 2
a7186 2
	while (isspace(UCH(*cp)) ||
	       IsSpecialAttrChar(UCH(*cp)))
d7193 1
a7193 1
		       !IsSpecialAttrChar(UCH(cp[i]))) {
d7200 1
a7200 3
		(tmp = typecallocn(unsigned char, strlen(cp)+1)) != 0) {
		if (tmp == NULL)
		    outofmem(__FILE__, "HText_setLastOptionValue");
a7225 2
	    FormInfo *last_input = text->last_anchor->input_field;

d7227 1
a7227 1
	    last_input->num_value = 0;
d7234 2
a7235 2
	    FREE(last_input->value);
	    FREE(last_input->cp_submit_value);
d7237 10
a7246 5
	    last_input->value             = last_input->select_list->name;
	    last_input->orig_value        = last_input->select_list->name;
	    last_input->cp_submit_value   = last_input->select_list->cp_submit_value;
	    last_input->orig_submit_value = last_input->select_list->cp_submit_value;
	    last_input->value_cs          = new_ptr->value_cs;
d7249 1
a7249 1
	    int curlen = HTCurSelectedOptionValue ? strlen(HTCurSelectedOptionValue) : 0;
a7261 1
	    FormInfo *last_input = text->last_anchor->input_field;
d7265 9
a7273 6
	    last_input->num_value	  = number;
	    last_input->value		  = new_ptr->name;
	    last_input->orig_value	  = new_ptr->name;
	    last_input->cp_submit_value	  = new_ptr->cp_submit_value;
	    last_input->orig_submit_value = new_ptr->cp_submit_value;
	    last_input->value_cs	  = new_ptr->value_cs;
d7294 1
a7294 1
	CTRACE((tfp, "HText_setLastOptionValue:%s value=\"%s\"\n",
d7296 2
a7297 2
		value));
	CTRACE((tfp,"            val_cs=%d \"%s\"",
d7300 1
a7300 1
			 LYCharSet_UC[val_cs].MIMEname : "<UNKNOWN>")));
d7302 1
a7302 1
	    CTRACE((tfp, " (submit_val_cs %d \"%s\") submit_value%s=\"%s\"\n",
d7308 1
a7308 1
		    submit_value));
d7311 1
a7311 1
	    CTRACE((tfp,"\n"));
d7327 3
a7329 2
    TextAnchor * a;
    FormInfo * f;
a7333 3
    int adjust_marker = 0;
    int MaximumSize;
    char marker[16];
d7335 1
a7335 1
    CTRACE((tfp, "GridText: Entering HText_beginInput\n"));
a7336 2
    POOLtypecalloc(TextAnchor, a);
    POOLtypecalloc(FormInfo, f);
d7340 1
d7345 1
d7351 1
a7351 1
     *  name that was checked. -FM
d7363 1
a7363 1
	    TextAnchor * b;
d7365 1
a7365 1
	    for (b = text->first_anchor; b != NULL; b = b->next) {
d7378 6
a7384 2
	    if (i2 == 0)
	       I->checked = TRUE;
d7393 1
a7393 1
    LYClearHiText(a);
d7405 1
d7407 1
a7407 1
     *  Set the no_cache flag if the METHOD is POST. -FM
d7418 1
a7418 1
	if ((tmp = typecallocn(unsigned char, strlen(IValue) + 1)) != 0) {
d7472 1
a7472 1
	    f->size = 20;  /* default */
a7523 1
	    CTRACE((tfp, "ok, got a file uploader\n"));
d7528 1
a7528 1
	     *  Note that TYPE="scribble" defaults to TYPE="text". -FM
d7554 4
a7557 2
	    CTRACE((tfp,
		  "GridText: No name present in input field; not displaying\n"));
d7574 1
a7574 1
     *  an option list make it a zero-length string. -FM
d7606 1
a7606 1
	if (non_empty(f->value)) {
d7614 1
a7614 1
	if (non_empty(f->value)) {
d7634 1
a7634 1
	    StrAllocCopy(f->value, (f->type == F_CHECKBOX_TYPE ? "on" : ""));
a7671 1
#ifndef EXP_FILE_UPLOAD
a7672 1
#endif
d7679 1
a7679 1
	    if (fields_are_numbered())
d7685 2
a7686 4
    if (fields_are_numbered() && (a->number > 0)) {
	sprintf(marker,"[%d]", a->number);
	if (number_fields_on_left) {
	    BOOL had_bracket = (f->type == F_OPTION_LIST_TYPE);
d7688 14
a7701 6
	    HText_appendText(text, had_bracket ? (marker + 1) : marker);
	    if (had_bracket)
		HText_appendCharacter(text, '[');
	} else {
	    adjust_marker = strlen(marker);
	}
a7703 2
    } else {
	*marker = '\0';
a7708 1
    MaximumSize = WRAP_COLS(text) - adjust_marker;
d7710 1
d7724 9
a7732 1
	     *  horizontally within the editing window. -FM
d7734 4
a7737 13
	    MaximumSize -= (1 +
			  (int)text->style->leftIndent +
			  (int)text->style->rightIndent);

	    /*  If we are numbering form links, place is taken by [nn]  */
	    if (fields_are_numbered()) {
		if (!number_fields_on_left
		 && f->type == F_TEXT_TYPE
		 && MaximumSize > a->line_pos + 10)
		    MaximumSize -= a->line_pos;
		else
		    MaximumSize -= strlen(marker);
	    }
d7746 1
d7752 1
a7752 1
	     *  type which is handled via a popup window. -FM
d7754 2
a7755 1
	    MaximumSize -= 10;
a7757 2
    if (f->size > MaximumSize)
	f->size = MaximumSize;
d7781 1
a7781 1
	CTRACE((tfp, "beginInput: HTCurrentForm is missing!\n"));
d7784 1
a7784 1
    CTRACE((tfp, "Input link: name=%s\nvalue=%s\nsize=%d\n",
d7786 3
a7788 3
			NonNull(f->value),
			f->size));
    CTRACE((tfp, "Input link: name_cs=%d \"%s\" (from %d \"%s\")\n",
d7794 2
a7795 2
			 LYCharSet_UC[I->name_cs].MIMEname : "<UNKNOWN>")));
    CTRACE((tfp, "            value_cs=%d \"%s\" (from %d \"%s\")\n",
d7801 1
a7801 1
			 LYCharSet_UC[I->value_cs].MIMEname : "<UNKNOWN>")));
a7809 20
 * If we're numbering fields on the right, do it.  Note that some fields may
 * be too long for the line - we'll lose the marker in that case rather than
 * truncate the field.
 */
PUBLIC void HText_endInput ARGS1(
	HText *,		text)
{
    if (fields_are_numbered()
     && !number_fields_on_left
     && text != NULL
     && text->last_anchor != NULL
     && text->last_anchor->number > 0) {
	char marker[20];
	HText_setIgnoreExcess(text, FALSE);
	sprintf(marker,"[%d]", text->last_anchor->number);
	HText_appendText(text, marker);
    }
}

/*
d7840 1
a7840 1
    if (non_empty(p)) {
d7908 1
a7908 281
#ifdef EXP_FILE_UPLOAD
PRIVATE void load_a_file ARGS2(
    char *,	val_used,
    bstring **,	result)
{
    FILE *fd;
    size_t bytes;
    char buffer[257];

    CTRACE((tfp, "Ok, about to convert %s to mime/thingy\n", val_used));

    if ((fd = fopen(val_used, BIN_R)) == 0) {
	HTAlert(gettext("Can't open file for uploading"));
    } else {
	while ((bytes = fread(buffer, sizeof(char), 256, fd)) != 0) {
	    HTSABCat(result, buffer, bytes);
	}
	LYCloseInput(fd);
    }
}

PRIVATE CONST char *guess_content_type ARGS1(CONST char *, filename)
{
    HTAtom *encoding;
    CONST char *desc;
    HTFormat format = HTFileFormat (filename, &encoding, &desc);
    return (format != 0 && non_empty(format->name))
	    ? format->name
	    : "text/plain";
}
#endif /* EXP_FILE_UPLOAD */


PRIVATE void cannot_transcode ARGS2(
    BOOL *,		had_warning,
    CONST char *,	target_csname)
{
    if (*had_warning == NO) {
	*had_warning = YES;
	_user_message(CANNOT_TRANSCODE_FORM,
	    target_csname ? target_csname : "UNKNOWN");
	LYSleepAlert();
    }
}

#define SPECIAL_8BIT 1
#define SPECIAL_FORM 2

PRIVATE unsigned check_form_specialchars ARGS1(
    char *,	value)
{
    unsigned result = 0;
    char *p;

    for (p = value;
	 non_empty(p) && (result != (SPECIAL_8BIT|SPECIAL_FORM));
	 p++) {
	if ((*p == HT_NON_BREAK_SPACE) ||
	    (*p == HT_EN_SPACE) ||
	    (*p == LY_SOFT_HYPHEN)) {
	    result |= SPECIAL_FORM;
	} else if ((*p & 0x80) != 0) {
	    result |= SPECIAL_8BIT;
	}
    }
    return result;
}

/*
 * Scan the given data, adding characters to the MIME-boundary to keep it from
 * matching any part of the data.
 */
PRIVATE void UpdateBoundary ARGS2(
	char **,	Boundary,
	bstring *,	data)
{
    int j;
    int have = strlen(*Boundary);
    int last = BStrLen(data);
    char *text = BStrData(data);
    char *want = *Boundary;

    for (j = 0; j <= (last - have); ++j) {
	if (want[0] == text[j]
	 && !memcmp(want, text + j, have)) {
	    char temp[2];
	    temp[0] = isdigit(text[have + j]) ? 'a' : '0';
	    temp[1] = '\0';
	    StrAllocCat(want, temp);
	    ++have;
	}
    }
    *Boundary = want;
}

/*
 * Convert a string to base64
 */
PRIVATE char * convert_to_base64 ARGS2(
	char *,		src,
	int,		len)
{
#define B64_LINE       76

    static CONST char basis_64[] =
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    char *dest;
    int rlen;   /* length of result string */
    unsigned char c1, c2, c3;
    char *eol, *r, *str;
    int eollen;
    int chunk;

    str = src;
    eol = "\n";
    eollen = 1;

    /* calculate the length of the result */
    rlen = (len+2) / 3 * 4;	/* encoded bytes */
    if (rlen) {
	/* add space for EOL */
	rlen += ((rlen-1) / B64_LINE + 1) * eollen;
    }

    /* allocate a result buffer */
    if ((dest = (char *) malloc(rlen + 1)) == NULL) {
	outofmem(__FILE__, "convert_to_base64");
    }
    r = dest;

    /* encode */
    for (chunk=0; len > 0; len -= 3, chunk++) {
	if (chunk == (B64_LINE/4)) {
	    char *c = eol;
	    char *e = eol + eollen;
	    while (c < e)
		*r++ = *c++;
	    chunk = 0;
	}
	c1 = *str++;
	c2 = *str++;
	*r++ = basis_64[c1>>2];
	*r++ = basis_64[((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4)];
	if (len > 2) {
	    c3 = *str++;
	    *r++ = basis_64[((c2 & 0xF) << 2) | ((c3 & 0xC0) >>6)];
	    *r++ = basis_64[c3 & 0x3F];
	} else if (len == 2) {
	    *r++ = basis_64[(c2 & 0xF) << 2];
	    *r++ = '=';
	} else { /* len == 1 */
	    *r++ = '=';
	    *r++ = '=';
	}
    }
    if (rlen) {
	/* append eol to the result string */
	char *c = eol;
	char *e = eol + eollen;
	while (c < e)
	    *r++ = *c++;
    }
    *r = '\0';

    return dest;
}

typedef enum {
    NO_QUOTE		/* no quoting needed */
    , QUOTE_MULTI	/* multipart */
    , QUOTE_BASE64	/* encode as base64 */
    , QUOTE_SPECIAL	/* escape special characters only */
} QuoteData;

typedef struct {
    int type;		/* the type of this field */
    BOOL first;		/* true if this begins a submission part */
    char *name;		/* the name of this field */
    char *value;	/* the nominal value of this field */
    bstring *data;	/* its data, which is usually the same as the value */
    QuoteData quote;	/* how to quote/translate the data */
} PostData;

PRIVATE char *escape_or_quote_name ARGS3(
	char *,		name,
	QuoteData,	quoting,
	char *,		MultipartContentType)
{
    char *escaped1 = NULL;

    switch (quoting) {
    case NO_QUOTE:
       StrAllocCopy(escaped1, name);
       break;
    case QUOTE_MULTI:
    case QUOTE_BASE64:
	StrAllocCopy(escaped1, "Content-Disposition: form-data");
	HTSprintf(&escaped1, "; name=\"%s\"", name);
	if (MultipartContentType)
	    HTSprintf(&escaped1, MultipartContentType, "text/plain");
	if (quoting == QUOTE_BASE64)
	    StrAllocCat(escaped1, "\r\nContent-Transfer-Encoding: base64");
	StrAllocCat(escaped1, "\r\n\r\n");
	break;
    case QUOTE_SPECIAL:
	escaped1 = HTEscapeSP(name, URL_XALPHAS);
	break;
    }
    return escaped1;
}

PRIVATE char *escape_or_quote_value ARGS2(
	char *,		value,
	QuoteData,	quoting)
{
    char *escaped2 = NULL;

    switch (quoting) {
    case NO_QUOTE:
    case QUOTE_MULTI:
	StrAllocCopy(escaped2, NonNull(value));
	break;
    case QUOTE_BASE64:
	/* FIXME: this is redundant */
	escaped2 = convert_to_base64(value, strlen(value));
	break;
    case QUOTE_SPECIAL:
	escaped2 = HTEscapeSP(value, URL_XALPHAS);
	break;
    }
    return escaped2;
}

/*
 * Check if we should encode the data in base64.  We can, only if we're using
 * a multipart content type.  We should, if we're sending mail and the data
 * contains long lines or nonprinting characters.
 */
PRIVATE int check_if_base64_needed ARGS2(
	int,		submit_method,
	bstring *,	data)
{
    int width = 0;
    BOOL printable = TRUE;
    char *text = BStrData(data);

    if (text != 0) {
	int col = 0;
	int n;
	int length = BStrLen(data);

	for (n = 0; n < length; ++n) {
	    int ch = UCH(text[n]);
	    if (is8bits(ch) || ((ch < 32 && ch != '\n'))) {
		CTRACE((tfp, "nonprintable %d:%#x\n", n, ch));
		printable = FALSE;
	    }
	    if (ch == '\n' || ch == '\r') {
		if (width < col)
		    width = col;
		col = 0;
	    } else {
		++col;
	    }
	}
	if (width < col)
	    width = col;
    }
    return !printable && ((submit_method == URL_MAIL_METHOD) && (width > 72));
}

/*
 *  HText_SubmitForm - generate submit data from form fields.
 *  For mailto forms, send the data.
 *  For other methods, set fields in structure pointed to by doc
 *  appropriately for next request.
 *  Returns 1 if *doc set appropriately for next request,
 *	    0 otherwise. - kw
 */
PUBLIC int HText_SubmitForm ARGS4(
d7910 1
a7910 1
	DocInfo *,	doc,
d7914 10
a7923 3
    BOOL had_chartrans_warning = NO;
    BOOL have_accept_cs = NO;
    BOOL success;
d7926 3
a7928 1
    BOOL skip_field = FALSE;
a7930 12
    PerFormInfo *thisform;
    PostData *my_data = NULL;
    TextAnchor *anchor_ptr;
    bstring *my_query = NULL;
    char *Boundary = NULL;
    char *MultipartContentType = NULL;
    char *content_type_out = NULL;
    char *copied_name_used = NULL;
    char *copied_val_used = NULL;
    char *escaped1 = NULL;
    char *escaped2 = NULL;
    char *last_textarea_name = NULL;
d7932 6
a7937 1
    char *previous_blanks = NULL;
d7939 2
a7940 7
    int anchor_count = 0;
    int anchor_limit = 0;
    int form_number = submit_item->number;
    int result = 0;
    int target_cs = -1;
    int textarea_lineno = 0;
    unsigned form_is_special = 0;
d7942 1
a7942 1
    CTRACE((tfp, "SubmitForm\n  link_name=%s\n  link_value=%s\n", link_name, link_value));
d7944 1
a7944 1
	return 0;
d7949 2
a7950 2
	CTRACE((tfp, "SubmitForm: form %d not in HTMainText's list!\n",
		    form_number));
d7952 2
a7953 2
	CTRACE((tfp, "SubmitForm: failed sanity check, %d!=%d !\n",
		    thisform->number, form_number));
d7957 11
a7967 12
    if (isEmpty(submit_item->submit_action)) {
	CTRACE((tfp, "SubmitForm: no action given\n"));
	return 0;
    }

    /*
     *  If we're mailing, make sure it's a mailto ACTION. -FM
     */
    if ((submit_item->submit_method == URL_MAIL_METHOD) &&
	!isMAILTO_URL(submit_item->submit_action)) {
	HTAlert(BAD_FORM_MAILTO);
	return 0;
d7971 1
a7971 1
     *  Check the ENCTYPE and set up the appropriate variables. -FM
d7977 1
a7977 1
	 *  to separate name=value pairs. -FM
d7985 1
a7985 1
	 *  separators for name=value pairs. -FM
d7992 4
a7995 2
	 *  Use the multipart MIME format.  Later we will ensure it does not
	 *  occur within the content.
d8046 1
a8046 1
     * Go through list of anchors and get a "max." charset parameter - kw
d8048 7
a8054 3
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
d8056 52
a8107 2
	if (anchor_ptr->link_type != INPUT_ANCHOR)
	    continue;
d8109 19
a8127 2
	if (anchor_ptr->input_field->number == form_number &&
		    !anchor_ptr->input_field->disabled) {
d8129 2
a8130 47
	    FormInfo *form_ptr = anchor_ptr->input_field;
	    char * val = form_ptr->cp_submit_value != NULL
			    ? form_ptr->cp_submit_value
			    : form_ptr->value;

	    unsigned field_is_special = check_form_specialchars(val);
	    unsigned name_is_special = check_form_specialchars(form_ptr->name);

	    form_is_special = (field_is_special | name_is_special);

	    if (field_is_special == 0) {
		/* already ok */
	    } else if (target_cs < 0) {
		/* already confused */
	    } else if ((field_is_special & SPECIAL_8BIT) == 0
	     && (LYCharSet_UC[target_cs].enc == UCT_ENC_8859
	      || (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
		/* those specials will be trivial */
	    } else if (UCNeedNotTranslate(form_ptr->value_cs, target_cs)) {
		/* already ok */
	    } else if (UCCanTranslateFromTo(form_ptr->value_cs, target_cs)) {
		/* also ok */
	    } else if (UCCanTranslateFromTo(target_cs, form_ptr->value_cs)) {
		target_cs = form_ptr->value_cs;	/* try this */
		target_csname = NULL; /* will be set after loop */
	    } else {
		target_cs = -1; /* don't know what to do */
	    }

	    /*  Same for name */
	    if (name_is_special == 0) {
		/* already ok */
	    } else if (target_cs < 0) {
		/* already confused */
	    } else if ((name_is_special & SPECIAL_8BIT) == 0
	     && (LYCharSet_UC[target_cs].enc == UCT_ENC_8859
	      || (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
		/* those specials will be trivial */
	    } else if (UCNeedNotTranslate(form_ptr->name_cs, target_cs)) {
		/* already ok */
	    } else if (UCCanTranslateFromTo(form_ptr->name_cs, target_cs)) {
		/* also ok */
	    } else if (UCCanTranslateFromTo(target_cs, form_ptr->name_cs)) {
		target_cs = form_ptr->value_cs;	/* try this */
		target_csname = NULL; /* will be set after loop */
	    } else {
		target_cs = -1; /* don't know what to do */
d8132 1
d8134 1
a8134 2
	    ++anchor_limit;
	} else if (anchor_ptr->input_field->number > form_number) {
a8135 2
	}
    }
d8137 1
a8137 8
    /*
     * If we have input fields (we expect this), make an array of them so we
     * can organize the data.
     */
    if (anchor_limit != 0) {
	my_data = typecallocn(PostData, anchor_limit);
	if (my_data == 0)
	    outofmem(__FILE__, "HText_SubmitForm");
d8141 1
a8141 1
	if ((form_is_special & SPECIAL_8BIT) != 0) {
d8143 1
a8143 1
	} else if ((form_is_special & SPECIAL_FORM) != 0) {
d8151 1
a8151 3
	char *temp = NULL;

	StrAllocCopy(temp, submit_item->submit_action);
d8155 1
a8155 1
	strtok (temp, "#");
d8159 1
a8159 1
	strtok (temp, "?");
d8163 1
a8163 2
	StrAllocCat(temp,"?");
	BStrCat0(my_query, temp);
d8167 1
a8167 2
	 *  so load content_type_out.  This will be put in
	 *  the post_content_type element if all goes well. -FM, kw
d8170 1
a8170 1
	    StrAllocCopy(content_type_out,
d8173 1
a8173 1
	    StrAllocCopy(content_type_out,
d8176 3
a8178 2
	    StrAllocCopy(content_type_out,
			 "multipart/form-data");
d8180 1
a8180 1
	    StrAllocCopy(content_type_out,
d8201 2
a8202 3
	if (have_accept_cs
	 || ((form_is_special & SPECIAL_8BIT) != 0
	  || (form_is_special & SPECIAL_FORM) != 0)) {
d8211 2
a8212 1
			HTSprintf(&content_type_out, "; charset=%s", target_csname);
d8216 5
a8220 1
		cannot_transcode(&had_chartrans_warning, target_csname);
d8225 1
d8229 5
a8233 1
     * Build up a list of the input fields and their associated values.
d8235 6
a8240 6
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {

	if (anchor_ptr->link_type != INPUT_ANCHOR)
	    continue;
d8242 2
a8243 2
	if (anchor_ptr->input_field->number == form_number &&
		    !anchor_ptr->input_field->disabled) {
d8245 2
a8246 38
	    FormInfo *form_ptr = anchor_ptr->input_field;
	    int out_cs;
	    QuoteData quoting = (PlainText
				 ? NO_QUOTE
				 : (Boundary
				    ? QUOTE_MULTI
				    : QUOTE_SPECIAL));

	    if (form_ptr->type != F_TEXTAREA_TYPE)
		textarea_lineno = 0;

	    CTRACE((tfp, "SubmitForm[%d/%d]: ",
		   anchor_count + 1, anchor_limit));

	    name_used = NonNull(form_ptr->name);

	    switch(form_ptr->type) {
	    case F_RESET_TYPE:
		CTRACE((tfp, "reset\n"));
		break;
#ifdef EXP_FILE_UPLOAD
	    case F_FILE_TYPE:
		val_used = NonNull(form_ptr->value);
		CTRACE((tfp, "I will submit %s (from %s)\n",
			     val_used, name_used));
		break;
#endif
	    case F_SUBMIT_TYPE:
	    case F_TEXT_SUBMIT_TYPE:
	    case F_IMAGE_SUBMIT_TYPE:
		if (!(non_empty(form_ptr->name) &&
		      !strcmp(form_ptr->name, link_name))) {
		    CTRACE((tfp, "skipping submit field with "));
		    CTRACE((tfp, "name \"%s\" for link_name \"%s\", %s.\n",
				 form_ptr->name ? form_ptr->name : "???",
				 link_name ? link_name : "???",
				 non_empty(form_ptr->name) ?
				 "not current link" : "no field name"));
d8248 41
a8288 73
		}
		if (!(form_ptr->type == F_TEXT_SUBMIT_TYPE ||
		    (non_empty(form_ptr->value) &&
		     !strcmp(form_ptr->value, link_value)))) {
		    CTRACE((tfp, "skipping submit field with "));
		    CTRACE((tfp, "name \"%s\" for link_name \"%s\", %s!\n",
				 form_ptr->name ? form_ptr->name : "???",
				 link_name ? link_name : "???",
				 "values are different"));
		    break;
		}
		/* FALLTHRU */
	    case F_RADIO_TYPE:
	    case F_CHECKBOX_TYPE:
	    case F_TEXTAREA_TYPE:
	    case F_PASSWORD_TYPE:
	    case F_TEXT_TYPE:
	    case F_OPTION_LIST_TYPE:
	    case F_HIDDEN_TYPE:
		/*
		 * Be sure to actually look at the option submit value.
		 */
		if (form_ptr->cp_submit_value != NULL) {
		    val_used = form_ptr->cp_submit_value;
		} else {
		    val_used = form_ptr->value;
		}

		/*
		 * Charset-translate value now, because we need to know the
		 * charset parameter for multipart bodyparts.  - kw
		 */
		if (check_form_specialchars(val_used) != 0) {
		    /*  We should translate back. */
		    StrAllocCopy(copied_val_used, val_used);
		    success = LYUCTranslateBackFormData(&copied_val_used,
							form_ptr->value_cs,
							target_cs, PlainText);
		    CTRACE((tfp, "field \"%s\" %d %s -> %d %s %s\n",
				 NonNull(form_ptr->name),
				 form_ptr->value_cs,
				 form_ptr->value_cs >= 0
				     ? LYCharSet_UC[form_ptr->value_cs].MIMEname
				     : "???",
				 target_cs,
				 target_csname ? target_csname : "???",
				 success ? "OK" : "FAILED"));
		    if (success) {
			val_used = copied_val_used;
		    }
		} else {  /* We can use the value directly. */
		    CTRACE((tfp, "field \"%s\" %d %s OK\n",
				 NonNull(form_ptr->name),
				 target_cs,
				 target_csname ? target_csname : "???"));
		    success = YES;
		}
		if (!success) {
		    cannot_transcode(&had_chartrans_warning, target_csname);
		    out_cs = form_ptr->value_cs;
		} else {
		    out_cs = target_cs;
		}
		if (out_cs >= 0)
		    out_csname = LYCharSet_UC[out_cs].MIMEname;
		if (Boundary) {
		    StrAllocCopy(MultipartContentType,
				 "\r\nContent-Type: %s");
		    if (!success && form_ptr->value_cs < 0) {
			/*  This is weird. */
			out_csname = "UNKNOWN-8BIT";
		    } else if (!success) {
			target_csname = NULL;
d8290 1
a8290 3
			if (!target_csname) {
			    target_csname = LYCharSet_UC[target_cs].MIMEname;
			}
a8291 3
		    if (strcmp(out_csname, "iso-8859-1"))
			HTSprintf(&MultipartContentType, "; charset=%s", out_csname);
		}
d8293 17
a8309 10
		/*
		 * Charset-translate name now, because we need to know the
		 * charset parameter for multipart bodyparts.  - kw
		 */
		if (form_ptr->type == F_TEXTAREA_TYPE) {
		    textarea_lineno++;
		    if (textarea_lineno > 1 &&
			last_textarea_name && form_ptr->name &&
			!strcmp(last_textarea_name, form_ptr->name)) {
			break;
a8310 1
		}
d8312 5
a8316 5
		if (check_form_specialchars(name_used) != 0) {
		    /*  We should translate back. */
		    StrAllocCopy(copied_name_used, name_used);
		    success = LYUCTranslateBackFormData(&copied_name_used,
							form_ptr->name_cs,
d8318 30
a8347 11
		    CTRACE((tfp, "name \"%s\" %d %s -> %d %s %s\n",
				 NonNull(form_ptr->name),
				 form_ptr->name_cs,
				 form_ptr->name_cs >= 0
				     ? LYCharSet_UC[form_ptr->name_cs].MIMEname
				     : "???",
				 target_cs,
				 target_csname ? target_csname : "???",
				 success ? "OK" : "FAILED"));
		    if (success) {
			name_used = copied_name_used;
d8349 2
d8352 9
a8360 2
			if (!success) {
			    StrAllocCopy(MultipartContentType, "");
d8363 1
a8363 1
			    if (!target_csname)
d8365 4
d8371 1
a8371 14
		} else {  /* We can use the name directly. */
		    CTRACE((tfp, "name \"%s\" %d %s OK\n",
				NonNull(form_ptr->name),
				target_cs,
				target_csname ? target_csname : "???"));
		    success = YES;
		    if (Boundary) {
			StrAllocCopy(copied_name_used, name_used);
		    }
		}
		if (!success) {
		    cannot_transcode(&had_chartrans_warning, target_csname);
		}
		if (Boundary) {
d8373 3
a8375 10
		     *  According to RFC 1867, Non-ASCII field names
		     *  "should be encoded according to the prescriptions
		     *  of RFC 1522 [...].  I don't think RFC 1522 actually
		     *  is meant to apply to parameters like this, and it
		     *  is unknown whether any server would make sense of
		     *  it, so for now just use some quoting/escaping and
		     *  otherwise leave 8-bit values as they are.
		     *  Non-ASCII characters in form field names submitted
		     *  as multipart/form-data can only occur if the form
		     *  provider specifically asked for it anyway. - kw
d8377 10
a8386 3
		    HTMake822Word(&copied_name_used, FALSE);
		    name_used = copied_name_used;
		}
d8388 13
a8400 5
		break;
	    default:
		CTRACE((tfp, "What type is %d?\n", form_ptr->type));
		break;
	    }
d8402 62
a8463 3
	    skip_field = FALSE;
	    my_data[anchor_count].first = TRUE;
	    my_data[anchor_count].type = form_ptr->type;
d8465 4
a8468 28
	    /*
	     * Using the values of 'name_used' and 'val_used' computed in the
	     * previous case-statement, compute the 'first' and 'data' values
	     * for the current input field.
	     */
	    switch(form_ptr->type) {

	    default:
		skip_field = TRUE;
		break;

#ifdef EXP_FILE_UPLOAD
	    case F_FILE_TYPE:
		load_a_file(val_used, &(my_data[anchor_count].data));
		break;
#endif /* EXP_FILE_UPLOAD */

	    case F_SUBMIT_TYPE:
	    case F_TEXT_SUBMIT_TYPE:
	    case F_IMAGE_SUBMIT_TYPE:
		if ((non_empty(form_ptr->name) &&
		    !strcmp(form_ptr->name, link_name)) &&
		   (form_ptr->type == F_TEXT_SUBMIT_TYPE ||
		    (non_empty(form_ptr->value) &&
		     !strcmp(form_ptr->value, link_value)))) {
		    ;
		} else {
		    skip_field = TRUE;
a8469 1
		break;
d8471 1
a8471 11
	    case F_RADIO_TYPE:
	    case F_CHECKBOX_TYPE:
		/*
		 *  Only add if selected.
		 */
		if (form_ptr->num_value) {
		    ;
		} else {
		    skip_field = TRUE;
		}
		break;
d8473 2
a8474 9
	    case F_TEXTAREA_TYPE:
		if (!last_textarea_name ||
		    strcmp(last_textarea_name, form_ptr->name)) {
		    textarea_lineno = 1;
		    last_textarea_name = form_ptr->name;
		} else {
		    my_data[anchor_count].first = FALSE;
		}
		break;
d8476 34
a8509 6
	    case F_PASSWORD_TYPE:
	    case F_TEXT_TYPE:
	    case F_OPTION_LIST_TYPE:
	    case F_HIDDEN_TYPE:
		break;
	    }
d8511 13
a8523 23
	    /*
	     * If we did not decide to skip the current field, populate the
	     * values in the array for it.
	     */
	    if (!skip_field) {
		StrAllocCopy(my_data[anchor_count].name, name_used);
		StrAllocCopy(my_data[anchor_count].value, val_used);
		if (my_data[anchor_count].data == 0)
		    BStrCat0(my_data[anchor_count].data, val_used);
		my_data[anchor_count].quote = quoting;
		if (quoting == QUOTE_MULTI
		 && check_if_base64_needed(submit_item->submit_method,
					   my_data[anchor_count].data)) {
		    CTRACE((tfp, "will encode as base64\n"));
		    my_data[anchor_count].quote = QUOTE_BASE64;
		    escaped2 = convert_to_base64(
				BStrData(my_data[anchor_count].data),
				BStrLen(my_data[anchor_count].data));
		    BStrCopy0(my_data[anchor_count].data, escaped2);
		    FREE(escaped2);
	        }
	    }
	    ++anchor_count;
d8525 7
a8531 2
	    FREE(copied_name_used);
	    FREE(copied_val_used);
d8533 46
a8578 4
	} else if (anchor_ptr->input_field->number > form_number) {
	    break;
	}
    }
d8580 23
a8602 1
    FREE(copied_name_used);
d8604 20
a8623 2
    if (my_data != 0) {
	BOOL first_one = TRUE;
d8625 16
a8640 13
	/*
	 * If we're using a MIME-boundary, make it unique.
	 */
	if (content_type_out != 0 && Boundary != 0) {
	    Boundary = 0;
	    StrAllocCopy(Boundary, "LYNX");
	    for (anchor_count = 0; anchor_count < anchor_limit; ++anchor_count) {
		if (my_data[anchor_count].data != 0) {
		    UpdateBoundary(&Boundary, my_data[anchor_count].data);
		}
	    }
	    HTSprintf(&content_type_out, "; boundary=%s", Boundary);
	}
d8642 8
a8649 1
	for (anchor_count = 0; anchor_count < anchor_limit; ++anchor_count) {
d8651 83
a8733 2
	    if (my_data[anchor_count].name != 0
	     && my_data[anchor_count].value != 0) {
d8735 4
a8738 9
		CTRACE((tfp, "processing [%d:%d] name=%s(first:%d, value=%s, data=%p)\n",
			anchor_count + 1,
			anchor_limit,
			NonNull(my_data[anchor_count].name),
			my_data[anchor_count].first,
			NonNull(my_data[anchor_count].value),
			my_data[anchor_count].data));

		if (my_data[anchor_count].first) {
d8741 1
a8741 1
			    HTBprintf(&my_query, "--%s\r\n", Boundary);
d8743 1
a8743 1
			first_one = FALSE;
d8746 1
a8746 1
			    BStrCat0(my_query, "\n");
d8748 1
a8748 1
			    BStrCat0(my_query, ";");
d8750 1
a8750 1
			    HTBprintf(&my_query, "\r\n--%s\r\n", Boundary);
d8752 1
a8752 1
			    BStrCat0(my_query, "&");
a8754 1
		}
d8756 9
a8764 81
		/* append a null to the string */
		HTSABCat(&(my_data[anchor_count].data), "", 1);
		name_used = my_data[anchor_count].name;
		val_used = my_data[anchor_count].value;

	    } else {
		/* there is no data to send */
		continue;
	    }

	    switch (my_data[anchor_count].type) {
	    case F_TEXT_TYPE:
	    case F_PASSWORD_TYPE:
	    case F_OPTION_LIST_TYPE:
	    case F_HIDDEN_TYPE:
		escaped1 = escape_or_quote_name(my_data[anchor_count].name,
						my_data[anchor_count].quote,
						MultipartContentType);

		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);

		HTBprintf(&my_query,
			"%s%s%s%s%s",
			escaped1,
			(Boundary ? "" : "="),
			(PlainText ? "\n" : ""),
			escaped2,
			((PlainText && *escaped2) ? "\n" : ""));
		break;
	    case F_CHECKBOX_TYPE:
	    case F_RADIO_TYPE:
		escaped1 = escape_or_quote_name(my_data[anchor_count].name,
						my_data[anchor_count].quote,
						MultipartContentType);

		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);

		HTBprintf(&my_query,
			"%s%s%s%s%s",
			escaped1,
			(Boundary ? "" : "="),
			(PlainText ? "\n" : ""),
			escaped2,
			((PlainText && *escaped2) ? "\n" : ""));
		break;
	    case F_SUBMIT_TYPE:
	    case F_TEXT_SUBMIT_TYPE:
	    case F_IMAGE_SUBMIT_TYPE:
		/*
		 *  If it has a non-zero length name (e.g., because
		 *  its IMAGE_SUBMIT_TYPE is to be handled homologously
		 *  to an image map, or a SUBMIT_TYPE in a set of
		 *  multiple submit buttons, or a single type="text"
		 *  that's been converted to a TEXT_SUBMIT_TYPE),
		 *  include the name=value pair, or fake name.x=0 and
		 *  name.y=0 pairs for IMAGE_SUBMIT_TYPE. -FM
		 */
		escaped1 = escape_or_quote_name(my_data[anchor_count].name,
						my_data[anchor_count].quote,
						MultipartContentType);

		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);

		if (my_data[anchor_count].type == F_IMAGE_SUBMIT_TYPE) {
		    /*
		     * It's a clickable image submit button.  Fake a 0,0
		     * coordinate pair, which typically returns the image's
		     * default.  -FM
		     */
		    if (Boundary) {
			*(strchr(escaped1, '=') + 1) = '\0';
			HTBprintf(&my_query,
				  "%s\"%s.x\"\r\n\r\n0\r\n--%s\r\n%s\"%s.y\"\r\n\r\n0",
				  escaped1,
				  my_data[anchor_count].name,
				  Boundary,
				  escaped1,
				  my_data[anchor_count].name);
d8766 1
a8766 9
			HTBprintf(&my_query,
				"%s.x=0%s%s.y=0%s",
				escaped1,
				(PlainText ?
				      "\n" : (SemiColon ?
						    ";" : "&")),
				escaped1,
				((PlainText && *escaped1) ?
						     "\n" : ""));
a8767 20
		} else {
		    /*
		     * It's a standard submit button.  Use the name=value
		     * pair.  = FM
		     */
		    HTBprintf(&my_query,
			    "%s%s%s%s%s",
			    escaped1,
			    (Boundary ? "" : "="),
			    (PlainText ? "\n" : ""),
			    escaped2,
			    ((PlainText && *escaped2) ? "\n" : ""));
		}
		break;
	    case F_RESET_TYPE:
		/* ignore */
		break;
	    case F_TEXTAREA_TYPE:
		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);
d8769 4
a8772 10
		if (my_data[anchor_count].first) {
		    textarea_lineno = 1;
		    /*
		     * Names are different so this is the first textarea or a
		     * different one from any before it.
		     */
		    if (PlainText) {
			FREE(previous_blanks);
		    } else if (Boundary) {
			StrAllocCopy(previous_blanks, "\r\n");
d8774 1
a8774 1
			StrAllocCopy(previous_blanks, "%0d%0a");
a8775 3
		    escaped1 = escape_or_quote_name(name_used,
						    my_data[anchor_count].quote,
						    MultipartContentType);
d8777 1
a8777 1
		    HTBprintf(&my_query,
d8780 4
a8783 2
			    (Boundary ? "" : "="),
			    (PlainText ? "\n" : ""),
d8785 7
a8791 23
			    ((PlainText && *escaped2) ? "\n" : ""));
		} else {
		    char *marker = (PlainText
				    ? "\n"
				    : (Boundary
				       ? "\r\n"
				       : "%0d%0a"));
		    /*
		     * This is a continuation of a previous textarea.
		     */
		    if (escaped2[0] != '\0') {
			if (previous_blanks) {
			    BStrCat0(my_query, previous_blanks);
			    FREE(previous_blanks);
			}
			BStrCat0(my_query, escaped2);
			if (PlainText || Boundary)
			    BStrCat0(my_query, marker);
			else
			    StrAllocCopy(previous_blanks, marker);
		    } else {
			StrAllocCat(previous_blanks, marker);
		    }
d8793 1
d8795 2
a8796 21
	    case F_RANGE_TYPE:
		/* not implemented */
		break;
#ifdef EXP_FILE_UPLOAD
	    case F_FILE_TYPE:
		if (PlainText) {
		    StrAllocCopy(escaped1, my_data[anchor_count].name);
		} else if (Boundary) {
		    CONST char *t = guess_content_type(val_used);

		    StrAllocCopy(escaped1, "Content-Disposition: form-data");
		    HTSprintf(&escaped1, "; name=\"%s\"", my_data[anchor_count].name);
		    HTSprintf(&escaped1, "; filename=\"%s\"", val_used);
		    /* Should we take into account the encoding? */
		    HTSprintf(&escaped1, "\r\nContent-Type: %s", t);
		    if (my_data[anchor_count].quote == QUOTE_BASE64)
			StrAllocCat(escaped1, "\r\nContent-Transfer-Encoding: base64");
		    StrAllocCat(escaped1, "\r\n\r\n");
		} else {
		    escaped1 = HTEscapeSP(my_data[anchor_count].name, URL_XALPHAS);
		}
d8798 2
a8799 22
		HTBprintf(&my_query,
			  "%s%s%s",
			  escaped1,
			  (Boundary ? "" : "="),
			  (PlainText ? "\n" : ""));
		/*
		 * If we have anything more than the trailing null we added,
		 * append the file-data to the query.
		 */
		if (BStrLen(my_data[anchor_count].data) > 1) {
		    HTSABCat(&my_query,
			     BStrData(my_data[anchor_count].data),
			     BStrLen(my_data[anchor_count].data) - 1);
		    if (PlainText)
			HTBprintf(&my_query, "\n");
		}
		break;
#endif /* EXP_FILE_UPLOAD */
	    case F_KEYGEN_TYPE:
		/* not implemented */
		break;
	    }
d8801 8
a8808 14
	    FREE(escaped1);
	    FREE(escaped2);
	}
	if (Boundary) {
	    HTBprintf(&my_query, "\r\n--%s--\r\n", Boundary);
	}
	/*
	 * The data may contain a null - so we use fwrite().
	 */
	if (TRACE) {
	    CTRACE((tfp, "Query %d{", BStrLen(my_query)));
	    trace_bstring(my_query);
	    CTRACE((tfp, "}\n"));
	}
d8810 1
d8814 9
a8822 1
	HTSABCat(&my_query, "", 1);	/* append null */
d8824 10
a8833 8
		 (isEmpty(submit_item->submit_title)
		   ? NonNull(HText_getTitle())
		   : submit_item->submit_title),
		 BStrData(my_query),
		 content_type_out);
	result = 0;
	BStrFree(my_query);
	FREE(content_type_out);
a8835 14

	if (submit_item->submit_method == URL_POST_METHOD || Boundary) {
	    LYFreePostData(doc);
	    doc->post_data = my_query;
	    doc->post_content_type = content_type_out; /* don't free c_t_out */
	    CTRACE((tfp, "GridText - post_data set:\n%s\n", content_type_out));
	    StrAllocCopy(doc->address, submit_item->submit_action);
	} else { /* GET_METHOD */
	    HTSABCat(&my_query, "", 1);	/* append null */
	    StrAllocCopy(doc->address, BStrData(my_query));	/* FIXME? */
	    LYFreePostData(doc);
	    FREE(content_type_out);
	}
	result = 1;
d8838 12
a8849 10
    FREE(MultipartContentType);
    FREE(previous_blanks);
    FREE(Boundary);
    if (my_data != 0) {
	for (anchor_count = 0; anchor_count < anchor_limit; ++anchor_count) {
	    FREE(my_data[anchor_count].name);
	    FREE(my_data[anchor_count].value);
	    BStrFree(my_data[anchor_count].data);
	}
	FREE(my_data);
a8850 2

    return (result);
d8864 2
a8865 3
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
d8871 5
d8893 2
a8894 3
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
d8922 5
d8940 1
a8940 1
	return FALSE;
d8946 2
a8947 3
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
d8974 4
d8990 2
a8991 3
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
d9008 5
d9041 2
d9097 1
a9097 1
    return (BOOL) ((text && text->toolbar) ? TRUE : FALSE);
d9111 1
a9111 1
    return (BOOL) ((text && text->no_cache) ? TRUE : FALSE);
d9117 1
a9117 1
    return (BOOL) ((text && text->T.output_utf8) ? TRUE : FALSE);
d9121 1
a9121 1
**  Check charset and set the kcode element. -FM
a9134 2
    BOOL explicit;

a9143 1
    explicit = charset ? TRUE : FALSE;
d9151 1
a9151 1
    **  Check whether we have a specified charset. -FM
d9161 1
a9161 1
    **  appropriately. -FM
d9163 2
a9164 10
    /*  If charset isn't specified explicitely nor assumed,
     *  p_in->MIMEname would be set as display charset.
     *  So text->kcode sholud be set as SJIS or EUC here only if charset
     *  is specified explicitely, otherwise text->kcode would cause
     *  mishandling Japanese strings. -- TH
     */
    if (explicit && (!strcmp(charset, "shift_jis") ||
	!strcmp(charset, "x-sjis") ||		/* 1997/11/28 (Fri) 18:11:33 */
	!strcmp(charset, "x-shift-jis")))
    {
d9166 1
a9166 2
    } else if (explicit && ((p_in && (p_in->enc == UCT_ENC_CJK)) ||
	       !strcmp(charset, "x-euc") ||	/* 1997/11/28 (Fri) 18:11:24 */
d9169 2
d9178 1
a9178 1
	       !strcmp(charset, "iso-2022-cn"))) {
d9183 1
a9183 1
	**  it is enabled.  But only if we are quite sure. -FM & kw
a9190 10
    if (explicit)
	text->specified_kcode = text->kcode;
    else {
	if (UCAssume_MIMEcharset) {
	    if (!strcmp(UCAssume_MIMEcharset, "euc-jp"))
		text->kcode = text->specified_kcode = EUC;
	    else if (!strcmp(UCAssume_MIMEcharset, "shift_jis"))
		text->kcode = text->specified_kcode = SJIS;
	}
    }
d9196 1
a9196 1
**  Set a permissible split at the current end of the last line. -FM
d9205 1
a9205 1
     *  Can split here. -FM
d9223 1
a9223 1
**  claimed or suggested this. -FM
d9232 1
d9251 1
a9251 1
    if (findPoundSelector(full_address) == NULL)
d9259 1
a9259 1
    if (isLYNXIMGMAP(anchor->address))
d9273 5
a9277 4
    MTaddress = (isLYNXIMGMAP(MTanc->address)
		? MTanc->address + LEN_LYNXIMGMAP
		: MTanc->address);
    MTpound = trimPoundSelector(MTaddress);
d9279 3
a9281 1
	restorePoundSelector(MTpound);
d9284 3
a9286 1
    restorePoundSelector(MTpound);
d9295 1
a9295 1
		if (!BINEQ(MTanc->post_data, anchor->post_data)) {
d9320 1
a9320 1
     *  or other directives not to use a cached rendition. -FM
a9324 2
#define CanTrimTextArea(c) \
    (LYtrimInputFields ? isspace(c) : ((c) == '\r' || (c) == '\n'))
d9352 1
a9352 1
	if (CanTrimTextArea(UCH(*p)))
d9406 1
a9406 1
	for (p = line, s = tbuf; *s != '\0'; p++, s++) {
d9408 6
a9413 6
	    *p = ((UCH(*s)  < UCH(' '))       ||
		  (UCH(*s) == UCH('\177'))    ||
		  ((UCH(*s) > UCH('\177')) &&
		   (UCH(*s) <
		    UCH(LYlowest_eightbit[current_char_set]))))
		 ? (char) SPLAT : *s;
d9415 1
a9415 1
	    *p = (UCH(*s) < UCH(' ')) ? SPLAT : *s;
a9416 1
	}
a9471 1
    int   post_n;
d9521 1
a9521 1
		if (isdigit(UCH(*t++))) {
d9540 1
a9540 1
	     *   of being correct, if and when such an unlikely juxtaposition
d9562 1
a9562 1
		     *  horizontal position, and that of all subsequent tags
d9580 1
a9580 1
		    if ((new_n -= n) != 0) {
d9590 1
a9590 1
	    }
d9603 1
a9603 4
	    pre_n = strlen (p);	/* count of 1st part chars in this line */
	    post_n = strlen(ht->next->data);
	    if (plx
	     && (pre_n + post_n + 2 < (int) sizeof(lxbuf))) {
d9605 1
d9616 1
a9616 1
		    if (isdigit(UCH(*t++))) {
d9631 1
a9631 3
		if ((valid)
		 && (n > 0)
		 && (n + post_n + 2) < MAX_LINE) {
d9709 1
a9709 1
    for (htline = FirstHTLine(HTMainText), i = 0;
d9720 3
a9722 4
    POOLallocHTLine(l, MAX_LINE);
    POOLtypecalloc(TextAnchor, a);
    POOLtypecalloc(FormInfo, f);
    if (a == NULL || l == NULL || f == NULL)
d9729 1
d9733 3
a9735 1
    LYCopyHiText(a, anchor);
a9752 1
    f->value_cs        = current_char_set; /* use current setting - kw */
d9759 3
a9764 2
    /*we fork the pointers!*/
    l->styles = htline->styles;
d9767 1
a9767 1
    if (fields_are_numbered()) {
d9811 1
a9811 1
	int,		 newlines,
d9813 1
a9813 1
	HTLine *,	 start_htline,
d9819 5
a9823 4
    int		line_adj = 0;
    int		tag_adj	 = 0;
    int		lx	 = 0;
    int	     hang	 = 0;  /* for HANG detection of a nasty intermittent */
d9827 1
a9827 1
    CTRACE((tfp, "GridText: adjusting struct's to add %d new line(s)\n", newlines));
d9839 1
a9839 1
	if (fields_are_numbered() &&
d9841 3
a9843 2
	    anchor->number += newlines;
	anchor->line_num  += newlines;
d9877 1
a9877 1
    if (fields_are_numbered()) {
d9879 1
a9879 1
	while (htline != FirstHTLine(HTMainText)) {
d9882 1
a9882 1
		if ((anchor->number - newlines) == start_tag)
d9885 17
a9901 17
		/*** A HANG (infinite loop) *has* occurred here, with */
		/*** the values of anchor and anchor->next being the  */
		/*** the same, OR with anchor->number "magically" and */
		/*** suddenly taking on an anchor-pointer-like value. */
		/***                                                  */
		/*** The same code and same doc have both passed and  */
		/*** failed at different times, which indicates some  */
		/*** sort of content/html dependency, or some kind of */
		/*** a "race" condition, but I'll be damned if I can  */
		/*** find it after tons of CTRACE's, printf()'s, gdb  */
		/*** breakpoints and watchpoints, etc.                */
		/***                                                  */
		/*** I have added a hang detector (with error msg and */
		/*** beep) here, to break the loop and warn the user, */
		/*** until it can be isolated and fixed.              */
		/***                                                  */
		/*** [One UGLY intermittent .. gak ..!  02/22/99 KED] */
d9912 1
a9912 2
						    &start_tag, newlines,
						    NOCHOP);
d9925 1
a9925 1
finish:
d9929 4
a9932 3
    nlinks                         += newlines;
    HTMainText->Lines              += newlines;
    HTMainText->last_anchor_number += newlines;
d9936 1
a9936 1
    CTRACE((tfp, "GridText: TextAnchor and HTLine struct's adjusted\n"));
d9940 1
a9940 1
hang_detected:  /* ugliness has happened; inform user and do the best we can */
d9942 5
a9946 2
    HTAlert(gettext("Hang Detect: TextAnchor struct corrupted - suggest aborting!"));
    goto finish;
d9963 1
a9963 1
	   LinkInfo *,	form_link)
a9974 1
    BOOLEAN wrapalert = FALSE;
d9983 1
a9983 1
    FormInfo   *form	 = form_link->l_form;
d9990 1
d9994 1
a9994 1
    int		match_tag = 0;
d9996 1
a9996 4
    int		len, len0, len_in;
    int		wanted_fieldlen_wrap = -1; /* not yet asked; 0 means don't. */
    char       *skip_at = NULL;
    int		skip_num = 0, i;
d9998 2
a9999 1
    CTRACE((tfp, "GridText: entered HText_ExtEditForm()\n"));
d10054 2
a10055 2
    CTRACE((tfp, "GridText: TEXTAREA name=|%s| dumped to tempfile\n", areaname));
    CTRACE((tfp, "GridText: invoking editor (%s) on tempfile\n", editor));
d10064 7
a10070 1
	sprintf (ed_offset, "%d", ((entry_line - start_line) + 1));
d10072 11
a10082 1
    edit_temporary_file(ed_temp, ed_offset, NULL);
d10084 1
a10084 1
    CTRACE((tfp, "GridText: returned from editor (%s)\n", editor));
d10093 1
a10093 3
	ebuf = typecalloc (char);
	if (!ebuf)
	    outofmem(__FILE__, "HText_ExtEditForm");
d10095 1
a10095 12
	ebuf = typecallocn(char, size + 1);
	if (!ebuf) {
	    /*
	     *  This could be huge - don't exit if we don't have enough
	     *  memory for it.  With some luck, the user may be even able
	     *  to recover the file manually from the temp space while
	     *  the lynx session is not over. - kw
	     */
	    free(ed_temp);
	    HTAlwaysAlert(NULL, MEMORY_EXHAUSTED_FILE);
	    return 0;
	}
d10099 1
a10099 2
	LYCloseInput (fp);
	ebuf[size] = '\0';	/* Terminate! - kw */
d10101 2
d10107 1
a10107 2
    while ((size != 0)
     && (CanTrimTextArea(UCH(ebuf[size-1])) || (ebuf[size-1] == '\0')))
a10118 3
    if (anchor_ptr->input_field->size <= 4 ||
	anchor_ptr->input_field->size >= MAX_LINE)
	wanted_fieldlen_wrap = 0;
d10120 1
a10120 1
    len = len_in = 0;
a10124 12
	if (skip_at) {
	    len0 = skip_at - lp;
	    strncpy(line, lp, len0);
	    line[len0] = '\0';
	    lp = skip_at + skip_num;
	    skip_at = NULL;
	    skip_num = 0;
	} else {
	    len0 = 0;
	}
	line[len0] = '\0';

d10126 1
a10126 1
	   len = len_in = cp - lp;
d10128 1
a10128 1
	   len = len_in = strlen (lp);
d10130 2
d10133 1
a10133 78
	if (wanted_fieldlen_wrap < 0 && !wrapalert &&
	    len0+len >= start_anchor->input_field->size &&
	    (cp = strchr(lp, ' ')) != NULL &&
	    (cp-lp) < start_anchor->input_field->size - 1) {
	    LYFixCursesOn("ask for confirmation:");
	    LYerase();		/* don't show previous state */
	    if (HTConfirmDefault(gettext("Wrap lines to fit displayed area?"),
				 NO)) {
		wanted_fieldlen_wrap = start_anchor->input_field->size - 1;
	    } else {
		wanted_fieldlen_wrap = 0;
	    }
	}
	if (wanted_fieldlen_wrap > 0 && len0+len > wanted_fieldlen_wrap) {
	    for (i = wanted_fieldlen_wrap-len0;
		 i+len0 >= wanted_fieldlen_wrap/4; i--) {
		if (isspace(UCH(lp[i]))) {
		    len = i + 1;
		    cp = lp + i;
		    if (cp[1] != '\n' &&
			isspace(UCH(cp[1])) &&
			!isspace(UCH(cp[2]))) {
			len++;
			cp++;
		    }
		    if (!isspace(UCH(cp[1]))) {
			while (*cp && *cp != '\r' && *cp != '\n' &&
			       (cp - lp) <= len + (3 * wanted_fieldlen_wrap/4))
			    cp++;	/* search for next line break */
			if (*cp == '\r' && cp[1] == '\n')
			    cp++;
			if (*cp == '\n' &&
			    (cp[1] == '\r' || cp[1] == '\n' ||
			     !isspace(UCH(cp[1])))) {
			    *cp = ' ';
			    while (isspace(UCH(*(cp-1)))) {
				skip_num++;
				cp--;
			    }
			    skip_at = cp;
			}
		    }
		    break;
		}
	    }
	}
	if (wanted_fieldlen_wrap > 0 && len0+len > wanted_fieldlen_wrap) {
	    i = len-1;
	    while (len0+i+1 > wanted_fieldlen_wrap &&
		   isspace(UCH(lp[i])))
		i--;
	    if (len0+i+1 > wanted_fieldlen_wrap)
		len = wanted_fieldlen_wrap - len0;
	}

	if (len0+len >= MAX_LINE) {
	    if (!wrapalert) {
		LYFixCursesOn("show alert:");
		HTAlert(gettext("Very long lines have been wrapped!"));
		wrapalert = TRUE;
	    }
	    /*
	     *  First try to find a space character for wrapping - kw
	     */
	    for (i = MAX_LINE - len0 - 1; i > 0; i--) {
		if (isspace(UCH(lp[i]))) {
		    len = i;
		    break;
		}
	    }
	    if (len0+len >= MAX_LINE)
		len = MAX_LINE - len0 - 1;
	}

	strncat (line, lp, len);
	*(line + len0+len) = '\0';

	cleanup_line_for_textarea (line, len0+len);
d10155 1
a10155 1
	if (len0+len > 0)
d10164 1
a10164 1
	if (*lp && isspace(UCH(*lp))) lp++;
d10175 1
a10175 1
    CTRACE((tfp, "GridText: edited text inserted into lynx struct's\n"));
d10193 1
a10193 1
    CTRACE((tfp, "GridText: exiting HText_ExtEditForm()\n"));
d10212 2
a10213 2
	    LinkInfo *,	form_link,
	    int,	newlines)
d10219 1
a10219 1
    FormInfo *form      = form_link->l_form;
d10229 1
a10229 1
    CTRACE((tfp, "GridText: entered HText_ExpandTextarea()\n"));
d10259 1
a10259 1
		firstanchor = FALSE;
d10286 2
a10287 2
    CTRACE((tfp, "GridText: %d blank line(s) added to TEXTAREA name=|%s|\n",
		newlines, areaname));
d10295 1
a10295 1
    CTRACE((tfp, "GridText: exiting HText_ExpandTextarea()\n"));
d10302 2
a10303 2
 *  Insert the contents of a file into a TEXTAREA between the cursor line,
 *  and the line preceding it.
d10312 1
a10312 1
	   LinkInfo *,	form_link)
a10323 1
    BOOLEAN truncalert = FALSE;
d10325 1
a10325 1
    FormInfo   *form	 = form_link->l_form;
a10339 1
    int		file_cs;
d10346 1
a10346 1
    CTRACE((tfp, "GridText: entered HText_InsertFile()\n"));
d10353 1
a10353 1
	CTRACE((tfp, "GridText: file insert cancelled - no filename provided\n"));
a10355 6
    if (no_dotfiles || !show_dotfiles) {
	if (*LYPathLeaf(fn) == '.') {
	    HTUserMsg(FILENAME_CANNOT_BE_DOT);
	    return (0);
	}
    }
d10363 2
a10364 2
	CTRACE((tfp, "GridText: file insert aborted - file=|%s|- was 0-length\n",
		    fn));
d10370 2
a10371 19
	if ((fbuf = typecallocn(char, size + 1)) == NULL) {
	    /*
	     *  This could be huge - don't exit if we don't have enough
	     *  memory for it. - kw
	     */ /*outofmem(__FILE__, "HText_InsertFile");*/
	    free(fn);
	    HTAlert(MEMORY_EXHAUSTED_FILE);
	    return 0;
	}

	/* Try to make the same assumption for the charset of the inserted
	 * file as we would for normal loading of that file, i.e. taking
	 * assume_local_charset and suffix mappings into account.
	 * If there is a mismatch with the display character set, characters
	 * may be displayed wrong, too bad; but the user has a chance to
	 * correct this by editing the lines, which will update f->value_cs
	 * again. - kw
	 */
	LYGetFileInfo(fn, 0, 0, 0, 0, 0, &file_cs);
a10373 6
	if (!fp) {
	    free(fbuf);
	    free(fn);
	    HTAlert(FILE_CANNOT_OPEN_R);
	    return 0;
	}
d10375 1
a10375 1
	LYCloseInput (fp);
a10376 1
	fbuf[size] = '\0';	/* Terminate! - kw */
d10423 1
a10423 1
    for (htline = FirstHTLine(HTMainText), i = 0;
d10430 3
a10432 4
    POOLallocHTLine(l, MAX_LINE);
    POOLtypecalloc(TextAnchor, a);
    POOLtypecalloc(FormInfo, f);
    if (a == NULL || l == NULL || f == NULL)
d10439 1
d10443 3
a10445 1
    LYCopyHiText(a, anchor_ptr);
a10462 1
    f->value_cs        = (file_cs >= 0) ? file_cs : current_char_set;
d10467 3
a10472 2
    /*we fork the pointers!*/
    l->styles = htline->styles;
d10489 5
a10493 5
    htline		= htline->prev;
    l->next		= htline->next;
    l->prev		= htline;
    htline->next->prev	= l;
    htline->next	= l;
a10527 9
	if (len >= MAX_LINE) {
	    if (!truncalert) {
		HTAlert(gettext("Very long lines have been truncated!"));
		truncalert = TRUE;
	    }
	    len = MAX_LINE - 1;
	    if (lp[len])
		lp[len+1] = '\0'; /* prevent next iteration */
	}
a10548 7
	 *  insert_new_textarea_anchor always uses current_char_set,
	 *  we may want something else, so fix it up. - kw
	 */
	 if (file_cs >= 0)
	     anchor_ptr->input_field->value_cs = file_cs;

	/*
d10559 1
a10559 1
    CTRACE((tfp, "GridText: file inserted into lynx struct's\n"));
d10567 1
d10574 1
a10574 1
    CTRACE((tfp, "GridText: exiting HText_InsertFile()\n"));
d10585 2
a10586 2
 * drawn.
 *
d10588 3
a10590 1
 * (since no support for lss is availble for Slang) -HV.
d10592 1
a10592 1
#ifdef USE_COLOR_STYLE
d10631 1
a10631 1
		LynxChangeStyle (CStyle.style,CStyle.direction);
d10640 1
a10640 1
		    LYaddch('_');
d10649 1
a10649 1
		    LYaddch('_');
d10667 1
a10667 1
		    LYaddch('+');
d10672 1
a10672 1
		    isspace(UCH(LastDisplayChar)) ||
d10682 1
a10682 1
		     *  split_line() in those cases. -FM
d10687 1
a10687 1
		     *  Make it a hard hyphen and fall through. -FM
a10691 1
		/* FALLTHRU */
d10695 23
a10717 2
		if (text->T.output_utf8 && is8bits(buffer[0])) {
		    utf_extra = utf8_length(text->T.output_utf8, data-1);
d10723 1
a10723 1
		    LYaddstr(buffer);
d10727 1
a10727 1
		} else if (HTCJK != NOCJK && is8bits(buffer[0])) {
d10733 1
a10733 1
		    LYaddstr(buffer);
d10744 1
a10744 1
		     *  character handling is used. -FM
d10748 1
a10748 1
		    LYaddstr(buffer);
d10761 1
a10761 1
	LynxChangeStyle (CStyle.style, CStyle.direction);
d10769 1
a10769 1
#endif /* USE_COLOR_STYLE */
a10770 1
#ifndef USE_COLOR_STYLE
d10772 4
a10775 245
 *  Function move_to_glyph is called from LYMoveToLink and does all
 *  the real work for it.
 *  The pair LYMoveToLink()/move_to_glyph() is similar to the pair
 *  redraw_lines_of_link()/redraw_part_of_line(), some key differences:
 *   LYMoveToLink/move_to_glyph		redraw_*
 *   -----------------------------------------------------------------
 *   - used without color style         - used with color style
 *   - handles showing WHEREIS target	- WHEREIS handled elsewhere
 *   - handles only one line		- handles first two lines for
 *					  hypertext anchors
 *   - right columns position for UTF-8
 *     by redrawing as necessary
 *   - currently used for highlight	- currently used for highlight
 *     ON and OFF			  OFF
 *
 *  Eventually the two sets of function should be unified, and should handle
 *  UTF-8 positioning, both lines of hypertext anchors, and WHEREIS in all
 *  cases.  If possible.  The complex WHEREIS target logic in highlight()
 *  could then be completely removed. - kw
 */
PRIVATE void move_to_glyph ARGS10(
	int,		YP,
	int,		XP,
	int,		XP_draw_min,
	char *,		data,
	int,		datasize,
	unsigned,	offset,
	CONST char *,	target,
	char *,		hightext,
	int,		flags,
	BOOL,		utf_flag)
{
    register int i;
    char buffer[7];
    CONST char *end_of_data;
    size_t utf_extra = 0;
#if defined(SHOW_WHEREIS_TARGETS)
    CONST char *cp_tgt;
    int i_start_tgt=0, i_after_tgt;
    int HitOffset, LenNeeded;
#endif /* SHOW_WHEREIS_TARGETS */
    BOOL intarget = NO, inunderline = NO, inbold = NO;
    BOOL drawing = NO, inU = NO, hadutf8 = NO;
    BOOL incurlink = NO, drawingtarget = NO, flag = NO;
    char *sdata = data;
    char LastDisplayChar = ' ';
    int XP_link = XP;
    int linkvlen;

    int	len;

    if (flags & 1)
	flag = YES;
    if (flags & 2)
	inU = YES;
    /* Set up the multibyte character buffer  */
    buffer[0] = buffer[1] = buffer[2] = '\0';
    /*
     *  Add offset, making sure that we do not
     *  go over the COLS limit on the display.
     */
    i = (int)offset;
    if (i > (int)DISPLAY_COLS - 1)
	i = (int)DISPLAY_COLS - 1;

    linkvlen = hightext ? LYmbcsstrlen(hightext, utf_flag, YES) : 0;

    /*
     *  Scan through the data, making sure that we do not
     *  go over the COLS limit on the display etc.
     */
    len = datasize;
    end_of_data = data + len;

#if defined(SHOW_WHEREIS_TARGETS)
    /*
     *  If the target overlaps with the part of this line that
     *  we are drawing, it will be emphasized.
     */
    i_after_tgt = i;
    if (target) {
	cp_tgt = LYno_attr_mb_strstr(sdata,
				     target,
				     utf_flag, YES,
				     &HitOffset,
				     &LenNeeded);
	if (cp_tgt) {
	    if ((int)offset + LenNeeded >= DISPLAY_COLS ||
		((int)offset + HitOffset >= XP + linkvlen)) {
		cp_tgt = NULL;
	    } else {
		i_start_tgt = i + HitOffset;
		i_after_tgt = i + LenNeeded;
	    }
	}
    } else {
	cp_tgt = NULL;
    }
#endif /* SHOW_WHEREIS_TARGETS */


    /*
     *  Iterate through the line data from the start, keeping track of
     *  the display ("glyph") position in i.  Drawing will be turned
     *  on when either the first UTF-8 sequence (that occurs after
     *  XP_draw_min) is found, or when we reach the link itself (if
     *  highlight is non-NULL). - kw
     */
    while ((i < DISPLAY_COLS - 1) && data < end_of_data && (*data != '\0')) {

	if (data && hightext && i >= XP && !incurlink) {

	/*
	 *  We reached the position of link itself, and hightext is
	 *  non-NULL.  We switch data from being a pointer into the HTLine
	 *  to being a pointer into hightext.  Normally (as long as this
	 *  routine is applied to normal hyperlink anchors) the text in
	 *  hightext will be identical to that part of the HTLine that
	 *  data was already pointing to, except that special attribute
	 *  chars LY_BOLD_START_CHAR etc. have been stripped out (see
	 *  HText_trimHightext).  So the switching should not result in
	 *  any different display, but it ensures that it doesn't go
	 *  unnoticed if somehow hightext got messed up somewhere else.
	 *  This is also useful in preparation for using this function
	 *  for something else than normal hyperlink anchors, i.e. form
	 *  fields.
	 *  Turn on drawing here or make sure it gets turned on before the
	 *  next actual normal character is handled. - kw
	 */
	    data = hightext;
	    len = strlen(hightext);
	    end_of_data = hightext + len;
	    XP += linkvlen;	/* from now on XP includes hightext chars */
	    incurlink = YES;
#ifdef SHOW_WHEREIS_TARGETS
	    if (cp_tgt) {
		if (flag && i_after_tgt >= XP)
		    i_after_tgt = XP - 1;
	    }
#endif
	    /*
	     *  The logic of where to set intarget drawingtarget etc.
	     *  and when to react to it should be cleaned up (here and
	     *  further below).  For now this seems to work but isn't
	     *  very clear.  The complications arise from reproducing
	     *  the behavior (previously done in LYhighlight()) for target
	     *  strings that fall into or overlap a link: use target
	     *  emphasis for the target string, except for the first
	     *  and last character of the anchor text if the anchor is
	     *  highlighted as "current link". - kw
	     */
	    if (!drawing) {
#ifdef SHOW_WHEREIS_TARGETS
		if (intarget) {
		    if (i_after_tgt > i) {
			LYmove(YP, i);
			if (flag) {
			    drawing = YES;
			    drawingtarget = NO;
			    if (inunderline)	inU = YES;
			    lynx_start_link_color (flag, inU);
			} else {
			    drawing = YES;
			    drawingtarget = YES;
			    LYstartTargetEmphasis();
			}
		    }
		}
#endif /* SHOW_WHEREIS_TARGETS */
	    } else {
#ifdef SHOW_WHEREIS_TARGETS
		if (intarget && i_after_tgt > i) {
		    if (flag && (data == hightext)) {
			drawingtarget = NO;
			LYstopTargetEmphasis();
		    }
		} else if (!intarget)
#endif /* SHOW_WHEREIS_TARGETS */
		{
		    if (inunderline)	inU = YES;
		    if (inunderline)	stop_underline();
		    if (inbold)		stop_bold();
		    lynx_start_link_color (flag, inU);
		}

	    }
	}
	if (i >= XP || data >= end_of_data)
	    break;
	if ((buffer[0] = *data) == '\0')
	    break;


#if defined(SHOW_WHEREIS_TARGETS)
	/*
	 *  Look for a subsequent occurrence of the target string,
	 *  if we had a previous one and have now stepped past it. - kw
	 */
	if (cp_tgt && i >= i_after_tgt) {
	    if (intarget) {

		if (incurlink && flag && i == XP - 1)
		    cp_tgt = NULL;
		else
		    cp_tgt = LYno_attr_mb_strstr(sdata,
						 target,
						 utf_flag, YES,
						 &HitOffset,
						 &LenNeeded);
		if (cp_tgt) {
		    i_start_tgt = i + HitOffset;
		    i_after_tgt = i + LenNeeded;
		    if (incurlink) {
			if (flag && i_start_tgt == XP_link)
			    i_start_tgt++;
			if (flag && i_start_tgt == XP - 1)
			    i_start_tgt++;
			if (flag && i_after_tgt >= XP)
			    i_after_tgt = XP - 1;
			if (flag && i_start_tgt >= XP)
			    cp_tgt = NULL;
		    } else if (i_start_tgt == XP) {
			if (flag)
			    i_start_tgt++;
		    }
		}
		if (!cp_tgt || i_start_tgt != i) {
		    intarget = NO;
		    if (drawing) {
			if (drawingtarget) {
			    drawingtarget = NO;
			    LYstopTargetEmphasis();
			    if (incurlink) {
				lynx_start_link_color (flag, inU);
			    }
			}
			if (!incurlink) {
			    if (inbold)		start_bold();
			    if (inunderline)	start_underline();
			}
		    }
		}
	    }
	}
#endif /* SHOW_WHEREIS_TARGETS */
a10776 296
	/*
	 *  Advance data to point to the next input char (for the
	 *  next round).  Advance sdata, used for searching for a
	 *  target string, so that they stays in synch.  As long
	 *  as we are not within the highlight text, data and sdata
	 *  have identical values.  After we have switched data to
	 *  point into hightext, sdata remains a pointer into the
	 *  HTLine (so that we don't miss a partial target match at
	 *  the end of the anchor text).  So sdata has to sometimes
	 *  skip additional special attribute characters that are
	 *  not present in highlight in order to stay in synch. - kw
	 */
	data++;
	if (*sdata) {
	    do sdata++;
		while (incurlink && *sdata && sdata != data &&
		       IsSpecialAttrChar(*(sdata-1)));
	}

	switch (buffer[0]) {

	    case LY_UNDERLINE_START_CHAR:
		if (!drawing || !incurlink) inunderline = YES;
		if (drawing && !intarget && !incurlink)
		    start_underline();
		break;

	    case LY_UNDERLINE_END_CHAR:
		inunderline = NO;
		if (drawing && !intarget && !incurlink)
		    stop_underline();
		break;

	    case LY_BOLD_START_CHAR:
		if (!drawing || !incurlink) inbold = YES;
		if (drawing && !intarget && !incurlink)
		    start_bold();
		break;

	    case LY_BOLD_END_CHAR:
		inbold = NO;
		if (drawing && !intarget && !incurlink)
		    stop_bold();
		break;

	    case LY_SOFT_NEWLINE:
		if (drawing) {
		    LYaddch('+');
		}
		i++;
		break;

	    case LY_SOFT_HYPHEN:
		if (*data != '\0' ||
		    isspace(UCH(LastDisplayChar)) ||
		    LastDisplayChar == '-') {
		    /*
		     *  Ignore the soft hyphen if it is not the last
		     *  character in the line.  Also ignore it if it
		     *  first character following the margin, or if it
		     *  is preceded by a white character (we loaded 'M'
		     *  into LastDisplayChar if it was a multibyte
		     *  character) or hyphen, though it should have
		     *  been excluded by HText_appendCharacter() or by
		     *  split_line() in those cases. -FM
		     */
		    break;
		} else {
		    /*
		     *  Make it a hard hyphen and fall through. -FM
		     */
		    buffer[0] = '-';
		}
		/* FALLTHRU */

	    default:
		/*
		 *  We have got an actual normal displayable character, or
		 *  the start of one.  Before proceeding check whether
		 *  drawing needs to be turned on now. - kw
		 */
#if defined(SHOW_WHEREIS_TARGETS)
		if (incurlink && intarget && flag && i_after_tgt > i) {
		    if (i == XP - 1) {
			i_after_tgt = i;
		    } else if (i == XP - 2 && HTCJK != NOCJK &&
			       is8bits(buffer[0])) {
			i_after_tgt = i;
			cp_tgt = NULL;
			if (drawing) {
			    if (drawingtarget) {
				LYstopTargetEmphasis();
				drawingtarget = NO;
				lynx_start_link_color (flag, inU);
			    }
			}
		    }
		}
		if (cp_tgt && i >= i_start_tgt && sdata > cp_tgt) {
		    if (!intarget ||
			(intarget && incurlink && !drawingtarget)) {

			if (incurlink && drawing &&
			    !(flag &&
			      (i == XP_link || i == XP - 1))) {
			    lynx_stop_link_color (flag, inU);
			}
			if (incurlink && !drawing) {
			    LYmove(YP, i);
			    if (inunderline)	inU = YES;
			    if (flag && (i == XP_link || i == XP - 1)) {
				lynx_start_link_color (flag, inU);
				drawingtarget = NO;
			    } else {
				LYstartTargetEmphasis();
				drawingtarget = YES;
			    }
			    drawing = YES;
			} else if (incurlink && drawing &&
				   intarget && !drawingtarget &&
				   (flag &&
				    (i == XP_link))) {
			    if (inunderline)	inU = YES;
			    lynx_start_link_color (flag, inU);
			} else if (drawing &&
				   !(flag &&
				     (i == XP_link || (incurlink && i == XP - 1)))) {
			    LYstartTargetEmphasis();
			    drawingtarget = YES;
			}
			intarget = YES;
		    }
		} else
#endif /* SHOW_WHEREIS_TARGETS */
		    if (incurlink) {
			if (!drawing) {
			    LYmove(YP, i);
			    if (inunderline)	inU = YES;
			    lynx_start_link_color (flag, inU);
			    drawing = YES;
			}
		    }

		i++;
		if (utf_flag && is8bits(buffer[0])) {
		    hadutf8 = YES;
		    utf_extra = utf8_length(utf_flag, data-1);
		    LastDisplayChar = 'M';
		}
		if (utf_extra) {
		    strncpy(&buffer[1], data, utf_extra);
		    buffer[utf_extra+1] = '\0';
		    if (!drawing && i >= XP_draw_min) {
			LYmove(YP, i - 1);
			drawing = YES;
#if defined(SHOW_WHEREIS_TARGETS)
			if (intarget) {
			    drawingtarget = YES;
			    LYstartTargetEmphasis();
			} else
#endif /* SHOW_WHEREIS_TARGETS */
			{
			    if (inbold)
				start_bold();
			    if (inunderline)
				start_underline();
			}
		    }
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		    sdata += utf_extra; data += utf_extra;
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && is8bits(buffer[0])) {
		    /*
		     *  For CJK strings, by Masanobu Kimura.
		     */
		    if (drawing && (i < DISPLAY_COLS - 1)) {
			buffer[1] = *data;
			LYaddstr(buffer);
			buffer[1] = '\0';
		    }
		    i++;
		    sdata++; data++;
		    /*
		     * For now, load 'M' into LastDisplayChar, but we should
		     * check whether it's white and if so, use ' '.  I don't
		     * know if there actually are white CJK characters, and
		     * we're loading ' ' for multibyte spacing characters in
		     * this code set, but this will become an issue when the
		     * development code set's multibyte character handling is
		     * used.  -FM
		     */
		    LastDisplayChar = 'M';
		} else {
		    if (drawing) {
			LYaddstr(buffer);
		    }
		    LastDisplayChar = buffer[0];
		}
	} /* end of switch */
    } /* end of while */

    if (!drawing) {
	LYmove(YP, i);
	lynx_start_link_color (flag, inU);
    } else {
#if defined(SHOW_WHEREIS_TARGETS)
	if (drawingtarget) {
	    LYstopTargetEmphasis();
	    lynx_start_link_color (flag, inU);
	}
#endif /* SHOW_WHEREIS_TARGETS */
	if (hadutf8) {
	    LYtouchline(YP);
	}
    }
    return;
}
#endif /* !USE_COLOR_STYLE */

#ifndef USE_COLOR_STYLE
/*
 *  Move cursor position to a link's place in the display.
 *  The "moving to" is done by scanning through the line's
 *  character data in the corresponding HTLine of HTMainText,
 *  and starting to draw when a UTF-8 encoded non-ASCII character
 *  is encountered before the link (with some protection against
 *  overwriting form fields).  This refreshing of preceding data is
 *  necessary for preventing curses's or slang's display logic from
 *  getting too clever; their logic counts character positions wrong
 *  since they don't know about multi-byte characters that take up
 *  only one screen position.  So we have to make them forget their
 *  idea of what's in a screen line drawn previously.
 *  If hightext is non-NULL, it should be the anchor text for a normal
 *  link as stored in a links[] element, and the anchor text will be
 *  drawn too, with appropriate attributes. - kw
 */
PUBLIC void LYMoveToLink ARGS6(
	int,		cur,
	CONST char *,	target,
	char *,		hightext,
	int,		flag,
	BOOL,		inU,
	BOOL,		utf_flag)
{
#define pvtTITLE_HEIGHT 1
    HTLine* todr;
    int i, n=0;
    int XP_draw_min = 0;
    int flags = ((flag == ON) ? 1 : 0) | (inU ? 2 : 0);

    /*
     *  We need to protect changed form text fields preceding this
     *  link on the same line against overwriting. - kw
     */
    for (i = cur-1; i >= 0; i++) {
	if (links[i].ly < links[cur].ly)
	    break;
	if (links[i].type == WWW_FORM_LINK_TYPE) {
	    XP_draw_min = links[i].ly + links[i].l_form->size;
	    break;
	}
    }

    /*  Find the right HTLine. */
    if (!HTMainText) {
	todr = NULL;
    } else if (HTMainText->stale) {
	todr = FirstHTLine(HTMainText);
	n = links[cur].ly - pvtTITLE_HEIGHT + HTMainText->top_of_screen;
    } else {
	todr = HTMainText->top_of_screen_line;
	n = links[cur].ly - pvtTITLE_HEIGHT;
    }
    for (i = 0; i < n && todr; i++) {
	todr = (todr == HTMainText->last_line) ? NULL : todr->next;
    }
    if (todr) {
	if (target && *target == '\0') target = NULL;
	move_to_glyph(links[cur].ly, links[cur].lx, XP_draw_min,
		      todr->data, todr->size, todr->offset,
		      target, hightext, flags, utf_flag);
    } else {
	/*  This should not happen. */
	move_to_glyph(links[cur].ly, links[cur].lx, XP_draw_min,
		      "", 0, links[cur].lx,
		      target, hightext, flags, utf_flag);
	/* LYmove(links[cur].ly, links[cur].lx); */
    }
}
#endif /* !USE_COLOR_STYLE */

/*
 * This is used only if compiled with lss support.  It's called to draw regular
 * link (1st two lines of link) when it's being unhighlighted in LYhighlight().
 */
d10780 1
a10780 1
#ifdef USE_COLOR_STYLE
d10782 1
a10782 1
    HTLine* todr1;
a10783 2
    int row, col, count;
    char *text;
d10787 1
a10787 1
	lines_back = HTMainText->Lines - ( links[cur].ly - pvtTITLE_HEIGHT+
d10790 1
a10790 1
	lines_back = display_lines - (links[cur].ly - pvtTITLE_HEIGHT);
d10793 1
a10793 1
    while (lines_back-- > 0)
d10795 2
d10798 7
a10804 6
    row = links[cur].ly;
    for (count = 0; row <= display_lines && (text = LYGetHiliteStr(cur, count)) != NULL; ++count) {
	col = LYGetHilitePos(cur, count);
	LYmove(row++, col);
	redraw_part_of_line (todr1, text, strlen(text), HTMainText);
	todr1 = todr1->next;
d10806 1
d10814 1
a10814 1
#ifdef USE_PRETTYSRC
d10818 1
a10818 1
	HTMainText->source = TRUE;
a10821 26
PUBLIC HTkcode HText_getKcode ARGS1(
	HText *,	text)
{
    return text->kcode;
}

PUBLIC void HText_updateKcode ARGS2(
	HText *,	text,
	HTkcode,	kcode)
{
    text->kcode = kcode;
}

PUBLIC HTkcode HText_getSpecifiedKcode ARGS1(
	HText *,	text)
{
    return text->specified_kcode;
}

PUBLIC void HText_updateSpecifiedKcode ARGS2(
	HText *,	text,
	HTkcode,	kcode)
{
    text->specified_kcode = kcode;
}

d10824 1
a10824 3
    return (HTMainText ?
	    HTAnchor_getUCLYhndl(HTMainText->node_anchor, UCT_STAGE_MIME)
	    : -1);
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@d790 1
d810 1
@


1.1.3.3
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d46 1
a46 1
#ifdef USE_SOURCE_CACHE
d142 1
a142 1
#ifdef USE_SOURCE_CACHE
d245 1
a245 1
#define POOLtypecalloc(T, ptr)      ptr = (T*) ALLOC_IN_POOL(&HTMainText->pool, sizeof(T))
d335 1
a335 14
#define LINE_SIZE(size) (sizeof(HTLine)+(size))   /* Allow for terminator */

#define HTLINE_NOT_IN_POOL 0	/* debug with this set to 1 */

#if HTLINE_NOT_IN_POOL
#define allocHTLine(ptr, size)  { ptr = (HTLine *)calloc(1, LINE_SIZE(size)); }
#define freeHTLine(self, ptr)   { \
	if (ptr && ptr != TEMP_LINE(self, 0) && ptr != TEMP_LINE(self, 1)) \
	    FREE(ptr); \
    }
#else
#define allocHTLine(ptr, size)  POOLallocHTLine(ptr, size)
#define freeHTLine(self, ptr)   {}
#endif
d448 1
a448 1
#ifdef USE_SOURCE_CACHE
d588 3
d659 2
a707 1
#define LYFreeHiText(a)     FREE((a)->lites.hl_info)
d718 1
a718 1
	POOLallocstring(a->lites.hl_base.hl_text, len + 1);
d745 1
a745 1
    POOLallocstring(have[need].hl_text, strlen(text) + 1);
a857 48
PRIVATE void free_form_fields ARGS1(
	FormInfo *,	input_field)
{
    /*
     *  Free form fields.
     */
    if (input_field->type == F_OPTION_LIST_TYPE &&
	input_field->select_list != NULL) {
	/*
	 *  Free off option lists if present.
	 *  It should always be present for F_OPTION_LIST_TYPE
	 *  unless we had invalid markup which prevented
	 *  HText_setLastOptionValue from finishing its job
	 *  and left the input field in an insane state. - kw
	 */
	OptionType *optptr = input_field->select_list;
	OptionType *tmp;
	while (optptr) {
	    tmp = optptr;
	    optptr = tmp->next;
	    FREE(tmp->name);
	    FREE(tmp->cp_submit_value);
	    FREE(tmp);
	}
	input_field->select_list = NULL;
	/*
	 *  Don't free the value field on option
	 *  lists since it points to a option value
	 *  same for orig value.
	 */
	input_field->value = NULL;
	input_field->orig_value = NULL;
	input_field->cp_submit_value = NULL;
	input_field->orig_submit_value = NULL;
    } else {
	FREE(input_field->value);
	FREE(input_field->orig_value);
	FREE(input_field->cp_submit_value);
	FREE(input_field->orig_submit_value);
    }
    FREE(input_field->name);
    FREE(input_field->submit_action);
    FREE(input_field->submit_enctype);
    FREE(input_field->submit_title);

    FREE(input_field->accept_cs);
}

d916 2
a917 1
     *  HTuncache_current_document(),  so we'll check now
d968 1
a968 1
#ifdef USE_SOURCE_CACHE
a1126 14
#if HTLINE_NOT_IN_POOL
    {
	HTLine *f = FirstHTLine(self);
	HTLine *l = self->last_line;

	while (l != f) {	/* Free off line array */
	    self->last_line = l->prev;
	    freeHTLine(self, l);
	    l = self->last_line;
	}
	freeHTLine(self, f);
    }
#endif

d1132 43
a1174 1
	    free_form_fields(l->input_field);
d1177 1
a1177 1
	LYFreeHiText(l);
d1218 1
a1218 1
#ifdef USE_SOURCE_CACHE
d2465 4
d2567 1
a2567 1
 *    (caller has to free the old one).
d2608 1
a2608 1
	allocHTLine(mod_line, line->size + added_chars);
d2680 26
a2856 1
	int i;
d2889 1
a2889 14
	    for (i = (plen - 1); i >= 0; i--) {
		if (p[i] == LY_UNDERLINE_START_CHAR ||
		    p[i] == LY_UNDERLINE_END_CHAR ||
		    p[i] == LY_BOLD_START_CHAR ||
		    p[i] == LY_BOLD_END_CHAR ||
		    p[i] == LY_SOFT_HYPHEN) {
		    ctrl_chars_on_this_line++;
		} else if (IS_UTF_EXTRA(p[i])) {
		    utfxtra_on_this_line++;
		}
		if (p[i] == LY_SOFT_HYPHEN && (int)text->permissible_split < i)
		    text->permissible_split = i + 1;
	    }
	    ctrl_chars_on_this_line += utfxtra_on_this_line;
d3047 1
a3047 1
    allocHTLine(temp, previous->size);
a3340 2
	    freeHTLine(text, previous);

d3409 2
a3410 3
	while (line != NULL &&
	       line != text->last_line &&
	       HText_TrueEmptyLine(line, text, FALSE)) {
d3416 2
d3438 2
a3439 1
    blank_lines(text, ((after > before) ? after : before));
d4022 2
d4057 2
a4612 1
	    freeHTLine(me, line);
d4834 66
d4976 2
a4977 3
    if (!me || !me->stbl)
	return;
    /* should this do something?? */
d5013 1
a5724 1
	freeHTLine(text, text->last_line);
a5906 3
	    int size = (int) line_ptr->size - anchor_ptr->line_pos;
	    if (size > anchor_ptr->extent)
		size = anchor_ptr->extent;
d5910 1
a5910 1
			size);
d8278 7
d8306 1
a8306 1
#ifdef USE_SOURCE_CACHE
d8361 1
a8361 1
	if (HText_HaveUserChangedForms(HTMainText)) {
d8414 1
a8414 1
	if (HText_HaveUserChangedForms(HTMainText)) {
d8779 1
a8779 1
    if (!(text && text->Lines > 1))
d8787 23
a8809 1
    freeHTLine(text, line);
d9883 1
a9883 1
#ifndef USE_FILE_UPLOAD
d10138 1
a10138 1
#ifdef USE_FILE_UPLOAD
d10149 5
a10153 8
    if (*val_used) {		/* ignore empty form field */
	if ((fd = fopen(val_used, BIN_R)) == 0) {
	    HTAlert(gettext("Can't open file for uploading"));
	} else {
	    while ((bytes = fread(buffer, sizeof(char), 256, fd)) != 0) {
		HTSABCat(result, buffer, bytes);
	    }
	    LYCloseInput(fd);
d10155 1
d10168 1
a10168 1
#endif /* USE_FILE_UPLOAD */
d10754 1
a10754 1
#ifdef USE_FILE_UPLOAD
d10946 1
a10946 1
#ifdef USE_FILE_UPLOAD
d10950 1
a10950 1
#endif /* USE_FILE_UPLOAD */
d11015 1
a11015 1
		}
d11242 1
a11242 1
#ifdef USE_FILE_UPLOAD
d11278 1
a11278 1
#endif /* USE_FILE_UPLOAD */
d11419 1
a11419 2
PUBLIC BOOLEAN HText_HaveUserChangedForms ARGS1(
	HText *,	text)
d11423 1
a11423 1
    if (text == 0)
d11430 1
a11430 1
    for (anchor_ptr = text->first_anchor;
d12162 1
a12162 1
    if (mode == CHOP) {
a12163 17
    } else if (strlen(buf) > ht->size) {
	/* we didn't allocate enough space originally - increase it */
	HTLine* temp;
	allocHTLine(temp, strlen(buf));
	if (!temp)
	    outofmem(__FILE__, "increment_tagged_htline");
	memcpy(temp, ht, LINE_SIZE(0));
#if defined(USE_COLOR_STYLE)
	POOLallocstyles(temp->styles, ht->numstyles);
	if (!temp->styles)
	    outofmem(__FILE__, "increment_tagged_htline");
	memcpy(temp->styles, ht->styles, sizeof(HTStyleChange)*ht->numstyles);
#endif
	ht = temp;
	ht->prev->next = ht;	/* Link in new line */
	ht->next->prev = ht;	/* Could be same node of course */
    }
d12217 1
a12217 1
    allocHTLine(l, MAX_LINE);
a12261 7

    /*
     *  Link in the new HTLine.
     */
    htline->next->prev = l;
    htline->next       = l;

d12278 1
a12278 1
     *  point the entry HTLine arg at it, too.
d12283 2
d13041 1
a13041 1
    allocHTLine(l, MAX_LINE);
@


1.1.3.4
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@d46 4
d1391 2
a1392 2
		    if (inbold)		lynx_start_bold();
		    if (inunderline)	lynx_start_underline();
d1423 1
a1423 1
			    lynx_start_bold();
d1425 1
a1425 1
			    lynx_start_underline();
d1427 1
a1427 1
			lynx_start_underline();
d1442 1
a1442 1
			lynx_stop_bold();
d1444 1
a1444 1
			lynx_stop_underline();
d1446 1
a1446 1
		    lynx_stop_underline();
d1455 1
a1455 1
		    lynx_start_bold();
d1461 1
a1461 1
		    lynx_stop_bold();
d1579 2
a1580 2
    lynx_stop_underline();
    lynx_stop_bold();
d13208 1
a13208 1
		    lynx_start_underline();
d13217 1
a13217 1
		    lynx_stop_underline();
d13222 1
a13222 1
		lynx_start_bold();
d13226 1
a13226 1
		lynx_stop_bold ();
d13300 2
a13301 2
    lynx_stop_underline();
    lynx_stop_bold();
d13498 2
a13499 2
		    if (inunderline)	lynx_stop_underline();
		    if (inbold)		lynx_stop_bold();
d13555 2
a13556 2
			    if (inbold)		lynx_start_bold();
			    if (inunderline)	lynx_start_underline();
d13588 1
a13588 1
		    lynx_start_underline();
d13594 1
a13594 1
		    lynx_stop_underline();
d13600 1
a13600 1
		    lynx_start_bold();
d13606 1
a13606 1
		    lynx_stop_bold();
d13727 1
a13727 1
				lynx_start_bold();
d13729 1
a13729 1
				lynx_start_underline();
@


1.1.3.5
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d70 1
a70 1
static void HText_trimHightext (
d73 1
a73 1
	int		stop_before);
d76 1
a76 1
static void LynxResetScreenCache (void)
d88 1
a88 1
    const HTStreamClass *       isa;
d106 1
a106 1
HTkcode last_kcode = NOKANJI;	/* 1997/11/14 (Fri) 09:09:26 */
d116 2
a117 2
HText * HTMainText = NULL;		/* Equivalent of main window */
HTParentAnchor * HTMainAnchor = NULL;	/* Anchor for HTMainText */
d119 2
a120 2
char * HTAppName = LYNX_NAME;		/* Application name */
char * HTAppVersion = LYNX_VERSION;	/* Application version */
d122 12
a133 12
int HTFormNumber = 0;
int HTFormFields = 0;
char * HTCurSelectGroup = NULL;		/* Form select group name */
static int HTCurSelectGroupCharset = -1;	/* ... and name's charset */
int HTCurSelectGroupType = F_RADIO_TYPE;	/* Group type */
char * HTCurSelectGroupSize = NULL;	/* Length of select */
static char * HTCurSelectedOptionValue = NULL;	/* Select choice */

char * checked_box = "[X]";
char * unchecked_box = "[ ]";
char * checked_radio = "(*)";
char * unchecked_radio = "( )";
d135 2
a136 2
static BOOLEAN underline_on = OFF;
static BOOLEAN bold_on      = OFF;
d139 2
a140 2
int LYCacheSource = SOURCE_CACHE_NONE;
int LYCacheSourceForAborted = SOURCE_CACHE_FOR_ABORTED_DROP;
d144 4
a147 4
BOOLEAN LYShowScrollbar = FALSE;
BOOLEAN LYsb_arrow = TRUE;
int LYsb_begin = -1;
int LYsb_end = -1;
d155 1
a155 1
static void * LY_check_calloc (size_t nmemb, size_t size);
d249 3
a251 3
static pool_data* ALLOC_IN_POOL (
	HTPool**	ppoolptr,
	unsigned	request)
d290 1
a290 1
static HTPool* POOL_NEW (void)
d303 2
a304 2
static void POOL_FREE (
	HTPool*	poolptr)
d476 3
a478 3
void* HText_pool_calloc (
	HText *	text,
	unsigned	size)
d483 1
a483 1
static void HText_AddHiddenLink (HText *text, TextAnchor *textanchor);
d486 2
a487 2
BOOL can_justify_here;
BOOL can_justify_here_saved;
d489 2
a490 2
BOOL can_justify_this_line;/* =FALSE if line contains form objects */
int wait_for_this_stacked_elt;/* -1 if can justify contents of the
d494 1
a494 1
BOOL form_in_htext;/*to indicate that we are in form (since HTML_FORM is
d496 1
a496 1
BOOL in_DT = FALSE;
d498 1
a498 1
BOOL can_justify_stack_depth;/* can be 0 or 1 if all code is correct*/
d516 1
a516 1
void ht_justify_cleanup (void)
d533 1
a533 1
void mark_justify_start_position (void* text)
d561 2
a562 2
static char underscore_string[MAX_LINE + 1];
char star_string[MAX_LINE + 1];
d564 2
a565 2
static int ctrl_chars_on_this_line = 0; /* num of ctrl chars in current line */
static int utfxtra_on_this_line = 0; /* num of UTF-8 extra bytes in line,
d573 1
a573 1
static HTStyle default_style =
d581 2
a582 2
static HTList * loaded_texts = NULL;	 /* A list of all those in memory */
HTList * search_queries = NULL;  /* isindex and whereis queries   */
d584 1
a584 1
static void free_all_texts (void);
d587 1
a587 1
static BOOL HText_TrueEmptyLine (
d590 1
a590 1
	BOOL		IgnoreSpaces);
d592 1
a592 1
static int HText_TrueLineSize (
d595 1
a595 1
	BOOL		IgnoreSpaces);
d607 1
a607 1
static void HText_halt (void)
d631 3
a633 3
static BOOL mem_is_avail (
    size_t	factor,
    size_t	bytes)
d654 3
a656 3
static void * LY_check_calloc (
    size_t	nmemb,
    size_t	size)
d704 2
a705 2
static void LYClearHiText (
	TextAnchor *	a)
d717 4
a720 4
static void LYSetHiText (
	TextAnchor *	a,
	char *		text,
	int		len)
d734 4
a737 4
static void LYAddHiText (
	TextAnchor *	a,
	char *		text,
	int		x)
d760 3
a762 3
static int LYAdjHiTextPos (
	TextAnchor *	a,
	int		count)
d782 3
a784 3
static char *LYGetHiTextStr (
	TextAnchor *	a,
	int		count)
d801 3
a803 3
static int LYGetHiTextPos (
	TextAnchor *	a,
	int		count)
d820 3
a822 3
static void LYCopyHiText (
	TextAnchor *	a,
	TextAnchor *	b)
d839 2
a840 2
static void HText_getChartransInfo (
	HText *	me)
d853 2
a854 2
static void PerFormInfo_free (
    PerFormInfo *	form)
d863 2
a864 2
static void free_form_fields (
	FormInfo *	input_field)
d911 2
a912 2
static void FormList_delete (
    HTList *		forms)
d924 2
a925 2
HText *	HText_new (
	HTParentAnchor *	anchor)
d1156 3
a1158 3
HText *  HText_new2 (
	HTParentAnchor *	anchor,
	HTStream *		stream)
d1173 2
a1174 2
void HText_free (
	HText *	self)
d1276 5
a1280 5
static int display_line (
	HTLine *	line,
	HText *	text,
	int		scrline GCC_UNUSED,
	const char*	target GCC_UNUSED)
d1295 1
a1295 1
    const char *cp_tgt;
d1591 2
a1592 2
static void display_title (
	HText *	text)
d1689 1
a1689 1
	    StrAllocCopy(title, (const char *)tmp);
d1766 2
a1767 2
static void display_scrollbar (
	HText *	text)
d1882 4
a1885 4
static void display_page (
	HText *	text,
	int		line_number,
	char *		target)
d2441 2
a2442 2
void HText_beginAppend (
	HText *	text)
d2497 5
a2501 5
static int set_style_by_embedded_chars (
	char *		s,
	char *		e,
	unsigned char	start_c,
	unsigned char	end_c)
d2516 8
a2523 8
static void move_anchors_in_region (
    HTLine *		line,
    int		line_number,
    TextAnchor **	prev_anchor,	/*updates++*/
    int *		prev_head_processed,
    int		sbyte,
    int		ebyte,
    int		shift)		/* Likewise */
d2591 8
a2598 8
static HTLine * insert_blanks_in_line (
    HTLine *		line,
    int		line_number,
    HText *		text,
    TextAnchor **	prev_anchor,	/*updates++*/
    int		ninserts,
    int *		oldpos,		/* Measured in cells */
    int *		newpos)		/* Likewise */
d2701 4
a2704 4
static HTStyleChange * skip_matched_and_correct_offsets (
	HTStyleChange *	end,
	HTStyleChange *	start,
	unsigned		split_pos)
d2731 3
a2733 3
static void split_line (
	HText *	text,
	unsigned	split)
d3406 3
a3408 3
static void blank_lines (
	HText *	text,
	int		newlines)
d3442 2
a3443 2
void HText_appendParagraph (
	HText *	text)
d3456 3
a3458 3
void HText_setStyle (
	HText *	text,
	HTStyle *	style)
d3477 3
a3479 3
void HText_appendCharacter (
	HText *	text,
	int		ch)
d4078 1
a4078 1
	const HTTabStop * Tab;
d4432 1
a4432 1
void _internal_HTC (HText *text, int style, int dir)
d4474 3
a4476 3
void HText_setLastChar (
	HText *	text,
	char		ch)
d4487 2
a4488 2
char HText_getLastChar (
	HText *	text)
d4499 3
a4501 3
void HText_setIgnoreExcess (
	HText *	text,
	BOOL		ignore)
d4521 3
a4523 3
static int HText_insertBlanksInStblLines (
    HText *		me,
    int		ncols)
d4760 2
a4761 2
void HText_cancelStbl (
	HText *	me)
d4784 3
a4786 3
void HText_startStblTABLE (
	HText *	me,
	short		alignment)
d4821 2
a4822 2
static void free_enclosed_stbl (
	HText *	me)
d4842 2
a4843 2
int HText_endStblTABLE (
	HText *	me)
d4900 3
a4902 3
void HText_startStblTR (
	HText *	me,
	short		alignment)
d4912 2
a4913 2
void HText_endStblTR (
	HText *	me)
d4922 6
a4927 6
void HText_startStblTD (
	HText *	me,
	int		colspan,
	int		rowspan,
	short		alignment,
	BOOL		isheader)
d4948 2
a4949 2
void HText_endStblTD (
	HText *	me)
d4960 5
a4964 5
void HText_startStblCOL (
	HText *	me,
	int		span,
	short		alignment,
	BOOL		isgroup)
d4980 2
a4981 2
void HText_endStblCOLGROUP (
	HText *	me)
d4991 3
a4993 3
void HText_startStblRowGroup (
	HText *	me,
	short		alignment)
d5004 4
a5007 4
static void add_link_number (
    HText *		text,
    TextAnchor *	a,
    BOOL		save_position)
d5034 4
a5037 4
int HText_beginAnchor (
	HText *		text,
	BOOL			underline,
	HTChildAnchor *	anc)
d5077 4
a5080 4
static BOOL HText_endAnchor0 (
	HText *	text,
	int		number,
	int		really)
d5548 3
a5550 3
void HText_endAnchor (
	HText *	text,
	int		number)
d5561 3
a5563 3
BOOL HText_isAnchorBlank (
	HText *	text,
	int		number)
d5569 3
a5571 3
void HText_appendText (
	HText *	text,
	const char *	str)
d5573 1
a5573 1
    const char *p;
d5587 2
a5588 2
static int remove_special_attr_chars (
	char *		buf)
d5613 2
a5614 2
void HText_endAppend (
	HText *	text)
d5704 4
a5707 4
static void HText_trimHightext (
	HText *	text,
	BOOLEAN	final,
	int		stop_before)
d5953 2
a5954 2
HTParentAnchor * HText_nodeAnchor (
	HText *	text)
d5967 3
a5969 3
HTChildAnchor * HText_childNextNumber (
	int		number,
	void**		prev)
d5996 3
a5998 3
void HText_FormDescNumber (
	int		number,
	char **	desc)
d6075 4
a6078 4
int HTGetRelLinkNum (
	int	num,
	int	rel,
	int	cur)
d6148 7
a6154 7
int HTGetLinkInfo (
	int		number,
	int		want_go,
	int *		go_line,
	int *		linknum,
	char **	hightext,
	char **	lname)
d6304 6
a6309 6
static BOOLEAN same_anchor_or_field (
    int		numberA,
    FormInfo *		formA,
    int		numberB,
    FormInfo *		formB,
    BOOLEAN		ta_same)
d6358 3
a6360 3
BOOL HText_TAHasMoreLines (
	int		curlink,
	int		direction)
d6415 6
a6420 6
int HTGetLinkOrFieldStart (
	int		curlink,
	int *		go_line,
	int *		linknum,
	int		direction,
	BOOLEAN	ta_skip)
d6606 8
a6613 8
BOOL HText_getFirstTargetInLine (
	HText *	text,
	int		line_num,
	BOOL		utf_flag,
	int *		offset,
	int *		tLen,
	char **	data,
	const char *	target)
d6681 1
a6681 1
int HText_getNumOfLines (void)
d6690 1
a6690 1
const char * HText_getTitle (void)
d6697 1
a6697 1
const char *HText_getStyle (void)
d6709 1
a6709 1
const char * HText_getSugFname (void)
d6727 4
a6730 4
void HTCheckFnameForCompression (
	char **		fname,
	HTParentAnchor *	anchor,
	BOOL			strip_ok)
d6735 2
a6736 2
    const char *ct = NULL;
    const char *ce = NULL;
d6887 1
a6887 1
const char * HText_getLastModified (void)
d6897 1
a6897 1
const char * HText_getDate (void)
d6907 1
a6907 1
const char * HText_getServer (void)
d6918 3
a6920 3
void HText_pageDisplay (
	int		line_num,
	char *		target)
d6964 1
a6964 1
BOOL HText_pageHasPrevTarget (void)
d6976 4
a6979 4
int HText_LinksInLines (
	HText *	text,
	int		line_num,
	int		Lines)
d7003 2
a7004 2
void HText_setStale (
	HText *	text)
d7009 2
a7010 2
void HText_refresh (
	HText *	text)
d7016 2
a7017 2
int HText_sourceAnchors (
	HText *	text)
d7022 2
a7023 2
BOOL HText_canScrollUp (
	HText *	text)
d7028 1
a7028 1
BOOL HText_canScrollDown (void)
d7038 2
a7039 2
void HText_scrollTop (
	HText *	text)
d7044 2
a7045 2
void HText_scrollDown (
	HText *	text)
d7050 2
a7051 2
void HText_scrollUp (
	HText *	text)
d7056 2
a7057 2
void HText_scrollBottom (
	HText *	text)
d7069 2
a7070 2
BOOL HText_select (
	HText *	text)
d7127 2
a7128 2
BOOL HText_POSTReplyLoaded (
	DocInfo *	doc)
d7168 2
a7169 2
BOOL HTFindPoundSelector (
	const char *		selector)
d7194 3
a7196 3
BOOL HText_selectAnchor (
	HText *		text,
	HTChildAnchor *	anchor)
d7248 3
a7250 3
void HText_applyStyle (
	HText *	me GCC_UNUSED,
	HTStyle *	style GCC_UNUSED)
d7258 3
a7260 3
void HText_updateStyle (
	HText *	me GCC_UNUSED,
	HTStyle *	style GCC_UNUSED)
d7268 3
a7270 3
HTStyle * HText_selectionStyle (
	HText *		me GCC_UNUSED,
	HTStyleSheet *		sheet GCC_UNUSED)
d7278 4
a7281 4
void HText_replaceSel (
	HText *	me GCC_UNUSED,
	const char *	aString GCC_UNUSED,
	HTStyle *	aStyle GCC_UNUSED)
d7289 3
a7291 3
void HTextApplyToSimilar (
	HText *	me GCC_UNUSED,
	HTStyle *	style GCC_UNUSED)
d7300 3
a7302 3
void HTextSelectUnstyled (
	HText *		me GCC_UNUSED,
	HTStyleSheet *		sheet GCC_UNUSED)
d7310 2
a7311 2
void HText_unlinkSelection (
	HText *	me GCC_UNUSED)
d7316 2
a7317 2
HTAnchor * HText_referenceSelected (
	HText *	me GCC_UNUSED)
d7323 1
a7323 1
int HText_getTopOfScreen (void)
d7329 2
a7330 2
int HText_getLines (
	HText *	text)
d7335 3
a7337 3
HTAnchor * HText_linkSelTo (
	HText *	me GCC_UNUSED,
	HTAnchor *	anchor GCC_UNUSED)
d7345 1
a7345 1
void HTSearchQueries_free (void)
d7365 2
a7366 2
void HTAddSearchQuery (
	char *		query)
d7399 2
a7400 2
int do_www_search (
	DocInfo *	doc)
d7598 3
a7600 3
static void write_offset (
	FILE *		fp,
	HTLine *	line)
d7611 2
a7612 2
static void write_hyphen (
	FILE *		fp)
a7627 1
 *  If is_email is TRUE add ">" before each "From " line.
d7631 3
a7633 4
void print_wwwfile_to_fd (
	FILE *		fp,
	BOOLEAN	is_email,
	BOOLEAN	is_reply)
d7642 1
a7642 1
    BOOL bs = (BOOL)(!is_email && !is_reply
a7657 2
	    } else if (is_email && !strncmp(line->data, "From ", 5)) {
		fputc('>',fp);
a7665 2
	    } else if (is_email && !strncmp(line->data, "From ", 5)) {
		fputc('>',fp);
d7742 4
a7745 4
void print_crawl_to_fd (
	FILE *		fp,
	char *		thelink,
	char *		thetitle)
d7797 4
a7800 4
static void adjust_search_result (
    DocInfo *	doc,
    int	tentative_result,
    int	start_line)
d7868 3
a7870 3
static BOOL anchor_has_target (
	TextAnchor *	a,
	char *		target)
d7959 2
a7960 2
static TextAnchor *line_num_to_anchor (
    int	line_num)
d7975 3
a7977 3
static int line_num_in_text (
    HText *		text,
    HTLine *		line)
d7992 2
a7993 2
static TextAnchor *get_prev_anchor (
    TextAnchor *	a)
d8008 6
a8013 6
static int www_search_forward (
	int		start_line,
	DocInfo *	doc,
	char *		target,
	HTLine *	line,
	int		count)
d8051 6
a8056 6
static int www_search_backward (
	int		start_line,
	DocInfo *	doc,
	char *		target,
	HTLine *	line,
	int		count)
d8094 5
a8098 5
void www_user_search (
	int		start_line,
	DocInfo *	doc,
	char *		target,
	int		direction)
d8130 3
a8132 3
void user_message (
	const char *	message,
	const char *	argument)
d8153 1
a8153 1
const char * HText_getOwner (void)
d8163 2
a8164 2
void HText_setMainTextOwner (
	const char *	owner)
d8177 1
a8177 1
const char * HText_getRevTitle (void)
d8187 1
a8187 1
const char * HText_getContentBase (void)
d8197 1
a8197 1
const char * HText_getContentLocation (void)
d8207 1
a8207 1
const char * HText_getMessageID (void)
d8213 1
a8213 1
void HTuncache_current_document (void)
d8244 1
a8244 1
static HTProtocol scm = { "source-cache-mem", 0, 0 }; /* dummy - kw */
d8246 1
a8246 1
BOOLEAN HTreparse_document (void)
d8372 1
a8372 1
BOOLEAN HTcan_reparse_document (void)
d8393 4
a8396 4
static void trace_setting_change (
	const char *	name,
	int		prev_setting,
	int		new_setting)
d8403 1
a8403 1
BOOLEAN HTdocument_settings_changed (void)
d8460 1
a8460 1
int HTisDocumentSource (void)
d8465 1
a8465 1
char * HTLoadedDocumentURL (void)
d8476 1
a8476 1
bstring * HTLoadedDocumentPost_data (void)
d8486 1
a8486 1
char * HTLoadedDocumentTitle (void)
d8497 1
a8497 1
BOOLEAN HTLoadedDocumentIsHEAD (void)
d8508 1
a8508 1
BOOLEAN HTLoadedDocumentIsSafe (void)
d8519 1
a8519 1
char * HTLoadedDocumentCharset (void)
d8530 1
a8530 1
BOOL HTLoadedDocumentEightbit (void)
d8538 2
a8539 2
void HText_setNodeAnchorBookmark (
	const char *	bookmark)
d8548 1
a8548 1
char * HTLoadedDocumentBookmark (void)
d8559 3
a8561 3
int HText_LastLineSize (
	HText *	text,
	BOOL		IgnoreSpaces)
d8568 3
a8570 3
BOOL HText_LastLineEmpty (
	HText *	text,
	BOOL		IgnoreSpaces)
d8577 2
a8578 2
int HText_LastLineOffset (
	HText *	text)
d8585 3
a8587 3
int HText_PreviousLineSize (
	HText *	text,
	BOOL		IgnoreSpaces)
d8598 3
a8600 3
BOOL HText_PreviousLineEmpty (
	HText *	text,
	BOOL		IgnoreSpaces)
d8614 4
a8617 4
static int HText_TrueLineSize (
	HTLine *	line,
	HText *	text,
	BOOL		IgnoreSpaces)
d8651 4
a8654 4
static BOOL HText_TrueEmptyLine (
	HTLine *	line,
	HText *	text,
	BOOL		IgnoreSpaces)
d8682 2
a8683 2
void HText_NegateLineOne (
	HText *	text)
d8691 2
a8692 2
BOOL HText_inLineOne (
	HText *	text)
d8710 2
a8711 2
void HText_RemovePreviousLine (
	HText *	text)
d8733 2
a8734 2
int HText_getCurrentColumn (
	HText *	text)
d8748 2
a8749 2
int HText_getMaximumColumn (
	HText *	text)
d8764 3
a8766 3
void HText_setTabID (
	HText *	text,
	const char *	name)
d8797 3
a8799 3
int HText_getTabIDColumn (
	HText *	text,
	const char *	name)
d8827 3
a8829 3
static void HText_AddHiddenLink (
	HText *	text,
	TextAnchor *	textanchor)
d8863 2
a8864 2
int HText_HiddenLinkCount (
	HText *	text)
d8879 3
a8881 3
char * HText_HiddenLinkAt (
	HText *	text,
	int		number)
d8897 14
a8910 14
static int HTFormMethod;
static char * HTFormAction = NULL;
static char * HTFormEnctype = NULL;
static char * HTFormTitle = NULL;
static char * HTFormAcceptCharset = NULL;
static BOOLEAN HTFormDisabled = FALSE;
static PerFormInfo * HTCurrentForm;

void HText_beginForm (
	char *		action,
	char *		method,
	char *		enctype,
	char *		title,
	const char *	accept_cs)
d8994 2
a8995 2
void HText_endForm (
	HText *	text)
d9060 5
a9064 5
void HText_beginSelect (
	char *		name,
	int		name_cs,
	BOOLEAN	multiple,
	char *		size)
d9105 2
a9106 2
int HText_getOptionNum (
	HText *	text)
d9133 2
a9134 2
static char * HText_skipOptionNumPrefix (
	char *		opname)
d9183 8
a9190 8
char * HText_setLastOptionValue (
	HText *	text,
	char *		value,
	char*		submit_value,
	int		order,
	BOOLEAN	checked,
	int		val_cs,
	int		submit_val_cs)
d9348 1
a9348 1
		StrAllocCopy(new_ptr->name, (const char *)tmp);
d9451 4
a9454 4
int HText_beginInput (
	HText *		text,
	BOOL			underline,
	InputFieldData *	I)
d9458 1
a9458 1
    const char *cp_option = NULL;
d9558 1
a9558 1
	    StrAllocCopy(IValue, (const char *)tmp);
d9938 2
a9939 2
void HText_endInput (
	HText *		text)
d9964 3
a9966 3
static double get_trans_q (
    int		cs_from,
    char *		givenmime)
d10015 4
a10018 4
static int find_best_target_cs (
    char **		best_csname,
    int		cs_from,
    const char *	acceptstring)
d10053 3
a10055 3
static void load_a_file (
    char *	val_used,
    bstring **	result)
d10075 1
a10075 1
static const char *guess_content_type (const char * filename)
d10078 1
a10078 1
    const char *desc;
d10087 3
a10089 3
static void cannot_transcode (
    BOOL *		had_warning,
    const char *	target_csname)
d10102 2
a10103 2
static unsigned check_form_specialchars (
    char *	value)
d10126 3
a10128 3
static void UpdateBoundary (
	char **	Boundary,
	bstring *	data)
d10152 3
a10154 3
static char * convert_to_base64 (
	char *		src,
	int		len)
d10158 1
a10158 1
    static const char basis_64[] =
d10238 4
a10241 4
static char *escape_or_quote_name (
	char *		name,
	QuoteData	quoting,
	char *		MultipartContentType)
d10266 3
a10268 3
static char *escape_or_quote_value (
	char *		value,
	QuoteData	quoting)
d10293 3
a10295 3
static int check_if_base64_needed (
	int		submit_method,
	bstring *	data)
d10334 5
a10338 5
int HText_SubmitForm (
	FormInfo *	submit_item,
	DocInfo *	doc,
	char *		link_name,
	char *		link_value)
d10346 2
a10347 2
    const char *out_csname;
    const char *target_csname = NULL;
d11163 1
a11163 1
		    const char *t = guess_content_type(val_used);
d11261 1
a11261 1
void HText_DisableCurrentForm (void)
d11285 2
a11286 2
void HText_ResetForm (
	FormInfo *	form)
d11335 2
a11336 2
BOOLEAN HText_HaveUserChangedForms (
	HText *	text)
d11380 2
a11381 2
void HText_activateRadioButton (
	FormInfo *	form)
d11423 1
a11423 1
static void free_all_texts (void)
d11469 2
a11470 2
char * stub_HTAnchor_address (
	HTAnchor *	me)
d11478 2
a11479 2
void HText_setToolbar (
	HText *	text)
d11486 2
a11487 2
BOOL HText_hasToolbar (
	HText *	text)
d11492 2
a11493 2
void HText_setNoCache (
	HText *	text)
d11500 2
a11501 2
BOOL HText_hasNoCacheSet (
	HText *	text)
d11506 2
a11507 2
BOOL HText_hasUTF8OutputSet (
	HText *	text)
d11522 4
a11525 4
void HText_setKcode (
	HText *	text,
	const char *	charset,
	LYUCcharset *	p_in)
d11610 2
a11611 2
void HText_setBreakPoint (
	HText *	text)
d11637 3
a11639 3
BOOL HText_AreDifferent (
	HTParentAnchor *	anchor,
	const char *		full_address)
d11743 3
a11745 3
static void cleanup_line_for_textarea (
	     char *  line,
	     int     len)
d11855 7
a11861 7
static int increment_tagged_htline (
	HTLine *	ht,
	TextAnchor *   a,
	int *		lx_val,
	int *		old_val,
	int		incr,
	int		mode)
d12114 3
a12116 3
static void insert_new_textarea_anchor (
	TextAnchor **   curr_anchor,
	HTLine **       exit_htline)
d12244 5
a12248 5
static void update_subsequent_anchors (
	int		 newlines,
	TextAnchor *	 start_anchor,
	HTLine *	 start_htline,
	int		 start_tag)
d12391 2
a12392 2
int HText_ExtEditForm (
	   LinkInfo *	form_link)
d12729 3
a12731 3
void HText_ExpandTextarea (
	    LinkInfo *	form_link,
	    int	newlines)
d12829 2
a12830 2
int HText_InsertFile (
	   LinkInfo *	form_link)
d13154 5
a13158 5
static void redraw_part_of_line (
	HTLine *	line,
	char*		str,
	int		len,
	HText *	text)
d13334 11
a13344 11
static void move_to_glyph (
	int		YP,
	int		XP,
	int		XP_draw_min,
	char *		data,
	int		datasize,
	unsigned	offset,
	const char *	target,
	char *		hightext,
	int		flags,
	BOOL		utf_flag)
d13348 1
a13348 1
    const char *end_of_data;
d13351 1
a13351 1
    const char *cp_tgt;
d13797 7
a13803 7
void LYMoveToLink (
	int		cur,
	const char *	target,
	char *		hightext,
	int		flag,
	BOOL		inU,
	BOOL		utf_flag)
d13856 2
a13857 2
void redraw_lines_of_link (
	int		cur GCC_UNUSED)
d13892 1
a13892 1
void HTMark_asSource (void)
d13899 2
a13900 2
HTkcode HText_getKcode (
	HText *	text)
d13905 3
a13907 3
void HText_updateKcode (
	HText *	text,
	HTkcode	kcode)
d13912 2
a13913 2
HTkcode HText_getSpecifiedKcode (
	HText *	text)
d13918 3
a13920 3
void HText_updateSpecifiedKcode (
	HText *	text,
	HTkcode	kcode)
d13925 1
a13925 1
int HTMainText_Get_UCLYhndl (void)
@


1.1.3.6
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 2
a3 2
 *		===============================
 */
d70 4
a73 2
static void HText_trimHightext(HText *text, BOOLEAN final,
			       int stop_before);
d76 1
a76 1
static void LynxResetScreenCache(void)
d87 2
a88 2
struct _HTStream {		/* only know it as object */
    const HTStreamClass *isa;
d116 2
a117 2
HText *HTMainText = NULL;	/* Equivalent of main window */
HTParentAnchor *HTMainAnchor = NULL;	/* Anchor for HTMainText */
d119 2
a120 2
char *HTAppName = LYNX_NAME;	/* Application name */
char *HTAppVersion = LYNX_VERSION;	/* Application version */
d124 1
a124 1
char *HTCurSelectGroup = NULL;	/* Form select group name */
d127 2
a128 2
char *HTCurSelectGroupSize = NULL;	/* Length of select */
static char *HTCurSelectedOptionValue = NULL;	/* Select choice */
d130 4
a133 4
char *checked_box = "[X]";
char *unchecked_box = "[ ]";
char *checked_radio = "(*)";
char *unchecked_radio = "( )";
d136 1
a136 1
static BOOLEAN bold_on = OFF;
d155 1
a155 2
static void *LY_check_calloc(size_t nmemb, size_t size);

d177 3
a179 3
    unsigned int direction:2;	/* on or off */
    unsigned int horizpos:14;	/* horizontal position of this change */
    unsigned int style:16;	/* which style to change to */
d190 1
a190 7
enum {
    POOL_SIZE = ((8192
		  - 4 * sizeof(void *)
		  - sizeof(struct _HTPool *)
		  - sizeof(int))
		 / sizeof(pool_data))
};
d193 2
a194 2
    pool_data data[POOL_SIZE];
    struct _HTPool *prev;
d245 7
a251 5
 * Allocates 'n' items in the pool of type 'HTPool' pointed by 'poolptr'.
 * Returns a pointer to the "allocated" memory or NULL if fails.
 * Updates 'poolptr' if necessary.
 */
static pool_data *ALLOC_IN_POOL(HTPool ** ppoolptr, unsigned request)
d253 2
a254 2
    HTPool *pool = *ppoolptr;
    pool_data *ptr;
d273 1
a273 2
	    HTPool *newpool = (HTPool *) LY_CALLOC(1, sizeof(HTPool));

d281 1
a281 1
	    }
d288 1
a288 1
 * Returns a pointer to initialized pool of type 'HTPool', or NULL if fails.
d290 1
a290 1
static HTPool *POOL_NEW(void)
d292 1
a292 2
    HTPool *poolptr = (HTPool *) LY_CALLOC(1, sizeof(HTPool));

d301 1
a301 1
 * Frees a pool of type 'HTPool' pointed by poolptr.
d303 2
a304 1
static void POOL_FREE(HTPool * poolptr)
d306 2
a307 3
    HTPool *cur = poolptr;
    HTPool *prev;

d319 4
a322 4
    struct _line *next;
    struct _line *prev;
    unsigned short offset;	/* Implicit initial spaces */
    unsigned short size;	/* Number of characters */
d324 2
a325 2
    HTStyleChange *styles;
    unsigned short numstyles;
d327 1
a327 1
    char data[1];		/* Space for terminator at least! */
d330 2
a331 1
#define LINE_SIZE(size) (sizeof(HTLine)+(size))		/* Allow for terminator */
d354 2
a355 2
    HTLine base;
    char data[MAX_LINE + 2];
d361 12
a372 12
    struct _TextAnchor *next;
    struct _TextAnchor *prev;	/* www_user_search only! */
    int number;			/* For user interface */
    int line_num;		/* Place in document */
    short line_pos;		/* Bytes/chars - extent too */
    short extent;		/* (see HText_trimHightext) */
    BOOL show_anchor;		/* Show the anchor? */
    BOOL inUnderline;		/* context is underlined */
    BOOL expansion_anch;	/* TEXTAREA edit new anchor */
    char link_type;		/* Normal, internal, or form? */
    FormInfo *input_field;	/* Info for form links */
    HiliteList lites;
d374 1
a374 1
    HTChildAnchor *anchor;
d378 2
a379 2
    char *name;			/* ID value of TAB */
    int column;			/* Zero-based column value */
d382 1
d384 4
a387 4
 *	next_line is valid if stale is false.
 *	top_of_screen line means the line at the top of the screen
 *			or just under the title if there is one.
 */
d389 1
a389 1
    HTParentAnchor *node_anchor;
d391 17
a407 17
    HTLine *last_line;
    HTLineTemp temp_line[2];
    int Lines;			/* Number of them */
    TextAnchor *first_anchor;	/* double-linked on demand */
    TextAnchor *last_anchor;
    TextAnchor *last_anchor_before_stbl;
    TextAnchor *last_anchor_before_split;
    HTList *forms;		/* also linked internally */
    int last_anchor_number;	/* user number */
    BOOL source;		/* Is the text source? */
    BOOL toolbar;		/* Toolbar set? */
    HTList *tabs;		/* TAB IDs */
    HTList *hidden_links;	/* Content-less links ... */
    int hiddenlinkflag;		/*  ... and how to treat them */
    BOOL no_cache;		/* Always refresh? */
    char LastChar;		/* For absorbing white space */
    BOOL IgnoreExcess;		/* Ignore chars at wrap point */
d410 11
a420 11
    HTStyle *style;		/* Current style */
    int display_on_the_fly;	/* Lines left */
    int top_of_screen;		/* Line number */
    HTLine *top_of_screen_line;	/* Top */
    HTLine *next_line;		/* Bottom + 1 */
    unsigned permissible_split;	/* in last line */
    BOOL in_line_1;		/* of paragraph */
    BOOL stale;			/* Must refresh */
    BOOL page_has_target;	/* has target on screen */
    BOOL has_utf8;		/* has utf-8 on screen or line */
    BOOL had_utf8;		/* had utf-8 when last displayed */
d422 2
a423 2
    int first_lineno_last_disp_partial;
    int last_lineno_last_disp_partial;
d425 2
a426 2
    STable_info *stbl;
    HTList *enclosed_stbl;
d428 2
a429 2
    HTkcode kcode;		/* Kanji code? */
    HTkcode specified_kcode;	/* Specified Kanji code */
d431 20
a450 35
    enum _detected_kcode {
	DET_SJIS,
	DET_EUC,
	DET_NOTYET,
	DET_MIXED
    } detected_kcode;		/* Detected Kanji code */
    enum _SJIS_status {
	SJIS_state_neutral,
	SJIS_state_in_kanji,
	SJIS_state_has_bad_code
    } SJIS_status;
    enum _EUC_status {
	EUC_state_neutral,
	EUC_state_in_kanji,
	EUC_state_in_kana,
	EUC_state_has_bad_code
    } EUC_status;
#endif
    enum grid_state {
	S_text,
	S_esc,
	S_dollar,
	S_paren,
	S_nonascii_text,
	S_dollar_paren,
	S_jisx0201_text
    } state;			/* Escape sequence? */
    int kanji_buf;		/* Lead multibyte */
    int in_sjis;		/* SJIS flag */
    int halted;			/* emergency halt */

    BOOL have_8bit_chars;	/* Any non-ASCII chars? */
    LYUCcharset *UCI;		/* node_anchor UCInfo */
    int UCLYhndl;		/* charset we are fed */
    UCTransParams T;
d452 2
a453 2
    HTStream *target;		/* Output stream */
    HTStreamClass targetClass;	/* Output routines */
d455 1
a455 1
    HTPool *pool;		/* this HText memory pool */
d458 14
a471 14
    /*
       * Parse settings when this HText was generated.
     */
    BOOL clickable_images;
    BOOL pseudo_inline_alts;
    BOOL verbose_img;
    BOOL raw_mode;
    BOOL historical_comments;
    BOOL minimal_comments;
    BOOL soft_dquotes;
    short old_dtd;
    short keypad_mode;
    short disp_lines;		/* Screen size */
    short disp_cols;		/* Used for reports only */
d476 3
a478 1
void *HText_pool_calloc(HText *text, unsigned size)
d480 1
a480 1
    return (void *) ALLOC_IN_POOL(&text->pool, size);
d483 1
a483 1
static void HText_AddHiddenLink(HText *text, TextAnchor *textanchor);
d489 7
a495 9
BOOL can_justify_this_line;	/* =FALSE if line contains form objects */
int wait_for_this_stacked_elt;	/* -1 if can justify contents of the

				   element on the op of stack. If positive - specifies minimal stack depth
				   plus 1 at which we can justify element (can be MAX_LINE+2 if
				   ok_justify ==FALSE or in psrcview. */
BOOL form_in_htext;		/*to indicate that we are in form (since HTML_FORM is

				   not stacked in the HTML.c */
a496 1

d498 1
a498 1
BOOL can_justify_stack_depth;	/* can be 0 or 1 if all code is correct */
d501 1
d503 2
a504 2
    int byte_len;		/*length in bytes */
    int cell_len;		/*length in cells */
d507 2
a508 1
static int justify_start_position;	/* this is an index of char from which
d510 1
a510 3
					   justification can start (eg after "* " preceeding <li> text) */

static int ht_num_runs;		/*the number of runs filled */
d513 1
a513 1
static TextAnchor *last_anchor_of_previous_line;
d516 1
a516 1
void ht_justify_cleanup(void)
d522 1
a522 2
	? 30000 /*MAX_NESTING */  + 2	/*some unreachable value */
	: -1;
d533 1
a533 1
void mark_justify_start_position(void *text)
d535 2
a536 2
    if (text && ((HText *) text)->last_line)
	justify_start_position = ((HText *) text)->last_line->size;
d539 1
d548 2
d551 1
a551 1
 * Boring static variable used for moving cursor across
d564 3
a566 4
static int ctrl_chars_on_this_line = 0;		/* num of ctrl chars in current line */
static int utfxtra_on_this_line = 0;	/* num of UTF-8 extra bytes in line,

					   they *also* count as ctrl chars. */
d574 5
a578 4
{0, "(Unstyled)", 0, "",
 (HTFont) 0, 1, HT_BLACK, 0, 0,
 0, 0, 0, HT_LEFT, 1, 0, 0,
 NO, NO, 0, 0, 0};
a579 2
static HTList *loaded_texts = NULL;	/* A list of all those in memory */
HTList *search_queries = NULL;	/* isindex and whereis queries   */
d581 2
d584 1
a584 1
static void free_all_texts(void);
d587 9
a595 3
static BOOL HText_TrueEmptyLine(HTLine *line, HText *text, BOOL IgnoreSpaces);

static int HText_TrueLineSize(HTLine *line, HText *text, BOOL IgnoreSpaces);
d600 6
a605 6
 * text->halted = 1: have set fake 'Z' and output a message
 *		  2: next time when HText_appendCharacter is called
 *		     it will append *** MEMORY EXHAUSTED ***, then set
 *		     to 3.
 *		  3: normal text output will be suppressed (but not anchors,
 *		     form fields etc.)
d607 1
a607 1
static void HText_halt(void)
d620 14
a633 12
 * Check whether factor*min(bytes,MIN_NEEDED_MEM) is available,
 * or bytes if factor is 0.
 * MIN_NEEDED_MEM and factor together represent a security margin,
 * to take account of all the memory allocations where we don't check
 * and of buffers which may be emptied before HTCheckForInterupt()
 * is (maybe) called and other things happening, with some chance of
 * success.
 * This just tries to malloc() the to-be-checked-for amount of memory,
 * which might make the situation worse depending how allocation works.
 * There should be a better way...  - kw
 */
static BOOL mem_is_avail(size_t factor, size_t bytes)
a635 1

d650 7
a656 5
 * Replacement for calloc which checks for "enough" free memory
 * (with some security margins) and tries various recovery actions
 * if deemed necessary.  - kw
 */
static void *LY_check_calloc(size_t nmemb, size_t size)
a658 1

d664 9
a672 11
	HText *t = (HText *) HTList_objectAt(loaded_texts, i);

	CTRACE((tfp,
		"\nBUG *** Emergency freeing document %d/%d for '%s'%s!\n",
		i + 1, n,
		((t && t->node_anchor &&
		  t->node_anchor->address) ?
		 t->node_anchor->address : "unknown anchor"),
		((t && t->node_anchor &&
		  t->node_anchor->post_data) ?
		 " with POST data" : "")));
d704 2
a705 1
static void LYClearHiText(TextAnchor *a)
a711 1

d717 4
a720 2
static void LYSetHiText(TextAnchor *a, char *text,
			int len)
d734 4
a737 2
static void LYAddHiText(TextAnchor *a, char *text,
			int x)
d760 3
a762 1
static int LYAdjHiTextPos(TextAnchor *a, int count)
d782 3
a784 1
static char *LYGetHiTextStr(TextAnchor *a, int count)
d801 3
a803 1
static int LYGetHiTextPos(TextAnchor *a, int count)
d820 3
a822 1
static void LYCopyHiText(TextAnchor *a, TextAnchor *b)
d828 1
a828 1
    for (count = 0;; ++count) {
d839 2
a840 1
static void HText_getChartransInfo(HText *me)
a844 1

d853 2
a854 1
static void PerFormInfo_free(PerFormInfo * form)
d863 2
a864 1
static void free_form_fields(FormInfo * input_field)
d867 1
a867 1
     * Free form fields.
d872 5
a876 5
	 * Free off option lists if present.
	 * It should always be present for F_OPTION_LIST_TYPE
	 * unless we had invalid markup which prevented
	 * HText_setLastOptionValue from finishing its job
	 * and left the input field in an insane state.  - kw
a879 1

d889 3
a891 3
	 * Don't free the value field on option
	 * lists since it points to a option value
	 * same for orig value.
d911 2
a912 1
static void FormList_delete(HTList *forms)
d916 1
a916 2

    while ((form = (PerFormInfo *) HTList_nextObject(cur)) != NULL)
d922 4
a925 3
 *			---------------
 */
HText *HText_new(HTParentAnchor *anchor)
d929 1
a929 1
    int status, VMType = 3, VMTotal;
d931 2
a932 3
    HTLine *line = NULL;
    HText *self = typecalloc(HText);

d944 3
a946 3
     * If the previously shown text had UTF-8 characters on screen,
     * remember this in the newly created object.  Do this now, before
     * the previous object may become invalid.  - kw
d959 1
a959 1
    if (!loaded_texts) {
d967 4
a970 4
     * Links between anchors & documents are a 1-1 relationship.  If
     * an anchor is already linked to a document we didn't call
     * HTuncache_current_document(), so we'll check now
     * and free it before reloading.  - Dick Wesseling (ftu@@fi.ruu.nl)
d974 1
a974 1
	CTRACE((tfp, "GridText: Auto-uncaching\n"));
d977 2
a978 2
	((HText *) anchor->document)->node_anchor = NULL;
	HText_free((HText *) anchor->document);
d991 1
a991 1
	HText_free((HText *) HTList_removeFirstObject(loaded_texts));
d1037 7
a1043 7
     * If we are going to render the List Page, always merge in hidden
     * links to get the numbering consistent if form fields are numbered
     * and show up as hidden links in the list of links.
     * If we are going to render a bookmark file, also always merge in
     * hidden links, to get the link numbers consistent with the counting
     * in remove_bookmark_link().  Normally a bookmark file shouldn't
     * contain any entries with empty titles, but it might happen.  - kw
d1053 1
a1053 1
		       anchor->post_data)
d1065 4
a1068 5
    /* mark_htext_as_source == TRUE if we are parsing html file (and psrc_view
     * is set temporary to false at creation time)
     *
     * psrc_view == TRUE if source of the text produced by some lynx module
     * (like ftp browsers) is requested).  - VH
d1070 1
a1070 3
    self->source = (BOOL) (LYpsrc
			   ? mark_htext_as_source || psrc_view
			   : HTOutputFormat == WWW_SOURCE);
d1073 2
a1074 2
    HTAnchor_setDocument(anchor, (HyperDoc *) self);
    HTFormNumber = 0;		/* no forms started yet */
d1096 1
a1096 1
     * Check the kcode setting if the anchor has a charset element.  -FM
d1102 4
a1105 4
     * Memory leak fixed.
     * 05-29-94 Lynx 2-3-1 Garrett Arch Blythe
     * Check to see if our underline and star_string need initialization
     * if the underline is not filled with dots.
d1109 1
a1109 1
	 * Create an array of dots for the UNDERSCORES macro.  -FM
d1111 2
a1112 2
	memset(underscore_string, '.', (MAX_LINE - 1));
	underscore_string[(MAX_LINE - 1)] = '\0';
d1115 1
a1115 1
	 * Create an array of underscores for the STARS macro.  -FM
d1117 2
a1118 2
	memset(star_string, '_', (MAX_LINE - 1));
	star_string[(MAX_LINE - 1)] = '\0';
d1122 1
a1122 1
    underline_on = FALSE;	/* reset */
d1131 2
a1132 2
	display_partial = TRUE;	/* enable HTDisplayPartial() */
	NumOfLines_partial = 0;	/* initialize */
d1136 4
a1139 4
     * These two fields should only be set to valid line numbers
     * by calls of display_page during partial displaying.  This
     * is just so that the FIRST display_page AFTER that can avoid
     * repainting the same lines on the screen.  - kw
d1152 8
a1159 6
 *			---------------
 *
 *      Stream is assumed open and left open.
 */
HText *HText_new2(HTParentAnchor *anchor,
		  HTStream *stream)
d1161 1
a1161 1
    HText *this = HText_new(anchor);
d1171 4
a1174 3
 *	----------------
 */
void HText_free(HText *self)
d1193 2
a1194 3
    while (self->first_anchor) {	/* Free off anchor array */
	TextAnchor *l = self->first_anchor;

d1206 1
a1206 1
     * Free the tabs list.  -FM
d1209 2
a1210 2
	HTTabID *Tab = NULL;
	HTList *cur = self->tabs;
d1212 1
a1212 1
	while (NULL != (Tab = (HTTabID *) HTList_nextObject(cur))) {
d1221 1
a1221 1
     * Free the hidden links list.  -FM
d1224 2
a1225 2
	char *href = NULL;
	HTList *cur = self->hidden_links;
d1227 1
a1227 1
	while (NULL != (href = (char *) HTList_nextObject(cur)))
d1234 2
a1235 2
     * Invoke HTAnchor_delete() to free the node_anchor
     * if it is not a destination of other links.  -FM
d1254 1
a1254 1
	HTAnchor_setDocument(self->node_anchor, (HyperDoc *) 0);
d1258 2
a1259 2
	     * Make sure HTMainAnchor won't point
	     * to an invalid structure.  - KW
d1269 3
a1271 2
 *		---------------
 */
d1274 7
a1280 4
 *	-------------
 */
static int display_line(HTLine *line, HText *text, int scrline GCC_UNUSED,
			const char *target GCC_UNUSED)
a1286 1

a1288 1

d1292 1
a1292 1
    BOOL inbold = NO, inunderline = NO;
d1296 1
a1296 1
    int i_start_tgt = 0, i_after_tgt;
d1298 1
a1298 2
    BOOL intarget = NO;

d1304 1
a1304 1
    text->has_utf8 = NO;	/* use as per-line flag, except with ncurses */
d1308 3
a1310 3
     * Set up the multibyte character buffer,
     * and clear the line to which we will be
     * writing.
d1316 2
a1317 2
     * Add offset, making sure that we do not
     * go over the COLS limit on the display.
d1319 3
a1321 3
    j = (int) line->offset;
    if (j > (int) DISPLAY_COLS - 1)
	j = (int) DISPLAY_COLS - 1;
d1323 1
a1323 1
    SLsmg_forward(j);
d1331 2
a1332 2
	for (i = 0; i < j; i++)
	    LYaddch(' ');
d1336 2
a1337 2
     * Add the data, making sure that we do not
     * go over the COLS limit on the display.
d1345 1
a1345 1
     * If the target is on this line, it will be emphasized.
d1350 4
a1353 4
				     target,
				     text->T.output_utf8, YES,
				     &HitOffset,
				     &LenNeeded);
d1355 1
a1355 1
	    if (((int) line->offset + LenNeeded) >= DISPLAY_COLS) {
d1376 4
a1379 4
					     target,
					     text->T.output_utf8, YES,
					     &HitOffset,
					     &LenNeeded);
d1387 2
a1388 4
		    if (inbold)
			lynx_start_bold();
		    if (inunderline)
			lynx_start_underline();
d1401 3
a1403 2
	       i >= (int) (CStyle.horizpos + line->offset + 1)) {
	    LynxChangeStyle(CStyle.style, CStyle.direction);
d1410 7
a1416 7
	case LY_UNDERLINE_START_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		inunderline = YES;
		if (!intarget) {
d1418 5
a1422 3
		    if (LYShowColor == SHOW_COLOR_NEVER)
			lynx_start_bold();
		    else
d1424 2
a1425 3
#else
		    lynx_start_underline();
#endif /* PDCURSES */
d1427 1
a1427 2
	    }
	    break;
d1429 7
a1435 7
	case LY_UNDERLINE_END_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		inunderline = NO;
		if (!intarget) {
d1443 2
a1444 1
#endif /* PDCURSES */
d1446 1
a1446 2
	    }
	    break;
d1448 5
a1452 5
	case LY_BOLD_START_CHAR:
	    inbold = YES;
	    if (!intarget)
		lynx_start_bold();
	    break;
d1454 5
a1458 5
	case LY_BOLD_END_CHAR:
	    inbold = NO;
	    if (!intarget)
		lynx_stop_bold();
	    break;
d1461 4
a1464 4
	case LY_SOFT_NEWLINE:
	    if (!dump_output_immediately) {
		LYaddch('+');
		i++;
d1466 1
a1466 1
		i_after_tgt++;
d1468 2
a1469 2
	    }
	    break;
d1471 22
a1492 22
	case LY_SOFT_HYPHEN:
	    if (*data != '\0' ||
		isspace(UCH(LastDisplayChar)) ||
		LastDisplayChar == '-') {
		/*
		 * Ignore the soft hyphen if it is not the last
		 * character in the line.  Also ignore it if it
		 * first character following the margin, or if it
		 * is preceded by a white character (we loaded 'M'
		 * into LastDisplayChar if it was a multibyte
		 * character) or hyphen, though it should have
		 * been excluded by HText_appendCharacter() or by
		 * split_line() in those cases.  -FM
		 */
		break;
	    } else {
		/*
		 * Make it a hard hyphen and fall through.  -FM
		 */
		buffer[0] = '-';
	    }
	    /* FALLTHRU */
d1494 1
a1494 1
	default:
d1497 8
a1504 7
	    if (!intarget && cp_tgt && i >= i_start_tgt) {
		/*
		 * Start the emphasis.
		 */
		if (data > cp_tgt) {
		    LYstartTargetEmphasis();
		    intarget = YES;
a1505 1
	    }
d1508 14
a1521 14
	    i++;
	    if (text->T.output_utf8 && is8bits(buffer[0])) {
		text->has_utf8 = YES;
		utf_extra = utf8_length(text->T.output_utf8, data - 1);
		LastDisplayChar = 'M';
	    }
	    if (utf_extra) {
		strncpy(&buffer[1], data, utf_extra);
		buffer[utf_extra + 1] = '\0';
		LYaddstr(buffer);
		buffer[1] = '\0';
		data += utf_extra;
		utf_extra = 0;
	    } else if (HTCJK != NOCJK && is8bits(buffer[0])
d1523 1
a1523 1
		       && kanji_code != SJIS
d1526 4
a1529 5
		/*
		 * For CJK strings, by Masanobu Kimura.
		 */
		if (i >= DISPLAY_COLS)
		    goto after_while;
d1531 24
a1554 24
		buffer[1] = *data;
		buffer[2] = '\0';
		data++;
		i++;
		LYaddstr(buffer);
		buffer[1] = '\0';
		/*
		 * For now, load 'M' into LastDisplayChar,
		 * but we should check whether it's white
		 * and if so, use ' '.  I don't know if
		 * there actually are white CJK characters,
		 * and we're loading ' ' for multibyte
		 * spacing characters in this code set,
		 * but this will become an issue when
		 * the development code set's multibyte
		 * character handling is used.  -FM
		 */
		LastDisplayChar = 'M';
	    } else {
		LYaddstr(buffer);
		LastDisplayChar = buffer[0];
	    }
	}			/* end of switch */
    }				/* end of while */
d1556 1
a1556 1
  after_while:
d1564 1
a1564 1
     * Add the return.
d1578 3
a1580 2
    while (current_style < line->numstyles) {
	LynxChangeStyle(CStyle.style, CStyle.direction);
d1585 1
a1585 1
    return (0);
d1589 4
a1592 3
 *	---------------------
 */
static void display_title(HText *text)
d1602 1
a1602 1
     * Make sure we have a text structure.  -FM
d1607 1
a1607 1
    lynx_start_title_color();
d1618 1
a1618 1
     * Load the title field.  -FM
d1625 3
a1627 3
     * There shouldn't be any \n in the title field,
     * but if there is, lets kill it now.  Also trim
     * any trailing spaces.  -FM
d1629 1
a1629 1
    if ((cp = strchr(title, '\n')) != NULL)
d1636 1
a1636 1
     * Generate the page indicator (percent) string.
d1642 1
a1642 1
	       text->top_of_screen <= 99999 && text->Lines <= 999999) {
d1646 1
a1646 1
	       (display_lines) > 0) {
d1648 2
a1649 2
	 * In a small attempt to correct the number of pages counted....
	 * GAB 07-14-94
d1651 2
a1652 2
	 * In a bigger attempt (hope it holds up 8-)....
	 * FM 02-08-95
d1655 1
a1655 1
	(((text->Lines + 1) + (display_lines - 1)) / (display_lines));
d1657 2
a1658 2
	((text->Lines + 1) < display_lines) ? 0 :
	((text->Lines + 1) - display_lines);
d1662 2
a1663 2
		 total_pages :
		 ((text->top_of_screen + display_lines) / (display_lines))),
d1670 3
a1672 3
     * Generate and display the title string, with page indicator
     * if appropriate, preceded by the toolbar token if appropriate,
     * and truncated if necessary.  -FM & KW
d1678 1
a1678 1
		TO_EUC((unsigned char *) title, tmp);
d1680 1
a1680 1
		TO_SJIS((unsigned char *) title, tmp);
d1683 1
a1683 1
		    if (title[i] != CH_ESC) {	/* S/390 -- gil -- 1487 */
d1689 1
a1689 1
	    StrAllocCopy(title, (const char *) tmp);
d1709 1
a1709 3
	    LYaddch(c);
	    LYaddch(c);
	    LYaddch(c);
d1713 1
a1713 3
	    LYaddch(ACS_RARROW);
	    LYaddch(ACS_RARROW);
	    LYaddch(ACS_RARROW);
d1723 2
a1724 2
	 * Truncation takes into account the possibility that
	 * multibyte characters might be present.  -HS (H.  Senshu)
d1727 1
a1727 2

	last = (int) strlen(percent) + CHAR_WIDTH;
d1749 1
a1749 1
	LYmove(1, 0);		/* As after \n */
d1757 1
a1757 1
    lynx_stop_title_color();
d1763 2
a1764 2
 *	---------------------
 */
d1766 2
a1767 1
static void display_scrollbar(HText *text)
d1770 2
a1771 2
    int h = display_lines - 2 * (LYsb_arrow != 0);	/* Height of the scrollbar */
    int off = (LYsb_arrow != 0);	/* Start of the scrollbar */
d1789 1
a1789 1
    sh = (shown * h + text->Lines / 2) / (text->Lines + 1);
d1806 2
a1807 2
			  1. * (h - sh - 1) * text->top_of_screen
			  / (text->Lines - display_lines + 1));
d1838 1
a1838 1
    for (i = 1; i <= h; i++) {
d1840 1
a1840 1
	if (i - 1 <= top_skip && i > top_skip)
d1842 1
a1842 1
	if (i - 1 <= h - bot_skip && i > h - bot_skip)
d1875 1
a1875 1
#define display_scrollbar(text)	/*nothing */
d1878 1
d1880 6
a1885 4
 *	-------------
 */
static void display_page(HText *text, int line_number,
			 char *target)
d1887 1
a1887 1
    HTLine *line = NULL;
a1888 1

a1901 1

d1910 3
a1912 3
	 * Check whether to force a screen clear to enable scrollback,
	 * or as a hack to fix a reverse clear screen problem for some
	 * curses packages.  - shf@@access.digex.net & seldon@@eskimo.com
d1921 1
a1921 1
	nlinks = 0;		/* set number of links to 0 */
d1924 1
d1934 1
a1934 2
    if (target && *target == '\0')
	target = NULL;
d1937 3
a1939 3
	/* No screen space to display anything!
	 * returning here makes it more likely we will survive if
	 * an xterm is temporarily made very small.  - kw */
d1947 1
a1947 1
     * Constrain the line number to be within the document.
d1956 1
a1956 1
    for (i = 0, line = FirstHTLine(text);	/* Find line */
d1958 1
a1958 1
	 i++, line = line->next) {	/* Loop */
d1970 1
a1970 1
	    nlinks = 0;		/* set number of links to 0 */
d1976 1
a1976 1
    }				/* Loop */
d1980 5
a1984 5
    /*
     * current_char_set has changed since last invocation,
     * and it's not just 7-bit.
     * Also we don't want to do this for -dump and -source etc.
     */
d1988 1
a1988 1
	 * Currently implemented only for LINUX
d1997 3
a1999 3
     * Check whether to force a screen clear to enable scrollback,
     * or as a hack to fix a reverse clear screen problem for some
     * curses packages.  - shf@@access.digex.net & seldon@@eskimo.com
d2006 1
d2009 4
a2012 4
     * Reset stack of color attribute changes to avoid color leaking,
     * except if what we last displayed from this text was the previous
     * screenful, in which case carrying over the state might be beneficial
     * (although it shouldn't generally be needed any more).  - kw
d2022 2
a2023 2
    display_title(text);	/* will move cursor to top of screen */
    display_flag = TRUE;
d2031 1
a2031 1
	LynxResetScreenCache();
d2037 2
a2038 2
	if (stop_before_for_anchors > line_number + (display_lines))
	    stop_before_for_anchors = line_number + (display_lines);
d2041 1
a2041 1
	stop_before_for_anchors = line_number + (display_lines);
d2044 1
a2044 1
     * Output the page.
d2058 1
a2058 1
	for (i = 0; i < (display_lines); i++) {
d2060 1
a2060 1
	     * Verify and display each line.
d2073 1
a2073 1
		nlinks = 0;	/* set number of links to 0 */
d2087 1
a2087 1
		display_line(line, text, i + 1, target);
d2092 2
a2093 2
	     * If the target is on this line, recursively
	     * seek and emphasize it.  -FM
d2095 2
a2096 2
	    data = (char *) line->data;
	    offset = (int) line->offset;
d2098 6
a2103 6
		   (cp = LYno_attr_mb_strstr(data,
					     target,
					     text->T.output_utf8, YES,
					     NULL,
					     &LenNeeded)) != NULL &&
		   ((int) line->offset + LenNeeded) < DISPLAY_COLS) {
d2106 1
a2106 1
		int x_pos = offset + (int) (cp - data);
d2114 1
a2114 1
		 * Start the emphasis.
d2119 1
a2119 1
		 * Output the target characters.
d2123 1
a2123 1
		     itmp++) {
d2126 1
a2126 1
			 * Ignore special characters.
d2133 1
a2133 1
			     * First printable character of target.
d2138 1
a2138 1
			 * Output all the printable target chars.
d2142 2
a2143 2
			    strncpy(&tmp[1], &line->data[itmp + 1], utf_extra);
			    tmp[utf_extra + 1] = '\0';
d2151 1
a2151 1
			     * For CJK strings, by Masanobu Kimura.
d2165 3
a2167 3
		 * Stop the emphasis, and reset the offset and
		 * data pointer for our current position in the
		 * line.  -FM
d2171 1
a2171 1
		data = (char *) &data[itmp];
d2174 3
a2176 3
		 * Adjust the cursor position, should we be at
		 * the end of the line, or not have another hit
		 * in it.  -FM
d2179 1
a2179 1
	    }			/* end while */
d2184 2
a2185 2
	     * Stop if this is the last line.  Otherwise, make sure
	     * display_flag is set and process the next line.  -FM
d2189 1
a2189 1
		 * Clear remaining lines of display.
d2200 2
a2201 2
		 * Remember as fully shown during last partial display,
		 * if it was not the last text line.  - kw
d2208 3
a2210 3
	}			/* end of "Verify and display each line." loop */
    }
    /* end "Output the page." */
d2215 1
a2215 1
     * Add the anchors to Lynx structures.
d2223 1
a2223 1
	    && Anchor_ptr->line_num < stop_before_for_anchors) {
d2227 1
a2227 1
	     * Load normal hypertext anchors.
d2230 2
a2231 2
		&& non_empty(hi_string)
		&& (Anchor_ptr->link_type & HYPERTEXT_ANCHOR)) {
d2235 1
a2235 1
		for (count = 0;; ++count) {
d2253 2
a2254 2
		     * Memory leak fixed 05-27-94
		     * Garrett Arch Blythe
a2256 1

d2263 1
a2263 1
									 Anchor_ptr->anchor, HTInternalLink);
d2267 2
a2268 2
					"GridText: display_page: unexpected typed link to %s!\n",
					link_dest_intl->parent->address));
a2274 1

d2301 1
a2301 1
		       && Anchor_ptr->input_field->type != F_HIDDEN_TYPE) {
d2303 1
a2303 1
		 * Handle form fields.
d2333 1
a2333 1
		} else {	/* TEXT type */
d2340 1
a2340 1
		 * Bold the link after incrementing nlinks.
d2348 1
a2348 1
		 * Not showing anchor.
d2359 2
a2360 2
	     * Links array is full.  If interactive, tell user
	     * to use half-page or two-line scrolling.  -FM
d2368 1
a2368 1
    }				/* end of loop "Add the anchors to Lynx structures." */
d2371 2
a2372 2
     * Free any un-reallocated links[] entries
     * from the previous page draw.  -FM
d2381 3
a2383 3
     * If Anchor_ptr is not NULL and is not pointing to the last
     * anchor, then there are anchors farther down in the document,
     * and we need to flag this for traversals.
d2393 1
a2393 1
	 * Nothing on the page.
d2415 2
a2416 2
	 * For other than ncurses, repainting is taken care of
	 * by touching lines in display_line and highlight.  - kw 1999-10-07
d2422 1
a2422 1
	 * For non-multibyte curses.
d2424 3
a2426 3
	 * Full repainting is necessary, otherwise only part of a multibyte
	 * character sequence might be written because of curses output
	 * optimizations.
d2435 1
d2437 6
a2442 5
 *			-----------------------
 *
 *	These are used by a parser to build the text in an object
 */
void HText_beginAppend(HText *text)
d2449 1
d2471 16
a2486 16
 *	----------------------
 *
 * On entry,
 *
 *	split	is zero for newline function, else number of characters
 *		before split.
 *	text->display_on_the_fly
 *		may be set to indicate direct output of the finished line.
 * On exit,
 *		A new line has been made, justified according to the
 *		current style.  Text after the split (if split nonzero)
 *		is taken over onto the next line.
 *
 *		If display_on_the_fly is set, then it is decremented and
 *		the finished line is displayed.
 */
d2494 1
a2494 1
#define CTRACE_SPLITLINE(p)	/*nothing */
d2497 5
a2501 4
static int set_style_by_embedded_chars(char *s,
				       char *e,
				       unsigned char start_c,
				       unsigned char end_c)
d2516 8
a2523 6
static void move_anchors_in_region(HTLine *line, int line_number,
				   TextAnchor **prev_anchor,	/*updates++ */
				   int *prev_head_processed,
				   int sbyte,
				   int ebyte,
				   int shift)	/* Likewise */
d2552 2
a2553 2
	    last -= line->prev->size + 1;	/* Fake "\n" "between" lines counted too */
	if (last < sbyte)	/* Completely before the start */
d2556 3
a2558 3
	if (!head_processed	/* a->line_pos is not edited yet */
	    && a->line_num == line_number
	    && a->line_pos >= ebyte)	/* Completely after the end */
d2563 2
a2564 2
	if (!head_processed && a->line_num == line_number
	    && a->line_pos >= sbyte) {
d2570 1
a2570 1
	if (last < ebyte)
d2573 1
a2573 1
	    break;		/* Keep this `a' for the next step */
d2580 9
a2588 9
 * Given a line and two int arrays of old/now position, this function
 * creates a new line where spaces have been inserted/removed
 * in appropriate places - so that characters at/after the old
 * position end up at/after the new position, for each pair, if possible.
 * Some necessary changes for anchors starting on this line are also done
 * here if needed.  Updates 'prev_anchor' internally.
 * Returns a newly allocated HTLine* if changes were made
 * (caller has to free the old one).
 * Returns NULL if no changes needed.  (Remove-spaces code may be buggy...)
d2591 8
a2598 6
static HTLine *insert_blanks_in_line(HTLine *line, int line_number,
				     HText *text,
				     TextAnchor **prev_anchor,	/*updates++ */
				     int ninserts,
				     int *oldpos,	/* Measured in cells */
				     int *newpos)	/* Likewise */
d2600 2
a2601 3
    int ioldc = 0;		/* count visible characters */
    int ip;			/* count insertion pairs */

d2608 1
a2608 1
    HTLine *mod_line;
d2624 1
a2624 1
	    mod_line = TEMP_LINE(text, 1);
d2626 1
a2626 1
	    mod_line = TEMP_LINE(text, 0);
d2642 4
a2645 5
	/* Include'em all! */
		      : ((int) line->size <= MAX_LINE
			 ? MAX_LINE + 1
			 : (int) line->size + 1));

d2651 2
a2652 2
	    if (text && text->T.output_utf8
		&& UCH(*s) >= 0x80 && UCH(*s) < 0xC0) {
d2654 1
a2654 1
	    } else if (!IsSpecialAttrChar(*s)) {	/* At a "displayed" char */
d2664 2
a2665 2
	if (ip)			/* Fix anchor positions */
	    move_anchors_in_region(line, line_number, prev_anchor /*updates++ */ ,
d2671 1
a2671 3
	for (;
	     istyle < line->numstyles && (int) NStyle.horizpos < curlim;
	     istyle++)
d2690 1
a2690 1
    while (pre < s)		/* Copy remaining style-codes */
d2701 10
a2710 9
static HTStyleChange *skip_matched_and_correct_offsets(HTStyleChange *end,
						       HTStyleChange *start,
						       unsigned split_pos)
{				/* Found an OFF change not part of an adjacent matched pair.
				 * Walk backward looking for the corresponding ON change.
				 * Move everything after split_pos to be at split_pos.
				 * This can only work correctly if all changes are correctly
				 * nested!  If this fails, assume it is safer to leave whatever
				 * comes before the OFF on the previous line alone. */
d2731 3
a2733 1
static void split_line(HText *text, unsigned split)
d2735 1
a2735 1
    HTStyle *style = text->style;
d2738 1
a2738 1
    text->style->indent1st : text->style->leftIndent;
d2740 1
a2740 1
    TextAnchor *a;
d2749 1
a2749 1
    char *cp;
d2751 2
a2752 2
    HTLine *previous = text->last_line;
    HTLine *line;
d2755 1
a2755 1
     * Set new line.
d2765 2
a2766 2
    ctrl_chars_on_this_line = 0;	/*reset since we are going to a new line */
    utfxtra_on_this_line = 0;	/*reset too, we'll count them */
d2770 2
a2771 2
    CTRACE((tfp, "GridText: split_line(%p,%d) called\n", text, split));
    CTRACE((tfp, "   bold_on=%d, underline_on=%d\n", bold_on, underline_on));
d2777 1
a2777 1
	|| cp[0] == LY_UNDERLINE_START_CHAR) {
d2779 1
a2779 8
	case LY_SOFT_NEWLINE:
	    cp[1] = cp[0];
	    cp[0] = LY_SOFT_NEWLINE;
	    break;
	case LY_BOLD_START_CHAR:
	case LY_UNDERLINE_START_CHAR:
	    if (cp[2] == LY_SOFT_NEWLINE) {
		cp[2] = cp[1];
d2782 9
a2790 2
	    }
	    break;
d2795 2
a2796 2
		"*** split_line: split==%d greater than last_line->size==%d !\n",
		split, previous->size));
d2815 1
a2815 1
    text->permissible_split = 0;	/* 12/13/93 */
d2820 1
a2820 1
    if (split > 0) {		/* Restore flags to the value at the splitting point */
d2822 7
a2828 7
	    t_underline = set_style_by_embedded_chars(previous->data,
						      previous->data + split,
						      LY_UNDERLINE_START_CHAR, LY_UNDERLINE_END_CHAR);

	t_bold = set_style_by_embedded_chars(previous->data,
					     previous->data + split,
					     LY_BOLD_START_CHAR, LY_BOLD_END_CHAR);
d2846 1
a2846 1
     * Split at required point
d2848 1
a2848 1
    if (split > 0) {		/* Delete space at "split" splitting line */
d2858 2
a2859 2
	 * Trim any spaces or soft hyphens from the beginning
	 * of our new line.  -FM
d2862 2
a2863 1
	while (((*p == ' '
d2865 4
a2868 4
	/* if justification is allowed for prev line, then raw
	 * HT_NON_BREAK_SPACE are still present in data[] (they'll be
	 * substituted at the end of this function with ' ') - VH
	 */
d2877 1
a2877 1
	       *p == LY_SOFT_HYPHEN) {
d2883 1
a2883 1
	if (plen) {		/* Count funny characters */
d2894 1
a2894 1
		if (p[i] == LY_SOFT_HYPHEN && (int) text->permissible_split < i)
d2906 1
a2906 1
     * Economize on space.
d2912 4
a2915 4
    /* if justification is allowed for prev line, then raw
     * HT_NON_BREAK_SPACE are still present in data[] (they'll be
     * substituted at the end of this function with ' ') - VH
     */
d2918 1
a2918 1
	   )
d2920 3
a2922 3
	   && !psrc_view	/*don't strip trailing whites - since next line can
				   start with LY_SOFT_NEWLINE - so we don't lose spaces when
				   'p'rinting this text to file -VH */
d2929 1
a2929 1
	p--;			/*  Strip trailers. */
d2931 1
a2931 1
    TailTrim = previous->data + previous->size - 1 - p;		/*  Strip trailers. */
d2936 3
a2938 3
     * s is the effective split position, given by either a non-zero
     * value of split or by the size of the previous line before
     * trimming.  - kw
d2941 1
a2941 1
	s = previous->size + TailTrim;	/* the original size */
d2946 1
a2946 1
    s_pre = s - TailTrim;
d2950 1
a2950 1
    if (s != (int) split)
d2952 1
a2952 1
	CTRACE((tfp, "GridText: split_line(%d [now:%d]) called\n", split, s));
d2966 4
a2969 4
	/* Color style changes after the split position
	 * are transferred to the new line.  Ditto for changes
	 * in the trimming region, but we stop when we reach an OFF change.
	 * The second loop below may then handle remaining changes.  - kw */
d2973 1
a2973 1
		to->horizpos += -s_post + SpecialAttrChars;
d2995 1
a2995 1
	       Report a bug on failure.
d2997 2
a2998 2
	       and the corresponding OFF at to;
	       If not, put the corresponding OFF at at_end, and copy to to;
d3008 3
a3010 3
		if (at_end->direction == STACK_ON
		    && at_end->style == scan->style
		    && (int) at_end->horizpos >= s_pre)
d3021 4
a3024 4
		if (to < line->styles + MAX_STYLES_ON_LINE - 1
		    && to[1].direction == STACK_OFF
		    && to[1].horizpos <= (unsigned) SpecialAttrChars
		    && to[1].style == scan->style)
d3046 1
a3046 1
	    line->styles[0].horizpos = ~0;	/* ?!!! */
d3051 1
a3051 1
#endif /*USE_COLOR_STYLE */
d3054 5
a3058 6
	HTLine *temp;

	allocHTLine(temp, previous->size);
	if (!temp)
	    outofmem(__FILE__, "split_line_2");
	memcpy(temp, previous, LINE_SIZE(previous->size));
d3060 4
a3063 4
	POOLallocstyles(temp->styles, previous->numstyles);
	if (!temp->styles)
	    outofmem(__FILE__, "split_line_2");
	memcpy(temp->styles, previous->styles, sizeof(HTStyleChange) * previous->numstyles);
d3065 1
a3065 1
	previous = temp;
d3072 1
a3072 1
     * Terminate finished line for printing.
d3077 1
a3077 1
     * Align left, right or center.
d3082 1
a3082 1
	   this_line_was_split ||
d3084 2
a3085 2
	   (alignment == HT_CENTER ||
	    alignment == HT_RIGHT) || text->stbl) {
d3098 1
a3098 1
	    (int) (previous->data[previous->size - 1] == LY_SOFT_HYPHEN))
d3102 2
a3103 2
	spare = (WRAP_COLS(text) - 1) -
	    (int) style->rightIndent - indent +
d3112 13
a3124 14
		int spare_cu = (LYcols_cu(text) - 1) -
		utfxtra_on_previous_line - indent +
		ctrl_chars_on_previous_line - previous->size;

		/*
		 * Shift non-leftaligned UTF-8 lines that would be
		 * mishandled by the display library towards the left
		 * if this would make them fit.  The resulting display
		 * will not be as intended, but this is better than
		 * having them split by curses.  (Curses cursor movement
		 * optimization may still cause wrong positioning within
		 * the line, in particular after a sequence of spaces).
		 * - kw
		 */
d3128 2
a3129 2
			    (int) (previous->offset + indent + spare / 2 +
				   previous->size)
d3132 1
a3132 1
			    /* do nothing - it still fits - kw */ ;
d3137 3
a3139 3
				 * Can't move towars center all the way,
				 * but at least make line contents appear
				 * as far right as possible.  - kw
d3144 3
a3146 2
		    } else if (indent + (int) previous->offset + spare_cu >= 0) {	/* subtract overdraft from effective indentation */
			indent += (int) previous->offset + spare_cu;
d3156 12
a3167 12
    case HT_CENTER:
	previous->offset = previous->offset + indent + spare / 2;
	break;
    case HT_RIGHT:
	previous->offset = previous->offset + indent + spare;
	break;
    case HT_LEFT:
    case HT_JUSTIFY:		/* Not implemented */
    default:
	previous->offset = previous->offset + indent;
	break;
    }				/* switch */
d3171 9
a3179 9
	 * Notify simple table stuff of line split, so that it can
	 * set the last cell's length.  The last cell should and
	 * its row should really end here, or on one of the following
	 * lines with no more characters added after the break.
	 * We don't know whether a cell has been started, so ignore
	 * errors here.
	 * This call is down here because we need the
	 * ctrl_chars_on_previous_line, which have just been re-
	 * counted above.  - kw
d3186 1
a3186 1
    text->in_line_1 = NO;	/* unless caller sets it otherwise */
d3189 2
a3190 2
     * If we split the line, adjust the anchor
     * structure values for the new line.  -FM
d3193 1
a3193 1
    if (s > 0) {		/* if not completely empty */
d3208 1
a3208 1
	for (; a; a = a->next) {
d3217 2
a3218 2
		   "Just because": those before s;
		   this is the only case when we use s, not s_pre/s_post);
d3236 1
a3236 2
		    CTRACE_SPLITLINE((tfp,
				      "anchor %d: no relocation, empty-finished",
d3238 1
a3238 1
		    a->line_pos = s_pre;	/* Leave at the end of line */
d3245 3
a3247 4
		CTRACE_SPLITLINE((tfp,
				  "anchor %d: (T,H,S)=(%d,%d,%d); (line,pos,ext):(%d,%d,%d), ",
				  n, TailTrim, HeadTrim, SpecialAttrChars,
				  a->line_num, a->line_pos, a->extent));
d3261 1
a3261 1
				  a->line_num, a->line_pos, a->extent));
d3266 1
d3271 12
a3282 12
	&& spare
	&& !text->stbl		/* We don't inform TRST on the cell width change yet */
	&& justify_max_void_percent > 0
	&& justify_max_void_percent <= 100
	&& justify_max_void_percent >= ((100 * spare)
					/ ((WRAP_COLS(text) - 1)
					   - (int) style->rightIndent
					   - indent
					   + ctrl_chars_on_previous_line))) {
	/* this is the only case when we need justification */
	char *jp = previous->data + justify_start_position;
	ht_run_info *r = ht_runs;
d3286 1
a3286 1
	HTLine *jline;
d3291 1
a3291 1
	for (; (c = *jp) != 0; ++jp) {
d3301 1
a3301 1
	    if (IsSpecialAttrChar(c))
a3310 1

d3320 1
a3320 1
	    int *oldpos = (int *) malloc(sizeof(int) * 2 * (ht_num_runs - 1));
d3327 2
a3328 2
	    d_ = spare / (ht_num_runs - 1);
	    r_ = spare % (ht_num_runs - 1);
d3332 1
a3332 1
	    newpos[0] = oldpos[0] + (d_ + (r_-- > 0));
d3336 2
a3337 2
		oldpos[i] = oldpos[i - 1] + delta;
		newpos[i] = newpos[i - 1] + delta + (d_ + (r_-- > 0));
d3341 1
a3341 1
					  &last_anchor_of_previous_line /*updates++ */ ,
d3343 1
a3343 1
	    free((char *) oldpos);
d3352 2
a3353 1
	} {			/* (ht_num_runs==1) */
d3355 2
a3356 3
		char *p2 = previous->data;

		for (; p2 < previous->data + justify_start_position; ++p2)
d3361 2
a3362 2
	if (REALLY_CAN_JUSTIFY(text)) {
	    char *p2;
d3369 1
a3369 2
		CTRACE((tfp,
			"BUG: justification: shouldn't happen - new line is not empty!\n"));
d3372 1
a3372 1
	    for (p2 = previous->data; *p2; ++p2)
d3377 1
a3377 1
	       table cells */
d3380 1
a3380 1
	    for (i = 0; i < previous->size; ++i)
d3385 1
a3385 1
	    for (i = 0; i < line->size; ++i)
d3393 1
a3393 1
    /* cleanup */
d3400 2
a3401 1
}				/* split_line */
d3404 5
a3408 3
 *	--------------------------
 */
static void blank_lines(HText *text, int newlines)
d3410 2
a3411 2
    if (HText_LastLineEmpty(text, FALSE)) {	/* No text on current line */
	HTLine *line = text->last_line->prev;
d3416 1
a3416 1
	    return;		/* Do not add a blank line at start */
d3428 1
a3428 1
	newlines++;		/* Need also to finish this line */
d3437 1
d3439 5
a3443 4
 *	------------------------------
 * See also: setStyle.
 */
void HText_appendParagraph(HText *text)
a3446 1

d3450 1
d3452 7
a3458 5
 *	---------
 *
 *	Does not filter unnecessary style changes.
 */
void HText_setStyle(HText *text, HTStyle *style)
d3463 1
a3463 1
	return;			/* Safety */
d3469 1
a3469 1
    blank_lines(text, ((after > before) ? after : before));
d3475 5
a3479 3
 *	-------------------------------------
 */
void HText_appendCharacter(HText *text, int ch)
d3481 2
a3482 2
    HTLine *line;
    HTStyle *style;
d3493 2
a3494 3
	char *special = NULL;	/* make trace a little more readable */

	switch (ch) {
d3496 2
a3497 2
	    special = "HT_NON_BREAK_SPACE";
	    break;
d3499 2
a3500 2
	    special = "HT_EN_SPACE";
	    break;
d3502 2
a3503 2
	    special = "LY_UNDERLINE_START_CHAR";
	    break;
d3505 2
a3506 2
	    special = "LY_UNDERLINE_END_CHAR";
	    break;
d3508 2
a3509 2
	    special = "LY_BOLD_START_CHAR";
	    break;
d3511 2
a3512 2
	    special = "LY_BOLD_END_CHAR";
	    break;
d3514 2
a3515 2
	    special = "LY_SOFT_HYPHEN";
	    break;
d3517 2
a3518 2
	    special = "LY_SOFT_NEWLINE";
	    break;
d3520 2
a3521 2
	    special = NULL;
	    break;
d3526 1
a3526 1
		    HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
d3528 1
a3528 1
#ifdef CJK_EX			/* 1998/08/30 (Sun) 13:26:23 */
d3534 1
a3534 1
			    HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
d3549 1
a3549 1
#endif /* CJK_EX */
d3551 1
a3551 1
    }				/* trace only */
d3555 1
a3555 1
     * Make sure we don't crash on NULLs.
d3562 2
a3563 2
	 * We should stop outputting more text, because low memory was
	 * detected.  - kw
d3567 4
a3570 4
	     * But if we haven't done so yet, first append a warning.
	     * We should still have a few bytes left for that :).
	     * We temporarily reset test->halted to 0 for this, since
	     * this function will get called recursively.  - kw
d3593 2
a3594 1
	    } else if ((c & 0x80) && !IS_SJIS_X0201KANA(c)) {
d3605 2
a3606 1
	    } else {
d3621 2
a3622 1
	    } else if (c == 0x8e) {
d3624 2
a3625 1
	    } else if (c & 0x80) {
d3636 2
a3637 1
	    } else {
d3646 1
a3646 1
	    if ((0xA1 <= c) && (c <= 0xDF)) {
d3648 2
a3649 1
	    } else {
d3661 1
a3661 2
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode seems SJIS.\n"));
d3664 1
a3664 2
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode seems EUC.\n"));
d3667 1
a3667 2
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode seems mixed!\n"));
d3670 1
a3670 2
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode is unexpected!\n"));
d3677 1
a3677 1
     * Make sure we don't hang on escape sequences.
d3679 1
a3679 1
    if (ch == CH_ESC && HTCJK == NOCJK) {	/* decimal 27  S/390 -- gil -- 1504 */
d3684 6
a3689 6
     * Block 8-bit chars not allowed by the current display character
     * set if they are below what LYlowest_eightbit indicates.
     * Slang used its own replacements, so for USE_SLANG blocking here
     * is not necessary to protect terminals from those characters.
     * They should have been filtered out or translated by an earlier
     * processing stage anyway.  - kw
d3691 1
a3691 1
#ifndef   EBCDIC		/* S/390 -- gil -- 1514 */
d3710 1
a3710 1
    indent = text->in_line_1 ? (int) style->indent1st : (int) style->leftIndent;
d3713 14
a3726 3
	switch (text->state) {
	case S_text:
	    if (ch == CH_ESC) {	/* S/390 -- gil -- 1536 */
d3728 1
a3728 2
		 * Setting up for CJK escape sequence handling (based on
		 * Takuya ASADA's (asada@@three-a.co.jp) CJK Lynx).  -FM
d3730 27
a3756 5
		text->state = S_esc;
		text->kanji_buf = '\0';
		return;
	    }
	    break;
d3758 11
a3768 14
	case S_esc:
	    /*
	     * Expecting '$'or '(' following CJK ESC.
	     */
	    if (ch == '$') {
		text->state = S_dollar;
		return;
	    } else if (ch == '(') {
		text->state = S_paren;
		return;
	    } else {
		text->state = S_text;
	    }
	    /* FALLTHRU */
d3770 17
a3786 7
	case S_dollar:
	    /*
	     * Expecting '@@', 'B', 'A' or '(' after CJK "ESC$".
	     */
	    if (ch == '@@' || ch == 'B' || ch == 'A') {
		text->state = S_nonascii_text;
		if (ch == '@@' || ch == 'B')
d3788 5
a3792 8
		return;
	    } else if (ch == '(') {
		text->state = S_dollar_paren;
		return;
	    } else {
		text->state = S_text;
	    }
	    break;
d3794 1
a3794 17
	case S_dollar_paren:
	    /*
	     * Expecting 'C' after CJK "ESC$(".
	     */
	    if (ch == 'C') {
		text->state = S_nonascii_text;
		return;
	    } else {
		text->state = S_text;
	    }
	    break;

	case S_paren:
	    /*
	     * Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(".
	     */
	    if (ch == 'B' || ch == 'J' || ch == 'T') {
d3796 1
a3796 1
		 * Can split here.  -FM
d3798 18
a3815 5
		text->permissible_split = text->last_line->size;
		text->state = S_text;
		return;
	    } else if (ch == 'I') {
		text->state = S_jisx0201_text;
d3817 1
a3817 1
		 * Can split here.  -FM
d3819 4
a3822 16
		text->permissible_split = text->last_line->size;
		text->kcode = JIS;
		return;
	    } else {
		text->state = S_text;
	    }
	    break;

	case S_nonascii_text:
	    /*
	     * Expecting CJK ESC after non-ASCII text.
	     */
	    if (ch == CH_ESC) {	/* S/390 -- gil -- 1553 */
		text->state = S_esc;
		text->kanji_buf = '\0';
		if (HTCJK == JAPANESE) {
d3824 4
d3829 2
a3830 27
		return;
	    } else if (UCH(ch) < 32) {
		text->state = S_text;
		text->kanji_buf = '\0';
		if (HTCJK == JAPANESE) {
		    text->kcode = NOKANJI;
		}
	    } else {
		ch |= 0200;
	    }
	    break;

	    /*
	     * JIS X0201 Kana in JIS support.  - by ASATAKU
	     */
	case S_jisx0201_text:
	    if (ch == CH_ESC) {	/* S/390 -- gil -- 1570 */
		text->state = S_esc;
		text->kanji_buf = '\0';
		text->kcode = NOKANJI;
		return;
	    } else {
		text->kanji_buf = '\216';
		ch |= 0200;
	    }
	    break;
	}			/* end switch */
d3835 1
a3835 1
		 * JIS X0201 Kana in SJIS support.  - by ASATAKU
d3838 1
a3838 1
		    && (
d3840 2
a3841 2
			   (last_kcode == SJIS) ||
			   ((last_kcode == NOKANJI) &&
d3843 1
a3843 1
			    ((text->kcode == SJIS) ||
d3845 2
a3846 2
			     ((text->detected_kcode == DET_SJIS) &&
			      (text->specified_kcode == NOKANJI)) ||
d3848 2
a3849 2
			     ((text->kcode == NOKANJI) &&
			      (text->specified_kcode == SJIS)))
d3851 1
a3851 1
			   )
a3858 1

d3860 3
a3862 3
					(unsigned char *) &kb,
					(unsigned char *) &c);
		    ch = (char) c;
d3866 1
a3866 1
		    text->permissible_split = (int) text->last_line->size;
d3870 1
a3870 1
		     * Can split here.  -FM
d3879 1
a3879 1
    } else if (ch == CH_ESC) {	/* S/390 -- gil -- 1587 */
d3882 2
a3883 1
#ifdef CJK_EX			/* MOJI-BAKE Fix! 1997/10/12 -- 10/31 (Fri) 00:22:57 - JH7AYN */
d3886 1
a3886 1
	text->permissible_split = (int) line->size;	/* Can split here */
d3894 1
a3894 1
	if (line->size >= (MAX_LINE - 1)) {
d3898 1
a3898 1
	if (with_backspaces && HTCJK == NOCJK && !text->T.output_utf8) {
d3900 5
a3904 18
	    if (ch == LY_UNDERLINE_START_CHAR) {
		line->data[line->size++] = LY_UNDERLINE_START_CHAR;
		line->data[line->size] = '\0';
		underline_on = ON;
		if (!(dump_output_immediately && use_underscore))
		    ctrl_chars_on_this_line++;
		return;
	    } else if (ch == LY_UNDERLINE_END_CHAR) {
		line->data[line->size++] = LY_UNDERLINE_END_CHAR;
		line->data[line->size] = '\0';
		underline_on = OFF;
		if (!(dump_output_immediately && use_underscore))
		    ctrl_chars_on_this_line++;
		return;
	    } else if (ch == LY_BOLD_START_CHAR) {
		line->data[line->size++] = LY_BOLD_START_CHAR;
		line->data[line->size] = '\0';
		bold_on = ON;
d3906 6
a3911 5
		return;
	    } else if (ch == LY_BOLD_END_CHAR) {
		line->data[line->size++] = LY_BOLD_END_CHAR;
		line->data[line->size] = '\0';
		bold_on = OFF;
d3913 22
d3936 1
a3936 2
	    } else if (ch == LY_SOFT_HYPHEN) {
		int i;
d3938 7
a3944 20
		/*
		 * Ignore the soft hyphen if it is the first character
		 * on the line, or if it is preceded by a space or
		 * hyphen.  -FM
		 */
		if (line->size < 1 || text->permissible_split >= line->size) {
		    return;
		}

		for (i = (text->permissible_split + 1); line->data[i]; i++) {
		    if (!IsSpecialAttrChar(UCH(line->data[i])) &&
			!isspace(UCH(line->data[i])) &&
			UCH(line->data[i]) != '-' &&
			UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
			UCH(line->data[i]) != HT_EN_SPACE) {
			break;
		    }
		}
		if (line->data[i] == '\0') {
		    return;
d3947 4
d3952 2
a3953 2
	} else {
	    /* if (with_backspaces && HTCJK==HTNOCJK && !text->T.output_utf8) */
d3955 1
a3955 1
	}
d3969 3
a3971 3
	 * Some extra checks for UTF-8 output here to make sure
	 * memory is not overrun.  For a non-first char, append
	 * to the line here and return.  - kw
d3974 2
a3975 2
	    if ((line->size > (MAX_LINE - 1))
		|| (indent + (int) (line->offset + line->size)
d3979 3
a3981 3
		       (int) (line->data[line->size - 1] ==
			      LY_SOFT_HYPHEN ?
			      1 : 0)) >= (LYcols_cu(text) - 1))
d3986 1
a3986 1
			   IS_UTF_EXTRA(line->data[text->permissible_split - 1]))
d3989 1
a3989 1
			(line->data[text->permissible_split - 1] & 0x80))
d3998 1
a3998 1
		    HText_appendCharacter(text, LY_SOFT_NEWLINE);
d4006 1
a4006 1
	    if ((line->size > (MAX_LINE - 7))) {
d4010 1
a4010 1
			   (line->data[text->permissible_split - 1] & 0x80)
d4021 1
a4021 1
		    HText_appendCharacter(text, LY_SOFT_NEWLINE);
d4027 1
a4027 1
     * New Line.
d4033 2
a4034 2
	 * There are some pages written in
	 * different kanji codes.  - TA & kw
d4042 1
a4042 1
     * Convert EN_SPACE to a space here so that it doesn't get collapsed.
d4047 2
a4048 2
#ifdef SH_EX			/* 1997/11/01 (Sat) 12:08:54 */
    if (ch == 0x0b) {		/* ^K ??? */
d4051 1
a4051 1
    if (ch == 0x1a) {		/* ^Z ??? */
d4057 4
a4060 4
     * I'm going to cheat here in a BIG way.  Since I know that all
     * \r's will be trapped by HTML_put_character I'm going to use
     * \r to mean go down a line but don't start a new paragraph.
     * i.e., use the second line indenting.
d4066 2
a4067 2
	 * There are some pages written in
	 * different kanji codes.  - TA & kw
d4075 1
a4075 1
     * Tabs.
d4078 1
a4078 1
	const HTTabStop *Tab;
d4082 1
a4082 1
	if (line->size > 0 && line->data[line->size - 1] == LY_SOFT_HYPHEN) {
d4084 2
a4085 2
	     * A tab shouldn't follow a soft hyphen, so
	     * if one does, we'll dump the soft hyphen.  -FM
d4090 2
a4091 2
	here = ((int) (line->size + line->offset) + indent)
	    - ctrl_chars_on_this_line;	/* Consider special chars GAB */
d4095 2
a4096 2
		 Tab->position <= here;
		 Tab++) {
d4104 2
a4105 2
	    if (here >= (int) style->leftIndent) {
		new_line(text);	/* wrap */
d4108 1
a4108 1
		target = (int) style->leftIndent;
d4112 2
a4113 2
	    target = (((int) line->offset + (int) line->size + 8) & (-8))
		+ (int) style->leftIndent;
d4125 1
a4125 1
	if (target > (WRAP_COLS(text) - 1) - (int) style->rightIndent &&
d4130 1
a4130 1
	     * Can split here.  -FM
d4133 2
a4134 2
	    if (target_cu > (WRAP_COLS(text) - 1))
		target -= target_cu - (WRAP_COLS(text) - 1);
d4138 1
a4138 1
		for (; here < target; here++) {
d4146 4
a4149 4
    }
    /* if tab */
  check_WrapSource:
    if ((text->source || dont_wrap_pre) && text == HTMainText) {
d4154 1
a4154 1
	int target = (int) (line->offset + line->size) - ctrl_chars_on_this_line;
d4156 1
a4156 2

	if (target >= (WRAP_COLS(text) - 1) - style->rightIndent -
d4159 1
a4159 1
	     target_cu + UTF_XLEN(ch) >= (LYcols_cu(text) - 1))) {
d4170 1
a4170 1
	    HText_appendCharacter(text, LY_SOFT_NEWLINE);
d4178 1
a4178 1
	 * Can split here.  -FM
d4182 2
a4183 2
	 * There are some pages written in
	 * different kanji codes.  - TA
d4190 1
a4190 1
     * Check if we should ignore characters at the wrap point.
d4193 1
a4193 1
	int nominal = (indent + (int) (line->offset + line->size) - ctrl_chars_on_this_line);
d4198 3
a4200 3
	    && !number_fields_on_left
	    && text->last_anchor != 0
	    && (number = text->last_anchor->number) > 0) {
d4202 10
a4211 10
		      ? 6
		      : (number > 9999
			 ? 5
			 : (number > 999
			    ? 4
			    : (number > 99
			       ? 3
			       : (number > 9
				  ? 2
				  : 1))))) + 2;
d4213 2
a4214 2
	if ((nominal + (int) style->rightIndent) >= limit
	    || (nominal + UTFXTRA_ON_THIS_LINE) >= (LYcols_cu(text) - 1)) {
d4220 1
a4220 1
     * Check for end of line.
d4222 1
a4222 1
    actual = ((indent + (int) line->offset + (int) line->size) +
d4224 1
a4224 1
	       (int) (line->data[line->size - 1] == LY_SOFT_HYPHEN ? 1 : 0)));
d4231 2
a4232 2
	    (int) style->rightIndent - ctrl_chars_on_this_line +
	    (((HTCJK != NOCJK) && text->kanji_buf) ? 1 : 0);
d4245 1
a4245 1
		return;		/* Ignore space causing split */
d4250 5
a4254 5
	     * For source output we don't want to wrap this stuff
	     * unless absolutely necessary.  - LJM
	     * !
	     * If we don't wrap here we might get a segmentation fault.
	     * but let's see what happens
d4256 2
a4257 2
	    if ((int) line->size >= (int) (MAX_LINE - 1)) {
		new_line(text);	/* try not to linewrap */
d4261 2
a4262 2
	     * For normal stuff like pre let's go ahead and
	     * wrap so the user can see all of the text.
d4264 3
a4266 3
	    if ((dump_output_immediately || (crawl && traversal))
		&& dont_wrap_pre) {
		if ((int) line->size >= (int) (MAX_LINE - 1)) {
d4273 1
a4273 1
    } else if ((int) line->size >= (int) (MAX_LINE - 1)) {
d4275 1
a4275 1
	 * Never overrun memory if DISPLAY_COLS is set to a large value - KW
d4281 1
a4281 1
     * Insert normal characters.
d4285 1
a4285 1
	&& !REALLY_CAN_JUSTIFY(text)
d4287 1
a4287 1
	)
d4306 1
a4306 1
	line = text->last_line;	/* May have changed */
d4321 2
a4322 2
			    if (text->specified_kcode != NOKANJI)
				text->kcode = text->specified_kcode;
d4324 9
a4332 9
			    else if (text->detected_kcode == DET_EUC)
				text->kcode = EUC;
			    else if (text->detected_kcode == DET_SJIS)
				text->kcode = SJIS;
#endif
			    else if (IS_EUC_X0201KANA(hi, lo) &&
				     (text->kcode != EUC))
				text->kcode = SJIS;
			} else
d4334 2
a4335 1
		    } else if (IS_EUC(hi, lo))
d4354 1
a4354 3
			CTRACE((tfp,
				"This character (%X:%X) doesn't seem Japanese\n",
				hi, lo));
d4361 2
a4362 1
		    if ((text->kcode == EUC) || (text->kcode == JIS)) {
d4379 1
a4379 3
			CTRACE((tfp,
				"This character (%X:%X) doesn't seem Japanese\n",
				hi, lo));
d4400 5
a4404 4
	    line->data[line->size++] = (char) ((kanji_code != NOKANJI) ?
					       ch :
					       (font & HT_CAPITALS) ?
					       TOUPPER(ch) : ch);
d4410 1
a4410 1
	if (font & HT_DOUBLE)	/* Do again if doubled */
d4412 1
a4412 1
	/* NOT a permissible split */
d4417 1
a4417 1
	     * Can split here.  -FM
d4430 3
a4432 3
 *  -------------------------------------------
 */
void _internal_HTC(HText *text, int style, int dir)
d4434 1
a4434 1
    HTLine *line;
d4442 4
a4445 4
	    line->styles[line->numstyles - 1].direction &&
	    line->styles[line->numstyles - 1].style == (unsigned) style &&
	    (int) line->styles[line->numstyles - 1].horizpos
	    == (int) line->size - ctrl_chars_on_this_line) {
d4447 2
a4448 2
	     * If this is an OFF change directly preceded by an
	     * ON for the same style, just remove the previous one.  - kw
d4452 1
a4452 1
	    line->styles[line->numstyles].horizpos = line->size;
d4454 4
a4457 4
	     * Special chars for bold and underlining usually don't
	     * occur with color style, but soft hyphen can.
	     * And in UTF-8 display mode all non-initial bytes are
	     * counted as ctrl_chars.  - kw
d4461 1
a4461 1
	    line->styles[line->numstyles].style = style;
d4469 2
d4472 5
a4476 3
 *	----------------------------------------
 */
void HText_setLastChar(HText *text, char ch)
d4485 4
a4488 3
 *	----------------------------------------
 */
char HText_getLastChar(HText *text)
d4491 1
a4491 1
	return ('\0');
d4493 1
a4493 1
    return ((char) text->LastChar);
d4497 5
a4501 3
 *	--------------------------------------------
 */
void HText_setIgnoreExcess(HText *text, BOOL ignore)
d4510 2
a4511 2
 *		-------------------------------
 */
d4514 10
a4523 8
 * HText_insertBlanksInStblLines fixes up table lines when simple table
 * processing is closed, by calling insert_blanks_in_line for lines
 * that need fixup.  Also recalculates alignment for those lines,
 * does additional updating of anchor positions, and makes sure the
 * display of the lines on screen will be updated after partial display
 * upon return to mainloop.  - kw
 */
static int HText_insertBlanksInStblLines(HText *me, int ncols)
d4527 4
a4530 5
    int *oldpos;
    int *newpos;
    int ninserts, lineno;
    int first_lineno, last_lineno, first_lineno_pass2;

d4532 1
a4532 1
    int last_nonempty = -1;
d4534 1
a4534 1
    int added_chars_before = 0;
d4545 1
a4545 1
     * oldpos, newpos:  allocate space for two int arrays.
a4567 1

d4578 2
a4579 2
	     * Last ditch effort to end the table with a line break,
	     * if HTML_end_element didn't do it.  - kw
d4581 1
a4581 1
	    if (first_line == line)	/* obscure: all table on last line... */
a4590 1

d4600 1
a4600 1
		    lineno, width, max_width));
d4604 1
a4604 1
					 &me->last_anchor_before_stbl /*updates++ */ ,
d4621 2
a4622 2
	     * Make sure modified lines get fully re-displayed after
	     * loading with partial display is done.
d4633 2
a4634 1
	} {
a4635 1

a4645 1

d4647 1
a4647 1
			lineno, width, max_width));
d4655 7
a4661 7
     * Line offsets have been set based on the paragraph style, and
     * have already been updated for centering or right-alignment
     * for each line in split_line.  Here we want to undo all that, and
     * align the table as a whole (i.e.  all lines for which
     * Stbl_getFixupPositions returned >= 0).  All those lines have to
     * get the same offset, for the simple table formatting mechanism
     * to make sense, and that may not actually be the case at this point.
d4663 5
a4667 5
     * What indentation and alignment do we want for the table as
     * a whole?  Let's take most style properties from me->style.
     * With some luck, it is the appropriate style for the element
     * enclosing the TABLE.  But let's take alignment from the attribute
     * of the TABLE itself instead, if it was specified.
d4669 3
a4671 3
     * Note that this logic assumes that all lines have been finished
     * by split_line.  The order of calls made by HTML_end_element for
     * HTML_TABLE should take care of this.
d4679 3
a4681 3
    spare = (WRAP_COLS(me) - 1) -
	(int) style->rightIndent - indent - max_width;
    if (spare < 0 && (int) style->rightIndent + spare >= 0) {
d4683 2
a4684 2
	 * Not enough room!  But we can fit if we ignore right indentation,
	 * so let's do that.
d4688 1
a4688 1
	spare += style->rightIndent;	/* ignore right indent, but need more */
d4692 1
a4692 1
	 * Still not enough room.  But we can move to the left.
d4698 2
a4699 2
	 * Still not enough.  Something went wrong.  Try the best we
	 * can do.
d4701 2
a4702 3
	CTRACE((tfp,
		"BUG: insertBlanks: resulting table too wide by %d positions!\n",
		-spare));
d4706 1
a4706 1
     * Align left, right or center.
d4709 12
a4720 12
    case HT_CENTER:
	table_offset = indent + spare / 2;
	break;
    case HT_RIGHT:
	table_offset = indent + spare;
	break;
    case HT_LEFT:
    case HT_JUSTIFY:
    default:
	table_offset = indent;
	break;
    }				/* switch */
d4755 2
a4756 2
 *		----------------------------------------
 */
d4760 2
a4761 1
void HText_cancelStbl(HText *me)
a4770 1

a4772 1

d4778 1
a4778 1
	Stbl_free(me->stbl);
d4784 3
a4786 1
void HText_startStblTABLE(HText *me, short alignment)
d4821 2
a4822 1
static void free_enclosed_stbl(HText *me)
d4827 1
a4827 2

	while (NULL != (stbl = (STable_info *) HTList_nextObject(list))) {
a4834 1

d4836 1
a4836 1
#define free_enclosed_stbl(me)	/* nothing */
d4842 2
a4843 1
int HText_endStblTABLE(HText *me)
d4865 2
a4866 2
	NumOfLines_partial -= lines_changed;	/* fake */
#endif /* DISP_PARTIAL */
d4868 1
d4900 3
a4902 1
void HText_startStblTR(HText *me, short alignment)
d4912 2
a4913 1
void HText_endStblTR(HText *me)
d4922 6
a4927 4
void HText_startStblTD(HText *me, int colspan,
		       int rowspan,
		       short alignment,
		       BOOL isheader)
d4942 1
a4942 3
			    me->Lines,
			    HText_LastLineOffset(me),
			    HText_LastLineSize(me, FALSE)) < 0)
d4948 2
a4949 1
void HText_endStblTD(HText *me)
d4954 1
a4954 3
			       me->Lines,
			       HText_LastLineOffset(me),
			       HText_LastLineSize(me, FALSE)) < 0)
d4960 5
a4964 3
void HText_startStblCOL(HText *me, int span,
			short alignment,
			BOOL isgroup)
d4980 2
a4981 1
void HText_endStblCOLGROUP(HText *me)
d4991 3
a4993 1
void HText_startStblRowGroup(HText *me, short alignment)
d5002 6
a5007 3
 *		---------------
 */
static void add_link_number(HText *text, TextAnchor *a, BOOL save_position)
d5012 1
a5012 1
     * If we are doing link_numbering add the link number.
d5016 1
a5016 1
	&& (text->source ? !psrcview_no_anchor_numbering : 1)
d5018 1
a5018 1
	&& links_are_numbered()) {
d5021 1
a5021 2

	sprintf(marker, "[%d]", a->number);
d5024 1
a5024 1
	    text->LastChar = ']';	/* if marker not after space caused split */
d5034 4
a5037 2
int HText_beginAnchor(HText *text, BOOL underline,
		      HTChildAnchor *anc)
d5039 1
a5039 1
    TextAnchor *a;
a5041 1

d5073 1
a5073 1
    return (a->number);
d5077 4
a5080 2
static BOOL HText_endAnchor0(HText *text, int number,
			     int really)
d5085 8
a5092 8
     * The number argument is set to 0 in HTML.c and
     * LYCharUtils.c when we want to end the anchor
     * for the immediately preceding HText_beginAnchor()
     * call.  If it's greater than 0, we want to handle
     * a particular anchor.  This allows us to set links
     * for positions indicated by NAME or ID attributes,
     * without needing to close any anchor with an HREF
     * within which that link might be embedded.  -FM
d5104 3
a5106 3
	     * There's no anchor with that number,
	     * so we'll default to the last anchor,
	     * and cross our fingers.  -FM
d5113 1
a5113 1
	    a->number, a->link_type));
d5116 1
a5116 1
	 * Shouldn't happen, but put test here anyway to be safe.  - LE
d5120 1
a5120 1
		"BUG: HText_endAnchor0: internal error: last anchor was input field!\n"));
d5126 1
a5126 1
	 * If it goes somewhere...
d5129 7
a5135 6
	BOOL remove_numbers_on_empty = (BOOL) ((links_are_numbered() &&
						((text->hiddenlinkflag != HIDDENLINKS_MERGE)
						 || (LYNoISMAPifUSEMAP &&
						     !(text->node_anchor && text->node_anchor->bookmark)
						     && HTAnchor_isISMAPScript
						     (HTAnchor_followLink(a->anchor))))));
d5144 1
a5144 1
	l = text->Lines;	/* lineno of last */
d5152 1
a5152 1
	start = last;		/* Used later */
d5155 3
a5157 3
	 * Check if the anchor content has only
	 * white and special characters, starting
	 * with the content on the last line.  -FM
d5160 1
a5160 1
	if (a->extent > (int) last->size) {
d5162 2
a5163 2
	     * The anchor extends over more than one line,
	     * so set up to check the entire last line.  -FM
d5168 2
a5169 2
	     * The anchor is restricted to the last line,
	     * so check from the start of the anchor.  -FM
d5174 1
a5174 1
	while (j < (int) last->size) {
d5184 1
a5184 1
	    if (a->extent > (int) last->size) {
d5186 4
a5189 4
		 * The anchor starts on a preceding line, and
		 * the last line has only white and special
		 * characters, so declare the entire extent
		 * of the last line as blank.  -FM
d5194 3
a5196 3
		 * The anchor starts on the last line, and
		 * has only white or special characters, so
		 * declare the anchor's extent as blank.  -FM
d5202 6
a5207 6
	 * While the anchor starts on a line preceding
	 * the one we just checked, and the one we just
	 * checked has only white and special characters,
	 * check whether the anchor's content on the
	 * immediately preceding line also has only
	 * white and special characters.  -FM
d5220 2
a5221 2
		 * The anchor starts on a preceding line,
		 * so check all of this line.  -FM
d5227 1
a5227 1
		 * The anchor starts on this line.  -FM
d5231 1
a5231 1
	    while (j < (int) prev->size) {
d5241 2
a5242 2
		if (a->extent > (CurBlankExtent + (int) prev->size) ||
		    (a->extent == CurBlankExtent + (int) prev->size &&
d5248 4
a5251 4
		     * This line has only white and special
		     * characters, so treat its entire extent
		     * as blank, and decrement the pointer for
		     * the line to be analyzed.  -FM
d5258 3
a5260 3
		     * The anchor starts on this line, and it
		     * has only white or special characters, so
		     * declare the anchor's extent as blank.  -FM
d5267 1
a5267 1
	if (!really) {		/* Just report whether it is empty */
d5269 1
a5269 1
	    return (BOOL) (i == 0);
d5273 3
a5275 3
	     * It's an invisible anchor probably from an ALT=""
	     * or an ignored ISMAP attribute due to a companion
	     * USEMAP.  -FM
d5280 3
a5282 3
		    "HText_endAnchor0: hidden (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
		    a->line_num, a->line_pos, a->extent,
		    BlankExtent));
d5285 2
a5286 2
	     * If links are numbered, then try to get rid of the
	     * numbered bracket and adjust the anchor count.  -FM
d5301 3
a5303 3
		 * Set start->data[j] to the close-square-bracket,
		 * or to the beginning of the line on which the
		 * anchor start.  -FM
d5307 1
a5307 1
		     * The anchor starts on the last line.  -FM
d5312 1
a5312 1
		     * The anchor starts on a previous line.  -FM
d5322 7
a5328 7
		 * If start->data[j] is a close-square-bracket, verify
		 * that it's the end of the numbered bracket, and if so,
		 * strip the numbered bracket.  If start->data[j] is not
		 * a close-square-bracket, check whether we had a wrap
		 * and the close-square-bracket is at the end of the
		 * previous line.  If so, strip the numbered bracket
		 * from that line.  -FM
d5343 2
a5344 2
			 * The numbered bracket is entirely
			 * on this line.  -FM
d5347 2
a5348 2
			if (start == last && (int) text->permissible_split > j) {
			    if ((int) text->permissible_split - NumSize < j)
d5354 1
a5354 1
			while (k < (int) start->size)
d5365 1
a5365 1
			    start->data[j++] = '\0';
d5383 3
a5385 3
			     * The numbered bracket started on the
			     * previous line, and part of it was
			     * wrapped to this line.  -FM
d5389 1
a5389 1
			    while (i < (int) prev->size)
d5396 1
a5396 1
				if ((int) text->permissible_split < k)
d5403 1
a5403 1
			    while (k < (int) start->size)
d5417 2
a5418 2
			     * Shucks!  We didn't find the
			     * numbered bracket.  -FM
d5424 2
a5425 2
			 * Shucks!  We didn't find the
			 * numbered bracket.  -FM
d5453 3
a5455 3
			     * The numbered bracket is all on the
			     * previous line, and the anchor content
			     * was wrapped to the last line.  -FM
d5459 1
a5459 1
			    while (k < (int) prev->size)
d5467 2
a5468 2
			     * Shucks!  We didn't find the
			     * numbered bracket.  -FM
d5474 2
a5475 2
			 * Shucks!  We didn't find the
			 * numbered bracket.  -FM
d5481 2
a5482 2
		     * Shucks!  We didn't find the
		     * numbered bracket.  -FM
d5491 3
a5493 3
	     * The anchor's content is not restricted to only
	     * white and special characters, so we'll show it
	     * as a link.  -FM
d5498 3
a5500 3
			"HText_endAnchor0: blanks (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
			a->line_num, a->line_pos, a->extent,
			BlankExtent));
d5505 5
a5509 5
	     * The anchor's content is restricted to white
	     * and special characters, so set its number
	     * and extent to zero, decrement the visible
	     * anchor number counter, and add this anchor
	     * to the hidden links list.  -FM
d5519 4
a5522 4
	     * The anchor's content is not restricted to white
	     * and special characters, so we'll display the
	     * content, but shorten its extent by any trailing
	     * blank lines we've detected.  -FM
d5525 1
a5525 1
			  BlankExtent : 0);
d5529 4
a5532 4
		    "->[%d](%d,%d,%d,%d)\n",
		    a->number,
		    a->line_num, a->line_pos, a->extent,
		    BlankExtent));
d5535 1
a5535 1
	if (!really)		/* Just report whether it is empty */
d5538 3
a5540 3
	 * It's a named anchor without an HREF, so it
	 * should be registered but not shown as a
	 * link.  -FM
d5548 3
a5550 1
void HText_endAnchor(HText *text, int number)
d5561 3
a5563 1
BOOL HText_isAnchorBlank(HText *text, int number)
d5569 3
a5571 1
void HText_appendText(HText *text, const char *str)
d5586 3
a5588 1
static int remove_special_attr_chars(char *buf)
d5593 1
a5593 1
    for (cp = buf; *cp != '\0'; cp++) {
d5595 1
a5595 1
	 * Don't print underline chars.
d5599 1
a5599 1
	    *buf++ = *cp;
d5606 1
d5608 7
a5614 6
 *  This function trims blank lines from the end of the document, and
 *  then gets the hightext from the text by finding the char position,
 *  and brings the anchors in line with the text by adding the text
 *  offset to each of the anchors.
 */
void HText_endAppend(HText *text)
d5621 1
a5621 1
    CTRACE((tfp, "Gridtext: Entering HText_endAppend\n"));
d5624 1
a5624 1
     * Create a blank line at the bottom.
d5632 3
a5634 3
	 * If output was stopped because memory was low, and we made
	 * it to the end of the document, reset those flags and hope
	 * things are better now.  - kw
d5640 2
a5641 2
	 * Could happen if TABLE end tag was missing.
	 * Alternatively we could cancel in this case.  - kw
d5647 1
a5647 1
     * Get the first line.
d5652 1
a5652 1
     * Remove the blank lines at the end of document.
d5658 1
a5658 1
		text->last_line->data));
d5660 1
a5660 1
	 * line_ptr points to the first line.
d5668 1
a5668 1
		text->last_line->data));
d5672 2
a5673 2
     * Fix up the anchor structure values and
     * create the hightext strings.  -FM
d5678 1
d5680 28
a5707 26
 *  This function gets the hightext from the text by finding the char
 *  position, and brings the anchors in line with the text by adding the text
 *  offset to each of the anchors.
 *
 *  `Forms input' fields cannot be displayed properly without this function
 *  to be invoked (detected in display_partial mode).
 *
 *  If final is set, this is the final fixup; if not set, we don't have
 *  to do everything because there should be another call later.
 *
 *  BEFORE this function has treated a TextAnchor, its line_pos and
 *  extent fields are counting bytes in the HTLine data, including
 *  invisible special attribute chars and counting UTF-8 multibyte
 *  characters as multiple bytes.
 *
 *  AFTER the adjustment, the anchor line_pos (and hightext offset if
 *  applicable) fields indicate x positions in terms of displayed character
 *  cells, and the extent field apparently is unimportant; the anchor text has
 *  been copied to the hightext fields (which should have been NULL up to that
 *  point), with special attribute chars removed.
 *
 *  This needs to be done so that display_page finds the anchors in the
 *  form it expects when it sets the links[] elements.
 */
static void HText_trimHightext(HText *text, BOOLEAN final,
			       int stop_before)
d5729 2
a5730 2
		"Gridtext: Entering HText_trimHightext (partial: 0..%d/%d)\n",
		stop_before, text->Lines));
d5734 1
a5734 1
     * Get the first line.
d5740 2
a5741 2
     * Fix up the anchor structure values and
     * create the hightext strings.  -FM
d5744 2
a5745 2
	 anchor_ptr != NULL;
	 prev_a = anchor_ptr, anchor_ptr = anchor_ptr->next) {
d5747 1
a5747 2

      re_parse:
d5749 1
a5749 1
	 * Find the right line.
d5752 2
a5753 2
	     line_ptr = line_ptr->next, cur_line++) {
	    ;			/* null body */
d5758 3
a5760 3
	     * If this is not the final call, stop when we have reached
	     * the last line, or the very end of preceding line.
	     * The last line is probably still not finished.  - kw
d5764 2
a5765 2
	    if (anchor_ptr->line_num >= text->Lines - 1
		&& anchor_ptr->line_pos >= (int) text->last_line->prev->size)
d5768 2
a5769 2
	     * Also skip this anchor if it looks like HText_endAnchor
	     * is not yet done with it.  - kw
d5779 3
a5781 3
	 * If hightext has already been set, then we must have already
	 * done the trimming & adjusting for this anchor, so avoid
	 * doing it a second time.  - kw
d5794 3
a5796 3
		"Gridtext: Anchor found on line:%d col:%d [%d] ext:%d\n",
		cur_line, anchor_ptr->line_pos,
		anchor_ptr->number, anchor_ptr->extent));
d5800 2
a5801 2
	 * Strip off any spaces or SpecialAttrChars at the beginning,
	 * if they exist, but only on HYPERTEXT_ANCHORS.
d5826 1
a5826 1
	if ((unsigned) anchor_ptr->line_pos >= strlen(line_ptr->data)) {
d5829 2
a5830 2
		 anchor_ptr->line_pos != (int) line_ptr->size ||
		 (prev_a &&	/* How could this happen? */
d5845 2
a5846 2
	    && anchor_ptr->extent > 0
	    && anchor_ptr->line_pos >= 0) {
a5847 1

d5876 1
a5876 1
		&& count_line >= stop_before) {
d5888 1
a5888 1
		&& line_ptr2->size) {
d5910 1
a5910 1
	    && count_line >= stop_before) {
a5924 1

d5936 1
a5936 1
	 * Add the offset, and set the line number.
d5939 1
a5939 1
	anchor_ptr->line_num = cur_line;
d5945 2
a5946 2
		cur_line, anchor_ptr->line_pos,
		anchor_ptr->number, "in HText_trimHightext"));
d5950 1
d5953 2
a5954 1
HTParentAnchor *HText_nodeAnchor(HText *text)
d5960 2
a5961 2
 *				=================
 */
d5964 2
a5965 2
 * HText_childNextNumber() returns the anchor with index [number],
 * using a pointer from the previous number (=optimization) or NULL.
d5967 3
a5969 1
HTChildAnchor *HText_childNextNumber(int number, void **prev)
d5972 1
a5972 1
    TextAnchor *a = *prev;
d5975 1
a5975 1
	return (HTChildAnchor *) 0;	/* Fail */
d5982 2
a5983 1
    for (; a && a->number != number; a = a->next) ;
d5986 2
a5987 2
	return (HTChildAnchor *) 0;	/* Fail */
    *prev = (void *) a;
d5992 7
a5998 6
 * HText_FormDescNumber() returns a description of the form field
 * with index N.  The index corresponds to the [number] we print
 * for the field.  -FM & LE
 */
void HText_FormDescNumber(int number,
			  char **desc)
d6000 1
a6000 1
    TextAnchor *a;
d6006 2
a6007 2
	*desc = gettext("unknown field or link");
	return;
d6021 45
a6065 45
    case F_TEXT_TYPE:
	*desc = gettext("text entry field");
	return;
    case F_PASSWORD_TYPE:
	*desc = gettext("password entry field");
	return;
    case F_CHECKBOX_TYPE:
	*desc = gettext("checkbox");
	return;
    case F_RADIO_TYPE:
	*desc = gettext("radio button");
	return;
    case F_SUBMIT_TYPE:
	*desc = gettext("submit button");
	return;
    case F_RESET_TYPE:
	*desc = gettext("reset button");
	return;
    case F_OPTION_LIST_TYPE:
	*desc = gettext("popup menu");
	return;
    case F_HIDDEN_TYPE:
	*desc = gettext("hidden form field");
	return;
    case F_TEXTAREA_TYPE:
	*desc = gettext("text entry area");
	return;
    case F_RANGE_TYPE:
	*desc = gettext("range entry field");
	return;
    case F_FILE_TYPE:
	*desc = gettext("file entry field");
	return;
    case F_TEXT_SUBMIT_TYPE:
	*desc = gettext("text-submit field");
	return;
    case F_IMAGE_SUBMIT_TYPE:
	*desc = gettext("image-submit button");
	return;
    case F_KEYGEN_TYPE:
	*desc = gettext("keygen field");
	return;
    default:
	*desc = gettext("unknown form field");
	return;
d6070 1
a6070 1
 * is to jump (input was 123+ or 123- or 123+g or 123-g or 123 or 123g)
d6075 4
a6078 3
int HTGetRelLinkNum(int num,
		    int rel,
		    int cur)
d6081 1
a6081 1
    int scrtop = HText_getTopOfScreen();	/*XXX +1? */
d6084 1
a6084 2
    int on_screen = (curline >= scrtop && curline < (scrtop + display_lines));

d6091 6
a6096 9
	    num, rel, cur, HTMainText));
    CTRACE((tfp,
	    "  scrtop=%d, curline=%d, curanchor=%d, display_lines=%d, %s\n",
	    scrtop, curline, curanchor, display_lines,
	    on_screen ? "on_screen" : "0"));
    if (!HTMainText)
	return 0;
    if (rel == 0)
	return num;
d6099 5
a6103 8
    if (on_screen && curanchor) {
	CTRACE((tfp, "curanchor=%d at line %d on screen\n", curanchor, curline));
	if (rel == '+')
	    return curanchor + num;
	else if (rel == '-')
	    return curanchor - num;
	else
	    return num;		/* shouldn't happen */
d6110 3
a6112 5
	CTRACE((tfp, "  a->line_num=%d, a->number=%d\n", a->line_num, a->number));
	if (a->line_num >= scrtop)
	    break;
	if (a->number == 0)
	    continue;
d6116 5
a6120 9
    CTRACE((tfp, "  a=%p, l=%p, curanchor=%d\n", a, l, curanchor));
    if (on_screen) {		/* on screen but not a numbered link */
	for (; a; a = a->next) {
	    if (a->number) {
		l = a;
		curanchor = l->number;
	    }
	    if (curline == a->line_num && curpos == a->line_pos)
		break;
d6123 1
a6123 1
    if (rel == '+') {
d6125 2
a6126 2
    } else if (rel == '-') {
	if (l)
d6129 1
a6129 1
	    for (; a && a->number == 0; a = a->next) ;
d6132 2
a6133 2
    } else
	return num;		/* shouldn't happen */
d6137 1
a6137 1
 * HTGetLinkInfo returns some link info based on the number.
d6139 5
a6143 5
 * If want_go is not 0, caller requests to know a line number for
 * the link indicated by number.  It will be returned in *go_line, and
 * *linknum will be set to an index into the links[] array, to use after
 * the line in *go_line has been made the new top screen line.
 * *hightext and *lname are unchanged.  - KW
d6145 2
a6146 2
 * If want_go is 0 and the number doesn't represent an input field, info
 * on the link indicated by number is deposited in *hightext and *lname.
d6148 7
a6154 6
int HTGetLinkInfo(int number,
		  int want_go,
		  int *go_line,
		  int *linknum,
		  char **hightext,
		  char **lname)
a6157 1

d6165 1
a6165 1
	return (NO);
d6169 7
a6175 7
	 * Count anchors, first on current line if there is more
	 * than one.  We have to count all links, including form
	 * field anchors and others with a->number == 0, because
	 * they are or will be included in the links[] array.
	 * The exceptions are hidden form fields and anchors with
	 * show_anchor not set, because they won't appear in links[]
	 * and don't count towards nlinks.  - KW
d6184 3
a6186 3
		 * This anchor is on a different line than the previous one.
		 * Remember which was the line number of the previous anchor,
		 * for use in screen positioning later.  - KW
d6194 5
a6198 5
		 * Count all anchors starting with the top line of the
		 * currently displayed screen.  Just keep on counting
		 * beyond this screen's bottom line - we'll know whether
		 * a found anchor is below the current screen by a check
		 * against nlinks later.  - KW
d6206 2
a6207 2
	     * We found it.  Now process it, depending
	     * on what kind of info is requested.  - KW
d6212 8
a6219 8
		     * The number requested has been assigned to an anchor
		     * without any selectable text, so we cannot position
		     * on it.  The code for suppressing such anchors in
		     * HText_endAnchor() may not have applied, or it may
		     * have failed.  Return a failure indication so that
		     * the user will notice that something is wrong,
		     * instead of positioning on some other anchor which
		     * might result in inadvertent activation.  - KW
d6221 1
a6221 1
		    return (NO);
d6226 1
a6226 1
		    a->line_num < HTMainText->top_of_screen + (display_lines)) {
d6228 4
a6231 4
		     * If the requested anchor is within the current screen,
		     * just set *go_line so that the screen window won't move
		     * (keep it as it is), and set *linknum to the index of
		     * this link in the current links[] array.  - KW
d6238 3
a6240 3
		     * if the requested anchor is not within the currently
		     * displayed screen, set *go_line such that the top line
		     * will be either
d6246 5
a6250 5
		     * whichever comes last.  In all cases the line with our
		     * target will end up being the first line with any links
		     * on the new screen, so that we can use the
		     * anchors_this_line counter to point to the anchor in
		     * the new links[] array.  - kw
a6252 1

d6265 1
a6265 1
		return (LINK_LINE_FOUND);
a6270 1

d6276 2
a6277 2
			    link_dest_intl =
				HTAnchor_followTypedLink(a->anchor, HTInternalLink);
d6280 2
a6281 3
				CTRACE((tfp,
					"HTGetLinkInfo: unexpected typed link to %s!\n",
					link_dest_intl->parent->address));
a6286 1

d6289 1
a6289 1
			    return (WWW_INTERN_LINK_TYPE);
d6297 1
a6297 1
		return (WWW_LINK_TYPE);
d6301 1
a6301 1
    return (NO);
d6304 6
a6309 5
static BOOLEAN same_anchor_or_field(int numberA,
				    FormInfo * formA,
				    int numberB,
				    FormInfo * formB,
				    BOOLEAN ta_same)
d6313 1
a6313 1
	    return (YES);
d6315 1
a6315 1
	    return (NO);
d6319 1
a6319 1
	    return (YES);
d6321 1
a6321 1
	    return (NO);
d6323 1
a6323 1
	    return (NO);
d6326 1
a6326 1
	return (NO);
d6331 1
a6331 1
	return (NO);
d6334 1
a6334 1
	return (NO);
d6336 1
a6336 1
	return (YES);
d6354 7
a6360 6
 * Are there more textarea lines belonging to the same textarea before
 * (direction < 0) or after (direction > 0) the current one?
 * On entry, curlink must be the index in links[] of a textarea field.  - kw
 */
BOOL HText_TAHasMoreLines(int curlink,
			  int direction)
d6366 1
a6366 1
	return (NO);
d6393 1
a6393 1
 * HTGetLinkOrFieldStart - moving to previous or next link or form field.
d6395 1
a6395 1
 * On input,
d6402 2
a6403 2
 * The caller wants a information for positioning on the new link to be
 * deposited in *go_line and (if linknum is not NULL) *linknum.
d6405 16
a6420 15
 * On failure (no more links in the requested direction) returns NO
 * and doesn't change *go_line or *linknum.  Otherwise, LINK_DO_ARROWUP
 * may be returned, and *go_line and *linknum not changed, to indicate that
 * the caller should use a normal PREV_LINK or PREV_PAGE mechanism.
 * Otherwise:
 * The number (0-based counting) for the new top screen line will be returned
 * in *go_line, and *linknum will be set to an index into the links[] array,
 * to use after the line in *go_line has been made the new top screen
 * line.  - kw
 */
int HTGetLinkOrFieldStart(int curlink,
			  int *go_line,
			  int *linknum,
			  int direction,
			  BOOLEAN ta_skip)
d6435 1
a6435 1
	return (NO);
d6444 7
a6450 7
	 * Count anchors, first on current line if there is more
	 * than one.  We have to count all links, including form
	 * field anchors and others with a->number == 0, because
	 * they are or will be included in the links[] array.
	 * The exceptions are hidden form fields and anchors with
	 * show_anchor not set, because they won't appear in links[]
	 * and don't count towards nlinks.  - KW
d6459 3
a6461 3
		 * This anchor is on a different line than the previous one.
		 * Remember which was the line number of the previous anchor,
		 * for use in screen positioning later.  - KW
d6481 1
a6481 1
		if (same_anchor_as_link(curlink, a, ta_skip)) {
d6490 1
a6490 1
			   same_anchor_as_link(curlink, previous.anc, ta_skip)) {
a6521 1

d6523 3
a6525 3
	     * We know where to go; most of the stuff below is just
	     * tweaks to try to position the new screen in a specific
	     * way.
d6527 3
a6529 3
	     * In some cases going to a previous link can be done
	     * via the normal LYK_PREV_LINK action, which may give
	     * better positioning of the new screen.  - kw
d6532 1
a6532 1
		a->line_num >= HTMainText->top_of_screen - (display_lines)) {
d6542 1
a6542 1
		    return (LINK_DO_ARROWUP);
d6546 7
a6552 7
	     * The fundamental limitation of the current anchors_this_line
	     * counter method is that we only can set *linknum to the right
	     * index into the future links[] array if the line with our link
	     * ends up being the first line with any links (that count) on
	     * the new screen.  Subject to that restriction we still have
	     * some vertical liberty (sometimes), and try to make the best
	     * of it.  It may be a question of taste though.  - kw
d6558 2
a6559 3
		(HTMainText->top_of_screen - a->line_num + (display_lines) - 1)
		/ (display_lines);

d6566 1
a6566 1
		       HTMainText->top_of_screen + (display_lines)) {
d6568 1
a6568 2
		(a->line_num - HTMainText->top_of_screen) / (display_lines);

d6589 1
a6589 1
	    return (LINK_LINE_FOUND);
d6592 1
a6592 1
    return (NO);
d6596 18
a6613 16
 * This function finds the line indicated by line_num in the
 * HText structure indicated by text, and searches that line
 * for the first hit with the string indicated by target.  If
 * there is no hit, FALSE is returned.  If there is a hit, then
 * a copy of the line starting at that first hit is loaded into
 * *data with all IsSpecial characters stripped, its offset and
 * the printable target length (without IsSpecial, or extra CJK
 * or utf8 characters) are loaded into *offset and *tLen, and
 * TRUE is returned.  -FM
 */
BOOL HText_getFirstTargetInLine(HText *text, int line_num,
				BOOL utf_flag,
				int *offset,
				int *tLen,
				char **data,
				const char *target)
d6621 2
a6622 2
     * Make sure we have an HText structure, that line_num is
     * in its range, and that we have a target string.  -FM
d6625 4
a6628 4
	  line_num >= 0 &&
	  line_num <= text->Lines &&
	  non_empty(target))) {
	return (FALSE);
d6632 1
a6632 1
     * Find the line and set up its data and offset -FM
d6638 1
a6638 1
	    return (FALSE);
d6642 3
a6644 3
	return (FALSE);
    LineData = (char *) line->data;
    LineOffset = (int) line->offset;
d6647 4
a6650 4
     * If the target is on the line, load the offset of
     * its first character and the subsequent line data,
     * strip any special characters from the loaded line
     * data, and return TRUE.  -FM
d6659 4
a6662 4
	 * We had a hit so load the results,
	 * remove IsSpecial characters from
	 * the allocated data string, and
	 * return TRUE.  -FM
d6666 3
a6668 3
	StrAllocCopy(*data, cp);
	remove_special_attr_chars(*data);
	return (TRUE);
d6672 1
a6672 1
     * The line does not contain the target.  -FM
d6674 1
a6674 1
    return (FALSE);
d6678 2
a6679 2
 * HText_getNumOfLines returns the number of lines in the
 * current document.
d6681 1
a6681 1
int HText_getNumOfLines(void)
d6683 1
a6683 1
    return (HTMainText ? HTMainText->Lines : 0);
d6687 2
a6688 2
 * HText_getTitle returns the title of the
 * current document.
d6690 1
a6690 1
const char *HText_getTitle(void)
d6692 2
a6693 2
    return (HTMainText ?
	    HTAnchor_title(HTMainText->node_anchor) : 0);
d6697 1
a6697 1
const char *HText_getStyle(void)
d6699 2
a6700 2
    return (HTMainText ?
	    HTAnchor_style(HTMainText->node_anchor) : 0);
d6705 3
a6707 3
 * HText_getSugFname returns the suggested filename of the current
 * document (normally derived from a Content-Disposition header with
 * attachment; filename=name.suffix).  -FM
d6709 1
a6709 1
const char *HText_getSugFname(void)
d6711 2
a6712 2
    return (HTMainText ?
	    HTAnchor_SugFname(HTMainText->node_anchor) : 0);
d6716 6
a6721 6
 * HTCheckFnameForCompression receives the address of an allocated
 * string containing a filename, and an anchor pointer, and expands
 * or truncates the string's suffix if appropriate, based on whether
 * the anchor indicates that the file is compressed.  We assume
 * that the file was not uncompressed (as when downloading), and
 * believe the headers about whether it's compressed or not.  -FM
d6723 8
a6730 7
 * Added third arg - if strip_ok is FALSE, we don't trust the anchor
 * info enough to remove a compression suffix if the anchor object
 * does not indicate compression.  - kw
 */
void HTCheckFnameForCompression(char **fname,
				HTParentAnchor *anchor,
				BOOL strip_ok)
d6741 1
a6741 1
     * Make sure we have a string and anchor.  -FM
d6747 1
a6747 1
     * Make sure we have a file, not directory, name.  -FM
d6753 2
a6754 2
     * Check the anchor's content_type and content_encoding
     * elements for a gzip or Unix compressed file.  -FM
d6760 2
a6761 2
	 * No Content-Encoding, so check
	 * the Content-Type.  -FM
d6787 3
a6789 3
     * If no Content-Encoding has been detected via the anchor
     * pointer, but strip_ok is not set, there is nothing left
     * to do.  - kw
d6798 1
a6798 1
	&& !strcasecomp(dot, ".tgz")) {
d6806 2
a6807 2
     * Seek the last dot, and check whether
     * we have a gzip or compress suffix.  -FM
d6813 3
a6815 3
		 * It has a suffix which signifies a gzipped
		 * or compressed file for us, but the anchor
		 * claims otherwise, so tweak the suffix.  -FM
d6824 3
a6826 3
		 * It has a tail which signifies a gzipped
		 * file for us, but the anchor claims otherwise,
		 * so tweak the suffix.  -FM
d6828 1
a6828 1
		if (cp == dot + 1)
d6833 3
a6835 3
		 * The anchor claims it's gzipped, and we
		 * believe it, so force this tail to the
		 * conventional suffix.  -FM
d6867 1
a6867 1
     * Add the appropriate suffix.  -FM
d6884 2
a6885 2
 * HText_getLastModified returns the Last-Modified header
 * if available, for the current document.  -FM
d6887 1
a6887 1
const char *HText_getLastModified(void)
d6889 2
a6890 2
    return (HTMainText ?
	    HTAnchor_last_modified(HTMainText->node_anchor) : 0);
d6894 2
a6895 2
 * HText_getDate returns the Date header
 * if available, for the current document.  -FM
d6897 1
a6897 1
const char *HText_getDate(void)
d6899 2
a6900 2
    return (HTMainText ?
	    HTAnchor_date(HTMainText->node_anchor) : 0);
d6904 2
a6905 2
 * HText_getServer returns the Server header
 * if available, for the current document.  -FM
d6907 1
a6907 1
const char *HText_getServer(void)
d6909 2
a6910 2
    return (HTMainText ?
	    HTAnchor_server(HTMainText->node_anchor) : 0);
a6912 1
#ifdef EXP_HTTP_HEADERS
d6914 3
a6916 2
 * Returns the full text of HTTP headers, if available, for the current
 * document.
d6918 3
a6920 14
const char *HText_getHttpHeaders(void)
{
    return (HTMainText ?
	    HTAnchor_http_headers(HTMainText->node_anchor) : 0);
}
#endif

/*
 * HText_pageDisplay displays a screen of text
 * starting from the line 'line_num'-1.
 * This is the primary call for lynx.
 */
void HText_pageDisplay(int line_num,
		       char *target)
a6928 1

d6930 8
a6937 8
	 * Garbage is reported from forms input fields in incremental mode.
	 * So we start HText_trimHightext() to forget this side effect.
	 * This function was split-out from HText_endAppend().
	 * It may not be the best solution but it works.  - LP
	 *
	 * (FALSE = indicate that we are in partial mode)
	 * Multiple calls of HText_trimHightext works without problem now.
	 */
d6944 1
a6944 1
    display_page(HTMainText, line_num - 1, target);
d6961 2
a6962 2
 * Return YES if we have a whereis search target on the displayed
 * page.  - kw
d6964 1
a6964 1
BOOL HText_pageHasPrevTarget(void)
d6973 2
a6974 2
 * HText_LinksInLines returns the number of links in the
 * 'Lines' number of lines beginning with 'line_num'-1.  -FM
d6976 4
a6979 2
int HText_LinksInLines(HText *text, int line_num,
		       int Lines)
d7003 2
a7004 1
void HText_setStale(HText *text)
d7009 2
a7010 1
void HText_refresh(HText *text)
d7016 2
a7017 1
int HText_sourceAnchors(HText *text)
d7022 2
a7023 1
BOOL HText_canScrollUp(HText *text)
d7028 1
a7028 1
BOOL HText_canScrollDown(void)
d7030 1
a7030 1
    HText *text = HTMainText;
d7033 1
a7033 1
		   && ((text->top_of_screen + display_lines) < text->Lines + 1));
d7038 2
a7039 1
void HText_scrollTop(HText *text)
d7044 2
a7045 1
void HText_scrollDown(HText *text)
d7050 2
a7051 1
void HText_scrollUp(HText *text)
d7056 2
a7057 1
void HText_scrollBottom(HText *text)
d7062 1
d7064 2
a7065 2
 *		==================
 */
d7069 2
a7070 1
BOOL HText_select(HText *text)
d7074 2
a7075 2
	 * Reset flag for whereis search string - cannot be true here
	 * since text is not our HTMainText.  - kw
d7092 2
a7093 2
	if (text->node_anchor->UCStages->s[UCT_STAGE_HTEXT].LYhndl
	    != current_char_set)
d7112 1
a7112 1
	 * Make this text the most current in the loaded texts list.  -FM
d7116 2
a7117 2
	/* let lynx do it */
	/* display_page(text, text->top_of_screen, ""); */
d7123 3
a7125 3
 * This function returns TRUE if doc's post_data, address
 * and isHEAD elements are identical to those of a loaded
 * (memory cached) text.  -FM
d7127 2
a7128 1
BOOL HText_POSTReplyLoaded(DocInfo *doc)
d7137 1
a7137 1
     * Make sure we have the structures.  -FM
d7140 1
a7140 1
	return (FALSE);
d7143 1
a7143 1
     * Make sure doc is for a POST reply.  -FM
d7147 1
a7147 1
	return (FALSE);
d7151 2
a7152 2
     * Loop through the loaded texts looking for a
     * POST reply match.  -FM
d7154 1
a7154 1
    while (NULL != (text = (HText *) HTList_nextObject(cur))) {
d7161 1
a7161 1
	    return (TRUE);
d7165 1
a7165 1
    return (FALSE);
d7168 2
a7169 1
BOOL HTFindPoundSelector(const char *selector)
d7171 1
a7171 1
    TextAnchor *a;
d7178 1
a7178 1
		www_search_result = a->line_num + 1;
d7181 1
a7181 1
			a->number, www_search_result));
d7185 1
a7185 1
		return (YES);
d7190 1
a7190 1
    return (NO);
d7194 3
a7196 1
BOOL HText_selectAnchor(HText *text, HTChildAnchor *anchor)
d7198 1
a7198 1
    TextAnchor *a;
d7207 2
a7208 3
    for (a = text->first_anchor; a; a = a->next) {
	if (a->anchor == anchor)
	    break;
d7215 2
a7216 2
    if (text != HTMainText) {	/* Comment out by ??? */
	HTMainText = text;	/* Put back in by tbl 921208 */
d7218 1
a7218 2
    } {
	int l = a->line_num;
d7220 9
a7228 2
	CTRACE((tfp, "HText: Selecting anchor [%d] at line %d\n",
		a->number, l));
d7230 1
a7230 6
	if (!text->stale &&
	    (l >= text->top_of_screen) &&
	    (l < text->top_of_screen + display_lines + 1))
	    return YES;

	www_search_result = l - (display_lines / 3);	/* put in global variable */
d7236 1
d7238 5
a7242 5
 *		=================
 *
 *	These are called from the application.  There are many more functions
 *	not included here from the original text object.
 */
d7248 3
a7250 1
void HText_applyStyle(HText *me GCC_UNUSED, HTStyle *style GCC_UNUSED)
d7255 1
d7258 3
a7260 1
void HText_updateStyle(HText *me GCC_UNUSED, HTStyle *style GCC_UNUSED)
d7265 1
d7268 3
a7270 1
HTStyle *HText_selectionStyle(HText *me GCC_UNUSED, HTStyleSheet *sheet GCC_UNUSED)
d7275 1
d7278 4
a7281 2
void HText_replaceSel(HText *me GCC_UNUSED, const char *aString GCC_UNUSED,
		      HTStyle *aStyle GCC_UNUSED)
d7285 1
d7287 5
a7291 3
 *	(style recovery only)
 */
void HTextApplyToSimilar(HText *me GCC_UNUSED, HTStyle *style GCC_UNUSED)
d7296 1
d7298 5
a7302 3
 *	(style recovery only)
 */
void HTextSelectUnstyled(HText *me GCC_UNUSED, HTStyleSheet *sheet GCC_UNUSED)
d7307 1
d7310 2
a7311 1
void HText_unlinkSelection(HText *me GCC_UNUSED)
d7316 2
a7317 1
HTAnchor *HText_referenceSelected(HText *me GCC_UNUSED)
d7319 1
a7319 1
    return 0;
d7322 2
a7323 1
int HText_getTopOfScreen(void)
d7325 1
a7325 2
    HText *text = HTMainText;

d7329 2
a7330 1
int HText_getLines(HText *text)
d7335 3
a7337 2
HTAnchor *HText_linkSelTo(HText *me GCC_UNUSED,
			  HTAnchor * anchor GCC_UNUSED)
d7343 1
a7343 1
 * Utility for freeing the list of previous isindex and whereis queries.  -FM
d7345 1
a7345 1
void HTSearchQueries_free(void)
d7353 1
a7353 1
    while (NULL != (query = (char *) HTList_nextObject(cur))) {
d7362 2
a7363 2
 * Utility for listing isindex and whereis queries, making
 * any repeated queries the most current in the list.  -FM
d7365 2
a7366 1
void HTAddSearchQuery(char *query)
d7387 1
a7387 1
    while (NULL != (old = (char *) HTList_nextObject(cur))) {
d7399 2
a7400 1
int do_www_search(DocInfo *doc)
d7409 1
a7409 1
     * Load the default query buffer
d7411 1
a7411 1
    if ((cp = strchr(doc->address, '?')) != NULL) {
d7413 2
a7414 2
	 * This is an index from a previous search.
	 * Use its query as the default.
d7417 2
a7418 2
	LYstrncpy(searchstring, ++cp, sizeof(searchstring) - 1);
	for (cp = searchstring; *cp; cp++)
d7424 1
a7424 1
	 * Make sure it's treated as the most recent query.  -FM
d7429 1
a7429 1
	 * New search; no default.
d7436 1
a7436 1
     * Prompt for a query string.
d7449 3
a7451 3
  get_query:
    if ((ch = LYgetstr(searchstring, VISIBLE,
		       sizeof(searchstring), recall)) < 0 ||
d7456 1
a7456 1
		 * Use the second to last query in the list.  -FM
d7462 1
a7462 1
		 * Go back to the previous query in the list.  -FM
d7468 1
a7468 1
		 * Roll around to the last query in the list.  -FM
d7471 3
a7473 3
	    if ((cp = (char *) HTList_objectAt(search_queries,
					       QueryNum)) != NULL) {
		LYstrncpy(searchstring, cp, sizeof(searchstring) - 1);
d7487 1
a7487 1
		 * Use the first query in the list.  -FM
d7493 1
a7493 1
		 * Advance to the next query in the list.  -FM
d7499 1
a7499 1
		 * Roll around to the first query in the list.  -FM
d7502 3
a7504 3
	    if ((cp = (char *) HTList_objectAt(search_queries,
					       QueryNum)) != NULL) {
		LYstrncpy(searchstring, cp, sizeof(searchstring) - 1);
d7518 1
a7518 1
	 * Search cancelled.
d7521 1
a7521 1
	return (NULLFILE);
d7525 1
a7525 1
     * Strip leaders and trailers.  -FM
d7530 1
a7530 1
	return (NULLFILE);
d7535 1
a7535 1
     * Don't resubmit the same query unintentionally.
d7539 1
a7539 1
	return (NULLFILE);
d7543 2
a7544 2
     * Add searchstring to the query list,
     * or make it the most current.  -FM
d7549 1
a7549 1
     * Show the URL with the new query.
d7551 1
a7551 1
    if ((cp = strchr(doc->address, '?')) != NULL)
d7565 1
a7565 1
     * OK, now we do the search.
d7569 2
a7570 2
	 * Memory leak fixed.
	 * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
a7572 1

d7574 1
a7574 1
	    cp_freeme = stub_HTAnchor_address((HTAnchor *) HTMainAnchor);
d7576 1
a7576 1
	    cp_freeme = HTAnchor_address((HTAnchor *) HTMainAnchor);
d7580 1
a7580 1
	CTRACE((tfp, "\ndo_www_search: newfile: %s\n", doc->address));
d7583 1
a7583 1
	 * Yah, the search succeeded.
d7585 1
a7585 1
	return (NORMAL);
d7589 5
a7593 5
     * Either the search failed (Yuk), or we got redirection.
     * If it's redirection, use_this_url_instead is set, and
     * mainloop() will deal with it such that security features
     * and restrictions are checked before acting on the URL, or
     * rejecting it.  -FM
d7595 1
a7595 1
    return (NOT_FOUND);
d7598 3
a7600 1
static void write_offset(FILE *fp, HTLine *line)
d7605 2
a7606 2
	for (i = 0; i < (int) line->offset; i++) {
	    fputc(' ', fp);
d7611 2
a7612 1
static void write_hyphen(FILE *fp)
d7619 1
a7619 1
	fputc(0xad, fp);	/* the iso8859 byte for SHY */
d7626 10
a7635 8
 * Print the contents of the file in HTMainText to
 * the file descriptor fp.
 * If is_email is TRUE add ">" before each "From " line.
 * If is_reply is TRUE add ">" to the beginning of each
 * line to specify the file is a reply to message.
 */
void print_wwwfile_to_fd(FILE *fp, BOOLEAN is_email,
			 BOOLEAN is_reply)
d7639 1
a7639 2
    HTLine *line;

d7641 1
a7641 1
    HText *text = HTMainText;
d7644 5
a7648 5
    BOOL bs = (BOOL) (!is_email && !is_reply
		      && text != 0
		      && with_backspaces
		      && HTCJK == NOCJK
		      && !text->T.output_utf8);
d7659 1
a7659 1
		fputc('>', fp);
d7661 1
a7661 1
		fputc('>', fp);
d7664 1
a7664 1
	    fputc('\n', fp);
d7666 1
a7666 1
	     * Add news-style quotation if requested.  -FM
d7669 1
a7669 1
		fputc('>', fp);
d7671 1
a7671 1
		fputc('>', fp);
d7678 1
a7678 1
	 * Add data.
d7685 1
a7685 1
		    fputc('\b', fp);
d7688 2
a7689 2
		    fputc('_', fp);
		    fputc('\b', fp);
d7693 1
a7693 1
		    fputc(line->data[i], fp);
d7695 1
a7695 1
		       line->data[i + 1] == '\0') {	/* last char on line */
d7699 7
a7705 7
		case LY_UNDERLINE_START_CHAR:
		case LY_UNDERLINE_END_CHAR:
		    fputc('_', fp);
		    break;
		case LY_BOLD_START_CHAR:
		case LY_BOLD_END_CHAR:
		    break;
d7711 15
a7725 15
		case LY_UNDERLINE_START_CHAR:
		    if (!in_b)
			in_u = TRUE;	/*favor bold over underline */
		    break;
		case LY_UNDERLINE_END_CHAR:
		    in_u = FALSE;
		    break;
		case LY_BOLD_START_CHAR:
		    if (in_u)
			in_u = FALSE;	/* turn it off */
		    in_b = TRUE;
		    break;
		case LY_BOLD_END_CHAR:
		    in_b = FALSE;
		    break;
d7739 1
a7739 1
    fputc('\n', fp);
d7744 3
a7746 3
 * Print the contents of the file in HTMainText to
 * the file descriptor fp.
 * First output line is "thelink", ie, the URL for this file.
d7748 4
a7751 2
void print_crawl_to_fd(FILE *fp, char *thelink,
		       char *thetitle)
d7755 1
a7755 1
    HTLine *line;
d7768 1
a7768 1
	    fputc('\n', fp);
d7773 1
a7773 1
	 * Add data.
d7779 1
a7779 1
		       line->data[i + 1] == '\0') {	/* last char on line */
d7788 1
a7788 1
    fputc('\n', fp);
d7791 1
a7791 1
     * Add the References list if appropriate
d7795 1
a7795 1
	printlist(fp, FALSE);
d7797 1
d7803 4
a7806 2
static void adjust_search_result(DocInfo *doc, int tentative_result,
				 int start_line)
d7810 1
a7810 1
	TextAnchor *a;
d7815 1
a7815 3
				 tentative_result <= HTMainText->top_of_screen +
				 display_lines);

a7823 1

d7840 1
a7840 1
	     a && a->line_num <= tentative_result - 1; a = a->next) {
d7849 1
a7849 1
	     tentative_result <= HTMainText->top_of_screen)) {
d7851 3
a7853 2
	} else if (tentative_result - start_line > 0 &&
		   tentative_result - (start_line + 1) <= max_offset) {
d7855 4
a7858 3
	} else if (tentative_result > HTMainText->top_of_screen &&
		   tentative_result <= start_line &&	/* have wrapped */
		   tentative_result <= HTMainText->top_of_screen + goal) {
d7860 2
a7861 1
	} else if (tentative_result <= goal)
d7874 3
a7876 1
static BOOL anchor_has_target(TextAnchor *a, char *target)
d7878 1
a7878 1
    OptionType *option;
d7886 1
a7886 1
    for (count = 0;; ++count) {
d7894 2
a7895 2
     * Search the relevant form fields, taking the
     * case_sensitive setting into account.  -FM
d7901 2
a7902 2
	     * Check the actual, hidden password, and then
	     * the displayed string.  -FM
d7917 2
a7918 2
	     * Search the option strings that are displayed
	     * when the popup is invoked.  -FM
d7929 1
a7929 1
	     * Search for checked or unchecked parens.  -FM
d7941 1
a7941 1
	     * Search for checked or unchecked square brackets.  -FM
d7965 2
a7966 1
static TextAnchor *line_num_to_anchor(int line_num)
d7981 3
a7983 1
static int line_num_in_text(HText *text, HTLine *line)
d7998 2
a7999 1
static TextAnchor *get_prev_anchor(TextAnchor *a)
d8014 6
a8019 5
static int www_search_forward(int start_line,
			      DocInfo *doc,
			      char *target,
			      HTLine *line,
			      int count)
d8057 6
a8062 5
static int www_search_backward(int start_line,
			       DocInfo *doc,
			       char *target,
			       HTLine *line,
			       int count)
d8100 5
a8104 4
void www_user_search(int start_line,
		     DocInfo *doc,
		     char *target,
		     int direction)
d8106 1
a8106 1
    HTLine *line;
d8114 1
a8114 1
     * Advance to the start line.
d8118 1
a8118 3
	for (count = 1;
	     count < start_line + direction;
	     line = line->next, count++) {
d8136 3
a8138 2
void user_message(const char *message,
		  const char *argument)
d8156 2
a8157 2
 * HText_getOwner returns the owner of the
 * current document.
d8159 1
a8159 1
const char *HText_getOwner(void)
d8161 2
a8162 2
    return (HTMainText ?
	    HTAnchor_owner(HTMainText->node_anchor) : 0);
d8166 2
a8167 2
 * HText_setMainTextOwner sets the owner for the
 * current document.
d8169 2
a8170 1
void HText_setMainTextOwner(const char *owner)
d8179 3
a8181 3
 * HText_getRevTitle returns the RevTitle element of the
 * current document, used as the subject for mailto comments
 * to the owner.
d8183 1
a8183 1
const char *HText_getRevTitle(void)
d8185 2
a8186 2
    return (HTMainText ?
	    HTAnchor_RevTitle(HTMainText->node_anchor) : 0);
d8190 2
a8191 2
 * HText_getContentBase returns the Content-Base header
 * of the current document.
d8193 1
a8193 1
const char *HText_getContentBase(void)
d8195 2
a8196 2
    return (HTMainText ?
	    HTAnchor_content_base(HTMainText->node_anchor) : 0);
d8200 2
a8201 2
 * HText_getContentLocation returns the Content-Location header
 * of the current document.
d8203 1
a8203 1
const char *HText_getContentLocation(void)
d8205 2
a8206 2
    return (HTMainText ?
	    HTAnchor_content_location(HTMainText->node_anchor) : 0);
d8210 2
a8211 2
 * HText_getMessageID returns the Message-ID of the
 * current document.
d8213 1
a8213 1
const char *HText_getMessageID(void)
d8215 2
a8216 2
    return (HTMainText ?
	    HTAnchor_messageID(HTMainText->node_anchor) : NULL);
d8219 1
a8219 1
void HTuncache_current_document(void)
d8222 1
a8222 1
     * Should remove current document from memory.
d8225 1
a8225 1
	HTParentAnchor *htmain_anchor = HTMainText->node_anchor;
d8233 7
a8239 7
		((htmain_anchor &&
		  htmain_anchor->address) ?
		 htmain_anchor->address : "unknown anchor"),
		((htmain_anchor &&
		  htmain_anchor->post_data)
		 ? " with POST data"
		 : "")));
d8250 1
a8250 2
static HTProtocol scm =
{"source-cache-mem", 0, 0};	/* dummy - kw */
d8252 1
a8252 1
BOOLEAN HTreparse_document(void)
d8258 1
a8258 1
	 !HTMainAnchor->source_cache_file) ||
d8260 1
a8260 1
	 !HTMainAnchor->source_cache_chunk))
d8264 1
a8264 1
	FILE *fp;
d8269 1
a8269 1
		HTMainAnchor->source_cache_file));
d8288 1
a8288 1
				     UCLYhndl_for_unspec);
d8318 1
a8318 2
	    CTRACE((tfp,
		    "SourceCache: `%s' has been accessed, partial content.\n",
d8330 1
a8330 1
		(void *) HTMainAnchor->source_cache_chunk));
d8343 8
a8350 8
	    /*
	     * This is only done to make things aligned with SOURCE_CACHE_NONE and
	     * SOURCE_CACHE_FILE when switching to source mode since the original
	     * document's charset will be LYPushAssumed() and then LYPopAssumed().
	     * See LYK_SOURCE in mainloop if you change something here.  No
	     * user-visible benefits, seems just '=' Info Page will show source's
	     * effective charset as "(assumed)".
	     */
d8352 1
a8352 1
				     UCLYhndl_for_unspec);
d8366 2
a8367 2
	HTAnchor_setProtocol(HTMainAnchor, &scm);	/* cheating -
							   anything != &HTTP or &HTTPS would do - kw */
d8369 1
a8369 1
			 HTMainAnchor->source_cache_chunk, NULL);
d8378 1
a8378 1
BOOLEAN HTcan_reparse_document(void)
d8382 1
a8382 1
	 !HTMainAnchor->source_cache_file) ||
d8384 1
a8384 1
	 !HTMainAnchor->source_cache_chunk))
d8396 1
a8396 1
    return FALSE;		/* if came to here */
d8399 4
a8402 3
static void trace_setting_change(const char *name,
				 int prev_setting,
				 int new_setting)
d8405 2
a8406 3
	CTRACE((tfp,
		"HTdocument_settings_changed: %s setting has changed (was %d, now %d)\n",
		name, prev_setting, new_setting));
d8409 1
a8409 1
BOOLEAN HTdocument_settings_changed(void)
d8417 1
a8417 1
	 !HTMainAnchor->source_cache_file) ||
d8419 1
a8419 1
	 !HTMainAnchor->source_cache_chunk))
d8432 2
a8433 2
			     HTMainText->verbose_img,
			     verbose_img);
d8448 2
a8449 5
		    "HTdocument_settings_changed: Screen size has changed (was %dx%d, now %dx%d)\n",
		    HTMainText->disp_cols,
		    HTMainText->disp_lines,
		    DISPLAY_COLS,
		    LYlines));
d8466 1
a8466 1
int HTisDocumentSource(void)
d8471 1
a8471 1
char *HTLoadedDocumentURL(void)
d8477 1
a8477 1
	return (HTMainText->node_anchor->address);
d8482 1
a8482 1
bstring *HTLoadedDocumentPost_data(void)
d8485 3
a8487 3
	&& HTMainText->node_anchor
	&& HTMainText->node_anchor->post_data)
	return (HTMainText->node_anchor->post_data);
d8492 1
a8492 1
char *HTLoadedDocumentTitle(void)
d8498 1
a8498 1
	return (HTMainText->node_anchor->title);
d8503 1
a8503 1
BOOLEAN HTLoadedDocumentIsHEAD(void)
d8509 1
a8509 1
	return (HTMainText->node_anchor->isHEAD);
d8514 1
a8514 1
BOOLEAN HTLoadedDocumentIsSafe(void)
d8520 1
a8520 1
	return (HTMainText->node_anchor->safe);
d8525 1
a8525 1
char *HTLoadedDocumentCharset(void)
d8531 1
a8531 1
	return (HTMainText->node_anchor->charset);
d8536 1
a8536 1
BOOL HTLoadedDocumentEightbit(void)
d8544 2
a8545 1
void HText_setNodeAnchorBookmark(const char *bookmark)
d8554 1
a8554 1
char *HTLoadedDocumentBookmark(void)
d8560 1
a8560 1
	return (HTMainText->node_anchor->bookmark);
d8565 3
a8567 1
int HText_LastLineSize(HText *text, BOOL IgnoreSpaces)
d8574 3
a8576 1
BOOL HText_LastLineEmpty(HText *text, BOOL IgnoreSpaces)
d8583 2
a8584 1
int HText_LastLineOffset(HText *text)
d8588 1
a8588 1
    return text->last_line->offset;
d8591 3
a8593 1
int HText_PreviousLineSize(HText *text, BOOL IgnoreSpaces)
d8595 1
a8595 1
    HTLine *line;
d8604 3
a8606 1
BOOL HText_PreviousLineEmpty(HText *text, BOOL IgnoreSpaces)
d8608 1
a8608 1
    HTLine *line;
d8620 4
a8623 1
static int HText_TrueLineSize(HTLine *line, HText *text, BOOL IgnoreSpaces)
d8657 4
a8660 1
static BOOL HText_TrueEmptyLine(HTLine *line, HText *text, BOOL IgnoreSpaces)
d8688 2
a8689 1
void HText_NegateLineOne(HText *text)
d8697 2
a8698 1
BOOL HText_inLineOne(HText *text)
d8707 8
a8714 8
 * This function is for removing the first of two
 * successive blank lines.  It should be called after
 * checking the situation with HText_LastLineSize()
 * and HText_PreviousLineSize().  Any characters in
 * the removed line (i.e., control characters, or it
 * wouldn't have tested blank) should have been
 * reiterated by split_line() in the retained blank
 * line.  -FM
d8716 2
a8717 1
void HText_RemovePreviousLine(HText *text)
d8733 1
a8733 1
 * NOTE:  This function presently is correct only if the
d8739 2
a8740 1
int HText_getCurrentColumn(HText *text)
d8747 3
a8749 3
		  (int) text->style->indent1st : (int) text->style->leftIndent)
	    + HText_LastLineSize(text, IgnoreSpaces)
	    + (int) text->last_line->offset;
d8754 2
a8755 1
int HText_getMaximumColumn(HText *text)
d8757 1
a8757 2
    int column = (DISPLAY_COLS - 2);

d8759 2
a8760 2
	column = ((int) text->style->rightIndent ? (DISPLAY_COLS - 2) :
		  ((DISPLAY_COLS - 1) - (int) text->style->rightIndent));
d8766 1
a8766 1
 * NOTE:  This function uses HText_getCurrentColumn() which
d8770 7
a8776 5
void HText_setTabID(HText *text, const char *name)
{
    HTTabID *Tab = NULL;
    HTList *cur = text->tabs;
    HTList *last = NULL;
d8784 1
a8784 1
	while (NULL != (Tab = (HTTabID *) HTList_nextObject(cur))) {
d8786 1
a8786 1
		return;		/* Already set.  Keep the first value. */
d8792 1
a8792 1
    if (!Tab) {			/* New name.  Create a new node */
d8803 3
a8805 1
int HText_getTabIDColumn(HText *text, const char *name)
d8808 2
a8809 2
    HTTabID *Tab;
    HTList *cur = text->tabs;
d8812 1
a8812 1
	while (NULL != (Tab = (HTTabID *) HTList_nextObject(cur))) {
d8823 13
a8835 11
 * This function is for saving the address of a link
 * which had an attribute in the markup that resolved
 * to a URL (i.e., not just a NAME or ID attribute),
 * but was found in HText_endAnchor() to have no visible
 * content for use as a link name.  It loads the address
 * into text->hidden_links, whose count can be determined
 * via HText_HiddenLinks(), below.  The addresses can be
 * retrieved via HText_HiddenLinkAt(), below, based on
 * count.  -FM
 */
static void HText_AddHiddenLink(HText *text, TextAnchor *textanchor)
d8840 1
a8840 1
     * Make sure we have an HText structure and anchor.  -FM
d8846 2
a8847 2
     * Create the hidden links list
     * if it hasn't been already.  -FM
d8853 3
a8855 3
     * Store the address, in reverse list order
     * so that first in will be first out on
     * retrievals.  -FM
d8866 2
a8867 2
 * This function returns the number of addresses
 * that are loaded in text->hidden_links.  -FM
d8869 2
a8870 1
int HText_HiddenLinkCount(HText *text)
d8875 1
a8875 1
	count = HTList_count((HTList *) text->hidden_links);
d8877 1
a8877 1
    return (count);
d8881 3
a8883 3
 * This function returns the address, corresponding to
 * a hidden link, at the position (zero-based) in the
 * text->hidden_links list of the number argument.  -FM
d8885 3
a8887 1
char *HText_HiddenLinkAt(HText *text, int number)
d8892 1
a8892 1
	href = (char *) HTList_objectAt((HTList *) text->hidden_links, number);
d8894 1
a8894 1
    return (href);
d8897 1
d8899 3
a8901 3
 * Form methods
 * These routines are used to build forms consisting
 * of input fields
d8904 4
a8907 4
static char *HTFormAction = NULL;
static char *HTFormEnctype = NULL;
static char *HTFormTitle = NULL;
static char *HTFormAcceptCharset = NULL;
d8909 1
a8909 1
static PerFormInfo *HTCurrentForm;
d8911 6
a8916 5
void HText_beginForm(char *action,
		     char *method,
		     char *enctype,
		     char *title,
		     const char *accept_cs)
d8918 1
a8918 2
    PerFormInfo *newform;

d8925 1
a8925 1
     * Check the ACTION.  -FM
d8932 2
a8933 1
    } else
d8937 1
a8937 1
     * Check the METHOD.  -FM
d8940 1
a8940 1
	if (!strcasecomp(method, "post") || !strcasecomp(method, "pget"))
d8944 1
a8944 1
     * Check the ENCTYPE.  -FM
d8956 1
a8956 1
     * Check the TITLE.  -FM
d8964 2
a8965 2
     * Check for an ACCEPT_CHARSET.  If present, store it and
     * convert to lowercase and collapse spaces.  - kw
d8974 7
a8980 7
     * Create a new "PerFormInfo" structure to hold info on the current
     * form.  The HTForm* variables could all migrate there, currently
     * this isn't done (yet?) but it might be less confusing.
     * Currently the only data saved in this structure that will actually
     * be used is the accept_cs string.
     * This will be appended to the forms list kept by the HText object
     * if and when we reach a HText_endForm.  - kw
d8984 1
a8984 1
	outofmem(__FILE__, "HText_beginForm");
d8987 1
a8987 1
    PerFormInfo_free(HTCurrentForm);	/* shouldn't happen here - kw */
d8991 7
a8997 7
	    HTFormAction, HTFormMethod,
	    (HTFormTitle ? " Title:" : ""),
	    NonNull(HTFormTitle),
	    (HTFormEnctype ? " Enctype:" : ""),
	    NonNull(HTFormEnctype),
	    (HTFormAcceptCharset ? " Accept-charset:" : ""),
	    NonNull(HTFormAcceptCharset)));
d9000 2
a9001 1
void HText_endForm(HText *text)
d9005 2
a9006 2
	 * Support submission of a single text input field in
	 * the form via <return> instead of a submit button.  -FM
d9008 1
a9008 2
	TextAnchor *a;

d9010 1
a9010 1
	 * Go through list of anchors and get our input field.  -FM
d9017 1
a9017 1
		 * Got it.  Make it submitting.  -FM
d9035 6
a9040 6
     * Append info on the current form to the HText object's list of
     * forms.
     * HText_beginInput call will have set some of the data in the
     * PerFormInfo structure (if there were any form fields at all),
     * we also fill in the ACCEPT-CHARSET data now (this could have
     * been done earlier).  - kw
d9066 5
a9070 4
void HText_beginSelect(char *name,
		       int name_cs,
		       BOOLEAN multiple,
		       char *size)
d9073 1
a9073 1
     * Save the group name.
d9079 1
a9079 1
     * If multiple then all options are actually checkboxes.
d9084 1
a9084 1
     * If not multiple then all options are radio buttons.
d9090 1
a9090 1
     * Length of an option list.
d9094 10
a9103 10
    CTRACE((tfp, "HText_beginSelect: name=%s type=%d size=%s\n",
	    ((HTCurSelectGroup == NULL) ?
	     "<NULL>" : HTCurSelectGroup),
	    HTCurSelectGroupType,
	    ((HTCurSelectGroupSize == NULL) ?
	     "<NULL>" : HTCurSelectGroupSize)));
    CTRACE((tfp, "HText_beginSelect: name_cs=%d \"%s\"\n",
	    HTCurSelectGroupCharset,
	    (HTCurSelectGroupCharset >= 0 ?
	     LYCharSet_UC[HTCurSelectGroupCharset].MIMEname : "<UNKNOWN>")));
d9107 6
a9112 5
 *  This function returns the number of the option whose
 *  value currently is being accumulated for a select
 *  block. - LE && FM
 */
int HText_getOptionNum(HText *text)
d9116 1
a9116 1
    int n = 1;			/* start count at 1 */
d9119 1
a9119 1
	return (0);
d9124 1
a9124 1
	return (0);
d9129 1
a9129 1
    return (n);
d9133 8
a9140 7
 *  This function checks for a numbered option pattern
 *  as the prefix for an option value.  If present, and
 *  we are in the correct keypad mode, it returns a
 *  pointer to the actual value, following that prefix.
 *  Otherwise, it returns the original pointer.
 */
static char *HText_skipOptionNumPrefix(char *opname)
d9143 1
a9143 1
     * Check if we are in the correct keypad mode.
d9147 6
a9152 6
	 * Skip the option number embedded in the option name so the
	 * extra chars won't mess up cgi scripts processing the value.
	 * The format is (nnn)__ where nnn is a number and there is a
	 * minimum of 5 chars (no underscores if (nnn) exceeds 5 chars).
	 * See HTML.c.  If the chars don't exactly match this format,
	 * just use all of opname.  - LE
d9169 1
a9169 1
		if (i < 5) {
d9178 1
a9178 1
	return (cp);
d9181 1
a9181 1
    return (opname);
d9185 12
a9196 10
 *  We couldn't set the value field for the previous option
 *  tag so we have to do it now.  Assume that the last anchor
 *  was the previous options tag.
 */
char *HText_setLastOptionValue(HText *text, char *value,
			       char *submit_value,
			       int order,
			       BOOLEAN checked,
			       int val_cs,
			       int submit_val_cs)
d9204 3
a9206 3
	  && text
	  && text->last_anchor
	  && text->last_anchor->link_type == INPUT_ANCHOR)) {
d9208 1
a9208 1
		(value ? value : "<NULL>")));
d9212 2
a9213 3
    CTRACE((tfp,
	    "Entering HText_setLastOptionValue: value:\"%s\", checked:%s\n",
	    value, (checked ? "on" : "off")));
d9216 1
a9216 1
     * Strip end spaces, newline is also whitespace.
d9219 1
a9219 1
	cp = &value[strlen(value) - 1];
d9223 1
a9223 1
	*(cp + 1) = '\0';
d9227 1
a9227 1
     * Find first non space
d9237 2
a9238 2
	 * Collapse any space between the popup option
	 * prefix and actual value.  -FM
d9258 1
a9258 1
	 * Put the text on the screen as well.
d9268 1
a9268 1
	 * Put the text on the screen as well.
d9274 1
a9274 1
	 * Create a linked list of option values.
d9276 2
a9277 2
	OptionType *op_ptr = text->last_anchor->input_field->select_list;
	OptionType *new_ptr = NULL;
d9281 1
a9281 1
	 * Deal with newlines or tabs.
d9287 1
a9287 1
	     * No option items yet.
d9290 2
a9291 3
		CTRACE((tfp,
			"HText_setLastOptionValue: last input_field not F_OPTION_LIST_TYPE (%d)\n",
			F_OPTION_LIST_TYPE));
d9293 1
a9293 1
			text->last_anchor->input_field->type));
d9298 1
a9298 1
		typecalloc(OptionType);
d9308 1
a9308 1
	    number++;		/* add one more */
d9319 2
a9320 2
	 * Find first non-space again, convert_to_spaces above may have
	 * changed the string.  - kw
d9338 1
a9338 1
		(tmp = typecallocn(unsigned char, strlen(cp) + 1)) != 0) {
d9342 1
a9342 1
		    TO_EUC((unsigned char *) cp, tmp);
d9345 1
a9345 1
		    TO_SJIS((unsigned char *) cp, tmp);
d9354 1
a9354 1
		StrAllocCopy(new_ptr->name, (const char *) tmp);
d9371 4
a9374 4
	     * If this is the first option in a popup select list,
	     * HText_beginInput may have allocated the value and
	     * cp_submit_value fields, so free them now to avoid
	     * a memory leak.  - kw
d9379 3
a9381 3
	    last_input->value = last_input->select_list->name;
	    last_input->orig_value = last_input->select_list->name;
	    last_input->cp_submit_value = last_input->select_list->cp_submit_value;
d9383 1
a9383 1
	    last_input->value_cs = new_ptr->value_cs;
d9386 5
a9390 8
	    int curlen = (HTCurSelectedOptionValue
			  ? strlen(HTCurSelectedOptionValue)
			  : 0);

	    /*
	     * Make the selected Option Value as long as
	     * the longest option.
	     */
d9393 1
a9393 1
			    UNDERSCORES(newlen - curlen));
a9399 1

d9401 1
a9401 1
	     * Set the default option as this one.
d9403 4
a9406 4
	    last_input->num_value = number;
	    last_input->value = new_ptr->name;
	    last_input->orig_value = new_ptr->name;
	    last_input->cp_submit_value = new_ptr->cp_submit_value;
d9408 1
a9408 1
	    last_input->value_cs = new_ptr->value_cs;
d9412 1
a9412 1
			    UNDERSCORES(newlen - curlen));
d9416 1
a9416 1
	 * Return the selected Option value to be sent to the screen.
d9420 1
a9420 1
	     * Change the value.
d9423 1
a9423 1
		strlen(HTCurSelectedOptionValue);
d9432 4
a9435 4
	CTRACE((tfp, "            val_cs=%d \"%s\"",
		val_cs,
		(val_cs >= 0 ?
		 LYCharSet_UC[val_cs].MIMEname : "<UNKNOWN>")));
d9442 1
a9442 1
		    "(ignored)" : "",
d9444 3
a9446 2
	} else {
	    CTRACE((tfp, "\n"));
d9449 1
a9449 1
    return (ret_Value);
d9453 3
a9455 3
 * Assign a form input anchor.
 * Returns the number of characters to leave
 * blank so that the input field can fit.
d9457 4
a9460 2
int HText_beginInput(HText *text, BOOL underline,
		     InputFieldData * I)
d9462 2
a9463 2
    TextAnchor *a;
    FormInfo *f;
a9474 1

d9484 5
a9488 5
     * If this is a radio button, or an OPTION we're converting
     * to a radio button, and it's the first with this name, make
     * sure it's checked by default.  Otherwise, if it's checked,
     * uncheck the default or any preceding radio button with this
     * name that was checked.  -FM
d9490 1
a9490 1
    if (I->type != NULL && !strcmp(I->type, "OPTION") &&
d9500 1
a9500 1
	    TextAnchor *b;
a9501 1

d9517 1
a9517 1
		I->checked = TRUE;
d9539 1
a9539 1
     * Set the no_cache flag if the METHOD is POST.  -FM
d9545 1
a9545 1
     * Set up VALUE.
d9552 1
a9552 1
		TO_EUC((unsigned char *) IValue, tmp);
d9555 1
a9555 1
		TO_SJIS((unsigned char *) IValue, tmp);
d9559 1
a9559 1
		    if (IValue[i] != CH_ESC) {	/* S/390 -- gil -- 1621 */
d9564 1
a9564 1
	    StrAllocCopy(IValue, (const char *) tmp);
d9570 2
a9571 2
     * Special case of OPTION.
     * Is handled above if radio type and LYSelectPopups is FALSE.
d9574 1
a9574 1
    if (I->type != NULL && !strcmp(I->type, "OPTION")) {
d9584 4
a9587 4
	 * The option's size parameter actually gives the length and not
	 * the width of the list.  Perform the conversion here
	 * and get rid of the allocated HTCurSelect....
	 * 0 is ok as it means any length (arbitrary decision).
d9596 1
a9596 1
     * Set SIZE.
d9601 1
a9601 1
	 * Leave at zero for option lists.
d9604 1
a9604 1
	    f->size = 20;	/* default */
d9607 1
a9607 1
	f->size = 20;		/* default */
d9611 1
a9611 1
     * Set MAXLENGTH.
d9616 1
a9616 1
	f->maxlength = 0;	/* 0 means infinite */
d9620 2
a9621 2
     * Set CHECKED
     * (num_value is only relevant to check and radio types).
d9629 1
a9629 1
     * Set TYPE.
d9632 1
a9632 1
	if (!strcasecomp(I->type, "password")) {
d9634 1
a9634 1
	} else if (!strcasecomp(I->type, "checkbox")) {
d9636 1
a9636 1
	} else if (!strcasecomp(I->type, "radio")) {
d9638 1
a9638 1
	} else if (!strcasecomp(I->type, "submit")) {
d9640 1
a9640 1
	} else if (!strcasecomp(I->type, "image")) {
d9642 1
a9642 1
	} else if (!strcasecomp(I->type, "reset")) {
d9644 1
a9644 1
	} else if (!strcasecomp(I->type, "OPTION_LIST")) {
d9646 1
a9646 1
	} else if (!strcasecomp(I->type, "hidden")) {
d9650 1
a9650 1
	} else if (!strcasecomp(I->type, "textarea")) {
d9652 1
a9652 1
	} else if (!strcasecomp(I->type, "range")) {
d9654 1
a9654 1
	} else if (!strcasecomp(I->type, "file")) {
d9657 1
a9657 1
	} else if (!strcasecomp(I->type, "keygen")) {
d9661 1
a9661 1
	     * Note that TYPE="scribble" defaults to TYPE="text".  -FM
d9663 1
a9663 1
	    f->type = F_TEXT_TYPE;	/* default */
d9670 1
a9670 1
     * Set NAME.
d9673 1
a9673 1
	StrAllocCopy(f->name, I->name);
d9680 1
a9680 1
	     * Set name to empty string.
d9685 1
a9685 1
	     * Error!  NAME must be present.
d9688 1
a9688 1
		    "GridText: No name present in input field; not displaying\n"));
d9690 1
a9690 1
	    return (0);
d9695 1
a9695 1
     * Add this anchor to the anchor list
d9704 2
a9705 2
     * Set VALUE, if it exists.  Otherwise, if it's not
     * an option list make it a zero-length string.  -FM
d9709 2
a9710 2
	 * OPTION VALUE is not actually the value to be seen but is to
	 * be sent....
d9715 2
a9716 2
	     * Fill both with the value.  The f->value may be
	     * overwritten in HText_setLastOptionValue....
d9727 2
a9728 2
	 * May be an empty INPUT field.  The text entered will then
	 * probably be in the current display character set.  - kw
d9734 1
a9734 1
     * Run checks and fill in necessary values.
d9763 1
a9763 1
	f->size = 3;
d9771 1
a9771 1
     * Set original values.
d9773 1
a9773 1
    if (f->type == F_RADIO_TYPE || f->type == F_CHECKBOX_TYPE) {
d9785 2
a9786 2
     * Store accept-charset if present, converting to lowercase
     * and collapsing spaces.  - kw
d9795 1
a9795 1
     * Add numbers to form fields if needed.  - LE & FM
d9799 2
a9800 2
	 * Do not supply number for hidden fields, nor
	 * for types that are not yet implemented.
d9802 1
a9802 1
    case F_HIDDEN_TYPE:
d9804 1
a9804 1
    case F_FILE_TYPE:
d9806 4
a9809 4
    case F_RANGE_TYPE:
    case F_KEYGEN_TYPE:
	a->number = 0;
	break;
d9811 6
a9816 6
    default:
	if (fields_are_numbered())
	    a->number = ++(text->last_anchor_number);
	else
	    a->number = 0;
	break;
d9819 1
a9819 1
	sprintf(marker, "[%d]", a->number);
d9836 1
a9836 1
     * Restrict SIZE to maximum allowable size.
d9841 27
a9867 27
    case F_SUBMIT_TYPE:
    case F_IMAGE_SUBMIT_TYPE:
    case F_RESET_TYPE:
    case F_TEXT_TYPE:
    case F_TEXTAREA_TYPE:
	/*
	 * For submit and reset buttons, and for text entry
	 * fields and areas, we limit the size element to that
	 * of one line for the current style because that's
	 * the most we could highlight on overwrites, and/or
	 * handle in the line editor.  The actual values for
	 * text entry lines can be long, and will be scrolled
	 * horizontally within the editing window.  -FM
	 */
	MaximumSize -= (1 +
			(int) text->style->leftIndent +
			(int) text->style->rightIndent);

	/*  If we are numbering form links, place is taken by [nn]  */
	if (fields_are_numbered()) {
	    if (!number_fields_on_left
		&& f->type == F_TEXT_TYPE
		&& MaximumSize > a->line_pos + 10)
		MaximumSize -= a->line_pos;
	    else
		MaximumSize -= strlen(marker);
	}
d9869 6
a9874 6
	/*
	 * Save value for submit/reset buttons so they
	 * will be visible when printing the page.  - LE
	 */
	I->value = f->value;
	break;
d9876 9
a9884 9
    default:
	/*
	 * For all other fields we limit the size element to
	 * 10 less than the screen width, because either they
	 * are types with small placeholders, and/or are a
	 * type which is handled via a popup window.  -FM
	 */
	MaximumSize -= 10;
	break;
d9890 1
a9890 1
     * Add this anchor to the anchor list
d9899 1
a9899 1
	HTCurrentForm->nfields++;	/* will count hidden fields - kw */
d9901 2
a9902 2
	 * Propagate form field's accept-charset attribute to enclosing
	 * form if the form itself didn't have an accept-charset - kw
d9915 3
a9917 3
	    f->name,
	    NonNull(f->value),
	    f->size));
d9919 6
a9924 6
	    f->name_cs,
	    (f->name_cs >= 0 ?
	     LYCharSet_UC[f->name_cs].MIMEname : "<UNKNOWN>"),
	    I->name_cs,
	    (I->name_cs >= 0 ?
	     LYCharSet_UC[I->name_cs].MIMEname : "<UNKNOWN>")));
d9926 6
a9931 6
	    f->value_cs,
	    (f->value_cs >= 0 ?
	     LYCharSet_UC[f->value_cs].MIMEname : "<UNKNOWN>"),
	    I->value_cs,
	    (I->value_cs >= 0 ?
	     LYCharSet_UC[I->value_cs].MIMEname : "<UNKNOWN>")));
d9934 1
a9934 1
     * Return the SIZE of the input field.
d9936 1
a9936 1
    return (f->size);
d9944 2
a9945 1
void HText_endInput(HText *text)
d9948 4
a9951 4
	&& !number_fields_on_left
	&& text != NULL
	&& text->last_anchor != NULL
	&& text->last_anchor->number > 0) {
a9952 1

d9954 1
a9954 1
	sprintf(marker, "[%d]", text->last_anchor->number);
d9960 6
a9965 6
 * Get a translation (properly:  transcoding) quality, factoring in
 * our ability to translate (an UCTQ_t) and a possible q parameter
 * on the given charset string, for cs_from -> givenmime.
 * The parsed input string will be mutilated on exit(!).
 * Note that results are not normalised to 1.0, but results from
 * different calls of this function can be compared.  - kw
d9967 2
a9968 2
 * Obsolete, it was planned to use here a quality parametr UCTQ_t,
 * which is boolean now.
d9970 3
a9972 2
static double get_trans_q(int cs_from,
			  char *givenmime)
a9976 1

d9979 1
a9979 1
    if ((p = strchr(givenmime, ';')) != NULL) {
a9991 1

d9996 1
a9996 1
		if (0 == strcasecomp(ptok, "q")) {
d10009 4
a10012 4
 * Find the best charset for submission, if we have an ACCEPT_CHARSET
 * list.  It factors in how well we can translate (just as guess, and
 * not a very good one..) and possible ";q=" factors.  Yes this is
 * more general than it needs to be here.
d10014 1
a10014 1
 * Input is cs_in and acceptstring.
d10016 9
a10024 8
 * Will return charset handle as int.
 * best_csname will point to a newly allocated MIME string for the
 * charset corresponding to the return value if return value >= 0.
 * - kw
 */
static int find_best_target_cs(char **best_csname,
			       int cs_from,
			       const char *acceptstring)
a10029 1

a10033 1

d10035 1
a10035 1
	    /* Get the Charset */
d10044 1
a10044 1
	if (!strcmp(bestmime, "*"))	/* non-standard for HTML attribute.. */
d10059 3
a10061 2
static void load_a_file(char *val_used,
			bstring **result)
d10081 1
a10081 1
static const char *guess_content_type(const char *filename)
d10085 1
a10085 2
    HTFormat format = HTFileFormat(filename, &encoding, &desc);

d10087 2
a10088 2
	? format->name
	: "text/plain";
d10092 4
a10095 2
static void cannot_transcode(BOOL *had_warning,
			     const char *target_csname)
d10100 1
a10100 1
		      target_csname ? target_csname : "UNKNOWN");
d10108 2
a10109 1
static unsigned check_form_specialchars(char *value)
d10115 1
a10115 1
	 non_empty(p) && (result != (SPECIAL_8BIT | SPECIAL_FORM));
d10132 3
a10134 2
static void UpdateBoundary(char **Boundary,
			   bstring *data)
d10144 1
a10144 1
	    && !memcmp(want, text + j, have)) {
a10145 1

d10158 3
a10160 2
static char *convert_to_base64(char *src,
			       int len)
d10165 1
a10165 1
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
d10168 1
a10168 1
    int rlen;			/* length of result string */
d10179 1
a10179 1
    rlen = (len + 2) / 3 * 4;	/* encoded bytes */
d10182 1
a10182 1
	rlen += ((rlen - 1) / B64_LINE + 1) * eollen;
d10192 2
a10193 2
    for (chunk = 0; len > 0; len -= 3, chunk++) {
	if (chunk == (B64_LINE / 4)) {
a10195 1

d10202 2
a10203 2
	*r++ = basis_64[c1 >> 2];
	*r++ = basis_64[((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4)];
d10206 1
a10206 1
	    *r++ = basis_64[((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6)];
d10211 1
a10211 1
	} else {		/* len == 1 */
a10219 1

d10229 4
a10232 4
    NO_QUOTE			/* no quoting needed */
    ,QUOTE_MULTI		/* multipart */
    ,QUOTE_BASE64		/* encode as base64 */
    ,QUOTE_SPECIAL		/* escape special characters only */
d10236 6
a10241 6
    int type;			/* the type of this field */
    BOOL first;			/* true if this begins a submission part */
    char *name;			/* the name of this field */
    char *value;		/* the nominal value of this field */
    bstring *data;		/* its data, which is usually the same as the value */
    QuoteData quote;		/* how to quote/translate the data */
d10244 4
a10247 3
static char *escape_or_quote_name(char *name,
				  QuoteData quoting,
				  char *MultipartContentType)
d10253 2
a10254 2
	StrAllocCopy(escaped1, name);
	break;
d10272 3
a10274 2
static char *escape_or_quote_value(char *value,
				   QuoteData quoting)
d10299 3
a10301 2
static int check_if_base64_needed(int submit_method,
				  bstring *data)
a10313 1

d10333 12
a10344 9
 * HText_SubmitForm - generate submit data from form fields.
 * For mailto forms, send the data.
 * For other methods, set fields in structure pointed to by doc
 * appropriately for next request.
 * Returns 1 if *doc set appropriately for next request,
 * 0 otherwise.  - kw
 */
int HText_SubmitForm(FormInfo * submit_item, DocInfo *doc, char *link_name,
		     char *link_value)
d10385 1
a10385 1
		form_number));
d10388 1
a10388 1
		thisform->number, form_number));
d10398 1
a10398 1
     * If we're mailing, make sure it's a mailto ACTION.  -FM
d10407 1
a10407 1
     * Check the ENCTYPE and set up the appropriate variables.  -FM
d10412 2
a10413 2
	 * Do not hex escape, and use physical newlines
	 * to separate name=value pairs.  -FM
d10420 2
a10421 2
	 * Use semicolons instead of ampersands as the
	 * separators for name=value pairs.  -FM
d10428 2
a10429 2
	 * Use the multipart MIME format.  Later we will ensure it does not
	 * occur within the content.
d10435 6
a10440 6
     * Determine in what character encoding (aka.  charset) we should
     * submit.  We call this target_cs and the MIME name for it
     * target_csname.
     * TODO:   - actually use ACCEPT-CHARSET stuff from FORM
     * TODO:   - deal with list in ACCEPT-CHARSET, find a "best"
     *           charset to submit
d10471 1
a10471 1
	    target_cs = UCLYhndl_for_unspec;	/* always >= 0 */
d10476 1
a10476 1
	target_cs = UCLYhndl_for_unspec;	/* always >= 0 */
d10490 1
a10490 1
	    !anchor_ptr->input_field->disabled) {
d10493 3
a10495 3
	    char *val = form_ptr->cp_submit_value != NULL
	    ? form_ptr->cp_submit_value
	    : form_ptr->value;
d10507 2
a10508 2
		       && (LYCharSet_UC[target_cs].enc == UCT_ENC_8859
			   || (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
d10515 2
a10516 2
		target_cs = form_ptr->value_cs;		/* try this */
		target_csname = NULL;	/* will be set after loop */
d10518 1
a10518 1
		target_cs = -1;	/* don't know what to do */
d10527 2
a10528 2
		       && (LYCharSet_UC[target_cs].enc == UCT_ENC_8859
			   || (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
d10535 2
a10536 2
		target_cs = form_ptr->value_cs;		/* try this */
		target_csname = NULL;	/* will be set after loop */
d10538 1
a10538 1
		target_cs = -1;	/* don't know what to do */
d10572 1
a10572 1
	 * Method is GET.  Clip out any anchor in the current URL.
d10574 1
a10574 1
	strtok(temp, "#");
d10576 1
a10576 1
	 * Clip out any old query in the current URL.
d10578 1
a10578 1
	strtok(temp, "?");
d10580 1
a10580 1
	 * Add the lead question mark for the new URL.
d10582 1
a10582 1
	StrAllocCat(temp, "?");
d10586 3
a10588 3
	 * We are submitting POST content to a server,
	 * so load content_type_out.  This will be put in
	 * the post_content_type element if all goes well.  -FM, kw
d10605 2
a10606 2
	 * If the ENCTYPE is not multipart/form-data, append the
	 * charset we'll be sending to the post_content_type, IF
d10610 1
a10610 1
	 *      AND it or target_csname is different from iso-8859-1,
d10614 6
a10619 6
	 *      AND target_cs is different from the currently effective
	 *      assumed charset (which should have been set by the user
	 *      so that it reflects what the server is sending, if the
	 *      document is rendered correctly).
	 * For multipart/form-data the equivalent will be done later,
	 * separately for each form field.  - kw
d10622 2
a10623 2
	    || ((form_is_special & SPECIAL_8BIT) != 0
		|| (form_is_special & SPECIAL_FORM) != 0)) {
d10654 1
a10654 1
	    !anchor_ptr->input_field->disabled) {
d10668 1
a10668 1
		    anchor_count + 1, anchor_limit));
d10672 1
a10672 1
	    switch (form_ptr->type) {
d10680 1
a10680 1
			val_used, name_used));
d10690 4
a10693 4
			    form_ptr->name ? form_ptr->name : "???",
			    link_name ? link_name : "???",
			    non_empty(form_ptr->name) ?
			    "not current link" : "no field name"));
d10697 2
a10698 2
		      (non_empty(form_ptr->value) &&
		       !strcmp(form_ptr->value, link_value)))) {
d10701 3
a10703 3
			    form_ptr->name ? form_ptr->name : "???",
			    link_name ? link_name : "???",
			    "values are different"));
d10734 8
a10741 8
			    NonNull(form_ptr->name),
			    form_ptr->value_cs,
			    form_ptr->value_cs >= 0
			    ? LYCharSet_UC[form_ptr->value_cs].MIMEname
			    : "???",
			    target_cs,
			    target_csname ? target_csname : "???",
			    success ? "OK" : "FAILED"));
d10745 1
a10745 1
		} else {	/* We can use the value directly. */
d10747 3
a10749 3
			    NonNull(form_ptr->name),
			    target_cs,
			    target_csname ? target_csname : "???"));
d10797 8
a10804 8
			    NonNull(form_ptr->name),
			    form_ptr->name_cs,
			    form_ptr->name_cs >= 0
			    ? LYCharSet_UC[form_ptr->name_cs].MIMEname
			    : "???",
			    target_cs,
			    target_csname ? target_csname : "???",
			    success ? "OK" : "FAILED"));
d10817 1
a10817 1
		} else {	/* We can use the name directly. */
d10819 3
a10821 3
			    NonNull(form_ptr->name),
			    target_cs,
			    target_csname ? target_csname : "???"));
d10832 10
a10841 10
		     * According to RFC 1867, Non-ASCII field names
		     * "should be encoded according to the prescriptions
		     * of RFC 1522 [...].  I don't think RFC 1522 actually
		     * is meant to apply to parameters like this, and it
		     * is unknown whether any server would make sense of
		     * it, so for now just use some quoting/escaping and
		     * otherwise leave 8-bit values as they are.
		     * Non-ASCII characters in form field names submitted
		     * as multipart/form-data can only occur if the form
		     * provider specifically asked for it anyway.  - kw
d10862 1
a10862 1
	    switch (form_ptr->type) {
d10878 4
a10881 4
		     !strcmp(form_ptr->name, link_name)) &&
		    (form_ptr->type == F_TEXT_SUBMIT_TYPE ||
		     (non_empty(form_ptr->value) &&
		      !strcmp(form_ptr->value, link_value)))) {
d10891 1
a10891 1
		 * Only add if selected.
d10928 2
a10929 2
		    && check_if_base64_needed(submit_item->submit_method,
					      my_data[anchor_count].data)) {
d10932 3
a10934 3
		    escaped2 =
			convert_to_base64(BStrData(my_data[anchor_count].data),
					  BStrLen(my_data[anchor_count].data));
d10971 1
a10971 1
		&& my_data[anchor_count].value != 0) {
d10973 1
a10973 2
		CTRACE((tfp,
			"processing [%d:%d] name=%s(first:%d, value=%s, data=%p)\n",
d11023 6
a11028 6
			  "%s%s%s%s%s",
			  escaped1,
			  (Boundary ? "" : "="),
			  (PlainText ? "\n" : ""),
			  escaped2,
			  ((PlainText && *escaped2) ? "\n" : ""));
d11040 6
a11045 6
			  "%s%s%s%s%s",
			  escaped1,
			  (Boundary ? "" : "="),
			  (PlainText ? "\n" : ""),
			  escaped2,
			  ((PlainText && *escaped2) ? "\n" : ""));
d11051 7
a11057 7
		 * If it has a non-zero length name (e.g., because
		 * its IMAGE_SUBMIT_TYPE is to be handled homologously
		 * to an image map, or a SUBMIT_TYPE in a set of
		 * multiple submit buttons, or a single type="text"
		 * that's been converted to a TEXT_SUBMIT_TYPE),
		 * include the name=value pair, or fake name.x=0 and
		 * name.y=0 pairs for IMAGE_SUBMIT_TYPE.  -FM
d11083 8
a11090 8
				  "%s.x=0%s%s.y=0%s",
				  escaped1,
				  (PlainText ?
				   "\n" : (SemiColon ?
					   ";" : "&")),
				  escaped1,
				  ((PlainText && *escaped1) ?
				   "\n" : ""));
d11098 6
a11103 6
			      "%s%s%s%s%s",
			      escaped1,
			      (Boundary ? "" : "="),
			      (PlainText ? "\n" : ""),
			      escaped2,
			      ((PlainText && *escaped2) ? "\n" : ""));
d11131 6
a11136 6
			      "%s%s%s%s%s",
			      escaped1,
			      (Boundary ? "" : "="),
			      (PlainText ? "\n" : ""),
			      escaped2,
			      ((PlainText && *escaped2) ? "\n" : ""));
a11142 1

d11172 1
a11172 2
		    HTSprintf(&escaped1, "; name=\"%s\"",
			      my_data[anchor_count].name);
d11177 1
a11177 2
			StrAllocCat(escaped1,
				    "\r\nContent-Transfer-Encoding: base64");
d11225 1
a11225 1
	mailform((submit_item->submit_action + 7),
d11227 2
a11228 2
		  ? NonNull(HText_getTitle())
		  : submit_item->submit_title),
d11240 1
a11240 1
	    doc->post_content_type = content_type_out;	/* don't free c_t_out */
d11243 2
a11244 2
	} else {		/* GET_METHOD */
	    HTSABCat(&my_query, "", 1);		/* append null */
d11267 1
a11267 1
void HText_DisableCurrentForm(void)
d11269 1
a11269 1
    TextAnchor *anchor_ptr;
d11276 1
a11276 1
     * Go through list of anchors and set the disabled flag.
d11291 2
a11292 1
void HText_ResetForm(FormInfo * form)
d11294 1
a11294 1
    TextAnchor *anchor_ptr;
d11301 1
a11301 1
     * Go through list of anchors and reset values.
d11320 1
a11320 1
			anchor_ptr->input_field->orig_value;
d11323 1
a11323 1
			anchor_ptr->input_field->orig_submit_value;
d11341 2
a11342 1
BOOLEAN HText_HaveUserChangedForms(HText *text)
d11344 1
a11344 1
    TextAnchor *anchor_ptr;
d11350 2
a11351 2
     * Go through list of anchors to check if any value was changed.
     * This code based on HText_ResetForm()
d11386 2
a11387 1
void HText_activateRadioButton(FormInfo * form)
d11389 1
a11389 1
    TextAnchor *anchor_ptr;
d11398 1
a11398 1
	    anchor_ptr->input_field->type == F_RADIO_TYPE) {
d11402 3
a11404 3
		/* if it has the same name and its on */
		if (!strcmp(anchor_ptr->input_field->name, form->name) &&
		    anchor_ptr->input_field->num_value) {
d11407 1
a11407 1
		}
d11409 1
a11409 1
		break;
d11413 1
a11413 1
    }
d11415 1
a11415 1
    form->num_value = 1;
d11429 1
a11429 1
static void free_all_texts(void)
d11437 1
a11437 1
     * Simply loop through the loaded texts list killing them off.
d11440 1
a11440 1
	if ((cur = (HText *) HTList_removeLastObject(loaded_texts)) != NULL) {
d11446 1
a11446 1
     * Get rid of the text list.
d11453 1
a11453 1
     * Insurance for bad HTML.
d11469 8
a11476 7
 *  stub_HTAnchor_address is like HTAnchor_address, but it returns the
 *  parent address for child links.  This is only useful for traversal's
 *  where one does not want to index a text file N times, once for each
 *  of N internal links.  Since the parent link has already been taken,
 *  it won't go again, hence the (incorrect) links won't cause problems.
 */
char *stub_HTAnchor_address(HTAnchor * me)
a11478 1

d11480 1
a11480 1
	StrAllocCopy(addr, me->parent->address);
d11484 2
a11485 1
void HText_setToolbar(HText *text)
d11492 2
a11493 1
BOOL HText_hasToolbar(HText *text)
d11498 2
a11499 1
void HText_setNoCache(HText *text)
d11506 2
a11507 1
BOOL HText_hasNoCacheSet(HText *text)
d11512 2
a11513 1
BOOL HText_hasUTF8OutputSet(HText *text)
d11519 13
a11531 11
 *  Check charset and set the kcode element. -FM
 *  Info on the input charset may be passed in in two forms,
 *  as a string (if given explicitly) and as a pointer to
 *  a LYUCcharset (from chartrans mechanism); either can be NULL.
 *  For Japanese the kcode will be reset at a space or explicit
 *  line or paragraph break, so what we set here may not last for
 *  long.  It's potentially more important not to set HTCJK to
 *  NOCJK unless we are sure. - kw
 */
void HText_setKcode(HText *text, const char *charset,
		    LYUCcharset *p_in)
d11539 2
a11540 2
     * Check whether we have some kind of info.  - kw
     */
d11546 2
a11547 2
     * If no explicit charset string, use the implied one.  - kw
     */
d11552 2
a11553 2
     * Check whether we have a specified charset.  -FM
     */
d11559 5
a11563 5
     * We've included the charset, and not forced a download offer,
     * only if the currently selected character set can handle it,
     * so check the charset value and set the text->kcode element
     * appropriately.  -FM
     */
d11565 4
a11568 4
     * p_in->MIMEname would be set as display charset.
     * So text->kcode sholud be set as SJIS or EUC here only if charset
     * is specified explicitely, otherwise text->kcode would cause
     * mishandling Japanese strings.  -- TH
d11571 3
a11573 2
		     !strcmp(charset, "x-sjis") ||	/* 1997/11/28 (Fri) 18:11:33 */
		     !strcmp(charset, "x-shift-jis"))) {
d11575 12
a11586 16
    } else if (explicit
#ifdef EXP_JAPANESEUTF8_SUPPORT
	       && strcmp(charset, "utf-8")
#endif
	       && ((p_in && (p_in->enc == UCT_ENC_CJK)) ||
		   !strcmp(charset, "x-euc") ||		/* 1997/11/28 (Fri) 18:11:24 */
		   !strcmp(charset, "euc-jp") ||
		   !strncmp(charset, "x-euc-", 6) ||
		   !strcmp(charset, "euc-kr") ||
		   !strcmp(charset, "iso-2022-kr") ||
		   !strcmp(charset, "big5") ||
		   !strcmp(charset, "cn-big5") ||
		   !strcmp(charset, "euc-cn") ||
		   !strcmp(charset, "gb2312") ||
		   !strncmp(charset, "cn-gb", 5) ||
		   !strcmp(charset, "iso-2022-cn"))) {
d11590 3
a11592 3
	 * If we get to here, it's not CJK, so disable that if
	 * it is enabled.  But only if we are quite sure.  -FM & kw
	 */
d11595 1
a11595 5
	    if (!p_in || ((p_in->enc != UCT_ENC_CJK)
#ifdef EXP_JAPANESEUTF8_SUPPORT
			  && (p_in->enc != UCT_ENC_UTF8)
#endif
		)) {
a11596 1
	    }
d11599 1
a11599 6

    if (explicit
#ifdef EXP_JAPANESEUTF8_SUPPORT
	&& strcmp(charset, "utf-8")
#endif
	) {
d11601 1
a11601 1
    } else {
d11614 4
a11617 3
 *  Set a permissible split at the current end of the last line. -FM
 */
void HText_setBreakPoint(HText *text)
d11623 1
a11623 1
     * Can split here.  -FM
d11631 15
a11645 14
 *  This function determines whether a document which
 *  would be sought via the a URL that has a fragment
 *  directive appended is otherwise identical to the
 *  currently loaded document, and if so, returns
 *  FALSE, so that any no_cache directives can be
 *  overridden "safely", on the grounds that we are
 *  simply acting on the equivalent of a paging
 *  command.  Otherwise, it returns TRUE, i.e, that
 *  the target document might differ from the current,
 *  based on any caching directives or analyses which
 *  claimed or suggested this. -FM
 */
BOOL HText_AreDifferent(HTParentAnchor *anchor,
			const char *full_address)
d11652 2
a11653 2
     * Do we have a loaded document and both
     * arguments for this function?
d11659 1
a11659 1
     * Do we have both URLs?
d11666 1
a11666 1
     * Do we have a fragment associated with the target?
d11672 3
a11674 3
     * Always treat client-side image map menus
     * as potentially stale, so we'll create a
     * fresh menu from the LynxMaps HTList.
d11680 1
a11680 1
     * Do the docs differ in the type of request?
d11686 3
a11688 3
     * Are the actual URLs different, after factoring
     * out a "LYNXIMGMAP:" leader in the MainText URL
     * and its fragment, if present?
d11691 2
a11692 2
		 ? MTanc->address + LEN_LYNXIMGMAP
		 : MTanc->address);
d11696 1
a11696 1
	return (TRUE);
d11701 2
a11702 2
     * If the MainText is not an image map menu,
     * do the docs have different POST contents?
d11709 1
a11709 1
		     * Both have contents, and they differ.
d11711 1
a11711 1
		    return (TRUE);
d11715 2
a11716 2
		 * The loaded document has content, but the
		 * target doesn't, so they're different.
d11718 1
a11718 1
		return (TRUE);
d11722 2
a11723 2
	     * The loaded document does not have content, but
	     * the target does, so they're different.
d11725 1
a11725 1
	    return (TRUE);
d11730 3
a11732 3
     * We'll assume the target is a position in the currently
     * displayed document, and thus can ignore any header, META,
     * or other directives not to use a cached rendition.  -FM
d11734 1
a11734 1
    return (FALSE);
d11741 5
a11745 5
 * Cleanup new lines coming into a TEXTAREA from an external editor, or a
 * file, such that they are in a suitable format for TEXTAREA rendering,
 * display, and manipulation.  That means trimming off trailing whitespace
 * from the line, expanding TABS into SPACES, and substituting a printable
 * character for control chars, and the like.
d11747 1
a11747 1
 * --KED 02/24/99
d11749 3
a11751 2
static void cleanup_line_for_textarea(char *line,
				      int len)
d11753 1
a11753 1
    char tbuf[MAX_LINE];
d11758 3
a11760 2
    int i;
    int n;
d11763 1
a11763 1
     * Whack off trailing whitespace from the line.
d11772 1
a11772 1
    if (strlen(line) != 0) {
d11774 1
a11774 1
	 * Expand any tab's, since they won't render properly in a TEXTAREA.
d11776 3
a11778 3
	 * [Is that "by spec", or just a "lynxism"?  As may be, it seems that
	 * such chars may cause other problems, too ...  with cursor movement,
	 * submit'ing, etc.  Probably needs looking into more deeply.]
d11784 5
a11788 5
	    if ((cp = strchr(p, '\t')) != 0) {
		i = cp - p;
		s = (strncpy(s, p, i)) + i;
		n = TABSTOP - (i % TABSTOP);
		s = (strncpy(s, SPACES, n)) + n;
d11793 1
a11793 1
		strcpy(s, p);
d11799 8
a11806 8
	 * Replace control chars with something printable.  Note that char
	 * substitution above 0x7f is dependent on the charset being used,
	 * and then only applies to the contiguous run of char values that
	 * are between 0x80, and the 1st real high-order-bit-set character,
	 * as specified by the charset.  In general (ie, for many character
	 * sets), that usually means the so-called "C1 control chars" that
	 * range from 0x80 thru 0x9f.  For EBCDIC machines, we only trim the
	 * (control) chars below a space (x'40').
d11808 2
a11809 2
	 * The assumption in all this is that the charset used in the editor,
	 * is compatible with the charset specified in lynx.
d11811 8
a11818 8
	 * [At some point in time, when/if lynx ever supports multibyte chars
	 * internally (eg, UCS-2, UCS-4, UTF-16, etc), this kind of thing may
	 * well cause problems.  But then, supporting such char sets will
	 * require massive changes in (most) all parts of the lynx code, so
	 * until then, we do the rational thing with char values that would
	 * otherwise foul the display, if left alone.  If you're implementing
	 * multibyte character set support, consider yourself to have been
	 * warned.]
d11822 2
a11823 2
	    *p = ((UCH(*s) < UCH(' ')) ||
		  (UCH(*s) == UCH('\177')) ||
d11827 1
a11827 1
		? (char) SPLAT : *s;
d11838 1
d11840 10
a11849 10
 * Re-render the text of a tagged ("[123]") HTLine (arg1), with the tag
 * number incremented by some value (arg5).  The re-rendered string may
 * be allowed to expand in the event of a tag width change (eg, 99 -> 100)
 * as controlled by arg6 (CHOP or NOCHOP).  Arg4 is either (the address
 * of) a value which must match, in order for the tag to be incremented,
 * or (the address of) a 0-value, which will match any value, and cause
 * any valid tag to be incremented.  Arg2 is a pointer to the first/only
 * anchor that exists on the line; we may need to adjust their position(s)
 * on the line.  Arg3 when non-0 indicates the number of new digits that
 * were added to the 2nd line in a line crossing pair.
d11851 2
a11852 2
 * All tags fields in a line which individually match an expected new value,
 * are incremented.  Line crossing [tags] are handled (PITA).
d11854 1
a11854 1
 * Untagged or improperly tagged lines are not altered.
d11856 2
a11857 2
 * Returns the number of chars added to the original string's length, if
 * any.
d11859 1
a11859 1
 * --KED 02/03/99
d11861 7
a11867 4
static int increment_tagged_htline(HTLine *ht, TextAnchor *a, int *lx_val,
				   int *old_val,
				   int incr,
				   int mode)
d11869 2
a11870 2
    char buf[MAX_LINE];
    char lxbuf[MAX_LINE * 2];
d11872 1
a11872 1
    TextAnchor *st_anchor = a;
d11875 3
a11877 3
    char *p = ht->data;
    char *s = buf;
    char *lx = lxbuf;
d11880 9
a11888 2
    BOOLEAN plx = FALSE;
    BOOLEAN valid;
d11890 10
a11899 16
    int val;
    int n;
    int new_n;
    int pre_n;
    int post_n;
    int fixup = 0;

    /*
     * Cleanup for the 2nd half of a line crosser, whose number of tag
     * digits grew by some number of places (usually 1 when it does
     * happen, though it *could* be more).  The tag chars were already
     * rendered into the 2nd line of the pair, but the positioning and
     * other effects haven't been rippled through any other anchors on
     * the (2nd) line.  So we do that here, as a special case, since
     * the part of the tag that's in the 2nd line of the pair, will not
     * be found by the tag string parsing code.  Double PITA.
d11901 1
a11901 1
     * [see comments below on line crosser caused problems]
d11909 1
a11909 1
	fixup = *lx_val;
d11911 1
a11911 2
	if (st_anchor)
	    st_anchor = st_anchor->next;
d11915 1
a11915 1
     * Walk thru the line looking for tags (ie, "[nnn]" strings).
d11917 2
a11918 2
    while (*p != '\0') {
	if (*p != '[') {
d11923 4
a11926 4
	    *s++ = *p++;
	    t = p;
	    n = 0;
	    valid = TRUE;	/* p = t = byte after '[' */
d11929 1
a11929 1
	     * Make sure there are only digits between "[" and "]".
d11931 2
a11932 2
	    while (*t != ']') {
		if (*t == '\0') {	/* uhoh - we have a potential line crosser */
d11934 1
a11934 1
		    plx = TRUE;
d11947 3
a11949 3
	     * If the format is OK, we check to see if the value is what
	     * we expect.  If not, we have a random [nn] string in the text,
	     * and leave it alone.
d11951 12
a11962 12
	     * [It is *possible* to have a false match here, *if* there are
	     * two identical [nn] strings (including the numeric value of
	     * nn), one of which is the [tag], and the other being part of
	     * a document.  In such a case, the 1st [nn] string will get
	     * incremented; the 2nd one won't, which makes it a 50-50 chance
	     * of being correct, if and when such an unlikely juxtaposition
	     * of text ever occurs.  Further validation tests of the [nnn]
	     * string are probably not possible, since little of the actual
	     * anchor-associated-text is retained in the TextAnchor or the
	     * FormInfo structs.  Fortunately, I think the current method is
	     * more than adequate to weed out 99.999% of any possible false
	     * matches, just as it stands.  Caveat emptor.]
d11965 2
a11966 2
		val = atoi(p);
		if ((val == *old_val) || (*old_val == 0)) {	/* 0 matches all */
d11970 2
a11971 2
		    sprintf(s, "%d", val);
		    new_n = strlen(s);
d11976 4
a11979 4
		     * If the number of digits in an existing [tag] increased
		     * (eg, [99] --> [100], etc), we need to "adjust" its
		     * horizontal position, and that of all subsequent tags
		     * that may be on the same line.  PITA.
d11981 11
a11991 11
		     * [This seems to work as long as a tag isn't a line
		     * crosser; when it is, the position of anchors on either
		     * side of the split tag, seem to "float" and try to be
		     * as "centered" as possible.  Which means that simply
		     * incrementing the line_pos by the fixed value of the
		     * number of digits that got added to some tag in either
		     * line doesn't work quite right, and the text for (say)
		     * a button may get stomped on by another copy of itself,
		     * but offset by a few chars, when it is selected (eg,
		     * "Box Office" may end up looking like "BoBox Office" or
		     * "Box Officece", etc.
d11993 2
a11994 2
		     * Dunno how to fix that behavior ATT, but at least the
		     * tag numbers themselves are correct.  -KED /\oo/\ ]
d11998 1
a11998 1
			while ((nxt_anchor) &&
d12003 1
a12003 2
			if (st_anchor)
			    st_anchor = st_anchor->next;
d12009 7
a12015 7
	     * Unfortunately, valid [tag] strings *can* be split across two
	     * lines.  Perhaps it would be best to just prevent that from
	     * happening, but a look into that code, makes me wonder.  Anyway,
	     * we can handle such tags without *too* much trouble in here [I
	     * think], though since such animals are rather rare, it makes it
	     * a bit difficult to test thoroughly (ie, Beyond here, there be
	     * Dragons).
d12017 1
a12017 1
	     * We use lxbuf[] to deal with the two lines involved.
d12019 1
a12019 1
	    pre_n = strlen(p);	/* count of 1st part chars in this line */
d12022 3
a12024 3
		&& (pre_n + post_n + 2 < (int) sizeof(lxbuf))) {
		strcpy(lx, p);	/* <- 1st part of a possible lx'ing tag */
		strcat(lx, ht->next->data);	/* tack on NEXT line          */
d12026 2
a12027 2
		t = lx;
		n = 0;
d12031 1
a12031 1
		 * Go hunting again for just digits, followed by tag end ']'.
d12044 4
a12047 4
		 * It *looks* like a line crosser; now we value test it to
		 * find out for sure [but see the "false match" warning,
		 * above], and if it matches, increment it into the buffer,
		 * along with the 2nd line's text.
d12050 3
a12052 3
		    && (n > 0)
		    && (n + post_n + 2) < MAX_LINE) {
		    val = atoi(lx);
d12057 3
a12059 3
			sprintf(lx, "%d", val);
			new_n = strlen(lx);
			strcat(lx, strchr(ht->next->data, ']'));
d12062 4
a12065 4
			 * We keep the the same number of chars from the
			 * adjusted tag number in the current line; any
			 * extra chars due to a digits increase, will be
			 * stuffed into the next line.
d12067 2
a12068 2
			 * Keep track of any digits added, for the next
			 * pass through.
d12070 1
a12070 1
			s = strncpy(s, lx, pre_n) + pre_n;
d12072 1
a12072 1
			strcpy(ht->next->data, lx);
d12077 1
a12077 1
		break;		/* had an lx'er, so we're done with this line */
d12084 1
a12084 1
    n = strlen(ht->data);
d12089 1
a12089 2
	HTLine *temp;

d12098 1
a12098 1
	memcpy(temp->styles, ht->styles, sizeof(HTStyleChange) * ht->numstyles);
d12104 1
a12104 1
    strcpy(ht->data, buf);
d12106 1
a12106 1
    return (strlen(buf) - n + fixup);
d12109 1
d12111 3
a12113 3
 * Creates a new anchor and associated struct's appropriate for a form
 * TEXTAREA, and links them into the lists following the current anchor
 * position (as specified by arg1).
d12115 2
a12116 2
 * Exits with arg1 now pointing at the new TextAnchor, and arg2 pointing
 * at the new, associated HTLine.
d12118 1
a12118 1
 * --KED 02/13/99
d12120 3
a12122 1
static void insert_new_textarea_anchor(TextAnchor **curr_anchor, HTLine **exit_htline)
d12125 1
a12125 1
    HTLine *htline;
d12128 2
a12129 2
    FormInfo *f = 0;
    HTLine *l = 0;
d12131 2
a12132 2
    int curr_tag = 0;		/* 0 ==> match any [tag] number */
    int lx = 0;			/* 0 ==> no line crossing [tag]; it's a new line */
d12135 1
d12137 2
a12138 2
     * Find line in the text that matches ending anchorline of
     * the TEXTAREA.
d12140 5
a12144 5
     * [Yes, Virginia ...  we *do* have to go thru this for each
     * anchor being added, since there is NOT a 1-to-1 mapping
     * between anchors and htlines.  I suppose we could create
     * YAS (Yet Another Struct), but there are too many structs{}
     * floating around in here, as it is.  IMNSHO.]
d12147 1
a12147 1
	 anchor->line_num != i; i++) {
d12154 2
a12155 2
     * Clone and initialize the struct's needed to add a new TEXTAREA
     * anchor.
a12158 1

d12165 5
a12169 5
    a->next = anchor->next;
    a->number = anchor->number;
    a->line_pos = anchor->line_pos;
    a->extent = anchor->extent;
    a->line_num = anchor->line_num + 1;
d12171 6
a12176 6
    a->link_type = anchor->link_type;
    a->input_field = f;
    a->show_anchor = anchor->show_anchor;
    a->inUnderline = anchor->inUnderline;
    a->expansion_anch = TRUE;
    a->anchor = NULL;
d12180 9
a12188 9
    StrAllocCopy(f->name, anchor->input_field->name);
    f->number = anchor->input_field->number;
    f->type = anchor->input_field->type;
    StrAllocCopy(f->orig_value, "");
    f->size = anchor->input_field->size;
    f->maxlength = anchor->input_field->maxlength;
    f->no_cache = anchor->input_field->no_cache;
    f->disabled = anchor->input_field->disabled;
    f->value_cs = current_char_set;	/* use current setting - kw */
d12191 4
a12194 4
    l->next = htline->next;
    l->prev = htline;
    l->offset = htline->offset;
    l->size = htline->size;
d12197 2
a12198 2
    l->numstyles = htline->numstyles;
    /*we fork the pointers! */
d12201 1
a12201 1
    strcpy(l->data, htline->data);
d12204 1
a12204 1
     * Link in the new HTLine.
d12207 1
a12207 1
    htline->next = l;
d12211 1
a12211 1
	increment_tagged_htline(l, a, &lx, &curr_tag, 1, CHOP);
d12215 2
a12216 2
     * If we're at the tail end of the TextAnchor or HTLine list(s),
     * the new node becomes the last node.
d12224 2
a12225 2
     * Link in the new TextAnchor and point the entry anchor arg at it;
     * point the entry HTLine arg at it, too.
d12228 1
a12228 1
    *curr_anchor = a;
d12230 1
a12230 1
    *exit_htline = l->next;
d12235 1
d12237 2
a12238 2
 * If new anchors were added to expand a TEXTAREA, we need to ripple the
 * new line numbers [and char counts ?] thru the subsequent anchors.
d12240 2
a12241 2
 * If form lines are getting [nnn] tagged, we need to update the displayed
 * tag values to match (which means rerendering them ...  sigh).
d12243 1
a12243 1
 * Finally, we need to update various HTMainText and other counts, etc.
d12245 2
a12246 2
 * [dunno if the char counts really *need* to be done, or if we're using
 * the exactly proper values/algorithms ...  seems to be OK though ...]
d12248 1
a12248 1
 * --KED 02/13/99
d12250 5
a12254 4
static void update_subsequent_anchors(int newlines,
				      TextAnchor *start_anchor,
				      HTLine *start_htline,
				      int start_tag)
d12257 7
a12263 1
    HTLine *htline = start_htline;
a12264 5
    int line_adj = 0;
    int tag_adj = 0;
    int lx = 0;
    int hang = 0;		/* for HANG detection of a nasty intermittent */
    int hang_detect = 100000;	/* ditto */
d12269 1
a12269 1
     * Update numeric fields of the rest of the anchors.
d12271 4
a12274 4
     * [We bypass bumping ->number if it has a value of 0, which takes care
     * of the ->input_field->type == F_HIDDEN_TYPE (as well as any other
     * "hidden" anchors, if such things exist).  Seems like the "right
     * thing" to do.  I think.]
d12276 1
a12276 1
    anchor = start_anchor->next;	/* begin updating with the NEXT anchor */
d12281 1
a12281 1
	anchor->line_num += newlines;
d12286 1
a12286 1
     * Update/rerender anchor [tags], if they are being numbered.
d12288 6
a12293 6
     * [If a number tag (eg, "[177]") is itself broken across a line
     * boundary, this fixup only partially works.  While the tag
     * numbering is done properly across the pair of lines, the
     * horizontal positioning on *either* side of the split, can get
     * out of sync by a char or two when it gets selected.  See the
     * [comments] in increment_tagged_htline() for some more detail.
d12295 3
a12297 3
     * I suppose THE fix is to prevent such tag-breaking in the first
     * place (dunno where yet, though).  Ah well ...  at least the tag
     * numbers themselves are correct from top to bottom now.
d12299 7
a12305 7
     * All that said, about the only time this will be a problem in
     * *practice*, is when a page has near 1000 links or more (possibly
     * after a TEXTAREA expansion), and has line crossing tag(s), and
     * the tag numbers in a line crosser go from initially all 3 digit
     * numbers, to some mix of 3 and 4 digits (or all 4 digits) as a
     * result of the expansion process.  Oh, you also need a "clump" of
     * anchors all on the same lines.
d12307 2
a12308 2
     * Yes, it *can* happen, but in real life, it probably won't be
     * seen very much ...]
d12310 4
a12313 4
     * [This may also be an artifact of bumping into the right hand
     * screen edge (or RHS margin), since we don't even *think* about
     * relocating an anchor to the following line, when [tag] digits
     * expansion pushes things too far in that direction.]
d12349 3
a12351 3
		line_adj = increment_tagged_htline(htline, anchor, &lx,
						   &start_tag, newlines,
						   NOCHOP);
d12353 1
a12353 1
		tag_adj += line_adj;
d12357 1
a12357 1
		break;		/* out of anchors ... we're done */
d12364 1
a12364 1
  finish:
d12366 1
a12366 1
     * Fixup various global variables.
d12368 2
a12369 2
    nlinks += newlines;
    HTMainText->Lines += newlines;
d12378 1
a12378 1
  hang_detected:		/* ugliness has happened; inform user and do the best we can */
d12384 1
d12386 4
a12389 4
 * Transfer the initial contents of a TEXTAREA to a temp file, invoke the
 * user's editor on that file, then transfer the contents of the resultant
 * edited file back into the TEXTAREA (expanding the size of the area, if
 * required).
d12391 3
a12393 3
 * Returns the number of lines that the cursor should be moved so that it
 * will end up on the 1st blank line of whatever number of trailing blank
 * lines there are in the TEXTAREA (there will *always* be at least one).
d12395 1
a12395 1
 * --KED 02/01/99
d12397 2
a12398 1
int HText_ExtEditForm(LinkInfo * form_link)
d12401 1
a12401 1
    size_t size;
d12403 2
a12404 2
    char *ed_temp;
    FILE *fp;
d12407 3
a12409 3
    TextAnchor *start_anchor = NULL;
    TextAnchor *end_anchor = NULL;
    BOOLEAN firstanchor = TRUE;
d12412 23
a12434 23
    char ed_offset[10];
    int start_line = 0;
    int entry_line = form_link->anchor_line_num;
    int exit_line = 0;
    int orig_cnt = 0;
    int line_cnt = 1;

    FormInfo *form = form_link->l_form;
    char *areaname = form->name;
    int form_num = form->number;

    HTLine *htline = NULL;

    char *ebuf;
    char *line;
    char *lp;
    char *cp;
    int match_tag = 0;
    int newlines = 0;
    int len, len0, len_in;
    int wanted_fieldlen_wrap = -1;	/* not yet asked; 0 means don't. */
    char *skip_at = NULL;
    int skip_num = 0, i;
d12438 2
a12439 2
    ed_temp = (char *) malloc(LY_MAXPATH);
    if ((fp = LYOpenTemp(ed_temp, "", "w")) == 0) {
d12445 2
a12446 2
     * Begin at the beginning, to find 1st anchor in the TEXTAREA, then
     * write all of its lines (anchors) out to the edit temp file.
d12448 7
a12454 7
     * [Finding the TEXTAREA we're actually *in* with these attributes
     * isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     * and there *could* be TEXTAREA's with the same "name".  If that
     * should ever be true, we'll actually get the data from the *1st*
     * TEXTAREA in the page that matches.  We should probably assign
     * a unique id to each TEXTAREA in a page, and match on that, to
     * avoid this (potential) problem.
d12456 3
a12458 3
     * Since the odds of "false matches" *actually* happening in real
     * life seem rather small though, we'll hold off doing this, for a
     * rainy day ...]
d12464 4
a12467 4
	if ((anchor_ptr->link_type == INPUT_ANCHOR) &&
	    (anchor_ptr->input_field->type == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num) &&
	    !strcmp(anchor_ptr->input_field->name, areaname)) {
d12470 1
a12470 1
		firstanchor = FALSE;
d12472 1
a12472 1
		start_line = anchor_ptr->line_num;
d12477 1
a12477 1
	     * Write the anchors' text to the temp edit file.
d12479 2
a12480 2
	    fputs(anchor_ptr->input_field->value, fp);
	    fputc('\n', fp);
d12482 1
a12482 1
	} else {
d12486 2
a12487 2
	}
	anchor_ptr = anchor_ptr->next;
d12489 1
a12489 1
    LYCloseTempFP(fp);
d12495 3
a12497 3
     * Go edit the TEXTAREA temp file, with the initial editor line
     * corresponding to the TEXTAREA line the cursor is on (if such
     * positioning is supported by the editor [as lynx knows it]).
d12499 1
a12499 1
    ed_offset[0] = 0;		/* pre-ANSI compilers don't initialize aggregates - TD */
d12501 1
a12501 1
	sprintf(ed_offset, "%d", ((entry_line - start_line) + 1));
d12508 1
a12508 1
     * Read back the edited temp file into our buffer.
d12510 2
a12511 2
    if ((stat(ed_temp, &stat_info) < 0) ||
	!S_ISREG(stat_info.st_mode) ||
d12514 1
a12514 2
	ebuf = typecalloc(char);

a12518 1

d12521 4
a12524 4
	     * This could be huge - don't exit if we don't have enough
	     * memory for it.  With some luck, the user may be even able
	     * to recover the file manually from the temp space while
	     * the lynx session is not over.  - kw
d12531 3
a12533 3
	fp = fopen(ed_temp, "r");
	size = fread(ebuf, 1, size, fp);
	LYCloseInput(fp);
d12538 1
a12538 1
     * Nuke any blank lines from the end of the edited data.
d12541 1
a12541 1
	   && (CanTrimTextArea(UCH(ebuf[size - 1])) || (ebuf[size - 1] == '\0')))
d12545 3
a12547 3
     * Copy each line from the temp file into the corresponding anchor
     * struct.  Add new lines to the TEXTAREA if needed.  (Always leave
     * the user with a blank line at the end of the TEXTAREA.)
d12549 1
a12549 1
    if ((line = (char *) malloc(MAX_LINE)) == 0)
d12558 1
a12558 1
    lp = ebuf;
d12574 2
a12575 2
	if ((cp = strchr(lp, '\n')) != 0)
	    len = len_in = cp - lp;
d12577 2
a12578 1
	    len = len_in = strlen(lp);
d12581 1
a12581 1
	    len0 + len >= start_anchor->input_field->size &&
d12583 1
a12583 1
	    (cp - lp) < start_anchor->input_field->size - 1) {
d12593 3
a12595 3
	if (wanted_fieldlen_wrap > 0 && len0 + len > wanted_fieldlen_wrap) {
	    for (i = wanted_fieldlen_wrap - len0;
		 i + len0 >= wanted_fieldlen_wrap / 4; i--) {
d12607 1
a12607 1
			       (cp - lp) <= len + (3 * wanted_fieldlen_wrap / 4))
d12615 1
a12615 1
			    while (isspace(UCH(*(cp - 1)))) {
d12626 3
a12628 3
	if (wanted_fieldlen_wrap > 0 && len0 + len > wanted_fieldlen_wrap) {
	    i = len - 1;
	    while (len0 + i + 1 > wanted_fieldlen_wrap &&
d12631 1
a12631 1
	    if (len0 + i + 1 > wanted_fieldlen_wrap)
d12635 1
a12635 1
	if (len0 + len >= MAX_LINE) {
d12642 1
a12642 1
	     * First try to find a space character for wrapping - kw
d12650 1
a12650 1
	    if (len0 + len >= MAX_LINE)
d12654 2
a12655 2
	strncat(line, lp, len);
	*(line + len0 + len) = '\0';
d12657 1
a12657 1
	cleanup_line_for_textarea(line, len0 + len);
d12660 3
a12662 3
	 * If there are more lines in the edit buffer than were in the
	 * original TEXTAREA, we need to add a new line/anchor, continuing
	 * on until the edit buffer is empty.
d12665 2
a12666 2
	    insert_new_textarea_anchor(&end_anchor, &htline);
	    anchor_ptr = end_anchor;	/* make the new anchor current */
d12671 1
a12671 1
	 * Finally copy the new line from the edit buffer into the anchor.
d12676 2
a12677 2
	 * Keep track of 1st blank line in any trailing blank lines, for
	 * later cursor repositioning.
d12679 1
a12679 1
	if (len0 + len > 0)
d12685 1
a12685 1
	 * And do the next line of edited text, for the next anchor ...
d12688 1
a12688 2
	if (*lp && isspace(UCH(*lp)))
	    lp++;
d12702 3
a12704 3
     * If we've added any new lines/anchors, we need to adjust various
     * things in all anchor-bearing lines following the last newly added
     * line/anchor.  The fun stuff starts here ...
d12707 1
a12707 1
	update_subsequent_anchors(newlines, end_anchor, htline, match_tag);
d12710 1
a12710 1
     * Cleanup time.
d12714 1
a12714 1
    LYRemoveTemp(ed_temp);
d12720 4
a12723 4
     * Return the offset needed to move the cursor from its current
     * (on entry) line number, to the 1st blank line of the trailing
     * (group of) blank line(s), which is where we want to be.  Let
     * the caller deal with moving us there, however ...  :-) ...
d12728 1
d12730 2
a12731 2
 * Expand the size of a TEXTAREA by a fixed number of lines (as specified
 * by arg2).
d12733 1
a12733 1
 * --KED 02/14/99
d12735 3
a12737 1
void HText_ExpandTextarea(LinkInfo * form_link, int newlines)
d12740 2
a12741 2
    TextAnchor *end_anchor = NULL;
    BOOLEAN firstanchor = TRUE;
d12743 3
a12745 3
    FormInfo *form = form_link->l_form;
    char *areaname = form->name;
    int form_num = form->number;
d12747 4
a12750 1
    HTLine *htline = NULL;
a12751 2
    int match_tag = 0;
    int i;
d12755 1
a12755 2
    if (newlines < 1)
	return;
d12758 2
a12759 2
     * Begin at the beginning, to find the TEXTAREA, then on to find
     * the last line (anchor) in it.
d12761 7
a12767 7
     * [Finding the TEXTAREA we're actually *in* with these attributes
     * isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     * and there *could* be TEXTAREA's with the same "name".  If that
     * should ever be true, we'll actually expand the *1st* TEXTAREA
     * in the page that matches.  We should probably assign a unique
     * id to each TEXTAREA in a page, and match on that, to avoid this
     * (potential) problem.
d12769 3
a12771 3
     * Since the odds of "false matches" *actually* happening in real
     * life seem rather small though, we'll hold off doing this, for a
     * rainy day ...]
d12777 4
a12780 4
	if ((anchor_ptr->link_type == INPUT_ANCHOR) &&
	    (anchor_ptr->input_field->type == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num) &&
	    !strcmp(anchor_ptr->input_field->name, areaname)) {
d12787 1
a12787 1
	} else {
d12791 2
a12792 2
	}
	anchor_ptr = anchor_ptr->next;
d12796 1
a12796 1
	insert_new_textarea_anchor(&end_anchor, &htline);
d12799 1
a12799 1
	 * Make the new line blank.
d12804 1
a12804 1
	 * And go add another line ...
d12807 1
a12807 1
	    match_tag = end_anchor->next->number;
d12811 1
a12811 1
	    newlines, areaname));
d12814 2
a12815 2
     * We need to adjust various things in all anchor bearing lines
     * following the last newly added line/anchor.  Fun stuff.
d12817 1
a12817 1
    update_subsequent_anchors(newlines, end_anchor, htline, match_tag);
d12824 1
d12826 2
a12827 2
 * Insert the contents of a file into a TEXTAREA between the cursor line,
 * and the line preceding it.
d12829 3
a12831 3
 * Returns the number of lines that the cursor should be moved so that it
 * will end up on the 1st line in the TEXTAREA following the inserted file
 * (if we decide to do that).
d12833 1
a12833 1
 * --KED 02/21/99
d12835 2
a12836 1
int HText_InsertFile(LinkInfo * form_link)
d12839 1
a12839 1
    size_t size;
d12841 2
a12842 2
    FILE *fp;
    char *fn;
d12846 2
a12847 2
    TextAnchor *end_anchor = NULL;
    BOOLEAN firstanchor = TRUE;
d12850 3
a12852 3
    FormInfo *form = form_link->l_form;
    char *areaname = form->name;
    int form_num = form->number;
d12854 1
a12854 1
    HTLine *htline = NULL;
d12857 13
a12869 2
    FormInfo *f = 0;
    HTLine *l = 0;
a12870 10
    char *fbuf;
    char *line;
    char *lp;
    char *cp;
    int entry_line = form_link->anchor_line_num;
    int file_cs;
    int match_tag = 0;
    int newlines = 0;
    int len;
    int i;
d12878 2
a12879 3
	HTInfoMsg(FILE_INSERT_CANCELLED);
	CTRACE((tfp,
		"GridText: file insert cancelled - no filename provided\n"));
d12890 1
a12890 1
     * Read it into our buffer (abort on 0-length file).
d12892 1
a12892 1
    if ((stat(fn, &stat_info) < 0) ||
d12894 3
a12896 4
	HTInfoMsg(FILE_INSERT_0_LENGTH);
	CTRACE((tfp,
		"GridText: file insert aborted - file=|%s|- was 0-length\n",
		fn));
d12904 3
a12906 3
	     * This could be huge - don't exit if we don't have enough
	     * memory for it.  - kw
	     */
d12922 1
a12922 1
	fp = fopen(fn, "r");
d12929 2
a12930 2
	size = fread(fbuf, 1, size, fp);
	LYCloseInput(fp);
d12935 1
d12937 2
a12938 2
     * Begin at the beginning, to find the TEXTAREA we're in, then
     * the current cursorline.
d12940 7
a12946 7
     * [Finding the TEXTAREA we're actually *in* with these attributes
     * isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     * and there *could* be TEXTAREA's with the same "name".  If that
     * should ever be true, we'll actually insert data into the *1st*
     * TEXTAREA in the page that matches.  We should probably assign
     * a unique id to each TEXTAREA in a page, and match on that, to
     * avoid this (potential) problem.
d12948 3
a12950 3
     * Since the odds of "false matches" *actually* happening in real
     * life seem rather small though, we'll hold off doing this, for a
     * rainy day ...]
d12956 4
a12959 4
	if ((anchor_ptr->link_type == INPUT_ANCHOR) &&
	    (anchor_ptr->input_field->type == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num) &&
	    !strcmp(anchor_ptr->input_field->name, areaname)) {
d12961 2
a12962 2
	    if (anchor_ptr->line_num == entry_line)
		break;
d12965 1
a12965 1
	anchor_ptr = anchor_ptr->next;
d12968 1
d12970 2
a12971 2
     * Clone a new TEXTAREA line/anchor using the cursorline anchor as
     * a template, but link it in BEFORE the cursorline anchor/htline.
d12973 5
a12977 5
     * [We can probably combine this with insert_new_textarea_anchor()
     * along with a flag to indicate "insert before" as we do here,
     * or the "normal" mode of operation (add after "current" anchor/
     * line).  Beware of the differences ...  some are a bit subtle to
     * notice.]
d12980 1
a12980 1
	 anchor_ptr->line_num != i; i++) {
a12987 1

d12994 5
a12998 5
    a->next = anchor_ptr;
    a->number = anchor_ptr->number;
    a->line_pos = anchor_ptr->line_pos;
    a->extent = anchor_ptr->extent;
    a->line_num = anchor_ptr->line_num;
d13000 6
a13005 6
    a->link_type = anchor_ptr->link_type;
    a->input_field = f;
    a->show_anchor = anchor_ptr->show_anchor;
    a->inUnderline = anchor_ptr->inUnderline;
    a->expansion_anch = TRUE;
    a->anchor = NULL;
d13009 9
a13017 9
    StrAllocCopy(f->name, anchor_ptr->input_field->name);
    f->number = anchor_ptr->input_field->number;
    f->type = anchor_ptr->input_field->type;
    StrAllocCopy(f->orig_value, "");
    f->size = anchor_ptr->input_field->size;
    f->maxlength = anchor_ptr->input_field->maxlength;
    f->no_cache = anchor_ptr->input_field->no_cache;
    f->disabled = anchor_ptr->input_field->disabled;
    f->value_cs = (file_cs >= 0) ? file_cs : current_char_set;
d13020 2
a13021 2
    l->offset = htline->offset;
    l->size = htline->size;
d13024 2
a13025 2
    l->numstyles = htline->numstyles;
    /*we fork the pointers! */
d13028 1
a13028 1
    strcpy(l->data, htline->data);
d13031 2
a13032 2
     * If we're at the head of the TextAnchor list, the new node becomes
     * the first node.
d13038 1
a13038 1
     * Link in the new TextAnchor, and corresponding HTLine.
d13043 5
a13047 5
    htline = htline->prev;
    l->next = htline->next;
    l->prev = htline;
    htline->next->prev = l;
    htline->next = l;
d13050 3
a13052 3
     * update_subsequent_anchors() expects htline to point to 1st potential
     * line needing fixup; we need to do this just in case the inserted file
     * was only a single line (yes, it's pathological ...  ).
d13054 2
a13055 2
    htline = htline->next;	/* ->new (current) htline, for 1st inserted line  */
    htline = htline->next;	/* ->1st potential (following) [tag] fixup htline */
d13060 1
d13062 2
a13063 2
     * Copy each line from the insert file into the corresponding anchor
     * struct.
d13065 1
a13065 1
     * Begin with the new line/anchor we just added (above the cursorline).
d13067 1
a13067 1
    if ((line = (char *) malloc(MAX_LINE)) == 0)
d13073 1
a13073 1
    lp = fbuf;
d13077 2
a13078 2
	if ((cp = strchr(lp, '\n')) != 0)
	    len = cp - lp;
d13080 1
a13080 1
	    len = strlen(lp);
d13089 1
a13089 1
		lp[len + 1] = '\0';	/* prevent next iteration */
d13091 1
a13091 1
	strncpy(line, lp, len);
d13094 1
a13094 1
	cleanup_line_for_textarea(line, len);
d13097 2
a13098 2
	 * If not the first line from the insert file, we need to add
	 * a new line/anchor, continuing on until the buffer is empty.
d13101 3
a13103 3
	    insert_new_textarea_anchor(&end_anchor, &htline);
	    anchor_ptr = end_anchor;	/* make the new anchor current */
	    newlines++;
d13107 1
a13107 1
	 * Copy the new line from the buffer into the anchor.
d13112 2
a13113 2
	 * insert_new_textarea_anchor always uses current_char_set,
	 * we may want something else, so fix it up.  - kw
d13115 2
a13116 2
	if (file_cs >= 0)
	    anchor_ptr->input_field->value_cs = file_cs;
d13119 1
a13119 1
	 * And do the next line of insert text, for the next anchor ...
d13122 1
a13122 2
	if (*lp)
	    lp++;
d13125 2
a13126 2
	end_anchor = anchor_ptr;
	anchor_ptr = anchor_ptr->next;
d13132 2
a13133 2
     * Now adjust various things in all anchor-bearing lines following the
     * last newly added line/anchor.  Some say this is the fun part ...
d13135 1
a13135 1
    update_subsequent_anchors(newlines, end_anchor, htline, match_tag);
d13138 1
a13138 1
     * Cleanup time.
d13160 5
a13164 3
static void redraw_part_of_line(HTLine *line, char *str,
				int len,
				HText *text)
d13168 1
a13168 1
    char *data, *end_of_data;
a13169 1

d13174 1
a13174 1
    int YP, XP;
d13176 1
a13176 1
    LYGetYX(YP, XP);
d13187 2
a13188 2
    /* this assumes that the part of line to be drawn fits in the screen */
    while (data < end_of_data) {
d13196 4
a13199 3
	       i >= (int) (CStyle.horizpos + line->offset + 1)) {
	    LynxChangeStyle(CStyle.style, CStyle.direction);
	    current_style++;
d13205 8
a13212 8
	case LY_UNDERLINE_START_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		lynx_start_underline();
	    }
	    break;
d13214 8
a13221 8
	case LY_UNDERLINE_END_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		lynx_stop_underline();
	    }
	    break;
d13223 3
a13225 3
	case LY_BOLD_START_CHAR:
	    lynx_start_bold();
	    break;
d13227 3
a13229 3
	case LY_BOLD_END_CHAR:
	    lynx_stop_bold();
	    break;
d13232 28
a13259 4
	case LY_SOFT_NEWLINE:
	    if (!dump_output_immediately)
		LYaddch('+');
	    break;
d13261 1
a13261 20
	case LY_SOFT_HYPHEN:
	    if (*data != '\0' ||
		isspace(UCH(LastDisplayChar)) ||
		LastDisplayChar == '-') {
		/*
		 * Ignore the soft hyphen if it is not the last
		 * character in the line.  Also ignore it if it
		 * first character following the margin, or if it
		 * is preceded by a white character (we loaded 'M'
		 * into LastDisplayChar if it was a multibyte
		 * character) or hyphen, though it should have
		 * been excluded by HText_appendCharacter() or by
		 * split_line() in those cases.  -FM
		 */
		break;
	    } else {
		/*
		 * Make it a hard hyphen and fall through.  -FM
		 */
		buffer[0] = '-';
d13263 37
a13299 42
	    }
	    /* FALLTHRU */

	default:
	    i++;
	    if (text->T.output_utf8 && is8bits(buffer[0])) {
		utf_extra = utf8_length(text->T.output_utf8, data - 1);
		LastDisplayChar = 'M';
	    }
	    if (utf_extra) {
		strncpy(&buffer[1], data, utf_extra);
		buffer[utf_extra + 1] = '\0';
		LYaddstr(buffer);
		buffer[1] = '\0';
		data += utf_extra;
		utf_extra = 0;
	    } else if (HTCJK != NOCJK && is8bits(buffer[0])) {
		/*
		 * For CJK strings, by Masanobu Kimura.
		 */
		buffer[1] = *data;
		data++;
		LYaddstr(buffer);
		buffer[1] = '\0';
		/*
		 * For now, load 'M' into LastDisplayChar,
		 * but we should check whether it's white
		 * and if so, use ' '.  I don't know if
		 * there actually are white CJK characters,
		 * and we're loading ' ' for multibyte
		 * spacing characters in this code set,
		 * but this will become an issue when
		 * the development code set's multibyte
		 * character handling is used.  -FM
		 */
		LastDisplayChar = 'M';
	    } else {
		LYaddstr(buffer);
		LastDisplayChar = buffer[0];
	    }
	}			/* end of switch */
    }				/* end of while */
d13306 3
a13308 2
    while (current_style < line->numstyles) {
	LynxChangeStyle(CStyle.style, CStyle.direction);
d13320 14
a13333 14
 * Function move_to_glyph is called from LYMoveToLink and does all
 * the real work for it.
 * The pair LYMoveToLink()/move_to_glyph() is similar to the pair
 * redraw_lines_of_link()/redraw_part_of_line(), some key differences:
 * LYMoveToLink/move_to_glyph redraw_*
 * -----------------------------------------------------------------
 * - used without color style           - used with color style
 * - handles showing WHEREIS target     - WHEREIS handled elsewhere
 * - handles only one line              - handles first two lines for
 *                                        hypertext anchors
 * - right columns position for UTF-8
 *   by redrawing as necessary
 * - currently used for highlight       - currently used for highlight
 *   ON and OFF                         OFF
d13335 16
a13350 15
 * Eventually the two sets of function should be unified, and should handle
 * UTF-8 positioning, both lines of hypertext anchors, and WHEREIS in all
 * cases.  If possible.  The complex WHEREIS target logic in highlight()
 * could then be completely removed.  - kw
 */
static void move_to_glyph(int YP,
			  int XP,
			  int XP_draw_min,
			  char *data,
			  int datasize,
			  unsigned offset,
			  const char *target,
			  char *hightext,
			  int flags,
			  BOOL utf_flag)
a13355 1

d13358 1
a13358 1
    int i_start_tgt = 0, i_after_tgt;
d13369 1
a13369 1
    int len;
d13378 2
a13379 2
     * Add offset, making sure that we do not
     * go over the COLS limit on the display.
d13381 3
a13383 3
    i = (int) offset;
    if (i > (int) DISPLAY_COLS - 1)
	i = (int) DISPLAY_COLS - 1;
d13388 2
a13389 2
     * Scan through the data, making sure that we do not
     * go over the COLS limit on the display etc.
d13396 2
a13397 2
     * If the target overlaps with the part of this line that
     * we are drawing, it will be emphasized.
d13407 2
a13408 2
	    if ((int) offset + LenNeeded >= DISPLAY_COLS ||
		((int) offset + HitOffset >= XP + linkvlen)) {
d13420 1
d13422 5
a13426 5
     * Iterate through the line data from the start, keeping track of
     * the display ("glyph") position in i.  Drawing will be turned
     * on when either the first UTF-8 sequence (that occurs after
     * XP_draw_min) is found, or when we reach the link itself (if
     * highlight is non-NULL).  - kw
d13432 17
a13448 17
	    /*
	     * We reached the position of link itself, and hightext is
	     * non-NULL.  We switch data from being a pointer into the HTLine
	     * to being a pointer into hightext.  Normally (as long as this
	     * routine is applied to normal hyperlink anchors) the text in
	     * hightext will be identical to that part of the HTLine that
	     * data was already pointing to, except that special attribute
	     * chars LY_BOLD_START_CHAR etc.  have been stripped out (see
	     * HText_trimHightext).  So the switching should not result in
	     * any different display, but it ensures that it doesn't go
	     * unnoticed if somehow hightext got messed up somewhere else.
	     * This is also useful in preparation for using this function
	     * for something else than normal hyperlink anchors, i.e. form
	     * fields.
	     * Turn on drawing here or make sure it gets turned on before the
	     * next actual normal character is handled.  - kw
	     */
d13461 9
a13469 9
	     * The logic of where to set intarget drawingtarget etc.
	     * and when to react to it should be cleaned up (here and
	     * further below).  For now this seems to work but isn't
	     * very clear.  The complications arise from reproducing
	     * the behavior (previously done in LYhighlight()) for target
	     * strings that fall into or overlap a link:  use target
	     * emphasis for the target string, except for the first
	     * and last character of the anchor text if the anchor is
	     * highlighted as "current link".  - kw
d13479 2
a13480 3
			    if (inunderline)
				inU = YES;
			    lynx_start_link_color(flag, inU);
d13499 4
a13502 7
		    if (inunderline)
			inU = YES;
		    if (inunderline)
			lynx_stop_underline();
		    if (inbold)
			lynx_stop_bold();
		    lynx_start_link_color(flag, inU);
d13512 1
d13515 2
a13516 2
	 * Look for a subsequent occurrence of the target string,
	 * if we had a previous one and have now stepped past it.  - kw
d13553 1
a13553 1
				lynx_start_link_color(flag, inU);
d13557 2
a13558 4
			    if (inbold)
				lynx_start_bold();
			    if (inunderline)
				lynx_start_underline();
d13567 10
a13576 10
	 * Advance data to point to the next input char (for the
	 * next round).  Advance sdata, used for searching for a
	 * target string, so that they stays in synch.  As long
	 * as we are not within the highlight text, data and sdata
	 * have identical values.  After we have switched data to
	 * point into hightext, sdata remains a pointer into the
	 * HTLine (so that we don't miss a partial target match at
	 * the end of the anchor text).  So sdata has to sometimes
	 * skip additional special attribute characters that are
	 * not present in highlight in order to stay in synch.  - kw
d13580 3
a13582 4
	    do
		sdata++;
	    while (incurlink && *sdata && sdata != data &&
		   IsSpecialAttrChar(*(sdata - 1)));
d13587 11
a13597 6
	case LY_UNDERLINE_START_CHAR:
	    if (!drawing || !incurlink)
		inunderline = YES;
	    if (drawing && !intarget && !incurlink)
		lynx_start_underline();
	    break;
d13599 5
a13603 5
	case LY_UNDERLINE_END_CHAR:
	    inunderline = NO;
	    if (drawing && !intarget && !incurlink)
		lynx_stop_underline();
	    break;
d13605 5
a13609 6
	case LY_BOLD_START_CHAR:
	    if (!drawing || !incurlink)
		inbold = YES;
	    if (drawing && !intarget && !incurlink)
		lynx_start_bold();
	    break;
d13611 6
a13616 5
	case LY_BOLD_END_CHAR:
	    inbold = NO;
	    if (drawing && !intarget && !incurlink)
		lynx_stop_bold();
	    break;
d13618 22
a13639 6
	case LY_SOFT_NEWLINE:
	    if (drawing) {
		LYaddch('+');
	    }
	    i++;
	    break;
d13641 1
a13641 16
	case LY_SOFT_HYPHEN:
	    if (*data != '\0' ||
		isspace(UCH(LastDisplayChar)) ||
		LastDisplayChar == '-') {
		/*
		 * Ignore the soft hyphen if it is not the last
		 * character in the line.  Also ignore it if it
		 * first character following the margin, or if it
		 * is preceded by a white character (we loaded 'M'
		 * into LastDisplayChar if it was a multibyte
		 * character) or hyphen, though it should have
		 * been excluded by HText_appendCharacter() or by
		 * split_line() in those cases.  -FM
		 */
		break;
	    } else {
d13643 3
a13645 1
		 * Make it a hard hyphen and fall through.  -FM
a13646 10
		buffer[0] = '-';
	    }
	    /* FALLTHRU */

	default:
	    /*
	     * We have got an actual normal displayable character, or
	     * the start of one.  Before proceeding check whether
	     * drawing needs to be turned on now.  - kw
	     */
d13648 13
a13660 12
	    if (incurlink && intarget && flag && i_after_tgt > i) {
		if (i == XP - 1) {
		    i_after_tgt = i;
		} else if (i == XP - 2 && HTCJK != NOCJK &&
			   is8bits(buffer[0])) {
		    i_after_tgt = i;
		    cp_tgt = NULL;
		    if (drawing) {
			if (drawingtarget) {
			    LYstopTargetEmphasis();
			    drawingtarget = NO;
			    lynx_start_link_color(flag, inU);
d13664 29
a13692 18
	    }
	    if (cp_tgt && i >= i_start_tgt && sdata > cp_tgt) {
		if (!intarget ||
		    (intarget && incurlink && !drawingtarget)) {

		    if (incurlink && drawing &&
			!(flag &&
			  (i == XP_link || i == XP - 1))) {
			lynx_stop_link_color(flag, inU);
		    }
		    if (incurlink && !drawing) {
			LYmove(YP, i);
			if (inunderline)
			    inU = YES;
			if (flag && (i == XP_link || i == XP - 1)) {
			    lynx_start_link_color(flag, inU);
			    drawingtarget = NO;
			} else {
d13696 1
a13696 13
			drawing = YES;
		    } else if (incurlink && drawing &&
			       intarget && !drawingtarget &&
			       (flag &&
				(i == XP_link))) {
			if (inunderline)
			    inU = YES;
			lynx_start_link_color(flag, inU);
		    } else if (drawing &&
			       !(flag &&
				 (i == XP_link || (incurlink && i == XP - 1)))) {
			LYstartTargetEmphasis();
			drawingtarget = YES;
d13698 1
a13698 3
		    intarget = YES;
		}
	    } else
d13700 8
a13707 9
	    if (incurlink) {
		if (!drawing) {
		    LYmove(YP, i);
		    if (inunderline)
			inU = YES;
		    lynx_start_link_color(flag, inU);
		    drawing = YES;
		}
	    }
d13709 12
a13720 12
	    i++;
	    if (utf_flag && is8bits(buffer[0])) {
		hadutf8 = YES;
		utf_extra = utf8_length(utf_flag, data - 1);
		LastDisplayChar = 'M';
	    }
	    if (utf_extra) {
		strncpy(&buffer[1], data, utf_extra);
		buffer[utf_extra + 1] = '\0';
		if (!drawing && i >= XP_draw_min) {
		    LYmove(YP, i - 1);
		    drawing = YES;
d13722 4
a13725 4
		    if (intarget) {
			drawingtarget = YES;
			LYstartTargetEmphasis();
		    } else
d13727 6
a13732 5
		    {
			if (inbold)
			    lynx_start_bold();
			if (inunderline)
			    lynx_start_underline();
a13733 12
		}
		LYaddstr(buffer);
		buffer[1] = '\0';
		sdata += utf_extra;
		data += utf_extra;
		utf_extra = 0;
	    } else if (HTCJK != NOCJK && is8bits(buffer[0])) {
		/*
		 * For CJK strings, by Masanobu Kimura.
		 */
		if (drawing && (i < DISPLAY_COLS - 1)) {
		    buffer[1] = *data;
d13736 28
d13765 2
a13766 21
		i++;
		sdata++;
		data++;
		/*
		 * For now, load 'M' into LastDisplayChar, but we should
		 * check whether it's white and if so, use ' '.  I don't
		 * know if there actually are white CJK characters, and
		 * we're loading ' ' for multibyte spacing characters in
		 * this code set, but this will become an issue when the
		 * development code set's multibyte character handling is
		 * used.  -FM
		 */
		LastDisplayChar = 'M';
	    } else {
		if (drawing) {
		    LYaddstr(buffer);
		}
		LastDisplayChar = buffer[0];
	    }
	}			/* end of switch */
    }				/* end of while */
d13770 1
a13770 1
	lynx_start_link_color(flag, inU);
d13775 1
a13775 1
	    lynx_start_link_color(flag, inU);
d13788 22
a13809 21
 * Move cursor position to a link's place in the display.
 * The "moving to" is done by scanning through the line's
 * character data in the corresponding HTLine of HTMainText,
 * and starting to draw when a UTF-8 encoded non-ASCII character
 * is encountered before the link (with some protection against
 * overwriting form fields).  This refreshing of preceding data is
 * necessary for preventing curses's or slang's display logic from
 * getting too clever; their logic counts character positions wrong
 * since they don't know about multi-byte characters that take up
 * only one screen position.  So we have to make them forget their
 * idea of what's in a screen line drawn previously.
 * If hightext is non-NULL, it should be the anchor text for a normal
 * link as stored in a links[] element, and the anchor text will be
 * drawn too, with appropriate attributes.  - kw
 */
void LYMoveToLink(int cur,
		  const char *target,
		  char *hightext,
		  int flag,
		  BOOL inU,
		  BOOL utf_flag)
d13812 2
a13813 2
    HTLine *todr;
    int i, n = 0;
d13818 2
a13819 2
     * We need to protect changed form text fields preceding this
     * link on the same line against overwriting.  - kw
d13821 1
a13821 1
    for (i = cur - 1; i >= 0; i++) {
d13844 1
a13844 2
	if (target && *target == '\0')
	    target = NULL;
d13862 2
a13863 1
void redraw_lines_of_link(int cur GCC_UNUSED)
d13867 1
a13867 1
    HTLine *todr1;
d13873 3
a13875 3
	/* we are at the last page - that is partially filled */
	lines_back = HTMainText->Lines - (links[cur].ly - pvtTITLE_HEIGHT +
					  HTMainText->top_of_screen);
d13884 1
a13884 3
    for (count = 0;
	 row <= display_lines && (text = LYGetHiliteStr(cur, count)) != NULL;
	 ++count) {
d13887 1
a13887 1
	redraw_part_of_line(todr1, text, strlen(text), HTMainText);
d13892 1
a13892 1
    /* no dead code ! */
d13898 1
a13898 1
void HTMark_asSource(void)
d13905 2
a13906 1
HTkcode HText_getKcode(HText *text)
d13911 3
a13913 1
void HText_updateKcode(HText *text, HTkcode kcode)
d13918 2
a13919 1
HTkcode HText_getSpecifiedKcode(HText *text)
d13924 3
a13926 1
void HText_updateSpecifiedKcode(HText *text, HTkcode kcode)
d13931 1
a13931 1
int HTMainText_Get_UCLYhndl(void)
@


1.1.3.7
log
@Lynx 2.8.6dev.5 amended with the 2.8.6dev.3-iz2 patch
@
text
@a72 3
static void split_line(HText *text,
		       unsigned split);

d182 1
a182 1
#define MAX_STYLES_ON_LINE   960	/* Table-in-table may aggregate many styles */
a607 2
static void HText_RemoveEmptyLastLine(HText *text);

a2487 6
#define AT_START_OF_CELL(text)	\
  (text->stbl			\
   && Stbl_at_start_of_cell(text->stbl, text->Lines, text->last_line->size))
#define START_OF_LAST_CELL(text)	\
    Stbl_start_of_last_cell(text->stbl, text->Lines)

a2697 25
/* Count funny characters */
static void reset_cached_linedata(HText *text,
				  char *p,
				  unsigned plen)
{
    int i;

    text->permissible_split = ctrl_chars_on_this_line =
	utfxtra_on_this_line = 0;
    for (i = (plen - 1); i >= 0; i--) {
	if (p[i] == LY_UNDERLINE_START_CHAR ||
	    p[i] == LY_UNDERLINE_END_CHAR ||
	    p[i] == LY_BOLD_START_CHAR ||
	    p[i] == LY_BOLD_END_CHAR ||
	    p[i] == LY_SOFT_HYPHEN) {
	    ctrl_chars_on_this_line++;
	} else if (IS_UTF_EXTRA(p[i])) {
	    utfxtra_on_this_line++;
	}
	if (p[i] == LY_SOFT_HYPHEN && (int) text->permissible_split < i)
	    text->permissible_split = i + 1;
    }
    ctrl_chars_on_this_line += utfxtra_on_this_line;
}

a2726 162
static HTLine *line2pool(HText *text GCC_UNUSED,
			 HTLine *previous)
{
    HTLine *temp;

    POOLallocHTLine(temp, previous->size);
    if (!temp)
	outofmem(__FILE__, "split_line_2");
    memcpy(temp, previous, LINE_SIZE(previous->size));
#if defined(USE_COLOR_STYLE)
    POOLallocstyles(temp->styles, previous->numstyles);
    if (!temp->styles)
	outofmem(__FILE__, "split_line_2");
    memcpy(temp->styles, previous->styles, sizeof(HTStyleChange) * previous->numstyles);
#endif
    return temp;
}

/*
 * Reverts the effects of split_line():  merges the line with the preceding
 * line, separating them by space (without styles).  Follows the logic of
 * split_line() backwards; some information on the styles of whitespace may be
 * lost by a split_line()/unsplit_line() pair, as well as HT_NON_BREAK_SPACE vs
 * ' '.
 */
static BOOLEAN unsplit_line(HText *text,
			    HTLine *line,
			    int insert,
			    int abs_pos)
{
    HTLine *previous = line->prev;
    int i;
    HTLine *last = text->last_line;
    HTLine *tmpline;
    TextAnchor *a;

#if 0
    int SpecialAttrChars = 0;
#endif

    if (text->Lines < 2)
	return FALSE;

    if (abs_pos != -1)
	insert = abs_pos - previous->size;
    if (insert < 0)
	return FALSE;

    if (previous->size + insert + line->size >= MAX_LINE)
	return FALSE;

    /* Relocate previous to the scratch space */
    if (last == TEMP_LINE(text, 0))
	tmpline = TEMP_LINE(text, 1);
    else
	tmpline = TEMP_LINE(text, 0);
    if (tmpline == NULL)
	return FALSE;
    memcpy(tmpline, previous, LINE_SIZE(previous->size));
#if defined(USE_COLOR_STYLE)
    if (previous->numstyles + line->numstyles > MAX_STYLES_ON_LINE)
	return FALSE;
    if (last->styles == stylechanges_buffers[0])
	tmpline->styles = stylechanges_buffers[1];
    else
	tmpline->styles = stylechanges_buffers[0];

    memcpy(tmpline->styles, previous->styles, sizeof(HTStyleChange) * previous->numstyles);
#endif

    /* Append the separating space */
    while (insert--)
	tmpline->data[tmpline->size++] = ' ';
    /* And the characters */
    strcpy(tmpline->data + tmpline->size, line->data);

    /* We do not unjustify yet... */
    /* Move anchors back to the previous line */
    if (text->first_anchor) {
	HTLine *before = FirstHTLine(text);
	int n = 0;		/* The first line is 0 */

	while (before != previous) {
	    before = before->next;
	    n++;
	}
	if ((a = text->last_anchor_before_split) != 0) {
	    if (a->line_num > n)
		a = text->first_anchor;
	    while (a && a->line_num <= n)	/* Over anchors before line */
		a = a->next;
	}
	if (a)			/* optimize for further unsplit()s */
	    text->last_anchor_before_split = a;
	while (a && a->line_num <= n + 1) {	/* Over anchors in `line' */
	    a->line_pos += tmpline->size;
	    a->line_num--;
	    a = a->next;
	}
	while (a) {		/* Over anchors after `line' */
	    a->line_num--;
	    a = a->next;
	}
    }
    text->in_line_1 = previous == previous->next->next;		/* unless caller sets it otherwise */
#if 0
    /* Un-align */
    tmpline->offset = 0;	/* it was determined during split_line() */
#endif
    /* We do not need to count SpecialAttrChars since we copy them anyway */
#if 0
    while (line->data[SpecialAttrChars] == LY_UNDERLINE_START_CHAR
	   || line->data[SpecialAttrChars] == LY_BOLD_START_CHAR
	   || line->data[SpecialAttrChars] == LY_SOFT_NEWLINE)
	SpecialAttrChars++;
#endif

#if defined(USE_COLOR_STYLE)
    /* Relocate the styles.  We do not need to care about
       cancellation because of the intervening style-less space */
    memcpy(tmpline->styles + tmpline->numstyles, line->styles,
	   line->numstyles * sizeof(*(line->styles)));
    for (i = 0; i < line->numstyles; i++) {
	tmpline->styles[i + tmpline->numstyles].horizpos += tmpline->size;
    }
    tmpline->numstyles += line->numstyles;
#endif
    tmpline->size += line->size;

    if (line == last) {
	text->last_line = tmpline;
    } else {
	tmpline = line2pool(text, tmpline);
	tmpline->prev->next = tmpline;	/* Link in new line */
	tmpline->next->prev = tmpline;	/* Could be same node of course */
    }

    /* Remove line (works even if tmpline->next->next == tmpline) */
    tmpline->next = tmpline->next->next;
    tmpline->next->prev = tmpline;
    text->Lines--;
    return TRUE;
}

static BOOL split_line_at_cellstart(HText *text,
				    int before_pos)
{
    int pos = text->last_line->size, startpos;

    if (!text->stbl || AT_START_OF_CELL(text)
	|| (tables_disable & TABLES_DISABLE_SPLIT_AT_CELLSTART))
	return FALSE;
    startpos = START_OF_LAST_CELL(text);
    if (startpos <= 0 || startpos >= before_pos)
	return FALSE;
    split_line(text, startpos);
    if ((int) text->permissible_split > pos - text->last_line->size)
	text->permissible_split -= pos - text->last_line->size;
    else
	text->permissible_split = 0;
    return TRUE;
}
d2732 2
a2733 8
    int indent_as_stbl = (text->stbl
			  && !(tables_disable & TABLES_DISABLE_SMART_INDENT));
    int indent = (indent_as_stbl
		  ? 0
		  : (text->in_line_1
		     ? text->style->indent1st
		     : text->style->leftIndent));
    int extra_space = indent + (indent_as_stbl ? 0 : text->style->rightIndent);
a2748 12
    if (text->stbl) {		/* Make multiline rows start on a new line */
	int olen = text->last_line->size;
	int pos = (split ? (int) split : olen);

	if (split_line_at_cellstart(text, pos)) {
	    int newlen = text->last_line->size;

	    if (olen - newlen < pos)
		split_line(text, pos - (olen - newlen));
	    return;
	}
    }
d2813 1
a2813 1
    alignment = indent_as_stbl ? HT_LEFT : style->alignment;
d2846 1
d2878 14
a2891 1
	    reset_cached_linedata(text, p, plen);
d3047 16
a3062 1
    previous = line2pool(text, previous);
d3097 2
a3098 1
	spare = (WRAP_COLS(text) - 1) - extra_space +
d3273 2
a3274 1
					   - extra_space
a3399 81
/* Moves Line back to be positioned vert_offset lines earlier. */
static BOOLEAN move_after_line(HText *text,
			       HTLine *line,
			       int vert_offset,
			       int lineno)
{
    HTLine *line_after = line;
    int i = vert_offset, new_lineno = lineno - vert_offset + 1;
    TextAnchor *a, *a_prev = NULL, *a_prev2, *a_prev3;
    TextAnchor **aPtr = &(text->first_anchor);

    while (--i >= 0)
	line_after = line_after->prev;

    /* Unlink line */
    line->next->prev = line->prev;
    line->prev->next = line->next;
    /* Link into the new place */
    line->next = line_after->next;
    line->prev = line_after;
    line_after->next = line;
    line->next->prev = line;

    /* Correct anchors */

    if (!text->first_anchor)
	return TRUE;

    if ((a = text->last_anchor_before_split) != NULL) {
	if (a->line_num >= new_lineno - 1)
	    a = text->first_anchor;
    }
    while (a && a->line_num < new_lineno)	/* Over anchors up to line_after */
	a_prev = a, a = a->next;
    if (a_prev) {		/* optimize for further operations */
	text->last_anchor_before_split = a_prev;
	aPtr = &(a_prev->next);
    }
    a_prev2 = a_prev;
    while (a && a->line_num < lineno) {		/* Over anchors in between */
	a->line_num++;
	a_prev2 = a;
	a = a->next;
    }
    a_prev3 = a_prev2;
    while (a && a->line_num == lineno) {	/* Over anchors in `line' */
	a->line_num = new_lineno;
	a_prev3 = a;
	a = a->next;
    }
    if (a_prev != a_prev2 && a_prev2 != a_prev3) {	/* Exchange the blocks */
	a_prev3->next = *aPtr;
	*aPtr = a_prev2->next;
	a_prev2->next = a;
    }
    return TRUE;
}

/* Moves line back to be positioned vert_offset lines earlier. */
static BOOLEAN has_multiline_anchor(HText *text,
				    HTLine *line,
				    int lineno)
{
    TextAnchor *a, *a_prev = NULL;

    if (!text || !text->first_anchor)
	return FALSE;

    if ((a = text->last_anchor_before_split) != NULL) {
	if (a->line_num > lineno)
	    a = text->first_anchor;
	while (a && a->line_num <= lineno)	/* Over anchors up to line_after */
	    a_prev = a, a = a->next;
	if (!a_prev || a_prev->line_num != lineno)
	    return FALSE;
	if (a_prev->line_pos + a_prev->extent > line->size)
	    return TRUE;
    }
    return FALSE;
}

a3421 2
    } else if (AT_START_OF_CELL(text)) {
	newlines = 1;		/* New line to get a correct offset */
d3441 1
a3441 3
    if (!AT_START_OF_CELL(text)
	|| (tables_disable & TABLES_DISABLE_TRIM_STARTCELL))
	blank_lines(text, ((after > before) ? after : before));
d3471 2
a3472 9
    HTStyle *style = text->style;
    int indent_as_stbl = (text->stbl
			  && !(tables_disable & TABLES_DISABLE_SMART_INDENT));
    int indent = (indent_as_stbl
		  ? 0
		  : (text->in_line_1
		     ? style->indent1st
		     : style->leftIndent));
    int right_indent = indent_as_stbl ? 0 : text->style->rightIndent;
a3474 1
    int flush_cell = 1;
d3696 3
a4017 3
	if (AT_START_OF_CELL(text)
	    && !(tables_disable & TABLES_DISABLE_TRIM_STARTCELL))
	    return;
a4050 3
	if (AT_START_OF_CELL(text)
	    && !(tables_disable & TABLES_DISABLE_TRIM_STARTCELL))
	    return;
d4113 1
a4113 1
	if (target > (WRAP_COLS(text) - 1) - right_indent &&
d4145 1
a4145 1
	if (target >= (WRAP_COLS(text) - 1) - right_indent -
d4202 1
a4202 1
	if ((nominal + right_indent) >= limit
a4207 1
  do_newline:
d4220 1
a4220 1
	    right_indent - ctrl_chars_on_this_line +
d4225 1
a4225 9
    if (actual >= limit + (ch == ' ') && flush_cell
	&& split_line_at_cellstart(text, actual)) {
	flush_cell = 0;
	line = text->last_line;
	/* Do not change style: essentially, no change was done. */
	goto do_newline;
    }

    if (actual >= limit + (ch == ' ')) {
a4502 2
 *
 * May also merge lines after a split (required by offset-algorithm).
d4506 1
a4506 1
    HTLine *line, *nextline;
d4518 1
a4518 1
    int max_width = 0, indent, spare, table_offset, right_indent;
d4521 1
a4521 4
    int i = 0, prevline_len = -1, do_unsplit, deleted = 0;
    int row_start_line = -1, cur_col = -1, cell_line_count = -1;
    int last_row_start_line, startrow_deleted = 0, vert_move = 1;
    bool enclosing;
d4541 2
a4542 14
    /* The lineno of this loop runs over line numbers *before* unsplitting,
       those which are wired into TRST structures */
    for (; line && lineno <= last_lineno; line = nextline, lineno++) {
	TextAnchor *a_prev_before, *a_start = NULL;

	nextline = line->next;
	last_row_start_line = row_start_line;
	do_unsplit = !(tables_disable & TABLES_DISABLE_UNSPLIT);
	ninserts = Stbl_getFixupPositions(me->stbl, lineno, oldpos, newpos,
					  prevline_len, &do_unsplit,
					  &row_start_line,
					  &cur_col, &cell_line_count);
	if (last_row_start_line != row_start_line)
	    startrow_deleted = deleted;
a4547 1
	    a_start = me->last_anchor_before_stbl;
a4584 1
	    prevline_len = width;
d4587 1
a4587 5
	if (me->last_anchor_before_stbl
	    && me->last_anchor_before_stbl->line_num >= lineno - deleted)
	    a_prev_before = a_start;
	a_prev_before = me->last_anchor_before_stbl;
	mod_line = insert_blanks_in_line(line, lineno - deleted, me,
a4616 62
	}
	if ((tables_disable & TABLES_DISABLE_VERT_MOVE)
	    || has_multiline_anchor(me, line, lineno - deleted))
	    vert_move = 0;
	if (vert_move && row_start_line != -1 && cell_line_count != -1
	    && lineno - deleted > (row_start_line
				   - startrow_deleted
				   + cell_line_count) + 1)
	    move_after_line(me, line,
			    lineno - deleted - (row_start_line
						- startrow_deleted
						+ cell_line_count),
			    lineno - deleted);
	if (do_unsplit != -1) {
	    HTLine *nxt_line = line->next;	/* If vert-moved, != nextline */

	    if (lineno - deleted > first_lineno
		&& unsplit_line(me, line, 0, do_unsplit)) {
		deleted++;
		/* Only one line is left is a special case */
		if (me->last_line == me->last_line->next)
		    nxt_line = nextline = me->last_line;	/* XXX nxt_line needed? */
		if (line == first_line->next)
		    first_line = nxt_line->prev;
		line = nxt_line->prev;
	    } else if (do_unsplit) {	/* Need to shift horizontally */
		int opos = 0, npos = do_unsplit;

		/* Redo insertion with larger offset */
		me->last_anchor_before_stbl = a_prev_before;
		mod_line =
		    insert_blanks_in_line(line, lineno - deleted, me,
					  &me->last_anchor_before_stbl /*updates++ */ ,
					  1, &opos, &npos);
		if (mod_line) {
		    if (line == me->last_line) {
			me->last_line = mod_line;
		    } else {
			added_chars_before += (mod_line->size - line->size);
		    }
		    line->prev->next = mod_line;
		    line->next->prev = mod_line;
		    lines_changed++;
		    if (line == first_line)
			first_line = mod_line;
		    line = mod_line;
#ifdef DISP_PARTIAL
		    /*
		     * Make sure modified lines get fully re-displayed after
		     * loading with partial display is done.
		     */
		    if (me->first_lineno_last_disp_partial >= 0) {
			if (me->first_lineno_last_disp_partial >= lineno) {
			    me->first_lineno_last_disp_partial =
				me->last_lineno_last_disp_partial = -1;
			} else if (me->last_lineno_last_disp_partial >= lineno) {
			    me->last_lineno_last_disp_partial = lineno - 1;
			}
		    }
#endif
		}
	    }
a4636 1
	    prevline_len = width;
d4659 1
a4659 3
    enclosing = (Stbl_get_enclosing(me->stbl)	/* Fake"unnested" to dumb down */
		 &&!(tables_disable & TABLES_DISABLE_SMART_INDENT));
    alignment = enclosing ? HT_LEFT : Stbl_getAlignment(me->stbl);
d4662 1
a4662 2
    indent = enclosing ? 0 : style->leftIndent;
    right_indent = enclosing ? 0 : style->rightIndent;
d4664 3
a4666 2
    spare = (WRAP_COLS(me) - 1) - right_indent - indent - max_width;
    if (spare < 0 && right_indent + spare >= 0) {
d4673 1
a4673 1
	spare += right_indent;	/* ignore right indent, but need more */
a4708 2
    prevline_len = -1;
    last_lineno -= deleted;
d4712 2
a4713 1
	if ((int) line->offset != table_offset) {
d4732 1
a4732 1
	    Stbl_update_enclosing(me->stbl, max_width, last_nonempty - deleted);
a4824 68
/*	Remove trailing blank lines from the last cell.  */
int HText_trimCellLines(HText *text)
{
    int ret = 0;
    HTLine *lastline;

#if defined(USE_COLOR_STYLE)
    HTStyleChange *laststyles;
#endif

    if (!(text && text->stbl)
	|| (tables_disable & TABLES_DISABLE_TRIM_ENDCELL))
	return 0;

    lastline = text->last_line;
#if defined(USE_COLOR_STYLE)
    laststyles = lastline->styles;
#endif
    while (text->last_line && text->Lines >= 1
	   && HText_LastLineSize(text, FALSE) == 0) {
	/* Empty line should survive only if
	   a) It is a first line of a row;
	   b) This is not a fake row.
	 */
	if (Stbl_trimFakeRows(text->stbl, text->Lines, text->last_line->size))
	    ret++, HText_RemoveEmptyLastLine(text);
	else
	    break;
    }

    if (!ret)
	return 0;

#ifndef FIXME_FIXME_XXXX
    /* De-POOL the line */
    memcpy(lastline, text->last_line, LINE_SIZE(text->last_line->size));
#if defined(USE_COLOR_STYLE)
    /* De-POOL the style buffers */
    memcpy(laststyles, lastline->styles,
	   sizeof(HTStyleChange) * lastline->numstyles);

    lastline->styles = laststyles;
#endif

    if (text->last_line->next == text->last_line)
	lastline->next = lastline->prev = lastline;
    text->last_line = lastline;
    lastline->prev->next = lastline;	/* Link in new line */
    lastline->next->prev = lastline;	/* Could be same node of course */

#endif /* FIXME_FIXME_XXXX */

    /* Fix global state for the last line */
    reset_cached_linedata(text, text->last_line->data,
			  text->last_line->size);
#if 0
    /* XXXX This is not enough.  Actually we need also to clear the
       me->in_word flag of HTML.c.  Since this is not
       possible, fake a real space. */
    text->LastChar = (text->last_line->size
		      ? text->last_line->data[text->last_line->size - 1]
		      : ' ');
#else
    HText_appendCharacter(text, ' ');
#endif
    return ret;
}

d4896 3
a4898 2
    if (me && me->stbl)
	Stbl_finishRowInTable(me->stbl);
a4932 1
    HText_trimCellLines(me);
d8629 1
a8629 1
    if (!(text && text->Lines >= 1))	/* Lines is 0-based */
a8640 22
 *  This function is for removing the last blank lines.
 *  It should be called after
 *  checking the situation with HText_LastLineSize().
 *  With POOLed allocation is should be wrapped into code restoring the
 *  expected POOLed/unPOOLed state of the line chain.
 */
static void HText_RemoveEmptyLastLine(HText *text)
{
    HTLine *line, *previous;

    if (!(text && text->Lines >= 1))	/* Lines is 0-based */
	return;

    line = text->last_line;
    previous = line->prev;
    previous->next = line->next;
    previous->next->prev = previous;
    text->last_line = previous;
    text->Lines--;
}

/*
d8653 2
a8654 3
	column = (text->in_line_1
		  ? text->style->indent1st
		  : text->style->leftIndent)
@


1.1.3.8
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@a15 1
#include <HText.h>
d57 1
a57 1
#  define DISPLAY_COLS    (LYwideLines ? MAX_COLS : LYcols)
d60 2
a61 3
			    ? DISPLAY_COLS				\
			    : (LYtableCols * LYcols)/12) - LYbarWidth	\
			   : LYcolLimit)
d63 2
a64 2
#  define DISPLAY_COLS    LYcols
#  define WRAP_COLS(text) LYcolLimit
d73 3
a108 1

d123 2
a124 2
static int HTFormNumber = 0;
static int HTFormFields = 0;
d185 1
a185 1
#define MAX_STYLES_ON_LINE   64
d611 2
d1323 2
a1324 2
    if (j >= DISPLAY_COLS)
	j = DISPLAY_COLS - 1;
d1372 1
a1372 1
    while ((i <= DISPLAY_COLS) && ((buffer[0] = *data) != '\0')) {
d1464 1
a1464 1
#endif /* !USE_COLOR_STYLE */
d1533 21
a1553 18
		if (i < DISPLAY_COLS) {
		    buffer[1] = *data;
		    buffer[2] = '\0';
		    data++;
		    i++;
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		    /*
		     * For now, load 'M' into LastDisplayChar, but we should
		     * check whether it's white and if so, use ' '.  I don't
		     * know if there actually are white CJK characters, and
		     * we're loading ' ' for multibyte spacing characters in
		     * this code set, but this will become an issue when the
		     * development code set's multibyte character handling is
		     * used.  -FM
		     */
		    LastDisplayChar = 'M';
		}
d1561 1
a1724 6
#ifdef WIDEC_CURSES
    i = limit - LYbarWidth - strlen(percent) - LYstrCells(title);
    if (i <= 0)
	i = 0;
    LYmove(0, i);
#else
a1744 1
#endif
d1753 1
a1753 1
	LYmove(0, LYcolLimit);
d1831 1
a1831 1
	LYmove(1, LYcolLimit + LYshiftWin);
d1852 1
a1852 1
	LYmove(i + off, LYcolLimit + LYshiftWin);
d1873 1
a1873 1
	LYmove(h + 2, LYcolLimit + LYshiftWin);
d2108 1
a2108 1
		   ((int) line->offset + LenNeeded) <= DISPLAY_COLS) {
a2337 1
		    /* FIXME: use LYstrExtent, not strlen */
a2439 1
    return;
d2493 6
d2709 25
d2763 162
d2930 8
a2937 3
    int indent = (text->in_line_1
		  ? text->style->indent1st
		  : text->style->leftIndent);
a2945 1
    char *cp;
a2946 2

#ifndef WIDEC_CURSES
d2948 1
a2948 1
#endif
d2953 12
d3029 1
a3029 1
    alignment = style->alignment;
a3061 1
	int i;
d3093 1
a3093 14
	    for (i = (plen - 1); i >= 0; i--) {
		if (p[i] == LY_UNDERLINE_START_CHAR ||
		    p[i] == LY_UNDERLINE_END_CHAR ||
		    p[i] == LY_BOLD_START_CHAR ||
		    p[i] == LY_BOLD_END_CHAR ||
		    p[i] == LY_SOFT_HYPHEN) {
		    ctrl_chars_on_this_line++;
		} else if (IS_UTF_EXTRA(p[i])) {
		    utfxtra_on_this_line++;
		}
		if (p[i] == LY_SOFT_HYPHEN && (int) text->permissible_split < i)
		    text->permissible_split = i + 1;
	    }
	    ctrl_chars_on_this_line += utfxtra_on_this_line;
d3249 1
a3249 16
    {
	HTLine *temp;

	allocHTLine(temp, previous->size);
	if (!temp)
	    outofmem(__FILE__, "split_line_2");
	memcpy(temp, previous, LINE_SIZE(previous->size));
#if defined(USE_COLOR_STYLE)
	POOLallocstyles(temp->styles, previous->numstyles);
	if (!temp->styles)
	    outofmem(__FILE__, "split_line_2");
	memcpy(temp->styles, previous->styles, sizeof(HTStyleChange) * previous->numstyles);
#endif
	previous = temp;
    }

a3273 1
#ifndef WIDEC_CURSES
a3274 1
#endif
d3284 1
a3284 9
#ifdef WIDEC_CURSES
	spare = WRAP_COLS(text) -
	    (int) style->rightIndent - indent +
	    ctrl_chars_on_previous_line - LYstrExtent2(previous->data, previous->size);
	if (spare < 0 && LYwideLines)	/* Can be wider than screen */
	    spare = 0;
#else
	spare = WRAP_COLS(text) -
	    (int) style->rightIndent - indent +
d3293 3
a3295 3
		int spare_cu = (LYcols_cu(text) -
				utfxtra_on_previous_line - indent +
				ctrl_chars_on_previous_line - previous->size);
d3313 1
a3313 1
			    + utfxtra_on_previous_line <= LYcols_cu(text))
d3319 1
a3319 1
				 * Can't move toward center all the way,
a3333 1
#endif
d3458 2
a3459 3
					/ (WRAP_COLS(text)
					   - (int) style->rightIndent
					   - indent
d3585 81
d3688 2
d3709 3
a3711 1
    blank_lines(text, ((after > before) ? after : before));
d3741 9
a3749 2
    HTStyle *style;
    int indent;
d3752 1
a3973 3
    style = text->style;

    indent = text->in_line_1 ? (int) style->indent1st : (int) style->leftIndent;
d4244 1
a4244 1
			      1 : 0)) >= LYcols_cu(text))
d4293 3
d4329 3
d4394 1
a4394 1
	if (target > WRAP_COLS(text) - (int) style->rightIndent &&
d4402 2
a4403 2
	    if (target_cu > WRAP_COLS(text))
		target -= target_cu - WRAP_COLS(text);
d4426 1
a4426 1
	if (target >= WRAP_COLS(text) - style->rightIndent -
d4429 1
a4429 1
	     target_cu + UTF_XLEN(ch) >= LYcols_cu(text))) {
d4466 1
a4466 1
	limit = WRAP_COLS(text);
d4483 2
a4484 2
	if ((nominal + (int) style->rightIndent) >= limit
	    || (nominal + UTFXTRA_ON_THIS_LINE) >= LYcols_cu(text)) {
d4489 1
d4499 1
a4499 1
	limit = LYcols_cu(text);
d4502 1
a4502 1
	    (int) style->rightIndent - ctrl_chars_on_this_line +
d4504 9
a4512 1
	limit = WRAP_COLS(text);
d4515 1
a4515 1
    if (actual >= limit) {
d4793 2
d4798 1
a4798 1
    HTLine *line;
d4810 1
a4810 1
    int max_width = 0, indent, spare, table_offset;
d4813 4
a4816 1
    int i = 0;
d4836 14
a4849 2
    for (; line && lineno <= last_lineno; line = line->next, lineno++) {
	ninserts = Stbl_getFixupPositions(me->stbl, lineno, oldpos, newpos);
d4855 1
d4893 1
d4896 5
a4900 1
	mod_line = insert_blanks_in_line(line, lineno, me,
d4930 62
d5012 1
d5035 3
a5037 1
    alignment = Stbl_getAlignment(me->stbl);
d5040 2
a5041 1
    indent = style->leftIndent;
d5043 2
a5044 3
    spare = WRAP_COLS(me) -
	(int) style->rightIndent - indent - max_width;
    if (spare < 0 && (int) style->rightIndent + spare >= 0) {
d5051 1
a5051 1
	spare += style->rightIndent;	/* ignore right indent, but need more */
d5087 2
d5092 1
a5092 2
	ninserts = Stbl_getFixupPositions(me->stbl, lineno, oldpos, newpos);
	if (ninserts >= 0 && (int) line->offset != table_offset) {
d5111 1
a5111 1
	    Stbl_update_enclosing(me->stbl, max_width, last_nonempty);
d5204 68
d5343 2
a5344 3
    if (!me || !me->stbl)
	return;
    /* should this do something?? */
d5379 1
d6029 1
a6029 1
    CTRACE((tfp, "GridText: Entering HText_endAppend\n"));
d6129 1
a6129 1
	CTRACE((tfp, "GridText: Entering HText_trimHightext (final)\n"));
d6134 1
a6134 1
		"GridText: Entering HText_trimHightext (partial: 0..%d/%d)\n",
d6151 1
a6151 1
	int anchor_col;
d6200 1
a6200 1
		"GridText: Anchor found on line:%d col:%d [%d] ext:%d\n",
a6327 5
	 * Save the offset (bytes) of the anchor in the line's data.
	 */
	anchor_col = anchor_ptr->line_pos;

	/*
a6329 11
#ifdef WIDEC_CURSES
	if (anchor_ptr->line_pos > 0) {
	    /*
	     * LYstrExtent filters out the formatting characters, so we do not
	     * have to count them here.
	     *
	     * FIXME: do we have to count soft-newlines?
	     */
	    anchor_ptr->line_pos = LYstrExtent2(line_ptr->data, anchor_col);
	}
#else /* 8-bit curses, etc.  */
a6331 1
	    int have_soft_newline_in_1st_line = 0;
d6333 1
a6333 1
	    for (; i < anchor_col; i++) {
a6340 2
	    /*handle LY_SOFT_NEWLINEs -VH */
	    anchor_ptr->line_pos += have_soft_newline_in_1st_line;
a6341 1
#endif /* WIDEC_CURSES */
d6344 1
a6344 1
	 * Set the line number.
d6349 3
d7073 1
a7073 1
	(LineOffset + LenNeeded) <= DISPLAY_COLS) {
d8174 1
a8174 1
    if ((no_list == FALSE) &&
a8621 24
static BOOLEAN useSourceCache(void)
{
    BOOLEAN result = FALSE;

    if (LYCacheSource == SOURCE_CACHE_FILE) {
	result = (HTMainAnchor->source_cache_file != 0);
	CTRACE((tfp, "SourceCache: file-cache%s found\n",
		result ? "" : " not"));
    }
    return result;
}

static BOOLEAN useMemoryCache(void)
{
    BOOLEAN result = FALSE;

    if (LYCacheSource == SOURCE_CACHE_MEMORY) {
	result = (HTMainAnchor->source_cache_chunk != 0);
	CTRACE((tfp, "SourceCache: memory-cache%s found\n",
		result ? "" : " not"));
    }
    return result;
}

d8626 5
a8630 2
    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE) {
	CTRACE((tfp, "HTreparse_document returns FALSE\n"));
a8631 1
    }
d8633 1
a8633 1
    if (useSourceCache()) {
a8692 2

	CTRACE((tfp, "Reparse file %s\n", (ok ? "succeeded" : "failed")));
d8695 2
a8696 1
    if (useMemoryCache()) {
d8742 1
d8744 1
a8744 2
	CTRACE((tfp, "Reparse memory %s\n", (ok ? "succeeded" : "failed")));
    }
d8751 10
a8760 1
    BOOLEAN result = FALSE;
d8762 3
a8764 6
    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE) {
	result = FALSE;
    } else if (useSourceCache()) {
	result = LYCanReadFile(HTMainAnchor->source_cache_file);
    } else if (useMemoryCache()) {
	result = TRUE;
d8767 1
a8767 2
    CTRACE((tfp, "HTcan_reparse_document -> %d\n", result));
    return result;
d8786 5
a8790 1
    if (!HTMainText || !HTcan_reparse_document())
d9076 1
a9076 1
    if (!(text && text->Lines > 1))
d9088 22
d9122 3
a9124 2
	column = (text->in_line_1 ?
		  (int) text->style->indent1st : (int) text->style->leftIndent)
d9133 1
a9133 1
    int column = DISPLAY_COLS;
d9136 2
a9137 1
	column -= (int) text->style->rightIndent;
d10204 1
a10204 1
    MaximumSize = WRAP_COLS(text) + 1 - adjust_marker;
d13699 1
d13709 3
a13711 9
    BOOL intarget = NO;
    BOOL inunderline = NO;
    BOOL inbold = NO;
    BOOL drawing = NO;
    BOOL inU = NO;
    BOOL hadutf8 = NO;
    BOOL incurlink = NO;
    BOOL drawingtarget = NO;
    BOOL flag = NO;
d13714 1
a13714 5

    int i = (int) offset;	/* FIXME: should be columns, not offset? */
    int last_i = DISPLAY_COLS;
    int XP_link = XP;		/* column of link */
    int XP_next = XP;		/* column to move to when done drawing */
d13729 5
a13733 11
    if (hightext != 0) {
#ifdef WIDEC_CURSES
	len = strlen(hightext);
	last_i = i + LYstrExtent2(data, datasize);
#endif
	linkvlen = LYmbcsstrlen(hightext, utf_flag, YES);
    } else {
	linkvlen = 0;
    }
    if (i >= last_i)
	i = last_i - 1;
d13755 1
a13755 1
	    if ((int) offset + LenNeeded > last_i ||
d13775 1
a13775 1
    while ((i <= last_i) && data < end_of_data && (*data != '\0')) {
d13786 1
a13786 1
	     * chars LY_BOLD_START_CHAR etc., have been stripped out (see
d13791 1
a13791 1
	     * for something else than normal hyperlink anchors, i.e., form
d13799 1
a13799 2
	    last_i = i + len;
	    XP_next += linkvlen;
d13808 1
a13808 1
	     * The logic of where to set in-target drawing target etc.
d13858 1
a13858 1
	if (i >= last_i || data >= end_of_data)
d13862 1
d13871 1
a13871 1
		if (incurlink && flag && i == last_i - 1)
d13885 1
a13885 1
			if (flag && i_start_tgt == last_i - 1)
d13887 3
a13889 3
			if (flag && i_after_tgt >= last_i)
			    i_after_tgt = last_i - 1;
			if (flag && i_start_tgt >= last_i)
d13891 1
a13891 1
		    } else if (i_start_tgt == last_i) {
d13921 1
a13921 1
	 * target string, so that they stay in synch.  As long
d13931 5
a13935 4
	if (incurlink) {
	    while (IsNormalChar(*sdata)) {
		++sdata;
	    }
d14004 1
a14004 1
		if (i == last_i - 1) {
d14006 1
a14006 1
		} else if (i == last_i - 2 && HTCJK != NOCJK &&
d14025 1
a14025 1
			  (i == XP_link || i == last_i - 1))) {
d14032 1
a14032 1
			if (flag && (i == XP_link || i == last_i - 1)) {
d14049 1
a14049 1
				 (i == XP_link || (incurlink && i == last_i - 1)))) {
a14067 1
#ifndef WIDEC_CURSES
a14072 1
#endif
d14101 1
a14101 1
		if (drawing && (i <= last_i)) {
d14129 1
a14129 1
	LYmove(YP, XP_next);
@


1.1.3.9
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d6740 2
a6741 3
    char *dot = NULL;
    char *cp = NULL;
    char *suffix = "";
d6781 10
a6790 1
	method = HTEncodingToCompressType(ce);
d6859 1
a6859 1
    case cftNone:
a6864 3
    case cftDeflate:
	suffix = ".zz";
	break;
d9546 2
a9547 2
    if (I->size != 0) {
	f->size = I->size;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d7 1
a13 1
#include <HTFile.h>
d19 6
a40 2
#include <TRSTable.h>
#include <LYHistory.h>
a47 4
#ifdef SH_EX	/* for DEBUG (1997/10/10 (Fri) 07:58:47) */
#define NOTUSED_BAD_FOR_SCREEN
#endif

d62 4
a65 1
#include <LYJustify.h>
d67 5
a71 9
#ifdef USE_CURSES_PADS
#  define DISPLAY_COLS (LYwideLines ? MAX_COLS : LYcols)
#  define WRAP_COLS(text) ((text)->stbl ?				\
			   (LYtableCols <= 0				\
			    ? DISPLAY_COLS : (LYtableCols * LYcols)/12)	\
			   : LYcols)
#else
#  define DISPLAY_COLS LYcols
#  define WRAP_COLS(text) LYcols
a72 9

#define FirstHTLine(text) ((text)->last_line->next)
#define LastHTLine(text)  ((text)->last_line)

PRIVATE void HText_trimHightext PARAMS((
	HText *		text,
	BOOLEAN		final,
	int		stop_before));

d76 1
a76 1
    int i, j;
d78 3
a80 3
    for (i = 1; (i < CACHEH && i <= display_lines); i++) {
	for (j = 0; j < CACHEW; j++)
	    cached_styles[i][j] = 0;
d92 1
a92 4
			  (UCH((ch))&0xc0) == 0x80)
/* a test in compact form: how many extra UTF-8 chars after initial? - kw */
#define UTF8_XNEGLEN(c) (c&0xC0? 0 :c&32? 1 :c&16? 2 :c&8? 3 :c&4? 4 :c&2? 5:0)
#define UTF_XLEN(c) UTF8_XNEGLEN(((char)~(c)))
d95 2
a96 9

#ifdef KANJI_CODE_OVERRIDE
PUBLIC HTkcode last_kcode = NOKANJI;	/* 1997/11/14 (Fri) 09:09:26 */
#endif
#ifdef CJK_EX
#define CHAR_WIDTH 6
#else
#define CHAR_WIDTH 1
#endif
d119 2
a120 2
PRIVATE BOOLEAN underline_on = OFF;
PRIVATE BOOLEAN bold_on      = OFF;
d123 2
d126 1
a126 8
PUBLIC int LYCacheSourceForAborted = SOURCE_CACHE_FOR_ABORTED_DROP;
#endif

#ifdef USE_SCROLLBAR
PUBLIC BOOLEAN LYsb = FALSE;
PUBLIC BOOLEAN LYsb_arrow = TRUE;
PUBLIC int LYsb_begin = -1;
PUBLIC int LYsb_end = -1;
a131 1
    /*try to fit in 2 shorts*/
d133 4
a136 4
	unsigned int	direction:2;	/* on or off */
	unsigned int	horizpos: (sizeof(short)*CHAR_BIT-2);
	    /* horizontal position of this change */
	unsigned short	style;		/* which style to change to */
d145 3
d149 1
a149 1
	HTStyleChange* styles;
a154 118
#if defined(USE_COLOR_STYLE)
typedef struct _HTStyleChangePool {
	HTStyleChange	data[4092];
	struct _HTStyleChangePool* next;
	int free_items;
} HTStyleChangePool;

/*these are used when current line is being aggregated. */
HTStyleChange stylechanges_buffers[2][MAX_STYLES_ON_LINE];
int stylechanges_buffers_free;/*this is an index of the free buffer.
    Can be 0 or 1*/

/* These are generic macors for any pools (provided those structures have the
same members as HTStyleChangePool).  Pools are used for allocation of groups of
objects of the same type T.  Pools are represented as a list of structures of
type P (called pool chunks here).  Structure P has an array of N objects of
type T named 'data' (the number N in the array can be chosen arbitrary),
pointer to the next pool chunk named 'pool', and the number of free items in
that pool chunk named 'free_items'.  Here is a definition of the structure P:
	struct P
	{
	    T data[N];
	    struct P* next;
	    int free_items;
	};
 It's recommended that sizeof(P) be memory page size minus 32 in order malloc'd
chunks to fit in machine page size.
 Allocation of 'n' items in the pool is implemented by decrementing member
'free_items' by 'n' if 'free_items' >= 'n', or allocating a new pool chunk and
allocating 'n' items in that new chunk.  It's the task of the programmer to
assert that 'n' is <= N.  Only entire pool may be freed - this limitation makes
allocation algorithms trivial and fast - so the use of pools is limited to
objects that are freed in batch, that are not deallocated not in the batch, and
not reallocated.
 Pools greatly reduce memory fragmentation and memory allocation/deallocation
speed due to the simple algorithms used.  Due to the fact that memory is
'allocated' in array, alignment overhead is minimal.  Allocating strings in a
pool provided their length will never exceed N and is much smaller than N seems
to be very efficient.

 Pool are referenced by pointer to the chunk that contains free slots. Macros
that allocate memory in pools update that pointer if needed.
 There are 3 macros that deal with pools - POOL_NEW, POOL_FREE and
ALLOC_IN_POOL.
 Here is a description of those macros as C++ functions (with names mentioned
above and with use of C++ references)

void ALLOC_IN_POOL( P*& pool, pool_type, int toalloc, T*& ptr)
    - allocates 'toalloc' items in the pool of type 'pool_type' pointed by
    'pool', sets the pointer 'ptr' to the "allocated" memory and updates 'pool'
    if necessary. Sets 'ptr' to NULL if fails.

void POOL_NEW( pool_type  , P*& ptr)
    Initializes a pool of type 'pool_type' pointed by 'ptr', updating 'ptr'.
    Sets 'ptr' to NULL if fails.

void POOL_FREE( pool_type , P* ptr)
    Frees a pool of type 'pool_type' pointed by ptr.

      - VH */

/*
void ALLOC_IN_POOL( P*& pool, pool_type, int toalloc, T*& ptr)
    - allocates 'toalloc' items in the pool of type 'pool_type' pointed by
    'pool', sets the pointer 'ptr' to the "allocated" memory and updates 'pool'
    if necessary. Sets 'ptr' to NULL if fails.
*/
#define ALLOC_IN_POOL(pool,pool_type,toalloc,ptr)     \
if (!pool)  \
    ptr = NULL; \
else { \
    if ((pool)->free_items > toalloc) { \
	(pool)->free_items -= toalloc; \
	ptr = (pool)->data + (pool)->free_items; \
    } else { \
	pool_type* newpool = (pool_type*)malloc(sizeof(pool_type)); \
	if (!newpool) { \
	    ptr = NULL; \
	} else { \
	    newpool->next = pool; \
	    newpool->free_items = sizeof newpool->data/ \
		    sizeof newpool->data[0] - toalloc; \
	    pool = newpool; \
	    ptr = newpool->data + sizeof newpool->data/sizeof newpool->data[0] - toalloc; \
	} \
    } \
}
/*
void POOL_NEW( pool_type  , P*& ptr)
    Initializes a pool of type 'pool_type' pointed by 'ptr', updating 'ptr'.
    Sets 'ptr' to NULL if fails.
*/
#define POOL_NEW(pool_type,ptr) \
    { \
	pool_type* newpool = (pool_type*)malloc(sizeof(pool_type)); \
	if (!newpool) { \
	    ptr = NULL; \
	} else { \
	    newpool->next = NULL; \
	    newpool->free_items = sizeof newpool->data/sizeof newpool->data[0]; \
	    ptr = newpool; \
	} \
    }
/*
void POOL_FREE( pool_type , P* ptr)
    Frees a pool of type 'pool_type' pointed by ptr.
*/
#define POOL_FREE(pool_type,xptr) \
    { \
	pool_type* ptr = xptr; \
	do { \
	    pool_type* prevpool = ptr; \
	    ptr = ptr->next; \
	    FREE(prevpool); \
	} while (ptr); \
    }
#endif

a155 1
#define allocHTLine(l) (HTLine *)calloc(1, LINE_SIZE(l))
a158 1
	struct _TextAnchor *	prev;		/* www_user_search only! */
d160 3
a162 2
	int			line_pos;	/* Bytes/chars - extent too */
	int			extent;		/* (see HText_trimHightext) */
d182 1
a182 1
**	next_line is valid if stale is false.
d189 3
a196 1
	BOOLEAN			verbose_img;
d201 3
a203 4
	int			old_dtd;
	int			keypad_mode;
	int			disp_lines;	/* Screen size */
	int			disp_cols;	/* Used for reports only */
d207 1
a209 1
	TextAnchor *		last_anchor_before_stbl;
a230 2
	BOOL			has_utf8; /* has utf-8 on screen or line */
	BOOL			had_utf8; /* had utf-8 when last displayed */
a234 1
	STable_info *		stbl;
a236 10
	HTkcode			specified_kcode;	/* Specified Kanji code */
#ifdef USE_TH_JP_AUTO_DETECT
	enum _detected_kcode  { DET_SJIS, DET_EUC, DET_NOTYET, DET_MIXED }
				detected_kcode;		/* Detected Kanji code */
	enum _SJIS_status     { SJIS_state_neutral, SJIS_state_in_kanji,
				SJIS_state_has_bad_code } SJIS_status;
	enum _EUC_status      { EUC_state_neutral, EUC_state_in_kanji,
				EUC_state_in_kana, EUC_state_has_bad_code }
				EUC_status;
#endif
a251 3
#if defined(USE_COLOR_STYLE)
	HTStyleChangePool*	styles_pool;
#endif
a255 67
#ifdef EXP_JUSTIFY_ELTS
PUBLIC BOOL can_justify_here;
PUBLIC BOOL can_justify_here_saved;

PUBLIC BOOL can_justify_this_line;/* =FALSE if line contains form objects */
PUBLIC int wait_for_this_stacked_elt;/* -1 if can justify contents of the
    element on the op of stack. If positive - specifies minimal stack depth
    plus 1 at which we can justify element (can be MAX_LINE+2 if
    ok_justify ==FALSE or in psrcview. */
PUBLIC BOOL form_in_htext;/*to indicate that we are in form (since HTML_FORM is
  not stacked in the HTML.c */
PUBLIC BOOL in_DT = FALSE;
#ifdef DEBUG_JUSTIFY
PUBLIC BOOL can_justify_stack_depth;/* can be 0 or 1 if all code is correct*/
#endif


typedef struct ht_run_info_ {
    int byte_len;		/*length in bytes*/
    int cell_len;		/*length in cells*/
} ht_run_info;

static int justify_start_position;/* this is an index of char from which
    justification can start (eg after "* " preceeding <li> text) */

static int ht_num_runs;/*the number of runs filled*/
static ht_run_info ht_runs[MAX_LINE];
static BOOL this_line_was_split;
static TextAnchor* last_anchor_of_previous_line;
static BOOL have_raw_nbsps = FALSE;

PUBLIC void ht_justify_cleanup NOARGS
{
    wait_for_this_stacked_elt = !ok_justify
#  ifdef USE_PRETTYSRC
	|| psrc_view
#  endif
	? 30000/*MAX_NESTING*/+2 /*some unreachable value*/ : -1;
    can_justify_here = TRUE;
    can_justify_this_line = TRUE;
    form_in_htext = FALSE;

    last_anchor_of_previous_line = NULL;
    this_line_was_split = FALSE;
    in_DT = FALSE;
    have_raw_nbsps = FALSE;
}

PUBLIC void mark_justify_start_position ARGS1(void*,text)
{
    if (text && ((HText*)text)->last_line)
	justify_start_position = ((HText*)text )->last_line->size;
}


#define REALLY_CAN_JUSTIFY(text) ( (wait_for_this_stacked_elt<0) && \
	( text->style->alignment == HT_LEFT     || \
	  text->style->alignment == HT_JUSTIFY) && \
	HTCJK == NOCJK && !in_DT && \
	can_justify_here && can_justify_this_line && !form_in_htext )

#else
#define last_anchor_of_previous_line (TextAnchor*)0
#endif /* EXP_JUSTIFY_ELTS */



a270 2
PRIVATE int utfxtra_on_this_line = 0; /* num of UTF-8 extra bytes in line,
				       they *also* count as ctrl chars. */
a293 1

d365 1
a365 1
	CTRACE((tfp, "\nBUG *** Emergency freeing document %d/%d for '%s'%s!\n",
d372 1
a372 1
		     " with POST data" : "")));
d453 1
a453 1
    HText * self = typecalloc(HText);
a456 2
    CTRACE((tfp, "GridText: start HText_new\n"));

d459 1
a459 1
    CTRACE((tfp, "GridText: VMTotal = %d\n", VMTotal));
a461 16
    /*
     *  If the previously shown text had UTF-8 characters on screen,
     *  remember this in the newly created object.  Do this now, before
     *  the previous object may become invalid. - kw
     */
    if (HTMainText) {
	if (HText_hasUTF8OutputSet(HTMainText) &&
	    HTLoadedDocumentEightbit() &&
	    LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
	    self->had_utf8 = HTMainText->has_utf8;
	} else {
	    self->had_utf8 = HTMainText->has_utf8;
	}
	HTMainText->has_utf8 = NO;
    }

d478 1
a478 1
	CTRACE((tfp, "GridText: Auto-uncaching\n")) ;
d492 1
a492 1
	CTRACE((tfp, "GridText: Freeing off cached doc.\n"));
d496 1
a496 1
	CTRACE((tfp, "GridText: VMTotal reduced to %d\n", VMTotal));
d500 1
a500 1
    line = self->last_line = allocHTLine(MAX_LINE);
a506 5
    POOL_NEW(HTStyleChangePool,self->styles_pool);
    if (!self->styles_pool)
	outofmem(__FILE__, "HText_New");
    stylechanges_buffers_free = 0;
    line->styles = stylechanges_buffers[0];
d508 1
a508 1
    self->Lines = 0;
d519 14
a536 1
    self->verbose_img = verbose_img;
d542 2
a543 3
    self->keypad_mode = keypad_mode;
    self->disp_lines = LYlines;
    self->disp_cols = DISPLAY_COLS;
d555 1
a555 2
	LYIsUIPage3(anchor->address, UIP_LIST_PAGE, 0) ||
	LYIsUIPage3(anchor->address, UIP_ADDRLIST_PAGE, 0))
d565 1
a565 1
#ifndef USE_PRETTYSRC
d571 1
a571 7
    /*  mark_htext_as_source == TRUE if we are parsing html file (and psrc_view is
     *	    set temporary to false at creation time)
     *	psrc_view == TRUE if source of the text produced by some lynx module
     *	    (like ftp browsers) is requested). - VH
     */
    self->source = (BOOL) (LYpsrc ? mark_htext_as_source || psrc_view : HTOutputFormat == WWW_SOURCE);
    mark_htext_as_source = FALSE;
a578 6
    self->specified_kcode = NOKANJI;
#ifdef USE_TH_JP_AUTO_DETECT
    self->detected_kcode = DET_NOTYET;
    self->SJIS_status = SJIS_state_neutral;
    self->EUC_status = EUC_state_neutral;
#endif
d592 3
a594 2
    HText_setKcode(self, anchor->charset,
		   HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT));
d622 1
a622 1
     * By this function we create HText object
d625 2
a626 4
    if (display_partial_flag) {
	display_partial = TRUE;	 /* enable HTDisplayPartial() */
	NumOfLines_partial = 0;	 /* initialize */
    }
d638 2
a639 3
#ifdef EXP_JUSTIFY_ELTS
    ht_justify_cleanup();
#endif
d672 1
a672 3
#if defined(USE_COLOR_STYLE)
    POOL_FREE(HTStyleChangePool,self->styles_pool);
#endif
a786 9
#ifdef SOURCE_CACHE
	/* Remove source cache files and chunks always, even if the
	 * HTAnchor_delete call does not actually remove the anchor.
	 * Keeping them would just be a waste of space - they won't
	 * be used any more after the anchor has been disassociated
	 * from a HText structure. - kw
	 */
	HTAnchor_clearSourceCache(self->node_anchor);
#endif
d795 17
d823 1
a823 1
PRIVATE int display_line ARGS4(
d825 1
a825 3
	HText *,	text,
	int,		scrline GCC_UNUSED,
	CONST char*,	target GCC_UNUSED)
a830 1
    char LastDisplayChar = ' ';
a832 16
#define inunderline NO
#define inbold NO
#else
    BOOL inbold=NO, inunderline=NO;
#endif
#if defined(SHOW_WHEREIS_TARGETS) && !defined(USE_COLOR_STYLE)
    CONST char *cp_tgt;
    int i_start_tgt=0, i_after_tgt;
    int HitOffset, LenNeeded;
    BOOL intarget=NO;
#else
#define intarget NO
#endif /* SHOW_WHEREIS_TARGETS && !USE_COLOR_STYLE */

#ifndef NCURSES_VERSION
    text->has_utf8 = NO; /* use as per-line flag, except with ncurses */
d834 1
d842 1
a842 1
    LYclrtoeol();
d849 2
a850 2
    if (j > (int)DISPLAY_COLS - 1)
	j = (int)DISPLAY_COLS - 1;
d861 1
a861 1
	LYaddch (' ');
d870 1
a870 54

#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
    /*
     *  If the target is on this line, it will be emphasized.
     */
    i_after_tgt = i;
    if (target) {
	cp_tgt = LYno_attr_mb_strstr(data,
				       target,
				       text->T.output_utf8, YES,
				       &HitOffset,
				       &LenNeeded);
	if (cp_tgt) {
	    if (((int)line->offset + LenNeeded) >= DISPLAY_COLS) {
		cp_tgt = NULL;
	    } else {
		text->page_has_target = YES;
		i_start_tgt = i + HitOffset;
		i_after_tgt = i + LenNeeded;
	    }
	}
    } else {
	cp_tgt = NULL;
    }
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */

    while ((i < DISPLAY_COLS) && ((buffer[0] = *data) != '\0')) {

#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
	if (cp_tgt && i >= i_after_tgt) {
	    if (intarget) {
		cp_tgt = LYno_attr_mb_strstr(data,
					    target,
					    text->T.output_utf8, YES,
					    &HitOffset,
					    &LenNeeded);
		if (cp_tgt) {
		    i_start_tgt = i + HitOffset;
		    i_after_tgt = i + LenNeeded;
		}
		if (!cp_tgt || i_start_tgt != i) {
		    LYstopTargetEmphasis();
		    intarget = NO;
		    if (inbold)		start_bold();
		    if (inunderline)	start_underline();
		}
	    }
	}
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */

d879 2
a880 2
	    LynxChangeStyle (CStyle.style,CStyle.direction);
	    current_style++;
d888 1
a888 1
		    LYaddch('_');
d891 1
a891 11
		    inunderline = YES;
		    if (!intarget) {
#if (defined(DOSPATH) || defined(WIN_EX)) && !defined(USE_SLANG)
			if (LYShowColor == SHOW_COLOR_NEVER)
			    start_bold();
			else
			    start_underline();
#else
			start_underline();
#endif	/* DOSPATH ... */
		    }
d897 1
a897 1
		    LYaddch('_');
a899 8
		    inunderline = NO;
		    if (!intarget) {
#if (defined(DOSPATH) || defined(WIN_EX)) && !defined(USE_SLANG)
		    if (LYShowColor == SHOW_COLOR_NEVER)
			stop_bold();
		    else
			stop_underline();
#else
a900 2
#endif	/* DOSPATH ... */
		    }
d905 1
a905 3
		inbold = YES;
		if (!intarget)
		    start_bold();
d909 1
a909 3
		inbold = NO;
		if (!intarget)
		    stop_bold();
d915 1
a915 1
		    LYaddch('+');
d922 1
a922 1
		    isspace(UCH(LastDisplayChar)) ||
d940 1
a941 1
		/* FALLTHRU */
a943 13
#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
		if (!intarget && cp_tgt && i >= i_start_tgt) {
		    /*
		     *  Start the emphasis.
		     */
		    if (data > cp_tgt) {
			LYstartTargetEmphasis();
			intarget = YES;
		    }
		}
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */
d945 1
a945 2
		if (text->T.output_utf8 && !isascii(UCH(buffer[0]))) {
		    text->has_utf8 = YES;
d973 1
a973 1
		    LYaddstr(buffer);
d977 1
a977 5
		} else if (HTCJK != NOCJK && !isascii(UCH(buffer[0]))
#ifndef CONV_JISX0201KANA_JISX0208KANA
		    && kanji_code != SJIS
#endif
		) {
a980 2
		    if (i >= DISPLAY_COLS) goto after_while;

a981 1
		    buffer[2] = '\0';
d983 1
a983 2
		    i++;
		    LYaddstr(buffer);
d998 1
a998 1
		    LYaddstr(buffer);
a1003 7
after_while:
#if !defined(NCURSES_VERSION)
    if (text->has_utf8) {
	LYtouchline(scrline);
	text->has_utf8 = NO;	/* we had some, but have dealt with it. */
    }
#endif
d1007 1
a1007 1
    LYaddch('\n');
a1008 6
#if defined(SHOW_WHEREIS_TARGETS) && !defined(USE_COLOR_STYLE)
    if (intarget)
	LYstopTargetEmphasis();
#else
#undef intarget
#endif /* SHOW_WHEREIS_TARGETS && !USE_COLOR_STYLE */
d1015 1
a1015 1
	LynxChangeStyle (CStyle.style, CStyle.direction);
d1033 1
a1033 2
    int i = 0, j = 0, toolbar = 0;
    int limit;
d1045 1
a1045 1
	LynxChangeStyle(s_title, STACK_ON);
d1047 1
a1047 1
	LynxChangeStyle(s_title, ABS_ON);
d1056 1
a1056 1
		  HTAnchor_title(text->node_anchor) : " "));	/* "" -> " " */
d1072 1
a1072 9
    limit = LYscreenWidth();
    if (limit < 10) {
	percent[0] = '\0';	/* Null string */
    } else if ((display_lines) <= 0 && LYlines > 0 &&
	text->top_of_screen <= 99999 && text->Lines <= 999999) {
	sprintf(percent, " (l%d of %d)",
		text->top_of_screen, text->Lines);
    } else if ((text->Lines + 1) > (display_lines) &&
	(display_lines) > 0) {
d1102 1
a1102 1
	    (tmp = typecallocn(unsigned char, (strlen(title) + 256)))) {
d1119 8
a1126 28
    LYmove(0, 0);
    LYclrtoeol();
#if defined(SH_EX) && defined(KANJI_CODE_OVERRIDE)
    LYaddstr(str_kcode(last_kcode));
#endif
    if (HText_hasToolbar(text)) {
	LYaddch('#');
	toolbar = 1;
    }
#ifdef USE_COLOR_STYLE
    if (s_forw_backw != NOSTYLE && (nhist || nhist_extra > 1)) {
	int c = nhist ? ACS_LARROW : ' ';

	/* turn the FORWBACKW.ARROW style on */
	LynxChangeStyle(s_forw_backw, STACK_ON);
	if (nhist) {
	    LYaddch(c); LYaddch(c); LYaddch(c);
	} else
	    LYmove(0, 3 + toolbar);
	if (nhist_extra > 1) {
	    LYaddch(ACS_RARROW); LYaddch(ACS_RARROW); LYaddch(ACS_RARROW);
	}
	LynxChangeStyle(s_forw_backw, STACK_OFF);
    }
#endif /* USE_COLOR_STYLE */
    i = (limit - 1) - strlen(percent) - strlen(title);
    if (i >= CHAR_WIDTH) {
	LYmove(0, i);
d1133 2
a1134 15
#ifdef SH_EX	/* 1999/06/15 (Tue) 10:17:28 */
	int last;
	last = (int)strlen(percent) + CHAR_WIDTH;
	if (limit - 3 >= last) {
	    title[(limit - 3) - last] = '.';
	    title[(limit - 2) - last] = '.';
	    title[(limit - 1) - last] = '\0';
	} else {
	    title[(limit - 1) - last] = '\0';
	}
#else
	if ((i = ((limit - 2) - strlen(percent)) - CHAR_WIDTH) >= 0)
	    title[i] = '\0';
#endif
	LYmove(0, CHAR_WIDTH);
d1136 1
a1136 1
    LYaddstr(title);
d1138 2
a1139 2
	LYaddstr(percent);
    LYaddch('\n');
d1144 1
a1144 1
    LynxChangeStyle(s_title, STACK_OFF);
a1150 115
/*	Output the scrollbar
**	---------------------
*/
#ifdef USE_SCROLLBAR
PRIVATE void display_scrollbar ARGS1(
	HText *,	text)
{
    int i;
    int h = display_lines - 2 * (LYsb_arrow!=0); /* Height of the scrollbar */
    int off = (LYsb_arrow != 0);		 /* Start of the scrollbar */
    int top_skip, bot_skip, sh, shown;

    LYsb_begin = LYsb_end = -1;
    if (!LYsb || !text || h <= 2
	|| (text->Lines + 1) <= display_lines)
	return;

    if (text->top_of_screen >= text->Lines + 1 - display_lines) {
	/* Only part of the screen shows actual text */
	shown = text->Lines + 1 - text->top_of_screen;

	if (shown <= 0)
	    shown = 1;
    } else
	shown = display_lines;
    /* Each cell of scrollbar represents text->Lines/h lines of text. */
    /* Always smaller than h */
    sh = (shown*h + text->Lines/2)/(text->Lines + 1);
    if (sh <= 0)
	sh = 1;
    if (sh >= h - 1)
	sh = h - 2;		/* Position at ends indicates BEG and END */

    if (text->top_of_screen == 0)
	top_skip = 0;
    else if (text->Lines - (text->top_of_screen + display_lines - 1) <= 0)
	top_skip = h - sh;
    else {
	/* text->top_of_screen between 1 and text->Lines - display_lines
	   corresponds to top_skip between 1 and h - sh - 1 */
	/* Use rounding to get as many positions into top_skip==h - sh - 1
	   as into top_skip == 1:
	   1--->1, text->Lines - display_lines + 1--->h - sh. */
	top_skip = (int) (1 +
	    1. * (h - sh - 1) * text->top_of_screen
		/ (text->Lines - display_lines + 1));
    }
    bot_skip = h - sh - top_skip;

    LYsb_begin = top_skip;
    LYsb_end = h - bot_skip;

    if (LYsb_arrow) {
#ifdef USE_COLOR_STYLE
	int s = top_skip ? s_sb_aa : s_sb_naa;

	if (last_colorattr_ptr > 0) {
	    LynxChangeStyle(s, STACK_ON);
	} else {
	    LynxChangeStyle(s, ABS_ON);
	}
#endif /* USE_COLOR_STYLE */
	LYmove(1, LYcols + LYshiftWin - 1);
	addch_raw(ACS_UARROW);
#ifdef USE_COLOR_STYLE
	LynxChangeStyle(s, STACK_OFF);
#endif /* USE_COLOR_STYLE */
    }
#ifdef USE_COLOR_STYLE
    if (last_colorattr_ptr > 0) {
	LynxChangeStyle(s_sb_bg, STACK_ON);
    } else {
	LynxChangeStyle(s_sb_bg, ABS_ON);
    }
#endif /* USE_COLOR_STYLE */

    for (i=1; i <= h; i++) {
#ifdef USE_COLOR_STYLE
	if (i-1 <= top_skip && i > top_skip)
	    LynxChangeStyle(s_sb_bar, STACK_ON);
	if (i-1 <= h - bot_skip && i > h - bot_skip)
	    LynxChangeStyle(s_sb_bar, STACK_OFF);
#endif /* USE_COLOR_STYLE */
	LYmove(i + off, LYcols + LYshiftWin - 1);
	if (i > top_skip && i <= h - bot_skip)
	    LYaddch(ACS_BLOCK);
	else
	    LYaddch(ACS_CKBOARD);
    }
#ifdef USE_COLOR_STYLE
    LynxChangeStyle(s_sb_bg, STACK_OFF);
#endif /* USE_COLOR_STYLE */

    if (LYsb_arrow) {
#ifdef USE_COLOR_STYLE
	int s = bot_skip ? s_sb_aa : s_sb_naa;

	if (last_colorattr_ptr > 0) {
	    LynxChangeStyle(s, STACK_ON);
	} else {
	    LynxChangeStyle(s, ABS_ON);
	}
#endif /* USE_COLOR_STYLE */
	LYmove(h + 2, LYcols + LYshiftWin - 1);
	addch_raw(ACS_DARROW);
#ifdef USE_COLOR_STYLE
	LynxChangeStyle(s, STACK_OFF);
#endif /* USE_COLOR_STYLE */
    }
    return;
}
#else
#define display_scrollbar(text) /*nothing*/
#endif /* USE_SCROLLBAR */

d1161 1
a1161 1
#if defined(USE_COLOR_STYLE) && defined(SHOW_WHEREIS_TARGETS)
a1166 1
    int stop_before_for_anchors;
d1186 3
a1188 3
	    LYaddch('*');
	    LYrefresh();
	    LYclear();
d1190 2
a1191 2
	LYaddstr("\n\nError accessing document!\nNo data available!\n");
	LYrefresh();
a1204 1
    if (target && *target == '\0') target = NULL;
a1205 6
    if (display_lines <= 0) {
	/*  No screen space to display anything!
	 *  returning here makes it more likely we will survive if
	 *  an xterm is temporarily made very small. - kw */
	return;
    }
d1219 1
a1219 1
    for (i = 0, line = FirstHTLine(text);		/* Find line */
d1227 3
a1229 3
		LYaddch('*');
		LYrefresh();
		LYclear();
d1231 2
a1232 2
	    LYaddstr("\n\nError drawing page!\nBad HText structure!\n");
	    LYrefresh();
d1249 1
d1251 1
d1257 1
a1258 1
	charset_last_displayed = current_char_set;
d1267 3
a1269 3
	LYaddch('*');
	LYrefresh();
	LYclear();
a1285 1
    text->top_of_screen_line = line;
a1297 9
#ifdef DISP_PARTIAL
    if (display_partial && text->stbl) {
	stop_before_for_anchors = Stbl_getStartLineDeep(text->stbl);
	if (stop_before_for_anchors > line_number+(display_lines))
	    stop_before_for_anchors = line_number+(display_lines);
    } else
#endif
	stop_before_for_anchors = line_number+(display_lines);

d1302 1
a1302 1
#if defined(USE_COLOR_STYLE) && defined(SHOW_WHEREIS_TARGETS)
d1304 1
a1304 8
	int offset, LenNeeded;
#endif
#ifdef DISP_PARTIAL
	if (display_partial ||
	    line_number != text->first_lineno_last_disp_partial)
	    text->has_utf8 = NO;
#else
	text->has_utf8 = NO;
d1315 3
a1317 3
		    LYaddch('*');
		    LYrefresh();
		    LYclear();
d1319 2
a1320 2
		LYaddstr("\n\nError drawing page!\nBad HText structure!\n");
		LYrefresh();
d1332 1
a1332 1
		LYmove((i + 2), 0);
d1335 1
a1335 1
	    display_line(line, text, i+1, target);
d1337 1
a1337 2
#if defined(SHOW_WHEREIS_TARGETS)
#ifdef USE_COLOR_STYLE		/* otherwise done in display_line - kw */
d1345 12
a1356 6
		    (cp = LYno_attr_mb_strstr(data,
					      target,
					      text->T.output_utf8, YES,
					      NULL,
					      &LenNeeded)) != NULL &&
		   ((int)line->offset + LenNeeded) < DISPLAY_COLS) {
d1383 38
a1420 2
		    } else if (&data[itmp] >= cp) {
			if (cp == &data[itmp]) {
d1422 1
a1422 1
			     *  First printable character of target.
d1424 7
a1430 1
			    LYmove((i + 1), x_pos);
d1432 2
d1435 1
a1435 1
			 *  Output all the printable target chars.
d1437 1
a1437 1
			if (text->T.output_utf8 && !isascii(UCH(tmp[0]))) {
d1465 1
a1465 1
			    LYaddstr(tmp);
d1469 1
a1469 1
			} else if (HTCJK != NOCJK && !isascii(UCH(tmp[0]))) {
d1474 1
a1474 1
			    LYaddstr(tmp);
d1478 1
a1478 1
			    LYaddstr(tmp);
d1498 1
a1498 1
		LYmove((i + 2), 0);
d1500 1
a1500 2
#endif /* USE_COLOR_STYLE */
#endif /* SHOW_WHEREIS_TARGETS */
d1511 2
a1512 2
		    LYmove((i + 1), 0);
		    LYclrtoeol();
d1538 1
a1538 1
		Anchor_ptr->line_num <= stop_before_for_anchors;
d1542 1
a1542 1
		Anchor_ptr->line_num < stop_before_for_anchors) {
d1575 3
a1577 3
				CTRACE((tfp,
		    "GridText: display_page: unexpected typed link to %s!\n",
					    link_dest_intl->parent->address));
d1667 1
a1667 1
		    CTRACE((tfp,
d1669 1
a1669 1
			    Anchor_ptr->hightext));
d1687 1
a1687 1
	    CTRACE((tfp, "\ndisplay_page: MAXLINKS reached.\n"));
d1715 1
a1715 1
	LYaddstr("\n     Document is empty");
a1716 1
    display_scrollbar(text);
d1731 1
a1731 8
    if (text->has_utf8 || text->had_utf8) {
	/*
	 *  For other than ncurses, repainting is taken care of
	 *  by touching lines in display_line and highlight. - kw 1999-10-07
	 */
	text->had_utf8 = text->has_utf8;
	clearok(curscr, TRUE);
    } else if (HTCJK != NOCJK) {
a1733 4
	 *
	 *  Full repainting is necessary, otherwise only part of a multibyte
	 *  character sequence might be written because of curses output
	 *  optimizations.
d1735 1
a1735 1
	clearok(curscr, TRUE);
d1737 2
a1738 1
    LYrefresh();
a1755 16
/* LYcols_cu is the notion that the display library has of the screen
   width.  Normally it is the same as LYcols, but there may be a
   difference via SLANG_MBCS_HACK.  Checks of the line length (as the
   non-UTF-8-aware display library would see it) against LYcols_cu are
   is used to try to prevent that lines with UTF-8 chars get wrapped
   by the library when they shouldn't.
   If there is no display library involved, i.e. dump_output_immediately,
   no such limit should be imposed.  MAX_COLS should be just as good
   as any other large value.  (But don't use INT_MAX or something close
   to it to, avoid over/underflow.) - kw */
#ifdef USE_SLANG
#define LYcols_cu (dump_output_immediately ? MAX_COLS : SLtt_Screen_Cols)
#else
#define LYcols_cu (dump_output_immediately ? MAX_COLS : DISPLAY_COLS)
#endif

d1775 19
d1795 2
a1796 42

#ifdef DEBUG_SPLITLINE
#define CTRACE_SPLITLINE(p)	CTRACE(p)
#else
#define CTRACE_SPLITLINE(p)	/*nothing*/
#endif

PRIVATE int set_style_by_embedded_chars ARGS4(
	char *,		s,
	char *,		e,
	unsigned char,	start_c,
	unsigned char,	end_c)
{
    int ret = NO;

    while (--e >= s) {
	if (*e == end_c)
	    break;
	if (*e == start_c) {
	    ret = YES;
	    break;
	}
    }
    return ret;
}

PRIVATE void move_anchors_in_region ARGS7(
    HTLine *,		line,
    int,		line_number,
    TextAnchor **,	prev_anchor,
    int *,		prev_head_processed,
    int,		sbyte,
    int,		ebyte,
    int,		shift)		/* Likewise */
{
    /*
     *  Update anchor positions for anchors that start on this line.
     *  Note: we rely on a->line_pos counting bytes, not
     *  characters.  That's one reason why HText_trimHightext
     *  has to be prevented from acting on these anchors in
     *  partial display mode before we get a chance to
     *  deal with them here.
a1797 210
    TextAnchor *a;
    int head_processed = *prev_head_processed;

    /* We need to know whether (*prev_anchor)->line_pos is "in new
       coordinates" or in old ones.  If prev_anchor' head was touched
       on the previous iteraction, we set head_processed.  The tail
       may need to be treated now. */
    for (a = *prev_anchor;
	 a && a->line_num <= line_number;
	 a = a->next, head_processed = 0) {
	/* extent==0 needs to be special-cased; happens if no text for
	   the anchor was processed yet.  */
	/* Subtract one so that the space is not inserted at the end
	   of the anchor... */
	int last = a->line_pos + (a->extent ? a->extent - 1 : 0);

	/* Include the anchors started on the previous line */
	if (a->line_num < line_number - 1)
	    continue;
	if (a->line_num == line_number - 1)
	    last -= line->prev->size + 1; /* Fake "\n" "between" lines counted too */
	if (last < sbyte)		/* Completely before the start */
	    continue;

	if ( !head_processed		/* a->line_pos is not edited yet */
	     && a->line_num == line_number
	     && a->line_pos >= ebyte)	/* Completely after the end */
	    break;
	/* Now we know that the anchor context intersects the chunk */

	/* Fix the start */
	if ( !head_processed && a->line_num == line_number
	     && a->line_pos >= sbyte ) {
	    a->line_pos += shift;
	    a->extent -= shift;
	    head_processed = 1;
	}
	/* Fix the end */
	if ( last < ebyte )
	    a->extent += shift;
	else
	    break;			/* Keep this `a' for the next step */
    }
    *prev_anchor = a;
    *prev_head_processed = head_processed;
}

/*
 *  Given a line and two int arrays of old/now position, this function
 *  creates a new line where spaces have been inserted/removed
 *  in appropriate places - so that characters at/after the old
 *  position end up at/after the new position, for each pair, if possible.
 *  Some necessary changes for anchors starting on this line are also done
 *  here if needed.
 *  Returns a newly allocated HTLine* if changes were made
 *    (caller has to free the old one).
 *  Returns NULL if no changes needed.  (Remove-spaces code may be buggy...)
 * - kw
 */
PRIVATE HTLine * insert_blanks_in_line ARGS7(
    HTLine *,		line,
    int,		line_number,
    HText *,		text,
    TextAnchor *,	prev_anchor,
    int,		ninserts,
    int *,		oldpos,		/* Measured in cells */
    int *,		newpos)		/* Likewise */
{
    int ioldc = 0;			/* count visible characters */
    int ip;				/* count insertion pairs */
#if defined(USE_COLOR_STYLE)
    int istyle = 0;
#endif
    int added_chars = 0;
    int shift = 0;
    int head_processed;
    HTLine * mod_line;
    char *newdata;
    char *s = line->data;
    char *pre = s;
    char *copied = line->data, *t;

    if (!(line && line->size && ninserts))
	return NULL;
    for (ip = 0; ip < ninserts; ip++)
	if (newpos[ip] > oldpos[ip] &&
	    (newpos[ip] - oldpos[ip]) > added_chars)
	    added_chars = newpos[ip] - oldpos[ip];
    if (line->size + added_chars > MAX_LINE - 2)
	return NULL;
    if (line == text->last_line)
	mod_line = allocHTLine(MAX_LINE);
    else
	mod_line = allocHTLine(line->size + added_chars);
    if (!mod_line)
	return NULL;
    if (!prev_anchor)
	prev_anchor = text->first_anchor;
    head_processed = (prev_anchor && prev_anchor->line_num < line_number);
    memcpy(mod_line, line, LINE_SIZE(1));
    t = newdata = mod_line->data;
    ip = 0;
    while (ip <= ninserts) {
	/* line->size is in bytes, so it may be larger than needed... */
	int curlim = (ip < ninserts
		      ? oldpos[ip]
		      /* Include'em all! */
		      : (line->size <= MAX_LINE ? MAX_LINE+1 : line->size+1));
	pre = s;

	/* Fast forward to char==curlim or EOL.  Stop *before* the
	   style-change chars. */
	while (*s) {
	    if ( text && text->T.output_utf8
		 && UCH(*s) >= 0x80 && UCH(*s) <  0xC0 ) {
		pre = s + 1;
	    } else if (!IsSpecialAttrChar(*s)) { /* At a "displayed" char */
		if (ioldc >= curlim)
		    break;
		ioldc++;
		pre = s + 1;
	    }
	    s++;
	}

	/* Now s is at the "displayed" char, pre is before the style change */
	if (ip)				/* Fix anchor positions */
	    move_anchors_in_region(line, line_number, &prev_anchor,
				   &head_processed,
				   copied - line->data, pre - line->data,
				   shift);
#if defined(USE_COLOR_STYLE)	/* Move styles too */
#define NStyle mod_line->styles[istyle]
	for (; istyle < line->numstyles && (int) NStyle.horizpos < curlim ; istyle++)
	    /* Should not we include OFF-styles at curlim? */
	    NStyle.horizpos += shift;
#endif
	while (copied < pre)	/* Copy verbatim to byte == pre */
	    *t++ = *copied++;
	if (ip < ninserts) {	/* Insert spaces */
	    int delta = newpos[ip] - oldpos[ip] - shift;

	    if (delta < 0) {	/* Not used yet? */
		while (delta++ < 0 && t > newdata && t[-1] == ' ')
		    t--, shift--;
	    } else
		shift = newpos[ip] - oldpos[ip];
	    while (delta-- > 0)
		*t++ = ' ';
	}
	ip++;
    }
    while (pre < s)	/* Copy remaining style-codes */
	*t++ = *pre++;
    /* Check whether the last anchor continues on the next line */
    if (head_processed && prev_anchor && prev_anchor->line_num == line_number)
	prev_anchor->extent += shift;
    *t = '\0';
    mod_line->size = t - newdata;
    return mod_line;
}

#if defined(USE_COLOR_STYLE)
PRIVATE HTStyleChange * skip_matched_and_correct_offsets ARGS3(
	HTStyleChange *,	end,
	HTStyleChange *,	start,
	unsigned,		split_pos)
{ /* Found an OFF change not part of an adjacent matched pair.
   * Walk backward looking for the corresponding ON change.
   * Move everything after split_pos to be at split_pos.
   * This can only work correctly if all changes are correctly
   * nested!  If this fails, assume it is safer to leave whatever
   * comes before the OFF on the previous line alone. */
    int level = 0;
    HTStyleChange *tmp = end;

    for (; tmp >= start; tmp--) {
	if (tmp->style == end->style) {
	    if (tmp->direction == STACK_OFF)
		level--;
	    else if (tmp->direction == STACK_ON) {
		if (++level == 0)
		    return tmp;
	    } else
		return 0;
	}
	if (tmp->horizpos > split_pos)
	    tmp->horizpos = split_pos;
    }
    return 0;
}
#endif /* USE_COLOR_STYLE */

PRIVATE void split_line ARGS2(
	HText *,	text,
	unsigned,	split)
{
    HTStyle * style = text->style;
    HTLine * temp;
    int spare;
    int indent = text->in_line_1 ?
	  text->style->indent1st : text->style->leftIndent;
    short alignment;
    TextAnchor * a;
    int CurLine = text->Lines;
    int HeadTrim = 0;
    int SpecialAttrChars = 0;
    int TailTrim = 0;
    int s, s_post, s_pre, t_underline = underline_on, t_bold = bold_on;
    char *p;
a1799 1
    int utfxtra_on_previous_line = utfxtra_on_this_line;
a1802 4

    /*
     *  Make new line.
     */
d1805 1
a1806 1
    utfxtra_on_this_line = 0;	/*reset too, we'll count them*/
d1810 2
a1811 2
    CTRACE((tfp,"GridText: split_line(%p,%d) called\n", text, split));
    CTRACE((tfp,"   bold_on=%d, underline_on=%d\n", bold_on, underline_on));
a1813 19
    cp = previous->data;
    /* Float LY_SOFT_NEWLINE to the start */
    if (cp[0] == LY_BOLD_START_CHAR
     || cp[0] == LY_UNDERLINE_START_CHAR) {
	switch (cp[1]) {
	    case LY_SOFT_NEWLINE:
		cp[1] = cp[0];
		cp[0] = LY_SOFT_NEWLINE;
		break;
	    case LY_BOLD_START_CHAR:
	    case LY_UNDERLINE_START_CHAR:
		if (cp[2] == LY_SOFT_NEWLINE) {
		    cp[2] = cp[1];
		    cp[1] = cp[0];
		    cp[0] = LY_SOFT_NEWLINE;
		}
		break;
	}
    }
d1815 1
a1815 1
	CTRACE((tfp,
d1817 1
a1817 1
	       split, previous->size));
d1823 1
a1823 1
	    CTRACE((tfp, "                split adjusted to %d.\n", split));
d1839 5
a1843 15
    alignment = style->alignment;

    if (split > 0) { /* Restore flags to the value at the splitting point */
	if (!(dump_output_immediately && use_underscore))
	    t_underline = set_style_by_embedded_chars(
		previous->data, previous->data + split,
		LY_UNDERLINE_START_CHAR, LY_UNDERLINE_END_CHAR);

	t_bold = set_style_by_embedded_chars(
	    previous->data, previous->data + split,
	    LY_BOLD_START_CHAR, LY_BOLD_END_CHAR);

    }

    if (!(dump_output_immediately && use_underscore) && t_underline) {
a1846 1
	SpecialAttrChars++;
d1848 4
a1851 1
    if (t_bold) {
a1854 1
	SpecialAttrChars++;
d1861 1
a1861 1
	char *prevdata = previous->data, *linedata = line->data;
d1865 3
a1867 1
	/* Split the line. - FM */
d1876 7
a1882 16
	while ((
		(*p == ' '
#ifdef EXP_JUSTIFY_ELTS
		/* if justification is allowed for prev line, then raw
		 * HT_NON_BREAK_SPACE are still present in data[] (they'll be
		 * substituted at the end of this function with ' ') - VH
		 */
		 || *p == HT_NON_BREAK_SPACE
#endif
		)
		&& (HeadTrim || text->first_anchor ||
		    underline_on || bold_on ||
		    alignment != HT_LEFT ||
		    style->wordWrap || style->freeFormat ||
		    style->spaceBefore || style->spaceAfter)) ||
		*p == LY_SOFT_HYPHEN) {
d1886 47
d1934 34
a1967 2
	plen = strlen(p);
	if (plen) {			/* Count funny characters */
d1969 1
a1969 3
		if (p[i] == LY_UNDERLINE_START_CHAR ||
		    p[i] == LY_UNDERLINE_END_CHAR ||
		    p[i] == LY_BOLD_START_CHAR ||
d1971 2
a1972 1
		    p[i] == LY_SOFT_HYPHEN)
d1974 2
a1975 3
		else if (IS_UTF_EXTRA(p[i]))
		    utfxtra_on_this_line++;
		if (p[i] == LY_SOFT_HYPHEN && (int)text->permissible_split < i)
d1977 1
d1979 1
a1979 1
	    ctrl_chars_on_this_line += utfxtra_on_this_line;
d1981 5
a1985 4
	    /* Add the data to the new line. - FM */
	    strcat(linedata, p);
	    line->size += plen;
	}
d1991 14
a2004 27
    p = previous->data + previous->size - 1;
    while (p >= previous->data
	   && (*p == ' '
#ifdef EXP_JUSTIFY_ELTS
	    /* if justification is allowed for prev line, then raw
	     * HT_NON_BREAK_SPACE are still present in data[] (they'll be
	     * substituted at the end of this function with ' ') - VH
	     */
	       || *p == HT_NON_BREAK_SPACE
#endif
	      )
#ifdef USE_PRETTYSRC
	   && !psrc_view /*don't strip trailing whites - since next line can
		start with LY_SOFT_NEWLINE - so we don't lose spaces when
		'p'rinting this text to file -VH */
#endif
	   && (ctrl_chars_on_this_line || HeadTrim || text->first_anchor ||
	       underline_on || bold_on ||
	       alignment != HT_LEFT ||
	       style->wordWrap || style->freeFormat ||
	       style->spaceBefore || style->spaceAfter)) {
	p--;	/*  Strip trailers. */
    }
    TailTrim = previous->data + previous->size - 1 - p;	/*  Strip trailers. */
    previous->size -= TailTrim;
    p[1] = '\0';

a2014 3
    s_post = s + HeadTrim;
    s_pre  = s - TailTrim;

d2019 1
a2019 1
	CTRACE((tfp,"GridText: split_line(%d [now:%d]) called\n", split, s));
d2023 1
a2023 1
    line->styles = stylechanges_buffers[stylechanges_buffers_free = (stylechanges_buffers_free + 1) &1];
d2025 117
a2141 17
    {
	HTStyleChange *from = previous->styles + previous->numstyles - 1;
	HTStyleChange *to = line->styles + MAX_STYLES_ON_LINE - 1;
	HTStyleChange *scan, *at_end;

	/*  Color style changes after the split position
	 *  are transferred to the new line.  Ditto for changes
	 *  in the trimming region, but we stop when we reach an OFF change.
	 *  The second loop below may then handle remaining changes. - kw */
	while (from >= previous->styles && to >= line->styles) {
	    *to = *from;
	    if ((int) to->horizpos > s_post)
		to->horizpos += - s_post + SpecialAttrChars;
	    else if ((int) to->horizpos > s_pre &&
		     (to->direction == STACK_ON ||
		      to->direction == ABS_ON))
		to->horizpos = ((int) to->horizpos < s) ? 0 : SpecialAttrChars;
d2143 6
a2148 3
		break;
	    to--;
	    from--;
d2150 2
a2151 2
	/* FROM may be invalid, otherwise it is either an ON change at or
	   before s_pre, or is an OFF change at or before s_post.  */
d2153 3
a2155 64
	scan = from;
	at_end = from;
	/* Now on the previous line we have a correctly nested but
	   possibly non-terminated sequence of style changes.
	   Terminate it, and duplicate unterminated changes at the
	   beginning of the new line. */
	while (scan >= previous->styles && at_end >= previous->styles) {
	    /* The algorithm: scan back though the styles on the previous line.
	       a) If OFF, skip the matched group.
		  Report a bug on failure.
	       b) If ON, (try to) cancel the corresponding ON at at_end,
		  and the corresponding OFF at to;
		  If not, put the corresponding OFF at at_end, and copy to to;
	     */
	    if (scan->direction == STACK_OFF) {
		scan = skip_matched_and_correct_offsets(scan, previous->styles,
							s_pre);
		if (!scan) {
		    CTRACE((tfp, "BUG: styles improperly nested.\n"));
		    break;
		}
	    } else if (scan->direction == STACK_ON) {
		if ( at_end->direction == STACK_ON
		     && at_end->style == scan->style
		     && (int) at_end->horizpos >= s_pre )
		    at_end--;
		else if (at_end >= previous->styles + MAX_STYLES_ON_LINE - 1) {
		    CTRACE((tfp, "BUG: style overflow before split_line.\n"));
		    break;
		} else {
		    at_end++;
		    at_end->direction = STACK_OFF;
		    at_end->style = scan->style;
		    at_end->horizpos = s_pre;
		}
		if ( to < line->styles + MAX_STYLES_ON_LINE - 1
		     && to[1].direction == STACK_OFF
		     && to[1].horizpos <= SpecialAttrChars
		     && to[1].style == scan->style )
		    to++;
		else if (to >= line->styles) {
		    *to = *scan;
		    to->horizpos = SpecialAttrChars;
		    to--;
		} else {
		    CTRACE((tfp, "BUG: style overflow after split_line.\n"));
		    break;
		}
	    }
	    if ((int) scan->horizpos > s_pre)
		scan->horizpos = s_pre;
	    scan--;
	}
	line->numstyles = line->styles + MAX_STYLES_ON_LINE - 1 - to;
	if (line->numstyles > 0 && line->numstyles < MAX_STYLES_ON_LINE) {
	    int n;

	    for (n = 0; n < line->numstyles; n++)
		line->styles[n] = to[n + 1];
	} else if (line->numstyles == 0)
	    line->styles[0].horizpos = ~0; /* ?!!! */
	previous->numstyles = at_end - previous->styles + 1;
	if (previous->numstyles == 0)
	    previous->styles[0].horizpos = ~0;	/* ?!!! */
d2157 11
a2173 6
#if defined(USE_COLOR_STYLE)
    ALLOC_IN_POOL((text->styles_pool),HTStyleChangePool,previous->numstyles,temp->styles);
    memcpy(temp->styles, previous->styles, sizeof(HTStyleChange)*previous->numstyles);
    if (!temp->styles)
	outofmem(__FILE__, "split_line_2");
#endif
d2189 2
a2190 6
    if (
#ifdef EXP_JUSTIFY_ELTS
	this_line_was_split ||
#endif
	(alignment == HT_CENTER ||
	 alignment == HT_RIGHT) || text->stbl) {
a2200 4
	if ((previous->size > 0) &&
		(int)(previous->data[previous->size-1] == LY_SOFT_HYPHEN))
	    ctrl_chars_on_previous_line--;

d2202 1
a2202 1
	spare =  (WRAP_COLS(text)-1) -
d2204 5
a2208 49
	    ctrl_chars_on_previous_line - previous->size;
	if (spare < 0 && LYwideLines)	/* Can be wider than screen */
	    spare = 0;

	if (spare > 0 && !dump_output_immediately &&
	    text->T.output_utf8 && ctrl_chars_on_previous_line) {
	    utfxtra_on_previous_line -= utfxtra_on_this_line;
	    if (utfxtra_on_previous_line) {
		int spare_cu = (LYcols_cu-1) -
		    utfxtra_on_previous_line - indent +
		    ctrl_chars_on_previous_line - previous->size;
		    /*
		     *  Shift non-leftaligned UTF-8 lines that would be
		     *  mishandled by the display library towards the left
		     *  if this would make them fit.  The resulting display
		     *  will not be as intended, but this is better than
		     *  having them split by curses.  (Curses cursor movement
		     *  optimization may still cause wrong positioning within
		     *  the line, in particular after a sequence of spaces).
		     * - kw
		     */
		if (spare_cu < spare) {
		    if (spare_cu >= 0) {
			if (alignment == HT_CENTER &&
			    (int)(previous->offset + indent + spare/2 +
				  previous->size)
			    - ctrl_chars_on_previous_line
			    + utfxtra_on_previous_line <= (LYcols_cu - 1))
			    /* do nothing - it still fits - kw */;
			else {
			    spare = spare_cu;
			    if (alignment == HT_CENTER) {
				/*
				 *  Can't move towars center all the way,
				 *  but at least make line contents appear
				 *  as far right as possible. - kw
				 */
				alignment = HT_RIGHT;
			    }
			}
		    } else if (indent + (int)previous->offset + spare_cu >= 0)
		    { /* subtract overdraft from effective indentation */
			indent += (int)previous->offset + spare_cu;
			previous->offset = 0;
			spare = 0;
		    }
		}
	    }
	}
d2225 1
a2225 17
    if (text->stbl)
	/*
	 *  Notify simple table stuff of line split, so that it can
	 *  set the last cell's length.  The last cell should and
	 *  its row should really end here, or on one of the following
	 *  lines with no more characters added after the break.
	 *  We don't know whether a cell has been started, so ignore
	 *  errors here.
	 *  This call is down here because we need the
	 *  ctrl_chars_on_previous_line, which have just been re-
	 *  counted above. - kw
	 */
	Stbl_lineBreak(text->stbl,
		       text->Lines - 1,
		       previous->offset,
		       previous->size - ctrl_chars_on_previous_line);

d2233 1
a2233 1
    if (s > 0) {			/* if not completely empty */
a2234 11
	int moved = 0;

	/* In the algorithm below we move or not move anchors between
	   lines using some heuristic criteria.  However, it is
	   desirable not to have two consequent anchors on different
	   lines *in a wrong order*!  (How can this happen?)
	   So when the "reasonable choice" is not unique, we use the
	   MOVED flag to choose one.
	 */
	/* Our operations can make a non-empty all-whitespace link
	   empty.  So what? */
d2237 8
a2244 20
		int len = a->extent, n = a->number, start = a->line_pos;
		int end = start + len;

		/* Which anchors do we leave on the previous line?
		   a) empty finished (We need a cut-off value.
		      "Just because": those before s;
		      this is the only case when we use s, not s_pre/s_post);
		   b) Those which start before s_pre;
		 */
		if (start < s_pre) {
		    if (end <= s_pre)
			continue;	/* No problem */

		    CTRACE_SPLITLINE((tfp, "anchor %d: no relocation", n));
		    if (end > s_post) {
			CTRACE_SPLITLINE((tfp, " of the start.\n"));
			a->extent += -(TailTrim + HeadTrim) - SpecialAttrChars;
		    } else {
			CTRACE_SPLITLINE((tfp, ", cut the end.\n"));
			a->extent = s_pre - start;
d2247 110
a2356 5
		} else if (start < s && !len
			   && (!n || (a->show_anchor && !moved))) {
		    CTRACE_SPLITLINE((tfp, "anchor %d: no relocation, empty-finished",
				      n));
		    a->line_pos = s_pre; /* Leave at the end of line */
d2359 13
d2373 4
a2376 24
		/* The rest we relocate */
		moved = 1;
		a->line_num++;
		CTRACE_SPLITLINE((tfp, "anchor %d: (T,H,S)=(%d,%d,%d); (line,pos,ext):(%d,%d,%d), ",
		       n, TailTrim,HeadTrim,SpecialAttrChars,
		       a->line_num,a->line_pos,a->extent));
		if (end < s_post) {	/* Move the end to s_post */
		    CTRACE_SPLITLINE((tfp, "Move end +%d, ", s_post - end));
		    len += s_post - end;
		}
		if (start < s_post) {	/* Move the start to s_post */
		    CTRACE_SPLITLINE((tfp, "Move start +%d, ", s_post - start));
		    len -= s_post - start;
		    start = s_post;
		}
		a->line_pos = start - s_post + SpecialAttrChars;
		a->extent = len;

		CTRACE_SPLITLINE((tfp, "->(%d,%d,%d)\n",
		       a->line_num,a->line_pos,a->extent));
	    } else if (a->line_num > CurLine)
		break;
	}
    }
a2377 60
#ifdef EXP_JUSTIFY_ELTS
    /* now perform justification - by VH */

    if (this_line_was_split
     && spare
     && !text->stbl	/* We don't inform TRST on the cell width change yet */
     && justify_max_void_percent > 0
     && justify_max_void_percent <= 100
     && justify_max_void_percent >= ((100*spare)
				  / ((WRAP_COLS(text) - 1)
				   - (int)style->rightIndent
				   - indent
				   + ctrl_chars_on_previous_line))) {
	/* this is the only case when we need justification*/
	char* jp = previous->data + justify_start_position;
	ht_run_info* r = ht_runs;
	char c;
	int total_byte_len = 0, total_cell_len = 0;
	int d_, r_;
	HTLine * jline;

	ht_num_runs = 0;
	r->byte_len = r->cell_len = 0;

	for(; (c = *jp) != 0; ++jp) {
	    if (c == ' ') {
		total_byte_len += r->byte_len;
		total_cell_len += r->cell_len;
		++r;
		++ht_num_runs;
		r->byte_len = r->cell_len = 0;
		continue;
	    }
	    ++r->byte_len;
	    if ( IsSpecialAttrChar(c) )
		continue;

	    ++r->cell_len;
	    if (c == HT_NON_BREAK_SPACE) {
		*jp = ' ';	/* substitute it */
		continue;
	    }
	    if (text->T.output_utf8 && !isascii(UCH(c))) {
		int utf_extra = 0;
		if ((c & 0xe0) == 0xc0) {
		    utf_extra = 1;
		} else if ((c & 0xf0) == 0xe0) {
		    utf_extra = 2;
		} else if ((c & 0xf8) == 0xf0) {
		    utf_extra = 3;
		} else if ((c & 0xfc) == 0xf8) {
		    utf_extra = 4;
		} else if ((c & 0xfe) == 0xfc) {
		    utf_extra = 5;
		} else
		    utf_extra = 0;
		if ( (int) strlen(jp+1) < utf_extra)
		    utf_extra = 0;
		r->byte_len += utf_extra;
		jp += utf_extra;
d2380 1
a2380 98
	total_byte_len += r->byte_len;
	total_cell_len += r->cell_len;
	++ht_num_runs;

	if (ht_num_runs != 1) {
	    int *oldpos = (int*)malloc(sizeof(int)*2*(ht_num_runs - 1));
	    int *newpos = oldpos + ht_num_runs - 1;
	    int i = 1;

	    if (oldpos == NULL)
		outofmem(__FILE__, "split_line_3");

	    d_ = spare/(ht_num_runs-1);
	    r_ = spare % (ht_num_runs-1);

	    /* The first run is not moved, proceed to the second one */
	    oldpos[0] = justify_start_position + ht_runs[0].cell_len + 1;
	    newpos[0] = oldpos[0] + ( d_ + ( r_--  > 0 ) );
	    while (i < ht_num_runs - 1) {
		int delta = ht_runs[i].cell_len + 1;

		oldpos[i] = oldpos[i-1] + delta;
		newpos[i] = newpos[i-1] + delta + ( d_ + ( r_--  > 0 ) );
		i++;
	    }
	    jline = insert_blanks_in_line(previous, CurLine, text,
					  last_anchor_of_previous_line,
					  ht_num_runs - 1, oldpos, newpos);
	    free((char*)oldpos);
	    if (jline == NULL)
		outofmem(__FILE__, "split_line_4");
	    previous->next->prev = jline;
	    previous->prev->next = jline;

	    FREE(previous);

	    previous = jline;
	}
	{ /* (ht_num_runs==1) */
	    /* keep maintaining 'last_anchor_of_previous_line' */
	    TextAnchor* a2 = last_anchor_of_previous_line;
	    if (justify_start_position) {
		char* p2 = previous->data;
		for( ; p2 < previous->data + justify_start_position; ++p2)
		    *p2 = (*p2 == HT_NON_BREAK_SPACE ? ' ' : *p2);
	    }

	    if (!a2)
		a2 = text->first_anchor;
	    else if (a2 == text->last_anchor)
		a2 = NULL;
	    else
		a2 = a2->next; /* 1st anchor on line we justify */

	    if (a2)
		for (; a2 && a2->line_num <= text->Lines-1;
		    last_anchor_of_previous_line = a2, a2 = a2->next);
	}
    } else {
	if (REALLY_CAN_JUSTIFY(text) ) {
	    char* p2;

	    /* it was permitted to justify line, but this function was called
	     * to end paragraph - we must substitute HT_NON_BREAK_SPACEs with
	     * spaces in previous line
	     */
	    if (line->size && !text->stbl) {
		  CTRACE((tfp,"BUG: justification: shouldn't happen - new line is not empty!\n"));
	    }

	    for (p2=previous->data;*p2;++p2)
		if (*p2 == HT_NON_BREAK_SPACE)
		    *p2 = ' ';
	} else if (have_raw_nbsps) {
	    /* this is very rare case, that can happen in forms placed in
	       table cells*/
	    unsigned i;

	    for (i = 0; i< previous->size; ++i)
		if (previous->data[i] == HT_NON_BREAK_SPACE)
		    previous->data[i] = ' ';

	    /*next line won't be justified, so substitute nbsps in it too */
	    for (i = 0; i< line->size; ++i)
		if (line->data[i] == HT_NON_BREAK_SPACE)
		    line->data[i] = ' ';
	}

	/* else HT_NON_BREAK_SPACEs were substituted with spaces in
	   HText_appendCharacter */
    }
	/* cleanup */
    can_justify_this_line = TRUE;
    justify_start_position = 0;
    this_line_was_split = FALSE;
    have_raw_nbsps = FALSE;
#endif /* EXP_JUSTIFY_ELTS */
    return;
a2394 7

#ifdef USE_COLOR_STYLE
	/* Style-change petty requests at the start of the document: */
	if (line == text->last_line && newlines == 1)
	    return;			/* Do not add a blank line at start */
#endif

d2442 1
a2442 1
    CTRACE((tfp, "GridText: Change to style %s\n", style->name));
d2454 1
a2454 1
	int,		ch)
d2458 1
a2458 1
    int indent, utfx;
a2460 4
#ifdef CJK_EX
    static unsigned char save_ch = 0;
#endif

d2494 2
a2495 2
	    CTRACE((tfp, "add(%s %d special char) %d/%d\n", special, ch,
		   HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
d2497 2
a2498 22
#ifdef CJK_EX	/* 1998/08/30 (Sun) 13:26:23 */
	    if (save_ch == 0) {
		if (IS_SJIS_HI1(ch) || IS_SJIS_HI2(ch)) {
		    save_ch = ch;
		} else {
		    CTRACE((tfp, "add(%c) %d/%d\n", ch,
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
		}
	    } else {
		CTRACE((tfp, "add(%c%c) %d/%d\n", save_ch, ch,
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
		save_ch = 0;
	    }
#else
	    if (ch < 0x80) {
		CTRACE((tfp, "add(%c) %d/%d\n", ch,
		    HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
	    } else {
		CTRACE((tfp, "add(%02x) %d/%d\n", ch,
		    HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
	    }
#endif	/* CJK_EX */
d2525 2
a2526 98
	text->halted = 3;
	return;
    }
#ifdef USE_TH_JP_AUTO_DETECT
    if ((HTCJK == JAPANESE) && (text->detected_kcode != DET_MIXED) &&
	(text->specified_kcode != SJIS) && (text->specified_kcode != EUC)) {
	unsigned char c;
	enum _detected_kcode save_d_kcode;

	c = UCH(ch);
	save_d_kcode = text->detected_kcode;
	switch (text->SJIS_status) {
	case SJIS_state_has_bad_code:
	    break;
	case SJIS_state_neutral:
	    if (IS_SJIS_HI1(c) || IS_SJIS_HI2(c)) {
		text->SJIS_status = SJIS_state_in_kanji;
	    }
	    else if ((c & 0x80) && !IS_SJIS_X0201KANA(c)) {
		text->SJIS_status = SJIS_state_has_bad_code;
		if (text->EUC_status == EUC_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_EUC;
	    }
	    break;
	case SJIS_state_in_kanji:
	    if (IS_SJIS_LO(c)) {
		text->SJIS_status = SJIS_state_neutral;
	    }
	    else {
		text->SJIS_status = SJIS_state_has_bad_code;
		if (text->EUC_status == EUC_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_EUC;
	    }
	    break;
	}
	switch (text->EUC_status) {
	case EUC_state_has_bad_code:
	    break;
	case EUC_state_neutral:
	    if (IS_EUC_HI(c)) {
		text->EUC_status = EUC_state_in_kanji;
	    }
	    else if (c == 0x8e) {
		text->EUC_status = EUC_state_in_kana;
	    }
	    else if (c & 0x80) {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	case EUC_state_in_kanji:
	    if (IS_EUC_LOX(c)) {
		text->EUC_status = EUC_state_neutral;
	    }
	    else {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	case EUC_state_in_kana:
	    if ((0xA1<=c)&&(c<=0xDF)) {
		text->EUC_status = EUC_state_neutral;
	    }
	    else {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	}
	if (save_d_kcode != text->detected_kcode) {
	    switch (text->detected_kcode) {
	    case DET_SJIS:
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode seems SJIS.\n"));
		break;
	    case DET_EUC:
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode seems EUC.\n"));
		break;
	    case DET_MIXED:
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode seems mixed!\n"));
		break;
	    default:
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode is unexpected!\n"));
		break;
	    }
	}
a2527 1
#endif /* USE_TH_JP_AUTO_DETECT */
d2531 1
a2531 1
    if (ch == CH_ESC && HTCJK == NOCJK) {		/* decimal 27  S/390 -- gil -- 1504 */
a2532 1
    }
d2543 1
a2543 1
    if (UCH(ch) >= 128 && HTCJK == NOCJK &&
d2545 1
a2545 1
	UCH(ch) < LYlowest_eightbit[current_char_set])
d2549 1
a2549 1
    if (UCH(ch) == 155 && HTCJK == NOCJK) {	/* octal 233 */
a2560 1
    utfx = utfxtra_on_this_line;
d2576 1
a2576 1
	    case S_esc:
a2588 1
		/* FALLTHRU */
d2590 1
a2590 1
	    case S_dollar:
a2595 2
		    if (ch == '@@' || ch == 'B')
			text->kcode = JIS;
d2605 1
a2605 1
	    case S_dollar_paren:
d2617 1
a2617 1
	    case S_paren:
a2633 1
		    text->kcode = JIS;
d2640 1
a2640 1
	    case S_nonascii_text:
a2646 3
		    if (HTCJK == JAPANESE) {
			text->kcode = NOKANJI;
		    }
a2647 6
		} else if (UCH(ch) < 32) {
		    text->state = S_text;
		    text->kanji_buf = '\0';
		    if (HTCJK == JAPANESE) {
			text->kcode = NOKANJI;
		    }
d2656 1
a2656 1
	    case S_jisx0201_text:
a2659 1
		    text->kcode = NOKANJI;
d2666 1
a2666 1
	} /* end switch */
d2673 5
a2677 22
		if ((text->kcode != JIS)
		 && (
#ifdef KANJI_CODE_OVERRIDE
		    (last_kcode == SJIS) ||
		     ((last_kcode == NOKANJI) &&
#endif
		      ((text->kcode == SJIS) ||
#ifdef USE_TH_JP_AUTO_DETECT
		       ((text->detected_kcode == DET_SJIS) &&
			(text->specified_kcode == NOKANJI)) ||
#endif
		       ((text->kcode == NOKANJI) &&
			(text->specified_kcode == SJIS)) )
#ifdef KANJI_CODE_OVERRIDE
		     )
#endif
		    ) &&
		    (UCH(ch) >= 0xA1) &&
		    (UCH(ch) <= 0xDF)) {
#ifdef CONV_JISX0201KANA_JISX0208KANA
		    unsigned char c = UCH(ch);
		    unsigned char kb = UCH(text->kanji_buf);
a2682 3
#endif
		    /* 1998/01/19 (Mon) 09:06:15 */
		    text->permissible_split = (int)text->last_line->size;
d2693 1
a2693 1
	    goto check_WrapSource;
a2698 9
#ifdef CJK_EX	/* MOJI-BAKE Fix! 1997/10/12 -- 10/31 (Fri) 00:22:57 - JH7AYN */
    if (HTCJK != NOCJK &&	/* added condition - kw */
	(ch == LY_BOLD_START_CHAR || ch == LY_BOLD_END_CHAR)) {
	text->permissible_split = (int)line->size;	/* Can split here */
	if (HTCJK == JAPANESE)
	    text->kcode = NOKANJI;
    }
#endif

d2700 2
a2701 6
#if !defined(USE_COLOR_STYLE) || !defined(NO_DUMP_WITH_BACKSPACES)
	if (line->size >= (MAX_LINE-1))
	    return;
#if defined(USE_COLOR_STYLE) && !defined(NO_DUMP_WITH_BACKSPACES)
	if (with_backspaces && HTCJK==NOCJK && !text->T.output_utf8) {
#endif
d2740 5
a2744 5
		if (!IsSpecialAttrChar(UCH(line->data[i])) &&
		    !isspace(UCH(line->data[i])) &&
		    UCH(line->data[i]) != '-' &&
		    UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
		    UCH(line->data[i]) != HT_EN_SPACE) {
a2751 6
#if defined(USE_COLOR_STYLE) && !defined(NO_DUMP_WITH_BACKSPACES)
	} /* if (with_backspaces && HTCJK==HTNOCJK && !text->T.output_utf8) */
	 else
	     return;
#endif

d2761 5
a2765 56
    if (text->T.output_utf8) {
	/*
	 *  Some extra checks for UTF-8 output here to make sure
	 *  memory is not overrun.  For a non-first char, append
	 *  to the line here and return. - kw
	 */
	if (IS_UTF_EXTRA(ch)) {
	    if ((line->size > (MAX_LINE-1))
		|| (indent + (int)(line->offset + line->size) +
		    utfxtra_on_this_line - ctrl_chars_on_this_line +
		    ((line->size > 0) &&
		     (int)(line->data[line->size-1] ==
				LY_SOFT_HYPHEN ?
					     1 : 0)) >= (LYcols_cu-1))
		) {
		if (!text->permissible_split || text->source) {
		    text->permissible_split = line->size;
		    while (text->permissible_split > 0 &&
			   IS_UTF_EXTRA(line->data[text->permissible_split-1]))
			text->permissible_split--;
		    if (text->permissible_split &&
			(line->data[text->permissible_split-1] & 0x80))
			text->permissible_split--;
		    if (text->permissible_split == line->size)
			text->permissible_split = 0;
		}
		split_line(text, text->permissible_split);
		line = text->last_line;
		if (text->source && line->size - ctrl_chars_on_this_line
		    + utfxtra_on_this_line == 0)
		    HText_appendCharacter (text, LY_SOFT_NEWLINE);
	    }
	    line->data[line->size++] = (char) ch;
	    line->data[line->size] = '\0';
	    utfxtra_on_this_line++;
	    ctrl_chars_on_this_line++;
	    return;
	} else if (ch & 0x80) {	/* a first char of UTF-8 sequence - kw */
	    if ((line->size > (MAX_LINE-7))) {
		if (!text->permissible_split || text->source) {
		    text->permissible_split = line->size;
		    while (text->permissible_split > 0 &&
			   (line->data[text->permissible_split-1] & 0x80)
			   == 0xC0) {
			text->permissible_split--;
		    }
		    if (text->permissible_split == line->size)
			text->permissible_split = 0;
		}
		split_line(text, text->permissible_split);
		line = text->last_line;
		if (text->source && line->size - ctrl_chars_on_this_line
		    + utfxtra_on_this_line == 0)
		    HText_appendCharacter (text, LY_SOFT_NEWLINE);
	    }
	}
a2788 9
#ifdef SH_EX	/* 1997/11/01 (Sat) 12:08:54 */
    if (ch == 0x0b) {	/* ^K ??? */
	ch = '\r';
    }
    if (ch == 0x1a) {	/* ^Z ??? */
	ch = '\r';
    }
#endif

d2813 2
a2814 2
	int target, target_cu;	/* Where to tab to */
	int here, here_cu;	/* in _cu we try to guess what curses thinks */
a2825 1
	here_cu = here + utfxtra_on_this_line;
d2853 1
a2853 6
	if (target >= here)
	    target_cu = target;
	else
	    target_cu = target + (here_cu - here);

	if (target > (WRAP_COLS(text)-1) - (int)style->rightIndent &&
a2860 2
	    if (target_cu > (WRAP_COLS(text)-1))
		target -= target_cu - (WRAP_COLS(text)-1);
d2873 1
a2873 3

check_WrapSource:
    if ( (text->source || dont_wrap_pre) && text == HTMainText) {
d2878 3
a2880 10
	int target = (int)(line->offset + line->size) - ctrl_chars_on_this_line;
	int target_cu = target + utfxtra_on_this_line;
	if (target >= (WRAP_COLS(text)-1) - style->rightIndent -
	    (((HTCJK != NOCJK) && text->kanji_buf) ? 1 : 0) ||
	    (text->T.output_utf8 &&
	     target_cu + UTF_XLEN(ch) >= (LYcols_cu-1))
	    ) {
	    int saved_kanji_buf;
	    int saved_state;

a2882 5

	    saved_kanji_buf = text->kanji_buf;
	    saved_state = text->state;
	    text->kanji_buf = '\0';
	    text->state = S_text;
a2883 2
	    text->kanji_buf = saved_kanji_buf;
	    text->state = saved_state;
d2903 1
d2905 2
a2906 4
	(((indent + (int)line->offset + (int)line->size) +
	  (int)style->rightIndent - ctrl_chars_on_this_line) >= (WRAP_COLS(text)-1) ||
	 ((indent + (int)line->offset + (int)line->size) +
	  utfxtra_on_this_line - ctrl_chars_on_this_line) >= (LYcols_cu-1)))
a2913 1
	 (((HTCJK != NOCJK) && text->kanji_buf) ? 1 : 0) +
d2917 1
a2917 9
					     1 : 0))) >= (WRAP_COLS(text) - 1) ||
	(text->T.output_utf8 &&
	 (((indent + (int)line->offset + (int)line->size) +
	   utfxtra_on_this_line - ctrl_chars_on_this_line +
	   UTF_XLEN(ch) +
	   ((line->size > 0) &&
	    (int)(line->data[line->size-1] ==
				LY_SOFT_HYPHEN ?
					     1 : 0))) >= (LYcols_cu - 1)))) {
a2919 4
#ifdef EXP_JUSTIFY_ELTS
	    if (REALLY_CAN_JUSTIFY(text))
		this_line_was_split = TRUE;
#endif
d2931 1
a2931 1
		if ((int)line->size >= (int)(MAX_LINE-1)) {
a2932 1
		}
d2938 1
a2938 9

		if ( (dump_output_immediately|| (crawl && traversal) )
		     && dont_wrap_pre) {
		    if ((int)line->size >= (int)(MAX_LINE-1))
			new_line(text);
		} else {
		    new_line(text);
		}

d2942 1
a2942 1
	 *  Never overrun memory if DISPLAY_COLS is set to a large value - KW
d2950 1
a2950 5
    if (ch == HT_NON_BREAK_SPACE
#ifdef EXP_JUSTIFY_ELTS
     && !REALLY_CAN_JUSTIFY(text)
#endif
     )
d2952 1
a2952 6
#ifdef EXP_JUSTIFY_ELTS
    else
	have_raw_nbsps = TRUE;
#endif

    /* we leave raw HT_NON_BREAK_SPACE otherwise (we'll substitute it later) */
a2956 3
    /*
     * Kanji charactor handling.
     */
a2961 1

d2963 8
a2970 76
	    hi = UCH(text->kanji_buf);
	    lo = UCH(ch);

	    if (HTCJK == JAPANESE) {
		if (text->kcode != JIS) {
		    if (IS_SJIS_2BYTE(hi, lo)) {
			if (IS_EUC(hi, lo)) {
#ifdef KANJI_CODE_OVERRIDE
			    if (last_kcode != NOKANJI)
				text->kcode = last_kcode;
			    else
#endif
				if (text->specified_kcode != NOKANJI)
				    text->kcode = text->specified_kcode;
#ifdef USE_TH_JP_AUTO_DETECT
				else if (text->detected_kcode == DET_EUC)
				    text->kcode = EUC;
				else if (text->detected_kcode == DET_SJIS)
				    text->kcode = SJIS;
#endif
				else if (IS_EUC_X0201KANA(hi, lo) && (text->kcode != EUC))
				    text->kcode = SJIS;
			}
			else
			    text->kcode = SJIS;
		    }
		    else if (IS_EUC(hi, lo))
			text->kcode = EUC;
		    else
			text->kcode = NOKANJI;
		}

		switch (kanji_code) {
		case EUC:
		    if (text->kcode == SJIS) {
			SJIS_TO_EUC1(hi, lo, tmp);
			line->data[line->size++] = tmp[0];
			line->data[line->size++] = tmp[1];
		    } else if (IS_EUC(hi, lo)) {
#ifdef CONV_JISX0201KANA_JISX0208KANA
			JISx0201TO0208_EUC(hi, lo, &hi, &lo);
#endif
			line->data[line->size++] = hi;
			line->data[line->size++] = lo;
		    } else {
			CTRACE((tfp, "This character (%X:%X) doesn't seem Japanese\n", hi, lo));
			line->data[line->size++] = '=';
			line->data[line->size++] = '=';
		    }
		    break;

		case SJIS:
		    if ((text->kcode == EUC) || (text->kcode == JIS))
		    {
#ifndef CONV_JISX0201KANA_JISX0208KANA
			if (IS_EUC_X0201KANA(hi, lo))
			    line->data[line->size++] = lo;
			else
#endif
			{
			    EUC_TO_SJIS1(hi, lo, tmp);
			    line->data[line->size++] = tmp[0];
			    line->data[line->size++] = tmp[1];
			}
		    } else if (IS_SJIS_2BYTE(hi, lo)) {
			line->data[line->size++] = hi;
			line->data[line->size++] = lo;
		    } else {
			line->data[line->size++] = '=';
			line->data[line->size++] = '=';
			CTRACE((tfp, "This character (%X:%X) doesn't seem Japanese\n", hi, lo));
		    }
		    break;

		default:
		    break;
d2972 16
d2993 2
a2994 11
	}
#ifndef CONV_JISX0201KANA_JISX0208KANA
	else if ((HTCJK == JAPANESE) && IS_SJIS_X0201KANA(UCH((ch))) &&
		 (kanji_code == EUC)) {
	    line->data[line->size++] = UCH(0x8e);
	    line->data[line->size++] = ch;
	}
#endif
	else if (HTCJK != NOCJK) {
	    line->data[line->size++] = (char) (
				       (kanji_code != NOKANJI) ?
d2997 1
a2997 1
						   TOUPPER(ch) : ch);
d3000 1
a3000 1
		(char) (font & HT_CAPITALS ? TOUPPER(ch) : ch);
a3017 1
    return;
d3033 1
a3033 11
	if (line->numstyles > 0 && dir == 0 &&
	    line->styles[line->numstyles-1].direction &&
	    line->styles[line->numstyles-1].style == style &&
	    (int) line->styles[line->numstyles-1].horizpos
	    == (int)line->size - ctrl_chars_on_this_line) {
	    /*
	     *  If this is an OFF change directly preceded by an
	     *	ON for the same style, just remove the previous one. - kw
	     */
	    line->numstyles--;
	} else if (line->numstyles < MAX_STYLES_ON_LINE) {
a3034 8
	    /*
	     *  Special chars for bold and underlining usually don't
	     *  occur with color style, but soft hyphen can.
	     *  And in UTF-8 display mode all non-initial bytes are
	     *  counted as ctrl_chars. - kw
	     */
	    if ((int) line->styles[line->numstyles].horizpos >= ctrl_chars_on_this_line)
		line->styles[line->numstyles].horizpos -= ctrl_chars_on_this_line;
d3058 2
a3059 459
/*	Get LastChar element in the text object.
**	----------------------------------------
*/
PUBLIC char HText_getLastChar ARGS1(
	HText *,	text)
{
    if (!text)
	return('\0');

    return((char)text->LastChar);
}

/*	Set IgnoreExcess element in the text object.
**	--------------------------------------------
*/
PUBLIC void HText_setIgnoreExcess ARGS2(
	HText *,	text,
	BOOL,		ignore)
{
    if (!text)
	return;

    text->IgnoreExcess = ignore;
}

/*		Simple table handling - private
**		-------------------------------
*/

/*
 *  HText_insertBlanksInStblLines fixes up table lines when simple table
 *  processing is closed, by calling insert_blanks_in_line for lines
 *  that need fixup.  Also recalculates alignment for those lines,
 *  does additional updating of anchor positions, and makes sure the
 *  display of the lines on screen will be updated after partial display
 *  upon return to mainloop. - kw
 */
PRIVATE int HText_insertBlanksInStblLines ARGS2(
    HText *,		me,
    int,		ncols)
{
    HTLine *line;
    HTLine *mod_line, *first_line = NULL;
    int *	oldpos;
    int *	newpos;
    int		ninserts, lineno;
    int		first_lineno, last_lineno, first_lineno_pass2;
#ifdef EXP_NESTED_TABLES
    int		last_nonempty = -1;
#endif
    int		added_chars_before = 0;
    int lines_changed = 0;
    int max_width = 0, indent, spare, table_offset;
    HTStyle *style;
    short alignment;
    int i = 0;

    lineno = first_lineno = Stbl_getStartLine(me->stbl);
    if (lineno < 0 || lineno > me->Lines)
	return -1;
    /*
     *  oldpos, newpos: allocate space for two int arrays.
     */
    oldpos = typecallocn(int, 2 * ncols);
    if (!oldpos)
	return -1;
    else
	newpos = oldpos + ncols;
    for (line = FirstHTLine(me); i < lineno; line = line->next, i++) {
	if (!line) {
	    free(oldpos);
	    return -1;
	}
    }
    first_lineno_pass2 = last_lineno = me->Lines;
    for (; line && lineno <= last_lineno; line = line->next, lineno++) {
	ninserts = Stbl_getFixupPositions(me->stbl, lineno, oldpos, newpos);
	if (ninserts < 0)
	    continue;
	if (!first_line) {
	    first_line = line;
	    first_lineno_pass2 = lineno;
	    if (TRACE) {
		int ip;
		CTRACE((tfp, "line %d first to adjust  --  newpos:", lineno));
		for (ip = 0; ip < ncols; ip++)
		    CTRACE((tfp, " %d", newpos[ip]));
		CTRACE((tfp, "\n"));
	    }
	}
	if (line == me->last_line) {
	    if (line->size == 0 || !HText_TrueLineSize(line, me, FALSE))
		continue;
	    /*
	     *  Last ditch effort to end the table with a line break,
	     *  if HTML_end_element didn't do it. - kw
	     */
	    if (first_line == line) /* obscure: all table on last line... */
		first_line = NULL;
	    new_line(me);
	    line = me->last_line->prev;
	    if (first_line == NULL)
		first_line = line;
	}
	if (ninserts == 0) {
	    /*  Do it also for no positions (but not error) */
	    int width = HText_TrueLineSize(line, me, FALSE);
	    if (width > max_width)
		max_width = width;
#ifdef EXP_NESTED_TABLES
	    if (nested_tables) {
		if (width && last_nonempty < lineno)
		    last_nonempty = lineno;
	    }
#endif
	    CTRACE((tfp, "line %d true/max width:%d/%d oldpos: NONE\n",
		   lineno, width, max_width));
	    continue;
	}
	mod_line = insert_blanks_in_line(line, lineno, me,
					 me->last_anchor_before_stbl,
					 ninserts, oldpos, newpos);
	if (mod_line) {
	    if (line == me->last_line) {
		me->last_line = mod_line;
	    } else {
		added_chars_before += (mod_line->size - line->size);
	    }
	    line->prev->next = mod_line;
	    line->next->prev = mod_line;
	    lines_changed++;
	    if (line == first_line)
		first_line = mod_line;
	    free(line);
	    line = mod_line;
#ifdef DISP_PARTIAL
	    /*
	     *  Make sure modified lines get fully re-displayed after
	     *  loading with partial display is done.
	     */
	    if (me->first_lineno_last_disp_partial >= 0) {
		if (me->first_lineno_last_disp_partial >= lineno) {
		    me->first_lineno_last_disp_partial =
			me->last_lineno_last_disp_partial = -1;
		} else if (me->last_lineno_last_disp_partial >= lineno) {
		    me->last_lineno_last_disp_partial = lineno - 1;
		}
	    }
#endif
	}
	{
	    int width = HText_TrueLineSize(line, me, FALSE);
	    if (width > max_width)
		max_width = width;
#ifdef EXP_NESTED_TABLES
	    if (nested_tables) {
		if (width && last_nonempty < lineno)
		    last_nonempty = lineno;
	    }
#endif
	    if (TRACE) {
		int ip;
		CTRACE((tfp, "line %d true/max width:%d/%d oldpos:",
		       lineno, width, max_width));
		for (ip = 0; ip < ninserts; ip++)
		    CTRACE((tfp, " %d", oldpos[ip]));
		CTRACE((tfp, "\n"));
	    }
	}
    }
    /*
     *  Line offsets have been set based on the paragraph style, and
     *  have already been updated for centering or right-alignment
     *  for each line in split_line.  Here we want to undo all that, and
     *  align the table as a whole (i.e. all lines for which
     *  Stbl_getFixupPositions returned >= 0).  All those lines have to
     *  get the same offset, for the simple table formatting mechanism
     *  to make sense, and that may not actually be the case at this point.
     *
     *  What indentation and alignment do we want for the table as
     *  a whole?  Let's take most style properties from me->style.
     *  With some luck, it is the appropriate style for the element
     *  enclosing the TABLE.  But let's take alignment from the attribute
     *  of the TABLE itself instead, if it was specified.
     *
     *  Note that this logic assumes that all lines have been finished
     *  by split_line.  The order of calls made by HTML_end_element for
     *  HTML_TABLE should take care of this.
     */
    style = me->style;
    alignment = Stbl_getAlignment(me->stbl);
    if (alignment == HT_ALIGN_NONE)
	alignment = style->alignment;
    indent = style->leftIndent;
    /* Calculate spare character positions */
    spare = (WRAP_COLS(me)-1) -
	(int)style->rightIndent - indent - max_width;
    if (spare < 0 && (int)style->rightIndent + spare >= 0) {
	/*
	 *  Not enough room!  But we can fit if we ignore right indentation,
	 *  so let's do that.
	 */
	spare = 0;
    } else if (spare < 0) {
	spare += style->rightIndent; /* ignore right indent, but need more */
    }
    if (spare < 0 && indent + spare >= 0) {
	/*
	 *  Still not enough room.  But we can move to the left.
	 */
	indent += spare;
	spare = 0;
    } else if (spare < 0) {
	/*
	 *  Still not enough.  Something went wrong.  Try the best we
	 *  can do.
	 */
	CTRACE((tfp, "BUG: insertBlanks: resulting table too wide by %d positions!\n",
	       -spare));
	indent = spare = 0;
    }
    /*
     *  Align left, right or center.
     */
    switch (alignment) {
	case HT_CENTER :
	    table_offset = indent + spare/2;
	    break;
	case HT_RIGHT :
	    table_offset = indent + spare;
	    break;
	case HT_LEFT :
	case HT_JUSTIFY :
	default:
	    table_offset = indent;
	    break;
    } /* switch */

    CTRACE((tfp, "changing offsets"));
    for (line = first_line, lineno = first_lineno_pass2;
	 line && lineno <= last_lineno && line != me->last_line;
	 line = line->next, lineno++) {
	ninserts = Stbl_getFixupPositions(me->stbl, lineno, oldpos, newpos);
	if (ninserts >= 0 && (int) line->offset != table_offset) {
#ifdef DISP_PARTIAL
	    /*  As above make sure modified lines get fully re-displayed */
	    if (me->first_lineno_last_disp_partial >= 0) {
		if (me->first_lineno_last_disp_partial >= lineno) {
		    me->first_lineno_last_disp_partial =
			me->last_lineno_last_disp_partial = -1;
		} else if (me->last_lineno_last_disp_partial >= lineno) {
		    me->last_lineno_last_disp_partial = lineno - 1;
		}
	    }
#endif
	    CTRACE((tfp, " %d:%d", lineno, table_offset - line->offset));
	    line->offset = table_offset;
	}
    }
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	if (max_width)
	    Stbl_update_enclosing(me->stbl, max_width, last_nonempty);
    }
#endif
    CTRACE((tfp, " %d:done\n", lineno));
    free(oldpos);
    return lines_changed;
}

/*		Simple table handling - public functions
**		----------------------------------------
*/

/*	Cancel simple table handling
*/
PUBLIC void HText_cancelStbl ARGS1(
	HText *,	me)
{
    if (!me || !me->stbl) {
	CTRACE((tfp, "cancelStbl: ignored.\n"));
	return;
    }
    CTRACE((tfp, "cancelStbl: ok, will do.\n"));
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	STable_info *stbl = me->stbl;
	while (stbl) {
	    STable_info *enclosing = Stbl_get_enclosing(stbl);
	    Stbl_free(stbl);
	    stbl = enclosing;
	}
    } else
#endif
    Stbl_free(me->stbl);
    me->stbl = NULL;
}

/*	Start simple table handling
*/
PUBLIC void HText_startStblTABLE ARGS2(
	HText *,	me,
	short,		alignment)
{
#ifdef EXP_NESTED_TABLES
    STable_info *current = me->stbl;
#endif

    if (!me)
	return;

#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	if (current)
	    new_line(me);
    } else
#endif
    {
	if (me->stbl)
	    HText_cancelStbl(me);	/* auto cancel previously open table */
    }

    me->stbl = Stbl_startTABLE(alignment);
    if (me->stbl) {
	CTRACE((tfp, "startStblTABLE: started.\n"));
#ifdef EXP_NESTED_TABLES
	if (nested_tables) {
	    Stbl_set_enclosing(me->stbl, current, me->last_anchor_before_stbl);
	}
#endif
	me->last_anchor_before_stbl = me->last_anchor;
    } else {
	CTRACE((tfp, "startStblTABLE: failed.\n"));
    }
}

/*	Finish simple table handling
 *	Return TRUE if the table is nested inside another table.
 */
PUBLIC int HText_endStblTABLE ARGS1(
	HText *,	me)
{
    int ncols, lines_changed = 0;
    STable_info *enclosing = NULL;

    if (!me || !me->stbl) {
	CTRACE((tfp, "endStblTABLE: ignored.\n"));
	return FALSE;
    }
    CTRACE((tfp, "endStblTABLE: ok, will try.\n"));
    ncols = Stbl_finishTABLE(me->stbl);
    CTRACE((tfp, "endStblTABLE: ncols = %d.\n", ncols));
    if (ncols > 0) {
	lines_changed = HText_insertBlanksInStblLines(me, ncols);
	CTRACE((tfp, "endStblTABLE: changed %d lines, done.\n", lines_changed));
#ifdef DISP_PARTIAL
	/* allow HTDisplayPartial() to redisplay the changed lines.
	 * There is no harm if we got several stbl in the document, hope so.
	 */
	NumOfLines_partial -= lines_changed;  /* fake */
#endif  /* DISP_PARTIAL */
    }
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	enclosing = Stbl_get_enclosing(me->stbl);
	me->last_anchor_before_stbl = Stbl_get_last_anchor_before(me->stbl);
    } else
#endif
    Stbl_free(me->stbl);
#ifdef EXP_NESTED_TABLES
    if (nested_tables)
	me->stbl = enclosing;
    else
#endif
    me->stbl = NULL;
    return enclosing != 0;
}

/*	Start simple table row
*/
PUBLIC void HText_startStblTR ARGS2(
	HText *,	me,
	short,		alignment)
{
    if (!me || !me->stbl)
	return;
    if (Stbl_addRowToTable(me->stbl, alignment, me->Lines) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Finish simple table row
*/
PUBLIC void HText_endStblTR ARGS1(
	HText *,	me)
{
    if (!me || !me->stbl)
	return;
    /* should this do something?? */
}

/*	Start simple table cell
*/
PUBLIC void HText_startStblTD ARGS5(
	HText *,	me,
	int,		colspan,
	int,		rowspan,
	short,		alignment,
	BOOL,		isheader)
{
    if (!me || !me->stbl)
	return;
    if (colspan < 0)
	colspan = 1;
    if (colspan > TRST_MAXCOLSPAN) {
	CTRACE((tfp, "*** COLSPAN=%d is too large, ignored!\n", colspan));
	colspan = 1;
    }
    if (rowspan > TRST_MAXROWSPAN) {
	CTRACE((tfp, "*** ROWSPAN=%d is too large, ignored!\n", rowspan));
	rowspan = 1;
    }
    if (Stbl_addCellToTable(me->stbl, colspan, rowspan, alignment, isheader,
			    me->Lines, HText_LastLineOffset(me), HText_LastLineSize(me,FALSE)) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Finish simple table cell
*/
PUBLIC void HText_endStblTD ARGS1(
	HText *,	me)
{
    if (!me || !me->stbl)
	return;
    if (Stbl_finishCellInTable(me->stbl, TRST_ENDCELL_ENDTD,
			       me->Lines, HText_LastLineOffset(me), HText_LastLineSize(me,FALSE)) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Remember COL info / Start a COLGROUP and remember info
*/
PUBLIC void HText_startStblCOL ARGS4(
	HText *,	me,
	int,		span,
	short,		alignment,
	BOOL,		isgroup)
{
    if (!me || !me->stbl)
	return;
    if (span <= 0)
	span = 1;
    if (span > TRST_MAXCOLSPAN) {
	CTRACE((tfp, "*** SPAN=%d is too large, ignored!\n", span));
	span = 1;
    }
    if (Stbl_addColInfo(me->stbl, span, alignment, isgroup) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Finish a COLGROUP
d3061 2
a3062 2
PUBLIC void HText_endStblCOLGROUP ARGS1(
	HText *,	me)
d3064 4
a3067 4
    if (!me || !me->stbl)
	return;
    if (Stbl_finishColGroup(me->stbl) < 0)
	HText_cancelStbl(me);	/* give up */
d3070 2
a3071 1
/*	Start a THEAD / TFOOT / TBODY - remember its alignment info
d3073 3
a3075 3
PUBLIC void HText_startStblRowGroup ARGS2(
	HText *,	me,
	short,		alignment)
d3077 1
a3077 1
    if (!me || !me->stbl)
d3079 2
a3080 2
    if (Stbl_addRowGroup(me->stbl, alignment) < 0)
	HText_cancelStbl(me);	/* give up */
d3096 1
a3096 1
    TextAnchor * a = typecalloc(TextAnchor);
d3102 1
d3124 1
a3124 1
    if (HTAnchor_followMainLink((HTAnchor*)anc)) {
a3133 3
#ifdef USE_PRETTYSRC
	(text->source ? !psrcview_no_anchor_numbering : 1 ) &&
#endif
d3135 1
a3135 1
	 keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED)) {
d3142 1
d3150 2
a3151 2
/* If !really, report whether the anchor is empty. */
PRIVATE BOOL HText_endAnchor0 ARGS3(
d3153 1
a3153 2
	int,		number,
	int,		really)
d3185 2
a3186 2
    CTRACE((tfp, "GridText:HText_endAnchor0: number:%d link_type:%d\n",
			a->number, a->link_type));
d3192 3
a3194 3
	CTRACE((tfp,
	   "BUG: HText_endAnchor0: internal error: last anchor was input field!\n"));
	return FALSE;
d3201 1
a3201 1
	BOOL remove_numbers_on_empty = (BOOL) (
d3203 1
a3203 1
	      keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) &&
d3208 1
a3208 1
		   HTAnchor_followMainLink((HTAnchor *)a->anchor))))));
a3213 12
	int extent_adjust = 0;

	/* Find the length taken by the anchor */
	l = text->Lines;		/* lineno of last */
	while (l > a->line_num) {
	    extent_adjust += start->size;
	    start = start->prev;
	    l--;
	}
	/* Now start is the start line of the anchor */
	extent_adjust += start->size - a->line_pos;
	start = last;			/* Used later */
d3220 2
a3221 1
	a->extent += extent_adjust;
d3238 1
a3238 1
		!isspace(UCH(last->data[j])) &&
d3295 1
a3295 1
		    !isspace(UCH(prev->data[j])) &&
a3328 4
	if (!really) {			/* Just report whether it is empty */
	    a->extent -= extent_adjust;
	    return (BOOL)(i == 0);
	}
d3337 4
a3340 4
	    CTRACE((tfp,
		   "HText_endAnchor0: hidden (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
		   a->line_num, a->line_pos, a->extent,
		   BlankExtent));
d3391 1
a3391 1
		    while (j >= 0 && isdigit(UCH(start->data[j]))) {
d3414 2
d3417 1
d3434 1
a3434 1
			       isdigit(UCH(prev->data[j]))) {
d3452 4
d3470 2
d3473 1
d3506 1
a3506 1
			 isdigit(UCH(prev->data[j - 1])))) {
d3511 1
a3511 1
			       isdigit(UCH(prev->data[j]))) {
d3529 4
d3567 4
a3570 4
		CTRACE((tfp,
		   "HText_endAnchor0: blanks (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
		   a->line_num,a->line_pos,a->extent,
		   BlankExtent));
d3576 1
a3576 1
	     *  and special characters, so set its number
d3591 1
a3591 1
	     *  content, but shorten its extent by any trailing
d3598 2
a3599 2
	    CTRACE((tfp,
		   "->[%d](%d,%d,%d,%d)\n",
d3601 2
a3602 2
		   a->line_num,a->line_pos,a->extent,
		   BlankExtent));
a3604 2
	if (!really)			/* Just report whether it is empty */
	    return FALSE;
a3612 8
    return FALSE;
}

PUBLIC void HText_endAnchor ARGS2(
	HText *,	text,
	int,		number)
{
    HText_endAnchor0(text, number, 1);
a3614 13
/*
    This returns whether the given anchor has blank content. Shamelessly copied
    from HText_endAnchor. The values returned are meaningful only for "normal"
    links - like ones produced by <a href=".">foo</a>, no inputs, etc. - VH
*/
#ifdef MARK_HIDDEN_LINKS
PUBLIC BOOL HText_isAnchorBlank ARGS2(
	HText *,	text,
	int,		number)
{
    return HText_endAnchor0(text, number, 0);
}
#endif /* MARK_HIDDEN_LINKS */
d3634 1
a3634 1
PRIVATE int remove_special_attr_chars ARGS1(
a3637 1
    register int soft_newline_count = 0;
a3642 1
	soft_newline_count += (*cp == LY_SOFT_NEWLINE);
a3648 1
    return soft_newline_count;
d3666 1
a3666 1
    CTRACE((tfp,"Gridtext: Entering HText_endAppend\n"));
a3673 2
	if (text->stbl)
	    HText_cancelStbl(text);
a3680 6
    } else if (text->stbl) {
	/*
	 *  Could happen if TABLE end tag was missing.
	 *  Alternatively we could cancel in this case. - kw
	 */
	HText_endStblTABLE(text);
d3686 1
a3686 1
    line_ptr = FirstHTLine(text);
d3694 3
a3696 2
	CTRACE((tfp, "GridText: Removing bottom blank line: `%s'\n",
			    text->last_line->data));
d3705 2
a3706 2
	CTRACE((tfp, "GridText: New bottom line: `%s'\n",
			    text->last_line->data));
d3713 1
a3713 1
    HText_trimHightext(text, TRUE, -1);
d3736 2
a3737 2
**  hightext2) fields (which should have been NULL up to that point),
**  with special attribute chars removed.
d3741 1
a3741 1
PRIVATE void HText_trimHightext ARGS3(
d3743 1
a3743 2
	BOOLEAN,	final,
	int,		stop_before)
d3745 1
a3745 1
    int cur_line, cur_shift;
d3754 2
a3755 9
    if (final) {
	CTRACE((tfp, "Gridtext: Entering HText_trimHightext (final)\n"));
    } else {
	if (stop_before < 0 || stop_before > text->Lines)
	    stop_before = text->Lines;
	CTRACE((tfp,
	       "Gridtext: Entering HText_trimHightext (partial: 0..%d/%d)\n",
	       stop_before, text->Lines));
    }
d3760 2
a3761 1
    line_ptr = FirstHTLine(text);
a3770 1
	int have_soft_newline_in_1st_line = 0;
d3775 4
a3778 2
	for (; anchor_ptr->line_num > cur_line;
	       line_ptr = line_ptr->next, cur_line++) {
d3788 1
a3788 1
	    if (cur_line >= stop_before)
d3790 1
a3790 2
	    if ( anchor_ptr->line_num >= text->Lines - 1
		 && anchor_ptr->line_pos >= (int) text->last_line->prev->size )
d3811 1
a3811 1
	if (anchor_ptr->line_pos > (int) line_ptr->size) {
d3813 3
d3818 1
d3822 1
a3822 1
	CTRACE((tfp,
d3825 1
a3825 1
	       anchor_ptr->number, anchor_ptr->extent));
d3833 1
a3833 1
	    ch = UCH(line_ptr->data[anchor_ptr->line_pos]);
d3839 1
a3839 1
		ch = UCH(line_ptr->data[anchor_ptr->line_pos]);
d3845 1
d3847 2
a3848 1
	CTRACE((tfp, "anchor text: '%s'\n", line_ptr->data));
d3860 3
a3862 5
		 (prev_a && /* How could this happen? */
		  (prev_a->line_num > anchor_ptr->line_num)))) {
		anchor_ptr->line_num++;
		anchor_ptr->line_pos = 0;
		CTRACE((tfp, "found anchor at end of line\n"));
d3865 1
a3865 1
		CTRACE((tfp, "found anchor at end of line, leaving it there\n"));
d3889 1
a3889 1
		if (cur_line + 1 >= stop_before) {
d3904 1
a3904 4
		/*handle LY_SOFT_NEWLINEs -VH */
		anchor_ptr->hightext2offset +=
			remove_special_attr_chars(anchor_ptr->hightext2);

d3925 1
a3925 1
	    for (; i < anchor_ptr->line_pos; i++) {
d3927 1
a3927 1
		    IsSpecialAttrChar(line_ptr->data[i])) {
a3928 3
		    have_soft_newline_in_1st_line += (line_ptr->data[i] == LY_SOFT_NEWLINE);
		}
	    }
d3938 1
a3938 4
	/*handle LY_SOFT_NEWLINEs -VH */
	anchor_ptr->line_pos += have_soft_newline_in_1st_line;

	CTRACE((tfp, "GridText:     add link on line %d col %d [%d] %s\n",
d3940 1
a3940 1
	       anchor_ptr->number, "in HText_trimHightext"));
d3951 9
d4089 3
a4091 3
    CTRACE((tfp, "HTGetRelLinkNum(%d,%d,%d) -- HTMainText=%p\n",
	   num, rel, cur, HTMainText));
    CTRACE((tfp,"  scrtop=%d, curline=%d, curanchor=%d, display_lines=%d, %s\n",
d4093 1
a4093 1
	   on_screen ? "on_screen" : "0"));
d4099 1
a4099 1
	CTRACE((tfp,"curanchor=%d at line %d on screen\n",curanchor,curline));
d4109 1
a4109 1
	CTRACE((tfp,"  a->line_num=%d, a->number=%d\n", a->line_num, a->number));
d4115 1
a4115 1
    CTRACE((tfp,"  a=%p, l=%p, curanchor=%d\n",a,l,curanchor));
d4177 2
a4178 2
	    !(a->link_type == INPUT_ANCHOR
	      && a->input_field->type == F_HIDDEN_TYPE)) {
d4279 2
a4280 2
				CTRACE((tfp, "HTGetLinkInfo: unexpected typed link to %s!\n",
					    link_dest_intl->parent->address));
d4328 1
a4328 2
	formA->type != F_TEXTAREA_TYPE ||
	formB->type != F_TEXTAREA_TYPE) {
d4335 1
a4335 1
    return (BOOL) (strcmp(formA->name, formB->name) == 0);
d4338 1
a4338 1
#define same_anchor_as_link(i,a,ta_same) (i >= 0 && a &&\
d4343 2
a4344 2
		ta_same))
#define same_anchors(a1,a2,ta_same) (a1 && a2 &&\
d4349 1
a4349 42
		ta_same))

/*
 *  Are there more textarea lines belonging to the same textarea before
 *  (direction < 0) or after (direction > 0) the current one?
 *  On entry, curlink must be the index in links[] of a textarea field. - kw
 */
PUBLIC BOOL HText_TAHasMoreLines ARGS2(
	int,		curlink,
	int,		direction)
{
    TextAnchor *a;
    TextAnchor *prev_a = NULL;

    if (!HTMainText)
	return(NO);
    if (direction < 0) {
	for (a = HTMainText->first_anchor; a; prev_a = a, a = a->next) {
	    if (a->link_type == INPUT_ANCHOR &&
		links[curlink].form == a->input_field) {
		return same_anchors(a, prev_a, TRUE);
	    }
	    if (links[curlink].anchor_number &&
		a->number >= links[curlink].anchor_number)
		break;
	}
	return NO;
    } else {
	for (a = HTMainText->first_anchor; a; a = a->next) {
	    if (a == HTMainText->last_anchor)
		break;
	    if (a->link_type == INPUT_ANCHOR &&
		links[curlink].form == a->input_field) {
		return same_anchors(a, a->next, TRUE);
	    }
	    if (links[curlink].anchor_number &&
		a->number >= links[curlink].anchor_number)
		break;
	}
	return NO;
    }
}
d4412 2
a4413 2
	    !(a->link_type == INPUT_ANCHOR
	      && a->input_field->type == F_HIDDEN_TYPE)) {
d4427 1
a4427 1
	    if (!same_anchors(current.anc, a, ta_skip)) {
d4440 1
a4440 1
		if (same_anchor_as_link(curlink,a, ta_skip)) {
d4449 1
a4449 1
			   same_anchor_as_link(curlink,previous.anc, ta_skip)) {
d4544 7
d4567 1
a4567 1
 *  *data with all IsSpecial characters stripped, its offset and
d4579 1
a4579 1
	CONST char *,	target)
d4597 1
a4597 1
    for (i = 0, line = FirstHTLine(text);
d4615 12
a4626 6
    if (((cp = LYno_attr_mb_strstr(LineData,
				   target,
				   utf_flag, YES,
				   &HitOffset,
				   &LenNeeded)) != NULL) &&
	(LineOffset + LenNeeded) < DISPLAY_COLS) {
d4665 1
a4665 1
#ifdef USE_COLOR_STYLE
a4702 1
    char *suffix;
d4705 1
a4705 2
    CompressFileType method = cftNone;
    CompressFileType second;
d4710 1
a4710 1
    if (!(fn && anchor))
d4716 6
a4721 2
    if (*(fn = LYPathLeaf(fn)) == '\0')
	return;
d4729 1
a4729 1
    if (ce == NULL && ct != 0) {
d4734 21
a4754 21
	if (!strncasecomp(ct, "application/gzip", 16) ||
	    !strncasecomp(ct, "application/x-gzip", 18)) {
	    method = cftGzip;
	} else if (!strncasecomp(ct, "application/compress", 20) ||
		   !strncasecomp(ct, "application/x-compress", 22)) {
	    method = cftCompress;
	} else if (!strncasecomp(ct, "application/bzip2", 17) ||
		   !strncasecomp(ct, "application/x-bzip2", 19)) {
	    method = cftBzip2;
	}
    } else if (ce != 0) {
	if (!strcasecomp(ce, "gzip") ||
	    !strcasecomp(ce, "x-gzip")) {
	    method = cftGzip;
	} else if (!strcasecomp(ce, "compress") ||
		   !strcasecomp(ce, "x-compress")) {
	    method = cftCompress;
	} else if (!strcasecomp(ce, "bzip2") ||
		   !strcasecomp(ce, "x-bzip2")) {
	    method = cftBzip2;
	}
d4762 1
a4762 11
    if ((method == cftNone) && !strip_ok)
	return;

    /*
     * Treat .tgz specially
     */
    if ((dot = strrchr(fn, '.')) != NULL
     && !strcasecomp(dot, ".tgz")) {
	if (method == cftNone) {
	    strcpy(dot, ".tar");
	}
a4763 1
    }
d4770 4
a4773 2
	if (HTCompressFileType(fn, ".", &cp) != cftNone) {
	    if (method == cftNone) {
d4779 1
d4781 3
d4787 47
a4833 16
	if ((second = HTCompressFileType(fn, "-_", &cp)) != cftNone) {
	    if (method == cftNone) {
		/*
		 *  It has a tail which signifies a gzipped
		 *  file for us, but the anchor claims otherwise,
		 *  so tweak the suffix. - FM
		 */
		if (cp == dot+1)
		    cp--;
		*cp = '\0';
	    } else {
		/*
		 *  The anchor claims it's gzipped, and we
		 *  believe it, so force this tail to the
		 *  conventional suffix. - FM
		 */
d4835 1
a4835 1
		*cp = '-';
d4837 1
a4837 1
		*cp = '.';
d4839 4
a4842 4
		if (second == cftCompress)
		    LYUpperCase(cp);
		else
		    LYLowerCase(cp);
a4843 1
	    return;
d4846 7
a4852 14

    switch (method) {
    default:
	suffix = "";
	break;
    case cftCompress:
	suffix = ".Z";
	break;
    case cftGzip:
	suffix = ".gz";
	break;
    case cftBzip2:
	suffix = ".bz2";
	break;
d4858 9
a4866 7
    if (*suffix) {
	if (!dot) {
	    StrAllocCat(*fname, suffix);
	} else if (*++dot == '\0') {
	    StrAllocCat(*fname, suffix + 1);
	} else {
	    StrAllocCat(*fname, suffix);
d4868 3
a4870 1
	    (*fname)[strlen(*fname) - strlen(suffix)] = '-';
d4872 1
a4872 2
	}
    }
d4916 1
a4916 1
	CTRACE((tfp, "GridText: HText_pageDisplay at line %d started\n", line_num));
a4919 1
	int stop_before = -1;
d4929 1
a4929 3
	if (HTMainText && HTMainText->stbl)
	    stop_before = Stbl_getStartLineDeep(HTMainText->stbl);
	HText_trimHightext(HTMainText, FALSE, stop_before);
d4937 1
a4937 1
	LYSleepMsg();
d4944 1
a4944 1
	CTRACE((tfp, "GridText: HText_pageDisplay finished\n"));
d4984 2
a4985 2
	    !(Anchor_ptr->link_type == INPUT_ANCHOR
	      && Anchor_ptr->input_field->type == F_HIDDEN_TYPE))
d5016 1
a5016 1
    return (BOOL) (text->top_of_screen != 0);
d5023 2
a5024 2
    return (BOOL) ((text != 0)
     && ((text->top_of_screen + display_lines) < text->Lines+1));
d5060 16
d5080 3
a5099 21
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	/* text->UCLYhndl is not reset by META, so use a more circumvent way */
	if ( text->node_anchor->UCStages->s[UCT_STAGE_HTEXT].LYhndl
	     != current_char_set )
	    Switch_Display_Charset(text->node_anchor->UCStages->s[UCT_STAGE_HTEXT].LYhndl, SWITCH_DISPLAY_CHARSET_MAYBE);
#endif
	if (HTMainText) {
	    if (HText_hasUTF8OutputSet(HTMainText) &&
		HTLoadedDocumentEightbit() &&
		LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
		text->had_utf8 = HTMainText->has_utf8;
	    } else {
		text->had_utf8 = NO;
	    }
	    HTMainText->has_utf8 = NO;
	    text->has_utf8 = NO;
	}

	HTMainText = text;
	HTMainAnchor = text->node_anchor;

d5105 2
a5106 2
	    /* let lynx do it */
	    /* display_page(text, text->top_of_screen, ""); */
d5168 4
a5171 4
		CTRACE((tfp,
		       "HText: Selecting anchor [%d] at line %d\n",
				     a->number, www_search_result));
		if (!strcmp(selector, LYToolbarName)) {
d5173 2
a5174 2
		}
		return(YES);
d5199 1
a5199 1
	CTRACE((tfp, "HText: No such anchor in this text!\n"));
d5209 4
a5212 4
	 int l = a->line_num;
	 CTRACE((tfp,
	    "HText: Selecting anchor [%d] at line %d\n",
	    a->number, l));
d5314 2
a5315 2
    HText * text = HTMainText;
    return text != 0 ? text->top_of_screen : 0;
d5321 1
a5321 1
    return text->Lines;
d5357 1
a5357 1
    char *new_query = NULL;
d5364 3
a5366 1
    StrAllocCopy(new_query, query);
d5373 1
a5373 1
	HTList_addObject(search_queries, new_query);
d5379 1
a5379 1
	if (!strcmp(old, new_query)) {
d5385 1
a5385 1
    HTList_addObject(search_queries, new_query);
d5408 1
a5408 1
	LYstrncpy(searchstring, ++cp, sizeof(searchstring)-1);
d5438 1
a5438 1
	       (!PreviousSearch && QueryTotal >= 1)) ? RECALL_URL : NORECALL);
d5464 1
a5464 1
		LYstrncpy(searchstring, cp, sizeof(searchstring)-1);
d5495 1
a5495 1
		LYstrncpy(searchstring, cp, sizeof(searchstring)-1);
d5548 5
a5552 3
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
    LYSyslog(tmpaddress);
#endif /* !VMS && SYSLOG_REQUESTED_URLS */
d5573 1
a5573 1
	CTRACE((tfp,"\ndo_www_search: newfile: %s\n",doc->address));
a5590 27
PRIVATE void write_offset ARGS2(
	FILE *,		fp,
	HTLine *,	line)
{
    int i;

    if (line->data[0]) {
	for (i = 0; i < (int)line->offset; i++) {
	     fputc(' ', fp);
	}
    }
}

PRIVATE void write_hyphen ARGS1(
	FILE *,		fp)
{
    if (dump_output_immediately &&
	LYRawMode &&
	LYlowest_eightbit[current_char_set] <= 173 &&
	(LYCharSet_UC[current_char_set].enc == UCT_ENC_8859 ||
	 (LYCharSet_UC[current_char_set].like8859 & UCT_R_8859SPECL)) != 0) {
	fputc(0xad, fp); /* the iso8859 byte for SHY */
    } else {
	fputc('-', fp);
    }
}

d5599 1
a5599 1
	BOOLEAN,	is_reply)
a5603 10
#ifndef NO_DUMP_WITH_BACKSPACES
    HText* text = HTMainText;
    BOOL in_b = FALSE;
    BOOL in_u = FALSE;
    BOOL bs = (BOOL)(!is_reply
		&& text != 0
		&& with_backspaces
		&& HTCJK == NOCJK
		&& !text->T.output_utf8);
#endif
d5608 1
a5608 1
    line = FirstHTLine(HTMainText);
d5610 2
a5611 1
	if (!first && line->data[0] != LY_SOFT_NEWLINE) {
d5613 7
a5619 6
	    /*
	     *  Add news-style quotation if requested. - FM
	     */
	    if (is_reply) {
		fputc('>',fp);
	    }
d5622 6
a5627 2
	first = FALSE;
	write_offset(fp, line);
a5633 11
#ifndef NO_DUMP_WITH_BACKSPACES
		if (in_b) {
		    fputc(line->data[i], fp);
		    fputc('\b',fp);
		    fputc(line->data[i], fp);
		} else if (in_u) {
		    fputc('_',fp);
		    fputc('\b',fp);
		    fputc(line->data[i], fp);
		} else
#endif
d5637 10
a5646 1
		write_hyphen(fp);
a5657 21
#ifndef NO_DUMP_WITH_BACKSPACES
	    else if (bs) {
		switch (line->data[i]) {
		    case LY_UNDERLINE_START_CHAR:
			if (!in_b)
			    in_u = TRUE; /*favor bold over underline*/
			break;
		    case LY_UNDERLINE_END_CHAR:
			in_u = FALSE;
			break;
		    case LY_BOLD_START_CHAR:
			if (in_u)
			    in_u = FALSE; /* turn it off*/
			in_b = TRUE;
			break;
		    case LY_BOLD_END_CHAR:
			in_b = FALSE;
			break;
		}
	    }
#endif
d5689 1
a5689 1
    line = FirstHTLine(HTMainText);
d5696 2
a5697 1
	if (!first && line->data[0] != LY_SOFT_NEWLINE)
d5700 6
a5705 1
	write_offset(fp, line);
d5715 11
a5725 2
		write_hyphen(fp);
	    }
d5739 1
a5739 1
	 keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED)) {
d5759 1
a5759 1
	BOOL on_screen = (BOOL) (tentative_result > HTMainText->top_of_screen &&
d5819 15
a5833 111
PRIVATE BOOL anchor_has_target ARGS2(
	TextAnchor *,	a,
	char *,		target)
{
    OptionType * option;
    char *stars = NULL, *cp;

    /*
     *  Search the hightext string, and hightext2 if present,
     *  taking the case_sensitive setting into account. - FM
     */
    if (LYno_attr_strstr(a->hightext, target)
     || LYno_attr_strstr(a->hightext2, target)) {
	return TRUE;
    }

    /*
     *  Search the relevant form fields, taking the
     *  case_sensitive setting into account. - FM
     */
    if ((a->input_field != NULL && a->input_field->value != NULL) &&
	a->input_field->type != F_HIDDEN_TYPE) {
	if (a->input_field->type == F_PASSWORD_TYPE) {
	    /*
	     *  Check the actual, hidden password, and then
	     *  the displayed string. - FM
	     */
	    if (LYno_attr_strstr(a->input_field->value, target)) {
		return TRUE;
	    }
	    StrAllocCopy(stars, a->input_field->value);
	    for (cp = stars; *cp != '\0'; cp++)
		*cp = '*';
	    if (LYno_attr_strstr(stars, target)) {
		FREE(stars);
		return TRUE;
	    }
	    FREE(stars);
       } else if (a->input_field->type == F_OPTION_LIST_TYPE) {
	    /*
	     *  Search the option strings that are displayed
	     *  when the popup is invoked. - FM
	     */
	    option = a->input_field->select_list;
	    while (option != NULL) {
		if (LYno_attr_strstr(option->name, target)) {
		    return TRUE;
		}
		option = option->next;
	    }
	} else if (a->input_field->type == F_RADIO_TYPE) {
	    /*
	     *  Search for checked or unchecked parens. - FM
	     */
	    if (a->input_field->num_value) {
		cp = checked_radio;
	    } else {
		cp = unchecked_radio;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else if (a->input_field->type == F_CHECKBOX_TYPE) {
	    /*
	     *  Search for checked or unchecked square brackets. - FM
	     */
	    if (a->input_field->num_value) {
		cp = checked_box;
	    } else {
		cp = unchecked_box;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else {
	    /*
	     *  Check the values intended for display.
	     *  May have been found already via the
	     *  hightext search, but make sure here
	     *  that the entire value is searched. - FM
	     */
	    if (LYno_attr_strstr(a->input_field->value, target)) {
		return TRUE;
	    }
	}
    }
    return FALSE;
}

PRIVATE TextAnchor *line_num_to_anchor ARGS1(
    int,	line_num)
{
    TextAnchor *a;

    if (HTMainText != 0) {
	a = HTMainText->first_anchor;
	while (a != 0 && a->line_num < line_num) {
	    a = a->next;
	}
    } else {
	a = 0;
    }
    return a;
}

PRIVATE int line_num_in_text ARGS2(
    HText *,		text,
    HTLine *,		line)
{
    int result = 1;
    HTLine *temp = FirstHTLine(text);
d5835 1
a5835 9
    while (temp != line) {
	temp = temp->next;
	++result;
    }
    return result;
}

/* Computes the 'prev' pointers on demand, and returns the one for the given
 * anchor.
d5837 2
a5838 17
PRIVATE TextAnchor *get_prev_anchor ARGS1(
    TextAnchor *,	a)
{
    TextAnchor *p, *q;

    if (a->prev == 0) {
	if ((p = HTMainText->first_anchor) != 0) {
	    while ((q = p->next) != 0) {
		q->prev = p;
		p = q;
	    }
	}
    }
    return a->prev;
}

PRIVATE int www_search_forward ARGS5(
d5842 1
d5844 2
a5845 1
	int,		count)
d5847 2
a5848 3
    int wrapped = 0;
    TextAnchor *a = line_num_to_anchor(count - 1);
    int tentative_result = -1;
d5851 1
a5851 1
	while ((a != NULL) && a->line_num == (count - 1)) {
d5853 14
a5866 4
		!(a->link_type == INPUT_ANCHOR
		  && a->input_field->type == F_HIDDEN_TYPE)) {
		if (anchor_has_target(a, target)) {
		    adjust_search_result(doc, count, start_line);
d5869 104
d5976 3
d5980 2
a5981 2
	if (LYno_attr_strstr(line->data, target)) {
	    tentative_result = count;
d5983 7
a5989 42
	} else if ((count == start_line && wrapped) || wrapped > 1) {
	    HTUserMsg2(STRING_NOT_FOUND, target);
	    return -1;
	} else if (line == HTMainText->last_line) {
	    count = 0;
	    wrapped++;
	}
	line = line->next;
	count++;
    }
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
    }
    return 0;
}

PRIVATE int www_search_backward ARGS5(
	int,		start_line,
	document *,	doc,
	char *,		target,
	HTLine *,	line,
	int,		count)
{
    int wrapped = 0;
    TextAnchor *a = line_num_to_anchor(count - 1);
    int tentative_result = -1;

    for (;;) {
	while ((a != NULL) && a->line_num == (count - 1)) {
	    if (a->show_anchor &&
		!(a->link_type == INPUT_ANCHOR
		  && a->input_field->type == F_HIDDEN_TYPE)) {
		if (anchor_has_target(a, target)) {
		    adjust_search_result(doc, count, start_line);
		    return 1;
		}
	    }
	    a = get_prev_anchor(a);
	}

	if (LYno_attr_strstr(line->data, target)) {
	    tentative_result = count;
d5991 1
a5991 1
	} else if ((count == start_line && wrapped) || wrapped > 1) {
d5993 4
a5996 4
	    return -1;
	} else if (line == FirstHTLine(HTMainText)) {
	    count = line_num_in_text(HTMainText, LastHTLine(HTMainText)) + 1;
	    wrapped++;
a5997 5
	line = line->prev;
	count--;
    }
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
d5999 1
d6003 1
a6003 1
PUBLIC void www_user_search ARGS4(
d6006 1
a6006 2
	char *,		target,
	int,		direction)
d6010 2
d6020 6
a6025 8
    line = FirstHTLine(HTMainText);
    if (start_line + direction > 0) {
	for (count = 1; count < start_line + direction; line = line->next, count++) {
	    if (line == HTMainText->last_line) {
		line = FirstHTLine(HTMainText);
		count = 1;
		break;
	    }
d6027 8
a6034 3
    } else {
	line = HTMainText->last_line;
	count = line_num_in_text(HTMainText, line);
d6037 18
a6054 4
    if (direction >= 0)
	www_search_forward(start_line, doc, target, line, count);
    else
	www_search_backward(start_line, doc, target, line, count);
d6068 1
a6068 1
    HTSprintf0(&temp, message, (argument == 0) ? "" : argument);
d6160 1
a6160 1
	CTRACE((tfp, "\nHTuncache.. freeing document for '%s'%s\n",
d6166 1
a6166 1
				      " with POST data" : "")));
d6171 1
a6171 1
	CTRACE((tfp, "HTuncache.. HTMainText already is NULL!\n"));
a6175 3

PRIVATE HTProtocol scm = { "source-cache-mem", 0, 0 }; /* dummy - kw */

d6180 1
a6180 1
    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE ||
d6182 1
a6182 1
	!HTMainAnchor->source_cache_file) ||
d6184 1
a6184 1
	!HTMainAnchor->source_cache_chunk))
d6187 1
a6187 1
    if (LYCacheSource == SOURCE_CACHE_FILE && HTMainAnchor->source_cache_file) {
d6192 2
a6193 10
	CTRACE((tfp, "SourceCache: Reparsing file %s\n",
	      HTMainAnchor->source_cache_file));

	/*
	 * This magic FREE(anchor->UCStages) call
	 * stolen from HTuncache_current_document() above.
	 */
	if (!(HTOutputFormat && HTOutputFormat == WWW_SOURCE)) {
	    FREE(HTMainAnchor->UCStages);
	}
d6199 2
a6200 2
	if (HTMainAnchor->content_type) {
	    format = HTAtom_for(HTMainAnchor->content_type);
d6202 2
a6203 2
	    format = HTFileFormat(HTMainAnchor->source_cache_file, NULL, NULL);
	    format = HTCharsetFormat(format, HTMainAnchor,
d6209 8
a6216 1
	CTRACE((tfp, "  Content type is \"%s\"\n", format->name));
d6218 1
a6218 1
	fp = fopen(HTMainAnchor->source_cache_file, "r");
d6220 2
a6221 3
	    CTRACE((tfp, "  Cannot read file %s\n", HTMainAnchor->source_cache_file));
	    LYRemoveTemp(HTMainAnchor->source_cache_file);
	    FREE(HTMainAnchor->source_cache_file);
d6224 4
a6227 1

d6234 6
a6239 11
	/* Set HTMainAnchor->protocol or HTMainAnchor->physical to convince
	 * the SourceCacheWriter to not regenerate the cache file (which
	 * would be an unnecessary "loop"). - kw
	 */
	HTAnchor_setProtocol(HTMainAnchor, &HTFile);
	ret = HTParseFile(format, HTOutputFormat, HTMainAnchor, fp, NULL);
	LYCloseInput(fp);
	if (ret == HT_PARTIAL_CONTENT) {
	    HTInfoMsg(gettext("Loading incomplete."));
	    CTRACE((tfp, "SourceCache: `%s' has been accessed, partial content.\n",
		    HTLoadedDocumentURL()));
a6240 1
	ok = (BOOL) (ret == HT_LOADED || ret == HT_PARTIAL_CONTENT);
d6244 1
a6244 1
	HTMainAnchor->source_cache_chunk) {
d6248 2
a6249 10
	CTRACE((tfp, "SourceCache: Reparsing from memory chunk %p\n",
		    (void *)HTMainAnchor->source_cache_chunk));

	/*
	 * This magic FREE(anchor->UCStages) call
	 * stolen from HTuncache_current_document() above.
	 */
	if (!(HTOutputFormat && HTOutputFormat == WWW_SOURCE)) {
	    FREE(HTMainAnchor->UCStages);
	}
a6250 3
	if (HTMainAnchor->content_type) {
	    format = HTAtom_for(HTMainAnchor->content_type);
	} else {
d6259 2
a6260 3
	    format = HTCharsetFormat(format, HTMainAnchor,
					     UCLYhndl_for_unspec);
	}
d6263 11
d6280 7
a6286 9
	/* Set HTMainAnchor->protocol or HTMainAnchor->physical to convince
	 * the SourceCacheWriter to not regenerate the cache chunk (which
	 * would be an unnecessary "loop"). - kw
	 */
	HTAnchor_setProtocol(HTMainAnchor, &scm); /* cheating -
				   anything != &HTTP or &HTTPS would do - kw */
	ret = HTParseMem(format, HTOutputFormat, HTMainAnchor,
			HTMainAnchor->source_cache_chunk, NULL);
	ok = (BOOL) (ret == HT_LOADED);
d6289 5
a6293 1
    CTRACE((tfp, "Reparse %s\n", (ok ? "succeeded" : "failed")));
d6300 1
a6300 1
    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE ||
d6302 1
a6302 1
	!HTMainAnchor->source_cache_file) ||
d6304 1
a6304 1
	!HTMainAnchor->source_cache_chunk))
d6307 9
a6315 2
    if (LYCacheSource == SOURCE_CACHE_FILE && HTMainAnchor->source_cache_file) {
	return LYCanReadFile(HTMainAnchor->source_cache_file);
d6319 1
a6319 1
	HTMainAnchor->source_cache_chunk) {
d6328 2
a6329 2
	int,		prev_setting,
	int,		new_setting)
d6332 2
a6333 2
	CTRACE((tfp, "HTdocument_settings_changed: %s setting has changed (was %d, now %d)\n",
	       name, prev_setting, new_setting));
d6342 1
a6342 1
    if (!HTMainAnchor || !HTMainText || LYCacheSource == SOURCE_CACHE_NONE ||
d6344 1
a6344 1
	!HTMainAnchor->source_cache_file) ||
d6346 1
a6346 1
	!HTMainAnchor->source_cache_chunk))
a6357 3
	trace_setting_change("VERBOSE_IMG",
			    HTMainText->verbose_img,
			    verbose_img);
d6368 2
a6369 4
	trace_setting_change("KEYPAD_MODE",
			     HTMainText->keypad_mode, keypad_mode);
	if (HTMainText->disp_lines != LYlines || HTMainText->disp_cols != DISPLAY_COLS)
	    CTRACE((tfp,
d6371 1
a6371 1
		   HTMainText->disp_cols, HTMainText->disp_lines, DISPLAY_COLS, LYlines));
a6375 1
	    HTMainText->verbose_img != verbose_img ||
d6378 1
a6378 2
	    (HTMainText->minimal_comments != minimal_comments &&
	     !historical_comments) ||
d6381 2
a6382 2
	    HTMainText->keypad_mode != keypad_mode ||
	    HTMainText->disp_cols != DISPLAY_COLS);
a6494 8
PUBLIC int HText_LastLineOffset ARGS1(
	HText *,	text)
{
    if (!text || !text->last_line)
	return 0;
    return  text->last_line->offset;
}

d6521 1
a6521 1
	    if (!IsSpecialAttrChar(UCH(line->data[i])) &&
d6523 5
a6527 5
		 UCH(line->data[i]) < 128 ||
		 (UCH((line->data[i] & 0xc0)) == 0xc0)) &&
		!isspace(UCH(line->data[i])) &&
		UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
		UCH(line->data[i]) != HT_EN_SPACE) {
d6535 2
a6536 2
		 UCH(line->data[i]) < 128 ||
		 (UCH(line->data[i] & 0xc0) == 0xc0))) {
d6586 2
d6617 1
a6617 1
    int column = (DISPLAY_COLS-2);
d6619 2
a6620 2
	column = ((int)text->style->rightIndent ? (DISPLAY_COLS-2) :
		  ((DISPLAY_COLS-1) - (int)text->style->rightIndent));
d6653 1
a6653 1
	Tab = typecalloc(HTTabID);
d6842 1
a6842 1
    newform = typecalloc(PerFormInfo);
d6850 1
a6850 1
    CTRACE((tfp, "BeginForm: action:%s Method:%d%s%s%s%s%s%s\n",
d6857 1
a6857 1
		(HTFormAcceptCharset ? HTFormAcceptCharset : "")));
d6915 1
a6915 1
	CTRACE((tfp, "endForm:    HTCurrentForm is missing!\n"));
d6935 5
a6939 5
    /*
     *  Save the group name.
     */
    StrAllocCopy(HTCurSelectGroup, name);
    HTCurSelectGroupCharset = name_cs;
d6941 10
a6950 10
    /*
     *  If multiple then all options are actually checkboxes.
     */
    if (multiple)
	HTCurSelectGroupType = F_CHECKBOX_TYPE;
    /*
     *  If not multiple then all options are radio buttons.
     */
    else
	HTCurSelectGroupType = F_RADIO_TYPE;
d6957 1
a6957 1
    CTRACE((tfp,"HText_beginSelect: name=%s type=%d size=%s\n",
d6962 2
a6963 2
				      "<NULL>" : HTCurSelectGroupSize)));
    CTRACE((tfp,"HText_beginSelect: name_cs=%d \"%s\"\n",
d6966 1
a6966 1
		 LYCharSet_UC[HTCurSelectGroupCharset].MIMEname : "<UNKNOWN>")));
d6991 1
a6991 1
    CTRACE((tfp, "HText_getOptionNum: Got number '%d'.\n", n));
d7008 1
a7008 1
    if (keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) {
d7020 2
a7021 2
	    *cp && isdigit(UCH(*cp++))) {
	    while (*cp && isdigit(UCH(*cp)))
d7068 2
a7069 2
	CTRACE((tfp, "HText_setLastOptionValue: invalid call!  value:%s!\n",
		    (value ? value : "<NULL>")));
d7073 2
a7074 2
    CTRACE((tfp, "Entering HText_setLastOptionValue: value:%s, checked:%s\n",
		value, (checked ? "on" : "off")));
d7081 2
a7082 2
	while ((cp >= value) && (isspace(UCH(*cp)) ||
				 IsSpecialAttrChar(UCH(*cp))))
d7091 2
a7092 2
    while (isspace(UCH(*cp)) ||
	   IsSpecialAttrChar(UCH(*cp)))
d7096 1
a7096 1
	keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) {
d7103 2
a7104 2
	    while (isspace(UCH(cp1[i])) ||
		   IsSpecialAttrChar(UCH(cp1[i]))) {
d7151 4
a7154 4
		CTRACE((tfp, "HText_setLastOptionValue: last input_field not F_OPTION_LIST_TYPE (%d)\n",
			    F_OPTION_LIST_TYPE));
		CTRACE((tfp, "                          but %d, ignoring!\n",
			    text->last_anchor->input_field->type));
d7159 1
a7159 1
				typecalloc(OptionType);
d7167 1
a7167 1
		op_ptr = op_ptr->next;
d7171 2
a7172 1
	    op_ptr->next = new_ptr = typecalloc(OptionType);
d7185 2
a7186 2
	while (isspace(UCH(*cp)) ||
	       IsSpecialAttrChar(UCH(*cp)))
d7193 1
a7193 1
		       !IsSpecialAttrChar(UCH(cp[i]))) {
d7200 1
a7200 5
		(tmp = typecallocn(unsigned char, strlen(cp)+1)) != 0) {
#ifdef SH_EX
		if (tmp == NULL)
		    outofmem(__FILE__, "HText_setLastOptionValue");
#endif
d7294 1
a7294 1
	CTRACE((tfp, "HText_setLastOptionValue:%s value=%s",
d7296 2
a7297 2
		value));
	CTRACE((tfp,"            val_cs=%d \"%s\"",
d7300 1
a7300 1
			 LYCharSet_UC[val_cs].MIMEname : "<UNKNOWN>")));
d7302 1
a7302 1
	    CTRACE((tfp, " (submit_val_cs %d \"%s\") submit_value%s=%s\n",
d7308 1
a7308 1
		    submit_value));
d7311 1
a7311 1
	    CTRACE((tfp,"\n"));
d7327 3
a7329 2
    TextAnchor * a = typecalloc(TextAnchor);
    FormInfo * f = typecalloc(FormInfo);
d7335 1
a7335 1
    CTRACE((tfp, "GridText: Entering HText_beginInput\n"));
d7340 1
d7418 1
a7418 1
	if ((tmp = typecallocn(unsigned char, strlen(IValue) + 1)) != 0) {
d7472 1
a7472 1
	    f->size = 20;  /* default */
a7523 1
	    CTRACE((tfp, "ok, got a file uploader\n"));
d7554 2
a7555 2
	    CTRACE((tfp,
		  "GridText: No name present in input field; not displaying\n"));
d7634 1
a7634 1
	    StrAllocCopy(f->value, (f->type == F_CHECKBOX_TYPE ? "on" : ""));
a7671 1
#ifndef EXP_FILE_UPLOAD
a7672 1
#endif
d7679 1
a7679 1
	    if (keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED)
d7685 1
a7685 1
    if (keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED && a->number > 0) {
d7701 1
d7726 1
a7726 1
	    MaximumSize = (WRAP_COLS(text) - 1) -
d7730 6
a7735 8
	    /*  If we are numbering form links, place is taken by [nn]  */
	    if (keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED)
		MaximumSize -= (a->number >= 10	/*Buggy if 1e6 links, sowhat?*/
				? (a->number >= 100
				   ? (a->number >= 1000
				      ? (a->number >= 10000
					 ? (a->number >= 100000
					    ? 6 : 5) : 4) : 3) : 2) : 1) + 2;
d7754 2
a7755 2
	    if (f->size > WRAP_COLS(text)-10)
		f->size = WRAP_COLS(text)-10;  /* maximum */
d7781 1
a7781 1
	CTRACE((tfp, "beginInput: HTCurrentForm is missing!\n"));
d7784 1
a7784 1
    CTRACE((tfp, "Input link: name=%s\nvalue=%s\nsize=%d\n",
d7787 2
a7788 2
			f->size));
    CTRACE((tfp, "Input link: name_cs=%d \"%s\" (from %d \"%s\")\n",
d7794 2
a7795 2
			 LYCharSet_UC[I->name_cs].MIMEname : "<UNKNOWN>")));
    CTRACE((tfp, "            value_cs=%d \"%s\" (from %d \"%s\")\n",
d7801 1
a7801 1
			 LYCharSet_UC[I->value_cs].MIMEname : "<UNKNOWN>")));
d7908 1
a7908 9
/*
 *  HText_SubmitForm - generate submit data from form fields.
 *  For mailto forms, send the data.
 *  For other methods, set fields in structure pointed to by doc
 *  appropriately for next request.
 *  Returns 1 if *doc set appropriately for next request,
 *	    0 otherwise. - kw
 */
PUBLIC int HText_SubmitForm ARGS4(
a7927 1
    char *content_type_out = NULL;
d7942 1
a7942 1
    CTRACE((tfp, "SubmitForm\n  link_name=%s\n  link_value=%s\n", link_name, link_value));
d7944 1
a7944 1
	return 0;
d7949 2
a7950 2
	CTRACE((tfp, "SubmitForm: form %d not in HTMainText's list!\n",
		    form_number));
d7952 2
a7953 2
	CTRACE((tfp, "SubmitForm: failed sanity check, %d!=%d !\n",
		    thisform->number, form_number));
d7964 1
a7964 1
	    return 0;
d7967 1
a7967 1
	return 0;
d8054 1
a8054 2
	    if (anchor_ptr->input_field->number == form_number &&
			!anchor_ptr->input_field->disabled) {
d8068 1
a8068 1
			(*p == HT_EN_SPACE) ||
d8167 1
a8167 2
	 *  so load content_type_out.  This will be put in
	 *  the post_content_type element if all goes well. - FM, kw
d8170 1
a8170 1
	    StrAllocCopy(content_type_out,
d8173 1
a8173 1
	    StrAllocCopy(content_type_out,
d8176 1
a8176 1
	    StrAllocCopy(content_type_out,
d8178 1
a8178 1
	    StrAllocCat(content_type_out, Boundary);
d8180 1
a8180 1
	    StrAllocCopy(content_type_out,
d8211 2
a8212 2
			StrAllocCat(content_type_out, "; charset=");
			StrAllocCat(content_type_out, target_csname);
d8220 1
a8220 1
		LYSleepAlert();
d8225 1
d8237 1
a8237 2
	    if (anchor_ptr->input_field->number == form_number &&
			!anchor_ptr->input_field->disabled) {
d8253 3
a8255 3
			CTRACE((tfp,
				    "SubmitForm: skipping submit field with "));
			CTRACE((tfp, "name \"%s\" for link_name \"%s\", %s.\n",
d8259 1
a8259 1
				    "not current link" : "no field name"));
d8265 9
a8273 7
			CTRACE((tfp,
				"SubmitForm: skipping submit field with "));
			CTRACE((tfp,
				"name \"%s\" for link_name \"%s\", %s!\n",
				form_ptr->name ? form_ptr->name : "???",
				link_name ? link_name : "???",
				"values are different"));
a8275 10
		    /* FALLTHRU */

#ifdef EXP_FILE_UPLOAD
		case F_FILE_TYPE:
		    CTRACE((tfp, "I'd submit %s (from %s), but you've not finished it\n", form_ptr->value, form_ptr->name));
		    name_used = (form_ptr->name ? form_ptr->name : "");
		    val_used = (form_ptr->value ? form_ptr->value : "");
		    break;
#endif

d8318 1
a8318 1
			CTRACE((tfp, "SubmitForm: field \"%s\" %d %s -> %d %s %s\n",
d8326 1
a8326 1
				    success ? "OK" : "FAILED"));
d8331 1
a8331 1
			CTRACE((tfp, "SubmitForm: field \"%s\" %d %s OK\n",
d8334 1
a8334 1
				    target_csname ? target_csname : "???"));
d8343 1
a8343 1
			    LYSleepAlert();
d8408 1
a8408 1
			CTRACE((tfp, "SubmitForm: name \"%s\" %d %s -> %d %s %s\n",
d8416 1
a8416 1
				    success ? "OK" : "FAILED"));
d8430 1
a8430 1
			CTRACE((tfp, "SubmitForm: name \"%s\" %d %s OK\n",
d8433 1
a8433 1
				    target_csname ? target_csname : "???"));
d8445 1
a8445 1
			    LYSleepAlert();
d8467 2
a8468 3
		    CTRACE((tfp, "SubmitForm: What type is %d?\n",
				form_ptr->type));
		    break;
a8475 81
#ifdef EXP_FILE_UPLOAD
		case F_FILE_TYPE:
		{
		    int cdisp_name_startpos = 0;
		    FILE *fd;
		    int bytes;
		    char buffer[257];

		    CTRACE((tfp, "Ok, about to convert %s to mime/thingy\n", form_ptr->value));
		    if (first_one) {
			if (Boundary) {
			    HTSprintf(&query, "--%s\r\n", Boundary);
			}
			first_one = FALSE;
		    } else {
			if (PlainText) {
			    HTSprintf(&query, "\n");
			} else if (SemiColon) {
			    HTSprintf(&query, ";");
			} else if (Boundary) {
			    HTSprintf(&query, "\r\n--%s\r\n", Boundary);
			} else {
			    HTSprintf(&query, "&");
			}
		    }

		    if (PlainText) {
			StrAllocCopy(escaped1, name_used);
		    } else if (Boundary) {
			StrAllocCopy(escaped1,
				"Content-Disposition: form-data; name=");
			cdisp_name_startpos = strlen(escaped1);
			StrAllocCat(escaped1, name_used);
			StrAllocCat(escaped1, "; filename=\"");
			StrAllocCat(escaped1, val_used);
			StrAllocCat(escaped1, "\"");
			if (MultipartContentType) {
			    StrAllocCat(escaped1, MultipartContentType);
			    StrAllocCat(escaped1, "\r\nContent-Transfer-Encoding: base64");
			}
			StrAllocCat(escaped1, "\r\n\r\n");
		    } else {
			escaped1 = HTEscapeSP(name_used, URL_XALPHAS);
		    }

		    if ((fd = fopen(val_used, BIN_R)) == 0) {
			/* We can't open the file, what do we do? */
			HTAlert(gettext("Can't open file for uploading"));
			goto exit_disgracefully;
		    }
		    StrAllocCopy(escaped2, "");
		    while ((bytes = fread(buffer, sizeof(char), 45, fd)) != 0) {
			char base64buf[128];
			base64_encode(base64buf, buffer, bytes);
			StrAllocCat(escaped2, base64buf);
		    }
		    if (ferror(fd)) {
			/* We got an error reading the file, what do we do? */
			HTAlert(gettext("Short read from file, problem?"));
			LYCloseInput(fd);
			goto exit_disgracefully;
		    }
		    LYCloseInput(fd);
		    /* we need to modify the mime-type here - rp */
		    /* Note: could use LYGetFileInfo for that and for
		       other headers that should be transmitted - kw */

		    HTSprintf(&query,
				   "%s%s%s%s%s",
				   escaped1,
				   (Boundary ? "" : "="),
				   (PlainText ? "\n" : ""),
					escaped2,
				   ((PlainText && *escaped2) ?
							 "\n" : ""));
		    FREE(escaped1);
		    FREE(escaped2);
		}
		break;
#endif /* EXP_FILE_UPLOAD */

d8481 1
a8481 1
		     *  its IMAGE_SUBMIT_TYPE is to be handled homologously
d8668 1
a8668 1
			    first_one = FALSE;
d8707 1
a8707 1
			 *  add %0d%0a (\r\n) and the escaped string.
d8719 1
a8719 1
				HTSprintf(&query, "%%0d%%0a%s", escaped2);
d8727 1
a8727 1
				StrAllocCat(previous_blanks, "%0d%0a");
a8811 2
    CTRACE((tfp, "QUERY (%d) >> \n%s\n", strlen(query), query));

d8814 3
a8816 3
	CTRACE((tfp, "\nGridText - mailto_address: %s\n",
			    (submit_item->submit_action+7)));
	CTRACE((tfp, "GridText - mailto_subject: %s\n",
d8821 2
a8822 2
					 HText_getTitle() : ""))));
	CTRACE((tfp,"GridText - mailto_content: %s\n",query));
d8830 1
a8830 1
		 content_type_out);
d8832 2
a8833 2
	FREE(content_type_out);
	return 0;
d8840 1
a8840 3
	FREE(doc->post_content_type);
	doc->post_content_type = content_type_out; /* don't free c_t_out */
	CTRACE((tfp,"GridText - post_data: %s\n",doc->post_data));
d8843 1
a8843 1
	return 1;
a8847 1
	FREE(content_type_out);
d8849 1
a8849 1
	return 1;
a8850 12
#ifdef EXP_FILE_UPLOAD
exit_disgracefully:
    FREE(escaped1);
    FREE(escaped2);
    FREE(previous_blanks);
    FREE(copied_name_used);
    FREE(copied_val_used);
    FREE(MultipartContentType);
    FREE(query);
    FREE(content_type_out);
    return 0;
#endif
d8940 1
a8940 1
	return FALSE;
d9097 1
a9097 1
    return (BOOL) ((text && text->toolbar) ? TRUE : FALSE);
d9111 1
a9111 1
    return (BOOL) ((text && text->no_cache) ? TRUE : FALSE);
d9117 1
a9117 1
    return (BOOL) ((text && text->T.output_utf8) ? TRUE : FALSE);
a9134 2
    BOOL explicit;

a9143 1
    explicit = charset ? TRUE : FALSE;
d9163 2
a9164 10
    /*  If charset isn't specified explicitely nor assumed,
     *  p_in->MIMEname would be set as display charset.
     *  So text->kcode sholud be set as SJIS or EUC here only if charset
     *  is specified explicitely, otherwise text->kcode would cause
     *  mishandling Japanese strings. -- TH
     */
    if (explicit && (!strcmp(charset, "shift_jis") ||
	!strcmp(charset, "x-sjis") ||		/* 1997/11/28 (Fri) 18:11:33 */
	!strcmp(charset, "x-shift-jis")))
    {
d9166 1
a9166 2
    } else if (explicit && ((p_in && (p_in->enc == UCT_ENC_CJK)) ||
	       !strcmp(charset, "x-euc") ||	/* 1997/11/28 (Fri) 18:11:24 */
d9169 2
d9178 1
a9178 1
	       !strcmp(charset, "iso-2022-cn"))) {
a9190 10
    if (explicit)
	text->specified_kcode = text->kcode;
    else {
	if (UCAssume_MIMEcharset) {
	    if (!strcmp(UCAssume_MIMEcharset, "euc-jp"))
		text->kcode = text->specified_kcode = EUC;
	    else if (!strcmp(UCAssume_MIMEcharset, "shift_jis"))
		text->kcode = text->specified_kcode = SJIS;
	}
    }
a9324 2
#define CanTrimTextArea(c) \
    (LYtrimInputFields ? isspace(c) : ((c) == '\r' || (c) == '\n'))
d9352 1
a9352 1
	if (CanTrimTextArea(UCH(*p)))
d9406 1
a9406 1
	for (p = line, s = tbuf; *s != '\0'; p++, s++) {
d9408 6
a9413 6
	    *p = ((UCH(*s)  < UCH(' '))       ||
		  (UCH(*s) == UCH('\177'))    ||
		  ((UCH(*s) > UCH('\177')) &&
		   (UCH(*s) <
		    UCH(LYlowest_eightbit[current_char_set]))))
		 ? (char) SPLAT : *s;
d9415 1
a9415 1
	    *p = (UCH(*s) < UCH(' ')) ? SPLAT : *s;
a9416 1
	}
a9471 1
    int   post_n;
d9521 1
a9521 1
		if (isdigit(UCH(*t++))) {
d9540 1
a9540 1
	     *   of being correct, if and when such an unlikely juxtaposition
d9562 1
a9562 1
		     *  horizontal position, and that of all subsequent tags
d9580 1
a9580 1
		    if ((new_n -= n) != 0) {
d9590 1
a9590 1
	    }
d9603 1
a9603 4
	    pre_n = strlen (p);	/* count of 1st part chars in this line */
	    post_n = strlen(ht->next->data);
	    if (plx
	     && (pre_n + post_n + 2 < (int) sizeof(lxbuf))) {
d9605 1
d9616 1
a9616 1
		    if (isdigit(UCH(*t++))) {
d9631 1
a9631 3
		if ((valid)
		 && (n > 0)
		 && (n + post_n + 2) < MAX_LINE) {
d9709 1
a9709 1
    for (htline = FirstHTLine(HTMainText), i = 0;
d9720 3
a9722 3
    if (((a = typecalloc(TextAnchor)) == 0) ||
	((f = typecalloc(FormInfo)) == 0) ||
	((l = allocHTLine(MAX_LINE)) == 0))
d9729 1
a9752 1
    f->value_cs        = current_char_set; /* use current setting - kw */
d9759 3
a9764 2
    /*we fork the pointers!*/
    l->styles = htline->styles;
d9767 1
a9767 1
    if (keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) {
d9811 1
a9811 1
	int,		 newlines,
d9813 1
a9813 1
	HTLine *,	 start_htline,
d9819 5
a9823 4
    int		line_adj = 0;
    int		tag_adj	 = 0;
    int		lx	 = 0;
    int	     hang	 = 0;  /* for HANG detection of a nasty intermittent */
d9827 1
a9827 1
    CTRACE((tfp, "GridText: adjusting struct's to add %d new line(s)\n", newlines));
d9839 1
a9839 1
	if ((keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) &&
d9841 3
a9843 2
	    anchor->number += newlines;
	anchor->line_num  += newlines;
d9877 1
a9877 1
    if (keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) {
d9879 1
a9879 1
	while (htline != FirstHTLine(HTMainText)) {
d9882 1
a9882 1
		if ((anchor->number - newlines) == start_tag)
d9885 17
a9901 17
		/*** A HANG (infinite loop) *has* occurred here, with */
		/*** the values of anchor and anchor->next being the  */
		/*** the same, OR with anchor->number "magically" and */
		/*** suddenly taking on an anchor-pointer-like value. */
		/***                                                  */
		/*** The same code and same doc have both passed and  */
		/*** failed at different times, which indicates some  */
		/*** sort of content/html dependency, or some kind of */
		/*** a "race" condition, but I'll be damned if I can  */
		/*** find it after tons of CTRACE's, printf()'s, gdb  */
		/*** breakpoints and watchpoints, etc.                */
		/***                                                  */
		/*** I have added a hang detector (with error msg and */
		/*** beep) here, to break the loop and warn the user, */
		/*** until it can be isolated and fixed.              */
		/***                                                  */
		/*** [One UGLY intermittent .. gak ..!  02/22/99 KED] */
d9912 1
a9912 2
						    &start_tag, newlines,
						    NOCHOP);
d9925 1
a9925 1
finish:
d9929 4
a9932 3
    nlinks                         += newlines;
    HTMainText->Lines              += newlines;
    HTMainText->last_anchor_number += newlines;
d9936 1
a9936 1
    CTRACE((tfp, "GridText: TextAnchor and HTLine struct's adjusted\n"));
d9940 1
a9940 1
hang_detected:  /* ugliness has happened; inform user and do the best we can */
d9942 5
a9946 2
    HTAlert(gettext("Hang Detect: TextAnchor struct corrupted - suggest aborting!"));
    goto finish;
a9974 1
    BOOLEAN wrapalert = FALSE;
d9990 1
d9994 1
a9994 1
    int		match_tag = 0;
d9996 1
a9996 4
    int		len, len0, len_in;
    int		wanted_fieldlen_wrap = -1; /* not yet asked; 0 means don't. */
    char       *skip_at = NULL;
    int		skip_num = 0, i;
d9998 2
a9999 1
    CTRACE((tfp, "GridText: entered HText_ExtEditForm()\n"));
d10054 2
a10055 2
    CTRACE((tfp, "GridText: TEXTAREA name=|%s| dumped to tempfile\n", areaname));
    CTRACE((tfp, "GridText: invoking editor (%s) on tempfile\n", editor));
d10064 7
a10070 1
	sprintf (ed_offset, "%d", ((entry_line - start_line) + 1));
d10072 11
a10082 1
    edit_temporary_file(ed_temp, ed_offset, NULL);
d10084 1
a10084 1
    CTRACE((tfp, "GridText: returned from editor (%s)\n", editor));
d10093 1
a10093 3
	ebuf = typecalloc (char);
	if (!ebuf)
	    outofmem(__FILE__, "HText_ExtEditForm");
d10095 1
a10095 12
	ebuf = typecallocn(char, size + 1);
	if (!ebuf) {
	    /*
	     *  This could be huge - don't exit if we don't have enough
	     *  memory for it.  With some luck, the user may be even able
	     *  to recover the file manually from the temp space while
	     *  the lynx session is not over. - kw
	     */
	    free(ed_temp);
	    HTAlwaysAlert(NULL, MEMORY_EXHAUSTED_FILE);
	    return 0;
	}
d10099 1
a10099 2
	LYCloseInput (fp);
	ebuf[size] = '\0';	/* Terminate! - kw */
d10101 2
d10107 1
a10107 2
    while ((size != 0)
     && (CanTrimTextArea(UCH(ebuf[size-1])) || (ebuf[size-1] == '\0')))
a10118 3
    if (anchor_ptr->input_field->size <= 4 ||
	anchor_ptr->input_field->size >= MAX_LINE)
	wanted_fieldlen_wrap = 0;
d10120 1
a10120 1
    len = len_in = 0;
d10125 4
a10128 91
	if (skip_at) {
	    len0 = skip_at - lp;
	    strncpy(line, lp, len0);
	    line[len0] = '\0';
	    lp = skip_at + skip_num;
	    skip_at = NULL;
	    skip_num = 0;
	} else {
	    len0 = 0;
	}
	line[len0] = '\0';

	if ((cp = strchr (lp, '\n')) != 0)
	   len = len_in = cp - lp;
	else
	   len = len_in = strlen (lp);


	if (wanted_fieldlen_wrap < 0 && !wrapalert &&
	    len0+len >= start_anchor->input_field->size &&
	    (cp = strchr(lp, ' ')) != NULL &&
	    (cp-lp) < start_anchor->input_field->size - 1) {
	    LYFixCursesOn("ask for confirmation:");
	    LYerase();		/* don't show previous state */
	    if (HTConfirmDefault(gettext("Wrap lines to fit displayed area?"),
				 NO)) {
		wanted_fieldlen_wrap = start_anchor->input_field->size - 1;
	    } else {
		wanted_fieldlen_wrap = 0;
	    }
	}
	if (wanted_fieldlen_wrap > 0 && len0+len > wanted_fieldlen_wrap) {
	    for (i = wanted_fieldlen_wrap-len0;
		 i+len0 >= wanted_fieldlen_wrap/4; i--) {
		if (isspace(UCH(lp[i]))) {
		    len = i + 1;
		    cp = lp + i;
		    if (cp[1] != '\n' &&
			isspace(UCH(cp[1])) &&
			!isspace(UCH(cp[2]))) {
			len++;
			cp++;
		    }
		    if (!isspace(UCH(cp[1]))) {
			while (*cp && *cp != '\r' && *cp != '\n' &&
			       (cp - lp) <= len + (3 * wanted_fieldlen_wrap/4))
			    cp++;	/* search for next line break */
			if (*cp == '\r' && cp[1] == '\n')
			    cp++;
			if (*cp == '\n' &&
			    (cp[1] == '\r' || cp[1] == '\n' ||
			     !isspace(UCH(cp[1])))) {
			    *cp = ' ';
			    while (isspace(UCH(*(cp-1)))) {
				skip_num++;
				cp--;
			    }
			    skip_at = cp;
			}
		    }
		    break;
		}
	    }
	}
	if (wanted_fieldlen_wrap > 0 && len0+len > wanted_fieldlen_wrap) {
	    i = len-1;
	    while (len0+i+1 > wanted_fieldlen_wrap &&
		   isspace(UCH(lp[i])))
		i--;
	    if (len0+i+1 > wanted_fieldlen_wrap)
		len = wanted_fieldlen_wrap - len0;
	}

	if (len0+len >= MAX_LINE) {
	    if (!wrapalert) {
		LYFixCursesOn("show alert:");
		HTAlert(gettext("Very long lines have been wrapped!"));
		wrapalert = TRUE;
	    }
	    /*
	     *  First try to find a space character for wrapping - kw
	     */
	    for (i = MAX_LINE - len0 - 1; i > 0; i--) {
		if (isspace(UCH(lp[i]))) {
		    len = i;
		    break;
		}
	    }
	    if (len0+len >= MAX_LINE)
		len = MAX_LINE - len0 - 1;
	}
d10130 2
a10131 2
	strncat (line, lp, len);
	*(line + len0+len) = '\0';
d10133 1
a10133 1
	cleanup_line_for_textarea (line, len0+len);
d10155 1
a10155 1
	if (len0+len > 0)
d10164 1
a10164 1
	if (*lp && isspace(UCH(*lp))) lp++;
d10175 1
a10175 1
    CTRACE((tfp, "GridText: edited text inserted into lynx struct's\n"));
d10193 1
a10193 1
    CTRACE((tfp, "GridText: exiting HText_ExtEditForm()\n"));
d10213 1
a10213 1
	    int,	    newlines)
d10229 1
a10229 1
    CTRACE((tfp, "GridText: entered HText_ExpandTextarea()\n"));
d10259 1
a10259 1
		firstanchor = FALSE;
d10286 2
a10287 2
    CTRACE((tfp, "GridText: %d blank line(s) added to TEXTAREA name=|%s|\n",
		newlines, areaname));
d10295 1
a10295 1
    CTRACE((tfp, "GridText: exiting HText_ExpandTextarea()\n"));
d10302 2
a10303 2
 *  Insert the contents of a file into a TEXTAREA between the cursor line,
 *  and the line preceding it.
a10323 1
    BOOLEAN truncalert = FALSE;
a10339 1
    int		file_cs;
d10346 1
a10346 1
    CTRACE((tfp, "GridText: entered HText_InsertFile()\n"));
d10353 1
a10353 1
	CTRACE((tfp, "GridText: file insert cancelled - no filename provided\n"));
a10355 6
    if (no_dotfiles || !show_dotfiles) {
	if (*LYPathLeaf(fn) == '.') {
	    HTUserMsg(FILENAME_CANNOT_BE_DOT);
	    return (0);
	}
    }
d10363 2
a10364 2
	CTRACE((tfp, "GridText: file insert aborted - file=|%s|- was 0-length\n",
		    fn));
d10370 2
a10371 19
	if ((fbuf = typecallocn(char, size + 1)) == NULL) {
	    /*
	     *  This could be huge - don't exit if we don't have enough
	     *  memory for it. - kw
	     */ /*outofmem(__FILE__, "HText_InsertFile");*/
	    free(fn);
	    HTAlert(MEMORY_EXHAUSTED_FILE);
	    return 0;
	}

	/* Try to make the same assumption for the charset of the inserted
	 * file as we would for normal loading of that file, i.e. taking
	 * assume_local_charset and suffix mappings into account.
	 * If there is a mismatch with the display character set, characters
	 * may be displayed wrong, too bad; but the user has a chance to
	 * correct this by editing the lines, which will update f->value_cs
	 * again. - kw
	 */
	LYGetFileInfo(fn, 0, 0, 0, 0, 0, &file_cs);
a10373 6
	if (!fp) {
	    free(fbuf);
	    free(fn);
	    HTAlert(FILE_CANNOT_OPEN_R);
	    return 0;
	}
d10375 1
a10375 1
	LYCloseInput (fp);
a10376 1
	fbuf[size] = '\0';	/* Terminate! - kw */
d10423 1
a10423 1
    for (htline = FirstHTLine(HTMainText), i = 0;
d10430 3
a10432 3
    if (((a = typecalloc(TextAnchor)) == 0) ||
	((f = typecalloc(FormInfo)) == 0) ||
	((l = allocHTLine(MAX_LINE)) == 0))
d10439 1
a10462 1
    f->value_cs        = (file_cs >= 0) ? file_cs : current_char_set;
d10467 3
a10472 2
    /*we fork the pointers!*/
    l->styles = htline->styles;
d10489 5
a10493 5
    htline		= htline->prev;
    l->next		= htline->next;
    l->prev		= htline;
    htline->next->prev	= l;
    htline->next	= l;
a10527 9
	if (len >= MAX_LINE) {
	    if (!truncalert) {
		HTAlert(gettext("Very long lines have been truncated!"));
		truncalert = TRUE;
	    }
	    len = MAX_LINE - 1;
	    if (lp[len])
		lp[len+1] = '\0'; /* prevent next iteration */
	}
a10548 7
	 *  insert_new_textarea_anchor always uses current_char_set,
	 *  we may want something else, so fix it up. - kw
	 */
	 if (file_cs >= 0)
	     anchor_ptr->input_field->value_cs = file_cs;

	/*
d10559 1
a10559 1
    CTRACE((tfp, "GridText: file inserted into lynx struct's\n"));
d10567 1
d10574 1
a10574 1
    CTRACE((tfp, "GridText: exiting HText_InsertFile()\n"));
d10631 1
a10631 1
		LynxChangeStyle (CStyle.style,CStyle.direction);
d10640 1
a10640 1
		    LYaddch('_');
d10649 1
a10649 1
		    LYaddch('_');
d10667 1
a10667 1
		    LYaddch('+');
d10672 1
a10672 1
		    isspace(UCH(LastDisplayChar)) ||
a10691 1
		/* FALLTHRU */
d10695 1
a10695 1
		if (text->T.output_utf8 && !isascii(UCH(buffer[0]))) {
d10723 1
a10723 1
		    LYaddstr(buffer);
d10727 1
a10727 1
		} else if (HTCJK != NOCJK && !isascii(UCH(buffer[0]))) {
d10733 1
a10733 1
		    LYaddstr(buffer);
d10748 1
a10748 1
		    LYaddstr(buffer);
d10761 1
a10761 1
	LynxChangeStyle (CStyle.style, CStyle.direction);
a10770 563
#ifndef USE_COLOR_STYLE
/*
 *  Function move_to_glyph is called from LYMoveToLink and does all
 *  the real work for it.
 *  The pair LYMoveToLink()/move_to_glyph() is similar to the pair
 *  redraw_lines_of_link()/redraw_part_of_line(), some key differences:
 *   LYMoveToLink/move_to_glyph		redraw_*
 *   -----------------------------------------------------------------
 *   - used without color style         - used with color style
 *   - handles showing WHEREIS target	- WHEREIS handled elsewhere
 *   - handles only one line		- handles first two lines for
 *					  hypertext anchors
 *   - right columns position for UTF-8
 *     by redrawing as necessary
 *   - currently used for highlight	- currently used for highlight
 *     ON and OFF			  OFF
 *
 *  Eventually the two sets of function should be unified, and should handle
 *  UTF-8 positioning, both lines of hypertext anchors, and WHEREIS in all
 *  cases.  If possible.  The complex WHEREIS target logic in highlight()
 *  could then be completely removed. - kw
 */
PRIVATE void move_to_glyph ARGS10(
	int,		YP,
	int,		XP,
	int,		XP_draw_min,
	char *,		data,
	int,		datasize,
	unsigned,	offset,
	CONST char *,	target,
	char *,		hightext,
	int,		flags,
	BOOL,		utf_flag)
{
    register int i;
    char buffer[7];
    CONST char *end_of_data;
    size_t utf_extra = 0;
#if defined(SHOW_WHEREIS_TARGETS)
    CONST char *cp_tgt;
    int i_start_tgt=0, i_after_tgt;
    int HitOffset, LenNeeded;
#endif /* SHOW_WHEREIS_TARGETS */
    BOOL intarget = NO, inunderline = NO, inbold = NO;
    BOOL drawing = NO, inU = NO, hadutf8 = NO;
    BOOL incurlink = NO, drawingtarget = NO, flag = NO;
    char *sdata = data;
    char LastDisplayChar = ' ';
    int XP_link = XP;
    int linkvlen;

    int	len;

    if (flags & 1)
	flag = YES;
    if (flags & 2)
	inU = YES;
    /* Set up the multibyte character buffer  */
    buffer[0] = buffer[1] = buffer[2] = '\0';
    /*
     *  Add offset, making sure that we do not
     *  go over the COLS limit on the display.
     */
    i = (int)offset;
    if (i > (int)DISPLAY_COLS - 1)
	i = (int)DISPLAY_COLS - 1;

    linkvlen = hightext ? LYmbcsstrlen(hightext, utf_flag, YES) : 0;

    /*
     *  Scan through the data, making sure that we do not
     *  go over the COLS limit on the display etc.
     */
    len = datasize;
    end_of_data = data + len;

#if defined(SHOW_WHEREIS_TARGETS)
    /*
     *  If the target overlaps with the part of this line that
     *  we are drawing, it will be emphasized.
     */
    i_after_tgt = i;
    if (target) {
	cp_tgt = LYno_attr_mb_strstr(sdata,
				     target,
				     utf_flag, YES,
				     &HitOffset,
				     &LenNeeded);
	if (cp_tgt) {
	    if ((int)offset + LenNeeded >= DISPLAY_COLS ||
		((int)offset + HitOffset >= XP + linkvlen)) {
		cp_tgt = NULL;
	    } else {
		i_start_tgt = i + HitOffset;
		i_after_tgt = i + LenNeeded;
	    }
	}
    } else {
	cp_tgt = NULL;
    }
#endif /* SHOW_WHEREIS_TARGETS */


    /*
     *  Iterate through the line data from the start, keeping track of
     *  the display ("glyph") position in i.  Drawing will be turned
     *  on when either the first UTF-8 sequence (that occurs after
     *  XP_draw_min) is found, or when we reach the link itself (if
     *  highlight is non-NULL). - kw
     */
    while ((i < DISPLAY_COLS - 1) && data < end_of_data && (*data != '\0')) {

	if (data && hightext && i >= XP && !incurlink) {

	/*
	 *  We reached the position of link itself, and hightext is
	 *  non-NULL.  We switch data from being a pointer into the HTLine
	 *  to being a pointer into hightext.  Normally (as long as this
	 *  routine is applied to normal hyperlink anchors) the text in
	 *  hightext will be identical to that part of the HTLine that
	 *  data was already pointing to, except that special attribute
	 *  chars LY_BOLD_START_CHAR etc. have been stripped out (see
	 *  HText_trimHightext).  So the switching should not result in
	 *  any different display, but it ensures that it doesn't go
	 *  unnoticed if somehow hightext got messed up somewhere else.
	 *  This is also useful in preparation for using this function
	 *  for something else than normal hyperlink anchors, i.e. form
	 *  fields.
	 *  Turn on drawing here or make sure it gets turned on before the
	 *  next actual normal character is handled. - kw
	 */
	    data = hightext;
	    len = strlen(hightext);
	    end_of_data = hightext + len;
	    XP += linkvlen;	/* from now on XP includes hightext chars */
	    incurlink = YES;
#ifdef SHOW_WHEREIS_TARGETS
	    if (cp_tgt) {
		if (flag && i_after_tgt >= XP)
		    i_after_tgt = XP - 1;
	    }
#endif
	    /*
	     *  The logic of where to set intarget drawingtarget etc.
	     *  and when to react to it should be cleaned up (here and
	     *  further below).  For now this seems to work but isn't
	     *  very clear.  The complications arise from reproducing
	     *  the behavior (previously done in highlight()) for target
	     *  strings that fall into or overlap a link: use target
	     *  emphasis for the target string, except for the first
	     *  and last character of the anchor text if the anchor is
	     *  highlighted as "current link". - kw
	     */
	    if (!drawing) {
#ifdef SHOW_WHEREIS_TARGETS
		if (intarget) {
		    if (i_after_tgt > i) {
			LYmove(YP, i);
			if (flag) {
			    drawing = YES;
			    drawingtarget = NO;
			    if (inunderline)	inU = YES;
			    lynx_start_link_color (flag, inU);
			} else {
			    drawing = YES;
			    drawingtarget = YES;
			    LYstartTargetEmphasis();
			}
		    }
		}
#endif /* SHOW_WHEREIS_TARGETS */
	    } else {
#ifdef SHOW_WHEREIS_TARGETS
		if (intarget && i_after_tgt > i) {
		    if (flag && (data == hightext)) {
			drawingtarget = NO;
			LYstopTargetEmphasis();
		    }
		} else if (!intarget)
#endif /* SHOW_WHEREIS_TARGETS */
		{
		    if (inunderline)	inU = YES;
		    if (inunderline)	stop_underline();
		    if (inbold)		stop_bold();
		    lynx_start_link_color (flag, inU);
		}

	    }
	}
	if (i >= XP || data >= end_of_data)
	    break;
	if ((buffer[0] = *data) == '\0')
	    break;


#if defined(SHOW_WHEREIS_TARGETS)
	/*
	 *  Look for a subsequent occurrence of the target string,
	 *  if we had a previous one and have now stepped past it. - kw
	 */
	if (cp_tgt && i >= i_after_tgt) {
	    if (intarget) {

		if (incurlink && flag && i == XP - 1)
		    cp_tgt = NULL;
		else
		    cp_tgt = LYno_attr_mb_strstr(sdata,
						 target,
						 utf_flag, YES,
						 &HitOffset,
						 &LenNeeded);
		if (cp_tgt) {
		    i_start_tgt = i + HitOffset;
		    i_after_tgt = i + LenNeeded;
		    if (incurlink) {
			if (flag && i_start_tgt == XP_link)
			    i_start_tgt++;
			if (flag && i_start_tgt == XP - 1)
			    i_start_tgt++;
			if (flag && i_after_tgt >= XP)
			    i_after_tgt = XP - 1;
			if (flag && i_start_tgt >= XP)
			    cp_tgt = NULL;
		    } else if (i_start_tgt == XP) {
			if (flag)
			    i_start_tgt++;
		    }
		}
		if (!cp_tgt || i_start_tgt != i) {
		    intarget = NO;
		    if (drawing) {
			if (drawingtarget) {
			    drawingtarget = NO;
			    LYstopTargetEmphasis();
			    if (incurlink) {
				lynx_start_link_color (flag, inU);
			    }
			}
			if (!incurlink) {
			    if (inbold)		start_bold();
			    if (inunderline)	start_underline();
			}
		    }
		}
	    }
	}
#endif /* SHOW_WHEREIS_TARGETS */

	/*
	 *  Advance data to point to the next input char (for the
	 *  next round).  Advance sdata, used for searching for a
	 *  target string, so that they stays in synch.  As long
	 *  as we are not within the highlight text, data and sdata
	 *  have identical values.  After we have switched data to
	 *  point into hightext, sdata remains a pointer into the
	 *  HTLine (so that we don't miss a partial target match at
	 *  the end of the anchor text).  So sdata has to sometimes
	 *  skip additional special attribute characters that are
	 *  not present in highlight in order to stay in synch. - kw
	 */
	data++;
	if (*sdata) {
	    do sdata++;
		while (incurlink && *sdata && sdata != data &&
		       IsSpecialAttrChar(*(sdata-1)));
	}

	switch (buffer[0]) {

	    case LY_UNDERLINE_START_CHAR:
		if (!drawing || !incurlink) inunderline = YES;
		if (drawing && !intarget && !incurlink)
		    start_underline();
		break;

	    case LY_UNDERLINE_END_CHAR:
		inunderline = NO;
		if (drawing && !intarget && !incurlink)
		    stop_underline();
		break;

	    case LY_BOLD_START_CHAR:
		if (!drawing || !incurlink) inbold = YES;
		if (drawing && !intarget && !incurlink)
		    start_bold();
		break;

	    case LY_BOLD_END_CHAR:
		inbold = NO;
		if (drawing && !intarget && !incurlink)
		    stop_bold();
		break;

	    case LY_SOFT_NEWLINE:
		if (drawing) {
		    LYaddch('+');
		}
		i++;
		break;

	    case LY_SOFT_HYPHEN:
		if (*data != '\0' ||
		    isspace(UCH(LastDisplayChar)) ||
		    LastDisplayChar == '-') {
		    /*
		     *  Ignore the soft hyphen if it is not the last
		     *  character in the line.  Also ignore it if it
		     *  first character following the margin, or if it
		     *  is preceded by a white character (we loaded 'M'
		     *  into LastDisplayChar if it was a multibyte
		     *  character) or hyphen, though it should have
		     *  been excluded by HText_appendCharacter() or by
		     *  split_line() in those cases. - FM
		     */
		    break;
		} else {
		    /*
		     *  Make it a hard hyphen and fall through. - FM
		     */
		    buffer[0] = '-';
		}
		/* FALLTHRU */

	    default:
		/*
		 *  We have got an actual normal displayable character, or
		 *  the start of one.  Before proceeding check whether
		 *  drawing needs to be turned on now. - kw
		 */
#if defined(SHOW_WHEREIS_TARGETS)
		if (incurlink && intarget && flag && i_after_tgt > i) {
		    if (i == XP - 1) {
			i_after_tgt = i;
		    } else if (i == XP - 2 && HTCJK != NOCJK &&
			       !isascii(UCH(buffer[0]))) {
			i_after_tgt = i;
			cp_tgt = NULL;
			if (drawing) {
			    if (drawingtarget) {
				LYstopTargetEmphasis();
				drawingtarget = NO;
				lynx_start_link_color (flag, inU);
			    }
			}
		    }
		}
		if (cp_tgt && i >= i_start_tgt && sdata > cp_tgt) {
		    if (!intarget ||
			(intarget && incurlink && !drawingtarget)) {

			if (incurlink && drawing &&
			    !(flag &&
			      (i == XP_link || i == XP - 1))) {
			    lynx_stop_link_color (flag, inU);
			}
			if (incurlink && !drawing) {
			    LYmove(YP, i);
			    if (inunderline)	inU = YES;
			    if (flag && (i == XP_link || i == XP - 1)) {
				lynx_start_link_color (flag, inU);
				drawingtarget = NO;
			    } else {
				LYstartTargetEmphasis();
				drawingtarget = YES;
			    }
			    drawing = YES;
			} else if (incurlink && drawing &&
				   intarget && !drawingtarget &&
				   (flag &&
				    (i == XP_link))) {
			    if (inunderline)	inU = YES;
			    lynx_start_link_color (flag, inU);
			} else if (drawing &&
				   !(flag &&
				     (i == XP_link || (incurlink && i == XP - 1)))) {
			    LYstartTargetEmphasis();
			    drawingtarget = YES;
			}
			intarget = YES;
		    }
		} else
#endif /* SHOW_WHEREIS_TARGETS */
		    if (incurlink) {
			if (!drawing) {
			    LYmove(YP, i);
			    if (inunderline)	inU = YES;
			    lynx_start_link_color (flag, inU);
			    drawing = YES;
			}
		    }

		i++;
		if (utf_flag && !isascii(UCH(buffer[0]))) {
		    hadutf8 = YES;
		    if ((*buffer & 0xe0) == 0xc0) {
			utf_extra = 1;
		    } else if ((*buffer & 0xf0) == 0xe0) {
			utf_extra = 2;
		    } else if ((*buffer & 0xf8) == 0xf0) {
			utf_extra = 3;
		    } else if ((*buffer & 0xfc) == 0xf8) {
			utf_extra = 4;
		    } else if ((*buffer & 0xfe) == 0xfc) {
			utf_extra = 5;
		    } else {
			 /*
			  *  Garbage.
			  */
			utf_extra = 0;
		    }
		    if (strlen(data) < utf_extra) {
			/*
			 *  Shouldn't happen.
			 */
			utf_extra = 0;
		    }
		    LastDisplayChar = 'M';
		}
		if (utf_extra) {
		    strncpy(&buffer[1], data, utf_extra);
		    buffer[utf_extra+1] = '\0';
		    if (!drawing && i >= XP_draw_min) {
			LYmove(YP, i - 1);
			drawing = YES;
#if defined(SHOW_WHEREIS_TARGETS)
			if (intarget) {
			    drawingtarget = YES;
			    LYstartTargetEmphasis();
			} else
#endif /* SHOW_WHEREIS_TARGETS */
			{
			    if (inbold)
				start_bold();
			    if (inunderline)
				start_underline();
			}
		    }
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		    sdata += utf_extra; data += utf_extra;
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && !isascii(UCH(buffer[0]))) {
		    /*
		     *  For CJK strings, by Masanobu Kimura.
		     */
		    if (drawing && (i < DISPLAY_COLS - 1)) {
			buffer[1] = *data;
			LYaddstr(buffer);
			buffer[1] = '\0';
		    }
		    i++;
		    sdata++; data++;
		    /*
		     *  For now, load 'M' into LastDisplayChar,
		     *  but we should check whether it's white
		     *  and if so, use ' '.  I don't know if
		     *  there actually are white CJK characters,
		     *  and we're loading ' ' for multibyte
		     *  spacing characters in this code set,
		     *  but this will become an issue when
		     *  the development code set's multibyte
		     *  character handling is used. - FM
		     */
		    LastDisplayChar = 'M';
		} else {
		    if (drawing) {
			LYaddstr(buffer);
		    }
		    LastDisplayChar = buffer[0];
		}
	} /* end of switch */
    } /* end of while */

    if (!drawing) {
	LYmove(YP, i);
	lynx_start_link_color (flag, inU);
    } else {
#if defined(SHOW_WHEREIS_TARGETS)
	if (drawingtarget) {
	    LYstopTargetEmphasis();
	    lynx_start_link_color (flag, inU);
	}
#endif /* SHOW_WHEREIS_TARGETS */
	if (hadutf8) {
	    LYtouchline(YP);
	}
    }
    return;
}
#endif /* !USE_COLOR_STYLE */

#ifndef USE_COLOR_STYLE
/*
 *  Move cursor position to a link's place in the display.
 *  The "moving to" is done by scanning through the line's
 *  character data in the corresponding HTLine of HTMainText,
 *  and starting to draw when a UTF-8 encoded non-ASCII character
 *  is encountered before the link (with some protection against
 *  overwriting form fields).  This refreshing of preceding data is
 *  necessary for preventing curses's or slang's display logic from
 *  getting too clever; their logic counts character positions wrong
 *  since they don't know about multi-byte characters that take up
 *  only one screen position.  So we have to make them forget their
 *  idea of what's in a screen line drawn previously.
 *  If hightext is non-NULL, it should be the anchor text for a normal
 *  link as stored in a links[] element, and the anchor text will be
 *  drawn too, with appropriate attributes. - kw
 */
PUBLIC void LYMoveToLink ARGS6(
	int,		cur,
	CONST char *,	target,
	char *,		hightext,
	int,		flag,
	BOOL,		inU,
	BOOL,		utf_flag)
{
#define pvtTITLE_HEIGHT 1
    HTLine* todr;
    int i, n=0;
    int XP_draw_min = 0;
    int flags = ((flag == ON) ? 1 : 0) | (inU ? 2 : 0);

    /*
     *  We need to protect changed form text fields preceding this
     *  link on the same line against overwriting. - kw
     */
    for (i = cur-1; i >= 0; i++) {
	if (links[i].ly < links[cur].ly)
	    break;
	if (links[i].type == WWW_FORM_LINK_TYPE) {
	    XP_draw_min = links[i].ly + links[i].form->size;
	    break;
	}
    }

    /*  Find the right HTLine. */
    if (!HTMainText) {
	todr = NULL;
    } else if (HTMainText->stale) {
	todr = FirstHTLine(HTMainText);
	n = links[cur].ly - pvtTITLE_HEIGHT + HTMainText->top_of_screen;
    } else {
	todr = HTMainText->top_of_screen_line;
	n = links[cur].ly - pvtTITLE_HEIGHT;
    }
    for (i = 0; i < n && todr; i++) {
	todr = (todr == HTMainText->last_line) ? NULL : todr->next;
    }
    if (todr) {
	if (target && *target == '\0') target = NULL;
	move_to_glyph(links[cur].ly, links[cur].lx, XP_draw_min,
		      todr->data, todr->size, todr->offset,
		      target, hightext, flags, utf_flag);
    } else {
	/*  This should not happen. */
	move_to_glyph(links[cur].ly, links[cur].lx, XP_draw_min,
		      "", 0, links[cur].lx,
		      target, hightext, flags, utf_flag);
	/* LYmove(links[cur].ly, links[cur].lx); */
    }
}
#endif /* !USE_COLOR_STYLE */

d10793 1
a10793 1
    while (lines_back-- > 0)
d10798 1
a10798 1
    LYmove(links[cur].ly,  links[cur].lx);
d10802 1
a10802 1
	LYmove(links[cur].ly+1,links[cur].hightext2_offset);
d10814 1
a10814 1
#ifdef USE_PRETTYSRC
d10818 1
a10818 1
	HTMainText->source = TRUE;
a10821 26
PUBLIC HTkcode HText_getKcode ARGS1(
	HText *,	text)
{
    return text->kcode;
}

PUBLIC void HText_updateKcode ARGS2(
	HText *,	text,
	HTkcode,	kcode)
{
    text->kcode = kcode;
}

PUBLIC HTkcode HText_getSpecifiedKcode ARGS1(
	HText *,	text)
{
    return text->specified_kcode;
}

PUBLIC void HText_updateSpecifiedKcode ARGS2(
	HText *,	text,
	HTkcode,	kcode)
{
    text->specified_kcode = kcode;
}

d10824 1
a10824 3
    return (HTMainText ?
	    HTAnchor_getUCLYhndl(HTMainText->node_anchor, UCT_STAGE_MIME)
	    : -1);
@

