head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.7
	tg-mergefixes-1-branch:1.1.3.7.0.4
	tg-mergefixes-1-base:1.1.3.7
	MIROS_X:1.1.3.7.0.2
	MIROS_X_BASE:1.1.3.7
	MIRBSD_XP_MIRPPC:1.1.3.5.0.4
	lynx-2_8_6dev_7b:1.1.3.7
	lynx-2_8_6dev_6:1.1.3.6
	MIRBSD_XP_SPARC_BASE:1.1.3.5
	MIRBSD_XP_SPARC:1.1.3.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2005.01.03.00.46.03;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.56.23;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.37;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.34;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.26;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.22;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.18;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.40;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.02.08.13.10.30;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.15.56;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.52.10;	author tg;	state Stab;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.11.20.16.26;	author tg;	state Exp;
branches;
next	1.1.3.7;

1.1.3.7
date	2004.10.20.10.10.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@soft merge
@
text
@#include <HTUtils.h>
#include <HTFTP.h>
#include <HTTP.h>		/* 'reloading' flag */
#include <HTML.h>
#include <LYCurses.h>
#include <LYUtils.h>
#include <LYStrings.h>
#include <LYGlobalDefs.h>
#include <LYHistory.h>
#include <LYOptions.h>
#include <LYSignal.h>
#include <LYClean.h>
#include <LYCharSets.h>
#include <UCMap.h>
#include <UCAux.h>
#include <LYKeymap.h>
#include <LYrcFile.h>
#include <HTAlert.h>
#include <LYBookmark.h>
#include <GridText.h>
#include <LYGetFile.h>
#include <LYReadCFG.h>
#include <LYPrettySrc.h>
#include <HTFile.h>

#include <LYLeaks.h>

BOOLEAN term_options;

#define TOP_LINK  "/"
#define MBM_LINK  "//MBM_MENU"

static int LYChosenShowColor = SHOW_COLOR_UNKNOWN;	/* whether to show and save */

static void terminate_options(int sig);

#if !defined(NO_OPTION_MENU) || (defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES)))
#define COL_OPTION_VALUES 36	/* display column where option values start */
#endif

#if defined(USE_SLANG) || defined(COLOR_CURSES)
static BOOLEAN can_do_colors = FALSE;
#endif

BOOLEAN LYCheckUserAgent(void)
{
    if (non_empty(LYUserAgent)) {
	if (strstr(LYUserAgent, "Lynx") == 0
	    && strstr(LYUserAgent, "lynx") == 0
	    && strstr(LYUserAgent, "L_y_n_x") == 0
	    && strstr(LYUserAgent, "l_y_n_x") == 0) {
	    return FALSE;
	}
    }
    return TRUE;
}

static void SetupChosenShowColor(void)
{
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    can_do_colors = TRUE;
#if defined(COLOR_CURSES)
    if (LYCursesON)		/* could crash if called before initialization */
	can_do_colors = (has_colors()
			 ? TRUE
			 : FALSE);
#endif
    if (!no_option_save) {
	if (LYChosenShowColor == SHOW_COLOR_UNKNOWN) {
	    switch (LYrcShowColor) {
	    case SHOW_COLOR_NEVER:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
		    SHOW_COLOR_ON : SHOW_COLOR_NEVER;
		break;
	    case SHOW_COLOR_ALWAYS:
		if (!can_do_colors)
		    LYChosenShowColor = SHOW_COLOR_ALWAYS;
		else
		    LYChosenShowColor =
			(LYShowColor >= SHOW_COLOR_ON) ?
			SHOW_COLOR_ALWAYS : SHOW_COLOR_OFF;
		break;
	    default:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
		    SHOW_COLOR_ON : SHOW_COLOR_OFF;
	    }
	}
    }
#endif /* USE_SLANG || COLOR_CURSES */
}

static void validate_x_display(void)
{
    char *cp;

    if ((cp = LYgetXDisplay()) != NULL) {
	StrAllocCopy(x_display, cp);
    } else {
	FREE(x_display);
    }
}

static void summarize_x_display(char *display_option)
{
    if ((x_display == NULL && *display_option == '\0') ||
	(x_display != NULL && !strcmp(x_display, display_option))) {
	if (x_display == NULL && LYisConfiguredForX == TRUE) {
	    _statusline(VALUE_ACCEPTED_WARNING_X);
	} else if (x_display != NULL && LYisConfiguredForX == FALSE) {
	    _statusline(VALUE_ACCEPTED_WARNING_NONX);
	} else {
	    _statusline(VALUE_ACCEPTED);
	}
    } else {
	if (*display_option) {
	    _statusline(FAILED_TO_SET_DISPLAY);
	} else {
	    _statusline(FAILED_CLEAR_SET_DISPLAY);
	}
    }
}

#ifndef NO_OPTION_MENU
static int boolean_choice(int status,
			  int line,
			  int column,
			  const char **choices);

#define LYChooseBoolean(status, line, column, choices) \
	boolean_choice(status, line, column, (const char **)choices)

#define MAXCHOICES 10

/*
 * Values for the options menu.  - FM
 *
 * L_foo values are the Y coordinates for the menu item.
 * B_foo values are the X coordinates for the item's prompt string.
 * C_foo values are the X coordinates for the item's value string.
 */
#define L_EDITOR	 2
#define L_DISPLAY	 3

#define L_HOME		 4
#define C_MULTI		24
#define B_BOOK		34
#define C_DEFAULT	50

#define L_FTPSTYPE	 5
#define L_MAIL_ADDRESS	 6
#define L_SSEARCH	 7
#define L_LANGUAGE	 8
#define L_PREF_CHARSET	 9
#define L_ASSUME_CHARSET (L_PREF_CHARSET + 1)
#define L_CHARSET	10
#define L_RAWMODE	11

#define L_COLOR		L_RAWMODE
#define B_COLOR		44
#define C_COLOR		62

#define L_BOOL_A	12
#define B_VIKEYS	5
#define C_VIKEYS	15
#define B_EMACSKEYS	22
#define C_EMACSKEYS	36
#define B_SHOW_DOTFILES	44
#define C_SHOW_DOTFILES	62

#define L_BOOL_B	13
#define B_SELECT_POPUPS	5
#define C_SELECT_POPUPS	36
#define B_SHOW_CURSOR	44
#define C_SHOW_CURSOR	62

#define L_KEYPAD	14
#define L_LINEED	15
#define L_LAYOUT	16

#ifdef DIRED_SUPPORT
#define L_DIRED		17
#define L_USER_MODE	18
#define L_USER_AGENT	19
#define L_EXEC		20
#else
#define L_USER_MODE	17
#define L_USER_AGENT	18
#define L_EXEC		19
#endif /* DIRED_SUPPORT */

#define L_VERBOSE_IMAGES L_USER_MODE
#define B_VERBOSE_IMAGES 50
#define C_VERBOSE_IMAGES (B_VERBOSE_IMAGES + 21)

/* a kludge to add assume_charset only in ADVANCED mode... */
#define L_Bool_A     (use_assume_charset ? L_BOOL_A     + 1 : L_BOOL_A)
#define L_Bool_B     (use_assume_charset ? L_BOOL_B     + 1 : L_BOOL_B)
#define L_Exec       (use_assume_charset ? L_EXEC       + 1 : L_EXEC)
#define L_Rawmode    (use_assume_charset ? L_RAWMODE    + 1 : L_RAWMODE)
#define L_Charset    (use_assume_charset ? L_CHARSET    + 1 : L_CHARSET)
#define L_Color      (use_assume_charset ? L_COLOR      + 1 : L_COLOR)
#define L_Keypad     (use_assume_charset ? L_KEYPAD     + 1 : L_KEYPAD)
#define L_Lineed     (use_assume_charset ? L_LINEED     + 1 : L_LINEED)
#define L_Layout     (use_assume_charset ? L_LAYOUT     + 1 : L_LAYOUT)
#define L_Dired      (use_assume_charset ? L_DIRED      + 1 : L_DIRED)
#define L_User_Mode  (use_assume_charset ? L_USER_MODE  + 1 : L_USER_MODE)
#define L_User_Agent (use_assume_charset ? L_USER_AGENT + 1 : L_USER_AGENT)

#define LPAREN '('
#define RPAREN ')'

static int add_it(char *text, int len)
{
    if (len) {
	text[len] = '\0';
	LYaddstr(text);
    }
    return 0;
}

/*
 * addlbl() is used instead of plain LYaddstr() in old-style options menu
 * to show hot keys in bold.
 */
static void addlbl(const char *text)
{
    char actual[80];
    int s, d;
    BOOL b = FALSE;

    for (s = d = 0; text[s]; s++) {
	actual[d++] = text[s];
	if (text[s] == LPAREN) {
	    d = add_it(actual, d - 1);
	    lynx_start_bold();
	    b = TRUE;
	    actual[d++] = text[s];
	} else if (text[s] == RPAREN) {
	    d = add_it(actual, d);
	    lynx_stop_bold();
	    b = FALSE;
	}
    }
    add_it(actual, d);
    if (b)
	lynx_stop_bold();
}

#if !defined(VMS) || defined(USE_SLANG)
#define HANDLE_LYOPTIONS \
		    if (term_options) { \
			term_options = FALSE; \
		    } else { \
			AddValueAccepted = TRUE; \
		    } \
		    goto draw_options
#else
#define HANDLE_LYOPTIONS \
		    term_options = FALSE; \
		    if (use_assume_charset != old_use_assume_charset) \
			goto draw_options
#endif /* !VMS || USE_SLANG */

void LYoptions(void)
{
#define ShowBool(value) LYaddstr((value) ? "ON " : "OFF")
    static const char *bool_choices[] =
    {
	"OFF",
	"ON",
	NULL
    };
    static const char *caseless_choices[] =
    {
	"CASE INSENSITIVE",
	"CASE SENSITIVE",
	NULL
    };
    static const char *dirList_choices[] =
    {
	"Directories first",
	"Files first",
	"Mixed style",
	NULL
    };

#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    static const char *exec_choices[] =
    {
	"ALWAYS OFF",
	"FOR LOCAL FILES ONLY",
#ifndef NEVER_ALLOW_REMOTE_EXEC
	"ALWAYS ON",
#endif				/* !NEVER_ALLOW_REMOTE_EXEC */
	NULL
    };
#endif
    static const char *fileSort_choices[] =
    {
	"By Filename",
	"By Type",
	"By Size",
	"By Date",
	NULL
    };
    static const char *keypad_choices[] =
    {
	"Numbers act as arrows",
	"Links are numbered",
	"Links and form fields are numbered",
	NULL
    };
    static const char *mbm_choices[] =
    {
	"OFF     ",
	"STANDARD",
	"ADVANCED",
	NULL
    };
    static const char *userMode_choices[] =
    {
	"Novice",
	"Intermediate",
	"Advanced",
	NULL
    };

#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    int itmp;
#endif /* ENABLE_OPTS_CHANGE_EXEC */
    int response, ch;

    /*
     * If the user changes the display we need memory to put it in.
     */
    char display_option[256];
    char *choices[MAXCHOICES];
    int CurrentCharSet = current_char_set;
    int CurrentAssumeCharSet = UCLYhndl_for_unspec;
    int CurrentShowColor = LYShowColor;
    BOOLEAN CurrentRawMode = LYRawMode;
    BOOLEAN AddValueAccepted = FALSE;
    char *cp = NULL;
    BOOL use_assume_charset, old_use_assume_charset;

#ifdef DIRED_SUPPORT
#ifdef ENABLE_OPTS_CHANGE_EXEC
    if (LYlines < 24) {
	HTAlert(OPTION_SCREEN_NEEDS_24);
	return;
    }
#else
    if (LYlines < 23) {
	HTAlert(OPTION_SCREEN_NEEDS_23);
	return;
    }
#endif /* ENABLE_OPTS_CHANGE_EXEC */
#else
#ifdef ENABLE_OPTS_CHANGE_EXEC
    if (LYlines < 23) {
	HTAlert(OPTION_SCREEN_NEEDS_23);
	return;
    }
#else
    if (LYlines < 22) {
	HTAlert(OPTION_SCREEN_NEEDS_22);
	return;
    }
#endif /* ENABLE_OPTS_CHANGE_EXEC */
#endif /* DIRED_SUPPORT */

    term_options = FALSE;
    LYStatusLine = (LYlines - 1);	/* screen is otherwise too crowded */
    signal(SIGINT, terminate_options);
    if (no_option_save) {
	if (LYShowColor == SHOW_COLOR_NEVER) {
	    LYShowColor = SHOW_COLOR_OFF;
	} else if (LYShowColor == SHOW_COLOR_ALWAYS) {
	    LYShowColor = SHOW_COLOR_ON;
	}
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    } else {
	SetupChosenShowColor();
#endif /* USE_SLANG || COLOR_CURSES */
    }

    old_use_assume_charset =
	use_assume_charset = (BOOL) (user_mode == ADVANCED_MODE);

  draw_options:

    old_use_assume_charset = use_assume_charset;
    /*
     * NOTE that printw() should be avoided for strings that might have
     * non-ASCII or multibyte/CJK characters.  - FM
     */
#if defined(FANCY_CURSES) || defined (USE_SLANG)
    if (enable_scrollback) {
	LYclear();
    } else {
	LYerase();
    }
#else
    LYclear();
#endif /* FANCY_CURSES || USE_SLANG */
    LYmove(0, 5);

    lynx_start_h1_color();
    LYaddstr("         Options Menu (");
    LYaddstr(LYNX_NAME);
    LYaddstr(" Version ");
    LYaddstr(LYNX_VERSION);
    LYaddch(')');
    lynx_stop_h1_color();
    LYmove(L_EDITOR, 5);
    addlbl("(E)ditor                     : ");
    LYaddstr(non_empty(editor) ? editor : "NONE");

    LYmove(L_DISPLAY, 5);
    addlbl("(D)ISPLAY variable           : ");
    LYaddstr(non_empty(x_display) ? x_display : "NONE");

    LYmove(L_HOME, 5);
    addlbl("mu(L)ti-bookmarks: ");
    LYaddstr(mbm_choices[LYMultiBookmarks]);
    LYmove(L_HOME, B_BOOK);
    if (LYMultiBookmarks != MBM_OFF) {
	addlbl("review/edit (B)ookmarks files");
    } else {
	addlbl("(B)ookmark file: ");
	LYaddstr(non_empty(bookmark_page) ? bookmark_page : "NONE");
    }

    LYmove(L_FTPSTYPE, 5);
    addlbl("(F)TP sort criteria          : ");
    LYaddstr((HTfileSortMethod == FILE_BY_NAME ? "By Filename" :
	      (HTfileSortMethod == FILE_BY_SIZE ? "By Size    " :
	       (HTfileSortMethod == FILE_BY_TYPE ? "By Type    " :
		"By Date    "))));

    LYmove(L_MAIL_ADDRESS, 5);
    addlbl("(P)ersonal mail address      : ");
    LYaddstr(non_empty(personal_mail_address) ?
	     personal_mail_address : "NONE");

    LYmove(L_SSEARCH, 5);
    addlbl("(S)earching type             : ");
    LYaddstr(case_sensitive ? "CASE SENSITIVE  " : "CASE INSENSITIVE");

    LYmove(L_Charset, 5);
    addlbl("display (C)haracter set      : ");
    LYaddstr(LYchar_set_names[current_char_set]);

    LYmove(L_LANGUAGE, 5);
    addlbl("preferred document lan(G)uage: ");
    LYaddstr(non_empty(language) ? language : "NONE");

    LYmove(L_PREF_CHARSET, 5);
    addlbl("preferred document c(H)arset : ");
    LYaddstr(non_empty(pref_charset) ? pref_charset : "NONE");

    if (use_assume_charset) {
	LYmove(L_ASSUME_CHARSET, 5);
	addlbl("(^A)ssume charset if unknown : ");
	if (UCAssume_MIMEcharset)
	    LYaddstr(UCAssume_MIMEcharset);
	else
	    LYaddstr((UCLYhndl_for_unspec >= 0) ?
		     LYCharSet_UC[UCLYhndl_for_unspec].MIMEname
		     : "NONE");
    }

    LYmove(L_Rawmode, 5);
    addlbl("Raw 8-bit or CJK m(O)de      : ");
    ShowBool(LYRawMode);

#if defined(USE_SLANG) || defined(COLOR_CURSES)
    LYmove(L_Color, B_COLOR);
    addlbl("show color (&)  : ");
    if (no_option_save) {
	ShowBool(LYShowColor == SHOW_COLOR_OFF);
    } else {
	switch (LYChosenShowColor) {
	case SHOW_COLOR_NEVER:
	    LYaddstr("NEVER     ");
	    break;
	case SHOW_COLOR_OFF:
	    LYaddstr("OFF");
	    break;
	case SHOW_COLOR_ON:
	    LYaddstr("ON ");
	    break;
	case SHOW_COLOR_ALWAYS:
#if defined(COLOR_CURSES)
	    if (!has_colors())
		LYaddstr("Always try");
	    else
#endif
		LYaddstr("ALWAYS    ");
	}
    }
#endif /* USE_SLANG || COLOR_CURSES */

    LYmove(L_Bool_A, B_VIKEYS);
    addlbl("(V)I keys: ");
    ShowBool(vi_keys);

    LYmove(L_Bool_A, B_EMACSKEYS);
    addlbl("e(M)acs keys: ");
    ShowBool(emacs_keys);

    LYmove(L_Bool_A, B_SHOW_DOTFILES);
    addlbl("sho(W) dot files: ");
    ShowBool(!no_dotfiles && show_dotfiles);

    LYmove(L_Bool_B, B_SELECT_POPUPS);
    addlbl("popups for selec(T) fields   : ");
    ShowBool(LYSelectPopups);

    LYmove(L_Bool_B, B_SHOW_CURSOR);
    addlbl("show cursor (@@) : ");
    ShowBool(LYShowCursor);

    LYmove(L_Keypad, 5);
    addlbl("(K)eypad mode                : ");
    LYaddstr(fields_are_numbered() && links_are_numbered()
	     ? "Links and form fields are numbered"
	     : links_are_numbered()
	     ? "Links are numbered                "
	     : fields_are_numbered()
	     ? "Form fields are numbered          "
	     : "Numbers act as arrows             ");

    LYmove(L_Lineed, 5);
    addlbl("li(N)e edit style            : ");
    LYaddstr(LYLineeditNames[current_lineedit]);

#ifdef EXP_KEYBOARD_LAYOUT
    LYmove(L_Layout, 5);
    addlbl("Ke(Y)board layout            : ");
    LYaddstr(LYKbLayoutNames[current_layout]);
#endif

#ifdef DIRED_SUPPORT
    LYmove(L_Dired, 5);
    addlbl("l(I)st directory style       : ");
    LYaddstr((dir_list_style == FILES_FIRST) ? "Files first      " :
	     ((dir_list_style == MIXED_STYLE) ? "Mixed style      " :
	      "Directories first"));
#endif /* DIRED_SUPPORT */

    LYmove(L_User_Mode, 5);
    addlbl("(U)ser mode                  : ");
    LYaddstr((user_mode == NOVICE_MODE) ? "Novice      " :
	     ((user_mode == INTERMEDIATE_MODE) ? "Intermediate" :
	      "Advanced    "));

    addlbl("  verbose images (!) : ");
    ShowBool(verbose_img);

    LYmove(L_User_Agent, 5);
    addlbl("user (A)gent                 : ");
    LYaddstr(non_empty(LYUserAgent) ? LYUserAgent : "NONE");

#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    LYmove(L_Exec, 5);
    addlbl("local e(X)ecution links      : ");
#ifndef NEVER_ALLOW_REMOTE_EXEC
    LYaddstr(local_exec ? "ALWAYS ON           " :
	     (local_exec_on_local_files ? "FOR LOCAL FILES ONLY" :
	      "ALWAYS OFF          "));
#else
    LYaddstr(local_exec_on_local_files ? "FOR LOCAL FILES ONLY" :
	     "ALWAYS OFF          ");
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
#endif /* ENABLE_OPTS_CHANGE_EXEC */

    LYmove(LYlines - 3, 2);
    LYaddstr(SELECT_SEGMENT);
    lynx_start_bold();
    LYaddstr(CAP_LETT_SEGMENT);
    lynx_stop_bold();
    LYaddstr(OF_OPT_LINE_SEGMENT);
    if (!no_option_save) {
	LYaddstr(" '");
	lynx_start_bold();
	LYaddstr(">");
	lynx_stop_bold();
	LYaddstr("'");
	LYaddstr(TO_SAVE_SEGMENT);
    }
    LYaddstr(OR_SEGMENT);
    LYaddstr("'");
    lynx_start_bold();
    LYaddstr("r");
    lynx_stop_bold();
    LYaddstr("'");
    LYaddstr(TO_RETURN_SEGMENT);

    response = 0;
    while (response != 'R' &&
	   !LYisNonAlnumKeyname(response, LYK_PREV_DOC) &&
	   response != '>' && !term_options &&
	   !LYCharIsINTERRUPT_NO_letter(response)) {
	if (AddValueAccepted == TRUE) {
	    _statusline(VALUE_ACCEPTED);
	    AddValueAccepted = FALSE;
	}
	LYmove((LYlines - 2), 0);
	lynx_start_prompt_color();
	LYaddstr(COMMAND_PROMPT);
	lynx_stop_prompt_color();

	LYrefresh();
	response = LYgetch_single();
	if (term_options || LYCharIsINTERRUPT_NO_letter(response))
	    response = 'R';
	if (LYisNonAlnumKeyname(response, LYK_REFRESH)) {
	    lynx_force_repaint();
	    goto draw_options;
	}
	switch (response) {
	case 'E':		/* Change the editor. */
	    if (no_editor) {
		_statusline(EDIT_DISABLED);
	    } else if (system_editor) {
		_statusline(EDITOR_LOCKED);
	    } else {
		if (non_empty(editor))
		    LYstrncpy(display_option, editor, sizeof(display_option) - 1);
		else {		/* clear the NONE */
		    LYmove(L_EDITOR, COL_OPTION_VALUES);
		    LYaddstr("    ");
		    *display_option = '\0';
		}
		_statusline(ACCEPT_DATA);
		LYmove(L_EDITOR, COL_OPTION_VALUES);
		lynx_start_bold();
		ch = LYgetstr(display_option, VISIBLE,
			      sizeof(display_option), NORECALL);
		lynx_stop_bold();
		LYmove(L_EDITOR, COL_OPTION_VALUES);
		if (term_options || ch == -1) {
		    LYaddstr(non_empty(editor) ?
			     editor : "NONE");
		} else if (*display_option == '\0') {
		    FREE(editor);
		    LYaddstr("NONE");
		} else {
		    StrAllocCopy(editor, display_option);
		    LYaddstr(display_option);
		}
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
	    }
	    response = ' ';
	    break;

	case 'D':		/* Change the display. */
	    if (non_empty(x_display)) {
		LYstrncpy(display_option, x_display, sizeof(display_option) - 1);
	    } else {		/* clear the NONE */
		LYmove(L_DISPLAY, COL_OPTION_VALUES);
		LYaddstr("    ");
		*display_option = '\0';
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_DISPLAY, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
	    lynx_stop_bold();
	    LYmove(L_DISPLAY, COL_OPTION_VALUES);

#ifdef VMS
#define CompareEnvVars(a,b) strcasecomp(a, b)
#else
#define CompareEnvVars(a,b) strcmp(a, b)
#endif /* VMS */

	    if ((term_options || ch == -1) ||
		(x_display != NULL &&
		 !CompareEnvVars(x_display, display_option))) {
		/*
		 * Cancelled, or a non-NULL display string wasn't changed.  -
		 * FM
		 */
		LYaddstr(non_empty(x_display) ? x_display : "NONE");
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
		response = ' ';
		break;
	    } else if (*display_option == '\0') {
		if ((x_display == NULL) ||
		    (x_display != NULL && *x_display == '\0')) {
		    /*
		     * NULL or zero-length display string wasn't changed.  - FM
		     */
		    LYaddstr("NONE");
		    LYclrtoeol();
		    _statusline(VALUE_ACCEPTED);
		    response = ' ';
		    break;
		}
	    }
	    /*
	     * Set the new DISPLAY variable.  - FM
	     */
	    LYsetXDisplay(display_option);
	    validate_x_display();
	    cp = NULL;
	    LYaddstr(x_display ? x_display : "NONE");
	    LYclrtoeol();
	    summarize_x_display(display_option);
	    response = ' ';
	    break;

	case 'L':		/* Change multibookmarks option. */
	    if (LYMBMBlocked) {
		_statusline(MULTIBOOKMARKS_DISALLOWED);
		response = ' ';
		break;
	    }
	    if (!LYSelectPopups) {
		LYMultiBookmarks = LYChooseBoolean(LYMultiBookmarks,
						   L_HOME, C_MULTI,
						   mbm_choices);
	    } else {
		LYMultiBookmarks = LYChoosePopup(LYMultiBookmarks,
						 L_HOME, (C_MULTI - 1),
						 mbm_choices,
						 3, FALSE, FALSE);
	    }
#if defined(VMS) || defined(USE_SLANG)
	    if (LYSelectPopups) {
		LYmove(L_HOME, C_MULTI);
		LYclrtoeol();
		LYaddstr(mbm_choices[LYMultiBookmarks]);
	    }
#endif /* VMS || USE_SLANG */
#if !defined(VMS) && !defined(USE_SLANG)
	    if (!LYSelectPopups)
#endif /* !VMS && !USE_SLANG */
	    {
		LYmove(L_HOME, B_BOOK);
		LYclrtoeol();
		if (LYMultiBookmarks != MBM_OFF) {
		    LYaddstr(gettext("review/edit B)ookmarks files"));
		} else {
		    LYaddstr(gettext("B)ookmark file: "));
		    LYaddstr(non_empty(bookmark_page) ?
			     bookmark_page : "NONE");
		}
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'B':		/* Change the bookmark page location. */
	    /*
	     * Anonymous users should not be allowed to change the bookmark
	     * page.
	     */
	    if (!no_bookmark) {
		if (LYMultiBookmarks != MBM_OFF) {
		    edit_bookmarks();
		    signal(SIGINT, terminate_options);
		    goto draw_options;
		}
		if (non_empty(bookmark_page)) {
		    LYstrncpy(display_option,
			      bookmark_page,
			      sizeof(display_option) - 1);
		} else {	/* clear the NONE */
		    LYmove(L_HOME, C_DEFAULT);
		    LYclrtoeol();
		    *display_option = '\0';
		}
		_statusline(ACCEPT_DATA);
		LYmove(L_HOME, C_DEFAULT);
		lynx_start_bold();
		ch = LYgetstr(display_option, VISIBLE,
			      sizeof(display_option), NORECALL);
		lynx_stop_bold();
		LYmove(L_HOME, C_DEFAULT);
		if (term_options ||
		    ch == -1 || *display_option == '\0') {
		    LYaddstr(non_empty(bookmark_page) ?
			     bookmark_page : "NONE");
		} else if (!LYPathOffHomeOK(display_option,
					    sizeof(display_option))) {
		    LYaddstr(non_empty(bookmark_page) ?
			     bookmark_page : "NONE");
		    LYclrtoeol();
		    _statusline(USE_PATH_OFF_HOME);
		    response = ' ';
		    break;
		} else {
		    StrAllocCopy(bookmark_page, display_option);
		    StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
		    LYaddstr(bookmark_page);
		}
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
	    } else {		/* anonymous */
		_statusline(BOOKMARK_CHANGE_DISALLOWED);
	    }
	    response = ' ';
	    break;

	case 'F':		/* Change ftp directory sorting. */
	    if (!LYSelectPopups) {
		HTfileSortMethod = LYChooseBoolean(HTfileSortMethod,
						   L_FTPSTYPE, -1,
						   fileSort_choices);
	    } else {
		HTfileSortMethod = LYChoosePopup(HTfileSortMethod,
						 L_FTPSTYPE, -1,
						 fileSort_choices,
						 4, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_FTPSTYPE, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(fileSort_choices[HTfileSortMethod]);
#endif /* VMS || USE_SLANG */
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'P':		/* Change personal mail address for From headers. */
	    if (non_empty(personal_mail_address)) {
		LYstrncpy(display_option,
			  personal_mail_address,
			  sizeof(display_option) - 1);
	    } else {		/* clear the NONE */
		LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
		LYaddstr("    ");
		*display_option = '\0';
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
	    lynx_stop_bold();
	    LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
	    if (term_options || ch == -1) {
		LYaddstr((personal_mail_address &&
			  *personal_mail_address) ?
			 personal_mail_address : "NONE");
	    } else if (*display_option == '\0') {
		FREE(personal_mail_address);
		LYaddstr("NONE");
	    } else {
		StrAllocCopy(personal_mail_address, display_option);
		LYaddstr(display_option);
	    }
	    LYclrtoeol();
	    if (ch == -1) {
		HTInfoMsg(CANCELLED);
		HTInfoMsg("");
	    } else {
		_statusline(VALUE_ACCEPTED);
	    }
	    response = ' ';
	    break;

	case 'S':		/* Change case sensitivity for searches. */
	    case_sensitive = LYChooseBoolean(case_sensitive,
					     L_SSEARCH, -1,
					     caseless_choices);
	    response = ' ';
	    break;

	case '\001':		/* Change assume_charset setting. */
	    if (use_assume_charset) {
		int i, curval;
		const char **assume_list;
		assume_list = typecallocn(const char *, (LYNumCharsets + 1));

		if (!assume_list) {
		    outofmem(__FILE__, "options");
		}
		for (i = 0; i < LYNumCharsets; i++) {
		    assume_list[i] = LYCharSet_UC[i].MIMEname;
		}
		curval = UCLYhndl_for_unspec;
		if (curval == current_char_set && UCAssume_MIMEcharset) {
		    curval = UCGetLYhndl_byMIME(UCAssume_MIMEcharset);
		}
		if (curval < 0)
		    curval = LYRawMode ? current_char_set : 0;
		if (!LYSelectPopups) {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		    UCLYhndl_for_unspec =
			assumed_doc_charset_map[(LYChooseBoolean(charset_subsets[curval].assumed_idx,
								 L_ASSUME_CHARSET, -1,
								 assumed_charset_choices)
						 ? 1
						 : 0)];
#else
		    UCLYhndl_for_unspec =
			LYChooseBoolean(curval,
					L_ASSUME_CHARSET, -1,
					assume_list);
#endif
		} else {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		    UCLYhndl_for_unspec =
			assumed_doc_charset_map[(LYChoosePopup(charset_subsets[curval].assumed_idx,
							       L_ASSUME_CHARSET, -1,
							       assumed_charset_choices,
							       0,
							       FALSE,
							       FALSE)
						 ? 1
						 : 0)];
#else
		    UCLYhndl_for_unspec =
			LYChoosePopup(curval,
				      L_ASSUME_CHARSET, -1,
				      assume_list,
				      0, FALSE, FALSE);
#endif
#if defined(VMS) || defined(USE_SLANG)
		    LYmove(L_ASSUME_CHARSET, COL_OPTION_VALUES);
		    LYclrtoeol();
		    if (UCLYhndl_for_unspec >= 0)
			LYaddstr(LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
#endif /* VMS || USE_SLANG */
		}

		/*
		 * Set the raw 8-bit or CJK mode defaults and character set if
		 * changed.  - FM
		 */
		if (CurrentAssumeCharSet != UCLYhndl_for_unspec ||
		    UCLYhndl_for_unspec != curval) {
		    if (UCLYhndl_for_unspec != CurrentAssumeCharSet) {
			StrAllocCopy(UCAssume_MIMEcharset,
				     LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
		    }
		    if (HTCJK != JAPANESE)
			LYRawMode = (BOOL) (UCLYhndl_for_unspec == current_char_set);
		    HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
		    HTMLSetCharacterHandling(current_char_set);
		    CurrentAssumeCharSet = UCLYhndl_for_unspec;
		    CurrentRawMode = LYRawMode;
#if !defined(VMS) && !defined(USE_SLANG)
		    if (!LYSelectPopups)
#endif /* !VMS && !USE_SLANG */
		    {
			LYmove(L_Rawmode, COL_OPTION_VALUES);
			LYclrtoeol();
			ShowBool(LYRawMode);
		    }
		}
		FREE(assume_list);
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
	    } else {
		_statusline(NEED_ADVANCED_USER_MODE);
		AddValueAccepted = FALSE;
	    }
	    break;

	case 'C':		/* Change display charset setting. */
	    if (!LYSelectPopups) {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		displayed_display_charset_idx = LYChooseBoolean(displayed_display_charset_idx,
								L_Charset, -1,
								display_charset_choices);
		current_char_set = display_charset_map[displayed_display_charset_idx];
#else
		current_char_set = LYChooseBoolean(current_char_set,
						   L_Charset, -1,
						   LYchar_set_names);
#endif
	    } else {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		displayed_display_charset_idx = LYChoosePopup(displayed_display_charset_idx,
							      L_Charset, -1,
							      display_charset_choices,
							      0, FALSE, FALSE);
		current_char_set = display_charset_map[displayed_display_charset_idx];
#else
		current_char_set = LYChoosePopup(current_char_set,
						 L_Charset, -1,
						 LYchar_set_names,
						 0, FALSE, FALSE);
#endif

#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Charset, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(LYchar_set_names[current_char_set]);
#endif /* VMS || USE_SLANG */
	    }
	    /*
	     * Set the raw 8-bit or CJK mode defaults and character set if
	     * changed.  - FM
	     */
	    if (CurrentCharSet != current_char_set) {
		LYUseDefaultRawMode = TRUE;
		HTMLUseCharacterSet(current_char_set);
		CurrentCharSet = current_char_set;
		CurrentRawMode = LYRawMode;
#if !defined(VMS) && !defined(USE_SLANG)
		if (!LYSelectPopups)
#endif /* !VMS && !USE_SLANG */
		{
		    LYmove(L_Rawmode, COL_OPTION_VALUES);
		    LYclrtoeol();
		    ShowBool(LYRawMode);
		}
#ifdef CAN_SWITCH_DISPLAY_CHARSET
		/* Deduce whether the user wants autoswitch: */
		switch_display_charsets =
		    (current_char_set == auto_display_charset
		     || current_char_set == auto_other_display_charset);
#endif
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'O':		/* Change raw mode setting. */
	    LYRawMode = LYChooseBoolean(LYRawMode, L_Rawmode, -1, bool_choices);
	    /*
	     * Set the LYUseDefaultRawMode value and character handling if
	     * LYRawMode was changed.  - FM
	     */
	    if (CurrentRawMode != LYRawMode) {
		HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
		HTMLSetCharacterHandling(current_char_set);
		CurrentRawMode = LYRawMode;
	    }
	    response = ' ';
	    break;

	case 'G':		/* Change language preference. */
	    if (non_empty(language)) {
		LYstrncpy(display_option, language, sizeof(display_option) - 1);
	    } else {		/* clear the NONE */
		LYmove(L_LANGUAGE, COL_OPTION_VALUES);
		LYaddstr("    ");
		*display_option = '\0';
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_LANGUAGE, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
	    lynx_stop_bold();
	    LYmove(L_LANGUAGE, COL_OPTION_VALUES);
	    if (term_options || ch == -1) {
		LYaddstr(non_empty(language) ?
			 language : "NONE");
	    } else if (*display_option == '\0') {
		FREE(language);
		LYaddstr("NONE");
	    } else {
		StrAllocCopy(language, display_option);
		LYaddstr(display_option);
	    }
	    LYclrtoeol();
	    if (ch == -1) {
		HTInfoMsg(CANCELLED);
		HTInfoMsg("");
	    } else {
		_statusline(VALUE_ACCEPTED);
	    }
	    response = ' ';
	    break;

	case 'H':		/* Change charset preference. */
	    if (non_empty(pref_charset)) {
		LYstrncpy(display_option,
			  pref_charset,
			  sizeof(display_option) - 1);
	    } else {		/* clear the NONE */
		LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
		LYaddstr("    ");
		*display_option = '\0';
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
	    lynx_stop_bold();
	    LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
	    if (term_options || ch == -1) {
		LYaddstr(non_empty(pref_charset) ?
			 pref_charset : "NONE");
	    } else if (*display_option == '\0') {
		FREE(pref_charset);
		LYaddstr("NONE");
	    } else {
		StrAllocCopy(pref_charset, display_option);
		LYaddstr(display_option);
	    }
	    LYclrtoeol();
	    if (ch == -1) {
		HTInfoMsg(CANCELLED);
		HTInfoMsg("");
	    } else {
		_statusline(VALUE_ACCEPTED);
	    }
	    response = ' ';
	    break;

	case 'V':		/* Change VI keys setting. */
	    vi_keys = LYChooseBoolean(vi_keys,
				      L_Bool_A, C_VIKEYS,
				      bool_choices);
	    if (vi_keys) {
		set_vi_keys();
	    } else {
		reset_vi_keys();
	    }
	    response = ' ';
	    break;

	case 'M':		/* Change emacs keys setting. */
	    emacs_keys = LYChooseBoolean(emacs_keys,
					 L_Bool_A, C_EMACSKEYS,
					 bool_choices);
	    if (emacs_keys) {
		set_emacs_keys();
	    } else {
		reset_emacs_keys();
	    }
	    response = ' ';
	    break;

	case 'W':		/* Change show dotfiles setting. */
	    if (no_dotfiles) {
		_statusline(DOTFILE_ACCESS_DISABLED);
	    } else {
		show_dotfiles = LYChooseBoolean(show_dotfiles,
						L_Bool_A,
						C_SHOW_DOTFILES,
						bool_choices);
	    }
	    response = ' ';
	    break;

	case 'T':		/* Change select popups setting. */
	    LYSelectPopups = LYChooseBoolean(LYSelectPopups,
					     L_Bool_B,
					     C_SELECT_POPUPS,
					     bool_choices);
	    response = ' ';
	    break;

#if defined(USE_SLANG) || defined(COLOR_CURSES)
	case '&':		/* Change show color setting. */
	    if (no_option_save) {
#if defined(COLOR_CURSES)
		if (!has_colors()) {
		    char *terminal = LYGetEnv("TERM");

		    if (terminal)
			HTUserMsg2(COLOR_TOGGLE_DISABLED_FOR_TERM,
				   terminal);
		    else
			HTUserMsg(COLOR_TOGGLE_DISABLED);
		    break;
		}
#endif
		LYShowColor = LYChooseBoolean((LYShowColor - 1),
					      L_Color,
					      C_COLOR,
					      bool_choices);
		if (LYShowColor == 0) {
		    LYShowColor = SHOW_COLOR_OFF;
		} else {
		    LYShowColor = SHOW_COLOR_ON;
		}
	    } else {		/* !no_option_save */
		BOOLEAN again = FALSE;
		int chosen;

		/*
		 * Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "NEVER     ");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "OFF       ");
		choices[2] = NULL;
		StrAllocCopy(choices[2], "ON        ");
		choices[3] = NULL;
#if defined(COLOR_CURSES)
		if (!has_colors())
		    StrAllocCopy(choices[3], "Always try");
		else
#endif
		    StrAllocCopy(choices[3], "ALWAYS    ");
		choices[4] = NULL;
		do {
		    if (!LYSelectPopups) {
			chosen = LYChooseBoolean(LYChosenShowColor,
						 L_Color,
						 C_COLOR,
						 choices);
		    } else {
			chosen = LYChoosePopup(LYChosenShowColor,
					       L_Color,
					       C_COLOR,
					       choices, 4, FALSE, FALSE);
		    }
#if defined(COLOR_CURSES)
		    again = (BOOL) (chosen == SHOW_COLOR_ON && !has_colors());
		    if (again) {
			char *terminal = LYGetEnv("TERM");

			if (terminal)
			    HTUserMsg2(COLOR_TOGGLE_DISABLED_FOR_TERM,
				       terminal);
			else
			    HTUserMsg(COLOR_TOGGLE_DISABLED);
		    }
#endif
		} while (again);
		LYChosenShowColor = chosen;
#if defined(VMS)
		if (LYSelectPopups) {
		    LYmove(L_Color, C_COLOR);
		    LYclrtoeol();
		    LYaddstr(choices[LYChosenShowColor]);
		}
#endif /* VMS */
#if defined(COLOR_CURSES)
		if (has_colors())
#endif
		    LYShowColor = chosen;
		FREE(choices[0]);
		FREE(choices[1]);
		FREE(choices[2]);
		FREE(choices[3]);
	    }
	    if (CurrentShowColor != LYShowColor) {
		lynx_force_repaint();
	    }
	    CurrentShowColor = LYShowColor;
#ifdef USE_SLANG
	    SLtt_Use_Ansi_Colors = (LYShowColor > SHOW_COLOR_OFF ? TRUE : FALSE);
#endif
	    response = ' ';
	    if (LYSelectPopups && !no_option_save) {
		HANDLE_LYOPTIONS;
	    }
	    break;
#endif /* USE_SLANG or COLOR_CURSES */

	case '@@':		/* Change show cursor setting. */
	    LYShowCursor = LYChooseBoolean(LYShowCursor,
					   L_Bool_B,
					   C_SHOW_CURSOR,
					   bool_choices);
	    response = ' ';
	    break;

	case 'K':		/* Change keypad mode. */
	    if (!LYSelectPopups) {
		keypad_mode = LYChooseBoolean(keypad_mode,
					      L_Keypad, -1,
					      keypad_choices);
	    } else {
		keypad_mode = LYChoosePopup(keypad_mode,
					    L_Keypad, -1,
					    keypad_choices,
					    3, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Keypad, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(keypad_choices[keypad_mode]);
#endif /* VMS || USE_SLANG */
	    }
	    if (keypad_mode == NUMBERS_AS_ARROWS) {
		set_numbers_as_arrows();
	    } else {
		reset_numbers_as_arrows();
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'N':		/* Change line editor key bindings. */
	    if (!LYSelectPopups) {
		current_lineedit = LYChooseBoolean(current_lineedit,
						   L_Lineed, -1,
						   LYLineeditNames);
	    } else {
		current_lineedit = LYChoosePopup(current_lineedit,
						 L_Lineed, -1,
						 LYLineeditNames,
						 0, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Lineed, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(LYLineeditNames[current_lineedit]);
#endif /* VMS || USE_SLANG */
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

#ifdef EXP_KEYBOARD_LAYOUT
	case 'Y':		/* Change keyboard layout */
	    if (!LYSelectPopups) {
		current_layout = LYChooseBoolean(current_layout,
						 L_Layout, -1,
						 LYKbLayoutNames);
	    } else {
		current_layout = LYChoosePopup(current_layout,
					       L_Layout, -1,
					       LYKbLayoutNames,
					       0, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Layout, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(LYKbLayoutNames[current_layout]);
#endif /* VMS || USE_SLANG */
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
#endif /* EXP_KEYBOARD_LAYOUT */

#ifdef DIRED_SUPPORT
	case 'I':		/* Change local directory sorting. */
	    if (!LYSelectPopups) {
		dir_list_style = LYChooseBoolean(dir_list_style,
						 L_Dired, -1,
						 dirList_choices);
	    } else {
		dir_list_style = LYChoosePopup(dir_list_style,
					       L_Dired, -1,
					       dirList_choices,
					       3, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Dired, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(dirList_choices[dir_list_style]);
#endif /* VMS || USE_SLANG */
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
#endif /* DIRED_SUPPORT */

	case 'U':		/* Change user mode. */
	    if (!LYSelectPopups) {
		user_mode = LYChooseBoolean(user_mode,
					    L_User_Mode, -1,
					    userMode_choices);
		use_assume_charset = (BOOL) (user_mode >= 2);
	    } else {
		user_mode = LYChoosePopup(user_mode,
					  L_User_Mode, -1,
					  userMode_choices,
					  3, FALSE, FALSE);
		use_assume_charset = (BOOL) (user_mode >= 2);
#if defined(VMS) || defined(USE_SLANG)
		if (use_assume_charset == old_use_assume_charset) {
		    LYmove(L_User_Mode, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(userMode_choices[user_mode]);
		}
#endif /* VMS || USE_SLANG */
	    }
	    if (user_mode == NOVICE_MODE) {
		display_lines = (LYlines - 4);
	    } else {
		display_lines = LYlines - 2;
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case '!':
	    if (!LYSelectPopups) {
		verbose_img = LYChooseBoolean(verbose_img,
					      L_VERBOSE_IMAGES,
					      C_VERBOSE_IMAGES,
					      bool_choices);
	    } else {
		verbose_img = LYChoosePopup(verbose_img,
					    L_VERBOSE_IMAGES,
					    C_VERBOSE_IMAGES,
					    bool_choices,
					    2, FALSE, FALSE);
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'A':		/* Change user agent string. */
	    if (!no_useragent) {
		if (non_empty(LYUserAgent)) {
		    LYstrncpy(display_option,
			      LYUserAgent,
			      sizeof(display_option) - 1);
		} else {	/* clear the NONE */
		    LYmove(L_HOME, COL_OPTION_VALUES);
		    LYaddstr("    ");
		    *display_option = '\0';
		}
		_statusline(ACCEPT_DATA_OR_DEFAULT);
		LYmove(L_User_Agent, COL_OPTION_VALUES);
		lynx_start_bold();
		ch = LYgetstr(display_option, VISIBLE,
			      sizeof(display_option), NORECALL);
		lynx_stop_bold();
		LYmove(L_User_Agent, COL_OPTION_VALUES);
		if (term_options || ch == -1) {
		    LYaddstr((LYUserAgent &&
			      *LYUserAgent) ?
			     LYUserAgent : "NONE");
		} else if (*display_option == '\0') {
		    StrAllocCopy(LYUserAgent, LYUserAgentDefault);
		    LYaddstr((LYUserAgent &&
			      *LYUserAgent) ?
			     LYUserAgent : "NONE");
		} else {
		    StrAllocCopy(LYUserAgent, display_option);
		    LYaddstr(display_option);
		}
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else if (!LYCheckUserAgent()) {
		    _statusline(UA_PLEASE_USE_LYNX);
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
	    } else {		/* disallowed */
		_statusline(UA_CHANGE_DISABLED);
	    }
	    response = ' ';
	    break;

#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
	case 'X':		/* Change local exec restriction. */
	    if (exec_frozen && !LYSelectPopups) {
		_statusline(CHANGE_OF_SETTING_DISALLOWED);
		response = ' ';
		break;
	    }
#ifndef NEVER_ALLOW_REMOTE_EXEC
	    if (local_exec) {
		itmp = 2;
	    } else
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
	    {
		if (local_exec_on_local_files) {
		    itmp = 1;
		} else {
		    itmp = 0;
		}
	    }
	    if (!LYSelectPopups) {
		itmp = LYChooseBoolean(itmp,
				       L_Exec, -1,
				       exec_choices);
	    } else {
		itmp = LYChoosePopup(itmp,
				     L_Exec, -1,
				     exec_choices,
				     0, (exec_frozen ? TRUE : FALSE),
				     FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Exec, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(exec_choices[itmp]);
#endif /* VMS || USE_SLANG */
	    }
	    if (!exec_frozen) {
		switch (itmp) {
		case 0:
		    local_exec = FALSE;
		    local_exec_on_local_files = FALSE;
		    break;
		case 1:
		    local_exec = FALSE;
		    local_exec_on_local_files = TRUE;
		    break;
#ifndef NEVER_ALLOW_REMOTE_EXEC
		case 2:
		    local_exec = TRUE;
		    local_exec_on_local_files = FALSE;
		    break;
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
		}		/* end switch */
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
#endif /* ENABLE_OPTS_CHANGE_EXEC */

	case '>':		/* Save current options to RC file. */
	    if (!no_option_save) {
		HTInfoMsg(SAVING_OPTIONS);
		LYrcShowColor = LYChosenShowColor;
		if (save_rc(NULL)) {
		    HTInfoMsg(OPTIONS_SAVED);
		} else {
		    HTAlert(OPTIONS_NOT_SAVED);
		}
	    } else {
		HTInfoMsg(R_TO_RETURN_TO_LYNX);
		/*
		 * Change response so that we don't exit the options menu.
		 */
		response = ' ';
	    }
	    break;

	case 'R':		/* Return to document (quit options menu). */
	    break;

	default:
	    if (!no_option_save) {
		HTInfoMsg(SAVE_OR_R_TO_RETURN_TO_LYNX);
	    } else {
		HTInfoMsg(R_TO_RETURN_TO_LYNX);
	    }
	}			/* end switch */
    }				/* end while */

    term_options = FALSE;
    LYStatusLine = -1;		/* let user_mode have some of the screen */
    signal(SIGINT, cleanup_sig);
}

static int widest_choice(const char **choices)
{
    int n, width = 0;

    for (n = 0; choices[n] != NULL; ++n) {
	int len = strlen(choices[n]);

	if (width < len)
	    width = len;
    }
    return width;
}

static void show_choice(const char *choice,
			int width)
{
    int len = strlen(choice);

    LYaddstr(choice);
    while (len++ < width)
	LYaddch(' ');
}

/*
 * Take a status code, prompt the user for a new status, and return it.
 */
static int boolean_choice(int cur_choice,
			  int line,
			  int column,
			  const char **choices)
{
    int response = 0;
    int cmd = 0;
    int number = 0;
    int col = (column >= 0 ? column : COL_OPTION_VALUES);
    int orig_choice = cur_choice;
    int width = widest_choice(choices);

    /*
     * Get the number of choices and then make number zero-based.
     */
    for (number = 0; choices[number] != NULL; number++) ;	/* empty loop body */
    number--;

    /*
     * Update the statusline.
     */
    _statusline(ANY_KEY_CHANGE_RET_ACCEPT);

    /*
     * Highlight the current choice.
     */
    LYmove(line, col);
    lynx_start_reverse();
    show_choice(choices[cur_choice], width);
    if (LYShowCursor)
	LYmove(line, (col - 1));
    LYrefresh();

    /*
     * Get the keyboard entry, and leave the cursor at the choice, to indicate
     * that it can be changed, until the user accepts the current choice.
     */
    term_options = FALSE;
    while (1) {
	LYmove(line, col);
	if (term_options == FALSE) {
	    response = LYgetch_single();
	}
	if (term_options || LYCharIsINTERRUPT_NO_letter(response)) {
	    /*
	     * Control-C or Control-G.
	     */
	    response = '\n';
	    term_options = TRUE;
	    cur_choice = orig_choice;
	}
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    response = '\n';
	    term_options = TRUE;
	    cur_choice = orig_choice;
	}
#endif /* VMS */
	if ((response != '\n' && response != '\r') &&
	    (cmd = LKC_TO_LAC(keymap, response)) != LYK_ACTIVATE) {
	    switch (cmd) {
	    case LYK_HOME:
		cur_choice = 0;
		break;

	    case LYK_END:
		cur_choice = number;
		break;

	    case LYK_REFRESH:
		lynx_force_repaint();
		LYrefresh();
		break;

	    case LYK_QUIT:
	    case LYK_ABORT:
	    case LYK_PREV_DOC:
		cur_choice = orig_choice;
		term_options = TRUE;
		break;

	    case LYK_PREV_PAGE:
	    case LYK_UP_HALF:
	    case LYK_UP_TWO:
	    case LYK_PREV_LINK:
	    case LYK_LPOS_PREV_LINK:
	    case LYK_FASTBACKW_LINK:
	    case LYK_UP_LINK:
	    case LYK_LEFT_LINK:
		if (cur_choice == 0)
		    cur_choice = number;	/* go back to end */
		else
		    cur_choice--;
		break;

	    case LYK_1:
	    case LYK_2:
	    case LYK_3:
	    case LYK_4:
	    case LYK_5:
	    case LYK_6:
	    case LYK_7:
	    case LYK_8:
	    case LYK_9:
		if ((cmd - LYK_1 + 1) <= number) {
		    cur_choice = cmd - LYK_1 + 1;
		    break;
		}		/* else fall through! */
	    default:
		if (cur_choice == number)
		    cur_choice = 0;	/* go over the top and around */
		else
		    cur_choice++;
	    }			/* end of switch */
	    show_choice(choices[cur_choice], width);
	    if (LYShowCursor)
		LYmove(line, (col - 1));
	    LYrefresh();
	} else {
	    /*
	     * Unhighlight choice.
	     */
	    LYmove(line, col);
	    lynx_stop_reverse();
	    show_choice(choices[cur_choice], width);

	    if (term_options) {
		term_options = FALSE;
		HTInfoMsg(CANCELLED);
		HTInfoMsg("");
	    } else {
		_statusline(VALUE_ACCEPTED);
	    }
	    return cur_choice;
	}
    }
}
#endif /* !NO_OPTION_MENU */

static void terminate_options(int sig GCC_UNUSED)
{
    term_options = TRUE;
    /*
     * Reassert the AST.
     */
    signal(SIGINT, terminate_options);
#ifdef VMS
    /*
     * Refresh the screen to get rid of the "interrupt" message.
     */
    if (!dump_output_immediately) {
	lynx_force_repaint();
	LYrefresh();
    }
#endif /* VMS */
}

/*
 * Multi-Bookmark On-Line editing support.  - FMG & FM
 */
void edit_bookmarks(void)
{
    int response = 0, def_response = 0, ch;
    int MBM_current = 1;

#define MULTI_OFFSET 8
    int a;			/* misc counter */
    char MBM_tmp_line[256];	/* buffer for LYgetstr */
    char ehead_buffer[265];

    /*
     * We need (MBM_V_MAXFILES + MULTI_OFFSET) lines to display the whole list
     * at once.  Otherwise break it up into two segments.  We know it won't be
     * less than that because 'o'ptions needs 23-24 at LEAST.
     */
    term_options = FALSE;
    signal(SIGINT, terminate_options);

  draw_bookmark_list:
    /*
     * Display menu of bookmarks.  NOTE that we avoid printw()'s to increase
     * the chances that any non-ASCII or multibyte/CJK characters will be
     * handled properly.  - FM
     */
#if defined(FANCY_CURSES) || defined (USE_SLANG)
    if (enable_scrollback) {
	LYclear();
    } else {
	LYerase();
    }
#else
    LYclear();
#endif /* FANCY_CURSES || USE_SLANG */
    LYmove(0, 5);
    lynx_start_h1_color();
    if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET)) {
	sprintf(ehead_buffer, MULTIBOOKMARKS_EHEAD_MASK, MBM_current);
	LYaddstr(ehead_buffer);
    } else {
	LYaddstr(MULTIBOOKMARKS_EHEAD);
    }
    lynx_stop_h1_color();

    if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET)) {
	for (a = ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1));
	     a <= (MBM_current * MBM_V_MAXFILES / 2); a++) {
	    LYmove((3 + a) - ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1)), 5);
	    LYaddch(UCH(LYindex2MBM(a)));
	    LYaddstr(" : ");
	    if (MBM_A_subdescript[a])
		LYaddstr(MBM_A_subdescript[a]);
	    LYmove((3 + a) - ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1)), 35);
	    LYaddstr("| ");
	    if (MBM_A_subbookmark[a]) {
		LYaddstr(MBM_A_subbookmark[a]);
	    }
	}
    } else {
	for (a = 0; a <= MBM_V_MAXFILES; a++) {
	    LYmove(3 + a, 5);
	    LYaddch(UCH(LYindex2MBM(a)));
	    LYaddstr(" : ");
	    if (MBM_A_subdescript[a])
		LYaddstr(MBM_A_subdescript[a]);
	    LYmove(3 + a, 35);
	    LYaddstr("| ");
	    if (MBM_A_subbookmark[a]) {
		LYaddstr(MBM_A_subbookmark[a]);
	    }
	}
    }

    /*
     * Only needed when we have 2 screens.
     */
    if (LYlines < MBM_V_MAXFILES + MULTI_OFFSET) {
	LYmove((LYlines - 4), 0);
	LYaddstr("'");
	lynx_start_bold();
	LYaddstr("[");
	lynx_stop_bold();
	LYaddstr("' ");
	LYaddstr(PREVIOUS);
	LYaddstr(", '");
	lynx_start_bold();
	LYaddstr("]");
	lynx_stop_bold();
	LYaddstr("' ");
	LYaddstr(NEXT_SCREEN);
    }

    LYmove((LYlines - 3), 0);
    if (!no_option_save) {
	LYaddstr("'");
	lynx_start_bold();
	LYaddstr(">");
	lynx_stop_bold();
	LYaddstr("'");
	LYaddstr(TO_SAVE_SEGMENT);
    }
    LYaddstr(OR_SEGMENT);
    LYaddstr("'");
    lynx_start_bold();
    LYaddstr("^G");
    lynx_stop_bold();
    LYaddstr("'");
    LYaddstr(TO_RETURN_SEGMENT);

    while (!term_options &&
	   !LYisNonAlnumKeyname(response, LYK_PREV_DOC) &&
	   !LYCharIsINTERRUPT_NO_letter(response) && response != '>') {

	LYmove((LYlines - 2), 0);
	lynx_start_prompt_color();
	LYaddstr(MULTIBOOKMARKS_LETTER);
	lynx_stop_prompt_color();

	LYrefresh();
	response = (def_response ? def_response : LYgetch_single());
	def_response = 0;

	/*
	 * Check for a cancel.
	 */
	if (term_options || LYCharIsINTERRUPT_NO_letter(response) ||
	    LYisNonAlnumKeyname(response, LYK_PREV_DOC))
	    continue;

	/*
	 * Check for a save.
	 */
	if (response == '>') {
	    if (!no_option_save) {
		HTInfoMsg(SAVING_OPTIONS);
		if (save_rc(NULL))
		    HTInfoMsg(OPTIONS_SAVED);
		else
		    HTAlert(OPTIONS_NOT_SAVED);
	    } else {
		HTInfoMsg(R_TO_RETURN_TO_LYNX);
		/*
		 * Change response so that we don't exit the options menu.
		 */
		response = ' ';
	    }
	    continue;
	}

	/*
	 * Check for a refresh.
	 */
	if (LYisNonAlnumKeyname(response, LYK_REFRESH)) {
	    lynx_force_repaint();
	    continue;
	}

	/*
	 * Move between the screens - if we can't show it all at once.
	 */
	if ((response == ']' ||
	     LYisNonAlnumKeyname(response, LYK_NEXT_PAGE)) &&
	    LYlines < (MBM_V_MAXFILES + MULTI_OFFSET)) {
	    MBM_current++;
	    if (MBM_current >= 3)
		MBM_current = 1;
	    goto draw_bookmark_list;
	}
	if ((response == '[' ||
	     LYisNonAlnumKeyname(response, LYK_PREV_PAGE)) &&
	    LYlines < (MBM_V_MAXFILES + MULTI_OFFSET)) {
	    MBM_current--;
	    if (MBM_current <= 0)
		MBM_current = 2;
	    goto draw_bookmark_list;
	}

	/*
	 * Instead of using 26 case statements, we set up a scan through the
	 * letters and edit the lines that way.
	 */
	for (a = 0; a <= MBM_V_MAXFILES; a++) {
	    if (LYMBM2index(response) == a) {
		if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET)) {
		    if (MBM_current == 1 && a > (MBM_V_MAXFILES / 2)) {
			MBM_current = 2;
			def_response = response;
			goto draw_bookmark_list;
		    }
		    if (MBM_current == 2 && a < (MBM_V_MAXFILES / 2)) {
			MBM_current = 1;
			def_response = response;
			goto draw_bookmark_list;
		    }
		}
		_statusline(ACCEPT_DATA);

		if (a > 0) {
		    lynx_start_bold();
		    if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET))
			LYmove((3 + a)
			       - ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1)),
			       9);
		    else
			LYmove((3 + a), 9);
		    LYstrncpy(MBM_tmp_line,
			      (!MBM_A_subdescript[a] ?
			       "" : MBM_A_subdescript[a]),
			      sizeof(MBM_tmp_line) - 1);
		    ch = LYgetstr(MBM_tmp_line, VISIBLE,
				  sizeof(MBM_tmp_line), NORECALL);
		    lynx_stop_bold();

		    if (strlen(MBM_tmp_line) < 1) {
			FREE(MBM_A_subdescript[a]);
		    } else {
			StrAllocCopy(MBM_A_subdescript[a], MBM_tmp_line);
		    }
		    if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET))
			LYmove((3 + a)
			       - ((MBM_V_MAXFILES / 2 + 1)
				  * (MBM_current - 1)),
			       5);
		    else
			LYmove((3 + a), 5);
		    LYaddch(UCH(LYindex2MBM(a)));
		    LYaddstr(" : ");
		    if (MBM_A_subdescript[a])
			LYaddstr(MBM_A_subdescript[a]);
		    LYclrtoeol();
		    LYrefresh();
		}

		if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET))
		    LYmove((3 + a)
			   - ((MBM_V_MAXFILES / 2 + 1)
			      * (MBM_current - 1)),
			   35);
		else
		    LYmove((3 + a), 35);
		LYaddstr("| ");

		lynx_start_bold();
		LYstrncpy(MBM_tmp_line,
			  NonNull(MBM_A_subbookmark[a]),
			  sizeof(MBM_tmp_line) - 1);
		ch = LYgetstr(MBM_tmp_line, VISIBLE,
			      sizeof(MBM_tmp_line), NORECALL);
		lynx_stop_bold();

		if (*MBM_tmp_line == '\0') {
		    if (a == 0)
			StrAllocCopy(MBM_A_subbookmark[a], bookmark_page);
		    else
			FREE(MBM_A_subbookmark[a]);
		} else if (!LYPathOffHomeOK(MBM_tmp_line,
					    sizeof(MBM_tmp_line))) {
		    LYMBM_statusline(USE_PATH_OFF_HOME);
		    LYSleepAlert();
		} else {
		    StrAllocCopy(MBM_A_subbookmark[a], MBM_tmp_line);
		    if (a == 0) {
			StrAllocCopy(bookmark_page, MBM_A_subbookmark[a]);
		    }
		}
		if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET))
		    LYmove((3 + a)
			   - ((MBM_V_MAXFILES / 2 + 1)
			      * (MBM_current - 1)),
			   35);
		else
		    LYmove((3 + a), 35);
		LYaddstr("| ");
		if (MBM_A_subbookmark[a])
		    LYaddstr(MBM_A_subbookmark[a]);
		LYclrtoeol();
		LYmove(LYlines - 1, 0);
		LYclrtoeol();
		break;
	    }
	}			/* end for */
    }				/* end while */

    term_options = FALSE;
    signal(SIGINT, cleanup_sig);
}

#if !defined(NO_OPTION_MENU) || (defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES)))

/*
 * This function offers the choices for values of an option via a popup window
 * which functions like that for selection of options in a form.  - FM
 *
 * Also used for mouse popups with ncurses; this is indicated by for_mouse.
 */
int popup_choice(int cur_choice,
		 int line,
		 int column,
		 const char **choices,
		 int i_length,
		 int disabled,
		 BOOLEAN for_mouse)
{
    if (column < 0)
	column = (COL_OPTION_VALUES - 1);

    term_options = FALSE;
    cur_choice = LYhandlePopupList(cur_choice,
				   line,
				   column,
				   (const char **) choices,
				   -1,
				   i_length,
				   disabled,
				   for_mouse,
				   TRUE);
    switch (cur_choice) {
    case LYK_QUIT:
    case LYK_ABORT:
    case LYK_PREV_DOC:
	term_options = TRUE;
	if (!for_mouse) {
	    HTUserMsg(CANCELLED);
	}
	break;
    }

    if (disabled || term_options) {
	_statusline("");
    } else if (!for_mouse) {
	_statusline(VALUE_ACCEPTED);
    }
    return (cur_choice);
}

#endif /* !NO_OPTION_MENU */
#ifndef NO_OPTION_FORMS

/*
 * I'm paranoid about mistyping strings.  Also, this way they get combined
 * so we don't have to worry about the intelligence of the compiler.
 * We don't need to burn memory like it's cheap.  We're better than that.
 */
#define SELECTED(flag) (flag) ? selected_string : ""
#define DISABLED(flag) (flag) ? disabled_string : ""

typedef struct {
    int value;
    const char *LongName;
    const char *HtmlName;
} OptValues;

typedef struct {
    char *tag;
    char *value;
} PostPair;

static const char selected_string[] = "selected";
static const char disabled_string[] = "disabled";
static const char on_string[] = N_("ON");
static const char off_string[] = N_("OFF");
static const char never_string[] = N_("NEVER");
static const char always_string[] = N_("ALWAYS");
static OptValues bool_values[] =
{
    {FALSE, N_("OFF"), "OFF"},
    {TRUE, N_("ON"), "ON"},
    {0, 0, 0}
};

static const char *secure_string = "secure";
static char *secure_value = NULL;
static const char *save_options_string = "save_options";

/*
 * Personal Preferences
 */
static const char *cookies_string = RC_SET_COOKIES;
static const char *cookies_ignore_all_string = N_("ignore");
static const char *cookies_up_to_user_string = N_("ask user");
static const char *cookies_accept_all_string = N_("accept all");
static const char *x_display_string = RC_DISPLAY;
static const char *editor_string = RC_FILE_EDITOR;
static const char *emacs_keys_string = RC_EMACS_KEYS;

#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
#define EXEC_ALWAYS 2
#define EXEC_LOCAL  1
#define EXEC_NEVER  0
static const char *exec_links_string = RC_RUN_ALL_EXECUTION_LINKS;
static OptValues exec_links_values[] =
{
    {EXEC_NEVER, N_("ALWAYS OFF"), "ALWAYS OFF"},
    {EXEC_LOCAL, N_("FOR LOCAL FILES ONLY"), "FOR LOCAL FILES ONLY"},
#ifndef NEVER_ALLOW_REMOTE_EXEC
    {EXEC_ALWAYS, N_("ALWAYS ON"), "ALWAYS ON"},
#endif
    {0, 0, 0}
};
#endif /* ENABLE_OPTS_CHANGE_EXEC */

#ifdef EXP_KEYBOARD_LAYOUT
static const char *kblayout_string = RC_KBLAYOUT;
#endif
static const char *keypad_mode_string = RC_KEYPAD_MODE;
static OptValues keypad_mode_values[] =
{
    {NUMBERS_AS_ARROWS, N_("Numbers act as arrows"),
     "number_arrows"},
    {LINKS_ARE_NUMBERED, N_("Links are numbered"),
     "links_numbered"},
    {LINKS_AND_FIELDS_ARE_NUMBERED,
     N_("Links and form fields are numbered"),
     "links_and_forms"},
    {FIELDS_ARE_NUMBERED,
     N_("Form fields are numbered"),
     "forms_numbered"},
    {0, 0, 0}
};
static const char *lineedit_mode_string = RC_LINEEDIT_MODE;
static const char *mail_address_string = RC_PERSONAL_MAIL_ADDRESS;
static const char *anonftp_password_string = RC_ANONFTP_PASSWORD;
static const char *search_type_string = RC_CASE_SENSITIVE_SEARCHING;
static OptValues search_type_values[] =
{
    {FALSE, N_("Case insensitive"), "case_insensitive"},
    {TRUE, N_("Case sensitive"), "case_sensitive"},
    {0, 0, 0}
};

#if defined(USE_SLANG) || defined(COLOR_CURSES)
static const char *show_color_string = RC_SHOW_COLOR;
static OptValues show_color_values[] =
{
    {SHOW_COLOR_NEVER, never_string, never_string},
    {SHOW_COLOR_OFF, off_string, off_string},
    {SHOW_COLOR_ON, on_string, on_string},
    {SHOW_COLOR_ALWAYS, always_string, always_string},
    {0, 0, 0}
};
#endif

static const char *show_cursor_string = RC_SHOW_CURSOR;

static const char *underline_links_string = RC_UNDERLINE_LINKS;

#ifdef USE_SCROLLBAR
static const char *show_scrollbar_string = RC_SCROLLBAR;
#endif

static const char prompt_dft_string[] = N_("prompt normally");
static const char prompt_yes_string[] = N_("force yes-response");
static const char prompt_no_string[] = N_("force no-response");
static OptValues prompt_values[] =
{
    {FORCE_PROMPT_DFT, prompt_dft_string, prompt_dft_string},
    {FORCE_PROMPT_YES, prompt_yes_string, prompt_yes_string},
    {FORCE_PROMPT_NO, prompt_no_string, prompt_no_string},
    {0, 0, 0}
};

static const char *cookie_prompt_string = RC_FORCE_COOKIE_PROMPT;

#ifdef USE_SSL
static const char *ssl_prompt_string = RC_FORCE_SSL_PROMPT;
#endif

static const char *user_mode_string = RC_USER_MODE;
static OptValues user_mode_values[] =
{
    {NOVICE_MODE, N_("Novice"), "Novice"},
    {INTERMEDIATE_MODE, N_("Intermediate"), "Intermediate"},
    {ADVANCED_MODE, N_("Advanced"), "Advanced"},
    {0, 0, 0}
};

static const char *vi_keys_string = RC_VI_KEYS;

static const char *visited_links_string = RC_VISITED_LINKS;
static OptValues visited_links_values[] =
{
    {VISITED_LINKS_AS_FIRST_V, N_("By First Visit"), "first_visited"},
    {VISITED_LINKS_AS_FIRST_V | VISITED_LINKS_REVERSE,
     N_("By First Visit Reversed"), "first_visited_reversed"},
    {VISITED_LINKS_AS_TREE, N_("As Visit Tree"), "visit_tree"},
    {VISITED_LINKS_AS_LATEST, N_("By Last Visit"), "last_visited"},
    {VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE,
     N_("By Last Visit Reversed"), "last_visited_reversed"},
    {0, 0, 0}
};

/*
 * Document Layout
 */
static const char *DTD_recovery_string = RC_TAGSOUP;
static OptValues DTD_type_values[] =
{
	/* Old_DTD variable */
    {TRUE, N_("relaxed (TagSoup mode)"), "tagsoup"},
    {FALSE, N_("strict (SortaSGML mode)"), "sortasgml"},
    {0, 0, 0}
};

static const char *select_popups_string = RC_SELECT_POPUPS;
static const char *images_string = "images";
static const char *images_ignore_all_string = N_("ignore");
static const char *images_use_label_string = N_("as labels");
static const char *images_use_links_string = N_("as links");

static const char *verbose_images_string = RC_VERBOSE_IMAGES;
static OptValues verbose_images_type_values[] =
{
	/* verbose_img variable */
    {FALSE, N_("OFF"), "OFF"},
    {TRUE, N_("show filename"), "ON"},
    {0, 0, 0}
};

/*
 * Bookmark Options
 */
static const char *mbm_string = RC_MULTI_BOOKMARK;
static OptValues mbm_values[] =
{
    {MBM_OFF, N_("OFF"), "OFF"},
    {MBM_STANDARD, N_("STANDARD"), "STANDARD"},
    {MBM_ADVANCED, N_("ADVANCED"), "ADVANCED"},
    {0, 0, 0}
};

static const char *single_bookmark_string = RC_BOOKMARK_FILE;

/*
 * Character Set Options
 */
static const char *assume_char_set_string = RC_ASSUME_CHARSET;
static const char *display_char_set_string = RC_CHARACTER_SET;
static const char *raw_mode_string = RC_RAW_MODE;

#ifdef EXP_LOCALE_CHARSET
static const char *locale_charset_string = RC_LOCALE_CHARSET;
#endif

/*
 * File Management Options
 */
static const char *show_dotfiles_string = RC_SHOW_DOTFILES;

#ifdef DIRED_SUPPORT
static const char *dired_list_string = RC_DIR_LIST_STYLE;
static OptValues dired_list_values[] =
{
    {DIRS_FIRST, N_("Directories first"), "dired_dir"},
    {FILES_FIRST, N_("Files first"), "dired_files"},
    {MIXED_STYLE, N_("Mixed style"), "dired_mixed"},
    {0, 0, 0}
};

#ifdef LONG_LIST
static const char *dired_sort_string = RC_DIR_LIST_ORDER;
static OptValues dired_sort_values[] =
{
    {ORDER_BY_NAME, N_("By Name"), "dired_by_name"},
    {ORDER_BY_TYPE, N_("By Type"), "dired_by_type"},
    {ORDER_BY_SIZE, N_("By Size"), "dired_by_size"},
    {ORDER_BY_DATE, N_("By Date"), "dired_by_date"},
    {ORDER_BY_MODE, N_("By Mode"), "dired_by_mode"},
#ifndef NO_GROUPS
    {ORDER_BY_USER, N_("By User"), "dired_by_user"},
    {ORDER_BY_GROUP, N_("By Group"), "dired_by_group"},
#endif
    {0, 0, 0}
};
#endif /* LONG_LIST */
#endif /* DIRED_SUPPORT */

static const char *ftp_sort_string = RC_FILE_SORTING_METHOD;
static OptValues ftp_sort_values[] =
{
    {FILE_BY_NAME, N_("By Name"), "ftp_by_name"},
    {FILE_BY_TYPE, N_("By Type"), "ftp_by_type"},
    {FILE_BY_SIZE, N_("By Size"), "ftp_by_size"},
    {FILE_BY_DATE, N_("By Date"), "ftp_by_date"},
    {0, 0, 0}
};

#ifdef USE_READPROGRESS
static const char *show_rate_string = RC_SHOW_KB_RATE;
static OptValues rate_values[] =
{
    {rateOFF, N_("Do not show rate"), "rate_off"},
    {rateBYTES, N_("Show %s/sec rate"), "rate_bytes"},
    {rateKB, N_("Show %s/sec rate"), "rate_kb"},
#ifdef USE_READPROGRESS
    {rateEtaBYTES, N_("Show %s/sec, ETA"), "rate_eta_bytes"},
    {rateEtaKB, N_("Show %s/sec, ETA"), "rate_eta_kb"},
#endif
    {0, 0, 0}
};
#endif /* USE_READPROGRESS */

/*
 * Presentation (MIME) types used in "Accept".
 */
static const char *preferred_media_string = RC_PREFERRED_MEDIA_TYPES;
static OptValues media_values[] =
{
    {mediaOpt1, N_("Accept lynx's internal types"), "media_opt1"},
    {mediaOpt2, N_("Also accept lynx.cfg's types"), "media_opt2"},
    {mediaOpt3, N_("Also accept user's types"), "media_opt3"},
    {mediaOpt4, N_("Also accept system's types"), "media_opt4"},
    {mediaALL, N_("Accept all types"), "media_all"},
    {0, 0, 0}
};

static const char *preferred_encoding_string = RC_PREFERRED_ENCODING;
static OptValues encoding_values[] =
{
    {encodingNONE, N_("None"), "encoding_none"},
#if defined(USE_ZLIB) || defined(GZIP_PATH)
    {encodingGZIP, N_("gzip"), "encoding_gzip"},
    {encodingDEFLATE, N_("deflate"), "encoding_deflate"},
#endif
#if defined(USE_ZLIB) || defined(COMPRESS_PATH)
    {encodingCOMPRESS, N_("compress"), "encoding_compress"},
#endif
#if defined(USE_BZLIB) || defined(BZIP2_PATH)
    {encodingBZIP2, N_("bzip2"), "encoding_bzip2"},
#endif
    {encodingALL, N_("All"), "encoding_all"},
    {0, 0, 0}
};

/*
 * Headers transferred to remote server
 */
static const char *preferred_doc_char_string = RC_PREFERRED_CHARSET;
static const char *preferred_doc_lang_string = RC_PREFERRED_LANGUAGE;
static const char *user_agent_string = RC_USERAGENT;

#define PutTextInput(fp, Name, Value, Size, disable) \
	fprintf(fp,\
	"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",\
		(int) Size, Name, Value, disable_all?disabled_string:disable)

#define PutOption(fp, flag, html, name) \
	fprintf(fp,"<option value=\"%s\" %s>%s\n", html, SELECTED(flag), gettext(name))

#define BeginSelect(fp, text) \
	fprintf(fp,"<select name=\"%s\" %s>\n", text, disable_all?disabled_string:"")

#define MaybeSelect(fp, flag, text) \
	fprintf(fp,"<select name=\"%s\" %s>\n", text, disable_all?disabled_string:DISABLED(flag))

#define EndSelect(fp)\
	fprintf(fp,"</select>\n")

static void PutOptValues(FILE *fp, int value,
			 OptValues * table)
{
    while (table->LongName != 0) {
	if (table->HtmlName) {
	    PutOption(fp,
		      value == table->value,
		      table->HtmlName,
		      table->LongName);
	}
	table++;
    }
}

static BOOLEAN GetOptValues(OptValues * table, char *value,
			    int *result)
{
    while (table->LongName != 0) {
	if (table->HtmlName && !strcmp(value, table->HtmlName)) {
	    *result = table->value;
	    return TRUE;
	}
	table++;
    }
    return FALSE;
}

/*
 * Break cgi line into array of pairs of pointers.  Don't bother trying to
 * be efficient.  We're not called all that often.
 * We come in with a string looking like:
 * tag1=value1&tag2=value2&...&tagN=valueN
 * We leave with an array of post_pairs.  The last element in the array
 * will have a tag pointing to NULL.
 * Not pretty, but works.  Hey, if strings can be null terminate arrays...
 */
static PostPair *break_data(bstring *data)
{
    char *p;
    PostPair *q = NULL;
    int count = 0;

    if (isBEmpty(data))
	return NULL;

    p = BStrData(data);
    CTRACE((tfp, "break_data %s\n", p));

    q = typecalloc(PostPair);
    if (q == NULL)
	outofmem(__FILE__, "break_data(calloc)");

    do {
	/*
	 * First, break up on '&', sliding 'p' on down the line.
	 */
	q[count].value = LYstrsep(&p, "&");
	/*
	 * Then break up on '=', sliding value down, and setting tag.
	 */
	q[count].tag = LYstrsep(&(q[count].value), "=");

	/*
	 * Clean them up a bit, in case user entered a funky string.
	 */
	HTUnEscape(q[count].tag);

	/* In the value field we have '+' instead of ' '. So do a simple
	 * find&replace on the value field before UnEscaping() - SKY
	 */
	{
	    size_t i, len;

	    len = strlen(q[count].value);
	    for (i = 0; i < len; i++) {
		if (q[count].value[i] == '+') {
#ifdef UNIX
		    /*
		     * Allow for special case of options which begin with a "+" on
		     * Unix - TD
		     */
		    if (i > 0
			&& q[count].value[i + 1] == '+'
			&& isalnum(UCH(q[count].value[i + 2]))) {
			q[count].value[i++] = ' ';
			i++;
			continue;
		    }
#endif
		    q[count].value[i] = ' ';
		}
	    }
	}
	HTUnEscape(q[count].value);
	CTRACE((tfp, "...item[%d] tag=%s, value=%s\n",
		count, q[count].tag, q[count].value));

	count++;
	/*
	 * Like I said, screw efficiency.  Sides, realloc is fast on
	 * Linux ;->
	 */
	q = typeRealloc(PostPair, q, count + 1);
	if (q == NULL)
	    outofmem(__FILE__, "break_data(realloc)");
	q[count].tag = NULL;
    } while (p != NULL && p[0] != '\0');
    return q;
}

static BOOL isLynxOptionsPage(const char *address, const char *portion)
{
    BOOL result = FALSE;

    if (!strncasecomp(address, STR_LYNXOPTIONS, LEN_LYNXOPTIONS)) {
	unsigned len = strlen(portion);

	address += LEN_LYNXOPTIONS;
	if (!strncasecomp(address, portion, len)
	    && (address[len] == '\0' || LYIsHtmlSep(address[len]))) {
	    result = TRUE;
	}
    }
    return result;
}

static int gen_options(char **newfile);

/*
 * Handle options from the pseudo-post.  I think we really only need
 * post_data here, but bring along everything just in case.  It's only a
 * pointer.  MRC
 *
 * Options are processed in order according to gen_options(), we should not
 * depend on it and add boolean flags where the order is essential (save,
 * character sets...)
 *
 * Security:  some options are disabled in gen_options() under certain
 * conditions.  We *should* duplicate the same conditions here in postoptions()
 * to prevent user with a limited access from editing HTML options code
 * manually (e.g., doing 'e'dit in 'o'ptions) and submit it to access the
 * restricted items.  Prevent spoofing attempts from index overrun. - LP
 *
 * Exit status: NULLFILE (reload) or NORMAL (use HText cache).
 *
 * On exit, got the document which was current before the Options menu:
 *
 *   (from cache) nothing changed or no visual effect supposed:
 *             editor name, e-mail, etc.
 *
 *   (reload locally) to see the effect of certain changes:
 *             display_char_set, assume_charset, etc.
 *             (use 'need_reload' flag where necessary).
 *
 *   (reload from remote server and uncache on a proxy)
 *             few options changes should be transferred to remote server:
 *             preferred language, fake browser name, etc.
 *             (use 'need_end_reload' flag).
 */

int postoptions(DocInfo *newdoc)
{
    PostPair *data = 0;
    DocAddress WWWDoc;		/* need on exit */
    int i;
    int code;
    BOOLEAN save_all = FALSE;
    int display_char_set_old = current_char_set;
    int old_media_value = LYAcceptMedia;
    BOOLEAN raw_mode_old = LYRawMode;
    BOOLEAN assume_char_set_changed = FALSE;
    BOOLEAN need_reload = FALSE;
    BOOLEAN need_end_reload = FALSE;

#if defined(USE_SLANG) || defined(COLOR_CURSES)
    int CurrentShowColor = LYShowColor;
#endif

    /*-------------------------------------------------
     * kludge a link from mbm_menu, the URL was:
     * "<a href=\"" LYNXOPTIONS_PAGE(MBM_MENU) "\">Goto multi-bookmark menu</a>\n"
     *--------------------------------------------------*/

    if (isLynxOptionsPage(newdoc->address, MBM_LINK)) {
	FREE(newdoc->post_data);
	if (no_bookmark) {
	    HTAlert(BOOKMARK_CHANGE_DISALLOWED);	/* anonymous */
	    return (NULLFILE);
	} else if (dump_output_immediately) {
	    return (NOT_FOUND);
	} else {
	    edit_bookmarks();
	    return (NULLFILE);
	}
    } else if (!isLynxOptionsPage(newdoc->address, "/")) {
	HTAlert(RANDOM_URL_DISALLOWED);
	return NULLFILE;
    }

    data = break_data(newdoc->post_data);

    if (!data) {
	int status;

	/*-------------------------------------------------
	 * kludge gen_options() call:
	 *--------------------------------------------------*/
	status = gen_options(&newdoc->address);
	if (status != NORMAL) {
	    HTAlwaysAlert("Unexpected way of accessing", newdoc->address);
	    FREE(newdoc->address);
	    return (status);
	}

	/* exit to getfile() cycle */
	WWWDoc.address = newdoc->address;
	WWWDoc.post_data = newdoc->post_data;
	WWWDoc.post_content_type = newdoc->post_content_type;
	WWWDoc.bookmark = newdoc->bookmark;
	WWWDoc.isHEAD = newdoc->isHEAD;
	WWWDoc.safe = newdoc->safe;

	if (!HTLoadAbsolute(&WWWDoc))
	    return (NOT_FOUND);
	LYRegisterUIPage(newdoc->address, UIP_OPTIONS_MENU);
#ifdef DIRED_SUPPORT
	lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
	return (NORMAL);
    }

    if (!LYIsUIPage3(HTLoadedDocumentURL(), UIP_OPTIONS_MENU, 0) &&
	!LYIsUIPage3(HTLoadedDocumentURL(), UIP_VLINKS, 0)) {
	char *buf = NULL;

	/*  We may have been spoofed? */
	HTSprintf0(&buf,
		   gettext("Use %s to invoke the Options menu!"),
		   key_for_func_ext(LYK_OPTIONS, FOR_PANEL));
	HTAlert(buf);
	FREE(buf);
	FREE(data);
	return (NOT_FOUND);
    }

    for (i = 0; data[i].tag != NULL; i++) {
	/*
	 * This isn't really for security, but rather for avoiding that the
	 * user may revisit an older instance from the history stack and submit
	 * stuff which accidentally undoes changes that had been done from a
	 * newer instance.  - kw
	 */
	if (!strcmp(data[i].tag, secure_string)) {
	    if (!secure_value || strcmp(data[i].value, secure_value)) {
		char *buf = NULL;

		/*
		 * We probably came from an older instance of the Options
		 * page that had been on the history stack. - kw
		 */
		HTSprintf0(&buf,
			   gettext("Use %s to invoke the Options menu!"),
			   key_for_func_ext(LYK_OPTIONS, FOR_PANEL));
		HTAlert(buf);
		FREE(data);
		return (NULLFILE);
	    }
	    FREE(secure_value);
	}

	/* Save options */
	if (!strcmp(data[i].tag, save_options_string) && (!no_option_save)) {
	    save_all = TRUE;
	}

	/* Cookies: SELECT */
	if (!strcmp(data[i].tag, cookies_string)) {
	    if (!strcmp(data[i].value, cookies_ignore_all_string)) {
		LYSetCookies = FALSE;
	    } else if (!strcmp(data[i].value, cookies_up_to_user_string)) {
		LYSetCookies = TRUE;
		LYAcceptAllCookies = FALSE;
	    } else if (!strcmp(data[i].value, cookies_accept_all_string)) {
		LYSetCookies = TRUE;
		LYAcceptAllCookies = TRUE;
	    }
	}

	/* X Display: INPUT */
	if (!strcmp(data[i].tag, x_display_string)) {
	    LYsetXDisplay(data[i].value);
	    validate_x_display();
	    summarize_x_display(data[i].value);
	}

	/* Editor: INPUT */
	if (!strcmp(data[i].tag, editor_string)) {
	    FREE(editor);
	    StrAllocCopy(editor, data[i].value);
	}

	/* Emacs keys: ON/OFF */
	if (!strcmp(data[i].tag, emacs_keys_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    if ((emacs_keys = (BOOL) code) != FALSE) {
		set_emacs_keys();
	    } else {
		reset_emacs_keys();
	    }
	}

	/* Execution links: SELECT */
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
	if (!strcmp(data[i].tag, exec_links_string)
	    && GetOptValues(exec_links_values, data[i].value, &code)) {
#ifndef NEVER_ALLOW_REMOTE_EXEC
	    local_exec = (code == EXEC_ALWAYS);
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
	    local_exec_on_local_files = (code == EXEC_LOCAL);
	}
#endif /* ENABLE_OPTS_CHANGE_EXEC */

	/* Keypad Mode: SELECT */
	if (!strcmp(data[i].tag, keypad_mode_string)) {
	    int newval;

	    if (GetOptValues(keypad_mode_values, data[i].value, &newval)
		&& keypad_mode != newval) {
		keypad_mode = newval;
		need_reload = TRUE;
		if (keypad_mode == NUMBERS_AS_ARROWS) {
		    set_numbers_as_arrows();
		} else {
		    reset_numbers_as_arrows();
		}
	    }
	}

	/* Line edit style: SELECT */
	if (!strcmp(data[i].tag, lineedit_mode_string)) {
	    int newval = atoi(data[i].value);
	    int j;

	    /* prevent spoofing attempt */
	    for (j = 0; LYLineeditNames[j]; j++) {
		if (j == newval)
		    current_lineedit = newval;
	    }
	}
#ifdef EXP_KEYBOARD_LAYOUT
	/* Keyboard layout: SELECT */
	if (!strcmp(data[i].tag, kblayout_string)) {
	    int newval = atoi(data[i].value);
	    int j;

	    /* prevent spoofing attempt */
	    for (j = 0; LYKbLayoutNames[j]; j++) {
		if (j == newval)
		    current_layout = newval;
	    }
	}
#endif /* EXP_KEYBOARD_LAYOUT */

	/* Mail Address: INPUT */
	if (!strcmp(data[i].tag, mail_address_string)) {
	    FREE(personal_mail_address);
	    StrAllocCopy(personal_mail_address, data[i].value);
	}

	/* Anonymous FTP Password: INPUT */
	if (!strcmp(data[i].tag, anonftp_password_string)) {
	    FREE(anonftp_password);
	    StrAllocCopy(anonftp_password, data[i].value);
	}

	/* Search Type: SELECT */
	if (!strcmp(data[i].tag, search_type_string)
	    && GetOptValues(search_type_values, data[i].value, &code)) {
	    case_sensitive = (BOOL) code;
	}

	/* HTML error tolerance: SELECT */
	if (!strcmp(data[i].tag, DTD_recovery_string)
	    && GetOptValues(DTD_type_values, data[i].value, &code)) {
	    if (Old_DTD != code) {
		Old_DTD = code;
		HTSwitchDTD(!Old_DTD);
		need_reload = TRUE;
	    }
	}

	/* Select Popups: ON/OFF */
	if (!strcmp(data[i].tag, select_popups_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYSelectPopups = (BOOL) code;
	}
#if defined(USE_SLANG) || defined(COLOR_CURSES)
	/* Show Color: SELECT */
	if (!strcmp(data[i].tag, show_color_string)
	    && GetOptValues(show_color_values, data[i].value,
			    &LYChosenShowColor)) {
	    if (can_do_colors)
		LYShowColor = LYChosenShowColor;
	    if (CurrentShowColor != LYShowColor) {
		lynx_force_repaint();
	    }
	    CurrentShowColor = LYShowColor;
#ifdef USE_SLANG
	    SLtt_Use_Ansi_Colors = (LYShowColor > SHOW_COLOR_OFF ? TRUE : FALSE);
#endif
	}
#endif /* USE_SLANG || COLOR_CURSES */

	/* Show Cursor: ON/OFF */
	if (!strcmp(data[i].tag, show_cursor_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYShowCursor = (BOOL) code;
	}

	/* Underline links: ON/OFF */
	if (!strcmp(data[i].tag, underline_links_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYUnderlineLinks = (BOOL) code;
	}
#ifdef USE_SCROLLBAR
	/* Show Scrollbar: ON/OFF */
	if (!strcmp(data[i].tag, show_scrollbar_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYShowScrollbar = (BOOL) code;
	    need_reload = TRUE;
	}
#endif

	/* Cookie Prompting: SELECT */
	if (!strcmp(data[i].tag, cookie_prompt_string))
	    GetOptValues(prompt_values, data[i].value, &cookie_noprompt);

#ifdef USE_SSL
	/* SSL Prompting: SELECT */
	if (!strcmp(data[i].tag, ssl_prompt_string))
	    GetOptValues(prompt_values, data[i].value, &ssl_noprompt);
#endif

	/* User Mode: SELECT */
	if (!strcmp(data[i].tag, user_mode_string)
	    && GetOptValues(user_mode_values, data[i].value, &user_mode)) {
	    if (user_mode == NOVICE_MODE) {
		display_lines = (LYlines - 4);
	    } else {
		display_lines = LYlines - 2;
	    }
	}

	/* Type of visited pages page: SELECT */
	if (!strcmp(data[i].tag, visited_links_string))
	    GetOptValues(visited_links_values, data[i].value, &Visited_Links_As);

	/* Show Images: SELECT */
	if (!strcmp(data[i].tag, images_string)) {
	    if (!strcmp(data[i].value, images_ignore_all_string)
		&& !(pseudo_inline_alts == FALSE && clickable_images == FALSE)) {
		pseudo_inline_alts = FALSE;
		clickable_images = FALSE;
		need_reload = TRUE;
	    } else if (!strcmp(data[i].value, images_use_label_string)
		       && !(pseudo_inline_alts == TRUE && clickable_images == FALSE)) {
		pseudo_inline_alts = TRUE;
		clickable_images = FALSE;
		need_reload = TRUE;
	    } else if (!strcmp(data[i].value, images_use_links_string)
		       && !(clickable_images == TRUE)) {
		clickable_images = TRUE;
		need_reload = TRUE;
	    }
	}

	/* Verbose Images: ON/OFF */
	if (!strcmp(data[i].tag, verbose_images_string)
	    && GetOptValues(verbose_images_type_values, data[i].value, &code)) {
	    if (verbose_img != code) {
		verbose_img = (BOOL) code;
		need_reload = TRUE;
	    }
	}

	/* VI Keys: ON/OFF */
	if (!strcmp(data[i].tag, vi_keys_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    if ((vi_keys = (BOOL) code) != FALSE) {
		set_vi_keys();
	    } else {
		reset_vi_keys();
	    }
	}

	/* Bookmarks File Menu: SELECT */
	if (!strcmp(data[i].tag, mbm_string) && (!LYMBMBlocked)) {
	    GetOptValues(mbm_values, data[i].value, &LYMultiBookmarks);
	}

	/* Default Bookmarks filename: INPUT */
	if (!strcmp(data[i].tag, single_bookmark_string) && (!no_bookmark)) {
	    if (strcmp(data[i].value, "")) {
		FREE(bookmark_page);
		StrAllocCopy(bookmark_page, data[i].value);
	    }
	}

	/* Assume Character Set: SELECT */
	if (!strcmp(data[i].tag, assume_char_set_string)) {
	    int newval = UCGetLYhndl_byMIME(data[i].value);

	    if (newval >= 0
		&& ((raw_mode_old &&
		     newval != safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset))
		    || (!raw_mode_old &&
			newval != UCLYhndl_for_unspec)
		)) {

		UCLYhndl_for_unspec = newval;
		StrAllocCopy(UCAssume_MIMEcharset, data[i].value);
		assume_char_set_changed = TRUE;
	    }
	}
#ifdef EXP_LOCALE_CHARSET
	/* Use locale-based character set: ON/OFF */
	if (!strcmp(data[i].tag, locale_charset_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYLocaleCharset = (BOOL) code;
	}
#endif

	/* Display Character Set: SELECT */
	if (!strcmp(data[i].tag, display_char_set_string)) {
	    int newval = atoi(data[i].value);
	    int j;

	    /* prevent spoofing attempt */
	    for (j = 0; LYchar_set_names[j]; j++) {
		if (j == newval)
		    current_char_set = newval;
	    }
	}

	/* Raw Mode: ON/OFF */
	if (!strcmp(data[i].tag, raw_mode_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYRawMode = (BOOL) code;
	}

	/*
	 * ftp sort: SELECT
	 */
	if (!strcmp(data[i].tag, ftp_sort_string)) {
	    GetOptValues(ftp_sort_values, data[i].value, &HTfileSortMethod);
	}
#ifdef DIRED_SUPPORT
	/* Local Directory Style: SELECT */
	if (!strcmp(data[i].tag, dired_list_string)) {
	    GetOptValues(dired_list_values, data[i].value, &dir_list_style);
	}
#ifdef LONG_LIST
	/* Local Directory Order: SELECT */
	if (!strcmp(data[i].tag, dired_sort_string)) {
	    GetOptValues(dired_sort_values, data[i].value, &dir_list_order);
	}
#endif /* LONG_LIST */
#endif /* DIRED_SUPPORT */

	/* Show dot files: ON/OFF */
	if (!strcmp(data[i].tag, show_dotfiles_string) && (!no_dotfiles)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    show_dotfiles = (BOOL) code;
	}
#ifdef USE_READPROGRESS
	/* Show Transfer Rate: enumerated value */
	if (!strcmp(data[i].tag, show_rate_string)
	    && GetOptValues(rate_values, data[i].value, &code)) {
	    LYTransferRate = code;
	}
#endif /* USE_READPROGRESS */

	/* Preferred Media Type: SELECT */
	if (!strcmp(data[i].tag, preferred_media_string)) {
	    GetOptValues(media_values, data[i].value, &LYAcceptMedia);
	}

	/* Preferred Encoding: SELECT */
	if (!strcmp(data[i].tag, preferred_encoding_string)) {
	    GetOptValues(encoding_values, data[i].value, &LYAcceptEncoding);
	}

	/* Preferred Document Character Set: INPUT */
	if (!strcmp(data[i].tag, preferred_doc_char_string)) {
	    if (strcmp(pref_charset, data[i].value)) {
		FREE(pref_charset);
		StrAllocCopy(pref_charset, data[i].value);
		need_end_reload = TRUE;
	    }
	}

	/* Preferred Document Language: INPUT */
	if (!strcmp(data[i].tag, preferred_doc_lang_string)) {
	    if (strcmp(language, data[i].value)) {
		FREE(language);
		StrAllocCopy(language, data[i].value);
		need_end_reload = TRUE;
	    }
	}

	/* User Agent: INPUT */
	if (!strcmp(data[i].tag, user_agent_string) && (!no_useragent)) {
	    if (strcmp(LYUserAgent, data[i].value)) {
		need_end_reload = TRUE;
		FREE(LYUserAgent);
		/* ignore Copyright warning ? */
		StrAllocCopy(LYUserAgent,
			     *(data[i].value)
			     ? data[i].value
			     : LYUserAgentDefault);
		if (!LYCheckUserAgent()) {
		    HTAlert(UA_PLEASE_USE_LYNX);
		}
	    }
	}
    }				/* end of loop */

    /*
     * Process the flags:
     */
#ifdef EXP_LOCALE_CHARSET
    LYFindLocaleCharset();
#endif

    if (old_media_value != LYAcceptMedia)
	HTFilterPresentations();

    if (display_char_set_old != current_char_set ||
	raw_mode_old != LYRawMode ||
	assume_char_set_changed) {
	/*
	 * charset settings: the order is essential here.
	 */
	if (display_char_set_old != current_char_set) {
	    /*
	     * Set the LYUseDefaultRawMode value and character handling if
	     * LYRawMode was changed.  - FM
	     */
	    LYUseDefaultRawMode = TRUE;
	    HTMLUseCharacterSet(current_char_set);
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Deduce whether the user wants autoswitch: */
	    switch_display_charsets =
		(current_char_set == auto_display_charset
		 || current_char_set == auto_other_display_charset);
#endif
	}
	if (assume_char_set_changed && HTCJK != JAPANESE) {
	    LYRawMode = (BOOL) (UCLYhndl_for_unspec == current_char_set);
	}
	if (raw_mode_old != LYRawMode || assume_char_set_changed) {
	    /*
	     * Set the raw 8-bit or CJK mode defaults and character set if
	     * changed.  - FM
	     */
	    HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
	    HTMLSetCharacterHandling(current_char_set);
	}
	need_reload = TRUE;
    }
    /* end of charset settings */
    /*
     * FIXME: Golly gee, we need to write all of this out now, don't we?
     */
    BStrFree(newdoc->post_data);
    FREE(data);
    if (save_all) {
	HTInfoMsg(SAVING_OPTIONS);
	LYrcShowColor = LYChosenShowColor;
	if (save_rc(NULL)) {
	    HTInfoMsg(OPTIONS_SAVED);
	} else {
	    HTAlert(OPTIONS_NOT_SAVED);
	}
    }

    /*
     * Exit:  working around the previous document.  Being out of
     * mainloop()/getfile() cycle, do things manually.
     */
    CTRACE((tfp, "\nLYOptions.c/postoptions(): exiting...\n"));
    CTRACE((tfp, "                            need_reload = %s\n",
	    need_reload ? "TRUE" : "FALSE"));
    CTRACE((tfp, "                            need_end_reload = %s\n",
	    need_end_reload ? "TRUE" : "FALSE"));

    /*  Options menu was pushed before postoptions(), so pop-up. */
    LYpop(newdoc);
    WWWDoc.address = newdoc->address;
    WWWDoc.post_data = newdoc->post_data;
    WWWDoc.post_content_type = newdoc->post_content_type;
    WWWDoc.bookmark = newdoc->bookmark;
    WWWDoc.isHEAD = newdoc->isHEAD;
    WWWDoc.safe = newdoc->safe;
    LYforce_no_cache = FALSE;	/* ! */
    LYoverride_no_cache = TRUE;	/* ! */
    /*
     * Working out of getfile() cycle we reset *no_cache manually here so
     * HTLoadAbsolute() will return "Document already in memory":  it was
     * forced reloading Options Menu again without this (overhead).
     *
     * Probably *no_cache was set in a wrong position because of
     * the internal page...
     */
    if (!HTLoadAbsolute(&WWWDoc))
	return (NOT_FOUND);

    HTuncache_current_document();	/* will never use again */

    /*
     * Return to previous doc, not to options menu!  Reload the document we had
     * before the options menu but uncache only when necessary (Hurrah, user!):
     */
    LYpop(newdoc);
    WWWDoc.address = newdoc->address;
    WWWDoc.post_data = newdoc->post_data;
    WWWDoc.post_content_type = newdoc->post_content_type;
    WWWDoc.bookmark = newdoc->bookmark;
    WWWDoc.isHEAD = newdoc->isHEAD;
    WWWDoc.safe = newdoc->safe;
    LYforce_no_cache = FALSE;	/* see below */
    LYoverride_no_cache = TRUE;	/* see below */
    /*
     * Re-setting of *no_cache is probably not required here but this is a
     * guarantee against _double_ reloading over the net in case prev document
     * has its own "no cache" attribute and options menu set "need_reload"
     * also.  Force this HTLoadAbsolute() to return "Document already in
     * memory".
     */
    if (!HTLoadAbsolute(&WWWDoc))
	return (NOT_FOUND);

    /*
     * Now most interesting part: reload document when necessary.
     * **********************************************************
     */

    reloading = FALSE;		/* set manually */
    /* force end-to-end reload from remote server if change LYUserAgent or
     * language or pref_charset (marked by need_end_reload flag above), from
     * old-style LYK_OPTIONS (mainloop):
     */
    if ((need_end_reload == TRUE &&
	 (strncmp(newdoc->address, "http", 4) == 0 ||
	  isLYNXCGI(newdoc->address) == 0))) {
	/*
	 * An option has changed which may influence content negotiation, and
	 * the resource is from a http or https or lynxcgi URL (the only
	 * protocols which currently do anything with this information).  Set
	 * reloading = TRUE so that proxy caches will be flushed, which is
	 * necessary until the time when all proxies understand HTTP 1.1 Vary: 
	 * and all Servers properly use it...  Treat like case LYK_RELOAD (see
	 * comments there).  - KW
	 */
	reloading = TRUE;	/* global flag */
	need_reload = TRUE;	/* this was probably already TRUE, don't worry */
    }

    if (need_reload == FALSE) {
	/*  no uncache, already loaded */
	CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
	return (NORMAL);
    } else {
	/*  update HText cache */

	/*
	 * see LYK_RELOAD & LYK_OPTIONS in mainloop for details...
	 */
	if (HTisDocumentSource()) {
	    srcmode_for_next_retrieval(1);
	}
#ifdef USE_SOURCE_CACHE
	if (reloading == FALSE) {
	    /* one more attempt to be smart enough: */
	    if (HTcan_reparse_document()) {
		if (!HTreparse_document())
		    srcmode_for_next_retrieval(0);
		CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
		return (NORMAL);
	    }
	}
#endif
	if (newdoc->post_data != NULL && !newdoc->safe &&
	    confirm_post_resub(newdoc->address, newdoc->title, 2, 1) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    if (HTisDocumentSource()) {
		srcmode_for_next_retrieval(0);
	    }
	    return (NORMAL);
	}

	HEAD_request = HTLoadedDocumentIsHEAD();
	/*  uncache and load again */
	HTuncache_current_document();
	LYpush(newdoc, FALSE);
	CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
	return (NULLFILE);
    }

    /******** Done! **************************************************/
}

static char *NewSecureValue(void)
{
    static char oops[] = "?";

    FREE(secure_value);
    if ((secure_value = typeMallocn(char, 80)) != 0) {
#if defined(RAND_MAX)
	long key = lynx_rand();

#else
	long key = (long) secure_value + (long) time(0);
#endif
	sprintf(secure_value, "%ld", key);
	return secure_value;
    }
    return oops;
}

#define LABEL_LEN 33

/*
 * Note: the 'value' we are passing here is a local copy of the "same" string
 * as is used in LYrcFile.c to index the savable options.
 */
static void PutLabel(FILE *fp, const char *name,
		     const char *value)
{
    int have = strlen(name);
    int want = LABEL_LEN;
    int need = LYstrExtent(name, have, want);

    fprintf(fp, "&nbsp;&nbsp;%s", name);
    if (will_save_rc(value) && !no_option_save) {
	while (need++ < want)
	    fprintf(fp, "&nbsp;");
    } else {
	want -= 3;
	if (need < want) {
	    fprintf(fp, "&nbsp;");
	    ++need;
	}
	fprintf(fp, "(!)");
	while (need++ < want) {
	    fprintf(fp, "&nbsp;");
	}
    }
    fprintf(fp, ": ");
}

/*
 * For given a list of the .lynxrc names for boolean flags that make up a
 * composite setting, check if any are not writable for the .lynxrc file.  If
 * so, return that name, so the subsequence will_save_rc() check in PutLabel()
 * will flag the composite as not-saved.
 */
static const char *check_if_write_lynxrc(const char **table)
{
    int n;
    const char *result = NULL;

    for (n = 0; table[n] != 0; ++n) {
	result = table[n];
	if (!will_save_rc(result))
	    break;
    }
    return result;
}

/*
 * The options menu treats "Cookies" as a single enumeration, but it is read
 * from lynx.cfg (and perhaps .lynxrc) as a set of booleans.  Check if any are
 * not writable to .lynxrc, so we can show the user. 
 */
static const char *will_save_cookies(void)
{
    static const char *table[] =
    {
	RC_SET_COOKIES,		/* LYSetCookies */
	RC_ACCEPT_ALL_COOKIES,	/* LYAcceptAllCookies */
	NULL
    };

    return check_if_write_lynxrc(table);
}

/*
 * The options menu treats "Show images" as a single enumeration, but it is
 * read from lynx.cfg (and perhaps .lynxrc) as a set of booleans.  Check if any
 * are not writable to .lynxrc, so we can show the user. 
 */
static const char *will_save_images(void)
{
    static const char *table[] =
    {
	RC_MAKE_PSEUDO_ALTS_FOR_INLINES,	/* pseudo_inline_alts */
	RC_MAKE_LINKS_FOR_ALL_IMAGES,	/* clickable_images */
	NULL
    };

    return check_if_write_lynxrc(table);
}

/*
 * The visited-links menu is used from the visited-links page as well as the
 * options page.
 */
void LYMenuVisitedLinks(FILE *fp0, int disable_all)
{
    BeginSelect(fp0, visited_links_string);
    PutOptValues(fp0, Visited_Links_As, visited_links_values);
    EndSelect(fp0);
}

/*
 * Okay, someone wants to change options.  So, let's gen up a form for them
 * and pass it around.  Gor, this is ugly.  Be a lot easier in Bourne with
 * "here" documents.  :->
 * Basic Strategy:  For each option, throw up the appropriate type of
 * control, giving defaults as appropriate.  If nothing else, we're
 * probably going to test every control there is.  MRC
 *
 * This function is synchronized with postoptions().  Read the comments in
 * postoptions() header if you change something in gen_options().
 */
static int gen_options(char **newfile)
{
    int i;
    static char tempfile[LY_MAXPATH] = "\0";
    BOOLEAN disable_all = FALSE;
    FILE *fp0;
    size_t cset_len = 0;
    size_t text_len = LYscreenWidth() > 45 ? LYscreenWidth() - 38 : 7;	/* cf: PutLabel */

    if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	return (NOT_FOUND);

    LYLocalFileToURL(newfile, tempfile);

    /* This should not be needed if we regenerate the temp file every time with
     * a new name, which just happened above in the case
     * LYReuseTempfiles==FALSE.  Even for LYReuseTempfiles=TRUE, code at the
     * end of postoptions() may remove an older cached version from memory if
     * that version of the page was left by submitting changes.  - kw
     * 1999-11-27
     * If access to the actual file via getfile() later fails (maybe because of
     * some restrictions), mainloop may leave this flag on after popping the
     * previous doc which is then unnecessarily reloaded.  But I changed
     * mainloop to reset the flag.  - kw 1999-05-24
     */
    LYforce_no_cache = TRUE;

    /*
     * Without LYUseFormsOptions set we should maybe not even get here.
     * However, it's possible we do; disable the form in that case. - kw
     */
#ifndef NO_OPTION_MENU
    if (!LYUseFormsOptions)
	disable_all = TRUE;
#endif

    BeginInternalPage(fp0, OPTIONS_TITLE, NULL);	/* help link below */

    /*
     * I do C, not HTML.  Feel free to pretty this up.
     */
    fprintf(fp0, "<form action=\"%s\" method=\"post\">\n", STR_LYNXOPTIONS);
    /*
     * use following with some sort of one shot secret key akin to NCSA
     * (or was it CUTE?) telnet one shot password to allow ftp to self.
     * to prevent spoofing.
     */
    fprintf(fp0, "<input name=\"%s\" type=\"hidden\" value=\"%s\">\n",
	    secure_string, NewSecureValue());

    /*
     * visible text begins here
     */

    /* Submit/Reset/Help */
    fprintf(fp0, "<p align=center>\n");
    if (!disable_all) {
	fprintf(fp0, "<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0, "<input type=\"reset\" value=\"%s\"> - \n", RESET_CHANGES);
	fprintf(fp0, "%s - \n", CANCEL_CHANGES);
    }
    fprintf(fp0, "<a href=\"%s%s\">%s</a>\n",
	    helpfilepath, OPTIONS_HELP, TO_HELP);

    /* Save options */
    if (!no_option_save) {
	if (!disable_all) {
	    fprintf(fp0, "<p align=center>%s: ", SAVE_OPTIONS);
	    fprintf(fp0, "<input type=\"checkbox\" name=\"%s\">\n",
		    save_options_string);
	}
	fprintf(fp0, "<br>%s\n",
		gettext("(options marked with (!) will not be saved)"));
    }

    /*
     * preformatted text follows
     */
    fprintf(fp0, "<pre>\n");

    fprintf(fp0, "\n  <em>%s</em>\n", gettext("General Preferences"));
    /*****************************************************************/

    /* User Mode: SELECT */
    PutLabel(fp0, gettext("User mode"), user_mode_string);
    BeginSelect(fp0, user_mode_string);
    PutOptValues(fp0, user_mode, user_mode_values);
    EndSelect(fp0);

    /* Editor: INPUT */
    PutLabel(fp0, gettext("Editor"), editor_string);
    PutTextInput(fp0, editor_string, NonNull(editor), text_len,
		 DISABLED(no_editor || system_editor));

    /* Search Type: SELECT */
    PutLabel(fp0, gettext("Type of Search"), search_type_string);
    BeginSelect(fp0, search_type_string);
    PutOptValues(fp0, case_sensitive, search_type_values);
    EndSelect(fp0);

    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Security and Privacy"));
    /*****************************************************************/

    /* Cookies: SELECT */
    PutLabel(fp0, gettext("Cookies"), will_save_cookies());
    BeginSelect(fp0, cookies_string);
    PutOption(fp0, !LYSetCookies,
	      cookies_ignore_all_string,
	      cookies_ignore_all_string);
    PutOption(fp0, LYSetCookies && !LYAcceptAllCookies,
	      cookies_up_to_user_string,
	      cookies_up_to_user_string);
    PutOption(fp0, LYSetCookies && LYAcceptAllCookies,
	      cookies_accept_all_string,
	      cookies_accept_all_string);
    EndSelect(fp0);

    /* Cookie Prompting: SELECT */
    PutLabel(fp0, gettext("Invalid-Cookie Prompting"), cookie_prompt_string);
    BeginSelect(fp0, cookie_prompt_string);
    PutOptValues(fp0, cookie_noprompt, prompt_values);
    EndSelect(fp0);

#ifdef USE_SSL
    /* SSL Prompting: SELECT */
    PutLabel(fp0, gettext("SSL Prompting"), ssl_prompt_string);
    BeginSelect(fp0, ssl_prompt_string);
    PutOptValues(fp0, ssl_noprompt, prompt_values);
    EndSelect(fp0);
#endif

    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Keyboard Input"));
    /*****************************************************************/

    /* Keypad Mode: SELECT */
    PutLabel(fp0, gettext("Keypad mode"), keypad_mode_string);
    BeginSelect(fp0, keypad_mode_string);
    PutOptValues(fp0, keypad_mode, keypad_mode_values);
    EndSelect(fp0);

    /* Emacs keys: ON/OFF */
    PutLabel(fp0, gettext("Emacs keys"), emacs_keys_string);
    BeginSelect(fp0, emacs_keys_string);
    PutOptValues(fp0, emacs_keys, bool_values);
    EndSelect(fp0);

    /* VI Keys: ON/OFF */
    PutLabel(fp0, gettext("VI keys"), vi_keys_string);
    BeginSelect(fp0, vi_keys_string);
    PutOptValues(fp0, vi_keys, bool_values);
    EndSelect(fp0);

    /* Line edit style: SELECT */
    if (LYLineeditNames[1]) {	/* well, at least 2 line edit styles available */
	PutLabel(fp0, gettext("Line edit style"), lineedit_mode_string);
	BeginSelect(fp0, lineedit_mode_string);
	for (i = 0; LYLineeditNames[i]; i++) {
	    char temp[16];

	    sprintf(temp, "%d", i);
	    PutOption(fp0, i == current_lineedit, temp, LYLineeditNames[i]);
	}
	EndSelect(fp0);
    }
#ifdef EXP_KEYBOARD_LAYOUT
    /* Keyboard layout: SELECT */
    PutLabel(fp0, gettext("Keyboard layout"), kblayout_string);
    BeginSelect(fp0, kblayout_string);
    for (i = 0; LYKbLayoutNames[i]; i++) {
	char temp[16];

	sprintf(temp, "%d", i);
	PutOption(fp0, i == current_layout, temp, LYKbLayoutNames[i]);
    }
    EndSelect(fp0);
#endif /* EXP_KEYBOARD_LAYOUT */

    /*
     * Display and Character Set
     */
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Display and Character Set"));
    /*****************************************************************/

#ifdef EXP_LOCALE_CHARSET
    /* Use locale-based character set: ON/OFF */
    PutLabel(fp0, gettext("Use locale-based character set"), locale_charset_string);
    BeginSelect(fp0, locale_charset_string);
    PutOptValues(fp0, LYLocaleCharset, bool_values);
    EndSelect(fp0);
#else
#define LYLocaleCharset FALSE
#endif

    /* Display Character Set: SELECT */
    PutLabel(fp0, gettext("Display character set"), display_char_set_string);
    MaybeSelect(fp0, LYLocaleCharset, display_char_set_string);
    for (i = 0; LYchar_set_names[i]; i++) {
	char temp[10];
	size_t len = strlen(LYchar_set_names[i]);

	if (len > cset_len)
	    cset_len = len;
	sprintf(temp, "%d", i);
#ifdef EXP_CHARSET_CHOICE
	if (!charset_subsets[i].hide_display)
#endif
	    PutOption(fp0, i == current_char_set, temp, LYchar_set_names[i]);
    }
    EndSelect(fp0);

    /* Assume Character Set: SELECT */
    {
	int curval;

	curval = UCLYhndl_for_unspec;

	/*
	 * FIXME: If bogus value in lynx.cfg, then in old way, that is the
	 * string that was displayed.  Now, user will never see that.  Good
	 * or bad?  I don't know.  MRC
	 */
	if (curval == current_char_set) {
	    /* ok, LYRawMode, so use UCAssume_MIMEcharset */
	    curval = safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset);
	}
	PutLabel(fp0, gettext("Assumed document character set"), assume_char_set_string);
	BeginSelect(fp0, assume_char_set_string);
	for (i = 0; i < LYNumCharsets; i++) {
#ifdef EXP_CHARSET_CHOICE
	    if (!charset_subsets[i].hide_assumed)
#endif
		PutOption(fp0, i == curval,
			  LYCharSet_UC[i].MIMEname,
			  LYCharSet_UC[i].MIMEname);
	}
	EndSelect(fp0);
    }

    /* Raw Mode: ON/OFF */
    if (LYHaveCJKCharacterSet) {
	/*
	 * Since CJK people hardly mixed with other world
	 * we split the header to make it more readable:
	 * "CJK mode" for CJK display charsets, and "Raw 8-bit" for others.
	 */
	PutLabel(fp0, gettext("CJK mode"), raw_mode_string);
    } else {
	PutLabel(fp0, gettext("Raw 8-bit"), raw_mode_string);
    }

    BeginSelect(fp0, raw_mode_string);
    PutOptValues(fp0, LYRawMode, bool_values);
    EndSelect(fp0);

    /* X Display: INPUT */
    PutLabel(fp0, gettext("X Display"), x_display_string);
    PutTextInput(fp0, x_display_string, NonNull(x_display), text_len, "");

    /*
     * Document Appearance
     */
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Document Appearance"));
    /*****************************************************************/

    /* Show Color: SELECT */
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    SetupChosenShowColor();
    PutLabel(fp0, gettext("Show color"), show_color_string);
    if (no_option_save) {
	MaybeSelect(fp0, !can_do_colors, show_color_string);
	if (LYShowColor == SHOW_COLOR_NEVER) {
	    LYShowColor = SHOW_COLOR_OFF;
	} else if (LYShowColor == SHOW_COLOR_ALWAYS) {
	    LYShowColor = SHOW_COLOR_ON;
	}
	PutOptValues(fp0, LYShowColor - SHOW_COLOR_OFF, bool_values);
    } else {
	BeginSelect(fp0, show_color_string);
	if (can_do_colors) {
	    show_color_values[2].HtmlName = on_string;
	    show_color_values[3].LongName = always_string;
	} else {
	    show_color_values[2].HtmlName = NULL;	/* suppress "ON" - kw */
	    show_color_values[3].LongName = "Always try";
	}
	PutOptValues(fp0, LYChosenShowColor, show_color_values);
    }
    EndSelect(fp0);
#endif /* USE_SLANG || COLOR_CURSES */

    /* Show cursor: ON/OFF */
    PutLabel(fp0, gettext("Show cursor"), show_cursor_string);
    BeginSelect(fp0, show_cursor_string);
    PutOptValues(fp0, LYShowCursor, bool_values);
    EndSelect(fp0);

    /* Underline links: ON/OFF */
    PutLabel(fp0, gettext("Underline links"), underline_links_string);
    BeginSelect(fp0, underline_links_string);
    PutOptValues(fp0, LYUnderlineLinks, bool_values);
    EndSelect(fp0);

#ifdef USE_SCROLLBAR
    /* Show scrollbar: ON/OFF */
    PutLabel(fp0, gettext("Show scrollbar"), show_scrollbar_string);
    BeginSelect(fp0, show_scrollbar_string);
    PutOptValues(fp0, LYShowScrollbar, bool_values);
    EndSelect(fp0);
#endif

    /* Select Popups: ON/OFF */
    PutLabel(fp0, gettext("Popups for select fields"), select_popups_string);
    BeginSelect(fp0, select_popups_string);
    PutOptValues(fp0, LYSelectPopups, bool_values);
    EndSelect(fp0);

    /* HTML error recovery: SELECT */
    PutLabel(fp0, gettext("HTML error recovery"), DTD_recovery_string);
    BeginSelect(fp0, DTD_recovery_string);
    PutOptValues(fp0, Old_DTD, DTD_type_values);
    EndSelect(fp0);

    /* Show Images: SELECT */
    PutLabel(fp0, gettext("Show images"), will_save_images());
    BeginSelect(fp0, images_string);
    PutOption(fp0, !pseudo_inline_alts && !clickable_images,
	      images_ignore_all_string,
	      images_ignore_all_string);
    PutOption(fp0, pseudo_inline_alts && !clickable_images,
	      images_use_label_string,
	      images_use_label_string);
    PutOption(fp0, clickable_images,
	      images_use_links_string,
	      images_use_links_string);
    EndSelect(fp0);

    /* Verbose Images: ON/OFF */
    PutLabel(fp0, gettext("Verbose images"), verbose_images_string);
    BeginSelect(fp0, verbose_images_string);
    PutOptValues(fp0, verbose_img, verbose_images_type_values);
    EndSelect(fp0);

    /*
     * Headers Transferred to Remote Servers
     */
    fprintf(fp0, "\n  <em>%s</em>\n",
	    gettext("Headers Transferred to Remote Servers"));
    /*****************************************************************/

    /* Mail Address: INPUT */
    PutLabel(fp0, gettext("Personal mail address"), mail_address_string);
    PutTextInput(fp0, mail_address_string,
		 NonNull(personal_mail_address), text_len, "");

    /* Mail Address: INPUT */
    PutLabel(fp0, gettext("Password for anonymous ftp"), mail_address_string);
    PutTextInput(fp0, anonftp_password_string,
		 NonNull(anonftp_password), text_len, "");

    /* Preferred media type: SELECT */
    PutLabel(fp0, gettext("Preferred media type"), preferred_media_string);
    BeginSelect(fp0, preferred_media_string);
    PutOptValues(fp0, LYAcceptMedia, media_values);
    EndSelect(fp0);

    /* Preferred encoding: SELECT */
    PutLabel(fp0, gettext("Preferred encoding"), preferred_encoding_string);
    BeginSelect(fp0, preferred_encoding_string);
    PutOptValues(fp0, LYAcceptEncoding, encoding_values);
    EndSelect(fp0);

    /* Preferred Document Character Set: INPUT */
    PutLabel(fp0, gettext("Preferred document character set"), preferred_doc_char_string);
    PutTextInput(fp0, preferred_doc_char_string,
		 NonNull(pref_charset), cset_len + 2, "");

    /* Preferred Document Language: INPUT */
    PutLabel(fp0, gettext("Preferred document language"), preferred_doc_lang_string);
    PutTextInput(fp0, preferred_doc_lang_string,
		 NonNull(language), cset_len + 2, "");

    /* User Agent: INPUT */
    if (!no_useragent) {
	PutLabel(fp0, gettext("User-Agent header"), user_agent_string);
	PutTextInput(fp0, user_agent_string,
		     NonNull(LYUserAgent), text_len, "");
    }

    /*
     * Listing and Accessing Files
     */
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Listing and Accessing Files"));
    /*****************************************************************/

    /* FTP sort: SELECT */
    PutLabel(fp0, gettext("FTP sort criteria"), ftp_sort_string);
    BeginSelect(fp0, ftp_sort_string);
    PutOptValues(fp0, HTfileSortMethod, ftp_sort_values);
    EndSelect(fp0);

#ifdef DIRED_SUPPORT
    /* Local Directory Sort: SELECT */
    PutLabel(fp0, gettext("Local directory sort criteria"), dired_list_string);
    BeginSelect(fp0, dired_list_string);
    PutOptValues(fp0, dir_list_style, dired_list_values);
    EndSelect(fp0);
#ifdef LONG_LIST
    /* Local Directory Order: SELECT */
    PutLabel(fp0, gettext("Local directory sort order"), dired_sort_string);
    BeginSelect(fp0, dired_sort_string);
    PutOptValues(fp0, dir_list_order, dired_sort_values);
    EndSelect(fp0);
#endif /* LONG_LIST */
#endif /* DIRED_SUPPORT */

    /* Show dot files: ON/OFF */
    if (!no_dotfiles) {
	PutLabel(fp0, gettext("Show dot files"), show_dotfiles_string);
	BeginSelect(fp0, show_dotfiles_string);
	PutOptValues(fp0, show_dotfiles, bool_values);
	EndSelect(fp0);
    }

    /* Execution links: SELECT */
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    PutLabel(fp0, gettext("Execution links"), exec_links_string);
    BeginSelect(fp0, exec_links_string);
#ifndef NEVER_ALLOW_REMOTE_EXEC
    PutOptValues(fp0, local_exec
		 ? EXEC_ALWAYS
		 : (local_exec_on_local_files
		    ? EXEC_LOCAL
		    : EXEC_NEVER),
		 exec_links_values);
#else
    PutOptValues(fp0, local_exec_on_local_files
		 ? EXEC_LOCAL
		 : EXEC_NEVER,
		 exec_links_values);
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
    EndSelect(fp0);
#endif /* ENABLE_OPTS_CHANGE_EXEC */

#ifdef USE_READPROGRESS
    /* Show transfer rate: SELECT */
    PutLabel(fp0, gettext("Show transfer rate"), show_rate_string);
    BeginSelect(fp0, show_rate_string);
    for (i = 0; rate_values[i].LongName != 0; ++i) {
	char *message = NULL;

	HTSprintf0(&message,
		   rate_values[i].LongName,
		   HTProgressUnits(rate_values[i].value));
	PutOption(fp0,
		  LYTransferRate == rate_values[i].value,
		  rate_values[i].HtmlName,
		  message);
	FREE(message);
    }
    EndSelect(fp0);
#endif /* USE_READPROGRESS */

    /*
     * Special Files and Screens
     */
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Special Files and Screens"));
    /*****************************************************************/

    /* Multi-Bookmark Mode: SELECT */
    if (!LYMBMBlocked) {
	PutLabel(fp0, gettext("Multi-bookmarks"), mbm_string);
	BeginSelect(fp0, mbm_string);
	PutOptValues(fp0, LYMultiBookmarks, mbm_values);
	EndSelect(fp0);
    }

    /* Bookmarks File Menu: LINK/INPUT */
    if (LYMultiBookmarks) {
	PutLabel(fp0, gettext("Review/edit Bookmarks files"), mbm_string);
	fprintf(fp0, "<a href=\"%s\">%s</a>\n",
		LYNXOPTIONS_PAGE(MBM_LINK), gettext("Goto multi-bookmark menu"));
    } else {
	PutLabel(fp0, gettext("Bookmarks file"), single_bookmark_string);
	PutTextInput(fp0, single_bookmark_string,
		     NonNull(bookmark_page), text_len, "");
    }

    /* Visited Pages: SELECT */
    PutLabel(fp0, gettext("Visited Pages"), visited_links_string);
    LYMenuVisitedLinks(fp0, disable_all);

    if (!no_lynxcfg_info) {
	fprintf(fp0, "\n  %s<a href=\"%s\">lynx.cfg</a>.\n",
		gettext("View the file "),
		STR_LYNXCFG);
    }

    fprintf(fp0, "\n</pre>\n");

    /* Submit/Reset */
    if (!disable_all) {
	fprintf(fp0, "<p align=center>\n");
	fprintf(fp0, "<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0, "<input type=\"reset\" value=\"%s\"> - \n", RESET_CHANGES);
	fprintf(fp0, "%s\n", CANCEL_CHANGES);
    }

    /*
     * close HTML
     */
    fprintf(fp0, "</form>\n");
    EndInternalPage(fp0);

    LYCloseTempFP(fp0);
    return (NORMAL);
}
#endif /* !NO_OPTION_FORMS */
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d3 1
a3 1
#include <HTTP.h>  /* 'reloading' flag */
d30 2
a31 1
PRIVATE int LYChosenShowColor = SHOW_COLOR_UNKNOWN; /* whether to show and save */
d33 3
a35 1
PRIVATE void terminate_options	PARAMS((int sig));
d38 1
a38 1
#define COL_OPTION_VALUES 36  /* display column where option values start */
d42 1
a42 1
PRIVATE BOOLEAN can_do_colors = FALSE;
d45 1
a45 1
PUBLIC BOOLEAN LYCheckUserAgent NOARGS
d47 1
a47 1
    if (LYUserAgent && *LYUserAgent) {
d49 3
a51 3
	 && strstr(LYUserAgent, "lynx") == 0
	 && strstr(LYUserAgent, "L_y_n_x") == 0
	 && strstr(LYUserAgent, "l_y_n_x") == 0) {
d58 1
a58 1
PRIVATE void SetupChosenShowColor NOARGS
d63 4
a66 2
    if (LYCursesON)	/* could crash if called before initialization */
	can_do_colors = (BOOL) has_colors();
d74 1
a74 1
			SHOW_COLOR_ON : SHOW_COLOR_NEVER;
d82 1
a82 1
				SHOW_COLOR_ALWAYS : SHOW_COLOR_OFF;
d87 1
a87 1
			SHOW_COLOR_ON : SHOW_COLOR_OFF;
d94 1
a94 1
PRIVATE void validate_x_display NOPARAMS
d97 1
d105 1
a105 2
PRIVATE void summarize_x_display ARGS1(
    char *,	display_option)
d125 5
a130 6
#ifndef NO_OPTION_MENU
PRIVATE int boolean_choice PARAMS((
	int		status,
	int		line,
	int		column,
	CONST char **	choices));
d132 1
a132 1
	boolean_choice(status, line, column, (CONST char **)choices)
d137 1
a137 1
 *  Values for the options menu. - FM
d139 3
a141 3
 *  L_foo values are the Y coordinates for the menu item.
 *  B_foo values are the X coordinates for the item's prompt string.
 *  C_foo values are the X coordinates for the item's value string.
d214 1
a214 1
PRIVATE int add_it ARGS2(char *, text, int, len)
d227 1
a227 1
PRIVATE void addlbl ARGS1(CONST char *, text)
d236 2
a237 2
	    d = add_it(actual, d-1);
	    start_bold();
d242 1
a242 1
	    stop_bold();
d248 1
a248 1
	stop_bold();
d266 1
a266 1
PUBLIC void LYoptions NOARGS
d269 2
a270 1
    static char *bool_choices[] = {
d275 2
a276 1
    static char *caseless_choices[] = {
d281 2
a282 1
    static char *dirList_choices[] = {
d288 1
d290 2
a291 1
    static char *exec_choices[] = {
d296 1
a296 1
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
d300 2
a301 1
    static char *fileSort_choices[] = {
d308 2
a309 1
    static char *keypad_choices[] = {
d315 2
a316 1
    static char *mbm_choices[] = {
d322 2
a323 1
    static char *userMode_choices[] = {
d329 1
d334 1
d336 1
a336 1
     *	If the user changes the display we need memory to put it in.
d392 1
a392 1
draw_options:
d396 2
a397 2
     *	NOTE that printw() should be avoided for strings that
     *	might have non-ASCII or multibyte/CJK characters. - FM
d410 1
a410 1
    lynx_start_h1_color ();
d416 1
a416 1
    lynx_stop_h1_color ();
d419 1
a419 1
    LYaddstr((editor && *editor) ? editor : "NONE");
d423 1
a423 1
    LYaddstr((x_display && *x_display) ? x_display : "NONE");
d433 1
a433 1
	LYaddstr((bookmark_page && *bookmark_page) ? bookmark_page : "NONE");
d439 3
a441 3
	   (HTfileSortMethod == FILE_BY_SIZE ? "By Size    " :
	   (HTfileSortMethod == FILE_BY_TYPE ? "By Type    " :
					       "By Date    "))));
d445 2
a446 2
    LYaddstr((personal_mail_address && *personal_mail_address) ?
				       personal_mail_address : "NONE");
d458 1
a458 1
    LYaddstr((language && *language) ? language : "NONE");
d462 1
a462 1
    LYaddstr((pref_charset && *pref_charset) ? pref_charset : "NONE");
d472 1
a472 1
					      : "NONE");
d487 2
a488 2
		LYaddstr("NEVER     ");
		break;
d490 2
a491 2
		LYaddstr("OFF");
		break;
d493 2
a494 2
		LYaddstr("ON ");
		break;
d497 3
a499 3
		if (!has_colors())
		    LYaddstr("Always try");
		else
d501 1
a501 1
		    LYaddstr("ALWAYS    ");
d529 6
a534 6
		? "Links and form fields are numbered"
		: links_are_numbered()
		? "Links are numbered                "
		: fields_are_numbered()
		? "Form fields are numbered          "
		: "Numbers act as arrows             ");
d550 2
a551 2
	  ((dir_list_style == MIXED_STYLE) ? "Mixed style      " :
					     "Directories first"));
d556 3
a558 3
    LYaddstr(  (user_mode == NOVICE_MODE) ? "Novice      " :
      ((user_mode == INTERMEDIATE_MODE) ? "Intermediate" :
					  "Advanced    "));
d561 1
a561 1
    ShowBool( verbose_img);
d565 1
a565 1
    LYaddstr((LYUserAgent && *LYUserAgent) ? LYUserAgent : "NONE");
d571 3
a573 3
    LYaddstr(               local_exec ? "ALWAYS ON           " :
	  (local_exec_on_local_files ? "FOR LOCAL FILES ONLY" :
				       "ALWAYS OFF          "));
d576 1
a576 1
				       "ALWAYS OFF          ");
d580 1
a580 1
    LYmove(LYlines-3, 2);
d582 1
a582 1
    start_bold();
d584 1
a584 1
    stop_bold();
d588 1
a588 1
	start_bold();
d590 1
a590 1
	stop_bold();
d596 1
a596 1
    start_bold();
d598 1
a598 1
    stop_bold();
d612 1
a612 1
	lynx_start_prompt_color ();
d614 1
a614 1
	lynx_stop_prompt_color ();
d625 9
a633 19
	    case 'E':	/* Change the editor. */
		if (no_editor) {
		    _statusline(EDIT_DISABLED);
		} else if (system_editor ) {
		    _statusline(EDITOR_LOCKED);
		} else {
		    if (editor && *editor)
			LYstrncpy(display_option, editor, sizeof(display_option) - 1);
		    else {  /* clear the NONE */
			LYmove(L_EDITOR, COL_OPTION_VALUES);
			LYaddstr("    ");
			*display_option = '\0';
		    }
		    _statusline(ACCEPT_DATA);
		    LYmove(L_EDITOR, COL_OPTION_VALUES);
		    start_bold();
		    ch = LYgetstr(display_option, VISIBLE,
				  sizeof(display_option), NORECALL);
		    stop_bold();
a634 26
		    if (term_options || ch == -1) {
			LYaddstr((editor && *editor) ?
					    editor : "NONE");
		    } else if (*display_option == '\0') {
			FREE(editor);
			LYaddstr("NONE");
		    } else {
			StrAllocCopy(editor, display_option);
			LYaddstr(display_option);
		    }
		    LYclrtoeol();
		    if (ch == -1) {
			HTInfoMsg(CANCELLED);
			HTInfoMsg("");
		    } else {
			_statusline(VALUE_ACCEPTED);
		    }
		}
		response = ' ';
		break;

	    case 'D':	/* Change the display. */
		if (x_display && *x_display) {
		    LYstrncpy(display_option, x_display, sizeof(display_option) - 1);
		} else {  /* clear the NONE */
		    LYmove(L_DISPLAY, COL_OPTION_VALUES);
d639 2
a640 2
		LYmove(L_DISPLAY, COL_OPTION_VALUES);
		start_bold();
d643 27
a669 1
		stop_bold();
d671 10
d688 20
a707 3
		if ((term_options || ch == -1) ||
		    (x_display != NULL &&
		     !CompareEnvVars(x_display, display_option))) {
d709 1
a709 2
		     *	Cancelled, or a non-NULL display string
		     *	wasn't changed. - FM
d711 1
a711 1
		    LYaddstr((x_display && *x_display) ? x_display : "NONE");
d713 1
a713 6
		    if (ch == -1) {
			HTInfoMsg(CANCELLED);
			HTInfoMsg("");
		    } else {
			_statusline(VALUE_ACCEPTED);
		    }
a715 13
		} else if (*display_option == '\0') {
		    if ((x_display == NULL) ||
			(x_display != NULL && *x_display == '\0')) {
			/*
			 *  NULL or zero-length display string
			 *  wasn't changed. - FM
			 */
			LYaddstr("NONE");
			LYclrtoeol();
			_statusline(VALUE_ACCEPTED);
			response = ' ';
			break;
		    }
d717 16
a732 9
		/*
		 *  Set the new DISPLAY variable. - FM
		 */
		LYsetXDisplay(display_option);
		validate_x_display();
		cp = NULL;
		LYaddstr(x_display ? x_display : "NONE");
		LYclrtoeol();
		summarize_x_display(display_option);
d735 11
a745 17

	    case 'L':	/* Change multibookmarks option. */
		if (LYMBMBlocked) {
		    _statusline(MULTIBOOKMARKS_DISALLOWED);
		    response = ' ';
		    break;
		}
		if (!LYSelectPopups) {
		    LYMultiBookmarks = LYChooseBoolean(LYMultiBookmarks,
						      L_HOME, C_MULTI,
						      mbm_choices);
		} else {
		    LYMultiBookmarks = LYChoosePopup(LYMultiBookmarks,
						    L_HOME, (C_MULTI - 1),
						    mbm_choices,
						    3, FALSE, FALSE);
		}
d747 5
a751 5
		if (LYSelectPopups) {
		    LYmove(L_HOME, C_MULTI);
		    LYclrtoeol();
		    LYaddstr(mbm_choices[LYMultiBookmarks]);
		}
d754 1
a754 1
		if (!LYSelectPopups)
d756 9
a764 10
		{
		    LYmove(L_HOME, B_BOOK);
		    LYclrtoeol();
		    if (LYMultiBookmarks != MBM_OFF) {
			LYaddstr(gettext("review/edit B)ookmarks files"));
		    } else {
			LYaddstr(gettext("B)ookmark file: "));
			LYaddstr((bookmark_page && *bookmark_page) ?
						   bookmark_page : "NONE");
		    }
d766 6
a771 5
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;
d773 16
a788 19
	    case 'B':	/* Change the bookmark page location. */
		/*
		 *  Anonymous users should not be allowed to
		 *  change the bookmark page.
		 */
		if (!no_bookmark) {
		    if (LYMultiBookmarks != MBM_OFF) {
			edit_bookmarks();
			signal(SIGINT, terminate_options);
			goto draw_options;
		    }
		    if (bookmark_page && *bookmark_page) {
			LYstrncpy(display_option, bookmark_page, sizeof(display_option) - 1);
		    } else {  /* clear the NONE */
			LYmove(L_HOME, C_DEFAULT);
			LYclrtoeol();
			*display_option = '\0';
		    }
		    _statusline(ACCEPT_DATA);
a789 47
		    start_bold();
		    ch = LYgetstr(display_option, VISIBLE,
				  sizeof(display_option), NORECALL);
		    stop_bold();
		    LYmove(L_HOME, C_DEFAULT);
		    if (term_options ||
			ch == -1 || *display_option == '\0') {
			LYaddstr((bookmark_page && *bookmark_page) ?
						   bookmark_page : "NONE");
		    } else if (!LYPathOffHomeOK(display_option,
						sizeof(display_option))) {
			LYaddstr((bookmark_page && *bookmark_page) ?
						   bookmark_page : "NONE");
			LYclrtoeol();
			_statusline(USE_PATH_OFF_HOME);
			response = ' ';
			break;
		    } else {
			StrAllocCopy(bookmark_page, display_option);
			StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
			LYaddstr(bookmark_page);
		    }
		    LYclrtoeol();
		    if (ch == -1) {
			HTInfoMsg(CANCELLED);
			HTInfoMsg("");
		    } else {
			_statusline(VALUE_ACCEPTED);
		    }
		} else { /* anonymous */
		    _statusline(BOOKMARK_CHANGE_DISALLOWED);
		}
		response = ' ';
		break;

	    case 'F':	/* Change ftp directory sorting. */
		if (!LYSelectPopups) {
		    HTfileSortMethod = LYChooseBoolean(HTfileSortMethod,
						      L_FTPSTYPE, -1,
						      fileSort_choices);
		} else {
		    HTfileSortMethod = LYChoosePopup(HTfileSortMethod,
						    L_FTPSTYPE, -1,
						    fileSort_choices,
						    4, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		    LYmove(L_FTPSTYPE, COL_OPTION_VALUES);
a790 15
		    LYaddstr(fileSort_choices[HTfileSortMethod]);
#endif /* VMS || USE_SLANG */
		}
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;

	    case 'P': /* Change personal mail address for From headers. */
		if (personal_mail_address && *personal_mail_address) {
		    LYstrncpy(display_option, personal_mail_address, sizeof(display_option) - 1);
		} else {  /* clear the NONE */
		    LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
		    LYaddstr("    ");
d794 2
a795 2
		LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
		start_bold();
d798 14
a811 9
		stop_bold();
		LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
		if (term_options || ch == -1) {
		    LYaddstr((personal_mail_address &&
			    *personal_mail_address) ?
			      personal_mail_address : "NONE");
		} else if (*display_option == '\0') {
		    FREE(personal_mail_address);
		    LYaddstr("NONE");
d813 3
a815 2
		    StrAllocCopy(personal_mail_address, display_option);
		    LYaddstr(display_option);
d824 5
a828 2
		response = ' ';
		break;
d830 10
a839 52
	    case 'S':	/* Change case sensitivity for searches. */
		case_sensitive = LYChooseBoolean(case_sensitive,
						 L_SSEARCH, -1,
						 caseless_choices);
		response = ' ';
		break;

	    case '\001':	/* Change assume_charset setting. */
		if (use_assume_charset) {
		    int i, curval;
		    CONST char ** assume_list;
		    assume_list = typecallocn(CONST char *,(LYNumCharsets + 1));
		    if (!assume_list) {
			outofmem(__FILE__, "options");
		    }
		    for (i = 0; i < LYNumCharsets; i++) {
			assume_list[i] = LYCharSet_UC[i].MIMEname;
		    }
		    curval = UCLYhndl_for_unspec;
		    if (curval == current_char_set && UCAssume_MIMEcharset) {
			curval = UCGetLYhndl_byMIME(UCAssume_MIMEcharset);
		    }
		    if (curval < 0)
			curval = LYRawMode ? current_char_set : 0;
		    if (!LYSelectPopups) {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
			UCLYhndl_for_unspec = assumed_doc_charset_map[
			    LYChooseBoolean(charset_subsets[curval].assumed_idx,
					    L_ASSUME_CHARSET, -1,
					    assumed_charset_choices)
					    ? 1
					    : 0];
#else
			UCLYhndl_for_unspec = LYChooseBoolean(curval,
							     L_ASSUME_CHARSET, -1,
							     assume_list);
#endif
		    } else {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
			UCLYhndl_for_unspec = assumed_doc_charset_map[
			    LYChoosePopup(charset_subsets[curval].assumed_idx,
					  L_ASSUME_CHARSET, -1,
					  assumed_charset_choices,
					  0, FALSE, FALSE)
					  ? 1
					  : 0];
#else
			UCLYhndl_for_unspec = LYChoosePopup(curval,
							   L_ASSUME_CHARSET, -1,
							   assume_list,
							   0, FALSE, FALSE);
#endif
d841 3
a843 4
			LYmove(L_ASSUME_CHARSET, COL_OPTION_VALUES);
			LYclrtoeol();
			if (UCLYhndl_for_unspec >= 0)
			    LYaddstr(LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d845 51
a895 1
		    }
d897 15
a911 33
		    /*
		     *	Set the raw 8-bit or CJK mode defaults and
		     *	character set if changed. - FM
		     */
		    if (CurrentAssumeCharSet != UCLYhndl_for_unspec ||
			UCLYhndl_for_unspec != curval) {
			if (UCLYhndl_for_unspec != CurrentAssumeCharSet) {
			    StrAllocCopy(UCAssume_MIMEcharset,
					 LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
			}
			if (HTCJK != JAPANESE)
			    LYRawMode = (BOOL) (UCLYhndl_for_unspec == current_char_set);
			HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
			HTMLSetCharacterHandling(current_char_set);
			CurrentAssumeCharSet = UCLYhndl_for_unspec;
			CurrentRawMode = LYRawMode;
#if !defined(VMS) && !defined(USE_SLANG)
			if (!LYSelectPopups)
#endif /* !VMS && !USE_SLANG */
			{
			    LYmove(L_Rawmode, COL_OPTION_VALUES);
			    LYclrtoeol();
			    ShowBool(LYRawMode);
			}
		    }
		    FREE(assume_list);
		    response = ' ';
		    if (LYSelectPopups) {
			HANDLE_LYOPTIONS;
		    }
		} else {
		    _statusline(NEED_ADVANCED_USER_MODE);
		    AddValueAccepted = FALSE;
d913 2
a914 3
		break;

	    case 'C':	/* Change display charset setting. */
d917 6
a922 4
		    displayed_display_charset_idx = LYChooseBoolean(displayed_display_charset_idx,
						      L_Charset, -1,
						      display_charset_choices);
		    current_char_set = display_charset_map[displayed_display_charset_idx];
d924 4
a927 3
		    current_char_set = LYChooseBoolean(current_char_set,
						      L_Charset, -1,
						      LYchar_set_names);
d931 9
a939 5
		    displayed_display_charset_idx = LYChoosePopup(displayed_display_charset_idx,
						    L_Charset, -1,
						    display_charset_choices,
						    0, FALSE, FALSE);
		    current_char_set = display_charset_map[displayed_display_charset_idx];
d941 5
a945 4
		    current_char_set = LYChoosePopup(current_char_set,
						    L_Charset, -1,
						    LYchar_set_names,
						    0, FALSE, FALSE);
a946 1

d948 1
a948 1
		    LYmove(L_Charset, COL_OPTION_VALUES);
d950 2
a951 1
		    LYaddstr(LYchar_set_names[current_char_set]);
d954 1
d956 2
a957 2
		 *  Set the raw 8-bit or CJK mode defaults and
		 *  character set if changed. - FM
d959 11
a969 4
		if (CurrentCharSet != current_char_set) {
		    LYUseDefaultRawMode = TRUE;
		    HTMLUseCharacterSet(current_char_set);
		    CurrentCharSet = current_char_set;
a978 6
#ifdef CAN_SWITCH_DISPLAY_CHARSET
		    /* Deduce whether the user wants autoswitch: */
		    switch_display_charsets =
			(current_char_set == auto_display_charset
			    || current_char_set == auto_other_display_charset);
#endif
d980 1
d985 31
a1015 1
		break;
d1017 22
a1038 10
	    case 'O':	/* Change raw mode setting. */
		LYRawMode = LYChooseBoolean(LYRawMode, L_Rawmode, -1, bool_choices);
		/*
		 *  Set the LYUseDefaultRawMode value and character
		 *  handling if LYRawMode was changed. - FM
		 */
		if (CurrentRawMode != LYRawMode) {
		    HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
		    HTMLSetCharacterHandling(current_char_set);
		    CurrentRawMode = LYRawMode;
d1040 26
a1065 2
		response = ' ';
		break;
d1067 4
a1070 9
	    case 'G':	/* Change language preference. */
		if (language && *language) {
		    LYstrncpy(display_option, language, sizeof(display_option) - 1);
		} else {  /* clear the NONE */
		    LYmove(L_LANGUAGE, COL_OPTION_VALUES);
		    LYaddstr("    ");
		    *display_option = '\0';
		}
		_statusline(ACCEPT_DATA);
d1072 29
a1100 24
		start_bold();
		ch = LYgetstr(display_option, VISIBLE,
			      sizeof(display_option), NORECALL);
		stop_bold();
		LYmove(L_LANGUAGE, COL_OPTION_VALUES);
		if (term_options || ch == -1) {
		    LYaddstr((language && *language) ?
					  language : "NONE");
		} else if (*display_option == '\0') {
		    FREE(language);
		    LYaddstr("NONE");
		} else {
		    StrAllocCopy(language, display_option);
		    LYaddstr(display_option);
		}
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
		response = ' ';
		break;
d1102 6
a1107 9
	    case 'H':	/* Change charset preference. */
		if (pref_charset && *pref_charset) {
		    LYstrncpy(display_option, pref_charset, sizeof(display_option) - 1);
		} else {  /* clear the NONE */
		    LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
		    LYaddstr("    ");
		    *display_option = '\0';
		}
		_statusline(ACCEPT_DATA);
d1109 41
a1149 24
		start_bold();
		ch = LYgetstr(display_option, VISIBLE,
			      sizeof(display_option), NORECALL);
		stop_bold();
		LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
		if (term_options || ch == -1) {
		    LYaddstr((pref_charset && *pref_charset) ?
			   pref_charset : "NONE");
		} else if (*display_option == '\0') {
		    FREE(pref_charset);
		    LYaddstr("NONE");
		} else {
		    StrAllocCopy(pref_charset, display_option);
		    LYaddstr(display_option);
		}
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
		response = ' ';
		break;
d1151 3
a1153 3
	    case 'V':	/* Change VI keys setting. */
		vi_keys = LYChooseBoolean(vi_keys,
					 L_Bool_A, C_VIKEYS,
d1155 34
a1188 7
		if (vi_keys) {
		    set_vi_keys();
		} else {
		    reset_vi_keys();
		}
		response = ' ';
		break;
d1190 6
a1195 8
	    case 'M':	/* Change emacs keys setting. */
		emacs_keys = LYChooseBoolean(emacs_keys,
					    L_Bool_A, C_EMACSKEYS,
					    bool_choices);
		if (emacs_keys) {
		    set_emacs_keys();
		} else {
		    reset_emacs_keys();
d1197 7
a1203 6
		response = ' ';
		break;

	    case 'W':	/* Change show dotfiles setting. */
		if (no_dotfiles) {
		    _statusline(DOTFILE_ACCESS_DISABLED);
d1205 1
a1205 4
		    show_dotfiles = LYChooseBoolean(show_dotfiles,
						   L_Bool_A,
						   C_SHOW_DOTFILES,
						   bool_choices);
d1207 3
a1209 2
		response = ' ';
		break;
d1211 10
a1220 11
	    case 'T':	/* Change select popups setting. */
		LYSelectPopups = LYChooseBoolean(LYSelectPopups,
						L_Bool_B,
						C_SELECT_POPUPS,
						bool_choices);
		response = ' ';
		break;

#if defined(USE_SLANG) || defined(COLOR_CURSES)
	    case '&':	/* Change show color setting. */
		if (no_option_save) {
d1222 3
a1224 10
		    if (!has_colors()) {
			char * terminal = LYGetEnv("TERM");
			if (terminal)
			    HTUserMsg2(
				COLOR_TOGGLE_DISABLED_FOR_TERM,
				terminal);
			else
			    HTUserMsg(COLOR_TOGGLE_DISABLED);
			break;
		    }
d1226 5
a1230 1
		    LYShowColor = LYChooseBoolean((LYShowColor - 1),
d1233 1
a1233 3
						 bool_choices);
		    if (LYShowColor == 0) {
			LYShowColor = SHOW_COLOR_OFF;
d1235 4
a1238 1
			LYShowColor = SHOW_COLOR_ON;
a1239 13
		} else {		/* !no_option_save */
		    BOOLEAN again = FALSE;
		    int chosen;
		    /*
		     *  Copy strings into choice array.
		     */
		    choices[0] = NULL;
		    StrAllocCopy(choices[0], "NEVER     ");
		    choices[1] = NULL;
		    StrAllocCopy(choices[1], "OFF       ");
		    choices[2] = NULL;
		    StrAllocCopy(choices[2], "ON        ");
		    choices[3] = NULL;
d1241 10
a1250 3
		    if (!has_colors())
			StrAllocCopy(choices[3], "Always try");
		    else
d1252 2
a1253 28
			StrAllocCopy(choices[3], "ALWAYS    ");
		    choices[4] = NULL;
		    do {
			if (!LYSelectPopups) {
			    chosen = LYChooseBoolean(LYChosenShowColor,
						    L_Color,
						    C_COLOR,
						    choices);
			} else {
			    chosen = LYChoosePopup(LYChosenShowColor,
						  L_Color,
						  C_COLOR,
						  choices, 4, FALSE, FALSE);
			}
#if defined(COLOR_CURSES)
			again = (BOOL) (chosen == SHOW_COLOR_ON && !has_colors());
			if (again) {
			    char * terminal = LYGetEnv("TERM");
			    if (terminal)
				HTUserMsg2(
				    COLOR_TOGGLE_DISABLED_FOR_TERM,
				    terminal);
			    else
				HTUserMsg(COLOR_TOGGLE_DISABLED);
			}
#endif
		    } while (again);
		    LYChosenShowColor = chosen;
d1255 5
a1259 5
		    if (LYSelectPopups) {
			LYmove(L_Color, C_COLOR);
			LYclrtoeol();
			LYaddstr(choices[LYChosenShowColor]);
		    }
d1262 1
a1262 1
		    if (has_colors())
d1264 10
a1273 10
			LYShowColor = chosen;
		    FREE(choices[0]);
		    FREE(choices[1]);
		    FREE(choices[2]);
		    FREE(choices[3]);
		}
		if (CurrentShowColor != LYShowColor) {
		    lynx_force_repaint();
		}
		CurrentShowColor = LYShowColor;
d1275 1
a1275 1
		SLtt_Use_Ansi_Colors = (LYShowColor > SHOW_COLOR_OFF ? TRUE : FALSE);
d1277 5
a1281 5
		response = ' ';
		if (LYSelectPopups && !no_option_save) {
		    HANDLE_LYOPTIONS;
		}
		break;
d1284 7
a1290 7
	    case '@@':	/* Change show cursor setting. */
		LYShowCursor = LYChooseBoolean(LYShowCursor,
					      L_Bool_B,
					      C_SHOW_CURSOR,
					      bool_choices);
		response = ' ';
		break;
d1292 10
a1301 10
	    case 'K':	/* Change keypad mode. */
		if (!LYSelectPopups) {
		    keypad_mode = LYChooseBoolean(keypad_mode,
						 L_Keypad, -1,
						 keypad_choices);
		} else {
		    keypad_mode = LYChoosePopup(keypad_mode,
						L_Keypad, -1,
						keypad_choices,
						3, FALSE, FALSE);
d1303 3
a1305 3
		    LYmove(L_Keypad, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(keypad_choices[keypad_mode]);
d1307 11
a1317 11
		}
		if (keypad_mode == NUMBERS_AS_ARROWS) {
		    set_numbers_as_arrows();
		} else {
		    reset_numbers_as_arrows();
		}
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;
d1319 10
a1328 10
	    case 'N':	/* Change line editor key bindings. */
		if (!LYSelectPopups) {
		    current_lineedit = LYChooseBoolean(current_lineedit,
						      L_Lineed, -1,
						      LYLineeditNames);
		} else {
		    current_lineedit = LYChoosePopup(current_lineedit,
						    L_Lineed, -1,
						    LYLineeditNames,
						    0, FALSE, FALSE);
d1330 3
a1332 3
		    LYmove(L_Lineed, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(LYLineeditNames[current_lineedit]);
d1334 6
a1339 6
		}
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;
d1342 10
a1351 10
	    case 'Y':	/* Change keyboard layout */
		if (!LYSelectPopups) {
		    current_layout = LYChooseBoolean(current_layout,
						      L_Layout, -1,
						      LYKbLayoutNames);
		} else {
		    current_layout = LYChoosePopup(current_layout,
						    L_Layout, -1,
						    LYKbLayoutNames,
						    0, FALSE, FALSE);
d1353 3
a1355 3
		    LYmove(L_Layout, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(LYKbLayoutNames[current_layout]);
d1357 6
a1362 6
		}
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;
d1366 10
a1375 10
	    case 'I':	/* Change local directory sorting. */
		if (!LYSelectPopups) {
		    dir_list_style = LYChooseBoolean(dir_list_style,
						    L_Dired, -1,
						    dirList_choices);
		} else {
		    dir_list_style = LYChoosePopup(dir_list_style,
						  L_Dired, -1,
						  dirList_choices,
						  3, FALSE, FALSE);
d1377 3
a1379 3
		    LYmove(L_Dired, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(dirList_choices[dir_list_style]);
d1381 6
a1386 6
		}
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;
d1389 12
a1400 12
	    case 'U':	/* Change user mode. */
		if (!LYSelectPopups) {
		    user_mode = LYChooseBoolean(user_mode,
						L_User_Mode, -1,
						userMode_choices);
		    use_assume_charset = (BOOL) (user_mode >= 2);
		} else {
		    user_mode = LYChoosePopup(user_mode,
					      L_User_Mode, -1,
					      userMode_choices,
					      3, FALSE, FALSE);
		    use_assume_charset = (BOOL) (user_mode >= 2);
d1402 5
a1406 5
		    if (use_assume_charset == old_use_assume_charset) {
			LYmove(L_User_Mode, COL_OPTION_VALUES);
			LYclrtoeol();
			LYaddstr(userMode_choices[user_mode]);
		    }
d1408 41
d1450 16
a1465 2
		if (user_mode == NOVICE_MODE) {
		    display_lines = (LYlines - 4);
d1467 2
a1468 1
		    display_lines = LYlines-2;
d1470 6
a1475 12
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;

	    case '!':
		if (!LYSelectPopups) {
		    verbose_img = LYChooseBoolean(verbose_img,
						L_VERBOSE_IMAGES,
						C_VERBOSE_IMAGES,
						bool_choices);
d1477 1
a1477 5
		    verbose_img = LYChoosePopup(verbose_img,
					     L_VERBOSE_IMAGES,
					     C_VERBOSE_IMAGES,
					     bool_choices,
					     2, FALSE, FALSE);
d1479 5
a1483 5
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;
d1485 4
a1488 41
	    case 'A':	/* Change user agent string. */
		if (!no_useragent) {
		    if (LYUserAgent && *LYUserAgent) {
			LYstrncpy(display_option, LYUserAgent, sizeof(display_option) - 1);
		    } else {  /* clear the NONE */
			LYmove(L_HOME, COL_OPTION_VALUES);
			LYaddstr("    ");
			*display_option = '\0';
		    }
		    _statusline(ACCEPT_DATA_OR_DEFAULT);
		    LYmove(L_User_Agent, COL_OPTION_VALUES);
		    start_bold();
		    ch = LYgetstr(display_option, VISIBLE,
				  sizeof(display_option), NORECALL);
		    stop_bold();
		    LYmove(L_User_Agent, COL_OPTION_VALUES);
		    if (term_options || ch == -1) {
			LYaddstr((LYUserAgent &&
				*LYUserAgent) ?
				  LYUserAgent : "NONE");
		    } else if (*display_option == '\0') {
			StrAllocCopy(LYUserAgent, LYUserAgentDefault);
			LYaddstr((LYUserAgent &&
				*LYUserAgent) ?
				  LYUserAgent : "NONE");
		    } else {
			StrAllocCopy(LYUserAgent, display_option);
			LYaddstr(display_option);
		    }
		    LYclrtoeol();
		    if (ch == -1) {
			HTInfoMsg(CANCELLED);
			HTInfoMsg("");
		    } else if (!LYCheckUserAgent()) {
			_statusline(UA_PLEASE_USE_LYNX);
		    } else {
			_statusline(VALUE_ACCEPTED);
		    }
		} else { /* disallowed */
		    _statusline(UA_CHANGE_DISABLED);
		}
d1491 1
a1491 8

#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
	    case 'X':	/* Change local exec restriction. */
		if (exec_frozen && !LYSelectPopups) {
		    _statusline(CHANGE_OF_SETTING_DISALLOWED);
		    response = ' ';
		    break;
		}
d1493 3
a1495 3
		if (local_exec) {
		    itmp = 2;
		} else
d1497 5
a1501 6
		{
		    if (local_exec_on_local_files) {
			itmp= 1;
		    } else {
			itmp = 0;
		    }
d1503 11
a1513 10
		if (!LYSelectPopups) {
		    itmp = LYChooseBoolean(itmp,
					  L_Exec, -1,
					  exec_choices);
		} else {
		    itmp = LYChoosePopup(itmp,
					L_Exec, -1,
					exec_choices,
					0, (exec_frozen ? TRUE : FALSE),
					FALSE);
d1515 3
a1517 3
		    LYmove(L_Exec, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(exec_choices[itmp]);
d1519 11
a1529 11
		}
		if (!exec_frozen) {
		    switch (itmp) {
			case 0:
			    local_exec = FALSE;
			    local_exec_on_local_files = FALSE;
			    break;
			case 1:
			    local_exec = FALSE;
			    local_exec_on_local_files = TRUE;
			    break;
d1531 4
a1534 4
			case 2:
			    local_exec = TRUE;
			    local_exec_on_local_files = FALSE;
			    break;
d1536 7
a1542 7
		    } /* end switch */
		}
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;
d1545 6
a1550 9
	    case '>':	/* Save current options to RC file. */
		if (!no_option_save) {
		    HTInfoMsg(SAVING_OPTIONS);
		    LYrcShowColor = LYChosenShowColor;
		    if (save_rc(NULL)) {
			HTInfoMsg(OPTIONS_SAVED);
		    } else {
			HTAlert(OPTIONS_NOT_SAVED);
		    }
d1552 1
a1552 6
		    HTInfoMsg(R_TO_RETURN_TO_LYNX);
		    /*
		     *	Change response so that we don't exit
		     *	the options menu.
		     */
		    response = ' ';
d1554 8
a1561 1
		break;
d1563 2
a1564 2
	    case 'R':	/* Return to document (quit options menu). */
		break;
d1566 8
a1573 8
	    default:
		if (!no_option_save) {
		    HTInfoMsg(SAVE_OR_R_TO_RETURN_TO_LYNX);
		} else {
		    HTInfoMsg(R_TO_RETURN_TO_LYNX);
		}
	}  /* end switch */
    }  /* end while */
d1580 1
a1580 2
PRIVATE int widest_choice ARGS1(
	CONST char **,	choices)
d1583 1
d1586 1
d1593 2
a1594 3
PRIVATE void show_choice ARGS2(
	CONST char *,	choice,
	int,		width)
d1597 1
d1604 1
a1604 1
 *  Take a status code, prompt the user for a new status, and return it.
d1606 4
a1609 5
PRIVATE int boolean_choice ARGS4(
	int,		cur_choice,
	int,		line,
	int,		column,
	CONST char **,	choices)
d1619 1
a1619 2
     *	Get the number of choices and then make
     *	number zero-based.
d1621 1
a1621 2
    for (number = 0; choices[number] != NULL; number++)
	;  /* empty loop body */
d1625 1
a1625 1
     *	Update the statusline.
d1630 1
a1630 1
     *	Highlight the current choice.
d1633 1
a1633 1
    start_reverse();
d1640 2
a1641 4
     *	Get the keyboard entry, and leave the
     *	cursor at the choice, to indicate that
     *	it can be changed, until the user accepts
     *	the current choice.
d1650 3
a1652 3
	     /*
	      *  Control-C or Control-G.
	      */
d1666 1
a1666 1
	    (cmd = LKC_TO_LAC(keymap,response)) != LYK_ACTIVATE) {
d1668 3
a1670 3
		case LYK_HOME:
		    cur_choice = 0;
		    break;
d1672 3
a1674 3
		case LYK_END:
		    cur_choice = number;
		    break;
d1676 4
a1679 4
		case LYK_REFRESH:
		    lynx_force_repaint();
		    LYrefresh();
		    break;
d1681 20
a1700 6
		case LYK_QUIT:
		case LYK_ABORT:
		case LYK_PREV_DOC:
		    cur_choice = orig_choice;
		    term_options = TRUE;
		    break;
d1702 11
a1712 12
		case LYK_PREV_PAGE:
		case LYK_UP_HALF:
		case LYK_UP_TWO:
		case LYK_PREV_LINK:
		case LYK_LPOS_PREV_LINK:
		case LYK_FASTBACKW_LINK:
		case LYK_UP_LINK:
		case LYK_LEFT_LINK:
		    if (cur_choice == 0)
			cur_choice = number;  /* go back to end */
		    else
			cur_choice--;
d1714 7
a1720 20

		case LYK_1:
		case LYK_2:
		case LYK_3:
		case LYK_4:
		case LYK_5:
		case LYK_6:
		case LYK_7:
		case LYK_8:
		case LYK_9:
		    if((cmd - LYK_1 + 1) <= number) {
			cur_choice = cmd -LYK_1 + 1;
			break;
		    }  /* else fall through! */
		default:
		    if (cur_choice == number)
			cur_choice = 0;  /* go over the top and around */
		    else
			cur_choice++;
	    }  /* end of switch */
d1727 1
a1727 1
	     *	Unhighlight choice.
d1730 1
a1730 1
	    stop_reverse();
d1746 1
a1746 2
PRIVATE void terminate_options ARGS1(
	int,		sig GCC_UNUSED)
d1750 1
a1750 1
     *	Reassert the AST.
d1755 1
a1755 1
     *	Refresh the screen to get rid of the "interrupt" message.
d1765 1
a1765 1
 *  Multi-Bookmark On-Line editing support. - FMG & FM
d1767 1
a1767 1
PUBLIC void edit_bookmarks NOARGS
d1771 1
d1773 2
a1774 2
    int a; /* misc counter */
    char MBM_tmp_line[256]; /* buffer for LYgetstr */
d1778 3
a1780 4
     *	We need (MBM_V_MAXFILES + MULTI_OFFSET) lines to display
     *	the whole list at once.  Otherwise break it up into two
     *	segments.  We know it won't be less than that because
     *	'o'ptions needs 23-24 at LEAST.
d1785 1
a1785 1
draw_bookmark_list:
d1787 3
a1789 3
     *	Display menu of bookmarks.  NOTE that we avoid printw()'s
     *	to increase the chances that any non-ASCII or multibyte/CJK
     *	characters will be handled properly. - FM
d1801 1
a1801 1
    lynx_start_h1_color ();
d1808 1
a1808 1
    lynx_stop_h1_color ();
d1811 3
a1813 3
	for (a = ((MBM_V_MAXFILES/2 + 1) * (MBM_current - 1));
		      a <= (MBM_current * MBM_V_MAXFILES/2 ); a++) {
	    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)), 5);
d1818 1
a1818 1
	    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)), 35);
d1840 1
a1840 1
     *	Only needed when we have 2 screens.
d1845 1
a1845 1
	start_bold();
d1847 1
a1847 1
	stop_bold();
d1851 1
a1851 1
	start_bold();
d1853 1
a1853 1
	stop_bold();
d1861 1
a1861 1
	start_bold();
d1863 1
a1863 1
	stop_bold();
d1869 1
a1869 1
    start_bold();
d1871 1
a1871 1
    stop_bold();
d1880 1
a1880 1
	lynx_start_prompt_color ();
d1882 1
a1882 1
	lynx_stop_prompt_color ();
d1889 1
a1889 1
	 *  Check for a cancel.
d1896 1
a1896 1
	 *  Check for a save.
d1908 1
a1908 2
		 *  Change response so that we don't exit
		 *  the options menu.
d1916 1
a1916 1
	 *  Check for a refresh.
d1924 1
a1924 1
	 *  Move between the screens - if we can't show it all at once.
d1944 2
a1945 3
	 *  Instead of using 26 case statements, we set up
	 *  a scan through the letters and edit the lines
	 *  that way.
d1950 1
a1950 1
		    if (MBM_current == 1 && a > (MBM_V_MAXFILES/2)) {
d1955 1
a1955 1
		    if (MBM_current == 2 && a < (MBM_V_MAXFILES/2)) {
d1964 1
a1964 1
		    start_bold();
d1966 3
a1968 3
			LYmove(
			 (3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)),
			     9);
d1972 2
a1973 2
			   (!MBM_A_subdescript[a] ?
					       "" : MBM_A_subdescript[a]),
d1977 1
a1977 1
		    stop_bold();
d1985 4
a1988 3
			LYmove(
			 (3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)),
			     5);
d2000 4
a2003 2
		    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)),
			 35);
d2008 1
a2008 1
		start_bold();
d2014 1
a2014 1
		stop_bold();
d2023 2
a2024 2
			LYMBM_statusline(USE_PATH_OFF_HOME);
			LYSleepAlert();
d2032 4
a2035 2
		    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current-1)),
			 35);
d2042 1
a2042 1
		LYmove(LYlines-1, 0);
d2046 2
a2047 2
	}  /* end for */
    } /* end while */
d2056 2
a2057 3
 *  This function offers the choices for values of an
 *  option via a popup window which functions like
 *  that for selection of options in a form. - FM
d2059 1
a2059 2
 *  Also used for mouse popups with ncurses; this is indicated
 *  by for_mouse.
d2061 7
a2067 8
PUBLIC int popup_choice ARGS7(
	int,		cur_choice,
	int,		line,
	int,		column,
	CONST char **,	choices,
	int,		i_length,
	int,		disabled,
	BOOLEAN,	for_mouse)
d2076 1
a2076 1
				   (CONST char **)choices,
d2098 1
a2098 1
    return(cur_choice);
d2114 2
a2115 2
    CONST char *LongName;
    CONST char *HtmlName;
d2119 2
a2120 2
    char * tag;
    char * value;
d2123 16
a2138 14
static CONST char selected_string[] = "selected";
static CONST char disabled_string[] = "disabled";
static CONST char on_string[]	    = "ON";
static CONST char off_string[]	    = "OFF";
static CONST char never_string[]    = "NEVER";
static CONST char always_string[]   = "ALWAYS";
static OptValues bool_values[] = {
	{ FALSE,	     "OFF",		  "OFF"		},
	{ TRUE,		     "ON",		  "ON"		},
	{ 0, 0, 0 }};

static char * secure_string		= "secure";
static char * secure_value		= NULL;
static char * save_options_string	= "save_options";
d2143 7
a2149 7
static char * cookies_string		= RC_SET_COOKIES;
static char * cookies_ignore_all_string = "ignore";
static char * cookies_up_to_user_string = "ask user";
static char * cookies_accept_all_string = "accept all";
static char * x_display_string		= RC_DISPLAY;
static char * editor_string		= RC_FILE_EDITOR;
static char * emacs_keys_string		= RC_EMACS_KEYS;
d2155 5
a2159 4
static char * exec_links_string		= RC_RUN_ALL_EXECUTION_LINKS;
static OptValues exec_links_values[]	= {
	{ EXEC_NEVER,	"ALWAYS OFF",		"ALWAYS OFF" },
	{ EXEC_LOCAL,	"FOR LOCAL FILES ONLY",	"FOR LOCAL FILES ONLY" },
d2161 1
a2161 1
	{ EXEC_ALWAYS,	"ALWAYS ON",		"ALWAYS ON" },
d2163 2
a2164 1
	{ 0, 0, 0 }};
d2168 1
a2168 1
static char * kblayout_string		= RC_KBLAYOUT;
d2170 25
a2194 18
static char * keypad_mode_string	= RC_KEYPAD_MODE;
static OptValues keypad_mode_values[]	= {
	{ NUMBERS_AS_ARROWS,  "Numbers act as arrows", "number_arrows" },
	{ LINKS_ARE_NUMBERED, "Links are numbered",    "links_numbered" },
	{ LINKS_AND_FIELDS_ARE_NUMBERED,
			      "Links and form fields are numbered",
			      "links_and_forms" },
	{ FIELDS_ARE_NUMBERED,
			      "Form fields are numbered",
			      "forms_numbered" },
	{ 0, 0, 0 }};
static char * lineedit_mode_string	= RC_LINEEDIT_MODE;
static char * mail_address_string	= RC_PERSONAL_MAIL_ADDRESS;
static char * search_type_string	= RC_CASE_SENSITIVE_SEARCHING;
static OptValues search_type_values[] = {
	{ FALSE,	    "Case insensitive",  "case_insensitive" },
	{ TRUE,		    "Case sensitive",	 "case_sensitive" },
	{ 0, 0, 0 }};
d2197 9
a2205 7
static char * show_color_string		= RC_SHOW_COLOR;
static OptValues show_color_values[] = {
	{ SHOW_COLOR_NEVER,	never_string,	never_string },
	{ SHOW_COLOR_OFF,	off_string,	off_string },
	{ SHOW_COLOR_ON,	on_string,	on_string },
	{ SHOW_COLOR_ALWAYS,	always_string,	always_string },
	{ 0, 0, 0 }};
d2208 3
a2210 1
static char * show_cursor_string	= RC_SHOW_CURSOR;
d2213 1
a2213 1
static char * show_scrollbar_string	= RC_SCROLLBAR;
d2216 10
a2225 8
static CONST char prompt_dft_string[]	= "prompt normally";
static CONST char prompt_yes_string[]	= "force yes-response";
static CONST char prompt_no_string[]	= "force no-response";
static OptValues prompt_values[] = {
	{ FORCE_PROMPT_DFT,	prompt_dft_string, prompt_dft_string },
	{ FORCE_PROMPT_YES,	prompt_yes_string, prompt_yes_string },
	{ FORCE_PROMPT_NO,	prompt_no_string,  prompt_no_string },
	{ 0, 0, 0 }};
d2227 1
a2227 1
static char * cookie_prompt_string	= RC_FORCE_COOKIE_PROMPT;
d2230 1
a2230 1
static char * ssl_prompt_string		= RC_FORCE_SSL_PROMPT;
d2233 23
a2255 19
static char * user_mode_string		= RC_USER_MODE;
static OptValues user_mode_values[] = {
	{ NOVICE_MODE,		"Novice",	"Novice" },
	{ INTERMEDIATE_MODE,	"Intermediate", "Intermediate" },
	{ ADVANCED_MODE,	"Advanced",	"Advanced" },
	{ 0, 0, 0 }};

static char * vi_keys_string		= RC_VI_KEYS;

static char * visited_links_string	= RC_VISITED_LINKS;
static OptValues visited_links_values[] = {
	{ VISITED_LINKS_AS_FIRST_V, "By First Visit",	"first_visited" },
	{ VISITED_LINKS_AS_FIRST_V | VISITED_LINKS_REVERSE,
		    "By First Visit Reversed",	"first_visited_reversed" },
	{ VISITED_LINKS_AS_TREE,    "As Visit Tree",	"visit_tree" },
	{ VISITED_LINKS_AS_LATEST,  "By Last Visit",	"last_visited" },
	{ VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE,
		    "By Last Visit Reversed",	"last_visited_reversed" },
	{ 0, 0, 0 }};
d2260 3
a2262 2
static char * DTD_recovery_string      = RC_TAGSOUP;
static OptValues DTD_type_values[] = {
d2264 14
a2277 11
	{ TRUE,		    "relaxed (TagSoup mode)",	 "tagsoup" },
	{ FALSE,	    "strict (SortaSGML mode)",	 "sortasgml" },
	{ 0, 0, 0 }};

static char * select_popups_string     = RC_SELECT_POPUPS;
static char * images_string            = "images";
static char * images_ignore_all_string = "ignore";
static char * images_use_label_string  = "as labels";
static char * images_use_links_string  = "as links";
static char * verbose_images_string    = RC_VERBOSE_IMAGES;
static OptValues verbose_images_type_values[] = {
d2279 4
a2282 3
	{ FALSE,	    "OFF",		 "OFF" },
	{ TRUE,		    "show filename",	 "ON" },
	{ 0, 0, 0 }};
d2287 8
a2294 6
static char * mbm_string		= RC_MULTI_BOOKMARK;
static OptValues mbm_values[] = {
	{ MBM_OFF,		"OFF",			"OFF" },
	{ MBM_STANDARD,		"STANDARD",		"STANDARD" },
	{ MBM_ADVANCED,		"ADVANCED",		"ADVANCED" },
	{ 0, 0, 0 }};
d2296 1
a2296 1
static char * single_bookmark_string	= RC_BOOKMARK_FILE;
d2301 7
a2307 3
static char * assume_char_set_string	= RC_ASSUME_CHARSET;
static char * display_char_set_string	= RC_CHARACTER_SET;
static char * raw_mode_string		= RC_RAW_MODE;
d2312 1
a2312 1
static char * show_dotfiles_string	= RC_SHOW_DOTFILES;
d2315 9
a2323 6
static char * dired_list_string		= RC_DIR_LIST_STYLE;
static OptValues dired_list_values[] = {
	{ DIRS_FIRST,		"Directories first",	"dired_dir" },
	{ FILES_FIRST,		"Files first",		"dired_files" },
	{ MIXED_STYLE,		"Mixed style",		"dired_mixed" },
	{ 0, 0, 0 }};
d2325 8
a2332 7
static char * dired_sort_string		= RC_DIR_LIST_ORDER;
static OptValues dired_sort_values[] = {
	{ ORDER_BY_NAME,	"By name",		"dired_by_name" },
	{ ORDER_BY_TYPE,	"By type",		"dired_by_type" },
	{ ORDER_BY_SIZE,	"By size",		"dired_by_size" },
	{ ORDER_BY_DATE,	"By date",		"dired_by_date" },
	{ ORDER_BY_MODE,	"By mode",		"dired_by_mode" },
d2334 2
a2335 2
	{ ORDER_BY_USER,	"By user",		"dired_by_user" },
	{ ORDER_BY_GROUP,	"By group",		"dired_by_group" },
d2337 2
a2338 1
	{ 0, 0, 0 }};
d2342 10
a2351 13
static char * ftp_sort_string		= RC_FILE_SORTING_METHOD;
static OptValues ftp_sort_values[] = {
	{ FILE_BY_NAME,		"By Name",		"ftp_by_name" },
	{ FILE_BY_TYPE,		"By Type",		"ftp_by_type" },
	{ FILE_BY_SIZE,		"By Size",		"ftp_by_size" },
	{ FILE_BY_DATE,		"By Date",		"ftp_by_date" },
	{ 0, 0, 0 }};

static char * show_rate_string		= RC_SHOW_KB_RATE;
static OptValues rate_values[] = {
	{ rateOFF,		"Do not show rate",	"rate_off" },
	{ rateBYTES,		"Show Bytes/sec rate",	"rate_bytes" },
	{ rateKB,		"Show KB/sec rate",	"rate_kb" },
d2353 9
a2361 2
	{ rateEtaBYTES,		"Show Bytes/sec, ETA",	"rate_eta_bytes" },
	{ rateEtaKB,		"Show KB/sec, ETA",	"rate_eta_kb" },
d2363 35
a2397 1
	{ 0, 0, 0 }};
d2402 3
a2404 3
static char * preferred_doc_char_string = RC_PREFERRED_CHARSET;
static char * preferred_doc_lang_string = RC_PREFERRED_LANGUAGE;
static char * user_agent_string		= RC_USERAGENT;
d2412 1
a2412 1
	fprintf(fp,"<option value=\"%s\" %s>%s\n", html, SELECTED(flag), name)
d2423 2
a2424 4
PRIVATE void PutOptValues ARGS3(
	FILE *,		fp,
	int,		value,
	OptValues *,	table)
d2437 2
a2438 4
PRIVATE BOOLEAN GetOptValues ARGS3(
	OptValues *,	table,
	char *,		value,
	int *,		result)
d2459 1
a2459 3

PRIVATE PostPair * break_data ARGS1(
    bstring *,	data)
d2461 2
a2462 2
    char * p;
    PostPair * q = NULL;
d2494 4
a2497 3
	   size_t i, len;
	   len = strlen(q[count].value);
	   for (i = 0; i < len; i++) {
d2505 2
a2506 2
		    && q[count].value[i+1] == '+'
		    && isalnum(UCH(q[count].value[i+2]))) {
d2514 1
a2514 1
	   }
d2517 2
a2518 1
	CTRACE((tfp, "...item[%d] tag=%s, value=%s\n", count, q[count].tag, q[count].value));
d2525 1
a2525 1
	q = realloc(q, sizeof(PostPair)*(count+1));
d2533 17
a2549 1
PRIVATE int gen_options PARAMS((char **newfile));
d2583 1
a2583 2
PUBLIC int postoptions ARGS1(
    DocInfo *,		newdoc)
d2586 1
a2586 1
    DocAddress WWWDoc;  /* need on exit */
d2591 1
d2596 1
d2603 1
a2603 1
     * "<a href=\"LYNXOPTIONS://MBM_MENU\">Goto multi-bookmark menu</a>\n"
d2606 1
a2606 1
    if (strstr(newdoc->address, "LYNXOPTIONS://MBM_MENU")) {
d2609 2
a2610 2
	   HTAlert(BOOKMARK_CHANGE_DISALLOWED); /* anonymous */
	   return(NULLFILE);
d2612 1
a2612 1
	    return(NOT_FOUND);
d2614 2
a2615 2
	   edit_bookmarks();
	   return(NULLFILE);
d2617 3
d2634 1
a2634 1
	    return(status);
d2646 1
a2646 1
	    return(NOT_FOUND);
d2651 1
a2651 1
	return(NORMAL);
d2665 1
a2665 1
	return(NOT_FOUND);
d2670 4
a2673 4
	 *  This isn't really for security, but rather for avoiding that
	 *  the user may revisit an older instance from the history stack
	 *  and submit stuff which accidentally undoes changes that had
	 *  been done from a newer instance. - kw
d2688 1
a2688 1
		return(NULLFILE);
d2726 1
a2726 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
d2737 1
a2737 1
	 && GetOptValues(exec_links_values, data[i].value, &code)) {
d2748 1
d2750 1
a2750 1
		 && keypad_mode != newval) {
d2765 1
d2768 2
a2769 1
		if (j==newval)	current_lineedit = newval;
a2771 1

d2777 1
d2780 2
a2781 1
		if (j==newval)	current_layout = newval;
d2792 6
d2800 1
a2800 1
	 && GetOptValues(search_type_values, data[i].value, &code)) {
d2806 1
a2806 1
	 && GetOptValues(DTD_type_values, data[i].value, &code)) {
d2816 1
a2816 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
a2818 1

d2822 2
a2823 2
	 && GetOptValues(show_color_values, data[i].value,
			 &LYChosenShowColor)) {
d2838 1
a2838 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
d2842 5
d2850 1
a2850 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
d2852 1
d2868 1
a2868 1
	 && GetOptValues(user_mode_values, data[i].value, &user_mode)) {
d2872 1
a2872 1
		display_lines = LYlines-2;
d2878 1
a2878 1
	   GetOptValues(visited_links_values, data[i].value, &Visited_Links_As);
d2883 1
a2883 1
			&& !(pseudo_inline_alts == FALSE && clickable_images == FALSE)) {
d2888 1
a2888 1
			&& !(pseudo_inline_alts == TRUE && clickable_images == FALSE)) {
d2893 1
a2893 1
			&& !(clickable_images == TRUE)) {
d2901 1
a2901 1
	 && GetOptValues(verbose_images_type_values, data[i].value, &code)) {
d2910 1
a2910 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
d2936 1
a2936 1
	     && ((raw_mode_old &&
d2938 2
a2939 2
	      || (!raw_mode_old &&
		     newval != UCLYhndl_for_unspec)
d2947 7
d2959 1
d2962 2
a2963 1
		if (j==newval)	current_char_set = newval;
d2969 1
a2969 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
a2978 1

d2994 1
a2994 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
d2997 1
a2997 1

d3000 1
a3000 1
	 && GetOptValues(rate_values, data[i].value, &code)) {
d3003 11
d3021 1
a3021 1
	   }
d3040 3
a3042 3
		   *(data[i].value)
		   ? data[i].value
		   : LYUserAgentDefault);
d3048 1
a3048 1
    } /* end of loop */
d3053 10
a3062 3
     if ( display_char_set_old != current_char_set ||
	       raw_mode_old != LYRawMode ||
	       assume_char_set_changed ) {
d3068 2
a3069 2
	     *  Set the LYUseDefaultRawMode value and character
	     *  handling if LYRawMode was changed. - FM
d3076 2
a3077 2
		 (current_char_set == auto_display_charset
		  || current_char_set == auto_other_display_charset);
d3085 2
a3086 2
	     *  Set the raw 8-bit or CJK mode defaults and
	     *  character set if changed. - FM
d3092 2
a3093 3
     } /* end of charset settings */


d3110 2
a3111 2
     *  Exit: working around the previous document.
     *  Being out of mainloop()/getfile() cycle, do things manually.
d3115 1
a3115 1
		    need_reload ? "TRUE" : "FALSE"));
d3117 1
a3117 1
		    need_end_reload ? "TRUE" : "FALSE"));
d3127 2
a3128 2
    LYforce_no_cache = FALSE;   /* ! */
    LYoverride_no_cache = TRUE; /* ! */
d3138 1
a3138 1
	return(NOT_FOUND);
d3140 1
a3140 1
    HTuncache_current_document(); /* will never use again */
d3143 2
a3144 3
     *  Return to previous doc, not to options menu!
     *  Reload the document we had before the options menu
     *  but uncache only when necessary (Hurrah, user!):
d3153 2
a3154 2
    LYforce_no_cache = FALSE;   /* see below */
    LYoverride_no_cache = TRUE; /* see below */
d3163 1
a3163 1
	return(NOT_FOUND);
d3170 4
a3173 4
    reloading = FALSE;  /* set manually */
    /*  force end-to-end reload from remote server if change LYUserAgent
     *  or language or pref_charset (marked by need_end_reload flag above),
     *  from old-style LYK_OPTIONS (mainloop):
d3179 7
a3185 9
	 *  An option has changed which may influence
	 *  content negotiation, and the resource is from
	 *  a http or https or lynxcgi URL (the only protocols
	 *  which currently do anything with this information).
	 *  Set reloading = TRUE so that proxy caches will be
	 *  flushed, which is necessary until the time when
	 *  all proxies understand HTTP 1.1 Vary: and all
	 *  Servers properly use it...  Treat like
	 *  case LYK_RELOAD (see comments there). - KW
d3187 2
a3188 2
	reloading = TRUE;  /* global flag */
	need_reload = TRUE;  /* this was probably already TRUE, don't worry */
d3194 1
a3194 1
	return(NORMAL);
d3199 1
a3199 1
	 *  see LYK_RELOAD & LYK_OPTIONS in mainloop for details...
d3211 1
a3211 1
		return(NORMAL);
d3221 1
a3221 1
	    return(NORMAL);
d3229 1
a3229 1
	return(NULLFILE);
d3235 1
a3235 1
PRIVATE char *NewSecureValue NOARGS
d3237 2
d3240 1
a3240 1
    if ((secure_value = malloc(80)) != 0) {
d3243 1
d3245 1
a3245 1
	long key = (long)secure_value + (long)time(0);
d3250 1
a3250 1
    return "?";
d3253 2
d3259 2
a3260 4
PRIVATE void PutLabel ARGS3(
	FILE *,		fp,
	char *,		name,
	char *,		value)
d3262 5
d3268 2
a3269 1
	fprintf(fp, "  %-33s: ", name);
d3271 9
a3279 5
	int l = strlen(name);
	fprintf(fp, "  %s", name);
	fprintf(fp, "%s%-*s: ",
		(l < 30) ? " " : "",
		(l < 30) ? 32 - l : 3, "(!)");
d3281 1
d3290 1
a3290 1
PRIVATE char *check_if_write_lynxrc ARGS1(char **, table)
d3293 1
a3293 1
    char *result = NULL;
d3308 1
a3308 1
PRIVATE char *will_save_cookies NOARGS
d3310 4
a3313 3
    static char *table[] = {
	RC_SET_COOKIES,			/* LYSetCookies */
	RC_ACCEPT_ALL_COOKIES,		/* LYAcceptAllCookies */
d3316 1
d3325 1
a3325 1
PRIVATE char *will_save_images NOARGS
d3327 3
a3329 2
    static char *table[] = {
	RC_MAKE_PSEUDO_ALTS_FOR_INLINES, /* pseudo_inline_alts */
d3333 1
d3338 11
d3359 1
a3359 2
PRIVATE int gen_options ARGS1(
	char **,	newfile)
d3369 1
a3369 1
	return(NOT_FOUND);
d3373 11
a3383 11
    /* This should not be needed if we regenerate the temp file every
       time with a new name, which just happened above in the case
       LYReuseTempfiles==FALSE.  Even for LYReuseTempfiles=TRUE, code
       at the end of postoptions() may remove an older cached version
       from memory if that version of the page was left by submitting
       changes. - kw 1999-11-27
       If access to the actual file via getfile() later fails
       (maybe because of some restrictions), mainloop may leave
       this flag on after popping the previous doc which is then
       unnecessarily reloaded.  But I changed mainloop to reset
       the flag. - kw 1999-05-24 */
d3395 1
a3395 1
    BeginInternalPage(fp0, OPTIONS_TITLE, NULL); /* help link below */
d3407 1
a3407 1
		 secure_string, NewSecureValue());
d3414 1
a3414 1
    fprintf(fp0,"<p align=center>\n");
d3416 3
a3418 3
	fprintf(fp0,"<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0,"<input type=\"reset\" value=\"%s\"> - \n", RESET_CHANGES);
	fprintf(fp0,"%s - \n", CANCEL_CHANGES);
d3421 1
a3421 1
		 helpfilepath, OPTIONS_HELP, TO_HELP);
d3428 1
a3428 1
			 save_options_string);
d3431 1
a3431 1
			gettext("(options marked with (!) will not be saved)"));
d3437 1
a3437 1
    fprintf(fp0,"<pre>\n");
d3439 1
a3439 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("General Preferences"));
d3451 1
a3451 1
		      DISABLED(no_editor || system_editor));
d3459 1
a3459 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Security and Privacy"));
d3466 2
a3467 2
		   cookies_ignore_all_string,
		   cookies_ignore_all_string);
d3469 2
a3470 2
		   cookies_up_to_user_string,
		   cookies_up_to_user_string);
d3472 2
a3473 2
		   cookies_accept_all_string,
		   cookies_accept_all_string);
d3490 1
a3490 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Keyboard Input"));
d3512 1
a3512 1
    if (LYLineeditNames[1]) { /* well, at least 2 line edit styles available */
d3517 1
d3519 1
a3519 1
	    PutOption(fp0, i==current_lineedit, temp, LYLineeditNames[i]);
a3522 1

d3529 1
d3539 1
a3539 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Display and Character Set"));
d3542 10
d3554 1
a3554 1
    BeginSelect(fp0, display_char_set_string);
d3558 1
d3565 1
a3565 1
	PutOption(fp0, i==current_char_set, temp, LYchar_set_names[i]);
d3572 1
d3581 1
a3581 1
		/* ok, LYRawMode, so use UCAssume_MIMEcharset */
d3590 3
a3592 3
	    PutOption(fp0, i == curval,
			   LYCharSet_UC[i].MIMEname,
			   LYCharSet_UC[i].MIMEname);
d3614 1
a3614 1
    PutLabel(fp0, gettext("X Display"),	x_display_string);
d3620 1
a3620 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Document Appearance"));
d3630 1
a3630 1
	   LYShowColor = SHOW_COLOR_OFF;
d3632 1
a3632 1
	   LYShowColor = SHOW_COLOR_ON;
d3638 2
a3639 2
	   show_color_values[2].HtmlName = on_string;
	   show_color_values[3].LongName = always_string;
d3641 2
a3642 2
	   show_color_values[2].HtmlName = NULL; /* suppress "ON" - kw */
	   show_color_values[3].LongName = "Always try";
d3655 6
d3685 2
a3686 2
		   images_ignore_all_string,
		   images_ignore_all_string);
d3688 2
a3689 2
		   images_use_label_string,
		   images_use_label_string);
d3691 2
a3692 2
		   images_use_links_string,
		   images_use_links_string);
d3704 2
a3705 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Headers Transferred to Remote Servers"));
d3711 18
a3728 1
		      NonNull(personal_mail_address), text_len, "");
d3733 1
a3733 1
		      NonNull(pref_charset), cset_len+2, "");
d3738 1
a3738 1
		      NonNull(language), cset_len+2, "");
d3744 1
a3744 1
			  NonNull(LYUserAgent), text_len, "");
d3750 1
a3750 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Listing and Accessing Files"));
d3754 1
a3754 1
    PutLabel(fp0, gettext("FTP sort criteria"),	ftp_sort_string);
d3788 5
a3792 5
		      ? EXEC_ALWAYS
		      : (local_exec_on_local_files
			  ? EXEC_LOCAL
			  : EXEC_NEVER),
		      exec_links_values);
d3795 3
a3797 3
		      ? EXEC_LOCAL
		      : EXEC_NEVER,
		      exec_links_values);
d3803 1
a3803 1
    /* Local Directory Sort: SELECT */
d3806 12
a3817 1
    PutOptValues(fp0, LYTransferRate, rate_values);
d3824 1
a3824 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Special Files and Screens"));
d3838 2
a3839 2
	fprintf(fp0, "<a href=\"%s//MBM_MENU\">%s</a>\n",
		    STR_LYNXOPTIONS, gettext("Goto multi-bookmark menu"));
d3843 1
a3843 1
			 NonNull(bookmark_page), text_len, "");
d3848 1
a3848 3
    BeginSelect(fp0, visited_links_string);
    PutOptValues(fp0, Visited_Links_As, visited_links_values);
    EndSelect(fp0);
d3852 2
a3853 2
		     gettext("View the file "),
		     STR_LYNXCFG);
d3856 1
a3856 1
    fprintf(fp0,"\n</pre>\n");
d3860 4
a3863 4
	fprintf(fp0,"<p align=center>\n");
	fprintf(fp0,"<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0,"<input type=\"reset\" value=\"%s\"> - \n", RESET_CHANGES);
	fprintf(fp0,"%s\n", CANCEL_CHANGES);
d3869 1
a3869 1
    fprintf(fp0,"</form>\n");
d3873 1
a3873 1
    return(NORMAL);
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d2131 1
a2131 1
static char * exec_links_string		= "exec_options";
d2246 1
a2246 1
static char * single_bookmark_string	= "single_bookmark_name";
d2296 1
a2296 1
#ifdef EXP_READPROGRESS
d2987 1
a2987 2
    /* comment out to avoid warning when removing forms content... */
    /* HTuncache_current_document(); */ /* will never use again */
d3054 1
a3054 1
#ifdef SOURCE_CACHE
d3200 1
a3200 2
       changes. (But that code doesn't do that - HTuncache_current_document
       is currently commented out.) - kw 1999-11-27
d3587 1
a3587 1
#ifdef EXP_READPROGRESS
d3593 1
a3593 1
#endif /* EXP_READPROGRESS */
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d24 1
d30 2
d34 1
a34 1
#if !defined(NO_OPTION_MENU) || defined(NCURSES_MOUSE_VERSION)
d38 83
d126 3
a128 1
	char **		choices));
d194 11
a204 11
#define L_Bool_A (use_assume_charset ? L_BOOL_A + 1 : L_BOOL_A)
#define L_Bool_B (use_assume_charset ? L_BOOL_B + 1 : L_BOOL_B)
#define L_Exec (use_assume_charset ? L_EXEC + 1 : L_EXEC)
#define L_Rawmode (use_assume_charset ? L_RAWMODE + 1 : L_RAWMODE)
#define L_Charset (use_assume_charset ? L_CHARSET + 1 : L_CHARSET)
#define L_Color (use_assume_charset ? L_COLOR + 1 : L_COLOR)
#define L_Keypad (use_assume_charset ? L_KEYPAD + 1 : L_KEYPAD)
#define L_Lineed (use_assume_charset ? L_LINEED + 1 : L_LINEED)
#define L_Layout (use_assume_charset ? L_LAYOUT + 1 : L_LAYOUT)
#define L_Dired (use_assume_charset ? L_DIRED + 1 : L_DIRED)
#define L_User_Mode (use_assume_charset ? L_USER_MODE + 1 : L_USER_MODE)
d214 1
a214 1
	addstr(text);
d220 1
a220 1
 * addlbl() is used instead of plain addstr() in old-style options menu
d247 15
d264 53
a316 1
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
d318 1
a318 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d334 1
a334 1
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
d344 1
a344 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d346 1
a346 1
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
d356 1
a356 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d370 1
a370 26
	if (LYChosenShowColor == SHOW_COLOR_UNKNOWN) {
	    switch (LYrcShowColor) {
	    case SHOW_COLOR_NEVER:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
				     SHOW_COLOR_ON :
				     SHOW_COLOR_NEVER;
		break;
	    case SHOW_COLOR_ALWAYS:
#if defined(COLOR_CURSES)
		if (!has_colors())
		    LYChosenShowColor = SHOW_COLOR_ALWAYS;
		else
#endif
		    LYChosenShowColor =
			(LYShowColor >= SHOW_COLOR_ON) ?
				     SHOW_COLOR_ALWAYS :
				     SHOW_COLOR_OFF;
		break;
	    default:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
				     SHOW_COLOR_ON :
				     SHOW_COLOR_OFF;
	    }
	}
d375 1
a375 1
	use_assume_charset = (user_mode == ADVANCED_MODE);
a383 1
    response = 0;
d386 1
a386 1
	clear();
d388 1
a388 1
	erase();
d391 1
a391 1
    clear();
d393 1
a393 1
    move(0, 5);
d396 5
a400 5
    addstr("         Options Menu (");
    addstr(LYNX_NAME);
    addstr(" Version ");
    addstr(LYNX_VERSION);
    addch(')');
d402 1
a402 1
    move(L_EDITOR, 5);
d404 1
a404 1
    addstr((editor && *editor) ? editor : "NONE");
d406 1
a406 1
    move(L_DISPLAY, 5);
d408 1
a408 1
    addstr((x_display && *x_display) ? x_display : "NONE");
d410 1
a410 1
    move(L_HOME, 5);
d412 3
a414 6
    addstr((LYMultiBookmarks ?
	      (LYMBMAdvanced ? "ADVANCED"
			     : "STANDARD")
			     : "OFF     "));
    move(L_HOME, B_BOOK);
    if (LYMultiBookmarks) {
d418 1
a418 1
	addstr((bookmark_page && *bookmark_page) ? bookmark_page : "NONE");
d421 1
a421 1
    move(L_FTPSTYPE, 5);
d423 1
a423 1
    addstr((HTfileSortMethod == FILE_BY_NAME ? "By Filename" :
d428 1
a428 1
    move(L_MAIL_ADDRESS, 5);
d430 1
a430 1
    addstr((personal_mail_address && *personal_mail_address) ?
d433 1
a433 1
    move(L_SSEARCH, 5);
d435 1
a435 1
    addstr(case_sensitive ? "CASE SENSITIVE  " : "CASE INSENSITIVE");
d437 1
a437 1
    move(L_Charset, 5);
d439 1
a439 1
    addstr((char *)LYchar_set_names[current_char_set]);
d441 1
a441 1
    move(L_LANGUAGE, 5);
d443 1
a443 1
    addstr((language && *language) ? language : "NONE");
d445 1
a445 1
    move(L_PREF_CHARSET, 5);
d447 1
a447 1
    addstr((pref_charset && *pref_charset) ? pref_charset : "NONE");
d450 1
a450 1
	move(L_ASSUME_CHARSET, 5);
d453 1
a453 1
	    addstr(UCAssume_MIMEcharset);
d455 2
a456 2
	    addstr((UCLYhndl_for_unspec >= 0) ?
		   (char *)LYCharSet_UC[UCLYhndl_for_unspec].MIMEname
d460 1
a460 1
    move(L_Rawmode, 5);
d462 1
a462 1
    addstr(LYRawMode ? "ON " : "OFF");
d465 1
a465 1
    move(L_Color, B_COLOR);
d468 1
a468 2
	addstr((LYShowColor == SHOW_COLOR_OFF ? "OFF" :
						"ON "));
d472 1
a472 1
		addstr("NEVER     ");
d475 1
a475 1
		addstr("OFF");
d478 1
a478 1
		addstr("ON ");
d483 1
a483 1
		    addstr("Always try");
d486 1
a486 1
		    addstr("ALWAYS    ");
d491 1
a491 1
    move(L_Bool_A, B_VIKEYS);
d493 1
a493 1
    addstr(vi_keys ? "ON " : "OFF");
d495 1
a495 1
    move(L_Bool_A, B_EMACSKEYS);
d497 1
a497 1
    addstr(emacs_keys ? "ON " : "OFF");
d499 1
a499 1
    move(L_Bool_A, B_SHOW_DOTFILES);
d501 1
a501 1
    addstr((!no_dotfiles && show_dotfiles) ? "ON " : "OFF");
d503 1
a503 1
    move(L_Bool_B, B_SELECT_POPUPS);
d505 1
a505 1
    addstr(LYSelectPopups ? "ON " : "OFF");
d507 1
a507 1
    move(L_Bool_B, B_SHOW_CURSOR);
d509 1
a509 1
    addstr(LYShowCursor ? "ON " : "OFF");
d511 1
a511 1
    move(L_Keypad, 5);
d513 7
a519 5
    addstr((keypad_mode == NUMBERS_AS_ARROWS) ?
				"Numbers act as arrows             " :
	 ((keypad_mode == LINKS_ARE_NUMBERED) ?
				"Links are numbered                " :
				"Links and form fields are numbered"));
d521 1
a521 1
    move(L_Lineed, 5);
d523 1
a523 1
    addstr(LYLineeditNames[current_lineedit]);
d526 1
a526 1
    move(L_Layout, 5);
d528 1
a528 1
    addstr(LYKbLayoutNames[current_layout]);
d532 1
a532 1
    move(L_Dired, 5);
d534 1
a534 1
    addstr((dir_list_style == FILES_FIRST) ? "Files first      " :
d539 1
a539 1
    move(L_User_Mode, 5);
d541 1
a541 1
    addstr(  (user_mode == NOVICE_MODE) ? "Novice      " :
d546 1
a546 1
    addstr( verbose_img ? "ON " : "OFF" );
d548 1
a548 1
    move(L_User_Agent, 5);
d550 1
a550 1
    addstr((LYUserAgent && *LYUserAgent) ? LYUserAgent : "NONE");
d552 2
a553 2
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
    move(L_Exec, 5);
d556 1
a556 1
    addstr(               local_exec ? "ALWAYS ON           " :
d560 1
a560 1
    addstr(local_exec_on_local_files ? "FOR LOCAL FILES ONLY" :
d563 1
a563 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d565 2
a566 2
    move(LYlines-3, 2);
    addstr(SELECT_SEGMENT);
d568 1
a568 1
    addstr(CAP_LETT_SEGMENT);
d570 1
a570 1
    addstr(OF_OPT_LINE_SEGMENT);
d572 1
a572 1
	addstr(" '");
d574 1
a574 1
	addstr(">");
d576 2
a577 2
	addstr("'");
	addstr(TO_SAVE_SEGMENT);
d579 2
a580 2
    addstr(OR_SEGMENT);
    addstr("'");
d582 1
a582 1
    addstr("r");
d584 2
a585 2
    addstr("'");
    addstr(TO_RETURN_SEGMENT);
d587 2
a588 1
    while (TOUPPER(response) != 'R' &&
d591 1
a591 1
	   response != 7 &&  response != 3) {
d596 1
a596 1
	move((LYlines - 2), 0);
d598 1
a598 1
	addstr(COMMAND_PROMPT);
d601 3
a603 3
	refresh();
	response = LYgetch();
	if (term_options || response == 7 || response == 3)
d610 1
a610 2
	    case 'e':	/* Change the editor. */
	    case 'E':
d617 1
a617 1
			strcpy(display_option, editor);
d619 2
a620 2
			move(L_EDITOR, COL_OPTION_VALUES);
			addstr("    ");
d624 1
a624 1
		    move(L_EDITOR, COL_OPTION_VALUES);
d629 1
a629 1
		    move(L_EDITOR, COL_OPTION_VALUES);
d631 1
a631 1
			addstr((editor && *editor) ?
d635 1
a635 1
			addstr("NONE");
d638 1
a638 1
			addstr(display_option);
d640 1
a640 1
		    clrtoeol();
d651 1
a651 2
	    case 'd':	/* Change the display. */
	    case 'D':
d653 1
a653 1
		    strcpy(display_option, x_display);
d655 2
a656 2
		    move(L_DISPLAY, COL_OPTION_VALUES);
		    addstr("    ");
d660 1
a660 1
		move(L_DISPLAY, COL_OPTION_VALUES);
d665 2
a666 3
		move(L_DISPLAY, COL_OPTION_VALUES);
		if ((term_options || ch == -1) ||
		    (x_display != NULL &&
d668 1
a668 1
		     !strcasecomp(x_display, display_option)))
d670 1
a670 1
		     !strcmp(x_display, display_option)))
d672 4
a675 1
		{
d680 2
a681 2
		    addstr((x_display && *x_display) ? x_display : "NONE");
		    clrtoeol();
d697 2
a698 2
			addstr("NONE");
			clrtoeol();
d708 1
a708 5
		if ((cp = LYgetXDisplay()) != NULL) {
		    StrAllocCopy(x_display, cp);
		} else {
		    FREE(x_display);
		}
d710 3
a712 21
		addstr(x_display ? x_display : "NONE");
		clrtoeol();
		if ((x_display == NULL && *display_option == '\0') ||
		    (x_display != NULL &&
		     !strcmp(x_display, display_option))) {
		    if (x_display == NULL &&
			LYisConfiguredForX == TRUE) {
			_statusline(VALUE_ACCEPTED_WARNING_X);
		    } else if (x_display != NULL &&
			LYisConfiguredForX == FALSE) {
			_statusline(VALUE_ACCEPTED_WARNING_NONX);
		    } else {
			_statusline(VALUE_ACCEPTED);
		    }
		} else {
		    if (*display_option) {
			_statusline(FAILED_TO_SET_DISPLAY);
		    } else {
			_statusline(FAILED_CLEAR_SET_DISPLAY);
		    }
		}
d716 1
a716 2
	    case 'l':	/* Change multibookmarks option. */
	    case 'L':
a721 7
		choices[0] = NULL;
		StrAllocCopy(choices[0], "OFF     ");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "STANDARD");
		choices[2] = NULL;
		StrAllocCopy(choices[2], "ADVANCED");
		choices[3] = NULL;
d723 1
a723 2
		    LYMultiBookmarks = boolean_choice((LYMultiBookmarks *
						       (1 + LYMBMAdvanced)),
d725 1
a725 1
						      choices);
d727 1
a727 2
		    LYMultiBookmarks = popup_choice((LYMultiBookmarks *
						     (1 + LYMBMAdvanced)),
d729 2
a730 8
						    choices,
						    3, FALSE);
		}
		if (LYMultiBookmarks == 2) {
		    LYMultiBookmarks = TRUE;
		    LYMBMAdvanced = TRUE;
		} else {
		    LYMBMAdvanced = FALSE;
d734 3
a736 3
		    move(L_HOME, C_MULTI);
		    clrtoeol();
		    addstr(choices[(LYMultiBookmarks * (1 + LYMBMAdvanced))]);
a738 3
		FREE(choices[0]);
		FREE(choices[1]);
		FREE(choices[2]);
d743 4
a746 4
		    move(L_HOME, B_BOOK);
		    clrtoeol();
		    if (LYMultiBookmarks) {
			addstr(gettext("review/edit B)ookmarks files"));
d748 2
a749 2
			addstr(gettext("B)ookmark file: "));
			addstr((bookmark_page && *bookmark_page) ?
d755 1
a755 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d759 1
a759 2
	    case 'b':	/* Change the bookmark page location. */
	    case 'B':
d765 1
a765 1
		    if (LYMultiBookmarks) {
d771 1
a771 1
			strcpy(display_option, bookmark_page);
d773 2
a774 2
			move(L_HOME, C_DEFAULT);
			clrtoeol();
d778 1
a778 1
		    move(L_HOME, C_DEFAULT);
d783 1
a783 1
		    move(L_HOME, C_DEFAULT);
d786 1
a786 1
			addstr((bookmark_page && *bookmark_page) ?
d790 1
a790 1
			addstr((bookmark_page && *bookmark_page) ?
d792 1
a792 1
			clrtoeol();
d798 2
a799 3
			StrAllocCopy(MBM_A_subbookmark[0],
				     bookmark_page);
			addstr(bookmark_page);
d801 1
a801 1
		    clrtoeol();
d814 1
a814 14
	    case 'f':	/* Change ftp directory sorting. */
	    case 'F':	/*  (also local for non-DIRED)	 */
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "By Filename");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "By Type    ");
		choices[2] = NULL;
		StrAllocCopy(choices[2], "By Size    ");
		choices[3] = NULL;
		StrAllocCopy(choices[3], "By Date    ");
		choices[4] = NULL;
d816 1
a816 1
		    HTfileSortMethod = boolean_choice(HTfileSortMethod,
d818 1
a818 1
						      choices);
d820 1
a820 1
		    HTfileSortMethod = popup_choice(HTfileSortMethod,
d822 2
a823 2
						    choices,
						    4, FALSE);
d825 3
a827 3
		    move(L_FTPSTYPE, COL_OPTION_VALUES);
		    clrtoeol();
		    addstr(choices[HTfileSortMethod]);
a829 4
		FREE(choices[0]);
		FREE(choices[1]);
		FREE(choices[2]);
		FREE(choices[3]);
d832 1
a832 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d836 1
a836 2
	    case 'p': /* Change personal mail address for From headers. */
	    case 'P':
d838 1
a838 1
		    strcpy(display_option, personal_mail_address);
d840 2
a841 2
		    move(L_MAIL_ADDRESS, COL_OPTION_VALUES);
		    addstr("    ");
d845 1
a845 1
		move(L_MAIL_ADDRESS, COL_OPTION_VALUES);
d850 1
a850 1
		move(L_MAIL_ADDRESS, COL_OPTION_VALUES);
d852 1
a852 1
		    addstr((personal_mail_address &&
d857 1
a857 1
		    addstr("NONE");
d860 1
a860 1
		    addstr(display_option);
d862 1
a862 1
		clrtoeol();
d872 4
a875 14
	    case 's':	/* Change case sensitivity for searches. */
	    case 'S':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "CASE INSENSITIVE");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "CASE SENSITIVE  ");
		choices[2] = NULL;
		case_sensitive = boolean_choice(case_sensitive,
						L_SSEARCH, -1, choices);
		FREE(choices[0]);
		FREE(choices[1]);
d882 2
a883 2
		    char ** assume_list;
		    assume_list = (char **)calloc(LYNumCharsets + 1, sizeof(char *));
d888 1
a888 1
			assume_list[i] = (char *)LYCharSet_UC[i].MIMEname;
d897 9
a905 1
			UCLYhndl_for_unspec = boolean_choice(curval,
d908 1
d910 10
a919 1
			UCLYhndl_for_unspec = popup_choice(curval,
d922 2
a923 1
							   0, FALSE);
d925 2
a926 2
			move(L_ASSUME_CHARSET, COL_OPTION_VALUES);
			clrtoeol();
d928 1
a928 2
			    addstr((char *)
				   LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d942 2
a943 1
			LYRawMode = (UCLYhndl_for_unspec == current_char_set);
d952 3
a954 3
			    move(L_Rawmode, COL_OPTION_VALUES);
			    clrtoeol();
			    addstr(LYRawMode ? "ON " : "OFF");
d960 1
a960 10
#if !defined(VMS) || defined(USE_SLANG)
			if (term_options) {
			    term_options = FALSE;
			} else {
			    AddValueAccepted = TRUE;
			}
			goto draw_options;
#else
			term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d968 1
a968 2
	    case 'c':	/* Change display charset setting. */
	    case 'C':
d970 2
a971 1
		    current_char_set = boolean_choice(current_char_set,
d973 7
a979 1
						      (char **)LYchar_set_names);
d981 8
a988 1
		    current_char_set = popup_choice(current_char_set,
d990 4
a993 2
						    (char **)LYchar_set_names,
						    0, FALSE);
d995 3
a997 3
		    move(L_Charset, COL_OPTION_VALUES);
		    clrtoeol();
		    addstr((char *)LYchar_set_names[current_char_set]);
d1013 10
a1022 4
			move(L_Rawmode, COL_OPTION_VALUES);
			clrtoeol();
			addstr(LYRawMode ? "ON " : "OFF");
		    }
d1026 1
a1026 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d1030 2
a1031 11
	    case 'o':	/* Change raw mode setting. */
	    case 'O':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "OFF");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "ON ");
		choices[2] = NULL;
		LYRawMode = boolean_choice(LYRawMode, L_Rawmode, -1, choices);
a1040 2
		FREE(choices[0]);
		FREE(choices[1]);
d1044 1
a1044 2
	    case 'g':	/* Change language preference. */
	    case 'G':
d1046 1
a1046 1
		    strcpy(display_option, language);
d1048 2
a1049 2
		    move(L_LANGUAGE, COL_OPTION_VALUES);
		    addstr("    ");
d1053 1
a1053 1
		move(L_LANGUAGE, COL_OPTION_VALUES);
d1058 1
a1058 1
		move(L_LANGUAGE, COL_OPTION_VALUES);
d1060 1
a1060 1
		    addstr((language && *language) ?
d1064 1
a1064 1
		    addstr("NONE");
d1067 1
a1067 1
		    addstr(display_option);
d1069 1
a1069 1
		clrtoeol();
d1079 1
a1079 2
	    case 'h':	/* Change charset preference. */
	    case 'H':
d1081 1
a1081 1
		    strcpy(display_option, pref_charset);
d1083 2
a1084 2
		    move(L_PREF_CHARSET, COL_OPTION_VALUES);
		    addstr("    ");
d1088 1
a1088 1
		move(L_PREF_CHARSET, COL_OPTION_VALUES);
d1093 1
a1093 1
		move(L_PREF_CHARSET, COL_OPTION_VALUES);
d1095 1
a1095 1
		    addstr((pref_charset && *pref_charset) ?
d1099 1
a1099 1
		    addstr("NONE");
d1102 1
a1102 1
		    addstr(display_option);
d1104 1
a1104 1
		clrtoeol();
d1114 2
a1115 11
	    case 'v':	/* Change VI keys setting. */
	    case 'V':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "OFF");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "ON ");
		choices[2] = NULL;
		vi_keys = boolean_choice(vi_keys,
d1117 1
a1117 1
					 choices);
a1122 2
		FREE(choices[0]);
		FREE(choices[1]);
d1127 1
a1127 10
	    case 'm':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "OFF");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "ON ");
		choices[2] = NULL;
		emacs_keys = boolean_choice(emacs_keys,
d1129 1
a1129 1
					    choices);
a1134 2
		FREE(choices[0]);
		FREE(choices[1]);
a1138 1
	    case 'w':
d1142 1
a1142 9
		    /*
		     *	Copy strings into choice array.
		     */
		    choices[0] = NULL;
		    StrAllocCopy(choices[0], "OFF");
		    choices[1] = NULL;
		    StrAllocCopy(choices[1], "ON ");
		    choices[2] = NULL;
		    show_dotfiles = boolean_choice(show_dotfiles,
d1145 1
a1145 3
						   choices);
		    FREE(choices[0]);
		    FREE(choices[1]);
d1150 2
a1151 11
	    case 't':	/* Change select popups setting. */
	    case 'T':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "OFF");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "ON ");
		choices[2] = NULL;
		LYSelectPopups = boolean_choice(LYSelectPopups,
d1154 1
a1154 3
						choices);
		FREE(choices[0]);
		FREE(choices[1]);
d1163 1
a1163 1
			char * terminal = getenv("TERM");
d1170 1
d1173 1
a1173 9
		/*
		 *  Copy strings into choice array.
		 */
		    choices[0] = NULL;
		    StrAllocCopy(choices[0], "OFF");
		    choices[1] = NULL;
		    StrAllocCopy(choices[1], "ON ");
		    choices[2] = NULL;
		    LYShowColor = boolean_choice((LYShowColor - 1),
d1176 1
a1176 1
						 choices);
d1185 3
a1187 3
		/*
		 *  Copy strings into choice array.
		 */
d1204 1
a1204 1
			    chosen = boolean_choice(LYChosenShowColor,
d1209 1
a1209 1
			    chosen = popup_choice(LYChosenShowColor,
d1212 1
a1212 1
						  choices, 4, FALSE);
d1215 1
a1215 1
			again = (chosen == 2 && !has_colors());
d1217 1
a1217 1
			    char * terminal = getenv("TERM");
d1230 3
a1232 3
			move(L_Color, C_COLOR);
			clrtoeol();
			addstr(choices[LYChosenShowColor]);
d1239 2
a1243 2
		FREE(choices[0]);
		FREE(choices[1]);
d1249 1
a1249 1
		SLtt_Use_Ansi_Colors = (LYShowColor > 1 ? 1 : 0);
d1253 1
a1253 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d1259 1
a1259 9
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "OFF");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "ON ");
		choices[2] = NULL;
		LYShowCursor = boolean_choice(LYShowCursor,
d1262 1
a1262 3
					      choices);
		FREE(choices[0]);
		FREE(choices[1]);
d1266 1
a1266 15
	    case 'k':	/* Change keypad mode. */
	    case 'K':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0],
			     "Numbers act as arrows             ");
		choices[1] = NULL;
		StrAllocCopy(choices[1],
			     "Links are numbered                ");
		choices[2] = NULL;
		StrAllocCopy(choices[2],
			     "Links and form fields are numbered");
		choices[3] = NULL;
d1268 1
a1268 1
		    keypad_mode = boolean_choice(keypad_mode,
d1270 1
a1270 1
						 choices);
d1272 4
a1275 4
		    keypad_mode = popup_choice(keypad_mode,
					       L_Keypad, -1,
					       choices,
					       3, FALSE);
d1277 3
a1279 3
		    move(L_Keypad, COL_OPTION_VALUES);
		    clrtoeol();
		    addstr(choices[keypad_mode]);
a1286 3
		FREE(choices[0]);
		FREE(choices[1]);
		FREE(choices[2]);
d1289 1
a1289 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d1293 1
a1293 2
	    case 'n':	/* Change line editor key bindings. */
	    case 'N':
d1295 1
a1295 1
		    current_lineedit = boolean_choice(current_lineedit,
d1299 1
a1299 1
		    current_lineedit = popup_choice(current_lineedit,
d1302 1
a1302 1
						    0, FALSE);
d1304 3
a1306 3
		    move(L_Lineed, COL_OPTION_VALUES);
		    clrtoeol();
		    addstr(LYLineeditNames[current_lineedit]);
d1311 1
a1311 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d1316 1
a1316 2
	    case 'y':	/* Change keyboard layout */
	    case 'Y':
d1318 1
a1318 1
		    current_layout = boolean_choice(current_layout,
d1322 1
a1322 1
		    current_layout = popup_choice(current_layout,
d1325 1
a1325 1
						    0, FALSE);
d1327 3
a1329 3
		    move(L_Layout, COL_OPTION_VALUES);
		    clrtoeol();
		    addstr(LYKbLayoutNames[current_layout]);
d1334 1
a1334 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d1340 1
a1340 12
	    case 'i':	/* Change local directory sorting. */
	    case 'I':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "Directories first");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "Files first      ");
		choices[2] = NULL;
		StrAllocCopy(choices[2], "Mixed style      ");
		choices[3] = NULL;
d1342 1
a1342 1
		    dir_list_style = boolean_choice(dir_list_style,
d1344 1
a1344 1
						    choices);
d1346 1
a1346 1
		    dir_list_style = popup_choice(dir_list_style,
d1348 2
a1349 2
						  choices,
						  3, FALSE);
d1351 3
a1353 3
		    move(L_Dired, COL_OPTION_VALUES);
		    clrtoeol();
		    addstr(choices[dir_list_style]);
a1355 3
		FREE(choices[0]);
		FREE(choices[1]);
		FREE(choices[2]);
d1358 1
a1358 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d1363 1
a1363 12
	    case 'u':	/* Change user mode. */
	    case 'U':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "Novice      ");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "Intermediate");
		choices[2] = NULL;
		StrAllocCopy(choices[2], "Advanced    ");
		choices[3] = NULL;
d1365 10
a1374 10
		    user_mode = boolean_choice(user_mode,
					       L_User_Mode, -1,
					       choices);
		    use_assume_charset = (user_mode >= 2);
		} else {
		    user_mode = popup_choice(user_mode,
					     L_User_Mode, -1,
					     choices,
					     3, FALSE);
		    use_assume_charset = (user_mode >= 2);
d1377 3
a1379 3
			move(L_User_Mode, COL_OPTION_VALUES);
			clrtoeol();
			addstr(choices[user_mode]);
a1382 3
		FREE(choices[0]);
		FREE(choices[1]);
		FREE(choices[2]);
d1390 1
a1390 12
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
		    if (use_assume_charset != old_use_assume_charset)
			goto draw_options;
#endif /* !VMS || USE_SLANG */
a1394 8
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "OFF");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "ON ");
		choices[2] = NULL;
d1396 1
a1396 1
		    verbose_img = boolean_choice(verbose_img,
d1399 1
a1399 1
						choices);
d1401 1
a1401 1
		    verbose_img = popup_choice(verbose_img,
d1404 2
a1405 2
					     choices,
					     2, FALSE);
a1406 2
		FREE(choices[0]);
		FREE(choices[1]);
d1409 1
a1409 12
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
		    if (use_assume_charset != old_use_assume_charset)
			goto draw_options;
#endif /* !VMS || USE_SLANG */
d1413 1
a1413 2
	    case 'a':	/* Change user agent string. */
	    case 'A':
d1416 1
a1416 1
			strcpy(display_option, LYUserAgent);
d1418 2
a1419 2
			move(L_HOME, COL_OPTION_VALUES);
			addstr("    ");
d1423 1
a1423 1
		    move(L_User_Agent, COL_OPTION_VALUES);
d1428 1
a1428 1
		    move(L_User_Agent, COL_OPTION_VALUES);
d1430 1
a1430 1
			addstr((LYUserAgent &&
d1435 1
a1435 1
			addstr((LYUserAgent &&
d1440 1
a1440 1
			addstr(display_option);
d1442 1
a1442 1
		    clrtoeol();
d1446 2
a1447 4
		    } else if (LYUserAgent && *LYUserAgent &&
			!strstr(LYUserAgent, "Lynx") &&
			!strstr(LYUserAgent, "lynx")) {
			_statusline(UA_COPYRIGHT_WARNING);
d1452 1
a1452 1
		    _statusline(UA_COPYRIGHT_WARNING);
d1457 2
a1458 3
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
	    case 'x':	/* Change local exec restriction. */
	    case 'X':
a1475 12
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "ALWAYS OFF          ");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "FOR LOCAL FILES ONLY");
		choices[2] = NULL;
#ifndef NEVER_ALLOW_REMOTE_EXEC
		StrAllocCopy(choices[2], "ALWAYS ON           ");
		choices[3] = NULL;
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
d1477 1
a1477 1
		    itmp = boolean_choice(itmp,
d1479 1
a1479 1
					  choices);
d1481 1
a1481 1
		    itmp = popup_choice(itmp,
d1483 3
a1485 2
					choices,
					0, (exec_frozen ? TRUE : FALSE));
d1487 3
a1489 3
		    move(L_Exec, COL_OPTION_VALUES);
		    clrtoeol();
		    addstr(choices[itmp]);
a1491 5
		FREE(choices[0]);
		FREE(choices[1]);
#ifndef NEVER_ALLOW_REMOTE_EXEC
		FREE(choices[2]);
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
d1512 1
a1512 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (exec_frozen || term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d1515 1
a1515 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d1519 4
a1522 4
		    _statusline(SAVING_OPTIONS);
		    if (save_rc()) {
			LYrcShowColor = LYChosenShowColor;
			_statusline(OPTIONS_SAVED);
d1527 1
a1527 1
		    _statusline(R_TO_RETURN_TO_LYNX);
d1536 1
a1536 2
	    case 'r':	/* Return to document (quit options menu). */
	    case 'R':
d1541 1
a1541 1
		    _statusline(SAVE_OR_R_TO_RETURN_TO_LYNX);
d1543 1
a1543 1
		    _statusline(R_TO_RETURN_TO_LYNX);
d1553 22
d1576 1
a1576 2
 *  Take a boolean status,prompt the user for a new status,
 *  and return it.
d1582 1
a1582 1
	char **,	choices)
d1589 1
d1607 1
a1607 1
    move(line, col);
d1609 1
a1609 1
    addstr(choices[cur_choice]);
d1611 2
a1612 2
	move(line, (col - 1));
    refresh();
d1622 1
a1622 1
	move(line, col);
d1624 1
a1624 1
	    response = LYgetch();
d1626 1
a1626 1
	if (term_options || response == 7 || response == 3) {
d1643 1
a1643 1
	    (cmd = keymap[response+1]) != LYK_ACTIVATE) {
d1655 1
a1655 1
		    refresh();
d1669 1
d1698 1
a1698 1
	    addstr(choices[cur_choice]);
d1700 2
a1701 2
		move(line, (col - 1));
	    refresh();
d1706 1
a1706 1
	    move(line, col);
d1708 1
a1708 1
	    addstr(choices[cur_choice]);
d1717 1
a1717 1
	    return(cur_choice);
d1737 1
a1737 1
	refresh();
d1771 1
a1771 1
	clear();
d1773 1
a1773 1
	erase();
d1776 1
a1776 1
    clear();
d1778 1
a1778 1
    move(0, 5);
d1782 1
a1782 1
	addstr(ehead_buffer);
d1784 1
a1784 1
	addstr(MULTIBOOKMARKS_EHEAD);
d1791 3
a1793 3
	    move((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)), 5);
	    addch((unsigned char)(a + 'A'));
	    addstr(" : ");
d1795 3
a1797 3
		addstr(MBM_A_subdescript[a]);
	    move((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)), 35);
	    addstr("| ");
d1799 1
a1799 1
		addstr(MBM_A_subbookmark[a]);
d1804 3
a1806 3
	    move(3 + a, 5);
	    addch((unsigned char)(a + 'A'));
	    addstr(" : ");
d1808 3
a1810 3
		addstr(MBM_A_subdescript[a]);
	    move(3 + a, 35);
	    addstr("| ");
d1812 1
a1812 1
		addstr(MBM_A_subbookmark[a]);
d1821 2
a1822 2
	move((LYlines - 4), 0);
	addstr("'");
d1824 1
a1824 1
	addstr("[");
d1826 3
a1828 3
	addstr("' ");
	addstr(PREVIOUS);
	addstr(", '");
d1830 1
a1830 1
	addstr("]");
d1832 2
a1833 2
	addstr("' ");
	addstr(NEXT_SCREEN);
d1836 1
a1836 1
    move((LYlines - 3), 0);
d1838 1
a1838 1
	addstr("'");
d1840 1
a1840 1
	addstr(">");
d1842 2
a1843 2
	addstr("'");
	addstr(TO_SAVE_SEGMENT);
d1845 2
a1846 2
    addstr(OR_SEGMENT);
    addstr("'");
d1848 1
a1848 1
    addstr("^G");
d1850 2
a1851 2
    addstr("'");
    addstr(TO_RETURN_SEGMENT);
d1855 1
a1855 2
	   response != 7 && response != 3 &&
	   response != '>') {
d1857 1
a1857 1
	move((LYlines - 2), 0);
d1859 1
a1859 1
	addstr(MULTIBOOKMARKS_LETTER);
d1862 2
a1863 2
	refresh();
	response = (def_response ? def_response : LYgetch());
d1869 1
a1869 2
	if (term_options ||
	    response == 7 || response == 3 ||
d1878 3
a1880 3
		_statusline(SAVING_OPTIONS);
		if (save_rc())
		    _statusline(OPTIONS_SAVED);
d1884 1
a1884 1
		_statusline(R_TO_RETURN_TO_LYNX);
d1928 1
a1928 1
	    if ((TOUPPER(response) - 'A') == a) {
d1946 1
a1946 1
			move(
d1950 2
a1951 2
			move((3 + a), 9);
		    strcpy(MBM_tmp_line,
d1953 2
a1954 1
					       "" : MBM_A_subdescript[a]));
d1965 1
a1965 1
			move(
d1969 3
a1971 3
			move((3 + a), 5);
		    addch((unsigned char)(a + 'A'));
		    addstr(" : ");
d1973 3
a1975 3
			addstr(MBM_A_subdescript[a]);
		    clrtoeol();
		    refresh();
d1979 1
a1979 1
		    move((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)),
d1982 2
a1983 2
		    move((3 + a), 35);
		addstr("| ");
d1986 3
a1988 2
		strcpy(MBM_tmp_line,
		       (!MBM_A_subbookmark[a] ? "" : MBM_A_subbookmark[a]));
d2001 1
a2001 1
			sleep(AlertSecs);
d2009 1
a2009 1
		    move((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current-1)),
d2012 2
a2013 2
		    move((3 + a), 35);
		addstr("| ");
d2015 4
a2018 4
		    addstr(MBM_A_subbookmark[a]);
		clrtoeol();
		move(LYlines-1, 0);
		clrtoeol();
d2028 1
a2028 42
#if !defined(NO_OPTION_MENU) || defined(NCURSES_MOUSE_VERSION)
/*
**  This function prompts for a choice or page number.
**  If a 'g' or 'p' suffix is included, that will be
**  loaded into c.  Otherwise, c is zeroed. - FM
*/
PRIVATE int get_popup_choice_number ARGS1(
	int *,		c)
{
    char temp[120];

    /*
     *	Load the c argument into the prompt buffer.
     */
    temp[0] = *c;
    temp[1] = '\0';
    _statusline(OPTION_CHOICE_NUMBER);

    /*
     *	Get the number, possibly with a suffix, from the user.
     */
    if (LYgetstr(temp, VISIBLE, sizeof(temp), NORECALL) < 0 ||
	*temp == 0 || term_options) {
	HTInfoMsg(CANCELLED);
	*c = '\0';
	term_options = FALSE;
	return(0);
    }

    /*
     *	If we had a 'g' or 'p' suffix, load it into c.
     *	Otherwise, zero c.  Then return the number.
     */
    if (strchr(temp, 'g') != NULL || strchr(temp, 'G') != NULL) {
	*c = 'g';
    } else if (strchr(temp, 'p') != NULL || strchr(temp, 'P') != NULL) {
	*c = 'p';
    } else {
	*c = '\0';
    }
    return(atoi(temp));
}
d2034 3
d2038 1
a2038 1
PUBLIC int popup_choice ARGS6(
d2042 1
a2042 1
	char **,	choices,
d2044 2
a2045 1
	int,		disabled)
d2047 2
a2048 26
    int ly = line;
    int lx = (column >= 0 ? column : (COL_OPTION_VALUES - 1));
    int c = 0, cmd = 0, i = 0, j = 0;
    int orig_choice = cur_choice;
#ifndef USE_SLANG
    WINDOW * form_window;
#endif /* !USE_SLANG */
    int num_choices = 0, top, bottom, length = -1;
    unsigned width = 0;
    char ** Cptr = choices;
    int window_offset = 0;
    int DisplayLines = (LYlines - 2);
    char Cnum[64];
    int Lnum;
    int npages;
    static char prev_target[512];		/* Search string buffer */
    static char prev_target_buffer[512];	/* Next search buffer */
    static BOOL first = TRUE;
    char *cp;
    int ch = 0, recall;
    int QueryTotal;
    int QueryNum;
    BOOLEAN FirstRecall = TRUE;
    BOOLEAN ReDraw = FALSE;
    int number;
    char buffer[512];
d2050 19
a2068 935
    /*
     * Initialize the search string buffer. - FM
     */
    if (first) {
	*prev_target_buffer = '\0';
	first = FALSE;
    }
    *prev_target = '\0';
    QueryTotal = (search_queries ? HTList_count(search_queries) : 0);
    recall = ((QueryTotal >= 1) ? RECALL : NORECALL);
    QueryNum = QueryTotal;

    /*
     *	Count the number of choices to be displayed, where
     *	num_choices ranges from 0 to n, and set width to the
     *	longest choice string length.  Also set Lnum to the
     *	length for the highest choice number, then decrement
     *	num_choices so as to be zero-based.  The window width
     *	will be based on the sum of width and Lnum. - FM
     */
    for (num_choices = 0; Cptr[num_choices] != NULL; num_choices++) {
	if (strlen(Cptr[num_choices]) > width) {
	    width = strlen(Cptr[num_choices]);
	}
    }
    sprintf(Cnum, "%d: ", num_choices);
    Lnum = strlen(Cnum);
    num_choices--;

    /*
     *	Let's assume for the sake of sanity that ly is the number
     *	 corresponding to the line the option is on.
     *	Let's also assume that cur_choice is the number of the
     *	 choice that should be initially selected, with 0 being
     *	 the first choice.
     *	So what we have, is the top equal to the current screen line
     *	 subtracting the cur_choice + 1 (the one must be for the top
     *	 line we will draw in a box).  If the top goes under 0, then
     *	 consider it 0.
     */
    top = ly - (cur_choice + 1);
    if (top < 0)
	top = 0;

    /*
     *	Check and see if we need to put the i_length parameter up to
     *	the number of real choices.
     */
    if (i_length < 1) {
	i_length = num_choices;
    } else {
	/*
	 *  Otherwise, it is really one number too high.
	 */
	i_length--;
    }

    /*
     *	The bottom is the value of the top plus the number of choices
     *	to view plus 3 (one for the top line, one for the bottom line,
     *	and one to offset the 0 counted in the num_choices).
     */
    bottom = top + i_length + 3;

    /*
     *	Hmm...	If the bottom goes beyond the number of lines available,
     */
    if (bottom > DisplayLines) {
	/*
	 *  Position the window at the top if we have more
	 *  choices than will fit in the window.
	 */
	if ((i_length + 3) > DisplayLines) {
	    top = 0;
	    bottom = (top + (i_length + 3));
	    if (bottom > DisplayLines)
		bottom = (DisplayLines + 1);
	} else {
	    /*
	     *	Try to position the window so that the selected choice will
	     *	  appear where the choice box currently is positioned.
	     *	It could end up too high, at this point, but we'll move it
	     *	  down latter, if that has happened.
	     */
	    top = (DisplayLines + 1) - (i_length + 3);
	    bottom = (DisplayLines + 1);
	}
    }

    /*
     *	This is really fun, when the length is 4, it means 0 to 4, or 5.
     */
    length = (bottom - top) - 2;

    /*
     *	Move the window down if it's too high.
     */
    if (bottom < ly + 2) {
	bottom = ly + 2;
	if (bottom > DisplayLines + 1)
	    bottom = DisplayLines + 1;
	top = bottom - length - 2;
    }

    /*
     *	Set up the overall window, including the boxing characters ('*'),
     *	if it all fits.  Otherwise, set up the widest window possible. - FM
     */
#ifdef USE_SLANG
    SLsmg_fill_region(top, lx - 1, bottom - top, (Lnum + width + 4), ' ');
#else
    if (!(form_window = newwin(bottom - top, (Lnum + width + 4),
			       top, (lx - 1))) &&
	!(form_window = newwin(bottom - top, 0, top, 0))) {
	HTAlert(POPUP_FAILED);
	return(orig_choice);
    }
    scrollok(form_window, TRUE);
#ifdef PDCURSES
    keypad(form_window, TRUE);
#endif /* PDCURSES */
#ifdef NCURSES
    LYsubwindow(form_window);
#endif
#if defined(HAVE_GETBKGD) /* not defined in ncurses 1.8.7 */
    wbkgd(form_window, getbkgd(stdscr));
    wbkgdset(form_window, getbkgd(stdscr));
#endif
#endif /* USE_SLANG */

    /*
     *	Clear the command line and write
     *	the popup statusline. - FM
     */
    move((LYlines - 2), 0);
    clrtoeol();
    if (disabled) {
	_statusline(CHOICE_LIST_UNM_MSG);
    } else {
	_statusline(CHOICE_LIST_MESSAGE);
    }

    /*
     *	Set up the window_offset for choices.
     *	 cur_choice ranges from 0...n
     *	 length ranges from 0...m
     */
    if (cur_choice >= length) {
	window_offset = cur_choice - length + 1;
    }

    /*
     *	Compute the number of popup window pages. - FM
     */
    npages = ((num_choices + 1) > length) ?
		(((num_choices + 1) + (length - 1))/(length))
					  : 1;
/*
 *  OH!  I LOVE GOTOs! hack hack hack
 */
redraw:
    Cptr = choices;

    /*
     *	Display the boxed choices.
     */
    for (i = 0; i <= num_choices; i++) {
	if (i >= window_offset && i - window_offset < length) {
	    sprintf(Cnum, "%s%d: ",
			   ((num_choices > 8 && i < 9) ?
						   " " : ""),
			   (i + 1));
#ifdef USE_SLANG
	    SLsmg_gotorc(top + ((i + 1) - window_offset), (lx - 1 + 2));
	    addstr(Cnum);
	    SLsmg_write_nstring(Cptr[i], width);
#else
	    wmove(form_window, ((i + 1) - window_offset), 2);
	    wclrtoeol(form_window);
	    waddstr(form_window, Cnum);
	    waddstr(form_window, Cptr[i]);
#endif /* USE_SLANG */
	}
    }
#ifdef USE_SLANG
    SLsmg_draw_box(top, (lx - 1), (bottom - top), (Lnum + width + 4));
#else
#ifdef VMS
    VMSbox(form_window, (bottom - top), (Lnum + width + 4));
#else
    LYbox(form_window, FALSE);
#endif /* VMS */
    wrefresh(form_window);
#endif /* USE_SLANG */
    Cptr = NULL;

    /*
     *	Loop on user input.
     */
    while (cmd != LYK_ACTIVATE) {
	/*
	 *  Unreverse cur choice.
	 */
	if (Cptr != NULL) {
	    sprintf(Cnum, "%s%d: ",
			  ((num_choices > 8 && i < 9) ?
						  " " : ""),
			  (i + 1));
#ifdef USE_SLANG
	    SLsmg_gotorc((top + ((i + 1) - window_offset)), (lx - 1 + 2));
	    addstr(Cnum);
	    SLsmg_write_nstring(Cptr[i], width);
#else
	    wmove(form_window, ((i + 1) - window_offset), 2);
	    waddstr(form_window, Cnum);
	    waddstr(form_window, Cptr[i]);
#endif /* USE_SLANG */
	}
	Cptr = choices;
	i = cur_choice;
	sprintf(Cnum, "%s%d: ",
		      ((num_choices > 8 && i < 9) ?
					      " " : ""),
		      (i + 1));
#ifdef USE_SLANG
	SLsmg_gotorc((top + ((i + 1) - window_offset)), (lx - 1 + 2));
	addstr(Cnum);
	SLsmg_set_color(2);
	SLsmg_write_nstring(Cptr[i], width);
	SLsmg_set_color(0);
	/*
	 *  If LYShowCursor is ON, move the cursor to the left
	 *  of the current choice, so that blind users, who are
	 *  most likely to have LYShowCursor ON, will have it's
	 *  string spoken or passed to the braille interface as
	 *  each choice is made current.  Otherwise, move it to
	 *  the bottom, right column of the screen, to "hide"
	 *  the cursor as for the main document, and let sighted
	 *  users rely on the current choice's highlighting or
	 *  color without the distraction of a blinking cursor
	 *  in the window. - FM
	 */
	if (LYShowCursor)
	    SLsmg_gotorc((top + ((i + 1) - window_offset)), (lx - 1 + 1));
	else
	    SLsmg_gotorc((LYlines - 1), (LYcols - 1));
	SLsmg_refresh();
#else
	wmove(form_window, ((i + 1) - window_offset), 2);
	waddstr(form_window, Cnum);
	wstart_reverse(form_window);
	waddstr(form_window, Cptr[i]);
	wstop_reverse(form_window);
	/*
	 *  If LYShowCursor is ON, move the cursor to the left
	 *  of the current choice, so that blind users, who are
	 *  most likely to have LYShowCursor ON, will have it's
	 *  string spoken or passed to the braille interface as
	 *  each choice is made current.  Otherwise, leave it to
	 *  the right of the current choice, since we can't move
	 *  it out of the window, and let sighted users rely on
	 *  the highlighting of the current choice without the
	 *  distraction of a blinking cursor preceding it. - FM
	 */
	if (LYShowCursor)
	    wmove(form_window, ((i + 1) - window_offset), 1);
	wrefresh(form_window);
#endif /* USE_SLANG  */

	term_options = FALSE;
	c = LYgetch_for(FOR_CHOICE);
	if (term_options || c == 3 || c == 7) {
	    cmd = LYK_QUIT;
#ifndef USE_SLANG
	} else if (c == MOUSE_KEY) {
	    if ((cmd = fancy_mouse(form_window, i + 1 + window_offset, &cur_choice)) < 0)
		goto redraw;
	    if  (cmd == LYK_ACTIVATE)
		break;
#endif
	} else {
	    cmd = keymap[c+1];
	}
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    cmd = LYK_QUIT;
	}
#endif /* VMS */

	switch(cmd) {
	    case LYK_F_LINK_NUM:
		c = '\0';
	    case LYK_1:
	    case LYK_2:
	    case LYK_3:
	    case LYK_4:
	    case LYK_5:
	    case LYK_6:
	    case LYK_7:
	    case LYK_8:
	    case LYK_9:
		/*
		 *  Get a number from the user, possibly with
		 *  a 'g' or 'p' suffix (which will be loaded
		 *  into c). - FM & LE
		 */
		number = get_popup_choice_number((int *)&c);

		/*
		 *  Check for a 'p' suffix. - FM
		 */
		if (c == 'p') {
		    /*
		     *	Treat 1 or less as the first page. - FM
		     */
		    if (number <= 1) {
			if (window_offset == 0) {
			    HTUserMsg(ALREADY_AT_CHOICE_BEGIN);
			    if (disabled) {
				_statusline(CHOICE_LIST_UNM_MSG);
			    } else {
				_statusline(CHOICE_LIST_MESSAGE);
			    }
			    break;
			}
			window_offset = 0;
			cur_choice = 0;
			if (disabled) {
			    _statusline(CHOICE_LIST_UNM_MSG);
			} else {
			    _statusline(CHOICE_LIST_MESSAGE);
			}
			goto redraw;
		    }

		    /*
		     *	Treat a number equal to or greater than the
		     *	number of pages as the last page. - FM
		     */
		    if (number >= npages) {
			if (window_offset >= ((num_choices - length) + 1)) {
			    HTUserMsg(ALREADY_AT_CHOICE_END);
			    if (disabled) {
				_statusline(CHOICE_LIST_UNM_MSG);
			    } else {
				_statusline(CHOICE_LIST_MESSAGE);
			    }
			    break;
			}
			window_offset = ((npages - 1) * length);
			if (window_offset > (num_choices - length)) {
			    window_offset = (num_choices - length + 1);
			}
			if (cur_choice < window_offset)
			    cur_choice = window_offset;
			if (disabled) {
			    _statusline(CHOICE_LIST_UNM_MSG);
			} else {
			    _statusline(CHOICE_LIST_MESSAGE);
			}
			goto redraw;
		    }

		    /*
		     *	We want an intermediate page. - FM
		     */
		    if (((number - 1) * length) == window_offset) {
			sprintf(buffer, ALREADY_AT_CHOICE_PAGE, number);
			HTUserMsg(buffer);
			if (disabled) {
			    _statusline(CHOICE_LIST_UNM_MSG);
			} else {
			    _statusline(CHOICE_LIST_MESSAGE);
			}
			break;
		    }
		    cur_choice = window_offset = ((number - 1) * length);
		    if (disabled) {
			_statusline(CHOICE_LIST_UNM_MSG);
		    } else {
			_statusline(CHOICE_LIST_MESSAGE);
		    }
		    goto redraw;

		}

		/*
		 *  Check for a positive number, which signifies
		 *  that a choice should be sought. - FM
		 */
		if (number > 0) {
		    /*
		     *	Decrement the number so as to correspond
		     *	with our cur_choice values. - FM
		     */
		    number--;

		    /*
		     *	If the number is in range and had no legal
		     *	suffix, select the indicated choice. - FM
		     */
		    if (number <= num_choices && c == '\0') {
			cur_choice = number;
			cmd = LYK_ACTIVATE;
			break;
		    }

		    /*
		     *	Verify that we had a 'g' suffix,
		     *	and act on the number. - FM
		     */
		    if (c == 'g') {
			if (cur_choice == number) {
			    /*
			     *	The choice already is current. - FM
			     */
			    sprintf(buffer,
				    CHOICE_ALREADY_CURRENT, (number + 1));
			    HTUserMsg(buffer);
			    if (disabled) {
				_statusline(CHOICE_LIST_UNM_MSG);
			    } else {
				_statusline(CHOICE_LIST_MESSAGE);
			    }
			    break;
			}

			if (number <= num_choices) {
			    /*
			     *	The number is in range and had a 'g'
			     *	suffix, so make it the current choice,
			     *	scrolling if needed. - FM
			     */
			    j = (number - cur_choice);
			    cur_choice = number;
			    if ((j > 0) &&
				(cur_choice - window_offset) >= length) {
				window_offset += j;
				if (window_offset > (num_choices - length + 1))
				    window_offset = (num_choices - length + 1);
			    } else if ((cur_choice - window_offset) < 0) {
				window_offset -= abs(j);
				if (window_offset < 0)
				    window_offset = 0;
			    }
			    if (disabled) {
				_statusline(CHOICE_LIST_UNM_MSG);
			    } else {
				_statusline(CHOICE_LIST_MESSAGE);
			    }
			    goto redraw;
			}

			/*
			 *  Not in range. - FM
			 */
			HTUserMsg(BAD_CHOICE_NUM_ENTERED);
		    }
		}

		/*
		 *  Restore the popup statusline. - FM
		 */
		if (disabled) {
		    _statusline(CHOICE_LIST_UNM_MSG);
		} else {
		    _statusline(CHOICE_LIST_MESSAGE);
		}
		break;

	    case LYK_PREV_LINK:
	    case LYK_UP_LINK:

		if (cur_choice > 0)
		    cur_choice--;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset--;
		    goto redraw;
		}
		break;

	    case LYK_NEXT_LINK:
	    case LYK_DOWN_LINK:
		if (cur_choice < num_choices)
		    cur_choice++;

		/*
		 *  Scroll the window down if necessary
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset++;
		    goto redraw;
		}
		break;

	    case LYK_NEXT_PAGE:
		/*
		 *  Okay, are we on the last page of the choices list?
		 *  If not then,
		 */
		if (window_offset != (num_choices - length + 1)) {
		    /*
		     *	Modify the current choice to not be a
		     *	coordinate in the list, but a coordinate
		     *	on the item selected in the window.
		     */
		    cur_choice -= window_offset;

		    /*
		     *	Page down the proper length for the list.
		     *	If simply to far, back up.
		     */
		    window_offset += length;
		    if (window_offset > (num_choices - length)) {
			window_offset = (num_choices - length + 1);
		    }

		    /*
		     *	Readjust the current choice to be a choice
		     *	list coordinate rather than window.
		     *	Redraw this thing.
		     */
		    cur_choice += window_offset;
		    goto redraw;
		}
		else if (cur_choice < num_choices) {
		    /*
		     *	Already on last page of the choice list so
		     *	just redraw it with the last item selected.
		     */
		    cur_choice = num_choices;
		}
		break;

	    case LYK_PREV_PAGE:
		/*
		 *  Are we on the first page of the choice list?
		 *  If not then,
		 */
		if (window_offset != 0) {
		    /*
		     *	Modify the current choice to not be a choice
		     *	list coordinate, but a window coordinate.
		     */
		    cur_choice -= window_offset;

		    /*
		     *	Page up the proper length.
		     *	If too far, back up.
		     */
		    window_offset -= length;
		    if (window_offset < 0) {
			window_offset = 0;
		    }

		    /*
		     *	Readjust the current choice.
		     */
		    cur_choice += window_offset;
		    goto redraw;
		} else if (cur_choice > 0) {
		    /*
		     *	Already on the first page so just
		     *	back up to the first item.
		     */
		    cur_choice = 0;
		}
		break;

	    case LYK_HOME:
		cur_choice = 0;
		if (window_offset > 0) {
		    window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_END:
		cur_choice = num_choices;
		if (window_offset != (num_choices - length + 1)) {
		    window_offset = (num_choices - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_DOWN_TWO:
		cur_choice += 2;
		if (cur_choice > num_choices)
		    cur_choice = num_choices;

		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += 2;
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_UP_TWO:
		cur_choice -= 2;
		if (cur_choice < 0)
		    cur_choice = 0;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= 2;
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_DOWN_HALF:
		cur_choice += (length/2);
		if (cur_choice > num_choices)
		    cur_choice = num_choices;

		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += (length/2);
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_UP_HALF:
		cur_choice -= (length/2);
		if (cur_choice < 0)
		    cur_choice = 0;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= (length/2);
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_REFRESH:
		lynx_force_repaint();
		refresh();
		break;

	    case LYK_NEXT:
		if (recall && *prev_target_buffer == '\0') {
		    /*
		     *	We got a 'n'ext command with no prior query
		     *	specified within the popup window.  See if
		     *	one was entered when the popup was retracted,
		     *	and if so, assume that's what's wanted.  Note
		     *	that it will become the default within popups,
		     *	unless another is entered within a popup.  If
		     *	the within popup default is to be changed at
		     *	that point, use WHEREIS ('/') and enter it,
		     *	or the up- or down-arrow keys to seek any of
		     *	the previously entered queries, regardless of
		     *	whether they were entered within or outside
		     *	of a popup window. - FM
		     */
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      0)) != NULL) {
			strcpy(prev_target_buffer, cp);
			QueryNum = 0;
			FirstRecall = FALSE;
		    }
		}
		strcpy(prev_target, prev_target_buffer);
	    case LYK_WHEREIS:
		if (*prev_target == '\0' ) {
		    _statusline(ENTER_WHEREIS_QUERY);
		    if ((ch = LYgetstr(prev_target, VISIBLE,
				       sizeof(prev_target_buffer),
				       recall)) < 0) {
			/*
			 *  User cancelled the search via ^G. - FM
			 */
			HTInfoMsg(CANCELLED);
			goto restore_popup_statusline;
		    }
		}

check_recall:
		if (*prev_target == '\0' &&
		    !(recall && (ch == UPARROW || ch == DNARROW))) {
		    /*
		     *	No entry.  Simply break.   - FM
		     */
		    HTInfoMsg(CANCELLED);
		    goto restore_popup_statusline;
		}

		if (recall && ch == UPARROW) {
		    if (FirstRecall) {
			/*
			 *  Use the current string or
			 *  last query in the list. - FM
			 */
			FirstRecall = FALSE;
			if (*prev_target_buffer) {
			    for (QueryNum = (QueryTotal - 1);
				 QueryNum > 0; QueryNum--) {
				if ((cp = (char *)HTList_objectAt(
							search_queries,
							QueryNum)) != NULL &&
				    !strcmp(prev_target_buffer, cp)) {
				    break;
				}
			    }
			} else {
			    QueryNum = 0;
			}
		    } else {
			/*
			 *  Go back to the previous query in the list. - FM
			 */
			QueryNum++;
		    }
		    if (QueryNum >= QueryTotal)
			/*
			 *  Roll around to the last query in the list. - FM
			 */
			QueryNum = 0;
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			strcpy(prev_target, cp);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer && QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				      QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
				sizeof(prev_target_buffer), recall)) < 0) {
			    /*
			     *	User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
		    }
		} else if (recall && ch == DNARROW) {
		    if (FirstRecall) {
		    /*
		     *	Use the current string or
		     *	first query in the list. - FM
		     */
		    FirstRecall = FALSE;
		    if (*prev_target_buffer) {
			for (QueryNum = 0;
			     QueryNum < (QueryTotal - 1); QueryNum++) {
			    if ((cp = (char *)HTList_objectAt(
							search_queries,
							QueryNum)) != NULL &&
				!strcmp(prev_target_buffer, cp)) {
				    break;
			    }
			}
		    } else {
			QueryNum = (QueryTotal - 1);
		    }
		} else {
		    /*
		     *	Advance to the next query in the list. - FM
		     */
		    QueryNum--;
		}
		if (QueryNum < 0)
		    /*
		     *	Roll around to the first query in the list. - FM
		     */
		    QueryNum = (QueryTotal - 1);
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			strcpy(prev_target, cp);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer &&
				    QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				    QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
					   sizeof(prev_target_buffer),
					   recall)) < 0) {
			    /*
			     * User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
		    }
		}
		/*
		 *  Replace the search string buffer with the new target. - FM
		 */
		strcpy(prev_target_buffer, prev_target);
		HTAddSearchQuery(prev_target_buffer);

		/*
		 *  Start search at the next choice. - FM
		 */
		for (j = 1; Cptr[i+j] != NULL; j++) {
		    sprintf(buffer, "%s%d: %s",
				    ((num_choices > 8 && (j + i) < 9) ?
								  " " : ""),
				    (i + j + 1),
				    Cptr[i+j]);
		    if (case_sensitive) {
			if (strstr(buffer, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(buffer, prev_target_buffer) != NULL)
			    break;
		    }
		}
		if (Cptr[i+j] != NULL) {
		    /*
		     *	We have a hit, so make that choice the current. - FM
		     */
		    cur_choice += j;
		    /*
		     *	Scroll the window down if necessary.
		     */
		    if ((cur_choice - window_offset) >= length) {
			window_offset += j;
			if (window_offset > (num_choices - length + 1))
			    window_offset = (num_choices - length + 1);
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
		}

		/*
		 *  If we started at the beginning, it can't be present. - FM
		 */
		if (cur_choice == 0) {
		    HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
		    goto restore_popup_statusline;
		}

		/*
		 *  Search from the beginning to the current choice. - FM
		 */
		for (j = 0; j < cur_choice; j++) {
		    sprintf(buffer, "%s%d: %s",
				    ((num_choices > 8 && j < 9) ?
							    " " : ""),
				    (j + 1),
				    Cptr[j]);
		    if (case_sensitive) {
			if (strstr(buffer, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(buffer, prev_target_buffer) != NULL)
			    break;
		    }
		}
		if (j < cur_choice) {
		    /*
		     *	We have a hit, so make that choice the current. - FM
		     */
		    j = (cur_choice - j);
		    cur_choice -= j;
		    /*
		     *	Scroll the window up if necessary.
		     */
		    if ((cur_choice - window_offset) < 0) {
			window_offset -= j;
			if (window_offset < 0)
			    window_offset = 0;
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
		}

		/*
		 *  Didn't find it in the preceding choices either. - FM
		 */
		HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);

restore_popup_statusline:
		/*
		 *  Restore the popup statusline and
		 *  reset the search variables. - FM
		 */
		if (disabled)
		    _statusline(CHOICE_LIST_UNM_MSG);
		else
		    _statusline(CHOICE_LIST_MESSAGE);
		*prev_target = '\0';
		QueryTotal = (search_queries ? HTList_count(search_queries)
					     : 0);
		recall = ((QueryTotal >= 1) ? RECALL : NORECALL);
		QueryNum = QueryTotal;
		if (ReDraw == TRUE) {
		    ReDraw = FALSE;
		    goto redraw;
		}
		break;

	    case LYK_QUIT:
	    case LYK_ABORT:
	    case LYK_PREV_DOC:
		cur_choice = orig_choice;
		term_options = TRUE;
		HTUserMsg(CANCELLED);
		cmd = LYK_ACTIVATE; /* to exit */
		break;
	}
a2069 6
#ifndef USE_SLANG
    delwin(form_window);
#ifdef NCURSES
    LYsubwindow(0);
#endif
#endif /* !USE_SLANG */
d2073 1
a2073 2
	return(orig_choice);
    } else {
a2074 1
	return(cur_choice);
d2076 1
a2079 1

a2088 1
#define NOTEMPTY(text) (text && text[0]) ? text : ""
d2119 1
a2119 1
static char * cookies_string		= "cookies";
d2123 3
a2125 3
static char * x_display_string		= "display";
static char * editor_string		= "editor";
static char * emacs_keys_string		= "emacs_keys";
d2127 1
a2127 1
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
d2139 1
a2139 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d2142 1
a2142 1
static char * kblayout_string		= "kblayout";
d2144 1
a2144 1
static char * keypad_mode_string	= "keypad_mode";
d2148 1
a2148 1
	{ LINKS_AND_FORM_FIELDS_ARE_NUMBERED,
d2151 3
d2155 3
a2157 3
static char * lineedit_style_string	= "lineedit_style";
static char * mail_address_string	= "mail_address";
static char * search_type_string	= "search_type";
d2162 1
d2164 1
a2164 1
static char * show_color_string		= "show_color";
d2172 23
a2194 2
static char * show_cursor_string	= "show_cursor";
static char * user_mode_string		= "user_mode";
d2200 13
a2212 1
static char * vi_keys_string		= "vi_keys";
d2217 1
a2217 1
static char * DTD_recovery_string      = "DTD";
d2223 2
a2224 1
static char * select_popups_string     = "select_popups";
d2226 4
a2229 4
static char * images_ignore_all_string  = "ignore";
static char * images_use_label_string   = "as labels";
static char * images_use_links_string   = "as links";
static char * verbose_images_string    = "verbose_images";
d2239 7
a2245 4
static char * mbm_advanced_string	= "ADVANCED";
static char * mbm_off_string		= "OFF";
static char * mbm_standard_string	= "STANDARD";
static char * mbm_string		= "multi_bookmarks_mode";
d2251 3
a2253 3
static char * assume_char_set_string	= "assume_char_set";
static char * display_char_set_string	= "display_char_set";
static char * raw_mode_string		= "raw_mode";
d2258 2
a2259 1
static char * show_dotfiles_string	= "show_dotfiles";
d2261 3
a2263 3
static char * dired_sort_string		= "dired_sort";
static OptValues dired_values[] = {
	{ 0,			"Directories first",	"dired_dir" },
d2267 14
d2282 2
a2283 1
static char * ftp_sort_string = "ftp_sort";
d2291 11
d2305 3
a2307 6
static char * preferred_doc_char_string = "preferred_doc_char";
static char * preferred_doc_lang_string = "preferred_doc_lang";
static char * user_agent_string		= "user_agent";

#define PutLabel(fp, text) \
	fprintf(fp,"  %-33s: ", text)
d2312 1
a2312 1
		(int) Size, Name, Value, disable)
d2318 1
a2318 1
	fprintf(fp,"<select name=\"%s\">\n", text)
d2321 1
a2321 1
	fprintf(fp,"<select name=\"%s\" %s>\n", text, DISABLED(flag))
d2332 6
a2337 4
	PutOption(fp,
	    value == table->value,
	    table->HtmlName,
	    table->LongName);
d2348 1
a2348 1
	if (!strcmp(value, table->HtmlName)) {
d2368 1
a2368 1
    char *,	data)
d2370 1
a2370 1
    char * p = data;
d2374 1
a2374 1
    if (p==NULL || p[0]=='\0')
d2377 5
a2381 2
    q = calloc(sizeof(PostPair), 1);
    if (q==NULL)
d2414 1
a2414 1
		    && isalnum(q[count].value[i+2])) {
a2418 1

d2425 1
d2433 1
a2433 1
	if (q==NULL)
d2435 2
a2436 2
	q[count].tag=NULL;
    } while (p!=NULL && p[0]!='\0');
d2441 1
d2475 1
a2475 1
    document *,		newdoc)
d2498 6
a2503 1
	if (!no_bookmark)
d2505 2
a2506 3
	else /* anonymous */
	   HTAlert(BOOKMARK_CHANGE_DISALLOWED);
	return(NULLFILE);
d2509 1
d2511 2
a2512 3
    /*-------------------------------------------------
     * kludge gen_options() call:
     *--------------------------------------------------*/
d2514 9
a2522 4
    if (strstr(newdoc->address, "LYNXOPTIONS:/") && !newdoc->post_data) {
	int status = gen_options(&newdoc->address);
	if (status == NOT_FOUND)
	    return(NOT_FOUND);
d2524 1
a2524 1
	/* exit to getfile() cyrcle */
d2534 4
d2541 13
a2553 2

    data = break_data(newdoc->post_data);
d2557 4
a2560 1
	 * Paranoid security.
d2564 2
d2567 2
a2568 1
		 * FIXME: We've been spoofed message here.
d2570 4
d2601 2
d2614 1
a2614 1
	    if ((emacs_keys = code) != FALSE) {
d2622 1
a2622 1
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
d2630 1
a2630 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d2639 5
d2648 1
a2648 1
	if (!strcmp(data[i].tag, lineedit_style_string)) {
d2653 1
a2653 1
	       if (j==newval)  current_lineedit = newval;
d2664 1
a2664 1
	       if (j==newval)  current_layout = newval;
d2678 1
a2678 1
	    case_sensitive = code;
d2694 1
a2694 1
	    LYSelectPopups = code;
d2700 4
a2703 2
	 && GetOptValues(show_color_values, data[i].value, &LYShowColor)) {
	    LYChosenShowColor = LYShowColor;
d2709 1
a2709 1
	    SLtt_Use_Ansi_Colors = (LYShowColor > 1 ? 1 : 0);
d2717 1
a2717 1
	    LYShowCursor = code;
d2720 18
d2748 4
d2756 2
a2757 2
		 pseudo_inline_alts = FALSE;
		 clickable_images = FALSE;
d2761 2
a2762 2
		 pseudo_inline_alts = TRUE;
		 clickable_images = FALSE;
d2775 1
a2775 1
		verbose_img = code;
d2783 1
a2783 1
	    if ((vi_keys = code) != FALSE) {
d2792 1
a2792 9
	    if (!strcmp(data[i].value, mbm_off_string)) {
		LYMultiBookmarks = FALSE;
	    } else if (!strcmp(data[i].value, mbm_standard_string)) {
		LYMultiBookmarks = TRUE;
		LYMBMAdvanced = FALSE;
	    } else if (!strcmp(data[i].value, mbm_advanced_string)) {
		LYMultiBookmarks = TRUE;
		LYMBMAdvanced = TRUE;
	    }
d2833 1
a2833 1
	    LYRawMode = code;
d2844 6
a2849 1
	/* Local Directory Sort: SELECT */
d2851 1
a2851 1
	    GetOptValues(dired_values, data[i].value, &dir_list_style);
d2853 1
d2859 7
a2865 1
	    show_dotfiles = code;
d2896 2
a2897 4
		if (LYUserAgent && *LYUserAgent &&
		   !strstr(LYUserAgent, "Lynx") &&
		   !strstr(LYUserAgent, "lynx")) {
		    HTAlert(UA_COPYRIGHT_WARNING);
d2912 25
a2936 19
       if (display_char_set_old != current_char_set) {
		/*
		 *  Set the LYUseDefaultRawMode value and character
		 *  handling if LYRawMode was changed. - FM
		 */
		LYUseDefaultRawMode = TRUE;
		HTMLUseCharacterSet(current_char_set);
	    }
	if (assume_char_set_changed) {
		LYRawMode = (UCLYhndl_for_unspec == current_char_set);
	    }
       if (raw_mode_old != LYRawMode || assume_char_set_changed) {
		/*
		 *  Set the raw 8-bit or CJK mode defaults and
		 *  character set if changed. - FM
		 */
		HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
		HTMLSetCharacterHandling(current_char_set);
	    }
d2944 1
a2944 1
    FREE(newdoc->post_data);
d2947 4
a2950 3
	_statusline(SAVING_OPTIONS);
	if (save_rc()) {
	    _statusline(OPTIONS_SAVED);
d2960 5
a2964 5
    CTRACE(tfp, "\nLYOptions.c/postoptions(): exiting...\n");
    CTRACE(tfp, "                            need_reload = %s\n",
                    need_reload ? "TRUE" : "FALSE");
    CTRACE(tfp, "                            need_end_reload = %s\n",
                    need_end_reload ? "TRUE" : "FALSE");
d3012 1
a3012 1
       return(NOT_FOUND);
d3026 1
a3026 1
	  strncmp(newdoc->address, "lynxcgi:", 8) == 0))) {
d3044 1
a3044 1
	CTRACE(tfp, "LYOptions.c/postoptions(): now really exit.\n\n");
d3053 1
a3053 8
#ifndef USE_PSRC
	    HTOutputFormat = WWW_SOURCE;
#else
	    if (LYpsrc)
		psrc_view = TRUE;
	    else
		HTOutputFormat = WWW_SOURCE;
#endif
d3058 4
a3061 2
	    if (HTreparse_document()) {
		CTRACE(tfp, "LYOptions.c/postoptions(): now really exit.\n\n");
d3066 9
d3079 1
a3079 1
	CTRACE(tfp, "LYOptions.c/postoptions(): now really exit.\n\n");
d3090 6
a3095 1
	sprintf(secure_value, "%ld", (long)secure_value + (long)time(0));
d3102 70
a3171 1
 * Okay, someone wants to change options.  So, lets gen up a form for them
d3185 2
a3186 4
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    BOOLEAN can_do_colors;
#endif
    static char tempfile[LY_MAXPATH];
d3189 1
a3189 1
    size_t text_len = COLS - 38;	/* cf: PutLabel */
d3191 1
a3191 4
    LYRemoveTemp(tempfile);
    fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
    if (fp0 == NULL) {
	HTAlert(UNABLE_TO_OPEN_TEMPFILE);
a3192 1
    }
d3196 12
d3210 9
d3224 1
a3224 1
    fprintf(fp0,"<form action=\"LYNXOPTIONS:\" method=\"post\">\n");
d3230 2
a3231 2
    fprintf(fp0,"<input name=\"%s\" type=\"hidden\" value=\"%s\">\n",
	    secure_string, NewSecureValue());
d3239 5
a3243 3
    fprintf(fp0,"<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
    fprintf(fp0,"<input type=\"reset\" value=\"%s\">\n", RESET_CHANGES);
    fprintf(fp0,"%s\n", CANCEL_CHANGES);
d3249 7
a3255 3
	fprintf(fp0, "<p align=center>%s: ", SAVE_OPTIONS);
	fprintf(fp0, "<input type=\"checkbox\" name=\"%s\">\n",
		save_options_string);
d3262 23
a3284 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Personal Preferences"));
d3287 1
a3287 1
    PutLabel(fp0, gettext("Cookies"));
d3290 2
a3291 2
	      cookies_ignore_all_string,
	      cookies_ignore_all_string);
d3293 2
a3294 2
	      cookies_up_to_user_string,
	      cookies_up_to_user_string);
d3296 2
a3297 2
	      cookies_accept_all_string,
	      cookies_accept_all_string);
d3300 22
a3321 4
    /* Editor: INPUT */
    PutLabel(fp0, gettext("Editor"));
    PutTextInput(fp0, editor_string, NOTEMPTY(editor), text_len,
		DISABLED(no_editor || system_editor));
d3324 1
a3324 1
    PutLabel(fp0, gettext("Emacs keys"));
d3329 4
a3332 4
    /* Keypad Mode: SELECT */
    PutLabel(fp0, gettext("Keypad mode"));
    BeginSelect(fp0, keypad_mode_string);
    PutOptValues(fp0, keypad_mode, keypad_mode_values);
d3337 2
a3338 2
	PutLabel(fp0, "Line edit style");
	BeginSelect(fp0, lineedit_style_string);
d3349 1
a3349 1
    PutLabel(fp0, "Keyboard layout");
d3354 1
a3354 1
	PutOption(fp0, i==current_layout, temp, LYKbLayoutNames[i]);
d3359 5
a3363 72
    /* Mail Address: INPUT */
    PutLabel(fp0, gettext("Personal mail address"));
    PutTextInput(fp0, mail_address_string,
		NOTEMPTY(personal_mail_address), text_len, "");

    /* Search Type: SELECT */
    PutLabel(fp0, gettext("Searching type"));
    BeginSelect(fp0, search_type_string);
    PutOptValues(fp0, case_sensitive, search_type_values);
    EndSelect(fp0);

    /* Show Color: SELECT */
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    can_do_colors = 1;
#if defined(COLOR_CURSES)
    can_do_colors = has_colors();
#endif
    PutLabel(fp0, gettext("Show color"));
    MaybeSelect(fp0, !can_do_colors, show_color_string);
    if (no_option_save) {
	if (LYShowColor == SHOW_COLOR_NEVER) {
	    LYShowColor = SHOW_COLOR_OFF;
	} else if (LYShowColor == SHOW_COLOR_ALWAYS) {
	    LYShowColor = SHOW_COLOR_ON;
	}
	PutOptValues(fp0, LYShowColor, bool_values);
    } else {
	if (LYChosenShowColor == SHOW_COLOR_UNKNOWN) {
	    switch (LYrcShowColor) {
	    case SHOW_COLOR_NEVER:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
			SHOW_COLOR_ON : SHOW_COLOR_NEVER;
		break;
	    case SHOW_COLOR_ALWAYS:
		if (!can_do_colors)
		    LYChosenShowColor = SHOW_COLOR_ALWAYS;
		else
		    LYChosenShowColor =
			(LYShowColor >= SHOW_COLOR_ON) ?
				SHOW_COLOR_ALWAYS : SHOW_COLOR_OFF;
		break;
	    default:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
			SHOW_COLOR_ON : SHOW_COLOR_OFF;
	    }
	}
	show_color_values[3].LongName = (can_do_colors) ? always_string
							: "Always try";
	PutOptValues(fp0, LYChosenShowColor, show_color_values);
    }
    EndSelect(fp0);
#endif /* USE_SLANG || COLOR_CURSES */

    /* Show cursor: ON/OFF */
    PutLabel(fp0, gettext("Show cursor"));
    BeginSelect(fp0, show_cursor_string);
    PutOptValues(fp0, LYShowCursor, bool_values);
    EndSelect(fp0);

    /* User Mode: SELECT */
    PutLabel(fp0, gettext("User mode"));
    BeginSelect(fp0, user_mode_string);
    PutOptValues(fp0, user_mode, user_mode_values);
    EndSelect(fp0);

    /* VI Keys: ON/OFF */
    PutLabel(fp0, gettext("VI keys"));
    BeginSelect(fp0, vi_keys_string);
    PutOptValues(fp0, vi_keys, bool_values);
    EndSelect(fp0);
d3366 1
a3366 1
    PutLabel(fp0, gettext("Display character set"));
d3372 1
a3372 1
	   cset_len = len;
d3374 3
a3380 9
    /* X Display: INPUT */
    PutLabel(fp0, gettext("X Display"));
    PutTextInput(fp0, x_display_string, NOTEMPTY(x_display), text_len, "");

    /*
     * Document Layout
     */
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Document Layout"));

a3381 1
    /* if (user_mode==ADVANCED_MODE) */
d3392 1
a3392 1
	    /* ok, LYRawMode, so use UCAssume_MIMEcharset */
d3395 1
a3395 1
	PutLabel(fp0, gettext("Assumed document character set"));
d3398 6
a3403 3
	    PutOption(fp0, i==curval,
		      LYCharSet_UC[i].MIMEname,
		      LYCharSet_UC[i].MIMEname);
d3409 1
a3409 1
    if (LYHaveCJKCharacterSet)
d3415 4
a3418 3
	PutLabel(fp0, gettext("CJK mode"));
    else
	PutLabel(fp0, gettext("Raw 8-bit"));
d3424 47
a3470 4
    /* HTML error recovery: SELECT */
    PutLabel(fp0, gettext("HTML error recovery"));
    BeginSelect(fp0, DTD_recovery_string);
    PutOptValues(fp0, Old_DTD, DTD_type_values);
d3472 1
d3475 1
a3475 1
    PutLabel(fp0, gettext("Popups for select fields"));
d3480 6
d3487 1
a3487 1
    PutLabel(fp0, gettext("Show images"));
d3490 2
a3491 2
       images_ignore_all_string,
       images_ignore_all_string);
d3493 2
a3494 2
       images_use_label_string,
       images_use_label_string);
d3496 2
a3497 2
       images_use_links_string,
       images_use_links_string);
d3501 1
a3501 1
    PutLabel(fp0, gettext("Verbose images"));
d3507 1
a3507 1
     * Bookmark Options
d3509 2
a3510 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Bookmark Options"));
d3512 4
a3515 15
    /* Multi-Bookmark Mode: SELECT */
    if (!LYMBMBlocked) {
       PutLabel(fp0, gettext("Multi-bookmarks"));
       BeginSelect(fp0, mbm_string);
       PutOption(fp0, !LYMultiBookmarks,
	   mbm_off_string,
	   mbm_off_string);
       PutOption(fp0, LYMultiBookmarks && !LYMBMAdvanced,
	   mbm_standard_string,
	   mbm_standard_string);
       PutOption(fp0, LYMultiBookmarks && LYMBMAdvanced,
	   mbm_advanced_string,
	   mbm_advanced_string);
       EndSelect(fp0);
    }
d3517 4
a3520 2
    /* Bookmarks File Menu: LINK/INPUT */
    if (LYMultiBookmarks) {
d3522 4
a3525 3
	PutLabel(fp0, gettext("Review/edit Bookmarks files"));
	fprintf(fp0, "<a href=\"LYNXOPTIONS://MBM_MENU\">%s</a>\n",
		gettext("Goto multi-bookmark menu"));
d3527 5
a3531 4
    } else {
	PutLabel(fp0, gettext("Bookmarks file"));
	PutTextInput(fp0, single_bookmark_string,
		NOTEMPTY(bookmark_page), text_len, "");
d3535 1
a3535 1
     * File Management Options
d3537 2
a3538 1
    fprintf(fp0,"\n  <em>%s</em>\n", DIRED_MENU_TITLE);
d3541 1
a3541 1
    PutLabel(fp0, gettext("FTP sort criteria"));
d3548 7
a3554 1
    PutLabel(fp0, gettext("Local directory sort criteria"));
d3556 1
a3556 1
    PutOptValues(fp0, dir_list_style, dired_values);
d3558 1
d3563 1
a3563 1
	PutLabel(fp0, gettext("Show dot files"));
d3570 2
a3571 2
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
    PutLabel(fp0, gettext("Execution links"));
d3579 1
a3579 1
	       exec_links_values);
d3584 1
a3584 1
	       exec_links_values);
d3587 9
a3595 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d3598 1
a3598 1
     * Headers transferred to remote server
d3600 2
a3601 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Headers transferred to remote server"));
d3603 7
a3609 4
    /* Preferred Document Character Set: INPUT */
    PutLabel(fp0, gettext("Preferred document character set"));
    PutTextInput(fp0, preferred_doc_char_string,
	    NOTEMPTY(pref_charset), cset_len+2, "");
d3611 10
a3620 4
    /* Preferred Document Language: INPUT */
    PutLabel(fp0, gettext("Preferred document language"));
    PutTextInput(fp0, preferred_doc_lang_string,
	    NOTEMPTY(language), cset_len+2, "");
d3622 5
a3626 6
    /* User Agent: INPUT */
    if (!no_useragent) {
	PutLabel(fp0, gettext("User-Agent header"));
	PutTextInput(fp0, user_agent_string,
		     NOTEMPTY(LYUserAgent), text_len, "");
    }
d3628 4
a3631 3
    if (!LYRestricted) {
	fprintf(fp0,
		"\n  Check your <a href=\"LYNXCFG:\">lynx.cfg</a> here\n");
d3637 6
a3642 4
    fprintf(fp0,"<p align=center>\n");
    fprintf(fp0,"<input type=\"submit\" value=\"%s\">\n - ", ACCEPT_CHANGES);
    fprintf(fp0,"<input type=\"reset\" value=\"%s\">\n", RESET_CHANGES);
    fprintf(fp0,"%s\n", CANCEL_CHANGES);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d3 1
a3 1
#include <HTTP.h>		/* 'reloading' flag */
a23 1
#include <HTFile.h>
d29 1
a29 2
#define TOP_LINK  "/"
#define MBM_LINK  "//MBM_MENU"
d31 2
a32 34
static int LYChosenShowColor = SHOW_COLOR_UNKNOWN;	/* whether to show and save */

static void terminate_options(int sig);

#if !defined(NO_OPTION_MENU) || (defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES)))
#define COL_OPTION_VALUES 36	/* display column where option values start */
#endif

#if defined(USE_SLANG) || defined(COLOR_CURSES)
static BOOLEAN can_do_colors = FALSE;
#endif

BOOLEAN LYCheckUserAgent(void)
{
    if (non_empty(LYUserAgent)) {
	if (strstr(LYUserAgent, "Lynx") == 0
	    && strstr(LYUserAgent, "lynx") == 0
	    && strstr(LYUserAgent, "L_y_n_x") == 0
	    && strstr(LYUserAgent, "l_y_n_x") == 0) {
	    return FALSE;
	}
    }
    return TRUE;
}

static void SetupChosenShowColor(void)
{
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    can_do_colors = TRUE;
#if defined(COLOR_CURSES)
    if (LYCursesON)		/* could crash if called before initialization */
	can_do_colors = (has_colors()
			 ? TRUE
			 : FALSE);
a33 56
    if (!no_option_save) {
	if (LYChosenShowColor == SHOW_COLOR_UNKNOWN) {
	    switch (LYrcShowColor) {
	    case SHOW_COLOR_NEVER:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
		    SHOW_COLOR_ON : SHOW_COLOR_NEVER;
		break;
	    case SHOW_COLOR_ALWAYS:
		if (!can_do_colors)
		    LYChosenShowColor = SHOW_COLOR_ALWAYS;
		else
		    LYChosenShowColor =
			(LYShowColor >= SHOW_COLOR_ON) ?
			SHOW_COLOR_ALWAYS : SHOW_COLOR_OFF;
		break;
	    default:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
		    SHOW_COLOR_ON : SHOW_COLOR_OFF;
	    }
	}
    }
#endif /* USE_SLANG || COLOR_CURSES */
}

static void validate_x_display(void)
{
    char *cp;

    if ((cp = LYgetXDisplay()) != NULL) {
	StrAllocCopy(x_display, cp);
    } else {
	FREE(x_display);
    }
}

static void summarize_x_display(char *display_option)
{
    if ((x_display == NULL && *display_option == '\0') ||
	(x_display != NULL && !strcmp(x_display, display_option))) {
	if (x_display == NULL && LYisConfiguredForX == TRUE) {
	    _statusline(VALUE_ACCEPTED_WARNING_X);
	} else if (x_display != NULL && LYisConfiguredForX == FALSE) {
	    _statusline(VALUE_ACCEPTED_WARNING_NONX);
	} else {
	    _statusline(VALUE_ACCEPTED);
	}
    } else {
	if (*display_option) {
	    _statusline(FAILED_TO_SET_DISPLAY);
	} else {
	    _statusline(FAILED_CLEAR_SET_DISPLAY);
	}
    }
}
d36 5
a40 7
static int boolean_choice(int status,
			  int line,
			  int column,
			  const char **choices);

#define LYChooseBoolean(status, line, column, choices) \
	boolean_choice(status, line, column, (const char **)choices)
d45 1
a45 1
 * Values for the options menu.  - FM
d47 3
a49 3
 * L_foo values are the Y coordinates for the menu item.
 * B_foo values are the X coordinates for the item's prompt string.
 * C_foo values are the X coordinates for the item's value string.
d106 11
a116 11
#define L_Bool_A     (use_assume_charset ? L_BOOL_A     + 1 : L_BOOL_A)
#define L_Bool_B     (use_assume_charset ? L_BOOL_B     + 1 : L_BOOL_B)
#define L_Exec       (use_assume_charset ? L_EXEC       + 1 : L_EXEC)
#define L_Rawmode    (use_assume_charset ? L_RAWMODE    + 1 : L_RAWMODE)
#define L_Charset    (use_assume_charset ? L_CHARSET    + 1 : L_CHARSET)
#define L_Color      (use_assume_charset ? L_COLOR      + 1 : L_COLOR)
#define L_Keypad     (use_assume_charset ? L_KEYPAD     + 1 : L_KEYPAD)
#define L_Lineed     (use_assume_charset ? L_LINEED     + 1 : L_LINEED)
#define L_Layout     (use_assume_charset ? L_LAYOUT     + 1 : L_LAYOUT)
#define L_Dired      (use_assume_charset ? L_DIRED      + 1 : L_DIRED)
#define L_User_Mode  (use_assume_charset ? L_USER_MODE  + 1 : L_USER_MODE)
d122 1
a122 1
static int add_it(char *text, int len)
d126 1
a126 1
	LYaddstr(text);
d132 1
a132 1
 * addlbl() is used instead of plain LYaddstr() in old-style options menu
d135 1
a135 1
static void addlbl(const char *text)
d144 2
a145 2
	    d = add_it(actual, d - 1);
	    lynx_start_bold();
d150 1
a150 1
	    lynx_stop_bold();
d156 1
a156 1
	lynx_stop_bold();
d159 1
a159 16
#if !defined(VMS) || defined(USE_SLANG)
#define HANDLE_LYOPTIONS \
		    if (term_options) { \
			term_options = FALSE; \
		    } else { \
			AddValueAccepted = TRUE; \
		    } \
		    goto draw_options
#else
#define HANDLE_LYOPTIONS \
		    term_options = FALSE; \
		    if (use_assume_charset != old_use_assume_charset) \
			goto draw_options
#endif /* !VMS || USE_SLANG */

void LYoptions(void)
d161 1
a161 63
#define ShowBool(value) LYaddstr((value) ? "ON " : "OFF")
    static const char *bool_choices[] =
    {
	"OFF",
	"ON",
	NULL
    };
    static const char *caseless_choices[] =
    {
	"CASE INSENSITIVE",
	"CASE SENSITIVE",
	NULL
    };
    static const char *dirList_choices[] =
    {
	"Directories first",
	"Files first",
	"Mixed style",
	NULL
    };

#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    static const char *exec_choices[] =
    {
	"ALWAYS OFF",
	"FOR LOCAL FILES ONLY",
#ifndef NEVER_ALLOW_REMOTE_EXEC
	"ALWAYS ON",
#endif				/* !NEVER_ALLOW_REMOTE_EXEC */
	NULL
    };
#endif
    static const char *fileSort_choices[] =
    {
	"By Filename",
	"By Type",
	"By Size",
	"By Date",
	NULL
    };
    static const char *keypad_choices[] =
    {
	"Numbers act as arrows",
	"Links are numbered",
	"Links and form fields are numbered",
	NULL
    };
    static const char *mbm_choices[] =
    {
	"OFF     ",
	"STANDARD",
	"ADVANCED",
	NULL
    };
    static const char *userMode_choices[] =
    {
	"Novice",
	"Intermediate",
	"Advanced",
	NULL
    };

#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
d163 1
a163 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
a164 1

d166 1
a166 1
     * If the user changes the display we need memory to put it in.
d179 1
a179 1
#ifdef ENABLE_OPTS_CHANGE_EXEC
d189 1
a189 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d191 1
a191 1
#ifdef ENABLE_OPTS_CHANGE_EXEC
d201 1
a201 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d215 26
a240 1
	SetupChosenShowColor();
d245 1
a245 1
	use_assume_charset = (BOOL) (user_mode == ADVANCED_MODE);
d247 1
a247 1
  draw_options:
d251 2
a252 2
     * NOTE that printw() should be avoided for strings that might have
     * non-ASCII or multibyte/CJK characters.  - FM
d254 1
d257 1
a257 1
	LYclear();
d259 1
a259 1
	LYerase();
d262 1
a262 1
    LYclear();
d264 1
a264 1
    LYmove(0, 5);
d266 8
a273 8
    lynx_start_h1_color();
    LYaddstr("         Options Menu (");
    LYaddstr(LYNX_NAME);
    LYaddstr(" Version ");
    LYaddstr(LYNX_VERSION);
    LYaddch(')');
    lynx_stop_h1_color();
    LYmove(L_EDITOR, 5);
d275 1
a275 1
    LYaddstr(non_empty(editor) ? editor : "NONE");
d277 1
a277 1
    LYmove(L_DISPLAY, 5);
d279 1
a279 1
    LYaddstr(non_empty(x_display) ? x_display : "NONE");
d281 1
a281 1
    LYmove(L_HOME, 5);
d283 6
a288 3
    LYaddstr(mbm_choices[LYMultiBookmarks]);
    LYmove(L_HOME, B_BOOK);
    if (LYMultiBookmarks != MBM_OFF) {
d292 1
a292 1
	LYaddstr(non_empty(bookmark_page) ? bookmark_page : "NONE");
d295 1
a295 1
    LYmove(L_FTPSTYPE, 5);
d297 4
a300 4
    LYaddstr((HTfileSortMethod == FILE_BY_NAME ? "By Filename" :
	      (HTfileSortMethod == FILE_BY_SIZE ? "By Size    " :
	       (HTfileSortMethod == FILE_BY_TYPE ? "By Type    " :
		"By Date    "))));
d302 1
a302 1
    LYmove(L_MAIL_ADDRESS, 5);
d304 2
a305 2
    LYaddstr(non_empty(personal_mail_address) ?
	     personal_mail_address : "NONE");
d307 1
a307 1
    LYmove(L_SSEARCH, 5);
d309 1
a309 1
    LYaddstr(case_sensitive ? "CASE SENSITIVE  " : "CASE INSENSITIVE");
d311 1
a311 1
    LYmove(L_Charset, 5);
d313 1
a313 1
    LYaddstr(LYchar_set_names[current_char_set]);
d315 1
a315 1
    LYmove(L_LANGUAGE, 5);
d317 1
a317 1
    LYaddstr(non_empty(language) ? language : "NONE");
d319 1
a319 1
    LYmove(L_PREF_CHARSET, 5);
d321 1
a321 1
    LYaddstr(non_empty(pref_charset) ? pref_charset : "NONE");
d324 1
a324 1
	LYmove(L_ASSUME_CHARSET, 5);
d327 1
a327 1
	    LYaddstr(UCAssume_MIMEcharset);
d329 3
a331 3
	    LYaddstr((UCLYhndl_for_unspec >= 0) ?
		     LYCharSet_UC[UCLYhndl_for_unspec].MIMEname
		     : "NONE");
d334 1
a334 1
    LYmove(L_Rawmode, 5);
d336 1
a336 1
    ShowBool(LYRawMode);
d339 1
a339 1
    LYmove(L_Color, B_COLOR);
d342 2
a343 1
	ShowBool(LYShowColor == SHOW_COLOR_OFF);
d347 2
a348 2
	    LYaddstr("NEVER     ");
	    break;
d350 2
a351 2
	    LYaddstr("OFF");
	    break;
d353 2
a354 2
	    LYaddstr("ON ");
	    break;
d357 3
a359 3
	    if (!has_colors())
		LYaddstr("Always try");
	    else
d361 1
a361 1
		LYaddstr("ALWAYS    ");
d366 1
a366 1
    LYmove(L_Bool_A, B_VIKEYS);
d368 1
a368 1
    ShowBool(vi_keys);
d370 1
a370 1
    LYmove(L_Bool_A, B_EMACSKEYS);
d372 1
a372 1
    ShowBool(emacs_keys);
d374 1
a374 1
    LYmove(L_Bool_A, B_SHOW_DOTFILES);
d376 1
a376 1
    ShowBool(!no_dotfiles && show_dotfiles);
d378 1
a378 1
    LYmove(L_Bool_B, B_SELECT_POPUPS);
d380 1
a380 1
    ShowBool(LYSelectPopups);
d382 1
a382 1
    LYmove(L_Bool_B, B_SHOW_CURSOR);
d384 1
a384 1
    ShowBool(LYShowCursor);
d386 1
a386 1
    LYmove(L_Keypad, 5);
d388 5
a392 7
    LYaddstr(fields_are_numbered() && links_are_numbered()
	     ? "Links and form fields are numbered"
	     : links_are_numbered()
	     ? "Links are numbered                "
	     : fields_are_numbered()
	     ? "Form fields are numbered          "
	     : "Numbers act as arrows             ");
d394 1
a394 1
    LYmove(L_Lineed, 5);
d396 1
a396 1
    LYaddstr(LYLineeditNames[current_lineedit]);
d399 1
a399 1
    LYmove(L_Layout, 5);
d401 1
a401 1
    LYaddstr(LYKbLayoutNames[current_layout]);
d405 1
a405 1
    LYmove(L_Dired, 5);
d407 3
a409 3
    LYaddstr((dir_list_style == FILES_FIRST) ? "Files first      " :
	     ((dir_list_style == MIXED_STYLE) ? "Mixed style      " :
	      "Directories first"));
d412 1
a412 1
    LYmove(L_User_Mode, 5);
d414 3
a416 3
    LYaddstr((user_mode == NOVICE_MODE) ? "Novice      " :
	     ((user_mode == INTERMEDIATE_MODE) ? "Intermediate" :
	      "Advanced    "));
d419 1
a419 1
    ShowBool(verbose_img);
d421 1
a421 1
    LYmove(L_User_Agent, 5);
d423 1
a423 1
    LYaddstr(non_empty(LYUserAgent) ? LYUserAgent : "NONE");
d425 2
a426 2
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    LYmove(L_Exec, 5);
d429 3
a431 3
    LYaddstr(local_exec ? "ALWAYS ON           " :
	     (local_exec_on_local_files ? "FOR LOCAL FILES ONLY" :
	      "ALWAYS OFF          "));
d433 2
a434 2
    LYaddstr(local_exec_on_local_files ? "FOR LOCAL FILES ONLY" :
	     "ALWAYS OFF          ");
d436 1
a436 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d438 6
a443 6
    LYmove(LYlines - 3, 2);
    LYaddstr(SELECT_SEGMENT);
    lynx_start_bold();
    LYaddstr(CAP_LETT_SEGMENT);
    lynx_stop_bold();
    LYaddstr(OF_OPT_LINE_SEGMENT);
d445 14
a458 14
	LYaddstr(" '");
	lynx_start_bold();
	LYaddstr(">");
	lynx_stop_bold();
	LYaddstr("'");
	LYaddstr(TO_SAVE_SEGMENT);
    }
    LYaddstr(OR_SEGMENT);
    LYaddstr("'");
    lynx_start_bold();
    LYaddstr("r");
    lynx_stop_bold();
    LYaddstr("'");
    LYaddstr(TO_RETURN_SEGMENT);
d460 1
a460 2
    response = 0;
    while (response != 'R' &&
d463 1
a463 1
	   !LYCharIsINTERRUPT_NO_letter(response)) {
d468 8
a475 8
	LYmove((LYlines - 2), 0);
	lynx_start_prompt_color();
	LYaddstr(COMMAND_PROMPT);
	lynx_stop_prompt_color();

	LYrefresh();
	response = LYgetch_single();
	if (term_options || LYCharIsINTERRUPT_NO_letter(response))
d482 49
a530 11
	case 'E':		/* Change the editor. */
	    if (no_editor) {
		_statusline(EDIT_DISABLED);
	    } else if (system_editor) {
		_statusline(EDITOR_LOCKED);
	    } else {
		if (non_empty(editor))
		    LYstrncpy(display_option, editor, sizeof(display_option) - 1);
		else {		/* clear the NONE */
		    LYmove(L_EDITOR, COL_OPTION_VALUES);
		    LYaddstr("    ");
d534 2
a535 2
		LYmove(L_EDITOR, COL_OPTION_VALUES);
		lynx_start_bold();
d538 4
a541 39
		lynx_stop_bold();
		LYmove(L_EDITOR, COL_OPTION_VALUES);
		if (term_options || ch == -1) {
		    LYaddstr(non_empty(editor) ?
			     editor : "NONE");
		} else if (*display_option == '\0') {
		    FREE(editor);
		    LYaddstr("NONE");
		} else {
		    StrAllocCopy(editor, display_option);
		    LYaddstr(display_option);
		}
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
	    }
	    response = ' ';
	    break;

	case 'D':		/* Change the display. */
	    if (non_empty(x_display)) {
		LYstrncpy(display_option, x_display, sizeof(display_option) - 1);
	    } else {		/* clear the NONE */
		LYmove(L_DISPLAY, COL_OPTION_VALUES);
		LYaddstr("    ");
		*display_option = '\0';
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_DISPLAY, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
	    lynx_stop_bold();
	    LYmove(L_DISPLAY, COL_OPTION_VALUES);

d543 1
a543 1
#define CompareEnvVars(a,b) strcasecomp(a, b)
d545 1
a545 1
#define CompareEnvVars(a,b) strcmp(a, b)
d547 29
a575 4

	    if ((term_options || ch == -1) ||
		(x_display != NULL &&
		 !CompareEnvVars(x_display, display_option))) {
d577 1
a577 2
		 * Cancelled, or a non-NULL display string wasn't changed.  -
		 * FM
d579 21
a599 5
		LYaddstr(non_empty(x_display) ? x_display : "NONE");
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
d601 5
a605 1
		    _statusline(VALUE_ACCEPTED);
d609 5
a613 9
	    } else if (*display_option == '\0') {
		if ((x_display == NULL) ||
		    (x_display != NULL && *x_display == '\0')) {
		    /*
		     * NULL or zero-length display string wasn't changed.  - FM
		     */
		    LYaddstr("NONE");
		    LYclrtoeol();
		    _statusline(VALUE_ACCEPTED);
d617 25
a641 29
	    }
	    /*
	     * Set the new DISPLAY variable.  - FM
	     */
	    LYsetXDisplay(display_option);
	    validate_x_display();
	    cp = NULL;
	    LYaddstr(x_display ? x_display : "NONE");
	    LYclrtoeol();
	    summarize_x_display(display_option);
	    response = ' ';
	    break;

	case 'L':		/* Change multibookmarks option. */
	    if (LYMBMBlocked) {
		_statusline(MULTIBOOKMARKS_DISALLOWED);
		response = ' ';
		break;
	    }
	    if (!LYSelectPopups) {
		LYMultiBookmarks = LYChooseBoolean(LYMultiBookmarks,
						   L_HOME, C_MULTI,
						   mbm_choices);
	    } else {
		LYMultiBookmarks = LYChoosePopup(LYMultiBookmarks,
						 L_HOME, (C_MULTI - 1),
						 mbm_choices,
						 3, FALSE, FALSE);
	    }
d643 5
a647 5
	    if (LYSelectPopups) {
		LYmove(L_HOME, C_MULTI);
		LYclrtoeol();
		LYaddstr(mbm_choices[LYMultiBookmarks]);
	    }
d649 3
d653 1
a653 1
	    if (!LYSelectPopups)
d655 101
a755 5
	    {
		LYmove(L_HOME, B_BOOK);
		LYclrtoeol();
		if (LYMultiBookmarks != MBM_OFF) {
		    LYaddstr(gettext("review/edit B)ookmarks files"));
d757 9
a765 3
		    LYaddstr(gettext("B)ookmark file: "));
		    LYaddstr(non_empty(bookmark_page) ?
			     bookmark_page : "NONE");
d767 12
a778 16
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'B':		/* Change the bookmark page location. */
	    /*
	     * Anonymous users should not be allowed to change the bookmark
	     * page.
	     */
	    if (!no_bookmark) {
		if (LYMultiBookmarks != MBM_OFF) {
		    edit_bookmarks();
		    signal(SIGINT, terminate_options);
d780 3
d784 9
a792 7
		if (non_empty(bookmark_page)) {
		    LYstrncpy(display_option,
			      bookmark_page,
			      sizeof(display_option) - 1);
		} else {	/* clear the NONE */
		    LYmove(L_HOME, C_DEFAULT);
		    LYclrtoeol();
d796 2
a797 2
		LYmove(L_HOME, C_DEFAULT);
		lynx_start_bold();
d800 9
a808 14
		lynx_stop_bold();
		LYmove(L_HOME, C_DEFAULT);
		if (term_options ||
		    ch == -1 || *display_option == '\0') {
		    LYaddstr(non_empty(bookmark_page) ?
			     bookmark_page : "NONE");
		} else if (!LYPathOffHomeOK(display_option,
					    sizeof(display_option))) {
		    LYaddstr(non_empty(bookmark_page) ?
			     bookmark_page : "NONE");
		    LYclrtoeol();
		    _statusline(USE_PATH_OFF_HOME);
		    response = ' ';
		    break;
d810 2
a811 3
		    StrAllocCopy(bookmark_page, display_option);
		    StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
		    LYaddstr(bookmark_page);
d813 1
a813 1
		LYclrtoeol();
d820 19
a838 5
	    } else {		/* anonymous */
		_statusline(BOOKMARK_CHANGE_DISALLOWED);
	    }
	    response = ' ';
	    break;
d840 26
a865 10
	case 'F':		/* Change ftp directory sorting. */
	    if (!LYSelectPopups) {
		HTfileSortMethod = LYChooseBoolean(HTfileSortMethod,
						   L_FTPSTYPE, -1,
						   fileSort_choices);
	    } else {
		HTfileSortMethod = LYChoosePopup(HTfileSortMethod,
						 L_FTPSTYPE, -1,
						 fileSort_choices,
						 4, FALSE, FALSE);
d867 5
a871 3
		LYmove(L_FTPSTYPE, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(fileSort_choices[HTfileSortMethod]);
d873 45
a917 44
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'P':		/* Change personal mail address for From headers. */
	    if (non_empty(personal_mail_address)) {
		LYstrncpy(display_option,
			  personal_mail_address,
			  sizeof(display_option) - 1);
	    } else {		/* clear the NONE */
		LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
		LYaddstr("    ");
		*display_option = '\0';
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
	    lynx_stop_bold();
	    LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
	    if (term_options || ch == -1) {
		LYaddstr((personal_mail_address &&
			  *personal_mail_address) ?
			 personal_mail_address : "NONE");
	    } else if (*display_option == '\0') {
		FREE(personal_mail_address);
		LYaddstr("NONE");
	    } else {
		StrAllocCopy(personal_mail_address, display_option);
		LYaddstr(display_option);
	    }
	    LYclrtoeol();
	    if (ch == -1) {
		HTInfoMsg(CANCELLED);
		HTInfoMsg("");
	    } else {
		_statusline(VALUE_ACCEPTED);
	    }
	    response = ' ';
	    break;
d919 2
a920 25
	case 'S':		/* Change case sensitivity for searches. */
	    case_sensitive = LYChooseBoolean(case_sensitive,
					     L_SSEARCH, -1,
					     caseless_choices);
	    response = ' ';
	    break;

	case '\001':		/* Change assume_charset setting. */
	    if (use_assume_charset) {
		int i, curval;
		const char **assume_list;
		assume_list = typecallocn(const char *, (LYNumCharsets + 1));

		if (!assume_list) {
		    outofmem(__FILE__, "options");
		}
		for (i = 0; i < LYNumCharsets; i++) {
		    assume_list[i] = LYCharSet_UC[i].MIMEname;
		}
		curval = UCLYhndl_for_unspec;
		if (curval == current_char_set && UCAssume_MIMEcharset) {
		    curval = UCGetLYhndl_byMIME(UCAssume_MIMEcharset);
		}
		if (curval < 0)
		    curval = LYRawMode ? current_char_set : 0;
d922 8
a929 31
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		    UCLYhndl_for_unspec =
			assumed_doc_charset_map[(LYChooseBoolean(charset_subsets[curval].assumed_idx,
								 L_ASSUME_CHARSET, -1,
								 assumed_charset_choices)
						 ? 1
						 : 0)];
#else
		    UCLYhndl_for_unspec =
			LYChooseBoolean(curval,
					L_ASSUME_CHARSET, -1,
					assume_list);
#endif
		} else {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		    UCLYhndl_for_unspec =
			assumed_doc_charset_map[(LYChoosePopup(charset_subsets[curval].assumed_idx,
							       L_ASSUME_CHARSET, -1,
							       assumed_charset_choices,
							       0,
							       FALSE,
							       FALSE)
						 ? 1
						 : 0)];
#else
		    UCLYhndl_for_unspec =
			LYChoosePopup(curval,
				      L_ASSUME_CHARSET, -1,
				      assume_list,
				      0, FALSE, FALSE);
#endif
d931 3
a933 4
		    LYmove(L_ASSUME_CHARSET, COL_OPTION_VALUES);
		    LYclrtoeol();
		    if (UCLYhndl_for_unspec >= 0)
			LYaddstr(LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
a935 1

d937 2
a938 2
		 * Set the raw 8-bit or CJK mode defaults and character set if
		 * changed.  - FM
d940 4
a943 11
		if (CurrentAssumeCharSet != UCLYhndl_for_unspec ||
		    UCLYhndl_for_unspec != curval) {
		    if (UCLYhndl_for_unspec != CurrentAssumeCharSet) {
			StrAllocCopy(UCAssume_MIMEcharset,
				     LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
		    }
		    if (HTCJK != JAPANESE)
			LYRawMode = (BOOL) (UCLYhndl_for_unspec == current_char_set);
		    HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
		    HTMLSetCharacterHandling(current_char_set);
		    CurrentAssumeCharSet = UCLYhndl_for_unspec;
d949 3
a951 3
			LYmove(L_Rawmode, COL_OPTION_VALUES);
			LYclrtoeol();
			ShowBool(LYRawMode);
a953 1
		FREE(assume_list);
d956 10
a965 1
		    HANDLE_LYOPTIONS;
d967 1
a967 5
	    } else {
		_statusline(NEED_ADVANCED_USER_MODE);
		AddValueAccepted = FALSE;
	    }
	    break;
d969 24
a992 25
	case 'C':		/* Change display charset setting. */
	    if (!LYSelectPopups) {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		displayed_display_charset_idx = LYChooseBoolean(displayed_display_charset_idx,
								L_Charset, -1,
								display_charset_choices);
		current_char_set = display_charset_map[displayed_display_charset_idx];
#else
		current_char_set = LYChooseBoolean(current_char_set,
						   L_Charset, -1,
						   LYchar_set_names);
#endif
	    } else {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		displayed_display_charset_idx = LYChoosePopup(displayed_display_charset_idx,
							      L_Charset, -1,
							      display_charset_choices,
							      0, FALSE, FALSE);
		current_char_set = display_charset_map[displayed_display_charset_idx];
#else
		current_char_set = LYChoosePopup(current_char_set,
						 L_Charset, -1,
						 LYchar_set_names,
						 0, FALSE, FALSE);
#endif
d994 32
a1025 22
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Charset, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(LYchar_set_names[current_char_set]);
#endif /* VMS || USE_SLANG */
	    }
	    /*
	     * Set the raw 8-bit or CJK mode defaults and character set if
	     * changed.  - FM
	     */
	    if (CurrentCharSet != current_char_set) {
		LYUseDefaultRawMode = TRUE;
		HTMLUseCharacterSet(current_char_set);
		CurrentCharSet = current_char_set;
		CurrentRawMode = LYRawMode;
#if !defined(VMS) && !defined(USE_SLANG)
		if (!LYSelectPopups)
#endif /* !VMS && !USE_SLANG */
		{
		    LYmove(L_Rawmode, COL_OPTION_VALUES);
		    LYclrtoeol();
		    ShowBool(LYRawMode);
d1027 2
a1028 12
#ifdef CAN_SWITCH_DISPLAY_CHARSET
		/* Deduce whether the user wants autoswitch: */
		switch_display_charsets =
		    (current_char_set == auto_display_charset
		     || current_char_set == auto_other_display_charset);
#endif
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
d1030 35
a1064 13
	case 'O':		/* Change raw mode setting. */
	    LYRawMode = LYChooseBoolean(LYRawMode, L_Rawmode, -1, bool_choices);
	    /*
	     * Set the LYUseDefaultRawMode value and character handling if
	     * LYRawMode was changed.  - FM
	     */
	    if (CurrentRawMode != LYRawMode) {
		HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
		HTMLSetCharacterHandling(current_char_set);
		CurrentRawMode = LYRawMode;
	    }
	    response = ' ';
	    break;
d1066 22
a1087 34
	case 'G':		/* Change language preference. */
	    if (non_empty(language)) {
		LYstrncpy(display_option, language, sizeof(display_option) - 1);
	    } else {		/* clear the NONE */
		LYmove(L_LANGUAGE, COL_OPTION_VALUES);
		LYaddstr("    ");
		*display_option = '\0';
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_LANGUAGE, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
	    lynx_stop_bold();
	    LYmove(L_LANGUAGE, COL_OPTION_VALUES);
	    if (term_options || ch == -1) {
		LYaddstr(non_empty(language) ?
			 language : "NONE");
	    } else if (*display_option == '\0') {
		FREE(language);
		LYaddstr("NONE");
	    } else {
		StrAllocCopy(language, display_option);
		LYaddstr(display_option);
	    }
	    LYclrtoeol();
	    if (ch == -1) {
		HTInfoMsg(CANCELLED);
		HTInfoMsg("");
	    } else {
		_statusline(VALUE_ACCEPTED);
	    }
	    response = ' ';
	    break;
d1089 22
a1110 60
	case 'H':		/* Change charset preference. */
	    if (non_empty(pref_charset)) {
		LYstrncpy(display_option,
			  pref_charset,
			  sizeof(display_option) - 1);
	    } else {		/* clear the NONE */
		LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
		LYaddstr("    ");
		*display_option = '\0';
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
	    lynx_stop_bold();
	    LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
	    if (term_options || ch == -1) {
		LYaddstr(non_empty(pref_charset) ?
			 pref_charset : "NONE");
	    } else if (*display_option == '\0') {
		FREE(pref_charset);
		LYaddstr("NONE");
	    } else {
		StrAllocCopy(pref_charset, display_option);
		LYaddstr(display_option);
	    }
	    LYclrtoeol();
	    if (ch == -1) {
		HTInfoMsg(CANCELLED);
		HTInfoMsg("");
	    } else {
		_statusline(VALUE_ACCEPTED);
	    }
	    response = ' ';
	    break;

	case 'V':		/* Change VI keys setting. */
	    vi_keys = LYChooseBoolean(vi_keys,
				      L_Bool_A, C_VIKEYS,
				      bool_choices);
	    if (vi_keys) {
		set_vi_keys();
	    } else {
		reset_vi_keys();
	    }
	    response = ' ';
	    break;

	case 'M':		/* Change emacs keys setting. */
	    emacs_keys = LYChooseBoolean(emacs_keys,
					 L_Bool_A, C_EMACSKEYS,
					 bool_choices);
	    if (emacs_keys) {
		set_emacs_keys();
	    } else {
		reset_emacs_keys();
	    }
	    response = ' ';
	    break;
d1112 4
a1115 41
	case 'W':		/* Change show dotfiles setting. */
	    if (no_dotfiles) {
		_statusline(DOTFILE_ACCESS_DISABLED);
	    } else {
		show_dotfiles = LYChooseBoolean(show_dotfiles,
						L_Bool_A,
						C_SHOW_DOTFILES,
						bool_choices);
	    }
	    response = ' ';
	    break;

	case 'T':		/* Change select popups setting. */
	    LYSelectPopups = LYChooseBoolean(LYSelectPopups,
					     L_Bool_B,
					     C_SELECT_POPUPS,
					     bool_choices);
	    response = ' ';
	    break;

#if defined(USE_SLANG) || defined(COLOR_CURSES)
	case '&':		/* Change show color setting. */
	    if (no_option_save) {
#if defined(COLOR_CURSES)
		if (!has_colors()) {
		    char *terminal = LYGetEnv("TERM");

		    if (terminal)
			HTUserMsg2(COLOR_TOGGLE_DISABLED_FOR_TERM,
				   terminal);
		    else
			HTUserMsg(COLOR_TOGGLE_DISABLED);
		    break;
		}
#endif
		LYShowColor = LYChooseBoolean((LYShowColor - 1),
					      L_Color,
					      C_COLOR,
					      bool_choices);
		if (LYShowColor == 0) {
		    LYShowColor = SHOW_COLOR_OFF;
d1117 14
a1130 1
		    LYShowColor = SHOW_COLOR_ON;
d1132 2
a1133 3
	    } else {		/* !no_option_save */
		BOOLEAN again = FALSE;
		int chosen;
d1135 2
d1138 1
a1138 1
		 * Copy strings into choice array.
d1141 1
a1141 1
		StrAllocCopy(choices[0], "NEVER     ");
d1143 1
a1143 1
		StrAllocCopy(choices[1], "OFF       ");
d1145 12
a1156 2
		StrAllocCopy(choices[2], "ON        ");
		choices[3] = NULL;
d1158 9
a1166 3
		if (!has_colors())
		    StrAllocCopy(choices[3], "Always try");
		else
d1168 9
a1176 5
		    StrAllocCopy(choices[3], "ALWAYS    ");
		choices[4] = NULL;
		do {
		    if (!LYSelectPopups) {
			chosen = LYChooseBoolean(LYChosenShowColor,
d1180 2
d1183 1
a1183 4
			chosen = LYChoosePopup(LYChosenShowColor,
					       L_Color,
					       C_COLOR,
					       choices, 4, FALSE, FALSE);
d1185 13
d1199 29
a1227 10
		    again = (BOOL) (chosen == SHOW_COLOR_ON && !has_colors());
		    if (again) {
			char *terminal = LYGetEnv("TERM");

			if (terminal)
			    HTUserMsg2(COLOR_TOGGLE_DISABLED_FOR_TERM,
				       terminal);
			else
			    HTUserMsg(COLOR_TOGGLE_DISABLED);
		    }
d1229 2
a1230 2
		} while (again);
		LYChosenShowColor = chosen;
d1232 5
a1236 5
		if (LYSelectPopups) {
		    LYmove(L_Color, C_COLOR);
		    LYclrtoeol();
		    LYaddstr(choices[LYChosenShowColor]);
		}
d1239 1
a1239 1
		if (has_colors())
d1241 4
a1244 1
		    LYShowColor = chosen;
d1247 4
a1250 7
		FREE(choices[2]);
		FREE(choices[3]);
	    }
	    if (CurrentShowColor != LYShowColor) {
		lynx_force_repaint();
	    }
	    CurrentShowColor = LYShowColor;
d1252 1
a1252 1
	    SLtt_Use_Ansi_Colors = (LYShowColor > SHOW_COLOR_OFF ? TRUE : FALSE);
d1254 14
a1267 5
	    response = ' ';
	    if (LYSelectPopups && !no_option_save) {
		HANDLE_LYOPTIONS;
	    }
	    break;
d1270 17
a1286 56
	case '@@':		/* Change show cursor setting. */
	    LYShowCursor = LYChooseBoolean(LYShowCursor,
					   L_Bool_B,
					   C_SHOW_CURSOR,
					   bool_choices);
	    response = ' ';
	    break;

	case 'K':		/* Change keypad mode. */
	    if (!LYSelectPopups) {
		keypad_mode = LYChooseBoolean(keypad_mode,
					      L_Keypad, -1,
					      keypad_choices);
	    } else {
		keypad_mode = LYChoosePopup(keypad_mode,
					    L_Keypad, -1,
					    keypad_choices,
					    3, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Keypad, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(keypad_choices[keypad_mode]);
#endif /* VMS || USE_SLANG */
	    }
	    if (keypad_mode == NUMBERS_AS_ARROWS) {
		set_numbers_as_arrows();
	    } else {
		reset_numbers_as_arrows();
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'N':		/* Change line editor key bindings. */
	    if (!LYSelectPopups) {
		current_lineedit = LYChooseBoolean(current_lineedit,
						   L_Lineed, -1,
						   LYLineeditNames);
	    } else {
		current_lineedit = LYChoosePopup(current_lineedit,
						 L_Lineed, -1,
						 LYLineeditNames,
						 0, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Lineed, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(LYLineeditNames[current_lineedit]);
#endif /* VMS || USE_SLANG */
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
d1288 24
a1311 11
#ifdef EXP_KEYBOARD_LAYOUT
	case 'Y':		/* Change keyboard layout */
	    if (!LYSelectPopups) {
		current_layout = LYChooseBoolean(current_layout,
						 L_Layout, -1,
						 LYKbLayoutNames);
	    } else {
		current_layout = LYChoosePopup(current_layout,
					       L_Layout, -1,
					       LYKbLayoutNames,
					       0, FALSE, FALSE);
d1313 3
a1315 3
		LYmove(L_Layout, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(LYKbLayoutNames[current_layout]);
d1317 88
a1404 6
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
d1408 21
a1428 10
	case 'I':		/* Change local directory sorting. */
	    if (!LYSelectPopups) {
		dir_list_style = LYChooseBoolean(dir_list_style,
						 L_Dired, -1,
						 dirList_choices);
	    } else {
		dir_list_style = LYChoosePopup(dir_list_style,
					       L_Dired, -1,
					       dirList_choices,
					       3, FALSE, FALSE);
d1430 3
a1432 3
		LYmove(L_Dired, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(dirList_choices[dir_list_style]);
d1434 18
a1451 6
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
d1454 23
a1476 12
	case 'U':		/* Change user mode. */
	    if (!LYSelectPopups) {
		user_mode = LYChooseBoolean(user_mode,
					    L_User_Mode, -1,
					    userMode_choices);
		use_assume_charset = (BOOL) (user_mode >= 2);
	    } else {
		user_mode = LYChoosePopup(user_mode,
					  L_User_Mode, -1,
					  userMode_choices,
					  3, FALSE, FALSE);
		use_assume_charset = (BOOL) (user_mode >= 2);
d1478 5
a1482 5
		if (use_assume_charset == old_use_assume_charset) {
		    LYmove(L_User_Mode, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(userMode_choices[user_mode]);
		}
a1483 41
	    }
	    if (user_mode == NOVICE_MODE) {
		display_lines = (LYlines - 4);
	    } else {
		display_lines = LYlines - 2;
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case '!':
	    if (!LYSelectPopups) {
		verbose_img = LYChooseBoolean(verbose_img,
					      L_VERBOSE_IMAGES,
					      C_VERBOSE_IMAGES,
					      bool_choices);
	    } else {
		verbose_img = LYChoosePopup(verbose_img,
					    L_VERBOSE_IMAGES,
					    C_VERBOSE_IMAGES,
					    bool_choices,
					    2, FALSE, FALSE);
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'A':		/* Change user agent string. */
	    if (!no_useragent) {
		if (non_empty(LYUserAgent)) {
		    LYstrncpy(display_option,
			      LYUserAgent,
			      sizeof(display_option) - 1);
		} else {	/* clear the NONE */
		    LYmove(L_HOME, COL_OPTION_VALUES);
		    LYaddstr("    ");
		    *display_option = '\0';
d1485 5
a1489 16
		_statusline(ACCEPT_DATA_OR_DEFAULT);
		LYmove(L_User_Agent, COL_OPTION_VALUES);
		lynx_start_bold();
		ch = LYgetstr(display_option, VISIBLE,
			      sizeof(display_option), NORECALL);
		lynx_stop_bold();
		LYmove(L_User_Agent, COL_OPTION_VALUES);
		if (term_options || ch == -1) {
		    LYaddstr((LYUserAgent &&
			      *LYUserAgent) ?
			     LYUserAgent : "NONE");
		} else if (*display_option == '\0') {
		    StrAllocCopy(LYUserAgent, LYUserAgentDefault);
		    LYaddstr((LYUserAgent &&
			      *LYUserAgent) ?
			     LYUserAgent : "NONE");
d1491 16
a1506 2
		    StrAllocCopy(LYUserAgent, display_option);
		    LYaddstr(display_option);
d1508 16
a1523 6
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else if (!LYCheckUserAgent()) {
		    _statusline(UA_PLEASE_USE_LYNX);
d1525 22
a1546 1
		    _statusline(VALUE_ACCEPTED);
d1548 1
a1548 5
	    } else {		/* disallowed */
		_statusline(UA_CHANGE_DISABLED);
	    }
	    response = ' ';
	    break;
d1550 44
a1593 4
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
	case 'X':		/* Change local exec restriction. */
	    if (exec_frozen && !LYSelectPopups) {
		_statusline(CHANGE_OF_SETTING_DISALLOWED);
d1596 29
a1624 1
	    }
d1626 2
a1627 3
	    if (local_exec) {
		itmp = 2;
	    } else
d1629 4
a1632 3
	    {
		if (local_exec_on_local_files) {
		    itmp = 1;
d1634 4
a1637 13
		    itmp = 0;
		}
	    }
	    if (!LYSelectPopups) {
		itmp = LYChooseBoolean(itmp,
				       L_Exec, -1,
				       exec_choices);
	    } else {
		itmp = LYChoosePopup(itmp,
				     L_Exec, -1,
				     exec_choices,
				     0, (exec_frozen ? TRUE : FALSE),
				     FALSE);
d1639 3
a1641 3
		LYmove(L_Exec, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(exec_choices[itmp]);
d1643 16
a1658 11
	    }
	    if (!exec_frozen) {
		switch (itmp) {
		case 0:
		    local_exec = FALSE;
		    local_exec_on_local_files = FALSE;
		    break;
		case 1:
		    local_exec = FALSE;
		    local_exec_on_local_files = TRUE;
		    break;
d1660 4
a1663 4
		case 2:
		    local_exec = TRUE;
		    local_exec_on_local_files = FALSE;
		    break;
d1665 17
a1681 8
		}		/* end switch */
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d1683 9
a1691 6
	case '>':		/* Save current options to RC file. */
	    if (!no_option_save) {
		HTInfoMsg(SAVING_OPTIONS);
		LYrcShowColor = LYChosenShowColor;
		if (save_rc(NULL)) {
		    HTInfoMsg(OPTIONS_SAVED);
d1693 6
a1698 1
		    HTAlert(OPTIONS_NOT_SAVED);
d1700 1
a1700 8
	    } else {
		HTInfoMsg(R_TO_RETURN_TO_LYNX);
		/*
		 * Change response so that we don't exit the options menu.
		 */
		response = ' ';
	    }
	    break;
d1702 3
a1704 2
	case 'R':		/* Return to document (quit options menu). */
	    break;
d1706 8
a1713 8
	default:
	    if (!no_option_save) {
		HTInfoMsg(SAVE_OR_R_TO_RETURN_TO_LYNX);
	    } else {
		HTInfoMsg(R_TO_RETURN_TO_LYNX);
	    }
	}			/* end switch */
    }				/* end while */
a1719 23
static int widest_choice(const char **choices)
{
    int n, width = 0;

    for (n = 0; choices[n] != NULL; ++n) {
	int len = strlen(choices[n]);

	if (width < len)
	    width = len;
    }
    return width;
}

static void show_choice(const char *choice,
			int width)
{
    int len = strlen(choice);

    LYaddstr(choice);
    while (len++ < width)
	LYaddch(' ');
}

d1721 2
a1722 1
 * Take a status code, prompt the user for a new status, and return it.
d1724 5
a1728 4
static int boolean_choice(int cur_choice,
			  int line,
			  int column,
			  const char **choices)
a1734 1
    int width = widest_choice(choices);
d1737 2
a1738 1
     * Get the number of choices and then make number zero-based.
d1740 2
a1741 1
    for (number = 0; choices[number] != NULL; number++) ;	/* empty loop body */
d1745 1
a1745 1
     * Update the statusline.
d1750 1
a1750 1
     * Highlight the current choice.
d1752 3
a1754 3
    LYmove(line, col);
    lynx_start_reverse();
    show_choice(choices[cur_choice], width);
d1756 2
a1757 2
	LYmove(line, (col - 1));
    LYrefresh();
d1760 4
a1763 2
     * Get the keyboard entry, and leave the cursor at the choice, to indicate
     * that it can be changed, until the user accepts the current choice.
d1767 1
a1767 1
	LYmove(line, col);
d1769 1
a1769 1
	    response = LYgetch_single();
d1771 4
a1774 4
	if (term_options || LYCharIsINTERRUPT_NO_letter(response)) {
	    /*
	     * Control-C or Control-G.
	     */
d1788 1
a1788 1
	    (cmd = LKC_TO_LAC(keymap, response)) != LYK_ACTIVATE) {
d1790 3
a1792 3
	    case LYK_HOME:
		cur_choice = 0;
		break;
d1794 3
a1796 3
	    case LYK_END:
		cur_choice = number;
		break;
d1798 4
a1801 4
	    case LYK_REFRESH:
		lynx_force_repaint();
		LYrefresh();
		break;
d1803 6
a1808 6
	    case LYK_QUIT:
	    case LYK_ABORT:
	    case LYK_PREV_DOC:
		cur_choice = orig_choice;
		term_options = TRUE;
		break;
d1810 12
a1821 13
	    case LYK_PREV_PAGE:
	    case LYK_UP_HALF:
	    case LYK_UP_TWO:
	    case LYK_PREV_LINK:
	    case LYK_LPOS_PREV_LINK:
	    case LYK_FASTBACKW_LINK:
	    case LYK_UP_LINK:
	    case LYK_LEFT_LINK:
		if (cur_choice == 0)
		    cur_choice = number;	/* go back to end */
		else
		    cur_choice--;
		break;
d1823 20
a1842 20
	    case LYK_1:
	    case LYK_2:
	    case LYK_3:
	    case LYK_4:
	    case LYK_5:
	    case LYK_6:
	    case LYK_7:
	    case LYK_8:
	    case LYK_9:
		if ((cmd - LYK_1 + 1) <= number) {
		    cur_choice = cmd - LYK_1 + 1;
		    break;
		}		/* else fall through! */
	    default:
		if (cur_choice == number)
		    cur_choice = 0;	/* go over the top and around */
		else
		    cur_choice++;
	    }			/* end of switch */
	    show_choice(choices[cur_choice], width);
d1844 2
a1845 2
		LYmove(line, (col - 1));
	    LYrefresh();
d1848 1
a1848 1
	     * Unhighlight choice.
d1850 3
a1852 3
	    LYmove(line, col);
	    lynx_stop_reverse();
	    show_choice(choices[cur_choice], width);
d1861 1
a1861 1
	    return cur_choice;
d1867 2
a1868 1
static void terminate_options(int sig GCC_UNUSED)
d1872 1
a1872 1
     * Reassert the AST.
d1877 1
a1877 1
     * Refresh the screen to get rid of the "interrupt" message.
d1881 1
a1881 1
	LYrefresh();
d1887 1
a1887 1
 * Multi-Bookmark On-Line editing support.  - FMG & FM
d1889 1
a1889 1
void edit_bookmarks(void)
a1892 1

d1894 2
a1895 2
    int a;			/* misc counter */
    char MBM_tmp_line[256];	/* buffer for LYgetstr */
d1899 4
a1902 3
     * We need (MBM_V_MAXFILES + MULTI_OFFSET) lines to display the whole list
     * at once.  Otherwise break it up into two segments.  We know it won't be
     * less than that because 'o'ptions needs 23-24 at LEAST.
d1907 1
a1907 1
  draw_bookmark_list:
d1909 3
a1911 3
     * Display menu of bookmarks.  NOTE that we avoid printw()'s to increase
     * the chances that any non-ASCII or multibyte/CJK characters will be
     * handled properly.  - FM
d1915 1
a1915 1
	LYclear();
d1917 1
a1917 1
	LYerase();
d1920 1
a1920 1
    LYclear();
d1922 2
a1923 2
    LYmove(0, 5);
    lynx_start_h1_color();
d1926 1
a1926 1
	LYaddstr(ehead_buffer);
d1928 1
a1928 1
	LYaddstr(MULTIBOOKMARKS_EHEAD);
d1930 1
a1930 1
    lynx_stop_h1_color();
d1933 5
a1937 5
	for (a = ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1));
	     a <= (MBM_current * MBM_V_MAXFILES / 2); a++) {
	    LYmove((3 + a) - ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1)), 5);
	    LYaddch(UCH(LYindex2MBM(a)));
	    LYaddstr(" : ");
d1939 3
a1941 3
		LYaddstr(MBM_A_subdescript[a]);
	    LYmove((3 + a) - ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1)), 35);
	    LYaddstr("| ");
d1943 1
a1943 1
		LYaddstr(MBM_A_subbookmark[a]);
d1948 3
a1950 3
	    LYmove(3 + a, 5);
	    LYaddch(UCH(LYindex2MBM(a)));
	    LYaddstr(" : ");
d1952 3
a1954 3
		LYaddstr(MBM_A_subdescript[a]);
	    LYmove(3 + a, 35);
	    LYaddstr("| ");
d1956 1
a1956 1
		LYaddstr(MBM_A_subbookmark[a]);
d1962 1
a1962 1
     * Only needed when we have 2 screens.
d1965 13
a1977 13
	LYmove((LYlines - 4), 0);
	LYaddstr("'");
	lynx_start_bold();
	LYaddstr("[");
	lynx_stop_bold();
	LYaddstr("' ");
	LYaddstr(PREVIOUS);
	LYaddstr(", '");
	lynx_start_bold();
	LYaddstr("]");
	lynx_stop_bold();
	LYaddstr("' ");
	LYaddstr(NEXT_SCREEN);
d1980 1
a1980 1
    LYmove((LYlines - 3), 0);
d1982 14
a1995 14
	LYaddstr("'");
	lynx_start_bold();
	LYaddstr(">");
	lynx_stop_bold();
	LYaddstr("'");
	LYaddstr(TO_SAVE_SEGMENT);
    }
    LYaddstr(OR_SEGMENT);
    LYaddstr("'");
    lynx_start_bold();
    LYaddstr("^G");
    lynx_stop_bold();
    LYaddstr("'");
    LYaddstr(TO_RETURN_SEGMENT);
d1999 2
a2000 1
	   !LYCharIsINTERRUPT_NO_letter(response) && response != '>') {
d2002 4
a2005 4
	LYmove((LYlines - 2), 0);
	lynx_start_prompt_color();
	LYaddstr(MULTIBOOKMARKS_LETTER);
	lynx_stop_prompt_color();
d2007 2
a2008 2
	LYrefresh();
	response = (def_response ? def_response : LYgetch_single());
d2012 1
a2012 1
	 * Check for a cancel.
d2014 2
a2015 1
	if (term_options || LYCharIsINTERRUPT_NO_letter(response) ||
d2020 1
a2020 1
	 * Check for a save.
d2024 3
a2026 3
		HTInfoMsg(SAVING_OPTIONS);
		if (save_rc(NULL))
		    HTInfoMsg(OPTIONS_SAVED);
d2030 1
a2030 1
		HTInfoMsg(R_TO_RETURN_TO_LYNX);
d2032 2
a2033 1
		 * Change response so that we don't exit the options menu.
d2040 868
a2907 7
	/*
	 * Check for a refresh.
	 */
	if (LYisNonAlnumKeyname(response, LYK_REFRESH)) {
	    lynx_force_repaint();
	    continue;
	}
d2909 4
a2912 19
	/*
	 * Move between the screens - if we can't show it all at once.
	 */
	if ((response == ']' ||
	     LYisNonAlnumKeyname(response, LYK_NEXT_PAGE)) &&
	    LYlines < (MBM_V_MAXFILES + MULTI_OFFSET)) {
	    MBM_current++;
	    if (MBM_current >= 3)
		MBM_current = 1;
	    goto draw_bookmark_list;
	}
	if ((response == '[' ||
	     LYisNonAlnumKeyname(response, LYK_PREV_PAGE)) &&
	    LYlines < (MBM_V_MAXFILES + MULTI_OFFSET)) {
	    MBM_current--;
	    if (MBM_current <= 0)
		MBM_current = 2;
	    goto draw_bookmark_list;
	}
d2914 21
a2934 11
	/*
	 * Instead of using 26 case statements, we set up a scan through the
	 * letters and edit the lines that way.
	 */
	for (a = 0; a <= MBM_V_MAXFILES; a++) {
	    if (LYMBM2index(response) == a) {
		if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET)) {
		    if (MBM_current == 1 && a > (MBM_V_MAXFILES / 2)) {
			MBM_current = 2;
			def_response = response;
			goto draw_bookmark_list;
d2936 13
a2948 4
		    if (MBM_current == 2 && a < (MBM_V_MAXFILES / 2)) {
			MBM_current = 1;
			def_response = response;
			goto draw_bookmark_list;
a2950 1
		_statusline(ACCEPT_DATA);
d2952 9
a2960 15
		if (a > 0) {
		    lynx_start_bold();
		    if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET))
			LYmove((3 + a)
			       - ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1)),
			       9);
		    else
			LYmove((3 + a), 9);
		    LYstrncpy(MBM_tmp_line,
			      (!MBM_A_subdescript[a] ?
			       "" : MBM_A_subdescript[a]),
			      sizeof(MBM_tmp_line) - 1);
		    ch = LYgetstr(MBM_tmp_line, VISIBLE,
				  sizeof(MBM_tmp_line), NORECALL);
		    lynx_stop_bold();
d2962 71
a3032 2
		    if (strlen(MBM_tmp_line) < 1) {
			FREE(MBM_A_subdescript[a]);
d3034 37
a3070 1
			StrAllocCopy(MBM_A_subdescript[a], MBM_tmp_line);
a3071 13
		    if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET))
			LYmove((3 + a)
			       - ((MBM_V_MAXFILES / 2 + 1)
				  * (MBM_current - 1)),
			       5);
		    else
			LYmove((3 + a), 5);
		    LYaddch(UCH(LYindex2MBM(a)));
		    LYaddstr(" : ");
		    if (MBM_A_subdescript[a])
			LYaddstr(MBM_A_subdescript[a]);
		    LYclrtoeol();
		    LYrefresh();
d3073 5
d3079 33
a3111 8
		if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET))
		    LYmove((3 + a)
			   - ((MBM_V_MAXFILES / 2 + 1)
			      * (MBM_current - 1)),
			   35);
		else
		    LYmove((3 + a), 35);
		LYaddstr("| ");
d3113 7
a3119 7
		lynx_start_bold();
		LYstrncpy(MBM_tmp_line,
			  NonNull(MBM_A_subbookmark[a]),
			  sizeof(MBM_tmp_line) - 1);
		ch = LYgetstr(MBM_tmp_line, VISIBLE,
			      sizeof(MBM_tmp_line), NORECALL);
		lynx_stop_bold();
d3121 31
a3151 13
		if (*MBM_tmp_line == '\0') {
		    if (a == 0)
			StrAllocCopy(MBM_A_subbookmark[a], bookmark_page);
		    else
			FREE(MBM_A_subbookmark[a]);
		} else if (!LYPathOffHomeOK(MBM_tmp_line,
					    sizeof(MBM_tmp_line))) {
		    LYMBM_statusline(USE_PATH_OFF_HOME);
		    LYSleepAlert();
		} else {
		    StrAllocCopy(MBM_A_subbookmark[a], MBM_tmp_line);
		    if (a == 0) {
			StrAllocCopy(bookmark_page, MBM_A_subbookmark[a]);
d3153 1
d3155 13
a3167 5
		if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET))
		    LYmove((3 + a)
			   - ((MBM_V_MAXFILES / 2 + 1)
			      * (MBM_current - 1)),
			   35);
d3169 10
a3178 7
		    LYmove((3 + a), 35);
		LYaddstr("| ");
		if (MBM_A_subbookmark[a])
		    LYaddstr(MBM_A_subbookmark[a]);
		LYclrtoeol();
		LYmove(LYlines - 1, 0);
		LYclrtoeol();
a3179 3
	    }
	}			/* end for */
    }				/* end while */
d3181 8
a3188 40
    term_options = FALSE;
    signal(SIGINT, cleanup_sig);
}

#if !defined(NO_OPTION_MENU) || (defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES)))

/*
 * This function offers the choices for values of an option via a popup window
 * which functions like that for selection of options in a form.  - FM
 *
 * Also used for mouse popups with ncurses; this is indicated by for_mouse.
 */
int popup_choice(int cur_choice,
		 int line,
		 int column,
		 const char **choices,
		 int i_length,
		 int disabled,
		 BOOLEAN for_mouse)
{
    if (column < 0)
	column = (COL_OPTION_VALUES - 1);

    term_options = FALSE;
    cur_choice = LYhandlePopupList(cur_choice,
				   line,
				   column,
				   (const char **) choices,
				   -1,
				   i_length,
				   disabled,
				   for_mouse,
				   TRUE);
    switch (cur_choice) {
    case LYK_QUIT:
    case LYK_ABORT:
    case LYK_PREV_DOC:
	term_options = TRUE;
	if (!for_mouse) {
	    HTUserMsg(CANCELLED);
a3189 1
	break;
d3191 6
d3200 2
a3201 1
    } else if (!for_mouse) {
d3203 1
a3204 1
    return (cur_choice);
d3208 1
d3218 1
d3222 2
a3223 2
    const char *LongName;
    const char *HtmlName;
d3227 2
a3228 2
    char *tag;
    char *value;
d3231 14
a3244 16
static const char selected_string[] = "selected";
static const char disabled_string[] = "disabled";
static const char on_string[] = N_("ON");
static const char off_string[] = N_("OFF");
static const char never_string[] = N_("NEVER");
static const char always_string[] = N_("ALWAYS");
static OptValues bool_values[] =
{
    {FALSE, N_("OFF"), "OFF"},
    {TRUE, N_("ON"), "ON"},
    {0, 0, 0}
};

static const char *secure_string = "secure";
static char *secure_value = NULL;
static const char *save_options_string = "save_options";
d3249 7
a3255 7
static const char *cookies_string = RC_SET_COOKIES;
static const char *cookies_ignore_all_string = N_("ignore");
static const char *cookies_up_to_user_string = N_("ask user");
static const char *cookies_accept_all_string = N_("accept all");
static const char *x_display_string = RC_DISPLAY;
static const char *editor_string = RC_FILE_EDITOR;
static const char *emacs_keys_string = RC_EMACS_KEYS;
d3257 1
a3257 1
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
d3261 4
a3264 5
static const char *exec_links_string = RC_RUN_ALL_EXECUTION_LINKS;
static OptValues exec_links_values[] =
{
    {EXEC_NEVER, N_("ALWAYS OFF"), "ALWAYS OFF"},
    {EXEC_LOCAL, N_("FOR LOCAL FILES ONLY"), "FOR LOCAL FILES ONLY"},
d3266 1
a3266 1
    {EXEC_ALWAYS, N_("ALWAYS ON"), "ALWAYS ON"},
d3268 2
a3269 3
    {0, 0, 0}
};
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d3272 1
a3272 1
static const char *kblayout_string = RC_KBLAYOUT;
d3274 15
a3288 26
static const char *keypad_mode_string = RC_KEYPAD_MODE;
static OptValues keypad_mode_values[] =
{
    {NUMBERS_AS_ARROWS, N_("Numbers act as arrows"),
     "number_arrows"},
    {LINKS_ARE_NUMBERED, N_("Links are numbered"),
     "links_numbered"},
    {LINKS_AND_FIELDS_ARE_NUMBERED,
     N_("Links and form fields are numbered"),
     "links_and_forms"},
    {FIELDS_ARE_NUMBERED,
     N_("Form fields are numbered"),
     "forms_numbered"},
    {0, 0, 0}
};
static const char *lineedit_mode_string = RC_LINEEDIT_MODE;
static const char *mail_address_string = RC_PERSONAL_MAIL_ADDRESS;
static const char *anonftp_password_string = RC_ANONFTP_PASSWORD;
static const char *search_type_string = RC_CASE_SENSITIVE_SEARCHING;
static OptValues search_type_values[] =
{
    {FALSE, N_("Case insensitive"), "case_insensitive"},
    {TRUE, N_("Case sensitive"), "case_sensitive"},
    {0, 0, 0}
};

d3290 16
a3305 59
static const char *show_color_string = RC_SHOW_COLOR;
static OptValues show_color_values[] =
{
    {SHOW_COLOR_NEVER, never_string, never_string},
    {SHOW_COLOR_OFF, off_string, off_string},
    {SHOW_COLOR_ON, on_string, on_string},
    {SHOW_COLOR_ALWAYS, always_string, always_string},
    {0, 0, 0}
};
#endif

static const char *show_cursor_string = RC_SHOW_CURSOR;

static const char *underline_links_string = RC_UNDERLINE_LINKS;

#ifdef USE_SCROLLBAR
static const char *show_scrollbar_string = RC_SCROLLBAR;
#endif

static const char prompt_dft_string[] = N_("prompt normally");
static const char prompt_yes_string[] = N_("force yes-response");
static const char prompt_no_string[] = N_("force no-response");
static OptValues prompt_values[] =
{
    {FORCE_PROMPT_DFT, prompt_dft_string, prompt_dft_string},
    {FORCE_PROMPT_YES, prompt_yes_string, prompt_yes_string},
    {FORCE_PROMPT_NO, prompt_no_string, prompt_no_string},
    {0, 0, 0}
};

static const char *cookie_prompt_string = RC_FORCE_COOKIE_PROMPT;

#ifdef USE_SSL
static const char *ssl_prompt_string = RC_FORCE_SSL_PROMPT;
#endif

static const char *user_mode_string = RC_USER_MODE;
static OptValues user_mode_values[] =
{
    {NOVICE_MODE, N_("Novice"), "Novice"},
    {INTERMEDIATE_MODE, N_("Intermediate"), "Intermediate"},
    {ADVANCED_MODE, N_("Advanced"), "Advanced"},
    {0, 0, 0}
};

static const char *vi_keys_string = RC_VI_KEYS;

static const char *visited_links_string = RC_VISITED_LINKS;
static OptValues visited_links_values[] =
{
    {VISITED_LINKS_AS_FIRST_V, N_("By First Visit"), "first_visited"},
    {VISITED_LINKS_AS_FIRST_V | VISITED_LINKS_REVERSE,
     N_("By First Visit Reversed"), "first_visited_reversed"},
    {VISITED_LINKS_AS_TREE, N_("As Visit Tree"), "visit_tree"},
    {VISITED_LINKS_AS_LATEST, N_("By Last Visit"), "last_visited"},
    {VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE,
     N_("By Last Visit Reversed"), "last_visited_reversed"},
    {0, 0, 0}
};
d3310 2
a3311 3
static const char *DTD_recovery_string = RC_TAGSOUP;
static OptValues DTD_type_values[] =
{
d3313 10
a3322 14
    {TRUE, N_("relaxed (TagSoup mode)"), "tagsoup"},
    {FALSE, N_("strict (SortaSGML mode)"), "sortasgml"},
    {0, 0, 0}
};

static const char *select_popups_string = RC_SELECT_POPUPS;
static const char *images_string = "images";
static const char *images_ignore_all_string = N_("ignore");
static const char *images_use_label_string = N_("as labels");
static const char *images_use_links_string = N_("as links");

static const char *verbose_images_string = RC_VERBOSE_IMAGES;
static OptValues verbose_images_type_values[] =
{
d3324 3
a3326 4
    {FALSE, N_("OFF"), "OFF"},
    {TRUE, N_("show filename"), "ON"},
    {0, 0, 0}
};
d3331 5
a3335 10
static const char *mbm_string = RC_MULTI_BOOKMARK;
static OptValues mbm_values[] =
{
    {MBM_OFF, N_("OFF"), "OFF"},
    {MBM_STANDARD, N_("STANDARD"), "STANDARD"},
    {MBM_ADVANCED, N_("ADVANCED"), "ADVANCED"},
    {0, 0, 0}
};

static const char *single_bookmark_string = RC_BOOKMARK_FILE;
d3340 3
a3342 7
static const char *assume_char_set_string = RC_ASSUME_CHARSET;
static const char *display_char_set_string = RC_CHARACTER_SET;
static const char *raw_mode_string = RC_RAW_MODE;

#ifdef EXP_LOCALE_CHARSET
static const char *locale_charset_string = RC_LOCALE_CHARSET;
#endif
d3347 1
a3347 2
static const char *show_dotfiles_string = RC_SHOW_DOTFILES;

d3349 6
a3354 25
static const char *dired_list_string = RC_DIR_LIST_STYLE;
static OptValues dired_list_values[] =
{
    {DIRS_FIRST, N_("Directories first"), "dired_dir"},
    {FILES_FIRST, N_("Files first"), "dired_files"},
    {MIXED_STYLE, N_("Mixed style"), "dired_mixed"},
    {0, 0, 0}
};

#ifdef LONG_LIST
static const char *dired_sort_string = RC_DIR_LIST_ORDER;
static OptValues dired_sort_values[] =
{
    {ORDER_BY_NAME, N_("By Name"), "dired_by_name"},
    {ORDER_BY_TYPE, N_("By Type"), "dired_by_type"},
    {ORDER_BY_SIZE, N_("By Size"), "dired_by_size"},
    {ORDER_BY_DATE, N_("By Date"), "dired_by_date"},
    {ORDER_BY_MODE, N_("By Mode"), "dired_by_mode"},
#ifndef NO_GROUPS
    {ORDER_BY_USER, N_("By User"), "dired_by_user"},
    {ORDER_BY_GROUP, N_("By Group"), "dired_by_group"},
#endif
    {0, 0, 0}
};
#endif /* LONG_LIST */
d3356 7
a3362 25

static const char *ftp_sort_string = RC_FILE_SORTING_METHOD;
static OptValues ftp_sort_values[] =
{
    {FILE_BY_NAME, N_("By Name"), "ftp_by_name"},
    {FILE_BY_TYPE, N_("By Type"), "ftp_by_type"},
    {FILE_BY_SIZE, N_("By Size"), "ftp_by_size"},
    {FILE_BY_DATE, N_("By Date"), "ftp_by_date"},
    {0, 0, 0}
};

#ifdef USE_READPROGRESS
static const char *show_rate_string = RC_SHOW_KB_RATE;
static OptValues rate_values[] =
{
    {rateOFF, N_("Do not show rate"), "rate_off"},
    {rateBYTES, N_("Show %s/sec rate"), "rate_bytes"},
    {rateKB, N_("Show %s/sec rate"), "rate_kb"},
#ifdef USE_READPROGRESS
    {rateEtaBYTES, N_("Show %s/sec, ETA"), "rate_eta_bytes"},
    {rateEtaKB, N_("Show %s/sec, ETA"), "rate_eta_kb"},
#endif
    {0, 0, 0}
};
#endif /* USE_READPROGRESS */
d3365 1
a3365 1
 * Presentation (MIME) types used in "Accept".
d3367 3
a3369 28
static const char *preferred_media_string = RC_PREFERRED_MEDIA_TYPES;
static OptValues media_values[] =
{
    {mediaOpt1, N_("Accept lynx's internal types"), "media_opt1"},
    {mediaOpt2, N_("Also accept lynx.cfg's types"), "media_opt2"},
    {mediaOpt3, N_("Also accept user's types"), "media_opt3"},
    {mediaOpt4, N_("Also accept system's types"), "media_opt4"},
    {mediaALL, N_("Accept all types"), "media_all"},
    {0, 0, 0}
};

static const char *preferred_encoding_string = RC_PREFERRED_ENCODING;
static OptValues encoding_values[] =
{
    {encodingNONE, N_("None"), "encoding_none"},
#if defined(USE_ZLIB) || defined(GZIP_PATH)
    {encodingGZIP, N_("gzip"), "encoding_gzip"},
    {encodingDEFLATE, N_("deflate"), "encoding_deflate"},
#endif
#if defined(USE_ZLIB) || defined(COMPRESS_PATH)
    {encodingCOMPRESS, N_("compress"), "encoding_compress"},
#endif
#if defined(USE_BZLIB) || defined(BZIP2_PATH)
    {encodingBZIP2, N_("bzip2"), "encoding_bzip2"},
#endif
    {encodingALL, N_("All"), "encoding_all"},
    {0, 0, 0}
};
d3371 2
a3372 6
/*
 * Headers transferred to remote server
 */
static const char *preferred_doc_char_string = RC_PREFERRED_CHARSET;
static const char *preferred_doc_lang_string = RC_PREFERRED_LANGUAGE;
static const char *user_agent_string = RC_USERAGENT;
d3377 1
a3377 1
		(int) Size, Name, Value, disable_all?disabled_string:disable)
d3380 1
a3380 1
	fprintf(fp,"<option value=\"%s\" %s>%s\n", html, SELECTED(flag), gettext(name))
d3383 1
a3383 1
	fprintf(fp,"<select name=\"%s\" %s>\n", text, disable_all?disabled_string:"")
d3386 1
a3386 1
	fprintf(fp,"<select name=\"%s\" %s>\n", text, disable_all?disabled_string:DISABLED(flag))
d3391 4
a3394 2
static void PutOptValues(FILE *fp, int value,
			 OptValues * table)
d3397 4
a3400 6
	if (table->HtmlName) {
	    PutOption(fp,
		      value == table->value,
		      table->HtmlName,
		      table->LongName);
	}
d3405 4
a3408 2
static BOOLEAN GetOptValues(OptValues * table, char *value,
			    int *result)
d3411 1
a3411 1
	if (table->HtmlName && !strcmp(value, table->HtmlName)) {
d3429 3
a3431 1
static PostPair *break_data(bstring *data)
d3433 2
a3434 2
    char *p;
    PostPair *q = NULL;
d3437 1
a3437 1
    if (isBEmpty(data))
d3440 2
a3441 5
    p = BStrData(data);
    CTRACE((tfp, "break_data %s\n", p));

    q = typecalloc(PostPair);
    if (q == NULL)
d3463 3
a3465 4
	    size_t i, len;

	    len = strlen(q[count].value);
	    for (i = 0; i < len; i++) {
d3473 2
a3474 2
			&& q[count].value[i + 1] == '+'
			&& isalnum(UCH(q[count].value[i + 2]))) {
d3479 1
d3483 1
a3483 1
	    }
a3485 2
	CTRACE((tfp, "...item[%d] tag=%s, value=%s\n",
		count, q[count].tag, q[count].value));
d3492 2
a3493 2
	q = typeRealloc(PostPair, q, count + 1);
	if (q == NULL)
d3495 2
a3496 2
	q[count].tag = NULL;
    } while (p != NULL && p[0] != '\0');
d3500 1
a3500 18
static BOOL isLynxOptionsPage(const char *address, const char *portion)
{
    BOOL result = FALSE;

    if (!strncasecomp(address, STR_LYNXOPTIONS, LEN_LYNXOPTIONS)) {
	unsigned len = strlen(portion);

	address += LEN_LYNXOPTIONS;
	if (!strncasecomp(address, portion, len)
	    && (address[len] == '\0' || LYIsHtmlSep(address[len]))) {
	    result = TRUE;
	}
    }
    return result;
}

static int gen_options(char **newfile);

d3533 2
a3534 1
int postoptions(DocInfo *newdoc)
d3537 1
a3537 1
    DocAddress WWWDoc;		/* need on exit */
a3541 1
    int old_media_value = LYAcceptMedia;
a3545 1

d3552 1
a3552 1
     * "<a href=\"" LYNXOPTIONS_PAGE(MBM_MENU) "\">Goto multi-bookmark menu</a>\n"
d3555 1
a3555 1
    if (isLynxOptionsPage(newdoc->address, MBM_LINK)) {
d3557 5
a3561 12
	if (no_bookmark) {
	    HTAlert(BOOKMARK_CHANGE_DISALLOWED);	/* anonymous */
	    return (NULLFILE);
	} else if (dump_output_immediately) {
	    return (NOT_FOUND);
	} else {
	    edit_bookmarks();
	    return (NULLFILE);
	}
    } else if (!isLynxOptionsPage(newdoc->address, "/")) {
	HTAlert(RANDOM_URL_DISALLOWED);
	return NULLFILE;
a3563 1
    data = break_data(newdoc->post_data);
d3565 3
a3567 2
    if (!data) {
	int status;
d3569 4
a3572 9
	/*-------------------------------------------------
	 * kludge gen_options() call:
	 *--------------------------------------------------*/
	status = gen_options(&newdoc->address);
	if (status != NORMAL) {
	    HTAlwaysAlert("Unexpected way of accessing", newdoc->address);
	    FREE(newdoc->address);
	    return (status);
	}
d3574 1
a3574 1
	/* exit to getfile() cycle */
d3583 2
a3584 6
	    return (NOT_FOUND);
	LYRegisterUIPage(newdoc->address, UIP_OPTIONS_MENU);
#ifdef DIRED_SUPPORT
	lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
	return (NORMAL);
d3587 2
a3588 13
    if (!LYIsUIPage3(HTLoadedDocumentURL(), UIP_OPTIONS_MENU, 0) &&
	!LYIsUIPage3(HTLoadedDocumentURL(), UIP_VLINKS, 0)) {
	char *buf = NULL;

	/*  We may have been spoofed? */
	HTSprintf0(&buf,
		   gettext("Use %s to invoke the Options menu!"),
		   key_for_func_ext(LYK_OPTIONS, FOR_PANEL));
	HTAlert(buf);
	FREE(buf);
	FREE(data);
	return (NOT_FOUND);
    }
d3592 1
a3592 4
	 * This isn't really for security, but rather for avoiding that the
	 * user may revisit an older instance from the history stack and submit
	 * stuff which accidentally undoes changes that had been done from a
	 * newer instance.  - kw
a3595 2
		char *buf = NULL;

d3597 1
a3597 2
		 * We probably came from an older instance of the Options
		 * page that had been on the history stack. - kw
a3598 4
		HTSprintf0(&buf,
			   gettext("Use %s to invoke the Options menu!"),
			   key_for_func_ext(LYK_OPTIONS, FOR_PANEL));
		HTAlert(buf);
d3600 1
a3600 1
		return (NULLFILE);
a3625 2
	    validate_x_display();
	    summarize_x_display(data[i].value);
d3636 2
a3637 2
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    if ((emacs_keys = (BOOL) code) != FALSE) {
d3645 1
a3645 1
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
d3647 1
a3647 1
	    && GetOptValues(exec_links_values, data[i].value, &code)) {
d3653 1
a3653 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
a3657 1

d3659 1
a3659 1
		&& keypad_mode != newval) {
a3661 5
		if (keypad_mode == NUMBERS_AS_ARROWS) {
		    set_numbers_as_arrows();
		} else {
		    reset_numbers_as_arrows();
		}
d3666 1
a3666 1
	if (!strcmp(data[i].tag, lineedit_mode_string)) {
a3668 1

d3671 1
a3671 2
		if (j == newval)
		    current_lineedit = newval;
d3674 1
a3679 1

d3682 1
a3682 2
		if (j == newval)
		    current_layout = newval;
a3692 6
	/* Anonymous FTP Password: INPUT */
	if (!strcmp(data[i].tag, anonftp_password_string)) {
	    FREE(anonftp_password);
	    StrAllocCopy(anonftp_password, data[i].value);
	}

d3695 2
a3696 2
	    && GetOptValues(search_type_values, data[i].value, &code)) {
	    case_sensitive = (BOOL) code;
d3701 1
a3701 1
	    && GetOptValues(DTD_type_values, data[i].value, &code)) {
d3711 2
a3712 2
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYSelectPopups = (BOOL) code;
d3714 1
d3718 2
a3719 4
	    && GetOptValues(show_color_values, data[i].value,
			    &LYChosenShowColor)) {
	    if (can_do_colors)
		LYShowColor = LYChosenShowColor;
d3725 1
a3725 1
	    SLtt_Use_Ansi_Colors = (LYShowColor > SHOW_COLOR_OFF ? TRUE : FALSE);
d3732 2
a3733 8
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYShowCursor = (BOOL) code;
	}

	/* Underline links: ON/OFF */
	if (!strcmp(data[i].tag, underline_links_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYUnderlineLinks = (BOOL) code;
a3734 18
#ifdef USE_SCROLLBAR
	/* Show Scrollbar: ON/OFF */
	if (!strcmp(data[i].tag, show_scrollbar_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYShowScrollbar = (BOOL) code;
	    need_reload = TRUE;
	}
#endif

	/* Cookie Prompting: SELECT */
	if (!strcmp(data[i].tag, cookie_prompt_string))
	    GetOptValues(prompt_values, data[i].value, &cookie_noprompt);

#ifdef USE_SSL
	/* SSL Prompting: SELECT */
	if (!strcmp(data[i].tag, ssl_prompt_string))
	    GetOptValues(prompt_values, data[i].value, &ssl_noprompt);
#endif
d3738 1
a3738 1
	    && GetOptValues(user_mode_values, data[i].value, &user_mode)) {
d3742 1
a3742 1
		display_lines = LYlines - 2;
a3745 4
	/* Type of visited pages page: SELECT */
	if (!strcmp(data[i].tag, visited_links_string))
	    GetOptValues(visited_links_values, data[i].value, &Visited_Links_As);

d3749 3
a3751 3
		&& !(pseudo_inline_alts == FALSE && clickable_images == FALSE)) {
		pseudo_inline_alts = FALSE;
		clickable_images = FALSE;
d3754 3
a3756 3
		       && !(pseudo_inline_alts == TRUE && clickable_images == FALSE)) {
		pseudo_inline_alts = TRUE;
		clickable_images = FALSE;
d3759 1
a3759 1
		       && !(clickable_images == TRUE)) {
d3767 1
a3767 1
	    && GetOptValues(verbose_images_type_values, data[i].value, &code)) {
d3769 1
a3769 1
		verbose_img = (BOOL) code;
d3776 2
a3777 2
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    if ((vi_keys = (BOOL) code) != FALSE) {
d3786 9
a3794 1
	    GetOptValues(mbm_values, data[i].value, &LYMultiBookmarks);
d3810 1
a3810 1
		&& ((raw_mode_old &&
d3812 2
a3813 2
		    || (!raw_mode_old &&
			newval != UCLYhndl_for_unspec)
a3820 7
#ifdef EXP_LOCALE_CHARSET
	/* Use locale-based character set: ON/OFF */
	if (!strcmp(data[i].tag, locale_charset_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYLocaleCharset = (BOOL) code;
	}
#endif
a3825 1

d3828 1
a3828 2
		if (j == newval)
		    current_char_set = newval;
d3834 2
a3835 2
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYRawMode = (BOOL) code;
d3844 1
d3846 1
a3846 6
	/* Local Directory Style: SELECT */
	if (!strcmp(data[i].tag, dired_list_string)) {
	    GetOptValues(dired_list_values, data[i].value, &dir_list_style);
	}
#ifdef LONG_LIST
	/* Local Directory Order: SELECT */
d3848 1
a3848 1
	    GetOptValues(dired_sort_values, data[i].value, &dir_list_order);
a3849 1
#endif /* LONG_LIST */
d3854 2
a3855 19
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    show_dotfiles = (BOOL) code;
	}
#ifdef USE_READPROGRESS
	/* Show Transfer Rate: enumerated value */
	if (!strcmp(data[i].tag, show_rate_string)
	    && GetOptValues(rate_values, data[i].value, &code)) {
	    LYTransferRate = code;
	}
#endif /* USE_READPROGRESS */

	/* Preferred Media Type: SELECT */
	if (!strcmp(data[i].tag, preferred_media_string)) {
	    GetOptValues(media_values, data[i].value, &LYAcceptMedia);
	}

	/* Preferred Encoding: SELECT */
	if (!strcmp(data[i].tag, preferred_encoding_string)) {
	    GetOptValues(encoding_values, data[i].value, &LYAcceptEncoding);
d3864 1
a3864 1
	    }
d3883 7
a3889 5
			     *(data[i].value)
			     ? data[i].value
			     : LYUserAgentDefault);
		if (!LYCheckUserAgent()) {
		    HTAlert(UA_PLEASE_USE_LYNX);
d3893 1
a3893 1
    }				/* end of loop */
d3895 30
a3924 6
    /*
     * Process the flags:
     */
#ifdef EXP_LOCALE_CHARSET
    LYFindLocaleCharset();
#endif
a3925 2
    if (old_media_value != LYAcceptMedia)
	HTFilterPresentations();
a3926 34
    if (display_char_set_old != current_char_set ||
	raw_mode_old != LYRawMode ||
	assume_char_set_changed) {
	/*
	 * charset settings: the order is essential here.
	 */
	if (display_char_set_old != current_char_set) {
	    /*
	     * Set the LYUseDefaultRawMode value and character handling if
	     * LYRawMode was changed.  - FM
	     */
	    LYUseDefaultRawMode = TRUE;
	    HTMLUseCharacterSet(current_char_set);
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Deduce whether the user wants autoswitch: */
	    switch_display_charsets =
		(current_char_set == auto_display_charset
		 || current_char_set == auto_other_display_charset);
#endif
	}
	if (assume_char_set_changed && HTCJK != JAPANESE) {
	    LYRawMode = (BOOL) (UCLYhndl_for_unspec == current_char_set);
	}
	if (raw_mode_old != LYRawMode || assume_char_set_changed) {
	    /*
	     * Set the raw 8-bit or CJK mode defaults and character set if
	     * changed.  - FM
	     */
	    HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
	    HTMLSetCharacterHandling(current_char_set);
	}
	need_reload = TRUE;
    }
    /* end of charset settings */
d3930 1
a3930 1
    BStrFree(newdoc->post_data);
d3933 3
a3935 4
	HTInfoMsg(SAVING_OPTIONS);
	LYrcShowColor = LYChosenShowColor;
	if (save_rc(NULL)) {
	    HTInfoMsg(OPTIONS_SAVED);
d3942 2
a3943 2
     * Exit:  working around the previous document.  Being out of
     * mainloop()/getfile() cycle, do things manually.
d3945 5
a3949 5
    CTRACE((tfp, "\nLYOptions.c/postoptions(): exiting...\n"));
    CTRACE((tfp, "                            need_reload = %s\n",
	    need_reload ? "TRUE" : "FALSE"));
    CTRACE((tfp, "                            need_end_reload = %s\n",
	    need_end_reload ? "TRUE" : "FALSE"));
d3959 2
a3960 2
    LYforce_no_cache = FALSE;	/* ! */
    LYoverride_no_cache = TRUE;	/* ! */
d3970 1
a3970 1
	return (NOT_FOUND);
d3972 2
a3973 1
    HTuncache_current_document();	/* will never use again */
d3976 3
a3978 2
     * Return to previous doc, not to options menu!  Reload the document we had
     * before the options menu but uncache only when necessary (Hurrah, user!):
d3987 2
a3988 2
    LYforce_no_cache = FALSE;	/* see below */
    LYoverride_no_cache = TRUE;	/* see below */
d3997 1
a3997 1
	return (NOT_FOUND);
d4004 4
a4007 4
    reloading = FALSE;		/* set manually */
    /* force end-to-end reload from remote server if change LYUserAgent or
     * language or pref_charset (marked by need_end_reload flag above), from
     * old-style LYK_OPTIONS (mainloop):
d4011 1
a4011 1
	  isLYNXCGI(newdoc->address) == 0))) {
d4013 9
a4021 7
	 * An option has changed which may influence content negotiation, and
	 * the resource is from a http or https or lynxcgi URL (the only
	 * protocols which currently do anything with this information).  Set
	 * reloading = TRUE so that proxy caches will be flushed, which is
	 * necessary until the time when all proxies understand HTTP 1.1 Vary: 
	 * and all Servers properly use it...  Treat like case LYK_RELOAD (see
	 * comments there).  - KW
d4023 2
a4024 2
	reloading = TRUE;	/* global flag */
	need_reload = TRUE;	/* this was probably already TRUE, don't worry */
d4029 2
a4030 2
	CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
	return (NORMAL);
d4035 1
a4035 1
	 * see LYK_RELOAD & LYK_OPTIONS in mainloop for details...
d4038 8
a4045 1
	    srcmode_for_next_retrieval(1);
d4047 1
a4047 1
#ifdef USE_SOURCE_CACHE
d4050 3
a4052 5
	    if (HTcan_reparse_document()) {
		if (!HTreparse_document())
		    srcmode_for_next_retrieval(0);
		CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
		return (NORMAL);
a4055 9
	if (newdoc->post_data != NULL && !newdoc->safe &&
	    confirm_post_resub(newdoc->address, newdoc->title, 2, 1) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    if (HTisDocumentSource()) {
		srcmode_for_next_retrieval(0);
	    }
	    return (NORMAL);
	}

d4060 2
a4061 2
	CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
	return (NULLFILE);
d4067 1
a4067 1
static char *NewSecureValue(void)
a4068 2
    static char oops[] = "?";

d4070 2
a4071 8
    if ((secure_value = typeMallocn(char, 80)) != 0) {
#if defined(RAND_MAX)
	long key = lynx_rand();

#else
	long key = (long) secure_value + (long) time(0);
#endif
	sprintf(secure_value, "%ld", key);
d4074 1
a4074 96
    return oops;
}

#define LABEL_LEN 33

/*
 * Note: the 'value' we are passing here is a local copy of the "same" string
 * as is used in LYrcFile.c to index the savable options.
 */
static void PutLabel(FILE *fp, const char *name,
		     const char *value)
{
    int have = strlen(name);
    int want = LABEL_LEN;
    int need = LYstrExtent(name, have, want);

    fprintf(fp, "&nbsp;&nbsp;%s", name);
    if (will_save_rc(value) && !no_option_save) {
	while (need++ < want)
	    fprintf(fp, "&nbsp;");
    } else {
	want -= 3;
	if (need < want) {
	    fprintf(fp, "&nbsp;");
	    ++need;
	}
	fprintf(fp, "(!)");
	while (need++ < want) {
	    fprintf(fp, "&nbsp;");
	}
    }
    fprintf(fp, ": ");
}

/*
 * For given a list of the .lynxrc names for boolean flags that make up a
 * composite setting, check if any are not writable for the .lynxrc file.  If
 * so, return that name, so the subsequence will_save_rc() check in PutLabel()
 * will flag the composite as not-saved.
 */
static const char *check_if_write_lynxrc(const char **table)
{
    int n;
    const char *result = NULL;

    for (n = 0; table[n] != 0; ++n) {
	result = table[n];
	if (!will_save_rc(result))
	    break;
    }
    return result;
}

/*
 * The options menu treats "Cookies" as a single enumeration, but it is read
 * from lynx.cfg (and perhaps .lynxrc) as a set of booleans.  Check if any are
 * not writable to .lynxrc, so we can show the user. 
 */
static const char *will_save_cookies(void)
{
    static const char *table[] =
    {
	RC_SET_COOKIES,		/* LYSetCookies */
	RC_ACCEPT_ALL_COOKIES,	/* LYAcceptAllCookies */
	NULL
    };

    return check_if_write_lynxrc(table);
}

/*
 * The options menu treats "Show images" as a single enumeration, but it is
 * read from lynx.cfg (and perhaps .lynxrc) as a set of booleans.  Check if any
 * are not writable to .lynxrc, so we can show the user. 
 */
static const char *will_save_images(void)
{
    static const char *table[] =
    {
	RC_MAKE_PSEUDO_ALTS_FOR_INLINES,	/* pseudo_inline_alts */
	RC_MAKE_LINKS_FOR_ALL_IMAGES,	/* clickable_images */
	NULL
    };

    return check_if_write_lynxrc(table);
}

/*
 * The visited-links menu is used from the visited-links page as well as the
 * options page.
 */
void LYMenuVisitedLinks(FILE *fp0, int disable_all)
{
    BeginSelect(fp0, visited_links_string);
    PutOptValues(fp0, Visited_Links_As, visited_links_values);
    EndSelect(fp0);
d4078 1
a4078 1
 * Okay, someone wants to change options.  So, let's gen up a form for them
d4088 2
a4089 1
static int gen_options(char **newfile)
d4092 4
a4095 2
    static char tempfile[LY_MAXPATH] = "\0";
    BOOLEAN disable_all = FALSE;
d4098 1
a4098 1
    size_t text_len = LYscreenWidth() > 45 ? LYscreenWidth() - 38 : 7;	/* cf: PutLabel */
d4100 6
a4105 2
    if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	return (NOT_FOUND);
a4108 11
    /* This should not be needed if we regenerate the temp file every time with
     * a new name, which just happened above in the case
     * LYReuseTempfiles==FALSE.  Even for LYReuseTempfiles=TRUE, code at the
     * end of postoptions() may remove an older cached version from memory if
     * that version of the page was left by submitting changes.  - kw
     * 1999-11-27
     * If access to the actual file via getfile() later fails (maybe because of
     * some restrictions), mainloop may leave this flag on after popping the
     * previous doc which is then unnecessarily reloaded.  But I changed
     * mainloop to reset the flag.  - kw 1999-05-24
     */
d4111 1
a4111 10
    /*
     * Without LYUseFormsOptions set we should maybe not even get here.
     * However, it's possible we do; disable the form in that case. - kw
     */
#ifndef NO_OPTION_MENU
    if (!LYUseFormsOptions)
	disable_all = TRUE;
#endif

    BeginInternalPage(fp0, OPTIONS_TITLE, NULL);	/* help link below */
d4116 1
a4116 1
    fprintf(fp0, "<form action=\"%s\" method=\"post\">\n", STR_LYNXOPTIONS);
d4122 1
a4122 1
    fprintf(fp0, "<input name=\"%s\" type=\"hidden\" value=\"%s\">\n",
d4130 4
a4133 6
    fprintf(fp0, "<p align=center>\n");
    if (!disable_all) {
	fprintf(fp0, "<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0, "<input type=\"reset\" value=\"%s\"> - \n", RESET_CHANGES);
	fprintf(fp0, "%s - \n", CANCEL_CHANGES);
    }
d4135 1
a4135 1
	    helpfilepath, OPTIONS_HELP, TO_HELP);
d4139 3
a4141 7
	if (!disable_all) {
	    fprintf(fp0, "<p align=center>%s: ", SAVE_OPTIONS);
	    fprintf(fp0, "<input type=\"checkbox\" name=\"%s\">\n",
		    save_options_string);
	}
	fprintf(fp0, "<br>%s\n",
		gettext("(options marked with (!) will not be saved)"));
d4147 2
a4148 24
    fprintf(fp0, "<pre>\n");

    fprintf(fp0, "\n  <em>%s</em>\n", gettext("General Preferences"));
    /*****************************************************************/

    /* User Mode: SELECT */
    PutLabel(fp0, gettext("User mode"), user_mode_string);
    BeginSelect(fp0, user_mode_string);
    PutOptValues(fp0, user_mode, user_mode_values);
    EndSelect(fp0);

    /* Editor: INPUT */
    PutLabel(fp0, gettext("Editor"), editor_string);
    PutTextInput(fp0, editor_string, NonNull(editor), text_len,
		 DISABLED(no_editor || system_editor));

    /* Search Type: SELECT */
    PutLabel(fp0, gettext("Type of Search"), search_type_string);
    BeginSelect(fp0, search_type_string);
    PutOptValues(fp0, case_sensitive, search_type_values);
    EndSelect(fp0);

    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Security and Privacy"));
    /*****************************************************************/
d4151 1
a4151 1
    PutLabel(fp0, gettext("Cookies"), will_save_cookies());
d4164 4
a4167 5
    /* Cookie Prompting: SELECT */
    PutLabel(fp0, gettext("Invalid-Cookie Prompting"), cookie_prompt_string);
    BeginSelect(fp0, cookie_prompt_string);
    PutOptValues(fp0, cookie_noprompt, prompt_values);
    EndSelect(fp0);
d4169 4
a4172 5
#ifdef USE_SSL
    /* SSL Prompting: SELECT */
    PutLabel(fp0, gettext("SSL Prompting"), ssl_prompt_string);
    BeginSelect(fp0, ssl_prompt_string);
    PutOptValues(fp0, ssl_noprompt, prompt_values);
a4173 4
#endif

    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Keyboard Input"));
    /*****************************************************************/
d4176 1
a4176 1
    PutLabel(fp0, gettext("Keypad mode"), keypad_mode_string);
a4180 12
    /* Emacs keys: ON/OFF */
    PutLabel(fp0, gettext("Emacs keys"), emacs_keys_string);
    BeginSelect(fp0, emacs_keys_string);
    PutOptValues(fp0, emacs_keys, bool_values);
    EndSelect(fp0);

    /* VI Keys: ON/OFF */
    PutLabel(fp0, gettext("VI keys"), vi_keys_string);
    BeginSelect(fp0, vi_keys_string);
    PutOptValues(fp0, vi_keys, bool_values);
    EndSelect(fp0);

d4182 3
a4184 3
    if (LYLineeditNames[1]) {	/* well, at least 2 line edit styles available */
	PutLabel(fp0, gettext("Line edit style"), lineedit_mode_string);
	BeginSelect(fp0, lineedit_mode_string);
a4186 1

d4188 1
a4188 1
	    PutOption(fp0, i == current_lineedit, temp, LYLineeditNames[i]);
d4192 1
d4195 1
a4195 1
    PutLabel(fp0, gettext("Keyboard layout"), kblayout_string);
a4198 1

d4200 1
a4200 1
	PutOption(fp0, i == current_layout, temp, LYKbLayoutNames[i]);
d4205 4
a4208 5
    /*
     * Display and Character Set
     */
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Display and Character Set"));
    /*****************************************************************/
d4210 4
a4213 5
#ifdef EXP_LOCALE_CHARSET
    /* Use locale-based character set: ON/OFF */
    PutLabel(fp0, gettext("Use locale-based character set"), locale_charset_string);
    BeginSelect(fp0, locale_charset_string);
    PutOptValues(fp0, LYLocaleCharset, bool_values);
d4215 6
a4220 2
#else
#define LYLocaleCharset FALSE
d4222 55
d4279 2
a4280 2
    PutLabel(fp0, gettext("Display character set"), display_char_set_string);
    MaybeSelect(fp0, LYLocaleCharset, display_char_set_string);
a4283 1

d4285 1
a4285 1
	    cset_len = len;
d4287 1
a4287 4
#ifdef EXP_CHARSET_CHOICE
	if (!charset_subsets[i].hide_display)
#endif
	    PutOption(fp0, i == current_char_set, temp, LYchar_set_names[i]);
d4291 9
d4301 1
a4303 1

d4315 1
a4315 1
	PutLabel(fp0, gettext("Assumed document character set"), assume_char_set_string);
d4318 3
a4320 6
#ifdef EXP_CHARSET_CHOICE
	    if (!charset_subsets[i].hide_assumed)
#endif
		PutOption(fp0, i == curval,
			  LYCharSet_UC[i].MIMEname,
			  LYCharSet_UC[i].MIMEname);
d4326 1
a4326 1
    if (LYHaveCJKCharacterSet) {
d4332 3
a4334 4
	PutLabel(fp0, gettext("CJK mode"), raw_mode_string);
    } else {
	PutLabel(fp0, gettext("Raw 8-bit"), raw_mode_string);
    }
d4340 4
a4343 53
    /* X Display: INPUT */
    PutLabel(fp0, gettext("X Display"), x_display_string);
    PutTextInput(fp0, x_display_string, NonNull(x_display), text_len, "");

    /*
     * Document Appearance
     */
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Document Appearance"));
    /*****************************************************************/

    /* Show Color: SELECT */
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    SetupChosenShowColor();
    PutLabel(fp0, gettext("Show color"), show_color_string);
    if (no_option_save) {
	MaybeSelect(fp0, !can_do_colors, show_color_string);
	if (LYShowColor == SHOW_COLOR_NEVER) {
	    LYShowColor = SHOW_COLOR_OFF;
	} else if (LYShowColor == SHOW_COLOR_ALWAYS) {
	    LYShowColor = SHOW_COLOR_ON;
	}
	PutOptValues(fp0, LYShowColor - SHOW_COLOR_OFF, bool_values);
    } else {
	BeginSelect(fp0, show_color_string);
	if (can_do_colors) {
	    show_color_values[2].HtmlName = on_string;
	    show_color_values[3].LongName = always_string;
	} else {
	    show_color_values[2].HtmlName = NULL;	/* suppress "ON" - kw */
	    show_color_values[3].LongName = "Always try";
	}
	PutOptValues(fp0, LYChosenShowColor, show_color_values);
    }
    EndSelect(fp0);
#endif /* USE_SLANG || COLOR_CURSES */

    /* Show cursor: ON/OFF */
    PutLabel(fp0, gettext("Show cursor"), show_cursor_string);
    BeginSelect(fp0, show_cursor_string);
    PutOptValues(fp0, LYShowCursor, bool_values);
    EndSelect(fp0);

    /* Underline links: ON/OFF */
    PutLabel(fp0, gettext("Underline links"), underline_links_string);
    BeginSelect(fp0, underline_links_string);
    PutOptValues(fp0, LYUnderlineLinks, bool_values);
    EndSelect(fp0);

#ifdef USE_SCROLLBAR
    /* Show scrollbar: ON/OFF */
    PutLabel(fp0, gettext("Show scrollbar"), show_scrollbar_string);
    BeginSelect(fp0, show_scrollbar_string);
    PutOptValues(fp0, LYShowScrollbar, bool_values);
a4344 1
#endif
d4347 1
a4347 1
    PutLabel(fp0, gettext("Popups for select fields"), select_popups_string);
a4351 6
    /* HTML error recovery: SELECT */
    PutLabel(fp0, gettext("HTML error recovery"), DTD_recovery_string);
    BeginSelect(fp0, DTD_recovery_string);
    PutOptValues(fp0, Old_DTD, DTD_type_values);
    EndSelect(fp0);

d4353 1
a4353 1
    PutLabel(fp0, gettext("Show images"), will_save_images());
d4356 2
a4357 2
	      images_ignore_all_string,
	      images_ignore_all_string);
d4359 2
a4360 2
	      images_use_label_string,
	      images_use_label_string);
d4362 2
a4363 2
	      images_use_links_string,
	      images_use_links_string);
d4367 1
a4367 1
    PutLabel(fp0, gettext("Verbose images"), verbose_images_string);
d4373 1
a4373 1
     * Headers Transferred to Remote Servers
d4375 1
a4375 3
    fprintf(fp0, "\n  <em>%s</em>\n",
	    gettext("Headers Transferred to Remote Servers"));
    /*****************************************************************/
d4377 15
a4391 4
    /* Mail Address: INPUT */
    PutLabel(fp0, gettext("Personal mail address"), mail_address_string);
    PutTextInput(fp0, mail_address_string,
		 NonNull(personal_mail_address), text_len, "");
d4393 2
a4394 10
    /* Mail Address: INPUT */
    PutLabel(fp0, gettext("Password for anonymous ftp"), mail_address_string);
    PutTextInput(fp0, anonftp_password_string,
		 NonNull(anonftp_password), text_len, "");

    /* Preferred media type: SELECT */
    PutLabel(fp0, gettext("Preferred media type"), preferred_media_string);
    BeginSelect(fp0, preferred_media_string);
    PutOptValues(fp0, LYAcceptMedia, media_values);
    EndSelect(fp0);
d4396 3
a4398 5
    /* Preferred encoding: SELECT */
    PutLabel(fp0, gettext("Preferred encoding"), preferred_encoding_string);
    BeginSelect(fp0, preferred_encoding_string);
    PutOptValues(fp0, LYAcceptEncoding, encoding_values);
    EndSelect(fp0);
d4400 4
a4403 15
    /* Preferred Document Character Set: INPUT */
    PutLabel(fp0, gettext("Preferred document character set"), preferred_doc_char_string);
    PutTextInput(fp0, preferred_doc_char_string,
		 NonNull(pref_charset), cset_len + 2, "");

    /* Preferred Document Language: INPUT */
    PutLabel(fp0, gettext("Preferred document language"), preferred_doc_lang_string);
    PutTextInput(fp0, preferred_doc_lang_string,
		 NonNull(language), cset_len + 2, "");

    /* User Agent: INPUT */
    if (!no_useragent) {
	PutLabel(fp0, gettext("User-Agent header"), user_agent_string);
	PutTextInput(fp0, user_agent_string,
		     NonNull(LYUserAgent), text_len, "");
d4407 1
a4407 1
     * Listing and Accessing Files
d4409 1
a4409 2
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Listing and Accessing Files"));
    /*****************************************************************/
d4412 1
a4412 1
    PutLabel(fp0, gettext("FTP sort criteria"), ftp_sort_string);
d4419 1
a4419 7
    PutLabel(fp0, gettext("Local directory sort criteria"), dired_list_string);
    BeginSelect(fp0, dired_list_string);
    PutOptValues(fp0, dir_list_style, dired_list_values);
    EndSelect(fp0);
#ifdef LONG_LIST
    /* Local Directory Order: SELECT */
    PutLabel(fp0, gettext("Local directory sort order"), dired_sort_string);
d4421 1
a4421 1
    PutOptValues(fp0, dir_list_order, dired_sort_values);
a4422 1
#endif /* LONG_LIST */
d4427 1
a4427 1
	PutLabel(fp0, gettext("Show dot files"), show_dotfiles_string);
d4434 2
a4435 2
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    PutLabel(fp0, gettext("Execution links"), exec_links_string);
d4439 5
a4443 5
		 ? EXEC_ALWAYS
		 : (local_exec_on_local_files
		    ? EXEC_LOCAL
		    : EXEC_NEVER),
		 exec_links_values);
d4446 3
a4448 3
		 ? EXEC_LOCAL
		 : EXEC_NEVER,
		 exec_links_values);
d4451 1
a4451 20
#endif /* ENABLE_OPTS_CHANGE_EXEC */

#ifdef USE_READPROGRESS
    /* Show transfer rate: SELECT */
    PutLabel(fp0, gettext("Show transfer rate"), show_rate_string);
    BeginSelect(fp0, show_rate_string);
    for (i = 0; rate_values[i].LongName != 0; ++i) {
	char *message = NULL;

	HTSprintf0(&message,
		   rate_values[i].LongName,
		   HTProgressUnits(rate_values[i].value));
	PutOption(fp0,
		  LYTransferRate == rate_values[i].value,
		  rate_values[i].HtmlName,
		  message);
	FREE(message);
    }
    EndSelect(fp0);
#endif /* USE_READPROGRESS */
d4454 1
a4454 1
     * Special Files and Screens
d4456 6
a4461 2
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Special Files and Screens"));
    /*****************************************************************/
d4463 4
a4466 7
    /* Multi-Bookmark Mode: SELECT */
    if (!LYMBMBlocked) {
	PutLabel(fp0, gettext("Multi-bookmarks"), mbm_string);
	BeginSelect(fp0, mbm_string);
	PutOptValues(fp0, LYMultiBookmarks, mbm_values);
	EndSelect(fp0);
    }
d4468 5
a4472 9
    /* Bookmarks File Menu: LINK/INPUT */
    if (LYMultiBookmarks) {
	PutLabel(fp0, gettext("Review/edit Bookmarks files"), mbm_string);
	fprintf(fp0, "<a href=\"%s\">%s</a>\n",
		LYNXOPTIONS_PAGE(MBM_LINK), gettext("Goto multi-bookmark menu"));
    } else {
	PutLabel(fp0, gettext("Bookmarks file"), single_bookmark_string);
	PutTextInput(fp0, single_bookmark_string,
		     NonNull(bookmark_page), text_len, "");
d4475 3
a4477 8
    /* Visited Pages: SELECT */
    PutLabel(fp0, gettext("Visited Pages"), visited_links_string);
    LYMenuVisitedLinks(fp0, disable_all);

    if (!no_lynxcfg_info) {
	fprintf(fp0, "\n  %s<a href=\"%s\">lynx.cfg</a>.\n",
		gettext("View the file "),
		STR_LYNXCFG);
d4480 1
a4480 1
    fprintf(fp0, "\n</pre>\n");
d4483 4
a4486 6
    if (!disable_all) {
	fprintf(fp0, "<p align=center>\n");
	fprintf(fp0, "<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0, "<input type=\"reset\" value=\"%s\"> - \n", RESET_CHANGES);
	fprintf(fp0, "%s\n", CANCEL_CHANGES);
    }
d4491 1
a4491 1
    fprintf(fp0, "</form>\n");
d4495 1
a4495 1
    return (NORMAL);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a23 1
#include <HTFile.h>
a28 2
PRIVATE int LYChosenShowColor = SHOW_COLOR_UNKNOWN; /* whether to show and save */

d31 1
a31 1
#if !defined(NO_OPTION_MENU) || (defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES)))
a34 83
#if defined(USE_SLANG) || defined(COLOR_CURSES)
PRIVATE BOOLEAN can_do_colors = FALSE;
#endif

PUBLIC BOOLEAN LYCheckUserAgent NOARGS
{
    if (LYUserAgent && *LYUserAgent) {
	if (strstr(LYUserAgent, "Lynx") == 0
	 && strstr(LYUserAgent, "lynx") == 0
	 && strstr(LYUserAgent, "L_y_n_x") == 0
	 && strstr(LYUserAgent, "l_y_n_x") == 0) {
	    return FALSE;
	}
    }
    return TRUE;
}

PRIVATE void SetupChosenShowColor NOARGS
{
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    can_do_colors = TRUE;
#if defined(COLOR_CURSES)
    if (LYCursesON)	/* could crash if called before initialization */
	can_do_colors = (BOOL) has_colors();
#endif
    if (!no_option_save) {
	if (LYChosenShowColor == SHOW_COLOR_UNKNOWN) {
	    switch (LYrcShowColor) {
	    case SHOW_COLOR_NEVER:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
			SHOW_COLOR_ON : SHOW_COLOR_NEVER;
		break;
	    case SHOW_COLOR_ALWAYS:
		if (!can_do_colors)
		    LYChosenShowColor = SHOW_COLOR_ALWAYS;
		else
		    LYChosenShowColor =
			(LYShowColor >= SHOW_COLOR_ON) ?
				SHOW_COLOR_ALWAYS : SHOW_COLOR_OFF;
		break;
	    default:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
			SHOW_COLOR_ON : SHOW_COLOR_OFF;
	    }
	}
    }
#endif /* USE_SLANG || COLOR_CURSES */
}

PRIVATE void validate_x_display NOPARAMS
{
    char *cp;
    if ((cp = LYgetXDisplay()) != NULL) {
	StrAllocCopy(x_display, cp);
    } else {
	FREE(x_display);
    }
}

PRIVATE void summarize_x_display ARGS1(
    char *,	display_option)
{
    if ((x_display == NULL && *display_option == '\0') ||
	(x_display != NULL && !strcmp(x_display, display_option))) {
	if (x_display == NULL && LYisConfiguredForX == TRUE) {
	    _statusline(VALUE_ACCEPTED_WARNING_X);
	} else if (x_display != NULL && LYisConfiguredForX == FALSE) {
	    _statusline(VALUE_ACCEPTED_WARNING_NONX);
	} else {
	    _statusline(VALUE_ACCEPTED);
	}
    } else {
	if (*display_option) {
	    _statusline(FAILED_TO_SET_DISPLAY);
	} else {
	    _statusline(FAILED_CLEAR_SET_DISPLAY);
	}
    }
}


d40 1
a40 3
	CONST char **	choices));
#define LYChooseBoolean(status, line, column, choices) \
	boolean_choice(status, line, column, (CONST char **)choices)
d106 11
a116 11
#define L_Bool_A     (use_assume_charset ? L_BOOL_A     + 1 : L_BOOL_A)
#define L_Bool_B     (use_assume_charset ? L_BOOL_B     + 1 : L_BOOL_B)
#define L_Exec       (use_assume_charset ? L_EXEC       + 1 : L_EXEC)
#define L_Rawmode    (use_assume_charset ? L_RAWMODE    + 1 : L_RAWMODE)
#define L_Charset    (use_assume_charset ? L_CHARSET    + 1 : L_CHARSET)
#define L_Color      (use_assume_charset ? L_COLOR      + 1 : L_COLOR)
#define L_Keypad     (use_assume_charset ? L_KEYPAD     + 1 : L_KEYPAD)
#define L_Lineed     (use_assume_charset ? L_LINEED     + 1 : L_LINEED)
#define L_Layout     (use_assume_charset ? L_LAYOUT     + 1 : L_LAYOUT)
#define L_Dired      (use_assume_charset ? L_DIRED      + 1 : L_DIRED)
#define L_User_Mode  (use_assume_charset ? L_USER_MODE  + 1 : L_USER_MODE)
d126 1
a126 1
	LYaddstr(text);
d132 1
a132 1
 * addlbl() is used instead of plain LYaddstr() in old-style options menu
a158 15
#if !defined(VMS) || defined(USE_SLANG)
#define HANDLE_LYOPTIONS \
		    if (term_options) { \
			term_options = FALSE; \
		    } else { \
			AddValueAccepted = TRUE; \
		    } \
		    goto draw_options
#else
#define HANDLE_LYOPTIONS \
		    term_options = FALSE; \
		    if (use_assume_charset != old_use_assume_charset) \
			goto draw_options
#endif /* !VMS || USE_SLANG */

d161 1
a161 53
#define ShowBool(value) LYaddstr((value) ? "ON " : "OFF")
    static char *bool_choices[] = {
	"OFF",
	"ON",
	NULL
    };
    static char *caseless_choices[] = {
	"CASE INSENSITIVE",
	"CASE SENSITIVE",
	NULL
    };
    static char *dirList_choices[] = {
	"Directories first",
	"Files first",
	"Mixed style",
	NULL
    };
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    static char *exec_choices[] = {
	"ALWAYS OFF",
	"FOR LOCAL FILES ONLY",
#ifndef NEVER_ALLOW_REMOTE_EXEC
	"ALWAYS ON",
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
	NULL
    };
#endif
    static char *fileSort_choices[] = {
	"By Filename",
	"By Type",
	"By Size",
	"By Date",
	NULL
    };
    static char *keypad_choices[] = {
	"Numbers act as arrows",
	"Links are numbered",
	"Links and form fields are numbered",
	NULL
    };
    static char *mbm_choices[] = {
	"OFF     ",
	"STANDARD",
	"ADVANCED",
	NULL
    };
    static char *userMode_choices[] = {
	"Novice",
	"Intermediate",
	"Advanced",
	NULL
    };
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
d163 1
a163 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d179 1
a179 1
#ifdef ENABLE_OPTS_CHANGE_EXEC
d189 1
a189 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d191 1
a191 1
#ifdef ENABLE_OPTS_CHANGE_EXEC
d201 1
a201 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d215 26
a240 1
	SetupChosenShowColor();
d245 1
a245 1
	use_assume_charset = (BOOL) (user_mode == ADVANCED_MODE);
d254 1
d257 1
a257 1
	LYclear();
d259 1
a259 1
	LYerase();
d262 1
a262 1
    LYclear();
d264 1
a264 1
    LYmove(0, 5);
d267 5
a271 5
    LYaddstr("         Options Menu (");
    LYaddstr(LYNX_NAME);
    LYaddstr(" Version ");
    LYaddstr(LYNX_VERSION);
    LYaddch(')');
d273 1
a273 1
    LYmove(L_EDITOR, 5);
d275 1
a275 1
    LYaddstr((editor && *editor) ? editor : "NONE");
d277 1
a277 1
    LYmove(L_DISPLAY, 5);
d279 1
a279 1
    LYaddstr((x_display && *x_display) ? x_display : "NONE");
d281 1
a281 1
    LYmove(L_HOME, 5);
d283 6
a288 3
    LYaddstr(mbm_choices[LYMultiBookmarks]);
    LYmove(L_HOME, B_BOOK);
    if (LYMultiBookmarks != MBM_OFF) {
d292 1
a292 1
	LYaddstr((bookmark_page && *bookmark_page) ? bookmark_page : "NONE");
d295 1
a295 1
    LYmove(L_FTPSTYPE, 5);
d297 1
a297 1
    LYaddstr((HTfileSortMethod == FILE_BY_NAME ? "By Filename" :
d302 1
a302 1
    LYmove(L_MAIL_ADDRESS, 5);
d304 1
a304 1
    LYaddstr((personal_mail_address && *personal_mail_address) ?
d307 1
a307 1
    LYmove(L_SSEARCH, 5);
d309 1
a309 1
    LYaddstr(case_sensitive ? "CASE SENSITIVE  " : "CASE INSENSITIVE");
d311 1
a311 1
    LYmove(L_Charset, 5);
d313 1
a313 1
    LYaddstr(LYchar_set_names[current_char_set]);
d315 1
a315 1
    LYmove(L_LANGUAGE, 5);
d317 1
a317 1
    LYaddstr((language && *language) ? language : "NONE");
d319 1
a319 1
    LYmove(L_PREF_CHARSET, 5);
d321 1
a321 1
    LYaddstr((pref_charset && *pref_charset) ? pref_charset : "NONE");
d324 1
a324 1
	LYmove(L_ASSUME_CHARSET, 5);
d327 1
a327 1
	    LYaddstr(UCAssume_MIMEcharset);
d329 2
a330 2
	    LYaddstr((UCLYhndl_for_unspec >= 0) ?
		     LYCharSet_UC[UCLYhndl_for_unspec].MIMEname
d334 1
a334 1
    LYmove(L_Rawmode, 5);
d336 1
a336 1
    ShowBool(LYRawMode);
d339 1
a339 1
    LYmove(L_Color, B_COLOR);
d342 2
a343 1
	ShowBool(LYShowColor == SHOW_COLOR_OFF);
d347 1
a347 1
		LYaddstr("NEVER     ");
d350 1
a350 1
		LYaddstr("OFF");
d353 1
a353 1
		LYaddstr("ON ");
d358 1
a358 1
		    LYaddstr("Always try");
d361 1
a361 1
		    LYaddstr("ALWAYS    ");
d366 1
a366 1
    LYmove(L_Bool_A, B_VIKEYS);
d368 1
a368 1
    ShowBool(vi_keys);
d370 1
a370 1
    LYmove(L_Bool_A, B_EMACSKEYS);
d372 1
a372 1
    ShowBool(emacs_keys);
d374 1
a374 1
    LYmove(L_Bool_A, B_SHOW_DOTFILES);
d376 1
a376 1
    ShowBool(!no_dotfiles && show_dotfiles);
d378 1
a378 1
    LYmove(L_Bool_B, B_SELECT_POPUPS);
d380 1
a380 1
    ShowBool(LYSelectPopups);
d382 1
a382 1
    LYmove(L_Bool_B, B_SHOW_CURSOR);
d384 1
a384 1
    ShowBool(LYShowCursor);
d386 1
a386 1
    LYmove(L_Keypad, 5);
d388 5
a392 7
    LYaddstr(fields_are_numbered() && links_are_numbered()
		? "Links and form fields are numbered"
		: links_are_numbered()
		? "Links are numbered                "
		: fields_are_numbered()
		? "Form fields are numbered          "
		: "Numbers act as arrows             ");
d394 1
a394 1
    LYmove(L_Lineed, 5);
d396 1
a396 1
    LYaddstr(LYLineeditNames[current_lineedit]);
d399 1
a399 1
    LYmove(L_Layout, 5);
d401 1
a401 1
    LYaddstr(LYKbLayoutNames[current_layout]);
d405 1
a405 1
    LYmove(L_Dired, 5);
d407 1
a407 1
    LYaddstr((dir_list_style == FILES_FIRST) ? "Files first      " :
d412 1
a412 1
    LYmove(L_User_Mode, 5);
d414 1
a414 1
    LYaddstr(  (user_mode == NOVICE_MODE) ? "Novice      " :
d419 1
a419 1
    ShowBool( verbose_img);
d421 1
a421 1
    LYmove(L_User_Agent, 5);
d423 1
a423 1
    LYaddstr((LYUserAgent && *LYUserAgent) ? LYUserAgent : "NONE");
d425 2
a426 2
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    LYmove(L_Exec, 5);
d429 1
a429 1
    LYaddstr(               local_exec ? "ALWAYS ON           " :
d433 1
a433 1
    LYaddstr(local_exec_on_local_files ? "FOR LOCAL FILES ONLY" :
d436 1
a436 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d438 2
a439 2
    LYmove(LYlines-3, 2);
    LYaddstr(SELECT_SEGMENT);
d441 1
a441 1
    LYaddstr(CAP_LETT_SEGMENT);
d443 1
a443 1
    LYaddstr(OF_OPT_LINE_SEGMENT);
d445 1
a445 1
	LYaddstr(" '");
d447 1
a447 1
	LYaddstr(">");
d449 2
a450 2
	LYaddstr("'");
	LYaddstr(TO_SAVE_SEGMENT);
d452 2
a453 2
    LYaddstr(OR_SEGMENT);
    LYaddstr("'");
d455 1
a455 1
    LYaddstr("r");
d457 2
a458 2
    LYaddstr("'");
    LYaddstr(TO_RETURN_SEGMENT);
d460 1
a460 2
    response = 0;
    while (response != 'R' &&
d463 1
a463 1
	   !LYCharIsINTERRUPT_NO_letter(response)) {
d468 1
a468 1
	LYmove((LYlines - 2), 0);
d470 1
a470 1
	LYaddstr(COMMAND_PROMPT);
d473 3
a475 3
	LYrefresh();
	response = LYgetch_single();
	if (term_options || LYCharIsINTERRUPT_NO_letter(response))
d482 2
a483 1
	    case 'E':	/* Change the editor. */
d490 1
a490 1
			LYstrncpy(display_option, editor, sizeof(display_option) - 1);
d492 2
a493 2
			LYmove(L_EDITOR, COL_OPTION_VALUES);
			LYaddstr("    ");
d497 1
a497 1
		    LYmove(L_EDITOR, COL_OPTION_VALUES);
d502 1
a502 1
		    LYmove(L_EDITOR, COL_OPTION_VALUES);
d504 1
a504 1
			LYaddstr((editor && *editor) ?
d508 1
a508 1
			LYaddstr("NONE");
d511 1
a511 1
			LYaddstr(display_option);
d513 1
a513 1
		    LYclrtoeol();
d524 2
a525 1
	    case 'D':	/* Change the display. */
d527 1
a527 1
		    LYstrncpy(display_option, x_display, sizeof(display_option) - 1);
d529 2
a530 2
		    LYmove(L_DISPLAY, COL_OPTION_VALUES);
		    LYaddstr("    ");
d534 1
a534 1
		LYmove(L_DISPLAY, COL_OPTION_VALUES);
d539 3
a541 2
		LYmove(L_DISPLAY, COL_OPTION_VALUES);

d543 1
a543 1
#define CompareEnvVars(a,b) strcasecomp(a, b)
d545 1
a545 1
#define CompareEnvVars(a,b) strcmp(a, b)
d547 1
a547 4

		if ((term_options || ch == -1) ||
		    (x_display != NULL &&
		     !CompareEnvVars(x_display, display_option))) {
d552 2
a553 2
		    LYaddstr((x_display && *x_display) ? x_display : "NONE");
		    LYclrtoeol();
d569 2
a570 2
			LYaddstr("NONE");
			LYclrtoeol();
d580 5
a584 1
		validate_x_display();
d586 21
a606 3
		LYaddstr(x_display ? x_display : "NONE");
		LYclrtoeol();
		summarize_x_display(display_option);
d610 2
a611 1
	    case 'L':	/* Change multibookmarks option. */
d617 7
d625 2
a626 1
		    LYMultiBookmarks = LYChooseBoolean(LYMultiBookmarks,
d628 1
a628 1
						      mbm_choices);
d630 2
a631 1
		    LYMultiBookmarks = LYChoosePopup(LYMultiBookmarks,
d633 8
a640 2
						    mbm_choices,
						    3, FALSE, FALSE);
d644 3
a646 3
		    LYmove(L_HOME, C_MULTI);
		    LYclrtoeol();
		    LYaddstr(mbm_choices[LYMultiBookmarks]);
d649 3
d656 4
a659 4
		    LYmove(L_HOME, B_BOOK);
		    LYclrtoeol();
		    if (LYMultiBookmarks != MBM_OFF) {
			LYaddstr(gettext("review/edit B)ookmarks files"));
d661 2
a662 2
			LYaddstr(gettext("B)ookmark file: "));
			LYaddstr((bookmark_page && *bookmark_page) ?
d668 10
a677 1
		    HANDLE_LYOPTIONS;
d681 2
a682 1
	    case 'B':	/* Change the bookmark page location. */
d688 1
a688 1
		    if (LYMultiBookmarks != MBM_OFF) {
d694 1
a694 1
			LYstrncpy(display_option, bookmark_page, sizeof(display_option) - 1);
d696 2
a697 2
			LYmove(L_HOME, C_DEFAULT);
			LYclrtoeol();
d701 1
a701 1
		    LYmove(L_HOME, C_DEFAULT);
d706 1
a706 1
		    LYmove(L_HOME, C_DEFAULT);
d709 1
a709 1
			LYaddstr((bookmark_page && *bookmark_page) ?
d713 1
a713 1
			LYaddstr((bookmark_page && *bookmark_page) ?
d715 1
a715 1
			LYclrtoeol();
d721 3
a723 2
			StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
			LYaddstr(bookmark_page);
d725 1
a725 1
		    LYclrtoeol();
d738 14
a751 1
	    case 'F':	/* Change ftp directory sorting. */
d753 1
a753 1
		    HTfileSortMethod = LYChooseBoolean(HTfileSortMethod,
d755 1
a755 1
						      fileSort_choices);
d757 1
a757 1
		    HTfileSortMethod = LYChoosePopup(HTfileSortMethod,
d759 2
a760 2
						    fileSort_choices,
						    4, FALSE, FALSE);
d762 3
a764 3
		    LYmove(L_FTPSTYPE, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(fileSort_choices[HTfileSortMethod]);
d767 4
d773 10
a782 1
		    HANDLE_LYOPTIONS;
d786 2
a787 1
	    case 'P': /* Change personal mail address for From headers. */
d789 1
a789 1
		    LYstrncpy(display_option, personal_mail_address, sizeof(display_option) - 1);
d791 2
a792 2
		    LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
		    LYaddstr("    ");
d796 1
a796 1
		LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
d801 1
a801 1
		LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
d803 1
a803 1
		    LYaddstr((personal_mail_address &&
d808 1
a808 1
		    LYaddstr("NONE");
d811 1
a811 1
		    LYaddstr(display_option);
d813 1
a813 1
		LYclrtoeol();
d823 14
a836 4
	    case 'S':	/* Change case sensitivity for searches. */
		case_sensitive = LYChooseBoolean(case_sensitive,
						 L_SSEARCH, -1,
						 caseless_choices);
d843 2
a844 2
		    CONST char ** assume_list;
		    assume_list = typecallocn(CONST char *,(LYNumCharsets + 1));
d849 1
a849 1
			assume_list[i] = LYCharSet_UC[i].MIMEname;
d858 1
a858 9
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
			UCLYhndl_for_unspec = assumed_doc_charset_map[
			    LYChooseBoolean(charset_subsets[curval].assumed_idx,
					    L_ASSUME_CHARSET, -1,
					    assumed_charset_choices)
					    ? 1
					    : 0];
#else
			UCLYhndl_for_unspec = LYChooseBoolean(curval,
a860 1
#endif
d862 1
a862 10
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
			UCLYhndl_for_unspec = assumed_doc_charset_map[
			    LYChoosePopup(charset_subsets[curval].assumed_idx,
					  L_ASSUME_CHARSET, -1,
					  assumed_charset_choices,
					  0, FALSE, FALSE)
					  ? 1
					  : 0];
#else
			UCLYhndl_for_unspec = LYChoosePopup(curval,
d865 1
a865 2
							   0, FALSE, FALSE);
#endif
d867 2
a868 2
			LYmove(L_ASSUME_CHARSET, COL_OPTION_VALUES);
			LYclrtoeol();
d870 2
a871 1
			    LYaddstr(LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d885 1
a885 2
			if (HTCJK != JAPANESE)
			    LYRawMode = (BOOL) (UCLYhndl_for_unspec == current_char_set);
d894 3
a896 3
			    LYmove(L_Rawmode, COL_OPTION_VALUES);
			    LYclrtoeol();
			    ShowBool(LYRawMode);
d902 10
a911 1
			HANDLE_LYOPTIONS;
d919 2
a920 1
	    case 'C':	/* Change display charset setting. */
d922 1
a922 2
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		    displayed_display_charset_idx = LYChooseBoolean(displayed_display_charset_idx,
d924 1
a924 7
						      display_charset_choices);
		    current_char_set = display_charset_map[displayed_display_charset_idx];
#else
		    current_char_set = LYChooseBoolean(current_char_set,
						      L_Charset, -1,
						      LYchar_set_names);
#endif
d926 1
a926 8
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		    displayed_display_charset_idx = LYChoosePopup(displayed_display_charset_idx,
						    L_Charset, -1,
						    display_charset_choices,
						    0, FALSE, FALSE);
		    current_char_set = display_charset_map[displayed_display_charset_idx];
#else
		    current_char_set = LYChoosePopup(current_char_set,
d928 2
a929 4
						    LYchar_set_names,
						    0, FALSE, FALSE);
#endif

d931 3
a933 3
		    LYmove(L_Charset, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(LYchar_set_names[current_char_set]);
d949 4
a952 10
			LYmove(L_Rawmode, COL_OPTION_VALUES);
			LYclrtoeol();
			ShowBool(LYRawMode);
		    }
#ifdef CAN_SWITCH_DISPLAY_CHARSET
		    /* Deduce whether the user wants autoswitch: */
		    switch_display_charsets =
			(current_char_set == auto_display_charset
			    || current_char_set == auto_other_display_charset);
#endif
d956 10
a965 1
		    HANDLE_LYOPTIONS;
d969 11
a979 2
	    case 'O':	/* Change raw mode setting. */
		LYRawMode = LYChooseBoolean(LYRawMode, L_Rawmode, -1, bool_choices);
d989 2
d994 2
a995 1
	    case 'G':	/* Change language preference. */
d997 1
a997 1
		    LYstrncpy(display_option, language, sizeof(display_option) - 1);
d999 2
a1000 2
		    LYmove(L_LANGUAGE, COL_OPTION_VALUES);
		    LYaddstr("    ");
d1004 1
a1004 1
		LYmove(L_LANGUAGE, COL_OPTION_VALUES);
d1009 1
a1009 1
		LYmove(L_LANGUAGE, COL_OPTION_VALUES);
d1011 1
a1011 1
		    LYaddstr((language && *language) ?
d1015 1
a1015 1
		    LYaddstr("NONE");
d1018 1
a1018 1
		    LYaddstr(display_option);
d1020 1
a1020 1
		LYclrtoeol();
d1030 2
a1031 1
	    case 'H':	/* Change charset preference. */
d1033 1
a1033 1
		    LYstrncpy(display_option, pref_charset, sizeof(display_option) - 1);
d1035 2
a1036 2
		    LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
		    LYaddstr("    ");
d1040 1
a1040 1
		LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
d1045 1
a1045 1
		LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
d1047 1
a1047 1
		    LYaddstr((pref_charset && *pref_charset) ?
d1051 1
a1051 1
		    LYaddstr("NONE");
d1054 1
a1054 1
		    LYaddstr(display_option);
d1056 1
a1056 1
		LYclrtoeol();
d1066 11
a1076 2
	    case 'V':	/* Change VI keys setting. */
		vi_keys = LYChooseBoolean(vi_keys,
d1078 1
a1078 1
					 bool_choices);
d1084 2
d1090 10
a1099 1
		emacs_keys = LYChooseBoolean(emacs_keys,
d1101 1
a1101 1
					    bool_choices);
d1107 2
d1113 1
d1117 9
a1125 1
		    show_dotfiles = LYChooseBoolean(show_dotfiles,
d1128 3
a1130 1
						   bool_choices);
d1135 11
a1145 2
	    case 'T':	/* Change select popups setting. */
		LYSelectPopups = LYChooseBoolean(LYSelectPopups,
d1148 3
a1150 1
						bool_choices);
d1159 1
a1159 1
			char * terminal = LYGetEnv("TERM");
a1165 1
			break;
d1168 9
a1176 1
		    LYShowColor = LYChooseBoolean((LYShowColor - 1),
d1179 1
a1179 1
						 bool_choices);
d1188 3
a1190 3
		    /*
		     *  Copy strings into choice array.
		     */
d1207 1
a1207 1
			    chosen = LYChooseBoolean(LYChosenShowColor,
d1212 1
a1212 1
			    chosen = LYChoosePopup(LYChosenShowColor,
d1215 1
a1215 1
						  choices, 4, FALSE, FALSE);
d1218 1
a1218 1
			again = (BOOL) (chosen == SHOW_COLOR_ON && !has_colors());
d1220 1
a1220 1
			    char * terminal = LYGetEnv("TERM");
d1233 3
a1235 3
			LYmove(L_Color, C_COLOR);
			LYclrtoeol();
			LYaddstr(choices[LYChosenShowColor]);
a1241 2
		    FREE(choices[0]);
		    FREE(choices[1]);
d1245 2
d1252 1
a1252 1
		SLtt_Use_Ansi_Colors = (LYShowColor > SHOW_COLOR_OFF ? TRUE : FALSE);
d1256 10
a1265 1
		    HANDLE_LYOPTIONS;
d1271 9
a1279 1
		LYShowCursor = LYChooseBoolean(LYShowCursor,
d1282 3
a1284 1
					      bool_choices);
d1288 15
a1302 1
	    case 'K':	/* Change keypad mode. */
d1304 1
a1304 1
		    keypad_mode = LYChooseBoolean(keypad_mode,
d1306 1
a1306 1
						 keypad_choices);
d1308 4
a1311 4
		    keypad_mode = LYChoosePopup(keypad_mode,
						L_Keypad, -1,
						keypad_choices,
						3, FALSE, FALSE);
d1313 3
a1315 3
		    LYmove(L_Keypad, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(keypad_choices[keypad_mode]);
d1323 3
d1328 10
a1337 1
		    HANDLE_LYOPTIONS;
d1341 2
a1342 1
	    case 'N':	/* Change line editor key bindings. */
d1344 1
a1344 1
		    current_lineedit = LYChooseBoolean(current_lineedit,
d1348 1
a1348 1
		    current_lineedit = LYChoosePopup(current_lineedit,
d1351 1
a1351 1
						    0, FALSE, FALSE);
d1353 3
a1355 3
		    LYmove(L_Lineed, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(LYLineeditNames[current_lineedit]);
d1360 10
a1369 1
		    HANDLE_LYOPTIONS;
d1374 2
a1375 1
	    case 'Y':	/* Change keyboard layout */
d1377 1
a1377 1
		    current_layout = LYChooseBoolean(current_layout,
d1381 1
a1381 1
		    current_layout = LYChoosePopup(current_layout,
d1384 1
a1384 1
						    0, FALSE, FALSE);
d1386 3
a1388 3
		    LYmove(L_Layout, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(LYKbLayoutNames[current_layout]);
d1393 10
a1402 1
		    HANDLE_LYOPTIONS;
d1408 12
a1419 1
	    case 'I':	/* Change local directory sorting. */
d1421 1
a1421 1
		    dir_list_style = LYChooseBoolean(dir_list_style,
d1423 1
a1423 1
						    dirList_choices);
d1425 1
a1425 1
		    dir_list_style = LYChoosePopup(dir_list_style,
d1427 2
a1428 2
						  dirList_choices,
						  3, FALSE, FALSE);
d1430 3
a1432 3
		    LYmove(L_Dired, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(dirList_choices[dir_list_style]);
d1435 3
d1440 10
a1449 1
		    HANDLE_LYOPTIONS;
d1454 12
a1465 1
	    case 'U':	/* Change user mode. */
d1467 10
a1476 10
		    user_mode = LYChooseBoolean(user_mode,
						L_User_Mode, -1,
						userMode_choices);
		    use_assume_charset = (BOOL) (user_mode >= 2);
		} else {
		    user_mode = LYChoosePopup(user_mode,
					      L_User_Mode, -1,
					      userMode_choices,
					      3, FALSE, FALSE);
		    use_assume_charset = (BOOL) (user_mode >= 2);
d1479 3
a1481 3
			LYmove(L_User_Mode, COL_OPTION_VALUES);
			LYclrtoeol();
			LYaddstr(userMode_choices[user_mode]);
d1485 3
d1495 12
a1506 1
		    HANDLE_LYOPTIONS;
d1511 8
d1520 1
a1520 1
		    verbose_img = LYChooseBoolean(verbose_img,
d1523 1
a1523 1
						bool_choices);
d1525 1
a1525 1
		    verbose_img = LYChoosePopup(verbose_img,
d1528 2
a1529 2
					     bool_choices,
					     2, FALSE, FALSE);
d1531 2
d1535 12
a1546 1
		    HANDLE_LYOPTIONS;
d1550 2
a1551 1
	    case 'A':	/* Change user agent string. */
d1554 1
a1554 1
			LYstrncpy(display_option, LYUserAgent, sizeof(display_option) - 1);
d1556 2
a1557 2
			LYmove(L_HOME, COL_OPTION_VALUES);
			LYaddstr("    ");
d1561 1
a1561 1
		    LYmove(L_User_Agent, COL_OPTION_VALUES);
d1566 1
a1566 1
		    LYmove(L_User_Agent, COL_OPTION_VALUES);
d1568 1
a1568 1
			LYaddstr((LYUserAgent &&
d1573 1
a1573 1
			LYaddstr((LYUserAgent &&
d1578 1
a1578 1
			LYaddstr(display_option);
d1580 1
a1580 1
		    LYclrtoeol();
d1584 4
a1587 2
		    } else if (!LYCheckUserAgent()) {
			_statusline(UA_PLEASE_USE_LYNX);
d1592 1
a1592 1
		    _statusline(UA_CHANGE_DISABLED);
d1597 3
a1599 2
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
	    case 'X':	/* Change local exec restriction. */
d1617 12
d1630 1
a1630 1
		    itmp = LYChooseBoolean(itmp,
d1632 1
a1632 1
					  exec_choices);
d1634 1
a1634 1
		    itmp = LYChoosePopup(itmp,
d1636 2
a1637 3
					exec_choices,
					0, (exec_frozen ? TRUE : FALSE),
					FALSE);
d1639 3
a1641 3
		    LYmove(L_Exec, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(exec_choices[itmp]);
d1644 5
d1669 10
a1678 1
		    HANDLE_LYOPTIONS;
d1681 1
a1681 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d1685 4
a1688 4
		    HTInfoMsg(SAVING_OPTIONS);
		    LYrcShowColor = LYChosenShowColor;
		    if (save_rc(NULL)) {
			HTInfoMsg(OPTIONS_SAVED);
d1693 1
a1693 1
		    HTInfoMsg(R_TO_RETURN_TO_LYNX);
d1702 2
a1703 1
	    case 'R':	/* Return to document (quit options menu). */
d1708 1
a1708 1
		    HTInfoMsg(SAVE_OR_R_TO_RETURN_TO_LYNX);
d1710 1
a1710 1
		    HTInfoMsg(R_TO_RETURN_TO_LYNX);
a1719 22
PRIVATE int widest_choice ARGS1(
	CONST char **,	choices)
{
    int n, width = 0;
    for (n = 0; choices[n] != NULL; ++n) {
	int len = strlen(choices[n]);
	if (width < len)
	    width = len;
    }
    return width;
}

PRIVATE void show_choice ARGS2(
	CONST char *,	choice,
	int,		width)
{
    int len = strlen(choice);
    LYaddstr(choice);
    while (len++ < width)
	LYaddch(' ');
}

d1721 2
a1722 1
 *  Take a status code, prompt the user for a new status, and return it.
d1728 1
a1728 1
	CONST char **,	choices)
a1734 1
    int width = widest_choice(choices);
d1752 1
a1752 1
    LYmove(line, col);
d1754 1
a1754 1
    show_choice(choices[cur_choice], width);
d1756 2
a1757 2
	LYmove(line, (col - 1));
    LYrefresh();
d1767 1
a1767 1
	LYmove(line, col);
d1769 1
a1769 1
	    response = LYgetch_single();
d1771 1
a1771 1
	if (term_options || LYCharIsINTERRUPT_NO_letter(response)) {
d1788 1
a1788 1
	    (cmd = LKC_TO_LAC(keymap,response)) != LYK_ACTIVATE) {
d1800 1
a1800 1
		    LYrefresh();
a1813 1
		case LYK_LPOS_PREV_LINK:
d1842 1
a1842 1
	    show_choice(choices[cur_choice], width);
d1844 2
a1845 2
		LYmove(line, (col - 1));
	    LYrefresh();
d1850 1
a1850 1
	    LYmove(line, col);
d1852 1
a1852 1
	    show_choice(choices[cur_choice], width);
d1861 1
a1861 1
	    return cur_choice;
d1881 1
a1881 1
	LYrefresh();
d1915 1
a1915 1
	LYclear();
d1917 1
a1917 1
	LYerase();
d1920 1
a1920 1
    LYclear();
d1922 1
a1922 1
    LYmove(0, 5);
d1926 1
a1926 1
	LYaddstr(ehead_buffer);
d1928 1
a1928 1
	LYaddstr(MULTIBOOKMARKS_EHEAD);
d1935 3
a1937 3
	    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)), 5);
	    LYaddch(UCH(LYindex2MBM(a)));
	    LYaddstr(" : ");
d1939 3
a1941 3
		LYaddstr(MBM_A_subdescript[a]);
	    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)), 35);
	    LYaddstr("| ");
d1943 1
a1943 1
		LYaddstr(MBM_A_subbookmark[a]);
d1948 3
a1950 3
	    LYmove(3 + a, 5);
	    LYaddch(UCH(LYindex2MBM(a)));
	    LYaddstr(" : ");
d1952 3
a1954 3
		LYaddstr(MBM_A_subdescript[a]);
	    LYmove(3 + a, 35);
	    LYaddstr("| ");
d1956 1
a1956 1
		LYaddstr(MBM_A_subbookmark[a]);
d1965 2
a1966 2
	LYmove((LYlines - 4), 0);
	LYaddstr("'");
d1968 1
a1968 1
	LYaddstr("[");
d1970 3
a1972 3
	LYaddstr("' ");
	LYaddstr(PREVIOUS);
	LYaddstr(", '");
d1974 1
a1974 1
	LYaddstr("]");
d1976 2
a1977 2
	LYaddstr("' ");
	LYaddstr(NEXT_SCREEN);
d1980 1
a1980 1
    LYmove((LYlines - 3), 0);
d1982 1
a1982 1
	LYaddstr("'");
d1984 1
a1984 1
	LYaddstr(">");
d1986 2
a1987 2
	LYaddstr("'");
	LYaddstr(TO_SAVE_SEGMENT);
d1989 2
a1990 2
    LYaddstr(OR_SEGMENT);
    LYaddstr("'");
d1992 1
a1992 1
    LYaddstr("^G");
d1994 2
a1995 2
    LYaddstr("'");
    LYaddstr(TO_RETURN_SEGMENT);
d1999 2
a2000 1
	   !LYCharIsINTERRUPT_NO_letter(response) && response != '>') {
d2002 1
a2002 1
	LYmove((LYlines - 2), 0);
d2004 1
a2004 1
	LYaddstr(MULTIBOOKMARKS_LETTER);
d2007 2
a2008 2
	LYrefresh();
	response = (def_response ? def_response : LYgetch_single());
d2014 2
a2015 1
	if (term_options || LYCharIsINTERRUPT_NO_letter(response) ||
d2024 3
a2026 3
		HTInfoMsg(SAVING_OPTIONS);
		if (save_rc(NULL))
		    HTInfoMsg(OPTIONS_SAVED);
d2030 1
a2030 1
		HTInfoMsg(R_TO_RETURN_TO_LYNX);
d2074 1
a2074 1
	    if (LYMBM2index(response) == a) {
d2092 1
a2092 1
			LYmove(
d2096 2
a2097 2
			LYmove((3 + a), 9);
		    LYstrncpy(MBM_tmp_line,
d2099 1
a2099 2
					       "" : MBM_A_subdescript[a]),
			      sizeof(MBM_tmp_line) - 1);
d2110 1
a2110 1
			LYmove(
d2114 3
a2116 3
			LYmove((3 + a), 5);
		    LYaddch(UCH(LYindex2MBM(a)));
		    LYaddstr(" : ");
d2118 3
a2120 3
			LYaddstr(MBM_A_subdescript[a]);
		    LYclrtoeol();
		    LYrefresh();
d2124 1
a2124 1
		    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)),
d2127 2
a2128 2
		    LYmove((3 + a), 35);
		LYaddstr("| ");
d2131 2
a2132 3
		LYstrncpy(MBM_tmp_line,
			  NonNull(MBM_A_subbookmark[a]),
			  sizeof(MBM_tmp_line) - 1);
d2145 1
a2145 1
			LYSleepAlert();
d2153 1
a2153 1
		    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current-1)),
d2156 2
a2157 2
		    LYmove((3 + a), 35);
		LYaddstr("| ");
d2159 4
a2162 4
		    LYaddstr(MBM_A_subbookmark[a]);
		LYclrtoeol();
		LYmove(LYlines-1, 0);
		LYclrtoeol();
d2172 42
a2213 1
#if !defined(NO_OPTION_MENU) || (defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES)))
a2218 3
 *
 *  Also used for mouse popups with ncurses; this is indicated
 *  by for_mouse.
d2220 1
a2220 1
PUBLIC int popup_choice ARGS7(
d2224 1
a2224 1
	CONST char **,	choices,
d2226 1
a2226 2
	int,		disabled,
	BOOLEAN,	for_mouse)
d2228 26
a2253 2
    if (column < 0)
	column = (COL_OPTION_VALUES - 1);
d2255 934
a3188 17
    term_options = FALSE;
    cur_choice = LYhandlePopupList(cur_choice,
				   line,
				   column,
				   (CONST char **)choices,
				   -1,
				   i_length,
				   disabled,
				   for_mouse,
				   TRUE);
    switch (cur_choice) {
    case LYK_QUIT:
    case LYK_ABORT:
    case LYK_PREV_DOC:
	term_options = TRUE;
	if (!for_mouse) {
	    HTUserMsg(CANCELLED);
a3189 1
	break;
d3191 6
d3200 2
a3201 1
    } else if (!for_mouse) {
d3203 1
a3204 1
    return(cur_choice);
d3208 1
d3218 1
d3249 1
a3249 1
static char * cookies_string		= RC_SET_COOKIES;
d3253 3
a3255 3
static char * x_display_string		= RC_DISPLAY;
static char * editor_string		= RC_FILE_EDITOR;
static char * emacs_keys_string		= RC_EMACS_KEYS;
d3257 1
a3257 1
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
d3269 1
a3269 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d3272 1
a3272 1
static char * kblayout_string		= RC_KBLAYOUT;
d3274 1
a3274 1
static char * keypad_mode_string	= RC_KEYPAD_MODE;
d3278 1
a3278 1
	{ LINKS_AND_FIELDS_ARE_NUMBERED,
a3280 3
	{ FIELDS_ARE_NUMBERED,
			      "Form fields are numbered",
			      "forms_numbered" },
d3282 3
a3284 3
static char * lineedit_mode_string	= RC_LINEEDIT_MODE;
static char * mail_address_string	= RC_PERSONAL_MAIL_ADDRESS;
static char * search_type_string	= RC_CASE_SENSITIVE_SEARCHING;
a3288 1

d3290 1
a3290 1
static char * show_color_string		= RC_SHOW_COLOR;
d3298 2
a3299 23

static char * show_cursor_string	= RC_SHOW_CURSOR;

#ifdef USE_SCROLLBAR
static char * show_scrollbar_string	= RC_SCROLLBAR;
#endif

static CONST char prompt_dft_string[]	= "prompt normally";
static CONST char prompt_yes_string[]	= "force yes-response";
static CONST char prompt_no_string[]	= "force no-response";
static OptValues prompt_values[] = {
	{ FORCE_PROMPT_DFT,	prompt_dft_string, prompt_dft_string },
	{ FORCE_PROMPT_YES,	prompt_yes_string, prompt_yes_string },
	{ FORCE_PROMPT_NO,	prompt_no_string,  prompt_no_string },
	{ 0, 0, 0 }};

static char * cookie_prompt_string	= RC_FORCE_COOKIE_PROMPT;

#ifdef USE_SSL
static char * ssl_prompt_string		= RC_FORCE_SSL_PROMPT;
#endif

static char * user_mode_string		= RC_USER_MODE;
d3305 1
a3305 13

static char * vi_keys_string		= RC_VI_KEYS;

static char * visited_links_string	= RC_VISITED_LINKS;
static OptValues visited_links_values[] = {
	{ VISITED_LINKS_AS_FIRST_V, "By First Visit",	"first_visited" },
	{ VISITED_LINKS_AS_FIRST_V | VISITED_LINKS_REVERSE,
		    "By First Visit Reversed",	"first_visited_reversed" },
	{ VISITED_LINKS_AS_TREE,    "As Visit Tree",	"visit_tree" },
	{ VISITED_LINKS_AS_LATEST,  "By Last Visit",	"last_visited" },
	{ VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE,
		    "By Last Visit Reversed",	"last_visited_reversed" },
	{ 0, 0, 0 }};
d3310 1
a3310 1
static char * DTD_recovery_string      = RC_TAGSOUP;
d3316 1
a3316 2

static char * select_popups_string     = RC_SELECT_POPUPS;
d3318 4
a3321 4
static char * images_ignore_all_string = "ignore";
static char * images_use_label_string  = "as labels";
static char * images_use_links_string  = "as links";
static char * verbose_images_string    = RC_VERBOSE_IMAGES;
d3331 4
a3334 7
static char * mbm_string		= RC_MULTI_BOOKMARK;
static OptValues mbm_values[] = {
	{ MBM_OFF,		"OFF",			"OFF" },
	{ MBM_STANDARD,		"STANDARD",		"STANDARD" },
	{ MBM_ADVANCED,		"ADVANCED",		"ADVANCED" },
	{ 0, 0, 0 }};

d3340 3
a3342 3
static char * assume_char_set_string	= RC_ASSUME_CHARSET;
static char * display_char_set_string	= RC_CHARACTER_SET;
static char * raw_mode_string		= RC_RAW_MODE;
d3347 1
a3347 2
static char * show_dotfiles_string	= RC_SHOW_DOTFILES;

d3349 3
a3351 3
static char * dired_list_string		= RC_DIR_LIST_STYLE;
static OptValues dired_list_values[] = {
	{ DIRS_FIRST,		"Directories first",	"dired_dir" },
a3354 14
#ifdef LONG_LIST
static char * dired_sort_string		= RC_DIR_LIST_ORDER;
static OptValues dired_sort_values[] = {
	{ ORDER_BY_NAME,	"By name",		"dired_by_name" },
	{ ORDER_BY_TYPE,	"By type",		"dired_by_type" },
	{ ORDER_BY_SIZE,	"By size",		"dired_by_size" },
	{ ORDER_BY_DATE,	"By date",		"dired_by_date" },
	{ ORDER_BY_MODE,	"By mode",		"dired_by_mode" },
#ifndef NO_GROUPS
	{ ORDER_BY_USER,	"By user",		"dired_by_user" },
	{ ORDER_BY_GROUP,	"By group",		"dired_by_group" },
#endif
	{ 0, 0, 0 }};
#endif /* LONG_LIST */
d3356 1
a3356 2

static char * ftp_sort_string		= RC_FILE_SORTING_METHOD;
a3363 11
static char * show_rate_string		= RC_SHOW_KB_RATE;
static OptValues rate_values[] = {
	{ rateOFF,		"Do not show rate",	"rate_off" },
	{ rateBYTES,		"Show Bytes/sec rate",	"rate_bytes" },
	{ rateKB,		"Show KB/sec rate",	"rate_kb" },
#ifdef EXP_READPROGRESS
	{ rateEtaBYTES,		"Show Bytes/sec, ETA",	"rate_eta_bytes" },
	{ rateEtaKB,		"Show KB/sec, ETA",	"rate_eta_kb" },
#endif
	{ 0, 0, 0 }};

d3367 6
a3372 3
static char * preferred_doc_char_string = RC_PREFERRED_CHARSET;
static char * preferred_doc_lang_string = RC_PREFERRED_LANGUAGE;
static char * user_agent_string		= RC_USERAGENT;
d3377 1
a3377 1
		(int) Size, Name, Value, disable_all?disabled_string:disable)
d3383 1
a3383 1
	fprintf(fp,"<select name=\"%s\" %s>\n", text, disable_all?disabled_string:"")
d3386 1
a3386 1
	fprintf(fp,"<select name=\"%s\" %s>\n", text, disable_all?disabled_string:DISABLED(flag))
d3397 4
a3400 6
	if (table->HtmlName) {
	    PutOption(fp,
		      value == table->value,
		      table->HtmlName,
		      table->LongName);
	}
d3411 1
a3411 1
	if (table->HtmlName && !strcmp(value, table->HtmlName)) {
d3431 1
a3431 1
    bstring *,	data)
d3433 1
a3433 1
    char * p;
d3437 1
a3437 1
    if (isBEmpty(data))
d3440 2
a3441 5
    p = BStrData(data);
    CTRACE((tfp, "break_data %s\n", p));

    q = typecalloc(PostPair);
    if (q == NULL)
d3474 1
a3474 1
		    && isalnum(UCH(q[count].value[i+2]))) {
d3479 1
a3485 1
	CTRACE((tfp, "...item[%d] tag=%s, value=%s\n", count, q[count].tag, q[count].value));
d3493 1
a3493 1
	if (q == NULL)
d3495 2
a3496 2
	q[count].tag = NULL;
    } while (p != NULL && p[0] != '\0');
a3500 1

d3534 1
a3534 1
    DocInfo *,		newdoc)
d3557 1
a3557 6
	if (no_bookmark) {
	   HTAlert(BOOKMARK_CHANGE_DISALLOWED); /* anonymous */
	   return(NULLFILE);
	} else if (dump_output_immediately) {
	    return(NOT_FOUND);
	} else {
d3559 3
a3561 2
	   return(NULLFILE);
	}
a3563 1
    data = break_data(newdoc->post_data);
d3565 3
a3567 2
    if (!data) {
	int status;
d3569 4
a3572 9
	/*-------------------------------------------------
	 * kludge gen_options() call:
	 *--------------------------------------------------*/
	status = gen_options(&newdoc->address);
	if (status != NORMAL) {
	    HTAlwaysAlert("Unexpected way of accessing", newdoc->address);
	    FREE(newdoc->address);
	    return(status);
	}
d3574 1
a3574 1
	/* exit to getfile() cycle */
a3583 4
	LYRegisterUIPage(newdoc->address, UIP_OPTIONS_MENU);
#ifdef DIRED_SUPPORT
	lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
d3587 2
a3588 13
    if (!LYIsUIPage3(HTLoadedDocumentURL(), UIP_OPTIONS_MENU, 0) &&
	!LYIsUIPage3(HTLoadedDocumentURL(), UIP_VLINKS, 0)) {
	char *buf = NULL;

	/*  We may have been spoofed? */
	HTSprintf0(&buf,
		   gettext("Use %s to invoke the Options menu!"),
		   key_for_func_ext(LYK_OPTIONS, FOR_PANEL));
	HTAlert(buf);
	FREE(buf);
	FREE(data);
	return(NOT_FOUND);
    }
d3592 1
a3592 4
	 *  This isn't really for security, but rather for avoiding that
	 *  the user may revisit an older instance from the history stack
	 *  and submit stuff which accidentally undoes changes that had
	 *  been done from a newer instance. - kw
a3595 2
		char *buf = NULL;

d3597 1
a3597 2
		 * We probably came from an older instance of the Options
		 * page that had been on the history stack. - kw
a3598 4
		HTSprintf0(&buf,
			   gettext("Use %s to invoke the Options menu!"),
			   key_for_func_ext(LYK_OPTIONS, FOR_PANEL));
		HTAlert(buf);
a3625 2
	    validate_x_display();
	    summarize_x_display(data[i].value);
d3637 1
a3637 1
	    if ((emacs_keys = (BOOL) code) != FALSE) {
d3645 1
a3645 1
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
d3653 1
a3653 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
a3661 5
		if (keypad_mode == NUMBERS_AS_ARROWS) {
		    set_numbers_as_arrows();
		} else {
		    reset_numbers_as_arrows();
		}
d3666 1
a3666 1
	if (!strcmp(data[i].tag, lineedit_mode_string)) {
d3671 1
a3671 1
		if (j==newval)	current_lineedit = newval;
d3682 1
a3682 1
		if (j==newval)	current_layout = newval;
d3696 1
a3696 1
	    case_sensitive = (BOOL) code;
d3712 1
a3712 1
	    LYSelectPopups = (BOOL) code;
d3718 2
a3719 4
	 && GetOptValues(show_color_values, data[i].value,
			 &LYChosenShowColor)) {
	    if (can_do_colors)
		LYShowColor = LYChosenShowColor;
d3725 1
a3725 1
	    SLtt_Use_Ansi_Colors = (LYShowColor > SHOW_COLOR_OFF ? TRUE : FALSE);
d3733 1
a3733 1
	    LYShowCursor = (BOOL) code;
a3735 18
#ifdef USE_SCROLLBAR
	/* Show Scrollbar: ON/OFF */
	if (!strcmp(data[i].tag, show_scrollbar_string)
	 && GetOptValues(bool_values, data[i].value, &code)) {
	    LYShowScrollbar = (BOOL) code;
	}
#endif

	/* Cookie Prompting: SELECT */
	if (!strcmp(data[i].tag, cookie_prompt_string))
	    GetOptValues(prompt_values, data[i].value, &cookie_noprompt);

#ifdef USE_SSL
	/* SSL Prompting: SELECT */
	if (!strcmp(data[i].tag, ssl_prompt_string))
	    GetOptValues(prompt_values, data[i].value, &ssl_noprompt);
#endif

a3745 4
	/* Type of visited pages page: SELECT */
	if (!strcmp(data[i].tag, visited_links_string))
	   GetOptValues(visited_links_values, data[i].value, &Visited_Links_As);

d3750 2
a3751 2
		pseudo_inline_alts = FALSE;
		clickable_images = FALSE;
d3755 2
a3756 2
		pseudo_inline_alts = TRUE;
		clickable_images = FALSE;
d3769 1
a3769 1
		verbose_img = (BOOL) code;
d3777 1
a3777 1
	    if ((vi_keys = (BOOL) code) != FALSE) {
d3786 9
a3794 1
	    GetOptValues(mbm_values, data[i].value, &LYMultiBookmarks);
d3835 1
a3835 1
	    LYRawMode = (BOOL) code;
d3846 1
a3846 6
	/* Local Directory Style: SELECT */
	if (!strcmp(data[i].tag, dired_list_string)) {
	    GetOptValues(dired_list_values, data[i].value, &dir_list_style);
	}
#ifdef LONG_LIST
	/* Local Directory Order: SELECT */
d3848 1
a3848 1
	    GetOptValues(dired_sort_values, data[i].value, &dir_list_order);
a3849 1
#endif /* LONG_LIST */
d3855 1
a3855 7
	    show_dotfiles = (BOOL) code;
	}

	/* Show Transfer Rate: enumerated value */
	if (!strcmp(data[i].tag, show_rate_string)
	 && GetOptValues(rate_values, data[i].value, &code)) {
	    LYTransferRate = code;
d3886 4
a3889 2
		if (!LYCheckUserAgent()) {
		    HTAlert(UA_PLEASE_USE_LYNX);
d3904 19
a3922 25
	if (display_char_set_old != current_char_set) {
	    /*
	     *  Set the LYUseDefaultRawMode value and character
	     *  handling if LYRawMode was changed. - FM
	     */
	    LYUseDefaultRawMode = TRUE;
	    HTMLUseCharacterSet(current_char_set);
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Deduce whether the user wants autoswitch: */
	    switch_display_charsets =
		 (current_char_set == auto_display_charset
		  || current_char_set == auto_other_display_charset);
#endif
	}
	if (assume_char_set_changed && HTCJK != JAPANESE) {
	    LYRawMode = (BOOL) (UCLYhndl_for_unspec == current_char_set);
	}
	if (raw_mode_old != LYRawMode || assume_char_set_changed) {
	    /*
	     *  Set the raw 8-bit or CJK mode defaults and
	     *  character set if changed. - FM
	     */
	    HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
	    HTMLSetCharacterHandling(current_char_set);
	}
d3930 1
a3930 1
    BStrFree(newdoc->post_data);
d3933 3
a3935 4
	HTInfoMsg(SAVING_OPTIONS);
	LYrcShowColor = LYChosenShowColor;
	if (save_rc(NULL)) {
	    HTInfoMsg(OPTIONS_SAVED);
d3945 5
a3949 5
    CTRACE((tfp, "\nLYOptions.c/postoptions(): exiting...\n"));
    CTRACE((tfp, "                            need_reload = %s\n",
		    need_reload ? "TRUE" : "FALSE"));
    CTRACE((tfp, "                            need_end_reload = %s\n",
		    need_end_reload ? "TRUE" : "FALSE"));
d3997 1
a3997 1
	return(NOT_FOUND);
d4011 1
a4011 1
	  isLYNXCGI(newdoc->address) == 0))) {
d4029 1
a4029 1
	CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
d4038 8
a4045 1
	    srcmode_for_next_retrieval(1);
d4050 2
a4051 4
	    if (HTcan_reparse_document()) {
		if (!HTreparse_document())
		    srcmode_for_next_retrieval(0);
		CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
a4055 9
	if (newdoc->post_data != NULL && !newdoc->safe &&
	    confirm_post_resub(newdoc->address, newdoc->title, 2, 1) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    if (HTisDocumentSource()) {
		srcmode_for_next_retrieval(0);
	    }
	    return(NORMAL);
	}

d4060 1
a4060 1
	CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
d4071 1
a4071 6
#if defined(RAND_MAX)
	long key = lynx_rand();
#else
	long key = (long)secure_value + (long)time(0);
#endif
	sprintf(secure_value, "%ld", key);
d4078 1
a4078 70
 * Note: the 'value' we are passing here is a local copy of the "same" string
 * as is used in LYrcFile.c to index the savable options.
 */
PRIVATE void PutLabel ARGS3(
	FILE *,		fp,
	char *,		name,
	char *,		value)
{
    if (will_save_rc(value) && !no_option_save) {
	fprintf(fp, "  %-33s: ", name);
    } else {
	int l = strlen(name);
	fprintf(fp, "  %s", name);
	fprintf(fp, "%s%-*s: ",
		(l < 30) ? " " : "",
		(l < 30) ? 32 - l : 3, "(!)");
    }
}

/*
 * For given a list of the .lynxrc names for boolean flags that make up a
 * composite setting, check if any are not writable for the .lynxrc file.  If
 * so, return that name, so the subsequence will_save_rc() check in PutLabel()
 * will flag the composite as not-saved.
 */
PRIVATE char *check_if_write_lynxrc ARGS1(char **, table)
{
    int n;
    char *result = NULL;

    for (n = 0; table[n] != 0; ++n) {
	result = table[n];
	if (!will_save_rc(result))
	    break;
    }
    return result;
}

/*
 * The options menu treats "Cookies" as a single enumeration, but it is read
 * from lynx.cfg (and perhaps .lynxrc) as a set of booleans.  Check if any are
 * not writable to .lynxrc, so we can show the user. 
 */
PRIVATE char *will_save_cookies NOARGS
{
    static char *table[] = {
	RC_SET_COOKIES,			/* LYSetCookies */
	RC_ACCEPT_ALL_COOKIES,		/* LYAcceptAllCookies */
	NULL
    };
    return check_if_write_lynxrc(table);
}

/*
 * The options menu treats "Show images" as a single enumeration, but it is
 * read from lynx.cfg (and perhaps .lynxrc) as a set of booleans.  Check if any
 * are not writable to .lynxrc, so we can show the user. 
 */
PRIVATE char *will_save_images NOARGS
{
    static char *table[] = {
	RC_MAKE_PSEUDO_ALTS_FOR_INLINES, /* pseudo_inline_alts */
	RC_MAKE_LINKS_FOR_ALL_IMAGES,	/* clickable_images */
	NULL
    };
    return check_if_write_lynxrc(table);
}

/*
 * Okay, someone wants to change options.  So, let's gen up a form for them
d4092 4
a4095 2
    static char tempfile[LY_MAXPATH] = "\0";
    BOOLEAN disable_all = FALSE;
d4098 1
a4098 1
    size_t text_len = LYscreenWidth() > 45 ? LYscreenWidth() - 38 : 7;	/* cf: PutLabel */
d4100 4
a4103 1
    if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
d4105 1
a4108 12
    /* This should not be needed if we regenerate the temp file every
       time with a new name, which just happened above in the case
       LYReuseTempfiles==FALSE.  Even for LYReuseTempfiles=TRUE, code
       at the end of postoptions() may remove an older cached version
       from memory if that version of the page was left by submitting
       changes. (But that code doesn't do that - HTuncache_current_document
       is currently commented out.) - kw 1999-11-27
       If access to the actual file via getfile() later fails
       (maybe because of some restrictions), mainloop may leave
       this flag on after popping the previous doc which is then
       unnecessarily reloaded.  But I changed mainloop to reset
       the flag. - kw 1999-05-24 */
a4110 9
    /*
     * Without LYUseFormsOptions set we should maybe not even get here.
     * However, it's possible we do; disable the form in that case. - kw
     */
#ifndef NO_OPTION_MENU
    if (!LYUseFormsOptions)
	disable_all = TRUE;
#endif

d4116 1
a4116 1
    fprintf(fp0, "<form action=\"%s\" method=\"post\">\n", STR_LYNXOPTIONS);
d4122 2
a4123 2
    fprintf(fp0, "<input name=\"%s\" type=\"hidden\" value=\"%s\">\n",
		 secure_string, NewSecureValue());
d4131 3
a4133 5
    if (!disable_all) {
	fprintf(fp0,"<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0,"<input type=\"reset\" value=\"%s\"> - \n", RESET_CHANGES);
	fprintf(fp0,"%s - \n", CANCEL_CHANGES);
    }
d4139 3
a4141 7
	if (!disable_all) {
	    fprintf(fp0, "<p align=center>%s: ", SAVE_OPTIONS);
	    fprintf(fp0, "<input type=\"checkbox\" name=\"%s\">\n",
			 save_options_string);
	}
	fprintf(fp0, "<br>%s\n",
			gettext("(options marked with (!) will not be saved)"));
d4148 1
a4148 23

    fprintf(fp0,"\n  <em>%s</em>\n", gettext("General Preferences"));
    /*****************************************************************/

    /* User Mode: SELECT */
    PutLabel(fp0, gettext("User mode"), user_mode_string);
    BeginSelect(fp0, user_mode_string);
    PutOptValues(fp0, user_mode, user_mode_values);
    EndSelect(fp0);

    /* Editor: INPUT */
    PutLabel(fp0, gettext("Editor"), editor_string);
    PutTextInput(fp0, editor_string, NonNull(editor), text_len,
		      DISABLED(no_editor || system_editor));

    /* Search Type: SELECT */
    PutLabel(fp0, gettext("Type of Search"), search_type_string);
    BeginSelect(fp0, search_type_string);
    PutOptValues(fp0, case_sensitive, search_type_values);
    EndSelect(fp0);

    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Security and Privacy"));
    /*****************************************************************/
d4151 1
a4151 1
    PutLabel(fp0, gettext("Cookies"), will_save_cookies());
d4154 2
a4155 2
		   cookies_ignore_all_string,
		   cookies_ignore_all_string);
d4157 2
a4158 2
		   cookies_up_to_user_string,
		   cookies_up_to_user_string);
d4160 2
a4161 2
		   cookies_accept_all_string,
		   cookies_accept_all_string);
d4164 4
a4167 5
    /* Cookie Prompting: SELECT */
    PutLabel(fp0, gettext("Invalid-Cookie Prompting"), cookie_prompt_string);
    BeginSelect(fp0, cookie_prompt_string);
    PutOptValues(fp0, cookie_noprompt, prompt_values);
    EndSelect(fp0);
d4169 4
a4172 5
#ifdef USE_SSL
    /* SSL Prompting: SELECT */
    PutLabel(fp0, gettext("SSL Prompting"), ssl_prompt_string);
    BeginSelect(fp0, ssl_prompt_string);
    PutOptValues(fp0, ssl_noprompt, prompt_values);
a4173 4
#endif

    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Keyboard Input"));
    /*****************************************************************/
d4176 1
a4176 1
    PutLabel(fp0, gettext("Keypad mode"), keypad_mode_string);
a4180 12
    /* Emacs keys: ON/OFF */
    PutLabel(fp0, gettext("Emacs keys"), emacs_keys_string);
    BeginSelect(fp0, emacs_keys_string);
    PutOptValues(fp0, emacs_keys, bool_values);
    EndSelect(fp0);

    /* VI Keys: ON/OFF */
    PutLabel(fp0, gettext("VI keys"), vi_keys_string);
    BeginSelect(fp0, vi_keys_string);
    PutOptValues(fp0, vi_keys, bool_values);
    EndSelect(fp0);

d4183 2
a4184 2
	PutLabel(fp0, gettext("Line edit style"), lineedit_mode_string);
	BeginSelect(fp0, lineedit_mode_string);
d4195 1
a4195 1
    PutLabel(fp0, gettext("Keyboard layout"), kblayout_string);
d4200 1
a4200 1
	PutOption(fp0, i == current_layout, temp, LYKbLayoutNames[i]);
d4205 72
a4276 5
    /*
     * Display and Character Set
     */
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Display and Character Set"));
    /*****************************************************************/
d4279 1
a4279 1
    PutLabel(fp0, gettext("Display character set"), display_char_set_string);
d4285 1
a4285 1
	    cset_len = len;
a4286 3
#ifdef EXP_CHARSET_CHOICE
	if (!charset_subsets[i].hide_display)
#endif
d4291 9
d4301 1
d4312 1
a4312 1
		/* ok, LYRawMode, so use UCAssume_MIMEcharset */
d4315 1
a4315 1
	PutLabel(fp0, gettext("Assumed document character set"), assume_char_set_string);
d4318 3
a4320 6
#ifdef EXP_CHARSET_CHOICE
	    if (!charset_subsets[i].hide_assumed)
#endif
	    PutOption(fp0, i == curval,
			   LYCharSet_UC[i].MIMEname,
			   LYCharSet_UC[i].MIMEname);
d4326 1
a4326 1
    if (LYHaveCJKCharacterSet) {
d4332 3
a4334 4
	PutLabel(fp0, gettext("CJK mode"), raw_mode_string);
    } else {
	PutLabel(fp0, gettext("Raw 8-bit"), raw_mode_string);
    }
d4340 4
a4343 40
    /* X Display: INPUT */
    PutLabel(fp0, gettext("X Display"),	x_display_string);
    PutTextInput(fp0, x_display_string, NonNull(x_display), text_len, "");

    /*
     * Document Appearance
     */
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Document Appearance"));
    /*****************************************************************/

    /* Show Color: SELECT */
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    SetupChosenShowColor();
    PutLabel(fp0, gettext("Show color"), show_color_string);
    if (no_option_save) {
	MaybeSelect(fp0, !can_do_colors, show_color_string);
	if (LYShowColor == SHOW_COLOR_NEVER) {
	   LYShowColor = SHOW_COLOR_OFF;
	} else if (LYShowColor == SHOW_COLOR_ALWAYS) {
	   LYShowColor = SHOW_COLOR_ON;
	}
	PutOptValues(fp0, LYShowColor - SHOW_COLOR_OFF, bool_values);
    } else {
	BeginSelect(fp0, show_color_string);
	if (can_do_colors) {
	   show_color_values[2].HtmlName = on_string;
	   show_color_values[3].LongName = always_string;
	} else {
	   show_color_values[2].HtmlName = NULL; /* suppress "ON" - kw */
	   show_color_values[3].LongName = "Always try";
	}
	PutOptValues(fp0, LYChosenShowColor, show_color_values);
    }
    EndSelect(fp0);
#endif /* USE_SLANG || COLOR_CURSES */

    /* Show cursor: ON/OFF */
    PutLabel(fp0, gettext("Show cursor"), show_cursor_string);
    BeginSelect(fp0, show_cursor_string);
    PutOptValues(fp0, LYShowCursor, bool_values);
a4345 8
#ifdef USE_SCROLLBAR
    /* Show scrollbar: ON/OFF */
    PutLabel(fp0, gettext("Show scrollbar"), show_scrollbar_string);
    BeginSelect(fp0, show_scrollbar_string);
    PutOptValues(fp0, LYShowScrollbar, bool_values);
    EndSelect(fp0);
#endif

d4347 1
a4347 1
    PutLabel(fp0, gettext("Popups for select fields"), select_popups_string);
a4351 6
    /* HTML error recovery: SELECT */
    PutLabel(fp0, gettext("HTML error recovery"), DTD_recovery_string);
    BeginSelect(fp0, DTD_recovery_string);
    PutOptValues(fp0, Old_DTD, DTD_type_values);
    EndSelect(fp0);

d4353 1
a4353 1
    PutLabel(fp0, gettext("Show images"), will_save_images());
d4356 2
a4357 2
		   images_ignore_all_string,
		   images_ignore_all_string);
d4359 2
a4360 2
		   images_use_label_string,
		   images_use_label_string);
d4362 2
a4363 2
		   images_use_links_string,
		   images_use_links_string);
d4367 1
a4367 1
    PutLabel(fp0, gettext("Verbose images"), verbose_images_string);
d4373 1
a4373 1
     * Headers Transferred to Remote Servers
d4375 1
a4375 2
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Headers Transferred to Remote Servers"));
    /*****************************************************************/
d4377 15
a4391 4
    /* Mail Address: INPUT */
    PutLabel(fp0, gettext("Personal mail address"), mail_address_string);
    PutTextInput(fp0, mail_address_string,
		      NonNull(personal_mail_address), text_len, "");
d4393 2
a4394 4
    /* Preferred Document Character Set: INPUT */
    PutLabel(fp0, gettext("Preferred document character set"), preferred_doc_char_string);
    PutTextInput(fp0, preferred_doc_char_string,
		      NonNull(pref_charset), cset_len+2, "");
d4396 3
a4398 4
    /* Preferred Document Language: INPUT */
    PutLabel(fp0, gettext("Preferred document language"), preferred_doc_lang_string);
    PutTextInput(fp0, preferred_doc_lang_string,
		      NonNull(language), cset_len+2, "");
d4400 4
a4403 5
    /* User Agent: INPUT */
    if (!no_useragent) {
	PutLabel(fp0, gettext("User-Agent header"), user_agent_string);
	PutTextInput(fp0, user_agent_string,
			  NonNull(LYUserAgent), text_len, "");
d4407 1
a4407 1
     * Listing and Accessing Files
d4409 1
a4409 2
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Listing and Accessing Files"));
    /*****************************************************************/
d4412 1
a4412 1
    PutLabel(fp0, gettext("FTP sort criteria"),	ftp_sort_string);
d4419 1
a4419 7
    PutLabel(fp0, gettext("Local directory sort criteria"), dired_list_string);
    BeginSelect(fp0, dired_list_string);
    PutOptValues(fp0, dir_list_style, dired_list_values);
    EndSelect(fp0);
#ifdef LONG_LIST
    /* Local Directory Order: SELECT */
    PutLabel(fp0, gettext("Local directory sort order"), dired_sort_string);
d4421 1
a4421 1
    PutOptValues(fp0, dir_list_order, dired_sort_values);
a4422 1
#endif /* LONG_LIST */
d4427 1
a4427 1
	PutLabel(fp0, gettext("Show dot files"), show_dotfiles_string);
d4434 2
a4435 2
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    PutLabel(fp0, gettext("Execution links"), exec_links_string);
d4443 1
a4443 1
		      exec_links_values);
d4448 1
a4448 1
		      exec_links_values);
d4451 1
a4451 9
#endif /* ENABLE_OPTS_CHANGE_EXEC */

#ifdef EXP_READPROGRESS
    /* Local Directory Sort: SELECT */
    PutLabel(fp0, gettext("Show transfer rate"), show_rate_string);
    BeginSelect(fp0, show_rate_string);
    PutOptValues(fp0, LYTransferRate, rate_values);
    EndSelect(fp0);
#endif /* EXP_READPROGRESS */
d4454 1
a4454 1
     * Special Files and Screens
d4456 1
a4456 2
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Special Files and Screens"));
    /*****************************************************************/
d4458 9
a4466 7
    /* Multi-Bookmark Mode: SELECT */
    if (!LYMBMBlocked) {
	PutLabel(fp0, gettext("Multi-bookmarks"), mbm_string);
	BeginSelect(fp0, mbm_string);
	PutOptValues(fp0, LYMultiBookmarks, mbm_values);
	EndSelect(fp0);
    }
d4468 5
a4472 9
    /* Bookmarks File Menu: LINK/INPUT */
    if (LYMultiBookmarks) {
	PutLabel(fp0, gettext("Review/edit Bookmarks files"), mbm_string);
	fprintf(fp0, "<a href=\"%s//MBM_MENU\">%s</a>\n",
		    STR_LYNXOPTIONS, gettext("Goto multi-bookmark menu"));
    } else {
	PutLabel(fp0, gettext("Bookmarks file"), single_bookmark_string);
	PutTextInput(fp0, single_bookmark_string,
			 NonNull(bookmark_page), text_len, "");
d4475 3
a4477 10
    /* Visited Pages: SELECT */
    PutLabel(fp0, gettext("Visited Pages"), visited_links_string);
    BeginSelect(fp0, visited_links_string);
    PutOptValues(fp0, Visited_Links_As, visited_links_values);
    EndSelect(fp0);

    if (!no_lynxcfg_info) {
	fprintf(fp0, "\n  %s<a href=\"%s\">lynx.cfg</a>.\n",
		     gettext("View the file "),
		     STR_LYNXCFG);
d4483 4
a4486 6
    if (!disable_all) {
	fprintf(fp0,"<p align=center>\n");
	fprintf(fp0,"<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0,"<input type=\"reset\" value=\"%s\"> - \n", RESET_CHANGES);
	fprintf(fp0,"%s\n", CANCEL_CHANGES);
    }
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d2131 1
a2131 1
static char * exec_links_string		= RC_RUN_ALL_EXECUTION_LINKS;
d2246 1
a2246 1
static char * single_bookmark_string	= RC_BOOKMARK_FILE;
d2296 1
a2296 1
#ifdef USE_READPROGRESS
d2987 2
a2988 1
    HTuncache_current_document(); /* will never use again */
d3055 1
a3055 1
#ifdef USE_SOURCE_CACHE
d3201 2
a3202 1
       changes. - kw 1999-11-27
d3589 1
a3589 1
#ifdef USE_READPROGRESS
d3595 1
a3595 1
#endif /* USE_READPROGRESS */
@


1.1.3.3
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@d233 1
a233 1
	    lynx_start_bold();
d238 1
a238 1
	    lynx_stop_bold();
d244 1
a244 1
	lynx_stop_bold();
d567 1
a567 1
    lynx_start_bold();
d569 1
a569 1
    lynx_stop_bold();
d573 1
a573 1
	lynx_start_bold();
d575 1
a575 1
	lynx_stop_bold();
d581 1
a581 1
    lynx_start_bold();
d583 1
a583 1
    lynx_stop_bold();
d625 1
a625 1
		    lynx_start_bold();
d628 1
a628 1
		    lynx_stop_bold();
d661 1
a661 1
		lynx_start_bold();
d664 1
a664 1
		lynx_stop_bold();
d779 1
a779 1
		    lynx_start_bold();
d782 1
a782 1
		    lynx_stop_bold();
d846 1
a846 1
		lynx_start_bold();
d849 1
a849 1
		lynx_stop_bold();
d1054 1
a1054 1
		lynx_start_bold();
d1057 1
a1057 1
		lynx_stop_bold();
d1089 1
a1089 1
		lynx_start_bold();
d1092 1
a1092 1
		lynx_stop_bold();
d1424 1
a1424 1
		    lynx_start_bold();
d1427 1
a1427 1
		    lynx_stop_bold();
d1608 1
a1608 1
    lynx_start_reverse();
d1707 1
a1707 1
	    lynx_stop_reverse();
d1823 1
a1823 1
	lynx_start_bold();
d1825 1
a1825 1
	lynx_stop_bold();
d1829 1
a1829 1
	lynx_start_bold();
d1831 1
a1831 1
	lynx_stop_bold();
d1839 1
a1839 1
	lynx_start_bold();
d1841 1
a1841 1
	lynx_stop_bold();
d1847 1
a1847 1
    lynx_start_bold();
d1849 1
a1849 1
    lynx_stop_bold();
d1944 1
a1944 1
		    lynx_start_bold();
d1957 1
a1957 1
		    lynx_stop_bold();
d1985 1
a1985 1
		lynx_start_bold();
d1991 1
a1991 1
		lynx_stop_bold();
d2103 4
a2106 4
static CONST char on_string[]	    = N_("ON");
static CONST char off_string[]	    = N_("OFF");
static CONST char never_string[]    = N_("NEVER");
static CONST char always_string[]   = N_("ALWAYS");
d2108 2
a2109 2
	{ FALSE,	     N_("OFF"),		  "OFF"		},
	{ TRUE,		     N_("ON"),		  "ON"		},
d2120 3
a2122 3
static char * cookies_ignore_all_string = N_("ignore");
static char * cookies_up_to_user_string = N_("ask user");
static char * cookies_accept_all_string = N_("accept all");
d2133 2
a2134 2
	{ EXEC_NEVER,	N_("ALWAYS OFF"),		"ALWAYS OFF" },
	{ EXEC_LOCAL,	N_("FOR LOCAL FILES ONLY"),	"FOR LOCAL FILES ONLY" },
d2136 1
a2136 1
	{ EXEC_ALWAYS,	N_("ALWAYS ON"),		"ALWAYS ON" },
d2146 2
a2147 4
	{ NUMBERS_AS_ARROWS,  N_("Numbers act as arrows"),
			      "number_arrows" },
	{ LINKS_ARE_NUMBERED, N_("Links are numbered"),
			      "links_numbered" },
d2149 1
a2149 1
			      N_("Links and form fields are numbered"),
d2152 1
a2152 1
			      N_("Form fields are numbered"),
d2159 2
a2160 2
	{ FALSE,	    N_("Case insensitive"),  "case_insensitive" },
	{ TRUE,		    N_("Case sensitive"),	 "case_sensitive" },
a2174 2
static char * underline_links_string	= RC_UNDERLINE_LINKS;

d2179 3
a2181 3
static CONST char prompt_dft_string[]	= N_("prompt normally");
static CONST char prompt_yes_string[]	= N_("force yes-response");
static CONST char prompt_no_string[]	= N_("force no-response");
d2196 3
a2198 3
	{ NOVICE_MODE,		N_("Novice"),			"Novice" },
	{ INTERMEDIATE_MODE,	N_("Intermediate"),		"Intermediate" },
	{ ADVANCED_MODE,	N_("Advanced"),			"Advanced" },
d2205 1
a2205 1
	{ VISITED_LINKS_AS_FIRST_V, N_("By First Visit"),	"first_visited" },
d2207 3
a2209 3
		    N_("By First Visit Reversed"),		"first_visited_reversed" },
	{ VISITED_LINKS_AS_TREE,    N_("As Visit Tree"),	"visit_tree" },
	{ VISITED_LINKS_AS_LATEST,  N_("By Last Visit"),	"last_visited" },
d2211 1
a2211 1
		    N_("By Last Visit Reversed"),		"last_visited_reversed" },
d2220 2
a2221 2
	{ TRUE,		    N_("relaxed (TagSoup mode)"),	 "tagsoup" },
	{ FALSE,	    N_("strict (SortaSGML mode)"),	 "sortasgml" },
d2226 3
a2228 4
static char * images_ignore_all_string = N_("ignore");
static char * images_use_label_string  = N_("as labels");
static char * images_use_links_string  = N_("as links");

d2232 2
a2233 2
	{ FALSE,	    N_("OFF"),		 	"OFF" },
	{ TRUE,		    N_("show filename"),	 "ON" },
d2241 3
a2243 3
	{ MBM_OFF,		N_("OFF"),		"OFF" },
	{ MBM_STANDARD,		N_("STANDARD"),		"STANDARD" },
	{ MBM_ADVANCED,		N_("ADVANCED"),		"ADVANCED" },
a2254 4
#ifdef EXP_LOCALE_CHARSET
static char * locale_charset_string	= RC_LOCALE_CHARSET;
#endif

d2263 3
a2265 3
	{ DIRS_FIRST,		N_("Directories first"),	"dired_dir" },
	{ FILES_FIRST,		N_("Files first"),		"dired_files" },
	{ MIXED_STYLE,		N_("Mixed style"),		"dired_mixed" },
d2270 5
a2274 5
	{ ORDER_BY_NAME,	N_("By Name"),		"dired_by_name" },
	{ ORDER_BY_TYPE,	N_("By Type"),		"dired_by_type" },
	{ ORDER_BY_SIZE,	N_("By Size"),		"dired_by_size" },
	{ ORDER_BY_DATE,	N_("By Date"),		"dired_by_date" },
	{ ORDER_BY_MODE,	N_("By Mode"),		"dired_by_mode" },
d2276 2
a2277 2
	{ ORDER_BY_USER,	N_("By User"),		"dired_by_user" },
	{ ORDER_BY_GROUP,	N_("By Group"),		"dired_by_group" },
d2285 4
a2288 4
	{ FILE_BY_NAME,		N_("By Name"),		"ftp_by_name" },
	{ FILE_BY_TYPE,		N_("By Type"),		"ftp_by_type" },
	{ FILE_BY_SIZE,		N_("By Size"),		"ftp_by_size" },
	{ FILE_BY_DATE,		N_("By Date"),		"ftp_by_date" },
a2290 1
#ifdef USE_READPROGRESS
d2293 3
a2295 3
	{ rateOFF,		N_("Do not show rate"),	"rate_off" },
	{ rateBYTES,		N_("Show %s/sec rate"),	"rate_bytes" },
	{ rateKB,		N_("Show %s/sec rate"), "rate_kb" },
d2297 2
a2298 2
	{ rateEtaBYTES,		N_("Show %s/sec, ETA"),	"rate_eta_bytes" },
	{ rateEtaKB,		N_("Show %s/sec, ETA"), "rate_eta_kb" },
a2300 1
#endif /* USE_READPROGRESS */
d2315 1
a2315 1
	fprintf(fp,"<option value=\"%s\" %s>%s\n", html, SELECTED(flag), gettext(name))
a2719 6
	/* Underline links: ON/OFF */
	if (!strcmp(data[i].tag, underline_links_string)
	 && GetOptValues(bool_values, data[i].value, &code)) {
	    LYUnderlineLinks = (BOOL) code;
	}

a2819 8
#ifdef EXP_LOCALE_CHARSET
	/* Use locale-based character set: ON/OFF */
	if (!strcmp(data[i].tag, locale_charset_string)
	 && GetOptValues(bool_values, data[i].value, &code)) {
	    LYLocaleCharset = (BOOL) code;
	}
#endif

a2861 1
#ifdef USE_READPROGRESS
a2866 1
#endif /* USE_READPROGRESS */
d2906 3
a2908 6
#ifdef EXP_LOCALE_CHARSET
    LYFindLocaleCharset();
#endif
    if ( display_char_set_old != current_char_set ||
	 raw_mode_old != LYRawMode ||
	 assume_char_set_changed ) {
d2938 2
a2939 1
    } /* end of charset settings */
a3099 2
#define LABEL_LEN 33

d3110 1
a3110 1
	fprintf(fp, "  %-*s: ", LABEL_LEN, name);
d3115 2
a3116 2
		(l < (LABEL_LEN-3)) ? " " : "",
		(l < (LABEL_LEN-3)) ? (LABEL_LEN-1) - l : 3, "(!)");
a3169 13
 * The visited-links menu is used from the visited-links page as well as the
 * options page.
 */
PUBLIC void LYMenuVisitedLinks ARGS2(
	FILE *,		fp0,
	int,		disable_all)
{
    BeginSelect(fp0, visited_links_string);
    PutOptValues(fp0, Visited_Links_As, visited_links_values);
    EndSelect(fp0);
}

/*
a3362 10
#ifdef EXP_LOCALE_CHARSET
    /* Use locale-based character set: ON/OFF */
    PutLabel(fp0, gettext("Use locale-based character set"), locale_charset_string);
    BeginSelect(fp0, locale_charset_string);
    PutOptValues(fp0, LYLocaleCharset, bool_values);
    EndSelect(fp0);
#else
#define LYLocaleCharset FALSE
#endif

d3365 1
a3365 1
    MaybeSelect(fp0, LYLocaleCharset, display_char_set_string);
a3463 6
    /* Underline links: ON/OFF */
    PutLabel(fp0, gettext("Underline links"), underline_links_string);
    BeginSelect(fp0, underline_links_string);
    PutOptValues(fp0, LYUnderlineLinks, bool_values);
    EndSelect(fp0);

d3588 1
a3588 1
    /* Show transfer rate: SELECT */
d3591 1
a3591 11
    for (i = 0; rate_values[i].LongName != 0; ++i) {
	char *message = NULL;
	HTSprintf0(&message,
		   rate_values[i].LongName,
		   HTProgressUnits(rate_values[i].value));
	PutOption(fp0,
		  LYTransferRate == rate_values[i].value,
		  rate_values[i].HtmlName,
		  message);
        FREE(message);
    }
d3622 3
a3624 1
    LYMenuVisitedLinks(fp0, disable_all);
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d30 1
a30 1
static int LYChosenShowColor = SHOW_COLOR_UNKNOWN; /* whether to show and save */
d32 1
a32 1
static void terminate_options	(int sig);
d39 1
a39 1
static BOOLEAN can_do_colors = FALSE;
d42 1
a42 1
BOOLEAN LYCheckUserAgent (void)
d55 1
a55 1
static void SetupChosenShowColor (void)
d89 1
a89 1
static void validate_x_display (void)
d99 2
a100 2
static void summarize_x_display (
    char *	display_option)
d122 1
a122 1
static int boolean_choice (
d126 1
a126 1
	const char **	choices);
d128 1
a128 1
	boolean_choice(status, line, column, (const char **)choices)
d210 1
a210 1
static int add_it (char * text, int len)
d223 1
a223 1
static void addlbl (const char * text)
d262 1
a262 1
void LYoptions (void)
d882 2
a883 2
		    const char ** assume_list;
		    assume_list = typecallocn(const char *,(LYNumCharsets + 1));
d1553 2
a1554 2
static int widest_choice (
	const char **	choices)
d1565 3
a1567 3
static void show_choice (
	const char *	choice,
	int		width)
d1578 5
a1582 5
static int boolean_choice (
	int		cur_choice,
	int		line,
	int		column,
	const char **	choices)
d1723 2
a1724 2
static void terminate_options (
	int		sig GCC_UNUSED)
d1745 1
a1745 1
void edit_bookmarks (void)
d2038 8
a2045 8
int popup_choice (
	int		cur_choice,
	int		line,
	int		column,
	const char **	choices,
	int		i_length,
	int		disabled,
	BOOLEAN	for_mouse)
d2054 1
a2054 1
				   (const char **)choices,
d2092 2
a2093 2
    const char *LongName;
    const char *HtmlName;
d2101 6
a2106 6
static const char selected_string[] = "selected";
static const char disabled_string[] = "disabled";
static const char on_string[]	    = N_("ON");
static const char off_string[]	    = N_("OFF");
static const char never_string[]    = N_("NEVER");
static const char always_string[]   = N_("ALWAYS");
d2183 3
a2185 3
static const char prompt_dft_string[]	= N_("prompt normally");
static const char prompt_yes_string[]	= N_("force yes-response");
static const char prompt_no_string[]	= N_("force no-response");
d2337 4
a2340 4
static void PutOptValues (
	FILE *		fp,
	int		value,
	OptValues *	table)
d2353 4
a2356 4
static BOOLEAN GetOptValues (
	OptValues *	table,
	char *		value,
	int *		result)
d2378 2
a2379 2
static PostPair * break_data (
    bstring *	data)
d2451 1
a2451 1
static int gen_options (char **newfile);
d2485 2
a2486 2
int postoptions (
    DocInfo *		newdoc)
d3114 1
a3114 1
static char *NewSecureValue (void)
d3135 4
a3138 4
static void PutLabel (
	FILE *		fp,
	char *		name,
	char *		value)
d3157 1
a3157 1
static char *check_if_write_lynxrc (char ** table)
d3175 1
a3175 1
static char *will_save_cookies (void)
d3190 1
a3190 1
static char *will_save_images (void)
d3204 3
a3206 3
void LYMenuVisitedLinks (
	FILE *		fp0,
	int		disable_all)
d3224 2
a3225 2
static int gen_options (
	char **	newfile)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d3 1
a3 1
#include <HTTP.h>		/* 'reloading' flag */
d30 1
a30 2
#define TOP_LINK  "/"
#define MBM_LINK  "//MBM_MENU"
d32 1
a32 3
static int LYChosenShowColor = SHOW_COLOR_UNKNOWN;	/* whether to show and save */

static void terminate_options(int sig);
d35 1
a35 1
#define COL_OPTION_VALUES 36	/* display column where option values start */
d42 1
a42 1
BOOLEAN LYCheckUserAgent(void)
d46 3
a48 3
	    && strstr(LYUserAgent, "lynx") == 0
	    && strstr(LYUserAgent, "L_y_n_x") == 0
	    && strstr(LYUserAgent, "l_y_n_x") == 0) {
d55 1
a55 1
static void SetupChosenShowColor(void)
d60 2
a61 4
    if (LYCursesON)		/* could crash if called before initialization */
	can_do_colors = (has_colors()
			 ? TRUE
			 : FALSE);
d69 1
a69 1
		    SHOW_COLOR_ON : SHOW_COLOR_NEVER;
d77 1
a77 1
			SHOW_COLOR_ALWAYS : SHOW_COLOR_OFF;
d82 1
a82 1
		    SHOW_COLOR_ON : SHOW_COLOR_OFF;
d89 1
a89 1
static void validate_x_display(void)
a91 1

d99 2
a100 1
static void summarize_x_display(char *display_option)
d120 1
d122 5
a126 5
static int boolean_choice(int status,
			  int line,
			  int column,
			  const char **choices);

d133 1
a133 1
 * Values for the options menu.  - FM
d135 3
a137 3
 * L_foo values are the Y coordinates for the menu item.
 * B_foo values are the X coordinates for the item's prompt string.
 * C_foo values are the X coordinates for the item's value string.
d210 1
a210 1
static int add_it(char *text, int len)
d223 1
a223 1
static void addlbl(const char *text)
d232 1
a232 1
	    d = add_it(actual, d - 1);
d262 1
a262 1
void LYoptions(void)
d265 1
a265 2
    static char *bool_choices[] =
    {
d270 1
a270 2
    static char *caseless_choices[] =
    {
d275 1
a275 2
    static char *dirList_choices[] =
    {
a280 1

d282 1
a282 2
    static char *exec_choices[] =
    {
d287 1
a287 1
#endif				/* !NEVER_ALLOW_REMOTE_EXEC */
d291 1
a291 2
    static char *fileSort_choices[] =
    {
d298 1
a298 2
    static char *keypad_choices[] =
    {
d304 1
a304 2
    static char *mbm_choices[] =
    {
d310 1
a310 2
    static char *userMode_choices[] =
    {
a315 1

a319 1

d321 1
a321 1
     * If the user changes the display we need memory to put it in.
d377 1
a377 1
  draw_options:
d381 2
a382 2
     * NOTE that printw() should be avoided for strings that might have
     * non-ASCII or multibyte/CJK characters.  - FM
d395 1
a395 1
    lynx_start_h1_color();
d401 1
a401 1
    lynx_stop_h1_color();
d424 3
a426 3
	      (HTfileSortMethod == FILE_BY_SIZE ? "By Size    " :
	       (HTfileSortMethod == FILE_BY_TYPE ? "By Type    " :
		"By Date    "))));
d431 1
a431 1
	     personal_mail_address : "NONE");
d457 1
a457 1
		     : "NONE");
d472 2
a473 2
	    LYaddstr("NEVER     ");
	    break;
d475 2
a476 2
	    LYaddstr("OFF");
	    break;
d478 2
a479 2
	    LYaddstr("ON ");
	    break;
d482 3
a484 3
	    if (!has_colors())
		LYaddstr("Always try");
	    else
d486 1
a486 1
		LYaddstr("ALWAYS    ");
d514 6
a519 6
	     ? "Links and form fields are numbered"
	     : links_are_numbered()
	     ? "Links are numbered                "
	     : fields_are_numbered()
	     ? "Form fields are numbered          "
	     : "Numbers act as arrows             ");
d535 2
a536 2
	     ((dir_list_style == MIXED_STYLE) ? "Mixed style      " :
	      "Directories first"));
d541 3
a543 3
    LYaddstr((user_mode == NOVICE_MODE) ? "Novice      " :
	     ((user_mode == INTERMEDIATE_MODE) ? "Intermediate" :
	      "Advanced    "));
d546 1
a546 1
    ShowBool(verbose_img);
d556 3
a558 3
    LYaddstr(local_exec ? "ALWAYS ON           " :
	     (local_exec_on_local_files ? "FOR LOCAL FILES ONLY" :
	      "ALWAYS OFF          "));
d561 1
a561 1
	     "ALWAYS OFF          ");
d565 1
a565 1
    LYmove(LYlines - 3, 2);
d597 1
a597 1
	lynx_start_prompt_color();
d599 1
a599 1
	lynx_stop_prompt_color();
d610 19
a628 9
	case 'E':		/* Change the editor. */
	    if (no_editor) {
		_statusline(EDIT_DISABLED);
	    } else if (system_editor) {
		_statusline(EDITOR_LOCKED);
	    } else {
		if (editor && *editor)
		    LYstrncpy(display_option, editor, sizeof(display_option) - 1);
		else {		/* clear the NONE */
d630 26
d660 1
a660 1
		LYmove(L_EDITOR, COL_OPTION_VALUES);
a664 26
		LYmove(L_EDITOR, COL_OPTION_VALUES);
		if (term_options || ch == -1) {
		    LYaddstr((editor && *editor) ?
			     editor : "NONE");
		} else if (*display_option == '\0') {
		    FREE(editor);
		    LYaddstr("NONE");
		} else {
		    StrAllocCopy(editor, display_option);
		    LYaddstr(display_option);
		}
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
	    }
	    response = ' ';
	    break;

	case 'D':		/* Change the display. */
	    if (x_display && *x_display) {
		LYstrncpy(display_option, x_display, sizeof(display_option) - 1);
	    } else {		/* clear the NONE */
a665 10
		LYaddstr("    ");
		*display_option = '\0';
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_DISPLAY, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
	    lynx_stop_bold();
	    LYmove(L_DISPLAY, COL_OPTION_VALUES);
d673 31
a703 3
	    if ((term_options || ch == -1) ||
		(x_display != NULL &&
		 !CompareEnvVars(x_display, display_option))) {
d705 1
a705 2
		 * Cancelled, or a non-NULL display string wasn't changed.  -
		 * FM
d707 4
a710 1
		LYaddstr((x_display && *x_display) ? x_display : "NONE");
d712 1
a712 6
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
d715 4
a718 9
	    } else if (*display_option == '\0') {
		if ((x_display == NULL) ||
		    (x_display != NULL && *x_display == '\0')) {
		    /*
		     * NULL or zero-length display string wasn't changed.  - FM
		     */
		    LYaddstr("NONE");
		    LYclrtoeol();
		    _statusline(VALUE_ACCEPTED);
d722 10
a731 29
	    }
	    /*
	     * Set the new DISPLAY variable.  - FM
	     */
	    LYsetXDisplay(display_option);
	    validate_x_display();
	    cp = NULL;
	    LYaddstr(x_display ? x_display : "NONE");
	    LYclrtoeol();
	    summarize_x_display(display_option);
	    response = ' ';
	    break;

	case 'L':		/* Change multibookmarks option. */
	    if (LYMBMBlocked) {
		_statusline(MULTIBOOKMARKS_DISALLOWED);
		response = ' ';
		break;
	    }
	    if (!LYSelectPopups) {
		LYMultiBookmarks = LYChooseBoolean(LYMultiBookmarks,
						   L_HOME, C_MULTI,
						   mbm_choices);
	    } else {
		LYMultiBookmarks = LYChoosePopup(LYMultiBookmarks,
						 L_HOME, (C_MULTI - 1),
						 mbm_choices,
						 3, FALSE, FALSE);
	    }
d733 5
a737 5
	    if (LYSelectPopups) {
		LYmove(L_HOME, C_MULTI);
		LYclrtoeol();
		LYaddstr(mbm_choices[LYMultiBookmarks]);
	    }
d740 1
a740 1
	    if (!LYSelectPopups)
d742 14
a755 9
	    {
		LYmove(L_HOME, B_BOOK);
		LYclrtoeol();
		if (LYMultiBookmarks != MBM_OFF) {
		    LYaddstr(gettext("review/edit B)ookmarks files"));
		} else {
		    LYaddstr(gettext("B)ookmark file: "));
		    LYaddstr((bookmark_page && *bookmark_page) ?
			     bookmark_page : "NONE");
d757 1
a757 6
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
d759 24
a782 16
	case 'B':		/* Change the bookmark page location. */
	    /*
	     * Anonymous users should not be allowed to change the bookmark
	     * page.
	     */
	    if (!no_bookmark) {
		if (LYMultiBookmarks != MBM_OFF) {
		    edit_bookmarks();
		    signal(SIGINT, terminate_options);
		    goto draw_options;
		}
		if (bookmark_page && *bookmark_page) {
		    LYstrncpy(display_option,
			      bookmark_page,
			      sizeof(display_option) - 1);
		} else {	/* clear the NONE */
d784 17
d802 40
d845 1
a845 1
		LYmove(L_HOME, C_DEFAULT);
d850 8
a857 13
		LYmove(L_HOME, C_DEFAULT);
		if (term_options ||
		    ch == -1 || *display_option == '\0') {
		    LYaddstr((bookmark_page && *bookmark_page) ?
			     bookmark_page : "NONE");
		} else if (!LYPathOffHomeOK(display_option,
					    sizeof(display_option))) {
		    LYaddstr((bookmark_page && *bookmark_page) ?
			     bookmark_page : "NONE");
		    LYclrtoeol();
		    _statusline(USE_PATH_OFF_HOME);
		    response = ' ';
		    break;
d859 2
a860 3
		    StrAllocCopy(bookmark_page, display_option);
		    StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
		    LYaddstr(bookmark_page);
d869 9
a877 5
	    } else {		/* anonymous */
		_statusline(BOOKMARK_CHANGE_DISALLOWED);
	    }
	    response = ' ';
	    break;
d879 45
a923 10
	case 'F':		/* Change ftp directory sorting. */
	    if (!LYSelectPopups) {
		HTfileSortMethod = LYChooseBoolean(HTfileSortMethod,
						   L_FTPSTYPE, -1,
						   fileSort_choices);
	    } else {
		HTfileSortMethod = LYChoosePopup(HTfileSortMethod,
						 L_FTPSTYPE, -1,
						 fileSort_choices,
						 4, FALSE, FALSE);
d925 4
a928 3
		LYmove(L_FTPSTYPE, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(fileSort_choices[HTfileSortMethod]);
d930 1
a930 6
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
d932 35
a966 37
	case 'P':		/* Change personal mail address for From headers. */
	    if (personal_mail_address && *personal_mail_address) {
		LYstrncpy(display_option,
			  personal_mail_address,
			  sizeof(display_option) - 1);
	    } else {		/* clear the NONE */
		LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
		LYaddstr("    ");
		*display_option = '\0';
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
	    lynx_stop_bold();
	    LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
	    if (term_options || ch == -1) {
		LYaddstr((personal_mail_address &&
			  *personal_mail_address) ?
			 personal_mail_address : "NONE");
	    } else if (*display_option == '\0') {
		FREE(personal_mail_address);
		LYaddstr("NONE");
	    } else {
		StrAllocCopy(personal_mail_address, display_option);
		LYaddstr(display_option);
	    }
	    LYclrtoeol();
	    if (ch == -1) {
		HTInfoMsg(CANCELLED);
		HTInfoMsg("");
	    } else {
		_statusline(VALUE_ACCEPTED);
	    }
	    response = ' ';
	    break;
d968 1
a968 25
	case 'S':		/* Change case sensitivity for searches. */
	    case_sensitive = LYChooseBoolean(case_sensitive,
					     L_SSEARCH, -1,
					     caseless_choices);
	    response = ' ';
	    break;

	case '\001':		/* Change assume_charset setting. */
	    if (use_assume_charset) {
		int i, curval;
		const char **assume_list;
		assume_list = typecallocn(const char *, (LYNumCharsets + 1));

		if (!assume_list) {
		    outofmem(__FILE__, "options");
		}
		for (i = 0; i < LYNumCharsets; i++) {
		    assume_list[i] = LYCharSet_UC[i].MIMEname;
		}
		curval = UCLYhndl_for_unspec;
		if (curval == current_char_set && UCAssume_MIMEcharset) {
		    curval = UCGetLYhndl_byMIME(UCAssume_MIMEcharset);
		}
		if (curval < 0)
		    curval = LYRawMode ? current_char_set : 0;
d971 4
a974 6
		    UCLYhndl_for_unspec =
			assumed_doc_charset_map[(LYChooseBoolean(charset_subsets[curval].assumed_idx,
								 L_ASSUME_CHARSET, -1,
								 assumed_charset_choices)
						 ? 1
						 : 0)];
d976 3
a978 4
		    UCLYhndl_for_unspec =
			LYChooseBoolean(curval,
					L_ASSUME_CHARSET, -1,
					assume_list);
d982 5
a986 9
		    UCLYhndl_for_unspec =
			assumed_doc_charset_map[(LYChoosePopup(charset_subsets[curval].assumed_idx,
							       L_ASSUME_CHARSET, -1,
							       assumed_charset_choices,
							       0,
							       FALSE,
							       FALSE)
						 ? 1
						 : 0)];
d988 4
a991 5
		    UCLYhndl_for_unspec =
			LYChoosePopup(curval,
				      L_ASSUME_CHARSET, -1,
				      assume_list,
				      0, FALSE, FALSE);
d993 1
d995 1
a995 1
		    LYmove(L_ASSUME_CHARSET, COL_OPTION_VALUES);
d997 1
a997 2
		    if (UCLYhndl_for_unspec >= 0)
			LYaddstr(LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
a999 1

d1001 2
a1002 2
		 * Set the raw 8-bit or CJK mode defaults and character set if
		 * changed.  - FM
d1004 4
a1007 11
		if (CurrentAssumeCharSet != UCLYhndl_for_unspec ||
		    UCLYhndl_for_unspec != curval) {
		    if (UCLYhndl_for_unspec != CurrentAssumeCharSet) {
			StrAllocCopy(UCAssume_MIMEcharset,
				     LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
		    }
		    if (HTCJK != JAPANESE)
			LYRawMode = (BOOL) (UCLYhndl_for_unspec == current_char_set);
		    HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
		    HTMLSetCharacterHandling(current_char_set);
		    CurrentAssumeCharSet = UCLYhndl_for_unspec;
d1017 6
a1023 1
		FREE(assume_list);
d1028 1
a1028 5
	    } else {
		_statusline(NEED_ADVANCED_USER_MODE);
		AddValueAccepted = FALSE;
	    }
	    break;
d1030 13
a1042 25
	case 'C':		/* Change display charset setting. */
	    if (!LYSelectPopups) {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		displayed_display_charset_idx = LYChooseBoolean(displayed_display_charset_idx,
								L_Charset, -1,
								display_charset_choices);
		current_char_set = display_charset_map[displayed_display_charset_idx];
#else
		current_char_set = LYChooseBoolean(current_char_set,
						   L_Charset, -1,
						   LYchar_set_names);
#endif
	    } else {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		displayed_display_charset_idx = LYChoosePopup(displayed_display_charset_idx,
							      L_Charset, -1,
							      display_charset_choices,
							      0, FALSE, FALSE);
		current_char_set = display_charset_map[displayed_display_charset_idx];
#else
		current_char_set = LYChoosePopup(current_char_set,
						 L_Charset, -1,
						 LYchar_set_names,
						 0, FALSE, FALSE);
#endif
d1044 25
a1068 2
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Charset, COL_OPTION_VALUES);
d1070 5
a1074 19
		LYaddstr(LYchar_set_names[current_char_set]);
#endif /* VMS || USE_SLANG */
	    }
	    /*
	     * Set the raw 8-bit or CJK mode defaults and character set if
	     * changed.  - FM
	     */
	    if (CurrentCharSet != current_char_set) {
		LYUseDefaultRawMode = TRUE;
		HTMLUseCharacterSet(current_char_set);
		CurrentCharSet = current_char_set;
		CurrentRawMode = LYRawMode;
#if !defined(VMS) && !defined(USE_SLANG)
		if (!LYSelectPopups)
#endif /* !VMS && !USE_SLANG */
		{
		    LYmove(L_Rawmode, COL_OPTION_VALUES);
		    LYclrtoeol();
		    ShowBool(LYRawMode);
d1076 2
a1077 12
#ifdef CAN_SWITCH_DISPLAY_CHARSET
		/* Deduce whether the user wants autoswitch: */
		switch_display_charsets =
		    (current_char_set == auto_display_charset
		     || current_char_set == auto_other_display_charset);
#endif
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
d1079 14
a1092 55
	case 'O':		/* Change raw mode setting. */
	    LYRawMode = LYChooseBoolean(LYRawMode, L_Rawmode, -1, bool_choices);
	    /*
	     * Set the LYUseDefaultRawMode value and character handling if
	     * LYRawMode was changed.  - FM
	     */
	    if (CurrentRawMode != LYRawMode) {
		HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
		HTMLSetCharacterHandling(current_char_set);
		CurrentRawMode = LYRawMode;
	    }
	    response = ' ';
	    break;

	case 'G':		/* Change language preference. */
	    if (language && *language) {
		LYstrncpy(display_option, language, sizeof(display_option) - 1);
	    } else {		/* clear the NONE */
		LYmove(L_LANGUAGE, COL_OPTION_VALUES);
		LYaddstr("    ");
		*display_option = '\0';
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_LANGUAGE, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
	    lynx_stop_bold();
	    LYmove(L_LANGUAGE, COL_OPTION_VALUES);
	    if (term_options || ch == -1) {
		LYaddstr((language && *language) ?
			 language : "NONE");
	    } else if (*display_option == '\0') {
		FREE(language);
		LYaddstr("NONE");
	    } else {
		StrAllocCopy(language, display_option);
		LYaddstr(display_option);
	    }
	    LYclrtoeol();
	    if (ch == -1) {
		HTInfoMsg(CANCELLED);
		HTInfoMsg("");
	    } else {
		_statusline(VALUE_ACCEPTED);
	    }
	    response = ' ';
	    break;

	case 'H':		/* Change charset preference. */
	    if (pref_charset && *pref_charset) {
		LYstrncpy(display_option,
			  pref_charset,
			  sizeof(display_option) - 1);
	    } else {		/* clear the NONE */
d1094 19
a1112 29
		LYaddstr("    ");
		*display_option = '\0';
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
	    lynx_stop_bold();
	    LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
	    if (term_options || ch == -1) {
		LYaddstr((pref_charset && *pref_charset) ?
			 pref_charset : "NONE");
	    } else if (*display_option == '\0') {
		FREE(pref_charset);
		LYaddstr("NONE");
	    } else {
		StrAllocCopy(pref_charset, display_option);
		LYaddstr(display_option);
	    }
	    LYclrtoeol();
	    if (ch == -1) {
		HTInfoMsg(CANCELLED);
		HTInfoMsg("");
	    } else {
		_statusline(VALUE_ACCEPTED);
	    }
	    response = ' ';
	    break;
d1114 3
a1116 15
	case 'V':		/* Change VI keys setting. */
	    vi_keys = LYChooseBoolean(vi_keys,
				      L_Bool_A, C_VIKEYS,
				      bool_choices);
	    if (vi_keys) {
		set_vi_keys();
	    } else {
		reset_vi_keys();
	    }
	    response = ' ';
	    break;

	case 'M':		/* Change emacs keys setting. */
	    emacs_keys = LYChooseBoolean(emacs_keys,
					 L_Bool_A, C_EMACSKEYS,
d1118 7
a1124 7
	    if (emacs_keys) {
		set_emacs_keys();
	    } else {
		reset_emacs_keys();
	    }
	    response = ' ';
	    break;
d1126 11
a1136 11
	case 'W':		/* Change show dotfiles setting. */
	    if (no_dotfiles) {
		_statusline(DOTFILE_ACCESS_DISABLED);
	    } else {
		show_dotfiles = LYChooseBoolean(show_dotfiles,
						L_Bool_A,
						C_SHOW_DOTFILES,
						bool_choices);
	    }
	    response = ' ';
	    break;
d1138 3
a1140 29
	case 'T':		/* Change select popups setting. */
	    LYSelectPopups = LYChooseBoolean(LYSelectPopups,
					     L_Bool_B,
					     C_SELECT_POPUPS,
					     bool_choices);
	    response = ' ';
	    break;

#if defined(USE_SLANG) || defined(COLOR_CURSES)
	case '&':		/* Change show color setting. */
	    if (no_option_save) {
#if defined(COLOR_CURSES)
		if (!has_colors()) {
		    char *terminal = LYGetEnv("TERM");

		    if (terminal)
			HTUserMsg2(COLOR_TOGGLE_DISABLED_FOR_TERM,
				   terminal);
		    else
			HTUserMsg(COLOR_TOGGLE_DISABLED);
		    break;
		}
#endif
		LYShowColor = LYChooseBoolean((LYShowColor - 1),
					      L_Color,
					      C_COLOR,
					      bool_choices);
		if (LYShowColor == 0) {
		    LYShowColor = SHOW_COLOR_OFF;
d1142 4
a1145 1
		    LYShowColor = SHOW_COLOR_ON;
d1147 2
a1148 3
	    } else {		/* !no_option_save */
		BOOLEAN again = FALSE;
		int chosen;
d1150 11
a1160 10
		/*
		 * Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "NEVER     ");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "OFF       ");
		choices[2] = NULL;
		StrAllocCopy(choices[2], "ON        ");
		choices[3] = NULL;
d1162 10
a1171 3
		if (!has_colors())
		    StrAllocCopy(choices[3], "Always try");
		else
d1173 1
a1173 5
		    StrAllocCopy(choices[3], "ALWAYS    ");
		choices[4] = NULL;
		do {
		    if (!LYSelectPopups) {
			chosen = LYChooseBoolean(LYChosenShowColor,
d1176 3
a1178 1
						 choices);
d1180 1
a1180 4
			chosen = LYChoosePopup(LYChosenShowColor,
					       L_Color,
					       C_COLOR,
					       choices, 4, FALSE, FALSE);
d1182 32
d1215 10
a1224 10
		    again = (BOOL) (chosen == SHOW_COLOR_ON && !has_colors());
		    if (again) {
			char *terminal = LYGetEnv("TERM");

			if (terminal)
			    HTUserMsg2(COLOR_TOGGLE_DISABLED_FOR_TERM,
				       terminal);
			else
			    HTUserMsg(COLOR_TOGGLE_DISABLED);
		    }
d1226 2
a1227 2
		} while (again);
		LYChosenShowColor = chosen;
d1229 5
a1233 5
		if (LYSelectPopups) {
		    LYmove(L_Color, C_COLOR);
		    LYclrtoeol();
		    LYaddstr(choices[LYChosenShowColor]);
		}
d1236 1
a1236 1
		if (has_colors())
d1238 10
a1247 10
		    LYShowColor = chosen;
		FREE(choices[0]);
		FREE(choices[1]);
		FREE(choices[2]);
		FREE(choices[3]);
	    }
	    if (CurrentShowColor != LYShowColor) {
		lynx_force_repaint();
	    }
	    CurrentShowColor = LYShowColor;
d1249 1
a1249 1
	    SLtt_Use_Ansi_Colors = (LYShowColor > SHOW_COLOR_OFF ? TRUE : FALSE);
d1251 5
a1255 5
	    response = ' ';
	    if (LYSelectPopups && !no_option_save) {
		HANDLE_LYOPTIONS;
	    }
	    break;
d1258 34
a1291 7
	case '@@':		/* Change show cursor setting. */
	    LYShowCursor = LYChooseBoolean(LYShowCursor,
					   L_Bool_B,
					   C_SHOW_CURSOR,
					   bool_choices);
	    response = ' ';
	    break;
d1293 10
a1302 10
	case 'K':		/* Change keypad mode. */
	    if (!LYSelectPopups) {
		keypad_mode = LYChooseBoolean(keypad_mode,
					      L_Keypad, -1,
					      keypad_choices);
	    } else {
		keypad_mode = LYChoosePopup(keypad_mode,
					    L_Keypad, -1,
					    keypad_choices,
					    3, FALSE, FALSE);
d1304 3
a1306 3
		LYmove(L_Keypad, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(keypad_choices[keypad_mode]);
d1308 6
a1313 33
	    }
	    if (keypad_mode == NUMBERS_AS_ARROWS) {
		set_numbers_as_arrows();
	    } else {
		reset_numbers_as_arrows();
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'N':		/* Change line editor key bindings. */
	    if (!LYSelectPopups) {
		current_lineedit = LYChooseBoolean(current_lineedit,
						   L_Lineed, -1,
						   LYLineeditNames);
	    } else {
		current_lineedit = LYChoosePopup(current_lineedit,
						 L_Lineed, -1,
						 LYLineeditNames,
						 0, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Lineed, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(LYLineeditNames[current_lineedit]);
#endif /* VMS || USE_SLANG */
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
d1316 10
a1325 10
	case 'Y':		/* Change keyboard layout */
	    if (!LYSelectPopups) {
		current_layout = LYChooseBoolean(current_layout,
						 L_Layout, -1,
						 LYKbLayoutNames);
	    } else {
		current_layout = LYChoosePopup(current_layout,
					       L_Layout, -1,
					       LYKbLayoutNames,
					       0, FALSE, FALSE);
d1327 3
a1329 3
		LYmove(L_Layout, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(LYKbLayoutNames[current_layout]);
d1331 6
a1336 6
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
d1340 10
a1349 10
	case 'I':		/* Change local directory sorting. */
	    if (!LYSelectPopups) {
		dir_list_style = LYChooseBoolean(dir_list_style,
						 L_Dired, -1,
						 dirList_choices);
	    } else {
		dir_list_style = LYChoosePopup(dir_list_style,
					       L_Dired, -1,
					       dirList_choices,
					       3, FALSE, FALSE);
d1351 3
a1353 3
		LYmove(L_Dired, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(dirList_choices[dir_list_style]);
d1355 6
a1360 6
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
d1363 12
a1374 12
	case 'U':		/* Change user mode. */
	    if (!LYSelectPopups) {
		user_mode = LYChooseBoolean(user_mode,
					    L_User_Mode, -1,
					    userMode_choices);
		use_assume_charset = (BOOL) (user_mode >= 2);
	    } else {
		user_mode = LYChoosePopup(user_mode,
					  L_User_Mode, -1,
					  userMode_choices,
					  3, FALSE, FALSE);
		use_assume_charset = (BOOL) (user_mode >= 2);
d1376 5
a1380 5
		if (use_assume_charset == old_use_assume_charset) {
		    LYmove(L_User_Mode, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(userMode_choices[user_mode]);
		}
a1381 41
	    }
	    if (user_mode == NOVICE_MODE) {
		display_lines = (LYlines - 4);
	    } else {
		display_lines = LYlines - 2;
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case '!':
	    if (!LYSelectPopups) {
		verbose_img = LYChooseBoolean(verbose_img,
					      L_VERBOSE_IMAGES,
					      C_VERBOSE_IMAGES,
					      bool_choices);
	    } else {
		verbose_img = LYChoosePopup(verbose_img,
					    L_VERBOSE_IMAGES,
					    C_VERBOSE_IMAGES,
					    bool_choices,
					    2, FALSE, FALSE);
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'A':		/* Change user agent string. */
	    if (!no_useragent) {
		if (LYUserAgent && *LYUserAgent) {
		    LYstrncpy(display_option,
			      LYUserAgent,
			      sizeof(display_option) - 1);
		} else {	/* clear the NONE */
		    LYmove(L_HOME, COL_OPTION_VALUES);
		    LYaddstr("    ");
		    *display_option = '\0';
d1383 2
a1384 16
		_statusline(ACCEPT_DATA_OR_DEFAULT);
		LYmove(L_User_Agent, COL_OPTION_VALUES);
		lynx_start_bold();
		ch = LYgetstr(display_option, VISIBLE,
			      sizeof(display_option), NORECALL);
		lynx_stop_bold();
		LYmove(L_User_Agent, COL_OPTION_VALUES);
		if (term_options || ch == -1) {
		    LYaddstr((LYUserAgent &&
			      *LYUserAgent) ?
			     LYUserAgent : "NONE");
		} else if (*display_option == '\0') {
		    StrAllocCopy(LYUserAgent, LYUserAgentDefault);
		    LYaddstr((LYUserAgent &&
			      *LYUserAgent) ?
			     LYUserAgent : "NONE");
d1386 5
a1390 2
		    StrAllocCopy(LYUserAgent, display_option);
		    LYaddstr(display_option);
d1392 8
a1399 6
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else if (!LYCheckUserAgent()) {
		    _statusline(UA_PLEASE_USE_LYNX);
d1401 9
a1409 1
		    _statusline(VALUE_ACCEPTED);
d1411 1
a1411 5
	    } else {		/* disallowed */
		_statusline(UA_CHANGE_DISABLED);
	    }
	    response = ' ';
	    break;
d1413 41
a1453 4
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
	case 'X':		/* Change local exec restriction. */
	    if (exec_frozen && !LYSelectPopups) {
		_statusline(CHANGE_OF_SETTING_DISALLOWED);
d1456 8
a1463 1
	    }
d1465 3
a1467 3
	    if (local_exec) {
		itmp = 2;
	    } else
d1469 11
a1479 3
	    {
		if (local_exec_on_local_files) {
		    itmp = 1;
d1481 5
a1485 13
		    itmp = 0;
		}
	    }
	    if (!LYSelectPopups) {
		itmp = LYChooseBoolean(itmp,
				       L_Exec, -1,
				       exec_choices);
	    } else {
		itmp = LYChoosePopup(itmp,
				     L_Exec, -1,
				     exec_choices,
				     0, (exec_frozen ? TRUE : FALSE),
				     FALSE);
d1487 3
a1489 3
		LYmove(L_Exec, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(exec_choices[itmp]);
d1491 11
a1501 11
	    }
	    if (!exec_frozen) {
		switch (itmp) {
		case 0:
		    local_exec = FALSE;
		    local_exec_on_local_files = FALSE;
		    break;
		case 1:
		    local_exec = FALSE;
		    local_exec_on_local_files = TRUE;
		    break;
d1503 4
a1506 4
		case 2:
		    local_exec = TRUE;
		    local_exec_on_local_files = FALSE;
		    break;
d1508 7
a1514 7
		}		/* end switch */
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
d1517 9
a1525 6
	case '>':		/* Save current options to RC file. */
	    if (!no_option_save) {
		HTInfoMsg(SAVING_OPTIONS);
		LYrcShowColor = LYChosenShowColor;
		if (save_rc(NULL)) {
		    HTInfoMsg(OPTIONS_SAVED);
d1527 6
a1532 1
		    HTAlert(OPTIONS_NOT_SAVED);
d1534 1
a1534 8
	    } else {
		HTInfoMsg(R_TO_RETURN_TO_LYNX);
		/*
		 * Change response so that we don't exit the options menu.
		 */
		response = ' ';
	    }
	    break;
d1536 2
a1537 2
	case 'R':		/* Return to document (quit options menu). */
	    break;
d1539 8
a1546 8
	default:
	    if (!no_option_save) {
		HTInfoMsg(SAVE_OR_R_TO_RETURN_TO_LYNX);
	    } else {
		HTInfoMsg(R_TO_RETURN_TO_LYNX);
	    }
	}			/* end switch */
    }				/* end while */
d1553 2
a1554 1
static int widest_choice(const char **choices)
a1556 1

a1558 1

d1565 3
a1567 2
static void show_choice(const char *choice,
			int width)
a1569 1

d1576 1
a1576 1
 * Take a status code, prompt the user for a new status, and return it.
d1578 5
a1582 4
static int boolean_choice(int cur_choice,
			  int line,
			  int column,
			  const char **choices)
d1592 2
a1593 1
     * Get the number of choices and then make number zero-based.
d1595 2
a1596 1
    for (number = 0; choices[number] != NULL; number++) ;	/* empty loop body */
d1600 1
a1600 1
     * Update the statusline.
d1605 1
a1605 1
     * Highlight the current choice.
d1615 4
a1618 2
     * Get the keyboard entry, and leave the cursor at the choice, to indicate
     * that it can be changed, until the user accepts the current choice.
d1627 3
a1629 3
	    /*
	     * Control-C or Control-G.
	     */
d1643 1
a1643 1
	    (cmd = LKC_TO_LAC(keymap, response)) != LYK_ACTIVATE) {
d1645 3
a1647 3
	    case LYK_HOME:
		cur_choice = 0;
		break;
d1649 3
a1651 3
	    case LYK_END:
		cur_choice = number;
		break;
d1653 4
a1656 4
	    case LYK_REFRESH:
		lynx_force_repaint();
		LYrefresh();
		break;
d1658 6
a1663 20
	    case LYK_QUIT:
	    case LYK_ABORT:
	    case LYK_PREV_DOC:
		cur_choice = orig_choice;
		term_options = TRUE;
		break;

	    case LYK_PREV_PAGE:
	    case LYK_UP_HALF:
	    case LYK_UP_TWO:
	    case LYK_PREV_LINK:
	    case LYK_LPOS_PREV_LINK:
	    case LYK_FASTBACKW_LINK:
	    case LYK_UP_LINK:
	    case LYK_LEFT_LINK:
		if (cur_choice == 0)
		    cur_choice = number;	/* go back to end */
		else
		    cur_choice--;
		break;
d1665 12
a1676 11
	    case LYK_1:
	    case LYK_2:
	    case LYK_3:
	    case LYK_4:
	    case LYK_5:
	    case LYK_6:
	    case LYK_7:
	    case LYK_8:
	    case LYK_9:
		if ((cmd - LYK_1 + 1) <= number) {
		    cur_choice = cmd - LYK_1 + 1;
d1678 20
a1697 7
		}		/* else fall through! */
	    default:
		if (cur_choice == number)
		    cur_choice = 0;	/* go over the top and around */
		else
		    cur_choice++;
	    }			/* end of switch */
d1704 1
a1704 1
	     * Unhighlight choice.
d1723 2
a1724 1
static void terminate_options(int sig GCC_UNUSED)
d1728 1
a1728 1
     * Reassert the AST.
d1733 1
a1733 1
     * Refresh the screen to get rid of the "interrupt" message.
d1743 1
a1743 1
 * Multi-Bookmark On-Line editing support.  - FMG & FM
d1745 1
a1745 1
void edit_bookmarks(void)
a1748 1

d1750 2
a1751 2
    int a;			/* misc counter */
    char MBM_tmp_line[256];	/* buffer for LYgetstr */
d1755 4
a1758 3
     * We need (MBM_V_MAXFILES + MULTI_OFFSET) lines to display the whole list
     * at once.  Otherwise break it up into two segments.  We know it won't be
     * less than that because 'o'ptions needs 23-24 at LEAST.
d1763 1
a1763 1
  draw_bookmark_list:
d1765 3
a1767 3
     * Display menu of bookmarks.  NOTE that we avoid printw()'s to increase
     * the chances that any non-ASCII or multibyte/CJK characters will be
     * handled properly.  - FM
d1779 1
a1779 1
    lynx_start_h1_color();
d1786 1
a1786 1
    lynx_stop_h1_color();
d1789 3
a1791 3
	for (a = ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1));
	     a <= (MBM_current * MBM_V_MAXFILES / 2); a++) {
	    LYmove((3 + a) - ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1)), 5);
d1796 1
a1796 1
	    LYmove((3 + a) - ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1)), 35);
d1818 1
a1818 1
     * Only needed when we have 2 screens.
d1858 1
a1858 1
	lynx_start_prompt_color();
d1860 1
a1860 1
	lynx_stop_prompt_color();
d1867 1
a1867 1
	 * Check for a cancel.
d1874 1
a1874 1
	 * Check for a save.
d1886 2
a1887 1
		 * Change response so that we don't exit the options menu.
d1895 1
a1895 1
	 * Check for a refresh.
d1903 1
a1903 1
	 * Move between the screens - if we can't show it all at once.
d1923 3
a1925 2
	 * Instead of using 26 case statements, we set up a scan through the
	 * letters and edit the lines that way.
d1930 1
a1930 1
		    if (MBM_current == 1 && a > (MBM_V_MAXFILES / 2)) {
d1935 1
a1935 1
		    if (MBM_current == 2 && a < (MBM_V_MAXFILES / 2)) {
d1946 3
a1948 3
			LYmove((3 + a)
			       - ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1)),
			       9);
d1952 2
a1953 2
			      (!MBM_A_subdescript[a] ?
			       "" : MBM_A_subdescript[a]),
d1965 3
a1967 4
			LYmove((3 + a)
			       - ((MBM_V_MAXFILES / 2 + 1)
				  * (MBM_current - 1)),
			       5);
d1979 2
a1980 4
		    LYmove((3 + a)
			   - ((MBM_V_MAXFILES / 2 + 1)
			      * (MBM_current - 1)),
			   35);
d2000 2
a2001 2
		    LYMBM_statusline(USE_PATH_OFF_HOME);
		    LYSleepAlert();
d2009 2
a2010 4
		    LYmove((3 + a)
			   - ((MBM_V_MAXFILES / 2 + 1)
			      * (MBM_current - 1)),
			   35);
d2017 1
a2017 1
		LYmove(LYlines - 1, 0);
d2021 2
a2022 2
	}			/* end for */
    }				/* end while */
d2031 3
a2033 2
 * This function offers the choices for values of an option via a popup window
 * which functions like that for selection of options in a form.  - FM
d2035 2
a2036 1
 * Also used for mouse popups with ncurses; this is indicated by for_mouse.
d2038 8
a2045 7
int popup_choice(int cur_choice,
		 int line,
		 int column,
		 const char **choices,
		 int i_length,
		 int disabled,
		 BOOLEAN for_mouse)
d2054 1
a2054 1
				   (const char **) choices,
d2076 1
a2076 1
    return (cur_choice);
d2097 2
a2098 2
    char *tag;
    char *value;
d2103 12
a2114 14
static const char on_string[] = N_("ON");
static const char off_string[] = N_("OFF");
static const char never_string[] = N_("NEVER");
static const char always_string[] = N_("ALWAYS");
static OptValues bool_values[] =
{
    {FALSE, N_("OFF"), "OFF"},
    {TRUE, N_("ON"), "ON"},
    {0, 0, 0}
};

static char *secure_string = "secure";
static char *secure_value = NULL;
static char *save_options_string = "save_options";
d2119 7
a2125 7
static char *cookies_string = RC_SET_COOKIES;
static char *cookies_ignore_all_string = N_("ignore");
static char *cookies_up_to_user_string = N_("ask user");
static char *cookies_accept_all_string = N_("accept all");
static char *x_display_string = RC_DISPLAY;
static char *editor_string = RC_FILE_EDITOR;
static char *emacs_keys_string = RC_EMACS_KEYS;
d2131 4
a2134 5
static char *exec_links_string = RC_RUN_ALL_EXECUTION_LINKS;
static OptValues exec_links_values[] =
{
    {EXEC_NEVER, N_("ALWAYS OFF"), "ALWAYS OFF"},
    {EXEC_LOCAL, N_("FOR LOCAL FILES ONLY"), "FOR LOCAL FILES ONLY"},
d2136 1
a2136 1
    {EXEC_ALWAYS, N_("ALWAYS ON"), "ALWAYS ON"},
d2138 1
a2138 2
    {0, 0, 0}
};
d2142 1
a2142 1
static char *kblayout_string = RC_KBLAYOUT;
d2144 20
a2163 24
static char *keypad_mode_string = RC_KEYPAD_MODE;
static OptValues keypad_mode_values[] =
{
    {NUMBERS_AS_ARROWS, N_("Numbers act as arrows"),
     "number_arrows"},
    {LINKS_ARE_NUMBERED, N_("Links are numbered"),
     "links_numbered"},
    {LINKS_AND_FIELDS_ARE_NUMBERED,
     N_("Links and form fields are numbered"),
     "links_and_forms"},
    {FIELDS_ARE_NUMBERED,
     N_("Form fields are numbered"),
     "forms_numbered"},
    {0, 0, 0}
};
static char *lineedit_mode_string = RC_LINEEDIT_MODE;
static char *mail_address_string = RC_PERSONAL_MAIL_ADDRESS;
static char *search_type_string = RC_CASE_SENSITIVE_SEARCHING;
static OptValues search_type_values[] =
{
    {FALSE, N_("Case insensitive"), "case_insensitive"},
    {TRUE, N_("Case sensitive"), "case_sensitive"},
    {0, 0, 0}
};
d2166 7
a2172 9
static char *show_color_string = RC_SHOW_COLOR;
static OptValues show_color_values[] =
{
    {SHOW_COLOR_NEVER, never_string, never_string},
    {SHOW_COLOR_OFF, off_string, off_string},
    {SHOW_COLOR_ON, on_string, on_string},
    {SHOW_COLOR_ALWAYS, always_string, always_string},
    {0, 0, 0}
};
d2175 1
a2175 1
static char *show_cursor_string = RC_SHOW_CURSOR;
d2177 1
a2177 1
static char *underline_links_string = RC_UNDERLINE_LINKS;
d2180 1
a2180 1
static char *show_scrollbar_string = RC_SCROLLBAR;
d2183 8
a2190 10
static const char prompt_dft_string[] = N_("prompt normally");
static const char prompt_yes_string[] = N_("force yes-response");
static const char prompt_no_string[] = N_("force no-response");
static OptValues prompt_values[] =
{
    {FORCE_PROMPT_DFT, prompt_dft_string, prompt_dft_string},
    {FORCE_PROMPT_YES, prompt_yes_string, prompt_yes_string},
    {FORCE_PROMPT_NO, prompt_no_string, prompt_no_string},
    {0, 0, 0}
};
d2192 1
a2192 1
static char *cookie_prompt_string = RC_FORCE_COOKIE_PROMPT;
d2195 1
a2195 1
static char *ssl_prompt_string = RC_FORCE_SSL_PROMPT;
d2198 19
a2216 23
static char *user_mode_string = RC_USER_MODE;
static OptValues user_mode_values[] =
{
    {NOVICE_MODE, N_("Novice"), "Novice"},
    {INTERMEDIATE_MODE, N_("Intermediate"), "Intermediate"},
    {ADVANCED_MODE, N_("Advanced"), "Advanced"},
    {0, 0, 0}
};

static char *vi_keys_string = RC_VI_KEYS;

static char *visited_links_string = RC_VISITED_LINKS;
static OptValues visited_links_values[] =
{
    {VISITED_LINKS_AS_FIRST_V, N_("By First Visit"), "first_visited"},
    {VISITED_LINKS_AS_FIRST_V | VISITED_LINKS_REVERSE,
     N_("By First Visit Reversed"), "first_visited_reversed"},
    {VISITED_LINKS_AS_TREE, N_("As Visit Tree"), "visit_tree"},
    {VISITED_LINKS_AS_LATEST, N_("By Last Visit"), "last_visited"},
    {VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE,
     N_("By Last Visit Reversed"), "last_visited_reversed"},
    {0, 0, 0}
};
d2221 2
a2222 3
static char *DTD_recovery_string = RC_TAGSOUP;
static OptValues DTD_type_values[] =
{
d2224 9
a2232 10
    {TRUE, N_("relaxed (TagSoup mode)"), "tagsoup"},
    {FALSE, N_("strict (SortaSGML mode)"), "sortasgml"},
    {0, 0, 0}
};

static char *select_popups_string = RC_SELECT_POPUPS;
static char *images_string = "images";
static char *images_ignore_all_string = N_("ignore");
static char *images_use_label_string = N_("as labels");
static char *images_use_links_string = N_("as links");
d2234 2
a2235 3
static char *verbose_images_string = RC_VERBOSE_IMAGES;
static OptValues verbose_images_type_values[] =
{
d2237 3
a2239 4
    {FALSE, N_("OFF"), "OFF"},
    {TRUE, N_("show filename"), "ON"},
    {0, 0, 0}
};
d2244 6
a2249 8
static char *mbm_string = RC_MULTI_BOOKMARK;
static OptValues mbm_values[] =
{
    {MBM_OFF, N_("OFF"), "OFF"},
    {MBM_STANDARD, N_("STANDARD"), "STANDARD"},
    {MBM_ADVANCED, N_("ADVANCED"), "ADVANCED"},
    {0, 0, 0}
};
d2251 1
a2251 1
static char *single_bookmark_string = RC_BOOKMARK_FILE;
d2256 3
a2258 3
static char *assume_char_set_string = RC_ASSUME_CHARSET;
static char *display_char_set_string = RC_CHARACTER_SET;
static char *raw_mode_string = RC_RAW_MODE;
d2261 1
a2261 1
static char *locale_charset_string = RC_LOCALE_CHARSET;
d2267 1
a2267 1
static char *show_dotfiles_string = RC_SHOW_DOTFILES;
d2270 6
a2275 9
static char *dired_list_string = RC_DIR_LIST_STYLE;
static OptValues dired_list_values[] =
{
    {DIRS_FIRST, N_("Directories first"), "dired_dir"},
    {FILES_FIRST, N_("Files first"), "dired_files"},
    {MIXED_STYLE, N_("Mixed style"), "dired_mixed"},
    {0, 0, 0}
};

d2277 7
a2283 8
static char *dired_sort_string = RC_DIR_LIST_ORDER;
static OptValues dired_sort_values[] =
{
    {ORDER_BY_NAME, N_("By Name"), "dired_by_name"},
    {ORDER_BY_TYPE, N_("By Type"), "dired_by_type"},
    {ORDER_BY_SIZE, N_("By Size"), "dired_by_size"},
    {ORDER_BY_DATE, N_("By Date"), "dired_by_date"},
    {ORDER_BY_MODE, N_("By Mode"), "dired_by_mode"},
d2285 2
a2286 2
    {ORDER_BY_USER, N_("By User"), "dired_by_user"},
    {ORDER_BY_GROUP, N_("By Group"), "dired_by_group"},
d2288 1
a2288 2
    {0, 0, 0}
};
d2292 7
a2298 9
static char *ftp_sort_string = RC_FILE_SORTING_METHOD;
static OptValues ftp_sort_values[] =
{
    {FILE_BY_NAME, N_("By Name"), "ftp_by_name"},
    {FILE_BY_TYPE, N_("By Type"), "ftp_by_type"},
    {FILE_BY_SIZE, N_("By Size"), "ftp_by_size"},
    {FILE_BY_DATE, N_("By Date"), "ftp_by_date"},
    {0, 0, 0}
};
d2301 5
a2305 6
static char *show_rate_string = RC_SHOW_KB_RATE;
static OptValues rate_values[] =
{
    {rateOFF, N_("Do not show rate"), "rate_off"},
    {rateBYTES, N_("Show %s/sec rate"), "rate_bytes"},
    {rateKB, N_("Show %s/sec rate"), "rate_kb"},
d2307 2
a2308 2
    {rateEtaBYTES, N_("Show %s/sec, ETA"), "rate_eta_bytes"},
    {rateEtaKB, N_("Show %s/sec, ETA"), "rate_eta_kb"},
d2310 1
a2310 2
    {0, 0, 0}
};
a2313 31
 * Presentation (MIME) types used in "Accept".
 */
static char *preferred_media_string = RC_PREFERRED_MEDIA_TYPES;
static OptValues media_values[] =
{
    {mediaOpt1, N_("Accept lynx's internal types"), "media_opt1"},
    {mediaOpt2, N_("Also accept lynx.cfg's types"), "media_opt2"},
    {mediaOpt3, N_("Also accept user's types"), "media_opt3"},
    {mediaOpt4, N_("Also accept system's types"), "media_opt4"},
    {mediaALL, N_("Accept all types"), "media_all"},
    {0, 0, 0}
};

static char *preferred_encoding_string = RC_PREFERRED_ENCODING;
static OptValues encoding_values[] =
{
    {encodingNONE, N_("None"), "encoding_none"},
#if defined(USE_ZLIB) || defined(GZIP_PATH)
    {encodingGZIP, N_("gzip"), "encoding_gzip"},
#endif
#if defined(USE_ZLIB) || defined(COMPRESS_PATH)
    {encodingCOMPRESS, N_("compress"), "encoding_compress"},
#endif
#if defined(USE_BZLIB) || defined(BZIP2_PATH)
    {encodingBZIP2, N_("bzip2"), "encoding_bzip2"},
#endif
    {encodingALL, N_("All"), "encoding_all"},
    {0, 0, 0}
};

/*
d2316 3
a2318 3
static char *preferred_doc_char_string = RC_PREFERRED_CHARSET;
static char *preferred_doc_lang_string = RC_PREFERRED_LANGUAGE;
static char *user_agent_string = RC_USERAGENT;
d2337 4
a2340 2
static void PutOptValues(FILE *fp, int value,
			 OptValues * table)
d2353 4
a2356 2
static BOOLEAN GetOptValues(OptValues * table, char *value,
			    int *result)
d2377 3
a2379 1
static PostPair *break_data(bstring *data)
d2381 2
a2382 2
    char *p;
    PostPair *q = NULL;
d2414 3
a2416 4
	    size_t i, len;

	    len = strlen(q[count].value);
	    for (i = 0; i < len; i++) {
d2424 2
a2425 2
			&& q[count].value[i + 1] == '+'
			&& isalnum(UCH(q[count].value[i + 2]))) {
d2433 1
a2433 1
	    }
d2436 1
a2436 2
	CTRACE((tfp, "...item[%d] tag=%s, value=%s\n",
		count, q[count].tag, q[count].value));
d2443 1
a2443 1
	q = realloc(q, sizeof(PostPair) * (count + 1));
d2451 1
a2451 17
static BOOL isLynxOptionsPage(const char *address, const char *portion)
{
    BOOL result = FALSE;

    if (!strncasecomp(address, STR_LYNXOPTIONS, LEN_LYNXOPTIONS)) {
	unsigned len = strlen(portion);

	address += LEN_LYNXOPTIONS;
	if (!strncasecomp(address, portion, len)
	    && (address[len] == '\0' || LYIsHtmlSep(address[len]))) {
	    result = TRUE;
	}
    }
    return result;
}

static int gen_options(char **newfile);
d2485 2
a2486 1
int postoptions(DocInfo *newdoc)
d2489 1
a2489 1
    DocAddress WWWDoc;		/* need on exit */
a2493 1
    int old_media_value = LYAcceptMedia;
a2497 1

d2504 1
a2504 1
     * "<a href=\"" LYNXOPTIONS_PAGE(MBM_MENU) "\">Goto multi-bookmark menu</a>\n"
d2507 1
a2507 1
    if (isLynxOptionsPage(newdoc->address, MBM_LINK)) {
d2510 2
a2511 2
	    HTAlert(BOOKMARK_CHANGE_DISALLOWED);	/* anonymous */
	    return (NULLFILE);
d2513 1
a2513 1
	    return (NOT_FOUND);
d2515 2
a2516 2
	    edit_bookmarks();
	    return (NULLFILE);
a2517 3
    } else if (!isLynxOptionsPage(newdoc->address, "/")) {
	HTAlert(RANDOM_URL_DISALLOWED);
	return NULLFILE;
d2532 1
a2532 1
	    return (status);
d2544 1
a2544 1
	    return (NOT_FOUND);
d2549 1
a2549 1
	return (NORMAL);
d2563 1
a2563 1
	return (NOT_FOUND);
d2568 4
a2571 4
	 * This isn't really for security, but rather for avoiding that the
	 * user may revisit an older instance from the history stack and submit
	 * stuff which accidentally undoes changes that had been done from a
	 * newer instance.  - kw
d2586 1
a2586 1
		return (NULLFILE);
d2624 1
a2624 1
	    && GetOptValues(bool_values, data[i].value, &code)) {
d2635 1
a2635 1
	    && GetOptValues(exec_links_values, data[i].value, &code)) {
a2645 1

d2647 1
a2647 1
		&& keypad_mode != newval) {
a2661 1

d2664 1
a2664 2
		if (j == newval)
		    current_lineedit = newval;
d2667 1
a2672 1

d2675 1
a2675 2
		if (j == newval)
		    current_layout = newval;
d2688 1
a2688 1
	    && GetOptValues(search_type_values, data[i].value, &code)) {
d2694 1
a2694 1
	    && GetOptValues(DTD_type_values, data[i].value, &code)) {
d2704 1
a2704 1
	    && GetOptValues(bool_values, data[i].value, &code)) {
d2707 1
d2711 2
a2712 2
	    && GetOptValues(show_color_values, data[i].value,
			    &LYChosenShowColor)) {
d2727 1
a2727 1
	    && GetOptValues(bool_values, data[i].value, &code)) {
d2733 1
a2733 1
	    && GetOptValues(bool_values, data[i].value, &code)) {
d2736 1
d2740 1
a2740 1
	    && GetOptValues(bool_values, data[i].value, &code)) {
d2757 1
a2757 1
	    && GetOptValues(user_mode_values, data[i].value, &user_mode)) {
d2761 1
a2761 1
		display_lines = LYlines - 2;
d2767 1
a2767 1
	    GetOptValues(visited_links_values, data[i].value, &Visited_Links_As);
d2772 1
a2772 1
		&& !(pseudo_inline_alts == FALSE && clickable_images == FALSE)) {
d2777 1
a2777 1
		       && !(pseudo_inline_alts == TRUE && clickable_images == FALSE)) {
d2782 1
a2782 1
		       && !(clickable_images == TRUE)) {
d2790 1
a2790 1
	    && GetOptValues(verbose_images_type_values, data[i].value, &code)) {
d2799 1
a2799 1
	    && GetOptValues(bool_values, data[i].value, &code)) {
d2825 1
a2825 1
		&& ((raw_mode_old &&
d2827 2
a2828 2
		    || (!raw_mode_old &&
			newval != UCLYhndl_for_unspec)
d2836 1
d2840 1
a2840 1
	    && GetOptValues(bool_values, data[i].value, &code)) {
a2848 1

d2851 1
a2851 2
		if (j == newval)
		    current_char_set = newval;
d2857 1
a2857 1
	    && GetOptValues(bool_values, data[i].value, &code)) {
d2867 1
d2883 1
a2883 1
	    && GetOptValues(bool_values, data[i].value, &code)) {
d2886 1
d2890 1
a2890 1
	    && GetOptValues(rate_values, data[i].value, &code)) {
a2894 10
	/* Preferred Media Type: SELECT */
	if (!strcmp(data[i].tag, preferred_media_string)) {
	    GetOptValues(media_values, data[i].value, &LYAcceptMedia);
	}

	/* Preferred Encoding: SELECT */
	if (!strcmp(data[i].tag, preferred_encoding_string)) {
	    GetOptValues(encoding_values, data[i].value, &LYAcceptEncoding);
	}

d2901 1
a2901 1
	    }
d2920 3
a2922 3
			     *(data[i].value)
			     ? data[i].value
			     : LYUserAgentDefault);
d2928 1
a2928 1
    }				/* end of loop */
d2936 3
a2938 7

    if (old_media_value != LYAcceptMedia)
	HTFilterPresentations();

    if (display_char_set_old != current_char_set ||
	raw_mode_old != LYRawMode ||
	assume_char_set_changed) {
d2944 2
a2945 2
	     * Set the LYUseDefaultRawMode value and character handling if
	     * LYRawMode was changed.  - FM
d2952 2
a2953 2
		(current_char_set == auto_display_charset
		 || current_char_set == auto_other_display_charset);
d2961 2
a2962 2
	     * Set the raw 8-bit or CJK mode defaults and character set if
	     * changed.  - FM
d2968 2
a2969 2
    }
    /* end of charset settings */
d2986 2
a2987 2
     * Exit:  working around the previous document.  Being out of
     * mainloop()/getfile() cycle, do things manually.
d2991 1
a2991 1
	    need_reload ? "TRUE" : "FALSE"));
d2993 1
a2993 1
	    need_end_reload ? "TRUE" : "FALSE"));
d3003 2
a3004 2
    LYforce_no_cache = FALSE;	/* ! */
    LYoverride_no_cache = TRUE;	/* ! */
d3014 1
a3014 1
	return (NOT_FOUND);
d3016 1
a3016 1
    HTuncache_current_document();	/* will never use again */
d3019 3
a3021 2
     * Return to previous doc, not to options menu!  Reload the document we had
     * before the options menu but uncache only when necessary (Hurrah, user!):
d3030 2
a3031 2
    LYforce_no_cache = FALSE;	/* see below */
    LYoverride_no_cache = TRUE;	/* see below */
d3040 1
a3040 1
	return (NOT_FOUND);
d3047 4
a3050 4
    reloading = FALSE;		/* set manually */
    /* force end-to-end reload from remote server if change LYUserAgent or
     * language or pref_charset (marked by need_end_reload flag above), from
     * old-style LYK_OPTIONS (mainloop):
d3056 9
a3064 7
	 * An option has changed which may influence content negotiation, and
	 * the resource is from a http or https or lynxcgi URL (the only
	 * protocols which currently do anything with this information).  Set
	 * reloading = TRUE so that proxy caches will be flushed, which is
	 * necessary until the time when all proxies understand HTTP 1.1 Vary: 
	 * and all Servers properly use it...  Treat like case LYK_RELOAD (see
	 * comments there).  - KW
d3066 2
a3067 2
	reloading = TRUE;	/* global flag */
	need_reload = TRUE;	/* this was probably already TRUE, don't worry */
d3073 1
a3073 1
	return (NORMAL);
d3078 1
a3078 1
	 * see LYK_RELOAD & LYK_OPTIONS in mainloop for details...
d3090 1
a3090 1
		return (NORMAL);
d3100 1
a3100 1
	    return (NORMAL);
d3108 1
a3108 1
	return (NULLFILE);
d3114 1
a3114 1
static char *NewSecureValue(void)
a3119 1

d3121 1
a3121 1
	long key = (long) secure_value + (long) time(0);
d3135 4
a3138 2
static void PutLabel(FILE *fp, char *name,
		     char *value)
a3143 1

d3146 2
a3147 2
		(l < (LABEL_LEN - 3)) ? " " : "",
		(l < (LABEL_LEN - 3)) ? (LABEL_LEN - 1) - l : 3, "(!)");
d3157 1
a3157 1
static char *check_if_write_lynxrc(char **table)
d3175 1
a3175 1
static char *will_save_cookies(void)
d3177 3
a3179 4
    static char *table[] =
    {
	RC_SET_COOKIES,		/* LYSetCookies */
	RC_ACCEPT_ALL_COOKIES,	/* LYAcceptAllCookies */
a3181 1

d3190 1
a3190 1
static char *will_save_images(void)
d3192 2
a3193 3
    static char *table[] =
    {
	RC_MAKE_PSEUDO_ALTS_FOR_INLINES,	/* pseudo_inline_alts */
a3196 1

d3204 3
a3206 1
void LYMenuVisitedLinks(FILE *fp0, int disable_all)
d3224 2
a3225 1
static int gen_options(char **newfile)
d3235 1
a3235 1
	return (NOT_FOUND);
d3239 11
a3249 11
    /* This should not be needed if we regenerate the temp file every time with
     * a new name, which just happened above in the case
     * LYReuseTempfiles==FALSE.  Even for LYReuseTempfiles=TRUE, code at the
     * end of postoptions() may remove an older cached version from memory if
     * that version of the page was left by submitting changes.  - kw
     * 1999-11-27
     * If access to the actual file via getfile() later fails (maybe because of
     * some restrictions), mainloop may leave this flag on after popping the
     * previous doc which is then unnecessarily reloaded.  But I changed
     * mainloop to reset the flag.  - kw 1999-05-24
     */
d3261 1
a3261 1
    BeginInternalPage(fp0, OPTIONS_TITLE, NULL);	/* help link below */
d3273 1
a3273 1
	    secure_string, NewSecureValue());
d3280 1
a3280 1
    fprintf(fp0, "<p align=center>\n");
d3282 3
a3284 3
	fprintf(fp0, "<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0, "<input type=\"reset\" value=\"%s\"> - \n", RESET_CHANGES);
	fprintf(fp0, "%s - \n", CANCEL_CHANGES);
d3287 1
a3287 1
	    helpfilepath, OPTIONS_HELP, TO_HELP);
d3294 1
a3294 1
		    save_options_string);
d3297 1
a3297 1
		gettext("(options marked with (!) will not be saved)"));
d3303 1
a3303 1
    fprintf(fp0, "<pre>\n");
d3305 1
a3305 1
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("General Preferences"));
d3317 1
a3317 1
		 DISABLED(no_editor || system_editor));
d3325 1
a3325 1
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Security and Privacy"));
d3332 2
a3333 2
	      cookies_ignore_all_string,
	      cookies_ignore_all_string);
d3335 2
a3336 2
	      cookies_up_to_user_string,
	      cookies_up_to_user_string);
d3338 2
a3339 2
	      cookies_accept_all_string,
	      cookies_accept_all_string);
d3356 1
a3356 1
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Keyboard Input"));
d3378 1
a3378 1
    if (LYLineeditNames[1]) {	/* well, at least 2 line edit styles available */
a3382 1

d3384 1
a3384 1
	    PutOption(fp0, i == current_lineedit, temp, LYLineeditNames[i]);
d3388 1
a3394 1

d3404 1
a3404 1
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Display and Character Set"));
a3422 1

d3429 1
a3429 1
	    PutOption(fp0, i == current_char_set, temp, LYchar_set_names[i]);
a3435 1

d3444 1
a3444 1
	    /* ok, LYRawMode, so use UCAssume_MIMEcharset */
d3453 3
a3455 3
		PutOption(fp0, i == curval,
			  LYCharSet_UC[i].MIMEname,
			  LYCharSet_UC[i].MIMEname);
d3477 1
a3477 1
    PutLabel(fp0, gettext("X Display"), x_display_string);
d3483 1
a3483 1
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Document Appearance"));
d3493 1
a3493 1
	    LYShowColor = SHOW_COLOR_OFF;
d3495 1
a3495 1
	    LYShowColor = SHOW_COLOR_ON;
d3501 2
a3502 2
	    show_color_values[2].HtmlName = on_string;
	    show_color_values[3].LongName = always_string;
d3504 2
a3505 2
	    show_color_values[2].HtmlName = NULL;	/* suppress "ON" - kw */
	    show_color_values[3].LongName = "Always try";
d3548 2
a3549 2
	      images_ignore_all_string,
	      images_ignore_all_string);
d3551 2
a3552 2
	      images_use_label_string,
	      images_use_label_string);
d3554 2
a3555 2
	      images_use_links_string,
	      images_use_links_string);
d3567 1
a3567 2
    fprintf(fp0, "\n  <em>%s</em>\n",
	    gettext("Headers Transferred to Remote Servers"));
d3573 1
a3573 13
		 NonNull(personal_mail_address), text_len, "");

    /* Preferred media type: SELECT */
    PutLabel(fp0, gettext("Preferred media type"), preferred_media_string);
    BeginSelect(fp0, preferred_media_string);
    PutOptValues(fp0, LYAcceptMedia, media_values);
    EndSelect(fp0);

    /* Preferred encoding: SELECT */
    PutLabel(fp0, gettext("Preferred encoding"), preferred_encoding_string);
    BeginSelect(fp0, preferred_encoding_string);
    PutOptValues(fp0, LYAcceptEncoding, encoding_values);
    EndSelect(fp0);
d3578 1
a3578 1
		 NonNull(pref_charset), cset_len + 2, "");
d3583 1
a3583 1
		 NonNull(language), cset_len + 2, "");
d3589 1
a3589 1
		     NonNull(LYUserAgent), text_len, "");
d3595 1
a3595 1
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Listing and Accessing Files"));
d3599 1
a3599 1
    PutLabel(fp0, gettext("FTP sort criteria"), ftp_sort_string);
d3633 5
a3637 5
		 ? EXEC_ALWAYS
		 : (local_exec_on_local_files
		    ? EXEC_LOCAL
		    : EXEC_NEVER),
		 exec_links_values);
d3640 3
a3642 3
		 ? EXEC_LOCAL
		 : EXEC_NEVER,
		 exec_links_values);
a3652 1

d3660 1
a3660 1
	FREE(message);
d3668 1
a3668 1
    fprintf(fp0, "\n  <em>%s</em>\n", gettext("Special Files and Screens"));
d3682 2
a3683 2
	fprintf(fp0, "<a href=\"%s\">%s</a>\n",
		LYNXOPTIONS_PAGE(MBM_LINK), gettext("Goto multi-bookmark menu"));
d3687 1
a3687 1
		     NonNull(bookmark_page), text_len, "");
d3696 2
a3697 2
		gettext("View the file "),
		STR_LYNXCFG);
d3700 1
a3700 1
    fprintf(fp0, "\n</pre>\n");
d3704 4
a3707 4
	fprintf(fp0, "<p align=center>\n");
	fprintf(fp0, "<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0, "<input type=\"reset\" value=\"%s\"> - \n", RESET_CHANGES);
	fprintf(fp0, "%s\n", CANCEL_CHANGES);
d3713 1
a3713 1
    fprintf(fp0, "</form>\n");
d3717 1
a3717 1
    return (NORMAL);
@


1.1.3.6
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@a2843 1
	    need_reload = TRUE;
a3250 5
    int have = strlen(name);
    int want = LABEL_LEN;
    int need = LYstrExtent(name, have, want);

    fprintf(fp, "&nbsp;&nbsp;%s", name);
d3252 1
a3252 2
	while (need++ < want)
	    fprintf(fp, "&nbsp;");
d3254 6
a3259 9
	want -= 3;
	if (need < want) {
	    fprintf(fp, "&nbsp;");
	    ++need;
	}
	fprintf(fp, "(!)");
	while (need++ < want) {
	    fprintf(fp, "&nbsp;");
	}
a3260 1
    fprintf(fp, ": ");
@


1.1.3.7
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d47 1
a47 1
    if (non_empty(LYUserAgent)) {
d419 1
a419 1
    LYaddstr(non_empty(editor) ? editor : "NONE");
d423 1
a423 1
    LYaddstr(non_empty(x_display) ? x_display : "NONE");
d433 1
a433 1
	LYaddstr(non_empty(bookmark_page) ? bookmark_page : "NONE");
d445 1
a445 1
    LYaddstr(non_empty(personal_mail_address) ?
d458 1
a458 1
    LYaddstr(non_empty(language) ? language : "NONE");
d462 1
a462 1
    LYaddstr(non_empty(pref_charset) ? pref_charset : "NONE");
d565 1
a565 1
    LYaddstr(non_empty(LYUserAgent) ? LYUserAgent : "NONE");
d631 1
a631 1
		if (non_empty(editor))
d646 1
a646 1
		    LYaddstr(non_empty(editor) ?
d667 1
a667 1
	    if (non_empty(x_display)) {
d695 1
a695 1
		LYaddstr(non_empty(x_display) ? x_display : "NONE");
d763 1
a763 1
		    LYaddstr(non_empty(bookmark_page) ?
d784 1
a784 1
		if (non_empty(bookmark_page)) {
d802 1
a802 1
		    LYaddstr(non_empty(bookmark_page) ?
d806 1
a806 1
		    LYaddstr(non_empty(bookmark_page) ?
d853 1
a853 1
	    if (non_empty(personal_mail_address)) {
d1068 1
a1068 1
	    if (non_empty(language)) {
d1083 1
a1083 1
		LYaddstr(non_empty(language) ?
d1103 1
a1103 1
	    if (non_empty(pref_charset)) {
d1120 1
a1120 1
		LYaddstr(non_empty(pref_charset) ?
d1441 1
a1441 1
		if (non_empty(LYUserAgent)) {
a2385 1
    {encodingDEFLATE, N_("deflate"), "encoding_deflate"},
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a28 2
PRIVATE int LYChosenShowColor = SHOW_COLOR_UNKNOWN; /* whether to show and save */

d31 1
a31 1
#if !defined(NO_OPTION_MENU) || (defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES)))
a34 83
#if defined(USE_SLANG) || defined(COLOR_CURSES)
PRIVATE BOOLEAN can_do_colors = 0;
#endif

PUBLIC BOOLEAN LYCheckUserAgent NOARGS
{
    if (LYUserAgent && *LYUserAgent) {
	if (strstr(LYUserAgent, "Lynx") == 0
	 && strstr(LYUserAgent, "lynx") == 0
	 && strstr(LYUserAgent, "L_y_n_x") == 0
	 && strstr(LYUserAgent, "l_y_n_x") == 0) {
	    return FALSE;
	}
    }
    return TRUE;
}

PRIVATE void SetupChosenShowColor NOARGS
{
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    can_do_colors = 1;
#if defined(COLOR_CURSES)
    if (LYCursesON)	/* could crash if called before initialization */
	can_do_colors = (BOOL) has_colors();
#endif
    if (!no_option_save) {
	if (LYChosenShowColor == SHOW_COLOR_UNKNOWN) {
	    switch (LYrcShowColor) {
	    case SHOW_COLOR_NEVER:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
			SHOW_COLOR_ON : SHOW_COLOR_NEVER;
		break;
	    case SHOW_COLOR_ALWAYS:
		if (!can_do_colors)
		    LYChosenShowColor = SHOW_COLOR_ALWAYS;
		else
		    LYChosenShowColor =
			(LYShowColor >= SHOW_COLOR_ON) ?
				SHOW_COLOR_ALWAYS : SHOW_COLOR_OFF;
		break;
	    default:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
			SHOW_COLOR_ON : SHOW_COLOR_OFF;
	    }
	}
    }
#endif /* USE_SLANG || COLOR_CURSES */
}

PRIVATE void validate_x_display NOPARAMS
{
    char *cp;
    if ((cp = LYgetXDisplay()) != NULL) {
	StrAllocCopy(x_display, cp);
    } else {
	FREE(x_display);
    }
}

PRIVATE void summarize_x_display ARGS1(
    char *,	display_option)
{
    if ((x_display == NULL && *display_option == '\0') ||
	(x_display != NULL && !strcmp(x_display, display_option))) {
	if (x_display == NULL && LYisConfiguredForX == TRUE) {
	    _statusline(VALUE_ACCEPTED_WARNING_X);
	} else if (x_display != NULL && LYisConfiguredForX == FALSE) {
	    _statusline(VALUE_ACCEPTED_WARNING_NONX);
	} else {
	    _statusline(VALUE_ACCEPTED);
	}
    } else {
	if (*display_option) {
	    _statusline(FAILED_TO_SET_DISPLAY);
	} else {
	    _statusline(FAILED_CLEAR_SET_DISPLAY);
	}
    }
}


d40 1
a40 3
	CONST char **	choices));
#define LYChooseBoolean(status, line, column, choices) \
	boolean_choice(status, line, column, (CONST char **)choices)
d106 11
a116 11
#define L_Bool_A     (use_assume_charset ? L_BOOL_A     + 1 : L_BOOL_A)
#define L_Bool_B     (use_assume_charset ? L_BOOL_B     + 1 : L_BOOL_B)
#define L_Exec       (use_assume_charset ? L_EXEC       + 1 : L_EXEC)
#define L_Rawmode    (use_assume_charset ? L_RAWMODE    + 1 : L_RAWMODE)
#define L_Charset    (use_assume_charset ? L_CHARSET    + 1 : L_CHARSET)
#define L_Color      (use_assume_charset ? L_COLOR      + 1 : L_COLOR)
#define L_Keypad     (use_assume_charset ? L_KEYPAD     + 1 : L_KEYPAD)
#define L_Lineed     (use_assume_charset ? L_LINEED     + 1 : L_LINEED)
#define L_Layout     (use_assume_charset ? L_LAYOUT     + 1 : L_LAYOUT)
#define L_Dired      (use_assume_charset ? L_DIRED      + 1 : L_DIRED)
#define L_User_Mode  (use_assume_charset ? L_USER_MODE  + 1 : L_USER_MODE)
d126 1
a126 1
	LYaddstr(text);
d132 1
a132 1
 * addlbl() is used instead of plain LYaddstr() in old-style options menu
a158 15
#if !defined(VMS) || defined(USE_SLANG)
#define HANDLE_LYOPTIONS \
		    if (term_options) { \
			term_options = FALSE; \
		    } else { \
			AddValueAccepted = TRUE; \
		    } \
		    goto draw_options
#else
#define HANDLE_LYOPTIONS \
		    term_options = FALSE; \
		    if (use_assume_charset != old_use_assume_charset) \
			goto draw_options
#endif /* !VMS || USE_SLANG */

d161 1
a161 53
#define ShowBool(value) LYaddstr((value) ? "ON " : "OFF")
    static char *bool_choices[] = {
	"OFF",
	"ON",
	NULL
    };
    static char *caseless_choices[] = {
	"CASE INSENSITIVE",
	"CASE SENSITIVE",
	NULL
    };
    static char *dirList_choices[] = {
	"Directories first",
	"Files first",
	"Mixed style",
	NULL
    };
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    static char *exec_choices[] = {
	"ALWAYS OFF",
	"FOR LOCAL FILES ONLY",
#ifndef NEVER_ALLOW_REMOTE_EXEC
	"ALWAYS ON",
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
	NULL
    };
#endif
    static char *fileSort_choices[] = {
	"By Filename",
	"By Type",
	"By Size",
	"By Date",
	NULL
    };
    static char *keypad_choices[] = {
	"Numbers act as arrows",
	"Links are numbered",
	"Links and form fields are numbered",
	NULL
    };
    static char *mbm_choices[] = {
	"OFF     ",
	"STANDARD",
	"ADVANCED",
	NULL
    };
    static char *userMode_choices[] = {
	"Novice",
	"Intermediate",
	"Advanced",
	NULL
    };
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
d163 1
a163 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d179 1
a179 1
#ifdef ENABLE_OPTS_CHANGE_EXEC
d189 1
a189 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d191 1
a191 1
#ifdef ENABLE_OPTS_CHANGE_EXEC
d201 1
a201 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d215 26
a240 1
	SetupChosenShowColor();
d245 1
a245 1
	use_assume_charset = (BOOL) (user_mode == ADVANCED_MODE);
d254 1
d257 1
a257 1
	LYclear();
d259 1
a259 1
	LYerase();
d262 1
a262 1
    LYclear();
d264 1
a264 1
    LYmove(0, 5);
d267 5
a271 5
    LYaddstr("         Options Menu (");
    LYaddstr(LYNX_NAME);
    LYaddstr(" Version ");
    LYaddstr(LYNX_VERSION);
    LYaddch(')');
d273 1
a273 1
    LYmove(L_EDITOR, 5);
d275 1
a275 1
    LYaddstr((editor && *editor) ? editor : "NONE");
d277 1
a277 1
    LYmove(L_DISPLAY, 5);
d279 1
a279 1
    LYaddstr((x_display && *x_display) ? x_display : "NONE");
d281 1
a281 1
    LYmove(L_HOME, 5);
d283 6
a288 3
    LYaddstr(mbm_choices[LYMultiBookmarks]);
    LYmove(L_HOME, B_BOOK);
    if (LYMultiBookmarks != MBM_OFF) {
d292 1
a292 1
	LYaddstr((bookmark_page && *bookmark_page) ? bookmark_page : "NONE");
d295 1
a295 1
    LYmove(L_FTPSTYPE, 5);
d297 1
a297 1
    LYaddstr((HTfileSortMethod == FILE_BY_NAME ? "By Filename" :
d302 1
a302 1
    LYmove(L_MAIL_ADDRESS, 5);
d304 1
a304 1
    LYaddstr((personal_mail_address && *personal_mail_address) ?
d307 1
a307 1
    LYmove(L_SSEARCH, 5);
d309 1
a309 1
    LYaddstr(case_sensitive ? "CASE SENSITIVE  " : "CASE INSENSITIVE");
d311 1
a311 1
    LYmove(L_Charset, 5);
d313 1
a313 1
    LYaddstr(LYchar_set_names[current_char_set]);
d315 1
a315 1
    LYmove(L_LANGUAGE, 5);
d317 1
a317 1
    LYaddstr((language && *language) ? language : "NONE");
d319 1
a319 1
    LYmove(L_PREF_CHARSET, 5);
d321 1
a321 1
    LYaddstr((pref_charset && *pref_charset) ? pref_charset : "NONE");
d324 1
a324 1
	LYmove(L_ASSUME_CHARSET, 5);
d327 1
a327 1
	    LYaddstr(UCAssume_MIMEcharset);
d329 2
a330 2
	    LYaddstr((UCLYhndl_for_unspec >= 0) ?
		     LYCharSet_UC[UCLYhndl_for_unspec].MIMEname
d334 1
a334 1
    LYmove(L_Rawmode, 5);
d336 1
a336 1
    ShowBool(LYRawMode);
d339 1
a339 1
    LYmove(L_Color, B_COLOR);
d342 2
a343 1
	ShowBool(LYShowColor == SHOW_COLOR_OFF);
d347 1
a347 1
		LYaddstr("NEVER     ");
d350 1
a350 1
		LYaddstr("OFF");
d353 1
a353 1
		LYaddstr("ON ");
d358 1
a358 1
		    LYaddstr("Always try");
d361 1
a361 1
		    LYaddstr("ALWAYS    ");
d366 1
a366 1
    LYmove(L_Bool_A, B_VIKEYS);
d368 1
a368 1
    ShowBool(vi_keys);
d370 1
a370 1
    LYmove(L_Bool_A, B_EMACSKEYS);
d372 1
a372 1
    ShowBool(emacs_keys);
d374 1
a374 1
    LYmove(L_Bool_A, B_SHOW_DOTFILES);
d376 1
a376 1
    ShowBool(!no_dotfiles && show_dotfiles);
d378 1
a378 1
    LYmove(L_Bool_B, B_SELECT_POPUPS);
d380 1
a380 1
    ShowBool(LYSelectPopups);
d382 1
a382 1
    LYmove(L_Bool_B, B_SHOW_CURSOR);
d384 1
a384 1
    ShowBool(LYShowCursor);
d386 1
a386 1
    LYmove(L_Keypad, 5);
d388 1
a388 1
    LYaddstr((keypad_mode == NUMBERS_AS_ARROWS) ?
d394 1
a394 1
    LYmove(L_Lineed, 5);
d396 1
a396 1
    LYaddstr(LYLineeditNames[current_lineedit]);
d399 1
a399 1
    LYmove(L_Layout, 5);
d401 1
a401 1
    LYaddstr(LYKbLayoutNames[current_layout]);
d405 1
a405 1
    LYmove(L_Dired, 5);
d407 1
a407 1
    LYaddstr((dir_list_style == FILES_FIRST) ? "Files first      " :
d412 1
a412 1
    LYmove(L_User_Mode, 5);
d414 1
a414 1
    LYaddstr(  (user_mode == NOVICE_MODE) ? "Novice      " :
d419 1
a419 1
    ShowBool( verbose_img);
d421 1
a421 1
    LYmove(L_User_Agent, 5);
d423 1
a423 1
    LYaddstr((LYUserAgent && *LYUserAgent) ? LYUserAgent : "NONE");
d425 2
a426 2
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    LYmove(L_Exec, 5);
d429 1
a429 1
    LYaddstr(               local_exec ? "ALWAYS ON           " :
d433 1
a433 1
    LYaddstr(local_exec_on_local_files ? "FOR LOCAL FILES ONLY" :
d436 1
a436 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d438 2
a439 2
    LYmove(LYlines-3, 2);
    LYaddstr(SELECT_SEGMENT);
d441 1
a441 1
    LYaddstr(CAP_LETT_SEGMENT);
d443 1
a443 1
    LYaddstr(OF_OPT_LINE_SEGMENT);
d445 1
a445 1
	LYaddstr(" '");
d447 1
a447 1
	LYaddstr(">");
d449 2
a450 2
	LYaddstr("'");
	LYaddstr(TO_SAVE_SEGMENT);
d452 2
a453 2
    LYaddstr(OR_SEGMENT);
    LYaddstr("'");
d455 1
a455 1
    LYaddstr("r");
d457 2
a458 2
    LYaddstr("'");
    LYaddstr(TO_RETURN_SEGMENT);
d460 1
a460 2
    response = 0;
    while (response != 'R' &&
d463 1
a463 1
	   !LYCharIsINTERRUPT_NO_letter(response)) {
d468 1
a468 1
	LYmove((LYlines - 2), 0);
d470 1
a470 1
	LYaddstr(COMMAND_PROMPT);
d473 3
a475 3
	LYrefresh();
	response = LYgetch_single();
	if (term_options || LYCharIsINTERRUPT_NO_letter(response))
d482 2
a483 1
	    case 'E':	/* Change the editor. */
d490 1
a490 1
			LYstrncpy(display_option, editor, sizeof(display_option) - 1);
d492 2
a493 2
			LYmove(L_EDITOR, COL_OPTION_VALUES);
			LYaddstr("    ");
d497 1
a497 1
		    LYmove(L_EDITOR, COL_OPTION_VALUES);
d502 1
a502 1
		    LYmove(L_EDITOR, COL_OPTION_VALUES);
d504 1
a504 1
			LYaddstr((editor && *editor) ?
d508 1
a508 1
			LYaddstr("NONE");
d511 1
a511 1
			LYaddstr(display_option);
d513 1
a513 1
		    LYclrtoeol();
d524 2
a525 1
	    case 'D':	/* Change the display. */
d527 1
a527 1
		    LYstrncpy(display_option, x_display, sizeof(display_option) - 1);
d529 2
a530 2
		    LYmove(L_DISPLAY, COL_OPTION_VALUES);
		    LYaddstr("    ");
d534 1
a534 1
		LYmove(L_DISPLAY, COL_OPTION_VALUES);
d539 3
a541 2
		LYmove(L_DISPLAY, COL_OPTION_VALUES);

d543 1
a543 1
#define CompareEnvVars(a,b) strcasecomp(a, b)
d545 1
a545 1
#define CompareEnvVars(a,b) strcmp(a, b)
d547 1
a547 4

		if ((term_options || ch == -1) ||
		    (x_display != NULL &&
		     !CompareEnvVars(x_display, display_option))) {
d552 2
a553 2
		    LYaddstr((x_display && *x_display) ? x_display : "NONE");
		    LYclrtoeol();
d569 2
a570 2
			LYaddstr("NONE");
			LYclrtoeol();
d580 5
a584 1
		validate_x_display();
d586 21
a606 3
		LYaddstr(x_display ? x_display : "NONE");
		LYclrtoeol();
		summarize_x_display(display_option);
d610 2
a611 1
	    case 'L':	/* Change multibookmarks option. */
d617 7
d625 2
a626 1
		    LYMultiBookmarks = LYChooseBoolean(LYMultiBookmarks,
d628 1
a628 1
						      mbm_choices);
d630 2
a631 1
		    LYMultiBookmarks = LYChoosePopup(LYMultiBookmarks,
d633 8
a640 2
						    mbm_choices,
						    3, FALSE, FALSE);
d644 3
a646 3
		    LYmove(L_HOME, C_MULTI);
		    LYclrtoeol();
		    LYaddstr(mbm_choices[LYMultiBookmarks]);
d649 3
d656 4
a659 4
		    LYmove(L_HOME, B_BOOK);
		    LYclrtoeol();
		    if (LYMultiBookmarks != MBM_OFF) {
			LYaddstr(gettext("review/edit B)ookmarks files"));
d661 2
a662 2
			LYaddstr(gettext("B)ookmark file: "));
			LYaddstr((bookmark_page && *bookmark_page) ?
d668 10
a677 1
		    HANDLE_LYOPTIONS;
d681 2
a682 1
	    case 'B':	/* Change the bookmark page location. */
d688 1
a688 1
		    if (LYMultiBookmarks != MBM_OFF) {
d694 1
a694 1
			LYstrncpy(display_option, bookmark_page, sizeof(display_option) - 1);
d696 2
a697 2
			LYmove(L_HOME, C_DEFAULT);
			LYclrtoeol();
d701 1
a701 1
		    LYmove(L_HOME, C_DEFAULT);
d706 1
a706 1
		    LYmove(L_HOME, C_DEFAULT);
d709 1
a709 1
			LYaddstr((bookmark_page && *bookmark_page) ?
d713 1
a713 1
			LYaddstr((bookmark_page && *bookmark_page) ?
d715 1
a715 1
			LYclrtoeol();
d721 3
a723 2
			StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
			LYaddstr(bookmark_page);
d725 1
a725 1
		    LYclrtoeol();
d738 14
a751 1
	    case 'F':	/* Change ftp directory sorting. */
d753 1
a753 1
		    HTfileSortMethod = LYChooseBoolean(HTfileSortMethod,
d755 1
a755 1
						      fileSort_choices);
d757 1
a757 1
		    HTfileSortMethod = LYChoosePopup(HTfileSortMethod,
d759 2
a760 2
						    fileSort_choices,
						    4, FALSE, FALSE);
d762 3
a764 3
		    LYmove(L_FTPSTYPE, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(fileSort_choices[HTfileSortMethod]);
d767 4
d773 10
a782 1
		    HANDLE_LYOPTIONS;
d786 2
a787 1
	    case 'P': /* Change personal mail address for From headers. */
d789 1
a789 1
		    LYstrncpy(display_option, personal_mail_address, sizeof(display_option) - 1);
d791 2
a792 2
		    LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
		    LYaddstr("    ");
d796 1
a796 1
		LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
d801 1
a801 1
		LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
d803 1
a803 1
		    LYaddstr((personal_mail_address &&
d808 1
a808 1
		    LYaddstr("NONE");
d811 1
a811 1
		    LYaddstr(display_option);
d813 1
a813 1
		LYclrtoeol();
d823 14
a836 4
	    case 'S':	/* Change case sensitivity for searches. */
		case_sensitive = LYChooseBoolean(case_sensitive,
						 L_SSEARCH, -1,
						 caseless_choices);
d843 2
a844 2
		    CONST char ** assume_list;
		    assume_list = typecallocn(CONST char *,(LYNumCharsets + 1));
d849 1
a849 1
			assume_list[i] = LYCharSet_UC[i].MIMEname;
d858 1
a858 9
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
			UCLYhndl_for_unspec = assumed_doc_charset_map[
			    LYChooseBoolean(charset_subsets[curval].assumed_idx,
					    L_ASSUME_CHARSET, -1,
					    assumed_charset_choices)
					    ? 1
					    : 0];
#else
			UCLYhndl_for_unspec = LYChooseBoolean(curval,
a860 1
#endif
d862 1
a862 10
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
			UCLYhndl_for_unspec = assumed_doc_charset_map[
			    LYChoosePopup(charset_subsets[curval].assumed_idx,
					  L_ASSUME_CHARSET, -1,
					  assumed_charset_choices,
					  0, FALSE, FALSE)
					  ? 1
					  : 0];
#else
			UCLYhndl_for_unspec = LYChoosePopup(curval,
d865 1
a865 2
							   0, FALSE, FALSE);
#endif
d867 2
a868 2
			LYmove(L_ASSUME_CHARSET, COL_OPTION_VALUES);
			LYclrtoeol();
d870 2
a871 1
			    LYaddstr(LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d885 1
a885 2
			if (HTCJK != JAPANESE)
			    LYRawMode = (BOOL) (UCLYhndl_for_unspec == current_char_set);
d894 3
a896 3
			    LYmove(L_Rawmode, COL_OPTION_VALUES);
			    LYclrtoeol();
			    ShowBool(LYRawMode);
d902 10
a911 1
			HANDLE_LYOPTIONS;
d919 2
a920 1
	    case 'C':	/* Change display charset setting. */
d922 1
a922 7
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		    displayed_display_charset_idx = LYChooseBoolean(displayed_display_charset_idx,
						      L_Charset, -1,
						      display_charset_choices);
		    current_char_set = display_charset_map[displayed_display_charset_idx];
#else
		    current_char_set = LYChooseBoolean(current_char_set,
d924 1
a924 2
						      LYchar_set_names);
#endif
d926 1
a926 2
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		    displayed_display_charset_idx = LYChoosePopup(displayed_display_charset_idx,
d928 2
a929 10
						    display_charset_choices,
						    0, FALSE, FALSE);
		    current_char_set = display_charset_map[displayed_display_charset_idx];
#else
		    current_char_set = LYChoosePopup(current_char_set,
						    L_Charset, -1,
						    LYchar_set_names,
						    0, FALSE, FALSE);
#endif

d931 3
a933 3
		    LYmove(L_Charset, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(LYchar_set_names[current_char_set]);
d949 4
a952 10
			LYmove(L_Rawmode, COL_OPTION_VALUES);
			LYclrtoeol();
			ShowBool(LYRawMode);
		    }
#ifdef CAN_SWITCH_DISPLAY_CHARSET
		    /* Deduce whether the user wants autoswitch: */
		    switch_display_charsets =
			(current_char_set == auto_display_charset
			    || current_char_set == auto_other_display_charset);
#endif
d956 10
a965 1
		    HANDLE_LYOPTIONS;
d969 11
a979 2
	    case 'O':	/* Change raw mode setting. */
		LYRawMode = LYChooseBoolean(LYRawMode, L_Rawmode, -1, bool_choices);
d989 2
d994 2
a995 1
	    case 'G':	/* Change language preference. */
d997 1
a997 1
		    LYstrncpy(display_option, language, sizeof(display_option) - 1);
d999 2
a1000 2
		    LYmove(L_LANGUAGE, COL_OPTION_VALUES);
		    LYaddstr("    ");
d1004 1
a1004 1
		LYmove(L_LANGUAGE, COL_OPTION_VALUES);
d1009 1
a1009 1
		LYmove(L_LANGUAGE, COL_OPTION_VALUES);
d1011 1
a1011 1
		    LYaddstr((language && *language) ?
d1015 1
a1015 1
		    LYaddstr("NONE");
d1018 1
a1018 1
		    LYaddstr(display_option);
d1020 1
a1020 1
		LYclrtoeol();
d1030 2
a1031 1
	    case 'H':	/* Change charset preference. */
d1033 1
a1033 1
		    LYstrncpy(display_option, pref_charset, sizeof(display_option) - 1);
d1035 2
a1036 2
		    LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
		    LYaddstr("    ");
d1040 1
a1040 1
		LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
d1045 1
a1045 1
		LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
d1047 1
a1047 1
		    LYaddstr((pref_charset && *pref_charset) ?
d1051 1
a1051 1
		    LYaddstr("NONE");
d1054 1
a1054 1
		    LYaddstr(display_option);
d1056 1
a1056 1
		LYclrtoeol();
d1066 11
a1076 2
	    case 'V':	/* Change VI keys setting. */
		vi_keys = LYChooseBoolean(vi_keys,
d1078 1
a1078 1
					 bool_choices);
d1084 2
d1090 10
a1099 1
		emacs_keys = LYChooseBoolean(emacs_keys,
d1101 1
a1101 1
					    bool_choices);
d1107 2
d1113 1
d1117 9
a1125 1
		    show_dotfiles = LYChooseBoolean(show_dotfiles,
d1128 3
a1130 1
						   bool_choices);
d1135 11
a1145 2
	    case 'T':	/* Change select popups setting. */
		LYSelectPopups = LYChooseBoolean(LYSelectPopups,
d1148 3
a1150 1
						bool_choices);
a1165 1
			break;
d1168 9
a1176 1
		    LYShowColor = LYChooseBoolean((LYShowColor - 1),
d1179 1
a1179 1
						 bool_choices);
d1188 3
a1190 3
		    /*
		     *  Copy strings into choice array.
		     */
d1207 1
a1207 1
			    chosen = LYChooseBoolean(LYChosenShowColor,
d1212 1
a1212 1
			    chosen = LYChoosePopup(LYChosenShowColor,
d1215 1
a1215 1
						  choices, 4, FALSE, FALSE);
d1218 1
a1218 1
			again = (BOOL) (chosen == 2 && !has_colors());
d1233 3
a1235 3
			LYmove(L_Color, C_COLOR);
			LYclrtoeol();
			LYaddstr(choices[LYChosenShowColor]);
a1241 2
		    FREE(choices[0]);
		    FREE(choices[1]);
d1245 2
d1256 10
a1265 1
		    HANDLE_LYOPTIONS;
d1271 9
a1279 1
		LYShowCursor = LYChooseBoolean(LYShowCursor,
d1282 3
a1284 1
					      bool_choices);
d1288 15
a1302 1
	    case 'K':	/* Change keypad mode. */
d1304 1
a1304 1
		    keypad_mode = LYChooseBoolean(keypad_mode,
d1306 1
a1306 1
						 keypad_choices);
d1308 4
a1311 4
		    keypad_mode = LYChoosePopup(keypad_mode,
						L_Keypad, -1,
						keypad_choices,
						3, FALSE, FALSE);
d1313 3
a1315 3
		    LYmove(L_Keypad, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(keypad_choices[keypad_mode]);
d1323 3
d1328 10
a1337 1
		    HANDLE_LYOPTIONS;
d1341 2
a1342 1
	    case 'N':	/* Change line editor key bindings. */
d1344 1
a1344 1
		    current_lineedit = LYChooseBoolean(current_lineedit,
d1348 1
a1348 1
		    current_lineedit = LYChoosePopup(current_lineedit,
d1351 1
a1351 1
						    0, FALSE, FALSE);
d1353 3
a1355 3
		    LYmove(L_Lineed, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(LYLineeditNames[current_lineedit]);
d1360 10
a1369 1
		    HANDLE_LYOPTIONS;
d1374 2
a1375 1
	    case 'Y':	/* Change keyboard layout */
d1377 1
a1377 1
		    current_layout = LYChooseBoolean(current_layout,
d1381 1
a1381 1
		    current_layout = LYChoosePopup(current_layout,
d1384 1
a1384 1
						    0, FALSE, FALSE);
d1386 3
a1388 3
		    LYmove(L_Layout, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(LYKbLayoutNames[current_layout]);
d1393 10
a1402 1
		    HANDLE_LYOPTIONS;
d1408 12
a1419 1
	    case 'I':	/* Change local directory sorting. */
d1421 1
a1421 1
		    dir_list_style = LYChooseBoolean(dir_list_style,
d1423 1
a1423 1
						    dirList_choices);
d1425 1
a1425 1
		    dir_list_style = LYChoosePopup(dir_list_style,
d1427 2
a1428 2
						  dirList_choices,
						  3, FALSE, FALSE);
d1430 3
a1432 3
		    LYmove(L_Dired, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(dirList_choices[dir_list_style]);
d1435 3
d1440 10
a1449 1
		    HANDLE_LYOPTIONS;
d1454 12
a1465 1
	    case 'U':	/* Change user mode. */
d1467 10
a1476 10
		    user_mode = LYChooseBoolean(user_mode,
						L_User_Mode, -1,
						userMode_choices);
		    use_assume_charset = (BOOL) (user_mode >= 2);
		} else {
		    user_mode = LYChoosePopup(user_mode,
					      L_User_Mode, -1,
					      userMode_choices,
					      3, FALSE, FALSE);
		    use_assume_charset = (BOOL) (user_mode >= 2);
d1479 3
a1481 3
			LYmove(L_User_Mode, COL_OPTION_VALUES);
			LYclrtoeol();
			LYaddstr(userMode_choices[user_mode]);
d1485 3
d1495 12
a1506 1
		    HANDLE_LYOPTIONS;
d1511 8
d1520 1
a1520 1
		    verbose_img = LYChooseBoolean(verbose_img,
d1523 1
a1523 1
						bool_choices);
d1525 1
a1525 1
		    verbose_img = LYChoosePopup(verbose_img,
d1528 2
a1529 2
					     bool_choices,
					     2, FALSE, FALSE);
d1531 2
d1535 12
a1546 1
		    HANDLE_LYOPTIONS;
d1550 2
a1551 1
	    case 'A':	/* Change user agent string. */
d1554 1
a1554 1
			LYstrncpy(display_option, LYUserAgent, sizeof(display_option) - 1);
d1556 2
a1557 2
			LYmove(L_HOME, COL_OPTION_VALUES);
			LYaddstr("    ");
d1561 1
a1561 1
		    LYmove(L_User_Agent, COL_OPTION_VALUES);
d1566 1
a1566 1
		    LYmove(L_User_Agent, COL_OPTION_VALUES);
d1568 1
a1568 1
			LYaddstr((LYUserAgent &&
d1573 1
a1573 1
			LYaddstr((LYUserAgent &&
d1578 1
a1578 1
			LYaddstr(display_option);
d1580 1
a1580 1
		    LYclrtoeol();
d1584 4
a1587 2
		    } else if (!LYCheckUserAgent()) {
			_statusline(UA_PLEASE_USE_LYNX);
d1592 1
a1592 1
		    _statusline(UA_CHANGE_DISABLED);
d1597 3
a1599 2
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
	    case 'X':	/* Change local exec restriction. */
d1617 12
d1630 1
a1630 1
		    itmp = LYChooseBoolean(itmp,
d1632 1
a1632 1
					  exec_choices);
d1634 1
a1634 1
		    itmp = LYChoosePopup(itmp,
d1636 2
a1637 3
					exec_choices,
					0, (exec_frozen ? TRUE : FALSE),
					FALSE);
d1639 3
a1641 3
		    LYmove(L_Exec, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(exec_choices[itmp]);
d1644 5
d1669 10
a1678 1
		    HANDLE_LYOPTIONS;
d1681 1
a1681 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d1685 4
a1688 4
		    HTInfoMsg(SAVING_OPTIONS);
		    LYrcShowColor = LYChosenShowColor;
		    if (save_rc(NULL)) {
			HTInfoMsg(OPTIONS_SAVED);
d1693 1
a1693 1
		    HTInfoMsg(R_TO_RETURN_TO_LYNX);
d1702 2
a1703 1
	    case 'R':	/* Return to document (quit options menu). */
d1708 1
a1708 1
		    HTInfoMsg(SAVE_OR_R_TO_RETURN_TO_LYNX);
d1710 1
a1710 1
		    HTInfoMsg(R_TO_RETURN_TO_LYNX);
a1719 22
PRIVATE int widest_choice ARGS1(
	CONST char **,	choices)
{
    int n, width = 0;
    for (n = 0; choices[n] != NULL; ++n) {
	int len = strlen(choices[n]);
	if (width < len)
	    width = len;
    }
    return width;
}

PRIVATE void show_choice ARGS2(
	CONST char *,	choice,
	int,		width)
{
    int len = strlen(choice);
    LYaddstr(choice);
    while (len++ < width)
	LYaddch(' ');
}

d1721 2
a1722 1
 *  Take a status code, prompt the user for a new status, and return it.
d1728 1
a1728 1
	CONST char **,	choices)
a1734 1
    int width = widest_choice(choices);
d1752 1
a1752 1
    LYmove(line, col);
d1754 1
a1754 1
    show_choice(choices[cur_choice], width);
d1756 2
a1757 2
	LYmove(line, (col - 1));
    LYrefresh();
d1767 1
a1767 1
	LYmove(line, col);
d1769 1
a1769 1
	    response = LYgetch_single();
d1771 1
a1771 1
	if (term_options || LYCharIsINTERRUPT_NO_letter(response)) {
d1788 1
a1788 1
	    (cmd = LKC_TO_LAC(keymap,response)) != LYK_ACTIVATE) {
d1800 1
a1800 1
		    LYrefresh();
a1813 1
		case LYK_LPOS_PREV_LINK:
d1842 1
a1842 1
	    show_choice(choices[cur_choice], width);
d1844 2
a1845 2
		LYmove(line, (col - 1));
	    LYrefresh();
d1850 1
a1850 1
	    LYmove(line, col);
d1852 1
a1852 1
	    show_choice(choices[cur_choice], width);
d1861 1
a1861 1
	    return cur_choice;
d1881 1
a1881 1
	LYrefresh();
d1915 1
a1915 1
	LYclear();
d1917 1
a1917 1
	LYerase();
d1920 1
a1920 1
    LYclear();
d1922 1
a1922 1
    LYmove(0, 5);
d1926 1
a1926 1
	LYaddstr(ehead_buffer);
d1928 1
a1928 1
	LYaddstr(MULTIBOOKMARKS_EHEAD);
d1935 3
a1937 3
	    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)), 5);
	    LYaddch(UCH(LYindex2MBM(a)));
	    LYaddstr(" : ");
d1939 3
a1941 3
		LYaddstr(MBM_A_subdescript[a]);
	    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)), 35);
	    LYaddstr("| ");
d1943 1
a1943 1
		LYaddstr(MBM_A_subbookmark[a]);
d1948 3
a1950 3
	    LYmove(3 + a, 5);
	    LYaddch(UCH(LYindex2MBM(a)));
	    LYaddstr(" : ");
d1952 3
a1954 3
		LYaddstr(MBM_A_subdescript[a]);
	    LYmove(3 + a, 35);
	    LYaddstr("| ");
d1956 1
a1956 1
		LYaddstr(MBM_A_subbookmark[a]);
d1965 2
a1966 2
	LYmove((LYlines - 4), 0);
	LYaddstr("'");
d1968 1
a1968 1
	LYaddstr("[");
d1970 3
a1972 3
	LYaddstr("' ");
	LYaddstr(PREVIOUS);
	LYaddstr(", '");
d1974 1
a1974 1
	LYaddstr("]");
d1976 2
a1977 2
	LYaddstr("' ");
	LYaddstr(NEXT_SCREEN);
d1980 1
a1980 1
    LYmove((LYlines - 3), 0);
d1982 1
a1982 1
	LYaddstr("'");
d1984 1
a1984 1
	LYaddstr(">");
d1986 2
a1987 2
	LYaddstr("'");
	LYaddstr(TO_SAVE_SEGMENT);
d1989 2
a1990 2
    LYaddstr(OR_SEGMENT);
    LYaddstr("'");
d1992 1
a1992 1
    LYaddstr("^G");
d1994 2
a1995 2
    LYaddstr("'");
    LYaddstr(TO_RETURN_SEGMENT);
d1999 2
a2000 1
	   !LYCharIsINTERRUPT_NO_letter(response) && response != '>') {
d2002 1
a2002 1
	LYmove((LYlines - 2), 0);
d2004 1
a2004 1
	LYaddstr(MULTIBOOKMARKS_LETTER);
d2007 2
a2008 2
	LYrefresh();
	response = (def_response ? def_response : LYgetch_single());
d2014 2
a2015 1
	if (term_options || LYCharIsINTERRUPT_NO_letter(response) ||
d2024 3
a2026 3
		HTInfoMsg(SAVING_OPTIONS);
		if (save_rc(NULL))
		    HTInfoMsg(OPTIONS_SAVED);
d2030 1
a2030 1
		HTInfoMsg(R_TO_RETURN_TO_LYNX);
d2074 1
a2074 1
	    if (LYMBM2index(response) == a) {
d2092 1
a2092 1
			LYmove(
d2096 2
a2097 2
			LYmove((3 + a), 9);
		    LYstrncpy(MBM_tmp_line,
d2099 1
a2099 2
					       "" : MBM_A_subdescript[a]),
			      sizeof(MBM_tmp_line) - 1);
d2110 1
a2110 1
			LYmove(
d2114 3
a2116 3
			LYmove((3 + a), 5);
		    LYaddch(UCH(LYindex2MBM(a)));
		    LYaddstr(" : ");
d2118 3
a2120 3
			LYaddstr(MBM_A_subdescript[a]);
		    LYclrtoeol();
		    LYrefresh();
d2124 1
a2124 1
		    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)),
d2127 2
a2128 2
		    LYmove((3 + a), 35);
		LYaddstr("| ");
d2131 2
a2132 3
		LYstrncpy(MBM_tmp_line,
			  (!MBM_A_subbookmark[a] ? "" : MBM_A_subbookmark[a]),
			  sizeof(MBM_tmp_line) - 1);
d2145 1
a2145 1
			LYSleepAlert();
d2153 1
a2153 1
		    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current-1)),
d2156 2
a2157 2
		    LYmove((3 + a), 35);
		LYaddstr("| ");
d2159 4
a2162 4
		    LYaddstr(MBM_A_subbookmark[a]);
		LYclrtoeol();
		LYmove(LYlines-1, 0);
		LYclrtoeol();
d2172 42
a2213 1
#if !defined(NO_OPTION_MENU) || (defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES)))
a2218 3
 *
 *  Also used for mouse popups with ncurses; this is indicated
 *  by for_mouse.
d2220 1
a2220 1
PUBLIC int popup_choice ARGS7(
d2224 1
a2224 1
	CONST char **,	choices,
d2226 1
a2226 2
	int,		disabled,
	BOOLEAN,	for_mouse)
d2228 26
a2253 2
    if (column < 0)
	column = (COL_OPTION_VALUES - 1);
d2255 934
a3188 17
    term_options = FALSE;
    cur_choice = LYhandlePopupList(cur_choice,
				   line,
				   column,
				   (CONST char **)choices,
				   -1,
				   i_length,
				   disabled,
				   for_mouse,
				   TRUE);
    switch (cur_choice) {
    case LYK_QUIT:
    case LYK_ABORT:
    case LYK_PREV_DOC:
	term_options = TRUE;
	if (!for_mouse) {
	    HTUserMsg(CANCELLED);
a3189 1
	break;
d3191 6
d3200 2
a3201 1
    } else if (!for_mouse) {
d3203 1
a3204 1
    return(cur_choice);
d3208 1
d3249 1
a3249 1
static char * cookies_string		= "set_cookies";
d3254 1
a3254 1
static char * editor_string		= "file_editor";
d3257 1
a3257 1
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
d3269 1
a3269 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
d3278 1
a3278 1
	{ LINKS_AND_FIELDS_ARE_NUMBERED,
d3282 3
a3284 3
static char * lineedit_mode_string	= "lineedit_mode";
static char * mail_address_string	= "personal_mail_address";
static char * search_type_string	= "case_sensitive_searching";
a3304 1

a3306 11
static char * visited_links_string	= "visited_links";
static OptValues visited_links_values[] = {
	{ VISITED_LINKS_AS_FIRST_V, "By First Visit",	"first_visited" },
	{ VISITED_LINKS_AS_FIRST_V | VISITED_LINKS_REVERSE,
		    "By First Visit Reversed",	"first_visited_reversed" },
	{ VISITED_LINKS_AS_TREE,    "As Visit Tree",	"visit_tree" },
	{ VISITED_LINKS_AS_LATEST,  "By Last Visit",	"last_visited" },
	{ VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE,
		    "By Last Visit Reversed",	"last_visited_reversed" },
	{ 0, 0, 0 }};

d3310 1
a3310 2
#ifndef SH_EX	/* 1999/01/19 (Tue) */
static char * DTD_recovery_string      = "DTD_recovery";
a3315 2
#endif

d3331 4
a3334 7
static char * mbm_string		= "multi_bookmark";
static OptValues mbm_values[] = {
	{ MBM_OFF,		"OFF",			"OFF" },
	{ MBM_STANDARD,		"STANDARD",		"STANDARD" },
	{ MBM_ADVANCED,		"ADVANCED",		"ADVANCED" },
	{ 0, 0, 0 }};

d3341 1
a3341 1
static char * display_char_set_string	= "character_set";
a3347 1

d3349 1
a3349 1
static char * dired_sort_string		= "dir_list_style";
d3356 1
a3356 2

static char * ftp_sort_string		= "file_sorting_method";
a3363 11
static char * show_rate_string		= "show_rate";
static OptValues rate_values[] = {
	{ rateOFF,		"Do not show rate",	"rate_off" },
	{ rateBYTES,		"Show Bytes/sec rate",	"rate_bytes" },
	{ rateKB,		"Show KB/sec rate",	"rate_kb" },
#ifdef EXP_READPROGRESS
	{ rateEtaBYTES,		"Show Bytes/sec, ETA",	"rate_eta_bytes" },
	{ rateEtaKB,		"Show KB/sec, ETA",	"rate_eta_kb" },
#endif
	{ 0, 0, 0 }};

d3367 2
a3368 2
static char * preferred_doc_char_string = "preferred_charset";
static char * preferred_doc_lang_string = "preferred_language";
d3371 3
d3377 1
a3377 1
		(int) Size, Name, Value, disable_all?disabled_string:disable)
d3383 1
a3383 1
	fprintf(fp,"<select name=\"%s\" %s>\n", text, disable_all?disabled_string:"")
d3386 1
a3386 1
	fprintf(fp,"<select name=\"%s\" %s>\n", text, disable_all?disabled_string:DISABLED(flag))
d3397 4
a3400 6
	if (table->HtmlName) {
	    PutOption(fp,
		      value == table->value,
		      table->HtmlName,
		      table->LongName);
	}
d3411 1
a3411 1
	if (table->HtmlName && !strcmp(value, table->HtmlName)) {
d3440 1
a3440 3
    CTRACE((tfp, "break_data %s\n", data));

    q = typecalloc(PostPair);
d3474 1
a3474 1
		    && isalnum(UCH(q[count].value[i+2]))) {
d3479 1
a3485 1
	CTRACE((tfp, "...item[%d] tag=%s, value=%s\n", count, q[count].tag, q[count].value));
a3500 1

d3557 1
a3557 6
	if (no_bookmark) {
	   HTAlert(BOOKMARK_CHANGE_DISALLOWED); /* anonymous */
	   return(NULLFILE);
	} else if (dump_output_immediately) {
	    return(NOT_FOUND);
	} else {
d3559 3
a3561 2
	   return(NULLFILE);
	}
a3563 1
    data = break_data(newdoc->post_data);
d3565 8
a3572 12
    if (!data) {
	int status;

	/*-------------------------------------------------
	 * kludge gen_options() call:
	 *--------------------------------------------------*/
	status = gen_options(&newdoc->address);
	if (status != NORMAL) {
	    HTAlwaysAlert("Unexpected way of accessing", newdoc->address);
	    FREE(newdoc->address);
	    return(status);
	}
d3574 1
a3574 1
	/* exit to getfile() cycle */
a3583 4
	LYRegisterUIPage(newdoc->address, UIP_OPTIONS_MENU);
#ifdef DIRED_SUPPORT
	lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
d3587 2
a3588 13
    if (!LYIsUIPage3(HTLoadedDocumentURL(), UIP_OPTIONS_MENU, 0) &&
	!LYIsUIPage3(HTLoadedDocumentURL(), UIP_VLINKS, 0)) {
	char *buf = NULL;

	/*  We may have been spoofed? */
	HTSprintf0(&buf,
		   gettext("Use %s to invoke the Options menu!"),
		   key_for_func_ext(LYK_OPTIONS, FOR_PANEL));
	HTAlert(buf);
	FREE(buf);
	FREE(data);
	return(NOT_FOUND);
    }
d3592 1
a3592 4
	 *  This isn't really for security, but rather for avoiding that
	 *  the user may revisit an older instance from the history stack
	 *  and submit stuff which accidentally undoes changes that had
	 *  been done from a newer instance. - kw
a3595 2
		char *buf = NULL;

d3597 1
a3597 2
		 * We probably came from an older instance of the Options
		 * page that had been on the history stack. - kw
a3598 4
		HTSprintf0(&buf,
			   gettext("Use %s to invoke the Options menu!"),
			   key_for_func_ext(LYK_OPTIONS, FOR_PANEL));
		HTAlert(buf);
a3625 2
	    validate_x_display();
	    summarize_x_display(data[i].value);
d3637 1
a3637 1
	    if ((emacs_keys = (BOOL) code) != FALSE) {
d3645 1
a3645 1
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
d3653 1
a3653 1
#endif /* ENABLE_OPTS_CHANGE_EXEC */
a3661 5
		if (keypad_mode == NUMBERS_AS_ARROWS) {
		    set_numbers_as_arrows();
		} else {
		    reset_numbers_as_arrows();
		}
d3666 1
a3666 1
	if (!strcmp(data[i].tag, lineedit_mode_string)) {
d3671 1
a3671 1
		if (j==newval)	current_lineedit = newval;
d3682 1
a3682 1
		if (j==newval)	current_layout = newval;
d3696 1
a3696 1
	    case_sensitive = (BOOL) code;
a3698 1
#ifndef SH_EX	/* 1999/01/19 (Tue) */
a3707 1
#endif
d3712 1
a3712 1
	    LYSelectPopups = (BOOL) code;
d3718 2
a3719 4
	 && GetOptValues(show_color_values, data[i].value,
			 &LYChosenShowColor)) {
	    if (can_do_colors)
		LYShowColor = LYChosenShowColor;
d3733 1
a3733 1
	    LYShowCursor = (BOOL) code;
a3745 4
	/* Type of visited pages page: SELECT */
	if (!strcmp(data[i].tag, visited_links_string))
	   GetOptValues(visited_links_values, data[i].value, &Visited_Links_As);

d3750 2
a3751 2
		pseudo_inline_alts = FALSE;
		clickable_images = FALSE;
d3755 2
a3756 2
		pseudo_inline_alts = TRUE;
		clickable_images = FALSE;
d3769 1
a3769 1
		verbose_img = (BOOL) code;
d3777 1
a3777 1
	    if ((vi_keys = (BOOL) code) != FALSE) {
d3786 9
a3794 1
	    GetOptValues(mbm_values, data[i].value, &LYMultiBookmarks);
d3835 1
a3835 1
	    LYRawMode = (BOOL) code;
d3855 1
a3855 7
	    show_dotfiles = (BOOL) code;
	}

	/* Show Transfer Rate: enumerated value */
	if (!strcmp(data[i].tag, show_rate_string)
	 && GetOptValues(rate_values, data[i].value, &code)) {
	    LYTransferRate = code;
d3886 4
a3889 2
		if (!LYCheckUserAgent()) {
		    HTAlert(UA_PLEASE_USE_LYNX);
d3904 19
a3922 25
	if (display_char_set_old != current_char_set) {
	    /*
	     *  Set the LYUseDefaultRawMode value and character
	     *  handling if LYRawMode was changed. - FM
	     */
	    LYUseDefaultRawMode = TRUE;
	    HTMLUseCharacterSet(current_char_set);
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Deduce whether the user wants autoswitch: */
	    switch_display_charsets =
		 (current_char_set == auto_display_charset
		  || current_char_set == auto_other_display_charset);
#endif
	}
	if (assume_char_set_changed && HTCJK != JAPANESE) {
	    LYRawMode = (BOOL) (UCLYhndl_for_unspec == current_char_set);
	}
	if (raw_mode_old != LYRawMode || assume_char_set_changed) {
	    /*
	     *  Set the raw 8-bit or CJK mode defaults and
	     *  character set if changed. - FM
	     */
	    HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
	    HTMLSetCharacterHandling(current_char_set);
	}
d3933 3
a3935 4
	HTInfoMsg(SAVING_OPTIONS);
	LYrcShowColor = LYChosenShowColor;
	if (save_rc(NULL)) {
	    HTInfoMsg(OPTIONS_SAVED);
d3945 5
a3949 5
    CTRACE((tfp, "\nLYOptions.c/postoptions(): exiting...\n"));
    CTRACE((tfp, "                            need_reload = %s\n",
		    need_reload ? "TRUE" : "FALSE"));
    CTRACE((tfp, "                            need_end_reload = %s\n",
		    need_end_reload ? "TRUE" : "FALSE"));
d3997 1
a3997 1
	return(NOT_FOUND);
d4029 1
a4029 1
	CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
d4038 8
a4045 1
	    srcmode_for_next_retrieval(1);
d4050 2
a4051 4
	    if (HTcan_reparse_document()) {
		if (!HTreparse_document())
		    srcmode_for_next_retrieval(0);
		CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
a4055 9
	if (newdoc->post_data != NULL && !newdoc->safe &&
	    confirm_post_resub(newdoc->address, newdoc->title, 2, 1) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    if (HTisDocumentSource()) {
		srcmode_for_next_retrieval(0);
	    }
	    return(NORMAL);
	}

d4060 1
a4060 1
	CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
d4071 1
a4071 6
#if defined(RAND_MAX)
	long key = lynx_rand();
#else
	long key = (long)secure_value + (long)time(0);
#endif
	sprintf(secure_value, "%ld", key);
d4078 1
a4078 70
 * Note: the 'value' we are passing here is a local copy of the "same" string
 * as is used in LYrcFile.c to index the savable options.
 */
PRIVATE void PutLabel ARGS3(
	FILE *,		fp,
	char *,		name,
	char *,		value)
{
    if (will_save_rc(value) && !no_option_save) {
	fprintf(fp, "  %-33s: ", name);
    } else {
	int l = strlen(name);
	fprintf(fp, "  %s", name);
	fprintf(fp, "%s%-*s: ",
		(l < 30) ? " " : "",
		(l < 30) ? 32 - l : 3, "(!)");
    }
}

/*
 * For given a list of the .lynxrc names for boolean flags that make up a
 * composite setting, check if any are not writable for the .lynxrc file.  If
 * so, return that name, so the subsequence will_save_rc() check in PutLabel()
 * will flag the composite as not-saved.
 */
PRIVATE char *check_if_write_lynxrc ARGS1(char **, table)
{
    int n;
    char *result = NULL;

    for (n = 0; table[n] != 0; ++n) {
	result = table[n];
	if (!will_save_rc(result))
	    break;
    }
    return result;
}

/*
 * The options menu treats "Cookies" as a single enumeration, but it is read
 * from lynx.cfg (and perhaps .lynxrc) as a set of booleans.  Check if any are
 * not writable to .lynxrc, so we can show the user. 
 */
PRIVATE char *will_save_cookies NOARGS
{
    static char *table[] = {
	"set_cookies",			/* LYSetCookies */
	"accept_all_cookies",		/* LYAcceptAllCookies */
	NULL
    };
    return check_if_write_lynxrc(table);
}

/*
 * The options menu treats "Show images" as a single enumeration, but it is
 * read from lynx.cfg (and perhaps .lynxrc) as a set of booleans.  Check if any
 * are not writable to .lynxrc, so we can show the user. 
 */
PRIVATE char *will_save_images NOARGS
{
    static char *table[] = {
	"make_pseudo_alts_for_inlines",	/* pseudo_inline_alts */
	"make_links_for_all_images",	/* clickable_images */
	NULL
    };
    return check_if_write_lynxrc(table);
}

/*
 * Okay, someone wants to change options.  So, let's gen up a form for them
d4092 4
a4095 2
    static char tempfile[LY_MAXPATH] = "\0";
    BOOLEAN disable_all = FALSE;
d4098 1
a4098 1
    size_t text_len = LYscreenWidth() > 45 ? LYscreenWidth() - 38 : 7;	/* cf: PutLabel */
d4100 2
a4101 6
    if (LYReuseTempfiles) {
	fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
    } else {
	LYRemoveTemp(tempfile);
	fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
    }
a4108 12
    /* This should not be needed if we regenerate the temp file every
       time with a new name, which just happened above in the case
       LYReuseTempfiles==FALSE.  Even for LYReuseTempfiles=TRUE, code
       at the end of postoptions() may remove an older cached version
       from memory if that version of the page was left by submitting
       changes. (But that code doesn't do that - HTuncache_current_document
       is currently commented out.) - kw 1999-11-27
       If access to the actual file via getfile() later fails
       (maybe because of some restrictions), mainloop may leave
       this flag on after popping the previous doc which is then
       unnecessarily reloaded.  But I changed mainloop to reset
       the flag. - kw 1999-05-24 */
a4110 9
    /*
     * Without LYUseFormsOptions set we should maybe not even get here.
     * However, it's possible we do; disable the form in that case. - kw
     */
#ifndef NO_OPTION_MENU
    if (!LYUseFormsOptions)
	disable_all = TRUE;
#endif

d4116 1
a4116 1
    fprintf(fp0, "<form action=\"LYNXOPTIONS:\" method=\"post\">\n");
d4122 2
a4123 2
    fprintf(fp0, "<input name=\"%s\" type=\"hidden\" value=\"%s\">\n",
		 secure_string, NewSecureValue());
d4131 3
a4133 5
    if (!disable_all) {
	fprintf(fp0,"<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0,"<input type=\"reset\" value=\"%s\">\n", RESET_CHANGES);
	fprintf(fp0,"%s\n", CANCEL_CHANGES);
    }
d4139 3
a4141 6
	if (!disable_all) {
	    fprintf(fp0, "<p align=center>%s: ", SAVE_OPTIONS);
	    fprintf(fp0, "<input type=\"checkbox\" name=\"%s\">\n",
			 save_options_string);
	}
	fprintf(fp0, "<br>(options marked with (!) will not be saved)\n");
d4148 1
a4148 20

    fprintf(fp0,"\n  <em>%s</em>\n", gettext("General Preferences"));
    /*****************************************************************/

    /* User Mode: SELECT */
    PutLabel(fp0, gettext("User mode"), user_mode_string);
    BeginSelect(fp0, user_mode_string);
    PutOptValues(fp0, user_mode, user_mode_values);
    EndSelect(fp0);

    /* Editor: INPUT */
    PutLabel(fp0, gettext("Editor"), editor_string);
    PutTextInput(fp0, editor_string, NOTEMPTY(editor), text_len,
		      DISABLED(no_editor || system_editor));

    /* Search Type: SELECT */
    PutLabel(fp0, gettext("Type of Search"), search_type_string);
    BeginSelect(fp0, search_type_string);
    PutOptValues(fp0, case_sensitive, search_type_values);
    EndSelect(fp0);
d4151 1
a4151 1
    PutLabel(fp0, gettext("Cookies"), will_save_cookies());
d4154 2
a4155 2
		   cookies_ignore_all_string,
		   cookies_ignore_all_string);
d4157 2
a4158 2
		   cookies_up_to_user_string,
		   cookies_up_to_user_string);
d4160 2
a4161 2
		   cookies_accept_all_string,
		   cookies_accept_all_string);
d4164 4
a4167 9

    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Keyboard Input"));
    /*****************************************************************/

    /* Keypad Mode: SELECT */
    PutLabel(fp0, gettext("Keypad mode"), keypad_mode_string);
    BeginSelect(fp0, keypad_mode_string);
    PutOptValues(fp0, keypad_mode, keypad_mode_values);
    EndSelect(fp0);
d4170 1
a4170 1
    PutLabel(fp0, gettext("Emacs keys"), emacs_keys_string);
d4175 4
a4178 4
    /* VI Keys: ON/OFF */
    PutLabel(fp0, gettext("VI keys"), vi_keys_string);
    BeginSelect(fp0, vi_keys_string);
    PutOptValues(fp0, vi_keys, bool_values);
d4183 2
a4184 2
	PutLabel(fp0, gettext("Line edit style"), lineedit_mode_string);
	BeginSelect(fp0, lineedit_mode_string);
d4195 1
a4195 1
    PutLabel(fp0, gettext("Keyboard layout"), kblayout_string);
d4200 1
a4200 1
	PutOption(fp0, i == current_layout, temp, LYKbLayoutNames[i]);
d4205 72
a4276 5
    /*
     * Display and Character Set
     */
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Display and Character Set"));
    /*****************************************************************/
d4279 1
a4279 1
    PutLabel(fp0, gettext("Display character set"), display_char_set_string);
d4285 1
a4285 1
	    cset_len = len;
a4286 3
#ifdef EXP_CHARSET_CHOICE
	if (!charset_subsets[i].hide_display)
#endif
d4291 9
d4301 1
d4312 1
a4312 1
		/* ok, LYRawMode, so use UCAssume_MIMEcharset */
d4315 1
a4315 1
	PutLabel(fp0, gettext("Assumed document character set"), assume_char_set_string);
d4318 3
a4320 6
#ifdef EXP_CHARSET_CHOICE
	    if (!charset_subsets[i].hide_assumed)
#endif
	    PutOption(fp0, i == curval,
			   LYCharSet_UC[i].MIMEname,
			   LYCharSet_UC[i].MIMEname);
d4326 1
a4326 1
    if (LYHaveCJKCharacterSet) {
d4332 3
a4334 4
	PutLabel(fp0, gettext("CJK mode"), raw_mode_string);
    } else {
	PutLabel(fp0, gettext("Raw 8-bit"), raw_mode_string);
    }
d4340 4
a4343 40
    /* X Display: INPUT */
    PutLabel(fp0, gettext("X Display"),	x_display_string);
    PutTextInput(fp0, x_display_string, NOTEMPTY(x_display), text_len, "");

    /*
     * Document Appearance
     */
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Document Appearance"));
    /*****************************************************************/

    /* Show Color: SELECT */
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    SetupChosenShowColor();
    PutLabel(fp0, gettext("Show color"), show_color_string);
    if (no_option_save) {
	MaybeSelect(fp0, !can_do_colors, show_color_string);
	if (LYShowColor == SHOW_COLOR_NEVER) {
	   LYShowColor = SHOW_COLOR_OFF;
	} else if (LYShowColor == SHOW_COLOR_ALWAYS) {
	   LYShowColor = SHOW_COLOR_ON;
	}
	PutOptValues(fp0, LYShowColor - SHOW_COLOR_OFF, bool_values);
    } else {
	BeginSelect(fp0, show_color_string);
	if (can_do_colors) {
	   show_color_values[2].HtmlName = on_string;
	   show_color_values[3].LongName = always_string;
	} else {
	   show_color_values[2].HtmlName = NULL; /* suppress "ON" - kw */
	   show_color_values[3].LongName = "Always try";
	}
	PutOptValues(fp0, LYChosenShowColor, show_color_values);
    }
    EndSelect(fp0);
#endif /* USE_SLANG || COLOR_CURSES */

    /* Show cursor: ON/OFF */
    PutLabel(fp0, gettext("Show cursor"), show_cursor_string);
    BeginSelect(fp0, show_cursor_string);
    PutOptValues(fp0, LYShowCursor, bool_values);
d4347 1
a4347 1
    PutLabel(fp0, gettext("Popups for select fields"), select_popups_string);
a4351 8
#ifndef SH_EX  /* 1999/01/19 (Tue) */
    /* HTML error recovery: SELECT */
    PutLabel(fp0, gettext("HTML error recovery"), DTD_recovery_string);
    BeginSelect(fp0, DTD_recovery_string);
    PutOptValues(fp0, Old_DTD, DTD_type_values);
    EndSelect(fp0);
#endif

d4353 1
a4353 1
    PutLabel(fp0, gettext("Show images"), will_save_images());
d4356 2
a4357 2
		   images_ignore_all_string,
		   images_ignore_all_string);
d4359 2
a4360 2
		   images_use_label_string,
		   images_use_label_string);
d4362 2
a4363 2
		   images_use_links_string,
		   images_use_links_string);
d4367 1
a4367 1
    PutLabel(fp0, gettext("Verbose images"), verbose_images_string);
d4373 1
a4373 1
     * Headers Transferred to Remote Servers
d4375 1
a4375 2
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Headers Transferred to Remote Servers"));
    /*****************************************************************/
d4377 15
a4391 4
    /* Mail Address: INPUT */
    PutLabel(fp0, gettext("Personal mail address"), mail_address_string);
    PutTextInput(fp0, mail_address_string,
		      NOTEMPTY(personal_mail_address), text_len, "");
d4393 2
a4394 4
    /* Preferred Document Character Set: INPUT */
    PutLabel(fp0, gettext("Preferred document character set"), preferred_doc_char_string);
    PutTextInput(fp0, preferred_doc_char_string,
		      NOTEMPTY(pref_charset), cset_len+2, "");
d4396 3
a4398 4
    /* Preferred Document Language: INPUT */
    PutLabel(fp0, gettext("Preferred document language"), preferred_doc_lang_string);
    PutTextInput(fp0, preferred_doc_lang_string,
		      NOTEMPTY(language), cset_len+2, "");
d4400 4
a4403 5
    /* User Agent: INPUT */
    if (!no_useragent) {
	PutLabel(fp0, gettext("User-Agent header"), user_agent_string);
	PutTextInput(fp0, user_agent_string,
			  NOTEMPTY(LYUserAgent), text_len, "");
d4407 1
a4407 1
     * Listing and Accessing Files
d4409 1
a4409 2
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Listing and Accessing Files"));
    /*****************************************************************/
d4412 1
a4412 1
    PutLabel(fp0, gettext("FTP sort criteria"),	ftp_sort_string);
d4419 1
a4419 1
    PutLabel(fp0, gettext("Local directory sort criteria"), dired_sort_string);
d4427 1
a4427 1
	PutLabel(fp0, gettext("Show dot files"), show_dotfiles_string);
d4434 2
a4435 2
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    PutLabel(fp0, gettext("Execution links"), exec_links_string);
d4443 1
a4443 1
		      exec_links_values);
d4448 1
a4448 1
		      exec_links_values);
d4451 1
a4451 9
#endif /* ENABLE_OPTS_CHANGE_EXEC */

#ifdef EXP_READPROGRESS
    /* Local Directory Sort: SELECT */
    PutLabel(fp0, gettext("Show transfer rate"), show_rate_string);
    BeginSelect(fp0, show_rate_string);
    PutOptValues(fp0, LYTransferRate, rate_values);
    EndSelect(fp0);
#endif /* EXP_READPROGRESS */
d4454 1
a4454 1
     * Special Files and Screens
d4456 6
a4461 2
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Special Files and Screens"));
    /*****************************************************************/
d4463 4
a4466 7
    /* Multi-Bookmark Mode: SELECT */
    if (!LYMBMBlocked) {
	PutLabel(fp0, gettext("Multi-bookmarks"), mbm_string);
	BeginSelect(fp0, mbm_string);
	PutOptValues(fp0, LYMultiBookmarks, mbm_values);
	EndSelect(fp0);
    }
d4468 5
a4472 9
    /* Bookmarks File Menu: LINK/INPUT */
    if (LYMultiBookmarks) {
	PutLabel(fp0, gettext("Review/edit Bookmarks files"), mbm_string);
	fprintf(fp0, "<a href=\"LYNXOPTIONS://MBM_MENU\">%s</a>\n",
		    gettext("Goto multi-bookmark menu"));
    } else {
	PutLabel(fp0, gettext("Bookmarks file"), single_bookmark_string);
	PutTextInput(fp0, single_bookmark_string,
			 NOTEMPTY(bookmark_page), text_len, "");
d4475 3
a4477 8
    /* Visited Pages: SELECT */
    PutLabel(fp0, gettext("Visited Pages"), visited_links_string);
    BeginSelect(fp0, visited_links_string);
    PutOptValues(fp0, Visited_Links_As, visited_links_values);
    EndSelect(fp0);

    if (!no_lynxcfg_info) {
	fprintf(fp0, "\n  Check your <a href=\"LYNXCFG:\">lynx.cfg</a> here\n");
d4483 4
a4486 6
    if (!disable_all) {
	fprintf(fp0,"<p align=center>\n");
	fprintf(fp0,"<input type=\"submit\" value=\"%s\">\n - ", ACCEPT_CHANGES);
	fprintf(fp0,"<input type=\"reset\" value=\"%s\">\n", RESET_CHANGES);
	fprintf(fp0,"%s\n", CANCEL_CHANGES);
    }
@

