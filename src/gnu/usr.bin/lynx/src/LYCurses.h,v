head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.6
	tg-mergefixes-1-branch:1.1.3.6.0.4
	tg-mergefixes-1-base:1.1.3.6
	MIROS_X:1.1.3.6.0.2
	MIROS_X_BASE:1.1.3.6
	MIRBSD_XP_MIRPPC:1.1.3.5.0.4
	lynx-2_8_6dev_7b:1.1.3.6
	lynx-2_8_6dev_6:1.1.3.6
	MIRBSD_XP_SPARC_BASE:1.1.3.5
	MIRBSD_XP_SPARC:1.1.3.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2005.01.03.00.45.56;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.56.12;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.33;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.31;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.22;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.44;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.14;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.39;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.02.08.13.10.03;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.15.51;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.51.42;	author tg;	state Stab;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.11.20.16.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@soft merge
@
text
@#ifndef LYCURSES_H
#define LYCURSES_H

#ifndef HTUTILS_H
#include <HTUtils.h>
#endif

/*
 * Because we have to configure PDCURSES last, we may get bogus definitions
 * from the system curses library - cancel these now.
 */
#ifdef HAVE_XCURSES

#undef ASSUME_DEFAULT_COLORS
#undef COLOR_CURSES
#undef FANCY_CURSES
#undef HAVE_CBREAK
#undef HAVE_RESIZETERM
#undef HAVE_USE_DEFAULT_COLORS
#undef NCURSES
#undef USE_DEFAULT_COLORS

#define HAVE_CBREAK 1
#define COLOR_CURSES 1
#define FANCY_CURSES 1

#endif

/*
 * The simple color scheme maps the 8 combinations of bold/underline/reverse
 * to the standard 8 ANSI colors (with some variations based on context).
 */
#undef USE_COLOR_TABLE

#ifndef USE_COLOR_STYLE
#if defined(USE_SLANG) || defined(COLOR_CURSES)
#define USE_COLOR_TABLE 1
#endif
#endif

#ifdef TRUE
#undef TRUE			/* to prevent parse error :( */
#endif /* TRUE */
#ifdef FALSE
#undef FALSE			/* to prevent parse error :( */
#endif /* FALSE */

#ifdef USE_SLANG
#include <slang.h>

#undef WINDOW
typedef struct {
    int top_y;
    int left_x;
    int height;
    int width;
} WINDOW;

/* slang doesn't really do windows... */
#define waddch(w,c)  LYaddch(c)
#define waddstr(w,s) addstr(s)
#define wmove(win, row, col) SLsmg_gotorc(((win)?(win)->top_y:0) + (row), ((win)?(win)->left_x:0) + (col))

#ifndef SLSMG_UARROW_CHAR
#define SLSMG_UARROW_CHAR '^'
#endif

#ifndef SLSMG_DARROW_CHAR
#define SLSMG_DARROW_CHAR 'v'
#endif

#ifndef SLSMG_LARROW_CHAR
#define SLSMG_LARROW_CHAR '<'
#endif

#ifndef SLSMG_RARROW_CHAR
#define SLSMG_RARROW_CHAR '>'
#endif

#ifndef SLSMG_CKBRD_CHAR
#define SLSMG_CKBRD_CHAR '#'
#endif

#ifndef SLSMG_BLOCK_CHAR
#define SLSMG_BLOCK_CHAR '#'
#endif

#ifndef ACS_UARROW
#define ACS_UARROW  SLSMG_UARROW_CHAR
#endif

#ifndef ACS_DARROW
#define ACS_DARROW  SLSMG_DARROW_CHAR
#endif

#ifndef ACS_LARROW
#define ACS_LARROW  SLSMG_LARROW_CHAR
#endif

#ifndef ACS_RARROW
#define ACS_RARROW  SLSMG_RARROW_CHAR
#endif

#ifndef ACS_CKBOARD
#define ACS_CKBOARD SLSMG_CKBRD_CHAR
#endif

#ifndef ACS_BLOCK
#define ACS_BLOCK   SLSMG_BLOCK_CHAR
#endif

#else /* Using curses: */

#ifdef VMS
#define FANCY_CURSES
#endif /* VMS */

/*
 *	CR may be defined before the curses.h include occurs.
 *	There is a conflict between the termcap char *CR and the define.
 *	Assuming that the definition of CR will always be carriage return.
 *	06-09-94 Lynx 2-3-1 Garrett Arch Blythe
 */
#ifdef CR
#undef CR			/* to prevent parse error :( */
#define REDEFINE_CR
#endif /* CR */

#ifdef HZ
#undef HZ			/* to prevent parse error :( */
#endif /* HZ */

/* SunOS 4.x has a redefinition between ioctl.h and termios.h */
#if defined(sun) && !defined(__SVR4)
#undef NL0
#undef NL1
#undef CR0
#undef CR1
#undef CR2
#undef CR3
#undef TAB0
#undef TAB1
#undef TAB2
#undef XTABS
#undef BS0
#undef BS1
#undef FF0
#undef FF1
#undef ECHO
#undef NOFLSH
#undef TOSTOP
#undef FLUSHO
#undef PENDIN
#endif

#if defined(_MSC_VER)
#undef MOUSE_MOVED		/* conflict between PDCURSES and _WIN32 */
#endif /* _MSC_VER */

/*
 * Do this to build with glibc 2.1.3 (apparently it was not used to build a
 * system before release).
 */
#include <signal.h>

#undef CS			/* some BSD versions of curses use this */
#define CS curses_CS		/* ...but we don't */

#ifdef ERR
#undef ERR			/* all versions of curses define this */
#endif

#ifdef MOUSE_MOVED
#undef MOUSE_MOVED		/* wincon.h or MINGW32's copy of it */
#endif

#ifdef HAVE_CONFIG_H
# ifdef HAVE_NCURSESW_NCURSES_H
#  undef GCC_PRINTFLIKE		/* <libutf8.h> may define 'printf' */
#  include <ncursesw/ncurses.h>
#  undef printf			/* but we don't want that... */
# else
#  ifdef HAVE_NCURSES_NCURSES_H
#   include <ncurses/ncurses.h>
#  else
#   ifdef HAVE_NCURSES_H
#    include <ncurses.h>
#   else
#    ifdef HAVE_CURSESX_H
#     include <cursesX.h>	/* Ultrix */
#    else
#     ifdef HAVE_JCURSES_H
#      include <jcurses.h>	/* sony_news */
#     else
#      ifdef HAVE_XCURSES
#       include <xcurses.h>	/* PDCurses' UNIX port */
#      else
#       include <curses.h>	/* default */
#      endif
#     endif
#    endif
#   endif
#  endif
# endif

# if defined(wgetbkgd) && !defined(getbkgd)
#  define getbkgd(w) wgetbkgd(w)	/* workaround pre-1.9.9g bug */
# endif

# ifdef FANCY_CURSES
#  if defined(NCURSES) && defined(HAVE_NCURSESW_TERM_H)
#    include <ncursesw/term.h>
#  else
#    if defined(NCURSES) && defined(HAVE_NCURSES_TERM_H)
#      include <ncurses/term.h>
#    else
#     if defined(HAVE_NCURSESW_NCURSES_H) || defined(HAVE_NCURSES_NCURSES_H) || defined(HAVE_XCURSES)
#       undef HAVE_TERM_H	/* only use one in comparable path! */
#     endif
#     if defined(HAVE_TERM_H)
#      include <term.h>
#     endif
#   endif
#  endif
# endif

# if defined(NCURSES_VERSION) && defined(HAVE_DEFINE_KEY)
#  define USE_KEYMAPS		1
# endif

#else
# if defined(VMS) && defined(__GNUC__)
#  include <LYGCurses.h>
#  else
#   include <curses.h>		/* everything else */
# endif				/* VMS && __GNUC__ */
#endif /* HAVE_CONFIG_H */

/*
 * PDCurses' mouse code does nothing in the DJGPP configuration.
 */
#if defined(PDCURSES) && !defined(__DJGPP__) && !defined(HAVE_XCURSES)
#define USE_MOUSE 1
#endif

/*
 * Pick up the native ncurses name:
 */
#if defined(NCURSES_MOUSE_VERSION)
#define USE_MOUSE 1
#endif

/*
 * If we have pads, use them to implement left/right scrolling.
 */
#if defined(HAVE_NEWPAD) && defined(HAVE_PNOUTREFRESH) && !defined(PDCURSES)
#define USE_CURSES_PADS 1
#endif

/*
 * ncurses 1.9.9e won't work for pads, but 4.2 does (1.9.9g doesn't have a
 * convenient ifdef, though it would work).
 */
#if defined(NCURSES_VERSION) && !defined(NCURSES_VERSION_MAJOR)
#undef USE_CURSES_PADS
#endif

/*
 * Most implementations of curses treat pair 0 specially, as the default
 * foreground and background color.  Also, the COLORS variable corresponds to
 * the total number of colors.
 *
 * PDCurses does not follow these rules.  Its COLORS variable claims it has
 * 8 colors, but it actually implements 16.  That makes it hard to optimize
 * color settings against color pair 0 in a portable fashion.
 */
#if defined(COLOR_CURSES)
#if defined(PDCURSES) || defined(HAVE_XCURSES)
#define COLORS 16		/* should be a variable... */
#else
#define USE_CURSES_PAIR_0
#endif
#endif

#endif /* USE_SLANG */

#ifdef __cplusplus
extern "C" {
#endif
#ifdef USE_SLANG
#define LYstopPopup()		/* nothing */
#define LYtopwindow() LYwin
#else
    extern void LYsubwindow(WINDOW * param);
    extern WINDOW *LYtopwindow(void);

#define LYstopPopup() LYsubwindow(0)
#endif				/* NCURSES */

    extern void LYbox(WINDOW * win, BOOLEAN formfield);
    extern WINDOW *LYstartPopup(int *top_y, int *left_x, int *height, int *width);

/*
 * Useful macros not in PDCurses or very old ncurses headers.
 */
#if !defined(HAVE_GETBEGX) && !defined(getbegx)
#define getbegx(win) ((win)->_begx)
#endif
#if !defined(HAVE_GETBEGY) && !defined(getbegy)
#define getbegy(win) ((win)->_begy)
#endif
#if !defined(HAVE_GETBKGD) && !defined(getbkgd)
#define getbkgd(win) ((win)->_bkgd)
#endif

#if defined(HAVE_WATTR_GET)
    extern long LYgetattrs(WINDOW * win);

#else
#if defined(HAVE_GETATTRS) || defined(getattrs)
#define LYgetattrs(win) getattrs(win)
#else
#define LYgetattrs(win) ((win)->_attrs)
#endif
#endif				/* HAVE_WATTR_GET */

#if defined(PDCURSES)
#define HAVE_GETBKGD 1		/* can use fallback definition */
#define HAVE_NAPMS 1		/* can use millisecond-delays */
#  if defined(PDC_BUILD) && PDC_BUILD >= 2401
    extern int saved_scrsize_x;
    extern int saved_scrsize_y;
#  endif
#endif

#ifdef HAVE_NAPMS
#define SECS2Secs(n) (1000 * (n))
#define Secs2SECS(n) ((n) / 1000.0)
#define SECS_FMT "%.3f"
#else
#define SECS2Secs(n) (n)
#define Secs2SECS(n) (n)
#define SECS_FMT "%.0f"
#endif

/* Both slang and curses: */
#ifndef TRUE
#define TRUE  1
#endif				/* !TRUE */
#ifndef FALSE
#define FALSE 0
#endif				/* !FALSE */

#ifdef REDEFINE_CR
#define CR FROMASCII('\015')
#endif				/* REDEFINE_CR */

#ifdef ALT_CHAR_SET
#define BOXVERT 0		/* use alt char set for popup window vertical borders */
#define BOXHORI 0		/* use alt char set for popup window vertical borders */
#endif

#ifndef BOXVERT
#define BOXVERT '*'		/* character for popup window vertical borders */
#endif
#ifndef BOXHORI
#define BOXHORI '*'		/* character for popup window horizontal borders */
#endif

#ifndef KEY_DOWN
#undef HAVE_KEYPAD		/* avoid confusion with bogus 'keypad()' */
#endif

    extern int LYlines;		/* replaces LINES */
    extern int LYcols;		/* replaces COLS */

/*
 * The scrollbar, if used, occupies the rightmost column.
 */
#ifdef USE_SCROLLBAR
#define LYbarWidth (LYShowScrollbar ? 1 : 0)
#else
#define LYbarWidth 0
#endif

/*
 * Usable limits for display:
 */
#if defined(FANCY_CURSES) || defined(USE_SLANG)
#define LYcolLimit (LYcols - LYbarWidth)
#else
#define LYcolLimit (LYcols - 1)
#endif

#ifdef USE_CURSES_PADS
    extern WINDOW *LYwin;
    extern int LYshiftWin;
    extern int LYwideLines;
    extern int LYtableCols;
    extern BOOL LYuseCursesPads;

#else
#define LYwin stdscr
#define LYshiftWin	0
#define LYwideLines	0
#define LYtableCols	0
#endif

#if defined(USE_COLOR_TABLE) || defined(USE_SLANG)
    extern int Current_Attr;
    extern int Masked_Attr;
#endif

    extern BOOLEAN setup(char *terminal);
    extern int LYscreenHeight(void);
    extern int LYscreenWidth(void);
    extern int LYstrExtent(const char *string, int len, int maxCells);
    extern int LYstrExtent2(const char *string, int len);
    extern int LYstrCells(const char *string);
    extern void LYclear(void);
    extern void LYclrtoeol(void);
    extern void LYerase(void);
    extern void LYmove(int y, int x);
    extern void LYnoVideo(int mask);
    extern void LYpaddstr(WINDOW * w, int width, const char *s);
    extern void LYrefresh(void);
    extern void LYstartTargetEmphasis(void);
    extern void LYstopTargetEmphasis(void);
    extern void LYtouchline(int row);
    extern void LYwaddnstr(WINDOW * w, const char *s, size_t len);
    extern void start_curses(void);
    extern void stop_curses(void);

#define LYaddstr(s)      LYwaddnstr(LYwin, s, strlen(s))
#define LYaddnstr(s,len) LYwaddnstr(LYwin, s, len)
#define LYwaddstr(w,s)   LYwaddnstr(w, s, strlen(s))

#ifdef VMS
    extern int DCLsystem(char *command);
    extern void VMSexit();
    extern int ttopen();
    extern int ttclose();
    extern int ttgetc();
    extern void VMSsignal(int sig, void (*func) ());
#endif				/* VMS */

#if defined(USE_COLOR_STYLE)
    extern void curses_css(char *name, int dir);
    extern void curses_style(int style, int dir);
    extern void setHashStyle(int style, int color, int cattr, int mono, char *element);
    extern void setStyle(int style, int color, int cattr, int mono);
    extern void wcurses_css(WINDOW * win, char *name, int dir);
    extern void curses_w_style(WINDOW * win, int style, int dir);

#  define LynxChangeStyle(style,dir) curses_style(style,dir)
#  define LynxWChangeStyle(win,style,dir) curses_w_style(win,style,dir)
#else
#  define LynxWChangeStyle(win,style,dir)	(void)1
#endif				/* USE_COLOR_STYLE */

#ifdef USE_COLOR_TABLE
    extern void LYaddAttr(int a);
    extern void LYsubAttr(int a);
    extern void lynx_setup_colors(void);
    extern unsigned int Lynx_Color_Flags;
#endif

#ifdef USE_SLANG
#define SHOW_WHEREIS_TARGETS 1

#if !defined(VMS) && !defined(DJGPP)
#define USE_MOUSE              1
#endif

#if !defined(__DJGPP__) && !defined(__CYGWIN__)
#define USE_KEYMAPS		1
#endif

#define SL_LYNX_USE_COLOR	1
#define SL_LYNX_OVERRIDE_COLOR	2

#define start_bold()      	LYaddAttr(LYUnderlineLinks ? 4 : 1)
#define start_reverse()   	LYaddAttr(2)
#define start_underline() 	LYaddAttr(LYUnderlineLinks ? 1 : 4)
#define stop_bold()       	LYsubAttr(LYUnderlineLinks ? 4 : 1)
#define stop_reverse()    	LYsubAttr(2)
#define stop_underline()  	LYsubAttr(LYUnderlineLinks ? 1 : 4)

#ifdef FANCY_CURSES
#undef FANCY_CURSES
#endif				/* FANCY_CURSES */

/*
 *  Map some curses functions to slang functions.
 */
#define stdscr ((WINDOW *)0)
#ifdef SLANG_MBCS_HACK
    extern int PHYSICAL_SLtt_Screen_Cols;

#define COLS PHYSICAL_SLtt_Screen_Cols
#else
#define COLS SLtt_Screen_Cols
#endif				/* SLANG_MBCS_HACK */
#define LINES SLtt_Screen_Rows
#define move SLsmg_gotorc
#define addstr SLsmg_write_string
    extern void LY_SLerase(void);

#define erase LY_SLerase
#define clear LY_SLerase
#define standout SLsmg_reverse_video
#define standend  SLsmg_normal_video
#define clrtoeol SLsmg_erase_eol

#ifdef SLSMG_NEWLINE_SCROLLS
#define scrollok(a,b) SLsmg_Newline_Behavior \
   = ((b) ? SLSMG_NEWLINE_SCROLLS : SLSMG_NEWLINE_MOVES)
#else
#define scrollok(a,b) SLsmg_Newline_Moves = ((b) ? 1 : -1)
#endif

#define LYaddch(ch)   SLsmg_write_char(ch)
#define addch_raw(ch) do {                                \
                        SLsmg_Char_Type buf;              \
                        buf = (ch) | (Current_Attr << 4); \
                        SLsmg_write_raw (&buf, 1);        \
                      } while (0)
#define echo()
#define printw        SLsmg_printf

    extern int curscr;
    extern BOOLEAN FullRefresh;

#ifdef clearok
#undef clearok
#endif				/* clearok */
#define clearok(a,b) { FullRefresh = (BOOLEAN)b; }
    extern void LY_SLrefresh(void);

#ifdef refresh
#undef refresh
#endif				/* refresh */
#define refresh LY_SLrefresh

#ifdef VMS
    extern void VTHome(void);

#define endwin() LYclear(),refresh(),SLsmg_reset_smg(),VTHome()
#else
#define endwin SLsmg_reset_smg(),SLang_reset_tty
#endif				/* VMS */

#else				/* Define curses functions: */

#ifdef FANCY_CURSES
#define SHOW_WHEREIS_TARGETS 1

#ifdef VMS
/*
 *  For VMS curses, [w]setattr() and [w]clrattr()
 *  add and subtract, respectively, the attributes
 *  _UNDERLINE, _BOLD, _REVERSE, and _BLINK. - FM
 */
#define start_bold()		setattr(LYUnderlineLinks ? _UNDERLINE : _BOLD)
#define stop_bold()		clrattr(LYUnderlineLinks ? _UNDERLINE : _BOLD)
#define start_underline()	setattr(LYUnderlineLinks ? _BOLD : _UNDERLINE)
#define stop_underline()	clrattr(LYUnderlineLinks ? _BOLD : _UNDERLINE)
#define start_reverse()		setattr(_REVERSE)
#define wstart_reverse(w)	wsetattr(w, _REVERSE)
#define stop_reverse()		clrattr(_REVERSE)
#define wstop_reverse(w)	wclrattr(w, _REVERSE)

#else				/* Not VMS: */

    extern int string_to_attr(char *name);

/*
 *  For Unix FANCY_FANCY curses we interpose
 *  our own functions to add or subtract the
 *  A_foo attributes. - FM
 */
#ifdef USE_COLOR_TABLE
    extern void LYaddWAttr(WINDOW * win, int a);
    extern void LYsubWAttr(WINDOW * win, int a);
    extern void LYaddWAttr(WINDOW * win, int a);
    extern void LYsubWAttr(WINDOW * win, int a);
    extern void lynx_set_color(int a);
    extern void lynx_standout(int a);
    extern int lynx_chg_color(int, int, int);

#undef  standout
#define standout() 		lynx_standout(TRUE)
#undef  standend
#define standend() 		lynx_standout(FALSE)
#else
#define LYaddAttr(attr)		LYaddWAttr(LYwin,attr)
#define LYaddWAttr(win,attr)	wattron(win,attr)
#define LYsubAttr(attr)		LYsubWAttr(LYwin,attr)
#define LYsubWAttr(win,attr)	wattroff(win,attr)
#endif

#define start_bold()		LYaddAttr(LYUnderlineLinks ? A_UNDERLINE : A_BOLD)
#define stop_bold()		LYsubAttr(LYUnderlineLinks ? A_UNDERLINE : A_BOLD)
#define start_underline()	LYaddAttr(LYUnderlineLinks ? A_BOLD : A_UNDERLINE)
#define stop_underline()	LYsubAttr(LYUnderlineLinks ? A_BOLD : A_UNDERLINE)

#if defined(SNAKE) && defined(HP_TERMINAL)
#define start_reverse()		LYaddWAttr(LYwin, A_DIM)
#define wstart_reverse(w)	LYaddWAttr(w, A_DIM)
#define stop_reverse()		LYsubWAttr(LYwin, A_DIM)
#define wstop_reverse(w)	LYsubWAttr(w, A_DIM)
#else
#define start_reverse()		LYaddAttr(A_REVERSE)
#define wstart_reverse(w)	LYaddWAttr(w, A_REVERSE)
#define stop_reverse()		LYsubAttr(A_REVERSE)
#define wstop_reverse(w)	LYsubWAttr(w, A_REVERSE)
#endif				/* SNAKE && HP_TERMINAL */

#endif				/* VMS */

#else				/* Not FANCY_CURSES: */
/* *INDENT-OFF* */
#ifdef COLOR_CURSES
#undef COLOR_CURSES
Error FANCY_CURSES
There is a problem with the configuration.  We expect to have FANCY_CURSES
defined when COLOR_CURSES is defined, since we build on the attributes used in
FANCY_CURSES.  Check your config.log to see why the FANCY_CURSES test failed.
#endif
/* *INDENT-ON* */

/*
 *  We only have [w]standout() and [w]standin(),
 *  so we'll use them synonymously for bold and
 *  reverse, and ignore underline. - FM
 */
#define start_bold()		standout()
#define start_underline()	/* nothing */
#define start_reverse()		standout()
#define wstart_reverse(a)	wstandout(a)
#define stop_bold()		standend()
#define stop_underline()	/* nothing */
#define stop_reverse()		standend()
#define wstop_reverse(a)	wstandend(a)

#endif				/* FANCY_CURSES */

#ifdef __hpux			/* FIXME: configure check */
#undef ACS_UARROW
#undef ACS_DARROW
#undef ACS_LARROW
#undef ACS_RARROW
#undef ACS_BLOCK
#undef ACS_CKBOARD
#endif

#ifndef ACS_UARROW
#define ACS_UARROW  '^'
#endif

#ifndef ACS_DARROW
#define ACS_DARROW  'V'
#endif

#ifndef ACS_LARROW
#define ACS_LARROW '{'
#endif

#ifndef ACS_RARROW
#define ACS_RARROW '}'
#endif

#ifndef ACS_BLOCK
#define ACS_BLOCK  '}'
#endif

#ifndef ACS_CKBOARD
#define ACS_CKBOARD '}'
#endif

#define LYaddch(ch)		waddch(LYwin, ch)

#define addch_raw(ch)           LYaddch(ch)

#endif				/* USE_SLANG */

#ifdef USE_SLANG
#define LYGetYX(y, x)   y = SLsmg_get_row(), x = SLsmg_get_column()
#else
#ifdef getyx
#define LYGetYX(y, x)   getyx(LYwin, y, x)
#else
#define LYGetYX(y, x)   y = LYwin->_cury, x = LYwin->_curx
#endif				/* getyx */
#endif				/* USE_SLANG */

/*
 * If the screen library allows us to specify "default" color, allow user to
 * control it.
 */
#ifdef USE_DEFAULT_COLORS
#if defined(USE_SLANG) || defined(HAVE_ASSUME_DEFAULT_COLORS)
#define EXP_ASSUMED_COLOR 1
#endif
#endif

    extern void lynx_enable_mouse(int);
    extern void lynx_force_repaint(void);
    extern void lynx_nl2crlf(int normal);
    extern void lynx_start_title_color(void);
    extern void lynx_stop_title_color(void);
    extern void lynx_start_link_color(int flag, int pending);
    extern void lynx_stop_link_color(int flag, int pending);
    extern void lynx_stop_target_color(void);
    extern void lynx_start_target_color(void);
    extern void lynx_start_status_color(void);
    extern void lynx_stop_status_color(void);
    extern void lynx_start_h1_color(void);
    extern void lynx_stop_h1_color(void);
    extern void lynx_start_prompt_color(void);
    extern void lynx_stop_prompt_color(void);
    extern void lynx_start_radio_color(void);
    extern void lynx_stop_radio_color(void);
    extern void lynx_stop_all_colors(void);

    extern void lynx_start_bold(void);
    extern void lynx_start_reverse(void);
    extern void lynx_start_underline(void);
    extern void lynx_stop_bold(void);
    extern void lynx_stop_reverse(void);
    extern void lynx_stop_underline(void);

/*
 * To prevent corrupting binary data on DOS, MS-WINDOWS or OS/2 we open files
 * and stdout in BINARY mode by default.  Where necessary we should open and
 * (close!) TEXT mode.
 *
 * Note:  EMX has no corresponding variable like _fmode on DOS, but it does
 * have setmode.
 */
#if defined(_WINDOWS) || defined(DJGPP) || defined(__EMX__) || defined(WIN_EX)
#define SetOutputMode(mode) fflush(stdout), setmode(fileno(stdout), mode)
#else
#define SetOutputMode(mode)	/* nothing */
#endif

#if defined(_WINDOWS) || defined(DJGPP)
#define SetDefaultMode(mode) _fmode = mode
#else
#define SetDefaultMode(mode)	/* nothing */
#endif

/*
 * Very old versions of curses cannot put the cursor on the lower right corner.
 * Adjust our "hidden" cursor position accordingly.
 */
#if defined(FANCY_CURSES) || defined(USE_SLANG)
#define LYHideCursor() LYmove((LYlines - 1), (LYcolLimit))
#else
#define LYHideCursor() LYmove((LYlines - 1), (LYcolLimit - 1))
#endif

    extern void LYstowCursor(WINDOW * win, int row, int col);

#ifdef __cplusplus
}
#endif
#endif				/* LYCURSES_H */
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d42 1
a42 1
#undef TRUE  /* to prevent parse error :( */
d45 1
a45 1
#undef FALSE  /* to prevent parse error :( */
d53 1
a53 1
    int	top_y;
d125 1
a125 1
#undef CR  /* to prevent parse error :( */
d130 1
a130 1
#undef HZ  /* to prevent parse error :( */
d157 1
a157 1
#undef MOUSE_MOVED	/* conflict between PDCURSES and _WIN32 */
d218 1
a218 1
#       undef HAVE_TERM_H			/* only use one in comparable path! */
d235 2
a236 2
#   include <curses.h>  /* everything else */
# endif /* VMS && __GNUC__ */
d287 3
d291 1
a291 1
#define LYstopPopup() /* nothing */
d294 3
a296 2
extern void LYsubwindow PARAMS((WINDOW * param));
extern WINDOW * LYtopwindow NOPARAMS;
d298 1
a298 1
#endif /* NCURSES */
d300 2
a301 2
extern void LYbox PARAMS((WINDOW *win, BOOLEAN formfield));
extern WINDOW *LYstartPopup PARAMS((int top_y, int left_x, int height, int width));
d317 2
a318 1
extern long LYgetattrs PARAMS((WINDOW *win));
d325 1
a325 1
#endif /* HAVE_WATTR_GET */
d328 6
a333 2
#define HAVE_GETBKGD 1	/* can use fallback definition */
#define HAVE_NAPMS 1	/* can use millisecond-delays */
d349 1
a349 1
#endif /* !TRUE */
d352 1
a352 1
#endif /* !FALSE */
d356 1
a356 1
#endif /* REDEFINE_CR */
d359 2
a360 2
#define BOXVERT 0   /* use alt char set for popup window vertical borders */
#define BOXHORI 0   /* use alt char set for popup window vertical borders */
d364 1
a364 1
#define BOXVERT '*'	/* character for popup window vertical borders */
d367 1
a367 1
#define BOXHORI '*'	/* character for popup window horizontal borders */
d371 1
a371 1
#undef HAVE_KEYPAD	/* avoid confusion with bogus 'keypad()' */
d374 20
a393 2
extern int LYlines;	/* replaces LINES */
extern int LYcols;	/* replaces COLS */
d396 6
a401 5
extern WINDOW *LYwin;
extern int LYshiftWin;
extern int LYwideLines;
extern int LYtableCols;
extern BOOL LYuseCursesPads;
d410 2
a411 2
extern int Current_Attr;
extern int Masked_Attr;
d414 19
a432 16
extern BOOLEAN setup PARAMS((char *terminal));
extern int LYscreenHeight NOPARAMS;
extern int LYscreenWidth NOPARAMS;
extern void LYclear NOPARAMS;
extern void LYclrtoeol NOPARAMS;
extern void LYerase NOPARAMS;
extern void LYmove PARAMS((int y, int x));
extern void LYnoVideo PARAMS((int mask));
extern void LYpaddstr PARAMS((WINDOW *w, int width, CONST char *s));
extern void LYrefresh NOPARAMS;
extern void LYstartTargetEmphasis NOPARAMS;
extern void LYstopTargetEmphasis NOPARAMS;
extern void LYtouchline PARAMS((int row));
extern void LYwaddnstr PARAMS((WINDOW *w, CONST char *s, size_t len));
extern void start_curses NOPARAMS;
extern void stop_curses NOPARAMS;
d439 7
a445 7
extern int DCLsystem (char *command);
extern void VMSexit();
extern int ttopen();
extern int ttclose();
extern int ttgetc();
extern void VMSsignal PARAMS((int sig, void (*func)()));
#endif /* VMS */
d448 7
a454 6
extern void curses_css PARAMS((char * name, int dir));
extern void curses_style PARAMS((int style, int dir));
extern void setHashStyle PARAMS((int style, int color, int cattr, int mono, char* element));
extern void setStyle PARAMS((int style, int color, int cattr, int mono));
extern void wcurses_css PARAMS((WINDOW * win, char* name, int dir));
extern void curses_w_style PARAMS((WINDOW* win, int style, int	dir));
d459 1
a459 1
#endif /* USE_COLOR_STYLE */
d462 4
a465 4
extern void LYaddAttr PARAMS((int a));
extern void LYsubAttr PARAMS((int a));
extern void lynx_setup_colors NOPARAMS;
extern unsigned int Lynx_Color_Flags;
d482 1
a482 2
#ifdef UNDERLINE_LINKS
#define start_bold()      	LYaddAttr(4)
d484 2
a485 2
#define start_underline() 	LYaddAttr(1)
#define stop_bold()       	LYsubAttr(4)
d487 1
a487 9
#define stop_underline()  	LYsubAttr(1)
#else
#define start_bold()      	LYaddAttr(1)
#define start_reverse()   	LYaddAttr(2)
#define start_underline() 	LYaddAttr(4)
#define stop_bold()       	LYsubAttr(1)
#define stop_reverse()    	LYsubAttr(2)
#define stop_underline()  	LYsubAttr(4)
#endif
d491 1
a491 1
#endif /* FANCY_CURSES */
d498 2
a499 1
extern int PHYSICAL_SLtt_Screen_Cols;
d503 1
a503 1
#endif /* SLANG_MBCS_HACK */
d507 2
a508 1
extern void LY_SLerase NOPARAMS;
d531 3
a533 2
extern int curscr;
extern BOOLEAN FullRefresh;
d536 1
a536 1
#endif /* clearok */
d538 2
a539 1
extern void LY_SLrefresh NOPARAMS;
d542 1
a542 1
#endif /* refresh */
d546 2
a547 1
extern void VTHome NOPARAMS;
d551 1
a551 1
#endif /* VMS */
d553 1
a553 1
#else /* Define curses functions: */
d564 4
a567 11
#ifdef UNDERLINE_LINKS
#define start_bold()		setattr(_UNDERLINE)
#define stop_bold()		clrattr(_UNDERLINE)
#define start_underline()	setattr(_BOLD)
#define stop_underline()	clrattr(_BOLD)
#else /* not UNDERLINE_LINKS */
#define start_bold()		setattr(_BOLD)
#define stop_bold()		clrattr(_BOLD)
#define start_underline()	setattr(_UNDERLINE)
#define stop_underline()	clrattr(_UNDERLINE)
#endif /* UNDERLINE_LINKS */
d573 1
a573 1
#else /* Not VMS: */
d575 1
a575 1
extern int string_to_attr PARAMS((char *name));
d583 8
a590 7
extern void LYaddWAttr PARAMS((WINDOW *win, int a));
extern void LYsubWAttr PARAMS((WINDOW *win, int a));
extern void LYaddWAttr PARAMS((WINDOW *win, int a));
extern void LYsubWAttr PARAMS((WINDOW *win, int a));
extern void lynx_set_color PARAMS((int a));
extern void lynx_standout  PARAMS((int a));
extern int  lynx_chg_color PARAMS((int, int, int));
d602 4
a605 15
#ifdef UNDERLINE_LINKS
#define start_bold()		LYaddAttr(A_UNDERLINE)
#define stop_bold()		LYsubAttr(A_UNDERLINE)
#define start_underline()	LYaddAttr(A_BOLD)
#define stop_underline()	LYsubAttr(A_BOLD)
#else /* not UNDERLINE_LINKS: */
#define start_bold()		LYaddAttr(A_BOLD)
#define stop_bold()		LYsubAttr(A_BOLD)
#ifdef USE_COLOR_STYLE
#define start_underline()	attron(A_UNDERLINE) /* allow combining - kw */
#else
#define start_underline()	LYaddAttr(A_UNDERLINE)
#endif /* USE_COLOR_STYLE */
#define stop_underline()	LYsubAttr(A_UNDERLINE)
#endif /* UNDERLINE_LINKS */
d617 1
a617 3
#endif /* SNAKE && HP_TERMINAL */

#endif /* VMS */
d619 1
a619 1
#else /* Not FANCY_CURSES: */
d621 2
d630 1
d646 1
a646 1
#endif /* FANCY_CURSES */
d685 1
a685 1
#endif /* USE_SLANG */
d694 2
a695 2
#endif /* getyx */
#endif /* USE_SLANG */
d707 25
a731 18
extern void lynx_enable_mouse PARAMS((int));
extern void lynx_force_repaint NOPARAMS;
extern void lynx_nl2crlf PARAMS((int normal));
extern void lynx_start_title_color NOPARAMS;
extern void lynx_stop_title_color NOPARAMS;
extern void lynx_start_link_color PARAMS((int flag, int pending));
extern void lynx_stop_link_color PARAMS((int flag, int pending));
extern void lynx_stop_target_color NOPARAMS;
extern void lynx_start_target_color NOPARAMS;
extern void lynx_start_status_color NOPARAMS;
extern void lynx_stop_status_color NOPARAMS;
extern void lynx_start_h1_color NOPARAMS;
extern void lynx_stop_h1_color NOPARAMS;
extern void lynx_start_prompt_color NOPARAMS;
extern void lynx_stop_prompt_color NOPARAMS;
extern void lynx_start_radio_color NOPARAMS;
extern void lynx_stop_radio_color NOPARAMS;
extern void lynx_stop_all_colors NOPARAMS;
d744 1
a744 1
#define SetOutputMode(mode) /* nothing */
d750 1
a750 1
#define SetDefaultMode(mode) /* nothing */
d758 1
a758 1
#define LYHideCursor() LYmove((LYlines - 1), (LYcols - 1))
d760 1
a760 1
#define LYHideCursor() LYmove((LYlines - 1), (LYcols - 2))
d763 1
a763 1
extern void LYstowCursor PARAMS((WINDOW * win, int row, int col));
d765 4
a768 1
#endif /* LYCURSES_H */
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d88 1
a88 1
#ifndef ACS_UARROW  
d277 4
a280 1
#if defined(COLOR_CURSES) && !(defined(PDCURSES) || defined(HAVE_XCURSES))
d283 1
a301 3
#if !defined(HAVE_GETATTRS) && !defined(getattrs)
#define getattrs(win) ((win)->_attrs)
#endif
d312 10
d636 10
a645 1
#ifndef ACS_UARROW  
d661 8
d686 1
a686 1
 * If the screen library allows us to specify "default" color, allow user to 
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d9 21
a48 3
#if defined(UNIX) && !defined(unix)
#define unix
#endif /* UNIX && !unix */
d51 61
d156 21
d178 4
a181 2
# ifdef HAVE_NCURSES_H
#  include <ncurses.h>
d183 2
a184 2
#  ifdef HAVE_CURSESX_H
#   include <cursesX.h>		/* Ultrix */
d186 2
a187 2
#   ifdef HAVE_JCURSES_H
#    include <jcurses.h>	/* sony_news */
d189 13
a201 1
#    include <curses.h>		/* default */
d210 16
a225 3
# ifdef NCURSES
extern void LYsubwindow PARAMS((WINDOW * param));
# endif /* NCURSES */
d227 3
a229 4
#if defined(NCURSES_VERSION) && defined(HAVE_DEFINE_KEY)
#include <term.h>
#define USE_KEYMAPS		1
#endif
d234 2
a235 2
# else
#  include <curses.h>  /* everything else */
d239 47
a285 2
#ifdef VMS
extern void VMSbox PARAMS((WINDOW *win, int height, int width));
d287 5
d293 22
a314 2
#endif /* VMS */
#endif /* USE_SLANG */
d316 9
d354 20
a373 2
extern int LYlines;  /* replaces LINES */
extern int LYcols;   /* replaces COLS */
a374 2
extern void start_curses NOPARAMS;
extern void stop_curses NOPARAMS;
d376 9
d387 8
a407 1
extern void curses_w_style PARAMS((WINDOW* win, int style, int dir));
d411 3
a413 1
#define LynxChangeStyle(style,dir,previous) curses_style(style,dir)
d415 1
a415 2
extern int slang_style PARAMS((int style, int dir, int previous));
#define LynxChangeStyle(style,dir,previous) slang_style(style,dir,previous)
d418 1
a418 1
#if USE_COLOR_TABLE
d426 1
d429 1
a429 1
#define USE_SLANG_MOUSE		1
d432 1
a432 1
#if !defined(__DJGPP__)
d437 1
a437 2
#define SL_LYNX_USE_BLINK	2
#define SL_LYNX_OVERRIDE_COLOR	4
d439 8
d453 1
d462 1
a462 4
#ifndef WINDOW
#define WINDOW void
#endif
#define stdscr NULL
d486 6
a491 1
#define addch SLsmg_write_char
d493 1
a493 1
#define printw SLsmg_printf
d509 1
a509 1
#define endwin() clear(),refresh(),SLsmg_reset_smg(),VTHome()
d517 1
d537 1
a537 2
#define wstart_reverse(a)	wsetattr(a, _REVERSE)
#define wstop_underline(a)	wclrattr(a, _UNDERLINE)
d539 1
a539 1
#define wstop_reverse(a)	wclrattr(a, _REVERSE)
d543 2
d550 1
a550 1
#if USE_COLOR_TABLE
d563 4
a566 4
#define LYaddAttr		attrset
#define LYaddWAttr		wattrset
#define LYsubAttr		attroff
#define LYsubWAttr		wattroff
d584 1
d586 4
a589 4
#define start_reverse()		LYaddWAttr(stdscr, A_DIM)
#define wstart_reverse(a)	LYaddWAttr(a, A_DIM)
#define stop_reverse()		LYsubWAttr(stdscr, A_DIM)
#define wstop_reverse(a)	LYsubWAttr(a, A_DIM)
d592 1
a592 1
#define wstart_reverse(a)	LYaddWAttr(a, A_REVERSE)
d594 1
a594 1
#define wstop_reverse(a)	LYsubWAttr(a, A_REVERSE)
d596 1
d624 21
d651 1
a651 1
#define LYGetYX(y, x)   getyx(stdscr, y, x)
d653 1
a653 1
#define LYGetYX(y, x)   y = stdscr->_cury, x = stdscr->_curx
d657 10
d669 1
d694 2
a695 2
#if defined(_WINDOWS) || defined(DJGPP) || defined(__EMX__)
#define SetOutputMode(mode) setmode(fileno(stdout), mode)
d705 12
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a8 21
 * Because we have to configure PDCURSES last, we may get bogus definitions
 * from the system curses library - cancel these now.
 */
#ifdef HAVE_XCURSES

#undef ASSUME_DEFAULT_COLORS
#undef COLOR_CURSES
#undef FANCY_CURSES
#undef HAVE_CBREAK
#undef HAVE_RESIZETERM
#undef HAVE_USE_DEFAULT_COLORS
#undef NCURSES
#undef USE_DEFAULT_COLORS

#define HAVE_CBREAK 1
#define COLOR_CURSES 1
#define FANCY_CURSES 1

#endif

/*
d21 1
a21 1
#undef TRUE			/* to prevent parse error :( */
d24 1
a24 1
#undef FALSE			/* to prevent parse error :( */
d28 3
a32 61
#undef WINDOW
typedef struct {
    int top_y;
    int left_x;
    int height;
    int width;
} WINDOW;

/* slang doesn't really do windows... */
#define waddch(w,c)  LYaddch(c)
#define waddstr(w,s) addstr(s)
#define wmove(win, row, col) SLsmg_gotorc(((win)?(win)->top_y:0) + (row), ((win)?(win)->left_x:0) + (col))

#ifndef SLSMG_UARROW_CHAR
#define SLSMG_UARROW_CHAR '^'
#endif

#ifndef SLSMG_DARROW_CHAR
#define SLSMG_DARROW_CHAR 'v'
#endif

#ifndef SLSMG_LARROW_CHAR
#define SLSMG_LARROW_CHAR '<'
#endif

#ifndef SLSMG_RARROW_CHAR
#define SLSMG_RARROW_CHAR '>'
#endif

#ifndef SLSMG_CKBRD_CHAR
#define SLSMG_CKBRD_CHAR '#'
#endif

#ifndef SLSMG_BLOCK_CHAR
#define SLSMG_BLOCK_CHAR '#'
#endif

#ifndef ACS_UARROW
#define ACS_UARROW  SLSMG_UARROW_CHAR
#endif

#ifndef ACS_DARROW
#define ACS_DARROW  SLSMG_DARROW_CHAR
#endif

#ifndef ACS_LARROW
#define ACS_LARROW  SLSMG_LARROW_CHAR
#endif

#ifndef ACS_RARROW
#define ACS_RARROW  SLSMG_RARROW_CHAR
#endif

#ifndef ACS_CKBOARD
#define ACS_CKBOARD SLSMG_CKBRD_CHAR
#endif

#ifndef ACS_BLOCK
#define ACS_BLOCK   SLSMG_BLOCK_CHAR
#endif

d46 1
a46 1
#undef CR			/* to prevent parse error :( */
d51 1
a51 1
#undef HZ			/* to prevent parse error :( */
a76 21
#if defined(_MSC_VER)
#undef MOUSE_MOVED		/* conflict between PDCURSES and _WIN32 */
#endif /* _MSC_VER */

/*
 * Do this to build with glibc 2.1.3 (apparently it was not used to build a
 * system before release).
 */
#include <signal.h>

#undef CS			/* some BSD versions of curses use this */
#define CS curses_CS		/* ...but we don't */

#ifdef ERR
#undef ERR			/* all versions of curses define this */
#endif

#ifdef MOUSE_MOVED
#undef MOUSE_MOVED		/* wincon.h or MINGW32's copy of it */
#endif

d78 2
a79 4
# ifdef HAVE_NCURSESW_NCURSES_H
#  undef GCC_PRINTFLIKE		/* <libutf8.h> may define 'printf' */
#  include <ncursesw/ncurses.h>
#  undef printf			/* but we don't want that... */
d81 2
a82 2
#  ifdef HAVE_NCURSES_NCURSES_H
#   include <ncurses/ncurses.h>
d84 2
a85 2
#   ifdef HAVE_NCURSES_H
#    include <ncurses.h>
d87 1
a87 13
#    ifdef HAVE_CURSESX_H
#     include <cursesX.h>	/* Ultrix */
#    else
#     ifdef HAVE_JCURSES_H
#      include <jcurses.h>	/* sony_news */
#     else
#      ifdef HAVE_XCURSES
#       include <xcurses.h>	/* PDCurses' UNIX port */
#      else
#       include <curses.h>	/* default */
#      endif
#     endif
#    endif
d96 3
a98 16
# ifdef FANCY_CURSES
#  if defined(NCURSES) && defined(HAVE_NCURSESW_TERM_H)
#    include <ncursesw/term.h>
#  else
#    if defined(NCURSES) && defined(HAVE_NCURSES_TERM_H)
#      include <ncurses/term.h>
#    else
#     if defined(HAVE_NCURSESW_NCURSES_H) || defined(HAVE_NCURSES_NCURSES_H) || defined(HAVE_XCURSES)
#       undef HAVE_TERM_H	/* only use one in comparable path! */
#     endif
#     if defined(HAVE_TERM_H)
#      include <term.h>
#     endif
#   endif
#  endif
# endif
d100 4
a103 3
# if defined(NCURSES_VERSION) && defined(HAVE_DEFINE_KEY)
#  define USE_KEYMAPS		1
# endif
d108 3
a110 3
#  else
#   include <curses.h>		/* everything else */
# endif				/* VMS && __GNUC__ */
d113 2
a114 41
/*
 * PDCurses' mouse code does nothing in the DJGPP configuration.
 */
#if defined(PDCURSES) && !defined(__DJGPP__) && !defined(HAVE_XCURSES)
#define USE_MOUSE 1
#endif

/*
 * Pick up the native ncurses name:
 */
#if defined(NCURSES_MOUSE_VERSION)
#define USE_MOUSE 1
#endif

/*
 * If we have pads, use them to implement left/right scrolling.
 */
#if defined(HAVE_NEWPAD) && defined(HAVE_PNOUTREFRESH) && !defined(PDCURSES)
#define USE_CURSES_PADS 1
#endif

/*
 * ncurses 1.9.9e won't work for pads, but 4.2 does (1.9.9g doesn't have a
 * convenient ifdef, though it would work).
 */
#if defined(NCURSES_VERSION) && !defined(NCURSES_VERSION_MAJOR)
#undef USE_CURSES_PADS
#endif

/*
 * Most implementations of curses treat pair 0 specially, as the default
 * foreground and background color.  Also, the COLORS variable corresponds to
 * the total number of colors.
 *
 * PDCurses does not follow these rules.  Its COLORS variable claims it has
 * 8 colors, but it actually implements 16.  That makes it hard to optimize
 * color settings against color pair 0 in a portable fashion.
 */
#if defined(COLOR_CURSES)
#if defined(PDCURSES) || defined(HAVE_XCURSES)
#define COLORS 16		/* should be a variable... */
d116 2
a117 4
#define USE_CURSES_PAIR_0
#endif
#endif

a119 58
#ifdef __cplusplus
extern "C" {
#endif
#ifdef USE_SLANG
#define LYstopPopup()		/* nothing */
#define LYtopwindow() LYwin
#else
    extern void LYsubwindow(WINDOW * param);
    extern WINDOW *LYtopwindow(void);

#define LYstopPopup() LYsubwindow(0)
#endif				/* NCURSES */

    extern void LYbox(WINDOW * win, BOOLEAN formfield);
    extern WINDOW *LYstartPopup(int *top_y, int *left_x, int *height, int *width);

/*
 * Useful macros not in PDCurses or very old ncurses headers.
 */
#if !defined(HAVE_GETBEGX) && !defined(getbegx)
#define getbegx(win) ((win)->_begx)
#endif
#if !defined(HAVE_GETBEGY) && !defined(getbegy)
#define getbegy(win) ((win)->_begy)
#endif
#if !defined(HAVE_GETBKGD) && !defined(getbkgd)
#define getbkgd(win) ((win)->_bkgd)
#endif

#if defined(HAVE_WATTR_GET)
    extern long LYgetattrs(WINDOW * win);

#else
#if defined(HAVE_GETATTRS) || defined(getattrs)
#define LYgetattrs(win) getattrs(win)
#else
#define LYgetattrs(win) ((win)->_attrs)
#endif
#endif				/* HAVE_WATTR_GET */

#if defined(PDCURSES)
#define HAVE_GETBKGD 1		/* can use fallback definition */
#define HAVE_NAPMS 1		/* can use millisecond-delays */
#  if defined(PDC_BUILD) && PDC_BUILD >= 2401
    extern int saved_scrsize_x;
    extern int saved_scrsize_y;
#  endif
#endif

#ifdef HAVE_NAPMS
#define SECS2Secs(n) (1000 * (n))
#define Secs2SECS(n) ((n) / 1000.0)
#define SECS_FMT "%.3f"
#else
#define SECS2Secs(n) (n)
#define Secs2SECS(n) (n)
#define SECS_FMT "%.0f"
#endif
d124 1
a124 1
#endif				/* !TRUE */
d127 1
a127 1
#endif				/* !FALSE */
d131 1
a131 1
#endif				/* REDEFINE_CR */
d134 2
a135 2
#define BOXVERT 0		/* use alt char set for popup window vertical borders */
#define BOXHORI 0		/* use alt char set for popup window vertical borders */
d139 1
a139 1
#define BOXVERT '*'		/* character for popup window vertical borders */
d142 1
a142 1
#define BOXHORI '*'		/* character for popup window horizontal borders */
d146 1
a146 1
#undef HAVE_KEYPAD		/* avoid confusion with bogus 'keypad()' */
d149 2
a150 2
    extern int LYlines;		/* replaces LINES */
    extern int LYcols;		/* replaces COLS */
d152 5
a156 60
/*
 * The scrollbar, if used, occupies the rightmost column.
 */
#ifdef USE_SCROLLBAR
#define LYbarWidth (LYShowScrollbar ? 1 : 0)
#else
#define LYbarWidth 0
#endif

/*
 * Usable limits for display:
 */
#if defined(FANCY_CURSES) || defined(USE_SLANG)
#define LYcolLimit (LYcols - LYbarWidth)
#else
#define LYcolLimit (LYcols - 1)
#endif

#ifdef USE_CURSES_PADS
    extern WINDOW *LYwin;
    extern int LYshiftWin;
    extern int LYwideLines;
    extern int LYtableCols;
    extern BOOL LYuseCursesPads;

#else
#define LYwin stdscr
#define LYshiftWin	0
#define LYwideLines	0
#define LYtableCols	0
#endif

#if defined(USE_COLOR_TABLE) || defined(USE_SLANG)
    extern int Current_Attr;
    extern int Masked_Attr;
#endif

    extern BOOLEAN setup(char *terminal);
    extern int LYscreenHeight(void);
    extern int LYscreenWidth(void);
    extern int LYstrExtent(const char *string, int len, int maxCells);
    extern int LYstrExtent2(const char *string, int len);
    extern int LYstrCells(const char *string);
    extern void LYclear(void);
    extern void LYclrtoeol(void);
    extern void LYerase(void);
    extern void LYmove(int y, int x);
    extern void LYnoVideo(int mask);
    extern void LYpaddstr(WINDOW * w, int width, const char *s);
    extern void LYrefresh(void);
    extern void LYstartTargetEmphasis(void);
    extern void LYstopTargetEmphasis(void);
    extern void LYtouchline(int row);
    extern void LYwaddnstr(WINDOW * w, const char *s, size_t len);
    extern void start_curses(void);
    extern void stop_curses(void);

#define LYaddstr(s)      LYwaddnstr(LYwin, s, strlen(s))
#define LYaddnstr(s,len) LYwaddnstr(LYwin, s, len)
#define LYwaddstr(w,s)   LYwaddnstr(w, s, strlen(s))
d159 7
a165 7
    extern int DCLsystem(char *command);
    extern void VMSexit();
    extern int ttopen();
    extern int ttclose();
    extern int ttgetc();
    extern void VMSsignal(int sig, void (*func) ());
#endif				/* VMS */
d168 17
a184 18
    extern void curses_css(char *name, int dir);
    extern void curses_style(int style, int dir);
    extern void setHashStyle(int style, int color, int cattr, int mono, char *element);
    extern void setStyle(int style, int color, int cattr, int mono);
    extern void wcurses_css(WINDOW * win, char *name, int dir);
    extern void curses_w_style(WINDOW * win, int style, int dir);

#  define LynxChangeStyle(style,dir) curses_style(style,dir)
#  define LynxWChangeStyle(win,style,dir) curses_w_style(win,style,dir)
#else
#  define LynxWChangeStyle(win,style,dir)	(void)1
#endif				/* USE_COLOR_STYLE */

#ifdef USE_COLOR_TABLE
    extern void LYaddAttr(int a);
    extern void LYsubAttr(int a);
    extern void lynx_setup_colors(void);
    extern unsigned int Lynx_Color_Flags;
a187 1
#define SHOW_WHEREIS_TARGETS 1
d190 1
a190 1
#define USE_MOUSE              1
d193 1
a193 1
#if !defined(__DJGPP__) && !defined(__CYGWIN__)
d198 2
a199 1
#define SL_LYNX_OVERRIDE_COLOR	2
d201 1
a201 1
#define start_bold()      	LYaddAttr(LYUnderlineLinks ? 4 : 1)
d203 2
a204 2
#define start_underline() 	LYaddAttr(LYUnderlineLinks ? 1 : 4)
#define stop_bold()       	LYsubAttr(LYUnderlineLinks ? 4 : 1)
d206 1
a206 1
#define stop_underline()  	LYsubAttr(LYUnderlineLinks ? 1 : 4)
d210 1
a210 1
#endif				/* FANCY_CURSES */
d215 4
a218 1
#define stdscr ((WINDOW *)0)
d220 1
a220 2
    extern int PHYSICAL_SLtt_Screen_Cols;

d224 1
a224 1
#endif				/* SLANG_MBCS_HACK */
d228 1
a228 2
    extern void LY_SLerase(void);

d242 1
a242 6
#define LYaddch(ch)   SLsmg_write_char(ch)
#define addch_raw(ch) do {                                \
                        SLsmg_Char_Type buf;              \
                        buf = (ch) | (Current_Attr << 4); \
                        SLsmg_write_raw (&buf, 1);        \
                      } while (0)
d244 1
a244 4
#define printw        SLsmg_printf

    extern int curscr;
    extern BOOLEAN FullRefresh;
d246 2
d250 1
a250 1
#endif				/* clearok */
d252 1
a252 2
    extern void LY_SLrefresh(void);

d255 1
a255 1
#endif				/* refresh */
d259 2
a260 3
    extern void VTHome(void);

#define endwin() LYclear(),refresh(),SLsmg_reset_smg(),VTHome()
d263 1
a263 1
#endif				/* VMS */
d265 1
a265 1
#else				/* Define curses functions: */
a267 1
#define SHOW_WHEREIS_TARGETS 1
d275 11
a285 4
#define start_bold()		setattr(LYUnderlineLinks ? _UNDERLINE : _BOLD)
#define stop_bold()		clrattr(LYUnderlineLinks ? _UNDERLINE : _BOLD)
#define start_underline()	setattr(LYUnderlineLinks ? _BOLD : _UNDERLINE)
#define stop_underline()	clrattr(LYUnderlineLinks ? _BOLD : _UNDERLINE)
d287 2
a288 1
#define wstart_reverse(w)	wsetattr(w, _REVERSE)
d290 1
a290 3
#define wstop_reverse(w)	wclrattr(w, _REVERSE)

#else				/* Not VMS: */
d292 1
a292 1
    extern int string_to_attr(char *name);
d299 8
a306 9
#ifdef USE_COLOR_TABLE
    extern void LYaddWAttr(WINDOW * win, int a);
    extern void LYsubWAttr(WINDOW * win, int a);
    extern void LYaddWAttr(WINDOW * win, int a);
    extern void LYsubWAttr(WINDOW * win, int a);
    extern void lynx_set_color(int a);
    extern void lynx_standout(int a);
    extern int lynx_chg_color(int, int, int);

d312 21
a332 11
#define LYaddAttr(attr)		LYaddWAttr(LYwin,attr)
#define LYaddWAttr(win,attr)	wattron(win,attr)
#define LYsubAttr(attr)		LYsubWAttr(LYwin,attr)
#define LYsubWAttr(win,attr)	wattroff(win,attr)
#endif

#define start_bold()		LYaddAttr(LYUnderlineLinks ? A_UNDERLINE : A_BOLD)
#define stop_bold()		LYsubAttr(LYUnderlineLinks ? A_UNDERLINE : A_BOLD)
#define start_underline()	LYaddAttr(LYUnderlineLinks ? A_BOLD : A_UNDERLINE)
#define stop_underline()	LYsubAttr(LYUnderlineLinks ? A_BOLD : A_UNDERLINE)

d334 4
a337 4
#define start_reverse()		LYaddWAttr(LYwin, A_DIM)
#define wstart_reverse(w)	LYaddWAttr(w, A_DIM)
#define stop_reverse()		LYsubWAttr(LYwin, A_DIM)
#define wstop_reverse(w)	LYsubWAttr(w, A_DIM)
d340 1
a340 1
#define wstart_reverse(w)	LYaddWAttr(w, A_REVERSE)
d342 3
a344 2
#define wstop_reverse(w)	LYsubWAttr(w, A_REVERSE)
#endif				/* SNAKE && HP_TERMINAL */
d346 1
a346 1
#endif				/* VMS */
a347 2
#else				/* Not FANCY_CURSES: */
/* *INDENT-OFF* */
a354 1
/* *INDENT-ON* */
d370 2
a371 40
#endif				/* FANCY_CURSES */

#ifdef __hpux			/* FIXME: configure check */
#undef ACS_UARROW
#undef ACS_DARROW
#undef ACS_LARROW
#undef ACS_RARROW
#undef ACS_BLOCK
#undef ACS_CKBOARD
#endif

#ifndef ACS_UARROW
#define ACS_UARROW  '^'
#endif

#ifndef ACS_DARROW
#define ACS_DARROW  'V'
#endif

#ifndef ACS_LARROW
#define ACS_LARROW '{'
#endif

#ifndef ACS_RARROW
#define ACS_RARROW '}'
#endif

#ifndef ACS_BLOCK
#define ACS_BLOCK  '}'
#endif

#ifndef ACS_CKBOARD
#define ACS_CKBOARD '}'
#endif

#define LYaddch(ch)		waddch(LYwin, ch)

#define addch_raw(ch)           LYaddch(ch)

#endif				/* USE_SLANG */
d377 1
a377 1
#define LYGetYX(y, x)   getyx(LYwin, y, x)
d379 3
a381 3
#define LYGetYX(y, x)   y = LYwin->_cury, x = LYwin->_curx
#endif				/* getyx */
#endif				/* USE_SLANG */
d383 17
a399 35
/*
 * If the screen library allows us to specify "default" color, allow user to
 * control it.
 */
#ifdef USE_DEFAULT_COLORS
#if defined(USE_SLANG) || defined(HAVE_ASSUME_DEFAULT_COLORS)
#define EXP_ASSUMED_COLOR 1
#endif
#endif

    extern void lynx_enable_mouse(int);
    extern void lynx_force_repaint(void);
    extern void lynx_nl2crlf(int normal);
    extern void lynx_start_title_color(void);
    extern void lynx_stop_title_color(void);
    extern void lynx_start_link_color(int flag, int pending);
    extern void lynx_stop_link_color(int flag, int pending);
    extern void lynx_stop_target_color(void);
    extern void lynx_start_target_color(void);
    extern void lynx_start_status_color(void);
    extern void lynx_stop_status_color(void);
    extern void lynx_start_h1_color(void);
    extern void lynx_stop_h1_color(void);
    extern void lynx_start_prompt_color(void);
    extern void lynx_stop_prompt_color(void);
    extern void lynx_start_radio_color(void);
    extern void lynx_stop_radio_color(void);
    extern void lynx_stop_all_colors(void);

    extern void lynx_start_bold(void);
    extern void lynx_start_reverse(void);
    extern void lynx_start_underline(void);
    extern void lynx_stop_bold(void);
    extern void lynx_stop_reverse(void);
    extern void lynx_stop_underline(void);
d409 2
a410 2
#if defined(_WINDOWS) || defined(DJGPP) || defined(__EMX__) || defined(WIN_EX)
#define SetOutputMode(mode) fflush(stdout), setmode(fileno(stdout), mode)
d412 1
a412 1
#define SetOutputMode(mode)	/* nothing */
d418 1
a418 1
#define SetDefaultMode(mode)	/* nothing */
d421 1
a421 16
/*
 * Very old versions of curses cannot put the cursor on the lower right corner.
 * Adjust our "hidden" cursor position accordingly.
 */
#if defined(FANCY_CURSES) || defined(USE_SLANG)
#define LYHideCursor() LYmove((LYlines - 1), (LYcolLimit))
#else
#define LYHideCursor() LYmove((LYlines - 1), (LYcolLimit - 1))
#endif

    extern void LYstowCursor(WINDOW * win, int row, int col);

#ifdef __cplusplus
}
#endif
#endif				/* LYCURSES_H */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a8 21
 * Because we have to configure PDCURSES last, we may get bogus definitions
 * from the system curses library - cancel these now.
 */
#ifdef HAVE_XCURSES

#undef ASSUME_DEFAULT_COLORS
#undef COLOR_CURSES
#undef FANCY_CURSES
#undef HAVE_CBREAK
#undef HAVE_RESIZETERM
#undef HAVE_USE_DEFAULT_COLORS
#undef NCURSES
#undef USE_DEFAULT_COLORS

#define HAVE_CBREAK 1
#define COLOR_CURSES 1
#define FANCY_CURSES 1

#endif

/*
d28 3
a32 61
#undef WINDOW
typedef struct {
    int	top_y;
    int left_x;
    int height;
    int width;
} WINDOW;

/* slang doesn't really do windows... */
#define waddch(w,c)  LYaddch(c)
#define waddstr(w,s) addstr(s)
#define wmove(win, row, col) SLsmg_gotorc(((win)?(win)->top_y:0) + (row), ((win)?(win)->left_x:0) + (col))

#ifndef SLSMG_UARROW_CHAR
#define SLSMG_UARROW_CHAR '^'
#endif

#ifndef SLSMG_DARROW_CHAR
#define SLSMG_DARROW_CHAR 'v'
#endif

#ifndef SLSMG_LARROW_CHAR
#define SLSMG_LARROW_CHAR '<'
#endif

#ifndef SLSMG_RARROW_CHAR
#define SLSMG_RARROW_CHAR '>'
#endif

#ifndef SLSMG_CKBRD_CHAR
#define SLSMG_CKBRD_CHAR '#'
#endif

#ifndef SLSMG_BLOCK_CHAR
#define SLSMG_BLOCK_CHAR '#'
#endif

#ifndef ACS_UARROW  
#define ACS_UARROW  SLSMG_UARROW_CHAR
#endif

#ifndef ACS_DARROW
#define ACS_DARROW  SLSMG_DARROW_CHAR
#endif

#ifndef ACS_LARROW
#define ACS_LARROW  SLSMG_LARROW_CHAR
#endif

#ifndef ACS_RARROW
#define ACS_RARROW  SLSMG_RARROW_CHAR
#endif

#ifndef ACS_CKBOARD
#define ACS_CKBOARD SLSMG_CKBRD_CHAR
#endif

#ifndef ACS_BLOCK
#define ACS_BLOCK   SLSMG_BLOCK_CHAR
#endif

a76 21
#if defined(_MSC_VER)
#undef MOUSE_MOVED	/* conflict between PDCURSES and _WIN32 */
#endif /* _MSC_VER */

/*
 * Do this to build with glibc 2.1.3 (apparently it was not used to build a
 * system before release).
 */
#include <signal.h>

#undef CS			/* some BSD versions of curses use this */
#define CS curses_CS		/* ...but we don't */

#ifdef ERR
#undef ERR			/* all versions of curses define this */
#endif

#ifdef MOUSE_MOVED
#undef MOUSE_MOVED		/* wincon.h or MINGW32's copy of it */
#endif

d78 2
a79 4
# ifdef HAVE_NCURSESW_NCURSES_H
#  undef GCC_PRINTFLIKE		/* <libutf8.h> may define 'printf' */
#  include <ncursesw/ncurses.h>
#  undef printf			/* but we don't want that... */
d81 2
a82 2
#  ifdef HAVE_NCURSES_NCURSES_H
#   include <ncurses/ncurses.h>
d84 2
a85 2
#   ifdef HAVE_NCURSES_H
#    include <ncurses.h>
d87 1
a87 13
#    ifdef HAVE_CURSESX_H
#     include <cursesX.h>	/* Ultrix */
#    else
#     ifdef HAVE_JCURSES_H
#      include <jcurses.h>	/* sony_news */
#     else
#      ifdef HAVE_XCURSES
#       include <xcurses.h>	/* PDCurses' UNIX port */
#      else
#       include <curses.h>	/* default */
#      endif
#     endif
#    endif
d96 3
a98 16
# ifdef FANCY_CURSES
#  if defined(NCURSES) && defined(HAVE_NCURSESW_TERM_H)
#    include <ncursesw/term.h>
#  else
#    if defined(NCURSES) && defined(HAVE_NCURSES_TERM_H)
#      include <ncurses/term.h>
#    else
#     if defined(HAVE_NCURSESW_NCURSES_H) || defined(HAVE_NCURSES_NCURSES_H) || defined(HAVE_XCURSES)
#       undef HAVE_TERM_H			/* only use one in comparable path! */
#     endif
#     if defined(HAVE_TERM_H)
#      include <term.h>
#     endif
#   endif
#  endif
# endif
d100 4
a103 3
# if defined(NCURSES_VERSION) && defined(HAVE_DEFINE_KEY)
#  define USE_KEYMAPS		1
# endif
d108 2
a109 2
#  else
#   include <curses.h>  /* everything else */
d113 2
a114 47
/*
 * PDCurses' mouse code does nothing in the DJGPP configuration.
 */
#if defined(PDCURSES) && !defined(__DJGPP__) && !defined(HAVE_XCURSES)
#define USE_MOUSE 1
#endif

/*
 * Pick up the native ncurses name:
 */
#if defined(NCURSES_MOUSE_VERSION)
#define USE_MOUSE 1
#endif

/*
 * If we have pads, use them to implement left/right scrolling.
 */
#if defined(HAVE_NEWPAD) && defined(HAVE_PNOUTREFRESH) && !defined(PDCURSES)
#define USE_CURSES_PADS 1
#endif

/*
 * ncurses 1.9.9e won't work for pads, but 4.2 does (1.9.9g doesn't have a
 * convenient ifdef, though it would work).
 */
#if defined(NCURSES_VERSION) && !defined(NCURSES_VERSION_MAJOR)
#undef USE_CURSES_PADS
#endif

/*
 * Most implementations of curses treat pair 0 specially, as the default
 * foreground and background color.  Also, the COLORS variable corresponds to
 * the total number of colors.
 *
 * PDCurses does not follow these rules.  Its COLORS variable claims it has
 * 8 colors, but it actually implements 16.  That makes it hard to optimize
 * color settings against color pair 0 in a portable fashion.
 */
#if defined(COLOR_CURSES) && !(defined(PDCURSES) || defined(HAVE_XCURSES))
#define USE_CURSES_PAIR_0
#endif

#endif /* USE_SLANG */

#ifdef USE_SLANG
#define LYstopPopup() /* nothing */
#define LYtopwindow() LYwin
a115 5
extern void LYsubwindow PARAMS((WINDOW * param));
extern WINDOW * LYtopwindow NOPARAMS;
#define LYstopPopup() LYsubwindow(0)
#endif /* NCURSES */

d117 2
a118 1
extern WINDOW *LYstartPopup PARAMS((int top_y, int left_x, int height, int width));
a119 30
/*
 * Useful macros not in PDCurses or very old ncurses headers.
 */
#if !defined(HAVE_GETATTRS) && !defined(getattrs)
#define getattrs(win) ((win)->_attrs)
#endif
#if !defined(HAVE_GETBEGX) && !defined(getbegx)
#define getbegx(win) ((win)->_begx)
#endif
#if !defined(HAVE_GETBEGY) && !defined(getbegy)
#define getbegy(win) ((win)->_begy)
#endif
#if !defined(HAVE_GETBKGD) && !defined(getbkgd)
#define getbkgd(win) ((win)->_bkgd)
#endif

#if defined(PDCURSES)
#define HAVE_GETBKGD 1	/* can use fallback definition */
#define HAVE_NAPMS 1	/* can use millisecond-delays */
#endif

#ifdef HAVE_NAPMS
#define SECS2Secs(n) (1000 * (n))
#define Secs2SECS(n) ((n) / 1000.0)
#define SECS_FMT "%.3f"
#else
#define SECS2Secs(n) (n)
#define Secs2SECS(n) (n)
#define SECS_FMT "%.0f"
#endif
d149 2
a150 20
extern int LYlines;	/* replaces LINES */
extern int LYcols;	/* replaces COLS */

#ifdef USE_CURSES_PADS
extern WINDOW *LYwin;
extern int LYshiftWin;
extern int LYwideLines;
extern int LYtableCols;
extern BOOL LYuseCursesPads;
#else
#define LYwin stdscr
#define LYshiftWin	0
#define LYwideLines	0
#define LYtableCols	0
#endif

#if defined(USE_COLOR_TABLE) || defined(USE_SLANG)
extern int Current_Attr;
extern int Masked_Attr;
#endif
d152 2
a154 9
extern int LYscreenHeight NOPARAMS;
extern int LYscreenWidth NOPARAMS;
extern void LYclear NOPARAMS;
extern void LYclrtoeol NOPARAMS;
extern void LYerase NOPARAMS;
extern void LYmove PARAMS((int y, int x));
extern void LYnoVideo PARAMS((int mask));
extern void LYpaddstr PARAMS((WINDOW *w, int width, CONST char *s));
extern void LYrefresh NOPARAMS;
a156 8
extern void LYtouchline PARAMS((int row));
extern void LYwaddnstr PARAMS((WINDOW *w, CONST char *s, size_t len));
extern void start_curses NOPARAMS;
extern void stop_curses NOPARAMS;

#define LYaddstr(s)      LYwaddnstr(LYwin, s, strlen(s))
#define LYaddnstr(s,len) LYwaddnstr(LYwin, s, len)
#define LYwaddstr(w,s)   LYwaddnstr(w, s, strlen(s))
d170 1
d174 1
a174 3
extern void curses_w_style PARAMS((WINDOW* win, int style, int	dir));
#  define LynxChangeStyle(style,dir) curses_style(style,dir)
#  define LynxWChangeStyle(win,style,dir) curses_w_style(win,style,dir)
d176 2
a177 1
#  define LynxWChangeStyle(win,style,dir)	(void)1
d180 1
a180 1
#ifdef USE_COLOR_TABLE
a187 1
#define SHOW_WHEREIS_TARGETS 1
d190 1
a190 1
#define USE_MOUSE              1
d193 1
a193 1
#if !defined(__DJGPP__) && !defined(__CYGWIN__)
d198 2
a199 1
#define SL_LYNX_OVERRIDE_COLOR	2
a200 8
#ifdef UNDERLINE_LINKS
#define start_bold()      	LYaddAttr(4)
#define start_reverse()   	LYaddAttr(2)
#define start_underline() 	LYaddAttr(1)
#define stop_bold()       	LYsubAttr(4)
#define stop_reverse()    	LYsubAttr(2)
#define stop_underline()  	LYsubAttr(1)
#else
a206 1
#endif
d215 4
a218 1
#define stdscr ((WINDOW *)0)
d242 1
a242 6
#define LYaddch(ch)   SLsmg_write_char(ch)
#define addch_raw(ch) do {                                \
                        SLsmg_Char_Type buf;              \
                        buf = (ch) | (Current_Attr << 4); \
                        SLsmg_write_raw (&buf, 1);        \
                      } while (0)
d244 1
a244 1
#define printw        SLsmg_printf
d260 1
a260 1
#define endwin() LYclear(),refresh(),SLsmg_reset_smg(),VTHome()
a267 1
#define SHOW_WHEREIS_TARGETS 1
d287 2
a288 1
#define wstart_reverse(w)	wsetattr(w, _REVERSE)
d290 1
a290 1
#define wstop_reverse(w)	wclrattr(w, _REVERSE)
a293 2
extern int string_to_attr PARAMS((char *name));

d299 1
a299 1
#ifdef USE_COLOR_TABLE
d312 4
a315 4
#define LYaddAttr(attr)		LYaddWAttr(LYwin,attr)
#define LYaddWAttr(win,attr)	wattron(win,attr)
#define LYsubAttr(attr)		LYsubWAttr(LYwin,attr)
#define LYsubWAttr(win,attr)	wattroff(win,attr)
a332 1

d334 4
a337 4
#define start_reverse()		LYaddWAttr(LYwin, A_DIM)
#define wstart_reverse(w)	LYaddWAttr(w, A_DIM)
#define stop_reverse()		LYsubWAttr(LYwin, A_DIM)
#define wstop_reverse(w)	LYsubWAttr(w, A_DIM)
d340 1
a340 1
#define wstart_reverse(w)	LYaddWAttr(w, A_REVERSE)
d342 1
a342 1
#define wstop_reverse(w)	LYsubWAttr(w, A_REVERSE)
a343 1

a370 21

#ifndef ACS_UARROW  
#define ACS_UARROW  '^'
#endif

#ifndef ACS_DARROW
#define ACS_DARROW  'V'
#endif

#ifndef ACS_LARROW
#define ACS_LARROW '{'
#endif

#ifndef ACS_RARROW
#define ACS_RARROW '}'
#endif

#define LYaddch(ch)		waddch(LYwin, ch)

#define addch_raw(ch)           LYaddch(ch)

d377 1
a377 1
#define LYGetYX(y, x)   getyx(LYwin, y, x)
d379 1
a379 1
#define LYGetYX(y, x)   y = LYwin->_cury, x = LYwin->_curx
a382 10
/*
 * If the screen library allows us to specify "default" color, allow user to 
 * control it.
 */
#ifdef USE_DEFAULT_COLORS
#if defined(USE_SLANG) || defined(HAVE_ASSUME_DEFAULT_COLORS)
#define EXP_ASSUMED_COLOR 1
#endif
#endif

a384 1
extern void lynx_nl2crlf PARAMS((int normal));
d409 2
a410 2
#if defined(_WINDOWS) || defined(DJGPP) || defined(__EMX__) || defined(WIN_EX)
#define SetOutputMode(mode) fflush(stdout), setmode(fileno(stdout), mode)
a419 12

/*
 * Very old versions of curses cannot put the cursor on the lower right corner.
 * Adjust our "hidden" cursor position accordingly.
 */
#if defined(FANCY_CURSES) || defined(USE_SLANG)
#define LYHideCursor() LYmove((LYlines - 1), (LYcols - 1))
#else
#define LYHideCursor() LYmove((LYlines - 1), (LYcols - 2))
#endif

extern void LYstowCursor PARAMS((WINDOW * win, int row, int col));
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d88 1
a88 1
#ifndef ACS_UARROW
d277 1
a277 4
#if defined(COLOR_CURSES)
#if defined(PDCURSES) || defined(HAVE_XCURSES)
#define COLORS 16		/* should be a variable... */
#else
a279 1
#endif
d298 3
a310 10
#if defined(HAVE_WATTR_GET)
extern long LYgetattrs PARAMS((WINDOW *win));
#else
#if defined(HAVE_GETATTRS) || defined(getattrs)
#define LYgetattrs(win) getattrs(win)
#else
#define LYgetattrs(win) ((win)->_attrs)
#endif
#endif /* HAVE_WATTR_GET */

d625 1
a625 10
#ifdef __hpux			/* FIXME: configure check */
#undef ACS_UARROW
#undef ACS_DARROW
#undef ACS_LARROW
#undef ACS_RARROW
#undef ACS_BLOCK
#undef ACS_CKBOARD
#endif

#ifndef ACS_UARROW
a640 8
#ifndef ACS_BLOCK
#define ACS_BLOCK  '}'
#endif

#ifndef ACS_CKBOARD
#define ACS_CKBOARD '}'
#endif

d658 1
a658 1
 * If the screen library allows us to specify "default" color, allow user to
@


1.1.3.3
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@d450 2
a451 1
#define start_bold()      	LYaddAttr(LYUnderlineLinks ? 4 : 1)
d453 2
a454 2
#define start_underline() 	LYaddAttr(LYUnderlineLinks ? 1 : 4)
#define stop_bold()       	LYsubAttr(LYUnderlineLinks ? 4 : 1)
d456 9
a464 1
#define stop_underline()  	LYsubAttr(LYUnderlineLinks ? 1 : 4)
d536 11
a546 4
#define start_bold()		setattr(LYUnderlineLinks ? _UNDERLINE : _BOLD)
#define stop_bold()		clrattr(LYUnderlineLinks ? _UNDERLINE : _BOLD)
#define start_underline()	setattr(LYUnderlineLinks ? _BOLD : _UNDERLINE)
#define stop_underline()	clrattr(LYUnderlineLinks ? _BOLD : _UNDERLINE)
d580 15
a594 4
#define start_bold()		LYaddAttr(LYUnderlineLinks ? A_UNDERLINE : A_BOLD)
#define stop_bold()		LYsubAttr(LYUnderlineLinks ? A_UNDERLINE : A_BOLD)
#define start_underline()	LYaddAttr(LYUnderlineLinks ? A_BOLD : A_UNDERLINE)
#define stop_underline()	LYsubAttr(LYUnderlineLinks ? A_BOLD : A_UNDERLINE)
a712 7

extern void lynx_start_bold NOPARAMS;
extern void lynx_start_reverse NOPARAMS;
extern void lynx_start_underline NOPARAMS;
extern void lynx_stop_bold NOPARAMS;
extern void lynx_stop_reverse NOPARAMS;
extern void lynx_stop_underline NOPARAMS;
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d291 2
a292 2
extern void LYsubwindow (WINDOW * param);
extern WINDOW * LYtopwindow (void);
d296 2
a297 2
extern void LYbox (WINDOW *win, BOOLEAN formfield);
extern WINDOW *LYstartPopup (int top_y, int left_x, int height, int width);
d313 1
a313 1
extern long LYgetattrs (WINDOW *win);
d386 16
a401 16
extern BOOLEAN setup (char *terminal);
extern int LYscreenHeight (void);
extern int LYscreenWidth (void);
extern void LYclear (void);
extern void LYclrtoeol (void);
extern void LYerase (void);
extern void LYmove (int y, int x);
extern void LYnoVideo (int mask);
extern void LYpaddstr (WINDOW *w, int width, const char *s);
extern void LYrefresh (void);
extern void LYstartTargetEmphasis (void);
extern void LYstopTargetEmphasis (void);
extern void LYtouchline (int row);
extern void LYwaddnstr (WINDOW *w, const char *s, size_t len);
extern void start_curses (void);
extern void stop_curses (void);
d413 1
a413 1
extern void VMSsignal (int sig, void (*func)());
d417 6
a422 6
extern void curses_css (char * name, int dir);
extern void curses_style (int style, int dir);
extern void setHashStyle (int style, int color, int cattr, int mono, char* element);
extern void setStyle (int style, int color, int cattr, int mono);
extern void wcurses_css (WINDOW * win, char* name, int dir);
extern void curses_w_style (WINDOW* win, int style, int	dir);
d430 3
a432 3
extern void LYaddAttr (int a);
extern void LYsubAttr (int a);
extern void lynx_setup_colors (void);
d474 1
a474 1
extern void LY_SLerase (void);
d503 1
a503 1
extern void LY_SLrefresh (void);
d510 1
a510 1
extern void VTHome (void);
d538 1
a538 1
extern int string_to_attr (char *name);
d546 7
a552 7
extern void LYaddWAttr (WINDOW *win, int a);
extern void LYsubWAttr (WINDOW *win, int a);
extern void LYaddWAttr (WINDOW *win, int a);
extern void LYsubWAttr (WINDOW *win, int a);
extern void lynx_set_color (int a);
extern void lynx_standout  (int a);
extern int  lynx_chg_color (int, int, int);
d668 25
a692 25
extern void lynx_enable_mouse (int);
extern void lynx_force_repaint (void);
extern void lynx_nl2crlf (int normal);
extern void lynx_start_title_color (void);
extern void lynx_stop_title_color (void);
extern void lynx_start_link_color (int flag, int pending);
extern void lynx_stop_link_color (int flag, int pending);
extern void lynx_stop_target_color (void);
extern void lynx_start_target_color (void);
extern void lynx_start_status_color (void);
extern void lynx_stop_status_color (void);
extern void lynx_start_h1_color (void);
extern void lynx_stop_h1_color (void);
extern void lynx_start_prompt_color (void);
extern void lynx_stop_prompt_color (void);
extern void lynx_start_radio_color (void);
extern void lynx_stop_radio_color (void);
extern void lynx_stop_all_colors (void);

extern void lynx_start_bold (void);
extern void lynx_start_reverse (void);
extern void lynx_start_underline (void);
extern void lynx_stop_bold (void);
extern void lynx_stop_reverse (void);
extern void lynx_stop_underline (void);
d724 1
a724 1
extern void LYstowCursor (WINDOW * win, int row, int col);
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d42 1
a42 1
#undef TRUE			/* to prevent parse error :( */
d45 1
a45 1
#undef FALSE			/* to prevent parse error :( */
d53 1
a53 1
    int top_y;
d125 1
a125 1
#undef CR			/* to prevent parse error :( */
d130 1
a130 1
#undef HZ			/* to prevent parse error :( */
d157 1
a157 1
#undef MOUSE_MOVED		/* conflict between PDCURSES and _WIN32 */
d218 1
a218 1
#       undef HAVE_TERM_H	/* only use one in comparable path! */
d235 2
a236 2
#   include <curses.h>		/* everything else */
# endif				/* VMS && __GNUC__ */
d288 1
a288 1
#define LYstopPopup()		/* nothing */
d291 2
a292 3
extern void LYsubwindow(WINDOW * param);
extern WINDOW *LYtopwindow(void);

d296 2
a297 2
extern void LYbox(WINDOW * win, BOOLEAN formfield);
extern WINDOW *LYstartPopup(int top_y, int left_x, int height, int width);
d313 1
a313 2
extern long LYgetattrs(WINDOW * win);

d323 2
a324 2
#define HAVE_GETBKGD 1		/* can use fallback definition */
#define HAVE_NAPMS 1		/* can use millisecond-delays */
d350 2
a351 2
#define BOXVERT 0		/* use alt char set for popup window vertical borders */
#define BOXHORI 0		/* use alt char set for popup window vertical borders */
d355 1
a355 1
#define BOXVERT '*'		/* character for popup window vertical borders */
d358 1
a358 1
#define BOXHORI '*'		/* character for popup window horizontal borders */
d362 1
a362 1
#undef HAVE_KEYPAD		/* avoid confusion with bogus 'keypad()' */
d365 2
a366 2
extern int LYlines;		/* replaces LINES */
extern int LYcols;		/* replaces COLS */
a373 1

d386 16
a401 16
extern BOOLEAN setup(char *terminal);
extern int LYscreenHeight(void);
extern int LYscreenWidth(void);
extern void LYclear(void);
extern void LYclrtoeol(void);
extern void LYerase(void);
extern void LYmove(int y, int x);
extern void LYnoVideo(int mask);
extern void LYpaddstr(WINDOW * w, int width, const char *s);
extern void LYrefresh(void);
extern void LYstartTargetEmphasis(void);
extern void LYstopTargetEmphasis(void);
extern void LYtouchline(int row);
extern void LYwaddnstr(WINDOW * w, const char *s, size_t len);
extern void start_curses(void);
extern void stop_curses(void);
d408 1
a408 1
extern int DCLsystem(char *command);
d413 1
a413 1
extern void VMSsignal(int sig, void (*func) ());
d417 6
a422 7
extern void curses_css(char *name, int dir);
extern void curses_style(int style, int dir);
extern void setHashStyle(int style, int color, int cattr, int mono, char *element);
extern void setStyle(int style, int color, int cattr, int mono);
extern void wcurses_css(WINDOW * win, char *name, int dir);
extern void curses_w_style(WINDOW * win, int style, int dir);

d430 3
a432 3
extern void LYaddAttr(int a);
extern void LYsubAttr(int a);
extern void lynx_setup_colors(void);
a466 1

d474 1
a474 2
extern void LY_SLerase(void);

a498 1

d503 1
a503 2
extern void LY_SLrefresh(void);

d510 1
a510 2
extern void VTHome(void);

d538 1
a538 1
extern int string_to_attr(char *name);
d546 7
a552 8
extern void LYaddWAttr(WINDOW * win, int a);
extern void LYsubWAttr(WINDOW * win, int a);
extern void LYaddWAttr(WINDOW * win, int a);
extern void LYsubWAttr(WINDOW * win, int a);
extern void lynx_set_color(int a);
extern void lynx_standout(int a);
extern int lynx_chg_color(int, int, int);

d584 1
a584 1
/* *INDENT-OFF* */
a591 1
/* *INDENT-ON* */
d668 25
a692 25
extern void lynx_enable_mouse(int);
extern void lynx_force_repaint(void);
extern void lynx_nl2crlf(int normal);
extern void lynx_start_title_color(void);
extern void lynx_stop_title_color(void);
extern void lynx_start_link_color(int flag, int pending);
extern void lynx_stop_link_color(int flag, int pending);
extern void lynx_stop_target_color(void);
extern void lynx_start_target_color(void);
extern void lynx_start_status_color(void);
extern void lynx_stop_status_color(void);
extern void lynx_start_h1_color(void);
extern void lynx_stop_h1_color(void);
extern void lynx_start_prompt_color(void);
extern void lynx_stop_prompt_color(void);
extern void lynx_start_radio_color(void);
extern void lynx_stop_radio_color(void);
extern void lynx_stop_all_colors(void);

extern void lynx_start_bold(void);
extern void lynx_start_reverse(void);
extern void lynx_start_underline(void);
extern void lynx_stop_bold(void);
extern void lynx_stop_reverse(void);
extern void lynx_stop_underline(void);
d705 1
a705 1
#define SetOutputMode(mode)	/* nothing */
d711 1
a711 1
#define SetDefaultMode(mode)	/* nothing */
d724 1
a724 1
extern void LYstowCursor(WINDOW * win, int row, int col);
@


1.1.3.6
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d298 1
a298 1
extern WINDOW *LYstartPopup(int *top_y, int *left_x, int *height, int *width);
a369 18
/*
 * The scrollbar, if used, occupies the rightmost column.
 */
#ifdef USE_SCROLLBAR
#define LYbarWidth (LYShowScrollbar ? 1 : 0)
#else
#define LYbarWidth 0
#endif

/*
 * Usable limits for display:
 */
#if defined(FANCY_CURSES) || defined(USE_SLANG)
#define LYcolLimit (LYcols - LYbarWidth)
#else
#define LYcolLimit (LYcols - 1)
#endif

a391 3
extern int LYstrExtent(const char *string, int len, int maxCells);
extern int LYstrExtent2(const char *string, int len);
extern int LYstrCells(const char *string);
d730 1
a730 1
#define LYHideCursor() LYmove((LYlines - 1), (LYcolLimit))
d732 1
a732 1
#define LYHideCursor() LYmove((LYlines - 1), (LYcolLimit - 1))
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a8 21
 * Because we have to configure PDCURSES last, we may get bogus definitions
 * from the system curses library - cancel these now.
 */
#ifdef HAVE_XCURSES

#undef ASSUME_DEFAULT_COLORS
#undef COLOR_CURSES
#undef FANCY_CURSES
#undef HAVE_CBREAK
#undef HAVE_RESIZETERM
#undef HAVE_USE_DEFAULT_COLORS
#undef NCURSES
#undef USE_DEFAULT_COLORS

#define HAVE_CBREAK 1
#define COLOR_CURSES 1
#define FANCY_CURSES 1

#endif

/*
d28 3
a32 61
#undef WINDOW
typedef struct {
    int	top_y;
    int left_x;
    int height;
    int width;
} WINDOW;

/* slang doesn't really do windows... */
#define waddch(w,c)  LYaddch(c)
#define waddstr(w,s) addstr(s)
#define wmove(win, row, col) SLsmg_gotorc((win)->top_y + (row), (win)->left_x + (col));

#ifndef SLSMG_UARROW_CHAR
#define SLSMG_UARROW_CHAR '^'
#endif

#ifndef SLSMG_DARROW_CHAR
#define SLSMG_DARROW_CHAR 'v'
#endif

#ifndef SLSMG_LARROW_CHAR
#define SLSMG_LARROW_CHAR '<'
#endif

#ifndef SLSMG_RARROW_CHAR
#define SLSMG_RARROW_CHAR '>'
#endif

#ifndef SLSMG_CKBRD_CHAR
#define SLSMG_CKBRD_CHAR '#'
#endif

#ifndef SLSMG_BLOCK_CHAR
#define SLSMG_BLOCK_CHAR '#'
#endif

#ifndef ACS_UARROW  
#define ACS_UARROW  SLSMG_UARROW_CHAR
#endif

#ifndef ACS_DARROW
#define ACS_DARROW  SLSMG_DARROW_CHAR
#endif

#ifndef ACS_LARROW
#define ACS_LARROW  SLSMG_LARROW_CHAR
#endif

#ifndef ACS_RARROW
#define ACS_RARROW  SLSMG_RARROW_CHAR
#endif

#ifndef ACS_CKBOARD
#define ACS_CKBOARD SLSMG_CKBRD_CHAR
#endif

#ifndef ACS_BLOCK
#define ACS_BLOCK   SLSMG_BLOCK_CHAR
#endif

a76 17
#if defined(_MSC_VER)
#undef MOUSE_MOVED	/* conflict between PDCURSES and _WIN32 */
#endif /* _MSC_VER */

/*
 * Do this to build with glibc 2.1.3 (apparently it was not used to build a
 * system before release).
 */
#include <signal.h>

#undef CS			/* some BSD versions of curses use this */
#define CS curses_CS		/* ...but we don't */

#ifdef ERR
#undef ERR			/* all versions of curses define this */
#endif

d78 2
a79 2
# ifdef HAVE_NCURSES_NCURSES_H
#   include <ncurses/ncurses.h>
d81 2
a82 2
#  ifdef HAVE_NCURSES_H
#   include <ncurses.h>
d84 2
a85 2
#   ifdef HAVE_CURSESX_H
#    include <cursesX.h>	/* Ultrix */
d87 1
a87 9
#    ifdef HAVE_JCURSES_H
#     include <jcurses.h>	/* sony_news */
#    else
#     ifdef HAVE_XCURSES
#      include <xcurses.h>	/* PDCurses' UNIX port */
#     else
#      include <curses.h>	/* default */
#     endif
#    endif
d96 3
a98 9
# ifdef FANCY_CURSES
#  if defined(NCURSES) && defined(HAVE_NCURSES_TERM_H)
#    include <ncurses/term.h>
#  else
#   if defined(HAVE_TERM_H)
#    include <term.h>
#   endif
#  endif
# endif
d100 4
a103 3
# if defined(NCURSES_VERSION) && defined(HAVE_DEFINE_KEY)
#  define USE_KEYMAPS		1
# endif
d108 2
a109 2
#  else
#   include <curses.h>  /* everything else */
d113 2
a114 33
/*
 * PDCurses' mouse code does nothing in the DJGPP configuration.
 */
#if defined(PDCURSES) && !defined(__DJGPP__) && !defined(HAVE_XCURSES)
#define USE_MOUSE 1
#endif

/*
 * Pick up the native ncurses name:
 */
#if defined(NCURSES_MOUSE_VERSION)
#define USE_MOUSE 1
#endif

/*
 * If we have pads, use them to implement left/right scrolling.
 */
#if defined(HAVE_NEWPAD) && defined(HAVE_PNOUTREFRESH)
#define USE_CURSES_PADS 1
#endif

/*
 * ncurses 1.9.9e won't work for pads, but 4.2 does (1.9.9g doesn't have a
 * convenient ifdef, though it would work).
 */
#if defined(NCURSES_VERSION) && !defined(NCURSES_VERSION_MAJOR)
#undef USE_CURSES_PADS
#endif

#endif /* USE_SLANG */

#ifdef USE_SLANG
#define LYstopPopup() /* nothing */
a115 4
extern void LYsubwindow PARAMS((WINDOW * param));
#define LYstopPopup() LYsubwindow(0)
#endif /* NCURSES */

d117 2
a118 17
extern WINDOW *LYstartPopup PARAMS((int top_y, int left_x, int height, int width));

/*
 * Useful macros not in PDCurses or very old ncurses headers.
 */
#if !defined(HAVE_GETATTRS) && !defined(getattrs)
#define getattrs(win) ((win)->_attrs)
#endif
#if !defined(HAVE_GETBEGX) && !defined(getbegx)
#define getbegx(win) ((win)->_begx)
#endif
#if !defined(HAVE_GETBEGY) && !defined(getbegy)
#define getbegy(win) ((win)->_begy)
#endif
#if !defined(HAVE_GETBKGD) && !defined(getbkgd)
#define getbkgd(win) ((win)->_bkgd)
#endif
a119 3
#if defined(PDCURSES)
#define HAVE_GETBKGD 1	/* can use fallback definition */
#endif
d149 2
a150 20
extern int LYlines;	/* replaces LINES */
extern int LYcols;	/* replaces COLS */

#ifdef USE_CURSES_PADS
extern WINDOW *LYwin;
extern int LYshiftWin;
extern int LYwideLines;
extern int LYtableCols;
extern BOOL LYuseCursesPads;
#else
#define LYwin stdscr
#define LYshiftWin	0
#define LYwideLines	0
#define LYtableCols	0
#endif

#if defined(USE_COLOR_TABLE) || defined(USE_SLANG)
extern int Current_Attr;
extern int Masked_Attr;
#endif
d152 2
a154 9
extern int LYscreenHeight NOPARAMS;
extern int LYscreenWidth NOPARAMS;
extern void LYclear NOPARAMS;
extern void LYclrtoeol NOPARAMS;
extern void LYerase NOPARAMS;
extern void LYmove PARAMS((int y, int x));
extern void LYnoVideo PARAMS((int mask));
extern void LYpaddstr PARAMS((WINDOW *w, int width, CONST char *s));
extern void LYrefresh NOPARAMS;
a156 8
extern void LYtouchline PARAMS((int row));
extern void LYwaddnstr PARAMS((WINDOW *w, CONST char *s, size_t len));
extern void start_curses NOPARAMS;
extern void stop_curses NOPARAMS;

#define LYaddstr(s)      LYwaddnstr(LYwin, s, strlen(s))
#define LYaddnstr(s,len) LYwaddnstr(LYwin, s, len)
#define LYwaddstr(w,s)   LYwaddnstr(w, s, strlen(s))
d170 1
d174 1
a174 3
extern void curses_w_style PARAMS((WINDOW* win, int style, int	dir));
#  define LynxChangeStyle(style,dir) curses_style(style,dir)
#  define LynxWChangeStyle(win,style,dir) curses_w_style(win,style,dir)
d176 2
a177 1
#  define LynxWChangeStyle(win,style,dir)	(void)1
a187 1
#define SHOW_WHEREIS_TARGETS 1
d190 1
a190 1
#define USE_MOUSE              1
d193 1
a193 1
#if !defined(__DJGPP__) && !defined(__CYGWIN__)
d198 2
a199 1
#define SL_LYNX_OVERRIDE_COLOR	2
d215 3
d242 1
a242 6
#define LYaddch(ch)   SLsmg_write_char(ch)
#define addch_raw(ch) do {                                \
                        SLsmg_Char_Type buf;              \
                        buf = (ch) | (Current_Attr << 4); \
                        SLsmg_write_raw (&buf, 1);        \
                      } while (0)
d244 1
a244 1
#define printw        SLsmg_printf
d260 1
a260 1
#define endwin() LYclear(),refresh(),SLsmg_reset_smg(),VTHome()
a267 1
#define SHOW_WHEREIS_TARGETS 1
d287 2
a288 1
#define wstart_reverse(w)	wsetattr(w, _REVERSE)
d290 1
a290 1
#define wstop_reverse(w)	wclrattr(w, _REVERSE)
a293 2
extern int string_to_attr PARAMS((char *name));

d312 4
a315 4
#define LYaddAttr(attr)		LYaddWAttr(LYwin,attr)
#define LYaddWAttr(win,attr)	wattron(win,attr)
#define LYsubAttr(attr)		LYsubWAttr(LYwin,attr)
#define LYsubWAttr(win,attr)	wattroff(win,attr)
a320 4
#ifdef __CYGWIN__	/* 1999/02/25 (Thu) 01:09:45 */
#define start_underline()	/* LYaddAttr(A_BOLD) */
#define stop_underline()	/* LYsubAttr(A_BOLD) */
#else
a322 1
#endif /* __CYGWIN__ */
a332 1

d334 4
a337 4
#define start_reverse()		LYaddWAttr(LYwin, A_DIM)
#define wstart_reverse(w)	LYaddWAttr(w, A_DIM)
#define stop_reverse()		LYsubWAttr(LYwin, A_DIM)
#define wstop_reverse(w)	LYsubWAttr(w, A_DIM)
d340 1
a340 1
#define wstart_reverse(w)	LYaddWAttr(w, A_REVERSE)
d342 1
a342 1
#define wstop_reverse(w)	LYsubWAttr(w, A_REVERSE)
a343 1

a370 21

#ifndef ACS_UARROW  
#define ACS_UARROW  '^'
#endif

#ifndef ACS_DARROW
#define ACS_DARROW  'V'
#endif

#ifndef ACS_LARROW
#define ACS_LARROW '{'
#endif

#ifndef ACS_RARROW
#define ACS_RARROW '}'
#endif

#define LYaddch(ch)		waddch(LYwin, ch)

#define addch_raw(ch)           LYaddch(ch)

d377 1
a377 1
#define LYGetYX(y, x)   getyx(LYwin, y, x)
d379 1
a379 1
#define LYGetYX(y, x)   y = LYwin->_cury, x = LYwin->_curx
a382 10
/*
 * If the screen library allows us to specify "default" color, allow user to 
 * control it.
 */
#if USE_DEFAULT_COLORS
#if USE_SLANG || (HAVE_ASSUME_DEFAULT_COLORS && !defined(USE_COLOR_STYLE))
#define EXP_ASSUMED_COLOR 1
#endif
#endif

a384 1
extern void lynx_nl2crlf PARAMS((int normal));
d409 2
a410 2
#if defined(_WINDOWS) || defined(DJGPP) || defined(__EMX__) || defined(WIN_EX)
#define SetOutputMode(mode) fflush(stdout), setmode(fileno(stdout), mode)
a419 12

/*
 * Very old versions of curses cannot put the cursor on the lower right corner.
 * Adjust our "hidden" cursor position accordingly.
 */
#if defined(FANCY_CURSES) || defined(USE_SLANG)
#define LYHideCursor() LYmove((LYlines - 1), (LYcols - 1))
#else
#define LYHideCursor() LYmove((LYlines - 1), (LYcols - 2))
#endif

extern void LYstowCursor PARAMS((WINDOW * win, int row, int col));
@

