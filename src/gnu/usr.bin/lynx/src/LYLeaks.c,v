head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.45.58;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.16.57;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.34;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.35;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.32;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.24;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.57;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.13;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.49;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.51.13;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@/*
 *	Copyright (c) 1994, University of Kansas, All Rights Reserved
 *
 *	This code will be used only if LY_FIND_LEAKS is defined.
 *
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 *	10-30-97	modified to handle StrAllocCopy() and
 *			  StrAllocCat(). - KW & FM
 */

/*
 *	Disable the overriding of the memory routines for this file.
 */
#define NO_MEMORY_TRACKING

#include <HTUtils.h>
#include <LYexit.h>
#include <LYLeaks.h>
#include <LYUtils.h>
#include <LYGlobalDefs.h>

#ifdef LY_FIND_LEAKS

static AllocationList *ALp_RunTimeAllocations = NULL;

#define LEAK_SUMMARY

#ifdef LEAK_SUMMARY

static long now_allocated = 0;
static long peak_alloced = 0;

static long total_alloced = 0;
static long total_freed = 0;

static long count_mallocs = 0;
static long count_frees = 0;

static void CountMallocs(long size)
{
    ++count_mallocs;
    total_alloced += size;
    now_allocated += size;
    if (peak_alloced < now_allocated)
	peak_alloced = now_allocated;
}

static void CountFrees(long size)
{
    ++count_frees;
    total_freed += size;
    now_allocated -= size;
}

#else
#define CountMallocs() ++count_mallocs
#define CountFrees()		/* nothing */
#endif

/*
 *  Purpose:	Add a new allocation item to the list.
 *  Arguments:		ALp_new The new item to add.
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		Static function made to make code reusable in projects beyond
 *		Lynx (some might ask why not use HTList).
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void AddToList(AllocationList * ALp_new)
{
    /*
     * Just make this the first item in the list.
     */
    ALp_new->ALp_Next = ALp_RunTimeAllocations;
    ALp_RunTimeAllocations = ALp_new;
}

/*
 *  Purpose:	Find the place in the list where vp_find is currently
 *		tracked.
 *  Arguments:		vp_find A pointer to look for in the list.
 *  Return Value:	AllocationList *	Either vp_find's place in the
 *						list or NULL if not found.
 *  Remarks/Portability/Dependencies/Restrictions:
 *		Static function made to make code reusable in projects outside
 *		of Lynx (some might ask why not use HTList).
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static AllocationList *FindInList(void *vp_find)
{
    AllocationList *ALp_find = ALp_RunTimeAllocations;

    /*
     * Go through the list of allocated pointers until end of list or vp_find
     * is found.
     */
    while (ALp_find != NULL) {
	if (ALp_find->vp_Alloced == vp_find) {
	    break;
	}
	ALp_find = ALp_find->ALp_Next;
    }

    return (ALp_find);
}

/*
 *  Purpose:	Remove the specified item from the list.
 *  Arguments:		ALp_del The item to remove from the list.
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		Static function made to make code reusable in projects outside
 *		of Lynx (some might ask why not use HTList).
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void RemoveFromList(AllocationList * ALp_del)
{
    AllocationList *ALp_findbefore = ALp_RunTimeAllocations;

    /*
     * There is one special case, where the item to remove is the first in the
     * list.
     */
    if (ALp_del == ALp_findbefore) {
	ALp_RunTimeAllocations = ALp_del->ALp_Next;
	return;
    }

    /*
     * Loop through checking all of the next values, if a match don't continue. 
     * Always assume the item will be found.
     */
    while (ALp_findbefore->ALp_Next != ALp_del) {
	ALp_findbefore = ALp_findbefore->ALp_Next;
    }

    /*
     * We are one item before the one to get rid of.  Get rid of it.
     */
    ALp_findbefore->ALp_Next = ALp_del->ALp_Next;
}

/*
 * Make the malloc-sequence available for debugging/tracing.
 */
#ifndef LYLeakSequence
long LYLeakSequence(void)
{
    return count_mallocs;
}
#endif

/*
 *  Purpose:	Print a report of all memory left unallocated by
 *		Lynx code or attempted unallocations on
 *		pointers that are not valid and then free
 *		all unfreed memory.
 *  Arguments:		void
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		This function should be registered for execution with the
 *		atexit (stdlib.h) function as the first statement
 *		in main.
 *		All output of this function is sent to the file defined in
 *		the header LYLeaks.h (LEAKAGE_SINK).
 */
void LYLeaks(void)
{
    AllocationList *ALp_head;
    size_t st_total = (size_t) 0;
    FILE *Fp_leakagesink;

    if (LYfind_leaks == FALSE)
	return;

    /*
     * Open the leakage sink to take all the output.  Recreate the file each
     * time.  Do nothing if unable to open the file.
     */
    Fp_leakagesink = LYNewTxtFile(LEAKAGE_SINK);
    if (Fp_leakagesink == NULL) {
	return;
    }

    while (ALp_RunTimeAllocations != NULL) {
	/*
	 * Take the head off of the run time allocation list.
	 */
	ALp_head = ALp_RunTimeAllocations;
	ALp_RunTimeAllocations = ALp_head->ALp_Next;

	/*
	 * Print the type of leak/error.  Free off memory when we no longer
	 * need it.
	 */
	if (ALp_head->vp_Alloced == NULL) {
	    /*
	     * If there is realloc information on the bad request, then it was
	     * a bad pointer value in a realloc statement.
	     */
	    fprintf(Fp_leakagesink, "%s.\n",
		    gettext("Invalid pointer detected."));
	    fprintf(Fp_leakagesink, "%s\t%ld\n",
		    gettext("Sequence:"),
		    ALp_head->st_Sequence);
	    fprintf(Fp_leakagesink, "%s\t%p\n",
		    gettext("Pointer:"), ALp_head->vp_BadRequest);

	    /*
	     * Don't free the bad request, it is an invalid pointer.  If the
	     * free source information is empty, we should check the realloc
	     * information too since it can get passed bad pointer values also.
	     */
	    if (ALp_head->SL_memory.cp_FileName == NULL) {
		fprintf(Fp_leakagesink, "%s\t%s\n",
			gettext("FileName:"),
			ALp_head->SL_realloc.cp_FileName);
		fprintf(Fp_leakagesink, "%s\t%d\n",
			gettext("LineCount:"),
			ALp_head->SL_realloc.ssi_LineNumber);
	    } else {
		fprintf(Fp_leakagesink, "%s\t%s\n",
			gettext("FileName:"),
			ALp_head->SL_memory.cp_FileName);
		fprintf(Fp_leakagesink, "%s\t%d\n",
			gettext("LineCount:"),
			ALp_head->SL_memory.ssi_LineNumber);
	    }
	} else {
	    size_t i_counter;
	    char *value = (char *) (ALp_head->vp_Alloced);

	    /*
	     * Increment the count of total memory lost and then print the
	     * information.
	     */
	    st_total += ALp_head->st_Bytes;

	    fprintf(Fp_leakagesink, "%s\n",
		    gettext("Memory leak detected."));
	    fprintf(Fp_leakagesink, "%s\t%ld\n",
		    gettext("Sequence:"),
		    ALp_head->st_Sequence);
	    fprintf(Fp_leakagesink, "%s\t%p\n",
		    gettext("Pointer:"),
		    ALp_head->vp_Alloced);
	    fprintf(Fp_leakagesink, "%s\t",
		    gettext("Contains:"));
	    for (i_counter = 0;
		 i_counter < ALp_head->st_Bytes &&
		 i_counter < MAX_CONTENT_LENGTH;
		 i_counter++) {
		if (isprint(UCH(value[i_counter]))) {
		    fprintf(Fp_leakagesink, "%c", value[i_counter]);
		} else {
		    fprintf(Fp_leakagesink, "|");
		}
	    }
	    fprintf(Fp_leakagesink, "\n");
	    fprintf(Fp_leakagesink, "%s\t%d\n",
		    gettext("ByteSize:"),
		    (int) (ALp_head->st_Bytes));
	    fprintf(Fp_leakagesink, "%s\t%s\n",
		    gettext("FileName:"),
		    ALp_head->SL_memory.cp_FileName);
	    fprintf(Fp_leakagesink, "%s\t%d\n",
		    gettext("LineCount:"),
		    ALp_head->SL_memory.ssi_LineNumber);
	    /*
	     * Give the last time the pointer was realloced if it happened
	     * also.
	     */
	    if (ALp_head->SL_realloc.cp_FileName != NULL) {
		fprintf(Fp_leakagesink, "%s\t%s\n",
			gettext("realloced:"),
			ALp_head->SL_realloc.cp_FileName);
		fprintf(Fp_leakagesink, "%s\t%d\n",
			gettext("LineCount:"),
			ALp_head->SL_realloc.ssi_LineNumber);
	    }
	    fflush(Fp_leakagesink);
	    FREE(ALp_head->vp_Alloced);
	}

	/*
	 * Create a blank line and release the memory held by the item.
	 */
	fprintf(Fp_leakagesink, "\n");
	FREE(ALp_head);
    }

    /*
     * Give a grand total of the leakage.  Close the output file.
     */
    fprintf(Fp_leakagesink, "%s\t%u\n",
	    gettext("Total memory leakage this run:"),
	    (unsigned) st_total);
#ifdef LEAK_SUMMARY
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Peak allocation"), peak_alloced);
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Bytes allocated"), total_alloced);
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Total mallocs"), count_mallocs);
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Total frees"), count_frees);
#endif
    fclose(Fp_leakagesink);

    HTSYS_purge(LEAKAGE_SINK);
#if defined(NCURSES) && defined(HAVE__NC_FREEALL)
    _nc_freeall();
#endif
}

/*
 *  Purpose:	Capture allocations using malloc (stdlib.h) and track
 *		the information in a list.
 *  Arguments:	st_bytes	The size of the allocation requested
 *				in bytes.
 *		cp_File		The file from which the request for
 *				allocation came from.
 *		ssi_Line	The line number in cp_File where the
 *				allocation request came from.
 *  Return Value:	void *	A pointer to the allocated memory or NULL on
 *				failure as per malloc (stdlib.h)
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If no memory is allocated, then no entry is added to the
 *		allocation list.
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void *LYLeakMalloc(size_t st_bytes, const char *cp_File,
		   const short ssi_Line)
{
    void *vp_malloc;

    if (LYfind_leaks == FALSE)
	return (void *) malloc(st_bytes);

    /*
     * Do the actual allocation.
     */
    vp_malloc = (void *) malloc(st_bytes);
    CountMallocs(st_bytes);

    /*
     * Only on successful allocation do we track any information.
     */
    if (vp_malloc != NULL) {
	/*
	 * Further allocate memory to store the information.  Just return on
	 * failure to allocate more.
	 */
	AllocationList *ALp_new = typecalloc(AllocationList);

	if (ALp_new == NULL) {
	    return (vp_malloc);
	}
	/*
	 * Copy over the relevant information.  There is no need to allocate
	 * more memory for the file name as it is a static string anyhow.
	 */
	ALp_new->st_Sequence = count_mallocs;
	ALp_new->vp_Alloced = vp_malloc;
	ALp_new->st_Bytes = st_bytes;
	ALp_new->SL_memory.cp_FileName = cp_File;
	ALp_new->SL_memory.ssi_LineNumber = ssi_Line;

	/*
	 * Add the new item to the allocation list.
	 */
	AddToList(ALp_new);
    }

    return (vp_malloc);
}

/*
 *  Purpose:	Add information about new allocation to the list,
 *		after a call to malloc or calloc or an equivalent
 *		function which may or may not have already created
 *		a list entry.
 *  Arguments:	vp_malloc	The pointer to newly allocated memory.
 *  Arguments:	st_bytes	The size of the allocation requested
 *				in bytes.
 *		cp_File		The file from which the request for
 *				allocation came from.
 *		ssi_Line	The line number in cp_File where the
 *				allocation request came from.
 *  Return Value:	void *	A pointer to the allocated memory or NULL on
 *				failure.
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If no memory is allocated, then no entry is added to the
 *		allocation list.
 *  Revision History:
 *	1999-02-08	created, modelled after LYLeakMalloc - kw
 */
AllocationList *LYLeak_mark_malloced(void *vp_malloced,
				     size_t st_bytes,
				     const char *cp_File,
				     const short ssi_Line)
{
    AllocationList *ALp_new = NULL;

    if (LYfind_leaks == FALSE)
	return NULL;

    /*
     * The actual allocation has already been done!
     *
     * Only on successful allocation do we track any information.
     */
    if (vp_malloced != NULL) {
	/*
	 * See if there is already an entry.  If so, just update the source
	 * location info.
	 */
	ALp_new = FindInList(vp_malloced);
	if (ALp_new) {
	    ALp_new->SL_memory.cp_FileName = cp_File;
	    ALp_new->SL_memory.ssi_LineNumber = ssi_Line;
	    return (ALp_new);
	}
	/*
	 * Further allocate memory to store the information.  Just return on
	 * failure to allocate more.
	 */
	ALp_new = typecalloc(AllocationList);

	if (ALp_new == NULL) {
	    return (NULL);
	}
	/*
	 * Copy over the relevant information.
	 */
	ALp_new->vp_Alloced = vp_malloced;
	ALp_new->st_Bytes = st_bytes;
	ALp_new->SL_memory.cp_FileName = cp_File;
	ALp_new->SL_memory.ssi_LineNumber = ssi_Line;

	/*
	 * Add the new item to the allocation list.
	 */
	AddToList(ALp_new);
    }

    return (ALp_new);
}

/*
 *  Purpose:	Capture allocations by calloc (stdlib.h) and
 *		save relevant information in a list.
 *  Arguments:	st_number	The number of items to allocate.
 *		st_bytes	The size of each item.
 *		cp_File		The file which wants to allocation.
 *		ssi_Line	The line number in cp_File requesting
 *				the allocation.
 *  Return Value:	void *	The allocated memory, or NULL on failure as
 *				per calloc (stdlib.h)
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If no memory can be allocated, then no entry will be added
 *		to the list.
 *  Revision History:
 *		05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void *LYLeakCalloc(size_t st_number, size_t st_bytes, const char *cp_File,
		   const short ssi_Line)
{
    void *vp_calloc;

    if (LYfind_leaks == FALSE)
	return (void *) calloc(st_number, st_bytes);

    /*
     * Allocate the requested memory.
     */
    vp_calloc = (void *) calloc(st_number, st_bytes);
    CountMallocs(st_bytes);

    /*
     * Only if the allocation was a success do we track information.
     */
    if (vp_calloc != NULL) {
	/*
	 * Allocate memory for the item to be in the list.  If unable, just
	 * return.
	 */
	AllocationList *ALp_new = typecalloc(AllocationList);

	if (ALp_new == NULL) {
	    return (vp_calloc);
	}

	/*
	 * Copy over the relevant information.  There is no need to allocate
	 * memory for the file name as it is a static string anyway.
	 */
	ALp_new->st_Sequence = count_mallocs;
	ALp_new->vp_Alloced = vp_calloc;
	ALp_new->st_Bytes = (st_number * st_bytes);
	ALp_new->SL_memory.cp_FileName = cp_File;
	ALp_new->SL_memory.ssi_LineNumber = ssi_Line;

	/*
	 * Add the item to the allocation list.
	 */
	AddToList(ALp_new);
    }

    return (vp_calloc);
}

/*
 *  Purpose:	Capture any realloc (stdlib.h) calls in order to
 *		properly keep track of our run time allocation
 *		table.
 *  Arguments:	vp_Alloced	The previously allocated block of
 *				memory to resize.  If NULL,
 *				realloc works just like
 *				malloc.
 *		st_newBytes	The new size of the chunk of memory.
 *		cp_File		The file containing the realloc.
 *		ssi_Line	The line containing the realloc in cp_File.
 *  Return Value:	void *	The new pointer value (could be the same) or
 *				NULL if unable to resize (old block
 *				still exists).
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If unable to resize vp_Alloced, then no change in the
 *		allocation list will be made.
 *		If vp_Alloced is an invalid pointer value, the program will
 *		exit after one last entry is added to the allocation list.
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void *LYLeakRealloc(void *vp_Alloced,
		    size_t st_newBytes,
		    const char *cp_File,
		    const short ssi_Line)
{
    void *vp_realloc;
    AllocationList *ALp_renew;

    if (LYfind_leaks == FALSE)
	return (void *) realloc(vp_Alloced, st_newBytes);

    /*
     * If we are asked to resize a NULL pointer, this is just a malloc call.
     */
    if (vp_Alloced == NULL) {
	return (LYLeakMalloc(st_newBytes, cp_File, ssi_Line));
    }

    /*
     * Find the current vp_Alloced block in the list.  If NULL, this is an
     * invalid pointer value.
     */
    ALp_renew = FindInList(vp_Alloced);
    if (ALp_renew == NULL) {
	/*
	 * Track the invalid pointer value and then exit.  If unable to
	 * allocate, just exit.
	 */
	auto AllocationList *ALp_new = typecalloc(AllocationList);

	if (ALp_new == NULL) {
	    exit_immediately(EXIT_FAILURE);
	}

	/*
	 * Set the information up; no need to allocate file name since it is a
	 * static string.
	 */
	ALp_new->vp_Alloced = NULL;
	ALp_new->vp_BadRequest = vp_Alloced;
	ALp_new->SL_realloc.cp_FileName = cp_File;
	ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;

	/*
	 * Add the item to the list.  Exit.
	 */
	AddToList(ALp_new);
	exit_immediately(EXIT_FAILURE);
    }

    /*
     * Perform the resize.  If not NULL, record the information.
     */
    vp_realloc = (void *) realloc(vp_Alloced, st_newBytes);
    CountMallocs(st_newBytes);
    CountFrees(ALp_renew->st_Bytes);

    if (vp_realloc != NULL) {
	ALp_renew->st_Sequence = count_mallocs;
	ALp_renew->vp_Alloced = vp_realloc;
	ALp_renew->st_Bytes = st_newBytes;

	/*
	 * Update the realloc information, too.  No need to allocate file name,
	 * static string.
	 */
	ALp_renew->SL_realloc.cp_FileName = cp_File;
	ALp_renew->SL_realloc.ssi_LineNumber = ssi_Line;
    }

    return (vp_realloc);
}

/*
 *  Purpose:	Add information about reallocated memory to the list,
 *		after a call to realloc or an equivalent
 *		function which has not already created or updated
 *		a list entry.
 *  Arguments:	ALp_old		List entry for previously allocated
 *				block of memory to resize.  If NULL,
 *				mark_realloced works just like
 *				mark_malloced.
 *		vp_realloced	The new pointer, after resizing.
 *		st_newBytes	The new size of the chunk of memory.
 *		cp_File		The file to record.
 *		ssi_Line	The line to record.
 *  Return Value:		Pointer to new or updated list entry
 *				for this memory block.
 *				NULL on allocation error.
 *  Revision History:
 *	1999-02-11	created kw
 */
#if defined(LY_FIND_LEAKS) && defined(LY_FIND_LEAKS_EXTENDED)
static AllocationList *mark_realloced(AllocationList * ALp_old, void *vp_realloced,
				      size_t st_newBytes,
				      const char *cp_File,
				      const short ssi_Line)
{
    /*
     * If there is no list entry for the old allocation, treat this as if a new
     * allocation had happened.
     */
    if (ALp_old == NULL) {
	return (LYLeak_mark_malloced(vp_realloced, st_newBytes, cp_File, ssi_Line));
    }

    /*
     * ALp_old represents the memory block before reallocation.  Assume that if
     * we get here, there isn't yet a list entry for the new, possibly
     * different, address after realloc, that is our list hasn't been updated -
     * so we're going to do that now.
     */

    if (vp_realloced != NULL) {
	ALp_old->vp_Alloced = vp_realloced;
	ALp_old->st_Bytes = st_newBytes;
	ALp_old->SL_realloc.cp_FileName = cp_File;
	ALp_old->SL_realloc.ssi_LineNumber = ssi_Line;
    }

    return (ALp_old);
}
#endif /* not LY_FIND_LEAKS and LY_FIND_LEAKS_EXTENDED */

/*
 *  Purpose:	Capture all requests to free information and also
 *		remove items from the allocation list.
 *  Arguments:	vp_Alloced	The memory to free.
 *		cp_File		The file calling free.
 *		ssi_Line	The line of cp_File calling free.
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If the pointer value is invalid, then an item will be added
 *		to the list and nothing else is done.
 *		I really like the name of this function and one day hope
 *		that Lynx is Leak Free.
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void LYLeakFree(void *vp_Alloced,
		const char *cp_File,
		const short ssi_Line)
{
    AllocationList *ALp_free;

    if (LYfind_leaks == FALSE) {
	free(vp_Alloced);
	return;
    }

    /*
     * Find the pointer in the allocated list.  If not found, bad pointer.  If
     * found, free list item and vp_Allloced.
     */
    ALp_free = FindInList(vp_Alloced);
    if (ALp_free == NULL) {
	/*
	 * Create the final entry before exiting marking this error.  If unable
	 * to allocate more memory just exit.
	 */
	AllocationList *ALp_new = typecalloc(AllocationList);

	if (ALp_new == NULL) {
	    exit_immediately(EXIT_FAILURE);
	}

	/*
	 * Set up the information, no memory need be allocated for the file
	 * name since it is a static string.
	 */
	ALp_new->vp_Alloced = NULL;
	ALp_new->vp_BadRequest = vp_Alloced;
	ALp_new->SL_memory.cp_FileName = cp_File;
	ALp_new->SL_memory.ssi_LineNumber = ssi_Line;

	/*
	 * Add the entry to the list and then return.
	 */
	AddToList(ALp_new);
	return;
    } else {
	/*
	 * Free off the memory.  Take entry out of allocation list.
	 */
	CountFrees(ALp_free->st_Bytes);
	RemoveFromList(ALp_free);
	FREE(ALp_free);
	FREE(vp_Alloced);
    }
}

/*
 *  Allocates a new copy of a string, and returns it.
 *  Tracks allocations by using other LYLeakFoo functions.
 *  Equivalent to HTSACopy in HTUtils.c - KW
 */
char *LYLeakSACopy(char **dest,
		   const char *src,
		   const char *cp_File,
		   const short ssi_Line)
{
    if (src != NULL && src == *dest) {
	CTRACE((tfp,
		"LYLeakSACopy: *dest equals src, contains \"%s\"\n",
		src));
	return *dest;
    }
    if (*dest) {
	LYLeakFree(*dest, cp_File, ssi_Line);
	*dest = NULL;
    }
    if (src) {
	*dest = (char *) LYLeakMalloc(strlen(src) + 1, cp_File, ssi_Line);
	if (*dest == NULL)
	    outofmem(__FILE__, "LYLeakSACopy");
	strcpy(*dest, src);
    }
    return *dest;
}

/*
 *  String Allocate and Concatenate.
 *  Tracks allocations by using other LYLeakFoo functions.
 *  Equivalent to HTSACat in HTUtils.c - KW
 */
char *LYLeakSACat(char **dest,
		  const char *src,
		  const char *cp_File,
		  const short ssi_Line)
{
    if (src && *src) {
	if (src == *dest) {
	    CTRACE((tfp,
		    "LYLeakSACat:  *dest equals src, contains \"%s\"\n",
		    src));
	    return *dest;
	}
	if (*dest) {
	    int length = strlen(*dest);

	    *dest = (char *) LYLeakRealloc(*dest,
					   (length + strlen(src) + 1),
					   cp_File,
					   ssi_Line);
	    if (*dest == NULL)
		outofmem(__FILE__, "LYLeakSACat");
	    strcpy(*dest + length, src);
	} else {
	    *dest = (char *) LYLeakMalloc((strlen(src) + 1),
					  cp_File,
					  ssi_Line);
	    if (*dest == NULL)
		outofmem(__FILE__, "LYLeakSACat");
	    strcpy(*dest, src);
	}
    }
    return *dest;
}

#if defined(LY_FIND_LEAKS) && defined(LY_FIND_LEAKS_EXTENDED)

const char *leak_cp_File_hack = __FILE__;
short leak_ssi_Line_hack = __LINE__;

/*
 * Purpose:	A wrapper around StrAllocVsprintf (the workhorse of
 *		HTSprintf/HTSprintf0, implemented in HTString.c) that
 *		tries to make sure that our allocation list is always
 *		properly updated, whether StrAllocVsprintf itself was
 *		compiled with memory tracking or not (or even a mixture,
 *		like tracking the freeing but not the new allocation).
 *		Some source files can be compiled with LY_FIND_LEAKS_EXTENDED
 *		in effect while others only have LY_FIND_LEAKS in effect,
 *		and as long as HTString.c is complied with memory tracking
 *		(of either kind) string objects allocated by HTSprintf/
 *		HTSprintf0 (or otherwise) can be passed around among them and
 *		manipulated both ways.
 *  Arguments:	dest		As for StrAllocVsprintf.
 *		cp_File		The source file of the caller (i.e. the
 *				caller of HTSprintf/HTSprintf0, hopefully).
 *		ssi_Line	The line of cp_File calling.
 *		inuse,fmt,ap	As for StrAllocVsprintf.
 *  Return Value:	The char pointer to resulting string, as set
 *			by StrAllocVsprintf, or
 *			NULL if dest==0 (wrong use!).
 *  Remarks/Portability/Dependencies/Restrictions:
 *		The price for generality is severe inefficiency: several
 *		list lookups are done to be on the safe side.
 *		We don't get he real allocation size, only a minimum based
 *		on the string length of the result.  So the amount of memory
 *		leakage may get underestimated.
 *		If *dest is an invalid pointer value on entry (i.e. was not
 *		tracked), the program will exit after one last entry is added
 *		to the allocation list.
 *		If StrAllocVsprintf fails to return a valid string via the
 *		indirect string pointer (its first parameter), invalid memory
 *		access will result and the program will probably terminate
 *		with a signal.  This can happen if, on entry, *dest is NULL
 *		and fmt is empty or NULL, so just Don't Do That.
 *  Revision History:
 *	1999-02-11	created kw
 *	1999-10-15	added comments kw
 */
static char *LYLeakSAVsprintf(char **dest,
			      const char *cp_File,
			      const short ssi_Line,
			      size_t inuse,
			      const char *fmt,
			      va_list * ap)
{
    AllocationList *ALp_old;
    void *vp_oldAlloced;

    const char *old_cp_File = __FILE__;
    short old_ssi_Line = __LINE__;

    if (!dest)
	return NULL;

    if (LYfind_leaks == FALSE) {
	StrAllocVsprintf(dest, inuse, fmt, ap);
	return (*dest);
    }

    vp_oldAlloced = *dest;
    if (!vp_oldAlloced) {
	StrAllocVsprintf(dest, inuse, fmt, ap);
	LYLeak_mark_malloced(*dest, strlen(*dest) + 1, cp_File, ssi_Line);
	return (*dest);
    } else {
	void *vp_realloced;

	ALp_old = FindInList(vp_oldAlloced);
	if (ALp_old == NULL) {
	    /*
	     * Track the invalid pointer value and then exit.  If unable to
	     * allocate, just exit.
	     */
	    auto AllocationList *ALp_new = typecalloc(AllocationList);

	    if (ALp_new == NULL) {
		exit_immediately(EXIT_FAILURE);
	    }

	    /*
	     * Set the information up; no need to allocate file name since it
	     * is a static string.
	     */
	    ALp_new->vp_Alloced = NULL;
	    ALp_new->vp_BadRequest = vp_oldAlloced;
	    ALp_new->SL_realloc.cp_FileName = cp_File;
	    ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;

	    /*
	     * Add the item to the list.  Exit.
	     */
	    AddToList(ALp_new);
	    exit_immediately(EXIT_FAILURE);
	}

	old_cp_File = ALp_old->SL_memory.cp_FileName;
	old_ssi_Line = ALp_old->SL_memory.ssi_LineNumber;
	/*
	 * DO THE REAL WORK, by calling StrAllocVsprintf.  If result is not
	 * NULL, record the information.
	 */
	StrAllocVsprintf(dest, inuse, fmt, ap);
	vp_realloced = (void *) *dest;
	if (vp_realloced != NULL) {
	    AllocationList *ALp_new = FindInList(vp_realloced);

	    if (!ALp_new) {
		/* Look up again, list may have changed! - kw */
		ALp_old = FindInList(vp_oldAlloced);
		if (ALp_old == NULL) {
		    LYLeak_mark_malloced(*dest, strlen(*dest) + 1, cp_File, ssi_Line);
		    return (*dest);
		}
		mark_realloced(ALp_old, *dest, strlen(*dest) + 1, cp_File, ssi_Line);
		return (*dest);
	    }
	    if (vp_realloced == vp_oldAlloced) {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
		return (*dest);
	    }
	    /* Look up again, list may have changed! - kw */
	    ALp_old = FindInList(vp_oldAlloced);
	    if (ALp_old == NULL) {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
	    } else {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
	    }
	}
	return (*dest);
    }
}

/* Note: the following may need updating if HTSprintf in HTString.c
 * is changed. - kw */
#ifdef ANSI_VARARGS
static char *LYLeakHTSprintf(char **pstr, const char *fmt,...)
#else
static char *LYLeakHTSprintf(va_alist)
    va_dcl
#endif
{
    char *str;
    size_t inuse = 0;
    va_list ap;

    LYva_start(ap, fmt);
    {
#ifndef ANSI_VARARGS
	char **pstr = va_arg(ap, char **);
	const char *fmt = va_arg(ap, const char *);
#endif
	if (pstr != 0 && *pstr != 0)
	    inuse = strlen(*pstr);
	str = LYLeakSAVsprintf(pstr, leak_cp_File_hack, leak_ssi_Line_hack,
			       inuse, fmt, &ap);
    }
    va_end(ap);
    return str;
}

/* Note: the following may need updating if HTSprintf0 in HTString.c
 * is changed. - kw */
#ifdef ANSI_VARARGS
static char *LYLeakHTSprintf0(char **pstr, const char *fmt,...)
#else
static char *LYLeakHTSprintf0(va_alist)
    va_dcl
#endif
{
    char *str;
    va_list ap;

    LYva_start(ap, fmt);
    {
#ifndef ANSI_VARARGS
	char **pstr = va_arg(ap, char **);
	const char *fmt = va_arg(ap, const char *);
#endif
	str = LYLeakSAVsprintf(pstr, leak_cp_File_hack, leak_ssi_Line_hack,
			       0, fmt, &ap);
    }
    va_end(ap);
    return str;
}

/*
 * HTSprintf and HTSprintf0 will be defined such that they effectively call one
 * of the following two functions that store away a copy to the File & Line
 * info in temporary hack variables, and then call the real function (which is
 * returned here as a function pointer) to the regular HTSprintf/HTSprintf0
 * arguments.  It's probably a bit inefficient, but that shouldn't be
 * noticeable compared to all the time that memory tracking takes up for list
 * traversal.  - kw
 */
HTSprintflike *Get_htsprintf_fn(const char *cp_File,
				const short ssi_Line)
{
    leak_cp_File_hack = cp_File;
    leak_ssi_Line_hack = ssi_Line;
    return &LYLeakHTSprintf;
}

HTSprintflike *Get_htsprintf0_fn(const char *cp_File,
				 const short ssi_Line)
{
    leak_cp_File_hack = cp_File;
    leak_ssi_Line_hack = ssi_Line;
    return &LYLeakHTSprintf0;
}

#endif /* LY_FIND_LEAKS and LY_FIND_LEAKS_EXTENDED */
#else
/* Standard C forbids an empty file */
void no_leak_checking(void);
void no_leak_checking(void)
{
}
#endif /* LY_FIND_LEAKS */
@


1.5
log
@automatic merge of lynx-current
@
text
@d567 1
a567 1
	    exit(EXIT_FAILURE);
d583 1
a583 1
	exit(EXIT_FAILURE);
d699 1
a699 1
	    exit(EXIT_FAILURE);
d877 1
a877 1
		exit(EXIT_FAILURE);
d893 1
a893 1
	    exit(EXIT_FAILURE);
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 9
a10 9
**	Copyright (c) 1994, University of Kansas, All Rights Reserved
**
**	This code will be used only if LY_FIND_LEAKS is defined.
**
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
**	10-30-97	modified to handle StrAllocCopy() and
**			  StrAllocCat(). - KW & FM
*/
d13 2
a14 2
**	Disable the overriding of the memory routines for this file.
*/
d40 1
a40 1
static void CountMallocs (long size)
d49 1
a49 1
static void CountFrees (long size)
d55 1
d58 1
a58 1
#define CountFrees() /* nothing */
d62 10
a71 11
**  Purpose:	Add a new allocation item to the list.
**  Arguments:		ALp_new The new item to add.
**  Return Value:	void
**  Remarks/Portability/Dependencies/Restrictions:
**		Static function made to make code reusable in projects beyond
**		Lynx (some might ask why not use HTList).
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
static void AddToList (
	AllocationList *	ALp_new)
d74 1
a74 1
     *	Just make this the first item in the list.
d81 12
a92 13
**  Purpose:	Find the place in the list where vp_find is currently
**		tracked.
**  Arguments:		vp_find A pointer to look for in the list.
**  Return Value:	AllocationList *	Either vp_find's place in the
**						list or NULL if not found.
**  Remarks/Portability/Dependencies/Restrictions:
**		Static function made to make code reusable in projects outside
**		of Lynx (some might ask why not use HTList).
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
static AllocationList *FindInList (
	void *		vp_find)
d97 2
a98 2
     *	Go through the list of allocated pointers until end of list
     *		or vp_find is found.
d107 1
a107 1
    return(ALp_find);
d111 10
a120 11
**  Purpose:	Remove the specified item from the list.
**  Arguments:		ALp_del The item to remove from the list.
**  Return Value:	void
**  Remarks/Portability/Dependencies/Restrictions:
**		Static function made to make code reusable in projects outside
**		of Lynx (some might ask why not use HTList).
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
static void RemoveFromList (
	AllocationList *	ALp_del)
d125 2
a126 2
     *	There is one special case, where the item to remove is the
     *		first in the list.
d134 2
a135 2
     *	Loop through checking all of the next values, if a match
     *	don't continue.  Always assume the item will be found.
d142 1
a142 2
     *	We are one item before the one to get rid of.
     *	Get rid of it.
d148 1
a148 1
 *  Make the malloc-sequence available for debugging/tracing.
d151 1
a151 1
long LYLeakSequence (void)
d158 14
a171 14
**  Purpose:	Print a report of all memory left unallocated by
**		Lynx code or attempted unallocations on
**		pointers that are not valid and then free
**		all unfreed memory.
**  Arguments:		void
**  Return Value:	void
**  Remarks/Portability/Dependencies/Restrictions:
**		This function should be registered for execution with the
**		atexit (stdlib.h) function as the first statement
**		in main.
**		All output of this function is sent to the file defined in
**		the header LYLeaks.h (LEAKAGE_SINK).
*/
void LYLeaks (void)
d174 1
a174 1
    size_t st_total = (size_t)0;
d181 2
a182 3
     *	Open the leakage sink to take all the output.
     *	Recreate the file each time.
     *	Do nothing if unable to open the file.
d191 1
a191 1
	 *  Take the head off of the run time allocation list.
d197 2
a198 2
	 *  Print the type of leak/error.
	 *  Free off memory when we no longer need it.
d202 2
a203 3
	     *	If there is realloc information on the
	     *	bad request, then it was a bad pointer
	     *	value in a realloc statement.
d214 3
a216 5
	     *	Don't free the bad request, it is an invalid pointer.
	     *	If the free source information is empty, we
	     *	should check the realloc information
	     *	too since it can get passed bad pointer
	     *	values also.
d235 1
a235 1
	    char *value = (char *)(ALp_head->vp_Alloced);
d238 2
a239 2
	     *	Increment the count of total memory lost and
	     *	then print the information.
d265 2
a266 2
				    gettext("ByteSize:"),
				    (int)(ALp_head->st_Bytes));
d268 2
a269 2
				    gettext("FileName:"),
				    ALp_head->SL_memory.cp_FileName);
d271 2
a272 2
				    gettext("LineCount:"),
				    ALp_head->SL_memory.ssi_LineNumber);
d274 2
a275 2
	     *	Give the last time the pointer was realloced
	     *	if it happened also.
d290 1
a290 2
	 *  Create a blank line and release the memory held
	 *  by the item.
d297 1
a297 2
     *	Give a grand total of the leakage.
     *	Close the output file.
d301 1
a301 1
	    (unsigned)st_total);
d317 18
a334 20
**  Purpose:	Capture allocations using malloc (stdlib.h) and track
**		the information in a list.
**  Arguments:	st_bytes	The size of the allocation requested
**				in bytes.
**		cp_File		The file from which the request for
**				allocation came from.
**		ssi_Line	The line number in cp_File where the
**				allocation request came from.
**  Return Value:	void *	A pointer to the allocated memory or NULL on
**				failure as per malloc (stdlib.h)
**  Remarks/Portability/Dependencies/Restrictions:
**		If no memory is allocated, then no entry is added to the
**		allocation list.
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
void *LYLeakMalloc (
	size_t		st_bytes,
	const char *	cp_File,
	const short	ssi_Line)
d339 1
a339 1
	return (void *)malloc(st_bytes);
d342 1
a342 1
     *	Do the actual allocation.
d344 1
a344 1
    vp_malloc = (void *)malloc(st_bytes);
d348 1
a348 1
     *	Only on successful allocation do we track any information.
d352 2
a353 2
	 *  Further allocate memory to store the information.
	 *  Just return on failure to allocate more.
d358 1
a358 1
	    return(vp_malloc);
d361 2
a362 3
	 *  Copy over the relevant information.
	 *  There is no need to allocate more memory for the
	 *  file name as it is a static string anyhow.
d371 1
a371 1
	 *  Add the new item to the allocation list.
d376 1
a376 1
    return(vp_malloc);
d380 23
a402 24
**  Purpose:	Add information about new allocation to the list,
**		after a call to malloc or calloc or an equivalent
**		function which may or may not have already created
**		a list entry.
**  Arguments:	vp_malloc	The pointer to newly allocated memory.
**  Arguments:	st_bytes	The size of the allocation requested
**				in bytes.
**		cp_File		The file from which the request for
**				allocation came from.
**		ssi_Line	The line number in cp_File where the
**				allocation request came from.
**  Return Value:	void *	A pointer to the allocated memory or NULL on
**				failure.
**  Remarks/Portability/Dependencies/Restrictions:
**		If no memory is allocated, then no entry is added to the
**		allocation list.
**  Revision History:
**	1999-02-08	created, modelled after LYLeakMalloc - kw
*/
AllocationList *LYLeak_mark_malloced (
	void *		vp_malloced,
	size_t		st_bytes,
	const char *	cp_File,
	const short	ssi_Line)
d410 1
a410 1
     *	The actual allocation has already been done!
d412 1
a412 1
     *	Only on successful allocation do we track any information.
d416 2
a417 2
	 *  See if there is already an entry.  If so, just
	 *  update the source location info.
d423 1
a423 1
	    return(ALp_new);
d426 2
a427 2
	 *  Further allocate memory to store the information.
	 *  Just return on failure to allocate more.
d432 1
a432 1
	    return(NULL);
d435 1
a435 1
	 *  Copy over the relevant information.
d443 1
a443 1
	 *  Add the new item to the allocation list.
d448 1
a448 1
    return(ALp_new);
d452 17
a468 20
**  Purpose:	Capture allocations by calloc (stdlib.h) and
**		save relevant information in a list.
**  Arguments:	st_number	The number of items to allocate.
**		st_bytes	The size of each item.
**		cp_File		The file which wants to allocation.
**		ssi_Line	The line number in cp_File requesting
**				the allocation.
**  Return Value:	void *	The allocated memory, or NULL on failure as
**				per calloc (stdlib.h)
**  Remarks/Portability/Dependencies/Restrictions:
**		If no memory can be allocated, then no entry will be added
**		to the list.
**  Revision History:
**		05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
void *LYLeakCalloc (
	size_t		st_number,
	size_t		st_bytes,
	const char *	cp_File,
	const short	ssi_Line)
d473 1
a473 1
	return (void *)calloc(st_number, st_bytes);
d476 1
a476 1
     *	Allocate the requested memory.
d478 1
a478 1
    vp_calloc = (void *)calloc(st_number, st_bytes);
d482 1
a482 1
     *	Only if the allocation was a success do we track information.
d486 2
a487 2
	 *  Allocate memory for the item to be in the list.
	 *  If unable, just return.
d492 1
a492 1
		return(vp_calloc);
d496 2
a497 3
	 *  Copy over the relevant information.
	 *  There is no need to allocate memory for the file
	 *  name as it is a static string anyway.
d506 1
a506 1
	 *	Add the item to the allocation list.
d511 1
a511 1
    return(vp_calloc);
d515 25
a539 26
**  Purpose:	Capture any realloc (stdlib.h) calls in order to
**		properly keep track of our run time allocation
**		table.
**  Arguments:	vp_Alloced	The previously allocated block of
**				memory to resize.  If NULL,
**				realloc works just like
**				malloc.
**		st_newBytes	The new size of the chunk of memory.
**		cp_File		The file containing the realloc.
**		ssi_Line	The line containing the realloc in cp_File.
**  Return Value:	void *	The new pointer value (could be the same) or
**				NULL if unable to resize (old block
**				still exists).
**  Remarks/Portability/Dependencies/Restrictions:
**		If unable to resize vp_Alloced, then no change in the
**		allocation list will be made.
**		If vp_Alloced is an invalid pointer value, the program will
**		exit after one last entry is added to the allocation list.
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
void *LYLeakRealloc (
	void *		vp_Alloced,
	size_t		st_newBytes,
	const char *	cp_File,
	const short	ssi_Line)
d545 1
a545 1
	return (void *)realloc(vp_Alloced, st_newBytes);
d548 1
a548 2
     *	If we are asked to resize a NULL pointer, this is just a
     *	malloc call.
d551 1
a551 1
	return(LYLeakMalloc(st_newBytes, cp_File, ssi_Line));
d555 2
a556 2
     *	Find the current vp_Alloced block in the list.
     *	If NULL, this is an invalid pointer value.
d561 2
a562 2
	 *  Track the invalid pointer value and then exit.
	 *  If unable to allocate, just exit.
d571 2
a572 2
	 *  Set the information up; no need to allocate file name
	 *  since it is a static string.
d580 1
a580 2
	 *  Add the item to the list.
	 *  Exit.
d587 1
a587 2
     *	Perform the resize.
     *	If not NULL, record the information.
d589 1
a589 1
    vp_realloc = (void *)realloc(vp_Alloced, st_newBytes);
d599 2
a600 2
	 *  Update the realloc information, too.
	 *  No need to allocate file name, static string.
d606 1
a606 1
    return(vp_realloc);
d610 18
a627 18
**  Purpose:	Add information about reallocated memory to the list,
**		after a call to realloc or an equivalent
**		function which has not already created or updated
**		a list entry.
**  Arguments:	ALp_old		List entry for previously allocated
**				block of memory to resize.  If NULL,
**				mark_realloced works just like
**				mark_malloced.
**		vp_realloced	The new pointer, after resizing.
**		st_newBytes	The new size of the chunk of memory.
**		cp_File		The file to record.
**		ssi_Line	The line to record.
**  Return Value:		Pointer to new or updated list entry
**				for this memory block.
**				NULL on allocation error.
**  Revision History:
**	1999-02-11	created kw
*/
d629 4
a632 6
static AllocationList *mark_realloced (
	AllocationList * ALp_old,
	void *		vp_realloced,
	size_t		st_newBytes,
	const char *	cp_File,
	const short	ssi_Line)
d635 2
a636 2
     *	If there is no list entry for the old allocation, treat this
     *	as if a new allocation had happened.
d639 1
a639 2
	return(LYLeak_mark_malloced(
	    vp_realloced, st_newBytes, cp_File, ssi_Line));
d643 4
a646 5
     *	ALp_old represents the memory block before reallocation.
     *  Assume that if we get here, there isn't yet a list entry
     *  for the new, possibly different, address after realloc,
     *  that is our list hasn't been updated - so we're going to
     *  do that now.
d656 1
a656 1
    return(ALp_old);
d661 17
a677 18
**  Purpose:	Capture all requests to free information and also
**		remove items from the allocation list.
**  Arguments:	vp_Alloced	The memory to free.
**		cp_File		The file calling free.
**		ssi_Line	The line of cp_File calling free.
**  Return Value:	void
**  Remarks/Portability/Dependencies/Restrictions:
**		If the pointer value is invalid, then an item will be added
**		to the list and nothing else is done.
**		I really like the name of this function and one day hope
**		that Lynx is Leak Free.
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
void LYLeakFree (
	void *		vp_Alloced,
	const char *	cp_File,
	const short	ssi_Line)
d687 2
a688 3
     *	Find the pointer in the allocated list.
     *	If not found, bad pointer.
     *	If found, free list item and vp_Allloced.
d693 2
a694 2
	 *  Create the final entry before exiting marking this error.
	 *  If unable to allocate more memory just exit.
d703 2
a704 2
	 *  Set up the information, no memory need be allocated
	 *  for the file name since it is a static string.
d712 1
a712 1
	 *  Add the entry to the list and then return.
d718 1
a718 2
	 *  Free off the memory.
	 *  Take entry out of allocation list.
d728 8
a735 9
**  Allocates a new copy of a string, and returns it.
**  Tracks allocations by using other LYLeakFoo functions.
**  Equivalent to HTSACopy in HTUtils.c - KW
*/
char * LYLeakSACopy (
	char **	dest,
	const char *	src,
	const char *	cp_File,
	const short	ssi_Line)
d739 2
a740 2
	       "LYLeakSACopy: *dest equals src, contains \"%s\"\n",
	       src));
d748 1
a748 1
	*dest = (char *)LYLeakMalloc(strlen(src) + 1, cp_File, ssi_Line);
d751 1
a751 1
	strcpy (*dest, src);
d757 8
a764 9
**  String Allocate and Concatenate.
**  Tracks allocations by using other LYLeakFoo functions.
**  Equivalent to HTSACat in HTUtils.c - KW
*/
char * LYLeakSACat (
	char **	dest,
	const char *	src,
	const char *	cp_File,
	const short	ssi_Line)
d769 2
a770 2
		   "LYLeakSACat:  *dest equals src, contains \"%s\"\n",
		   src));
d775 5
a779 4
	    *dest = (char *)LYLeakRealloc(*dest,
					  (length + strlen(src) + 1),
					  cp_File,
					  ssi_Line);
d782 1
a782 1
	    strcpy (*dest + length, src);
d784 3
a786 3
	    *dest = (char *)LYLeakMalloc((strlen(src) + 1),
					 cp_File,
					 ssi_Line);
d789 1
a789 1
	    strcpy (*dest, src);
d797 1
a797 1
const char * leak_cp_File_hack = __FILE__;
d801 44
a844 45
** Purpose:	A wrapper around StrAllocVsprintf (the workhorse of
**		HTSprintf/HTSprintf0, implemented in HTString.c) that
**		tries to make sure that our allocation list is always
**		properly updated, whether StrAllocVsprintf itself was
**		compiled with memory tracking or not (or even a mixture,
**		like tracking the freeing but not the new allocation).
**		Some source files can be compiled with LY_FIND_LEAKS_EXTENDED
**		in effect while others only have LY_FIND_LEAKS in effect,
**		and as long as HTString.c is complied with memory tracking
**		(of either kind) string objects allocated by HTSprintf/
**		HTSprintf0 (or otherwise) can be passed around among them and
**		manipulated both ways.
**  Arguments:	dest		As for StrAllocVsprintf.
**		cp_File		The source file of the caller (i.e. the
**				caller of HTSprintf/HTSprintf0, hopefully).
**		ssi_Line	The line of cp_File calling.
**		inuse,fmt,ap	As for StrAllocVsprintf.
**  Return Value:	The char pointer to resulting string, as set
**			by StrAllocVsprintf, or
**			NULL if dest==0 (wrong use!).
**  Remarks/Portability/Dependencies/Restrictions:
**		The price for generality is severe inefficiency: several
**		list lookups are done to be on the safe side.
**		We don't get he real allocation size, only a minimum based
**		on the string length of the result.  So the amount of memory
**		leakage may get underestimated.
**		If *dest is an invalid pointer value on entry (i.e. was not
**		tracked), the program will exit after one last entry is added
**		to the allocation list.
**		If StrAllocVsprintf fails to return a valid string via the
**		indirect string pointer (its first parameter), invalid memory
**		access will result and the program will probably terminate
**		with a signal.  This can happen if, on entry, *dest is NULL
**		and fmt is empty or NULL, so just Don't Do That.
**  Revision History:
**	1999-02-11	created kw
**	1999-10-15	added comments kw
*/
static char * LYLeakSAVsprintf (
	char **	dest,
	const char *	cp_File,
	const short	ssi_Line,
	size_t		inuse,
	const char *	fmt,
	va_list *	ap)
d849 1
a849 1
    const char * old_cp_File = __FILE__;
d864 1
a864 1
	return(*dest);
d866 2
a867 1
	void * vp_realloced;
d871 2
a872 2
	     *  Track the invalid pointer value and then exit.
	     *  If unable to allocate, just exit.
d881 2
a882 2
	     *  Set the information up; no need to allocate file name
	     *  since it is a static string.
d890 1
a890 2
	     *  Add the item to the list.
	     *  Exit.
d899 2
a900 2
	 *	DO THE REAL WORK, by calling StrAllocVsprintf.
	 *	If result is not NULL, record the information.
d903 1
a903 1
	vp_realloced = (void *)*dest;
d906 1
d912 1
a912 1
		    return(*dest);
d915 1
a915 1
		return(*dest);
d922 1
a922 1
		return(*dest);
d938 1
a938 1
	return(*dest);
d945 1
a945 1
static char * LYLeakHTSprintf (char **pstr, const char *fmt, ...)
d947 1
a947 1
static char * LYLeakHTSprintf (va_alist)
d954 2
a955 1
    LYva_start(ap,fmt);
d958 2
a959 2
	char **		pstr = va_arg(ap, char **);
	const char *	fmt  = va_arg(ap, const char *);
d973 1
a973 1
static char * LYLeakHTSprintf0 (char **pstr, const char *fmt, ...)
d975 1
a975 1
static char * LYLeakHTSprintf0 (va_alist)
d981 2
a982 1
    LYva_start(ap,fmt);
d985 2
a986 2
	char **		pstr = va_arg(ap, char **);
	const char *	fmt  = va_arg(ap, const char *);
d996 7
a1002 8
 *  HTSprintf and HTSprintf0 will be defined such that they effectively
 *  call one of the following two functions that store away a copy to
 *  the File & Line info in temporary hack variables, and then call
 *  the real function (which is returned here as a function pointer)
 *  to the regular HTSprintf/HTSprintf0 arguments.
 *  It's probably a bit inefficient, but that shouldn't be noticeable
 *  compared to all the time that memory tracking takes up for list
 *  traversal. - kw
d1004 2
a1005 3
HTSprintflike *Get_htsprintf_fn (
	const char *	cp_File,
	const short	ssi_Line)
d1012 2
a1013 3
HTSprintflike *Get_htsprintf0_fn (
	const char *	cp_File,
	const short	ssi_Line)
d1023 4
a1026 2
void no_leak_checking (void);
void no_leak_checking (void) { }
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d25 1
a25 1
PRIVATE AllocationList *ALp_RunTimeAllocations = NULL;
d31 2
a32 2
PRIVATE long now_allocated = 0;
PRIVATE long peak_alloced = 0;
d34 2
a35 2
PRIVATE long total_alloced = 0;
PRIVATE long total_freed = 0;
d37 2
a38 2
PRIVATE long count_mallocs = 0;
PRIVATE long count_frees = 0;
d40 1
a40 1
PRIVATE void CountMallocs ARGS1(long, size)
d49 1
a49 1
PRIVATE void CountFrees ARGS1(long, size)
d70 2
a71 2
PRIVATE void AddToList ARGS1(
	AllocationList *,	ALp_new)
d92 2
a93 2
PRIVATE AllocationList *FindInList ARGS1(
	void *,		vp_find)
d121 2
a122 2
PRIVATE void RemoveFromList ARGS1(
	AllocationList *,	ALp_del)
d153 2
a154 1
PUBLIC long LYLeakSequence NOARGS
d158 1
d174 1
a174 1
PUBLIC void LYLeaks NOARGS
d342 4
a345 4
PUBLIC void *LYLeakMalloc ARGS3(
	size_t,		st_bytes,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d411 5
a415 5
PUBLIC AllocationList *LYLeak_mark_malloced ARGS4(
	void *,		vp_malloced,
	size_t,		st_bytes,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d480 5
a484 5
PUBLIC void *LYLeakCalloc ARGS4(
	size_t,		st_number,
	size_t,		st_bytes,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d553 5
a557 5
PUBLIC void *LYLeakRealloc ARGS4(
	void *,		vp_Alloced,
	size_t,		st_newBytes,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d650 6
a655 6
PRIVATE AllocationList *mark_realloced ARGS5(
	AllocationList *, ALp_old,
	void *,		vp_realloced,
	size_t,		st_newBytes,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d700 4
a703 4
PUBLIC void LYLeakFree ARGS3(
	void *,		vp_Alloced,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d760 5
a764 5
PUBLIC char * LYLeakSACopy ARGS4(
	char **,	dest,
	CONST char *,	src,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d790 5
a794 5
PUBLIC char * LYLeakSACat ARGS4(
	char **,	dest,
	CONST char *,	src,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d826 2
a827 2
PUBLIC CONST char * leak_cp_File_hack = __FILE__;
PUBLIC short leak_ssi_Line_hack = __LINE__;
d868 7
a874 7
PRIVATE char * LYLeakSAVsprintf ARGS6(
	char **,	dest,
	CONST char *,	cp_File,
	CONST short,	ssi_Line,
	size_t,		inuse,
	CONST char *,	fmt,
	va_list *,	ap)
d879 1
a879 1
    CONST char * old_cp_File = __FILE__;
d974 1
a974 1
PRIVATE char * LYLeakHTSprintf (char **pstr, CONST char *fmt, ...)
d976 1
a976 1
PRIVATE char * LYLeakHTSprintf (va_alist)
d987 1
a987 1
	CONST char *	fmt  = va_arg(ap, CONST char *);
d1001 1
a1001 1
PRIVATE char * LYLeakHTSprintf0 (char **pstr, CONST char *fmt, ...)
d1003 1
a1003 1
PRIVATE char * LYLeakHTSprintf0 (va_alist)
d1013 1
a1013 1
	CONST char *	fmt  = va_arg(ap, CONST char *);
d1032 3
a1034 3
PUBLIC HTSprintflike *Get_htsprintf_fn ARGS2(
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d1041 3
a1043 3
PUBLIC HTSprintflike *Get_htsprintf0_fn ARGS2(
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d1053 2
a1054 2
void no_leak_checking NOPARAMS;
void no_leak_checking NOARGS { }
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d5 5
d21 3
d27 130
a156 6
PRIVATE void AddToList PARAMS((
	AllocationList *	ALp_new));
PRIVATE AllocationList *FindInList PARAMS((
	void *			vp_find));
PRIVATE void RemoveFromList PARAMS((
	AllocationList *	ALp_del));
a170 4
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
**	10-30-97	modified to handle StrAllocCopy() and
**			  StrAllocCat(). - KW & FM
d178 3
d210 3
d250 3
d256 1
a256 1
	    fprintf(Fp_leakagesink, "%s:\t",
d262 1
a262 1
		if (isprint(value[i_counter])) {
a268 1
	    FREE(ALp_head->vp_Alloced);
d290 2
d306 1
a306 1
    fprintf(Fp_leakagesink, "\n%s\t%u\n",
d309 6
d318 3
d345 5
d353 2
a354 1
    void *vp_malloc = (void *)malloc(st_bytes);
d364 1
a364 2
	AllocationList *ALp_new =
			(AllocationList *)calloc(1, sizeof(AllocationList));
d374 1
d390 73
d484 5
d492 2
a493 1
    void *vp_calloc = (void *)calloc(st_number, st_bytes);
d503 1
a503 2
	AllocationList *ALp_new =
			(AllocationList *)calloc(1, sizeof(AllocationList));
d514 1
d560 3
d581 1
a581 3
	auto AllocationList *ALp_new =
			     (AllocationList *)calloc(1,
						      sizeof(AllocationList));
d584 1
a584 1
	    exit(-1);
d601 1
a601 1
	exit(-1);
d609 3
d613 1
d629 55
d705 5
d721 1
a721 3
	AllocationList *ALp_new =
			(AllocationList *)calloc(1,
						 sizeof(AllocationList));
d724 1
a724 1
	    exit(-1);
d746 1
d765 1
a765 1
	CTRACE(tfp,
d767 1
a767 1
	       src);
d796 1
a796 1
	    CTRACE(tfp,
d798 1
a798 1
		   src);
d822 5
d828 20
a847 3
**  Purpose:	Add a new allocation item to the list.
**  Arguments:		ALp_new The new item to add.
**  Return Value:	void
d849 13
a861 2
**		Static function made to make code reusable in projects beyond
**		Lynx (some might ask why not use HTList).
d863 2
a864 1
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
d866 7
a872 2
PRIVATE void AddToList ARGS1(
	AllocationList *,	ALp_new)
d874 41
a914 6
    /*
     *	Just make this the first item in the list.
     */
    ALp_new->ALp_Next = ALp_RunTimeAllocations;
    ALp_RunTimeAllocations = ALp_new;
}
d916 7
a922 16
/*
**  Purpose:	Find the place in the list where vp_find is currently
**		tracked.
**  Arguments:		vp_find A pointer to look for in the list.
**  Return Value:	AllocationList *	Either vp_find's place in the
**						list or NULL if not found.
**  Remarks/Portability/Dependencies/Restrictions:
**		Static function made to make code reusable in projects outside
**		of Lynx (some might ask why not use HTList).
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PRIVATE AllocationList *FindInList ARGS1(
	void *,		vp_find)
{
    AllocationList *ALp_find = ALp_RunTimeAllocations;
d924 40
a963 7
    /*
     *	Go through the list of allocated pointers until end of list
     *		or vp_find is found.
     */
    while (ALp_find != NULL) {
	if (ALp_find->vp_Alloced == vp_find) {
	    break;
d965 1
a965 1
	ALp_find = ALp_find->ALp_Next;
d967 1
d969 25
a993 1
    return(ALp_find);
d996 8
a1003 12
/*
**  Purpose:	Remove the specified item from the list.
**  Arguments:		ALp_del The item to remove from the list.
**  Return Value:	void
**  Remarks/Portability/Dependencies/Restrictions:
**		Static function made to make code reusable in projects outside
**		of Lynx (some might ask why not use HTList).
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PRIVATE void RemoveFromList ARGS1(
	AllocationList *,	ALp_del)
d1005 10
a1014 9
    AllocationList *ALp_findbefore = ALp_RunTimeAllocations;

    /*
     *	There is one special case, where the item to remove is the
     *		first in the list.
     */
    if (ALp_del == ALp_findbefore) {
	ALp_RunTimeAllocations = ALp_del->ALp_Next;
	return;
d1016 3
d1020 18
a1037 7
    /*
     *	Loop through checking all of the next values, if a match
     *	don't continue.  Always assume the item will be found.
     */
    while (ALp_findbefore->ALp_Next != ALp_del) {
	ALp_findbefore = ALp_findbefore->ALp_Next;
    }
d1039 7
a1045 5
    /*
     *	We are one item before the one to get rid of.
     *	Get rid of it.
     */
    ALp_findbefore->ALp_Next = ALp_del->ALp_Next;
d1047 7
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 4
a5 9
 *	Copyright (c) 1994, University of Kansas, All Rights Reserved
 *
 *	This code will be used only if LY_FIND_LEAKS is defined.
 *
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 *	10-30-97	modified to handle StrAllocCopy() and
 *			  StrAllocCat(). - KW & FM
 */
d8 2
a9 2
 *	Disable the overriding of the memory routines for this file.
 */
a15 1
#include <LYGlobalDefs.h>
d17 1
a17 1
#ifdef LY_FIND_LEAKS
d19 26
a44 147
static AllocationList *ALp_RunTimeAllocations = NULL;

#define LEAK_SUMMARY

#ifdef LEAK_SUMMARY

static long now_allocated = 0;
static long peak_alloced = 0;

static long total_alloced = 0;
static long total_freed = 0;

static long count_mallocs = 0;
static long count_frees = 0;

static void CountMallocs(long size)
{
    ++count_mallocs;
    total_alloced += size;
    now_allocated += size;
    if (peak_alloced < now_allocated)
	peak_alloced = now_allocated;
}

static void CountFrees(long size)
{
    ++count_frees;
    total_freed += size;
    now_allocated -= size;
}

#else
#define CountMallocs() ++count_mallocs
#define CountFrees()		/* nothing */
#endif

/*
 *  Purpose:	Add a new allocation item to the list.
 *  Arguments:		ALp_new The new item to add.
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		Static function made to make code reusable in projects beyond
 *		Lynx (some might ask why not use HTList).
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void AddToList(AllocationList * ALp_new)
{
    /*
     * Just make this the first item in the list.
     */
    ALp_new->ALp_Next = ALp_RunTimeAllocations;
    ALp_RunTimeAllocations = ALp_new;
}

/*
 *  Purpose:	Find the place in the list where vp_find is currently
 *		tracked.
 *  Arguments:		vp_find A pointer to look for in the list.
 *  Return Value:	AllocationList *	Either vp_find's place in the
 *						list or NULL if not found.
 *  Remarks/Portability/Dependencies/Restrictions:
 *		Static function made to make code reusable in projects outside
 *		of Lynx (some might ask why not use HTList).
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static AllocationList *FindInList(void *vp_find)
{
    AllocationList *ALp_find = ALp_RunTimeAllocations;

    /*
     * Go through the list of allocated pointers until end of list or vp_find
     * is found.
     */
    while (ALp_find != NULL) {
	if (ALp_find->vp_Alloced == vp_find) {
	    break;
	}
	ALp_find = ALp_find->ALp_Next;
    }

    return (ALp_find);
}

/*
 *  Purpose:	Remove the specified item from the list.
 *  Arguments:		ALp_del The item to remove from the list.
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		Static function made to make code reusable in projects outside
 *		of Lynx (some might ask why not use HTList).
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void RemoveFromList(AllocationList * ALp_del)
{
    AllocationList *ALp_findbefore = ALp_RunTimeAllocations;

    /*
     * There is one special case, where the item to remove is the first in the
     * list.
     */
    if (ALp_del == ALp_findbefore) {
	ALp_RunTimeAllocations = ALp_del->ALp_Next;
	return;
    }

    /*
     * Loop through checking all of the next values, if a match don't continue. 
     * Always assume the item will be found.
     */
    while (ALp_findbefore->ALp_Next != ALp_del) {
	ALp_findbefore = ALp_findbefore->ALp_Next;
    }

    /*
     * We are one item before the one to get rid of.  Get rid of it.
     */
    ALp_findbefore->ALp_Next = ALp_del->ALp_Next;
}

/*
 * Make the malloc-sequence available for debugging/tracing.
 */
#ifndef LYLeakSequence
long LYLeakSequence(void)
{
    return count_mallocs;
}
#endif

/*
 *  Purpose:	Print a report of all memory left unallocated by
 *		Lynx code or attempted unallocations on
 *		pointers that are not valid and then free
 *		all unfreed memory.
 *  Arguments:		void
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		This function should be registered for execution with the
 *		atexit (stdlib.h) function as the first statement
 *		in main.
 *		All output of this function is sent to the file defined in
 *		the header LYLeaks.h (LEAKAGE_SINK).
 */
void LYLeaks(void)
d47 1
a47 1
    size_t st_total = (size_t) 0;
a49 3
    if (LYfind_leaks == FALSE)
	return;

d51 3
a53 2
     * Open the leakage sink to take all the output.  Recreate the file each
     * time.  Do nothing if unable to open the file.
d62 1
a62 1
	 * Take the head off of the run time allocation list.
d68 2
a69 2
	 * Print the type of leak/error.  Free off memory when we no longer
	 * need it.
d73 3
a75 2
	     * If there is realloc information on the bad request, then it was
	     * a bad pointer value in a realloc statement.
a78 3
	    fprintf(Fp_leakagesink, "%s\t%ld\n",
		    gettext("Sequence:"),
		    ALp_head->st_Sequence);
d83 5
a87 3
	     * Don't free the bad request, it is an invalid pointer.  If the
	     * free source information is empty, we should check the realloc
	     * information too since it can get passed bad pointer values also.
d106 1
a106 1
	    char *value = (char *) (ALp_head->vp_Alloced);
d109 2
a110 2
	     * Increment the count of total memory lost and then print the
	     * information.
a115 3
	    fprintf(Fp_leakagesink, "%s\t%ld\n",
		    gettext("Sequence:"),
		    ALp_head->st_Sequence);
d119 1
a119 1
	    fprintf(Fp_leakagesink, "%s\t",
d125 1
a125 1
		if (isprint(UCH(value[i_counter]))) {
d132 1
d134 2
a135 2
		    gettext("ByteSize:"),
		    (int) (ALp_head->st_Bytes));
d137 2
a138 2
		    gettext("FileName:"),
		    ALp_head->SL_memory.cp_FileName);
d140 2
a141 2
		    gettext("LineCount:"),
		    ALp_head->SL_memory.ssi_LineNumber);
d143 2
a144 2
	     * Give the last time the pointer was realloced if it happened
	     * also.
a153 2
	    fflush(Fp_leakagesink);
	    FREE(ALp_head->vp_Alloced);
d157 2
a158 1
	 * Create a blank line and release the memory held by the item.
d165 2
a166 1
     * Give a grand total of the leakage.  Close the output file.
d168 1
a168 1
    fprintf(Fp_leakagesink, "%s\t%u\n",
d170 1
a170 7
	    (unsigned) st_total);
#ifdef LEAK_SUMMARY
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Peak allocation"), peak_alloced);
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Bytes allocated"), total_alloced);
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Total mallocs"), count_mallocs);
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Total frees"), count_frees);
#endif
a173 3
#if defined(NCURSES) && defined(HAVE__NC_FREEALL)
    _nc_freeall();
#endif
d177 20
a196 18
 *  Purpose:	Capture allocations using malloc (stdlib.h) and track
 *		the information in a list.
 *  Arguments:	st_bytes	The size of the allocation requested
 *				in bytes.
 *		cp_File		The file from which the request for
 *				allocation came from.
 *		ssi_Line	The line number in cp_File where the
 *				allocation request came from.
 *  Return Value:	void *	A pointer to the allocated memory or NULL on
 *				failure as per malloc (stdlib.h)
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If no memory is allocated, then no entry is added to the
 *		allocation list.
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void *LYLeakMalloc(size_t st_bytes, const char *cp_File,
		   const short ssi_Line)
a197 5
    void *vp_malloc;

    if (LYfind_leaks == FALSE)
	return (void *) malloc(st_bytes);

d199 1
a199 1
     * Do the actual allocation.
d201 1
a201 2
    vp_malloc = (void *) malloc(st_bytes);
    CountMallocs(st_bytes);
d204 1
a204 1
     * Only on successful allocation do we track any information.
d208 2
a209 2
	 * Further allocate memory to store the information.  Just return on
	 * failure to allocate more.
d211 2
a212 1
	AllocationList *ALp_new = typecalloc(AllocationList);
d215 1
a215 1
	    return (vp_malloc);
d218 3
a220 2
	 * Copy over the relevant information.  There is no need to allocate
	 * more memory for the file name as it is a static string anyhow.
a221 1
	ALp_new->st_Sequence = count_mallocs;
d228 1
a228 1
	 * Add the new item to the allocation list.
d233 1
a233 1
    return (vp_malloc);
d237 20
a256 23
 *  Purpose:	Add information about new allocation to the list,
 *		after a call to malloc or calloc or an equivalent
 *		function which may or may not have already created
 *		a list entry.
 *  Arguments:	vp_malloc	The pointer to newly allocated memory.
 *  Arguments:	st_bytes	The size of the allocation requested
 *				in bytes.
 *		cp_File		The file from which the request for
 *				allocation came from.
 *		ssi_Line	The line number in cp_File where the
 *				allocation request came from.
 *  Return Value:	void *	A pointer to the allocated memory or NULL on
 *				failure.
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If no memory is allocated, then no entry is added to the
 *		allocation list.
 *  Revision History:
 *	1999-02-08	created, modelled after LYLeakMalloc - kw
 */
AllocationList *LYLeak_mark_malloced(void *vp_malloced,
				     size_t st_bytes,
				     const char *cp_File,
				     const short ssi_Line)
a257 5
    AllocationList *ALp_new = NULL;

    if (LYfind_leaks == FALSE)
	return NULL;

d259 1
a259 3
     * The actual allocation has already been done!
     *
     * Only on successful allocation do we track any information.
d261 1
a261 66
    if (vp_malloced != NULL) {
	/*
	 * See if there is already an entry.  If so, just update the source
	 * location info.
	 */
	ALp_new = FindInList(vp_malloced);
	if (ALp_new) {
	    ALp_new->SL_memory.cp_FileName = cp_File;
	    ALp_new->SL_memory.ssi_LineNumber = ssi_Line;
	    return (ALp_new);
	}
	/*
	 * Further allocate memory to store the information.  Just return on
	 * failure to allocate more.
	 */
	ALp_new = typecalloc(AllocationList);

	if (ALp_new == NULL) {
	    return (NULL);
	}
	/*
	 * Copy over the relevant information.
	 */
	ALp_new->vp_Alloced = vp_malloced;
	ALp_new->st_Bytes = st_bytes;
	ALp_new->SL_memory.cp_FileName = cp_File;
	ALp_new->SL_memory.ssi_LineNumber = ssi_Line;

	/*
	 * Add the new item to the allocation list.
	 */
	AddToList(ALp_new);
    }

    return (ALp_new);
}

/*
 *  Purpose:	Capture allocations by calloc (stdlib.h) and
 *		save relevant information in a list.
 *  Arguments:	st_number	The number of items to allocate.
 *		st_bytes	The size of each item.
 *		cp_File		The file which wants to allocation.
 *		ssi_Line	The line number in cp_File requesting
 *				the allocation.
 *  Return Value:	void *	The allocated memory, or NULL on failure as
 *				per calloc (stdlib.h)
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If no memory can be allocated, then no entry will be added
 *		to the list.
 *  Revision History:
 *		05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void *LYLeakCalloc(size_t st_number, size_t st_bytes, const char *cp_File,
		   const short ssi_Line)
{
    void *vp_calloc;

    if (LYfind_leaks == FALSE)
	return (void *) calloc(st_number, st_bytes);

    /*
     * Allocate the requested memory.
     */
    vp_calloc = (void *) calloc(st_number, st_bytes);
    CountMallocs(st_bytes);
d264 1
a264 1
     * Only if the allocation was a success do we track information.
d268 2
a269 2
	 * Allocate memory for the item to be in the list.  If unable, just
	 * return.
d271 2
a272 1
	AllocationList *ALp_new = typecalloc(AllocationList);
d275 1
a275 1
	    return (vp_calloc);
d279 3
a281 2
	 * Copy over the relevant information.  There is no need to allocate
	 * memory for the file name as it is a static string anyway.
a282 1
	ALp_new->st_Sequence = count_mallocs;
d289 1
a289 1
	 * Add the item to the allocation list.
d294 1
a294 1
    return (vp_calloc);
d298 26
a323 25
 *  Purpose:	Capture any realloc (stdlib.h) calls in order to
 *		properly keep track of our run time allocation
 *		table.
 *  Arguments:	vp_Alloced	The previously allocated block of
 *				memory to resize.  If NULL,
 *				realloc works just like
 *				malloc.
 *		st_newBytes	The new size of the chunk of memory.
 *		cp_File		The file containing the realloc.
 *		ssi_Line	The line containing the realloc in cp_File.
 *  Return Value:	void *	The new pointer value (could be the same) or
 *				NULL if unable to resize (old block
 *				still exists).
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If unable to resize vp_Alloced, then no change in the
 *		allocation list will be made.
 *		If vp_Alloced is an invalid pointer value, the program will
 *		exit after one last entry is added to the allocation list.
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void *LYLeakRealloc(void *vp_Alloced,
		    size_t st_newBytes,
		    const char *cp_File,
		    const short ssi_Line)
a327 3
    if (LYfind_leaks == FALSE)
	return (void *) realloc(vp_Alloced, st_newBytes);

d329 2
a330 1
     * If we are asked to resize a NULL pointer, this is just a malloc call.
d333 1
a333 1
	return (LYLeakMalloc(st_newBytes, cp_File, ssi_Line));
d337 2
a338 2
     * Find the current vp_Alloced block in the list.  If NULL, this is an
     * invalid pointer value.
d343 2
a344 2
	 * Track the invalid pointer value and then exit.  If unable to
	 * allocate, just exit.
d346 3
a348 1
	auto AllocationList *ALp_new = typecalloc(AllocationList);
d351 1
a351 1
	    exit_immediately(EXIT_FAILURE);
d355 2
a356 2
	 * Set the information up; no need to allocate file name since it is a
	 * static string.
d364 2
a365 1
	 * Add the item to the list.  Exit.
d368 1
a368 1
	exit_immediately(EXIT_FAILURE);
d372 2
a373 1
     * Perform the resize.  If not NULL, record the information.
d375 1
a375 4
    vp_realloc = (void *) realloc(vp_Alloced, st_newBytes);
    CountMallocs(st_newBytes);
    CountFrees(ALp_renew->st_Bytes);

a376 1
	ALp_renew->st_Sequence = count_mallocs;
d381 2
a382 2
	 * Update the realloc information, too.  No need to allocate file name,
	 * static string.
d388 1
a388 51
    return (vp_realloc);
}

/*
 *  Purpose:	Add information about reallocated memory to the list,
 *		after a call to realloc or an equivalent
 *		function which has not already created or updated
 *		a list entry.
 *  Arguments:	ALp_old		List entry for previously allocated
 *				block of memory to resize.  If NULL,
 *				mark_realloced works just like
 *				mark_malloced.
 *		vp_realloced	The new pointer, after resizing.
 *		st_newBytes	The new size of the chunk of memory.
 *		cp_File		The file to record.
 *		ssi_Line	The line to record.
 *  Return Value:		Pointer to new or updated list entry
 *				for this memory block.
 *				NULL on allocation error.
 *  Revision History:
 *	1999-02-11	created kw
 */
#if defined(LY_FIND_LEAKS) && defined(LY_FIND_LEAKS_EXTENDED)
static AllocationList *mark_realloced(AllocationList * ALp_old, void *vp_realloced,
				      size_t st_newBytes,
				      const char *cp_File,
				      const short ssi_Line)
{
    /*
     * If there is no list entry for the old allocation, treat this as if a new
     * allocation had happened.
     */
    if (ALp_old == NULL) {
	return (LYLeak_mark_malloced(vp_realloced, st_newBytes, cp_File, ssi_Line));
    }

    /*
     * ALp_old represents the memory block before reallocation.  Assume that if
     * we get here, there isn't yet a list entry for the new, possibly
     * different, address after realloc, that is our list hasn't been updated -
     * so we're going to do that now.
     */

    if (vp_realloced != NULL) {
	ALp_old->vp_Alloced = vp_realloced;
	ALp_old->st_Bytes = st_newBytes;
	ALp_old->SL_realloc.cp_FileName = cp_File;
	ALp_old->SL_realloc.ssi_LineNumber = ssi_Line;
    }

    return (ALp_old);
a389 1
#endif /* not LY_FIND_LEAKS and LY_FIND_LEAKS_EXTENDED */
d392 18
a409 17
 *  Purpose:	Capture all requests to free information and also
 *		remove items from the allocation list.
 *  Arguments:	vp_Alloced	The memory to free.
 *		cp_File		The file calling free.
 *		ssi_Line	The line of cp_File calling free.
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If the pointer value is invalid, then an item will be added
 *		to the list and nothing else is done.
 *		I really like the name of this function and one day hope
 *		that Lynx is Leak Free.
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void LYLeakFree(void *vp_Alloced,
		const char *cp_File,
		const short ssi_Line)
a412 5
    if (LYfind_leaks == FALSE) {
	free(vp_Alloced);
	return;
    }

d414 3
a416 2
     * Find the pointer in the allocated list.  If not found, bad pointer.  If
     * found, free list item and vp_Allloced.
d421 2
a422 2
	 * Create the final entry before exiting marking this error.  If unable
	 * to allocate more memory just exit.
d424 3
a426 1
	AllocationList *ALp_new = typecalloc(AllocationList);
d429 1
a429 1
	    exit_immediately(EXIT_FAILURE);
d433 2
a434 2
	 * Set up the information, no memory need be allocated for the file
	 * name since it is a static string.
d442 1
a442 1
	 * Add the entry to the list and then return.
d448 2
a449 1
	 * Free off the memory.  Take entry out of allocation list.
a450 1
	CountFrees(ALp_free->st_Bytes);
d458 9
a466 8
 *  Allocates a new copy of a string, and returns it.
 *  Tracks allocations by using other LYLeakFoo functions.
 *  Equivalent to HTSACopy in HTUtils.c - KW
 */
char *LYLeakSACopy(char **dest,
		   const char *src,
		   const char *cp_File,
		   const short ssi_Line)
d469 3
a471 3
	CTRACE((tfp,
		"LYLeakSACopy: *dest equals src, contains \"%s\"\n",
		src));
d479 1
a479 1
	*dest = (char *) LYLeakMalloc(strlen(src) + 1, cp_File, ssi_Line);
d482 1
a482 1
	strcpy(*dest, src);
d488 9
a496 8
 *  String Allocate and Concatenate.
 *  Tracks allocations by using other LYLeakFoo functions.
 *  Equivalent to HTSACat in HTUtils.c - KW
 */
char *LYLeakSACat(char **dest,
		  const char *src,
		  const char *cp_File,
		  const short ssi_Line)
d500 3
a502 3
	    CTRACE((tfp,
		    "LYLeakSACat:  *dest equals src, contains \"%s\"\n",
		    src));
d507 4
a510 5

	    *dest = (char *) LYLeakRealloc(*dest,
					   (length + strlen(src) + 1),
					   cp_File,
					   ssi_Line);
d513 1
a513 1
	    strcpy(*dest + length, src);
d515 3
a517 3
	    *dest = (char *) LYLeakMalloc((strlen(src) + 1),
					  cp_File,
					  ssi_Line);
d520 1
a520 1
	    strcpy(*dest, src);
d526 19
a544 4
#if defined(LY_FIND_LEAKS) && defined(LY_FIND_LEAKS_EXTENDED)

const char *leak_cp_File_hack = __FILE__;
short leak_ssi_Line_hack = __LINE__;
d547 13
a559 44
 * Purpose:	A wrapper around StrAllocVsprintf (the workhorse of
 *		HTSprintf/HTSprintf0, implemented in HTString.c) that
 *		tries to make sure that our allocation list is always
 *		properly updated, whether StrAllocVsprintf itself was
 *		compiled with memory tracking or not (or even a mixture,
 *		like tracking the freeing but not the new allocation).
 *		Some source files can be compiled with LY_FIND_LEAKS_EXTENDED
 *		in effect while others only have LY_FIND_LEAKS in effect,
 *		and as long as HTString.c is complied with memory tracking
 *		(of either kind) string objects allocated by HTSprintf/
 *		HTSprintf0 (or otherwise) can be passed around among them and
 *		manipulated both ways.
 *  Arguments:	dest		As for StrAllocVsprintf.
 *		cp_File		The source file of the caller (i.e. the
 *				caller of HTSprintf/HTSprintf0, hopefully).
 *		ssi_Line	The line of cp_File calling.
 *		inuse,fmt,ap	As for StrAllocVsprintf.
 *  Return Value:	The char pointer to resulting string, as set
 *			by StrAllocVsprintf, or
 *			NULL if dest==0 (wrong use!).
 *  Remarks/Portability/Dependencies/Restrictions:
 *		The price for generality is severe inefficiency: several
 *		list lookups are done to be on the safe side.
 *		We don't get he real allocation size, only a minimum based
 *		on the string length of the result.  So the amount of memory
 *		leakage may get underestimated.
 *		If *dest is an invalid pointer value on entry (i.e. was not
 *		tracked), the program will exit after one last entry is added
 *		to the allocation list.
 *		If StrAllocVsprintf fails to return a valid string via the
 *		indirect string pointer (its first parameter), invalid memory
 *		access will result and the program will probably terminate
 *		with a signal.  This can happen if, on entry, *dest is NULL
 *		and fmt is empty or NULL, so just Don't Do That.
 *  Revision History:
 *	1999-02-11	created kw
 *	1999-10-15	added comments kw
 */
static char *LYLeakSAVsprintf(char **dest,
			      const char *cp_File,
			      const short ssi_Line,
			      size_t inuse,
			      const char *fmt,
			      va_list * ap)
d561 1
a561 2
    AllocationList *ALp_old;
    void *vp_oldAlloced;
d563 7
a569 45
    const char *old_cp_File = __FILE__;
    short old_ssi_Line = __LINE__;

    if (!dest)
	return NULL;

    if (LYfind_leaks == FALSE) {
	StrAllocVsprintf(dest, inuse, fmt, ap);
	return (*dest);
    }

    vp_oldAlloced = *dest;
    if (!vp_oldAlloced) {
	StrAllocVsprintf(dest, inuse, fmt, ap);
	LYLeak_mark_malloced(*dest, strlen(*dest) + 1, cp_File, ssi_Line);
	return (*dest);
    } else {
	void *vp_realloced;

	ALp_old = FindInList(vp_oldAlloced);
	if (ALp_old == NULL) {
	    /*
	     * Track the invalid pointer value and then exit.  If unable to
	     * allocate, just exit.
	     */
	    auto AllocationList *ALp_new = typecalloc(AllocationList);

	    if (ALp_new == NULL) {
		exit_immediately(EXIT_FAILURE);
	    }

	    /*
	     * Set the information up; no need to allocate file name since it
	     * is a static string.
	     */
	    ALp_new->vp_Alloced = NULL;
	    ALp_new->vp_BadRequest = vp_oldAlloced;
	    ALp_new->SL_realloc.cp_FileName = cp_File;
	    ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;

	    /*
	     * Add the item to the list.  Exit.
	     */
	    AddToList(ALp_new);
	    exit_immediately(EXIT_FAILURE);
d571 1
a571 44

	old_cp_File = ALp_old->SL_memory.cp_FileName;
	old_ssi_Line = ALp_old->SL_memory.ssi_LineNumber;
	/*
	 * DO THE REAL WORK, by calling StrAllocVsprintf.  If result is not
	 * NULL, record the information.
	 */
	StrAllocVsprintf(dest, inuse, fmt, ap);
	vp_realloced = (void *) *dest;
	if (vp_realloced != NULL) {
	    AllocationList *ALp_new = FindInList(vp_realloced);

	    if (!ALp_new) {
		/* Look up again, list may have changed! - kw */
		ALp_old = FindInList(vp_oldAlloced);
		if (ALp_old == NULL) {
		    LYLeak_mark_malloced(*dest, strlen(*dest) + 1, cp_File, ssi_Line);
		    return (*dest);
		}
		mark_realloced(ALp_old, *dest, strlen(*dest) + 1, cp_File, ssi_Line);
		return (*dest);
	    }
	    if (vp_realloced == vp_oldAlloced) {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
		return (*dest);
	    }
	    /* Look up again, list may have changed! - kw */
	    ALp_old = FindInList(vp_oldAlloced);
	    if (ALp_old == NULL) {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
	    } else {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
	    }
	}
	return (*dest);
a572 1
}
d574 1
a574 26
/* Note: the following may need updating if HTSprintf in HTString.c
 * is changed. - kw */
#ifdef ANSI_VARARGS
static char *LYLeakHTSprintf(char **pstr, const char *fmt,...)
#else
static char *LYLeakHTSprintf(va_alist)
    va_dcl
#endif
{
    char *str;
    size_t inuse = 0;
    va_list ap;

    LYva_start(ap, fmt);
    {
#ifndef ANSI_VARARGS
	char **pstr = va_arg(ap, char **);
	const char *fmt = va_arg(ap, const char *);
#endif
	if (pstr != 0 && *pstr != 0)
	    inuse = strlen(*pstr);
	str = LYLeakSAVsprintf(pstr, leak_cp_File_hack, leak_ssi_Line_hack,
			       inuse, fmt, &ap);
    }
    va_end(ap);
    return str;
d577 12
a588 8
/* Note: the following may need updating if HTSprintf0 in HTString.c
 * is changed. - kw */
#ifdef ANSI_VARARGS
static char *LYLeakHTSprintf0(char **pstr, const char *fmt,...)
#else
static char *LYLeakHTSprintf0(va_alist)
    va_dcl
#endif
d590 1
a590 2
    char *str;
    va_list ap;
d592 7
a598 8
    LYva_start(ap, fmt);
    {
#ifndef ANSI_VARARGS
	char **pstr = va_arg(ap, char **);
	const char *fmt = va_arg(ap, const char *);
#endif
	str = LYLeakSAVsprintf(pstr, leak_cp_File_hack, leak_ssi_Line_hack,
			       0, fmt, &ap);
a599 3
    va_end(ap);
    return str;
}
d601 7
a607 16
/*
 * HTSprintf and HTSprintf0 will be defined such that they effectively call one
 * of the following two functions that store away a copy to the File & Line
 * info in temporary hack variables, and then call the real function (which is
 * returned here as a function pointer) to the regular HTSprintf/HTSprintf0
 * arguments.  It's probably a bit inefficient, but that shouldn't be
 * noticeable compared to all the time that memory tracking takes up for list
 * traversal.  - kw
 */
HTSprintflike *Get_htsprintf_fn(const char *cp_File,
				const short ssi_Line)
{
    leak_cp_File_hack = cp_File;
    leak_ssi_Line_hack = ssi_Line;
    return &LYLeakHTSprintf;
}
d609 5
a613 14
HTSprintflike *Get_htsprintf0_fn(const char *cp_File,
				 const short ssi_Line)
{
    leak_cp_File_hack = cp_File;
    leak_ssi_Line_hack = ssi_Line;
    return &LYLeakHTSprintf0;
}

#endif /* LY_FIND_LEAKS and LY_FIND_LEAKS_EXTENDED */
#else
/* Standard C forbids an empty file */
void no_leak_checking(void);
void no_leak_checking(void)
{
a614 1
#endif /* LY_FIND_LEAKS */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a4 5
**
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
**	10-30-97	modified to handle StrAllocCopy() and
**			  StrAllocCat(). - KW & FM
a15 3
#include <LYGlobalDefs.h>

#ifdef LY_FIND_LEAKS
d19 6
a24 130
#define LEAK_SUMMARY

#ifdef LEAK_SUMMARY

PRIVATE long now_allocated = 0;
PRIVATE long peak_alloced = 0;

PRIVATE long total_alloced = 0;
PRIVATE long total_freed = 0;

PRIVATE long count_mallocs = 0;
PRIVATE long count_frees = 0;

PRIVATE void CountMallocs ARGS1(long, size)
{
    ++count_mallocs;
    total_alloced += size;
    now_allocated += size;
    if (peak_alloced < now_allocated)
	peak_alloced = now_allocated;
}

PRIVATE void CountFrees ARGS1(long, size)
{
    ++count_frees;
    total_freed += size;
    now_allocated -= size;
}
#else
#define CountMallocs() ++count_mallocs
#define CountFrees() /* nothing */
#endif

/*
**  Purpose:	Add a new allocation item to the list.
**  Arguments:		ALp_new The new item to add.
**  Return Value:	void
**  Remarks/Portability/Dependencies/Restrictions:
**		Static function made to make code reusable in projects beyond
**		Lynx (some might ask why not use HTList).
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PRIVATE void AddToList ARGS1(
	AllocationList *,	ALp_new)
{
    /*
     *	Just make this the first item in the list.
     */
    ALp_new->ALp_Next = ALp_RunTimeAllocations;
    ALp_RunTimeAllocations = ALp_new;
}

/*
**  Purpose:	Find the place in the list where vp_find is currently
**		tracked.
**  Arguments:		vp_find A pointer to look for in the list.
**  Return Value:	AllocationList *	Either vp_find's place in the
**						list or NULL if not found.
**  Remarks/Portability/Dependencies/Restrictions:
**		Static function made to make code reusable in projects outside
**		of Lynx (some might ask why not use HTList).
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PRIVATE AllocationList *FindInList ARGS1(
	void *,		vp_find)
{
    AllocationList *ALp_find = ALp_RunTimeAllocations;

    /*
     *	Go through the list of allocated pointers until end of list
     *		or vp_find is found.
     */
    while (ALp_find != NULL) {
	if (ALp_find->vp_Alloced == vp_find) {
	    break;
	}
	ALp_find = ALp_find->ALp_Next;
    }

    return(ALp_find);
}

/*
**  Purpose:	Remove the specified item from the list.
**  Arguments:		ALp_del The item to remove from the list.
**  Return Value:	void
**  Remarks/Portability/Dependencies/Restrictions:
**		Static function made to make code reusable in projects outside
**		of Lynx (some might ask why not use HTList).
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PRIVATE void RemoveFromList ARGS1(
	AllocationList *,	ALp_del)
{
    AllocationList *ALp_findbefore = ALp_RunTimeAllocations;

    /*
     *	There is one special case, where the item to remove is the
     *		first in the list.
     */
    if (ALp_del == ALp_findbefore) {
	ALp_RunTimeAllocations = ALp_del->ALp_Next;
	return;
    }

    /*
     *	Loop through checking all of the next values, if a match
     *	don't continue.  Always assume the item will be found.
     */
    while (ALp_findbefore->ALp_Next != ALp_del) {
	ALp_findbefore = ALp_findbefore->ALp_Next;
    }

    /*
     *	We are one item before the one to get rid of.
     *	Get rid of it.
     */
    ALp_findbefore->ALp_Next = ALp_del->ALp_Next;
}

/*
 *  Make the malloc-sequence available for debugging/tracing.
 */
PUBLIC long LYLeakSequence NOARGS
{
    return count_mallocs;
}
d39 4
a49 3
    if (LYfind_leaks == FALSE)
	return;

a78 3
	    fprintf(Fp_leakagesink, "%s\t%ld\n",
		    gettext("Sequence:"),
		    ALp_head->st_Sequence);
a115 3
	    fprintf(Fp_leakagesink, "%s\t%ld\n",
		    gettext("Sequence:"),
		    ALp_head->st_Sequence);
d119 1
a119 1
	    fprintf(Fp_leakagesink, "%s\t",
d125 1
a125 1
		if (isprint(UCH(value[i_counter]))) {
d132 1
a153 2
	    fflush(Fp_leakagesink);
	    FREE(ALp_head->vp_Alloced);
d168 1
a168 1
    fprintf(Fp_leakagesink, "%s\t%u\n",
a170 6
#ifdef LEAK_SUMMARY
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Peak allocation"), peak_alloced);
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Bytes allocated"), total_alloced);
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Total mallocs"), count_mallocs);
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Total frees"), count_frees);
#endif
a173 3
#if defined(NCURSES) && defined(HAVE__NC_FREEALL)
    _nc_freeall();
#endif
a197 5
    void *vp_malloc;

    if (LYfind_leaks == FALSE)
	return (void *)malloc(st_bytes);

d201 1
a201 2
    vp_malloc = (void *)malloc(st_bytes);
    CountMallocs(st_bytes);
d211 2
a212 1
	AllocationList *ALp_new = typecalloc(AllocationList);
a221 1
	ALp_new->st_Sequence = count_mallocs;
a236 73
**  Purpose:	Add information about new allocation to the list,
**		after a call to malloc or calloc or an equivalent
**		function which may or may not have already created
**		a list entry.
**  Arguments:	vp_malloc	The pointer to newly allocated memory.
**  Arguments:	st_bytes	The size of the allocation requested
**				in bytes.
**		cp_File		The file from which the request for
**				allocation came from.
**		ssi_Line	The line number in cp_File where the
**				allocation request came from.
**  Return Value:	void *	A pointer to the allocated memory or NULL on
**				failure.
**  Remarks/Portability/Dependencies/Restrictions:
**		If no memory is allocated, then no entry is added to the
**		allocation list.
**  Revision History:
**	1999-02-08	created, modelled after LYLeakMalloc - kw
*/
PUBLIC AllocationList *LYLeak_mark_malloced ARGS4(
	void *,		vp_malloced,
	size_t,		st_bytes,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
{
    AllocationList *ALp_new = NULL;

    if (LYfind_leaks == FALSE)
	return NULL;

    /*
     *	The actual allocation has already been done!
     *
     *	Only on successful allocation do we track any information.
     */
    if (vp_malloced != NULL) {
	/*
	 *  See if there is already an entry.  If so, just
	 *  update the source location info.
	 */
	ALp_new = FindInList(vp_malloced);
	if (ALp_new) {
	    ALp_new->SL_memory.cp_FileName = cp_File;
	    ALp_new->SL_memory.ssi_LineNumber = ssi_Line;
	    return(ALp_new);
	}
	/*
	 *  Further allocate memory to store the information.
	 *  Just return on failure to allocate more.
	 */
	ALp_new = typecalloc(AllocationList);

	if (ALp_new == NULL) {
	    return(NULL);
	}
	/*
	 *  Copy over the relevant information.
	 */
	ALp_new->vp_Alloced = vp_malloced;
	ALp_new->st_Bytes = st_bytes;
	ALp_new->SL_memory.cp_FileName = cp_File;
	ALp_new->SL_memory.ssi_LineNumber = ssi_Line;

	/*
	 *  Add the new item to the allocation list.
	 */
	AddToList(ALp_new);
    }

    return(ALp_new);
}

/*
a257 5
    void *vp_calloc;

    if (LYfind_leaks == FALSE)
	return (void *)calloc(st_number, st_bytes);

d261 1
a261 2
    vp_calloc = (void *)calloc(st_number, st_bytes);
    CountMallocs(st_bytes);
d271 2
a272 1
	AllocationList *ALp_new = typecalloc(AllocationList);
a282 1
	ALp_new->st_Sequence = count_mallocs;
a327 3
    if (LYfind_leaks == FALSE)
	return (void *)realloc(vp_Alloced, st_newBytes);

d346 3
a348 1
	auto AllocationList *ALp_new = typecalloc(AllocationList);
d351 1
a351 1
	    exit(EXIT_FAILURE);
d368 1
a368 1
	exit(EXIT_FAILURE);
a375 3
    CountMallocs(st_newBytes);
    CountFrees(ALp_renew->st_Bytes);

a376 1
	ALp_renew->st_Sequence = count_mallocs;
a391 55
**  Purpose:	Add information about reallocated memory to the list,
**		after a call to realloc or an equivalent
**		function which has not already created or updated
**		a list entry.
**  Arguments:	ALp_old		List entry for previously allocated
**				block of memory to resize.  If NULL,
**				mark_realloced works just like
**				mark_malloced.
**		vp_realloced	The new pointer, after resizing.
**		st_newBytes	The new size of the chunk of memory.
**		cp_File		The file to record.
**		ssi_Line	The line to record.
**  Return Value:		Pointer to new or updated list entry
**				for this memory block.
**				NULL on allocation error.
**  Revision History:
**	1999-02-11	created kw
*/
#if defined(LY_FIND_LEAKS) && defined(LY_FIND_LEAKS_EXTENDED)
PRIVATE AllocationList *mark_realloced ARGS5(
	AllocationList *, ALp_old,
	void *,		vp_realloced,
	size_t,		st_newBytes,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
{
    /*
     *	If there is no list entry for the old allocation, treat this
     *	as if a new allocation had happened.
     */
    if (ALp_old == NULL) {
	return(LYLeak_mark_malloced(
	    vp_realloced, st_newBytes, cp_File, ssi_Line));
    }

    /*
     *	ALp_old represents the memory block before reallocation.
     *  Assume that if we get here, there isn't yet a list entry
     *  for the new, possibly different, address after realloc,
     *  that is our list hasn't been updated - so we're going to
     *  do that now.
     */

    if (vp_realloced != NULL) {
	ALp_old->vp_Alloced = vp_realloced;
	ALp_old->st_Bytes = st_newBytes;
	ALp_old->SL_realloc.cp_FileName = cp_File;
	ALp_old->SL_realloc.ssi_LineNumber = ssi_Line;
    }

    return(ALp_old);
}
#endif /* not LY_FIND_LEAKS and LY_FIND_LEAKS_EXTENDED */

/*
a412 5
    if (LYfind_leaks == FALSE) {
	free(vp_Alloced);
	return;
    }

d424 3
a426 1
	AllocationList *ALp_new = typecalloc(AllocationList);
d429 1
a429 1
	    exit(EXIT_FAILURE);
a450 1
	CountFrees(ALp_free->st_Bytes);
d469 1
a469 1
	CTRACE((tfp,
d471 1
a471 1
	       src));
d500 1
a500 1
	    CTRACE((tfp,
d502 1
a502 1
		   src));
d526 19
a544 4
#if defined(LY_FIND_LEAKS) && defined(LY_FIND_LEAKS_EXTENDED)

PUBLIC CONST char * leak_cp_File_hack = __FILE__;
PUBLIC short leak_ssi_Line_hack = __LINE__;
d547 5
a551 20
** Purpose:	A wrapper around StrAllocVsprintf (the workhorse of
**		HTSprintf/HTSprintf0, implemented in HTString.c) that
**		tries to make sure that our allocation list is always
**		properly updated, whether StrAllocVsprintf itself was
**		compiled with memory tracking or not (or even a mixture,
**		like tracking the freeing but not the new allocation).
**		Some source files can be compiled with LY_FIND_LEAKS_EXTENDED
**		in effect while others only have LY_FIND_LEAKS in effect,
**		and as long as HTString.c is complied with memory tracking
**		(of either kind) string objects allocated by HTSprintf/
**		HTSprintf0 (or otherwise) can be passed around among them and
**		manipulated both ways.
**  Arguments:	dest		As for StrAllocVsprintf.
**		cp_File		The source file of the caller (i.e. the
**				caller of HTSprintf/HTSprintf0, hopefully).
**		ssi_Line	The line of cp_File calling.
**		inuse,fmt,ap	As for StrAllocVsprintf.
**  Return Value:	The char pointer to resulting string, as set
**			by StrAllocVsprintf, or
**			NULL if dest==0 (wrong use!).
d553 2
a554 13
**		The price for generality is severe inefficiency: several
**		list lookups are done to be on the safe side.
**		We don't get he real allocation size, only a minimum based
**		on the string length of the result.  So the amount of memory
**		leakage may get underestimated.
**		If *dest is an invalid pointer value on entry (i.e. was not
**		tracked), the program will exit after one last entry is added
**		to the allocation list.
**		If StrAllocVsprintf fails to return a valid string via the
**		indirect string pointer (its first parameter), invalid memory
**		access will result and the program will probably terminate
**		with a signal.  This can happen if, on entry, *dest is NULL
**		and fmt is empty or NULL, so just Don't Do That.
d556 1
a556 2
**	1999-02-11	created kw
**	1999-10-15	added comments kw
d558 2
a559 7
PRIVATE char * LYLeakSAVsprintf ARGS6(
	char **,	dest,
	CONST char *,	cp_File,
	CONST short,	ssi_Line,
	size_t,		inuse,
	CONST char *,	fmt,
	va_list *,	ap)
d561 1
a561 2
    AllocationList *ALp_old;
    void *vp_oldAlloced;
d563 9
a571 9
    CONST char * old_cp_File = __FILE__;
    short old_ssi_Line = __LINE__;

    if (!dest)
	return NULL;

    if (LYfind_leaks == FALSE) {
	StrAllocVsprintf(dest, inuse, fmt, ap);
	return (*dest);
d574 1
a574 79
    vp_oldAlloced = *dest;
    if (!vp_oldAlloced) {
	StrAllocVsprintf(dest, inuse, fmt, ap);
	LYLeak_mark_malloced(*dest, strlen(*dest) + 1, cp_File, ssi_Line);
	return(*dest);
    } else {
	void * vp_realloced;
	ALp_old = FindInList(vp_oldAlloced);
	if (ALp_old == NULL) {
	    /*
	     *  Track the invalid pointer value and then exit.
	     *  If unable to allocate, just exit.
	     */
	    auto AllocationList *ALp_new = typecalloc(AllocationList);

	    if (ALp_new == NULL) {
		exit(EXIT_FAILURE);
	    }

	    /*
	     *  Set the information up; no need to allocate file name
	     *  since it is a static string.
	     */
	    ALp_new->vp_Alloced = NULL;
	    ALp_new->vp_BadRequest = vp_oldAlloced;
	    ALp_new->SL_realloc.cp_FileName = cp_File;
	    ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;

	    /*
	     *  Add the item to the list.
	     *  Exit.
	     */
	    AddToList(ALp_new);
	    exit(EXIT_FAILURE);
	}

	old_cp_File = ALp_old->SL_memory.cp_FileName;
	old_ssi_Line = ALp_old->SL_memory.ssi_LineNumber;
	/*
	 *	DO THE REAL WORK, by calling StrAllocVsprintf.
	 *	If result is not NULL, record the information.
	 */
	StrAllocVsprintf(dest, inuse, fmt, ap);
	vp_realloced = (void *)*dest;
	if (vp_realloced != NULL) {
	    AllocationList *ALp_new = FindInList(vp_realloced);
	    if (!ALp_new) {
		/* Look up again, list may have changed! - kw */
		ALp_old = FindInList(vp_oldAlloced);
		if (ALp_old == NULL) {
		    LYLeak_mark_malloced(*dest, strlen(*dest) + 1, cp_File, ssi_Line);
		    return(*dest);
		}
		mark_realloced(ALp_old, *dest, strlen(*dest) + 1, cp_File, ssi_Line);
		return(*dest);
	    }
	    if (vp_realloced == vp_oldAlloced) {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
		return(*dest);
	    }
	    /* Look up again, list may have changed! - kw */
	    ALp_old = FindInList(vp_oldAlloced);
	    if (ALp_old == NULL) {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
	    } else {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
	    }
	}
	return(*dest);
    }
d577 12
a588 8
/* Note: the following may need updating if HTSprintf in HTString.c
 * is changed. - kw */
#ifdef ANSI_VARARGS
PRIVATE char * LYLeakHTSprintf (char **pstr, CONST char *fmt, ...)
#else
PRIVATE char * LYLeakHTSprintf (va_alist)
    va_dcl
#endif
d590 9
a598 13
    char *str;
    size_t inuse = 0;
    va_list ap;
    LYva_start(ap,fmt);
    {
#ifndef ANSI_VARARGS
	char **		pstr = va_arg(ap, char **);
	CONST char *	fmt  = va_arg(ap, CONST char *);
#endif
	if (pstr != 0 && *pstr != 0)
	    inuse = strlen(*pstr);
	str = LYLeakSAVsprintf(pstr, leak_cp_File_hack, leak_ssi_Line_hack,
			       inuse, fmt, &ap);
a599 3
    va_end(ap);
    return str;
}
d601 6
a606 19
/* Note: the following may need updating if HTSprintf0 in HTString.c
 * is changed. - kw */
#ifdef ANSI_VARARGS
PRIVATE char * LYLeakHTSprintf0 (char **pstr, CONST char *fmt, ...)
#else
PRIVATE char * LYLeakHTSprintf0 (va_alist)
    va_dcl
#endif
{
    char *str;
    va_list ap;
    LYva_start(ap,fmt);
    {
#ifndef ANSI_VARARGS
	char **		pstr = va_arg(ap, char **);
	CONST char *	fmt  = va_arg(ap, CONST char *);
#endif
	str = LYLeakSAVsprintf(pstr, leak_cp_File_hack, leak_ssi_Line_hack,
			       0, fmt, &ap);
a607 3
    va_end(ap);
    return str;
}
d609 5
a613 17
/*
 *  HTSprintf and HTSprintf0 will be defined such that they effectively
 *  call one of the following two functions that store away a copy to
 *  the File & Line info in temporary hack variables, and then call
 *  the real function (which is returned here as a function pointer)
 *  to the regular HTSprintf/HTSprintf0 arguments.
 *  It's probably a bit inefficient, but that shouldn't be noticeable
 *  compared to all the time that memory tracking takes up for list
 *  traversal. - kw
 */
PUBLIC HTSprintflike *Get_htsprintf_fn ARGS2(
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
{
    leak_cp_File_hack = cp_File;
    leak_ssi_Line_hack = ssi_Line;
    return &LYLeakHTSprintf;
a614 16

PUBLIC HTSprintflike *Get_htsprintf0_fn ARGS2(
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
{
    leak_cp_File_hack = cp_File;
    leak_ssi_Line_hack = ssi_Line;
    return &LYLeakHTSprintf0;
}

#endif /* LY_FIND_LEAKS and LY_FIND_LEAKS_EXTENDED */
#else
/* Standard C forbids an empty file */
void no_leak_checking NOPARAMS;
void no_leak_checking NOARGS { }
#endif /* LY_FIND_LEAKS */
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d25 1
a25 1
static AllocationList *ALp_RunTimeAllocations = NULL;
d31 2
a32 2
static long now_allocated = 0;
static long peak_alloced = 0;
d34 2
a35 2
static long total_alloced = 0;
static long total_freed = 0;
d37 2
a38 2
static long count_mallocs = 0;
static long count_frees = 0;
d40 1
a40 1
static void CountMallocs (long size)
d49 1
a49 1
static void CountFrees (long size)
d70 2
a71 2
static void AddToList (
	AllocationList *	ALp_new)
d92 2
a93 2
static AllocationList *FindInList (
	void *		vp_find)
d121 2
a122 2
static void RemoveFromList (
	AllocationList *	ALp_del)
d153 1
a153 2
#ifndef LYLeakSequence
long LYLeakSequence (void)
a156 1
#endif
d172 1
a172 1
void LYLeaks (void)
d340 4
a343 4
void *LYLeakMalloc (
	size_t		st_bytes,
	const char *	cp_File,
	const short	ssi_Line)
d409 5
a413 5
AllocationList *LYLeak_mark_malloced (
	void *		vp_malloced,
	size_t		st_bytes,
	const char *	cp_File,
	const short	ssi_Line)
d478 5
a482 5
void *LYLeakCalloc (
	size_t		st_number,
	size_t		st_bytes,
	const char *	cp_File,
	const short	ssi_Line)
d551 5
a555 5
void *LYLeakRealloc (
	void *		vp_Alloced,
	size_t		st_newBytes,
	const char *	cp_File,
	const short	ssi_Line)
d648 6
a653 6
static AllocationList *mark_realloced (
	AllocationList * ALp_old,
	void *		vp_realloced,
	size_t		st_newBytes,
	const char *	cp_File,
	const short	ssi_Line)
d698 4
a701 4
void LYLeakFree (
	void *		vp_Alloced,
	const char *	cp_File,
	const short	ssi_Line)
d758 5
a762 5
char * LYLeakSACopy (
	char **	dest,
	const char *	src,
	const char *	cp_File,
	const short	ssi_Line)
d788 5
a792 5
char * LYLeakSACat (
	char **	dest,
	const char *	src,
	const char *	cp_File,
	const short	ssi_Line)
d824 2
a825 2
const char * leak_cp_File_hack = __FILE__;
short leak_ssi_Line_hack = __LINE__;
d866 7
a872 7
static char * LYLeakSAVsprintf (
	char **	dest,
	const char *	cp_File,
	const short	ssi_Line,
	size_t		inuse,
	const char *	fmt,
	va_list *	ap)
d877 1
a877 1
    const char * old_cp_File = __FILE__;
d972 1
a972 1
static char * LYLeakHTSprintf (char **pstr, const char *fmt, ...)
d974 1
a974 1
static char * LYLeakHTSprintf (va_alist)
d985 1
a985 1
	const char *	fmt  = va_arg(ap, const char *);
d999 1
a999 1
static char * LYLeakHTSprintf0 (char **pstr, const char *fmt, ...)
d1001 1
a1001 1
static char * LYLeakHTSprintf0 (va_alist)
d1011 1
a1011 1
	const char *	fmt  = va_arg(ap, const char *);
d1030 3
a1032 3
HTSprintflike *Get_htsprintf_fn (
	const char *	cp_File,
	const short	ssi_Line)
d1039 3
a1041 3
HTSprintflike *Get_htsprintf0_fn (
	const char *	cp_File,
	const short	ssi_Line)
d1051 2
a1052 2
void no_leak_checking (void);
void no_leak_checking (void) { }
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 9
a10 9
 *	Copyright (c) 1994, University of Kansas, All Rights Reserved
 *
 *	This code will be used only if LY_FIND_LEAKS is defined.
 *
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 *	10-30-97	modified to handle StrAllocCopy() and
 *			  StrAllocCat(). - KW & FM
 */
d13 2
a14 2
 *	Disable the overriding of the memory routines for this file.
 */
d40 1
a40 1
static void CountMallocs(long size)
d49 1
a49 1
static void CountFrees(long size)
a54 1

d57 1
a57 1
#define CountFrees()		/* nothing */
d61 11
a71 10
 *  Purpose:	Add a new allocation item to the list.
 *  Arguments:		ALp_new The new item to add.
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		Static function made to make code reusable in projects beyond
 *		Lynx (some might ask why not use HTList).
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void AddToList(AllocationList * ALp_new)
d74 1
a74 1
     * Just make this the first item in the list.
d81 13
a93 12
 *  Purpose:	Find the place in the list where vp_find is currently
 *		tracked.
 *  Arguments:		vp_find A pointer to look for in the list.
 *  Return Value:	AllocationList *	Either vp_find's place in the
 *						list or NULL if not found.
 *  Remarks/Portability/Dependencies/Restrictions:
 *		Static function made to make code reusable in projects outside
 *		of Lynx (some might ask why not use HTList).
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static AllocationList *FindInList(void *vp_find)
d98 2
a99 2
     * Go through the list of allocated pointers until end of list or vp_find
     * is found.
d108 1
a108 1
    return (ALp_find);
d112 11
a122 10
 *  Purpose:	Remove the specified item from the list.
 *  Arguments:		ALp_del The item to remove from the list.
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		Static function made to make code reusable in projects outside
 *		of Lynx (some might ask why not use HTList).
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void RemoveFromList(AllocationList * ALp_del)
d127 2
a128 2
     * There is one special case, where the item to remove is the first in the
     * list.
d136 2
a137 2
     * Loop through checking all of the next values, if a match don't continue. 
     * Always assume the item will be found.
d144 2
a145 1
     * We are one item before the one to get rid of.  Get rid of it.
d151 1
a151 1
 * Make the malloc-sequence available for debugging/tracing.
d154 1
a154 1
long LYLeakSequence(void)
d161 14
a174 14
 *  Purpose:	Print a report of all memory left unallocated by
 *		Lynx code or attempted unallocations on
 *		pointers that are not valid and then free
 *		all unfreed memory.
 *  Arguments:		void
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		This function should be registered for execution with the
 *		atexit (stdlib.h) function as the first statement
 *		in main.
 *		All output of this function is sent to the file defined in
 *		the header LYLeaks.h (LEAKAGE_SINK).
 */
void LYLeaks(void)
d177 1
a177 1
    size_t st_total = (size_t) 0;
d184 3
a186 2
     * Open the leakage sink to take all the output.  Recreate the file each
     * time.  Do nothing if unable to open the file.
d195 1
a195 1
	 * Take the head off of the run time allocation list.
d201 2
a202 2
	 * Print the type of leak/error.  Free off memory when we no longer
	 * need it.
d206 3
a208 2
	     * If there is realloc information on the bad request, then it was
	     * a bad pointer value in a realloc statement.
d219 5
a223 3
	     * Don't free the bad request, it is an invalid pointer.  If the
	     * free source information is empty, we should check the realloc
	     * information too since it can get passed bad pointer values also.
d242 1
a242 1
	    char *value = (char *) (ALp_head->vp_Alloced);
d245 2
a246 2
	     * Increment the count of total memory lost and then print the
	     * information.
d272 2
a273 2
		    gettext("ByteSize:"),
		    (int) (ALp_head->st_Bytes));
d275 2
a276 2
		    gettext("FileName:"),
		    ALp_head->SL_memory.cp_FileName);
d278 2
a279 2
		    gettext("LineCount:"),
		    ALp_head->SL_memory.ssi_LineNumber);
d281 2
a282 2
	     * Give the last time the pointer was realloced if it happened
	     * also.
d297 2
a298 1
	 * Create a blank line and release the memory held by the item.
d305 2
a306 1
     * Give a grand total of the leakage.  Close the output file.
d310 1
a310 1
	    (unsigned) st_total);
d326 20
a345 18
 *  Purpose:	Capture allocations using malloc (stdlib.h) and track
 *		the information in a list.
 *  Arguments:	st_bytes	The size of the allocation requested
 *				in bytes.
 *		cp_File		The file from which the request for
 *				allocation came from.
 *		ssi_Line	The line number in cp_File where the
 *				allocation request came from.
 *  Return Value:	void *	A pointer to the allocated memory or NULL on
 *				failure as per malloc (stdlib.h)
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If no memory is allocated, then no entry is added to the
 *		allocation list.
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void *LYLeakMalloc(size_t st_bytes, const char *cp_File,
		   const short ssi_Line)
d350 1
a350 1
	return (void *) malloc(st_bytes);
d353 1
a353 1
     * Do the actual allocation.
d355 1
a355 1
    vp_malloc = (void *) malloc(st_bytes);
d359 1
a359 1
     * Only on successful allocation do we track any information.
d363 2
a364 2
	 * Further allocate memory to store the information.  Just return on
	 * failure to allocate more.
d369 1
a369 1
	    return (vp_malloc);
d372 3
a374 2
	 * Copy over the relevant information.  There is no need to allocate
	 * more memory for the file name as it is a static string anyhow.
d383 1
a383 1
	 * Add the new item to the allocation list.
d388 1
a388 1
    return (vp_malloc);
d392 24
a415 23
 *  Purpose:	Add information about new allocation to the list,
 *		after a call to malloc or calloc or an equivalent
 *		function which may or may not have already created
 *		a list entry.
 *  Arguments:	vp_malloc	The pointer to newly allocated memory.
 *  Arguments:	st_bytes	The size of the allocation requested
 *				in bytes.
 *		cp_File		The file from which the request for
 *				allocation came from.
 *		ssi_Line	The line number in cp_File where the
 *				allocation request came from.
 *  Return Value:	void *	A pointer to the allocated memory or NULL on
 *				failure.
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If no memory is allocated, then no entry is added to the
 *		allocation list.
 *  Revision History:
 *	1999-02-08	created, modelled after LYLeakMalloc - kw
 */
AllocationList *LYLeak_mark_malloced(void *vp_malloced,
				     size_t st_bytes,
				     const char *cp_File,
				     const short ssi_Line)
d423 1
a423 1
     * The actual allocation has already been done!
d425 1
a425 1
     * Only on successful allocation do we track any information.
d429 2
a430 2
	 * See if there is already an entry.  If so, just update the source
	 * location info.
d436 1
a436 1
	    return (ALp_new);
d439 2
a440 2
	 * Further allocate memory to store the information.  Just return on
	 * failure to allocate more.
d445 1
a445 1
	    return (NULL);
d448 1
a448 1
	 * Copy over the relevant information.
d456 1
a456 1
	 * Add the new item to the allocation list.
d461 1
a461 1
    return (ALp_new);
d465 20
a484 17
 *  Purpose:	Capture allocations by calloc (stdlib.h) and
 *		save relevant information in a list.
 *  Arguments:	st_number	The number of items to allocate.
 *		st_bytes	The size of each item.
 *		cp_File		The file which wants to allocation.
 *		ssi_Line	The line number in cp_File requesting
 *				the allocation.
 *  Return Value:	void *	The allocated memory, or NULL on failure as
 *				per calloc (stdlib.h)
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If no memory can be allocated, then no entry will be added
 *		to the list.
 *  Revision History:
 *		05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void *LYLeakCalloc(size_t st_number, size_t st_bytes, const char *cp_File,
		   const short ssi_Line)
d489 1
a489 1
	return (void *) calloc(st_number, st_bytes);
d492 1
a492 1
     * Allocate the requested memory.
d494 1
a494 1
    vp_calloc = (void *) calloc(st_number, st_bytes);
d498 1
a498 1
     * Only if the allocation was a success do we track information.
d502 2
a503 2
	 * Allocate memory for the item to be in the list.  If unable, just
	 * return.
d508 1
a508 1
	    return (vp_calloc);
d512 3
a514 2
	 * Copy over the relevant information.  There is no need to allocate
	 * memory for the file name as it is a static string anyway.
d523 1
a523 1
	 * Add the item to the allocation list.
d528 1
a528 1
    return (vp_calloc);
d532 26
a557 25
 *  Purpose:	Capture any realloc (stdlib.h) calls in order to
 *		properly keep track of our run time allocation
 *		table.
 *  Arguments:	vp_Alloced	The previously allocated block of
 *				memory to resize.  If NULL,
 *				realloc works just like
 *				malloc.
 *		st_newBytes	The new size of the chunk of memory.
 *		cp_File		The file containing the realloc.
 *		ssi_Line	The line containing the realloc in cp_File.
 *  Return Value:	void *	The new pointer value (could be the same) or
 *				NULL if unable to resize (old block
 *				still exists).
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If unable to resize vp_Alloced, then no change in the
 *		allocation list will be made.
 *		If vp_Alloced is an invalid pointer value, the program will
 *		exit after one last entry is added to the allocation list.
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void *LYLeakRealloc(void *vp_Alloced,
		    size_t st_newBytes,
		    const char *cp_File,
		    const short ssi_Line)
d563 1
a563 1
	return (void *) realloc(vp_Alloced, st_newBytes);
d566 2
a567 1
     * If we are asked to resize a NULL pointer, this is just a malloc call.
d570 1
a570 1
	return (LYLeakMalloc(st_newBytes, cp_File, ssi_Line));
d574 2
a575 2
     * Find the current vp_Alloced block in the list.  If NULL, this is an
     * invalid pointer value.
d580 2
a581 2
	 * Track the invalid pointer value and then exit.  If unable to
	 * allocate, just exit.
d590 2
a591 2
	 * Set the information up; no need to allocate file name since it is a
	 * static string.
d599 2
a600 1
	 * Add the item to the list.  Exit.
d607 2
a608 1
     * Perform the resize.  If not NULL, record the information.
d610 1
a610 1
    vp_realloc = (void *) realloc(vp_Alloced, st_newBytes);
d620 2
a621 2
	 * Update the realloc information, too.  No need to allocate file name,
	 * static string.
d627 1
a627 1
    return (vp_realloc);
d631 18
a648 18
 *  Purpose:	Add information about reallocated memory to the list,
 *		after a call to realloc or an equivalent
 *		function which has not already created or updated
 *		a list entry.
 *  Arguments:	ALp_old		List entry for previously allocated
 *				block of memory to resize.  If NULL,
 *				mark_realloced works just like
 *				mark_malloced.
 *		vp_realloced	The new pointer, after resizing.
 *		st_newBytes	The new size of the chunk of memory.
 *		cp_File		The file to record.
 *		ssi_Line	The line to record.
 *  Return Value:		Pointer to new or updated list entry
 *				for this memory block.
 *				NULL on allocation error.
 *  Revision History:
 *	1999-02-11	created kw
 */
d650 6
a655 4
static AllocationList *mark_realloced(AllocationList * ALp_old, void *vp_realloced,
				      size_t st_newBytes,
				      const char *cp_File,
				      const short ssi_Line)
d658 2
a659 2
     * If there is no list entry for the old allocation, treat this as if a new
     * allocation had happened.
d662 2
a663 1
	return (LYLeak_mark_malloced(vp_realloced, st_newBytes, cp_File, ssi_Line));
d667 5
a671 4
     * ALp_old represents the memory block before reallocation.  Assume that if
     * we get here, there isn't yet a list entry for the new, possibly
     * different, address after realloc, that is our list hasn't been updated -
     * so we're going to do that now.
d681 1
a681 1
    return (ALp_old);
d686 18
a703 17
 *  Purpose:	Capture all requests to free information and also
 *		remove items from the allocation list.
 *  Arguments:	vp_Alloced	The memory to free.
 *		cp_File		The file calling free.
 *		ssi_Line	The line of cp_File calling free.
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If the pointer value is invalid, then an item will be added
 *		to the list and nothing else is done.
 *		I really like the name of this function and one day hope
 *		that Lynx is Leak Free.
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void LYLeakFree(void *vp_Alloced,
		const char *cp_File,
		const short ssi_Line)
d713 3
a715 2
     * Find the pointer in the allocated list.  If not found, bad pointer.  If
     * found, free list item and vp_Allloced.
d720 2
a721 2
	 * Create the final entry before exiting marking this error.  If unable
	 * to allocate more memory just exit.
d730 2
a731 2
	 * Set up the information, no memory need be allocated for the file
	 * name since it is a static string.
d739 1
a739 1
	 * Add the entry to the list and then return.
d745 2
a746 1
	 * Free off the memory.  Take entry out of allocation list.
d756 9
a764 8
 *  Allocates a new copy of a string, and returns it.
 *  Tracks allocations by using other LYLeakFoo functions.
 *  Equivalent to HTSACopy in HTUtils.c - KW
 */
char *LYLeakSACopy(char **dest,
		   const char *src,
		   const char *cp_File,
		   const short ssi_Line)
d768 2
a769 2
		"LYLeakSACopy: *dest equals src, contains \"%s\"\n",
		src));
d777 1
a777 1
	*dest = (char *) LYLeakMalloc(strlen(src) + 1, cp_File, ssi_Line);
d780 1
a780 1
	strcpy(*dest, src);
d786 9
a794 8
 *  String Allocate and Concatenate.
 *  Tracks allocations by using other LYLeakFoo functions.
 *  Equivalent to HTSACat in HTUtils.c - KW
 */
char *LYLeakSACat(char **dest,
		  const char *src,
		  const char *cp_File,
		  const short ssi_Line)
d799 2
a800 2
		    "LYLeakSACat:  *dest equals src, contains \"%s\"\n",
		    src));
d805 4
a808 5

	    *dest = (char *) LYLeakRealloc(*dest,
					   (length + strlen(src) + 1),
					   cp_File,
					   ssi_Line);
d811 1
a811 1
	    strcpy(*dest + length, src);
d813 3
a815 3
	    *dest = (char *) LYLeakMalloc((strlen(src) + 1),
					  cp_File,
					  ssi_Line);
d818 1
a818 1
	    strcpy(*dest, src);
d826 1
a826 1
const char *leak_cp_File_hack = __FILE__;
d830 45
a874 44
 * Purpose:	A wrapper around StrAllocVsprintf (the workhorse of
 *		HTSprintf/HTSprintf0, implemented in HTString.c) that
 *		tries to make sure that our allocation list is always
 *		properly updated, whether StrAllocVsprintf itself was
 *		compiled with memory tracking or not (or even a mixture,
 *		like tracking the freeing but not the new allocation).
 *		Some source files can be compiled with LY_FIND_LEAKS_EXTENDED
 *		in effect while others only have LY_FIND_LEAKS in effect,
 *		and as long as HTString.c is complied with memory tracking
 *		(of either kind) string objects allocated by HTSprintf/
 *		HTSprintf0 (or otherwise) can be passed around among them and
 *		manipulated both ways.
 *  Arguments:	dest		As for StrAllocVsprintf.
 *		cp_File		The source file of the caller (i.e. the
 *				caller of HTSprintf/HTSprintf0, hopefully).
 *		ssi_Line	The line of cp_File calling.
 *		inuse,fmt,ap	As for StrAllocVsprintf.
 *  Return Value:	The char pointer to resulting string, as set
 *			by StrAllocVsprintf, or
 *			NULL if dest==0 (wrong use!).
 *  Remarks/Portability/Dependencies/Restrictions:
 *		The price for generality is severe inefficiency: several
 *		list lookups are done to be on the safe side.
 *		We don't get he real allocation size, only a minimum based
 *		on the string length of the result.  So the amount of memory
 *		leakage may get underestimated.
 *		If *dest is an invalid pointer value on entry (i.e. was not
 *		tracked), the program will exit after one last entry is added
 *		to the allocation list.
 *		If StrAllocVsprintf fails to return a valid string via the
 *		indirect string pointer (its first parameter), invalid memory
 *		access will result and the program will probably terminate
 *		with a signal.  This can happen if, on entry, *dest is NULL
 *		and fmt is empty or NULL, so just Don't Do That.
 *  Revision History:
 *	1999-02-11	created kw
 *	1999-10-15	added comments kw
 */
static char *LYLeakSAVsprintf(char **dest,
			      const char *cp_File,
			      const short ssi_Line,
			      size_t inuse,
			      const char *fmt,
			      va_list * ap)
d879 1
a879 1
    const char *old_cp_File = __FILE__;
d894 1
a894 1
	return (*dest);
d896 1
a896 2
	void *vp_realloced;

d900 2
a901 2
	     * Track the invalid pointer value and then exit.  If unable to
	     * allocate, just exit.
d910 2
a911 2
	     * Set the information up; no need to allocate file name since it
	     * is a static string.
d919 2
a920 1
	     * Add the item to the list.  Exit.
d929 2
a930 2
	 * DO THE REAL WORK, by calling StrAllocVsprintf.  If result is not
	 * NULL, record the information.
d933 1
a933 1
	vp_realloced = (void *) *dest;
a935 1

d941 1
a941 1
		    return (*dest);
d944 1
a944 1
		return (*dest);
d951 1
a951 1
		return (*dest);
d967 1
a967 1
	return (*dest);
d974 1
a974 1
static char *LYLeakHTSprintf(char **pstr, const char *fmt,...)
d976 1
a976 1
static char *LYLeakHTSprintf(va_alist)
d983 1
a983 2

    LYva_start(ap, fmt);
d986 2
a987 2
	char **pstr = va_arg(ap, char **);
	const char *fmt = va_arg(ap, const char *);
d1001 1
a1001 1
static char *LYLeakHTSprintf0(char **pstr, const char *fmt,...)
d1003 1
a1003 1
static char *LYLeakHTSprintf0(va_alist)
d1009 1
a1009 2

    LYva_start(ap, fmt);
d1012 2
a1013 2
	char **pstr = va_arg(ap, char **);
	const char *fmt = va_arg(ap, const char *);
d1023 8
a1030 7
 * HTSprintf and HTSprintf0 will be defined such that they effectively call one
 * of the following two functions that store away a copy to the File & Line
 * info in temporary hack variables, and then call the real function (which is
 * returned here as a function pointer) to the regular HTSprintf/HTSprintf0
 * arguments.  It's probably a bit inefficient, but that shouldn't be
 * noticeable compared to all the time that memory tracking takes up for list
 * traversal.  - kw
d1032 3
a1034 2
HTSprintflike *Get_htsprintf_fn(const char *cp_File,
				const short ssi_Line)
d1041 3
a1043 2
HTSprintflike *Get_htsprintf0_fn(const char *cp_File,
				 const short ssi_Line)
d1053 2
a1054 4
void no_leak_checking(void);
void no_leak_checking(void)
{
}
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d119 1
a119 1
	    fprintf(Fp_leakagesink, "%s\t",
d125 1
a125 1
		if (isprint(UCH(value[i_counter]))) {
d132 1
a153 2
	    fflush(Fp_leakagesink);
	    FREE(ALp_head->vp_Alloced);
d211 2
a212 1
	AllocationList *ALp_new = typecalloc(AllocationList);
a236 69
**  Purpose:	Add information about new allocation to the list,
**		after a call to malloc or calloc or an equivalent
**		function which may or may not have already created
**		a list entry.
**  Arguments:	vp_malloc	The pointer to newly allocate memory.
**  Arguments:	st_bytes	The size of the allocation requested
**				in bytes.
**		cp_File		The file from which the request for
**				allocation came from.
**		ssi_Line	The line number in cp_File where the
**				allocation request came from.
**  Return Value:	void *	A pointer to the allocated memory or NULL on
**				failure.
**  Remarks/Portability/Dependencies/Restrictions:
**		If no memory is allocated, then no entry is added to the
**		allocation list.
**  Revision History:
**	1999-02-08	created, modelled after LYLeakMalloc - kw
*/
PUBLIC AllocationList *LYLeak_mark_malloced ARGS4(
	void *,		vp_malloced,
	size_t,		st_bytes,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
{
    AllocationList *ALp_new = NULL;
    /*
     *	The actual allocation has already been done!
     *
     *	Only on successful allocation do we track any information.
     */
    if (vp_malloced != NULL) {
	/*
	 *  See if there is already an entry.  If so, just
	 *  update the source location info.
	 */
	ALp_new = FindInList(vp_malloced);
	if (ALp_new) {
	    ALp_new->SL_memory.cp_FileName = cp_File;
	    ALp_new->SL_memory.ssi_LineNumber = ssi_Line;
	    return(ALp_new);
	}
	/*
	 *  Further allocate memory to store the information.
	 *  Just return on failure to allocate more.
	 */
	ALp_new = typecalloc(AllocationList);

	if (ALp_new == NULL) {
	    return(NULL);
	}
	/*
	 *  Copy over the relevant information.
	 */
	ALp_new->vp_Alloced = vp_malloced;
	ALp_new->st_Bytes = st_bytes;
	ALp_new->SL_memory.cp_FileName = cp_File;
	ALp_new->SL_memory.ssi_LineNumber = ssi_Line;

	/*
	 *  Add the new item to the allocation list.
	 */
	AddToList(ALp_new);
    }

    return(ALp_new);
}

/*
d271 2
a272 1
	AllocationList *ALp_new = typecalloc(AllocationList);
d346 3
a348 1
	auto AllocationList *ALp_new = typecalloc(AllocationList);
d351 1
a351 1
	    exit(EXIT_FAILURE);
d368 1
a368 1
	exit(EXIT_FAILURE);
a391 55
**  Purpose:	Add information about reallocated memory to the list,
**		after a call to realloc or an equivalent
**		function which has not already created or updated
**		a list entry.
**  Arguments:	ALp_old		List entry for previously allocated
**				block of memory to resize.  If NULL,
**				mark_realloced works just like
**				mark_malloced.
**		vp_realloced	The new pointer, after resizing.
**		st_newBytes	The new size of the chunk of memory.
**		cp_File		The file to record.
**		ssi_Line	The line to record.
**  Return Value:		Pointer to new or updated list entry
**				for this memory block.
**				NULL on allocation error.
**  Revision History:
**	1999-02-11	created kw
*/
#if defined(LY_FIND_LEAKS) && defined(LY_FIND_LEAKS_EXTENDED)
PRIVATE AllocationList *mark_realloced ARGS5(
	AllocationList *, ALp_old,
	void *,		vp_realloced,
	size_t,		st_newBytes,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
{
    /*
     *	If there is no list entry for the old allocation, treat this
     *	as if a new allocation had happened.
     */
    if (ALp_old == NULL) {
	return(LYLeak_mark_malloced(
	    vp_realloced, st_newBytes, cp_File, ssi_Line));
    }

    /*
     *	ALp_old represents the memory block before reallocation.
     *  Assume that if we get here, there isn't yet a list entry
     *  for the new, possibly different, address after realloc,
     *  that is our list hasn't been updated - so we're going to
     *  do that now.
     */

    if (vp_realloced != NULL) {
	ALp_old->vp_Alloced = vp_realloced;
	ALp_old->st_Bytes = st_newBytes;
	ALp_old->SL_realloc.cp_FileName = cp_File;
	ALp_old->SL_realloc.ssi_LineNumber = ssi_Line;
    }

    return(ALp_old);
}
#endif /* not LY_FIND_LEAKS and LY_FIND_LEAKS_EXTENDED */

/*
d424 3
a426 1
	AllocationList *ALp_new = typecalloc(AllocationList);
d429 1
a429 1
	    exit(EXIT_FAILURE);
d469 1
a469 1
	CTRACE((tfp,
d471 1
a471 1
	       src));
d500 1
a500 1
	    CTRACE((tfp,
d502 1
a502 1
		   src));
a524 222

#if defined(LY_FIND_LEAKS) && defined(LY_FIND_LEAKS_EXTENDED)
PUBLIC CONST char * leak_cp_File_hack = __FILE__;
PUBLIC short leak_ssi_Line_hack = __LINE__;

/*
** Purpose:	A wrapper around StrAllocVsprintf (the workhorse of
**		HTSprintf/HTSprintf0, implemented in HTString.c) that
**		tries to make sure that our allocation list is always
**		properly updated, whether StrAllocVsprintf itself was
**		compiled with memory tracking or not (or even a mixture,
**		like tracking the freeing but not the new allocation).
**		Some source files can be compiled with LY_FIND_LEAKS_EXTENDED
**		in effect while others only have LY_FIND_LEAKS in effect,
**		and as long as HTString.c is complied with memory tracking
**		(of either kind) string objects allocated by HTSprintf/
**		HTSprintf0 (or otherwise) can be passed around among them and
**		manipulated both ways.
**  Arguments:	dest		As for StrAllocVsprintf.
**		cp_File		The source file of the caller (i.e. the
**				caller of HTSprintf/HTSprintf0, hopefully).
**		ssi_Line	The line of cp_File calling.
**		inuse,fmt,ap	As for StrAllocVsprintf.
**  Return Value:	The char pointer to resulting string, as set
**			by StrAllocVsprintf, or
**			NULL if dest==0 (wrong use!).
**  Remarks/Portability/Dependencies/Restrictions:
**		The price for generality is severe inefficiency: several
**		list lookups are done to be on the safe side.
**		We don't get he real allocation size, only a minimum based
**		on the string length of the result.  So the amount of memory
**		leakage may get underestimated.
**		If *dest is an invalid pointer value on entry (i.e. was not
**		tracked), the program will exit after one last entry is added
**		to the allocation list.
**		If StrAllocVsprintf fails to return a valid string via the
**		indirect string pointer (its first parameter), invalid memory
**		access will result and the program will probably terminate
**		with a signal.  This can happen if, on entry, *dest is NULL
**		and fmt is empty or NULL, so just Don't Do That.
**  Revision History:
**	1999-02-11	created kw
**	1999-10-15	added comments kw
*/
PRIVATE char * LYLeakSAVsprintf ARGS6(
	char **,	dest,
	CONST char *,	cp_File,
	CONST short,	ssi_Line,
	size_t,		inuse,
	CONST char *,	fmt,
	va_list *,	ap)
{
    AllocationList *ALp_old;
    void *vp_oldAlloced;

    CONST char * old_cp_File = __FILE__;
    short old_ssi_Line = __LINE__;

    if (!dest)
	return NULL;

    vp_oldAlloced = *dest;
    if (!vp_oldAlloced) {
	StrAllocVsprintf(dest, inuse, fmt, ap);
	LYLeak_mark_malloced(*dest, strlen(*dest) + 1, cp_File, ssi_Line);
	return(*dest);
    } else {
	void * vp_realloced;
	ALp_old = FindInList(vp_oldAlloced);
	if (ALp_old == NULL) {
	    /*
	     *  Track the invalid pointer value and then exit.
	     *  If unable to allocate, just exit.
	     */
	    auto AllocationList *ALp_new = typecalloc(AllocationList);

	    if (ALp_new == NULL) {
		exit(EXIT_FAILURE);
	    }

	    /*
	     *  Set the information up; no need to allocate file name
	     *  since it is a static string.
	     */
	    ALp_new->vp_Alloced = NULL;
	    ALp_new->vp_BadRequest = vp_oldAlloced;
	    ALp_new->SL_realloc.cp_FileName = cp_File;
	    ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;

	    /*
	     *  Add the item to the list.
	     *  Exit.
	     */
	    AddToList(ALp_new);
	    exit(EXIT_FAILURE);
	}

	old_cp_File = ALp_old->SL_memory.cp_FileName;
	old_ssi_Line = ALp_old->SL_memory.ssi_LineNumber;
	/*
	 *	DO THE REAL WORK, by calling StrAllocVsprintf.
	 *	If result is not NULL, record the information.
	 */
	StrAllocVsprintf(dest, inuse, fmt, ap);
	vp_realloced = (void *)*dest;
	if (vp_realloced != NULL) {
	    AllocationList *ALp_new = FindInList(vp_realloced);
	    if (!ALp_new) {
		/* Look up again, list may have changed! - kw */
		ALp_old = FindInList(vp_oldAlloced);
		if (ALp_old == NULL) {
		    LYLeak_mark_malloced(*dest, strlen(*dest) + 1, cp_File, ssi_Line);
		    return(*dest);
		}
		mark_realloced(ALp_old, *dest, strlen(*dest) + 1, cp_File, ssi_Line);
		return(*dest);
	    }
	    if (vp_realloced == vp_oldAlloced) {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
		return(*dest);
	    }
	    /* Look up again, list may have changed! - kw */
	    ALp_old = FindInList(vp_oldAlloced);
	    if (ALp_old == NULL) {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
	    } else {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
	    }
	}
	return(*dest);
    }
}

/* Note: the following may need updating if HTSprintf in HTString.c
 * is changed. - kw */
#if ANSI_VARARGS
PRIVATE char * LYLeakHTSprintf (char **pstr, CONST char *fmt, ...)
#else
PRIVATE char * LYLeakHTSprintf (va_alist)
    va_dcl
#endif
{
    char *str;
    size_t inuse = 0;
    va_list ap;
    LYva_start(ap,fmt);
    {
#if !ANSI_VARARGS
	char **		pstr = va_arg(ap, char **);
	CONST char *	fmt  = va_arg(ap, CONST char *);
#endif
	if (pstr != 0 && *pstr != 0)
	    inuse = strlen(*pstr);
	str = LYLeakSAVsprintf(pstr, leak_cp_File_hack, leak_ssi_Line_hack,
			       inuse, fmt, &ap);
    }
    va_end(ap);
    return str;
}

/* Note: the following may need updating if HTSprintf0 in HTString.c
 * is changed. - kw */
#if ANSI_VARARGS
PRIVATE char * LYLeakHTSprintf0 (char **pstr, CONST char *fmt, ...)
#else
PRIVATE char * LYLeakHTSprintf0 (va_alist)
    va_dcl
#endif
{
    char *str;
    va_list ap;
    LYva_start(ap,fmt);
    {
#if !ANSI_VARARGS
	char **		pstr = va_arg(ap, char **);
	CONST char *	fmt  = va_arg(ap, CONST char *);
#endif
	str = LYLeakSAVsprintf(pstr, leak_cp_File_hack, leak_ssi_Line_hack,
			       0, fmt, &ap);
    }
    va_end(ap);
    return str;
}

/*
 *  HTSprintf and HTSprintf0 will be defined such that they effectively
 *  call one of the following two functions that store away a copy to
 *  the File & Line info in temporary hack variables, and then call
 *  the real function (which is returned here as a function pointer)
 *  to the regular HTSprintf/HTSprintf0 arguments.
 *  It's probably a bit inefficient, but that shouldn't be noticeable
 *  compared to all the time that memory tracking takes up for list
 *  traversal. - kw
 */
PUBLIC HTSprintflike *Get_htsprintf_fn ARGS2(
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
{
    leak_cp_File_hack = cp_File;
    leak_ssi_Line_hack = ssi_Line;
    return &LYLeakHTSprintf;
}

PUBLIC HTSprintflike *Get_htsprintf0_fn ARGS2(
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
{
    leak_cp_File_hack = cp_File;
    leak_ssi_Line_hack = ssi_Line;
    return &LYLeakHTSprintf0;
}

#endif /* not LY_FIND_LEAKS and LY_FIND_LEAKS_EXTENDED */
@

