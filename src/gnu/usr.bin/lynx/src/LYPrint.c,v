head	1.7;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.4
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.2
	MIROS_X_BASE:1.6
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.4
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2005.01.03.00.46.03;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.20.10.26.30;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.17.01;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.36;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.37;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.34;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.27;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.24;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.16;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.56;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.52.08;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.10.20.10.10.45;	author tg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@soft merge
@
text
@#include <HTUtils.h>
#include <HTAccess.h>
#include <HTList.h>
#include <HTAlert.h>
#include <HTFile.h>
#include <LYCurses.h>
#include <GridText.h>
#include <LYUtils.h>
#include <LYPrint.h>
#include <LYGlobalDefs.h>
#include <LYSignal.h>
#include <LYStrings.h>
#include <LYClean.h>
#include <LYGetFile.h>
#include <LYHistory.h>
#include <LYList.h>
#include <LYCharSets.h>		/* To get current charset for mail header. */

#include <LYLeaks.h>

#define CancelPrint(msg) HTInfoMsg(msg); goto done
#define CannotPrint(msg) HTAlert(msg); goto done

/*
 * printfile prints out the current file minus the links and targets to a
 * variety of places
 */

/* it parses an incoming link that looks like
 *
 * LYNXPRINT://LOCAL_FILE/lines=##
 * LYNXPRINT://MAIL_FILE/lines=##
 * LYNXPRINT://TO_SCREEN/lines=##
 * LYNXPRINT://LPANSI/lines=##
 * LYNXPRINT://PRINTER/lines=##/number=#
 */

#define TO_FILE   1
#define TO_SCREEN 2
/*
 * "lpansi.c"
 * Original author: Gary Day (gday@@comp.uark.edu), 11/30/93
 * Current version: 2.1 by Noel Hunter (noel@@wfu.edu), 10/20/94
 *
 * Basic structure based on print -- format files for printing from
 * _Practical_C_Programming by Steve Oualline, O'Reilly & Associates
 *
 * adapted from the README for lpansi.c v2.1, dated 10/20/1994:
 *		    Print to ANSI printer on local terminal
 *     The VT100 standard defines printer on and off escape sequences,
 *     esc[5i is printer on, and esc[4i is printer off.
 *
 * incorporate the idea of "lpansi" directly into LYPrint.c - HN
 */
#define LPANSI	  3
#define MAIL	  4
#define PRINTER   5

#if USE_VMS_MAILER
static int remove_quotes(char *string);
#endif /* USE_VMS_MAILER */

static char *subject_translate8bit(char *source);

#define LYNX_PRINT_TITLE   0
#define LYNX_PRINT_URL     1
#define LYNX_PRINT_DATE    2
#define LYNX_PRINT_LASTMOD 3

#define MAX_PUTENV 4

static void set_environ(int name,
			const char *value,
			const char *no_value)
{
    static const char *names[MAX_PUTENV] =
    {
	"LYNX_PRINT_TITLE",
	"LYNX_PRINT_URL",
	"LYNX_PRINT_DATE",
	"LYNX_PRINT_LASTMOD",
    };
    static char *pointers[MAX_PUTENV];
    char *envbuffer = 0;

#ifdef VMS
#define SET_ENVIRON(name, value, no_value) set_environ(name, value, no_value)
    char temp[80];

    StrAllocCopy(envbuffer, value);
    if (isEmpty(envbuffer))
	StrAllocCopy(envbuffer, no_value);
    Define_VMSLogical(strcpy(temp, names[name]), envbuffer);
    FREE(envbuffer);
#else
#define SET_ENVIRON(name, value, no_value) set_environ(name, value, "")
    /*
     * Once we've given a string to 'putenv()', we must not free it until we
     * give it a string to replace it.
     */
    StrAllocCopy(envbuffer, names[name]);
    StrAllocCat(envbuffer, "=");
    StrAllocCat(envbuffer, value ? value : no_value);
    putenv(envbuffer);
    FREE(pointers[name]);
    pointers[name] = envbuffer;
#endif
}

static char *suggested_filename(DocInfo *newdoc)
{
    char *cp, *sug_filename = 0;

    /*
     * Load the suggested filename string.  - FM
     */
    if (HText_getSugFname() != 0)
	StrAllocCopy(sug_filename, HText_getSugFname());	/* must be freed */
    else
	StrAllocCopy(sug_filename, newdoc->address);	/* must be freed */
    /*
     * Strip any gzip or compress suffix, if present.  - FM
     */
    cp = NULL;
    if (strlen(sug_filename) > 3) {
	cp = (char *) &sug_filename[(strlen(sug_filename) - 3)];
	if ((*cp == '.' || *cp == '-' || *cp == '_') &&
	    !strcasecomp((cp + 1), "gz")) {
	    *cp = '\0';
	} else {
	    cp = NULL;
	}
    }
    if ((cp == NULL) && strlen(sug_filename) > 2) {
	cp = (char *) &sug_filename[(strlen(sug_filename) - 2)];
	if ((*cp == '.' || *cp == '-' || *cp == '_') &&
	    !strcasecomp((cp + 1), "Z")) {
	    *cp = '\0';
	}
    }
    return sug_filename;
}

static void SetupFilename(char *filename,
			  const char *sug_filename)
{
    HTFormat format;
    HTAtom *encoding;
    char *cp;

    LYstrncpy(filename, sug_filename, LY_MAXPATH - 1);	/* add suggestion info */
    /* make the sug_filename conform to system specs */
    change_sug_filename(filename);
    if (!(HTisDocumentSource())
	&& (cp = strrchr(filename, '.')) != NULL
	&& (cp - filename) < LY_MAXPATH - 5) {
	format = HTFileFormat(filename, &encoding, NULL);
	if (!strcasecomp(format->name, "text/html") ||
	    !IsUnityEnc(encoding)) {
	    strcpy(cp, TEXT_SUFFIX);
	}
    }
}

#define FN_INIT 0
#define FN_READ 1
#define FN_DONE 2
#define FN_QUIT 3

#define PRINT_FLAG   0
#define GENERIC_FLAG 1

static int RecallFilename(char *filename,
			  BOOLEAN *first,
			  int *now,
			  int *total,
			  int flag)
{
    int ch;
    char *cp;
    RecallType recall;

    /*
     * Set up the sug_filenames recall buffer.
     */
    if (*now < 0) {
	*total = (sug_filenames ? HTList_count(sug_filenames) : 0);
	*now = *total;
    }
    recall = ((*total >= 1) ? RECALL_URL : NORECALL);

    if ((ch = LYgetstr(filename, VISIBLE, LY_MAXPATH, recall)) < 0 ||
	*filename == '\0' || ch == UPARROW || ch == DNARROW) {
	if (recall && ch == UPARROW) {
	    if (*first) {
		*first = FALSE;
		/*
		 * Use the last Fname in the list.  - FM
		 */
		*now = 0;
	    } else {
		/*
		 * Go back to the previous Fname in the list.  - FM
		 */
		*now += 1;
	    }
	    if (*now >= *total) {
		/*
		 * Reset the *first flag, and use sug_file or a blank.  -
		 * FM
		 */
		*first = TRUE;
		*now = *total;
		_statusline(FILENAME_PROMPT);
		return FN_INIT;
	    } else if ((cp = (char *) HTList_objectAt(sug_filenames,
						      *now)) != NULL) {
		LYstrncpy(filename, cp, LY_MAXPATH - 1);
		if (*total == 1) {
		    _statusline(EDIT_THE_PREV_FILENAME);
		} else {
		    _statusline(EDIT_A_PREV_FILENAME);
		}
		return FN_READ;
	    }
	} else if (recall && ch == DNARROW) {
	    if (*first) {
		*first = FALSE;
		/*
		 * Use the first Fname in the list. - FM
		 */
		*now = *total - 1;
	    } else {
		/*
		 * Advance to the next Fname in the list. - FM
		 */
		*now -= 1;
	    }
	    if (*now < 0) {
		/*
		 * Set the *first flag, and use sug_file or a blank.  - FM
		 */
		*first = TRUE;
		*now = *total;
		_statusline(FILENAME_PROMPT);
		return FN_INIT;
	    } else if ((cp = (char *) HTList_objectAt(sug_filenames,
						      *now)) != NULL) {
		LYstrncpy(filename, cp, LY_MAXPATH - 1);
		if (*total == 1) {
		    _statusline(EDIT_THE_PREV_FILENAME);
		} else {
		    _statusline(EDIT_A_PREV_FILENAME);
		}
		return FN_READ;
	    }
	}

	/*
	 * Operation cancelled.
	 */
	if (flag == PRINT_FLAG)
	    HTInfoMsg(SAVE_REQUEST_CANCELLED);
	else if (flag == GENERIC_FLAG)
	    return FN_QUIT;

	return FN_QUIT;
    }
    return FN_DONE;
}

static BOOLEAN confirm_by_pages(const char *prompt,
				int lines_in_file,
				int lines_per_page)
{
    int pages = lines_in_file / (lines_per_page + 1);
    int c;

    /* count fractional pages ! */
    if ((lines_in_file % (LYlines + 1)) > 0)
	pages++;

    if (pages > 4) {
	char *msg = 0;

	HTSprintf0(&msg, prompt, pages);
	c = HTConfirmDefault(msg, YES);
	FREE(msg);

	if (c == YES) {
	    LYaddstr("   Ok...");
	} else {
	    HTInfoMsg(PRINT_REQUEST_CANCELLED);
	    return FALSE;
	}
    }
    return TRUE;
}

static void send_file_to_file(DocInfo *newdoc, char *content_base,
			      char *sug_filename)
{
    BOOLEAN FirstRecall = TRUE;
    BOOLEAN use_cte;
    const char *disp_charset;
    FILE *outfile_fp;
    char buffer[LY_MAXPATH];
    char filename[LY_MAXPATH];
    int FnameNum = -1;
    int FnameTotal;
    int c = 0;

    _statusline(FILENAME_PROMPT);
  retry:
    SetupFilename(filename, sug_filename);
    if (lynx_save_space
	&& (strlen(lynx_save_space) + strlen(filename)) < sizeof(filename)) {
	strcpy(buffer, lynx_save_space);
	strcat(buffer, filename);
	strcpy(filename, buffer);
    }
  check_recall:
    switch (RecallFilename(filename, &FirstRecall, &FnameNum,
			   &FnameTotal, PRINT_FLAG)) {
    case FN_INIT:
	goto retry;
    case FN_READ:
	goto check_recall;
    case FN_QUIT:
	goto done;
    default:
	break;
    }

    if (!LYValidateFilename(buffer, filename)) {
	CancelPrint(SAVE_REQUEST_CANCELLED);
    }

    /*
     * See if it already exists.
     */
    switch (LYValidateOutput(buffer)) {
    case 'Y':
	break;
    case 'N':
	_statusline(NEW_FILENAME_PROMPT);
	FirstRecall = TRUE;
	FnameNum = FnameTotal;
	goto retry;
    default:
	goto done;
    }

    /*
     * See if we can write to it.
     */
    CTRACE((tfp, "LYPrint: filename is %s, action is `%c'\n", buffer, c));

#ifdef HAVE_POPEN
    if (*buffer == '|') {
	if (no_shell) {
	    HTUserMsg(SPAWNING_DISABLED);
	    FirstRecall = TRUE;
	    FnameNum = FnameTotal;
	    goto retry;
	} else if ((outfile_fp = popen(buffer + 1, "w")) == NULL) {
	    CTRACE((tfp, "LYPrint: errno is %d\n", errno));
	    HTAlert(CANNOT_WRITE_TO_FILE);
	    _statusline(NEW_FILENAME_PROMPT);
	    FirstRecall = TRUE;
	    FnameNum = FnameTotal;
	    goto retry;
	}
    } else
#endif
	if ((outfile_fp = (TOUPPER(c) == 'A'
			   ? LYAppendToTxtFile(buffer)
			   : LYNewTxtFile(buffer))) == NULL) {
	CTRACE((tfp, "LYPrint: errno is %d\n", errno));
	HTAlert(CANNOT_WRITE_TO_FILE);
	_statusline(NEW_FILENAME_PROMPT);
	FirstRecall = TRUE;
	FnameNum = FnameTotal;
	goto retry;
    }

    if (LYPrependBaseToSource && HTisDocumentSource()) {
	/*
	 * Added the document's base as a BASE tag to the top of the file.  May
	 * create technically invalid HTML, but will help get any partial or
	 * relative URLs resolved properly if no BASE tag is present to replace
	 * it.  - FM
	 *
	 * Add timestamp (last reload).
	 */

	fprintf(outfile_fp,
		"<!-- X-URL: %s -->\n", newdoc->address);
	if (HText_getDate() != NULL) {
	    fprintf(outfile_fp,
		    "<!-- Date: %s -->\n", HText_getDate());
	    if (HText_getLastModified() != NULL
		&& strcmp(HText_getLastModified(), HText_getDate())
		&& strcmp(HText_getLastModified(),
			  "Thu, 01 Jan 1970 00:00:01 GMT")) {
		fprintf(outfile_fp,
			"<!-- Last-Modified: %s -->\n", HText_getLastModified());
	    }
	}

	fprintf(outfile_fp,
		"<BASE HREF=\"%s\">\n", content_base);
    }

    if (LYPrependCharsetToSource && HTisDocumentSource()) {
	/*
	 * Added the document's charset as a META CHARSET tag to the top of the
	 * file.  May create technically invalid HTML, but will help to resolve
	 * properly the document converted via chartrans:  printed document
	 * correspond to a display charset and we *should* override both
	 * assume_local_charset and original document's META CHARSET (if any).
	 *
	 * Currently, if several META CHARSETs are found Lynx uses the first
	 * only, and it is opposite to BASE where the original BASE in the
	 * <HEAD> overrides ones from the top.
	 *
	 * As in print-to-email we write charset only if the document has 8-bit
	 * characters, and we have no CJK or an unofficial "x-" charset.
	 */
	use_cte = HTLoadedDocumentEightbit();
	disp_charset = LYCharSet_UC[current_char_set].MIMEname;
	if (!use_cte || LYHaveCJKCharacterSet ||
	    strncasecomp(disp_charset, "x-", 2) == 0) {
	} else {
	    fprintf(outfile_fp,
		    "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n",
		    disp_charset);
	}
    }

    print_wwwfile_to_fd(outfile_fp, FALSE, FALSE);	/* FILE */
    if (keypad_mode)
	printlist(outfile_fp, FALSE);

#ifdef HAVE_POPEN
    if (LYIsPipeCommand(buffer))
	pclose(outfile_fp);
    else
#endif
	LYCloseOutput(outfile_fp);

#ifdef VMS
    if (0 == strncasecomp(buffer, "sys$disk:", 9)) {
	if (0 == strncmp((buffer + 9), "[]", 2)) {
	    HTAddSugFilename(buffer + 11);
	} else {
	    HTAddSugFilename(buffer + 9);
	}
    } else {
	HTAddSugFilename(buffer);
    }
#else
    HTAddSugFilename(buffer);
#endif /* VMS */

  done:
    return;
}

static void send_file_to_mail(DocInfo *newdoc, char *content_base,
			      char *content_location)
{
    static BOOLEAN first_mail_preparsed = TRUE;

#if USE_VMS_MAILER
    BOOLEAN isPMDF = LYMailPMDF();
    FILE *hfd;
    char hdrfile[LY_MAXPATH];
#endif
    BOOL use_mime;

#if !CAN_PIPE_TO_MAILER
    char my_temp[LY_MAXPATH];
#endif

    BOOL use_cte;
    BOOL use_type;
    const char *disp_charset;
    FILE *outfile_fp;
    char *buffer = NULL;
    char *subject = NULL;
    char user_response[LINESIZE];

    if (!LYSystemMail())
	return;

    if (LYPreparsedSource && first_mail_preparsed &&
	HTisDocumentSource()) {
	if (HTConfirmDefault(CONFIRM_MAIL_SOURCE_PREPARSED, NO) == YES) {
	    LYaddstr("   Ok...");
	    first_mail_preparsed = FALSE;
	} else {
	    CancelPrint(MAIL_REQUEST_CANCELLED);
	}
    }

    _statusline(MAIL_ADDRESS_PROMPT);
    LYstrncpy(user_response, personal_mail_address, sizeof(user_response) - 1);
    if (LYgetstr(user_response,
		 VISIBLE,
		 sizeof(user_response),
		 RECALL_MAIL) < 0 ||
	*user_response == '\0') {
	CancelPrint(MAIL_REQUEST_CANCELLED);
    }

    /*
     * Determine which mail headers should be sent.  Use Content-Type and
     * MIME-Version headers only if needed.  We need them if we are mailing
     * HTML source, or if we have 8-bit characters and will be sending
     * Content-Transfer-Encoding to indicate this.  We will append a charset
     * parameter to the Content-Type if we do not have an "x-" charset, and we
     * will include the Content-Transfer-Encoding only if we are appending the
     * charset parameter, because indicating an 8-bit transfer without also
     * indicating the charset can cause problems with many mailers.  - FM & KW
     */
    disp_charset = LYCharSet_UC[current_char_set].MIMEname;
    use_cte = HTLoadedDocumentEightbit();
    if (!(use_cte && strncasecomp(disp_charset, "x-", 2))) {
	disp_charset = NULL;
	use_cte = FALSE;
    }
    use_type = (BOOL) (disp_charset || HTisDocumentSource());

    /*
     * Use newdoc->title as a subject instead of sug_filename:  MORE readable
     * and 8-bit letters shouldn't be a problem - LP
     */
    /* change_sug_filename(sug_filename); */
    subject = subject_translate8bit(newdoc->title);

    if (newdoc->isHEAD) {
	/*
	 * Special case for mailing HEAD responce:  this is rather technical
	 * information, show URL.
	 */
	FREE(subject);
	StrAllocCopy(subject, "HEAD  ");
	StrAllocCat(subject, newdoc->address);
    }
#if USE_VMS_MAILER
    if (strchr(user_response, '@@') && !strchr(user_response, ':') &&
	!strchr(user_response, '%') && !strchr(user_response, '"')) {
	char *temp = 0;

	HTSprintf0(&temp, mail_adrs, user_response);
	LYstrncpy(user_response, temp, sizeof(user_response) - 1);
	FREE(temp);
    }

    outfile_fp = LYOpenTemp(my_temp,
			    (HTisDocumentSource())
			    ? HTML_SUFFIX
			    : TEXT_SUFFIX,
			    "w");
    if (outfile_fp == NULL) {
	CannotPrint(UNABLE_TO_OPEN_TEMPFILE);
    }

    if (isPMDF) {
	if ((hfd = LYOpenTemp(hdrfile, TEXT_SUFFIX, "w")) == NULL) {
	    CannotPrint(UNABLE_TO_OPEN_TEMPFILE);
	}
	if (use_type) {
	    fprintf(hfd, "Mime-Version: 1.0\n");
	    if (use_cte) {
		fprintf(hfd, "Content-Transfer-Encoding: 8bit\n");
	    }
	}
	if (HTisDocumentSource()) {
	    /*
	     * Add Content-Type, Content-Location, and Content-Base headers for
	     * HTML source.  - FM
	     */
	    fprintf(hfd, "Content-Type: text/html");
	    if (disp_charset != NULL) {
		fprintf(hfd, "; charset=%s\n", disp_charset);
	    } else {
		fprintf(hfd, "\n");
	    }
	    fprintf(hfd, "Content-Base: %s\n", content_base);
	    fprintf(hfd, "Content-Location: %s\n", content_location);
	} else {
	    /*
	     * Add Content-Type:  text/plain if we have 8-bit characters and a
	     * valid charset for non-source documents.  - FM
	     */
	    if (disp_charset != NULL) {
		fprintf(hfd,
			"Content-Type: text/plain; charset=%s\n",
			disp_charset);
	    }
	}
	/*
	 * X-URL header.  - FM
	 */
	fprintf(hfd, "X-URL: %s\n", newdoc->address);
	/*
	 * For PMDF, put the subject in the header file and close it.  - FM
	 */
	fprintf(hfd, "Subject: %.70s\n\n", subject);
	LYCloseTempFP(hfd);
    }

    /*
     * Write the contents to a temp file.
     */
    if (LYPrependBaseToSource && HTisDocumentSource()) {
	/*
	 * Added the document's base as a BASE tag to the top of the message
	 * body.  May create technically invalid HTML, but will help get any
	 * partial or relative URLs resolved properly if no BASE tag is present
	 * to replace it.  - FM
	 */
	fprintf(outfile_fp,
		"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",
		newdoc->address, content_base);
    } else if (!isPMDF) {
	fprintf(outfile_fp, "X-URL: %s\n\n", newdoc->address);
    }
    print_wwwfile_to_fd(outfile_fp, TRUE, FALSE);	/* MAIL */
    if (keypad_mode)
	printlist(outfile_fp, FALSE);
    LYCloseTempFP(outfile_fp);

    buffer = NULL;
    if (isPMDF) {
	/*
	 * Now set up the command.  - FM
	 */
	HTSprintf0(&buffer,
		   "%s %s %s,%s %s",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_temp,
		   user_response);
    } else {
	/*
	 * For "generic" VMS MAIL, include the subject in the command.  - FM
	 */
	remove_quotes(subject);
	HTSprintf0(&buffer,
		   "%s %s/subject=\"%.70s\" %s %s",
		   system_mail,
		   system_mail_flags,
		   subject,
		   my_temp,
		   user_response);
    }

    stop_curses();
    SetOutputMode(O_TEXT);
    printf(MAILING_FILE);
    LYSystem(buffer);
    LYSleepAlert();
    start_curses();
    SetOutputMode(O_BINARY);

    if (isPMDF)
	LYRemoveTemp(hdrfile);
    LYRemoveTemp(my_temp);
#else /* !VMS (Unix or DOS) */

#if CAN_PIPE_TO_MAILER
    outfile_fp = LYPipeToMailer();
#else
    outfile_fp = LYOpenTemp(my_temp, TEXT_SUFFIX, "w");
#endif
    if (outfile_fp == NULL) {
	CannotPrint(MAIL_REQUEST_FAILED);
    }

    /*
     * Determine which mail headers should be sent.  Use Content-Type and
     * MIME-Version headers only if needed.  We need them if we are mailing
     * HTML source, or if we have 8-bit characters and will be sending
     * Content-Transfer-Encoding to indicate this.
     *
     * Send Content-Transfer-Encoding only if the document has 8-bit
     * characters.  Send a charset parameter only if the document has 8-bit
     * characters and we seem to have a valid charset.  - kw
     */
    use_cte = HTLoadedDocumentEightbit();
    disp_charset = LYCharSet_UC[current_char_set].MIMEname;
    /*
     * Don't send a charset if we have a CJK character set selected, since it
     * may not be appropriate for mail...  Also don't use an unofficial "x-"
     * charset.  - kw
     */
    if (!use_cte || LYHaveCJKCharacterSet ||
	strncasecomp(disp_charset, "x-", 2) == 0) {
	disp_charset = NULL;
    }
#ifdef NOTDEFINED
    /* Enable this if indicating an 8-bit transfer without also indicating the
     * charset causes problems.  - kw */
    if (use_cte && !disp_charset)
	use_cte = FALSE;
#endif /* NOTDEFINED */
    use_type = (BOOL) (disp_charset || HTisDocumentSource());
    use_mime = (BOOL) (use_cte || use_type);

    if (use_mime) {
	fprintf(outfile_fp, "Mime-Version: 1.0\n");
	if (use_cte) {
	    fprintf(outfile_fp, "Content-Transfer-Encoding: 8bit\n");
	}
    }

    if (HTisDocumentSource()) {
	/*
	 * Add Content-Type, Content-Location, and Content-Base headers for
	 * HTML source.  - FM
	 */
	fprintf(outfile_fp, "Content-Type: text/html");
	if (disp_charset != NULL) {
	    fprintf(outfile_fp, "; charset=%s\n", disp_charset);
	} else {
	    fprintf(outfile_fp, "\n");
	}
    } else {
	/*
	 * Add Content-Type:  text/plain if we have 8-bit characters and a
	 * valid charset for non-source documents.  - KW
	 */
	if (disp_charset != NULL) {
	    fprintf(outfile_fp,
		    "Content-Type: text/plain; charset=%s\n",
		    disp_charset);
	}
    }
    /*
     * If we are using MIME headers, add content-base and content-location if
     * we have them.  This will always be the case if the document is source.
     * - kw
     */
    if (use_mime) {
	if (content_base)
	    fprintf(outfile_fp, "Content-Base: %s\n", content_base);
	if (content_location)
	    fprintf(outfile_fp, "Content-Location: %s\n", content_location);
    }

    /*
     * Add the To, Subject, and X-URL headers.  - FM
     */
    fprintf(outfile_fp, "To: %s\nSubject: %s\n", user_response, subject);
    fprintf(outfile_fp, "X-URL: %s\n\n", newdoc->address);

    if (LYPrependBaseToSource && HTisDocumentSource()) {
	/*
	 * Added the document's base as a BASE tag to the top of the message
	 * body.  May create technically invalid HTML, but will help get any
	 * partial or relative URLs resolved properly if no BASE tag is present
	 * to replace it.  - FM
	 */
	fprintf(outfile_fp,
		"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",
		newdoc->address, content_base);
    }
    print_wwwfile_to_fd(outfile_fp, TRUE, FALSE);	/* MAIL */
    if (keypad_mode)
	printlist(outfile_fp, FALSE);

#if CAN_PIPE_TO_MAILER
    pclose(outfile_fp);
#else
    LYCloseOutput(outfile_fp);
    LYSendMailFile(user_response,
		   my_temp,
		   subject,
		   "",
		   "");
    LYRemoveTemp(my_temp);	/* Delete the tmpfile. */
#endif /* CAN_PIPE_TO_MAILER */
#endif /* USE_VMS_MAILER */

  done:			/* send_file_to_mail() */
    FREE(buffer);
    FREE(subject);
    return;
}

static void send_file_to_printer(DocInfo *newdoc, char *content_base,
				 char *sug_filename,
				 int printer_number)
{
    BOOLEAN FirstRecall = TRUE;
    FILE *outfile_fp;
    char *the_command = 0;
    char my_file[LY_MAXPATH];
    char my_temp[LY_MAXPATH];
    int FnameTotal, FnameNum = -1;
    lynx_list_item_type *cur_printer;

    outfile_fp = LYOpenTemp(my_temp,
			    (HTisDocumentSource())
			    ? HTML_SUFFIX
			    : TEXT_SUFFIX,
			    "w");
    if (outfile_fp == NULL) {
	CannotPrint(FILE_ALLOC_FAILED);
    }

    if (LYPrependBaseToSource && HTisDocumentSource()) {
	/*
	 * Added the document's base as a BASE tag to the top of the file.  May
	 * create technically invalid HTML, but will help get any partial or
	 * relative URLs resolved properly if no BASE tag is present to replace
	 * it.  - FM
	 */
	fprintf(outfile_fp,
		"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",
		newdoc->address, content_base);
    }
    print_wwwfile_to_fd(outfile_fp, FALSE, FALSE);	/* PRINTER */
    if (keypad_mode)
	printlist(outfile_fp, FALSE);

    LYCloseTempFP(outfile_fp);

    /* find the right printer number */
    {
	int count = 0;

	for (cur_printer = printers;
	     count < printer_number;
	     count++, cur_printer = cur_printer->next) ;	/* null body */
    }

    /*
     * Commands have the form "command %s [%s] [etc]" where %s is the filename
     * and the second optional %s is the suggested filename.
     */
    if (cur_printer->command == NULL) {
	CannotPrint(PRINTER_MISCONF_ERROR);
    }

    /*
     * Check for two '%s' and ask for the second filename argument if there
     * is.
     */
    if (HTCountCommandArgs(cur_printer->command) >= 2) {
	_statusline(FILENAME_PROMPT);
      again:
	SetupFilename(my_file, sug_filename);
      check_again:
	switch (RecallFilename(my_file, &FirstRecall, &FnameNum,
			       &FnameTotal, PRINT_FLAG)) {
	case FN_INIT:
	    goto again;
	case FN_READ:
	    goto check_again;
	case FN_QUIT:
	    goto done;
	default:
	    break;
	}

	if (no_dotfiles || !show_dotfiles) {
	    if (*LYPathLeaf(my_file) == '.') {
		HTAlert(FILENAME_CANNOT_BE_DOT);
		_statusline(NEW_FILENAME_PROMPT);
		FirstRecall = TRUE;
		FnameNum = FnameTotal;
		goto again;
	    }
	}
	/*
	 * Cancel if the user entered "/dev/null" on Unix, or an "nl:" path
	 * on VMS.  - FM
	 */
	if (LYIsNullDevice(my_file)) {
	    CancelPrint(PRINT_REQUEST_CANCELLED);
	}
	HTAddSugFilename(my_file);
    }
#ifdef SH_EX			/* 1999/01/04 (Mon) 09:37:03 */
    else {
	my_file[0] = '\0';
    }

    HTAddParam(&the_command, cur_printer->command, 1, my_temp);
    if (my_file[0]) {
	HTAddParam(&the_command, cur_printer->command, 2, my_file);
	HTEndParam(&the_command, cur_printer->command, 3);
    } else {
	HTEndParam(&the_command, cur_printer->command, 2);
    }
#else
    HTAddParam(&the_command, cur_printer->command, 1, my_temp);
    HTAddParam(&the_command, cur_printer->command, 2, my_file);
    HTEndParam(&the_command, cur_printer->command, 2);
#endif

    /*
     * Move the cursor to the top of the screen so that output from system'd
     * commands don't scroll up the screen.
     */
    LYmove(1, 1);

    stop_curses();
    CTRACE((tfp, "command: %s\n", the_command));
    SetOutputMode(O_TEXT);
    printf(PRINTING_FILE);
    /*
     * Set various bits of document information as environment variables, for
     * use by external print scripts/etc.  On UNIX, We assume there are values,
     * and leave NULL value checking up to the external PRINTER:  cmd/script -
     * KED
     */
    SET_ENVIRON(LYNX_PRINT_TITLE, HText_getTitle(), "No Title");
    SET_ENVIRON(LYNX_PRINT_URL, newdoc->address, "No URL");
    SET_ENVIRON(LYNX_PRINT_DATE, HText_getDate(), "No Date");
    SET_ENVIRON(LYNX_PRINT_LASTMOD, HText_getLastModified(), "No LastMod");

    LYSystem(the_command);
    FREE(the_command);
    LYRemoveTemp(my_temp);

    /*
     * Remove the various LYNX_PRINT_xxxx logicals.  - KED
     * [could use unsetenv(), but it's not portable]
     */
    SET_ENVIRON(LYNX_PRINT_TITLE, "", "");
    SET_ENVIRON(LYNX_PRINT_URL, "", "");
    SET_ENVIRON(LYNX_PRINT_DATE, "", "");
    SET_ENVIRON(LYNX_PRINT_LASTMOD, "", "");

    fflush(stdout);
#ifndef VMS
    signal(SIGINT, cleanup_sig);
#endif /* !VMS */
#ifdef SH_EX
    fprintf(stdout, gettext(" Print job complete.\n"));
    fflush(stdout);
#endif
    SetOutputMode(O_BINARY);
    LYSleepMsg();
    start_curses();

  done:			/* send_file_to_printer() */
    return;
}

static void send_file_to_screen(DocInfo *newdoc, char *content_base,
				BOOLEAN Lpansi)
{
    FILE *outfile_fp;
    char prompt[80];

    if (Lpansi) {
	_statusline(CHECK_PRINTER);
    } else {
	_statusline(PRESS_RETURN_TO_BEGIN);
    }

    *prompt = '\0';
    if (LYgetstr(prompt, VISIBLE, sizeof(prompt), NORECALL) < 0) {
	CancelPrint(PRINT_REQUEST_CANCELLED);
    }

    outfile_fp = stdout;

    stop_curses();
    SetOutputMode(O_TEXT);

#ifndef VMS
    signal(SIGINT, SIG_IGN);
#endif /* !VMS */

    if (LYPrependBaseToSource && HTisDocumentSource()) {
	/*
	 * Added the document's base as a BASE tag to the top of the file.  May
	 * create technically invalid HTML, but will help get any partial or
	 * relative URLs resolved properly if no BASE tag is present to replace
	 * it.  - FM
	 */
	fprintf(outfile_fp,
		"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",
		newdoc->address, content_base);
    }
    if (Lpansi)
	printf("\033[5i");
    print_wwwfile_to_fd(outfile_fp, FALSE, FALSE);	/* SCREEN */
    if (keypad_mode)
	printlist(outfile_fp, FALSE);

#ifdef VMS
    if (HadVMSInterrupt) {
	HadVMSInterrupt = FALSE;
	start_curses();
	CancelPrint(PRINT_REQUEST_CANCELLED);
    }
#endif /* VMS */
    if (Lpansi) {
	printf("\n\014");	/* Form feed */
	printf("\033[4i");
	fflush(stdout);		/* refresh to screen */
	Lpansi = FALSE;
    } else {
	fprintf(stdout, "\n\n%s", PRESS_RETURN_TO_FINISH);
	fflush(stdout);		/* refresh to screen */
	(void) LYgetch();	/* grab some user input to pause */
#ifdef VMS
	HadVMSInterrupt = FALSE;
#endif /* VMS */
    }
#ifdef SH_EX
    fprintf(stdout, "\n");
#endif
    SetOutputMode(O_BINARY);
    start_curses();

  done:			/* send_file_to_screen() */
    return;
}

int printfile(DocInfo *newdoc)
{
    BOOLEAN Lpansi = FALSE;
    DocAddress WWWDoc;
    char *content_base = NULL;
    char *content_location = NULL;
    char *cp = NULL;
    char *link_info = NULL;
    char *sug_filename = NULL;
    int lines_in_file = 0;
    int pagelen = 0;
    int printer_number = 0;
    int type = 0;

    /*
     * Extract useful info from URL.
     */
    StrAllocCopy(link_info, newdoc->address + 12);

    /*
     * Reload the file we want to print into memory.
     */
    LYpop(newdoc);
    WWWDoc.address = newdoc->address;
    WWWDoc.post_data = newdoc->post_data;
    WWWDoc.post_content_type = newdoc->post_content_type;
    WWWDoc.bookmark = newdoc->bookmark;
    WWWDoc.isHEAD = newdoc->isHEAD;
    WWWDoc.safe = newdoc->safe;
    if (!HTLoadAbsolute(&WWWDoc))
	return (NOT_FOUND);

    /*
     * If we have an explicit content-base, we may use it even if not in source
     * mode.  - kw
     */
    if (HText_getContentBase()) {
	StrAllocCopy(content_base, HText_getContentBase());
	LYRemoveBlanks(content_base);
	if (isEmpty(content_base)) {
	    FREE(content_base);
	}
    }
    /*
     * If document is source, load the content_base and content_location
     * strings.  - FM
     */
    if (HTisDocumentSource()) {
	if (HText_getContentLocation()) {
	    StrAllocCopy(content_location, HText_getContentLocation());
	    LYRemoveBlanks(content_location);
	    if (isEmpty(content_location)) {
		FREE(content_location);
	    }
	}
	if (!content_base) {
	    if ((content_location) && is_url(content_location)) {
		StrAllocCopy(content_base, content_location);
	    } else {
		StrAllocCopy(content_base, newdoc->address);
	    }
	}
	if (!content_location) {
	    StrAllocCopy(content_location, newdoc->address);
	}
    }

    sug_filename = suggested_filename(newdoc);

    /*
     * Get the number of lines in the file.
     */
    if ((cp = strstr(link_info, "lines=")) != NULL) {
	/*
	 * Terminate prev string here.
	 */
	*cp = '\0';
	/*
	 * Number of characters in "lines=".
	 */
	cp += 6;

	lines_in_file = atoi(cp);
    }

    /*
     * Determine the type.
     */
    if (strstr(link_info, "LOCAL_FILE")) {
	type = TO_FILE;
    } else if (strstr(link_info, "TO_SCREEN")) {
	type = TO_SCREEN;
    } else if (strstr(link_info, "LPANSI")) {
	Lpansi = TRUE;
	type = TO_SCREEN;
    } else if (strstr(link_info, "MAIL_FILE")) {
	type = MAIL;
    } else if (strstr(link_info, "PRINTER")) {
	type = PRINTER;

	if ((cp = strstr(link_info, "number=")) != NULL) {
	    /* number of characters in "number=" */
	    cp += 7;
	    printer_number = atoi(cp);
	}
	if ((cp = strstr(link_info, "pagelen=")) != NULL) {
	    /* number of characters in "pagelen=" */
	    cp += 8;
	    pagelen = atoi(cp);
	} else {
	    /* default to 66 lines */
	    pagelen = 66;
	}
    }

    /*
     * Act on the request.  - FM
     */
    switch (type) {

    case TO_FILE:
	send_file_to_file(newdoc, content_base, sug_filename);
	break;

    case MAIL:
	send_file_to_mail(newdoc, content_base, content_location);
	break;

    case TO_SCREEN:
	if (confirm_by_pages(CONFIRM_LONG_SCREEN_PRINT, lines_in_file, LYlines))
	    send_file_to_screen(newdoc, content_base, Lpansi);
	break;

    case PRINTER:
	if (confirm_by_pages(CONFIRM_LONG_PAGE_PRINT, lines_in_file, pagelen))
	    send_file_to_printer(newdoc, content_base, sug_filename, printer_number);
	break;

    }				/* end switch */

    FREE(link_info);
    FREE(sug_filename);
    FREE(content_base);
    FREE(content_location);
    return (NORMAL);
}

#if USE_VMS_MAILER
static int remove_quotes(char *string)
{
    int i;

    for (i = 0; string[i] != '\0'; i++)
	if (string[i] == '"')
	    string[i] = ' ';
	else if (string[i] == '&')
	    string[i] = ' ';
	else if (string[i] == '|')
	    string[i] = ' ';

    return (0);
}
#endif /* USE_VMS_MAILER */

/*
 * Mail subject may have 8-bit characters and they are in display charset. 
 * There is no stable practice for 8-bit subject encodings:  MIME defines
 * "quoted-printable" which holds charset info but most mailers still don't
 * support it.  On the other hand many mailers send open 8-bit subjects without
 * charset info and use local assumption for certain countries.  Besides that,
 * obsolete SMTP software is not 8bit clean but still in use, it strips the
 * characters in 128-160 range from subjects which may be a fault outside
 * iso-8859-XX.
 *
 * We translate subject to "outgoing_mail_charset" (defined in lynx.cfg) it may
 * correspond to US-ASCII as the safest value or any other lynx character
 * handler, -1 for no translation (so display charset).
 *
 * Always returns a new allocated string which has to be freed.
 */
#include <LYCharUtils.h>
static char *subject_translate8bit(char *source)
{
    char *target = NULL;

    int charset_in, charset_out;

    int i = outgoing_mail_charset;	/* from lynx.cfg, -1 by default */

    StrAllocCopy(target, source);
    if (i < 0
	|| i == current_char_set
	|| LYCharSet_UC[current_char_set].enc == UCT_ENC_CJK
	|| LYCharSet_UC[i].enc == UCT_ENC_CJK) {
	return (target);	/* OK */
    } else {
	charset_out = i;
	charset_in = current_char_set;
    }

    LYUCTranslateBackHeaderText(&target, charset_in, charset_out, YES);

    return (target);
}

/*
 * print_options writes out the current printer choices to a file
 * so that the user can select printers in the same way that
 * they select all other links
 * printer links look like
 *
 * LYNXPRINT://LOCAL_FILE/lines=#	     print to a local file
 * LYNXPRINT://TO_SCREEN/lines=#	     print to the screen
 * LYNXPRINT://LPANSI/lines=#		     print to the local terminal
 * LYNXPRINT://MAIL_FILE/lines=#	     mail the file
 * LYNXPRINT://PRINTER/lines=#/number=#      print to printer number #
 */
int print_options(char **newfile,
		  const char *printed_url,
		  int lines_in_file)
{
    static char my_temp[LY_MAXPATH] = "\0";
    char *buffer = 0;
    int count;
    int pages;
    FILE *fp0;
    lynx_list_item_type *cur_printer;

    if ((fp0 = InternalPageFP(my_temp, TRUE)) == 0)
	return (-1);

    LYLocalFileToURL(newfile, my_temp);

    BeginInternalPage(fp0, PRINT_OPTIONS_TITLE, PRINT_OPTIONS_HELP);

    fprintf(fp0, "<pre>\n");

    /*  pages = lines_in_file/66 + 1; */
    pages = (lines_in_file + 65) / 66;
    HTSprintf0(&buffer,
	       "   <em>%s</em> %s\n   <em>%s</em> %d\n   <em>%s</em> %d %s %s\n",
	       gettext("Document:"), printed_url,
	       gettext("Number of lines:"), lines_in_file,
	       gettext("Number of pages:"), pages,
	       (pages > 1 ? gettext("pages") : gettext("page")),
	       gettext("(approximately)"));
    fputs(buffer, fp0);
    FREE(buffer);

    if (no_print || no_disk_save || child_lynx || no_mail)
	fprintf(fp0,
		"   <em>%s</em>\n",
		gettext("Some print functions have been disabled!"));

    fprintf(fp0, "\n%s\n",
	    (user_mode == NOVICE_MODE)
	    ? gettext("Standard print options:")
	    : gettext("Print options:"));

    if (child_lynx == FALSE && no_disk_save == FALSE && no_print == FALSE) {
	fprintf(fp0,
		"   <a href=\"%s//LOCAL_FILE/lines=%d\">%s</a>\n",
		STR_LYNXPRINT,
		lines_in_file,
		gettext("Save to a local file"));
    } else {
	fprintf(fp0, "   <em>%s</em>\n", gettext("Save to disk disabled"));
    }
    if (child_lynx == FALSE && no_mail == FALSE && local_host_only == FALSE)
	fprintf(fp0,
		"   <a href=\"%s//MAIL_FILE/lines=%d\">%s</a>\n",
		STR_LYNXPRINT,
		lines_in_file,
		gettext("Mail the file"));

#if defined(UNIX) || defined(VMS)
    fprintf(fp0,
	    "   <a href=\"%s//TO_SCREEN/lines=%d\">%s</a>\n",
	    STR_LYNXPRINT,
	    lines_in_file,
	    gettext("Print to the screen"));
    fprintf(fp0,
	    "   <a href=\"%s//LPANSI/lines=%d\">%s</a>\n",
	    STR_LYNXPRINT,
	    lines_in_file,
	    gettext("Print out on a printer attached to your vt100 terminal"));
#endif

    if (user_mode == NOVICE_MODE)
	fprintf(fp0, "\n%s\n", gettext("Local additions:"));

    for (count = 0, cur_printer = printers; cur_printer != NULL;
	 cur_printer = cur_printer->next, count++)
	if (no_print == FALSE || cur_printer->always_enabled) {
	    fprintf(fp0,
		    "   <a href=\"%s//PRINTER/number=%d/pagelen=%d/lines=%d\">",
		    STR_LYNXPRINT,
		    count, cur_printer->pagelen, lines_in_file);
	    fprintf(fp0, (cur_printer->name ?
			  cur_printer->name : "No Name Given"));
	    fprintf(fp0, "</a>\n");
	}
    fprintf(fp0, "</pre>\n");
    EndInternalPage(fp0);
    LYCloseTempFP(fp0);

    LYforce_no_cache = TRUE;
    return (0);
}

/*
 * General purpose filename getter.
 *
 * Returns a pointer to an absolute filename string, if the input filename
 * exists, and is readable.  Returns NULL if the input was cancelled (^G, or CR
 * on empty input).
 *
 * The pointer to the filename string needs to be free()'d by the caller (when
 * non-NULL).
 *
 * --KED 02/21/99
 */
char *GetFileName(void)
{
    struct stat stat_info;

    char fbuf[LY_MAXPATH];
    char tbuf[LY_MAXPATH];
    char *fn;

    BOOLEAN FirstRecall = TRUE;
    int FnameNum = -1;
    int FnameTotal;

    _statusline(FILENAME_PROMPT);

  retry:
    /*
     * No initial filename.
     */
    SetupFilename(fbuf, "");

  check_recall:
    /*
     * Go get a filename (it would be nice to do TAB == filename-completion as
     * the name is entered, but we'll save doing that for another time.
     */
    switch (RecallFilename(fbuf, &FirstRecall, &FnameNum,
			   &FnameTotal, GENERIC_FLAG)) {
    case FN_INIT:
	goto retry;
    case FN_READ:
	goto check_recall;
    case FN_QUIT:
	goto quit;
    default:
	break;
    }

    /*
     * Add raw input form to list ...  we may want to reuse/edit it on a
     * subsequent call, etc.
     */
#ifdef VMS
    if (0 == strncasecomp(fbuf, "sys$disk:", 9)) {
	if (0 == strncmp((fbuf + 9), "[]", 2)) {
	    HTAddSugFilename(fbuf + 11);
	} else {
	    HTAddSugFilename(fbuf + 9);
	}
    } else {
	HTAddSugFilename(fbuf);
    }
#else
    HTAddSugFilename(fbuf);
#endif /* VMS */

    /*
     * Expand tilde's, make filename absolute, etc.
     */
    if (!LYValidateFilename(tbuf, fbuf))
	goto quit;

    /*
     * Check for file existence; readability.
     */
    if ((stat(tbuf, &stat_info) < 0) ||
	(!(S_ISREG(stat_info.st_mode)
#ifdef S_IFLNK
	   || S_ISLNK(stat_info.st_mode)
#endif /* S_IFLNK */
	 ))) {
	HTInfoMsg(FILE_DOES_NOT_EXIST);
	_statusline(FILE_DOES_NOT_EXIST_RE);
	FirstRecall = TRUE;
	FnameNum = FnameTotal;
	goto retry;
    }

    if (!LYCanReadFile(tbuf)) {
	HTInfoMsg(FILE_NOT_READABLE);
	_statusline(FILE_NOT_READABLE_RE);
	FirstRecall = TRUE;
	FnameNum = FnameTotal;
	goto retry;
    }

    /*
     * We have a valid filename, and readable file.  Return it to the caller.
     *
     * The returned pointer should be free()'d by the caller.
     *
     * [For some silly reason, if we use StrAllocCopy() here, we get an
     * "invalid pointer" reported in the Lynx.leaks file (if compiled with
     * --enable-find-leaks turned on.  Dumb.]
     */
    if ((fn = typecallocn(char, strlen(tbuf) + 1)) == NULL)
	  outofmem(__FILE__, "GetFileName");

    return (strcpy(fn, tbuf));

  quit:
    /*
     * The user cancelled the input (^G, or CR on empty input field).
     */
    return (NULL);
}
@


1.6
log
@automatic merge
@
text
@d145 1
a145 1
			  char *sug_filename)
d181 1
a181 1
    int recall;
d272 1
a272 1
static BOOLEAN confirm_by_pages(char *prompt,
@


1.5
log
@automatic merge of lynx-current
@
text
@d91 1
a91 1
    if (!(envbuffer && *envbuffer))
d1069 1
a1069 1
	if (!(content_base && *content_base)) {
d1081 1
a1081 1
	    if (!(content_location && *content_location)) {
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d17 1
a17 1
#include <LYCharSets.h>  /* To get current charset for mail header. */
d25 2
a26 2
 *  printfile prints out the current file minus the links and targets
 *  to a variety of places
d31 5
a35 5
 *  LYNXPRINT://LOCAL_FILE/lines=##
 *  LYNXPRINT://MAIL_FILE/lines=##
 *  LYNXPRINT://TO_SCREEN/lines=##
 *  LYNXPRINT://LPANSI/lines=##
 *  LYNXPRINT://PRINTER/lines=##/number=#
d60 1
a60 1
static int remove_quotes (char *string);
d63 1
a63 1
static  char* subject_translate8bit (char *source);
d72 3
a74 4
static void set_environ (
	int		name,
	const char *	value,
	const char *	no_value)
d76 2
a77 1
    static const char *names[MAX_PUTENV] = {
d85 1
d89 1
d110 1
a110 2
static char *suggested_filename (
	DocInfo *	newdoc)
d115 1
a115 1
     *	Load the suggested filename string. - FM
d118 1
a118 1
	StrAllocCopy(sug_filename, HText_getSugFname()); /* must be freed */
d120 1
a120 1
	StrAllocCopy(sug_filename, newdoc->address); /* must be freed */
d122 1
a122 1
     *	Strip any gzip or compress suffix, if present. - FM
d126 1
a126 1
	cp = (char *)&sug_filename[(strlen(sug_filename) - 3)];
d135 1
a135 1
	cp = (char *)&sug_filename[(strlen(sug_filename) - 2)];
d144 2
a145 3
static void SetupFilename (
	char *		filename,
	char *		sug_filename)
d151 1
a151 1
    LYstrncpy(filename, sug_filename, LY_MAXPATH-1);  /* add suggestion info */
d155 2
a156 2
     && (cp = strrchr(filename, '.')) != NULL
     && (cp - filename) < LY_MAXPATH-5) {
d173 5
a177 6
static int RecallFilename (
	char *		filename,
	BOOLEAN *	first,
	int *		now,
	int *		total,
	int		flag)
d216 3
a218 4
	    } else if ((cp = (char *)HTList_objectAt(
					    sug_filenames,
					    *now)) != NULL) {
		LYstrncpy(filename, cp, LY_MAXPATH-1);
d247 3
a249 4
	    } else if ((cp = (char *)HTList_objectAt(
					    sug_filenames,
					    *now)) != NULL) {
		LYstrncpy(filename, cp, LY_MAXPATH-1);
d272 3
a274 4
static BOOLEAN confirm_by_pages (
	char *		prompt,
	int		lines_in_file,
	int		lines_per_page)
d276 1
a276 1
    int pages = lines_in_file/(lines_per_page+1);
d280 1
a280 1
    if ((lines_in_file % (LYlines+1)) > 0)
d300 2
a301 4
static void send_file_to_file (
	DocInfo *	newdoc,
	char *		content_base,
	char *		sug_filename)
d314 1
a314 1
retry:
d317 1
a317 1
     && (strlen(lynx_save_space) + strlen(filename)) < sizeof(filename)) {
d322 11
a332 11
check_recall:
    switch (RecallFilename(filename,    &FirstRecall, &FnameNum,
			   &FnameTotal, PRINT_FLAG))  {
	case FN_INIT:
	    goto retry;
	case FN_READ:
	    goto check_recall;
	case FN_QUIT:
	    goto done;
	default:
	    break;
d366 1
a366 1
	} else if ((outfile_fp = popen(buffer+1, "w")) == NULL) {
d376 3
a378 3
    if ((outfile_fp = (TOUPPER(c) == 'A'
	    ? LYAppendToTxtFile(buffer)
	    : LYNewTxtFile(buffer))) == NULL) {
d401 1
a401 1
		"<!-- Date: %s -->\n", HText_getDate());
d403 3
a405 2
			&& strcmp(HText_getLastModified(), HText_getDate())
			&& strcmp(HText_getLastModified(), "Thu, 01 Jan 1970 00:00:01 GMT")) {
d407 1
a407 1
		    "<!-- Last-Modified: %s -->\n", HText_getLastModified());
d443 1
a443 1
	printlist(outfile_fp,FALSE);
d454 2
a455 2
	if (0 == strncmp((buffer+9), "[]", 2)) {
	    HTAddSugFilename(buffer+11);
d457 1
a457 1
	    HTAddSugFilename(buffer+9);
d466 1
a466 1
done:
d470 2
a471 4
static void send_file_to_mail (
	DocInfo *	newdoc,
	char *		content_base,
	char *		content_location)
d481 1
d502 1
a502 1
	} else	{
d508 5
a512 2
    LYstrncpy(user_response, personal_mail_address, sizeof(user_response)-1);
    if (LYgetstr(user_response, VISIBLE, sizeof(user_response), RECALL_MAIL) < 0 ||
a550 1

d552 2
a553 2
    if (strchr(user_response,'@@') && !strchr(user_response,':') &&
       !strchr(user_response,'%') && !strchr(user_response,'"')) {
d555 1
d557 1
a557 1
	LYstrncpy(user_response, temp, sizeof(user_response)-1);
d563 2
a564 2
				    ? HTML_SUFFIX
				    : TEXT_SUFFIX,
d605 1
a605 1
	 *	X-URL header. - FM
d616 1
a616 1
     *  Write the contents to a temp file.
d642 6
a647 6
		"%s %s %s,%s %s",
		system_mail,
		system_mail_flags,
		hdrfile,
		my_temp,
		user_response);
d654 6
a659 6
		"%s %s/subject=\"%.70s\" %s %s",
		system_mail,
		system_mail_flags,
		subject,
		my_temp,
		user_response);
d663 1
a663 1
    SetOutputMode( O_TEXT );
d668 1
a668 1
    SetOutputMode( O_BINARY );
d706 2
a707 2
    /*  Enable this if indicating an 8-bit transfer without
     *  also indicating the charset causes problems. - kw */
d756 1
a756 1
     *  Add the To, Subject, and X-URL headers. - FM
d780 6
a785 7
    LYSendMailFile (
	    user_response,
	    my_temp,
	    subject,
	    "",
	    "");
    LYRemoveTemp(my_temp); /* Delete the tmpfile. */
d789 1
a789 1
done:	/* send_file_to_mail() */
d795 3
a797 5
static void send_file_to_printer (
	DocInfo *	newdoc,
	char *		content_base,
	char *		sug_filename,
	int		printer_number)
d809 2
a810 2
				    ? HTML_SUFFIX
				    : TEXT_SUFFIX,
d835 2
a836 1
	int count=0;
d839 1
a839 2
	     count++, cur_printer = cur_printer->next)
	    ; /* null body */
d854 1
a854 1
    if (HTCountCommandArgs (cur_printer->command) >= 2) {
d856 1
a856 1
again:
d858 11
a868 11
check_again:
	switch (RecallFilename(my_file,     &FirstRecall, &FnameNum,
			       &FnameTotal, PRINT_FLAG))  {
	    case FN_INIT:
		goto again;
	    case FN_READ:
		goto check_again;
	    case FN_QUIT:
		goto done;
	    default:
		break;
d889 1
a889 1
#ifdef SH_EX	/* 1999/01/04 (Mon) 09:37:03 */
d894 1
a894 1
    HTAddParam (&the_command, cur_printer->command, 1, my_temp);
d896 2
a897 2
	HTAddParam (&the_command, cur_printer->command, 2, my_file);
	HTEndParam (&the_command, cur_printer->command, 3);
d899 1
a899 1
	HTEndParam (&the_command, cur_printer->command, 2);
d902 3
a904 3
    HTAddParam (&the_command, cur_printer->command, 1, my_temp);
    HTAddParam (&the_command, cur_printer->command, 2, my_file);
    HTEndParam (&the_command, cur_printer->command, 2);
d911 1
a911 1
    LYmove(1,1);
d915 1
a915 1
    SetOutputMode( O_TEXT );
d923 3
a925 3
    SET_ENVIRON(LYNX_PRINT_TITLE,   HText_getTitle(),        "No Title");
    SET_ENVIRON(LYNX_PRINT_URL,     newdoc->address,         "No URL");
    SET_ENVIRON(LYNX_PRINT_DATE,    HText_getDate(),         "No Date");
d936 3
a938 3
    SET_ENVIRON(LYNX_PRINT_TITLE,   "", "");
    SET_ENVIRON(LYNX_PRINT_URL,     "", "");
    SET_ENVIRON(LYNX_PRINT_DATE,    "", "");
d949 1
a949 1
    SetOutputMode( O_BINARY );
d953 1
a953 1
done:	/* send_file_to_printer() */
d957 2
a958 4
static void send_file_to_screen (
	DocInfo *	newdoc,
	char *		content_base,
	BOOLEAN	Lpansi)
d977 1
a977 1
    SetOutputMode( O_TEXT );
d1010 1
a1010 1
	fflush(stdout);  /* refresh to screen */
d1013 1
a1013 1
	fprintf(stdout,"\n\n%s", PRESS_RETURN_TO_FINISH);
d1021 1
a1021 1
    fprintf(stdout,"\n");
d1023 1
a1023 1
    SetOutputMode( O_BINARY );
d1026 1
a1026 1
done:	/* send_file_to_screen() */
d1030 1
a1030 2
int printfile (
	DocInfo *	newdoc)
d1045 1
a1045 1
     *	Extract useful info from URL.
d1047 1
a1047 1
    StrAllocCopy(link_info, newdoc->address+12);
d1050 1
a1050 1
     *	Reload the file we want to print into memory.
d1060 1
a1060 1
	return(NOT_FOUND);
d1063 2
a1064 2
     *	If we have an explicit content-base, we may use it even
     *	if not in source mode. - kw
d1074 2
a1075 2
     *	If document is source, load the content_base
     *	and content_location strings. - FM
d1100 1
a1100 1
     *	Get the number of lines in the file.
d1104 1
a1104 1
	 *  Terminate prev string here.
d1108 1
a1108 1
	 *  Number of characters in "lines=".
d1116 1
a1116 1
     *	Determine the type.
d1146 1
a1146 1
     *	Act on the request. - FM
d1150 3
a1152 3
	case TO_FILE:
	    send_file_to_file(newdoc, content_base, sug_filename);
	    break;
d1154 3
a1156 3
	case MAIL:
	    send_file_to_mail(newdoc, content_base, content_location);
	    break;
d1158 4
a1161 4
	case TO_SCREEN:
	    if (confirm_by_pages(CONFIRM_LONG_SCREEN_PRINT, lines_in_file, LYlines))
		send_file_to_screen(newdoc, content_base, Lpansi);
	    break;
d1163 4
a1166 4
	case PRINTER:
	    if (confirm_by_pages(CONFIRM_LONG_PAGE_PRINT, lines_in_file, pagelen))
		send_file_to_printer(newdoc, content_base, sug_filename, printer_number);
	    break;
d1168 1
a1168 1
    } /* end switch */
d1174 1
a1174 1
    return(NORMAL);
d1178 1
a1178 2
static int remove_quotes (
	char *		string)
d1180 1
a1180 1
   int i;
d1182 7
a1188 7
   for(i = 0; string[i] != '\0'; i++)
	if(string[i] == '"')
	   string[i] = ' ';
	else if(string[i] == '&')
	   string[i] = ' ';
	else if(string[i] == '|')
	   string[i] = ' ';
d1190 1
a1190 1
   return(0);
d1195 8
a1202 9
 *  Mail subject may have 8-bit characters and they are in display charset.
 *  There is no stable practice for 8-bit subject encodings:
 *  MIME defines "quoted-printable" which holds charset info
 *  but most mailers still don't support it.  On the other hand
 *  many mailers send open 8-bit subjects without charset info
 *  and use local assumption for certain countries.  Besides that,
 *  obsolete SMTP software is not 8bit clean but still in use,
 *  it strips the characters in 128-160 range from subjects
 *  which may be a fault outside iso-8859-XX.
d1204 3
a1206 3
 *  We translate subject to "outgoing_mail_charset" (defined in lynx.cfg)
 *  it may correspond to US-ASCII as the safest value or any other
 *  lynx character handler, -1 for no translation (so display charset).
d1208 1
a1208 1
 *  Always returns a new allocated string which has to be freed.
d1211 1
a1211 1
static char* subject_translate8bit (char * source)
d1217 1
a1217 1
    int i = outgoing_mail_charset;  /* from lynx.cfg, -1 by default */
d1221 4
a1224 4
     || i == current_char_set
     || LYCharSet_UC[current_char_set].enc == UCT_ENC_CJK
     || LYCharSet_UC[i].enc == UCT_ENC_CJK) {
	return(target); /* OK */
d1227 1
a1227 1
	charset_in  = current_char_set;
d1232 1
a1232 1
    return(target);
d1240 6
a1245 5
 *  LYNXPRINT://LOCAL_FILE/lines=#	     print to a local file
 *  LYNXPRINT://TO_SCREEN/lines=#	     print to the screen
 *  LYNXPRINT://LPANSI/lines=#		     print to the local terminal
 *  LYNXPRINT://MAIL_FILE/lines=#	     mail the file
 *  LYNXPRINT://PRINTER/lines=#/number=#   print to printer number #
d1247 3
a1249 4
int print_options (
	char **	newfile,
	const char *	printed_url,
	int		lines_in_file)
d1259 1
a1259 1
	return(-1);
d1268 8
a1275 7
    pages = (lines_in_file+65)/66;
    HTSprintf0(&buffer, "   <em>%s</em> %s\n   <em>%s</em> %d\n   <em>%s</em> %d %s %s\n",
	    gettext("Document:"), printed_url,
	    gettext("Number of lines:"), lines_in_file,
	    gettext("Number of pages:"), pages,
	    (pages > 1 ? gettext("pages") : gettext("page")),
	    gettext("(approximately)"));
d1280 3
a1282 1
	fprintf(fp0, "   <em>%s</em>\n", gettext("Some print functions have been disabled!"));
d1296 1
a1296 1
	fprintf(fp0,"   <em>%s</em>\n", gettext("Save to disk disabled"));
d1322 10
a1331 10
	cur_printer = cur_printer->next, count++)
    if (no_print == FALSE || cur_printer->always_enabled) {
	fprintf(fp0,
		"   <a href=\"%s//PRINTER/number=%d/pagelen=%d/lines=%d\">",
		STR_LYNXPRINT,
		count, cur_printer->pagelen, lines_in_file);
	fprintf(fp0, (cur_printer->name ?
		      cur_printer->name : "No Name Given"));
	fprintf(fp0, "</a>\n");
    }
d1337 1
a1337 1
    return(0);
a1339 1

d1341 1
a1341 1
 *  General purpose filename getter.
d1343 3
a1345 3
 *  Returns a pointer to an absolute filename string, if the input
 *  filename exists, and is readable.  Returns NULL if the input
 *  was cancelled (^G, or CR on empty input).
d1347 2
a1348 2
 *  The pointer to the filename string needs to be free()'d by the
 *  caller (when non-NULL).
d1350 1
a1350 1
 *  --KED  02/21/99
d1352 1
a1352 1
char * GetFileName (void)
d1356 2
a1357 2
    char  fbuf[LY_MAXPATH];
    char  tbuf[LY_MAXPATH];
d1361 2
a1362 3
    int     FnameNum    = -1;
    int     FnameTotal;

d1366 1
a1366 1
retry:
d1368 1
a1368 1
     *  No initial filename.
d1370 1
a1370 1
    SetupFilename (fbuf, "");
d1372 1
a1372 1
check_recall:
d1374 2
a1375 2
     *  Go get a filename (it would be nice to do TAB == filename-completion
     *  as the name is entered, but we'll save doing that for another time.
d1377 10
a1386 10
    switch (RecallFilename (fbuf,        &FirstRecall,  &FnameNum,
			    &FnameTotal, GENERIC_FLAG)) {
	case FN_INIT:
	    goto retry;
	case FN_READ:
	    goto check_recall;
	case FN_QUIT:
	    goto quit;
	default:
	    break;
d1390 2
a1391 2
     *  Add raw input form to list ... we may want to reuse/edit it on a
     *  subsequent call, etc.
d1394 3
a1396 3
    if (0 == strncasecomp (fbuf, "sys$disk:", 9)) {
	if (0 == strncmp ((fbuf+9), "[]", 2)) {
	    HTAddSugFilename (fbuf+11);
d1398 1
a1398 1
	    HTAddSugFilename (fbuf+9);
d1401 1
a1401 1
	HTAddSugFilename (fbuf);
d1404 1
a1404 1
    HTAddSugFilename (fbuf);
d1408 1
a1408 1
     *  Expand tilde's, make filename absolute, etc.
d1410 1
a1410 1
    if (!LYValidateFilename (tbuf, fbuf))
d1414 1
a1414 1
     *  Check for file existence; readability.
d1416 2
a1417 2
    if ((stat (tbuf, &stat_info) < 0) ||
       (!(S_ISREG(stat_info.st_mode)
d1419 1
a1419 1
	 || S_ISLNK(stat_info.st_mode)
d1421 2
a1422 2
	))) {
	HTInfoMsg (FILE_DOES_NOT_EXIST);
d1425 1
a1425 1
	FnameNum    = FnameTotal;
d1430 1
a1430 1
	HTInfoMsg (FILE_NOT_READABLE);
d1433 1
a1433 1
	FnameNum    = FnameTotal;
d1438 1
a1438 2
     *  We have a valid filename, and readable file.  Return it to the
     *  caller.
d1440 1
a1440 1
     *  The returned pointer should be free()'d by the caller.
d1442 3
a1444 3
     *  [For some silly reason, if we use StrAllocCopy() here, we get an
     *   "invalid pointer" reported in the Lynx.leaks file (if compiled
     *   with  --enable-find-leaks  turned on.  Dumb.]
d1446 2
a1447 3
    if ((fn = typecallocn(char, strlen (tbuf) + 1)) == NULL)
	outofmem(__FILE__, "GetFileName");
    return (strcpy (fn, tbuf));
d1449 1
d1451 1
a1451 1
quit:
d1453 1
a1453 1
     *  The user cancelled the input (^G, or CR on empty input field).
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d60 1
a60 1
PRIVATE int remove_quotes PARAMS((char *string));
d63 1
a63 1
PRIVATE  char* subject_translate8bit PARAMS((char *source));
d72 4
a75 4
PRIVATE void set_environ ARGS3(
	int,		name,
	CONST char *,	value,
	CONST char *,	no_value)
d77 1
a77 1
    static CONST char *names[MAX_PUTENV] = {
d108 2
a109 2
PRIVATE char *suggested_filename ARGS1(
	DocInfo *,	newdoc)
d143 3
a145 3
PRIVATE void SetupFilename ARGS2(
	char *,		filename,
	char *,		sug_filename)
d173 6
a178 6
PRIVATE int RecallFilename ARGS5(
	char *,		filename,
	BOOLEAN *,	first,
	int *,		now,
	int *,		total,
	int,		flag)
d275 4
a278 4
PRIVATE BOOLEAN confirm_by_pages ARGS3(
	char *,		prompt,
	int,		lines_in_file,
	int,		lines_per_page)
d304 4
a307 4
PRIVATE void send_file_to_file ARGS3(
	DocInfo *,	newdoc,
	char *,		content_base,
	char *,		sug_filename)
d311 1
a311 1
    CONST char *disp_charset;
d446 1
a446 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* FILE */
d475 4
a478 4
PRIVATE void send_file_to_mail ARGS3(
	DocInfo *,	newdoc,
	char *,		content_base,
	char *,		content_location)
d494 1
a494 1
    CONST char *disp_charset;
d634 1
a634 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* MAIL */
d775 1
a775 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* MAIL */
d799 5
a803 5
PRIVATE void send_file_to_printer ARGS4(
	DocInfo *,	newdoc,
	char *,		content_base,
	char *,		sug_filename,
	int,		printer_number)
d833 1
a833 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* PRINTER */
d963 4
a966 4
PRIVATE void send_file_to_screen ARGS3(
	DocInfo *,	newdoc,
	char *,		content_base,
	BOOLEAN,	Lpansi)
d1004 1
a1004 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* SCREEN */
d1038 2
a1039 2
PUBLIC int printfile ARGS1(
	DocInfo *,	newdoc)
d1187 2
a1188 2
PRIVATE int remove_quotes ARGS1(
	char *,		string)
d1222 1
a1222 1
PRIVATE char* subject_translate8bit ARGS1(char *, source)
d1257 4
a1260 4
PUBLIC int print_options ARGS3(
	char **,	newfile,
	CONST char *,	printed_url,
	int,		lines_in_file)
d1361 1
a1361 1
PUBLIC char * GetFileName NOARGS
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d59 1
a59 1
#ifdef VMS
d61 1
a61 1
#endif /* VMS */
d109 1
a109 1
	document *,	newdoc)
d160 1
a160 1
	    strcpy(cp, ".txt");
d191 1
a191 1
    recall = ((*total >= 1) ? RECALL : NORECALL);
d295 1
a295 1
	    addstr("   Ok...");
d305 1
a305 1
	document *,	newdoc,
d363 1
a363 1
    CTRACE(tfp, "LYPrint: filename is %s, action is `%c'\n", buffer, c);
d365 1
a365 1
#if HAVE_POPEN
d373 1
a373 1
	    CTRACE(tfp, "LYPrint: errno is %d\n", errno);
d385 1
a385 1
	CTRACE(tfp, "LYPrint: errno is %d\n", errno);
d405 2
a406 2
	if (HText_getDate() != NULL)
	     fprintf(outfile_fp,
d408 8
d446 1
a446 1
    print_wwwfile_to_fd(outfile_fp,0);
d450 1
a450 1
#if HAVE_POPEN
d455 2
a456 1
    fclose(outfile_fp);
d476 1
a476 1
	document *,	newdoc,
d482 2
a483 2
#ifdef VMS
    BOOLEAN isPMDF = !strncasecomp(system_mail, "PMDF SEND", 9);
a485 1
    char my_temp[LY_MAXPATH];
d487 2
a488 1
#ifdef DOSPATH
a492 1
    BOOL use_mime;
d500 3
d506 1
a506 1
	    addstr("   Ok...");
d515 1
a515 1
    if (LYgetstr(user_response, VISIBLE, sizeof(user_response), NORECALL) < 0 ||
d536 1
a536 1
    use_type =  (disp_charset || HTisDocumentSource());
d543 1
a543 1
   subject = subject_translate8bit(newdoc->title);
d545 8
a552 8
   if (newdoc->isHEAD) {
	   /*
	    * Special case for mailing HEAD responce:  this is rather technical
	    * information, show URL.
	    */
	   FREE(subject);
	   StrAllocCopy(subject, "HEAD  ");
	   StrAllocCat(subject, newdoc->address);
d555 1
a555 1
#ifdef VMS
d567 1
a567 1
				    : ".txt",
d574 1
a574 1
	if ((hfd = LYOpenTemp(hdrfile, ".txt", "w")) == NULL) {
d611 5
d634 1
a634 1
    print_wwwfile_to_fd(outfile_fp, 0);
d639 1
a641 5
	 * For PMDF, put the subject in the header file and close it.  - FM
	 */
	fprintf(hfd, "Subject: %.70s\n\n", subject);
	LYCloseTempFP(hfd);
	/*
d666 1
d669 1
a669 1
    sleep(AlertSecs);
d671 2
d676 1
a676 1
#else /* Unix or DOS */
d678 2
a679 2
#ifdef DOSPATH
    outfile_fp = LYOpenTemp(my_temp, ".txt", "w");
d681 1
a681 2
    HTSprintf0(&buffer, "%s %s", system_mail, system_mail_flags);
    outfile_fp = popen(buffer, "w");
d714 2
a715 2
    use_type = (disp_charset || HTisDocumentSource());
    use_mime = (use_cte || use_type);
d775 1
a775 1
    print_wwwfile_to_fd(outfile_fp, 0);
d779 10
a788 8
#ifdef DOSPATH
    HTSprintf0(&buffer, "%s -t \"%s\" -F %s", system_mail, user_response, my_temp);
    LYCloseTempFP(outfile_fp);	/* Close the tmpfile. */
    stop_curses();
    printf("%s\n\n$ %s\n\n%s", gettext("Sending"), buffer, PLEASE_WAIT);
    LYSystem(buffer);
    sleep(MessageSecs);
    start_curses();
d790 2
a791 4
#else
    pclose(outfile_fp);
#endif
#endif /* VMS */
d793 1
a793 1
done:
d800 1
a800 1
	document *,	newdoc,
d811 1
a811 1
    lynx_printer_item_type *cur_printer;
d816 1
a816 1
				    : ".txt",
d833 1
a833 1
    print_wwwfile_to_fd(outfile_fp, 0);
d888 1
a888 1
	 * (case-insensitive) on VMS.  - FM
d890 1
a890 7
#ifdef VMS
	if (!strncasecomp(my_file, "nl:", 3) ||
	    !strncasecomp(my_file, "/nl/", 4))
#else
	if (!strcmp(my_file, "/dev/null"))
#endif /* VMS */
	{
d895 4
d901 8
d911 1
d917 1
a917 1
    move(1,1);
d920 2
a921 1
    CTRACE(tfp, "command: %s\n", the_command);
d951 6
a956 1
    sleep(MessageSecs);
d959 1
a959 1
done:
d964 1
a964 1
	document *,	newdoc,
d985 2
d1004 1
a1004 1
    print_wwwfile_to_fd(outfile_fp, 0);
d1018 1
d1022 2
a1023 1
	LYgetch();  /* grab some user input to pause */
d1028 4
a1031 1
    fflush(stdout);  /* refresh to screen */
d1034 1
a1034 1
done:
d1039 1
a1039 1
	document *,	newdoc)
d1111 1
a1111 1
    if ((cp = (char *)strstr(link_info, "lines=")) != NULL) {
d1139 1
a1139 1
	if ((cp = (char *)strstr(link_info, "number=")) != NULL) {
d1144 1
a1144 1
	if ((cp = (char *)strstr(link_info, "pagelen=")) != NULL) {
d1186 1
a1186 1
#ifdef VMS
d1202 1
a1202 1
#endif /* VMS */
d1207 2
a1208 2
 *  MIME define "quoted-printable" which holds charset info
 *  but most mailers still don't support it, on the other hand
d1221 1
a1223 2
    CONST char *p = source;
    char temp[2];
a1226 1
    char replace_buf [10];
d1230 1
a1234 1
	StrAllocCopy(target, source);
d1241 1
a1241 10
    for ( ; *p; p++) {
	LYstrncpy(temp, p, sizeof(temp)-1);
	if ((unsigned char)*temp <= 127) {
	    StrAllocCat(target, temp);
	} else {
	    if (UCTransCharStr(replace_buf, sizeof(replace_buf), *temp,
				charset_in, charset_out, YES) > 0)
		StrAllocCat(target, replace_buf);
	}
    }
d1259 1
a1259 1
	char **,	printed_url,
d1262 1
a1262 1
    static char my_temp[LY_MAXPATH];
d1267 1
a1267 1
    lynx_printer_item_type *cur_printer;
d1269 1
a1269 3
    LYRemoveTemp(my_temp);
    if ((fp0 = LYOpenTemp(my_temp, HTML_SUFFIX, "w")) == NULL) {
	HTAlert(UNABLE_TO_OPEN_PRINTOP_FILE);
a1270 1
    }
d1281 1
a1281 1
	    gettext("Document:"), *printed_url,
d1299 2
a1300 1
		"   <a href=\"LYNXPRINT://LOCAL_FILE/lines=%d\">%s</a>\n",
d1308 2
a1309 1
		"   <a href=\"LYNXPRINT://MAIL_FILE/lines=%d\">%s</a>\n",
d1313 1
a1313 1
#ifndef DOSPATH
d1315 2
a1316 1
	    "   <a href=\"LYNXPRINT://TO_SCREEN/lines=%d\">%s</a>\n",
d1320 2
a1321 1
	    "   <a href=\"LYNXPRINT://LPANSI/lines=%d\">%s</a>\n",
d1333 2
a1334 1
		"   <a href=\"LYNXPRINT://PRINTER/number=%d/pagelen=%d/lines=%d\">",
a1364 2
    FILE *fp;

d1439 1
a1439 1
    if ((fp = fopen (tbuf, "r")) == NULL) {
a1444 2
    } else {
	fclose (fp);
d1457 1
a1457 1
    if ((fn = (char *) calloc (1, (strlen (tbuf) + 1))) == NULL)
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d17 1
a17 1
#include <LYCharSets.h>		/* To get current charset for mail header. */
d25 2
a26 2
 * printfile prints out the current file minus the links and targets to a
 * variety of places
d31 5
a35 5
 * LYNXPRINT://LOCAL_FILE/lines=##
 * LYNXPRINT://MAIL_FILE/lines=##
 * LYNXPRINT://TO_SCREEN/lines=##
 * LYNXPRINT://LPANSI/lines=##
 * LYNXPRINT://PRINTER/lines=##/number=#
d59 3
a61 3
#if USE_VMS_MAILER
static int remove_quotes(char *string);
#endif /* USE_VMS_MAILER */
d63 1
a63 1
static char *subject_translate8bit(char *source);
d72 4
a75 3
static void set_environ(int name,
			const char *value,
			const char *no_value)
d77 1
a77 2
    static const char *names[MAX_PUTENV] =
    {
a84 1

a87 1

d89 1
a89 1
    if (isEmpty(envbuffer))
d108 2
a109 1
static char *suggested_filename(DocInfo *newdoc)
d114 1
a114 1
     * Load the suggested filename string.  - FM
d117 1
a117 1
	StrAllocCopy(sug_filename, HText_getSugFname());	/* must be freed */
d119 1
a119 1
	StrAllocCopy(sug_filename, newdoc->address);	/* must be freed */
d121 1
a121 1
     * Strip any gzip or compress suffix, if present.  - FM
d125 1
a125 1
	cp = (char *) &sug_filename[(strlen(sug_filename) - 3)];
d134 1
a134 1
	cp = (char *) &sug_filename[(strlen(sug_filename) - 2)];
d143 3
a145 2
static void SetupFilename(char *filename,
			  const char *sug_filename)
d151 1
a151 1
    LYstrncpy(filename, sug_filename, LY_MAXPATH - 1);	/* add suggestion info */
d155 2
a156 2
	&& (cp = strrchr(filename, '.')) != NULL
	&& (cp - filename) < LY_MAXPATH - 5) {
d160 1
a160 1
	    strcpy(cp, TEXT_SUFFIX);
d173 6
a178 5
static int RecallFilename(char *filename,
			  BOOLEAN *first,
			  int *now,
			  int *total,
			  int flag)
d182 1
a182 1
    RecallType recall;
d191 1
a191 1
    recall = ((*total >= 1) ? RECALL_URL : NORECALL);
d217 4
a220 3
	    } else if ((cp = (char *) HTList_objectAt(sug_filenames,
						      *now)) != NULL) {
		LYstrncpy(filename, cp, LY_MAXPATH - 1);
d249 4
a252 3
	    } else if ((cp = (char *) HTList_objectAt(sug_filenames,
						      *now)) != NULL) {
		LYstrncpy(filename, cp, LY_MAXPATH - 1);
d275 4
a278 3
static BOOLEAN confirm_by_pages(const char *prompt,
				int lines_in_file,
				int lines_per_page)
d280 1
a280 1
    int pages = lines_in_file / (lines_per_page + 1);
d284 1
a284 1
    if ((lines_in_file % (LYlines + 1)) > 0)
d295 1
a295 1
	    LYaddstr("   Ok...");
d304 4
a307 2
static void send_file_to_file(DocInfo *newdoc, char *content_base,
			      char *sug_filename)
d311 1
a311 1
    const char *disp_charset;
d320 1
a320 1
  retry:
d323 1
a323 1
	&& (strlen(lynx_save_space) + strlen(filename)) < sizeof(filename)) {
d328 11
a338 11
  check_recall:
    switch (RecallFilename(filename, &FirstRecall, &FnameNum,
			   &FnameTotal, PRINT_FLAG)) {
    case FN_INIT:
	goto retry;
    case FN_READ:
	goto check_recall;
    case FN_QUIT:
	goto done;
    default:
	break;
d363 1
a363 1
    CTRACE((tfp, "LYPrint: filename is %s, action is `%c'\n", buffer, c));
d365 1
a365 1
#ifdef HAVE_POPEN
d372 2
a373 2
	} else if ((outfile_fp = popen(buffer + 1, "w")) == NULL) {
	    CTRACE((tfp, "LYPrint: errno is %d\n", errno));
d382 4
a385 4
	if ((outfile_fp = (TOUPPER(c) == 'A'
			   ? LYAppendToTxtFile(buffer)
			   : LYNewTxtFile(buffer))) == NULL) {
	CTRACE((tfp, "LYPrint: errno is %d\n", errno));
d405 3
a407 12
	if (HText_getDate() != NULL) {
	    fprintf(outfile_fp,
		    "<!-- Date: %s -->\n", HText_getDate());
	    if (HText_getLastModified() != NULL
		&& strcmp(HText_getLastModified(), HText_getDate())
		&& strcmp(HText_getLastModified(),
			  "Thu, 01 Jan 1970 00:00:01 GMT")) {
		fprintf(outfile_fp,
			"<!-- Last-Modified: %s -->\n", HText_getLastModified());
	    }
	}

d438 1
a438 1
    print_wwwfile_to_fd(outfile_fp, FALSE, FALSE);	/* FILE */
d440 1
a440 1
	printlist(outfile_fp, FALSE);
d442 1
a442 1
#ifdef HAVE_POPEN
d447 1
a447 2
	LYCloseOutput(outfile_fp);

d450 2
a451 2
	if (0 == strncmp((buffer + 9), "[]", 2)) {
	    HTAddSugFilename(buffer + 11);
d453 1
a453 1
	    HTAddSugFilename(buffer + 9);
d462 1
a462 1
  done:
d466 4
a469 2
static void send_file_to_mail(DocInfo *newdoc, char *content_base,
			      char *content_location)
d473 2
a474 2
#if USE_VMS_MAILER
    BOOLEAN isPMDF = LYMailPMDF();
d477 1
d479 1
a479 3
    BOOL use_mime;

#if !CAN_PIPE_TO_MAILER
d484 1
d486 1
a486 1
    const char *disp_charset;
a491 3
    if (!LYSystemMail())
	return;

d495 1
a495 1
	    LYaddstr("   Ok...");
d497 1
a497 1
	} else {
d503 2
a504 5
    LYstrncpy(user_response, personal_mail_address, sizeof(user_response) - 1);
    if (LYgetstr(user_response,
		 VISIBLE,
		 sizeof(user_response),
		 RECALL_MAIL) < 0 ||
d525 1
a525 1
    use_type = (BOOL) (disp_charset || HTisDocumentSource());
d532 11
a542 1
    subject = subject_translate8bit(newdoc->title);
d544 3
a546 12
    if (newdoc->isHEAD) {
	/*
	 * Special case for mailing HEAD responce:  this is rather technical
	 * information, show URL.
	 */
	FREE(subject);
	StrAllocCopy(subject, "HEAD  ");
	StrAllocCat(subject, newdoc->address);
    }
#if USE_VMS_MAILER
    if (strchr(user_response, '@@') && !strchr(user_response, ':') &&
	!strchr(user_response, '%') && !strchr(user_response, '"')) {
a547 1

d549 1
a549 1
	LYstrncpy(user_response, temp, sizeof(user_response) - 1);
d555 2
a556 2
			    ? HTML_SUFFIX
			    : TEXT_SUFFIX,
d563 1
a563 1
	if ((hfd = LYOpenTemp(hdrfile, TEXT_SUFFIX, "w")) == NULL) {
d597 1
a597 1
	 * X-URL header.  - FM
a599 5
	/*
	 * For PMDF, put the subject in the header file and close it.  - FM
	 */
	fprintf(hfd, "Subject: %.70s\n\n", subject);
	LYCloseTempFP(hfd);
d603 1
a603 1
     * Write the contents to a temp file.
d618 1
a618 1
    print_wwwfile_to_fd(outfile_fp, TRUE, FALSE);	/* MAIL */
a622 1
    buffer = NULL;
d625 5
d633 6
a638 6
		   "%s %s %s,%s %s",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_temp,
		   user_response);
d645 6
a650 6
		   "%s %s/subject=\"%.70s\" %s %s",
		   system_mail,
		   system_mail_flags,
		   subject,
		   my_temp,
		   user_response);
a653 1
    SetOutputMode(O_TEXT);
d656 1
a656 1
    LYSleepAlert();
a657 2
    SetOutputMode(O_BINARY);

d661 1
a661 1
#else /* !VMS (Unix or DOS) */
d663 2
a664 2
#if CAN_PIPE_TO_MAILER
    outfile_fp = LYPipeToMailer();
d666 2
a667 1
    outfile_fp = LYOpenTemp(my_temp, TEXT_SUFFIX, "w");
d695 2
a696 2
    /* Enable this if indicating an 8-bit transfer without also indicating the
     * charset causes problems.  - kw */
d700 2
a701 2
    use_type = (BOOL) (disp_charset || HTisDocumentSource());
    use_mime = (BOOL) (use_cte || use_type);
d745 1
a745 1
     * Add the To, Subject, and X-URL headers.  - FM
d761 1
a761 1
    print_wwwfile_to_fd(outfile_fp, TRUE, FALSE);	/* MAIL */
d765 10
a774 1
#if CAN_PIPE_TO_MAILER
d776 2
a777 10
#else
    LYCloseOutput(outfile_fp);
    LYSendMailFile(user_response,
		   my_temp,
		   subject,
		   "",
		   "");
    LYRemoveTemp(my_temp);	/* Delete the tmpfile. */
#endif /* CAN_PIPE_TO_MAILER */
#endif /* USE_VMS_MAILER */
d779 1
a779 1
  done:			/* send_file_to_mail() */
d785 5
a789 3
static void send_file_to_printer(DocInfo *newdoc, char *content_base,
				 char *sug_filename,
				 int printer_number)
d797 1
a797 1
    lynx_list_item_type *cur_printer;
d801 2
a802 2
			    ? HTML_SUFFIX
			    : TEXT_SUFFIX,
d819 1
a819 1
    print_wwwfile_to_fd(outfile_fp, FALSE, FALSE);	/* PRINTER */
d827 1
a827 2
	int count = 0;

d830 2
a831 1
	     count++, cur_printer = cur_printer->next) ;	/* null body */
d846 1
a846 1
    if (HTCountCommandArgs(cur_printer->command) >= 2) {
d848 1
a848 1
      again:
d850 11
a860 11
      check_again:
	switch (RecallFilename(my_file, &FirstRecall, &FnameNum,
			       &FnameTotal, PRINT_FLAG)) {
	case FN_INIT:
	    goto again;
	case FN_READ:
	    goto check_again;
	case FN_QUIT:
	    goto done;
	default:
	    break;
d874 1
a874 1
	 * on VMS.  - FM
d876 7
a882 1
	if (LYIsNullDevice(my_file)) {
a886 4
#ifdef SH_EX			/* 1999/01/04 (Mon) 09:37:03 */
    else {
	my_file[0] = '\0';
    }
d888 3
a890 12
    HTAddParam(&the_command, cur_printer->command, 1, my_temp);
    if (my_file[0]) {
	HTAddParam(&the_command, cur_printer->command, 2, my_file);
	HTEndParam(&the_command, cur_printer->command, 3);
    } else {
	HTEndParam(&the_command, cur_printer->command, 2);
    }
#else
    HTAddParam(&the_command, cur_printer->command, 1, my_temp);
    HTAddParam(&the_command, cur_printer->command, 2, my_file);
    HTEndParam(&the_command, cur_printer->command, 2);
#endif
d896 1
a896 1
    LYmove(1, 1);
d899 1
a899 2
    CTRACE((tfp, "command: %s\n", the_command));
    SetOutputMode(O_TEXT);
d907 3
a909 3
    SET_ENVIRON(LYNX_PRINT_TITLE, HText_getTitle(), "No Title");
    SET_ENVIRON(LYNX_PRINT_URL, newdoc->address, "No URL");
    SET_ENVIRON(LYNX_PRINT_DATE, HText_getDate(), "No Date");
d920 3
a922 3
    SET_ENVIRON(LYNX_PRINT_TITLE, "", "");
    SET_ENVIRON(LYNX_PRINT_URL, "", "");
    SET_ENVIRON(LYNX_PRINT_DATE, "", "");
d929 1
a929 6
#ifdef SH_EX
    fprintf(stdout, gettext(" Print job complete.\n"));
    fflush(stdout);
#endif
    SetOutputMode(O_BINARY);
    LYSleepMsg();
d932 1
a932 1
  done:			/* send_file_to_printer() */
d936 4
a939 2
static void send_file_to_screen(DocInfo *newdoc, char *content_base,
				BOOLEAN Lpansi)
a957 2
    SetOutputMode(O_TEXT);

d975 1
a975 1
    print_wwwfile_to_fd(outfile_fp, FALSE, FALSE);	/* SCREEN */
a988 1
	fflush(stdout);		/* refresh to screen */
d991 2
a992 3
	fprintf(stdout, "\n\n%s", PRESS_RETURN_TO_FINISH);
	fflush(stdout);		/* refresh to screen */
	(void) LYgetch();	/* grab some user input to pause */
d997 1
a997 4
#ifdef SH_EX
    fprintf(stdout, "\n");
#endif
    SetOutputMode(O_BINARY);
d1000 1
a1000 1
  done:			/* send_file_to_screen() */
d1004 2
a1005 1
int printfile(DocInfo *newdoc)
d1020 1
a1020 1
     * Extract useful info from URL.
d1022 1
a1022 1
    StrAllocCopy(link_info, newdoc->address + 12);
d1025 1
a1025 1
     * Reload the file we want to print into memory.
d1035 1
a1035 1
	return (NOT_FOUND);
d1038 2
a1039 2
     * If we have an explicit content-base, we may use it even if not in source
     * mode.  - kw
d1044 1
a1044 1
	if (isEmpty(content_base)) {
d1049 2
a1050 2
     * If document is source, load the content_base and content_location
     * strings.  - FM
d1056 1
a1056 1
	    if (isEmpty(content_location)) {
d1075 1
a1075 1
     * Get the number of lines in the file.
d1077 1
a1077 1
    if ((cp = strstr(link_info, "lines=")) != NULL) {
d1079 1
a1079 1
	 * Terminate prev string here.
d1083 1
a1083 1
	 * Number of characters in "lines=".
d1091 1
a1091 1
     * Determine the type.
d1105 1
a1105 1
	if ((cp = strstr(link_info, "number=")) != NULL) {
d1110 1
a1110 1
	if ((cp = strstr(link_info, "pagelen=")) != NULL) {
d1121 1
a1121 1
     * Act on the request.  - FM
d1125 3
a1127 3
    case TO_FILE:
	send_file_to_file(newdoc, content_base, sug_filename);
	break;
d1129 3
a1131 3
    case MAIL:
	send_file_to_mail(newdoc, content_base, content_location);
	break;
d1133 4
a1136 4
    case TO_SCREEN:
	if (confirm_by_pages(CONFIRM_LONG_SCREEN_PRINT, lines_in_file, LYlines))
	    send_file_to_screen(newdoc, content_base, Lpansi);
	break;
d1138 4
a1141 4
    case PRINTER:
	if (confirm_by_pages(CONFIRM_LONG_PAGE_PRINT, lines_in_file, pagelen))
	    send_file_to_printer(newdoc, content_base, sug_filename, printer_number);
	break;
d1143 1
a1143 1
    }				/* end switch */
d1149 1
a1149 1
    return (NORMAL);
d1152 3
a1154 2
#if USE_VMS_MAILER
static int remove_quotes(char *string)
d1156 1
a1156 1
    int i;
d1158 7
a1164 7
    for (i = 0; string[i] != '\0'; i++)
	if (string[i] == '"')
	    string[i] = ' ';
	else if (string[i] == '&')
	    string[i] = ' ';
	else if (string[i] == '|')
	    string[i] = ' ';
d1166 1
a1166 1
    return (0);
d1168 1
a1168 1
#endif /* USE_VMS_MAILER */
d1171 9
a1179 8
 * Mail subject may have 8-bit characters and they are in display charset. 
 * There is no stable practice for 8-bit subject encodings:  MIME defines
 * "quoted-printable" which holds charset info but most mailers still don't
 * support it.  On the other hand many mailers send open 8-bit subjects without
 * charset info and use local assumption for certain countries.  Besides that,
 * obsolete SMTP software is not 8bit clean but still in use, it strips the
 * characters in 128-160 range from subjects which may be a fault outside
 * iso-8859-XX.
d1181 3
a1183 3
 * We translate subject to "outgoing_mail_charset" (defined in lynx.cfg) it may
 * correspond to US-ASCII as the safest value or any other lynx character
 * handler, -1 for no translation (so display charset).
d1185 1
a1185 1
 * Always returns a new allocated string which has to be freed.
d1187 1
a1187 2
#include <LYCharUtils.h>
static char *subject_translate8bit(char *source)
d1189 2
d1194 1
d1196 1
a1196 1
    int i = outgoing_mail_charset;	/* from lynx.cfg, -1 by default */
a1197 1
    StrAllocCopy(target, source);
d1199 5
a1203 4
	|| i == current_char_set
	|| LYCharSet_UC[current_char_set].enc == UCT_ENC_CJK
	|| LYCharSet_UC[i].enc == UCT_ENC_CJK) {
	return (target);	/* OK */
d1206 1
a1206 1
	charset_in = current_char_set;
d1209 10
a1218 1
    LYUCTranslateBackHeaderText(&target, charset_in, charset_out, YES);
d1220 1
a1220 1
    return (target);
d1228 5
a1232 6
 *
 * LYNXPRINT://LOCAL_FILE/lines=#	     print to a local file
 * LYNXPRINT://TO_SCREEN/lines=#	     print to the screen
 * LYNXPRINT://LPANSI/lines=#		     print to the local terminal
 * LYNXPRINT://MAIL_FILE/lines=#	     mail the file
 * LYNXPRINT://PRINTER/lines=#/number=#      print to printer number #
d1234 4
a1237 3
int print_options(char **newfile,
		  const char *printed_url,
		  int lines_in_file)
d1239 1
a1239 1
    static char my_temp[LY_MAXPATH] = "\0";
d1244 1
a1244 1
    lynx_list_item_type *cur_printer;
d1246 5
a1250 2
    if ((fp0 = InternalPageFP(my_temp, TRUE)) == 0)
	return (-1);
d1259 7
a1265 8
    pages = (lines_in_file + 65) / 66;
    HTSprintf0(&buffer,
	       "   <em>%s</em> %s\n   <em>%s</em> %d\n   <em>%s</em> %d %s %s\n",
	       gettext("Document:"), printed_url,
	       gettext("Number of lines:"), lines_in_file,
	       gettext("Number of pages:"), pages,
	       (pages > 1 ? gettext("pages") : gettext("page")),
	       gettext("(approximately)"));
d1270 1
a1270 3
	fprintf(fp0,
		"   <em>%s</em>\n",
		gettext("Some print functions have been disabled!"));
d1279 1
a1279 2
		"   <a href=\"%s//LOCAL_FILE/lines=%d\">%s</a>\n",
		STR_LYNXPRINT,
d1283 1
a1283 1
	fprintf(fp0, "   <em>%s</em>\n", gettext("Save to disk disabled"));
d1287 1
a1287 2
		"   <a href=\"%s//MAIL_FILE/lines=%d\">%s</a>\n",
		STR_LYNXPRINT,
d1291 1
a1291 1
#if defined(UNIX) || defined(VMS)
d1293 1
a1293 2
	    "   <a href=\"%s//TO_SCREEN/lines=%d\">%s</a>\n",
	    STR_LYNXPRINT,
d1297 1
a1297 2
	    "   <a href=\"%s//LPANSI/lines=%d\">%s</a>\n",
	    STR_LYNXPRINT,
d1306 9
a1314 10
	 cur_printer = cur_printer->next, count++)
	if (no_print == FALSE || cur_printer->always_enabled) {
	    fprintf(fp0,
		    "   <a href=\"%s//PRINTER/number=%d/pagelen=%d/lines=%d\">",
		    STR_LYNXPRINT,
		    count, cur_printer->pagelen, lines_in_file);
	    fprintf(fp0, (cur_printer->name ?
			  cur_printer->name : "No Name Given"));
	    fprintf(fp0, "</a>\n");
	}
d1320 1
a1320 1
    return (0);
d1323 1
d1325 1
a1325 1
 * General purpose filename getter.
d1327 3
a1329 3
 * Returns a pointer to an absolute filename string, if the input filename
 * exists, and is readable.  Returns NULL if the input was cancelled (^G, or CR
 * on empty input).
d1331 2
a1332 2
 * The pointer to the filename string needs to be free()'d by the caller (when
 * non-NULL).
d1334 1
a1334 1
 * --KED 02/21/99
d1336 1
a1336 1
char *GetFileName(void)
d1340 4
a1343 2
    char fbuf[LY_MAXPATH];
    char tbuf[LY_MAXPATH];
d1347 3
a1349 2
    int FnameNum = -1;
    int FnameTotal;
d1353 1
a1353 1
  retry:
d1355 1
a1355 1
     * No initial filename.
d1357 1
a1357 1
    SetupFilename(fbuf, "");
d1359 1
a1359 1
  check_recall:
d1361 2
a1362 2
     * Go get a filename (it would be nice to do TAB == filename-completion as
     * the name is entered, but we'll save doing that for another time.
d1364 10
a1373 10
    switch (RecallFilename(fbuf, &FirstRecall, &FnameNum,
			   &FnameTotal, GENERIC_FLAG)) {
    case FN_INIT:
	goto retry;
    case FN_READ:
	goto check_recall;
    case FN_QUIT:
	goto quit;
    default:
	break;
d1377 2
a1378 2
     * Add raw input form to list ...  we may want to reuse/edit it on a
     * subsequent call, etc.
d1381 3
a1383 3
    if (0 == strncasecomp(fbuf, "sys$disk:", 9)) {
	if (0 == strncmp((fbuf + 9), "[]", 2)) {
	    HTAddSugFilename(fbuf + 11);
d1385 1
a1385 1
	    HTAddSugFilename(fbuf + 9);
d1388 1
a1388 1
	HTAddSugFilename(fbuf);
d1391 1
a1391 1
    HTAddSugFilename(fbuf);
d1395 1
a1395 1
     * Expand tilde's, make filename absolute, etc.
d1397 1
a1397 1
    if (!LYValidateFilename(tbuf, fbuf))
d1401 1
a1401 1
     * Check for file existence; readability.
d1403 2
a1404 2
    if ((stat(tbuf, &stat_info) < 0) ||
	(!(S_ISREG(stat_info.st_mode)
d1406 1
a1406 1
	   || S_ISLNK(stat_info.st_mode)
d1408 2
a1409 2
	 ))) {
	HTInfoMsg(FILE_DOES_NOT_EXIST);
d1412 1
a1412 1
	FnameNum = FnameTotal;
d1416 2
a1417 2
    if (!LYCanReadFile(tbuf)) {
	HTInfoMsg(FILE_NOT_READABLE);
d1420 1
a1420 1
	FnameNum = FnameTotal;
d1422 2
d1427 2
a1428 1
     * We have a valid filename, and readable file.  Return it to the caller.
d1430 1
a1430 1
     * The returned pointer should be free()'d by the caller.
d1432 3
a1434 3
     * [For some silly reason, if we use StrAllocCopy() here, we get an
     * "invalid pointer" reported in the Lynx.leaks file (if compiled with
     * --enable-find-leaks turned on.  Dumb.]
d1436 3
a1438 2
    if ((fn = typecallocn(char, strlen(tbuf) + 1)) == NULL)
	  outofmem(__FILE__, "GetFileName");
a1439 1
    return (strcpy(fn, tbuf));
d1441 1
a1441 1
  quit:
d1443 1
a1443 1
     * The user cancelled the input (^G, or CR on empty input field).
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d59 1
a59 1
#if USE_VMS_MAILER
d61 1
a61 1
#endif /* USE_VMS_MAILER */
d109 1
a109 1
	DocInfo *,	newdoc)
d160 1
a160 1
	    strcpy(cp, TEXT_SUFFIX);
d191 1
a191 1
    recall = ((*total >= 1) ? RECALL_URL : NORECALL);
d295 1
a295 1
	    LYaddstr("   Ok...");
d305 1
a305 1
	DocInfo *,	newdoc,
d363 1
a363 1
    CTRACE((tfp, "LYPrint: filename is %s, action is `%c'\n", buffer, c));
d365 1
a365 1
#ifdef HAVE_POPEN
d373 1
a373 1
	    CTRACE((tfp, "LYPrint: errno is %d\n", errno));
d385 1
a385 1
	CTRACE((tfp, "LYPrint: errno is %d\n", errno));
d405 2
a406 2
	if (HText_getDate() != NULL) {
	    fprintf(outfile_fp,
a407 8
	    if (HText_getLastModified() != NULL
			&& strcmp(HText_getLastModified(), HText_getDate())
			&& strcmp(HText_getLastModified(), "Thu, 01 Jan 1970 00:00:01 GMT")) {
		fprintf(outfile_fp,
		    "<!-- Last-Modified: %s -->\n", HText_getLastModified());
	    }
	}

d438 1
a438 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* FILE */
d442 1
a442 1
#ifdef HAVE_POPEN
d447 1
a447 2
	LYCloseOutput(outfile_fp);

d467 1
a467 1
	DocInfo *,	newdoc,
d473 2
a474 2
#if USE_VMS_MAILER
    BOOLEAN isPMDF = LYMailPMDF();
d477 1
d479 1
a479 2
    BOOL use_mime;
#if !CAN_PIPE_TO_MAILER
d484 1
a491 3
    if (!LYSystemMail())
	return;

d495 1
a495 1
	    LYaddstr("   Ok...");
d504 1
a504 1
    if (LYgetstr(user_response, VISIBLE, sizeof(user_response), RECALL_MAIL) < 0 ||
d525 1
a525 1
    use_type = (BOOL) (disp_charset || HTisDocumentSource());
d532 1
a532 1
    subject = subject_translate8bit(newdoc->title);
d534 8
a541 8
    if (newdoc->isHEAD) {
	/*
	 * Special case for mailing HEAD responce:  this is rather technical
	 * information, show URL.
	 */
	FREE(subject);
	StrAllocCopy(subject, "HEAD  ");
	StrAllocCat(subject, newdoc->address);
d544 1
a544 1
#if USE_VMS_MAILER
d556 1
a556 1
				    : TEXT_SUFFIX,
d563 1
a563 1
	if ((hfd = LYOpenTemp(hdrfile, TEXT_SUFFIX, "w")) == NULL) {
a599 5
	/*
	 * For PMDF, put the subject in the header file and close it.  - FM
	 */
	fprintf(hfd, "Subject: %.70s\n\n", subject);
	LYCloseTempFP(hfd);
d618 1
a618 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* MAIL */
a622 1
    buffer = NULL;
d625 5
a653 1
    SetOutputMode( O_TEXT );
d656 1
a656 1
    LYSleepAlert();
a657 2
    SetOutputMode( O_BINARY );

d661 1
a661 1
#else /* !VMS (Unix or DOS) */
d663 2
a664 2
#if CAN_PIPE_TO_MAILER
    outfile_fp = LYPipeToMailer();
d666 2
a667 1
    outfile_fp = LYOpenTemp(my_temp, TEXT_SUFFIX, "w");
d700 2
a701 2
    use_type = (BOOL) (disp_charset || HTisDocumentSource());
    use_mime = (BOOL) (use_cte || use_type);
d761 1
a761 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* MAIL */
d765 10
a774 1
#if CAN_PIPE_TO_MAILER
d776 2
a777 11
#else
    LYCloseOutput(outfile_fp);
    LYSendMailFile (
	    user_response,
	    my_temp,
	    subject,
	    "",
	    "");
    LYRemoveTemp(my_temp); /* Delete the tmpfile. */
#endif /* CAN_PIPE_TO_MAILER */
#endif /* USE_VMS_MAILER */
d779 1
a779 1
done:	/* send_file_to_mail() */
d786 1
a786 1
	DocInfo *,	newdoc,
d797 1
a797 1
    lynx_list_item_type *cur_printer;
d802 1
a802 1
				    : TEXT_SUFFIX,
d819 1
a819 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* PRINTER */
d874 1
a874 1
	 * on VMS.  - FM
d876 7
a882 1
	if (LYIsNullDevice(my_file)) {
a886 4
#ifdef SH_EX	/* 1999/01/04 (Mon) 09:37:03 */
    else {
	my_file[0] = '\0';
    }
a888 8
    if (my_file[0]) {
	HTAddParam (&the_command, cur_printer->command, 2, my_file);
	HTEndParam (&the_command, cur_printer->command, 3);
    } else {
	HTEndParam (&the_command, cur_printer->command, 2);
    }
#else
    HTAddParam (&the_command, cur_printer->command, 1, my_temp);
a890 1
#endif
d896 1
a896 1
    LYmove(1,1);
d899 1
a899 2
    CTRACE((tfp, "command: %s\n", the_command));
    SetOutputMode( O_TEXT );
d929 1
a929 6
#ifdef SH_EX
    fprintf(stdout, gettext(" Print job complete.\n"));
    fflush(stdout);
#endif
    SetOutputMode( O_BINARY );
    LYSleepMsg();
d932 1
a932 1
done:	/* send_file_to_printer() */
d937 1
a937 1
	DocInfo *,	newdoc,
a957 2
    SetOutputMode( O_TEXT );

d975 1
a975 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* SCREEN */
a988 1
	fflush(stdout);  /* refresh to screen */
d992 1
a992 2
	fflush(stdout);		/* refresh to screen */
	(void) LYgetch();	/* grab some user input to pause */
d997 1
a997 4
#ifdef SH_EX
    fprintf(stdout,"\n");
#endif
    SetOutputMode( O_BINARY );
d1000 1
a1000 1
done:	/* send_file_to_screen() */
d1005 1
a1005 1
	DocInfo *,	newdoc)
d1077 1
a1077 1
    if ((cp = strstr(link_info, "lines=")) != NULL) {
d1105 1
a1105 1
	if ((cp = strstr(link_info, "number=")) != NULL) {
d1110 1
a1110 1
	if ((cp = strstr(link_info, "pagelen=")) != NULL) {
d1152 1
a1152 1
#if USE_VMS_MAILER
d1168 1
a1168 1
#endif /* USE_VMS_MAILER */
d1173 2
a1174 2
 *  MIME defines "quoted-printable" which holds charset info
 *  but most mailers still don't support it.  On the other hand
a1186 1
#include <LYCharUtils.h>
d1189 2
d1194 1
a1197 1
    StrAllocCopy(target, source);
d1202 1
d1209 10
a1218 1
    LYUCTranslateBackHeaderText(&target, charset_in, charset_out, YES);
d1236 1
a1236 1
	CONST char *,	printed_url,
d1239 1
a1239 1
    static char my_temp[LY_MAXPATH] = "\0";
d1244 1
a1244 1
    lynx_list_item_type *cur_printer;
d1246 3
a1248 1
    if ((fp0 = InternalPageFP(my_temp, TRUE)) == 0)
d1250 1
d1261 1
a1261 1
	    gettext("Document:"), printed_url,
d1279 1
a1279 2
		"   <a href=\"%s//LOCAL_FILE/lines=%d\">%s</a>\n",
		STR_LYNXPRINT,
d1287 1
a1287 2
		"   <a href=\"%s//MAIL_FILE/lines=%d\">%s</a>\n",
		STR_LYNXPRINT,
d1291 1
a1291 1
#if defined(UNIX) || defined(VMS)
d1293 1
a1293 2
	    "   <a href=\"%s//TO_SCREEN/lines=%d\">%s</a>\n",
	    STR_LYNXPRINT,
d1297 1
a1297 2
	    "   <a href=\"%s//LPANSI/lines=%d\">%s</a>\n",
	    STR_LYNXPRINT,
d1309 1
a1309 2
		"   <a href=\"%s//PRINTER/number=%d/pagelen=%d/lines=%d\">",
		STR_LYNXPRINT,
d1340 2
d1416 1
a1416 1
    if (!LYCanReadFile(tbuf)) {
d1422 2
d1436 1
a1436 1
    if ((fn = typecallocn(char, strlen (tbuf) + 1)) == NULL)
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d60 1
a60 1
static int remove_quotes (char *string);
d63 1
a63 1
static  char* subject_translate8bit (char *source);
d72 4
a75 4
static void set_environ (
	int		name,
	const char *	value,
	const char *	no_value)
d77 1
a77 1
    static const char *names[MAX_PUTENV] = {
d108 2
a109 2
static char *suggested_filename (
	DocInfo *	newdoc)
d143 3
a145 3
static void SetupFilename (
	char *		filename,
	char *		sug_filename)
d173 6
a178 6
static int RecallFilename (
	char *		filename,
	BOOLEAN *	first,
	int *		now,
	int *		total,
	int		flag)
d275 4
a278 4
static BOOLEAN confirm_by_pages (
	char *		prompt,
	int		lines_in_file,
	int		lines_per_page)
d304 4
a307 4
static void send_file_to_file (
	DocInfo *	newdoc,
	char *		content_base,
	char *		sug_filename)
d311 1
a311 1
    const char *disp_charset;
d446 1
a446 1
    print_wwwfile_to_fd(outfile_fp, FALSE, FALSE);	/* FILE */
d475 4
a478 4
static void send_file_to_mail (
	DocInfo *	newdoc,
	char *		content_base,
	char *		content_location)
d494 1
a494 1
    const char *disp_charset;
d634 1
a634 1
    print_wwwfile_to_fd(outfile_fp, TRUE, FALSE);	/* MAIL */
d775 1
a775 1
    print_wwwfile_to_fd(outfile_fp, TRUE, FALSE);	/* MAIL */
d799 5
a803 5
static void send_file_to_printer (
	DocInfo *	newdoc,
	char *		content_base,
	char *		sug_filename,
	int		printer_number)
d833 1
a833 1
    print_wwwfile_to_fd(outfile_fp, FALSE, FALSE);	/* PRINTER */
d963 4
a966 4
static void send_file_to_screen (
	DocInfo *	newdoc,
	char *		content_base,
	BOOLEAN	Lpansi)
d1004 1
a1004 1
    print_wwwfile_to_fd(outfile_fp, FALSE, FALSE);	/* SCREEN */
d1038 2
a1039 2
int printfile (
	DocInfo *	newdoc)
d1187 2
a1188 2
static int remove_quotes (
	char *		string)
d1222 1
a1222 1
static char* subject_translate8bit (char * source)
d1257 4
a1260 4
int print_options (
	char **	newfile,
	const char *	printed_url,
	int		lines_in_file)
d1361 1
a1361 1
char * GetFileName (void)
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d17 1
a17 1
#include <LYCharSets.h>		/* To get current charset for mail header. */
d25 2
a26 2
 * printfile prints out the current file minus the links and targets to a
 * variety of places
d31 5
a35 5
 * LYNXPRINT://LOCAL_FILE/lines=##
 * LYNXPRINT://MAIL_FILE/lines=##
 * LYNXPRINT://TO_SCREEN/lines=##
 * LYNXPRINT://LPANSI/lines=##
 * LYNXPRINT://PRINTER/lines=##/number=#
d60 1
a60 1
static int remove_quotes(char *string);
d63 1
a63 1
static char *subject_translate8bit(char *source);
d72 4
a75 3
static void set_environ(int name,
			const char *value,
			const char *no_value)
d77 1
a77 2
    static const char *names[MAX_PUTENV] =
    {
a84 1

a87 1

d108 2
a109 1
static char *suggested_filename(DocInfo *newdoc)
d114 1
a114 1
     * Load the suggested filename string.  - FM
d117 1
a117 1
	StrAllocCopy(sug_filename, HText_getSugFname());	/* must be freed */
d119 1
a119 1
	StrAllocCopy(sug_filename, newdoc->address);	/* must be freed */
d121 1
a121 1
     * Strip any gzip or compress suffix, if present.  - FM
d125 1
a125 1
	cp = (char *) &sug_filename[(strlen(sug_filename) - 3)];
d134 1
a134 1
	cp = (char *) &sug_filename[(strlen(sug_filename) - 2)];
d143 3
a145 2
static void SetupFilename(char *filename,
			  char *sug_filename)
d151 1
a151 1
    LYstrncpy(filename, sug_filename, LY_MAXPATH - 1);	/* add suggestion info */
d155 2
a156 2
	&& (cp = strrchr(filename, '.')) != NULL
	&& (cp - filename) < LY_MAXPATH - 5) {
d173 6
a178 5
static int RecallFilename(char *filename,
			  BOOLEAN *first,
			  int *now,
			  int *total,
			  int flag)
d217 4
a220 3
	    } else if ((cp = (char *) HTList_objectAt(sug_filenames,
						      *now)) != NULL) {
		LYstrncpy(filename, cp, LY_MAXPATH - 1);
d249 4
a252 3
	    } else if ((cp = (char *) HTList_objectAt(sug_filenames,
						      *now)) != NULL) {
		LYstrncpy(filename, cp, LY_MAXPATH - 1);
d275 4
a278 3
static BOOLEAN confirm_by_pages(char *prompt,
				int lines_in_file,
				int lines_per_page)
d280 1
a280 1
    int pages = lines_in_file / (lines_per_page + 1);
d284 1
a284 1
    if ((lines_in_file % (LYlines + 1)) > 0)
d304 4
a307 2
static void send_file_to_file(DocInfo *newdoc, char *content_base,
			      char *sug_filename)
d320 1
a320 1
  retry:
d323 1
a323 1
	&& (strlen(lynx_save_space) + strlen(filename)) < sizeof(filename)) {
d328 11
a338 11
  check_recall:
    switch (RecallFilename(filename, &FirstRecall, &FnameNum,
			   &FnameTotal, PRINT_FLAG)) {
    case FN_INIT:
	goto retry;
    case FN_READ:
	goto check_recall;
    case FN_QUIT:
	goto done;
    default:
	break;
d372 1
a372 1
	} else if ((outfile_fp = popen(buffer + 1, "w")) == NULL) {
d382 3
a384 3
	if ((outfile_fp = (TOUPPER(c) == 'A'
			   ? LYAppendToTxtFile(buffer)
			   : LYNewTxtFile(buffer))) == NULL) {
d407 1
a407 1
		    "<!-- Date: %s -->\n", HText_getDate());
d409 2
a410 3
		&& strcmp(HText_getLastModified(), HText_getDate())
		&& strcmp(HText_getLastModified(),
			  "Thu, 01 Jan 1970 00:00:01 GMT")) {
d412 1
a412 1
			"<!-- Last-Modified: %s -->\n", HText_getLastModified());
d448 1
a448 1
	printlist(outfile_fp, FALSE);
d459 2
a460 2
	if (0 == strncmp((buffer + 9), "[]", 2)) {
	    HTAddSugFilename(buffer + 11);
d462 1
a462 1
	    HTAddSugFilename(buffer + 9);
d471 1
a471 1
  done:
d475 4
a478 2
static void send_file_to_mail(DocInfo *newdoc, char *content_base,
			      char *content_location)
a487 1

d508 1
a508 1
	} else {
d514 2
a515 5
    LYstrncpy(user_response, personal_mail_address, sizeof(user_response) - 1);
    if (LYgetstr(user_response,
		 VISIBLE,
		 sizeof(user_response),
		 RECALL_MAIL) < 0 ||
d554 1
d556 2
a557 2
    if (strchr(user_response, '@@') && !strchr(user_response, ':') &&
	!strchr(user_response, '%') && !strchr(user_response, '"')) {
a558 1

d560 1
a560 1
	LYstrncpy(user_response, temp, sizeof(user_response) - 1);
d566 2
a567 2
			    ? HTML_SUFFIX
			    : TEXT_SUFFIX,
d608 1
a608 1
	 * X-URL header.  - FM
d619 1
a619 1
     * Write the contents to a temp file.
d645 6
a650 6
		   "%s %s %s,%s %s",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_temp,
		   user_response);
d657 6
a662 6
		   "%s %s/subject=\"%.70s\" %s %s",
		   system_mail,
		   system_mail_flags,
		   subject,
		   my_temp,
		   user_response);
d666 1
a666 1
    SetOutputMode(O_TEXT);
d671 1
a671 1
    SetOutputMode(O_BINARY);
d709 2
a710 2
    /* Enable this if indicating an 8-bit transfer without also indicating the
     * charset causes problems.  - kw */
d759 1
a759 1
     * Add the To, Subject, and X-URL headers.  - FM
d783 7
a789 6
    LYSendMailFile(user_response,
		   my_temp,
		   subject,
		   "",
		   "");
    LYRemoveTemp(my_temp);	/* Delete the tmpfile. */
d793 1
a793 1
  done:			/* send_file_to_mail() */
d799 5
a803 3
static void send_file_to_printer(DocInfo *newdoc, char *content_base,
				 char *sug_filename,
				 int printer_number)
d815 2
a816 2
			    ? HTML_SUFFIX
			    : TEXT_SUFFIX,
d841 1
a841 2
	int count = 0;

d844 2
a845 1
	     count++, cur_printer = cur_printer->next) ;	/* null body */
d860 1
a860 1
    if (HTCountCommandArgs(cur_printer->command) >= 2) {
d862 1
a862 1
      again:
d864 11
a874 11
      check_again:
	switch (RecallFilename(my_file, &FirstRecall, &FnameNum,
			       &FnameTotal, PRINT_FLAG)) {
	case FN_INIT:
	    goto again;
	case FN_READ:
	    goto check_again;
	case FN_QUIT:
	    goto done;
	default:
	    break;
d895 1
a895 1
#ifdef SH_EX			/* 1999/01/04 (Mon) 09:37:03 */
d900 1
a900 1
    HTAddParam(&the_command, cur_printer->command, 1, my_temp);
d902 2
a903 2
	HTAddParam(&the_command, cur_printer->command, 2, my_file);
	HTEndParam(&the_command, cur_printer->command, 3);
d905 1
a905 1
	HTEndParam(&the_command, cur_printer->command, 2);
d908 3
a910 3
    HTAddParam(&the_command, cur_printer->command, 1, my_temp);
    HTAddParam(&the_command, cur_printer->command, 2, my_file);
    HTEndParam(&the_command, cur_printer->command, 2);
d917 1
a917 1
    LYmove(1, 1);
d921 1
a921 1
    SetOutputMode(O_TEXT);
d929 3
a931 3
    SET_ENVIRON(LYNX_PRINT_TITLE, HText_getTitle(), "No Title");
    SET_ENVIRON(LYNX_PRINT_URL, newdoc->address, "No URL");
    SET_ENVIRON(LYNX_PRINT_DATE, HText_getDate(), "No Date");
d942 3
a944 3
    SET_ENVIRON(LYNX_PRINT_TITLE, "", "");
    SET_ENVIRON(LYNX_PRINT_URL, "", "");
    SET_ENVIRON(LYNX_PRINT_DATE, "", "");
d955 1
a955 1
    SetOutputMode(O_BINARY);
d959 1
a959 1
  done:			/* send_file_to_printer() */
d963 4
a966 2
static void send_file_to_screen(DocInfo *newdoc, char *content_base,
				BOOLEAN Lpansi)
d985 1
a985 1
    SetOutputMode(O_TEXT);
d1018 1
a1018 1
	fflush(stdout);		/* refresh to screen */
d1021 1
a1021 1
	fprintf(stdout, "\n\n%s", PRESS_RETURN_TO_FINISH);
d1029 1
a1029 1
    fprintf(stdout, "\n");
d1031 1
a1031 1
    SetOutputMode(O_BINARY);
d1034 1
a1034 1
  done:			/* send_file_to_screen() */
d1038 2
a1039 1
int printfile(DocInfo *newdoc)
d1054 1
a1054 1
     * Extract useful info from URL.
d1056 1
a1056 1
    StrAllocCopy(link_info, newdoc->address + 12);
d1059 1
a1059 1
     * Reload the file we want to print into memory.
d1069 1
a1069 1
	return (NOT_FOUND);
d1072 2
a1073 2
     * If we have an explicit content-base, we may use it even if not in source
     * mode.  - kw
d1083 2
a1084 2
     * If document is source, load the content_base and content_location
     * strings.  - FM
d1109 1
a1109 1
     * Get the number of lines in the file.
d1113 1
a1113 1
	 * Terminate prev string here.
d1117 1
a1117 1
	 * Number of characters in "lines=".
d1125 1
a1125 1
     * Determine the type.
d1155 1
a1155 1
     * Act on the request.  - FM
d1159 3
a1161 3
    case TO_FILE:
	send_file_to_file(newdoc, content_base, sug_filename);
	break;
d1163 3
a1165 3
    case MAIL:
	send_file_to_mail(newdoc, content_base, content_location);
	break;
d1167 4
a1170 4
    case TO_SCREEN:
	if (confirm_by_pages(CONFIRM_LONG_SCREEN_PRINT, lines_in_file, LYlines))
	    send_file_to_screen(newdoc, content_base, Lpansi);
	break;
d1172 4
a1175 4
    case PRINTER:
	if (confirm_by_pages(CONFIRM_LONG_PAGE_PRINT, lines_in_file, pagelen))
	    send_file_to_printer(newdoc, content_base, sug_filename, printer_number);
	break;
d1177 1
a1177 1
    }				/* end switch */
d1183 1
a1183 1
    return (NORMAL);
d1187 2
a1188 1
static int remove_quotes(char *string)
d1190 1
a1190 1
    int i;
d1192 7
a1198 7
    for (i = 0; string[i] != '\0'; i++)
	if (string[i] == '"')
	    string[i] = ' ';
	else if (string[i] == '&')
	    string[i] = ' ';
	else if (string[i] == '|')
	    string[i] = ' ';
d1200 1
a1200 1
    return (0);
d1205 9
a1213 8
 * Mail subject may have 8-bit characters and they are in display charset. 
 * There is no stable practice for 8-bit subject encodings:  MIME defines
 * "quoted-printable" which holds charset info but most mailers still don't
 * support it.  On the other hand many mailers send open 8-bit subjects without
 * charset info and use local assumption for certain countries.  Besides that,
 * obsolete SMTP software is not 8bit clean but still in use, it strips the
 * characters in 128-160 range from subjects which may be a fault outside
 * iso-8859-XX.
d1215 3
a1217 3
 * We translate subject to "outgoing_mail_charset" (defined in lynx.cfg) it may
 * correspond to US-ASCII as the safest value or any other lynx character
 * handler, -1 for no translation (so display charset).
d1219 1
a1219 1
 * Always returns a new allocated string which has to be freed.
d1222 1
a1222 1
static char *subject_translate8bit(char *source)
d1228 1
a1228 1
    int i = outgoing_mail_charset;	/* from lynx.cfg, -1 by default */
d1232 4
a1235 4
	|| i == current_char_set
	|| LYCharSet_UC[current_char_set].enc == UCT_ENC_CJK
	|| LYCharSet_UC[i].enc == UCT_ENC_CJK) {
	return (target);	/* OK */
d1238 1
a1238 1
	charset_in = current_char_set;
d1243 1
a1243 1
    return (target);
d1251 5
a1255 6
 *
 * LYNXPRINT://LOCAL_FILE/lines=#	     print to a local file
 * LYNXPRINT://TO_SCREEN/lines=#	     print to the screen
 * LYNXPRINT://LPANSI/lines=#		     print to the local terminal
 * LYNXPRINT://MAIL_FILE/lines=#	     mail the file
 * LYNXPRINT://PRINTER/lines=#/number=#      print to printer number #
d1257 4
a1260 3
int print_options(char **newfile,
		  const char *printed_url,
		  int lines_in_file)
d1270 1
a1270 1
	return (-1);
d1279 7
a1285 8
    pages = (lines_in_file + 65) / 66;
    HTSprintf0(&buffer,
	       "   <em>%s</em> %s\n   <em>%s</em> %d\n   <em>%s</em> %d %s %s\n",
	       gettext("Document:"), printed_url,
	       gettext("Number of lines:"), lines_in_file,
	       gettext("Number of pages:"), pages,
	       (pages > 1 ? gettext("pages") : gettext("page")),
	       gettext("(approximately)"));
d1290 1
a1290 3
	fprintf(fp0,
		"   <em>%s</em>\n",
		gettext("Some print functions have been disabled!"));
d1304 1
a1304 1
	fprintf(fp0, "   <em>%s</em>\n", gettext("Save to disk disabled"));
d1330 10
a1339 10
	 cur_printer = cur_printer->next, count++)
	if (no_print == FALSE || cur_printer->always_enabled) {
	    fprintf(fp0,
		    "   <a href=\"%s//PRINTER/number=%d/pagelen=%d/lines=%d\">",
		    STR_LYNXPRINT,
		    count, cur_printer->pagelen, lines_in_file);
	    fprintf(fp0, (cur_printer->name ?
			  cur_printer->name : "No Name Given"));
	    fprintf(fp0, "</a>\n");
	}
d1345 1
a1345 1
    return (0);
d1348 1
d1350 1
a1350 1
 * General purpose filename getter.
d1352 3
a1354 3
 * Returns a pointer to an absolute filename string, if the input filename
 * exists, and is readable.  Returns NULL if the input was cancelled (^G, or CR
 * on empty input).
d1356 2
a1357 2
 * The pointer to the filename string needs to be free()'d by the caller (when
 * non-NULL).
d1359 1
a1359 1
 * --KED 02/21/99
d1361 1
a1361 1
char *GetFileName(void)
d1365 2
a1366 2
    char fbuf[LY_MAXPATH];
    char tbuf[LY_MAXPATH];
d1370 3
a1372 2
    int FnameNum = -1;
    int FnameTotal;
d1376 1
a1376 1
  retry:
d1378 1
a1378 1
     * No initial filename.
d1380 1
a1380 1
    SetupFilename(fbuf, "");
d1382 1
a1382 1
  check_recall:
d1384 2
a1385 2
     * Go get a filename (it would be nice to do TAB == filename-completion as
     * the name is entered, but we'll save doing that for another time.
d1387 10
a1396 10
    switch (RecallFilename(fbuf, &FirstRecall, &FnameNum,
			   &FnameTotal, GENERIC_FLAG)) {
    case FN_INIT:
	goto retry;
    case FN_READ:
	goto check_recall;
    case FN_QUIT:
	goto quit;
    default:
	break;
d1400 2
a1401 2
     * Add raw input form to list ...  we may want to reuse/edit it on a
     * subsequent call, etc.
d1404 3
a1406 3
    if (0 == strncasecomp(fbuf, "sys$disk:", 9)) {
	if (0 == strncmp((fbuf + 9), "[]", 2)) {
	    HTAddSugFilename(fbuf + 11);
d1408 1
a1408 1
	    HTAddSugFilename(fbuf + 9);
d1411 1
a1411 1
	HTAddSugFilename(fbuf);
d1414 1
a1414 1
    HTAddSugFilename(fbuf);
d1418 1
a1418 1
     * Expand tilde's, make filename absolute, etc.
d1420 1
a1420 1
    if (!LYValidateFilename(tbuf, fbuf))
d1424 1
a1424 1
     * Check for file existence; readability.
d1426 2
a1427 2
    if ((stat(tbuf, &stat_info) < 0) ||
	(!(S_ISREG(stat_info.st_mode)
d1429 1
a1429 1
	   || S_ISLNK(stat_info.st_mode)
d1431 2
a1432 2
	 ))) {
	HTInfoMsg(FILE_DOES_NOT_EXIST);
d1435 1
a1435 1
	FnameNum = FnameTotal;
d1440 1
a1440 1
	HTInfoMsg(FILE_NOT_READABLE);
d1443 1
a1443 1
	FnameNum = FnameTotal;
d1448 2
a1449 1
     * We have a valid filename, and readable file.  Return it to the caller.
d1451 1
a1451 1
     * The returned pointer should be free()'d by the caller.
d1453 3
a1455 3
     * [For some silly reason, if we use StrAllocCopy() here, we get an
     * "invalid pointer" reported in the Lynx.leaks file (if compiled with
     * --enable-find-leaks turned on.  Dumb.]
d1457 3
a1459 2
    if ((fn = typecallocn(char, strlen(tbuf) + 1)) == NULL)
	  outofmem(__FILE__, "GetFileName");
a1460 1
    return (strcpy(fn, tbuf));
d1462 1
a1462 1
  quit:
d1464 1
a1464 1
     * The user cancelled the input (^G, or CR on empty input field).
@


1.1.3.4
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d91 1
a91 1
    if (isEmpty(envbuffer))
d1069 1
a1069 1
	if (isEmpty(content_base)) {
d1081 1
a1081 1
	    if (isEmpty(content_location)) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d59 1
a59 1
#if USE_VMS_MAILER
d61 1
a61 1
#endif /* USE_VMS_MAILER */
d191 1
a191 1
    recall = ((*total >= 1) ? RECALL_URL : NORECALL);
d295 1
a295 1
	    LYaddstr("   Ok...");
d363 1
a363 1
    CTRACE((tfp, "LYPrint: filename is %s, action is `%c'\n", buffer, c));
d373 1
a373 1
	    CTRACE((tfp, "LYPrint: errno is %d\n", errno));
d385 1
a385 1
	CTRACE((tfp, "LYPrint: errno is %d\n", errno));
d405 2
a406 2
	if (HText_getDate() != NULL) {
	    fprintf(outfile_fp,
a407 8
	    if (HText_getLastModified() != NULL
			&& strcmp(HText_getLastModified(), HText_getDate())
			&& strcmp(HText_getLastModified(), "Thu, 01 Jan 1970 00:00:01 GMT")) {
		fprintf(outfile_fp,
		    "<!-- Last-Modified: %s -->\n", HText_getLastModified());
	    }
	}

d438 1
a438 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* FILE */
d447 1
a447 2
	LYCloseOutput(outfile_fp);

d473 2
a474 2
#if USE_VMS_MAILER
    BOOLEAN isPMDF = LYMailPMDF();
d477 1
d479 1
a479 2
    BOOL use_mime;
#if !CAN_PIPE_TO_MAILER
d484 1
d495 1
a495 1
	    LYaddstr("   Ok...");
d504 1
a504 1
    if (LYgetstr(user_response, VISIBLE, sizeof(user_response), RECALL_MAIL) < 0 ||
d525 1
a525 1
    use_type = (BOOL) (disp_charset || HTisDocumentSource());
d532 1
a532 1
    subject = subject_translate8bit(newdoc->title);
d534 8
a541 8
    if (newdoc->isHEAD) {
	/*
	 * Special case for mailing HEAD responce:  this is rather technical
	 * information, show URL.
	 */
	FREE(subject);
	StrAllocCopy(subject, "HEAD  ");
	StrAllocCat(subject, newdoc->address);
d544 1
a544 1
#if USE_VMS_MAILER
a599 5
	/*
	 * For PMDF, put the subject in the header file and close it.  - FM
	 */
	fprintf(hfd, "Subject: %.70s\n\n", subject);
	LYCloseTempFP(hfd);
d618 1
a618 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* MAIL */
a622 1
    buffer = NULL;
d625 5
a653 1
    SetOutputMode( O_TEXT );
d656 1
a656 1
    LYSleepAlert();
a657 2
    SetOutputMode( O_BINARY );

d661 1
a661 1
#else /* !VMS (Unix or DOS) */
d663 2
a664 2
#if CAN_PIPE_TO_MAILER
    outfile_fp = LYPipeToMailer();
d666 2
a667 1
    outfile_fp = LYOpenTemp(my_temp, ".txt", "w");
d700 2
a701 2
    use_type = (BOOL) (disp_charset || HTisDocumentSource());
    use_mime = (BOOL) (use_cte || use_type);
d761 1
a761 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* MAIL */
d765 10
a774 1
#if CAN_PIPE_TO_MAILER
d776 2
a777 11
#else
    LYCloseOutput(outfile_fp);
    LYSendMailFile (
	    user_response,
	    my_temp,
	    subject,
	    "",
	    "");
    LYRemoveTemp(my_temp); /* Delete the tmpfile. */
#endif /* CAN_PIPE_TO_MAILER */
#endif /* USE_VMS_MAILER */
d779 1
a779 1
done:	/* send_file_to_mail() */
d797 1
a797 1
    lynx_list_item_type *cur_printer;
d819 1
a819 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* PRINTER */
a879 3
#if defined(DOSPATH)	/* 1997/10/15 (Wed) 16:41:30 */
	if (!strcmp(my_file, "nul"))
#else
a880 1
#endif /* DOSPATH */
a886 4
#ifdef SH_EX	/* 1999/01/04 (Mon) 09:37:03 */
    else {
	my_file[0] = '\0';
    }
a888 8
    if (my_file[0]) {
	HTAddParam (&the_command, cur_printer->command, 2, my_file);
	HTEndParam (&the_command, cur_printer->command, 3);
    } else {
	HTEndParam (&the_command, cur_printer->command, 2);
    }
#else
    HTAddParam (&the_command, cur_printer->command, 1, my_temp);
a890 1
#endif
d896 1
a896 1
    LYmove(1,1);
d899 1
a899 2
    CTRACE((tfp, "command: %s\n", the_command));
    SetOutputMode( O_TEXT );
d929 1
a929 6
#ifdef SH_EX
    fprintf(stdout, gettext(" Print job complete.\n"));
    fflush(stdout);
#endif
    SetOutputMode( O_BINARY );
    LYSleepMsg();
d932 1
a932 1
done:	/* send_file_to_printer() */
a957 2
    SetOutputMode( O_TEXT );

d975 1
a975 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* SCREEN */
a988 1
	fflush(stdout);  /* refresh to screen */
d992 1
a992 2
	fflush(stdout);		/* refresh to screen */
	(void) LYgetch();	/* grab some user input to pause */
d997 1
a997 4
#ifdef SH_EX
    fprintf(stdout,"\n");
#endif
    SetOutputMode( O_BINARY );
d1000 1
a1000 1
done:	/* send_file_to_screen() */
d1077 1
a1077 1
    if ((cp = strstr(link_info, "lines=")) != NULL) {
d1105 1
a1105 1
	if ((cp = strstr(link_info, "number=")) != NULL) {
d1110 1
a1110 1
	if ((cp = strstr(link_info, "pagelen=")) != NULL) {
d1152 1
a1152 1
#if USE_VMS_MAILER
d1168 1
a1168 1
#endif /* USE_VMS_MAILER */
a1186 1
#include <LYCharUtils.h>
d1189 2
d1194 1
a1197 1
    StrAllocCopy(target, source);
d1202 1
d1209 10
a1218 1
    LYUCTranslateBackHeaderText(&target, charset_in, charset_out, YES);
d1236 1
a1236 1
	CONST char *,	printed_url,
d1239 1
a1239 1
    static char my_temp[LY_MAXPATH] = "\0";
d1244 1
a1244 1
    lynx_list_item_type *cur_printer;
d1246 2
a1247 7
    if (LYReuseTempfiles) {
	fp0 = LYOpenTempRewrite(my_temp, HTML_SUFFIX, "w");
    } else {
	LYRemoveTemp(my_temp);
	fp0 = LYOpenTemp(my_temp, HTML_SUFFIX, "w");
    }
    if (fp0 == NULL) {
d1261 1
a1261 1
	    gettext("Document:"), printed_url,
d1340 2
d1416 1
a1416 1
    if (!LYCanReadFile(tbuf)) {
d1422 2
d1436 1
a1436 1
    if ((fn = typecallocn(char, strlen (tbuf) + 1)) == NULL)
@

