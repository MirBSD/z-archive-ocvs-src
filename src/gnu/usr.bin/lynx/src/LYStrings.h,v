head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.46.05;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.17.04;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.37;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.38;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.35;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.22;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.22;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.28;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.34;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.14;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.51;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.51.39;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@#ifndef LYSTRINGS_H
#define LYSTRINGS_H

#include <LYCurses.h>

#ifdef __cplusplus
extern "C" {
#endif
    typedef enum {
	NORECALL = 0
	,RECALL_URL
	,RECALL_CMD
	,RECALL_MAIL
    } RecallType;

#define is8bits(ch) (UCH(ch) >= 128)	/* isascii(ch) is not POSIX */

/*  UPPER8(ch1,ch2) is an extension of (TOUPPER(ch1) - TOUPPER(ch2))  */
    extern int UPPER8(int ch1,
		      int ch2);

    extern int get_mouse_link(void);
    extern int peek_mouse_link(void);
    extern int peek_mouse_levent(void);
    extern int fancy_mouse(WINDOW * win, int row, int *position);

    extern char *LYstrncpy(char *dst,
			   const char *src,
			   int n);
    extern void ena_csi(BOOLEAN flag);
    extern int get_popup_number(const char *msg,
				int *c,
				int *rel);
    extern int LYarrayLength(const char **list);
    extern int LYarrayWidth(const char **list);
    extern int LYgetch(void);
    extern int LYgetch_choice(void);
    extern int LYgetch_input(void);
    extern int LYgetch_single(void);
    extern int LYgetstr(char *inputline,
			int hidden,
			size_t bufsize,
			RecallType recall);
    extern char *LYstrsep(char **stringp,
			  const char *delim);
    extern char *LYstrstr(char *chptr,
			  const char *tarptr);
    extern char *LYmbcsstrncpy(char *dst,
			       const char *src,
			       int n_bytes,
			       int n_glyphs,
			       BOOL utf_flag);
    extern const char *LYmbcs_skip_glyphs(const char *data,
					  int n_glyphs,
					  BOOL utf_flag);
    extern int LYmbcsstrlen(const char *str,
			    BOOL utf_flag,
			    BOOL count_gcells);

    extern const char *LYno_attr_mbcs_strstr(const char *chptr,
					     const char *tarptr,
					     BOOL utf_flag,
					     BOOL count_gcells,
					     int *nstartp,
					     int *nendp);
    extern const char *LYno_attr_mbcs_case_strstr(const char *chptr,
						  const char *tarptr,
						  BOOL utf_flag,
						  BOOL count_gcells,
						  int *nstartp,
						  int *nendp);

#define non_empty(s) !isEmpty(s)

#define LYno_attr_mb_strstr(chptr, tarptr, utf_flag, count_gcells, nstartp, nendp) \
	(case_sensitive \
	    ? LYno_attr_mbcs_strstr(chptr, tarptr, utf_flag, count_gcells, nstartp, nendp) \
	    : LYno_attr_mbcs_case_strstr(chptr, tarptr, utf_flag, count_gcells, nstartp, nendp))

    extern const char *LYno_attr_char_strstr(const char *chptr,
					     const char *tarptr);
    extern const char *LYno_attr_char_case_strstr(const char *chptr,
						  const char *tarptr);

#define LYno_attr_strstr(chptr, tarptr) \
	(case_sensitive \
	? LYno_attr_char_strstr(chptr, tarptr) \
	: LYno_attr_char_case_strstr(chptr, tarptr))

    extern char *SNACopy(char **dest,
			 const char *src,
			 int n);
    extern char *SNACat(char **dest,
			const char *src,
			int n);

#define StrnAllocCopy(dest, src, n)  SNACopy (&(dest), src, n)
#define StrnAllocCat(dest, src, n)   SNACat  (&(dest), src, n)

    extern char *LYSafeGets(char **src, FILE *fp);

#ifdef EXP_CMD_LOGGING
    extern BOOL LYHaveCmdScript(void);
    extern int LYReadCmdKey(int mode);
    extern void LYCloseCmdLogfile(void);
    extern void LYOpenCmdLogfile(int argc, char **argv);
    extern void LYOpenCmdScript(void);
    extern void LYWriteCmdKey(int ch);

#else
#define LYHaveCmdScript() FALSE
#define LYReadCmdKey(mode) LYgetch_for(mode)
#define LYCloseCmdLogfile()	/* nothing */
#endif

/* values for LYgetch */
/* The following are lynxkeycodes, not to be confused with
   lynxactioncodes (LYK_*) to which they are often mapped.
   The lynxkeycodes include all single-byte keys as a subset. - kw
*/
#define UPARROW		256	/* 0x100 */
#define DNARROW		257	/* 0x101 */
#define RTARROW		258	/* 0x102 */
#define LTARROW		259	/* 0x103 */
#define PGDOWN		260	/* 0x104 */
#define PGUP		261	/* 0x105 */
#define HOME		262	/* 0x106 */
#define END_KEY		263	/* 0x107 */
#define F1		264	/* 0x108 */
#define DO_KEY		265	/* 0x109 */
#define FIND_KEY	266	/* 0x10A */
#define SELECT_KEY	267	/* 0x10B */
#define INSERT_KEY	268	/* 0x10C */
#define REMOVE_KEY	269	/* 0x10D */
#define DO_NOTHING	270	/* 0x10E */
#define BACKTAB_KEY	271	/* 0x10F */
#define MOUSE_KEY	285	/* 0x11D */
/*  ***** NOTES: *****
    If you add definitions for new lynxkeycodes to the above list that need to
    be mapped to LYK_* lynxactioncodes -

    - AT LEAST the tables keymap[] and key_override[] in LYKeymap.c have to be
      changed/reviewed, AS WELL AS the lineedit binding tables in LYEditmap.c !

    - KEYMAP_SIZE, defined in LYKeymap.h, may need to be changed !

    - See also table named_keys[] in LYKeymap.c for 'pretty' strings for the
      keys with codes >= 256 (to appear on the 'K'eymap page).  New keycodes
      should probably be assigned consecutively, so their key names can be
      easily added to named_keys[] (but see next point).  They should also be
      documented in lynx.cfg.

    - The DOS port uses its own native codes for some keys, unless they are
      remapped by the code in LYgetch().  See *.key files in docs/ directory. 
      Adding new keys here may conflict with those codes (affecting DOS users),
      unless/until remapping is added or changed in LYgetch().  (N)curses
      keypad codes (KEY_* from curses.h) can also directly appear as
      lynxkeycodes and conflict with our assignments, although that shouldn't
      happen - the useful ones should be recognized in LYgetch().

    - The actual recognition of raw input keys or escape sequences, and mapping
      to our lynxkeycodes, take place in LYgetch() and/or its subsidiary
      functions and/or the curses/slang/etc.  libraries.

    The basic lynxkeycodes can appear combined with various flags in
    higher-order bits as extended lynxkeycodes; see macros in LYKeymap.h.  The
    range of possible basic values is therefore limited, they have to be less
    than LKC_ISLKC (even if KEYMAP_SIZE is increased).
*/

#  define FOR_PANEL	0	/* normal screen, also LYgetch default */
#  define FOR_CHOICE	1	/* mouse menu */
#  define FOR_INPUT	2	/* form input and textarea field */
#  define FOR_PROMPT	3	/* string prompt editing */
#  define FOR_SINGLEKEY	4	/* single key prompt, confirmation */

#define VISIBLE  0
#define HIDDEN   1

#ifdef EXP_ALT_BINDINGS
/*  Enable code implementing additional, mostly emacs-like, line-editing
    functions. - kw */
#define ENHANCED_LINEEDIT
#endif

/* EditFieldData preserves state between calls to LYEdit1
 */
    typedef struct _EditFieldData {

	int sx;			/* Origin of editfield                       */
	int sy;
	int dspwdth;		/* Screen real estate for editting           */

	int strlen;		/* Current size of string.                   */
	int maxlen;		/* Max size of string, excluding zero at end */
	char pad;		/* Right padding  typically ' ' or '_'       */
	BOOL hidden;		/* Masked password entry flag                */

	BOOL dirty;		/* accumulate refresh requests               */
	BOOL panon;		/* Need horizontal scroll indicator          */
	int xpan;		/* Horizontal scroll offset                  */
	int pos;		/* Insertion point in string                 */
	int margin;		/* Number of columns look-ahead/look-back    */
	int current_modifiers;	/* Modifiers for next input lynxkeycode */
#ifdef ENHANCED_LINEEDIT
	int mark;		/* position of emacs-like mark, or -1-pos to denote
				   unactive mark.  */
#endif

	char buffer[1024];	/* String buffer                          */

    } EditFieldData;

/* line-edit action encoding */

    typedef enum {
	LYE_NOP = 0		/* Do Nothing            */
	,LYE_CHAR		/* Insert printable char */
	,LYE_ENTER		/* Input complete, return char/lynxkeycode */
	,LYE_TAB		/* Input complete, return TAB  */
	,LYE_STOP		/* Input complete, deactivate  */
	,LYE_ABORT		/* Input cancelled       */

	,LYE_FORM_PASS		/* In form fields: input complete,
				   return char / lynxkeycode;
				   Elsewhere: Do Nothing */

	,LYE_DELN		/* Delete next/curr char */
	,LYE_DELC		/* Obsolete (DELC case was equiv to DELN) */
	,LYE_DELP		/* Delete prev      char */
	,LYE_DELNW		/* Delete next word      */
	,LYE_DELPW		/* Delete prev word      */

	,LYE_ERASE		/* Erase the line        */

	,LYE_BOL		/* Go to begin of line   */
	,LYE_EOL		/* Go to end   of line   */
	,LYE_FORW		/* Cursor forwards       */
	,LYE_FORW_RL		/* Cursor forwards or right link */
	,LYE_BACK		/* Cursor backwards      */
	,LYE_BACK_LL		/* Cursor backwards or left link */
	,LYE_FORWW		/* Word forward          */
	,LYE_BACKW		/* Word back             */

	,LYE_LOWER		/* Lower case the line   */
	,LYE_UPPER		/* Upper case the line   */

	,LYE_LKCMD		/* Invoke command prompt */

	,LYE_AIX		/* Hex 97                */

	,LYE_DELBL		/* Delete back to BOL    */
	,LYE_DELEL		/* Delete thru EOL       */

	,LYE_SWMAP		/* Switch input keymap   */

	,LYE_TPOS		/* Transpose characters  */

	,LYE_SETM1		/* Set modifier 1 flag   */
	,LYE_SETM2		/* Set modifier 2 flag   */
	,LYE_UNMOD		/* Fall back to no-modifier command */

	,LYE_C1CHAR		/* Insert C1 char if printable */

	,LYE_SETMARK		/* emacs-like set-mark-command */
	,LYE_XPMARK		/* emacs-like exchange-point-and-mark */
	,LYE_KILLREG		/* emacs-like kill-region */
	,LYE_YANK		/* emacs-like yank */
#ifdef CAN_CUT_AND_PASTE
	,LYE_PASTE		/* ClipBoard to Lynx       */
#endif
    } LYEditCodes;

/* All preceding values must be within 0x00..0x7f - kw */

/*  The following are meant to be bitwise or-ed:  */
#define LYE_DF       0x80	/* Flag to set modifier 3 AND do other
				   action */
#define LYE_FORM_LAC 0x1000	/* Flag to pass lynxactioncode given by
				   lower bits.  Doesn't fit in a char! */

#if defined(USE_KEYMAPS)
    extern int lynx_initialize_keymaps(void);
    extern int map_string_to_keysym(const char *src, int *lec);
#endif

    extern char *LYElideString(char *str,
			       int cut_pos);
    extern void LYEscapeStartfile(char **buffer);
    extern void LYLowerCase(char *buffer);
    extern void LYUpperCase(char *buffer);
    extern BOOLEAN LYRemoveNewlines(char *buffer);
    extern char *LYReduceBlanks(char *buffer);
    extern char *LYRemoveBlanks(char *buffer);
    extern char *LYSkipBlanks(char *buffer);
    extern char *LYSkipNonBlanks(char *buffer);
    extern const char *LYSkipCBlanks(const char *buffer);
    extern const char *LYSkipCNonBlanks(const char *buffer);
    extern void LYTrimLeading(char *buffer);
    extern char *LYTrimNewline(char *buffer);
    extern void LYTrimTrailing(char *buffer);
    extern void LYTrimAllStartfile(char *buffer);
    extern BOOLEAN LYTrimStartfile(char *buffer);
    extern void LYSetupEdit(EditFieldData *edit, char *old,
			    int maxstr,
			    int maxdsp);
    extern void LYRefreshEdit(EditFieldData *edit);
    extern int EditBinding(int ch);	/* in LYEditmap.c */
    extern BOOL LYRemapEditBinding(int xlkc,
				   int lec,
				   int select_edi);	/* in LYEditmap.c */
    extern int LYKeyForEditAction(int lec);	/* in LYEditmap.c */
    extern int LYEditKeyForAction(int lac, int *pmodkey);	/* LYEditmap.c */
    extern int LYEdit1(EditFieldData *edit, int ch,
		       int action,
		       BOOL maxMessage);
    extern void LYCloseCloset(RecallType recall);
    extern int LYhandlePopupList(int cur_choice,
				 int ly,
				 int lx,
				 const char **choices,
				 int width,
				 int i_length,
				 int disabled,
				 BOOLEAN for_mouse,
				 BOOLEAN numbered);

    typedef unsigned char LYEditCode;

    extern int current_lineedit;
    extern const char *LYLineeditNames[];
    extern LYEditCode *LYLineEditors[];
    extern const char *LYLineeditHelpURLs[];

    extern const char *LYLineeditHelpURL(void);

    extern int escape_bound;

#define LYLineEdit(e,c,m) LYEdit1(e, c, EditBinding(c) & ~LYE_DF, m)

/* Dummy initializer for LYEditmap.c */
    extern int LYEditmapDeclared(void);

    extern int LYEditInsert(EditFieldData *edit,
			    unsigned const char *s,
			    int len, int map_active,
			    BOOL maxMessage);

#ifdef __cplusplus
}
#endif
#endif				/* LYSTRINGS_H */
@


1.5
log
@automatic merge of lynx-current
@
text
@d6 9
a14 6
typedef enum {
    NORECALL = 0
    ,RECALL_URL
    ,RECALL_CMD
    ,RECALL_MAIL
} RecallType;
d19 7
a25 2
extern int UPPER8(int ch1,
		  int ch2);
d27 1
a27 27
extern int get_mouse_link(void);
extern int peek_mouse_link(void);
extern int peek_mouse_levent(void);
extern int fancy_mouse(WINDOW * win, int row, int *position);

extern char *LYstrncpy(char *dst,
		       const char *src,
		       int n);
extern void ena_csi(BOOLEAN flag);
extern int get_popup_number(char *msg,
			    int *c,
			    int *rel);
extern int LYarrayLength(const char **list);
extern int LYarrayWidth(const char **list);
extern int LYgetch(void);
extern int LYgetch_choice(void);
extern int LYgetch_input(void);
extern int LYgetch_single(void);
extern int LYgetstr(char *inputline,
		    int hidden,
		    size_t bufsize,
		    RecallType recall);
extern char *LYstrsep(char **stringp,
		      const char *delim);
extern char *LYstrstr(char *chptr,
		      const char *tarptr);
extern char *LYmbcsstrncpy(char *dst,
d29 43
a71 22
			   int n_bytes,
			   int n_glyphs,
			   BOOL utf_flag);
extern char *LYmbcs_skip_glyphs(char *data,
				int n_glyphs,
				BOOL utf_flag);
extern int LYmbcsstrlen(char *str,
			BOOL utf_flag,
			BOOL count_gcells);

extern char *LYno_attr_mbcs_strstr(char *chptr,
				   const char *tarptr,
				   BOOL utf_flag,
				   BOOL count_gcells,
				   int *nstartp,
				   int *nendp);
extern char *LYno_attr_mbcs_case_strstr(char *chptr,
					const char *tarptr,
					BOOL utf_flag,
					BOOL count_gcells,
					int *nstartp,
					int *nendp);
d80 4
a83 4
extern char *LYno_attr_char_strstr(char *chptr,
				   char *tarptr);
extern char *LYno_attr_char_case_strstr(char *chptr,
					char *tarptr);
d90 6
a95 6
extern char *SNACopy(char **dest,
		     const char *src,
		     int n);
extern char *SNACat(char **dest,
		    const char *src,
		    int n);
d100 1
a100 1
extern char *LYSafeGets(char **src, FILE *fp);
d103 6
a108 6
extern BOOL LYHaveCmdScript(void);
extern int LYReadCmdKey(int mode);
extern void LYCloseCmdLogfile(void);
extern void LYOpenCmdLogfile(int argc, char **argv);
extern void LYOpenCmdScript(void);
extern void LYWriteCmdKey(int ch);
d188 1
a188 1
typedef struct _EditFieldData {
d190 15
a204 15
    int sx;			/* Origin of editfield                       */
    int sy;
    int dspwdth;		/* Screen real estate for editting           */

    int strlen;			/* Current size of string.                   */
    int maxlen;			/* Max size of string, excluding zero at end */
    char pad;			/* Right padding  typically ' ' or '_'       */
    BOOL hidden;		/* Masked password entry flag                */

    BOOL dirty;			/* accumulate refresh requests               */
    BOOL panon;			/* Need horizontal scroll indicator          */
    int xpan;			/* Horizontal scroll offset                  */
    int pos;			/* Insertion point in string                 */
    int margin;			/* Number of columns look-ahead/look-back    */
    int current_modifiers;	/* Modifiers for next input lynxkeycode */
d206 1
a206 1
    int mark;			/* position of emacs-like mark, or -1-pos to denote
d210 1
a210 1
    char buffer[1024];		/* String buffer                          */
d212 1
a212 1
} EditFieldData;
d216 7
a222 7
typedef enum {
    LYE_NOP = 0			/* Do Nothing            */
    ,LYE_CHAR			/* Insert printable char */
    ,LYE_ENTER			/* Input complete, return char/lynxkeycode */
    ,LYE_TAB			/* Input complete, return TAB  */
    ,LYE_STOP			/* Input complete, deactivate  */
    ,LYE_ABORT			/* Input cancelled       */
d224 1
a224 1
    ,LYE_FORM_PASS		/* In form fields: input complete,
d228 5
a232 5
    ,LYE_DELN			/* Delete next/curr char */
    ,LYE_DELC			/* Obsolete (DELC case was equiv to DELN) */
    ,LYE_DELP			/* Delete prev      char */
    ,LYE_DELNW			/* Delete next word      */
    ,LYE_DELPW			/* Delete prev word      */
d234 1
a234 1
    ,LYE_ERASE			/* Erase the line        */
d236 8
a243 8
    ,LYE_BOL			/* Go to begin of line   */
    ,LYE_EOL			/* Go to end   of line   */
    ,LYE_FORW			/* Cursor forwards       */
    ,LYE_FORW_RL		/* Cursor forwards or right link */
    ,LYE_BACK			/* Cursor backwards      */
    ,LYE_BACK_LL		/* Cursor backwards or left link */
    ,LYE_FORWW			/* Word forward          */
    ,LYE_BACKW			/* Word back             */
d245 2
a246 2
    ,LYE_LOWER			/* Lower case the line   */
    ,LYE_UPPER			/* Upper case the line   */
d248 1
a248 1
    ,LYE_LKCMD			/* Invoke command prompt */
d250 1
a250 1
    ,LYE_AIX			/* Hex 97                */
d252 2
a253 2
    ,LYE_DELBL			/* Delete back to BOL    */
    ,LYE_DELEL			/* Delete thru EOL       */
d255 1
a255 1
    ,LYE_SWMAP			/* Switch input keymap   */
d257 1
a257 1
    ,LYE_TPOS			/* Transpose characters  */
d259 3
a261 3
    ,LYE_SETM1			/* Set modifier 1 flag   */
    ,LYE_SETM2			/* Set modifier 2 flag   */
    ,LYE_UNMOD			/* Fall back to no-modifier command */
d263 1
a263 1
    ,LYE_C1CHAR			/* Insert C1 char if printable */
d265 4
a268 4
    ,LYE_SETMARK		/* emacs-like set-mark-command */
    ,LYE_XPMARK			/* emacs-like exchange-point-and-mark */
    ,LYE_KILLREG		/* emacs-like kill-region */
    ,LYE_YANK			/* emacs-like yank */
d270 1
a270 1
    ,LYE_PASTE			/* ClipBoard to Lynx       */
d272 1
a272 1
} LYEditCodes;
d283 2
a284 2
extern int lynx_initialize_keymaps(void);
extern int map_string_to_keysym(const char *src, int *lec);
d287 47
a333 46
extern char *LYElideString(char *str,
			   int cut_pos);
extern void LYEscapeStartfile(char **buffer);
extern void LYLowerCase(char *buffer);
extern void LYUpperCase(char *buffer);
extern BOOLEAN LYRemoveNewlines(char *buffer);
extern char *LYRemoveBlanks(char *buffer);
extern char *LYSkipBlanks(char *buffer);
extern char *LYSkipNonBlanks(char *buffer);
extern const char *LYSkipCBlanks(const char *buffer);
extern const char *LYSkipCNonBlanks(const char *buffer);
extern void LYTrimLeading(char *buffer);
extern char *LYTrimNewline(char *buffer);
extern void LYTrimTrailing(char *buffer);
extern void LYTrimAllStartfile(char *buffer);
extern BOOLEAN LYTrimStartfile(char *buffer);
extern void LYSetupEdit(EditFieldData *edit, char *old,
			int maxstr,
			int maxdsp);
extern void LYRefreshEdit(EditFieldData *edit);
extern int EditBinding(int ch);	/* in LYEditmap.c */
extern BOOL LYRemapEditBinding(int xlkc,
			       int lec,
			       int select_edi);		/* in LYEditmap.c */
extern int LYKeyForEditAction(int lec);		/* in LYEditmap.c */
extern int LYEditKeyForAction(int lac, int *pmodkey);	/* LYEditmap.c */
extern int LYEdit1(EditFieldData *edit, int ch,
		   int action,
		   BOOL maxMessage);
extern void LYCloseCloset(RecallType recall);
extern int LYhandlePopupList(int cur_choice,
			     int ly,
			     int lx,
			     const char **choices,
			     int width,
			     int i_length,
			     int disabled,
			     BOOLEAN for_mouse,
			     BOOLEAN numbered);

typedef unsigned char LYEditCode;

extern int current_lineedit;
extern char *LYLineeditNames[];
extern LYEditCode *LYLineEditors[];
extern const char *LYLineeditHelpURLs[];
d335 1
a335 1
extern const char *LYLineeditHelpURL(void);
d337 1
a337 1
extern int escape_bound;
d342 1
a342 1
extern int LYEditmapDeclared(void);
d344 4
a347 4
extern int LYEditInsert(EditFieldData *edit,
			unsigned char *s,
			int len, int map_active,
			BOOL maxMessage);
d349 4
a352 1
#endif /* LYSTRINGS_H */
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d8 3
a10 3
    , RECALL_URL
    , RECALL_CMD
    , RECALL_MAIL
d16 53
a68 64
extern int UPPER8  (
	int		ch1,
	int		ch2);

extern int get_mouse_link (void);
extern int peek_mouse_link (void);
extern int peek_mouse_levent (void);
extern int fancy_mouse (WINDOW *win, int row, int *position);

extern char * LYstrncpy (
	char *		dst,
	const char *	src,
	int		n);
extern void ena_csi (BOOLEAN flag);
extern int get_popup_number (
	char *		msg,
	int *		c,
	int *		rel);
extern int LYarrayLength (const char ** list);
extern int LYarrayWidth (const char ** list);
extern int LYgetch (void);
extern int LYgetch_choice (void);
extern int LYgetch_input (void);
extern int LYgetch_single (void);
extern int LYgetstr (
	char *		inputline,
	int		hidden,
	size_t		bufsize,
	RecallType	recall);
extern char *LYstrsep (
	char **		stringp,
	const char *	delim);
extern char * LYstrstr (
	char *		chptr,
	const char *	tarptr);
extern char * LYmbcsstrncpy (
	char *		dst,
	const char *	src,
	int		n_bytes,
	int		n_glyphs,
	BOOL		utf_flag);
extern char * LYmbcs_skip_glyphs (
	char *		data,
	int		n_glyphs,
	BOOL		utf_flag);
extern int LYmbcsstrlen (
	char *		str,
	BOOL		utf_flag,
	BOOL		count_gcells);

extern char * LYno_attr_mbcs_strstr (
	char *		chptr,
	const char *	tarptr,
	BOOL		utf_flag,
	BOOL		count_gcells,
	int *		nstartp,
	int *		nendp);
extern char * LYno_attr_mbcs_case_strstr (
	char *		chptr,
	const char *	tarptr,
	BOOL		utf_flag,
	BOOL		count_gcells,
	int *		nstartp,
	int *		nendp);
d77 4
a80 6
extern char * LYno_attr_char_strstr (
	char *		chptr,
	char *		tarptr);
extern char * LYno_attr_char_case_strstr (
	char *		chptr,
	char *		tarptr);
d87 7
a93 8
extern char * SNACopy (
	char **		dest,
	const char *	src,
	int		n);
extern char * SNACat (
	char **		dest,
	const char *	src,
	int		n);
d97 1
a97 1
extern char *LYSafeGets (char ** src, FILE * fp);
d100 7
a106 6
extern BOOL LYHaveCmdScript (void);
extern int LYReadCmdKey (int mode);
extern void LYCloseCmdLogfile (void);
extern void LYOpenCmdLogfile (int argc, char **argv);
extern void LYOpenCmdScript (void);
extern void LYWriteCmdKey (int ch);
d110 1
a110 1
#define LYCloseCmdLogfile() /* nothing */
d136 6
a141 5
    If you add definitions for new lynxkeycodes to the above list that
    need to be mapped to LYK_* lynxactioncodes -
    - AT LEAST the tables keymap[] and key_override[] in LYKeymap.c
      have to be changed/reviewed, AS WELL AS the lineedit binding
      tables in LYEditmap.c !
d143 19
a161 17
    - See also table named_keys[] in LYKeymap.c for 'pretty' strings
      for the keys with codes >= 256 (to appear on the 'K'eymap page).
      New keycodes should probably be assigned consecutively, so their
      key names can be easily added to named_keys[] (but see next point).
      They should also be documented in lynx.cfg.
    - The DOS port uses its own native codes for some keys, unless
      they are remapped by the code in LYgetch().  See *.key files
      in docs/ directory.  Adding new keys here may conflict with
      those codes (affecting DOS users), unless/until remapping is
      added or changed in LYgetch().
      (N)curses keypad codes (KEY_* from curses.h) can also directly
      appear as lynxkeycodes and conflict with our assignments, although
      that shouldn't happen - the useful ones should be recognized in
      LYgetch().
    - The actual recognition of raw input keys or escape sequences, and
      mapping to our lynxkeycodes, take place in LYgetch() and/or its
      subsidiary functions and/or the curses/slang/etc. libraries.
d163 3
a165 3
    higher-order bits as extended lynxkeycodes; see macros in LYKeymap.h.
    The range of possible basic values is therefore limited, they have
    to be less than LKC_ISLKC (even if KEYMAP_SIZE is increased).
d187 15
a201 15
        int  sx;        /* Origin of editfield                       */
        int  sy;
        int  dspwdth;   /* Screen real estate for editting           */

        int  strlen;    /* Current size of string.                   */
        int  maxlen;    /* Max size of string, excluding zero at end */
        char pad;       /* Right padding  typically ' ' or '_'       */
        BOOL hidden;    /* Masked password entry flag                */

        BOOL dirty;     /* accumulate refresh requests               */
        BOOL panon;     /* Need horizontal scroll indicator          */
        int  xpan;      /* Horizontal scroll offset                  */
        int  pos;       /* Insertion point in string                 */
        int  margin;    /* Number of columns look-ahead/look-back    */
        int  current_modifiers; /* Modifiers for next input lynxkeycode */
d203 2
a204 2
	int  mark;	/* position of emacs-like mark, or -1-pos to denote
				unactive mark.  */
d207 1
a207 1
        char buffer[1024]; /* String buffer                          */
d214 1
a214 1
    LYE_NOP = 0			/* Do Nothing		 */
d219 1
a219 1
    ,LYE_ABORT			/* Input cancelled	 */
d227 9
a235 9
    ,LYE_DELP			/* Delete prev	    char */
    ,LYE_DELNW			/* Delete next word	 */
    ,LYE_DELPW			/* Delete prev word	 */

    ,LYE_ERASE			/* Erase the line	 */

    ,LYE_BOL			/* Go to begin of line	 */
    ,LYE_EOL			/* Go to end   of line	 */
    ,LYE_FORW			/* Cursor forwards	 */
d237 1
a237 1
    ,LYE_BACK			/* Cursor backwards	 */
d239 2
a240 2
    ,LYE_FORWW			/* Word forward		 */
    ,LYE_BACKW			/* Word back		 */
d242 2
a243 2
    ,LYE_LOWER			/* Lower case the line	 */
    ,LYE_UPPER			/* Upper case the line	 */
d247 1
a247 1
    ,LYE_AIX			/* Hex 97		 */
d249 2
a250 2
    ,LYE_DELBL			/* Delete back to BOL	 */
    ,LYE_DELEL			/* Delete thru EOL	 */
d252 1
a252 1
    ,LYE_SWMAP			/* Switch input keymap	 */
d254 1
a254 1
    ,LYE_TPOS			/* Transpose characters	 */
d256 2
a257 2
    ,LYE_SETM1			/* Set modifier 1 flag	 */
    ,LYE_SETM2			/* Set modifier 2 flag	 */
d267 1
a267 1
    ,LYE_PASTE			/* ClipBoard to Lynx	   */
d270 1
d274 1
a274 1
#define LYE_DF       0x80       /* Flag to set modifier 3 AND do other
d276 1
a276 1
#define LYE_FORM_LAC 0x1000     /* Flag to pass lynxactioncode given by
a278 1

d280 2
a281 2
extern int lynx_initialize_keymaps (void);
extern int map_string_to_keysym (const char * src, int *lec);
d284 39
a322 61
extern char *LYElideString (
	char *		str,
	int		cut_pos);
extern void LYEscapeStartfile (
	char **		buffer);
extern void LYLowerCase (
	char *		buffer);
extern void LYUpperCase (
	char *		buffer);
extern BOOLEAN LYRemoveNewlines (
	char *		buffer);
extern char * LYRemoveBlanks (
	char *		buffer);
extern char * LYSkipBlanks (
	char *		buffer);
extern char * LYSkipNonBlanks (
	char *		buffer);
extern const char * LYSkipCBlanks (
	const char *	buffer);
extern const char * LYSkipCNonBlanks (
	const char *	buffer);
extern void LYTrimLeading (
	char *		buffer);
extern char * LYTrimNewline (
	char *		buffer);
extern void LYTrimTrailing (
	char *		buffer);
extern void LYTrimAllStartfile (
	char *		buffer);
extern BOOLEAN LYTrimStartfile (
	char *		buffer);
extern void LYSetupEdit (
	EditFieldData *	edit,
	char *		old,
	int		maxstr,
	int		maxdsp);
extern void LYRefreshEdit (
	EditFieldData *	edit);
extern int EditBinding (int ch);		   /* in LYEditmap.c */
extern BOOL LYRemapEditBinding (
	int		xlkc,
	int		lec,
	int 		select_edi);			   /* in LYEditmap.c */
extern int LYKeyForEditAction (int lec);	   /* in LYEditmap.c */
extern int LYEditKeyForAction (int lac, int *pmodkey);/* LYEditmap.c */
extern int LYEdit1 (
	EditFieldData *	edit,
	int		ch,
	int		action,
	BOOL		maxMessage);
extern void LYCloseCloset (RecallType recall);
extern int LYhandlePopupList (
	int		cur_choice,
	int		ly,
	int		lx,
	const char **	choices,
	int		width,
	int		i_length,
	int		disabled,
	BOOLEAN		for_mouse,
	BOOLEAN		numbered);
d327 3
a329 3
extern char * LYLineeditNames[];
extern LYEditCode * LYLineEditors[];
extern const char * LYLineeditHelpURLs[];
d331 1
a331 1
extern const char * LYLineeditHelpURL (void);
d335 1
a335 1
#define LYLineEdit(e,c,m) LYEdit1(e,c,EditBinding(c)&~LYE_DF,m)
d338 1
a338 1
extern int LYEditmapDeclared (void);
d340 4
a343 1
int LYEditInsert (EditFieldData *edit, unsigned char *s,	int len, int map_active, BOOL maxMessage);
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d16 1
a16 1
extern int UPPER8  PARAMS((
d18 1
a18 1
	int		ch2));
d20 4
a23 4
extern int get_mouse_link NOPARAMS;
extern int peek_mouse_link NOPARAMS;
extern int peek_mouse_levent NOPARAMS;
extern int fancy_mouse PARAMS((WINDOW *win, int row, int *position));
d25 1
a25 1
extern char * LYstrncpy PARAMS((
d27 4
a30 4
	CONST char *	src,
	int		n));
extern void ena_csi PARAMS((BOOLEAN flag));
extern int get_popup_number PARAMS((
d33 8
a40 8
	int *		rel));
extern int LYarrayLength PARAMS((CONST char ** list));
extern int LYarrayWidth PARAMS((CONST char ** list));
extern int LYgetch NOPARAMS;
extern int LYgetch_choice NOPARAMS;
extern int LYgetch_input NOPARAMS;
extern int LYgetch_single NOPARAMS;
extern int LYgetstr PARAMS((
d44 2
a45 2
	RecallType	recall));
extern char *LYstrsep PARAMS((
d47 2
a48 2
	CONST char *	delim));
extern char * LYstrstr PARAMS((
d50 2
a51 2
	CONST char *	tarptr));
extern char * LYmbcsstrncpy PARAMS((
d53 1
a53 1
	CONST char *	src,
d56 2
a57 2
	BOOL		utf_flag));
extern char * LYmbcs_skip_glyphs PARAMS((
d60 2
a61 2
	BOOL		utf_flag));
extern int LYmbcsstrlen PARAMS((
d64 1
a64 1
	BOOL		count_gcells));
d66 1
a66 1
extern char * LYno_attr_mbcs_strstr PARAMS((
d68 1
a68 1
	CONST char *	tarptr,
d72 2
a73 2
	int *		nendp));
extern char * LYno_attr_mbcs_case_strstr PARAMS((
d75 1
a75 1
	CONST char *	tarptr,
d79 1
a79 1
	int *		nendp));
d88 1
a88 1
extern char * LYno_attr_char_strstr PARAMS((
d90 2
a91 2
	char *		tarptr));
extern char * LYno_attr_char_case_strstr PARAMS((
d93 1
a93 1
	char *		tarptr));
d100 1
a100 1
extern char * SNACopy PARAMS((
d102 3
a104 3
	CONST char *	src,
	int		n));
extern char * SNACat PARAMS((
d106 2
a107 2
	CONST char *	src,
	int		n));
d111 1
a111 1
extern char *LYSafeGets PARAMS((char ** src, FILE * fp));
d114 6
a119 6
extern BOOL LYHaveCmdScript NOPARAMS;
extern int LYReadCmdKey PARAMS((int mode));
extern void LYCloseCmdLogfile NOPARAMS;
extern void LYOpenCmdLogfile PARAMS((int argc, char **argv));
extern void LYOpenCmdScript NOPARAMS;
extern void LYWriteCmdKey PARAMS((int ch));
d290 2
a291 2
extern int lynx_initialize_keymaps NOPARAMS;
extern int map_string_to_keysym PARAMS((CONST char * src, int *lec));
d294 1
a294 1
extern char *LYElideString PARAMS((
d296 30
a325 30
	int		cut_pos));
extern void LYEscapeStartfile PARAMS((
	char **		buffer));
extern void LYLowerCase PARAMS((
	char *		buffer));
extern void LYUpperCase PARAMS((
	char *		buffer));
extern BOOLEAN LYRemoveNewlines PARAMS((
	char *		buffer));
extern char * LYRemoveBlanks PARAMS((
	char *		buffer));
extern char * LYSkipBlanks PARAMS((
	char *		buffer));
extern char * LYSkipNonBlanks PARAMS((
	char *		buffer));
extern CONST char * LYSkipCBlanks PARAMS((
	CONST char *	buffer));
extern CONST char * LYSkipCNonBlanks PARAMS((
	CONST char *	buffer));
extern void LYTrimLeading PARAMS((
	char *		buffer));
extern char * LYTrimNewline PARAMS((
	char *		buffer));
extern void LYTrimTrailing PARAMS((
	char *		buffer));
extern void LYTrimAllStartfile PARAMS((
	char *		buffer));
extern BOOLEAN LYTrimStartfile PARAMS((
	char *		buffer));
extern void LYSetupEdit PARAMS((
d329 5
a333 5
	int		maxdsp));
extern void LYRefreshEdit PARAMS((
	EditFieldData *	edit));
extern int EditBinding PARAMS((int ch));		   /* in LYEditmap.c */
extern BOOL LYRemapEditBinding PARAMS((
d336 4
a339 4
	int 		select_edi));			   /* in LYEditmap.c */
extern int LYKeyForEditAction PARAMS((int lec));	   /* in LYEditmap.c */
extern int LYEditKeyForAction PARAMS((int lac, int *pmodkey));/* LYEditmap.c */
extern int LYEdit1 PARAMS((
d343 3
a345 3
	BOOL		maxMessage));
extern void LYCloseCloset PARAMS((RecallType recall));
extern int LYhandlePopupList PARAMS((
d349 1
a349 1
	CONST char **	choices,
d354 1
a354 1
	BOOLEAN		numbered));
d361 1
a361 1
extern CONST char * LYLineeditHelpURLs[];
d363 1
a363 1
extern CONST char * LYLineeditHelpURL NOPARAMS;
d370 1
a370 1
extern int LYEditmapDeclared NOPARAMS;
d372 1
a372 1
int LYEditInsert PARAMS((EditFieldData *edit, unsigned char *s,	int len, int map_active, BOOL maxMessage));
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d6 9
a24 7
#ifdef HAVE_STRERROR
#define LYStrerror strerror
#else
extern char *LYStrerror PARAMS((
	int		code));
#endif /* HAVE_STRERROR */

d30 6
d37 3
a39 2
extern int LYgetch_for PARAMS((
	int		code));
d44 1
a44 1
	int		recall));
d63 3
a65 1
	BOOL		utf_flag));
d68 1
a68 1
	char *		tarptr,
d70 1
d75 1
a75 1
	char *		tarptr,
d77 1
d80 8
d95 5
d113 13
d127 4
d147 2
a148 2
#define MOUSE_KEY	0x11d	/* 0x11D */
/*  *** NOTE: ***
d155 21
d178 5
a182 4

#  define FOR_PANEL	0
#  define FOR_CHOICE	1
#  define FOR_INPUT	2
d186 6
a191 2
#define NORECALL 0
#define RECALL   1
d211 5
d223 58
a280 31
#define LYE_NOP 0		  /* Do Nothing            */
#define LYE_CHAR  (LYE_NOP   +1)  /* Insert printable char */
#define LYE_ENTER (LYE_CHAR  +1)  /* Input complete, return char/lynxkeycode */
#define LYE_TAB   (LYE_ENTER +1)  /* Input complete, return TAB  */
#define LYE_ABORT (LYE_TAB   +1)  /* Input cancelled       */

#define LYE_FORM_PASS (LYE_ABORT +1)  /* In form fields: input complete,
					 return char / lynxkeycode;
					 Elsewhere: Do Nothing */

#define LYE_DELN  (LYE_FORM_PASS +1)  /* Delete next/curr char */
#define LYE_DELC  (LYE_DELN)      /* Obsolete (DELC case was equiv to DELN) */
#define LYE_DELP  (LYE_DELN  +1)  /* Delete prev      char */
#define LYE_DELNW (LYE_DELP  +1)  /* Delete next word      */
#define LYE_DELPW (LYE_DELNW +1)  /* Delete prev word      */

#define LYE_ERASE (LYE_DELPW +1)  /* Erase the line        */

#define LYE_BOL   (LYE_ERASE +1)  /* Go to begin of line   */
#define LYE_EOL   (LYE_BOL   +1)  /* Go to end   of line   */
#define LYE_FORW  (LYE_EOL   +1)  /* Cursor forwards       */
#define LYE_BACK  (LYE_FORW  +1)  /* Cursor backwards      */
#define LYE_FORWW (LYE_BACK  +1)  /* Word forward          */
#define LYE_BACKW (LYE_FORWW +1)  /* Word back             */

#define LYE_LOWER (LYE_BACKW +1)  /* Lower case the line   */
#define LYE_UPPER (LYE_LOWER +1)  /* Upper case the line   */

#define LYE_LKCMD (LYE_UPPER +1)  /* Invoke command prompt */

#define LYE_AIX   (LYE_LKCMD +1)  /* Hex 97                */
d282 5
a286 2
#define LYE_DELBL (LYE_AIX   +1)  /* Delete back to BOL    */
#define LYE_DELEL (LYE_DELBL +1)  /* Delete thru EOL       */
a287 1
#define LYE_SWMAP (LYE_DELEL +1)  /* Switch input keymap   */
d291 1
d294 3
d303 3
a305 1
extern void LYRemoveBlanks PARAMS((
d317 2
d332 7
a338 1
extern int EditBinding PARAMS((int ch));
d344 13
a356 2
extern void LYOpenCloset NOPARAMS;
extern void LYCloseCloset NOPARAMS;
d360 2
a361 1
extern char * LYLineEditors[];
d363 5
a367 7
/* Push a character through the lineedit machinery */
#ifdef    NOT_ASCII  /* S/390 -- gil -- 2080 */
#define EditBinding(c) (LYLineEditors[current_lineedit][(c)<256 ? TOASCII(c) : c])
#else  /* NOT_ASCII */
#define EditBinding(c) (LYLineEditors[current_lineedit][c])
#endif /* NOT_ASCII */
#define LYLineEdit(e,c,m) LYEdit1(e,c,EditBinding(c),m)
d371 2
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a5 12
#ifdef __cplusplus
extern "C" {
#endif
    typedef enum {
	NORECALL = 0
	,RECALL_URL
	,RECALL_CMD
	,RECALL_MAIL
    } RecallType;

#define is8bits(ch) (UCH(ch) >= 128)	/* isascii(ch) is not POSIX */

d7 8
a14 77
    extern int UPPER8(int ch1,
		      int ch2);

    extern int get_mouse_link(void);
    extern int peek_mouse_link(void);
    extern int peek_mouse_levent(void);
    extern int fancy_mouse(WINDOW * win, int row, int *position);

    extern char *LYstrncpy(char *dst,
			   const char *src,
			   int n);
    extern void ena_csi(BOOLEAN flag);
    extern int get_popup_number(const char *msg,
				int *c,
				int *rel);
    extern int LYarrayLength(const char **list);
    extern int LYarrayWidth(const char **list);
    extern int LYgetch(void);
    extern int LYgetch_choice(void);
    extern int LYgetch_input(void);
    extern int LYgetch_single(void);
    extern int LYgetstr(char *inputline,
			int hidden,
			size_t bufsize,
			RecallType recall);
    extern char *LYstrsep(char **stringp,
			  const char *delim);
    extern char *LYstrstr(char *chptr,
			  const char *tarptr);
    extern char *LYmbcsstrncpy(char *dst,
			       const char *src,
			       int n_bytes,
			       int n_glyphs,
			       BOOL utf_flag);
    extern const char *LYmbcs_skip_glyphs(const char *data,
					  int n_glyphs,
					  BOOL utf_flag);
    extern int LYmbcsstrlen(const char *str,
			    BOOL utf_flag,
			    BOOL count_gcells);

    extern const char *LYno_attr_mbcs_strstr(const char *chptr,
					     const char *tarptr,
					     BOOL utf_flag,
					     BOOL count_gcells,
					     int *nstartp,
					     int *nendp);
    extern const char *LYno_attr_mbcs_case_strstr(const char *chptr,
						  const char *tarptr,
						  BOOL utf_flag,
						  BOOL count_gcells,
						  int *nstartp,
						  int *nendp);

#define non_empty(s) !isEmpty(s)

#define LYno_attr_mb_strstr(chptr, tarptr, utf_flag, count_gcells, nstartp, nendp) \
	(case_sensitive \
	    ? LYno_attr_mbcs_strstr(chptr, tarptr, utf_flag, count_gcells, nstartp, nendp) \
	    : LYno_attr_mbcs_case_strstr(chptr, tarptr, utf_flag, count_gcells, nstartp, nendp))

    extern const char *LYno_attr_char_strstr(const char *chptr,
					     const char *tarptr);
    extern const char *LYno_attr_char_case_strstr(const char *chptr,
						  const char *tarptr);

#define LYno_attr_strstr(chptr, tarptr) \
	(case_sensitive \
	? LYno_attr_char_strstr(chptr, tarptr) \
	: LYno_attr_char_case_strstr(chptr, tarptr))

    extern char *SNACopy(char **dest,
			 const char *src,
			 int n);
    extern char *SNACat(char **dest,
			const char *src,
			int n);
d16 66
d85 1
a85 15
    extern char *LYSafeGets(char **src, FILE *fp);

#ifdef EXP_CMD_LOGGING
    extern BOOL LYHaveCmdScript(void);
    extern int LYReadCmdKey(int mode);
    extern void LYCloseCmdLogfile(void);
    extern void LYOpenCmdLogfile(int argc, char **argv);
    extern void LYOpenCmdScript(void);
    extern void LYWriteCmdKey(int ch);

#else
#define LYHaveCmdScript() FALSE
#define LYReadCmdKey(mode) LYgetch_for(mode)
#define LYCloseCmdLogfile()	/* nothing */
#endif
a87 4
/* The following are lynxkeycodes, not to be confused with
   lynxactioncodes (LYK_*) to which they are often mapped.
   The lynxkeycodes include all single-byte keys as a subset. - kw
*/
d104 7
a110 8
#define MOUSE_KEY	285	/* 0x11D */
/*  ***** NOTES: *****
    If you add definitions for new lynxkeycodes to the above list that need to
    be mapped to LYK_* lynxactioncodes -

    - AT LEAST the tables keymap[] and key_override[] in LYKeymap.c have to be
      changed/reviewed, AS WELL AS the lineedit binding tables in LYEditmap.c !

d112 1
a113 23
    - See also table named_keys[] in LYKeymap.c for 'pretty' strings for the
      keys with codes >= 256 (to appear on the 'K'eymap page).  New keycodes
      should probably be assigned consecutively, so their key names can be
      easily added to named_keys[] (but see next point).  They should also be
      documented in lynx.cfg.

    - The DOS port uses its own native codes for some keys, unless they are
      remapped by the code in LYgetch().  See *.key files in docs/ directory. 
      Adding new keys here may conflict with those codes (affecting DOS users),
      unless/until remapping is added or changed in LYgetch().  (N)curses
      keypad codes (KEY_* from curses.h) can also directly appear as
      lynxkeycodes and conflict with our assignments, although that shouldn't
      happen - the useful ones should be recognized in LYgetch().

    - The actual recognition of raw input keys or escape sequences, and mapping
      to our lynxkeycodes, take place in LYgetch() and/or its subsidiary
      functions and/or the curses/slang/etc.  libraries.

    The basic lynxkeycodes can appear combined with various flags in
    higher-order bits as extended lynxkeycodes; see macros in LYKeymap.h.  The
    range of possible basic values is therefore limited, they have to be less
    than LKC_ISLKC (even if KEYMAP_SIZE is increased).
*/
d115 3
a117 5
#  define FOR_PANEL	0	/* normal screen, also LYgetch default */
#  define FOR_CHOICE	1	/* mouse menu */
#  define FOR_INPUT	2	/* form input and textarea field */
#  define FOR_PROMPT	3	/* string prompt editing */
#  define FOR_SINGLEKEY	4	/* single key prompt, confirmation */
d121 2
a122 6

#ifdef EXP_ALT_BINDINGS
/*  Enable code implementing additional, mostly emacs-like, line-editing
    functions. - kw */
#define ENHANCED_LINEEDIT
#endif
d126 1
a126 1
    typedef struct _EditFieldData {
d128 14
a141 19
	int sx;			/* Origin of editfield                       */
	int sy;
	int dspwdth;		/* Screen real estate for editting           */

	int strlen;		/* Current size of string.                   */
	int maxlen;		/* Max size of string, excluding zero at end */
	char pad;		/* Right padding  typically ' ' or '_'       */
	BOOL hidden;		/* Masked password entry flag                */

	BOOL dirty;		/* accumulate refresh requests               */
	BOOL panon;		/* Need horizontal scroll indicator          */
	int xpan;		/* Horizontal scroll offset                  */
	int pos;		/* Insertion point in string                 */
	int margin;		/* Number of columns look-ahead/look-back    */
	int current_modifiers;	/* Modifiers for next input lynxkeycode */
#ifdef ENHANCED_LINEEDIT
	int mark;		/* position of emacs-like mark, or -1-pos to denote
				   unactive mark.  */
#endif
d143 1
a143 1
	char buffer[1024];	/* String buffer                          */
d145 1
a145 1
    } EditFieldData;
d149 31
a179 57
    typedef enum {
	LYE_NOP = 0		/* Do Nothing            */
	,LYE_CHAR		/* Insert printable char */
	,LYE_ENTER		/* Input complete, return char/lynxkeycode */
	,LYE_TAB		/* Input complete, return TAB  */
	,LYE_STOP		/* Input complete, deactivate  */
	,LYE_ABORT		/* Input cancelled       */

	,LYE_FORM_PASS		/* In form fields: input complete,
				   return char / lynxkeycode;
				   Elsewhere: Do Nothing */

	,LYE_DELN		/* Delete next/curr char */
	,LYE_DELC		/* Obsolete (DELC case was equiv to DELN) */
	,LYE_DELP		/* Delete prev      char */
	,LYE_DELNW		/* Delete next word      */
	,LYE_DELPW		/* Delete prev word      */

	,LYE_ERASE		/* Erase the line        */

	,LYE_BOL		/* Go to begin of line   */
	,LYE_EOL		/* Go to end   of line   */
	,LYE_FORW		/* Cursor forwards       */
	,LYE_FORW_RL		/* Cursor forwards or right link */
	,LYE_BACK		/* Cursor backwards      */
	,LYE_BACK_LL		/* Cursor backwards or left link */
	,LYE_FORWW		/* Word forward          */
	,LYE_BACKW		/* Word back             */

	,LYE_LOWER		/* Lower case the line   */
	,LYE_UPPER		/* Upper case the line   */

	,LYE_LKCMD		/* Invoke command prompt */

	,LYE_AIX		/* Hex 97                */

	,LYE_DELBL		/* Delete back to BOL    */
	,LYE_DELEL		/* Delete thru EOL       */

	,LYE_SWMAP		/* Switch input keymap   */

	,LYE_TPOS		/* Transpose characters  */

	,LYE_SETM1		/* Set modifier 1 flag   */
	,LYE_SETM2		/* Set modifier 2 flag   */
	,LYE_UNMOD		/* Fall back to no-modifier command */

	,LYE_C1CHAR		/* Insert C1 char if printable */

	,LYE_SETMARK		/* emacs-like set-mark-command */
	,LYE_XPMARK		/* emacs-like exchange-point-and-mark */
	,LYE_KILLREG		/* emacs-like kill-region */
	,LYE_YANK		/* emacs-like yank */
#ifdef CAN_CUT_AND_PASTE
	,LYE_PASTE		/* ClipBoard to Lynx       */
#endif
    } LYEditCodes;
d181 2
a182 1
/* All preceding values must be within 0x00..0x7f - kw */
d184 1
a184 5
/*  The following are meant to be bitwise or-ed:  */
#define LYE_DF       0x80	/* Flag to set modifier 3 AND do other
				   action */
#define LYE_FORM_LAC 0x1000	/* Flag to pass lynxactioncode given by
				   lower bits.  Doesn't fit in a char! */
d187 1
a187 2
    extern int lynx_initialize_keymaps(void);
    extern int map_string_to_keysym(const char *src, int *lec);
d190 51
a240 53
    extern char *LYElideString(char *str,
			       int cut_pos);
    extern void LYEscapeStartfile(char **buffer);
    extern void LYLowerCase(char *buffer);
    extern void LYUpperCase(char *buffer);
    extern BOOLEAN LYRemoveNewlines(char *buffer);
    extern char *LYReduceBlanks(char *buffer);
    extern char *LYRemoveBlanks(char *buffer);
    extern char *LYSkipBlanks(char *buffer);
    extern char *LYSkipNonBlanks(char *buffer);
    extern const char *LYSkipCBlanks(const char *buffer);
    extern const char *LYSkipCNonBlanks(const char *buffer);
    extern void LYTrimLeading(char *buffer);
    extern char *LYTrimNewline(char *buffer);
    extern void LYTrimTrailing(char *buffer);
    extern void LYTrimAllStartfile(char *buffer);
    extern BOOLEAN LYTrimStartfile(char *buffer);
    extern void LYSetupEdit(EditFieldData *edit, char *old,
			    int maxstr,
			    int maxdsp);
    extern void LYRefreshEdit(EditFieldData *edit);
    extern int EditBinding(int ch);	/* in LYEditmap.c */
    extern BOOL LYRemapEditBinding(int xlkc,
				   int lec,
				   int select_edi);	/* in LYEditmap.c */
    extern int LYKeyForEditAction(int lec);	/* in LYEditmap.c */
    extern int LYEditKeyForAction(int lac, int *pmodkey);	/* LYEditmap.c */
    extern int LYEdit1(EditFieldData *edit, int ch,
		       int action,
		       BOOL maxMessage);
    extern void LYCloseCloset(RecallType recall);
    extern int LYhandlePopupList(int cur_choice,
				 int ly,
				 int lx,
				 const char **choices,
				 int width,
				 int i_length,
				 int disabled,
				 BOOLEAN for_mouse,
				 BOOLEAN numbered);

    typedef unsigned char LYEditCode;

    extern int current_lineedit;
    extern const char *LYLineeditNames[];
    extern LYEditCode *LYLineEditors[];
    extern const char *LYLineeditHelpURLs[];

    extern const char *LYLineeditHelpURL(void);

    extern int escape_bound;

#define LYLineEdit(e,c,m) LYEdit1(e, c, EditBinding(c) & ~LYE_DF, m)
d243 1
a243 6
    extern int LYEditmapDeclared(void);

    extern int LYEditInsert(EditFieldData *edit,
			    unsigned const char *s,
			    int len, int map_active,
			    BOOL maxMessage);
d245 1
a245 4
#ifdef __cplusplus
}
#endif
#endif				/* LYSTRINGS_H */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a5 9
typedef enum {
    NORECALL = 0
    , RECALL_URL
    , RECALL_CMD
    , RECALL_MAIL
} RecallType;

#define is8bits(ch) (UCH(ch) >= 128)	/* isascii(ch) is not POSIX */

d16 7
a27 6
extern int get_popup_number PARAMS((
	char *		msg,
	int *		c,
	int *		rel));
extern int LYarrayLength PARAMS((CONST char ** list));
extern int LYarrayWidth PARAMS((CONST char ** list));
d29 2
a30 3
extern int LYgetch_choice NOPARAMS;
extern int LYgetch_input NOPARAMS;
extern int LYgetch_single NOPARAMS;
d35 1
a35 1
	RecallType	recall));
d54 1
a54 3
	BOOL		utf_flag,
	BOOL		count_gcells));

d57 1
a57 1
	CONST char *	tarptr,
a58 1
	BOOL		count_gcells,
d63 1
a63 1
	CONST char *	tarptr,
a64 1
	BOOL		count_gcells,
a66 8

#define non_empty(s) !isEmpty(s)

#define LYno_attr_mb_strstr(chptr, tarptr, utf_flag, count_gcells, nstartp, nendp) \
	(case_sensitive \
	    ? LYno_attr_mbcs_strstr(chptr, tarptr, utf_flag, count_gcells, nstartp, nendp) \
	    : LYno_attr_mbcs_case_strstr(chptr, tarptr, utf_flag, count_gcells, nstartp, nendp))

a73 5
#define LYno_attr_strstr(chptr, tarptr) \
	(case_sensitive \
	? LYno_attr_char_strstr(chptr, tarptr) \
	: LYno_attr_char_case_strstr(chptr, tarptr))

a86 13
#ifdef EXP_CMD_LOGGING
extern BOOL LYHaveCmdScript NOPARAMS;
extern int LYReadCmdKey PARAMS((int mode));
extern void LYCloseCmdLogfile NOPARAMS;
extern void LYOpenCmdLogfile PARAMS((int argc, char **argv));
extern void LYOpenCmdScript NOPARAMS;
extern void LYWriteCmdKey PARAMS((int ch));
#else
#define LYHaveCmdScript() FALSE
#define LYReadCmdKey(mode) LYgetch_for(mode)
#define LYCloseCmdLogfile() /* nothing */
#endif

a87 4
/* The following are lynxkeycodes, not to be confused with
   lynxactioncodes (LYK_*) to which they are often mapped.
   The lynxkeycodes include all single-byte keys as a subset. - kw
*/
d104 2
a105 2
#define MOUSE_KEY	285	/* 0x11D */
/*  ***** NOTES: *****
a111 21
    - See also table named_keys[] in LYKeymap.c for 'pretty' strings
      for the keys with codes >= 256 (to appear on the 'K'eymap page).
      New keycodes should probably be assigned consecutively, so their
      key names can be easily added to named_keys[] (but see next point).
      They should also be documented in lynx.cfg.
    - The DOS port uses its own native codes for some keys, unless
      they are remapped by the code in LYgetch().  See *.key files
      in docs/ directory.  Adding new keys here may conflict with
      those codes (affecting DOS users), unless/until remapping is
      added or changed in LYgetch().
      (N)curses keypad codes (KEY_* from curses.h) can also directly
      appear as lynxkeycodes and conflict with our assignments, although
      that shouldn't happen - the useful ones should be recognized in
      LYgetch().
    - The actual recognition of raw input keys or escape sequences, and
      mapping to our lynxkeycodes, take place in LYgetch() and/or its
      subsidiary functions and/or the curses/slang/etc. libraries.
    The basic lynxkeycodes can appear combined with various flags in
    higher-order bits as extended lynxkeycodes; see macros in LYKeymap.h.
    The range of possible basic values is therefore limited, they have
    to be less than LKC_ISLKC (even if KEYMAP_SIZE is increased).
d114 4
a117 5
#  define FOR_PANEL	0	/* normal screen, also LYgetch default */
#  define FOR_CHOICE	1	/* mouse menu */
#  define FOR_INPUT	2	/* form input and textarea field */
#  define FOR_PROMPT	3	/* string prompt editing */
#  define FOR_SINGLEKEY	4	/* single key prompt, confirmation */
d121 2
a122 6

#ifdef EXP_ALT_BINDINGS
/*  Enable code implementing additional, mostly emacs-like, line-editing
    functions. - kw */
#define ENHANCED_LINEEDIT
#endif
a141 5
        int  current_modifiers; /* Modifiers for next input lynxkeycode */
#ifdef ENHANCED_LINEEDIT
	int  mark;	/* position of emacs-like mark, or -1-pos to denote
				unactive mark.  */
#endif
d149 31
a179 58
typedef enum {
    LYE_NOP = 0			/* Do Nothing		 */
    ,LYE_CHAR			/* Insert printable char */
    ,LYE_ENTER			/* Input complete, return char/lynxkeycode */
    ,LYE_TAB			/* Input complete, return TAB  */
    ,LYE_STOP			/* Input complete, deactivate  */
    ,LYE_ABORT			/* Input cancelled	 */

    ,LYE_FORM_PASS		/* In form fields: input complete,
				   return char / lynxkeycode;
				   Elsewhere: Do Nothing */

    ,LYE_DELN			/* Delete next/curr char */
    ,LYE_DELC			/* Obsolete (DELC case was equiv to DELN) */
    ,LYE_DELP			/* Delete prev	    char */
    ,LYE_DELNW			/* Delete next word	 */
    ,LYE_DELPW			/* Delete prev word	 */

    ,LYE_ERASE			/* Erase the line	 */

    ,LYE_BOL			/* Go to begin of line	 */
    ,LYE_EOL			/* Go to end   of line	 */
    ,LYE_FORW			/* Cursor forwards	 */
    ,LYE_FORW_RL		/* Cursor forwards or right link */
    ,LYE_BACK			/* Cursor backwards	 */
    ,LYE_BACK_LL		/* Cursor backwards or left link */
    ,LYE_FORWW			/* Word forward		 */
    ,LYE_BACKW			/* Word back		 */

    ,LYE_LOWER			/* Lower case the line	 */
    ,LYE_UPPER			/* Upper case the line	 */

    ,LYE_LKCMD			/* Invoke command prompt */

    ,LYE_AIX			/* Hex 97		 */

    ,LYE_DELBL			/* Delete back to BOL	 */
    ,LYE_DELEL			/* Delete thru EOL	 */

    ,LYE_SWMAP			/* Switch input keymap	 */

    ,LYE_TPOS			/* Transpose characters	 */

    ,LYE_SETM1			/* Set modifier 1 flag	 */
    ,LYE_SETM2			/* Set modifier 2 flag	 */
    ,LYE_UNMOD			/* Fall back to no-modifier command */

    ,LYE_C1CHAR			/* Insert C1 char if printable */

    ,LYE_SETMARK		/* emacs-like set-mark-command */
    ,LYE_XPMARK			/* emacs-like exchange-point-and-mark */
    ,LYE_KILLREG		/* emacs-like kill-region */
    ,LYE_YANK			/* emacs-like yank */
#ifdef CAN_CUT_AND_PASTE
    ,LYE_PASTE			/* ClipBoard to Lynx	   */
#endif
} LYEditCodes;
/* All preceding values must be within 0x00..0x7f - kw */
d181 2
a182 5
/*  The following are meant to be bitwise or-ed:  */
#define LYE_DF       0x80       /* Flag to set modifier 3 AND do other
				   action */
#define LYE_FORM_LAC 0x1000     /* Flag to pass lynxactioncode given by
				   lower bits.  Doesn't fit in a char! */
d184 1
a187 1
extern int map_string_to_keysym PARAMS((CONST char * src, int *lec));
a189 3
extern char *LYElideString PARAMS((
	char *		str,
	int		cut_pos));
d196 1
a196 3
extern BOOLEAN LYRemoveNewlines PARAMS((
	char *		buffer));
extern char * LYRemoveBlanks PARAMS((
a207 2
extern char * LYTrimNewline PARAMS((
	char *		buffer));
d221 1
a221 7
extern int EditBinding PARAMS((int ch));		   /* in LYEditmap.c */
extern BOOL LYRemapEditBinding PARAMS((
	int		xlkc,
	int		lec,
	int 		select_edi));			   /* in LYEditmap.c */
extern int LYKeyForEditAction PARAMS((int lec));	   /* in LYEditmap.c */
extern int LYEditKeyForAction PARAMS((int lac, int *pmodkey));/* LYEditmap.c */
d227 2
a228 13
extern void LYCloseCloset PARAMS((RecallType recall));
extern int LYhandlePopupList PARAMS((
	int		cur_choice,
	int		ly,
	int		lx,
	CONST char **	choices,
	int		width,
	int		i_length,
	int		disabled,
	BOOLEAN		for_mouse,
	BOOLEAN		numbered));

typedef unsigned char LYEditCode;
d232 1
a232 2
extern LYEditCode * LYLineEditors[];
extern CONST char * LYLineeditHelpURLs[];
d234 7
a240 5
extern CONST char * LYLineeditHelpURL NOPARAMS;

extern int escape_bound;

#define LYLineEdit(e,c,m) LYEdit1(e,c,EditBinding(c)&~LYE_DF,m)
a243 2

int LYEditInsert PARAMS((EditFieldData *edit, unsigned char *s,	int len, int map_active, BOOL maxMessage));
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d16 1
a16 1
extern int UPPER8  (
d18 1
a18 1
	int		ch2);
d20 4
a23 4
extern int get_mouse_link (void);
extern int peek_mouse_link (void);
extern int peek_mouse_levent (void);
extern int fancy_mouse (WINDOW *win, int row, int *position);
d25 1
a25 1
extern char * LYstrncpy (
d27 4
a30 4
	const char *	src,
	int		n);
extern void ena_csi (BOOLEAN flag);
extern int get_popup_number (
d33 8
a40 8
	int *		rel);
extern int LYarrayLength (const char ** list);
extern int LYarrayWidth (const char ** list);
extern int LYgetch (void);
extern int LYgetch_choice (void);
extern int LYgetch_input (void);
extern int LYgetch_single (void);
extern int LYgetstr (
d44 2
a45 2
	RecallType	recall);
extern char *LYstrsep (
d47 2
a48 2
	const char *	delim);
extern char * LYstrstr (
d50 2
a51 2
	const char *	tarptr);
extern char * LYmbcsstrncpy (
d53 1
a53 1
	const char *	src,
d56 2
a57 2
	BOOL		utf_flag);
extern char * LYmbcs_skip_glyphs (
d60 2
a61 2
	BOOL		utf_flag);
extern int LYmbcsstrlen (
d64 1
a64 1
	BOOL		count_gcells);
d66 1
a66 1
extern char * LYno_attr_mbcs_strstr (
d68 1
a68 1
	const char *	tarptr,
d72 2
a73 2
	int *		nendp);
extern char * LYno_attr_mbcs_case_strstr (
d75 1
a75 1
	const char *	tarptr,
d79 1
a79 1
	int *		nendp);
d88 1
a88 1
extern char * LYno_attr_char_strstr (
d90 2
a91 2
	char *		tarptr);
extern char * LYno_attr_char_case_strstr (
d93 1
a93 1
	char *		tarptr);
d100 1
a100 1
extern char * SNACopy (
d102 3
a104 3
	const char *	src,
	int		n);
extern char * SNACat (
d106 2
a107 2
	const char *	src,
	int		n);
d111 1
a111 1
extern char *LYSafeGets (char ** src, FILE * fp);
d114 6
a119 6
extern BOOL LYHaveCmdScript (void);
extern int LYReadCmdKey (int mode);
extern void LYCloseCmdLogfile (void);
extern void LYOpenCmdLogfile (int argc, char **argv);
extern void LYOpenCmdScript (void);
extern void LYWriteCmdKey (int ch);
d290 2
a291 2
extern int lynx_initialize_keymaps (void);
extern int map_string_to_keysym (const char * src, int *lec);
d294 1
a294 1
extern char *LYElideString (
d296 30
a325 30
	int		cut_pos);
extern void LYEscapeStartfile (
	char **		buffer);
extern void LYLowerCase (
	char *		buffer);
extern void LYUpperCase (
	char *		buffer);
extern BOOLEAN LYRemoveNewlines (
	char *		buffer);
extern char * LYRemoveBlanks (
	char *		buffer);
extern char * LYSkipBlanks (
	char *		buffer);
extern char * LYSkipNonBlanks (
	char *		buffer);
extern const char * LYSkipCBlanks (
	const char *	buffer);
extern const char * LYSkipCNonBlanks (
	const char *	buffer);
extern void LYTrimLeading (
	char *		buffer);
extern char * LYTrimNewline (
	char *		buffer);
extern void LYTrimTrailing (
	char *		buffer);
extern void LYTrimAllStartfile (
	char *		buffer);
extern BOOLEAN LYTrimStartfile (
	char *		buffer);
extern void LYSetupEdit (
d329 5
a333 5
	int		maxdsp);
extern void LYRefreshEdit (
	EditFieldData *	edit);
extern int EditBinding (int ch);		   /* in LYEditmap.c */
extern BOOL LYRemapEditBinding (
d336 4
a339 4
	int 		select_edi);			   /* in LYEditmap.c */
extern int LYKeyForEditAction (int lec);	   /* in LYEditmap.c */
extern int LYEditKeyForAction (int lac, int *pmodkey);/* LYEditmap.c */
extern int LYEdit1 (
d343 3
a345 3
	BOOL		maxMessage);
extern void LYCloseCloset (RecallType recall);
extern int LYhandlePopupList (
d349 1
a349 1
	const char **	choices,
d354 1
a354 1
	BOOLEAN		numbered);
d361 1
a361 1
extern const char * LYLineeditHelpURLs[];
d363 1
a363 1
extern const char * LYLineeditHelpURL (void);
d370 1
a370 1
extern int LYEditmapDeclared (void);
d372 1
a372 1
int LYEditInsert (EditFieldData *edit, unsigned char *s,	int len, int map_active, BOOL maxMessage);
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d8 3
a10 3
    ,RECALL_URL
    ,RECALL_CMD
    ,RECALL_MAIL
d16 64
a79 53
extern int UPPER8(int ch1,
		  int ch2);

extern int get_mouse_link(void);
extern int peek_mouse_link(void);
extern int peek_mouse_levent(void);
extern int fancy_mouse(WINDOW * win, int row, int *position);

extern char *LYstrncpy(char *dst,
		       const char *src,
		       int n);
extern void ena_csi(BOOLEAN flag);
extern int get_popup_number(char *msg,
			    int *c,
			    int *rel);
extern int LYarrayLength(const char **list);
extern int LYarrayWidth(const char **list);
extern int LYgetch(void);
extern int LYgetch_choice(void);
extern int LYgetch_input(void);
extern int LYgetch_single(void);
extern int LYgetstr(char *inputline,
		    int hidden,
		    size_t bufsize,
		    RecallType recall);
extern char *LYstrsep(char **stringp,
		      const char *delim);
extern char *LYstrstr(char *chptr,
		      const char *tarptr);
extern char *LYmbcsstrncpy(char *dst,
			   const char *src,
			   int n_bytes,
			   int n_glyphs,
			   BOOL utf_flag);
extern char *LYmbcs_skip_glyphs(char *data,
				int n_glyphs,
				BOOL utf_flag);
extern int LYmbcsstrlen(char *str,
			BOOL utf_flag,
			BOOL count_gcells);

extern char *LYno_attr_mbcs_strstr(char *chptr,
				   const char *tarptr,
				   BOOL utf_flag,
				   BOOL count_gcells,
				   int *nstartp,
				   int *nendp);
extern char *LYno_attr_mbcs_case_strstr(char *chptr,
					const char *tarptr,
					BOOL utf_flag,
					BOOL count_gcells,
					int *nstartp,
					int *nendp);
d88 6
a93 4
extern char *LYno_attr_char_strstr(char *chptr,
				   char *tarptr);
extern char *LYno_attr_char_case_strstr(char *chptr,
					char *tarptr);
d100 8
a107 7
extern char *SNACopy(char **dest,
		     const char *src,
		     int n);
extern char *SNACat(char **dest,
		    const char *src,
		    int n);

d111 1
a111 1
extern char *LYSafeGets(char **src, FILE *fp);
d114 6
a119 7
extern BOOL LYHaveCmdScript(void);
extern int LYReadCmdKey(int mode);
extern void LYCloseCmdLogfile(void);
extern void LYOpenCmdLogfile(int argc, char **argv);
extern void LYOpenCmdScript(void);
extern void LYWriteCmdKey(int ch);

d123 1
a123 1
#define LYCloseCmdLogfile()	/* nothing */
d149 5
a153 6
    If you add definitions for new lynxkeycodes to the above list that need to
    be mapped to LYK_* lynxactioncodes -

    - AT LEAST the tables keymap[] and key_override[] in LYKeymap.c have to be
      changed/reviewed, AS WELL AS the lineedit binding tables in LYEditmap.c !

d155 17
a171 19

    - See also table named_keys[] in LYKeymap.c for 'pretty' strings for the
      keys with codes >= 256 (to appear on the 'K'eymap page).  New keycodes
      should probably be assigned consecutively, so their key names can be
      easily added to named_keys[] (but see next point).  They should also be
      documented in lynx.cfg.

    - The DOS port uses its own native codes for some keys, unless they are
      remapped by the code in LYgetch().  See *.key files in docs/ directory. 
      Adding new keys here may conflict with those codes (affecting DOS users),
      unless/until remapping is added or changed in LYgetch().  (N)curses
      keypad codes (KEY_* from curses.h) can also directly appear as
      lynxkeycodes and conflict with our assignments, although that shouldn't
      happen - the useful ones should be recognized in LYgetch().

    - The actual recognition of raw input keys or escape sequences, and mapping
      to our lynxkeycodes, take place in LYgetch() and/or its subsidiary
      functions and/or the curses/slang/etc.  libraries.

d173 3
a175 3
    higher-order bits as extended lynxkeycodes; see macros in LYKeymap.h.  The
    range of possible basic values is therefore limited, they have to be less
    than LKC_ISLKC (even if KEYMAP_SIZE is increased).
d197 15
a211 15
    int sx;			/* Origin of editfield                       */
    int sy;
    int dspwdth;		/* Screen real estate for editting           */

    int strlen;			/* Current size of string.                   */
    int maxlen;			/* Max size of string, excluding zero at end */
    char pad;			/* Right padding  typically ' ' or '_'       */
    BOOL hidden;		/* Masked password entry flag                */

    BOOL dirty;			/* accumulate refresh requests               */
    BOOL panon;			/* Need horizontal scroll indicator          */
    int xpan;			/* Horizontal scroll offset                  */
    int pos;			/* Insertion point in string                 */
    int margin;			/* Number of columns look-ahead/look-back    */
    int current_modifiers;	/* Modifiers for next input lynxkeycode */
d213 2
a214 2
    int mark;			/* position of emacs-like mark, or -1-pos to denote
				   unactive mark.  */
d217 1
a217 1
    char buffer[1024];		/* String buffer                          */
d224 1
a224 1
    LYE_NOP = 0			/* Do Nothing            */
d229 1
a229 1
    ,LYE_ABORT			/* Input cancelled       */
d237 9
a245 9
    ,LYE_DELP			/* Delete prev      char */
    ,LYE_DELNW			/* Delete next word      */
    ,LYE_DELPW			/* Delete prev word      */

    ,LYE_ERASE			/* Erase the line        */

    ,LYE_BOL			/* Go to begin of line   */
    ,LYE_EOL			/* Go to end   of line   */
    ,LYE_FORW			/* Cursor forwards       */
d247 1
a247 1
    ,LYE_BACK			/* Cursor backwards      */
d249 2
a250 2
    ,LYE_FORWW			/* Word forward          */
    ,LYE_BACKW			/* Word back             */
d252 2
a253 2
    ,LYE_LOWER			/* Lower case the line   */
    ,LYE_UPPER			/* Upper case the line   */
d257 1
a257 1
    ,LYE_AIX			/* Hex 97                */
d259 2
a260 2
    ,LYE_DELBL			/* Delete back to BOL    */
    ,LYE_DELEL			/* Delete thru EOL       */
d262 1
a262 1
    ,LYE_SWMAP			/* Switch input keymap   */
d264 1
a264 1
    ,LYE_TPOS			/* Transpose characters  */
d266 2
a267 2
    ,LYE_SETM1			/* Set modifier 1 flag   */
    ,LYE_SETM2			/* Set modifier 2 flag   */
d277 1
a277 1
    ,LYE_PASTE			/* ClipBoard to Lynx       */
a279 1

d283 1
a283 1
#define LYE_DF       0x80	/* Flag to set modifier 3 AND do other
d285 1
a285 1
#define LYE_FORM_LAC 0x1000	/* Flag to pass lynxactioncode given by
d288 1
d290 2
a291 2
extern int lynx_initialize_keymaps(void);
extern int map_string_to_keysym(const char *src, int *lec);
d294 61
a354 39
extern char *LYElideString(char *str,
			   int cut_pos);
extern void LYEscapeStartfile(char **buffer);
extern void LYLowerCase(char *buffer);
extern void LYUpperCase(char *buffer);
extern BOOLEAN LYRemoveNewlines(char *buffer);
extern char *LYRemoveBlanks(char *buffer);
extern char *LYSkipBlanks(char *buffer);
extern char *LYSkipNonBlanks(char *buffer);
extern const char *LYSkipCBlanks(const char *buffer);
extern const char *LYSkipCNonBlanks(const char *buffer);
extern void LYTrimLeading(char *buffer);
extern char *LYTrimNewline(char *buffer);
extern void LYTrimTrailing(char *buffer);
extern void LYTrimAllStartfile(char *buffer);
extern BOOLEAN LYTrimStartfile(char *buffer);
extern void LYSetupEdit(EditFieldData *edit, char *old,
			int maxstr,
			int maxdsp);
extern void LYRefreshEdit(EditFieldData *edit);
extern int EditBinding(int ch);	/* in LYEditmap.c */
extern BOOL LYRemapEditBinding(int xlkc,
			       int lec,
			       int select_edi);		/* in LYEditmap.c */
extern int LYKeyForEditAction(int lec);		/* in LYEditmap.c */
extern int LYEditKeyForAction(int lac, int *pmodkey);	/* LYEditmap.c */
extern int LYEdit1(EditFieldData *edit, int ch,
		   int action,
		   BOOL maxMessage);
extern void LYCloseCloset(RecallType recall);
extern int LYhandlePopupList(int cur_choice,
			     int ly,
			     int lx,
			     const char **choices,
			     int width,
			     int i_length,
			     int disabled,
			     BOOLEAN for_mouse,
			     BOOLEAN numbered);
d359 3
a361 3
extern char *LYLineeditNames[];
extern LYEditCode *LYLineEditors[];
extern const char *LYLineeditHelpURLs[];
d363 1
a363 1
extern const char *LYLineeditHelpURL(void);
d367 1
a367 1
#define LYLineEdit(e,c,m) LYEdit1(e, c, EditBinding(c) & ~LYE_DF, m)
d370 1
a370 1
extern int LYEditmapDeclared(void);
d372 1
a372 4
extern int LYEditInsert(EditFieldData *edit,
			unsigned char *s,
			int len, int map_active,
			BOOL maxMessage);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a5 7
typedef enum {
    NORECALL = 0
    , RECALL_URL
    , RECALL_CMD
    , RECALL_MAIL
} RecallType;

d16 7
a27 6
extern int get_popup_number PARAMS((
	char *		msg,
	int *		c,
	int *		rel));
extern int LYarrayLength PARAMS((CONST char ** list));
extern int LYarrayWidth PARAMS((CONST char ** list));
d29 2
a30 3
extern int LYgetch_choice NOPARAMS;
extern int LYgetch_input NOPARAMS;
extern int LYgetch_single NOPARAMS;
d35 1
a35 1
	RecallType	recall));
d54 1
a54 3
	BOOL		utf_flag,
	BOOL		count_gcells));

d57 1
a57 1
	CONST char *	tarptr,
a58 1
	BOOL		count_gcells,
d63 1
a63 1
	CONST char *	tarptr,
a64 1
	BOOL		count_gcells,
a66 6

#define LYno_attr_mb_strstr(chptr, tarptr, utf_flag, count_gcells, nstartp, nendp) \
	(case_sensitive \
	    ? LYno_attr_mbcs_strstr(chptr, tarptr, utf_flag, count_gcells, nstartp, nendp) \
	    : LYno_attr_mbcs_case_strstr(chptr, tarptr, utf_flag, count_gcells, nstartp, nendp))

a73 5
#define LYno_attr_strstr(chptr, tarptr) \
	(case_sensitive \
	? LYno_attr_char_strstr(chptr, tarptr) \
	: LYno_attr_char_case_strstr(chptr, tarptr))

a86 17
#ifdef EXP_CMD_LOGGING
extern BOOL LYHaveCmdScript NOPARAMS;
extern int LYReadCmdKey PARAMS((int mode));
extern void LYCloseCmdLogfile NOPARAMS;
extern void LYOpenCmdLogfile PARAMS((int argc, char **argv));
extern void LYOpenCmdScript NOPARAMS;
extern void LYWriteCmdKey PARAMS((int ch));
#else
#define LYHaveCmdScript() FALSE
#define LYReadCmdKey(mode) LYgetch_for(mode)
#define LYCloseCmdLogfile() /* nothing */
#endif

#ifdef EXP_FILE_UPLOAD
extern void base64_encode PARAMS((char * dest, char * src, int len));
#endif

a87 4
/* The following are lynxkeycodes, not to be confused with
   lynxactioncodes (LYK_*) to which they are often mapped.
   The lynxkeycodes include all single-byte keys as a subset. - kw
*/
d104 2
a105 2
#define MOUSE_KEY	285	/* 0x11D */
/*  ***** NOTES: *****
a111 21
    - See also table named_keys[] in LYKeymap.c for 'pretty' strings
      for the keys with codes >= 256 (to appear on the 'K'eymap page).
      New keycodes should probably be assigned consecutively, so their
      key names can be easily added to named_keys[] (but see next point).
      They should also be documented in lynx.cfg.
    - The DOS port uses its own native codes for some keys, unless
      they are remapped by the code in LYgetch().  See *.key files
      in docs/ directory.  Adding new keys here may conflict with
      those codes (affecting DOS users), unless/until remapping is
      added or changed in LYgetch().
      (N)curses keypad codes (KEY_* from curses.h) can also directly
      appear as lynxkeycodes and conflict with our assignments, although
      that shouldn't happen - the useful ones should be recognized in
      LYgetch().
    - The actual recognition of raw input keys or escape sequences, and
      mapping to our lynxkeycodes, take place in LYgetch() and/or its
      subsidiary functions and/or the curses/slang/etc. libraries.
    The basic lynxkeycodes can appear combined with various flags in
    higher-order bits as extended lynxkeycodes; see macros in LYKeymap.h.
    The range of possible basic values is therefore limited, they have
    to be less than LKC_ISLKC (even if KEYMAP_SIZE is increased).
d114 4
a117 5
#  define FOR_PANEL	0	/* normal screen, also LYgetch default */
#  define FOR_CHOICE	1	/* mouse menu */
#  define FOR_INPUT	2	/* form input and textarea field */
#  define FOR_PROMPT	3	/* string prompt editing */
#  define FOR_SINGLEKEY	4	/* single key prompt, confirmation */
d121 2
a122 6

#ifdef EXP_ALT_BINDINGS
/*  Enable code implementing additional, mostly emacs-like, line-editing
    functions. - kw */
#define ENHANCED_LINEEDIT
#endif
a141 5
        int  current_modifiers; /* Modifiers for next input lynxkeycode */
#ifdef ENHANCED_LINEEDIT
	int  mark;	/* position of emacs-like mark, or -1-pos to denote
				unactive mark.  */
#endif
d149 31
a179 58
typedef enum {
    LYE_NOP = 0			/* Do Nothing		 */
    ,LYE_CHAR			/* Insert printable char */
    ,LYE_ENTER			/* Input complete, return char/lynxkeycode */
    ,LYE_TAB			/* Input complete, return TAB  */
    ,LYE_STOP			/* Input complete, deactivate  */
    ,LYE_ABORT			/* Input cancelled	 */

    ,LYE_FORM_PASS		/* In form fields: input complete,
				   return char / lynxkeycode;
				   Elsewhere: Do Nothing */

    ,LYE_DELN			/* Delete next/curr char */
    ,LYE_DELC			/* Obsolete (DELC case was equiv to DELN) */
    ,LYE_DELP			/* Delete prev	    char */
    ,LYE_DELNW			/* Delete next word	 */
    ,LYE_DELPW			/* Delete prev word	 */

    ,LYE_ERASE			/* Erase the line	 */

    ,LYE_BOL			/* Go to begin of line	 */
    ,LYE_EOL			/* Go to end   of line	 */
    ,LYE_FORW			/* Cursor forwards	 */
    ,LYE_FORW_RL		/* Cursor forwards or right link */
    ,LYE_BACK			/* Cursor backwards	 */
    ,LYE_BACK_LL		/* Cursor backwards or left link */
    ,LYE_FORWW			/* Word forward		 */
    ,LYE_BACKW			/* Word back		 */

    ,LYE_LOWER			/* Lower case the line	 */
    ,LYE_UPPER			/* Upper case the line	 */

    ,LYE_LKCMD			/* Invoke command prompt */

    ,LYE_AIX			/* Hex 97		 */

    ,LYE_DELBL			/* Delete back to BOL	 */
    ,LYE_DELEL			/* Delete thru EOL	 */

    ,LYE_SWMAP			/* Switch input keymap	 */

    ,LYE_TPOS			/* Transpose characters	 */

    ,LYE_SETM1			/* Set modifier 1 flag	 */
    ,LYE_SETM2			/* Set modifier 2 flag	 */
    ,LYE_UNMOD			/* Fall back to no-modifier command */

    ,LYE_C1CHAR			/* Insert C1 char if printable */

    ,LYE_SETMARK		/* emacs-like set-mark-command */
    ,LYE_XPMARK			/* emacs-like exchange-point-and-mark */
    ,LYE_KILLREG		/* emacs-like kill-region */
    ,LYE_YANK			/* emacs-like yank */
#ifdef CAN_CUT_AND_PASTE
    ,LYE_PASTE			/* ClipBoard to Lynx	   */
#endif
} LYEditCodes;
/* All preceding values must be within 0x00..0x7f - kw */
d181 2
a182 5
/*  The following are meant to be bitwise or-ed:  */
#define LYE_DF       0x80       /* Flag to set modifier 3 AND do other
				   action */
#define LYE_FORM_LAC 0x1000     /* Flag to pass lynxactioncode given by
				   lower bits.  Doesn't fit in a char! */
d184 1
a187 1
extern int map_string_to_keysym PARAMS((CONST char * src, int *lec));
a189 3
extern char *LYElideString PARAMS((
	char *		str,
	int		cut_pos));
d221 1
a221 7
extern int EditBinding PARAMS((int ch));		   /* in LYEditmap.c */
extern BOOL LYRemapEditBinding PARAMS((
	int		xlkc,
	int		lec,
	int 		select_edi));			   /* in LYEditmap.c */
extern int LYKeyForEditAction PARAMS((int lec));	   /* in LYEditmap.c */
extern int LYEditKeyForAction PARAMS((int lac, int *pmodkey));/* LYEditmap.c */
d227 2
a228 13
extern void LYCloseCloset PARAMS((RecallType recall));
extern int LYhandlePopupList PARAMS((
	int		cur_choice,
	int		ly,
	int		lx,
	CONST char **	choices,
	int		width,
	int		i_length,
	int		disabled,
	BOOLEAN		for_mouse,
	BOOLEAN		numbered));

typedef unsigned char LYEditCode;
d232 1
a232 2
extern LYEditCode * LYLineEditors[];
extern CONST char * LYLineeditHelpURLs[];
d234 7
a240 5
extern CONST char * LYLineeditHelpURL NOPARAMS;

extern int escape_bound;

#define LYLineEdit(e,c,m) LYEdit1(e,c,EditBinding(c)&~LYE_DF,m)
a243 2

int LYEditInsert PARAMS((EditFieldData *edit, unsigned char *s,	int len, int map_active, BOOL maxMessage));
@

