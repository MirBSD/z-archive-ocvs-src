head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.45.59;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.16.58;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.35;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.35;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.32;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.24;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.02;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.19;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.59;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.52.38;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@#include <HTUtils.h>
#include <HTParse.h>
#include <LYGlobalDefs.h>
#include <HTAlert.h>
#include <LYCurses.h>
#include <LYSignal.h>
#include <LYUtils.h>
#include <LYClean.h>
#include <LYStrings.h>
#include <GridText.h>
#include <LYMail.h>
#include <LYEdit.h>
#include <LYCharSets.h>		/* to get current charset for mail header */

#include <LYLeaks.h>

#define MAX_SUBJECT 70

BOOLEAN term_letter;		/* Global variable for async i/o. */

static void terminate_letter(int sig GCC_UNUSED)
{
    term_letter = TRUE;
    /* Reassert the AST */
    signal(SIGINT, terminate_letter);
#if USE_VMS_MAILER || defined(PDCURSES)
    /*
     * Refresh the screen to get rid of the "interrupt" message.
     */
    if (!dump_output_immediately) {
	lynx_force_repaint();
	LYrefresh();
    }
#endif /* VMS */
}

/* HTUnEscape with control-code nuking */
static void SafeHTUnEscape(char *string)
{
    int i;
    int flg = FALSE;

    HTUnEscape(string);
    for (i = 0; string[i] != '\0'; i++) {
	/* FIXME: this is no longer explicitly 7-bit ASCII,
	   but are there portability problems? */
	if ((!LYIsASCII(string[i])) || !isprint(UCH(string[i]))) {
	    string[i] = '?';
	    flg = TRUE;
	}
    }
    if (flg)
	HTAlert(MAILTO_SQUASH_CTL);
}

static void remove_tildes(char *string)
{
    /*
     * Change the first character to a space if it is a '~'.
     */
    if (*string == '~')
	*string = ' ';
}

static void comma_append(char **dst,
			 char *src)
{
    if (*src) {
	while (*src == ',' || isspace(UCH(*src)))
	    src++;
	if (*src) {
	    if (isEmpty(*dst)) {
		StrAllocCopy(*dst, src);
	    } else {
		StrAllocCat(*dst, ",");
		StrAllocCat(*dst, src);
	    }
	}
    }
}

static void extract_field(char **dst,
			  char *src,
			  const char *keyword)
{
    int len = strlen(keyword);
    char *cp, *cp1;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len)) {
	    cp += len;
	    if ((cp1 = strchr(cp, '&')) != NULL) {
		*cp1 = '\0';
	    }
	    comma_append(dst, cp);
	    if (cp1) {
		*cp1 = '&';
		cp = cp1;
		cp1 = NULL;
	    } else {
		break;
	    }
	}
	cp++;
    }
    CTRACE((tfp, "extract_field(%s) = '%s'\n", keyword, NONNULL(*dst)));
}

/*
 * Seek and handle a subject=foo.  - FM
 */
static void extract_subject(char *dst,
			    char *src)
{
    const char *keyword = "subject=";
    int len = strlen(keyword);
    char *cp, *cp1;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len))
	    break;
	cp++;
    }
    if (*cp) {
	cp += len;
	if ((cp1 = strchr(cp, '&')) != NULL) {
	    *cp1 = '\0';
	}
	if (*cp) {
	    strncpy(dst, cp, MAX_SUBJECT);
	    dst[MAX_SUBJECT] = '\0';
	    SafeHTUnEscape(dst);
	}
	if (cp1) {
	    *cp1 = '&';
	    cp1 = NULL;
	}
    }
    CTRACE((tfp, "extract_subject(%s) = '%s'\n", keyword, NONNULL(dst)));
}

/*
 * Seek and handle body=foo fields.  - FM
 */
static void extract_body(char **dst,
			 char *src)
{
    const char *keyword = "body=";
    int len = strlen(keyword);
    int i;
    char *cp, *cp0, *cp1, *temp = 0;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len)) {
	    cp += len;
	    if ((cp1 = strchr(cp, '&')) != NULL) {
		*cp1 = '\0';
	    }
	    if (*cp) {
		/*
		 * Break up the value into lines with a maximum length of 78. 
		 * - FM
		 */
		StrAllocCopy(temp, cp);
		HTUnEscape(temp);
		cp0 = temp;
		while ((cp = strchr(cp0, '\n')) != NULL) {
		    *cp = '\0';
		    if (cp > cp0) {
			if (*(cp - 1) == '\r') {
			    *(cp - 1) = '\0';
			}
		    }
		    i = 0;
		    len = strlen(cp0);
		    while (len > 78) {
			HTSprintf(dst, "%.78s\n", &cp0[i]);
			i += 78;
			len = strlen(&cp0[i]);
		    }
		    HTSprintf(dst, "%s\n", &cp0[i]);
		    cp0 = (cp + 1);
		}
		i = 0;
		len = strlen(cp0);
		while (len > 78) {
		    HTSprintf(dst, "%.78s\n", &cp0[i]);
		    i += 78;
		    len = strlen(&cp0[i]);
		}
		if (len) {
		    HTSprintf(dst, "%s\n", &cp0[i]);
		}
		FREE(temp);
	    }
	    if (cp1) {
		*cp1 = '&';
		cp = cp1;
		cp1 = NULL;
	    } else {
		break;
	    }
	}
	cp++;
    }
    CTRACE((tfp, "extract_body(%s) = '%s'\n", keyword, NONNULL(*dst)));
}

/*
 * Convert any Explorer semi-colon Internet address separators to commas - FM
 */
static BOOLEAN trim_comma(char *address)
{
    if (address[(strlen(address) - 1)] == ',')
	address[(strlen(address) - 1)] = '\0';
    return (BOOL) (*address == '\0');
}

/*
 * Convert any Explorer semi-colon Internet address separators to commas - FM
 */
static BOOLEAN convert_explorer(char *address)
{
    char *cp = address;
    char *cp0;
    char *cp1;

    while ((cp1 = strchr(cp, '@@')) != NULL) {
	cp1++;
	if ((cp0 = strchr(cp1, ';')) != NULL) {
	    *cp0 = ',';
	    cp1 = cp0 + 1;
	}
	cp = cp1;
    }
    return trim_comma(address);
}

/*
 * reply_by_mail() prompts line-by-line for header information, allowing
 * scrolling of the screen.
 */
static int header_prompt(const char *label,
			 char **result,
			 unsigned limit)
{
    char buffer[LINESIZE];
    int ok;

    if (*result != 0) {
	LYaddstr(CTRL_U_TO_ERASE);
	LYstrncpy(buffer, *result, sizeof(buffer) - 1);
    } else
	*buffer = 0;

    if (limit > sizeof(buffer))
	limit = sizeof(buffer);

    LYaddstr(gettext(label));
    LYaddstr(": ");
    ok = (LYgetstr(buffer, VISIBLE, limit, NORECALL) >= 0
	  && !term_letter);
    LYaddstr("\n");

    if (ok) {
	remove_tildes(buffer);
	StrAllocCopy(*result, buffer);
    }
    term_letter = FALSE;
    return ok;
}

static void show_addresses(char *addresses)
{
    char *cp = addresses;
    char *cp1;

    while ((cp1 = strchr(cp, ',')) != NULL) {
	*cp1 = '\0';
	while (*cp == ' ')
	    cp++;
	if (*cp) {
	    LYaddstr(cp);
	    LYaddstr(",\n  ");
	}
	*cp1 = ',';
	cp = (cp1 + 1);
    }
    if (*cp) {
	LYaddstr(cp);
    }
}

#if USE_BLAT_MAILER

/*
syntax:
Blat <filename> -t <recipient> [optional switches (see below)]

<filename>    : file with the message body
-t <recipient>: recipient list (comma separated)
-s <subj>     : subject line
-f <sender>   : overrides the default sender address (must be known to server)
-i <addr>     : a 'From:' address, not necessarily known to the SMTP server.
-c <recipient>: carbon copy recipient list (comma separated)
-b <recipient>: blind carbon copy recipient list (comma separated)
-h            : displays this help.
-mime         : MIME Quoted-Printable Content-Transfer-Encoding.
-q            : supresses *all* output.
-server <addr>: overrides the default SMTP server to be used.

*/

static char *blat_cmd(char *mail_cmd,
		      char *filename,
		      char *address,
		      char *subject,
		      char *ccaddr,
		      char *mail_addr)
{
    static char *b_cmd;

#ifdef USE_ALT_BLAT_MAILER

    HTSprintf0(&b_cmd, "%s %s -t \"%s\" -s \"%s\" %s%s%s%s",
	       mail_cmd,
	       filename,
	       address,
	       subject,
	       system_mail_flags,
	       ccaddr ? " -c \"" : "",
	       NonNull(ccaddr),
	       ccaddr ? "\"" : "");

#else /* !USE_ALT_BLAT_MAILER */

    static char bl_cmd_file[512];
    FILE *fp;

#ifdef __CYGWIN__
    char dosname[LY_MAXPATH];
#endif

    bl_cmd_file[0] = '\0';
    if ((fp = LYOpenTemp(bl_cmd_file, ".blt", "w")) == NULL) {
	HTAlert(FORM_MAILTO_FAILED);
	return NULL;
    }
#ifdef __CYGWIN__
    cygwin_conv_to_full_win32_path(filename, dosname);
    fprintf(fp, "%s\n", dosname);
#else
    fprintf(fp, "%s\n", filename);
#endif
    fprintf(fp, "-t\n%s\n", address);
    if (subject)
	fprintf(fp, "-s\n%s\n", subject);
    if (!isEmpty(mail_addr)) {
	fprintf(fp, "-f\n%s\n", mail_addr);
    }
    if (!isEmpty(ccaddr)) {
	fprintf(fp, "-c\n%s\n", ccaddr);
    }
    LYCloseOutput(fp);

#ifdef __CYGWIN__
    cygwin_conv_to_full_win32_path(bl_cmd_file, dosname);
    HTSprintf0(&b_cmd, "%s \"@@%s\"", mail_cmd, dosname);
#else
    HTSprintf0(&b_cmd, "%s @@%s", mail_cmd, bl_cmd_file);
#endif

#endif /* USE_ALT_BLAT_MAILER */

    return b_cmd;
}

#endif /* USE_BLAT_MAILER */

#if USE_VMS_MAILER
BOOLEAN LYMailPMDF(void)
{
    return (system_mail != 0)
	? !strncasecomp(system_mail, "PMDF SEND", 9)
	: FALSE;
}

/*
 * Add all of the people in the address field to the command
 */
static void vms_append_addrs(char **cmd, char *address, char *option)
{
    BOOLEAN first = TRUE;
    char *cp;
    char *address_ptr1;
    char *address_ptr2;

    address_ptr1 = address;
    do {
	if ((cp = strchr(address_ptr1, ',')) != NULL) {
	    address_ptr2 = (cp + 1);
	    *cp = '\0';
	} else {
	    address_ptr2 = NULL;
	}

	/*
	 * 4 letters is arbitrarily the smallest possible mail address, at
	 * least for lynx.  That way extra spaces won't confuse the mailer and
	 * give a blank address.
	 */
	if (strlen(address_ptr1) > 3) {
	    if (!first) {
		StrAllocCat(*cmd, ",");
	    }
	    HTSprintf(cmd, mail_adrs, address_ptr1);
	    if (*option && LYMailPMDF())
		StrAllocCat(*cmd, option);
	    first = FALSE;
	}
	address_ptr1 = address_ptr2;
    } while (address_ptr1 != NULL);
}

static void remove_quotes(char *string)
{
    while (*string != 0) {
	if (strchr("\"&|", *string) != 0)
	    *string = ' ';
	string++;
    }
}
#else
#if CAN_PIPE_TO_MAILER

/*
 * Open a pipe to the mailer
 */
FILE *LYPipeToMailer(void)
{
    char *buffer = NULL;
    FILE *fp = NULL;

    if (LYSystemMail()) {
	HTSprintf0(&buffer, "%s %s", system_mail, system_mail_flags);
	fp = popen(buffer, "w");
	CTRACE((tfp, "popen(%s) %s\n", buffer, fp != 0 ? "OK" : "FAIL"));
	FREE(buffer);
    }
    return fp;
}
#else /* DOS, Win32, etc. */

int LYSendMailFile(char *the_address,
		   char *the_filename,
		   char *the_subject GCC_UNUSED,
		   char *the_ccaddr GCC_UNUSED,
		   char *message)
{
    char *cmd = NULL;

#ifdef __DJGPP__
    char *shell;
#endif /* __DJGPP__ */
    int code;

    if (!LYSystemMail())
	return 0;

#if USE_BLAT_MAILER
    if (mail_is_blat)
	StrAllocCopy(cmd,
		     blat_cmd(system_mail,
			      the_filename,
			      the_address,
			      the_subject,
			      the_ccaddr,
			      personal_mail_address
		     )
	    );
    else
#endif
#ifdef __DJGPP__
    if ((shell = LYGetEnv("SHELL")) != NULL) {
	if (strstr(shell, "sh") != NULL) {
	    HTSprintf0(&cmd, "%s -c %s -t \"%s\" -F %s",
		       shell,
		       system_mail,
		       the_address,
		       the_filename);
	} else {
	    HTSprintf0(&cmd, "%s /c %s -t \"%s\" -F %s",
		       shell,
		       system_mail,
		       the_address,
		       the_filename);
	}
    } else {
	HTSprintf0(&cmd, "%s -t \"%s\" -F %s",
		   system_mail,
		   the_address,
		   the_filename);
    }
#else
	HTSprintf0(&cmd, "%s -t \"%s\" -F %s",
		   system_mail,
		   the_address,
		   the_filename);
#endif /* __DJGPP__ */

    stop_curses();
    SetOutputMode(O_TEXT);
    printf("%s\n\n$ %s\n\n%s",
	   *message ? message : gettext("Sending"),
	   cmd, PLEASE_WAIT);
    code = LYSystem(cmd);
    LYSleepMsg();
    start_curses();
    SetOutputMode(O_BINARY);

    FREE(cmd);

    return code;
}
#endif /* CAN_PIPE_TO_FILE */
#endif /* USE_VMS_MAILER */

/*
 *  mailform() sends form content to the mailto address(es). - FM
 */
void mailform(const char *mailto_address,
	      const char *mailto_subject,
	      const char *mailto_content,
	      const char *mailto_type)
{
    FILE *fd;
    char *address = NULL;
    char *ccaddr = NULL;
    char *keywords = NULL;
    char *cp = NULL;
    char self[MAX_SUBJECT + 10];
    char subject[MAX_SUBJECT + 10];
    char *searchpart = NULL;
    char buf[512];
    int ch, len, i;

#if USE_VMS_MAILER
    static char *cmd;
    char *command = NULL;
    BOOLEAN isPMDF = LYMailPMDF();
    char hdrfile[LY_MAXPATH];
#endif
#if !CAN_PIPE_TO_MAILER
    char my_tmpfile[LY_MAXPATH];
#endif

    CTRACE((tfp, "mailto_address: \"%s\"\n", NONNULL(mailto_address)));
    CTRACE((tfp, "mailto_subject: \"%s\"\n", NONNULL(mailto_subject)));
    CTRACE((tfp, "mailto_content: \"%s\"\n", NONNULL(mailto_content)));
    CTRACE((tfp, "mailto_type:    \"%s\"\n", NONNULL(mailto_type)));

    if (!LYSystemMail())
	return;

    if (!mailto_address || !mailto_content) {
	HTAlert(BAD_FORM_MAILTO);
	return;
    }
    subject[0] = '\0';
    self[0] = '\0';

    if ((cp = (char *) strchr(mailto_address, '\n')) != NULL)
	*cp = '\0';
    StrAllocCopy(address, mailto_address);

    /*
     * Check for a ?searchpart.  - FM
     */
    if ((cp = strchr(address, '?')) != NULL) {
	StrAllocCopy(searchpart, cp);
	*cp = '\0';
	cp = (searchpart + 1);
	if (*cp != '\0') {
	    /*
	     * Seek and handle a subject=foo.  - FM
	     */
	    extract_subject(subject, searchpart);

	    /*
	     * Seek and handle to=address(es) fields.  Appends to address.  -
	     * FM
	     */
	    extract_field(&address, searchpart, "to=");

	    /*
	     * Seek and handle cc=address(es) fields.  Excludes Bcc=address(es)
	     * as unsafe.  We may append our own cc (below) as a list for the
	     * actual mailing.  - FM
	     */
	    extract_field(&ccaddr, searchpart, "cc=");

	    /*
	     * Seek and handle keywords=term(s) fields.  - FM
	     */
	    extract_field(&keywords, searchpart, "keywords=");

	    if (keywords != NULL) {
		if (*keywords != '\0') {
		    SafeHTUnEscape(keywords);
		} else {
		    FREE(keywords);
		}
	    }

	    FREE(searchpart);
	}
    }

    if (convert_explorer(address)) {
	HTAlert(BAD_FORM_MAILTO);
	goto cleanup;
    }
    if (ccaddr != NULL) {
	if (convert_explorer(ccaddr)) {
	    FREE(ccaddr);
	}
    }

    /*
     * Unescape the address and ccaddr fields.  - FM
     */
    SafeHTUnEscape(address);
    if (ccaddr != NULL) {
	SafeHTUnEscape(ccaddr);
    }

    /*
     * Allow user to edit the default Subject - FM
     */
    if (isEmpty(subject)) {
	if (!isEmpty(mailto_subject)) {
	    LYstrncpy(subject, mailto_subject, MAX_SUBJECT);
	} else {
	    sprintf(subject, "mailto:%.63s", address);
	}
    }
    _statusline(SUBJECT_PROMPT);
    if ((ch = LYgetstr(subject, VISIBLE, MAX_SUBJECT, NORECALL)) < 0) {
	/*
	 * User cancelled via ^G. - FM
	 */
	HTInfoMsg(FORM_MAILTO_CANCELLED);
	goto cleanup;
    }

    /*
     * Allow user to specify a self copy via a CC:  entry, if permitted.  - FM
     */
    if (!LYNoCc) {
	sprintf(self, "%.*s", MAX_SUBJECT,
		isEmpty(personal_mail_address) ? "" : personal_mail_address);
	_statusline("Cc: ");
	if ((ch = LYgetstr(self, VISIBLE, MAX_SUBJECT, NORECALL)) < 0) {
	    /*
	     * User cancelled via ^G. - FM
	     */
	    HTInfoMsg(FORM_MAILTO_CANCELLED);
	    goto cleanup;
	}
	remove_tildes(self);
	if (ccaddr == NULL) {
	    StrAllocCopy(ccaddr, self);
	} else {
	    StrAllocCat(ccaddr, ",");
	    StrAllocCat(ccaddr, self);
	}
    }
#if CAN_PIPE_TO_MAILER
    if ((fd = LYPipeToMailer()) == 0) {
	HTAlert(FORM_MAILTO_FAILED);
	goto cleanup;
    }

    if (!isEmpty(mailto_type)) {
	fprintf(fd, "Mime-Version: 1.0\n");
	fprintf(fd, "Content-Type: %s\n", mailto_type);
    }
    fprintf(fd, "To: %s\n", address);
    if (!isEmpty(personal_mail_address))
	fprintf(fd, "From: %s\n", personal_mail_address);
    if (!isEmpty(ccaddr))
	fprintf(fd, "Cc: %s\n", ccaddr);
    fprintf(fd, "Subject: %s\n\n", subject);
    if (!isEmpty(keywords))
	fprintf(fd, "Keywords: %s\n", keywords);
    _statusline(SENDING_FORM_CONTENT);
#else /* e.g., VMS, DOS */
    if ((fd = LYOpenTemp(my_tmpfile, ".txt", "w")) == NULL) {
	HTAlert(FORM_MAILTO_FAILED);
	goto cleanup;
    }
#if USE_VMS_MAILER
    if (isPMDF) {
	FILE *hfd;

	if ((hfd = LYOpenTemp(hdrfile, ".txt", "w")) == NULL) {
	    HTAlert(FORM_MAILTO_FAILED);
	    LYCloseTempFP(fd);
	    goto cleanup;
	}
	if (!isEmpty(mailto_type)) {
	    fprintf(hfd, "Mime-Version: 1.0\n");
	    fprintf(hfd, "Content-Type: %s\n", mailto_type);
	    if (!isEmpty(personal_mail_address))
		fprintf(hfd, "From: %s\n", personal_mail_address);
	}
	/*
	 * For PMDF, put any keywords and the subject in the header file and
	 * close it.  - FM
	 */
	if (!isEmpty(keywords)) {
	    fprintf(hfd, "Keywords: %s\n", keywords);
	}
	fprintf(hfd, "Subject: %s\n\n", subject);
	LYCloseTempFP(hfd);
    } else if (mailto_type &&
	       !strncasecomp(mailto_type, "multipart/form-data", 19)) {
	/*
	 * Ugh!  There's no good way to include headers while we're still using
	 * "generic" VMS MAIL, so we'll put this in the body of the message.  -
	 * FM
	 */
	fprintf(fd, "X-Content-Type: %s\n\n", mailto_type);
    }
#else /* !VMS (DOS) */
#if USE_BLAT_MAILER
    if (mail_is_blat) {
	if (strlen(subject) > MAX_SUBJECT)
	    subject[MAX_SUBJECT] = '\0';
    } else
#endif
    {
	if (!isEmpty(mailto_type)) {
	    fprintf(fd, "Mime-Version: 1.0\n");
	    fprintf(fd, "Content-Type: %s\n", mailto_type);
	}
	fprintf(fd, "To: %s\n", address);
	if (!isEmpty(personal_mail_address))
	    fprintf(fd, "From: %s\n", personal_mail_address);
	fprintf(fd, "Subject: %.70s\n\n", subject);
    }
#endif /* VMS */
#endif /* CAN_PIPE_TO_MAILER */

    /*
     * Break up the content into lines with a maximum length of 78.  If the
     * ENCTYPE was text/plain, we have physical newlines and should take them
     * into account.  Otherwise, the actual newline characters in the content
     * are hex escaped.  - FM
     */
    while ((cp = strchr(mailto_content, '\n')) != NULL) {
	*cp = '\0';
	i = 0;
	len = strlen(mailto_content);
	while (len > 78) {
	    strncpy(buf, &mailto_content[i], 78);
	    buf[78] = '\0';
	    fprintf(fd, "%s\n", buf);
	    i += 78;
	    len = strlen(&mailto_content[i]);
	}
	fprintf(fd, "%s\n", &mailto_content[i]);
	mailto_content = (cp + 1);
    }
    i = 0;
    len = strlen(mailto_content);
    while (len > 78) {
	strncpy(buf, &mailto_content[i], 78);
	buf[78] = '\0';
	fprintf(fd, "%s\n", buf);
	i += 78;
	len = strlen(&mailto_content[i]);
    }
    if (len)
	fprintf(fd, "%s\n", &mailto_content[i]);

#if CAN_PIPE_TO_MAILER
    pclose(fd);
    LYSleepMsg();
#else
    LYCloseTempFP(fd);
#if USE_VMS_MAILER
    /*
     * Set the mail command.  - FM
     */
    if (isPMDF) {
	/*
	 * Now set up the command.  - FM
	 */
	HTSprintf0(&cmd,
		   "%s %s %s,%s ",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_tmpfile);
    } else {
	/*
	 * For "generic" VMS MAIL, include the subject in the command, and
	 * ignore any keywords to minimize risk of them making the line too
	 * long or having problem characters.  - FM
	 */
	HTSprintf0(&cmd,
		   "%s %s%s/subject=\"%s\" %s ",
		   system_mail,
		   system_mail_flags,
		   (strncasecomp(system_mail, "MAIL", 4) ? "" : "/noself"),
		   subject,
		   my_tmpfile);
    }
    StrAllocCopy(command, cmd);

    vms_append_addrs(&command, address, "");
    if (!isEmpty(ccaddr)) {
	vms_append_addrs(&command, ccaddr, "/CC");
    }

    stop_curses();
    printf("%s\n\n$ %s\n\n%s", SENDING_FORM_CONTENT, command, PLEASE_WAIT);
    LYSystem(command);		/* Mail (VMS) */
    FREE(command);
    LYSleepAlert();
    start_curses();
    LYRemoveTemp(my_tmpfile);
    if (isPMDF)
	LYRemoveTemp(hdrfile);
#else /* DOS */
    LYSendMailFile(address,
		   my_tmpfile,
		   subject,
		   ccaddr,
		   SENDING_FORM_CONTENT);
    LYRemoveTemp(my_tmpfile);
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */

  cleanup:
    FREE(address);
    FREE(ccaddr);
    FREE(keywords);
    return;
}

/*
 *  mailmsg() sends a message to the owner of the file, if one is defined,
 *  telling of errors (i.e., link not available).
 */
void mailmsg(int cur,
	     char *owner_address,
	     char *filename,
	     char *linkname)
{
    FILE *fd, *fp;
    char *address = NULL;
    char *searchpart = NULL;
    char *cmd = NULL, *cp;

#ifdef ALERTMAIL
    BOOLEAN skip_parsing = FALSE;
#endif
#if !CAN_PIPE_TO_MAILER
    char *ccaddr;
    char subject[128];
    char my_tmpfile[LY_MAXPATH];
#endif
#if USE_VMS_MAILER
    BOOLEAN isPMDF = LYMailPMDF();
    char hdrfile[LY_MAXPATH];
    char *command = NULL;

    CTRACE((tfp, "mailmsg(%d, \"%s\", \"%s\", \"%s\")\n", cur,
	    NONNULL(owner_address),
	    NONNULL(filename),
	    NONNULL(linkname)));

#endif /* VMS */

    if (!LYSystemMail())
	return;

#ifdef ALERTMAIL
    if (owner_address == NULL) {
	owner_address = ALERTMAIL;
	skip_parsing = TRUE;
    }
#endif

    if (isEmpty(owner_address))
	return;
    if ((cp = (char *) strchr(owner_address, '\n')) != NULL) {
#ifdef ALERTMAIL
	if (skip_parsing)
	    return;		/* invalidly defined - ignore - kw */
#else
	*cp = '\0';
#endif
    }
    if (!strncasecomp(owner_address, "lynx-dev@@", 9)) {
	/*
	 * Silently refuse sending bad link messages to lynx-dev.
	 */
	return;
    }
    StrAllocCopy(address, owner_address);

#ifdef ALERTMAIL
    /*
     * If we are using a fixed address given by ALERTMAIL, it is supposed to
     * already be in usable form, without URL-isms like ?-searchpart and
     * URL-escaping.  So skip some code.  - kw
     */
    if (!skip_parsing)
#endif
    {
	/*
	 * Check for a ?searchpart.  - FM
	 */
	if ((cp = strchr(address, '?')) != NULL) {
	    StrAllocCopy(searchpart, cp);
	    *cp = '\0';
	    cp = (searchpart + 1);
	    if (*cp != '\0') {
		/*
		 * Seek and handle to=address(es) fields.
		 * Appends to address.  We ignore any other
		 * headers in the ?searchpart.  - FM
		 */
		extract_field(&address, searchpart, "to=");
	    }
	}

	convert_explorer(address);

	/*
	 * Unescape the address field.  - FM
	 */
	SafeHTUnEscape(address);
    }

    if (trim_comma(address)) {
	FREE(address);
	CTRACE((tfp, "mailmsg: No address in '%s'.\n", owner_address));
	return;
    }
#if CAN_PIPE_TO_MAILER
    if ((fd = LYPipeToMailer()) == 0) {
	FREE(address);
	CTRACE((tfp, "mailmsg: '%s' failed.\n", cmd));
	return;
    }

    fprintf(fd, "To: %s\n", address);
    fprintf(fd, "Subject: Lynx Error in %s\n", filename);
    if (!isEmpty(personal_mail_address)) {
	fprintf(fd, "Cc: %s\n", personal_mail_address);
    }
    fprintf(fd, "X-URL: %s\n", filename);
    fprintf(fd, "X-Mailer: %s, Version %s\n\n", LYNX_NAME, LYNX_VERSION);
#else
    if ((fd = LYOpenTemp(my_tmpfile, ".txt", "w")) == NULL) {
	CTRACE((tfp, "mailmsg: Could not fopen '%s'.\n", my_tmpfile));
	FREE(address);
	return;
    }
    sprintf(subject, "Lynx Error in %.56s", filename);
    ccaddr = personal_mail_address;
#if USE_VMS_MAILER
    if (isPMDF) {
	FILE *hfd;

	if ((hfd = LYOpenTemp(hdrfile, ".txt", "w")) == NULL) {
	    CTRACE((tfp, "mailmsg: Could not fopen '%s'.\n", hdrfile));
	    FREE(address);
	    return;
	}

	if (!isEmpty(personal_mail_address)) {
	    fprintf(fd, "Cc: %s\n", personal_mail_address);
	}
	fprintf(fd, "X-URL: %s\n", filename);
	fprintf(fd, "X-Mailer: %s, Version %s\n\n", LYNX_NAME, LYNX_VERSION);
	/*
	 * For PMDF, put the subject in the header file and close it.  - FM
	 */
	fprintf(hfd, "Subject: Lynx Error in %.56s\n\n", filename);
	LYCloseTempFP(hfd);
    }
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */

    fprintf(fd, gettext("The link   %s :?: %s \n"),
	    links[cur].lname, links[cur].target);
    fprintf(fd, gettext("called \"%s\"\n"), LYGetHiliteStr(cur, 0));
    fprintf(fd, gettext("in the file \"%s\" called \"%s\"\n"), filename, linkname);
    fprintf(fd, "%s\n\n", gettext("was requested but was not available."));
    fprintf(fd, "%s\n\n", gettext("Thought you might want to know."));

    fprintf(fd, "%s\n", gettext("This message was automatically generated by"));
    fprintf(fd, "%s %s", LYNX_NAME, LYNX_VERSION);
    if ((LynxSigFile != NULL) &&
	(fp = fopen(LynxSigFile, TXT_R)) != NULL) {
	fputs("-- \n", fd);
	while (LYSafeGets(&cmd, fp) != NULL)
	    fputs(cmd, fd);
	LYCloseInput(fp);
    }
#if CAN_PIPE_TO_MAILER
    pclose(fd);
#else
    LYCloseTempFP(fd);
#if USE_VMS_MAILER
    if (isPMDF) {
	/*
	 * Now set up the command.  - FM
	 */
	HTSprintf0(&command,
		   "%s %s %s,%s ",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_tmpfile);
    } else {
	/*
	 * For "generic" VMS MAIL, include the subject in the command.  - FM
	 */
	HTSprintf0(&command,
		   "%s %s/self/subject=\"Lynx Error in %.56s\" %s ",
		   system_mail,
		   system_mail_flags,
		   filename,
		   my_tmpfile);
    }
    vms_append_addrs(&command, address, "");

    LYSystem(command);		/* VMS */
    FREE(command);
    FREE(cmd);
    LYRemoveTemp(my_tmpfile);
    if (isPMDF) {
	LYRemoveTemp(hdrfile);
    }
#else /* DOS */
    LYSendMailFile(address,
		   my_tmpfile,
		   subject,
		   ccaddr,
		   "");
    LYRemoveTemp(my_tmpfile);
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */

    if (traversal) {
	FILE *ofp;

	if ((ofp = LYAppendToTxtFile(TRAVERSE_ERRORS)) == NULL) {
	    if ((ofp = LYNewTxtFile(TRAVERSE_ERRORS)) == NULL) {
		perror(NOOPEN_TRAV_ERR_FILE);
		exit_immediately(EXIT_FAILURE);
	    }
	}

	fprintf(ofp, "%s\t%s \tin %s\n",
		links[cur].lname, links[cur].target, filename);
	LYCloseOutput(ofp);
    }

    FREE(address);
    return;
}

/*
 *  reply_by_mail() invokes sendmail on Unix or mail on VMS to send
 *  a comment from the users to the owner
 */
void reply_by_mail(char *mail_address,
		   char *filename,
		   const char *title,
		   const char *refid)
{
#ifndef NO_ANONYMOUS_EMAIL
    static char *personal_name = NULL;
#endif
    char user_input[LINESIZE];
    FILE *fd, *fp;
    const char *label = NULL;
    char *from_address = NULL;
    char *cc_address = NULL;
    char *to_address = NULL;
    char *the_subject = NULL;
    char *ccaddr = NULL;
    char *keywords = NULL;
    char *searchpart = NULL;
    char *body = NULL;
    char *cp = NULL, *cp1 = NULL;
    int i;
    int c = 0;			/* user input */
    char my_tmpfile[LY_MAXPATH];
    char default_subject[MAX_SUBJECT + 10];

#if USE_VMS_MAILER
    char *command = NULL;
    BOOLEAN isPMDF = LYMailPMDF();
    char hdrfile[LY_MAXPATH];
    FILE *hfd = 0;

#else
#if !CAN_PIPE_TO_MAILER
    char tmpfile2[LY_MAXPATH];
#endif
    char buf[4096];		/* 512 */
    char *header = NULL;
    int n;
#endif /* USE_VMS_MAILER */

    CTRACE((tfp, "reply_by_mail(\"%s\", \"%s\", \"%s\", \"%s\")\n",
	    NONNULL(mail_address),
	    NONNULL(filename),
	    NONNULL(title),
	    NONNULL(refid)));

    term_letter = FALSE;

    if (!LYSystemMail())
	return;

    if (isEmpty(mail_address)) {
	HTAlert(NO_ADDRESS_IN_MAILTO_URL);
	return;
    }
    StrAllocCopy(to_address, mail_address);

    if ((fd = LYOpenTemp(my_tmpfile, ".txt", "w")) == NULL) {
	HTAlert(MAILTO_URL_TEMPOPEN_FAILED);
	return;
    }
#if USE_VMS_MAILER
    if (isPMDF) {
	if ((hfd = LYOpenTemp(hdrfile, ".txt", "w")) == NULL) {
	    HTAlert(MAILTO_URL_TEMPOPEN_FAILED);
	    return;
	}
    }
#endif /* VMS */
    default_subject[0] = '\0';

    /*
     * Check for a ?searchpart.  - FM
     */
    if ((cp = strchr(to_address, '?')) != NULL) {
	StrAllocCopy(searchpart, cp);
	*cp = '\0';
	cp = (searchpart + 1);
	if (*cp != '\0') {
	    /*
	     * Seek and handle a subject=foo.  - FM
	     */
	    extract_subject(default_subject, searchpart);

	    /*
	     * Seek and handle to=address(es) fields.  Appends to address.  -
	     * FM
	     */
	    extract_field(&to_address, searchpart, "to=");

	    /*
	     * Seek and handle cc=address(es) fields.  Excludes Bcc=address(es)
	     * as unsafe.  We may append our own cc (below) as a list for the
	     * actual mailing.  - FM
	     */
	    extract_field(&ccaddr, searchpart, "cc=");

	    /*
	     * Seek and handle keywords=term(s) fields.  - FM
	     */
	    extract_field(&keywords, searchpart, "keywords=");

	    if (keywords != NULL) {
		if (*keywords != '\0') {
		    SafeHTUnEscape(keywords);
		} else {
		    FREE(keywords);
		}
	    }

	    /*
	     * Seek and handle body=foo fields.  - FM
	     */
	    extract_body(&body, searchpart);

	    FREE(searchpart);
	}
    }

    if (convert_explorer(to_address)) {
	HTAlert(NO_ADDRESS_IN_MAILTO_URL);
	goto cancelled;
    }
    if (ccaddr != NULL) {
	if (convert_explorer(ccaddr)) {
	    FREE(ccaddr);
	}
    }

    /*
     * Unescape the address and ccaddr fields.  - FM
     */
    SafeHTUnEscape(to_address);
    if (ccaddr != NULL) {
	SafeHTUnEscape(ccaddr);
    }

    /*
     * Set the default subject.  - FM
     */
    if (isEmpty(default_subject) && !isEmpty(title)) {
	strncpy(default_subject, title, MAX_SUBJECT);
	default_subject[MAX_SUBJECT] = '\0';
    }

    /*
     * Use ^G to cancel mailing of comment and don't let SIGINTs exit lynx.
     */
    signal(SIGINT, terminate_letter);

#if USE_VMS_MAILER
    if (isPMDF || !body) {
	/*
	 * Put the X-URL and X-Mailer lines in the hdrfile for PMDF or
	 * my_tmpfile for VMS MAIL.  - FM
	 */
	fprintf((isPMDF ? hfd : fd),
		"X-URL: %s%s\n",
		isEmpty(filename) ? STR_MAILTO_URL : filename,
		isEmpty(filename) ? to_address : "");
	fprintf((isPMDF ? hfd : fd),
		"X-Mailer: %s, Version %s\n", LYNX_NAME, LYNX_VERSION);
#ifdef NO_ANONYMOUS_EMAIL
	if (!isPMDF) {
	    fprintf(fd, "\n");
	}
#endif /* NO_ANONYMOUS_EMAIL */
    }
#else /* Unix/DOS/Windows */
    /*
     * Put the To:  line in the header.
     */
#ifndef DOSPATH
    HTSprintf(&header, "To: %s\n", to_address);
#endif

    /*
     * Put the Mime-Version, Content-Type and Content-Transfer-Encoding in the
     * header.  This assumes that the same character set is used for composing
     * the mail which is currently selected as display character set...  Don't
     * send a charset if we have a CJK character set selected, since it may not
     * be appropriate for mail...  Also don't use an unofficial "x-" charset. 
     * Also if the charset would be "us-ascii" (7-bit replacements selected,
     * don't send any MIME headers.  - kw
     */
    if (strncasecomp(LYCharSet_UC[current_char_set].MIMEname,
		     "us-ascii", 8) != 0) {
	StrAllocCat(header, "Mime-Version: 1.0\n");
	if (!LYHaveCJKCharacterSet &&
	    strncasecomp(LYCharSet_UC[current_char_set].MIMEname, "x-", 2)
	    != 0) {
	    HTSprintf(&header, "Content-Type: text/plain; charset=%s\n",
		      LYCharSet_UC[current_char_set].MIMEname);
	}
	StrAllocCat(header, "Content-Transfer-Encoding: 8bit\n");
    }
    /*
     * Put the X-URL and X-Mailer lines in the header.
     */
    if (!isEmpty(filename)) {
	HTSprintf(&header, "X-URL: %s\n", filename);
    } else {
	HTSprintf(&header, "X-URL: mailto:%s\n", to_address);
    }
    HTSprintf(&header, "X-Mailer: %s, Version %s\n", LYNX_NAME, LYNX_VERSION);

    if (!isEmpty(refid)) {
	HTSprintf(&header, "In-Reply-To: <%s>\n", refid);
    }
#endif /* VMS */

    /*
     * Clear the screen and inform the user.
     */
    LYclear();
    LYmove(2, 0);
    scrollok(LYwin, TRUE);	/* Enable scrolling. */
    if (body)
	LYaddstr(SENDING_MESSAGE_WITH_BODY_TO);
    else
	LYaddstr(SENDING_COMMENT_TO);
    show_addresses(to_address);
    if (
#if USE_VMS_MAILER
	   (isPMDF == TRUE) &&
#endif /* VMS */
	   (cp = ccaddr) != NULL) {
	if (strchr(cp, ',') != NULL) {
	    LYaddstr(WITH_COPIES_TO);
	} else {
	    LYaddstr(WITH_COPY_TO);
	}
	show_addresses(ccaddr);
    }
    LYaddstr(CTRL_G_TO_CANCEL_SEND);

#if USE_VMS_MAILER
    if (isPMDF || !body) {
#endif /* USE_VMS_MAILER */
#ifndef NO_ANONYMOUS_EMAIL
	/*
	 * Get the user's personal name.
	 */
	LYaddstr(ENTER_NAME_OR_BLANK);
#if USE_VMS_MAILER
	if (isPMDF) {
	    label = "Personal_name: ";
	} else {
	    label = "X-Personal_name: ";
	}
#else
	label = "X-Personal_Name: ";
#endif /* USE_VMS_MAILER */
	if (!header_prompt(label, &personal_name, LINESIZE)) {
	    goto cancelled;
	}
	if (*personal_name) {
#if USE_VMS_MAILER
	    fprintf((isPMDF ? hfd : fd), "%s: %s\n", label, personal_name);
#else
	    HTSprintf(&header, "%s: %s\n", label, personal_name);
#endif /* VMS */
	}

	/*
	 * Get the user's return address.
	 */
	LYaddstr(ENTER_MAIL_ADDRESS_OR_OTHER);
	LYaddstr(MEANS_TO_CONTACT_FOR_RESPONSE);
#if USE_VMS_MAILER
	if (isPMDF) {
	    label = "From";
	} else {
	    label = "X-From";
	}
#else
	label = "From";
#endif /* VMS */
	/* Add the personal mail address if there is one. */
	if (personal_mail_address)
	    StrAllocCopy(from_address, personal_mail_address);
	if (!header_prompt(label, &from_address, LINESIZE)) {
	    goto cancelled;
	}
#if USE_VMS_MAILER
	if (*from_address) {
	    fprintf(isPMDF ? hfd : fd, "%s: %s\n", label, from_address);
	}
	if (!isPMDF) {
	    fprintf(fd, "\n");
	}
#else
	HTSprintf(&header, "%s: %s\n", label, from_address);
#endif /* USE_VMS_MAILER */
#endif /* !NO_ANONYMOUS_EMAIL */
#if USE_VMS_MAILER
    }
#endif /* USE_VMS_MAILER */

    /*
     * Get the subject line.
     */
    LYaddstr(ENTER_SUBJECT_LINE);
    label = "Subject";
    if (*default_subject) {
	StrAllocCopy(the_subject, default_subject);
    } else if (!isEmpty(filename)) {
	HTSprintf(&the_subject, "%s", filename);
    } else {
	HTSprintf(&the_subject, "mailto:%s", to_address);
    }
    if (!header_prompt(label, &the_subject, MAX_SUBJECT)) {
	goto cancelled;
    }

    /*
     * Offer a CC line, if permitted.  - FM
     */
    if (!LYNoCc) {
	LYaddstr(ENTER_ADDRESS_FOR_CC);
	LYaddstr(BLANK_FOR_NO_COPY);
	if (personal_mail_address)
	    StrAllocCopy(cc_address, personal_mail_address);
	if (!header_prompt("Cc", &cc_address, LINESIZE)) {
	    goto cancelled;
	}
	comma_append(&ccaddr, cc_address);
    }
#if !USE_VMS_MAILER
    HTSprintf(&header, "%s: %s\n", label, the_subject);
#if !CAN_PIPE_TO_MAILER
    if (*to_address) {
	HTSprintf(&header, "To: %s\n", to_address);
    }
#endif

    /*
     * Add the Cc:  header.  - FM
     */
    if (!isEmpty(ccaddr)) {
	HTSprintf(&header, "Cc: %s\n", ccaddr);
    }

    /*
     * Add the Keywords:  header.  - FM
     */
    if (!isEmpty(keywords)) {
	HTSprintf(&header, "Keywords: %s\n", keywords);
    }

    /*
     * Terminate the header.
     */
    StrAllocCat(header, "\n");
    CTRACE((tfp, "**header==\n%s", header));
#endif /* !VMS */

    if (!no_editor && !isEmpty(editor)) {

	if (body) {
	    cp1 = body;
	    while ((cp = strchr(cp1, '\n')) != NULL) {
		*cp++ = '\0';
		fprintf(fd, "%s\n", cp1);
		cp1 = cp;
	    }
	} else if (strcmp(HTLoadedDocumentURL(), "")) {
	    /*
	     * Ask if the user wants to include the original message.
	     */
	    BOOLEAN is_preparsed = (BOOL) (LYPreparsedSource &&
					   HTisDocumentSource());

	    if (HTConfirm(is_preparsed
			  ? INC_PREPARSED_MSG_PROMPT
			  : INC_ORIG_MSG_PROMPT) == YES) {
		print_wwwfile_to_fd(fd, TRUE, (BOOL) !is_preparsed);
	    }
	}
	LYCloseTempFP(fd);	/* Close the tmpfile. */
	scrollok(LYwin, FALSE);	/* Stop scrolling.    */

	if (term_letter || LYCharIsINTERRUPT(c))
	    goto cleanup;

	/*
	 * Spawn the users editor on the mail file
	 */
	edit_temporary_file(my_tmpfile, "", SPAWNING_EDITOR_FOR_MAIL);

    } else if (body) {
	/*
	 * Let user review the body.  - FM
	 */
	LYclear();
	LYmove(0, 0);
	LYaddstr(REVIEW_MESSAGE_BODY);
	LYrefresh();
	cp1 = body;
	i = (LYlines - 5);
	while ((cp = strchr(cp1, '\n')) != NULL) {
	    if (i <= 0) {
		LYaddstr(RETURN_TO_CONTINUE);
		LYrefresh();
		c = LYgetch();
		LYaddstr("\n");
		if (term_letter || LYCharIsINTERRUPT(c)) {
		    goto cancelled;
		}
		i = (LYlines - 2);
	    }
	    *cp++ = '\0';
	    fprintf(fd, "%s\n", cp1);
	    LYaddstr(cp1);
	    LYaddstr("\n");
	    cp1 = cp;
	    i--;
	}
	while (i >= 0) {
	    LYaddstr("\n");
	    i--;
	}
	LYrefresh();
	LYCloseTempFP(fd);	/* Close the tmpfile.     */
	scrollok(LYwin, FALSE);	/* Stop scrolling.        */

    } else {
	/*
	 * Use the internal line editor for the message.
	 */
	LYaddstr(ENTER_MESSAGE_BELOW);
	LYaddstr(ENTER_PERIOD_WHEN_DONE_A);
	LYaddstr(ENTER_PERIOD_WHEN_DONE_B);
	LYaddstr("\n\n");
	LYrefresh();
	*user_input = '\0';
	if (LYgetstr(user_input, VISIBLE, sizeof(user_input), NORECALL) < 0 ||
	    term_letter || STREQ(user_input, ".")) {
	    goto cancelled;
	}

	while (!STREQ(user_input, ".") && !term_letter) {
	    LYaddstr("\n");
	    remove_tildes(user_input);
	    fprintf(fd, "%s\n", user_input);
	    *user_input = '\0';
	    if (LYgetstr(user_input, VISIBLE,
			 sizeof(user_input), NORECALL) < 0) {
		goto cancelled;
	    }
	}

	fprintf(fd, "\n");	/* Terminate the message. */
	LYCloseTempFP(fd);	/* Close the tmpfile.     */
	scrollok(LYwin, FALSE);	/* Stop scrolling.        */
    }

#if !USE_VMS_MAILER
    /*
     * Ignore CTRL-C on this last question.
     */
    signal(SIGINT, SIG_IGN);
#endif /* !VMS */
    LYStatusLine = (LYlines - 1);
    c = HTConfirm(body ? SEND_MESSAGE_PROMPT : SEND_COMMENT_PROMPT);
    LYStatusLine = -1;
    if (c != YES) {
	LYclear();		/* clear the screen */
	goto cleanup;
    }
    if ((body == NULL && LynxSigFile != NULL) &&
	(fp = fopen(LynxSigFile, TXT_R)) != NULL) {
	LYStatusLine = (LYlines - 1);
	if (term_letter) {
	    _user_message(APPEND_SIG_FILE, LynxSigFile);
	    c = 0;
	} else {
	    char *msg = NULL;

	    HTSprintf0(&msg, APPEND_SIG_FILE, LynxSigFile);
	    c = HTConfirm(msg);
	    FREE(msg);
	}
	LYStatusLine = -1;
	if (c == YES) {
	    if ((fd = fopen(my_tmpfile, TXT_A)) != NULL) {
		char *buffer = NULL;

		fputs("-- \n", fd);
		while (LYSafeGets(&buffer, fp) != NULL) {
		    fputs(buffer, fd);
		}
		LYCloseOutput(fd);
		FREE(buffer);
	    }
	}
	LYCloseInput(fp);
    }
    LYclear();			/* Clear the screen. */

    /*
     * Send the message.
     */
#if USE_VMS_MAILER
    /*
     * Set the mail command.  - FM
     */
    if (isPMDF) {
	/*
	 * For PMDF, put any keywords and the subject in the header file and
	 * close it.  - FM
	 */
	if (!isEmpty(keywords)) {
	    fprintf(hfd, "Keywords: %s\n", keywords);
	}
	fprintf(hfd, "Subject: %s\n\n", the_subject);
	LYCloseTempFP(hfd);
	/*
	 * Now set up the command.  - FM
	 */
	HTSprintf0(&command, "%s %s %s,%s ",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_tmpfile);
    } else {
	/*
	 * For "generic" VMS MAIL, include the subject in the command, and
	 * ignore any keywords to minimize risk of them making the line too
	 * long or having problem characters.  - FM
	 */
	HTSprintf0(&command, "%s %s%s/subject=\"%s\" %s ",
		   system_mail,
		   system_mail_flags,
		   (strncasecomp(system_mail, "MAIL", 4) ? "" : "/noself"),
		   the_subject,
		   my_tmpfile);
    }

    vms_append_addrs(&command, to_address, "");
    if (!isEmpty(ccaddr)) {
	vms_append_addrs(&command, ccaddr, "/CC");
    }

    stop_curses();
    printf("%s\n\n$ %s\n\n%s", SENDING_COMMENT, command, PLEASE_WAIT);
    LYSystem(command);		/* SENDING COMMENT (VMS) */
    FREE(command);
    LYSleepAlert();
    start_curses();
#else /* Unix/DOS/Windows */
    /*
     * Send the tmpfile into sendmail.
     */
    _statusline(SENDING_YOUR_MSG);
#if CAN_PIPE_TO_MAILER
    signal(SIGINT, SIG_IGN);
    if ((fp = LYPipeToMailer()) == 0) {
	HTInfoMsg(CANCELLED);
    }
#else
    if ((fp = LYOpenTemp(tmpfile2, ".txt", "w")) == NULL) {
	HTAlert(MAILTO_URL_TEMPOPEN_FAILED);
    }
#endif /* CAN_PIPE_TO_MAILER */
    if (fp != 0) {
	fd = fopen(my_tmpfile, TXT_R);
	if (fd == NULL) {
	    HTInfoMsg(CANCELLED);
#if CAN_PIPE_TO_MAILER
	    pclose(fp);
#else
	    LYCloseTempFP(fp);
#endif /* CAN_PIPE_TO_MAILER */
	} else {
#if USE_BLAT_MAILER
	    if (!mail_is_blat)
		fputs(header, fp);
#else
	    fputs(header, fp);
#endif
	    while ((n = fread(buf, 1, sizeof(buf), fd)) != 0) {
		fwrite(buf, 1, n, fp);
	    }
#if CAN_PIPE_TO_MAILER
	    pclose(fp);
#else
	    LYCloseTempFP(fp);	/* Close the tmpfile. */
	    LYSendMailFile(to_address,
			   tmpfile2,
			   the_subject,
			   ccaddr,
			   SENDING_COMMENT);
	    LYRemoveTemp(tmpfile2);	/* Delete the tmpfile. */
#endif /* CAN_PIPE_TO_MAILER */
	    LYCloseInput(fd);	/* Close the tmpfile. */
	}
    }
#endif /* USE_VMS_MAILER */
    goto cleanup;

    /*
     * Come here to cleanup and exit.
     */
  cancelled:
    HTInfoMsg(CANCELLED);
    LYCloseTempFP(fd);		/* Close the tmpfile.   */
    scrollok(LYwin, FALSE);	/* Stop scrolling.      */
  cleanup:
    signal(SIGINT, cleanup_sig);
    term_letter = FALSE;

#if USE_VMS_MAILER
    while (LYRemoveTemp(my_tmpfile) == 0) ;	/* Delete the tmpfile(s). */
    if (isPMDF) {
	LYRemoveTemp(hdrfile);	/* Delete the hdrfile. */
    }
#else
    FREE(header);
    LYRemoveTemp(my_tmpfile);	/* Delete the tmpfile. */
#endif /* VMS */

    FREE(from_address);
    FREE(the_subject);
    FREE(cc_address);
    FREE(to_address);
    FREE(ccaddr);
    FREE(keywords);
    FREE(body);
    return;
}

/*
 * Check that we have configured values for system mailer.
 */
BOOLEAN LYSystemMail(void)
{
    if (system_mail == 0 || !strcmp(system_mail, "unknown")) {
	HTAlert(gettext("No system mailer configured"));
	return FALSE;
    }
    return TRUE;
}
@


1.5
log
@automatic merge of lynx-current
@
text
@d84 1
a84 1
			  char *keyword)
d249 1
a249 1
static int header_prompt(char *label,
d1100 1
a1100 1
    char *label = NULL;
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d13 1
a13 1
#include <LYCharSets.h>  /* to get current charset for mail header */
d19 1
a19 1
BOOLEAN term_letter;	/* Global variable for async i/o. */
d21 1
a21 1
static void terminate_letter (int sig GCC_UNUSED)
d28 1
a28 1
     *	Refresh the screen to get rid of the "interrupt" message.
d38 1
a38 2
static void SafeHTUnEscape (
    char *	string)
d40 2
a41 2
     int i;
     int flg = FALSE;
d43 2
a44 3
     HTUnEscape(string);
     for (i=0; string[i] != '\0'; i++)
     {
d47 3
a49 4
	if ((!LYIsASCII(string[i])) || !isprint(UCH(string[i])))
	{
	   string[i] = '?';
	   flg = TRUE;
d51 2
a52 2
     }
     if (flg)
d56 1
a56 1
static void remove_tildes (char *string)
d58 3
a60 4
   /*
    *  Change the first character to
    *  a space if it is a '~'.
    */
d65 2
a66 3
static void comma_append (
    char **	dst,
    char *	src)
d82 3
a84 4
static void extract_field (
    char **	dst,
    char *	src,
    char *	keyword)
d114 2
a115 3
static void extract_subject (
    char *	dst,
    char *	src)
d149 2
a150 3
static void extract_body (
    char **	dst,
    char *	src)
d167 2
a168 2
		 *  Break up the value into lines with
		 *  a maximum length of 78. - FM
d173 1
a173 1
		while((cp = strchr(cp0, '\n')) != NULL) {
d218 1
a218 2
static BOOLEAN trim_comma (
    char *	address)
d228 1
a228 2
static BOOLEAN convert_explorer (
    char *	address)
d249 3
a251 4
static int header_prompt (
    char *		label,
    char **		result,
    unsigned		limit)
d258 1
a258 1
	LYstrncpy(buffer, *result, sizeof(buffer)-1);
d268 1
a268 1
	&& !term_letter);
d279 1
a279 2
static void show_addresses (
    char *	addresses)
d320 6
a325 7
static char *blat_cmd(
	char *mail_cmd,
	char *filename,
	char *address,
	char *subject,
	char *ccaddr,
	char *mail_addr)
d332 8
a339 8
		mail_cmd,
		filename,
		address,
		subject,
		system_mail_flags,
		ccaddr? " -c \"" : "",
		NonNull(ccaddr),
		ccaddr? "\"" : "");
d345 1
a354 1

d390 2
a391 2
	    ? !strncasecomp(system_mail, "PMDF SEND", 9)
	    : FALSE;
d397 1
a397 1
static void vms_append_addrs (char **cmd, char *address, char *option)
d407 1
a407 1
	    address_ptr2 = (cp+1);
d414 3
a416 3
	 *  4 letters is arbitrarily the smallest possible mail
	 *  address, at least for lynx.  That way extra spaces
	 *  won't confuse the mailer and give a blank address.
d431 1
a431 1
static void remove_quotes (char * string)
d445 1
a445 1
FILE *LYPipeToMailer (void)
d458 1
a458 1
#else	/* DOS, Win32, etc. */
d460 5
a464 6
int LYSendMailFile (
    char *	the_address,
    char *	the_filename,
    char *	the_subject GCC_UNUSED,
    char *	the_ccaddr GCC_UNUSED,
    char *	message)
d467 1
d479 8
a486 9
		blat_cmd(
		    system_mail,
		    the_filename,
		    the_address,
		    the_subject,
		    the_ccaddr,
		    personal_mail_address
		)
	);
d490 7
a496 14
	if ((shell = LYGetEnv("SHELL")) != NULL) {
	    if (strstr(shell, "sh") != NULL) {
		HTSprintf0(&cmd, "%s -c %s -t \"%s\" -F %s",
			   shell,
			   system_mail,
			   the_address,
			   the_filename);
	    } else {
		HTSprintf0(&cmd, "%s /c %s -t \"%s\" -F %s",
			   shell,
			   system_mail,
			   the_address,
			   the_filename);
	    }
d498 2
a499 1
	    HTSprintf0(&cmd, "%s -t \"%s\" -F %s",
d504 6
d525 1
a525 1
    SetOutputMode( O_BINARY );
d535 6
a540 7
**  mailform() sends form content to the mailto address(es). - FM
*/
void mailform (
    const char *	mailto_address,
    const char *	mailto_subject,
    const char *	mailto_content,
    const char *	mailto_type)
d552 1
d578 1
a578 1
    if ((cp = (char *)strchr(mailto_address,'\n')) != NULL)
d583 1
a583 1
     *	Check for a ?searchpart. - FM
d591 1
a591 1
	     *	Seek and handle a subject=foo. - FM
d596 2
a597 2
	     *	Seek and handle to=address(es) fields.
	     *	Appends to address. - FM
d602 3
a604 3
	     *	Seek and handle cc=address(es) fields.	Excludes
	     *	Bcc=address(es) as unsafe.  We may append our own
	     *	cc (below) as a list for the actual mailing. - FM
d609 1
a609 1
	     *	Seek and handle keywords=term(s) fields. - FM
d636 1
a636 1
     *	Unescape the address and ccaddr fields. - FM
d644 1
a644 1
     *	Allow user to edit the default Subject - FM
d663 1
a663 2
     *	Allow user to specify a self copy via a CC:
     *	entry, if permitted. - FM
a683 1

d703 1
a703 1
#else	/* e.g., VMS, DOS */
d711 1
d724 2
a725 2
	 *  For PMDF, put any keywords and the subject
	 *  in the header file and close it. - FM
d735 3
a737 3
	 *  Ugh!  There's no good way to include headers while
	 *  we're still using "generic" VMS MAIL, so we'll put
	 *  this in the body of the message. - FM
d741 1
a741 1
#else	/* !VMS (DOS) */
d753 1
a753 1
	fprintf(fd,"To: %s\n", address);
d755 2
a756 2
	    fprintf(fd,"From: %s\n", personal_mail_address);
	fprintf(fd,"Subject: %.70s\n\n", subject);
d762 4
a765 4
     *	Break up the content into lines with a maximum length of 78.
     *	If the ENCTYPE was text/plain, we have physical newlines and
     *	should take them into account.	Otherwise, the actual newline
     *	characters in the content are hex escaped. - FM
d767 1
a767 1
    while((cp = strchr(mailto_content, '\n')) != NULL) {
d779 1
a779 1
	mailto_content = (cp+1);
d800 1
a800 1
     *	Set the mail command. - FM
d804 1
a804 1
	 *  Now set up the command. - FM
d807 5
a811 5
		"%s %s %s,%s ",
		system_mail,
		system_mail_flags,
		hdrfile,
		my_tmpfile);
d814 3
a816 4
	 *  For "generic" VMS MAIL, include the subject in the
	 *  command, and ignore any keywords to minimize risk
	 *  of them making the line too long or having problem
	 *  characters. - FM
d819 6
a824 6
		"%s %s%s/subject=\"%s\" %s ",
		system_mail,
		system_mail_flags,
		(strncasecomp(system_mail, "MAIL", 4) ? "" : "/noself"),
		subject,
		my_tmpfile);
d835 1
a835 1
    LYSystem(command);	/* Mail (VMS) */
d843 5
a847 6
    LYSendMailFile (
	address,
	my_tmpfile,
	subject,
	ccaddr,
	SENDING_FORM_CONTENT);
d852 1
a852 1
cleanup:
d860 7
a866 8
**  mailmsg() sends a message to the owner of the file, if one is defined,
**  telling of errors (i.e., link not available).
*/
void mailmsg (
	int		cur,
	char *		owner_address,
	char *		filename,
	char *		linkname)
d872 1
d887 3
a889 3
	NONNULL(owner_address),
	NONNULL(filename),
	NONNULL(linkname)));
d905 1
a905 1
    if ((cp = (char *)strchr(owner_address,'\n')) != NULL) {
d915 1
a915 1
	 *  Silently refuse sending bad link messages to lynx-dev.
d923 3
a925 3
     *  If we are using a fixed address given by ALERTMAIL, it is
     *  supposed to already be in usable form, without URL-isms like
     *  ?-searchpart and URL-escaping.  So skip some code. - kw
d931 1
a931 1
	 *	Check for a ?searchpart. - FM
d950 1
a950 1
	 *  Unescape the address field. - FM
a959 1

d985 1
d998 1
a998 2
	 *  For PMDF, put the subject in the
	 *  header file and close it. - FM
d1007 1
a1007 1
		links[cur].lname, links[cur].target);
d1029 1
a1029 1
	 *  Now set up the command. - FM
d1032 5
a1036 5
		"%s %s %s,%s ",
		system_mail,
		system_mail_flags,
		hdrfile,
		my_tmpfile);
d1039 1
a1039 2
	 *  For "generic" VMS MAIL, include the
	 *  subject in the command. - FM
d1042 5
a1046 5
		"%s %s/self/subject=\"Lynx Error in %.56s\" %s ",
		system_mail,
		system_mail_flags,
		filename,
		my_tmpfile);
d1050 1
a1050 1
    LYSystem(command);	/* VMS */
d1058 5
a1062 6
    LYSendMailFile (
	address,
	my_tmpfile,
	subject,
	ccaddr,
	"");
d1078 1
a1078 1
		     links[cur].lname, links[cur].target, filename);
d1087 7
a1093 8
**  reply_by_mail() invokes sendmail on Unix or mail on VMS to send
**  a comment from the users to the owner
*/
void reply_by_mail (
	char *		mail_address,
	char *		filename,
	const char *	title,
	const char *	refid)
d1111 1
a1111 1
    int c = 0;	/* user input */
d1114 1
d1120 1
d1125 1
a1125 1
    char buf[4096];	/* 512 */
d1131 4
a1134 4
	NONNULL(mail_address),
	NONNULL(filename),
	NONNULL(title),
	NONNULL(refid)));
d1162 1
a1162 1
     *	Check for a ?searchpart. - FM
d1170 1
a1170 1
	     *	Seek and handle a subject=foo. - FM
d1175 2
a1176 2
	     *	Seek and handle to=address(es) fields.
	     *	Appends to address. - FM
d1181 3
a1183 3
	     *	Seek and handle cc=address(es) fields.	Excludes
	     *	Bcc=address(es) as unsafe.  We may append our own
	     *	cc (below) as a list for the actual mailing. - FM
d1188 1
a1188 1
	     *	Seek and handle keywords=term(s) fields. - FM
d1201 1
a1201 1
	     *	Seek and handle body=foo fields. - FM
d1220 1
a1220 1
     *	Unescape the address and ccaddr fields. - FM
d1228 1
a1228 1
     *	Set the default subject. - FM
d1236 1
a1236 2
     *	Use ^G to cancel mailing of comment
     *	and don't let SIGINTs exit lynx.
d1243 2
a1244 2
	 *  Put the X-URL and X-Mailer lines in the hdrfile
	 *  for PMDF or my_tmpfile for VMS MAIL. - FM
d1260 1
a1260 1
     *	Put the To: line in the header.
d1267 7
a1273 10
     *	Put the Mime-Version, Content-Type and
     *	Content-Transfer-Encoding in the header.
     *	This assumes that the same character set is used
     *	for composing the mail which is currently selected
     *	as display character set...
     *	Don't send a charset if we have a CJK character set
     *	selected, since it may not be appropriate for mail...
     *	Also don't use an unofficial "x-" charset.
     *	Also if the charset would be "us-ascii" (7-bit replacements
     *	selected, don't send any MIME headers. - kw
d1282 1
a1282 1
		    LYCharSet_UC[current_char_set].MIMEname);
d1287 1
a1287 1
     *	Put the X-URL and X-Mailer lines in the header.
d1302 1
a1302 1
     *	Clear the screen and inform the user.
d1305 1
a1305 1
    LYmove(2,0);
d1314 1
a1314 1
	(isPMDF == TRUE) &&
d1316 1
a1316 2
	(cp = ccaddr) != NULL)
    {
d1330 4
a1333 4
    /*
     *	Get the user's personal name.
     */
    LYaddstr(ENTER_NAME_OR_BLANK);
d1335 5
a1339 5
    if (isPMDF) {
	label = "Personal_name: ";
    } else {
	label = "X-Personal_name: ";
    }
d1341 1
a1341 1
    label = "X-Personal_Name: ";
d1343 4
a1346 4
    if (!header_prompt(label, &personal_name, LINESIZE)) {
	goto cancelled;
    }
    if (*personal_name) {
d1348 1
a1348 1
	fprintf((isPMDF ? hfd : fd), "%s: %s\n", label, personal_name);
d1350 1
a1350 1
	HTSprintf(&header, "%s: %s\n", label, personal_name);
d1352 1
a1352 1
    }
d1354 5
a1358 5
    /*
     *	Get the user's return address.
     */
    LYaddstr(ENTER_MAIL_ADDRESS_OR_OTHER);
    LYaddstr(MEANS_TO_CONTACT_FOR_RESPONSE);
d1360 6
a1365 1
    if (isPMDF) {
a1366 5
    } else {
	label = "X-From";
    }
#else
    label = "From";
d1368 6
a1373 6
    /* Add the personal mail address if there is one. */
    if (personal_mail_address)
	StrAllocCopy(from_address, personal_mail_address);
    if (!header_prompt(label, &from_address, LINESIZE)) {
	goto cancelled;
    }
d1375 6
a1380 6
    if (*from_address) {
	fprintf(isPMDF ? hfd : fd, "%s: %s\n", label, from_address);
    }
    if (!isPMDF) {
	fprintf(fd, "\n");
    }
d1382 1
a1382 1
    HTSprintf(&header, "%s: %s\n", label, from_address);
d1390 1
a1390 1
     *	Get the subject line.
d1406 1
a1406 1
     *	Offer a CC line, if permitted. - FM
a1417 1

d1427 2
a1428 2
    **	Add the Cc: header. - FM
    */
d1434 2
a1435 2
    **	Add the Keywords: header. - FM
    */
d1441 1
a1441 1
     *	Terminate the header.
d1444 1
a1444 1
    CTRACE((tfp,"**header==\n%s",header));
d1451 1
a1451 1
	    while((cp = strchr(cp1, '\n')) != NULL) {
d1458 1
a1458 1
	     *	Ask if the user wants to include the original message.
d1461 2
a1462 1
				    HTisDocumentSource());
d1464 2
a1465 2
		? INC_PREPARSED_MSG_PROMPT
		: INC_ORIG_MSG_PROMPT) == YES) {
d1470 1
a1470 1
	scrollok(LYwin,FALSE);	/* Stop scrolling.    */
d1476 1
a1476 1
	 *  Spawn the users editor on the mail file
d1482 1
a1482 1
	 *  Let user review the body. - FM
d1485 1
a1485 1
	LYmove(0,0);
d1490 1
a1490 1
	while((cp = strchr(cp1, '\n')) != NULL) {
d1513 2
a1514 2
	LYCloseTempFP(fd);	/* Close the tmpfile.	  */
	scrollok(LYwin,FALSE);	/* Stop scrolling.	  */
d1518 1
a1518 1
	 *  Use the internal line editor for the message.
d1543 2
a1544 2
	LYCloseTempFP(fd);	/* Close the tmpfile.	  */
	scrollok(LYwin,FALSE);	/* Stop scrolling.	  */
d1549 1
a1549 1
     *	Ignore CTRL-C on this last question.
d1554 1
a1554 1
    c = HTConfirm (body ? SEND_MESSAGE_PROMPT : SEND_COMMENT_PROMPT);
d1557 1
a1557 1
	LYclear();  /* clear the screen */
d1568 1
d1577 1
d1588 1
a1588 1
    LYclear();  /* Clear the screen. */
d1591 1
a1591 1
     *	Send the message.
d1595 1
a1595 1
     *	Set the mail command. - FM
d1599 2
a1600 2
	 *  For PMDF, put any keywords and the subject
	 *  in the header file and close it. - FM
d1608 1
a1608 1
	 *  Now set up the command. - FM
d1611 4
a1614 4
		system_mail,
		system_mail_flags,
		hdrfile,
		my_tmpfile);
d1617 3
a1619 4
	 *  For "generic" VMS MAIL, include the subject in the
	 *  command, and ignore any keywords to minimize risk
	 *  of them making the line too long or having problem
	 *  characters. - FM
d1622 5
a1626 5
		system_mail,
		system_mail_flags,
		(strncasecomp(system_mail, "MAIL", 4) ? "" : "/noself"),
		the_subject,
		my_tmpfile);
d1636 1
a1636 1
    LYSystem(command);	/* SENDING COMMENT (VMS) */
d1642 1
a1642 1
     *	Send the tmpfile into sendmail.
d1678 5
a1682 6
	    LYSendMailFile (
		to_address,
		tmpfile2,
		the_subject,
		ccaddr,
		SENDING_COMMENT);
d1685 1
a1685 1
	    LYCloseInput(fd); /* Close the tmpfile. */
d1692 1
a1692 1
     *	Come here to cleanup and exit.
d1694 1
a1694 1
cancelled:
d1696 3
a1698 3
    LYCloseTempFP(fd);		/* Close the tmpfile.	*/
    scrollok(LYwin,FALSE);	/* Stop scrolling.	*/
cleanup:
d1703 1
a1703 2
    while (LYRemoveTemp(my_tmpfile) == 0)
	;		 /* Delete the tmpfile(s). */
d1705 1
a1705 1
	LYRemoveTemp(hdrfile); /* Delete the hdrfile. */
d1709 1
a1709 1
    LYRemoveTemp(my_tmpfile);  /* Delete the tmpfile. */
d1725 1
a1725 1
BOOLEAN LYSystemMail (void)
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d21 1
a21 1
PRIVATE void terminate_letter ARGS1(int,sig GCC_UNUSED)
d38 2
a39 2
PRIVATE void SafeHTUnEscape ARGS1(
    char *,	string)
d59 1
a59 1
PRIVATE void remove_tildes ARGS1(char *,string)
d69 3
a71 3
PRIVATE void comma_append ARGS2(
    char **,	dst,
    char *,	src)
d87 4
a90 4
PRIVATE void extract_field ARGS3(
    char **,	dst,
    char *,	src,
    char *,	keyword)
d120 3
a122 3
PRIVATE void extract_subject ARGS2(
    char *,	dst,
    char *,	src)
d124 1
a124 1
    CONST char *keyword = "subject=";
d156 3
a158 3
PRIVATE void extract_body ARGS2(
    char **,	dst,
    char *,	src)
d160 1
a160 1
    CONST char *keyword = "body=";
d226 2
a227 2
PRIVATE BOOLEAN trim_comma ARGS1(
    char *,	address)
d237 2
a238 2
PRIVATE BOOLEAN convert_explorer ARGS1(
    char *,	address)
d259 4
a262 4
PRIVATE int header_prompt ARGS3(
    char *,		label,
    char **,		result,
    unsigned,		limit)
d290 2
a291 2
PRIVATE void show_addresses ARGS1(
    char *,	addresses)
d332 1
a332 1
PRIVATE char *blat_cmd(
d400 1
a400 1
PUBLIC BOOLEAN LYMailPMDF(void)
d410 1
a410 1
PRIVATE void vms_append_addrs (char **cmd, char *address, char *option)
d444 1
a444 1
PRIVATE void remove_quotes (char * string)
d458 1
a458 1
PUBLIC FILE *LYPipeToMailer NOARGS
d473 6
a478 6
PUBLIC int LYSendMailFile ARGS5(
    char *,	the_address,
    char *,	the_filename,
    char *,	the_subject GCC_UNUSED,
    char *,	the_ccaddr GCC_UNUSED,
    char *,	message)
d551 5
a555 5
PUBLIC void mailform ARGS4(
    CONST char *,	mailto_address,
    CONST char *,	mailto_subject,
    CONST char *,	mailto_content,
    CONST char *,	mailto_type)
d880 5
a884 5
PUBLIC void mailmsg ARGS4(
	int,		cur,
	char *,		owner_address,
	char *,		filename,
	char *,		linkname)
d1110 5
a1114 5
PUBLIC void reply_by_mail ARGS4(
	char *,		mail_address,
	char *,		filename,
	CONST char *,	title,
	CONST char *,	refid)
d1490 1
a1490 1
		print_wwwfile_to_fd(fd, (BOOL) !is_preparsed);
d1750 1
a1750 1
PUBLIC BOOLEAN LYSystemMail NOARGS
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a0 10
/*
 * This file checked for sprintf() buffer overruns on 1998/05/06 by Bela
 * Lubkin <filbo@@armory.com>.  Please don't introduce any new ones...
 *
 * See comments marked "- BL" for two still-possible overruns in the VMS
 * code.
 *
 * Not yet checked for any other sort of buffer overrun.
 */

d12 1
d17 2
d20 16
a35 2
PRIVATE void terminate_letter  PARAMS((int sig));
PRIVATE void remove_tildes PARAMS((char *string));
d39 1
a39 1
	char *,	string)
d49 1
a49 1
	if ((!LYIsASCII(string[i])) || !isprint(string[i]))
d59 489
d552 4
a555 4
	CONST char *, 	mailto_address,
	CONST char *, 	mailto_subject,
	CONST char *, 	mailto_content,
	CONST char *, 	mailto_type)
d561 3
d565 9
a573 6
    char *cp = NULL, *cp0 = NULL, *cp1 = NULL;
    char subject[80];
    char self[80];
    char cmd[512];
    int len, i, ch;
#if defined(VMS) || defined(DOSPATH)
a574 4
    char *command = NULL;
#ifdef VMS
    char *address_ptr1, *address_ptr2;
    BOOLEAN first = TRUE;
a575 3
    BOOLEAN isPMDF = FALSE;
    char hdrfile[LY_MAXPATH];
    FILE *hfd;
d577 7
a583 4
    if (!strncasecomp(system_mail, "PMDF SEND", 9)) {
	isPMDF = TRUE;
    }
#endif /* VMS */
d607 1
a607 20
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "subject=", 8))
		    break;
		cp++;
	    }
	    if (*cp) {
		cp += 8;
		if ((cp1 = strchr(cp, '&')) != NULL) {
		    *cp1 = '\0';
		}
		if (*cp) {
		    SafeHTUnEscape(subject);
		    LYstrncpy(subject, cp, 70);
		}
		if (cp1) {
		    *cp1 = '&';
		    cp1 = NULL;
		}
	    }
d613 1
a613 26
	    cp = (searchpart + 1);
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "to=", 3)) {
		    cp += 3;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    while (*cp == ',' || isspace((unsigned char)*cp))
			cp++;
		    if (*cp) {
			if (*address) {
			    StrAllocCat(address, ",");
			}
			StrAllocCat(address, cp);
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
	    }
d620 1
a620 28
	    cp = (searchpart + 1);
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "cc=", 3)) {
		    cp += 3;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    while (*cp == ',' || isspace((unsigned char)*cp))
			cp++;
		    if (*cp) {
			if (ccaddr == NULL) {
			    StrAllocCopy(ccaddr, cp);
			} else {
			    StrAllocCat(ccaddr, ",");
			    StrAllocCat(ccaddr, cp);
			}
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
	    }
d625 2
a626 28
	    cp = (searchpart + 1);
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "keywords=", 9)) {
		    cp += 9;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    while (*cp == ',' || isspace((unsigned char)*cp))
			cp++;
		    if (*cp) {
			if (keywords == NULL) {
			    StrAllocCopy(keywords, cp);
			} else {
			    StrAllocCat(keywords, cp);
			    StrAllocCat(keywords, ", ");
			}
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
	    }
d639 1
a639 19
    /*
     * Convert any Explorer semi-colon Internet address
     * separators to commas. - FM
     */
    cp = address;
    while ((cp1 = strchr(cp, '@@')) != NULL) {
	cp1++;
	if ((cp0 = strchr(cp1, ';')) != NULL) {
	    *cp0 = ',';
	    cp1 = cp0 + 1;
	}
	cp = cp1;
    }
    if (address[(strlen(address) - 1)] == ',')
	address[(strlen(address) - 1)] = '\0';
    if (*address == '\0') {
	FREE(address);
	FREE(ccaddr);
	FREE(keywords);
d641 1
a641 1
	return;
d644 1
a644 13
	cp = ccaddr;
	while ((cp1 = strchr(cp, '@@')) != NULL) {
	    cp1++;
	    if ((cp0 = strchr(cp1, ';')) != NULL) {
		*cp0 = ',';
		cp1 = cp0 + 1;
	    }
	    cp = cp1;
	}
	if (ccaddr[(strlen(ccaddr) - 1)] == ',') {
	    ccaddr[(strlen(ccaddr) - 1)] = '\0';
	}
	if (*ccaddr == '\0') {
d660 3
a662 3
    if (subject[0] == '\0') {
	if (mailto_subject && *mailto_subject) {
	    LYstrncpy(subject, mailto_subject, 70);
d664 1
a664 2
	    strcpy(subject, "mailto:");
	    LYstrncpy((char*)&subject[7], address, 63);
d668 1
a668 1
    if ((ch = LYgetstr(subject, VISIBLE, 71, NORECALL)) < 0) {
d673 1
a673 4
	FREE(address);
	FREE(ccaddr);
	FREE(keywords);
	return;
d681 2
a682 3
	sprintf(self, "%.79s", (personal_mail_address ?
				personal_mail_address : ""));
	self[79] = '\0';
d684 1
a684 1
	if ((ch = LYgetstr(self, VISIBLE, sizeof(self), NORECALL)) < 0) {
d689 1
a689 4
	    FREE(address);
	    FREE(ccaddr);
	    FREE(keywords);
	    return;
d700 20
a719 1
#if defined(VMS) || defined(DOSPATH)
d722 1
a722 4
	FREE(address);
	FREE(ccaddr);
	FREE(keywords);
	return;
d724 1
d726 1
d730 1
a730 4
	    FREE(address);
	    FREE(ccaddr);
	    FREE(keywords);
	    return;
d732 1
a732 4
    }
#ifdef VMS
    if (isPMDF) {
	if (mailto_type && *mailto_type) {
d735 1
a735 1
	    if (personal_mail_address && *personal_mail_address)
d737 10
a746 1
	    }
d756 6
a761 10
#else
    if (mailto_type && *mailto_type) {
	fprintf(fd, "Mime-Version: 1.0\n");
	fprintf(fd, "Content-Type: %s\n", mailto_type);
    }
    fprintf(fd,"To: %s\n", address);
    if (personal_mail_address && *personal_mail_address)
	fprintf(fd,"From: %s\n", personal_mail_address);
    remove_tildes(self);
    fprintf(fd,"Subject: %.70s\n\n", subject);
d763 9
a771 9

#else
    sprintf(cmd, "%s %s", system_mail, system_mail_flags);
    if ((fd = popen(cmd, "w")) == NULL) {
	HTAlert(FORM_MAILTO_FAILED);
	FREE(address);
	FREE(ccaddr);
	FREE(keywords);
	return;
a772 14

    if (mailto_type && *mailto_type) {
	fprintf(fd, "Mime-Version: 1.0\n");
	fprintf(fd, "Content-Type: %s\n", mailto_type);
    }
    fprintf(fd, "To: %s\n", address);
    if (personal_mail_address && *personal_mail_address)
	fprintf(fd, "From: %s\n", personal_mail_address);
    if (ccaddr != NULL && *ccaddr != '\0')
	fprintf(fd, "Cc: %s\n", ccaddr);
    fprintf(fd, "Subject: %s\n\n", subject);
    if (keywords != NULL && *keywords != '\0')
	fprintf(fd, "Keywords: %s\n", keywords);
    _statusline(SENDING_FORM_CONTENT);
d774 1
d787 3
a789 3
	    strncpy(cmd, &mailto_content[i], 78);
	    cmd[78] = '\0';
	    fprintf(fd, "%s\n", cmd);
d799 3
a801 3
	strncpy(cmd, &mailto_content[i], 78);
	cmd[78] = '\0';
	fprintf(fd, "%s\n", cmd);
d808 1
a808 1
#ifdef UNIX
d810 2
a811 3
    sleep(MessageSecs);
#endif /* UNIX */
#if defined(VMS) || defined(DOSPATH)
d813 1
a813 1
#ifdef VMS
a818 9
	 *  For PMDF, put any keywords and the subject
	 *  in the header file and close it. - FM
	 */
	if (keywords != NULL && *keywords != '\0') {
	    fprintf(hfd, "Keywords: %s\n", keywords);
	}
	fprintf(hfd, "Subject: %s\n\n", subject);
	LYCloseTempFP(hfd);
	/*
d821 1
a821 1
	sprintf(cmd,
a832 2
	 *
	 *  Possibly still a problem if user supplies long subject. - BL
d834 1
a834 1
	sprintf(cmd,
d844 3
a846 64
    /*
     *	Now add all the people in the address field. - FM
     */
    address_ptr1 = address;
    do {
	if ((cp = strchr(address_ptr1, ',')) != NULL) {
	    address_ptr2 = (cp+1);
	    *cp = '\0';
	} else {
	    address_ptr2 = NULL;
	}

	/*
	 *  4 letters is arbitrarily the smallest possible mail
	 *  address, at least for lynx.  That way extra spaces
	 *  won't confuse the mailer and give a blank address.
	 *
	 *  ignore addresses so long that they would overflow the
	 *  temporary buffer (i.e., about 500 chars). - BL
	 */
	if (strlen(address_ptr1) > 3 &&
	    strlen(address_ptr1) + strlen(mail_adrs) < sizeof(cmd)) {
	    if (!first) {
		StrAllocCat(command, ",");
	    }
	    sprintf(cmd, mail_adrs, address_ptr1);
	    StrAllocCat(command, cmd);
	    first = FALSE;
	}
	address_ptr1 = address_ptr2;
    } while (address_ptr1 != NULL);

    /*
     *	Now add all the people in the CC field. - FM
     */
    if (ccaddr != NULL && *ccaddr != '\0') {
	address_ptr1 = ccaddr;
	do {
	    if ((cp = strchr(address_ptr1, ',')) != NULL) {
		address_ptr2 = (cp+1);
		*cp = '\0';
	    } else {
		address_ptr2 = NULL;
	    }

	    /*
	     *	4 letters is arbitrarily the smallest possible mail
	     *	address, at least for lynx.  That way extra spaces
	     *	won't confuse the mailer and give a blank address.
	     *
	     *  ignore addresses so long that they would overflow the
	     *  temporary buffer (i.e., about 500 chars). - BL
	     */
	    if (strlen(address_ptr1) > 3 &&
		strlen(address_ptr1) + strlen(mail_adrs) < sizeof(cmd)) {
		StrAllocCat(command, ",");
		sprintf(cmd, mail_adrs, address_ptr1);
		if (isPMDF) {
		    strcat(cmd, "/CC");
		}
		StrAllocCat(command, cmd);
	    }
	    address_ptr1 = address_ptr2;
	} while (address_ptr1 != NULL);
d851 1
a851 1
    LYSystem(command);
d853 1
a853 1
    sleep(AlertSecs);
d856 9
a864 13
    LYRemoveTemp(hdrfile);
#else /* DOSPATH */
    StrAllocCopy(command, system_mail);
    StrAllocCat(command, " -t \"");
    StrAllocCat(command, address);
    StrAllocCat(command, "\" -F ");
    StrAllocCat(command, my_tmpfile);
    stop_curses();
    printf("%s\n\n$ %s\n\n%s", SENDING_FORM_CONTENT, command, PLEASE_WAIT);
    LYSystem(command);
    FREE(command);
    sleep(MessageSecs);
    start_curses();
d866 2
a867 2
#endif
#endif /* VMS */
d869 1
d882 3
a884 3
	char *, 	owner_address,
	char *, 	filename,
	char *, 	linkname)
d889 7
a895 2
    char *cmd = NULL, *cp, *cp0, *cp1;
#if defined(VMS) || defined(DOSPATH)
a896 4
    char *command = NULL;
#ifdef VMS
    char *address_ptr1, *address_ptr2;
    BOOLEAN first = TRUE;
d898 2
a899 1
    BOOLEAN isPMDF = FALSE;
d901 1
a901 1
    FILE *hfd;
d903 4
a906 4
    CTRACE(tfp, "mailmsg(%d, \"%s\", \"%s\", \"%s\")\n", cur,
	owner_address?owner_address:"<nil>",
	filename?filename:"<nil>",
	linkname?linkname:"<nil>");
a907 3
    if (!strncasecomp(system_mail, "PMDF SEND", 9)) {
	isPMDF = TRUE;
    }
d910 1
a910 1
    if (owner_address == NULL || *owner_address == '\0') {
d912 5
d918 9
a926 1
    if ((cp = (char *)strchr(owner_address,'\n')) != NULL)
d928 8
d938 1
d940 3
a942 1
     *	Check for a ?searchpart. - FM
d944 9
a952 10
    if ((cp = strchr(address, '?')) != NULL) {
	StrAllocCopy(searchpart, cp);
	*cp = '\0';
	cp = (searchpart + 1);
	if (*cp != '\0') {
	    /*
	     *	Seek and handle to=address(es) fields.
	     *	Appends to address.  We ignore any other
	     *	headers in the ?searchpart. - FM
	     */
d954 7
a960 24
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "to=", 3)) {
		    cp += 3;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    while (*cp == ',' || isspace((unsigned char)*cp))
			cp++;
		    if (*cp) {
			if (*address) {
			    StrAllocCat(address, ",");
			}
			StrAllocCat(address, cp);
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
a962 1
    }
d964 6
a969 12
    /*
     *	Convert any Explorer semi-colon Internet address
     *	separators to commas. - FM
     */
    cp = address;
    while ((cp1 = strchr(cp, '@@')) != NULL) {
	cp1++;
	if ((cp0 = strchr(cp1, ';')) != NULL) {
	    *cp0 = ',';
	    cp1 = cp0 + 1;
	}
	cp = cp1;
d972 1
a972 7
    /*
     *	Unescape the address field. - FM
     */
    SafeHTUnEscape(address);
    if (address[(strlen(address) - 1)] == ',')
	address[(strlen(address) - 1)] = '\0';
    if (*address == '\0') {
d974 1
a974 2
	CTRACE(tfp, "mailmsg: No address in '%s'.\n",
		    owner_address);
d978 2
a979 3
#ifdef UNIX
    HTSprintf0(&cmd, "%s %s", system_mail, system_mail_flags);
    if ((fd = popen(cmd, "w")) == NULL) {
d981 1
a981 2
	CTRACE(tfp, "mailmsg: '%s' failed.\n",
		    cmd);
d987 1
a987 1
    if (personal_mail_address != NULL && *personal_mail_address != '\0') {
d991 2
a992 3
    fprintf(fd, "X-Mailer: Lynx, Version %s\n\n", LYNX_VERSION);
#endif /* UNIX */
#if defined(VMS) || defined(DOSPATH)
d994 1
a994 2
	CTRACE(tfp, "mailmsg: Could not fopen '%s'.\n",
		    my_tmpfile);
d998 3
d1002 1
d1004 1
a1004 2
	    CTRACE(tfp, "mailmsg: Could not fopen '%s'.\n",
			hdrfile);
d1009 1
a1009 1
	if (personal_mail_address != NULL && *personal_mail_address != '\0') {
d1013 7
a1019 1
	fprintf(fd, "X-Mailer: Lynx, Version %s\n\n", LYNX_VERSION);
d1021 2
a1022 1
#endif /* VMS */
d1026 1
a1026 1
    fprintf(fd, gettext("called \"%s\"\n"), links[cur].hightext);
d1032 1
a1032 1
    fprintf(fd, gettext("Lynx ver. %s"), LYNX_VERSION);
d1034 1
a1034 1
	(fp = fopen(LynxSigFile, "r")) != NULL) {
d1038 1
a1038 1
	fclose(fp);
d1040 1
a1040 1
#ifdef UNIX
d1042 1
a1042 2
#endif /* UNIX */
#if defined(VMS) || defined(DOSPATH)
d1044 1
a1044 1
#ifdef VMS
a1046 6
	 *  For PMDF, put the subject in the
	 *  header file and close it. - FM
	 */
	fprintf(hfd, "Subject: Lynx Error in %.56s\n\n", filename);
	LYCloseTempFP(hfd);
	/*
d1060 8
a1067 31
	HTSprintf0(&command,
		"%s %s/self/subject=\"Lynx Error in %.56s\" %s ",
		system_mail,
		system_mail_flags,
		filename,
		my_tmpfile);
    }
    address_ptr1 = address;
    do {
	if ((cp = strchr(address_ptr1, ',')) != NULL) {
	    address_ptr2 = (cp+1);
	    *cp = '\0';
	} else
	    address_ptr2 = NULL;

	/*
	 *  4 letters is arbitrarily the smallest possible mail
	 *  address, at least for lynx.  That way extra spaces
	 *  won't confuse the mailer and give a blank address.
	 *
	 *  ignore addresses so long that they would overflow the
	 *  temporary buffer (i.e., about 500 chars). - BL
	 */
	if (!first) {
	    StrAllocCat(command, ",");
	}
	HTSprintf0(&cmd, mail_adrs, address_ptr1);
	StrAllocCat(command, cmd);
	first = FALSE;
	address_ptr1 = address_ptr2;
    } while (address_ptr1 != NULL);
d1069 1
a1069 1
    LYSystem(command);
d1076 7
a1082 8
#else /* DOSPATH */
    StrAllocCopy(command, system_mail);
    StrAllocCat(command, " -t \"");
    StrAllocCat(command, address);
    StrAllocCat(command, "\" -F ");
    StrAllocCat(command, my_tmpfile);
    LYSystem(command);
    FREE(command);
d1084 2
a1085 2
#endif
#endif /* VMS */
d1093 1
a1093 1
		exit_immediately(-1);
d1099 1
a1099 1
	fclose(ofp);
d1108 1
a1108 1
**  a comment  from the users to the owner
d1111 2
a1112 2
	char *, 	mail_address,
	char *, 	filename,
d1116 4
a1119 1
    char user_input[1000];
d1121 5
a1125 1
    char *address = NULL;
d1130 2
a1131 3
    char *cp = NULL, *cp0 = NULL, *cp1 = NULL;
    char *temp = NULL;
    int i, len;
d1133 3
a1135 5
    char my_tmpfile[LY_MAXPATH], cmd[512];
#ifdef DOSPATH
    char tmpfile2[LY_MAXPATH];
#endif
#if defined(DOSPATH) || defined(VMS)
d1137 1
a1137 9
#endif
#ifndef NO_ANONYMOUS_EMAIL
    static char *personal_name = NULL;
#endif
    char subject[80];
#ifdef VMS
    char *address_ptr1 = NULL, *address_ptr2 = NULL;
    BOOLEAN first = TRUE;
    BOOLEAN isPMDF = FALSE;
d1139 1
a1139 5
    FILE *hfd;

    if (!strncasecomp(system_mail, "PMDF SEND", 9)) {
	isPMDF = TRUE;
    }
d1141 4
a1144 1
    char buf[512];
d1147 1
a1147 1
#endif /* VMS */
d1149 5
a1153 5
    CTRACE(tfp, "reply_by_mail(\"%s\", \"%s\", \"%s\", \"%s\")\n",
	mail_address?mail_address:"<nil>",
	filename?filename:"<nil>",
	title?title:"<nil>",
	refid?refid:"<nil>");
d1157 4
a1160 3
    if (mail_address && *mail_address) {
	StrAllocCopy(address, mail_address);
    } else {
d1164 1
d1170 1
a1170 1
#ifdef VMS
d1178 1
a1178 1
    subject[0] = '\0';
d1183 1
a1183 1
    if ((cp = strchr(address, '?')) != NULL) {
d1191 1
a1191 21
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "subject=", 8))
		    break;
		cp++;
	    }
	    if (*cp) {
		cp += 8;
		if ((cp1 = strchr(cp, '&')) != NULL) {
		    *cp1 = '\0';
		}
		if (*cp) {
		    strncpy(subject, cp, 70);
		    subject[70] = '\0';
		    SafeHTUnEscape(subject);
		}
		if (cp1) {
		    *cp1 = '&';
		    cp1 = NULL;
		}
	    }
d1197 1
a1197 26
	    cp = (searchpart + 1);
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "to=", 3)) {
		    cp += 3;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    while (*cp == ',' || isspace((unsigned char)*cp))
			cp++;
		    if (*cp) {
			if (*address) {
			    StrAllocCat(address, ",");
			}
			StrAllocCat(address, cp);
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
	    }
d1204 1
a1204 28
	    cp = (searchpart + 1);
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "cc=", 3)) {
		    cp += 3;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    while (*cp == ',' || isspace((unsigned char)*cp))
			cp++;
		    if (*cp) {
			if (ccaddr == NULL) {
			    StrAllocCopy(ccaddr, cp);
			} else {
			    StrAllocCat(ccaddr, ",");
			    StrAllocCat(ccaddr, cp);
			}
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
	    }
d1209 2
a1210 29
	    cp = (searchpart + 1);
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "keywords=", 9)) {
		    cp += 9;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    while (*cp == ',' || isspace((unsigned char)*cp))
			cp++;
		    if (*cp) {
			if (keywords == NULL) {
			    StrAllocCopy(keywords, cp);
			} else {
			    StrAllocCat(keywords, cp);
			    StrAllocCat(keywords, ", ");
			}
			StrAllocCat(keywords, cp);
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
	    }
d1222 1
a1222 63
	    cp = (searchpart + 1);
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "body=", 5)) {
		    cp += 5;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    if (*cp) {
			/*
			 *  Break up the value into lines with
			 *  a maximum length of 78. - FM
			 */
			StrAllocCopy(temp, cp);
			HTUnEscape(temp);
			cp0 = temp;
			while((cp = strchr(cp0, '\n')) != NULL) {
			    *cp = '\0';
			    if (cp > cp0) {
				if (*(cp - 1) == '\r') {
				    *(cp - 1) = '\0';
				}
			    }
			    i = 0;
			    len = strlen(cp0);
			    while (len > 78) {
				strncpy(cmd, (char *)&cp0[i], 78);
				cmd[78] = '\0';
				strcat(cmd, "\n");
				StrAllocCat(body, cmd);
				i += 78;
				len = strlen((char *)&cp0[i]);
			    }
			    sprintf(cmd, "%s\n", (char *)&cp0[i]);
			    StrAllocCat(body, cmd);
			    cp0 = (cp + 1);
			}
			i = 0;
			len = strlen(cp0);
			while (len > 78) {
			    strncpy(cmd, (char *)&cp0[i], 78);
			    cmd[78] = '\0';
			    strcat(cmd, "\n");
			    StrAllocCat(body, cmd);
			    i += 78;
			    len = strlen((char *)&cp0[i]);
			}
			if (len) {
			    sprintf(cmd, "%s\n", (char *)&cp0[i]);
			    StrAllocCat(body, cmd);
			}
			FREE(temp);
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
	    }
d1228 1
a1228 22
    /*
     *	Convert any Explorer semi-colon Internet address
     *	separators to commas. - FM
     */
    cp = address;
    while ((cp1 = strchr(cp, '@@')) != NULL) {
	cp1++;
	if ((cp0 = strchr(cp1, ';')) != NULL) {
	    *cp0 = ',';
	    cp1 = cp0 + 1;
	}
	cp = cp1;
    }
    if (address[(strlen(address) - 1)] == ',')
	address[(strlen(address) - 1)] = '\0';
    if (*address == '\0') {
	FREE(address);
	FREE(ccaddr);
	FREE(keywords);
	FREE(body);
	LYCloseTempFP(fd);		/* Close the tmpfile.  */
	LYRemoveTemp(my_tmpfile);	/* Delete the tmpfile. */
d1230 1
a1230 1
	return;
d1233 1
a1233 13
	cp = ccaddr;
	while ((cp1 = strchr(cp, '@@')) != NULL) {
	    cp1++;
	    if ((cp0 = strchr(cp1, ';')) != NULL) {
		*cp0 = ',';
		cp1 = cp0 + 1;
	    }
	    cp = cp1;
	}
	if (ccaddr[(strlen(ccaddr) - 1)] == ',') {
	    ccaddr[(strlen(ccaddr) - 1)] = '\0';
	}
	if (*ccaddr == '\0') {
d1241 1
a1241 1
    SafeHTUnEscape(address);
d1249 3
a1251 3
    if (subject[0] == '\0' && title && *title) {
	strncpy(subject, title, 70);
	subject[70] = '\0';
d1260 1
a1260 2

#ifdef VMS
d1268 2
a1269 2
		(filename && *filename) ? filename : "mailto:",
		(filename && *filename) ? "" : address);
d1271 2
a1272 2
		"X-Mailer: Lynx, Version %s\n",LYNX_VERSION);
#ifdef NO_ANONYMOUS_MAIL
d1276 1
a1276 1
#endif /* NO_ANONYMOUS_MAIL */
d1278 1
a1278 1
#else /* Unix: */
d1283 1
a1283 3
    StrAllocCopy(header, "To: ");
    StrAllocCat(header, address);
    StrAllocCat(header, "\n");
d1304 1
a1304 1
	    sprintf(buf,"Content-Type: text/plain; charset=%s\n",
a1305 1
	    StrAllocCat(header, buf);
d1312 4
a1315 7
    StrAllocCat(header, "X-URL: ");
    if (filename && *filename) {
	StrAllocCat(header, filename);
    }
    else {
	StrAllocCat(header, "mailto:");
	StrAllocCat(header, address);
d1317 1
a1317 3
    StrAllocCat(header, "\n");
    sprintf(buf, "X-Mailer: Lynx, Version %s\n", LYNX_VERSION);
    StrAllocCat(header, buf);
d1319 2
a1320 4
    if (refid && *refid) {
	StrAllocCat(header, "In-Reply-To: <");
	StrAllocCat(header, refid);
	StrAllocCat(header, ">\n");
d1327 3
a1329 3
    clear();
    move(2,0);
    scrollok(stdscr, TRUE);	/* Enable scrolling. */
d1331 1
a1331 1
	addstr(SENDING_MESSAGE_WITH_BODY_TO);
d1333 6
a1338 18
	addstr(SENDING_COMMENT_TO);
    cp = address;
    while ((cp1 = strchr(cp, ',')) != NULL) {
	*cp1 = '\0';
	while (*cp == ' ')
	    cp++;
	if (*cp) {
	    addstr(cp);
	    addstr(",\n  ");
	}
	*cp1 = ',';
	cp = (cp1 + 1);
    }
    if (*cp) {
	addstr(cp);
    }
#ifdef VMS
    if ((isPMDF == TRUE) &&
a1339 3
#else
    if ((cp = ccaddr) != NULL)
#endif /* VMS */
d1342 1
a1342 1
	    addstr(WITH_COPIES_TO);
d1344 1
a1344 15
	    addstr(WITH_COPY_TO);
	}
	while ((cp1 = strchr(cp, ',')) != NULL) {
	    *cp1 = '\0';
	    while (*cp == ' ')
		cp++;
	    if (*cp) {
		addstr(cp);
		addstr(",\n  ");
	    }
	    *cp1 = ',';
	    cp = (cp1 + 1);
	}
	if (*cp) {
	    addstr(cp);
d1346 1
d1348 1
a1348 1
    addstr(CTRL_G_TO_CANCEL_SEND);
d1350 1
a1350 1
#ifdef VMS
d1352 1
a1352 1
#endif /* VMS */
d1357 2
a1358 8
    addstr(ENTER_NAME_OR_BLANK);
    if (personal_name == NULL)
	*user_input = '\0';
    else {
	addstr(CTRL_U_TO_ERASE);
	strcpy(user_input, personal_name);
    }
#ifdef VMS
d1360 1
a1360 1
	addstr(gettext("Personal_name: "));
d1362 1
a1362 1
	addstr(gettext("X_Personal_name: "));
d1365 8
a1372 18
    addstr(gettext("Personal Name: "));
#endif /* VMS */
    if (LYgetstr(user_input, VISIBLE, sizeof(user_input), NORECALL) < 0 ||
	term_letter) {
	addstr("\n");
	HTInfoMsg(COMMENT_REQUEST_CANCELLED);
	LYCloseTempFP(fd);	/* Close the tmpfile. */
	scrollok(stdscr,FALSE); /* Stop scrolling.    */
	goto cleanup;
    }
    addstr("\n");
    remove_tildes(user_input);
    StrAllocCopy(personal_name, user_input);
    term_letter = FALSE;
    if (*user_input) {
#ifdef VMS
	fprintf((isPMDF ? hfd : fd),
		"X-Personal_name: %s\n",user_input);
d1374 1
a1374 3
	StrAllocCat(header, "X-Personal_name: ");
	StrAllocCat(header, user_input);
	StrAllocCat(header, "\n");
d1381 3
a1383 5
    addstr(ENTER_MAIL_ADDRESS_OR_OTHER);
    addstr(MEANS_TO_CONTACT_FOR_RESPONSE);
    if (personal_mail_address)
	addstr(CTRL_U_TO_ERASE);
#ifdef VMS
d1385 1
a1385 1
	addstr("From: ");
d1387 1
a1387 1
	addstr("X-From: ");
d1390 1
a1390 1
    addstr("From: ");
d1393 8
a1400 9
    sprintf(user_input, "%s", (personal_mail_address ?
			       personal_mail_address : ""));
    if (LYgetstr(user_input, VISIBLE, sizeof(user_input), NORECALL) < 0 ||
	term_letter) {
	addstr("\n");
	HTInfoMsg(COMMENT_REQUEST_CANCELLED);
	LYCloseTempFP(fd);	/* Close the tmpfile. */
	scrollok(stdscr,FALSE); /* Stop scrolling.    */
	goto cleanup;
d1402 1
a1402 10
    addstr("\n");
    remove_tildes(user_input);
#ifdef VMS
    if (*user_input) {
	if (isPMDF) {
	    fprintf(hfd, "From: %s\n", user_input);
	} else {
	    fprintf(fd, "X-From: %s\n\n", user_input);
	}
    } else if (!isPMDF) {
d1406 2
a1407 4
    StrAllocCat(header, "From: ");
    StrAllocCat(header, user_input);
    StrAllocCat(header, "\n");
#endif /* VMS */
d1409 1
a1409 1
#ifdef VMS
d1411 1
a1411 1
#endif /* VMS */
d1416 11
a1426 20
    addstr(ENTER_SUBJECT_LINE);
    addstr(CTRL_U_TO_ERASE);
    addstr(SUBJECT_PROMPT);
    /* Add the default subject. */
    sprintf(user_input, "%.70s%.63s",
			(subject[0] != '\0') ?
				     subject :
		    ((filename && *filename) ?
				    filename : "mailto:"),
			(subject[0] != '\0') ?
					  "" :
		    ((filename && *filename) ?
					  "" : address));
    if (LYgetstr(user_input, VISIBLE, 71, NORECALL) < 0 ||
	term_letter) {
	addstr("\n");
	HTInfoMsg(COMMENT_REQUEST_CANCELLED);
	LYCloseTempFP(fd);	/* Close the tmpfile. */
	scrollok(stdscr,FALSE); /* Stop scrolling.    */
	goto cleanup;
a1427 9
    addstr("\n");
    remove_tildes(user_input);
#ifdef VMS
    sprintf(subject, "%.70s", user_input);
#else
    StrAllocCat(header, "Subject: ");
    StrAllocCat(header, user_input);
    StrAllocCat(header, "\n");
#endif /* VMS */
a1431 1
    user_input[0] = '\0';
d1433 2
a1434 1
	addstr(ENTER_ADDRESS_FOR_CC);
d1436 5
a1440 32
	    addstr(CTRL_U_TO_ERASE);
	addstr(BLANK_FOR_NO_COPY);
	addstr("Cc: ");
	/*
	 *  Add the mail address if there is one.
	 */
	sprintf(user_input, "%s", (personal_mail_address ?
				   personal_mail_address : ""));
	if (LYgetstr(user_input, VISIBLE, sizeof(user_input), NORECALL) < 0 ||
	    term_letter) {
	    addstr("\n");
	    HTInfoMsg(COMMENT_REQUEST_CANCELLED);
	    LYCloseTempFP(fd); 		/* Close the tmpfile. */
	    scrollok(stdscr, FALSE);	/* Stop scrolling.    */
	    goto cleanup;
	}
	addstr("\n");
    }
    remove_tildes(user_input);

    if (*user_input) {
	cp = user_input;
	while (*cp == ',' || isspace((unsigned char)*cp))
	    cp++;
	if (*cp) {
	    if (ccaddr == NULL) {
		StrAllocCopy(ccaddr, cp);
	    } else {
		StrAllocCat(ccaddr, ",");
		StrAllocCat(ccaddr, cp);
	    }
	}
d1443 5
a1447 5
#ifdef DOSPATH
    if (*address) {
	StrAllocCat(header, "To: ");
	StrAllocCat(header, address);
	StrAllocCat(header, "\n");
a1450 1
#ifndef VMS
d1454 2
a1455 4
    if (ccaddr != NULL && *ccaddr != '\0') {
	StrAllocCat(header, "Cc: ");
	StrAllocCat(header, ccaddr);
	StrAllocCat(header, "\n");
d1461 2
a1462 4
    if (keywords != NULL && *keywords != '\0') {
	StrAllocCat(header, "Keywords: ");
	StrAllocCat(header, keywords);
	StrAllocCat(header, "\n");
d1468 2
a1469 3
    sprintf(buf, "\n");
    StrAllocCat(header, buf);
    CTRACE(tfp,"**header==\n%s",header);
d1472 1
a1472 5
    if (!no_editor && editor && *editor != '\0') {
	/*
	 *  Use an external editor for the message.
	 */
	char *editor_arg = "";
d1485 1
a1485 1
	    BOOLEAN is_preparsed = (LYPreparsedSource &&
d1488 1
a1488 1
	    	? INC_PREPARSED_MSG_PROMPT
d1490 1
a1490 7
		/*
		 *  The 1 will add the reply "> " in front of every line.
		 */
		if (is_preparsed)
		    print_wwwfile_to_fd(fd, 0);
		else
		    print_wwwfile_to_fd(fd, 1);
d1494 1
a1494 1
	scrollok(stdscr,FALSE); /* Stop scrolling.    */
d1496 1
a1496 1
	if (term_letter || c == 7 || c == 3)
d1502 1
a1502 12
	if (strstr(editor, "pico")) {
	    editor_arg = " -t"; /* No prompt for filename to use */
	}
	sprintf(user_input, "%s%s %s", editor, editor_arg, my_tmpfile);
	_statusline(SPAWNING_EDITOR_FOR_MAIL);
	stop_curses();
	if (LYSystem(user_input)) {
	    start_curses();
	    HTAlert(ERROR_SPAWNING_EDITOR);
	} else {
	    start_curses();
	}
d1508 4
a1511 4
	clear();
	move(0,0);
	addstr(REVIEW_MESSAGE_BODY);
	refresh();
d1516 2
a1517 2
		addstr(RETURN_TO_CONTINUE);
		refresh();
d1519 3
a1521 7
		addstr("\n");
		if (term_letter || c == 7 || c == 3) {
		    addstr(CANCELLED);
		    sleep(InfoSecs);
		    LYCloseTempFP(fd); 		/* Close the tmpfile. */
		    scrollok(stdscr, FALSE);	/* Stop scrolling.    */
		    goto cleanup;
d1527 2
a1528 2
	    addstr(cp1);
	    addstr("\n");
d1533 1
a1533 1
	    addstr("\n");
d1536 1
a1536 1
	refresh();
d1538 1
a1538 1
	scrollok(stdscr,FALSE); /* Stop scrolling.	  */
d1544 5
a1548 5
	addstr(ENTER_MESSAGE_BELOW);
	addstr(ENTER_PERIOD_WHEN_DONE_A);
	addstr(ENTER_PERIOD_WHEN_DONE_B);
	addstr("\n\n");
	refresh();
d1552 1
a1552 4
	    HTInfoMsg(COMMENT_REQUEST_CANCELLED);
	    LYCloseTempFP(fd); 		/* Close the tmpfile. */
	    scrollok(stdscr,FALSE);	/* Stop scrolling.    */
	    goto cleanup;
d1556 1
a1556 1
	    addstr("\n");
d1562 1
a1562 4
		HTInfoMsg(COMMENT_REQUEST_CANCELLED);
		LYCloseTempFP(fd);	/* Close the tmpfile. */
		scrollok(stdscr,FALSE); /* Stop scrolling.    */
		goto cleanup;
d1568 1
a1568 1
	scrollok(stdscr,FALSE); /* Stop scrolling.	  */
d1571 1
a1571 1
#ifndef VMS
d1581 1
a1581 1
	clear();  /* clear the screen */
d1585 1
a1585 1
	(fp = fopen(LynxSigFile, "r")) != NULL) {
d1598 1
a1598 1
	    if ((fd = fopen(my_tmpfile, "a")) != NULL) {
d1604 2
a1605 1
		fclose(fd);
d1608 1
a1608 1
	fclose(fp);
d1610 1
a1610 1
    clear();  /* Clear the screen. */
d1615 1
a1615 1
#ifdef VMS
d1624 1
a1624 1
	if (keywords != NULL && *keywords != '\0') {
d1627 1
a1627 1
	fprintf(hfd, "Subject: %s\n\n", subject);
d1632 1
a1632 2
	sprintf(cmd,
		"%s %s %s,%s ",
a1642 2
	 *
	 *  Possibly still a problem if user supplies long subject. - BL
d1644 1
a1644 2
	sprintf(cmd,
		"%s %s%s/subject=\"%s\" %s ",
d1648 1
a1648 1
		subject,
a1650 46
    StrAllocCopy(command, cmd);

    /*
     *	Now add all the people in the address field. - FM
     */
    address_ptr1 = address;
    do {
	if ((cp = strchr(address_ptr1, ',')) != NULL) {
	    address_ptr2 = (cp+1);
	    *cp = '\0';
	} else {
	    address_ptr2 = NULL;
	}

	/*
	 *  4 letters is arbitrarily the smallest possible mail
	 *  address, at least for lynx.  That way extra spaces
	 *  won't confuse the mailer and give a blank address.
	 *
	 *  ignore addresses so long that they would overflow the
	 *  temporary buffer (i.e., about 500 chars). - BL
	 */
	if (strlen(address_ptr1) > 3 &&
	    strlen(address_ptr1) + strlen(mail_adrs) < sizeof(cmd)) {
	    if (!first) {
		StrAllocCat(command, ",");
	    }
	    sprintf(cmd, mail_adrs, address_ptr1);
	    StrAllocCat(command, cmd);
	    first = FALSE;
	}
	address_ptr1 = address_ptr2;
    } while (address_ptr1 != NULL);

    /*
     *	Now add all the people in the CC field. - FM
     */
    if (ccaddr != NULL && *ccaddr != '\0') {
	address_ptr1 = ccaddr;
	do {
	    if ((cp = strchr(address_ptr1, ',')) != NULL) {
		address_ptr2 = (cp+1);
		*cp = '\0';
	    } else {
		address_ptr2 = NULL;
	    }
d1652 3
a1654 19
	    /*
	     *	4 letters is arbitrarily the smallest possible mail
	     *	address, at least for lynx.  That way extra spaces
	     *	won't confuse the mailer and give a blank address.
	     *
	     *  ignore addresses so long that they would overflow the
	     *  temporary buffer (i.e., about 500 chars). - BL
	     */
	    if (strlen(address_ptr1) > 3 &&
		strlen(address_ptr1) + strlen(mail_adrs) < sizeof(cmd)) {
		StrAllocCat(command, ",");
		sprintf(cmd, mail_adrs, address_ptr1);
		if (isPMDF) {
		    strcat(cmd, "/CC");
		}
		StrAllocCat(command, cmd);
	    }
	    address_ptr1 = address_ptr2;
	} while (address_ptr1 != NULL);
d1659 1
a1659 1
    LYSystem(command);
d1661 1
a1661 1
    sleep(AlertSecs);
d1663 1
a1663 2
    goto cleandown;
#else /* Unix: */
d1668 6
a1673 2
    sprintf(cmd, "%s %s", system_mail, system_mail_flags);
#ifdef DOSPATH
a1675 1
	return;
d1677 7
d1685 6
a1690 30
    signal(SIGINT, SIG_IGN);
    fp = popen(cmd, "w");
    if (fp == NULL) {
	HTInfoMsg(COMMENT_REQUEST_CANCELLED);
	goto cleanup;
    }
#endif /* DOSPATH */
    fd = fopen(my_tmpfile, "r");
    if (fd == NULL) {
	HTInfoMsg(COMMENT_REQUEST_CANCELLED);
	pclose(fp);
	goto cleanup;
    }
    fputs(header, fp);
    while ((n = fread(buf, 1, sizeof(buf), fd)) != 0)
	fwrite(buf, 1, n, fp);
#ifdef DOSPATH
    StrAllocCopy(command, system_mail);
    StrAllocCat(command, " -t \"");
    StrAllocCat(command, address);
    StrAllocCat(command, "\" -F ");
    StrAllocCat(command, tmpfile2);
    LYCloseTempFP(fp);	/* Close the tmpfile. */
    stop_curses();
    printf("%s\n\n$ %s\n\n%s", SENDING_COMMENT, command, PLEASE_WAIT);
    LYSystem(command);
    FREE(command);
    sleep(MessageSecs);
    start_curses();
    LYRemoveTemp(tmpfile2);	/* Delete the tmpfile. */
d1692 1
a1692 1
    pclose(fp);
d1694 20
a1713 4
    LYCloseTempFP(fd); /* Close the tmpfile. */

    CTRACE(tfp, "%s\n", cmd);
#endif /* VMS */
d1718 4
d1724 1
a1724 3
#if !defined(VMS) && !defined(DOSPATH)
    FREE(header);
#endif /* !VMS */
d1726 3
a1728 6
#if defined(VMS) || defined(DOSPATH)
cleandown:
#endif /* VMS */
    term_letter = FALSE;
#ifdef VMS
    FREE(command);
d1730 1
a1730 1
	LYRemoveTemp(hdrfile);
d1732 3
d1736 5
a1740 2
    LYRemoveTemp(my_tmpfile);
    FREE(address);
d1747 4
a1750 1
PRIVATE void terminate_letter ARGS1(int,sig GCC_UNUSED)
d1752 3
a1754 10
    term_letter = TRUE;
    /* Reassert the AST */
    signal(SIGINT, terminate_letter);
#if defined(VMS) || defined(DOSPATH)
    /*
     *	Refresh the screen to get rid of the "interrupt" message.
     */
    if (!dump_output_immediately) {
	lynx_force_repaint();
	refresh();
d1756 1
a1756 11
#endif /* VMS */
}

PRIVATE void remove_tildes ARGS1(char *,string)
{
   /*
    *  Change the first character to
    *  a space if it is a '~'.
    */
    if (*string == '~')
	*string = ' ';
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d1 10
d22 1
a22 2
#include <LYEdit.h>
#include <LYCharSets.h>		/* to get current charset for mail header */
d26 3
a28 19
#define MAX_SUBJECT 70

BOOLEAN term_letter;		/* Global variable for async i/o. */

static void terminate_letter(int sig GCC_UNUSED)
{
    term_letter = TRUE;
    /* Reassert the AST */
    signal(SIGINT, terminate_letter);
#if USE_VMS_MAILER || defined(PDCURSES)
    /*
     * Refresh the screen to get rid of the "interrupt" message.
     */
    if (!dump_output_immediately) {
	lynx_force_repaint();
	LYrefresh();
    }
#endif /* VMS */
}
d31 2
a32 1
static void SafeHTUnEscape(char *string)
d34 2
a35 2
    int i;
    int flg = FALSE;
d37 3
a39 2
    HTUnEscape(string);
    for (i = 0; string[i] != '\0'; i++) {
d42 4
a45 3
	if ((!LYIsASCII(string[i])) || !isprint(UCH(string[i]))) {
	    string[i] = '?';
	    flg = TRUE;
d47 2
a48 2
    }
    if (flg)
a51 246
static void remove_tildes(char *string)
{
    /*
     * Change the first character to a space if it is a '~'.
     */
    if (*string == '~')
	*string = ' ';
}

static void comma_append(char **dst,
			 char *src)
{
    if (*src) {
	while (*src == ',' || isspace(UCH(*src)))
	    src++;
	if (*src) {
	    if (isEmpty(*dst)) {
		StrAllocCopy(*dst, src);
	    } else {
		StrAllocCat(*dst, ",");
		StrAllocCat(*dst, src);
	    }
	}
    }
}

static void extract_field(char **dst,
			  char *src,
			  const char *keyword)
{
    int len = strlen(keyword);
    char *cp, *cp1;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len)) {
	    cp += len;
	    if ((cp1 = strchr(cp, '&')) != NULL) {
		*cp1 = '\0';
	    }
	    comma_append(dst, cp);
	    if (cp1) {
		*cp1 = '&';
		cp = cp1;
		cp1 = NULL;
	    } else {
		break;
	    }
	}
	cp++;
    }
    CTRACE((tfp, "extract_field(%s) = '%s'\n", keyword, NONNULL(*dst)));
}

/*
 * Seek and handle a subject=foo.  - FM
 */
static void extract_subject(char *dst,
			    char *src)
{
    const char *keyword = "subject=";
    int len = strlen(keyword);
    char *cp, *cp1;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len))
	    break;
	cp++;
    }
    if (*cp) {
	cp += len;
	if ((cp1 = strchr(cp, '&')) != NULL) {
	    *cp1 = '\0';
	}
	if (*cp) {
	    strncpy(dst, cp, MAX_SUBJECT);
	    dst[MAX_SUBJECT] = '\0';
	    SafeHTUnEscape(dst);
	}
	if (cp1) {
	    *cp1 = '&';
	    cp1 = NULL;
	}
    }
    CTRACE((tfp, "extract_subject(%s) = '%s'\n", keyword, NONNULL(dst)));
}

/*
 * Seek and handle body=foo fields.  - FM
 */
static void extract_body(char **dst,
			 char *src)
{
    const char *keyword = "body=";
    int len = strlen(keyword);
    int i;
    char *cp, *cp0, *cp1, *temp = 0;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len)) {
	    cp += len;
	    if ((cp1 = strchr(cp, '&')) != NULL) {
		*cp1 = '\0';
	    }
	    if (*cp) {
		/*
		 * Break up the value into lines with a maximum length of 78. 
		 * - FM
		 */
		StrAllocCopy(temp, cp);
		HTUnEscape(temp);
		cp0 = temp;
		while ((cp = strchr(cp0, '\n')) != NULL) {
		    *cp = '\0';
		    if (cp > cp0) {
			if (*(cp - 1) == '\r') {
			    *(cp - 1) = '\0';
			}
		    }
		    i = 0;
		    len = strlen(cp0);
		    while (len > 78) {
			HTSprintf(dst, "%.78s\n", &cp0[i]);
			i += 78;
			len = strlen(&cp0[i]);
		    }
		    HTSprintf(dst, "%s\n", &cp0[i]);
		    cp0 = (cp + 1);
		}
		i = 0;
		len = strlen(cp0);
		while (len > 78) {
		    HTSprintf(dst, "%.78s\n", &cp0[i]);
		    i += 78;
		    len = strlen(&cp0[i]);
		}
		if (len) {
		    HTSprintf(dst, "%s\n", &cp0[i]);
		}
		FREE(temp);
	    }
	    if (cp1) {
		*cp1 = '&';
		cp = cp1;
		cp1 = NULL;
	    } else {
		break;
	    }
	}
	cp++;
    }
    CTRACE((tfp, "extract_body(%s) = '%s'\n", keyword, NONNULL(*dst)));
}

/*
 * Convert any Explorer semi-colon Internet address separators to commas - FM
 */
static BOOLEAN trim_comma(char *address)
{
    if (address[(strlen(address) - 1)] == ',')
	address[(strlen(address) - 1)] = '\0';
    return (BOOL) (*address == '\0');
}

/*
 * Convert any Explorer semi-colon Internet address separators to commas - FM
 */
static BOOLEAN convert_explorer(char *address)
{
    char *cp = address;
    char *cp0;
    char *cp1;

    while ((cp1 = strchr(cp, '@@')) != NULL) {
	cp1++;
	if ((cp0 = strchr(cp1, ';')) != NULL) {
	    *cp0 = ',';
	    cp1 = cp0 + 1;
	}
	cp = cp1;
    }
    return trim_comma(address);
}

/*
 * reply_by_mail() prompts line-by-line for header information, allowing
 * scrolling of the screen.
 */
static int header_prompt(const char *label,
			 char **result,
			 unsigned limit)
{
    char buffer[LINESIZE];
    int ok;

    if (*result != 0) {
	LYaddstr(CTRL_U_TO_ERASE);
	LYstrncpy(buffer, *result, sizeof(buffer) - 1);
    } else
	*buffer = 0;

    if (limit > sizeof(buffer))
	limit = sizeof(buffer);

    LYaddstr(gettext(label));
    LYaddstr(": ");
    ok = (LYgetstr(buffer, VISIBLE, limit, NORECALL) >= 0
	  && !term_letter);
    LYaddstr("\n");

    if (ok) {
	remove_tildes(buffer);
	StrAllocCopy(*result, buffer);
    }
    term_letter = FALSE;
    return ok;
}

static void show_addresses(char *addresses)
{
    char *cp = addresses;
    char *cp1;

    while ((cp1 = strchr(cp, ',')) != NULL) {
	*cp1 = '\0';
	while (*cp == ' ')
	    cp++;
	if (*cp) {
	    LYaddstr(cp);
	    LYaddstr(",\n  ");
	}
	*cp1 = ',';
	cp = (cp1 + 1);
    }
    if (*cp) {
	LYaddstr(cp);
    }
}

#if USE_BLAT_MAILER

d53 1
a53 15
syntax:
Blat <filename> -t <recipient> [optional switches (see below)]

<filename>    : file with the message body
-t <recipient>: recipient list (comma separated)
-s <subj>     : subject line
-f <sender>   : overrides the default sender address (must be known to server)
-i <addr>     : a 'From:' address, not necessarily known to the SMTP server.
-c <recipient>: carbon copy recipient list (comma separated)
-b <recipient>: blind carbon copy recipient list (comma separated)
-h            : displays this help.
-mime         : MIME Quoted-Printable Content-Transfer-Encoding.
-q            : supresses *all* output.
-server <addr>: overrides the default SMTP server to be used.

d55 5
a59 222

static char *blat_cmd(char *mail_cmd,
		      char *filename,
		      char *address,
		      char *subject,
		      char *ccaddr,
		      char *mail_addr)
{
    static char *b_cmd;

#ifdef USE_ALT_BLAT_MAILER

    HTSprintf0(&b_cmd, "%s %s -t \"%s\" -s \"%s\" %s%s%s%s",
	       mail_cmd,
	       filename,
	       address,
	       subject,
	       system_mail_flags,
	       ccaddr ? " -c \"" : "",
	       NonNull(ccaddr),
	       ccaddr ? "\"" : "");

#else /* !USE_ALT_BLAT_MAILER */

    static char bl_cmd_file[512];
    FILE *fp;

#ifdef __CYGWIN__
    char dosname[LY_MAXPATH];
#endif

    bl_cmd_file[0] = '\0';
    if ((fp = LYOpenTemp(bl_cmd_file, ".blt", "w")) == NULL) {
	HTAlert(FORM_MAILTO_FAILED);
	return NULL;
    }
#ifdef __CYGWIN__
    cygwin_conv_to_full_win32_path(filename, dosname);
    fprintf(fp, "%s\n", dosname);
#else
    fprintf(fp, "%s\n", filename);
#endif
    fprintf(fp, "-t\n%s\n", address);
    if (subject)
	fprintf(fp, "-s\n%s\n", subject);
    if (!isEmpty(mail_addr)) {
	fprintf(fp, "-f\n%s\n", mail_addr);
    }
    if (!isEmpty(ccaddr)) {
	fprintf(fp, "-c\n%s\n", ccaddr);
    }
    LYCloseOutput(fp);

#ifdef __CYGWIN__
    cygwin_conv_to_full_win32_path(bl_cmd_file, dosname);
    HTSprintf0(&b_cmd, "%s \"@@%s\"", mail_cmd, dosname);
#else
    HTSprintf0(&b_cmd, "%s @@%s", mail_cmd, bl_cmd_file);
#endif

#endif /* USE_ALT_BLAT_MAILER */

    return b_cmd;
}

#endif /* USE_BLAT_MAILER */

#if USE_VMS_MAILER
BOOLEAN LYMailPMDF(void)
{
    return (system_mail != 0)
	? !strncasecomp(system_mail, "PMDF SEND", 9)
	: FALSE;
}

/*
 * Add all of the people in the address field to the command
 */
static void vms_append_addrs(char **cmd, char *address, char *option)
{
    BOOLEAN first = TRUE;
    char *cp;
    char *address_ptr1;
    char *address_ptr2;

    address_ptr1 = address;
    do {
	if ((cp = strchr(address_ptr1, ',')) != NULL) {
	    address_ptr2 = (cp + 1);
	    *cp = '\0';
	} else {
	    address_ptr2 = NULL;
	}

	/*
	 * 4 letters is arbitrarily the smallest possible mail address, at
	 * least for lynx.  That way extra spaces won't confuse the mailer and
	 * give a blank address.
	 */
	if (strlen(address_ptr1) > 3) {
	    if (!first) {
		StrAllocCat(*cmd, ",");
	    }
	    HTSprintf(cmd, mail_adrs, address_ptr1);
	    if (*option && LYMailPMDF())
		StrAllocCat(*cmd, option);
	    first = FALSE;
	}
	address_ptr1 = address_ptr2;
    } while (address_ptr1 != NULL);
}

static void remove_quotes(char *string)
{
    while (*string != 0) {
	if (strchr("\"&|", *string) != 0)
	    *string = ' ';
	string++;
    }
}
#else
#if CAN_PIPE_TO_MAILER

/*
 * Open a pipe to the mailer
 */
FILE *LYPipeToMailer(void)
{
    char *buffer = NULL;
    FILE *fp = NULL;

    if (LYSystemMail()) {
	HTSprintf0(&buffer, "%s %s", system_mail, system_mail_flags);
	fp = popen(buffer, "w");
	CTRACE((tfp, "popen(%s) %s\n", buffer, fp != 0 ? "OK" : "FAIL"));
	FREE(buffer);
    }
    return fp;
}
#else /* DOS, Win32, etc. */

int LYSendMailFile(char *the_address,
		   char *the_filename,
		   char *the_subject GCC_UNUSED,
		   char *the_ccaddr GCC_UNUSED,
		   char *message)
{
    char *cmd = NULL;

#ifdef __DJGPP__
    char *shell;
#endif /* __DJGPP__ */
    int code;

    if (!LYSystemMail())
	return 0;

#if USE_BLAT_MAILER
    if (mail_is_blat)
	StrAllocCopy(cmd,
		     blat_cmd(system_mail,
			      the_filename,
			      the_address,
			      the_subject,
			      the_ccaddr,
			      personal_mail_address
		     )
	    );
    else
#endif
#ifdef __DJGPP__
    if ((shell = LYGetEnv("SHELL")) != NULL) {
	if (strstr(shell, "sh") != NULL) {
	    HTSprintf0(&cmd, "%s -c %s -t \"%s\" -F %s",
		       shell,
		       system_mail,
		       the_address,
		       the_filename);
	} else {
	    HTSprintf0(&cmd, "%s /c %s -t \"%s\" -F %s",
		       shell,
		       system_mail,
		       the_address,
		       the_filename);
	}
    } else {
	HTSprintf0(&cmd, "%s -t \"%s\" -F %s",
		   system_mail,
		   the_address,
		   the_filename);
    }
#else
	HTSprintf0(&cmd, "%s -t \"%s\" -F %s",
		   system_mail,
		   the_address,
		   the_filename);
#endif /* __DJGPP__ */

    stop_curses();
    SetOutputMode(O_TEXT);
    printf("%s\n\n$ %s\n\n%s",
	   *message ? message : gettext("Sending"),
	   cmd, PLEASE_WAIT);
    code = LYSystem(cmd);
    LYSleepMsg();
    start_curses();
    SetOutputMode(O_BINARY);

    FREE(cmd);

    return code;
}
#endif /* CAN_PIPE_TO_FILE */
#endif /* USE_VMS_MAILER */

/*
 *  mailform() sends form content to the mailto address(es). - FM
 */
void mailform(const char *mailto_address,
	      const char *mailto_subject,
	      const char *mailto_content,
	      const char *mailto_type)
a64 3
    char *cp = NULL;
    char self[MAX_SUBJECT + 10];
    char subject[MAX_SUBJECT + 10];
d66 7
a72 5
    char buf[512];
    int ch, len, i;

#if USE_VMS_MAILER
    static char *cmd;
d74 5
a78 1
    BOOLEAN isPMDF = LYMailPMDF();
d80 1
a80 4
#endif
#if !CAN_PIPE_TO_MAILER
    char my_tmpfile[LY_MAXPATH];
#endif
d82 4
a85 7
    CTRACE((tfp, "mailto_address: \"%s\"\n", NONNULL(mailto_address)));
    CTRACE((tfp, "mailto_subject: \"%s\"\n", NONNULL(mailto_subject)));
    CTRACE((tfp, "mailto_content: \"%s\"\n", NONNULL(mailto_content)));
    CTRACE((tfp, "mailto_type:    \"%s\"\n", NONNULL(mailto_type)));

    if (!LYSystemMail())
	return;
d94 1
a94 1
    if ((cp = (char *) strchr(mailto_address, '\n')) != NULL)
d99 1
a99 1
     * Check for a ?searchpart.  - FM
d107 1
a107 1
	     * Seek and handle a subject=foo.  - FM
d109 20
a128 1
	    extract_subject(subject, searchpart);
d131 2
a132 2
	     * Seek and handle to=address(es) fields.  Appends to address.  -
	     * FM
d134 26
a159 1
	    extract_field(&address, searchpart, "to=");
d162 3
a164 3
	     * Seek and handle cc=address(es) fields.  Excludes Bcc=address(es)
	     * as unsafe.  We may append our own cc (below) as a list for the
	     * actual mailing.  - FM
d166 28
a193 1
	    extract_field(&ccaddr, searchpart, "cc=");
d196 1
a196 1
	     * Seek and handle keywords=term(s) fields.  - FM
d198 28
a225 2
	    extract_field(&keywords, searchpart, "keywords=");

d238 19
a256 1
    if (convert_explorer(address)) {
d258 1
a258 1
	goto cleanup;
d261 13
a273 1
	if (convert_explorer(ccaddr)) {
d279 1
a279 1
     * Unescape the address and ccaddr fields.  - FM
d287 1
a287 1
     * Allow user to edit the default Subject - FM
d289 3
a291 3
    if (isEmpty(subject)) {
	if (!isEmpty(mailto_subject)) {
	    LYstrncpy(subject, mailto_subject, MAX_SUBJECT);
d293 2
a294 1
	    sprintf(subject, "mailto:%.63s", address);
d298 1
a298 1
    if ((ch = LYgetstr(subject, VISIBLE, MAX_SUBJECT, NORECALL)) < 0) {
d303 4
a306 1
	goto cleanup;
d310 2
a311 1
     * Allow user to specify a self copy via a CC:  entry, if permitted.  - FM
d314 3
a316 2
	sprintf(self, "%.*s", MAX_SUBJECT,
		isEmpty(personal_mail_address) ? "" : personal_mail_address);
d318 1
a318 1
	if ((ch = LYgetstr(self, VISIBLE, MAX_SUBJECT, NORECALL)) < 0) {
d323 4
a326 1
	    goto cleanup;
a335 5
#if CAN_PIPE_TO_MAILER
    if ((fd = LYPipeToMailer()) == 0) {
	HTAlert(FORM_MAILTO_FAILED);
	goto cleanup;
    }
d337 1
a337 14
    if (!isEmpty(mailto_type)) {
	fprintf(fd, "Mime-Version: 1.0\n");
	fprintf(fd, "Content-Type: %s\n", mailto_type);
    }
    fprintf(fd, "To: %s\n", address);
    if (!isEmpty(personal_mail_address))
	fprintf(fd, "From: %s\n", personal_mail_address);
    if (!isEmpty(ccaddr))
	fprintf(fd, "Cc: %s\n", ccaddr);
    fprintf(fd, "Subject: %s\n\n", subject);
    if (!isEmpty(keywords))
	fprintf(fd, "Keywords: %s\n", keywords);
    _statusline(SENDING_FORM_CONTENT);
#else /* e.g., VMS, DOS */
d340 4
a343 1
	goto cleanup;
a344 1
#if USE_VMS_MAILER
a345 2
	FILE *hfd;

d349 4
a352 1
	    goto cleanup;
d354 4
a357 1
	if (!isEmpty(mailto_type)) {
d360 1
a360 1
	    if (!isEmpty(personal_mail_address))
d362 1
a362 10
	}
	/*
	 * For PMDF, put any keywords and the subject in the header file and
	 * close it.  - FM
	 */
	if (!isEmpty(keywords)) {
	    fprintf(hfd, "Keywords: %s\n", keywords);
	}
	fprintf(hfd, "Subject: %s\n\n", subject);
	LYCloseTempFP(hfd);
d366 3
a368 3
	 * Ugh!  There's no good way to include headers while we're still using
	 * "generic" VMS MAIL, so we'll put this in the body of the message.  -
	 * FM
d372 10
a381 6
#else /* !VMS (DOS) */
#if USE_BLAT_MAILER
    if (mail_is_blat) {
	if (strlen(subject) > MAX_SUBJECT)
	    subject[MAX_SUBJECT] = '\0';
    } else
d383 14
a396 9
    {
	if (!isEmpty(mailto_type)) {
	    fprintf(fd, "Mime-Version: 1.0\n");
	    fprintf(fd, "Content-Type: %s\n", mailto_type);
	}
	fprintf(fd, "To: %s\n", address);
	if (!isEmpty(personal_mail_address))
	    fprintf(fd, "From: %s\n", personal_mail_address);
	fprintf(fd, "Subject: %.70s\n\n", subject);
d398 9
a407 1
#endif /* CAN_PIPE_TO_MAILER */
d410 4
a413 4
     * Break up the content into lines with a maximum length of 78.  If the
     * ENCTYPE was text/plain, we have physical newlines and should take them
     * into account.  Otherwise, the actual newline characters in the content
     * are hex escaped.  - FM
d415 1
a415 1
    while ((cp = strchr(mailto_content, '\n')) != NULL) {
d420 3
a422 3
	    strncpy(buf, &mailto_content[i], 78);
	    buf[78] = '\0';
	    fprintf(fd, "%s\n", buf);
d427 1
a427 1
	mailto_content = (cp + 1);
d432 3
a434 3
	strncpy(buf, &mailto_content[i], 78);
	buf[78] = '\0';
	fprintf(fd, "%s\n", buf);
d441 1
a441 1
#if CAN_PIPE_TO_MAILER
d443 3
a445 2
    LYSleepMsg();
#else
d447 1
a447 1
#if USE_VMS_MAILER
d449 1
a449 1
     * Set the mail command.  - FM
d453 2
a454 1
	 * Now set up the command.  - FM
d456 14
a469 6
	HTSprintf0(&cmd,
		   "%s %s %s,%s ",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_tmpfile);
d472 14
a485 11
	 * For "generic" VMS MAIL, include the subject in the command, and
	 * ignore any keywords to minimize risk of them making the line too
	 * long or having problem characters.  - FM
	 */
	HTSprintf0(&cmd,
		   "%s %s%s/subject=\"%s\" %s ",
		   system_mail,
		   system_mail_flags,
		   (strncasecomp(system_mail, "MAIL", 4) ? "" : "/noself"),
		   subject,
		   my_tmpfile);
d489 64
a552 3
    vms_append_addrs(&command, address, "");
    if (!isEmpty(ccaddr)) {
	vms_append_addrs(&command, ccaddr, "/CC");
d557 1
a557 1
    LYSystem(command);		/* Mail (VMS) */
d559 1
a559 1
    LYSleepAlert();
d562 13
a574 8
    if (isPMDF)
	LYRemoveTemp(hdrfile);
#else /* DOS */
    LYSendMailFile(address,
		   my_tmpfile,
		   subject,
		   ccaddr,
		   SENDING_FORM_CONTENT);
d576 2
a577 2
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */
a578 1
  cleanup:
d586 8
a593 7
 *  mailmsg() sends a message to the owner of the file, if one is defined,
 *  telling of errors (i.e., link not available).
 */
void mailmsg(int cur,
	     char *owner_address,
	     char *filename,
	     char *linkname)
d598 2
a599 8
    char *cmd = NULL, *cp;

#ifdef ALERTMAIL
    BOOLEAN skip_parsing = FALSE;
#endif
#if !CAN_PIPE_TO_MAILER
    char *ccaddr;
    char subject[128];
d601 4
d606 1
a606 2
#if USE_VMS_MAILER
    BOOLEAN isPMDF = LYMailPMDF();
d608 1
a608 1
    char *command = NULL;
d610 4
a613 4
    CTRACE((tfp, "mailmsg(%d, \"%s\", \"%s\", \"%s\")\n", cur,
	    NONNULL(owner_address),
	    NONNULL(filename),
	    NONNULL(linkname)));
d615 3
d620 1
a620 1
    if (!LYSystemMail())
a621 5

#ifdef ALERTMAIL
    if (owner_address == NULL) {
	owner_address = ALERTMAIL;
	skip_parsing = TRUE;
d623 1
a623 9
#endif

    if (isEmpty(owner_address))
	return;
    if ((cp = (char *) strchr(owner_address, '\n')) != NULL) {
#ifdef ALERTMAIL
	if (skip_parsing)
	    return;		/* invalidly defined - ignore - kw */
#else
a624 8
#endif
    }
    if (!strncasecomp(owner_address, "lynx-dev@@", 9)) {
	/*
	 * Silently refuse sending bad link messages to lynx-dev.
	 */
	return;
    }
a626 1
#ifdef ALERTMAIL
d628 1
a628 3
     * If we are using a fixed address given by ALERTMAIL, it is supposed to
     * already be in usable form, without URL-isms like ?-searchpart and
     * URL-escaping.  So skip some code.  - kw
d630 10
a639 9
    if (!skip_parsing)
#endif
    {
	/*
	 * Check for a ?searchpart.  - FM
	 */
	if ((cp = strchr(address, '?')) != NULL) {
	    StrAllocCopy(searchpart, cp);
	    *cp = '\0';
d641 24
a664 7
	    if (*cp != '\0') {
		/*
		 * Seek and handle to=address(es) fields.
		 * Appends to address.  We ignore any other
		 * headers in the ?searchpart.  - FM
		 */
		extract_field(&address, searchpart, "to=");
d667 1
d669 12
a680 6
	convert_explorer(address);

	/*
	 * Unescape the address field.  - FM
	 */
	SafeHTUnEscape(address);
d683 7
a689 1
    if (trim_comma(address)) {
d691 2
a692 1
	CTRACE((tfp, "mailmsg: No address in '%s'.\n", owner_address));
d695 4
a698 2
#if CAN_PIPE_TO_MAILER
    if ((fd = LYPipeToMailer()) == 0) {
d700 2
a701 1
	CTRACE((tfp, "mailmsg: '%s' failed.\n", cmd));
d707 1
a707 1
    if (!isEmpty(personal_mail_address)) {
d711 3
a713 2
    fprintf(fd, "X-Mailer: %s, Version %s\n\n", LYNX_NAME, LYNX_VERSION);
#else
d715 2
a716 1
	CTRACE((tfp, "mailmsg: Could not fopen '%s'.\n", my_tmpfile));
a719 3
    sprintf(subject, "Lynx Error in %.56s", filename);
    ccaddr = personal_mail_address;
#if USE_VMS_MAILER
a720 2
	FILE *hfd;

d722 2
a723 1
	    CTRACE((tfp, "mailmsg: Could not fopen '%s'.\n", hdrfile));
d728 1
a728 1
	if (!isEmpty(personal_mail_address)) {
d732 1
a732 6
	fprintf(fd, "X-Mailer: %s, Version %s\n\n", LYNX_NAME, LYNX_VERSION);
	/*
	 * For PMDF, put the subject in the header file and close it.  - FM
	 */
	fprintf(hfd, "Subject: Lynx Error in %.56s\n\n", filename);
	LYCloseTempFP(hfd);
d734 1
a734 2
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */
d737 2
a738 2
	    links[cur].lname, links[cur].target);
    fprintf(fd, gettext("called \"%s\"\n"), LYGetHiliteStr(cur, 0));
d744 1
a744 1
    fprintf(fd, "%s %s", LYNX_NAME, LYNX_VERSION);
d746 1
a746 1
	(fp = fopen(LynxSigFile, TXT_R)) != NULL) {
d750 1
a750 1
	LYCloseInput(fp);
d752 1
a752 1
#if CAN_PIPE_TO_MAILER
d754 2
a755 1
#else
d757 1
a757 1
#if USE_VMS_MAILER
d760 7
a766 1
	 * Now set up the command.  - FM
d769 5
a773 5
		   "%s %s %s,%s ",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_tmpfile);
d776 2
a777 1
	 * For "generic" VMS MAIL, include the subject in the command.  - FM
d780 5
a784 5
		   "%s %s/self/subject=\"Lynx Error in %.56s\" %s ",
		   system_mail,
		   system_mail_flags,
		   filename,
		   my_tmpfile);
d786 24
a809 1
    vms_append_addrs(&command, address, "");
d811 1
a811 1
    LYSystem(command);		/* VMS */
d818 8
a825 6
#else /* DOS */
    LYSendMailFile(address,
		   my_tmpfile,
		   subject,
		   ccaddr,
		   "");
d827 2
a828 2
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */
d836 1
a836 1
		exit_immediately(EXIT_FAILURE);
d841 2
a842 2
		links[cur].lname, links[cur].target, filename);
	LYCloseOutput(ofp);
d850 8
a857 7
 *  reply_by_mail() invokes sendmail on Unix or mail on VMS to send
 *  a comment from the users to the owner
 */
void reply_by_mail(char *mail_address,
		   char *filename,
		   const char *title,
		   const char *refid)
d859 1
a859 4
#ifndef NO_ANONYMOUS_EMAIL
    static char *personal_name = NULL;
#endif
    char user_input[LINESIZE];
d861 1
a861 5
    const char *label = NULL;
    char *from_address = NULL;
    char *cc_address = NULL;
    char *to_address = NULL;
    char *the_subject = NULL;
d866 9
a874 7
    char *cp = NULL, *cp1 = NULL;
    int i;
    int c = 0;			/* user input */
    char my_tmpfile[LY_MAXPATH];
    char default_subject[MAX_SUBJECT + 10];

#if USE_VMS_MAILER
d876 9
a884 1
    BOOLEAN isPMDF = LYMailPMDF();
d886 1
a886 1
    FILE *hfd = 0;
d888 3
d892 1
a892 4
#if !CAN_PIPE_TO_MAILER
    char tmpfile2[LY_MAXPATH];
#endif
    char buf[4096];		/* 512 */
d895 1
a895 1
#endif /* USE_VMS_MAILER */
d897 5
a901 5
    CTRACE((tfp, "reply_by_mail(\"%s\", \"%s\", \"%s\", \"%s\")\n",
	    NONNULL(mail_address),
	    NONNULL(filename),
	    NONNULL(title),
	    NONNULL(refid)));
d905 3
a907 4
    if (!LYSystemMail())
	return;

    if (isEmpty(mail_address)) {
a910 1
    StrAllocCopy(to_address, mail_address);
d916 1
a916 1
#if USE_VMS_MAILER
d924 1
a924 1
    default_subject[0] = '\0';
d927 1
a927 1
     * Check for a ?searchpart.  - FM
d929 1
a929 1
    if ((cp = strchr(to_address, '?')) != NULL) {
d935 1
a935 1
	     * Seek and handle a subject=foo.  - FM
d937 21
a957 1
	    extract_subject(default_subject, searchpart);
d960 2
a961 2
	     * Seek and handle to=address(es) fields.  Appends to address.  -
	     * FM
d963 26
a988 1
	    extract_field(&to_address, searchpart, "to=");
d991 3
a993 3
	     * Seek and handle cc=address(es) fields.  Excludes Bcc=address(es)
	     * as unsafe.  We may append our own cc (below) as a list for the
	     * actual mailing.  - FM
d995 28
a1022 1
	    extract_field(&ccaddr, searchpart, "cc=");
d1025 1
a1025 1
	     * Seek and handle keywords=term(s) fields.  - FM
d1027 29
a1055 2
	    extract_field(&keywords, searchpart, "keywords=");

d1065 1
a1065 1
	     * Seek and handle body=foo fields.  - FM
d1067 63
a1129 1
	    extract_body(&body, searchpart);
d1135 22
a1156 1
    if (convert_explorer(to_address)) {
d1158 1
a1158 1
	goto cancelled;
d1161 13
a1173 1
	if (convert_explorer(ccaddr)) {
d1179 1
a1179 1
     * Unescape the address and ccaddr fields.  - FM
d1181 1
a1181 1
    SafeHTUnEscape(to_address);
d1187 1
a1187 1
     * Set the default subject.  - FM
d1189 3
a1191 3
    if (isEmpty(default_subject) && !isEmpty(title)) {
	strncpy(default_subject, title, MAX_SUBJECT);
	default_subject[MAX_SUBJECT] = '\0';
d1195 2
a1196 1
     * Use ^G to cancel mailing of comment and don't let SIGINTs exit lynx.
d1200 2
a1201 1
#if USE_VMS_MAILER
d1204 2
a1205 2
	 * Put the X-URL and X-Mailer lines in the hdrfile for PMDF or
	 * my_tmpfile for VMS MAIL.  - FM
d1209 2
a1210 2
		isEmpty(filename) ? STR_MAILTO_URL : filename,
		isEmpty(filename) ? to_address : "");
d1212 2
a1213 2
		"X-Mailer: %s, Version %s\n", LYNX_NAME, LYNX_VERSION);
#ifdef NO_ANONYMOUS_EMAIL
d1217 1
a1217 1
#endif /* NO_ANONYMOUS_EMAIL */
d1219 1
a1219 1
#else /* Unix/DOS/Windows */
d1221 1
a1221 1
     * Put the To:  line in the header.
d1224 3
a1226 1
    HTSprintf(&header, "To: %s\n", to_address);
d1230 10
a1239 7
     * Put the Mime-Version, Content-Type and Content-Transfer-Encoding in the
     * header.  This assumes that the same character set is used for composing
     * the mail which is currently selected as display character set...  Don't
     * send a charset if we have a CJK character set selected, since it may not
     * be appropriate for mail...  Also don't use an unofficial "x-" charset. 
     * Also if the charset would be "us-ascii" (7-bit replacements selected,
     * don't send any MIME headers.  - kw
d1247 3
a1249 2
	    HTSprintf(&header, "Content-Type: text/plain; charset=%s\n",
		      LYCharSet_UC[current_char_set].MIMEname);
d1254 1
a1254 1
     * Put the X-URL and X-Mailer lines in the header.
d1256 7
a1262 4
    if (!isEmpty(filename)) {
	HTSprintf(&header, "X-URL: %s\n", filename);
    } else {
	HTSprintf(&header, "X-URL: mailto:%s\n", to_address);
d1264 3
a1266 1
    HTSprintf(&header, "X-Mailer: %s, Version %s\n", LYNX_NAME, LYNX_VERSION);
d1268 4
a1271 2
    if (!isEmpty(refid)) {
	HTSprintf(&header, "In-Reply-To: <%s>\n", refid);
d1276 1
a1276 1
     * Clear the screen and inform the user.
d1278 3
a1280 3
    LYclear();
    LYmove(2, 0);
    scrollok(LYwin, TRUE);	/* Enable scrolling. */
d1282 1
a1282 1
	LYaddstr(SENDING_MESSAGE_WITH_BODY_TO);
d1284 21
a1304 5
	LYaddstr(SENDING_COMMENT_TO);
    show_addresses(to_address);
    if (
#if USE_VMS_MAILER
	   (isPMDF == TRUE) &&
d1306 1
a1306 1
	   (cp = ccaddr) != NULL) {
d1308 1
a1308 1
	    LYaddstr(WITH_COPIES_TO);
d1310 15
a1324 1
	    LYaddstr(WITH_COPY_TO);
a1325 1
	show_addresses(ccaddr);
d1327 1
a1327 1
    LYaddstr(CTRL_G_TO_CANCEL_SEND);
d1329 1
a1329 1
#if USE_VMS_MAILER
d1331 1
a1331 1
#endif /* USE_VMS_MAILER */
d1333 16
a1348 10
	/*
	 * Get the user's personal name.
	 */
	LYaddstr(ENTER_NAME_OR_BLANK);
#if USE_VMS_MAILER
	if (isPMDF) {
	    label = "Personal_name: ";
	} else {
	    label = "X-Personal_name: ";
	}
d1350 18
a1367 8
	label = "X-Personal_Name: ";
#endif /* USE_VMS_MAILER */
	if (!header_prompt(label, &personal_name, LINESIZE)) {
	    goto cancelled;
	}
	if (*personal_name) {
#if USE_VMS_MAILER
	    fprintf((isPMDF ? hfd : fd), "%s: %s\n", label, personal_name);
d1369 3
a1371 1
	    HTSprintf(&header, "%s: %s\n", label, personal_name);
d1373 1
a1373 1
	}
d1375 31
a1405 6
	/*
	 * Get the user's return address.
	 */
	LYaddstr(ENTER_MAIL_ADDRESS_OR_OTHER);
	LYaddstr(MEANS_TO_CONTACT_FOR_RESPONSE);
#if USE_VMS_MAILER
d1407 1
a1407 1
	    label = "From";
d1409 1
a1409 1
	    label = "X-From";
d1411 3
d1415 3
a1417 1
	label = "From";
a1418 16
	/* Add the personal mail address if there is one. */
	if (personal_mail_address)
	    StrAllocCopy(from_address, personal_mail_address);
	if (!header_prompt(label, &from_address, LINESIZE)) {
	    goto cancelled;
	}
#if USE_VMS_MAILER
	if (*from_address) {
	    fprintf(isPMDF ? hfd : fd, "%s: %s\n", label, from_address);
	}
	if (!isPMDF) {
	    fprintf(fd, "\n");
	}
#else
	HTSprintf(&header, "%s: %s\n", label, from_address);
#endif /* USE_VMS_MAILER */
d1420 1
a1420 1
#if USE_VMS_MAILER
d1422 1
a1422 1
#endif /* USE_VMS_MAILER */
d1425 1
a1425 1
     * Get the subject line.
d1427 20
a1446 11
    LYaddstr(ENTER_SUBJECT_LINE);
    label = "Subject";
    if (*default_subject) {
	StrAllocCopy(the_subject, default_subject);
    } else if (!isEmpty(filename)) {
	HTSprintf(&the_subject, "%s", filename);
    } else {
	HTSprintf(&the_subject, "mailto:%s", to_address);
    }
    if (!header_prompt(label, &the_subject, MAX_SUBJECT)) {
	goto cancelled;
d1448 9
d1459 1
a1459 1
     * Offer a CC line, if permitted.  - FM
d1461 1
d1463 1
a1463 2
	LYaddstr(ENTER_ADDRESS_FOR_CC);
	LYaddstr(BLANK_FOR_NO_COPY);
d1465 39
a1503 11
	    StrAllocCopy(cc_address, personal_mail_address);
	if (!header_prompt("Cc", &cc_address, LINESIZE)) {
	    goto cancelled;
	}
	comma_append(&ccaddr, cc_address);
    }
#if !USE_VMS_MAILER
    HTSprintf(&header, "%s: %s\n", label, the_subject);
#if !CAN_PIPE_TO_MAILER
    if (*to_address) {
	HTSprintf(&header, "To: %s\n", to_address);
d1507 1
d1509 6
a1514 4
     * Add the Cc:  header.  - FM
     */
    if (!isEmpty(ccaddr)) {
	HTSprintf(&header, "Cc: %s\n", ccaddr);
d1518 6
a1523 4
     * Add the Keywords:  header.  - FM
     */
    if (!isEmpty(keywords)) {
	HTSprintf(&header, "Keywords: %s\n", keywords);
d1527 1
a1527 1
     * Terminate the header.
d1529 3
a1531 2
    StrAllocCat(header, "\n");
    CTRACE((tfp, "**header==\n%s", header));
d1534 5
a1538 1
    if (!no_editor && !isEmpty(editor)) {
d1542 1
a1542 1
	    while ((cp = strchr(cp1, '\n')) != NULL) {
d1549 1
a1549 1
	     * Ask if the user wants to include the original message.
d1551 2
a1552 3
	    BOOLEAN is_preparsed = (BOOL) (LYPreparsedSource &&
					   HTisDocumentSource());

d1554 9
a1562 3
			  ? INC_PREPARSED_MSG_PROMPT
			  : INC_ORIG_MSG_PROMPT) == YES) {
		print_wwwfile_to_fd(fd, TRUE, (BOOL) !is_preparsed);
d1566 1
a1566 1
	scrollok(LYwin, FALSE);	/* Stop scrolling.    */
d1568 1
a1568 1
	if (term_letter || LYCharIsINTERRUPT(c))
d1572 1
a1572 1
	 * Spawn the users editor on the mail file
d1574 12
a1585 1
	edit_temporary_file(my_tmpfile, "", SPAWNING_EDITOR_FOR_MAIL);
d1589 1
a1589 1
	 * Let user review the body.  - FM
d1591 4
a1594 4
	LYclear();
	LYmove(0, 0);
	LYaddstr(REVIEW_MESSAGE_BODY);
	LYrefresh();
d1597 1
a1597 1
	while ((cp = strchr(cp1, '\n')) != NULL) {
d1599 2
a1600 2
		LYaddstr(RETURN_TO_CONTINUE);
		LYrefresh();
d1602 7
a1608 3
		LYaddstr("\n");
		if (term_letter || LYCharIsINTERRUPT(c)) {
		    goto cancelled;
d1614 2
a1615 2
	    LYaddstr(cp1);
	    LYaddstr("\n");
d1620 1
a1620 1
	    LYaddstr("\n");
d1623 3
a1625 3
	LYrefresh();
	LYCloseTempFP(fd);	/* Close the tmpfile.     */
	scrollok(LYwin, FALSE);	/* Stop scrolling.        */
d1629 1
a1629 1
	 * Use the internal line editor for the message.
d1631 5
a1635 5
	LYaddstr(ENTER_MESSAGE_BELOW);
	LYaddstr(ENTER_PERIOD_WHEN_DONE_A);
	LYaddstr(ENTER_PERIOD_WHEN_DONE_B);
	LYaddstr("\n\n");
	LYrefresh();
d1639 4
a1642 1
	    goto cancelled;
d1646 1
a1646 1
	    LYaddstr("\n");
d1652 4
a1655 1
		goto cancelled;
d1660 2
a1661 2
	LYCloseTempFP(fd);	/* Close the tmpfile.     */
	scrollok(LYwin, FALSE);	/* Stop scrolling.        */
d1664 1
a1664 1
#if !USE_VMS_MAILER
d1666 1
a1666 1
     * Ignore CTRL-C on this last question.
d1671 1
a1671 1
    c = HTConfirm(body ? SEND_MESSAGE_PROMPT : SEND_COMMENT_PROMPT);
d1674 1
a1674 1
	LYclear();		/* clear the screen */
d1678 1
a1678 1
	(fp = fopen(LynxSigFile, TXT_R)) != NULL) {
a1684 1

d1691 1
a1691 1
	    if ((fd = fopen(my_tmpfile, TXT_A)) != NULL) {
a1692 1

d1697 1
a1697 2
		LYCloseOutput(fd);
		FREE(buffer);
d1700 1
a1700 1
	LYCloseInput(fp);
d1702 1
a1702 1
    LYclear();			/* Clear the screen. */
d1705 1
a1705 1
     * Send the message.
d1707 1
a1707 1
#if USE_VMS_MAILER
d1709 1
a1709 1
     * Set the mail command.  - FM
d1713 2
a1714 2
	 * For PMDF, put any keywords and the subject in the header file and
	 * close it.  - FM
d1716 1
a1716 1
	if (!isEmpty(keywords)) {
d1719 1
a1719 1
	fprintf(hfd, "Subject: %s\n\n", the_subject);
d1722 1
a1722 1
	 * Now set up the command.  - FM
d1724 6
a1729 5
	HTSprintf0(&command, "%s %s %s,%s ",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_tmpfile);
d1732 36
a1767 3
	 * For "generic" VMS MAIL, include the subject in the command, and
	 * ignore any keywords to minimize risk of them making the line too
	 * long or having problem characters.  - FM
d1769 24
a1792 7
	HTSprintf0(&command, "%s %s%s/subject=\"%s\" %s ",
		   system_mail,
		   system_mail_flags,
		   (strncasecomp(system_mail, "MAIL", 4) ? "" : "/noself"),
		   the_subject,
		   my_tmpfile);
    }
d1794 19
a1812 3
    vms_append_addrs(&command, to_address, "");
    if (!isEmpty(ccaddr)) {
	vms_append_addrs(&command, ccaddr, "/CC");
d1817 1
a1817 1
    LYSystem(command);		/* SENDING COMMENT (VMS) */
d1819 1
a1819 1
    LYSleepAlert();
d1821 2
a1822 1
#else /* Unix/DOS/Windows */
d1824 1
a1824 1
     * Send the tmpfile into sendmail.
d1827 2
a1828 6
#if CAN_PIPE_TO_MAILER
    signal(SIGINT, SIG_IGN);
    if ((fp = LYPipeToMailer()) == 0) {
	HTInfoMsg(CANCELLED);
    }
#else
d1831 1
a1832 7
#endif /* CAN_PIPE_TO_MAILER */
    if (fp != 0) {
	fd = fopen(my_tmpfile, TXT_R);
	if (fd == NULL) {
	    HTInfoMsg(CANCELLED);
#if CAN_PIPE_TO_MAILER
	    pclose(fp);
d1834 30
a1863 6
	    LYCloseTempFP(fp);
#endif /* CAN_PIPE_TO_MAILER */
	} else {
#if USE_BLAT_MAILER
	    if (!mail_is_blat)
		fputs(header, fp);
d1865 1
a1865 1
	    fputs(header, fp);
d1867 9
a1875 28
	    while ((n = fread(buf, 1, sizeof(buf), fd)) != 0) {
		fwrite(buf, 1, n, fp);
	    }
#if CAN_PIPE_TO_MAILER
	    pclose(fp);
#else
	    LYCloseTempFP(fp);	/* Close the tmpfile. */
	    LYSendMailFile(to_address,
			   tmpfile2,
			   the_subject,
			   ccaddr,
			   SENDING_COMMENT);
	    LYRemoveTemp(tmpfile2);	/* Delete the tmpfile. */
#endif /* CAN_PIPE_TO_MAILER */
	    LYCloseInput(fd);	/* Close the tmpfile. */
	}
    }
#endif /* USE_VMS_MAILER */
    goto cleanup;

    /*
     * Come here to cleanup and exit.
     */
  cancelled:
    HTInfoMsg(CANCELLED);
    LYCloseTempFP(fd);		/* Close the tmpfile.   */
    scrollok(LYwin, FALSE);	/* Stop scrolling.      */
  cleanup:
d1877 7
d1885 2
a1886 3

#if USE_VMS_MAILER
    while (LYRemoveTemp(my_tmpfile) == 0) ;	/* Delete the tmpfile(s). */
d1888 1
a1888 1
	LYRemoveTemp(hdrfile);	/* Delete the hdrfile. */
a1889 3
#else
    FREE(header);
    LYRemoveTemp(my_tmpfile);	/* Delete the tmpfile. */
d1891 2
a1892 5

    FREE(from_address);
    FREE(the_subject);
    FREE(cc_address);
    FREE(to_address);
d1899 1
a1899 4
/*
 * Check that we have configured values for system mailer.
 */
BOOLEAN LYSystemMail(void)
d1901 10
a1910 3
    if (system_mail == 0 || !strcmp(system_mail, "unknown")) {
	HTAlert(gettext("No system mailer configured"));
	return FALSE;
d1912 11
a1922 1
    return TRUE;
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d1 10
a21 1
#include <LYEdit.h>
a25 2
#define MAX_SUBJECT 70

d27 2
a28 16

PRIVATE void terminate_letter ARGS1(int,sig GCC_UNUSED)
{
    term_letter = TRUE;
    /* Reassert the AST */
    signal(SIGINT, terminate_letter);
#if USE_VMS_MAILER || defined(PDCURSES)
    /*
     *	Refresh the screen to get rid of the "interrupt" message.
     */
    if (!dump_output_immediately) {
	lynx_force_repaint();
	LYrefresh();
    }
#endif /* VMS */
}
d32 1
a32 1
    char *,	string)
d42 1
a42 1
	if ((!LYIsASCII(string[i])) || !isprint(UCH(string[i])))
a51 489
PRIVATE void remove_tildes ARGS1(char *,string)
{
   /*
    *  Change the first character to
    *  a space if it is a '~'.
    */
    if (*string == '~')
	*string = ' ';
}

PRIVATE void comma_append ARGS2(
    char **,	dst,
    char *,	src)
{
    if (*src) {
	while (*src == ',' || isspace(UCH(*src)))
	    src++;
	if (*src) {
	    if (isEmpty(*dst)) {
		StrAllocCopy(*dst, src);
	    } else {
		StrAllocCat(*dst, ",");
		StrAllocCat(*dst, src);
	    }
	}
    }
}

PRIVATE void extract_field ARGS3(
    char **,	dst,
    char *,	src,
    char *,	keyword)
{
    int len = strlen(keyword);
    char *cp, *cp1;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len)) {
	    cp += len;
	    if ((cp1 = strchr(cp, '&')) != NULL) {
		*cp1 = '\0';
	    }
	    comma_append(dst, cp);
	    if (cp1) {
		*cp1 = '&';
		cp = cp1;
		cp1 = NULL;
	    } else {
		break;
	    }
	}
	cp++;
    }
    CTRACE((tfp, "extract_field(%s) = '%s'\n", keyword, NONNULL(*dst)));
}

/*
 * Seek and handle a subject=foo.  - FM
 */
PRIVATE void extract_subject ARGS2(
    char *,	dst,
    char *,	src)
{
    CONST char *keyword = "subject=";
    int len = strlen(keyword);
    char *cp, *cp1;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len))
	    break;
	cp++;
    }
    if (*cp) {
	cp += len;
	if ((cp1 = strchr(cp, '&')) != NULL) {
	    *cp1 = '\0';
	}
	if (*cp) {
	    strncpy(dst, cp, MAX_SUBJECT);
	    dst[MAX_SUBJECT] = '\0';
	    SafeHTUnEscape(dst);
	}
	if (cp1) {
	    *cp1 = '&';
	    cp1 = NULL;
	}
    }
    CTRACE((tfp, "extract_subject(%s) = '%s'\n", keyword, NONNULL(dst)));
}

/*
 * Seek and handle body=foo fields.  - FM
 */
PRIVATE void extract_body ARGS2(
    char **,	dst,
    char *,	src)
{
    CONST char *keyword = "body=";
    int len = strlen(keyword);
    int i;
    char *cp, *cp0, *cp1, *temp = 0;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len)) {
	    cp += len;
	    if ((cp1 = strchr(cp, '&')) != NULL) {
		*cp1 = '\0';
	    }
	    if (*cp) {
		/*
		 *  Break up the value into lines with
		 *  a maximum length of 78. - FM
		 */
		StrAllocCopy(temp, cp);
		HTUnEscape(temp);
		cp0 = temp;
		while((cp = strchr(cp0, '\n')) != NULL) {
		    *cp = '\0';
		    if (cp > cp0) {
			if (*(cp - 1) == '\r') {
			    *(cp - 1) = '\0';
			}
		    }
		    i = 0;
		    len = strlen(cp0);
		    while (len > 78) {
			HTSprintf(dst, "%.78s\n", &cp0[i]);
			i += 78;
			len = strlen(&cp0[i]);
		    }
		    HTSprintf(dst, "%s\n", &cp0[i]);
		    cp0 = (cp + 1);
		}
		i = 0;
		len = strlen(cp0);
		while (len > 78) {
		    HTSprintf(dst, "%.78s\n", &cp0[i]);
		    i += 78;
		    len = strlen(&cp0[i]);
		}
		if (len) {
		    HTSprintf(dst, "%s\n", &cp0[i]);
		}
		FREE(temp);
	    }
	    if (cp1) {
		*cp1 = '&';
		cp = cp1;
		cp1 = NULL;
	    } else {
		break;
	    }
	}
	cp++;
    }
    CTRACE((tfp, "extract_body(%s) = '%s'\n", keyword, NONNULL(*dst)));
}

/*
 * Convert any Explorer semi-colon Internet address separators to commas - FM
 */
PRIVATE BOOLEAN trim_comma ARGS1(
    char *,	address)
{
    if (address[(strlen(address) - 1)] == ',')
	address[(strlen(address) - 1)] = '\0';
    return (BOOL) (*address == '\0');
}

/*
 * Convert any Explorer semi-colon Internet address separators to commas - FM
 */
PRIVATE BOOLEAN convert_explorer ARGS1(
    char *,	address)
{
    char *cp = address;
    char *cp0;
    char *cp1;

    while ((cp1 = strchr(cp, '@@')) != NULL) {
	cp1++;
	if ((cp0 = strchr(cp1, ';')) != NULL) {
	    *cp0 = ',';
	    cp1 = cp0 + 1;
	}
	cp = cp1;
    }
    return trim_comma(address);
}

/*
 * reply_by_mail() prompts line-by-line for header information, allowing
 * scrolling of the screen.
 */
PRIVATE int header_prompt ARGS3(
    char *,		label,
    char **,		result,
    unsigned,		limit)
{
    char buffer[LINESIZE];
    int ok;

    if (*result != 0) {
	LYaddstr(CTRL_U_TO_ERASE);
	LYstrncpy(buffer, *result, sizeof(buffer)-1);
    } else
	*buffer = 0;

    if (limit > sizeof(buffer))
	limit = sizeof(buffer);

    LYaddstr(gettext(label));
    LYaddstr(": ");
    ok = (LYgetstr(buffer, VISIBLE, limit, NORECALL) >= 0
	&& !term_letter);
    LYaddstr("\n");

    if (ok) {
	remove_tildes(buffer);
	StrAllocCopy(*result, buffer);
    }
    term_letter = FALSE;
    return ok;
}

PRIVATE void show_addresses ARGS1(
    char *,	addresses)
{
    char *cp = addresses;
    char *cp1;

    while ((cp1 = strchr(cp, ',')) != NULL) {
	*cp1 = '\0';
	while (*cp == ' ')
	    cp++;
	if (*cp) {
	    LYaddstr(cp);
	    LYaddstr(",\n  ");
	}
	*cp1 = ',';
	cp = (cp1 + 1);
    }
    if (*cp) {
	LYaddstr(cp);
    }
}

#if USE_BLAT_MAILER

/*
syntax:
Blat <filename> -t <recipient> [optional switches (see below)]

<filename>    : file with the message body
-t <recipient>: recipient list (comma separated)
-s <subj>     : subject line
-f <sender>   : overrides the default sender address (must be known to server)
-i <addr>     : a 'From:' address, not necessarily known to the SMTP server.
-c <recipient>: carbon copy recipient list (comma separated)
-b <recipient>: blind carbon copy recipient list (comma separated)
-h            : displays this help.
-mime         : MIME Quoted-Printable Content-Transfer-Encoding.
-q            : supresses *all* output.
-server <addr>: overrides the default SMTP server to be used.

*/

PRIVATE char *blat_cmd(
	char *mail_cmd,
	char *filename,
	char *address,
	char *subject,
	char *ccaddr,
	char *mail_addr)
{
    static char *b_cmd;

#ifdef USE_ALT_BLAT_MAILER

    HTSprintf0(&b_cmd, "%s %s -t \"%s\" -s \"%s\" %s%s%s%s",
		mail_cmd,
		filename,
		address,
		subject,
		system_mail_flags,
		ccaddr? " -c \"" : "",
		NonNull(ccaddr),
		ccaddr? "\"" : "");

#else /* !USE_ALT_BLAT_MAILER */

    static char bl_cmd_file[512];
    FILE *fp;
#ifdef __CYGWIN__
    char dosname[LY_MAXPATH];
#endif

    bl_cmd_file[0] = '\0';
    if ((fp = LYOpenTemp(bl_cmd_file, ".blt", "w")) == NULL) {
	HTAlert(FORM_MAILTO_FAILED);
	return NULL;
    }

#ifdef __CYGWIN__
    cygwin_conv_to_full_win32_path(filename, dosname);
    fprintf(fp, "%s\n", dosname);
#else
    fprintf(fp, "%s\n", filename);
#endif
    fprintf(fp, "-t\n%s\n", address);
    if (subject)
	fprintf(fp, "-s\n%s\n", subject);
    if (!isEmpty(mail_addr)) {
	fprintf(fp, "-f\n%s\n", mail_addr);
    }
    if (!isEmpty(ccaddr)) {
	fprintf(fp, "-c\n%s\n", ccaddr);
    }
    LYCloseOutput(fp);

#ifdef __CYGWIN__
    cygwin_conv_to_full_win32_path(bl_cmd_file, dosname);
    HTSprintf0(&b_cmd, "%s \"@@%s\"", mail_cmd, dosname);
#else
    HTSprintf0(&b_cmd, "%s @@%s", mail_cmd, bl_cmd_file);
#endif

#endif /* USE_ALT_BLAT_MAILER */

    return b_cmd;
}

#endif /* USE_BLAT_MAILER */

#if USE_VMS_MAILER
PUBLIC BOOLEAN LYMailPMDF(void)
{
    return (system_mail != 0)
	    ? !strncasecomp(system_mail, "PMDF SEND", 9)
	    : FALSE;
}

/*
 * Add all of the people in the address field to the command
 */
PRIVATE void vms_append_addrs (char **cmd, char *address, char *option)
{
    BOOLEAN first = TRUE;
    char *cp;
    char *address_ptr1;
    char *address_ptr2;

    address_ptr1 = address;
    do {
	if ((cp = strchr(address_ptr1, ',')) != NULL) {
	    address_ptr2 = (cp+1);
	    *cp = '\0';
	} else {
	    address_ptr2 = NULL;
	}

	/*
	 *  4 letters is arbitrarily the smallest possible mail
	 *  address, at least for lynx.  That way extra spaces
	 *  won't confuse the mailer and give a blank address.
	 */
	if (strlen(address_ptr1) > 3) {
	    if (!first) {
		StrAllocCat(*cmd, ",");
	    }
	    HTSprintf(cmd, mail_adrs, address_ptr1);
	    if (*option && LYMailPMDF())
		StrAllocCat(*cmd, option);
	    first = FALSE;
	}
	address_ptr1 = address_ptr2;
    } while (address_ptr1 != NULL);
}

PRIVATE void remove_quotes (char * string)
{
    while (*string != 0) {
	if (strchr("\"&|", *string) != 0)
	    *string = ' ';
	string++;
    }
}
#else
#if CAN_PIPE_TO_MAILER

/*
 * Open a pipe to the mailer
 */
PUBLIC FILE *LYPipeToMailer NOARGS
{
    char *buffer = NULL;
    FILE *fp = NULL;

    if (LYSystemMail()) {
	HTSprintf0(&buffer, "%s %s", system_mail, system_mail_flags);
	fp = popen(buffer, "w");
	CTRACE((tfp, "popen(%s) %s\n", buffer, fp != 0 ? "OK" : "FAIL"));
	FREE(buffer);
    }
    return fp;
}
#else	/* DOS, Win32, etc. */

PUBLIC int LYSendMailFile ARGS5(
    char *,	the_address,
    char *,	the_filename,
    char *,	the_subject GCC_UNUSED,
    char *,	the_ccaddr GCC_UNUSED,
    char *,	message)
{
    char *cmd = NULL;
#ifdef __DJGPP__
    char *shell;
#endif /* __DJGPP__ */
    int code;

    if (!LYSystemMail())
	return 0;

#if USE_BLAT_MAILER
    if (mail_is_blat)
	StrAllocCopy(cmd,
		blat_cmd(
		    system_mail,
		    the_filename,
		    the_address,
		    the_subject,
		    the_ccaddr,
		    personal_mail_address
		)
	);
    else
#endif
#ifdef __DJGPP__
	if ((shell = LYGetEnv("SHELL")) != NULL) {
	    if (strstr(shell, "sh") != NULL) {
		HTSprintf0(&cmd, "%s -c %s -t \"%s\" -F %s",
			   shell,
			   system_mail,
			   the_address,
			   the_filename);
	    } else {
		HTSprintf0(&cmd, "%s /c %s -t \"%s\" -F %s",
			   shell,
			   system_mail,
			   the_address,
			   the_filename);
	    }
	} else {
	    HTSprintf0(&cmd, "%s -t \"%s\" -F %s",
		       system_mail,
		       the_address,
		       the_filename);
	}
#else
	HTSprintf0(&cmd, "%s -t \"%s\" -F %s",
		   system_mail,
		   the_address,
		   the_filename);
#endif /* __DJGPP__ */

    stop_curses();
    SetOutputMode(O_TEXT);
    printf("%s\n\n$ %s\n\n%s",
	   *message ? message : gettext("Sending"),
	   cmd, PLEASE_WAIT);
    code = LYSystem(cmd);
    LYSleepMsg();
    start_curses();
    SetOutputMode( O_BINARY );

    FREE(cmd);

    return code;
}
#endif /* CAN_PIPE_TO_FILE */
#endif /* USE_VMS_MAILER */

d56 4
a59 4
    CONST char *,	mailto_address,
    CONST char *,	mailto_subject,
    CONST char *,	mailto_content,
    CONST char *,	mailto_type)
a64 3
    char *cp = NULL;
    char self[MAX_SUBJECT + 10];
    char subject[MAX_SUBJECT + 10];
d66 7
a72 4
    char buf[512];
    int ch, len, i;
#if USE_VMS_MAILER
    static char *cmd;
d74 5
a78 1
    BOOLEAN isPMDF = LYMailPMDF();
d80 1
a80 4
#endif
#if !CAN_PIPE_TO_MAILER
    char my_tmpfile[LY_MAXPATH];
#endif
d82 4
a85 7
    CTRACE((tfp, "mailto_address: \"%s\"\n", NONNULL(mailto_address)));
    CTRACE((tfp, "mailto_subject: \"%s\"\n", NONNULL(mailto_subject)));
    CTRACE((tfp, "mailto_content: \"%s\"\n", NONNULL(mailto_content)));
    CTRACE((tfp, "mailto_type:    \"%s\"\n", NONNULL(mailto_type)));

    if (!LYSystemMail())
	return;
d109 20
a128 1
	    extract_subject(subject, searchpart);
d134 26
a159 1
	    extract_field(&address, searchpart, "to=");
d166 28
a193 1
	    extract_field(&ccaddr, searchpart, "cc=");
d198 28
a225 2
	    extract_field(&keywords, searchpart, "keywords=");

d238 19
a256 1
    if (convert_explorer(address)) {
d258 1
a258 1
	goto cleanup;
d261 13
a273 1
	if (convert_explorer(ccaddr)) {
d289 3
a291 3
    if (isEmpty(subject)) {
	if (!isEmpty(mailto_subject)) {
	    LYstrncpy(subject, mailto_subject, MAX_SUBJECT);
d293 2
a294 1
	    sprintf(subject, "mailto:%.63s", address);
d298 1
a298 1
    if ((ch = LYgetstr(subject, VISIBLE, MAX_SUBJECT, NORECALL)) < 0) {
d303 4
a306 1
	goto cleanup;
d314 3
a316 2
	sprintf(self, "%.*s", MAX_SUBJECT,
		isEmpty(personal_mail_address) ? "" : personal_mail_address);
d318 1
a318 1
	if ((ch = LYgetstr(self, VISIBLE, MAX_SUBJECT, NORECALL)) < 0) {
d323 4
a326 1
	    goto cleanup;
d337 1
a337 20
#if CAN_PIPE_TO_MAILER
    if ((fd = LYPipeToMailer()) == 0) {
	HTAlert(FORM_MAILTO_FAILED);
	goto cleanup;
    }

    if (!isEmpty(mailto_type)) {
	fprintf(fd, "Mime-Version: 1.0\n");
	fprintf(fd, "Content-Type: %s\n", mailto_type);
    }
    fprintf(fd, "To: %s\n", address);
    if (!isEmpty(personal_mail_address))
	fprintf(fd, "From: %s\n", personal_mail_address);
    if (!isEmpty(ccaddr))
	fprintf(fd, "Cc: %s\n", ccaddr);
    fprintf(fd, "Subject: %s\n\n", subject);
    if (!isEmpty(keywords))
	fprintf(fd, "Keywords: %s\n", keywords);
    _statusline(SENDING_FORM_CONTENT);
#else	/* e.g., VMS, DOS */
d340 4
a343 1
	goto cleanup;
a344 1
#if USE_VMS_MAILER
a345 1
	FILE *hfd;
d349 4
a352 1
	    goto cleanup;
d354 4
a357 1
	if (!isEmpty(mailto_type)) {
d360 1
a360 1
	    if (!isEmpty(personal_mail_address))
d362 1
a362 10
	}
	/*
	 *  For PMDF, put any keywords and the subject
	 *  in the header file and close it. - FM
	 */
	if (!isEmpty(keywords)) {
	    fprintf(hfd, "Keywords: %s\n", keywords);
	}
	fprintf(hfd, "Subject: %s\n\n", subject);
	LYCloseTempFP(hfd);
d372 10
a381 6
#else	/* !VMS (DOS) */
#if USE_BLAT_MAILER
    if (mail_is_blat) {
	if (strlen(subject) > MAX_SUBJECT)
	    subject[MAX_SUBJECT] = '\0';
    } else
d383 14
a396 9
    {
	if (!isEmpty(mailto_type)) {
	    fprintf(fd, "Mime-Version: 1.0\n");
	    fprintf(fd, "Content-Type: %s\n", mailto_type);
	}
	fprintf(fd,"To: %s\n", address);
	if (!isEmpty(personal_mail_address))
	    fprintf(fd,"From: %s\n", personal_mail_address);
	fprintf(fd,"Subject: %.70s\n\n", subject);
d398 9
a407 1
#endif /* CAN_PIPE_TO_MAILER */
d420 3
a422 3
	    strncpy(buf, &mailto_content[i], 78);
	    buf[78] = '\0';
	    fprintf(fd, "%s\n", buf);
d432 3
a434 3
	strncpy(buf, &mailto_content[i], 78);
	buf[78] = '\0';
	fprintf(fd, "%s\n", buf);
d441 1
a441 1
#if CAN_PIPE_TO_MAILER
d443 3
a445 2
    LYSleepMsg();
#else
d447 1
a447 1
#if USE_VMS_MAILER
d453 9
d464 1
a464 1
	HTSprintf0(&cmd,
d476 2
d479 1
a479 1
	HTSprintf0(&cmd,
d489 64
a552 3
    vms_append_addrs(&command, address, "");
    if (!isEmpty(ccaddr)) {
	vms_append_addrs(&command, ccaddr, "/CC");
d557 1
a557 1
    LYSystem(command);	/* Mail (VMS) */
d559 1
a559 1
    LYSleepAlert();
d562 13
a574 9
    if (isPMDF)
	LYRemoveTemp(hdrfile);
#else /* DOS */
    LYSendMailFile (
	address,
	my_tmpfile,
	subject,
	ccaddr,
	SENDING_FORM_CONTENT);
d576 2
a577 2
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */
a578 1
cleanup:
d591 3
a593 3
	char *,		owner_address,
	char *,		filename,
	char *,		linkname)
d598 2
a599 7
    char *cmd = NULL, *cp;
#ifdef ALERTMAIL
    BOOLEAN skip_parsing = FALSE;
#endif
#if !CAN_PIPE_TO_MAILER
    char *ccaddr;
    char subject[128];
d601 4
d606 1
a606 2
#if USE_VMS_MAILER
    BOOLEAN isPMDF = LYMailPMDF();
d608 1
a608 1
    char *command = NULL;
d610 4
a613 4
    CTRACE((tfp, "mailmsg(%d, \"%s\", \"%s\", \"%s\")\n", cur,
	NONNULL(owner_address),
	NONNULL(filename),
	NONNULL(linkname)));
d615 3
d620 1
a620 1
    if (!LYSystemMail())
a621 5

#ifdef ALERTMAIL
    if (owner_address == NULL) {
	owner_address = ALERTMAIL;
	skip_parsing = TRUE;
d623 1
a623 9
#endif

    if (isEmpty(owner_address))
	return;
    if ((cp = (char *)strchr(owner_address,'\n')) != NULL) {
#ifdef ALERTMAIL
	if (skip_parsing)
	    return;		/* invalidly defined - ignore - kw */
#else
a624 8
#endif
    }
    if (!strncasecomp(owner_address, "lynx-dev@@", 9)) {
	/*
	 *  Silently refuse sending bad link messages to lynx-dev.
	 */
	return;
    }
a626 1
#ifdef ALERTMAIL
d628 1
a628 3
     *  If we are using a fixed address given by ALERTMAIL, it is
     *  supposed to already be in usable form, without URL-isms like
     *  ?-searchpart and URL-escaping.  So skip some code. - kw
d630 10
a639 9
    if (!skip_parsing)
#endif
    {
	/*
	 *	Check for a ?searchpart. - FM
	 */
	if ((cp = strchr(address, '?')) != NULL) {
	    StrAllocCopy(searchpart, cp);
	    *cp = '\0';
d641 24
a664 7
	    if (*cp != '\0') {
		/*
		 * Seek and handle to=address(es) fields.
		 * Appends to address.  We ignore any other
		 * headers in the ?searchpart.  - FM
		 */
		extract_field(&address, searchpart, "to=");
d667 1
d669 12
a680 6
	convert_explorer(address);

	/*
	 *  Unescape the address field. - FM
	 */
	SafeHTUnEscape(address);
d683 7
a689 1
    if (trim_comma(address)) {
d691 2
a692 1
	CTRACE((tfp, "mailmsg: No address in '%s'.\n", owner_address));
d696 3
a698 2
#if CAN_PIPE_TO_MAILER
    if ((fd = LYPipeToMailer()) == 0) {
d700 2
a701 1
	CTRACE((tfp, "mailmsg: '%s' failed.\n", cmd));
d707 1
a707 1
    if (!isEmpty(personal_mail_address)) {
d711 3
a713 2
    fprintf(fd, "X-Mailer: %s, Version %s\n\n", LYNX_NAME, LYNX_VERSION);
#else
d715 2
a716 1
	CTRACE((tfp, "mailmsg: Could not fopen '%s'.\n", my_tmpfile));
a719 3
    sprintf(subject, "Lynx Error in %.56s", filename);
    ccaddr = personal_mail_address;
#if USE_VMS_MAILER
a720 1
	FILE *hfd;
d722 2
a723 1
	    CTRACE((tfp, "mailmsg: Could not fopen '%s'.\n", hdrfile));
d728 1
a728 1
	if (!isEmpty(personal_mail_address)) {
d732 1
a732 7
	fprintf(fd, "X-Mailer: %s, Version %s\n\n", LYNX_NAME, LYNX_VERSION);
	/*
	 *  For PMDF, put the subject in the
	 *  header file and close it. - FM
	 */
	fprintf(hfd, "Subject: Lynx Error in %.56s\n\n", filename);
	LYCloseTempFP(hfd);
d734 1
a734 2
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */
d738 1
a738 1
    fprintf(fd, gettext("called \"%s\"\n"), LYGetHiliteStr(cur, 0));
d744 1
a744 1
    fprintf(fd, "%s %s", LYNX_NAME, LYNX_VERSION);
d746 1
a746 1
	(fp = fopen(LynxSigFile, TXT_R)) != NULL) {
d750 1
a750 1
	LYCloseInput(fp);
d752 1
a752 1
#if CAN_PIPE_TO_MAILER
d754 2
a755 1
#else
d757 1
a757 1
#if USE_VMS_MAILER
d760 6
d774 27
a800 4
    } else {
	/*
	 *  For "generic" VMS MAIL, include the
	 *  subject in the command. - FM
d802 8
a809 8
	HTSprintf0(&command,
		"%s %s/self/subject=\"Lynx Error in %.56s\" %s ",
		system_mail,
		system_mail_flags,
		filename,
		my_tmpfile);
    }
    vms_append_addrs(&command, address, "");
d811 1
a811 1
    LYSystem(command);	/* VMS */
d818 8
a825 7
#else /* DOS */
    LYSendMailFile (
	address,
	my_tmpfile,
	subject,
	ccaddr,
	"");
d827 2
a828 2
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */
d836 1
a836 1
		exit_immediately(EXIT_FAILURE);
d842 1
a842 1
	LYCloseOutput(ofp);
d851 1
a851 1
**  a comment from the users to the owner
d854 2
a855 2
	char *,		mail_address,
	char *,		filename,
d859 1
a859 4
#ifndef NO_ANONYMOUS_EMAIL
    static char *personal_name = NULL;
#endif
    char user_input[LINESIZE];
d861 1
a861 5
    char *label = NULL;
    char *from_address = NULL;
    char *cc_address = NULL;
    char *to_address = NULL;
    char *the_subject = NULL;
d866 3
a868 2
    char *cp = NULL, *cp1 = NULL;
    int i;
d870 5
a874 3
    char my_tmpfile[LY_MAXPATH];
    char default_subject[MAX_SUBJECT + 10];
#if USE_VMS_MAILER
d876 9
a884 1
    BOOLEAN isPMDF = LYMailPMDF();
d886 5
a890 1
    FILE *hfd = 0;
d892 1
a892 4
#if !CAN_PIPE_TO_MAILER
    char tmpfile2[LY_MAXPATH];
#endif
    char buf[4096];	/* 512 */
d895 1
a895 1
#endif /* USE_VMS_MAILER */
d897 5
a901 5
    CTRACE((tfp, "reply_by_mail(\"%s\", \"%s\", \"%s\", \"%s\")\n",
	NONNULL(mail_address),
	NONNULL(filename),
	NONNULL(title),
	NONNULL(refid)));
d905 3
a907 4
    if (!LYSystemMail())
	return;

    if (isEmpty(mail_address)) {
a910 1
    StrAllocCopy(to_address, mail_address);
d916 1
a916 1
#if USE_VMS_MAILER
d924 1
a924 1
    default_subject[0] = '\0';
d929 1
a929 1
    if ((cp = strchr(to_address, '?')) != NULL) {
d937 21
a957 1
	    extract_subject(default_subject, searchpart);
d963 26
a988 1
	    extract_field(&to_address, searchpart, "to=");
d995 28
a1022 1
	    extract_field(&ccaddr, searchpart, "cc=");
d1027 29
a1055 2
	    extract_field(&keywords, searchpart, "keywords=");

d1067 63
a1129 1
	    extract_body(&body, searchpart);
d1135 22
a1156 1
    if (convert_explorer(to_address)) {
d1158 1
a1158 1
	goto cancelled;
d1161 13
a1173 1
	if (convert_explorer(ccaddr)) {
d1181 1
a1181 1
    SafeHTUnEscape(to_address);
d1189 3
a1191 3
    if (isEmpty(default_subject) && !isEmpty(title)) {
	strncpy(default_subject, title, MAX_SUBJECT);
	default_subject[MAX_SUBJECT] = '\0';
d1200 2
a1201 1
#if USE_VMS_MAILER
d1209 2
a1210 2
		isEmpty(filename) ? STR_MAILTO_URL : filename,
		isEmpty(filename) ? to_address : "");
d1212 2
a1213 2
		"X-Mailer: %s, Version %s\n", LYNX_NAME, LYNX_VERSION);
#ifdef NO_ANONYMOUS_EMAIL
d1217 1
a1217 1
#endif /* NO_ANONYMOUS_EMAIL */
d1219 1
a1219 1
#else /* Unix/DOS/Windows */
d1224 3
a1226 1
    HTSprintf(&header, "To: %s\n", to_address);
d1247 1
a1247 1
	    HTSprintf(&header, "Content-Type: text/plain; charset=%s\n",
d1249 1
d1256 7
a1262 4
    if (!isEmpty(filename)) {
	HTSprintf(&header, "X-URL: %s\n", filename);
    } else {
	HTSprintf(&header, "X-URL: mailto:%s\n", to_address);
d1264 3
a1266 1
    HTSprintf(&header, "X-Mailer: %s, Version %s\n", LYNX_NAME, LYNX_VERSION);
d1268 4
a1271 2
    if (!isEmpty(refid)) {
	HTSprintf(&header, "In-Reply-To: <%s>\n", refid);
d1278 3
a1280 3
    LYclear();
    LYmove(2,0);
    scrollok(LYwin, TRUE);	/* Enable scrolling. */
d1282 1
a1282 1
	LYaddstr(SENDING_MESSAGE_WITH_BODY_TO);
d1284 21
a1304 5
	LYaddstr(SENDING_COMMENT_TO);
    show_addresses(to_address);
    if (
#if USE_VMS_MAILER
	(isPMDF == TRUE) &&
a1305 1
	(cp = ccaddr) != NULL)
d1308 1
a1308 1
	    LYaddstr(WITH_COPIES_TO);
d1310 15
a1324 1
	    LYaddstr(WITH_COPY_TO);
a1325 1
	show_addresses(ccaddr);
d1327 1
a1327 1
    LYaddstr(CTRL_G_TO_CANCEL_SEND);
d1329 1
a1329 1
#if USE_VMS_MAILER
d1331 1
a1331 1
#endif /* USE_VMS_MAILER */
d1336 8
a1343 2
    LYaddstr(ENTER_NAME_OR_BLANK);
#if USE_VMS_MAILER
d1345 1
a1345 1
	label = "Personal_name: ";
d1347 1
a1347 1
	label = "X-Personal_name: ";
d1350 18
a1367 8
    label = "X-Personal_Name: ";
#endif /* USE_VMS_MAILER */
    if (!header_prompt(label, &personal_name, LINESIZE)) {
	goto cancelled;
    }
    if (*personal_name) {
#if USE_VMS_MAILER
	fprintf((isPMDF ? hfd : fd), "%s: %s\n", label, personal_name);
d1369 3
a1371 1
	HTSprintf(&header, "%s: %s\n", label, personal_name);
d1378 5
a1382 3
    LYaddstr(ENTER_MAIL_ADDRESS_OR_OTHER);
    LYaddstr(MEANS_TO_CONTACT_FOR_RESPONSE);
#if USE_VMS_MAILER
d1384 1
a1384 1
	label = "From";
d1386 1
a1386 1
	label = "X-From";
d1389 1
a1389 1
    label = "From";
d1392 9
a1400 8
    if (personal_mail_address)
	StrAllocCopy(from_address, personal_mail_address);
    if (!header_prompt(label, &from_address, LINESIZE)) {
	goto cancelled;
    }
#if USE_VMS_MAILER
    if (*from_address) {
	fprintf(isPMDF ? hfd : fd, "%s: %s\n", label, from_address);
d1402 10
a1411 1
    if (!isPMDF) {
d1415 4
a1418 2
    HTSprintf(&header, "%s: %s\n", label, from_address);
#endif /* USE_VMS_MAILER */
d1420 1
a1420 1
#if USE_VMS_MAILER
d1422 1
a1422 1
#endif /* USE_VMS_MAILER */
d1427 20
a1446 11
    LYaddstr(ENTER_SUBJECT_LINE);
    label = "Subject";
    if (*default_subject) {
	StrAllocCopy(the_subject, default_subject);
    } else if (!isEmpty(filename)) {
	HTSprintf(&the_subject, "%s", filename);
    } else {
	HTSprintf(&the_subject, "mailto:%s", to_address);
    }
    if (!header_prompt(label, &the_subject, MAX_SUBJECT)) {
	goto cancelled;
d1448 9
d1461 1
d1463 1
a1463 2
	LYaddstr(ENTER_ADDRESS_FOR_CC);
	LYaddstr(BLANK_FOR_NO_COPY);
d1465 32
a1496 5
	    StrAllocCopy(cc_address, personal_mail_address);
	if (!header_prompt("Cc", &cc_address, LINESIZE)) {
	    goto cancelled;
	}
	comma_append(&ccaddr, cc_address);
d1499 5
a1503 5
#if !USE_VMS_MAILER
    HTSprintf(&header, "%s: %s\n", label, the_subject);
#if !CAN_PIPE_TO_MAILER
    if (*to_address) {
	HTSprintf(&header, "To: %s\n", to_address);
d1507 1
d1511 4
a1514 2
    if (!isEmpty(ccaddr)) {
	HTSprintf(&header, "Cc: %s\n", ccaddr);
d1520 4
a1523 2
    if (!isEmpty(keywords)) {
	HTSprintf(&header, "Keywords: %s\n", keywords);
d1529 3
a1531 2
    StrAllocCat(header, "\n");
    CTRACE((tfp,"**header==\n%s",header));
d1534 5
a1538 1
    if (!no_editor && !isEmpty(editor)) {
d1551 1
a1551 1
	    BOOLEAN is_preparsed = (BOOL) (LYPreparsedSource &&
d1554 1
a1554 1
		? INC_PREPARSED_MSG_PROMPT
d1556 7
a1562 1
		print_wwwfile_to_fd(fd, (BOOL) !is_preparsed);
d1566 1
a1566 1
	scrollok(LYwin,FALSE);	/* Stop scrolling.    */
d1568 1
a1568 1
	if (term_letter || LYCharIsINTERRUPT(c))
d1574 12
a1585 1
	edit_temporary_file(my_tmpfile, "", SPAWNING_EDITOR_FOR_MAIL);
d1591 4
a1594 4
	LYclear();
	LYmove(0,0);
	LYaddstr(REVIEW_MESSAGE_BODY);
	LYrefresh();
d1599 2
a1600 2
		LYaddstr(RETURN_TO_CONTINUE);
		LYrefresh();
d1602 7
a1608 3
		LYaddstr("\n");
		if (term_letter || LYCharIsINTERRUPT(c)) {
		    goto cancelled;
d1614 2
a1615 2
	    LYaddstr(cp1);
	    LYaddstr("\n");
d1620 1
a1620 1
	    LYaddstr("\n");
d1623 1
a1623 1
	LYrefresh();
d1625 1
a1625 1
	scrollok(LYwin,FALSE);	/* Stop scrolling.	  */
d1631 5
a1635 5
	LYaddstr(ENTER_MESSAGE_BELOW);
	LYaddstr(ENTER_PERIOD_WHEN_DONE_A);
	LYaddstr(ENTER_PERIOD_WHEN_DONE_B);
	LYaddstr("\n\n");
	LYrefresh();
d1639 4
a1642 1
	    goto cancelled;
d1646 1
a1646 1
	    LYaddstr("\n");
d1652 4
a1655 1
		goto cancelled;
d1661 1
a1661 1
	scrollok(LYwin,FALSE);	/* Stop scrolling.	  */
d1664 1
a1664 1
#if !USE_VMS_MAILER
d1674 1
a1674 1
	LYclear();  /* clear the screen */
d1678 1
a1678 1
	(fp = fopen(LynxSigFile, TXT_R)) != NULL) {
d1691 1
a1691 1
	    if ((fd = fopen(my_tmpfile, TXT_A)) != NULL) {
d1697 1
a1697 2
		LYCloseOutput(fd);
		FREE(buffer);
d1700 1
a1700 1
	LYCloseInput(fp);
d1702 1
a1702 1
    LYclear();  /* Clear the screen. */
d1707 1
a1707 1
#if USE_VMS_MAILER
d1716 1
a1716 1
	if (!isEmpty(keywords)) {
d1719 1
a1719 1
	fprintf(hfd, "Subject: %s\n\n", the_subject);
d1724 2
a1725 1
	HTSprintf0(&command, "%s %s %s,%s ",
d1736 2
d1739 2
a1740 1
	HTSprintf0(&command, "%s %s%s/subject=\"%s\" %s ",
d1744 1
a1744 1
		the_subject,
d1747 46
d1794 19
a1812 3
    vms_append_addrs(&command, to_address, "");
    if (!isEmpty(ccaddr)) {
	vms_append_addrs(&command, ccaddr, "/CC");
d1817 1
a1817 1
    LYSystem(command);	/* SENDING COMMENT (VMS) */
d1819 1
a1819 1
    LYSleepAlert();
d1821 2
a1822 1
#else /* Unix/DOS/Windows */
d1827 2
a1828 6
#if CAN_PIPE_TO_MAILER
    signal(SIGINT, SIG_IGN);
    if ((fp = LYPipeToMailer()) == 0) {
	HTInfoMsg(CANCELLED);
    }
#else
d1831 1
a1832 7
#endif /* CAN_PIPE_TO_MAILER */
    if (fp != 0) {
	fd = fopen(my_tmpfile, TXT_R);
	if (fd == NULL) {
	    HTInfoMsg(CANCELLED);
#if CAN_PIPE_TO_MAILER
	    pclose(fp);
d1834 30
a1863 6
	    LYCloseTempFP(fp);
#endif /* CAN_PIPE_TO_MAILER */
	} else {
#if USE_BLAT_MAILER
	    if (!mail_is_blat)
		fputs(header, fp);
d1865 1
a1865 1
	    fputs(header, fp);
d1867 4
a1870 20
	    while ((n = fread(buf, 1, sizeof(buf), fd)) != 0) {
		fwrite(buf, 1, n, fp);
	    }
#if CAN_PIPE_TO_MAILER
	    pclose(fp);
#else
	    LYCloseTempFP(fp);	/* Close the tmpfile. */
	    LYSendMailFile (
		to_address,
		tmpfile2,
		the_subject,
		ccaddr,
		SENDING_COMMENT);
	    LYRemoveTemp(tmpfile2);	/* Delete the tmpfile. */
#endif /* CAN_PIPE_TO_MAILER */
	    LYCloseInput(fd); /* Close the tmpfile. */
	}
    }
#endif /* USE_VMS_MAILER */
    goto cleanup;
a1874 4
cancelled:
    HTInfoMsg(CANCELLED);
    LYCloseTempFP(fd);		/* Close the tmpfile.	*/
    scrollok(LYwin,FALSE);	/* Stop scrolling.	*/
d1877 7
d1885 2
a1886 4

#if USE_VMS_MAILER
    while (LYRemoveTemp(my_tmpfile) == 0)
	;		 /* Delete the tmpfile(s). */
d1888 1
a1888 1
	LYRemoveTemp(hdrfile); /* Delete the hdrfile. */
a1889 3
#else
    FREE(header);
    LYRemoveTemp(my_tmpfile);  /* Delete the tmpfile. */
d1891 2
a1892 5

    FREE(from_address);
    FREE(the_subject);
    FREE(cc_address);
    FREE(to_address);
d1899 1
a1899 4
/*
 * Check that we have configured values for system mailer.
 */
PUBLIC BOOLEAN LYSystemMail NOARGS
d1901 10
a1910 3
    if (system_mail == 0 || !strcmp(system_mail, "unknown")) {
	HTAlert(gettext("No system mailer configured"));
	return FALSE;
d1912 11
a1922 1
    return TRUE;
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d21 1
a21 1
static void terminate_letter (int sig GCC_UNUSED)
d38 2
a39 2
static void SafeHTUnEscape (
    char *	string)
d59 1
a59 1
static void remove_tildes (char *string)
d69 3
a71 3
static void comma_append (
    char **	dst,
    char *	src)
d87 4
a90 4
static void extract_field (
    char **	dst,
    char *	src,
    char *	keyword)
d120 3
a122 3
static void extract_subject (
    char *	dst,
    char *	src)
d124 1
a124 1
    const char *keyword = "subject=";
d156 3
a158 3
static void extract_body (
    char **	dst,
    char *	src)
d160 1
a160 1
    const char *keyword = "body=";
d226 2
a227 2
static BOOLEAN trim_comma (
    char *	address)
d237 2
a238 2
static BOOLEAN convert_explorer (
    char *	address)
d259 4
a262 4
static int header_prompt (
    char *		label,
    char **		result,
    unsigned		limit)
d290 2
a291 2
static void show_addresses (
    char *	addresses)
d332 1
a332 1
static char *blat_cmd(
d400 1
a400 1
BOOLEAN LYMailPMDF(void)
d410 1
a410 1
static void vms_append_addrs (char **cmd, char *address, char *option)
d444 1
a444 1
static void remove_quotes (char * string)
d458 1
a458 1
FILE *LYPipeToMailer (void)
d473 6
a478 6
int LYSendMailFile (
    char *	the_address,
    char *	the_filename,
    char *	the_subject GCC_UNUSED,
    char *	the_ccaddr GCC_UNUSED,
    char *	message)
d551 5
a555 5
void mailform (
    const char *	mailto_address,
    const char *	mailto_subject,
    const char *	mailto_content,
    const char *	mailto_type)
d880 5
a884 5
void mailmsg (
	int		cur,
	char *		owner_address,
	char *		filename,
	char *		linkname)
d1110 5
a1114 5
void reply_by_mail (
	char *		mail_address,
	char *		filename,
	const char *	title,
	const char *	refid)
d1490 1
a1490 1
		print_wwwfile_to_fd(fd, TRUE, (BOOL) !is_preparsed);
d1750 1
a1750 1
BOOLEAN LYSystemMail (void)
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d13 1
a13 1
#include <LYCharSets.h>		/* to get current charset for mail header */
d19 1
a19 1
BOOLEAN term_letter;		/* Global variable for async i/o. */
d21 1
a21 1
static void terminate_letter(int sig GCC_UNUSED)
d28 1
a28 1
     * Refresh the screen to get rid of the "interrupt" message.
d38 2
a39 1
static void SafeHTUnEscape(char *string)
d41 2
a42 2
    int i;
    int flg = FALSE;
d44 3
a46 2
    HTUnEscape(string);
    for (i = 0; string[i] != '\0'; i++) {
d49 4
a52 3
	if ((!LYIsASCII(string[i])) || !isprint(UCH(string[i]))) {
	    string[i] = '?';
	    flg = TRUE;
d54 2
a55 2
    }
    if (flg)
d59 1
a59 1
static void remove_tildes(char *string)
d61 4
a64 3
    /*
     * Change the first character to a space if it is a '~'.
     */
d69 3
a71 2
static void comma_append(char **dst,
			 char *src)
d87 4
a90 3
static void extract_field(char **dst,
			  char *src,
			  char *keyword)
d120 3
a122 2
static void extract_subject(char *dst,
			    char *src)
d156 3
a158 2
static void extract_body(char **dst,
			 char *src)
d175 2
a176 2
		 * Break up the value into lines with a maximum length of 78. 
		 * - FM
d181 1
a181 1
		while ((cp = strchr(cp0, '\n')) != NULL) {
d226 2
a227 1
static BOOLEAN trim_comma(char *address)
d237 2
a238 1
static BOOLEAN convert_explorer(char *address)
d259 4
a262 3
static int header_prompt(char *label,
			 char **result,
			 unsigned limit)
d269 1
a269 1
	LYstrncpy(buffer, *result, sizeof(buffer) - 1);
d279 1
a279 1
	  && !term_letter);
d290 2
a291 1
static void show_addresses(char *addresses)
d332 7
a338 6
static char *blat_cmd(char *mail_cmd,
		      char *filename,
		      char *address,
		      char *subject,
		      char *ccaddr,
		      char *mail_addr)
d345 8
a352 8
	       mail_cmd,
	       filename,
	       address,
	       subject,
	       system_mail_flags,
	       ccaddr ? " -c \"" : "",
	       NonNull(ccaddr),
	       ccaddr ? "\"" : "");
a357 1

d367 1
d403 2
a404 2
	? !strncasecomp(system_mail, "PMDF SEND", 9)
	: FALSE;
d410 1
a410 1
static void vms_append_addrs(char **cmd, char *address, char *option)
d420 1
a420 1
	    address_ptr2 = (cp + 1);
d427 3
a429 3
	 * 4 letters is arbitrarily the smallest possible mail address, at
	 * least for lynx.  That way extra spaces won't confuse the mailer and
	 * give a blank address.
d444 1
a444 1
static void remove_quotes(char *string)
d458 1
a458 1
FILE *LYPipeToMailer(void)
d471 1
a471 1
#else /* DOS, Win32, etc. */
d473 6
a478 5
int LYSendMailFile(char *the_address,
		   char *the_filename,
		   char *the_subject GCC_UNUSED,
		   char *the_ccaddr GCC_UNUSED,
		   char *message)
a480 1

d492 9
a500 8
		     blat_cmd(system_mail,
			      the_filename,
			      the_address,
			      the_subject,
			      the_ccaddr,
			      personal_mail_address
		     )
	    );
d504 14
a517 7
    if ((shell = LYGetEnv("SHELL")) != NULL) {
	if (strstr(shell, "sh") != NULL) {
	    HTSprintf0(&cmd, "%s -c %s -t \"%s\" -F %s",
		       shell,
		       system_mail,
		       the_address,
		       the_filename);
d519 1
a519 2
	    HTSprintf0(&cmd, "%s /c %s -t \"%s\" -F %s",
		       shell,
a523 6
    } else {
	HTSprintf0(&cmd, "%s -t \"%s\" -F %s",
		   system_mail,
		   the_address,
		   the_filename);
    }
d539 1
a539 1
    SetOutputMode(O_BINARY);
d549 7
a555 6
 *  mailform() sends form content to the mailto address(es). - FM
 */
void mailform(const char *mailto_address,
	      const char *mailto_subject,
	      const char *mailto_content,
	      const char *mailto_type)
a566 1

d592 1
a592 1
    if ((cp = (char *) strchr(mailto_address, '\n')) != NULL)
d597 1
a597 1
     * Check for a ?searchpart.  - FM
d605 1
a605 1
	     * Seek and handle a subject=foo.  - FM
d610 2
a611 2
	     * Seek and handle to=address(es) fields.  Appends to address.  -
	     * FM
d616 3
a618 3
	     * Seek and handle cc=address(es) fields.  Excludes Bcc=address(es)
	     * as unsafe.  We may append our own cc (below) as a list for the
	     * actual mailing.  - FM
d623 1
a623 1
	     * Seek and handle keywords=term(s) fields.  - FM
d650 1
a650 1
     * Unescape the address and ccaddr fields.  - FM
d658 1
a658 1
     * Allow user to edit the default Subject - FM
d677 2
a678 1
     * Allow user to specify a self copy via a CC:  entry, if permitted.  - FM
d699 1
d719 1
a719 1
#else /* e.g., VMS, DOS */
a726 1

d739 2
a740 2
	 * For PMDF, put any keywords and the subject in the header file and
	 * close it.  - FM
d750 3
a752 3
	 * Ugh!  There's no good way to include headers while we're still using
	 * "generic" VMS MAIL, so we'll put this in the body of the message.  -
	 * FM
d756 1
a756 1
#else /* !VMS (DOS) */
d768 1
a768 1
	fprintf(fd, "To: %s\n", address);
d770 2
a771 2
	    fprintf(fd, "From: %s\n", personal_mail_address);
	fprintf(fd, "Subject: %.70s\n\n", subject);
d777 4
a780 4
     * Break up the content into lines with a maximum length of 78.  If the
     * ENCTYPE was text/plain, we have physical newlines and should take them
     * into account.  Otherwise, the actual newline characters in the content
     * are hex escaped.  - FM
d782 1
a782 1
    while ((cp = strchr(mailto_content, '\n')) != NULL) {
d794 1
a794 1
	mailto_content = (cp + 1);
d815 1
a815 1
     * Set the mail command.  - FM
d819 1
a819 1
	 * Now set up the command.  - FM
d822 5
a826 5
		   "%s %s %s,%s ",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_tmpfile);
d829 4
a832 3
	 * For "generic" VMS MAIL, include the subject in the command, and
	 * ignore any keywords to minimize risk of them making the line too
	 * long or having problem characters.  - FM
d835 6
a840 6
		   "%s %s%s/subject=\"%s\" %s ",
		   system_mail,
		   system_mail_flags,
		   (strncasecomp(system_mail, "MAIL", 4) ? "" : "/noself"),
		   subject,
		   my_tmpfile);
d851 1
a851 1
    LYSystem(command);		/* Mail (VMS) */
d859 6
a864 5
    LYSendMailFile(address,
		   my_tmpfile,
		   subject,
		   ccaddr,
		   SENDING_FORM_CONTENT);
d869 1
a869 1
  cleanup:
d877 8
a884 7
 *  mailmsg() sends a message to the owner of the file, if one is defined,
 *  telling of errors (i.e., link not available).
 */
void mailmsg(int cur,
	     char *owner_address,
	     char *filename,
	     char *linkname)
a889 1

d904 3
a906 3
	    NONNULL(owner_address),
	    NONNULL(filename),
	    NONNULL(linkname)));
d922 1
a922 1
    if ((cp = (char *) strchr(owner_address, '\n')) != NULL) {
d932 1
a932 1
	 * Silently refuse sending bad link messages to lynx-dev.
d940 3
a942 3
     * If we are using a fixed address given by ALERTMAIL, it is supposed to
     * already be in usable form, without URL-isms like ?-searchpart and
     * URL-escaping.  So skip some code.  - kw
d948 1
a948 1
	 * Check for a ?searchpart.  - FM
d967 1
a967 1
	 * Unescape the address field.  - FM
d977 1
a1002 1

d1015 2
a1016 1
	 * For PMDF, put the subject in the header file and close it.  - FM
d1025 1
a1025 1
	    links[cur].lname, links[cur].target);
d1047 1
a1047 1
	 * Now set up the command.  - FM
d1050 5
a1054 5
		   "%s %s %s,%s ",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_tmpfile);
d1057 2
a1058 1
	 * For "generic" VMS MAIL, include the subject in the command.  - FM
d1061 5
a1065 5
		   "%s %s/self/subject=\"Lynx Error in %.56s\" %s ",
		   system_mail,
		   system_mail_flags,
		   filename,
		   my_tmpfile);
d1069 1
a1069 1
    LYSystem(command);		/* VMS */
d1077 6
a1082 5
    LYSendMailFile(address,
		   my_tmpfile,
		   subject,
		   ccaddr,
		   "");
d1098 1
a1098 1
		links[cur].lname, links[cur].target, filename);
d1107 8
a1114 7
 *  reply_by_mail() invokes sendmail on Unix or mail on VMS to send
 *  a comment from the users to the owner
 */
void reply_by_mail(char *mail_address,
		   char *filename,
		   const char *title,
		   const char *refid)
d1132 1
a1132 1
    int c = 0;			/* user input */
a1134 1

a1139 1

d1144 1
a1144 1
    char buf[4096];		/* 512 */
d1150 4
a1153 4
	    NONNULL(mail_address),
	    NONNULL(filename),
	    NONNULL(title),
	    NONNULL(refid)));
d1181 1
a1181 1
     * Check for a ?searchpart.  - FM
d1189 1
a1189 1
	     * Seek and handle a subject=foo.  - FM
d1194 2
a1195 2
	     * Seek and handle to=address(es) fields.  Appends to address.  -
	     * FM
d1200 3
a1202 3
	     * Seek and handle cc=address(es) fields.  Excludes Bcc=address(es)
	     * as unsafe.  We may append our own cc (below) as a list for the
	     * actual mailing.  - FM
d1207 1
a1207 1
	     * Seek and handle keywords=term(s) fields.  - FM
d1220 1
a1220 1
	     * Seek and handle body=foo fields.  - FM
d1239 1
a1239 1
     * Unescape the address and ccaddr fields.  - FM
d1247 1
a1247 1
     * Set the default subject.  - FM
d1255 2
a1256 1
     * Use ^G to cancel mailing of comment and don't let SIGINTs exit lynx.
d1263 2
a1264 2
	 * Put the X-URL and X-Mailer lines in the hdrfile for PMDF or
	 * my_tmpfile for VMS MAIL.  - FM
d1280 1
a1280 1
     * Put the To:  line in the header.
d1287 10
a1296 7
     * Put the Mime-Version, Content-Type and Content-Transfer-Encoding in the
     * header.  This assumes that the same character set is used for composing
     * the mail which is currently selected as display character set...  Don't
     * send a charset if we have a CJK character set selected, since it may not
     * be appropriate for mail...  Also don't use an unofficial "x-" charset. 
     * Also if the charset would be "us-ascii" (7-bit replacements selected,
     * don't send any MIME headers.  - kw
d1305 1
a1305 1
		      LYCharSet_UC[current_char_set].MIMEname);
d1310 1
a1310 1
     * Put the X-URL and X-Mailer lines in the header.
d1325 1
a1325 1
     * Clear the screen and inform the user.
d1328 1
a1328 1
    LYmove(2, 0);
d1337 1
a1337 1
	   (isPMDF == TRUE) &&
d1339 2
a1340 1
	   (cp = ccaddr) != NULL) {
d1354 4
a1357 4
	/*
	 * Get the user's personal name.
	 */
	LYaddstr(ENTER_NAME_OR_BLANK);
d1359 5
a1363 5
	if (isPMDF) {
	    label = "Personal_name: ";
	} else {
	    label = "X-Personal_name: ";
	}
d1365 1
a1365 1
	label = "X-Personal_Name: ";
d1367 4
a1370 4
	if (!header_prompt(label, &personal_name, LINESIZE)) {
	    goto cancelled;
	}
	if (*personal_name) {
d1372 1
a1372 1
	    fprintf((isPMDF ? hfd : fd), "%s: %s\n", label, personal_name);
d1374 1
a1374 1
	    HTSprintf(&header, "%s: %s\n", label, personal_name);
d1376 1
a1376 1
	}
d1378 5
a1382 5
	/*
	 * Get the user's return address.
	 */
	LYaddstr(ENTER_MAIL_ADDRESS_OR_OTHER);
	LYaddstr(MEANS_TO_CONTACT_FOR_RESPONSE);
d1384 5
a1388 5
	if (isPMDF) {
	    label = "From";
	} else {
	    label = "X-From";
	}
d1390 1
a1390 1
	label = "From";
d1392 6
a1397 6
	/* Add the personal mail address if there is one. */
	if (personal_mail_address)
	    StrAllocCopy(from_address, personal_mail_address);
	if (!header_prompt(label, &from_address, LINESIZE)) {
	    goto cancelled;
	}
d1399 6
a1404 6
	if (*from_address) {
	    fprintf(isPMDF ? hfd : fd, "%s: %s\n", label, from_address);
	}
	if (!isPMDF) {
	    fprintf(fd, "\n");
	}
d1406 1
a1406 1
	HTSprintf(&header, "%s: %s\n", label, from_address);
d1414 1
a1414 1
     * Get the subject line.
d1430 1
a1430 1
     * Offer a CC line, if permitted.  - FM
d1442 1
d1452 2
a1453 2
     * Add the Cc:  header.  - FM
     */
d1459 2
a1460 2
     * Add the Keywords:  header.  - FM
     */
d1466 1
a1466 1
     * Terminate the header.
d1469 1
a1469 1
    CTRACE((tfp, "**header==\n%s", header));
d1476 1
a1476 1
	    while ((cp = strchr(cp1, '\n')) != NULL) {
d1483 1
a1483 1
	     * Ask if the user wants to include the original message.
d1486 1
a1486 2
					   HTisDocumentSource());

d1488 2
a1489 2
			  ? INC_PREPARSED_MSG_PROMPT
			  : INC_ORIG_MSG_PROMPT) == YES) {
d1494 1
a1494 1
	scrollok(LYwin, FALSE);	/* Stop scrolling.    */
d1500 1
a1500 1
	 * Spawn the users editor on the mail file
d1506 1
a1506 1
	 * Let user review the body.  - FM
d1509 1
a1509 1
	LYmove(0, 0);
d1514 1
a1514 1
	while ((cp = strchr(cp1, '\n')) != NULL) {
d1537 2
a1538 2
	LYCloseTempFP(fd);	/* Close the tmpfile.     */
	scrollok(LYwin, FALSE);	/* Stop scrolling.        */
d1542 1
a1542 1
	 * Use the internal line editor for the message.
d1567 2
a1568 2
	LYCloseTempFP(fd);	/* Close the tmpfile.     */
	scrollok(LYwin, FALSE);	/* Stop scrolling.        */
d1573 1
a1573 1
     * Ignore CTRL-C on this last question.
d1578 1
a1578 1
    c = HTConfirm(body ? SEND_MESSAGE_PROMPT : SEND_COMMENT_PROMPT);
d1581 1
a1581 1
	LYclear();		/* clear the screen */
a1591 1

a1599 1

d1610 1
a1610 1
    LYclear();			/* Clear the screen. */
d1613 1
a1613 1
     * Send the message.
d1617 1
a1617 1
     * Set the mail command.  - FM
d1621 2
a1622 2
	 * For PMDF, put any keywords and the subject in the header file and
	 * close it.  - FM
d1630 1
a1630 1
	 * Now set up the command.  - FM
d1633 4
a1636 4
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_tmpfile);
d1639 4
a1642 3
	 * For "generic" VMS MAIL, include the subject in the command, and
	 * ignore any keywords to minimize risk of them making the line too
	 * long or having problem characters.  - FM
d1645 5
a1649 5
		   system_mail,
		   system_mail_flags,
		   (strncasecomp(system_mail, "MAIL", 4) ? "" : "/noself"),
		   the_subject,
		   my_tmpfile);
d1659 1
a1659 1
    LYSystem(command);		/* SENDING COMMENT (VMS) */
d1665 1
a1665 1
     * Send the tmpfile into sendmail.
d1701 6
a1706 5
	    LYSendMailFile(to_address,
			   tmpfile2,
			   the_subject,
			   ccaddr,
			   SENDING_COMMENT);
d1709 1
a1709 1
	    LYCloseInput(fd);	/* Close the tmpfile. */
d1716 1
a1716 1
     * Come here to cleanup and exit.
d1718 1
a1718 1
  cancelled:
d1720 3
a1722 3
    LYCloseTempFP(fd);		/* Close the tmpfile.   */
    scrollok(LYwin, FALSE);	/* Stop scrolling.      */
  cleanup:
d1727 2
a1728 1
    while (LYRemoveTemp(my_tmpfile) == 0) ;	/* Delete the tmpfile(s). */
d1730 1
a1730 1
	LYRemoveTemp(hdrfile);	/* Delete the hdrfile. */
d1734 1
a1734 1
    LYRemoveTemp(my_tmpfile);	/* Delete the tmpfile. */
d1750 1
a1750 1
BOOLEAN LYSystemMail(void)
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 10
a21 1
#include <LYEdit.h>
a25 4
#define MAX_SUBJECT 70
#define EMPTY(s) ((s) == 0 || *(s) == 0)
#define NIL_OK(s) (((s) != 0) ? (s) : "<nil>")

d27 2
a28 16

PRIVATE void terminate_letter ARGS1(int,sig GCC_UNUSED)
{
    term_letter = TRUE;
    /* Reassert the AST */
    signal(SIGINT, terminate_letter);
#if USE_VMS_MAILER || defined(DOSPATH) || defined(WIN_EX)
    /*
     *	Refresh the screen to get rid of the "interrupt" message.
     */
    if (!dump_output_immediately) {
	lynx_force_repaint();
	LYrefresh();
    }
#endif /* VMS */
}
d32 1
a32 1
    char *,	string)
d42 1
a42 1
	if ((!LYIsASCII(string[i])) || !isprint(UCH(string[i])))
a51 456
PRIVATE void remove_tildes ARGS1(char *,string)
{
   /*
    *  Change the first character to
    *  a space if it is a '~'.
    */
    if (*string == '~')
	*string = ' ';
}

PRIVATE void comma_append ARGS2(
    char **,	dst,
    char *,	src)
{
    if (*src) {
	while (*src == ',' || isspace(UCH(*src)))
	    src++;
	if (*src) {
	    if (EMPTY(*dst)) {
		StrAllocCopy(*dst, src);
	    } else {
		StrAllocCat(*dst, ",");
		StrAllocCat(*dst, src);
	    }
	}
    }
}

PRIVATE void extract_field ARGS3(
    char **,	dst,
    char *,	src,
    char *,	keyword)
{
    int len = strlen(keyword);
    char *cp, *cp1;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len)) {
	    cp += len;
	    if ((cp1 = strchr(cp, '&')) != NULL) {
		*cp1 = '\0';
	    }
	    comma_append(dst, cp);
	    if (cp1) {
		*cp1 = '&';
		cp = cp1;
		cp1 = NULL;
	    } else {
		break;
	    }
	}
	cp++;
    }
    CTRACE((tfp, "extract_field(%s) = '%s'\n", keyword, NIL_OK(*dst)));
}

/*
 * Seek and handle a subject=foo.  - FM
 */
PRIVATE void extract_subject ARGS2(
    char *,	dst,
    char *,	src)
{
    CONST char *keyword = "subject=";
    int len = strlen(keyword);
    char *cp, *cp1;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len))
	    break;
	cp++;
    }
    if (*cp) {
	cp += len;
	if ((cp1 = strchr(cp, '&')) != NULL) {
	    *cp1 = '\0';
	}
	if (*cp) {
	    strncpy(dst, cp, MAX_SUBJECT);
	    dst[MAX_SUBJECT] = '\0';
	    SafeHTUnEscape(dst);
	}
	if (cp1) {
	    *cp1 = '&';
	    cp1 = NULL;
	}
    }
    CTRACE((tfp, "extract_subject(%s) = '%s'\n", keyword, NIL_OK(dst)));
}

/*
 * Seek and handle body=foo fields.  - FM
 */
PRIVATE void extract_body ARGS2(
    char **,	dst,
    char *,	src)
{
    CONST char *keyword = "body=";
    int len = strlen(keyword);
    int i;
    char *cp, *cp0, *cp1, *temp = 0;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len)) {
	    cp += len;
	    if ((cp1 = strchr(cp, '&')) != NULL) {
		*cp1 = '\0';
	    }
	    if (*cp) {
		/*
		 *  Break up the value into lines with
		 *  a maximum length of 78. - FM
		 */
		StrAllocCopy(temp, cp);
		HTUnEscape(temp);
		cp0 = temp;
		while((cp = strchr(cp0, '\n')) != NULL) {
		    *cp = '\0';
		    if (cp > cp0) {
			if (*(cp - 1) == '\r') {
			    *(cp - 1) = '\0';
			}
		    }
		    i = 0;
		    len = strlen(cp0);
		    while (len > 78) {
			HTSprintf(dst, "%.78s\n", &cp0[i]);
			i += 78;
			len = strlen(&cp0[i]);
		    }
		    HTSprintf(dst, "%s\n", &cp0[i]);
		    cp0 = (cp + 1);
		}
		i = 0;
		len = strlen(cp0);
		while (len > 78) {
		    HTSprintf(dst, "%.78s\n", &cp0[i]);
		    i += 78;
		    len = strlen(&cp0[i]);
		}
		if (len) {
		    HTSprintf(dst, "%s\n", &cp0[i]);
		}
		FREE(temp);
	    }
	    if (cp1) {
		*cp1 = '&';
		cp = cp1;
		cp1 = NULL;
	    } else {
		break;
	    }
	}
	cp++;
    }
    CTRACE((tfp, "extract_body(%s) = '%s'\n", keyword, NIL_OK(*dst)));
}

/*
 * Convert any Explorer semi-colon Internet address separators to commas - FM
 */
PRIVATE BOOLEAN trim_comma ARGS1(
    char *,	address)
{
    if (address[(strlen(address) - 1)] == ',')
	address[(strlen(address) - 1)] = '\0';
    return (BOOL) (*address == '\0');
}

/*
 * Convert any Explorer semi-colon Internet address separators to commas - FM
 */
PRIVATE BOOLEAN convert_explorer ARGS1(
    char *,	address)
{
    char *cp = address;
    char *cp0;
    char *cp1;

    while ((cp1 = strchr(cp, '@@')) != NULL) {
	cp1++;
	if ((cp0 = strchr(cp1, ';')) != NULL) {
	    *cp0 = ',';
	    cp1 = cp0 + 1;
	}
	cp = cp1;
    }
    return trim_comma(address);
}

/*
 * reply_by_mail() prompts line-by-line for header information, allowing
 * scrolling of the screen.
 */
PRIVATE int header_prompt ARGS3(
    char *,		label,
    char **,		result,
    unsigned,		limit)
{
    char buffer[LINESIZE];
    int ok;

    if (*result != 0) {
	LYaddstr(CTRL_U_TO_ERASE);
	LYstrncpy(buffer, *result, sizeof(buffer)-1);
    } else
	*buffer = 0;

    if (limit > sizeof(buffer))
	limit = sizeof(buffer);

    LYaddstr(gettext(label));
    LYaddstr(": ");
    ok = (LYgetstr(buffer, VISIBLE, limit, NORECALL) >= 0
	&& !term_letter);
    LYaddstr("\n");

    if (ok) {
	remove_tildes(buffer);
	StrAllocCopy(*result, buffer);
    }
    term_letter = FALSE;
    return ok;
}

PRIVATE void show_addresses ARGS1(
    char *,	addresses)
{
    char *cp = addresses;
    char *cp1;

    while ((cp1 = strchr(cp, ',')) != NULL) {
	*cp1 = '\0';
	while (*cp == ' ')
	    cp++;
	if (*cp) {
	    LYaddstr(cp);
	    LYaddstr(",\n  ");
	}
	*cp1 = ',';
	cp = (cp1 + 1);
    }
    if (*cp) {
	LYaddstr(cp);
    }
}

#if USE_BLAT_MAILER

/*
syntax:
Blat <filename> -t <recipient> [optional switches (see below)]

<filename>    : file with the message body
-t <recipient>: recipient list (comma separated)
-s <subj>     : subject line
-f <sender>   : overrides the default sender address (must be known to server)
-i <addr>     : a 'From:' address, not necessarily known to the SMTP server.
-c <recipient>: carbon copy recipient list (comma separated)
-b <recipient>: blind carbon copy recipient list (comma separated)
-h            : displays this help.
-mime         : MIME Quoted-Printable Content-Transfer-Encoding.
-q            : supresses *all* output.
-server <addr>: overrides the default SMTP server to be used.

*/

PRIVATE char *blat_cmd(
	char *mail_cmd,
	char *filename,
	char *address,
	char *subject,
	char *ccaddr,
	char *mail_addr)
{
    static char *b_cmd;

#ifdef USE_ALT_BLAT_MAILER

    HTSprintf0(&b_cmd, "%s %s -t \"%s\" -s \"%s\" %s%s%s%s",
		mail_cmd,
		filename,
		address,
		subject,
		system_mail_flags,
		ccaddr? " -c \"" : "",
		ccaddr? ccaddr : "",
		ccaddr? "\"" : "");

#else /* !USE_ALT_BLAT_MAILER */

    static char bl_cmd_file[512];
    FILE *fp;
#ifdef __CYGWIN__
    char dosname[LY_MAXPATH];
#endif

    bl_cmd_file[0] = '\0';
    if ((fp = LYOpenTemp(bl_cmd_file, ".blt", "w")) == NULL) {
	HTAlert(FORM_MAILTO_FAILED);
	return NULL;
    }

#ifdef __CYGWIN__
    cygwin_conv_to_full_win32_path(filename, dosname);
    fprintf(fp, "%s\n", dosname);
#else
    fprintf(fp, "%s\n", filename);
#endif
    fprintf(fp, "-t\n%s\n", address);
    if (subject)
	fprintf(fp, "-s\n%s\n", subject);
    if (!EMPTY(mail_addr)) {
	fprintf(fp, "-f\n%s\n", mail_addr);
    }
    if (!EMPTY(ccaddr)) {
	fprintf(fp, "-c\n%s\n", ccaddr);
    }
    LYCloseOutput(fp);

#ifdef __CYGWIN__
    cygwin_conv_to_full_win32_path(bl_cmd_file, dosname);
    HTSprintf0(&b_cmd, "%s \"@@%s\"", mail_cmd, dosname);
#else
    HTSprintf0(&b_cmd, "%s @@%s", mail_cmd, bl_cmd_file);
#endif

#endif /* USE_ALT_BLAT_MAILER */

    return b_cmd;
}

#endif /* USE_BLAT_MAILER */

#if USE_VMS_MAILER
PUBLIC BOOLEAN LYMailPMDF(void)
{
    return !strncasecomp(system_mail, "PMDF SEND", 9);
}

/*
 * Add all of the people in the address field to the command
 */
PRIVATE void vms_append_addrs (char **cmd, char *address, char *option)
{
    BOOLEAN first = TRUE;
    char *cp;
    char *address_ptr1;
    char *address_ptr2;

    address_ptr1 = address;
    do {
	if ((cp = strchr(address_ptr1, ',')) != NULL) {
	    address_ptr2 = (cp+1);
	    *cp = '\0';
	} else {
	    address_ptr2 = NULL;
	}

	/*
	 *  4 letters is arbitrarily the smallest possible mail
	 *  address, at least for lynx.  That way extra spaces
	 *  won't confuse the mailer and give a blank address.
	 */
	if (strlen(address_ptr1) > 3) {
	    if (!first) {
		StrAllocCat(*cmd, ",");
	    }
	    HTSprintf(cmd, mail_adrs, address_ptr1);
	    if (*option && LYMailPMDF())
		StrAllocCat(*cmd, option);
	    first = FALSE;
	}
	address_ptr1 = address_ptr2;
    } while (address_ptr1 != NULL);
}

PRIVATE void remove_quotes (char * string)
{
    while (*string != 0) {
	if (strchr("\"&|", *string) != 0)
	    *string = ' ';
	string++;
    }
}
#else
#if CAN_PIPE_TO_MAILER

/*
 * Open a pipe to the mailer
 */
PUBLIC FILE *LYPipeToMailer NOARGS
{
    char *buffer = NULL;
    FILE *fp;

    HTSprintf0(&buffer, "%s %s", system_mail, system_mail_flags);
    fp = popen(buffer, "w");
    CTRACE((tfp, "popen(%s) %s\n", buffer, fp != 0 ? "OK" : "FAIL"));
    FREE(buffer);
    return fp;
}
#else	/* DOS, Win32, etc. */

PUBLIC int LYSendMailFile ARGS5(
    char *,	the_address,
    char *,	the_filename,
    char *,	the_subject GCC_UNUSED,
    char *,	the_ccaddr GCC_UNUSED,
    char *,	message)
{
    char *cmd = NULL;
    int code;

#if USE_BLAT_MAILER
    if (mail_is_blat)
	StrAllocCopy(cmd,
		blat_cmd(
		    system_mail,
		    the_filename,
		    the_address,
		    the_subject,
		    the_ccaddr,
		    personal_mail_address
		)
	);
    else
#endif
	HTSprintf0(&cmd, "%s -t \"%s\" -F %s",
		   system_mail,
		   the_address,
		   the_filename);

    stop_curses();
    SetOutputMode(O_TEXT);
    printf("%s\n\n$ %s\n\n%s",
	   *message ? message : gettext("Sending"),
	   cmd, PLEASE_WAIT);
    code = LYSystem(cmd);
    LYSleepMsg();
    start_curses();
    SetOutputMode( O_BINARY );

    FREE(cmd);

    return code;
}
#endif /* CAN_PIPE_TO_FILE */
#endif /* USE_VMS_MAILER */

d56 4
a59 4
    CONST char *, 	mailto_address,
    CONST char *, 	mailto_subject,
    CONST char *, 	mailto_content,
    CONST char *, 	mailto_type)
a64 3
    char *cp = NULL;
    char self[MAX_SUBJECT + 10];
    char subject[MAX_SUBJECT + 10];
d66 7
a72 4
    char buf[512];
    int ch, len, i;
#if USE_VMS_MAILER
    static char *cmd;
d74 5
a78 1
    BOOLEAN isPMDF = LYMailPMDF();
d80 1
a80 4
#endif
#if !CAN_PIPE_TO_MAILER
    char my_tmpfile[LY_MAXPATH];
#endif
d82 4
a85 5
    CTRACE((tfp, "mailform(\"%s\", \"%s\", \"%s\", \"%s\")\n",
	NIL_OK(mailto_address),
	NIL_OK(mailto_subject),
	NIL_OK(mailto_content),
	NIL_OK(mailto_type)));
d109 20
a128 1
	    extract_subject(subject, searchpart);
d134 26
a159 1
	    extract_field(&address, searchpart, "to=");
d166 28
a193 1
	    extract_field(&ccaddr, searchpart, "cc=");
d198 28
a225 2
	    extract_field(&keywords, searchpart, "keywords=");

d238 19
a256 1
    if (convert_explorer(address)) {
d258 1
a258 1
	goto cleanup;
d261 13
a273 1
	if (convert_explorer(ccaddr)) {
d289 3
a291 3
    if (EMPTY(subject)) {
	if (!EMPTY(mailto_subject)) {
	    LYstrncpy(subject, mailto_subject, MAX_SUBJECT);
d293 2
a294 1
	    sprintf(subject, "mailto:%.63s", address);
d298 1
a298 1
    if ((ch = LYgetstr(subject, VISIBLE, MAX_SUBJECT, NORECALL)) < 0) {
d303 4
a306 1
	goto cleanup;
d314 3
a316 2
	sprintf(self, "%.*s", MAX_SUBJECT,
		EMPTY(personal_mail_address) ? "" : personal_mail_address);
d318 1
a318 1
	if ((ch = LYgetstr(self, VISIBLE, MAX_SUBJECT, NORECALL)) < 0) {
d323 4
a326 1
	    goto cleanup;
d337 1
a337 20
#if CAN_PIPE_TO_MAILER
    if ((fd = LYPipeToMailer()) == 0) {
	HTAlert(FORM_MAILTO_FAILED);
	goto cleanup;
    }

    if (!EMPTY(mailto_type)) {
	fprintf(fd, "Mime-Version: 1.0\n");
	fprintf(fd, "Content-Type: %s\n", mailto_type);
    }
    fprintf(fd, "To: %s\n", address);
    if (!EMPTY(personal_mail_address))
	fprintf(fd, "From: %s\n", personal_mail_address);
    if (!EMPTY(ccaddr))
	fprintf(fd, "Cc: %s\n", ccaddr);
    fprintf(fd, "Subject: %s\n\n", subject);
    if (!EMPTY(keywords))
	fprintf(fd, "Keywords: %s\n", keywords);
    _statusline(SENDING_FORM_CONTENT);
#else	/* e.g., VMS, DOSPATH */
d340 4
a343 1
	goto cleanup;
a344 1
#if USE_VMS_MAILER
a345 1
	FILE *hfd;
d349 4
a352 1
	    goto cleanup;
d354 4
a357 1
	if (!EMPTY(mailto_type)) {
d360 1
a360 1
	    if (!EMPTY(personal_mail_address))
d362 1
a362 10
	}
	/*
	 *  For PMDF, put any keywords and the subject
	 *  in the header file and close it. - FM
	 */
	if (!EMPTY(keywords)) {
	    fprintf(hfd, "Keywords: %s\n", keywords);
	}
	fprintf(hfd, "Subject: %s\n\n", subject);
	LYCloseTempFP(hfd);
d372 10
a381 6
#else	/* !VMS (DOS) */
#if USE_BLAT_MAILER
    if (mail_is_blat) {
	if (strlen(subject) > MAX_SUBJECT)
	    subject[MAX_SUBJECT] = '\0';
    } else
d383 14
a396 9
    {
	if (!EMPTY(mailto_type)) {
	    fprintf(fd, "Mime-Version: 1.0\n");
	    fprintf(fd, "Content-Type: %s\n", mailto_type);
	}
	fprintf(fd,"To: %s\n", address);
	if (!EMPTY(personal_mail_address))
	    fprintf(fd,"From: %s\n", personal_mail_address);
	fprintf(fd,"Subject: %.70s\n\n", subject);
d398 9
a407 1
#endif /* CAN_PIPE_TO_MAILER */
d420 3
a422 3
	    strncpy(buf, &mailto_content[i], 78);
	    buf[78] = '\0';
	    fprintf(fd, "%s\n", buf);
d432 3
a434 3
	strncpy(buf, &mailto_content[i], 78);
	buf[78] = '\0';
	fprintf(fd, "%s\n", buf);
d441 1
a441 1
#if CAN_PIPE_TO_MAILER
d443 3
a445 2
    LYSleepMsg();
#else
d447 1
a447 1
#if USE_VMS_MAILER
d453 9
d464 1
a464 1
	HTSprintf0(&cmd,
d476 2
d479 1
a479 1
	HTSprintf0(&cmd,
d489 64
a552 3
    vms_append_addrs(&command, address, "");
    if (!EMPTY(ccaddr)) {
	vms_append_addrs(&command, ccaddr, "/CC");
d557 1
a557 1
    LYSystem(command);	/* Mail (VMS) */
d559 1
a559 1
    LYSleepAlert();
d562 1
a562 2
    if (isPMDF)
	LYRemoveTemp(hdrfile);
d564 11
a574 6
    LYSendMailFile (
	address,
	my_tmpfile,
	subject,
	ccaddr,
	SENDING_FORM_CONTENT);
d576 2
a577 2
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */
a578 1
cleanup:
d598 2
a599 7
    char *cmd = NULL, *cp;
#ifdef ALERTMAIL
    BOOLEAN skip_parsing = FALSE;
#endif
#if !CAN_PIPE_TO_MAILER
    char *ccaddr;
    char subject[128];
d601 4
d606 1
a606 2
#if USE_VMS_MAILER
    BOOLEAN isPMDF = LYMailPMDF();
d608 1
a608 1
    char *command = NULL;
d610 4
a613 4
    CTRACE((tfp, "mailmsg(%d, \"%s\", \"%s\", \"%s\")\n", cur,
	NIL_OK(owner_address),
	NIL_OK(filename),
	NIL_OK(linkname)));
d615 3
a619 7
#ifdef ALERTMAIL
    if (owner_address == NULL) {
	owner_address = ALERTMAIL;
	skip_parsing = TRUE;
    }
#endif

d623 1
a623 5
    if ((cp = (char *)strchr(owner_address,'\n')) != NULL) {
#ifdef ALERTMAIL
	if (skip_parsing)
	    return;		/* invalidly defined - ignore - kw */
#else
a624 8
#endif
    }
    if (!strncasecomp(owner_address, "lynx-dev@@", 9)) {
	/*
	 *  Silently refuse sending bad link messages to lynx-dev.
	 */
	return;
    }
a626 1
#ifdef ALERTMAIL
d628 1
a628 3
     *  If we are using a fixed address given by ALERTMAIL, it is
     *  supposed to already be in usable form, without URL-isms like
     *  ?-searchpart and URL-escaping.  So skip some code. - kw
d630 10
a639 9
    if (!skip_parsing)
#endif
    {
	/*
	 *	Check for a ?searchpart. - FM
	 */
	if ((cp = strchr(address, '?')) != NULL) {
	    StrAllocCopy(searchpart, cp);
	    *cp = '\0';
d641 24
a664 7
	    if (*cp != '\0') {
		/*
		 * Seek and handle to=address(es) fields.
		 * Appends to address.  We ignore any other
		 * headers in the ?searchpart.  - FM
		 */
		extract_field(&address, searchpart, "to=");
d667 1
d669 12
a680 6
	convert_explorer(address);

	/*
	 *  Unescape the address field. - FM
	 */
	SafeHTUnEscape(address);
d683 7
a689 1
    if (trim_comma(address)) {
d691 2
a692 1
	CTRACE((tfp, "mailmsg: No address in '%s'.\n", owner_address));
d696 3
a698 2
#if CAN_PIPE_TO_MAILER
    if ((fd = LYPipeToMailer()) == 0) {
d700 2
a701 1
	CTRACE((tfp, "mailmsg: '%s' failed.\n", cmd));
d707 1
a707 1
    if (!EMPTY(personal_mail_address)) {
d711 3
a713 2
    fprintf(fd, "X-Mailer: %s, Version %s\n\n", LYNX_NAME, LYNX_VERSION);
#else
d715 2
a716 1
	CTRACE((tfp, "mailmsg: Could not fopen '%s'.\n", my_tmpfile));
a719 3
    sprintf(subject, "Lynx Error in %.56s", filename);
    ccaddr = personal_mail_address;
#if USE_VMS_MAILER
a720 1
	FILE *hfd;
d722 2
a723 1
	    CTRACE((tfp, "mailmsg: Could not fopen '%s'.\n", hdrfile));
d728 1
a728 1
	if (!EMPTY(personal_mail_address)) {
d732 1
a732 7
	fprintf(fd, "X-Mailer: %s, Version %s\n\n", LYNX_NAME, LYNX_VERSION);
	/*
	 *  For PMDF, put the subject in the
	 *  header file and close it. - FM
	 */
	fprintf(hfd, "Subject: Lynx Error in %.56s\n\n", filename);
	LYCloseTempFP(hfd);
d734 1
a734 2
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */
d744 1
a744 1
    fprintf(fd, "%s %s", LYNX_NAME, LYNX_VERSION);
d746 1
a746 1
	(fp = fopen(LynxSigFile, TXT_R)) != NULL) {
d750 1
a750 1
	LYCloseInput(fp);
d752 1
a752 1
#if CAN_PIPE_TO_MAILER
d754 2
a755 1
#else
d757 1
a757 1
#if USE_VMS_MAILER
d760 6
d774 27
a800 4
    } else {
	/*
	 *  For "generic" VMS MAIL, include the
	 *  subject in the command. - FM
d802 8
a809 8
	HTSprintf0(&command,
		"%s %s/self/subject=\"Lynx Error in %.56s\" %s ",
		system_mail,
		system_mail_flags,
		filename,
		my_tmpfile);
    }
    vms_append_addrs(&command, address, "");
d811 1
a811 1
    LYSystem(command);	/* VMS */
d819 7
a825 6
    LYSendMailFile (
	address,
	my_tmpfile,
	subject,
	ccaddr,
	"");
d827 2
a828 2
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */
d836 1
a836 1
		exit_immediately(EXIT_FAILURE);
d842 1
a842 1
	LYCloseOutput(ofp);
d851 1
a851 1
**  a comment from the users to the owner
d859 1
a859 4
#ifndef NO_ANONYMOUS_EMAIL
    static char *personal_name = NULL;
#endif
    char user_input[LINESIZE];
d861 1
a861 5
    char *label = NULL;
    char *from_address = NULL;
    char *cc_address = NULL;
    char *to_address = NULL;
    char *the_subject = NULL;
d866 3
a868 2
    char *cp = NULL, *cp1 = NULL;
    int i;
d870 5
a874 1
    char my_tmpfile[LY_MAXPATH];
d876 9
a884 3
    char default_subject[MAX_SUBJECT + 10];
#if USE_VMS_MAILER
    BOOLEAN isPMDF = LYMailPMDF();
d886 5
a890 1
    FILE *hfd = 0;
d892 1
a892 4
#if !CAN_PIPE_TO_MAILER
    char tmpfile2[LY_MAXPATH];
#endif
    char buf[4096];	/* 512 */
d895 1
a895 1
#endif /* USE_VMS_MAILER */
d897 5
a901 5
    CTRACE((tfp, "reply_by_mail(\"%s\", \"%s\", \"%s\", \"%s\")\n",
	NIL_OK(mail_address),
	NIL_OK(filename),
	NIL_OK(title),
	NIL_OK(refid)));
d905 3
a907 1
    if (EMPTY(mail_address)) {
a910 1
    StrAllocCopy(to_address, mail_address);
d916 1
a916 1
#if USE_VMS_MAILER
d924 1
a924 1
    default_subject[0] = '\0';
d929 1
a929 1
    if ((cp = strchr(to_address, '?')) != NULL) {
d937 21
a957 1
	    extract_subject(default_subject, searchpart);
d963 26
a988 1
	    extract_field(&to_address, searchpart, "to=");
d995 28
a1022 1
	    extract_field(&ccaddr, searchpart, "cc=");
d1027 29
a1055 2
	    extract_field(&keywords, searchpart, "keywords=");

d1067 63
a1129 1
	    extract_body(&body, searchpart);
d1135 22
a1156 1
    if (convert_explorer(to_address)) {
d1158 1
a1158 1
	goto cancelled;
d1161 13
a1173 1
	if (convert_explorer(ccaddr)) {
d1181 1
a1181 1
    SafeHTUnEscape(to_address);
d1189 3
a1191 3
    if (EMPTY(default_subject) && !EMPTY(title)) {
	strncpy(default_subject, title, MAX_SUBJECT);
	default_subject[MAX_SUBJECT] = '\0';
d1200 2
a1201 1
#if USE_VMS_MAILER
d1209 2
a1210 2
		EMPTY(filename) ? "mailto:" : filename,
		EMPTY(filename) ? to_address : "");
d1212 2
a1213 2
		"X-Mailer: %s, Version %s\n", LYNX_NAME, LYNX_VERSION);
#ifdef NO_ANONYMOUS_EMAIL
d1217 1
a1217 1
#endif /* NO_ANONYMOUS_EMAIL */
d1219 1
a1219 1
#else /* Unix/DOS/Windows */
d1224 3
a1226 1
    HTSprintf(&header, "To: %s\n", to_address);
d1247 1
a1247 1
	    HTSprintf(&header, "Content-Type: text/plain; charset=%s\n",
d1249 1
d1256 7
a1262 4
    if (!EMPTY(filename)) {
	HTSprintf(&header, "X-URL: %s\n", filename);
    } else {
	HTSprintf(&header, "X-URL: mailto:%s\n", to_address);
d1264 3
a1266 1
    HTSprintf(&header, "X-Mailer: %s, Version %s\n", LYNX_NAME, LYNX_VERSION);
d1268 4
a1271 2
    if (!EMPTY(refid)) {
	HTSprintf(&header, "In-Reply-To: <%s>\n", refid);
d1278 3
a1280 3
    LYclear();
    LYmove(2,0);
    scrollok(LYwin, TRUE);	/* Enable scrolling. */
d1282 1
a1282 1
	LYaddstr(SENDING_MESSAGE_WITH_BODY_TO);
d1284 21
a1304 5
	LYaddstr(SENDING_COMMENT_TO);
    show_addresses(to_address);
    if (
#if USE_VMS_MAILER
	(isPMDF == TRUE) &&
a1305 1
	(cp = ccaddr) != NULL)
d1308 1
a1308 1
	    LYaddstr(WITH_COPIES_TO);
d1310 15
a1324 1
	    LYaddstr(WITH_COPY_TO);
a1325 1
	show_addresses(ccaddr);
d1327 1
a1327 1
    LYaddstr(CTRL_G_TO_CANCEL_SEND);
d1329 1
a1329 1
#if USE_VMS_MAILER
d1331 1
a1331 1
#endif /* USE_VMS_MAILER */
d1336 8
a1343 2
    LYaddstr(ENTER_NAME_OR_BLANK);
#if USE_VMS_MAILER
d1345 1
a1345 1
	label = "Personal_name: ";
d1347 1
a1347 1
	label = "X-Personal_name: ";
d1350 18
a1367 8
    label = "X-Personal_Name: ";
#endif /* USE_VMS_MAILER */
    if (!header_prompt(label, &personal_name, LINESIZE)) {
	goto cancelled;
    }
    if (*personal_name) {
#if USE_VMS_MAILER
	fprintf((isPMDF ? hfd : fd), "%s: %s\n", label, personal_name);
d1369 3
a1371 1
	HTSprintf(&header, "%s: %s\n", label, personal_name);
d1378 5
a1382 3
    LYaddstr(ENTER_MAIL_ADDRESS_OR_OTHER);
    LYaddstr(MEANS_TO_CONTACT_FOR_RESPONSE);
#if USE_VMS_MAILER
d1384 1
a1384 1
	label = "From";
d1386 1
a1386 1
	label = "X-From";
d1389 1
a1389 1
    label = "From";
d1392 9
a1400 8
    if (personal_mail_address)
	StrAllocCopy(from_address, personal_mail_address);
    if (!header_prompt(label, &from_address, LINESIZE)) {
	goto cancelled;
    }
#if USE_VMS_MAILER
    if (*from_address) {
	fprintf(isPMDF ? hfd : fd, "%s: %s\n", label, from_address);
d1402 10
a1411 1
    if (!isPMDF) {
d1415 4
a1418 2
    HTSprintf(&header, "%s: %s\n", label, from_address);
#endif /* USE_VMS_MAILER */
d1420 1
a1420 1
#if USE_VMS_MAILER
d1422 1
a1422 1
#endif /* USE_VMS_MAILER */
d1427 20
a1446 11
    LYaddstr(ENTER_SUBJECT_LINE);
    label = "Subject";
    if (*default_subject) {
	StrAllocCopy(the_subject, default_subject);
    } else if (!EMPTY(filename)) {
	HTSprintf(&the_subject, "%s", filename);
    } else {
	HTSprintf(&the_subject, "mailto:%s", to_address);
    }
    if (!header_prompt(label, &the_subject, MAX_SUBJECT)) {
	goto cancelled;
d1448 9
d1461 1
d1463 1
a1463 2
	LYaddstr(ENTER_ADDRESS_FOR_CC);
	LYaddstr(BLANK_FOR_NO_COPY);
d1465 32
a1496 5
	    StrAllocCopy(cc_address, personal_mail_address);
	if (!header_prompt("Cc", &cc_address, LINESIZE)) {
	    goto cancelled;
	}
	comma_append(&ccaddr, cc_address);
d1499 5
a1503 5
#if !USE_VMS_MAILER
    HTSprintf(&header, "%s: %s\n", label, the_subject);
#if !CAN_PIPE_TO_MAILER
    if (*to_address) {
	HTSprintf(&header, "To: %s\n", to_address);
d1507 1
d1511 4
a1514 2
    if (!EMPTY(ccaddr)) {
	HTSprintf(&header, "Cc: %s\n", ccaddr);
d1520 4
a1523 2
    if (!EMPTY(keywords)) {
	HTSprintf(&header, "Keywords: %s\n", keywords);
d1529 3
a1531 2
    StrAllocCat(header, "\n");
    CTRACE((tfp,"**header==\n%s",header));
d1534 5
a1538 1
    if (!no_editor && !EMPTY(editor)) {
d1551 1
a1551 1
	    BOOLEAN is_preparsed = (BOOL) (LYPreparsedSource &&
d1556 7
a1562 1
		print_wwwfile_to_fd(fd, (BOOL) !is_preparsed);
d1566 1
a1566 1
	scrollok(LYwin,FALSE);	/* Stop scrolling.    */
d1568 1
a1568 1
	if (term_letter || LYCharIsINTERRUPT(c))
d1574 12
a1585 1
	edit_temporary_file(my_tmpfile, "", SPAWNING_EDITOR_FOR_MAIL);
d1591 4
a1594 4
	LYclear();
	LYmove(0,0);
	LYaddstr(REVIEW_MESSAGE_BODY);
	LYrefresh();
d1599 2
a1600 2
		LYaddstr(RETURN_TO_CONTINUE);
		LYrefresh();
d1602 7
a1608 3
		LYaddstr("\n");
		if (term_letter || LYCharIsINTERRUPT(c)) {
		    goto cancelled;
d1614 2
a1615 2
	    LYaddstr(cp1);
	    LYaddstr("\n");
d1620 1
a1620 1
	    LYaddstr("\n");
d1623 1
a1623 1
	LYrefresh();
d1625 1
a1625 1
	scrollok(LYwin,FALSE);	/* Stop scrolling.	  */
d1631 5
a1635 5
	LYaddstr(ENTER_MESSAGE_BELOW);
	LYaddstr(ENTER_PERIOD_WHEN_DONE_A);
	LYaddstr(ENTER_PERIOD_WHEN_DONE_B);
	LYaddstr("\n\n");
	LYrefresh();
d1639 4
a1642 1
	    goto cancelled;
d1646 1
a1646 1
	    LYaddstr("\n");
d1652 4
a1655 1
		goto cancelled;
d1661 1
a1661 1
	scrollok(LYwin,FALSE);	/* Stop scrolling.	  */
d1664 1
a1664 1
#if !USE_VMS_MAILER
d1674 1
a1674 1
	LYclear();  /* clear the screen */
d1678 1
a1678 1
	(fp = fopen(LynxSigFile, TXT_R)) != NULL) {
d1691 1
a1691 1
	    if ((fd = fopen(my_tmpfile, TXT_A)) != NULL) {
d1697 1
a1697 2
		LYCloseOutput(fd);
		FREE(buffer);
d1700 1
a1700 1
	LYCloseInput(fp);
d1702 1
a1702 1
    LYclear();  /* Clear the screen. */
d1707 1
a1707 1
#if USE_VMS_MAILER
d1716 1
a1716 1
	if (!EMPTY(keywords)) {
d1719 1
a1719 1
	fprintf(hfd, "Subject: %s\n\n", the_subject);
d1724 2
a1725 1
	HTSprintf0(&command, "%s %s %s,%s ",
d1736 2
d1739 2
a1740 1
	HTSprintf0(&command, "%s %s%s/subject=\"%s\" %s ",
d1744 1
a1744 1
		the_subject,
d1747 46
d1794 19
a1812 3
    vms_append_addrs(&command, to_address, "");
    if (!EMPTY(ccaddr)) {
	vms_append_addrs(&command, ccaddr, "/CC");
d1817 1
a1817 1
    LYSystem(command);	/* SENDING COMMENT (VMS) */
d1819 1
a1819 1
    LYSleepAlert();
d1821 2
a1822 1
#else /* Unix/DOS/Windows */
d1827 2
a1828 7
#if CAN_PIPE_TO_MAILER
    signal(SIGINT, SIG_IGN);
    if ((fp = LYPipeToMailer()) == 0) {
	HTInfoMsg(CANCELLED);
    }
    FREE(command);
#else
d1831 1
a1832 7
#endif /* CAN_PIPE_TO_MAILER */
    if (fp != 0) {
	fd = fopen(my_tmpfile, TXT_R);
	if (fd == NULL) {
	    HTInfoMsg(CANCELLED);
#if CAN_PIPE_TO_MAILER
	    pclose(fp);
d1834 30
a1863 6
	    LYCloseTempFP(fp);
#endif /* CAN_PIPE_TO_MAILER */
	} else {
#if USE_BLAT_MAILER
	    if (!mail_is_blat)
		fputs(header, fp);
d1865 1
a1865 1
	    fputs(header, fp);
d1867 4
a1870 20
	    while ((n = fread(buf, 1, sizeof(buf), fd)) != 0) {
		fwrite(buf, 1, n, fp);
	    }
#if CAN_PIPE_TO_MAILER
	    pclose(fp);
#else
	    LYCloseTempFP(fp);	/* Close the tmpfile. */
	    LYSendMailFile (
		to_address,
		tmpfile2,
		the_subject,
		ccaddr,
		SENDING_COMMENT);
	    LYRemoveTemp(tmpfile2);	/* Delete the tmpfile. */
#endif /* CAN_PIPE_TO_MAILER */
	    LYCloseInput(fd); /* Close the tmpfile. */
	}
    }
#endif /* USE_VMS_MAILER */
    goto cleanup;
a1874 4
cancelled:
    HTInfoMsg(CANCELLED);
    LYCloseTempFP(fd);		/* Close the tmpfile.	*/
    scrollok(LYwin,FALSE); 	/* Stop scrolling.	*/
d1877 7
d1885 1
a1885 2

#if USE_VMS_MAILER
a1886 2
    while (LYRemoveTemp(my_tmpfile) == 0)
	;		 /* Delete the tmpfile(s). */
d1888 1
a1888 1
	LYRemoveTemp(hdrfile); /* Delete the hdrfile. */
a1889 3
#else
    FREE(header);
    LYRemoveTemp(my_tmpfile);  /* Delete the tmpfile. */
d1891 2
a1892 5

    FREE(from_address);
    FREE(the_subject);
    FREE(cc_address);
    FREE(to_address);
d1897 26
@

