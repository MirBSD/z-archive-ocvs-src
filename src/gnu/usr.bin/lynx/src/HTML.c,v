head	1.11;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.10
	tg-mergefixes-1-branch:1.10.0.4
	tg-mergefixes-1-base:1.10
	MIROS_X:1.10.0.2
	MIROS_X_BASE:1.10
	MIRBSD_XP_MIRPPC:1.8.0.4
	lynx-2_8_6dev_7b:1.1.3.8
	lynx-2_8_6dev_6:1.1.3.7
	MIRBSD_XP_SPARC_BASE:1.8
	MIRBSD_XP_SPARC:1.8.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.6
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.4
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.3
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.4.0.6
	MIRBSD_7:1.4.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.4
	MIRBSD_7_DEV:1.4.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2005.01.03.00.45.54;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.20.10.26.25;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.11.20.30.39;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.23.05.43.50;	author tg;	state Stab;
branches;
next	1.7;

1.7
date	2004.07.15.18.16.49;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.30.16.32.30;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.18.16.56.05;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.27.13.12.42;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.27;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.26;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.17;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.29;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.21;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.46.11;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.01.18.15.34.42;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.16.01;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.53.05;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.07.15.16.06.04;	author tg;	state Exp;
branches;
next	1.1.3.7;

1.1.3.7
date	2004.10.11.20.16.24;	author tg;	state Exp;
branches;
next	1.1.3.8;

1.1.3.8
date	2004.10.20.10.10.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.11
log
@soft merge
@
text
@/*		Structured stream to Rich hypertext converter
 *		============================================
 *
 *	This generates a hypertext object.  It converts from the
 *	structured stream interface of HTML events into the style-
 *	oriented interface of the HText.h interface.  This module is
 *	only used in clients and should not be linked into servers.
 *
 *	Override this module if making a new GUI browser.
 *
 *   Being Overidden
 *
 */

#include <HTUtils.h>

#define Lynx_HTML_Handler
#include <HTChunk.h>
#include <HText.h>
#include <HTStyle.h>
#include <HTML.h>

#include <HTCJK.h>
#include <HTAtom.h>
#include <HTAnchor.h>
#include <HTMLGen.h>
#include <HTParse.h>
#include <HTList.h>
#include <UCMap.h>
#include <UCDefs.h>
#include <UCAux.h>

#include <LYGlobalDefs.h>
#include <LYCharUtils.h>
#include <LYCharSets.h>

#include <HTAlert.h>
#include <HTForms.h>
#include <HTNestedList.h>
#include <GridText.h>
#include <LYStrings.h>
#include <LYUtils.h>
#include <LYMap.h>
#include <LYList.h>
#include <LYBookmark.h>

#ifdef VMS
#include <LYCurses.h>
#endif /* VMS */

#ifdef USE_PRETTYSRC
#include <LYPrettySrc.h>
#endif

#ifdef USE_COLOR_STYLE
#include <SGML.h>
#include <AttrList.h>
#include <LYHash.h>
#include <LYStyle.h>
#undef SELECTED_STYLES
#define pHText_changeStyle(X,Y,Z) {}

#if OMIT_SCN_KEEPING
# define HCODE_TO_STACK_OFF(x) /*(CSHASHSIZE+1)*/ 88888		/*special value. */
#else
# define HCODE_TO_STACK_OFF(x) x	/*pass computed value */
#endif

#endif /* USE_COLOR_STYLE */

#ifdef USE_SOURCE_CACHE
#include <HTAccess.h>
#endif

#include <LYCurses.h>
#include <LYJustify.h>

#include <LYexit.h>
#include <LYLeaks.h>

#define STACKLEVEL(me) ((me->stack + MAX_NESTING - 1) - me->sp)

#define DFT_TEXTAREA_COLS 60
#define DFT_TEXTAREA_ROWS 4

#define MAX_TEXTAREA_COLS LYcolLimit
#define MAX_TEXTAREA_ROWS (3 * LYlines)

#define LimitValue(name, value) \
 	if (name > value) { \
		CTRACE((tfp, "Limited " #name " to %d, was %d\n", \
			value, name)); \
		name = value; \
	}

struct _HTStream {
    const HTStreamClass *isa;
#ifdef USE_SOURCE_CACHE
    HTParentAnchor *anchor;
    FILE *fp;
    char *filename;
    HTChunk *chunk;
    const HTStreamClass *actions;
    HTStream *target;
    int status;
#else
    /* .... */
#endif
};

static HTStyleSheet *styleSheet = NULL;		/* Application-wide */

/*	Module-wide style cache
*/
static HTStyle *styles[HTML_ELEMENTS + LYNX_HTML_EXTRA_ELEMENTS];

					   /* adding 24 nested list styles  */
					   /* and 3 header alignment styles */
					   /* and 3 div alignment styles    */
static HTStyle *default_style = NULL;

const char *LYToolbarName = "LynxPseudoToolbar";

/* used to turn off a style if the HTML author forgot to
static int i_prior_style = -1;
 */

/*
 *	Private function....
 */
static int HTML_end_element(HTStructured * me, int element_number,
			    char **include);

static int HTML_start_element(HTStructured * me, int element_number,
			      const BOOL *present,
			      const char **value,
			      int tag_charset,
			      char **include);

/*
 * If we have verbose_img set, display labels for images.
 */
#define VERBOSE_IMG(value,src_type,string) \
      ((verbose_img) ? (newtitle = MakeNewTitle(value,src_type)): string)

static char *MakeNewTitle(const char **value, int src_type);
static char *MakeNewImageValue(const char **value);
static char *MakeNewMapValue(const char **value, const char *mapstr);

/*	Set an internal flag that the next call to a stack-affecting method
 *	is only internal and the stack manipulation should be skipped. - kw
 */
#define SET_SKIP_STACK(el_num) if (HTML_dtd.tags[el_num].contents != SGML_EMPTY) \
						{ me->skip_stack++; }

void strtolower(char *i)
{
    if (!i)
	return;
    while (*i) {
	*i = (char) TOLOWER(*i);
	i++;
    }
}

/*		Flattening the style structure
 *		------------------------------
 *
 * On the NeXT, and on any read-only browser, it is simpler for the text to
 * have a sequence of styles, rather than a nested tree of styles.  In this
 * case we have to flatten the structure as it arrives from SGML tags into a
 * sequence of styles.
 */

/*
 *  If style really needs to be set, call this.
 */
void actually_set_style(HTStructured * me)
{
    if (!me->text) {		/* First time through */
	LYGetChartransInfo(me);
	UCSetTransParams(&me->T,
			 me->UCLYhndl, me->UCI,
			 HTAnchor_getUCLYhndl(me->node_anchor,
					      UCT_STAGE_HTEXT),
			 HTAnchor_getUCInfoStage(me->node_anchor,
						 UCT_STAGE_HTEXT));
	me->text = HText_new2(me->node_anchor, me->target);
	HText_beginAppend(me->text);
	HText_setStyle(me->text, me->new_style);
	me->in_word = NO;
	LYCheckForContentBase(me);
    } else {
	HText_setStyle(me->text, me->new_style);
    }

    me->old_style = me->new_style;
    me->style_change = NO;
}

/*
 *  If you THINK you need to change style, call this.
 */
static void change_paragraph_style(HTStructured * me, HTStyle *style)
{
    if (me->new_style != style) {
	me->style_change = YES;
	me->new_style = style;
    }
    me->in_word = NO;
}

BOOL LYBadHTML(HTStructured * me)
{
    if (!TRACE && !me->inBadHTML) {
	HTUserMsg(BAD_HTML_USE_TRACE);
	me->inBadHTML = TRUE;
	return FALSE;
    }
    return TRUE;
}

/*_________________________________________________________________________
 *
 *			A C T I O N	R O U T I N E S
 */

/* FIXME:  this should be amended to do the substitution only when not in a
 * multibyte stream.
 */
#ifdef EXP_JAPANESE_SPACES
#define FIX_JAPANESE_SPACES \
	(HTCJK == CHINESE || HTCJK == JAPANESE || HTCJK == TAIPEI)
	/* don't replace '\n' with ' ' if Chinese or Japanese - HN
	 */
#else
#define FIX_JAPANESE_SPACES 0
#endif

/*	Character handling
 *	------------------
 */
void HTML_put_character(HTStructured * me, char c)
{
    /*
     * Ignore all non-MAP content when just scanning a document for MAPs.  - FM
     */
    if (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT)
	return;

    /*
     * Do EOL conversion if needed.  - FM
     *
     * Convert EOL styles:
     *   macintosh:  cr    --> lf
     *   ascii:      cr-lf --> lf
     *   unix:       lf    --> lf
     */
    if ((me->lastraw == '\r') && c == '\n') {
	me->lastraw = -1;
	return;
    }
    me->lastraw = c;
    if (c == '\r')
	c = '\n';

    /*
     * Handle SGML_LITTERAL tags that have HTChunk elements.  - FM
     */
    switch (me->sp[0].tag_number) {

    case HTML_COMMENT:
	return;			/* Do Nothing */

    case HTML_TITLE:
	if (c == LY_SOFT_HYPHEN)
	    return;
	if (c != '\n' && c != '\t' && c != '\r') {
	    HTChunkPutc(&me->title, c);
	} else if (FIX_JAPANESE_SPACES) {
	    if (c == '\t') {
		HTChunkPutc(&me->title, ' ');
	    } else {
		return;
	    }
	} else {
	    HTChunkPutc(&me->title, ' ');
	}
	return;

    case HTML_STYLE:
	HTChunkPutc(&me->style_block, c);
	return;

    case HTML_SCRIPT:
	HTChunkPutc(&me->script, c);
	return;

    case HTML_OBJECT:
	HTChunkPutc(&me->object, c);
	return;

    case HTML_TEXTAREA:
	HTChunkPutc(&me->textarea, c);
	return;

    case HTML_SELECT:
    case HTML_OPTION:
	HTChunkPutc(&me->option, c);
	return;

    case HTML_MATH:
	HTChunkPutc(&me->math, c);
	return;

    default:
	if (me->inSELECT) {
	    /*
	     * If we are within a SELECT not caught by the cases above -
	     * HTML_SELECT or HTML_OPTION may not be the last element pushed on
	     * the style stack if there were invalid markup tags within a
	     * SELECT element.  For error recovery, treat text as part of the
	     * OPTION text, it is probably meant to show up as user-visible
	     * text.  Having A as an open element while in SELECT is really
	     * sick, don't make anchor text part of the option text in that
	     * case since the option text will probably just be discarded.  -
	     * kw
	     */
	    if (me->sp[0].tag_number == HTML_A)
		break;
	    HTChunkPutc(&me->option, c);
	    return;
	}
	break;
    }				/* end first switch */

    /*
     * Handle all other tag content.  - FM
     */
    switch (me->sp[0].tag_number) {

    case HTML_PRE:		/* Formatted text */
	/*
	 * We guarantee that the style is up-to-date in begin_litteral. But we
	 * still want to strip \r's.
	 */
	if (c != '\r' &&
	    !(c == '\n' && me->inLABEL && !me->inP) &&
	    !(c == '\n' && !me->inPRE)) {
	    me->inP = TRUE;
	    me->inLABEL = FALSE;
	    HText_appendCharacter(me->text, c);
	}
	me->inPRE = TRUE;
	break;

    case HTML_LISTING:		/* Literal text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
	/*
	 * We guarantee that the style is up-to-date in begin_litteral.  But we
	 * still want to strip \r's.
	 */
	if (c != '\r') {
	    me->inP = TRUE;
	    me->inLABEL = FALSE;
	    HText_appendCharacter(me->text, c);
	}
	break;

    default:
	/*
	 * Free format text.
	 */
	if (me->sp->style->id == ST_Preformatted) {
	    if (c != '\r' &&
		!(c == '\n' && me->inLABEL && !me->inP) &&
		!(c == '\n' && !me->inPRE)) {
		me->inP = TRUE;
		me->inLABEL = FALSE;
		HText_appendCharacter(me->text, c);
	    }
	    me->inPRE = TRUE;

	} else if (me->sp->style->id == ST_Listing ||
		   me->sp->style->id == ST_Example) {
	    if (c != '\r') {
		me->inP = TRUE;
		me->inLABEL = FALSE;
		HText_appendCharacter(me->text, c);
	    }

	} else {
	    if (me->style_change) {
		if ((c == '\n') || (c == ' '))
		    return;	/* Ignore it */
		UPDATE_STYLE;
	    }
	    if (c == '\n') {
		if (!FIX_JAPANESE_SPACES) {
		    if (me->in_word) {
			if (HText_getLastChar(me->text) != ' ') {
			    me->inP = TRUE;
			    me->inLABEL = FALSE;
			    HText_appendCharacter(me->text, ' ');
			}
			me->in_word = NO;
		    }
		}

	    } else if (c == ' ' || c == '\t') {
		if (HText_getLastChar(me->text) != ' ') {
		    me->inP = TRUE;
		    me->inLABEL = FALSE;
		    HText_appendCharacter(me->text, ' ');
		}

	    } else if (c == '\r') {
		/* ignore */

	    } else {
		me->inP = TRUE;
		me->inLABEL = FALSE;
		HText_appendCharacter(me->text, c);
		me->in_word = YES;
	    }
	}
    }				/* end second switch */

    if (c == '\n' || c == '\t') {
	HText_setLastChar(me->text, ' ');	/* set it to a generic separator */

	/*
	 * \r's are ignored.  In order to keep collapsing spaces correctly we
	 * must default back to the previous separator if there was one.
	 */
    } else if (c == '\r' && HText_getLastChar(me->text) == ' ') {
	HText_setLastChar(me->text, ' ');	/* set it to a generic separator */
    } else {
	HText_setLastChar(me->text, c);
    }
}

/*	String handling
 *	---------------
 *
 *	This is written separately from put_character because the loop can
 *	in some cases be promoted to a higher function call level for speed.
 */
void HTML_put_string(HTStructured * me, const char *s)
{
#ifdef USE_PRETTYSRC
    char *translated_string = NULL;
#endif

    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
	return;
#ifdef USE_PRETTYSRC
    if (psrc_convert_string) {
	StrAllocCopy(translated_string, s);
	TRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);
	s = (const char *) translated_string;
    }
#endif

    switch (me->sp[0].tag_number) {

    case HTML_COMMENT:
	break;			/* Do Nothing */

    case HTML_TITLE:
	HTChunkPuts(&me->title, s);
	break;

    case HTML_STYLE:
	HTChunkPuts(&me->style_block, s);
	break;

    case HTML_SCRIPT:
	HTChunkPuts(&me->script, s);
	break;

    case HTML_PRE:		/* Formatted text */
    case HTML_LISTING:		/* Literal text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
	/*
	 * We guarantee that the style is up-to-date in begin_litteral
	 */
	HText_appendText(me->text, s);
	break;

    case HTML_OBJECT:
	HTChunkPuts(&me->object, s);
	break;

    case HTML_TEXTAREA:
	HTChunkPuts(&me->textarea, s);
	break;

    case HTML_SELECT:
    case HTML_OPTION:
	HTChunkPuts(&me->option, s);
	break;

    case HTML_MATH:
	HTChunkPuts(&me->math, s);
	break;

    default:			/* Free format text? */
	if (!me->sp->style->freeFormat) {
	    /*
	     * If we are within a preformatted text style not caught by the
	     * cases above (HTML_PRE or similar may not be the last element
	     * pushed on the style stack).  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for (; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
		HText_appendText(me->text, s);
	    break;
	} else {
	    const char *p = s;
	    char c;

	    if (me->style_change) {
		for (; *p && ((*p == '\n') || (*p == '\r') ||
			      (*p == ' ') || (*p == '\t')); p++) ;	/* Ignore leaders */
		if (!*p)
		    break;
		UPDATE_STYLE;
	    }
	    for (; *p; p++) {
		if (*p == 13 && p[1] != 10) {
		    /*
		     * Treat any '\r' which is not followed by '\n' as '\n', to
		     * account for macintosh lineend in ALT attributes etc.  -
		     * kw
		     */
		    c = '\n';
		} else {
		    c = *p;
		}
		if (me->style_change) {
		    if ((c == '\n') || (c == ' ') || (c == '\t'))
			continue;	/* Ignore it */
		    UPDATE_STYLE;
		}
		if (c == '\n') {
		    if (!FIX_JAPANESE_SPACES) {
			if (me->in_word) {
			    if (HText_getLastChar(me->text) != ' ')
				HText_appendCharacter(me->text, ' ');
			    me->in_word = NO;
			}
		    }

		} else if (c == ' ' || c == '\t') {
		    if (HText_getLastChar(me->text) != ' ')
			HText_appendCharacter(me->text, ' ');

		} else if (c == '\r') {
		    /* ignore */
		} else {
		    HText_appendCharacter(me->text, c);
		    me->in_word = YES;
		}

		/* set the Last Character */
		if (c == '\n' || c == '\t') {
		    /* set it to a generic separator */
		    HText_setLastChar(me->text, ' ');
		} else if (c == '\r' &&
			   HText_getLastChar(me->text) == ' ') {
		    /*
		     * \r's are ignored.  In order to keep collapsing spaces
		     * correctly, we must default back to the previous
		     * separator, if there was one.  So we set LastChar to a
		     * generic separator.
		     */
		    HText_setLastChar(me->text, ' ');
		} else {
		    HText_setLastChar(me->text, c);
		}

	    }			/* for */
	}
    }				/* end switch */
#ifdef USE_PRETTYSRC
    if (psrc_convert_string) {
	psrc_convert_string = FALSE;
	FREE(translated_string);
    }
#endif
}

/*	Buffer write
 *	------------
 */
void HTML_write(HTStructured * me, const char *s, int l)
{
    const char *p;
    const char *e = s + l;

    if (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT)
	return;

    for (p = s; p < e; p++)
	HTML_put_character(me, *p);
}

/*
 *  "Internal links" are hyperlinks whose source and destination are
 *  within the same document, and for which the destination is given
 *  as a URL Reference with an empty URL, but possibly with a non-empty
 *  #fragment.	(This terminology re URL-Reference vs. URL follows the
 *  Fielding URL syntax and semantics drafts).
 *  Differences:
 *  (1) The document's base (in whatever way it is given) is not used for
 *	resolving internal link references.
 *  (2) Activating an internal link should not result in a new retrieval
 *	of a copy of the document.
 *  (3) Internal links are the only way to refer with a hyperlink to a document
 *	(or a location in it) which is only known as the result of a POST
 *	request (doesn't have a URL from which the document can be retrieved
 *	with GET), and can only be used from within that document.
 *
 * *If DONT_TRACK_INTERNAL_LINKS is not defined, we keep track of whether a
 *  link destination was given as an internal link.  This information is
 *  recorded in the type of the link between anchor objects, and is available
 *  to the HText object and the mainloop from there.  URL References to
 *  internal destinations are still resolved into an absolute form before
 *  being passed on, but using the current stream's retrieval address instead
 *  of the base URL.
 *  Examples:  (replace [...] to have a valid absolute URL)
 *  In document retrieved from [...]/mypath/mydoc.htm w/ base [...]/otherpath/
 *  a. HREF="[...]/mypath/mydoc.htm"	  -> [...]/mypath/mydoc.htm
 *  b. HREF="[...]/mypath/mydoc.htm#frag" -> [...]/mypath/mydoc.htm#frag
 *  c. HREF="mydoc.htm"			  -> [...]/otherpath/mydoc.htm
 *  d. HREF="mydoc.htm#frag"		  -> [...]/otherpath/mydoc.htm#frag
 *  e. HREF=""		      -> [...]/mypath/mydoc.htm      (marked internal)
 *  f. HREF="#frag"	      -> [...]/mypath/mydoc.htm#frag (marked internal)
 *
 * *If DONT_TRACK_INTERNAL_LINKS is defined, URL-less URL-References are
 *  resolved differently from URL-References with a non-empty URL (using the
 *  current stream's retrieval address instead of the base), but we make no
 *  further distinction.  Resolution is then as in the examples above, execept
 *  that there is no "(marked internal)".
 *
 * *Note that this doesn't apply to form ACTIONs (always resolved using base,
 *  never marked internal).  Also other references encountered or generated
 *  are not marked internal, whether they have a URL or not, if in a given
 *  context an internal link makes no sense (e.g., IMG SRC=).
 */

/* A flag is used to keep track of whether an "URL reference" encountered
   had a real "URL" or not.  In the latter case, it will be marked as
   "internal".	The flag is set before we start messing around with the
   string (resolution of relative URLs etc.).  This variable only used
   locally here, don't confuse with LYinternal_flag which is for
   overriding non-caching similar to LYoverride_no_cache. - kw */
#define CHECK_FOR_INTERN(flag,s) flag = (s && (*s=='#' || *s=='\0')) ? TRUE : FALSE

/* Last argument to pass to HTAnchor_findChildAndLink() calls,
   just an abbreviation. - kw */
#define INTERN_LT (HTLinkType *)(intern_flag ? HTInternalLink : NULL)

#ifdef USE_COLOR_STYLE
static char *Style_className = 0;
static char *Style_className_end = 0;
static unsigned Style_className_len = 0;
static int hcode;

#ifdef LY_FIND_LEAKS
static void free_Style_className(void)
{
    FREE(Style_className);
}
#endif

static void addClassName(const char *prefix,
			 const char *actual,
			 int length)
{
    int offset = strlen(prefix);
    unsigned have = (Style_className_end - Style_className);
    unsigned need = (offset + length + 1);

    if ((have + need) >= Style_className_len) {
	Style_className_len += 1024 + 2 * (have + need);
	if (Style_className == 0) {
	    Style_className = typeMallocn(char, Style_className_len);
	} else {
	    Style_className = typeRealloc(char, Style_className, Style_className_len);
	}
	if (Style_className == NULL)
	    outofmem(__FILE__, "addClassName");
	Style_className_end = Style_className + have;
    }
    if (offset)
	strcpy(Style_className_end, prefix);
    if (length)
	memcpy(Style_className_end + offset, actual, length);
    Style_className_end[offset + length] = '\0';
    strtolower(Style_className_end);

    Style_className_end += (offset + length);
}
#else
#define addClassName(prefix, actual, length)	/* nothing */
#endif

#ifdef USE_PRETTYSRC

static void HTMLSRC_apply_markup(HTStructured * context, HTlexeme lexeme, BOOL start,
				 int tag_charset)
{
    HT_tagspec *ts = *((start ? lexeme_start : lexeme_end) + lexeme);

    while (ts) {
#ifdef USE_COLOR_STYLE
	if (ts->start) {
	    current_tag_style = ts->style;
	    force_current_tag_style = TRUE;
	    forced_classname = ts->class_name;
	    force_classname = TRUE;
	}
#endif
	CTRACE((tfp, ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n", (int) lexeme));
	if (ts->start)
	    HTML_start_element(context,
			       ts->element,
			       ts->present,
			       (const char **) ts->value,
			       tag_charset,
			       NULL);
	else
	    HTML_end_element(context,
			     ts->element,
			     NULL);
	ts = ts->next;
    }
}
#  define START TRUE
#  define STOP FALSE

#  define PSRCSTART(x)	HTMLSRC_apply_markup(me,HTL_##x,START,tag_charset)
#  define PSRCSTOP(x)  HTMLSRC_apply_markup(me,HTL_##x,STOP,tag_charset)

#  define PUTC(x) HTML_put_character(me,x)
#  define PUTS(x) HTML_put_string(me,x)

#endif /* USE_PRETTYSRC */

static void LYStartArea(HTStructured * obj, const char *href,
			const char *alt,
			const char *title,
			int tag_charset)
{
    BOOL new_present[HTML_AREA_ATTRIBUTES];
    const char *new_value[HTML_AREA_ATTRIBUTES];
    int i;

    for (i = 0; i < HTML_AREA_ATTRIBUTES; i++)
	new_present[i] = NO;

    if (alt) {
	new_present[HTML_AREA_ALT] = YES;
	new_value[HTML_AREA_ALT] = (const char *) alt;
    }
    if (non_empty(title)) {
	new_present[HTML_AREA_TITLE] = YES;
	new_value[HTML_AREA_TITLE] = (const char *) title;
    }
    if (href) {
	new_present[HTML_AREA_HREF] = YES;
	new_value[HTML_AREA_HREF] = (const char *) href;
    }

    (*obj->isa->start_element) (obj, HTML_AREA, new_present, new_value,
				tag_charset, 0);
}

static void LYHandleFIG(HTStructured * me, const BOOL *present,
			const char **value,
			BOOL isobject,
			BOOL imagemap,
			const char *id,
			const char *src,
			BOOL convert,
			BOOL start,
			BOOL *intern_flag GCC_UNUSED)
{
    if (start == TRUE) {
	me->inFIG = TRUE;
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, NULL);
	}
	if (!isobject) {
	    LYEnsureDoubleSpace(me);
	    LYResetParagraphAlignment(me);
	    me->inFIGwithP = TRUE;
	} else {
	    me->inFIGwithP = FALSE;
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	}
	if (non_empty(id)) {
	    if (present && convert) {
		CHECK_ID(HTML_FIG_ID);
	    } else
		LYHandleID(me, id);
	}
	me->in_word = NO;
	me->inP = FALSE;

	if (clickable_images && non_empty(src)) {
	    char *href = NULL;

	    StrAllocCopy(href, src);
	    CHECK_FOR_INTERN(*intern_flag, href);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href) {
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 INTERN_LT);	/* Type */
		HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		HTML_put_string(me, (isobject
				     ? (imagemap
					? "(IMAGE)"
					: "(OBJECT)")
				     : "[FIGURE]"));
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, 0);
		HTML_put_character(me, '-');
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
	    }
	    FREE(href);
	}
    } else {			/* handle end tag */
	if (me->inFIGwithP) {
	    LYEnsureDoubleSpace(me);
	} else {
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	}
	LYResetParagraphAlignment(me);
	me->inFIGwithP = FALSE;
	me->inFIG = FALSE;
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	if (me->List_Nesting_Level >= 0) {
	    UPDATE_STYLE;
	    HText_NegateLineOne(me->text);
	}
    }
}

static void clear_objectdata(HTStructured * me)
{
    if (me) {
	HTChunkClear(&me->object);
	me->object_started = FALSE;
	me->object_declare = FALSE;
	me->object_shapes = FALSE;
	me->object_ismap = FALSE;
	FREE(me->object_usemap);
	FREE(me->object_id);
	FREE(me->object_title);
	FREE(me->object_data);
	FREE(me->object_type);
	FREE(me->object_classid);
	FREE(me->object_codebase);
	FREE(me->object_codetype);
	FREE(me->object_name);
    }
}

#define HTParseALL(pp,pconst)  \
	{ char* free_me = *pp; \
	  *pp = HTParse(*pp, pconst, PARSE_ALL); \
	  FREE(free_me);       \
	}

/*	Start Element
 *	-------------
 */
static int HTML_start_element(HTStructured * me, int element_number,
			      const BOOL *present,
			      const char **value,
			      int tag_charset,
			      char **include)
{
    char *alt_string = NULL;
    char *id_string = NULL;
    char *newtitle = NULL;
    char **pdoctitle = NULL;
    char *href = NULL;
    char *map_href = NULL;
    char *title = NULL;
    char *I_value = NULL;
    char *I_name = NULL;
    char *temp = NULL;
    const char *Base = NULL;
    int dest_char_set = -1;
    HTParentAnchor *dest = NULL;	/* An anchor's destination */
    BOOL dest_ismap = FALSE;	/* Is dest an image map script? */
    HTChildAnchor *ID_A = NULL;	/* HTML_foo_ID anchor */
    int url_type = 0, i = 0;
    char *cp = NULL;
    HTMLElement ElementNumber = (HTMLElement) element_number;
    BOOL intern_flag = FALSE;
    short stbl_align = HT_ALIGN_NONE;
    int status = HT_OK;

#ifdef USE_COLOR_STYLE
    char *class_name;
    int class_used = 0;
#endif

#ifdef USE_PRETTYSRC
    if (psrc_view && !sgml_in_psrc_was_initialized) {
	if (!psrc_nested_call) {
	    HTTag *tag = &HTML_dtd.tags[element_number];
	    char buf[200];
	    const char *p;

	    if (psrc_first_tag) {
		psrc_first_tag = FALSE;
		/* perform the special actions on the begining of the document.
		   It's assumed that all lynx modules start generating html
		   from tag (ie not a text) so we are able to trap this moment
		   and initialize.
		 */
		psrc_nested_call = TRUE;
		HTML_start_element(me, HTML_BODY, NULL, NULL, tag_charset, NULL);
		HTML_start_element(me, HTML_PRE, NULL, NULL, tag_charset, NULL);
		PSRCSTART(entire);
		psrc_nested_call = FALSE;
	    }

	    psrc_nested_call = TRUE;
	    /*write markup for tags and exit */
	    PSRCSTART(abracket);
	    PUTC('<');
	    PSRCSTOP(abracket);
	    PSRCSTART(tag);
	    if (tagname_transform != 0)
		PUTS(tag->name);
	    else {
		LYstrncpy(buf, tag->name, sizeof(buf) - 1);
		LYLowerCase(buf);
		PUTS(buf);
	    }
	    if (present) {
		for (i = 0; i < tag->number_of_attributes; i++)
		    if (present[i]) {
			PUTC(' ');
			PSRCSTART(attrib);
			if (attrname_transform != 0)
			    PUTS(tag->attributes[i].name);
			else {
			    LYstrncpy(buf,
				      tag->attributes[i].name,
				      sizeof(buf) - 1);
			    LYLowerCase(buf);
			    PUTS(buf);
			}
			if (value[i]) {
			    char q = '"';

			    /*0 in dquotes, 1 - in quotes, 2 mixed */
			    char kind = (char) (!strchr(value[i], '"') ?
						0 :
						!strchr(value[i], '\'') ?
						q = '\'', 1 :
						2);

			    PUTC('=');
			    PSRCSTOP(attrib);
			    PSRCSTART(attrval);
			    PUTC(q);
			    /*is it special ? */
			    if (tag->attributes[i].type == HTMLA_ANAME) {
				HTStartAnchor(me, value[i], NULL);
				HTML_end_element(me, HTML_A, NULL);
			    } else if (tag->attributes[i].type == HTMLA_HREF) {
				PSRCSTART(href);
				HTStartAnchor(me, NULL, value[i]);
			    }
			    if (kind != 2)
				PUTS(value[i]);
			    else
				for (p = value[i]; *p; p++)
				    if (*p != '"')
					PUTC(*p);
				    else
					PUTS("&#34;");
			    /*is it special ? */
			    if (tag->attributes[i].type == HTMLA_HREF) {
				HTML_end_element(me, HTML_A, NULL);
				PSRCSTOP(href);
			    }
			    PUTC(q);
			    PSRCSTOP(attrval);
			}	/* if value */
		    }		/* if present[i] */
	    }			/* if present */
	    PSRCSTOP(tag);
	    PSRCSTART(abracket);
	    PUTC('>');
	    PSRCSTOP(abracket);
	    psrc_nested_call = FALSE;
	    return HT_OK;
	}			/*if (!psrc_nested_call) */
	/*fall through */
    }
#endif /* USE_PRETTYSRC */

    if (LYMapsOnly) {
	if (!(ElementNumber == HTML_MAP || ElementNumber == HTML_AREA ||
	      ElementNumber == HTML_BASE || ElementNumber == HTML_OBJECT ||
	      ElementNumber == HTML_A)) {
	    return HT_OK;
	}
    } else if (!me->text) {
	UPDATE_STYLE;
    } {
	/*  me->tag_charset  is charset for attribute values.  */
	int j = ((tag_charset < 0) ? me->UCLYhndl : tag_charset);

	if ((me->tag_charset != j) || (j < 0 /* for trace entry */ )) {
	    CTRACE((tfp, "me->tag_charset: %d -> %d", me->tag_charset, j));
	    CTRACE((tfp, " (me->UCLYhndl: %d, tag_charset: %d)\n",
		    me->UCLYhndl, tag_charset));
	    me->tag_charset = j;
	}
    }

/* this should be done differently */
#if defined(USE_COLOR_STYLE)

    addClassName(";",
		 HTML_dtd.tags[element_number].name,
		 HTML_dtd.tags[element_number].name_len);

    class_name = (force_classname ? forced_classname : class_string);
    force_classname = FALSE;

    if (force_current_tag_style == FALSE) {
	current_tag_style = class_name[0]
	    ? -1
	    : cached_tag_styles[element_number];
    } else {
	force_current_tag_style = FALSE;
    }

    CTRACE2(TRACE_STYLE, (tfp, "CSS.elt:<%s>\n", HTML_dtd.tags[element_number].name));

    if (current_tag_style == -1) {	/* Append class_name */
	hcode = hash_code_lowercase_on_fly(HTML_dtd.tags[element_number].name);
	if (class_name[0]) {
	    int ohcode = hcode;

	    hcode = hash_code_aggregate_char('.', hcode);
	    hcode = hash_code_aggregate_lower_str(class_name, hcode);
	    if (!hashStyles[hcode].name) {	/* None such -> classless version */
		hcode = ohcode;
		CTRACE2(TRACE_STYLE,
			(tfp,
			 "STYLE.start_element: <%s> (class <%s> not configured), hcode=%d.\n",
			 HTML_dtd.tags[element_number].name, class_name, hcode));
	    } else {
		addClassName(".", class_name, strlen(class_name));

		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.start_element: <%s>.<%s>, hcode=%d.\n",
			 HTML_dtd.tags[element_number].name, class_name, hcode));
		class_used = 1;
	    }
	}

	class_string[0] = '\0';

    } else {			/* (current_tag_style!=-1)  */
	if (class_name[0]) {
	    addClassName(".", class_name, strlen(class_name));
	    class_string[0] = '\0';
	}
	hcode = current_tag_style;
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE.start_element: <%s>, hcode=%d.\n",
		 HTML_dtd.tags[element_number].name, hcode));
	current_tag_style = -1;
    }

#if !OMIT_SCN_KEEPING		/* Can be done in other cases too... */
    if (!class_used && ElementNumber == HTML_INPUT) {	/* For some other too? */
	const char *type = "";
	int ohcode = hcode;

	if (present && present[HTML_INPUT_TYPE] && value[HTML_INPUT_TYPE])
	    type = value[HTML_INPUT_TYPE];

	hcode = hash_code_aggregate_lower_str(".type.", hcode);
	hcode = hash_code_aggregate_lower_str(type, hcode);
	if (!hashStyles[hcode].name) {	/* None such -> classless version */
	    hcode = ohcode;
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.start_element: type <%s> not configured.\n",
		     type));
	} else {
	    addClassName(".type.", type, strlen(type));

	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.start_element: <%s>.type.<%s>, hcode=%d.\n",
		     HTML_dtd.tags[element_number].name, type, hcode));
	}
    }
#endif /* !OMIT_SCN_KEEPING */

    HText_characterStyle(me->text, hcode, 1);
#endif /* USE_COLOR_STYLE */

    /*
     * Handle the start tag.  - FM
     */
    switch (ElementNumber) {

    case HTML_HTML:
	break;

    case HTML_HEAD:
	break;

    case HTML_BASE:
	if (present && present[HTML_BASE_HREF] && !local_host_only &&
	    non_empty(value[HTML_BASE_HREF])) {
	    char *base = NULL;
	    const char *related = NULL;

	    StrAllocCopy(base, value[HTML_BASE_HREF]);
	    CTRACE((tfp, "*HTML_BASE: initial href=`%s'\n", NonNull(base)));

	    if (!(url_type = LYLegitimizeHREF(me, &base, TRUE, TRUE))) {
		CTRACE((tfp, "HTML: BASE '%s' is not an absolute URL.\n",
			NonNull(base)));
		if (me->inBadBASE == FALSE)
		    HTAlert(BASE_NOT_ABSOLUTE);
		me->inBadBASE = TRUE;
	    }

	    if (url_type == LYNXIMGMAP_URL_TYPE) {
		/*
		 * These have a non-standard form, basically strip the prefix
		 * or the code below would insert a nonsense host into the
		 * pseudo URL.  These should never occur where they would be
		 * used for resolution of relative URLs anyway.  We can also
		 * strip the #map part.  - kw
		 */
		temp = base;
		base = HTParse(base + 11, "", PARSE_ALL_WITHOUT_ANCHOR);
		FREE(temp);
	    }

	    /*
	     * Get parent's address for defaulted fields.
	     */
	    related = me->node_anchor->address;

	    /*
	     * Create the access field.
	     */
	    temp = HTParse(base, related, PARSE_ACCESS + PARSE_PUNCTUATION);
	    StrAllocCopy(me->base_href, temp);
	    FREE(temp);

	    /*
	     * Create the host[:port] field.
	     */
	    temp = HTParse(base, "", PARSE_HOST + PARSE_PUNCTUATION);
	    if (!strncmp(temp, "//", 2)) {
		StrAllocCat(me->base_href, temp);
		if (!strcmp(me->base_href, "file://")) {
		    StrAllocCat(me->base_href, "localhost");
		}
	    } else {
		if (isFILE_URL(me->base_href)) {
		    StrAllocCat(me->base_href, "//localhost");
		} else if (strcmp(me->base_href, STR_NEWS_URL)) {
		    FREE(temp);
		    StrAllocCat(me->base_href, (temp = HTParse(related, "",
							       PARSE_HOST + PARSE_PUNCTUATION)));
		}
	    }
	    FREE(temp);

	    /*
	     * Create the path field.
	     */
	    temp = HTParse(base, "", PARSE_PATH + PARSE_PUNCTUATION);
	    if (*temp != '\0') {
		char *p = strchr(temp, '?');

		if (p)
		    *p = '\0';
		p = strrchr(temp, '/');
		if (p)
		    *(p + 1) = '\0';	/* strip after the last slash */

		StrAllocCat(me->base_href, temp);
	    } else if (!strcmp(me->base_href, STR_NEWS_URL)) {
		StrAllocCat(me->base_href, "*");
	    } else if (isNEWS_URL(me->base_href) ||
		       isNNTP_URL(me->base_href) ||
		       isSNEWS_URL(me->base_href)) {
		StrAllocCat(me->base_href, "/*");
	    } else {
		StrAllocCat(me->base_href, "/");
	    }
	    FREE(temp);
	    FREE(base);

	    me->inBASE = TRUE;
	    me->node_anchor->inBASE = TRUE;
	    StrAllocCopy(me->node_anchor->content_base, me->base_href);
	    /* me->base_href is a valid URL */

	    CTRACE((tfp, "*HTML_BASE: final href=`%s'\n", me->base_href));
	}
	break;

    case HTML_META:
	if (present)
	    LYHandleMETA(me, present, value, include);
	break;

    case HTML_TITLE:
	HTChunkClear(&me->title);
	break;

    case HTML_LINK:
	intern_flag = FALSE;
	if (present && present[HTML_LINK_HREF]) {
	    CHECK_FOR_INTERN(intern_flag, value[HTML_LINK_HREF]);
	    /*
	     * Prepare to do housekeeping on the reference.  - FM
	     */
	    if (!value[HTML_LINK_HREF]) {
		Base = (me->inBASE)
		    ? me->base_href
		    : me->node_anchor->address;
		StrAllocCopy(href, Base);
	    } else {
		StrAllocCopy(href, value[HTML_LINK_HREF]);
		url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);

		Base = (me->inBASE && *href != '\0' && *href != '#')
		    ? me->base_href
		    : me->node_anchor->address;
		HTParseALL(&href, Base);
	    }

	    /*
	     * Handle links with a REV attribute.  - FM
	     */
	    if (present &&
		present[HTML_LINK_REV] && value[HTML_LINK_REV]) {
		/*
		 * Handle REV="made" or REV="owner".  - LM & FM
		 */
		if (!strcasecomp("made", value[HTML_LINK_REV]) ||
		    !strcasecomp("owner", value[HTML_LINK_REV])) {
		    /*
		     * Load the owner element.  - FM
		     */
		    HTAnchor_setOwner(me->node_anchor, href);
		    CTRACE((tfp, "HTML: DOC OWNER '%s' found\n", href));
		    FREE(href);

		    /*
		     * Load the RevTitle element if a TITLE attribute and value
		     * are present.  - FM
		     */
		    if (present && present[HTML_LINK_TITLE] &&
			value[HTML_LINK_TITLE] &&
			*value[HTML_LINK_TITLE] != '\0') {
			StrAllocCopy(title, value[HTML_LINK_TITLE]);
			TRANSLATE_AND_UNESCAPE_ENTITIES(&title, TRUE, FALSE);
			LYTrimHead(title);
			LYTrimTail(title);
			if (*title != '\0')
			    HTAnchor_setRevTitle(me->node_anchor, title);
			FREE(title);
		    }
		    break;
		}
	    }

	    /*
	     * Handle REL links.  - FM
	     */

	    if (present &&
		present[HTML_LINK_REL] && value[HTML_LINK_REL]) {
		/*
		 * Ignore style sheets, for now.  - FM
		 *
		 * lss and css have different syntax - lynx shouldn't try to
		 * parse them now (it tries to parse them as lss, so it exits
		 * with error message on the 1st non-empty line) - VH
		 */
#ifndef USE_COLOR_STYLE
		if (!strcasecomp(value[HTML_LINK_REL], "StyleSheet") ||
		    !strcasecomp(value[HTML_LINK_REL], "Style")) {
		    CTRACE2(TRACE_STYLE,
			    (tfp, "HTML: StyleSheet link found.\n"));
		    CTRACE2(TRACE_STYLE,
			    (tfp, "        StyleSheets not yet implemented.\n"));
		    FREE(href);
		    break;
		}
#endif /* ! USE_COLOR_STYLE */

		/*
		 * Ignore anything not registered in the 28-Mar-95 IETF HTML
		 * 3.0 draft and W3C HTML 3.2 draft, or not appropriate for
		 * Lynx banner links in the expired Maloney and Quin relrev
		 * draft.  We'll make this more efficient when the situation
		 * stabilizes, and for now, we'll treat "Banner" as another
		 * toolbar element.  - FM
		 */
		if (!strcasecomp(value[HTML_LINK_REL], "Home") ||
		    !strcasecomp(value[HTML_LINK_REL], "ToC") ||
		    !strcasecomp(value[HTML_LINK_REL], "Contents") ||
		    !strcasecomp(value[HTML_LINK_REL], "Index") ||
		    !strcasecomp(value[HTML_LINK_REL], "Glossary") ||
		    !strcasecomp(value[HTML_LINK_REL], "Copyright") ||
		    !strcasecomp(value[HTML_LINK_REL], "Help") ||
		    !strcasecomp(value[HTML_LINK_REL], "Search") ||
		    !strcasecomp(value[HTML_LINK_REL], "Bookmark") ||
		    !strcasecomp(value[HTML_LINK_REL], "Banner") ||
		    !strcasecomp(value[HTML_LINK_REL], "Top") ||
		    !strcasecomp(value[HTML_LINK_REL], "Origin") ||
		    !strcasecomp(value[HTML_LINK_REL], "Navigator") ||
		    !strcasecomp(value[HTML_LINK_REL], "Disclaimer") ||
		    !strcasecomp(value[HTML_LINK_REL], "Author") ||
		    !strcasecomp(value[HTML_LINK_REL], "Editor") ||
		    !strcasecomp(value[HTML_LINK_REL], "Publisher") ||
		    !strcasecomp(value[HTML_LINK_REL], "Trademark") ||
		    !strcasecomp(value[HTML_LINK_REL], "Hotlist") ||
		    !strcasecomp(value[HTML_LINK_REL], "Begin") ||
		    !strcasecomp(value[HTML_LINK_REL], "First") ||
		    !strcasecomp(value[HTML_LINK_REL], "End") ||
		    !strcasecomp(value[HTML_LINK_REL], "Last") ||
		    !strcasecomp(value[HTML_LINK_REL], "Documentation") ||
		    !strcasecomp(value[HTML_LINK_REL], "Biblioentry") ||
		    !strcasecomp(value[HTML_LINK_REL], "Bibliography") ||
		    !strcasecomp(value[HTML_LINK_REL], "Start") ||
		    !strcasecomp(value[HTML_LINK_REL], "Appendix")) {
		    StrAllocCopy(title, value[HTML_LINK_REL]);
		    pdoctitle = &title;		/* for setting HTAnchor's title */
		} else if (!strcasecomp(value[HTML_LINK_REL], "Up") ||
			   !strcasecomp(value[HTML_LINK_REL], "Next") ||
			   !strcasecomp(value[HTML_LINK_REL], "Previous") ||
			   !strcasecomp(value[HTML_LINK_REL], "Prev") ||
			   !strcasecomp(value[HTML_LINK_REL], "Child") ||
			   !strcasecomp(value[HTML_LINK_REL], "Sibling") ||
			   !strcasecomp(value[HTML_LINK_REL], "Parent") ||
			   !strcasecomp(value[HTML_LINK_REL], "Meta") ||
			   !strcasecomp(value[HTML_LINK_REL], "URC") ||
			   !strcasecomp(value[HTML_LINK_REL], "Pointer") ||
			   !strcasecomp(value[HTML_LINK_REL], "Translation") ||
			   !strcasecomp(value[HTML_LINK_REL], "Definition") ||
			   !strcasecomp(value[HTML_LINK_REL], "Alternate") ||
			   !strcasecomp(value[HTML_LINK_REL], "Section") ||
			   !strcasecomp(value[HTML_LINK_REL], "Subsection") ||
			   !strcasecomp(value[HTML_LINK_REL], "Chapter")) {
		    StrAllocCopy(title, value[HTML_LINK_REL]);
		    /* not setting target HTAnchor's title, for these
		       links of highly relative character.  Instead,
		       try to remember the REL attribute as a property
		       of the link (but not the destination), in the
		       (otherwise underused) link type in a special format;
		       the LIST page generation code may later use it. - kw */
		    if (!intern_flag) {
			StrAllocCopy(temp, "RelTitle: ");
			StrAllocCat(temp, value[HTML_LINK_REL]);
		    }
#ifndef DISABLE_BIBP
		} else if (!strcasecomp(value[HTML_LINK_REL], "citehost")) {
		    /*  Citehost determination for bibp links. - RDC */
		    HTAnchor_setCitehost(me->node_anchor, href);
		    CTRACE((tfp, "HTML: citehost '%s' found\n", href));
		    FREE(href);
		    break;
#endif
		} else {
		    CTRACE((tfp, "HTML: LINK with REL=\"%s\" ignored.\n",
			    value[HTML_LINK_REL]));
		    FREE(href);
		    break;
		}
	    }
	} else if (present &&
		   present[HTML_LINK_REL] && value[HTML_LINK_REL]) {
	    /*
	     * If no HREF was specified, handle special REL links with
	     * self-designated HREFs.  - FM
	     */
	    if (!strcasecomp(value[HTML_LINK_REL], "Home")) {
		StrAllocCopy(href, LynxHome);
	    } else if (!strcasecomp(value[HTML_LINK_REL], "Help")) {
		StrAllocCopy(href, helpfile);
	    } else if (!strcasecomp(value[HTML_LINK_REL], "Index")) {
		StrAllocCopy(href, indexfile);
	    } else {
		CTRACE((tfp,
			"HTML: LINK with REL=\"%s\" and no HREF ignored.\n",
			value[HTML_LINK_REL]));
		break;
	    }
	    StrAllocCopy(title, value[HTML_LINK_REL]);
	    pdoctitle = &title;
	}
	if (href) {
	    /*
	     * Create a title (link name) from the TITLE value, if present, or
	     * default to the REL value that was loaded into title.  - FM
	     */
	    if (present && present[HTML_LINK_TITLE] &&
		non_empty(value[HTML_LINK_TITLE])) {
		StrAllocCopy(title, value[HTML_LINK_TITLE]);
		TRANSLATE_AND_UNESCAPE_ENTITIES(&title, TRUE, FALSE);
		LYTrimHead(title);
		LYTrimTail(title);
		pdoctitle = &title;
		FREE(temp);	/* forget about recording RelTitle - kw */
	    }
	    if (isEmpty(title)) {
		FREE(href);
		FREE(title);
		break;
	    }

	    if (me->inA) {
		/*
		 * Ugh!  The LINK tag, which is a HEAD element, is in an
		 * Anchor, which is BODY element.  All we can do is close the
		 * Anchor and cross our fingers.  - FM
		 */
		SET_SKIP_STACK(HTML_A);
		HTML_end_element(me, HTML_A, include);
	    }

	    /*
	     * Create anchors for the links that simulate a toolbar.  - FM
	     */
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (temp
						      ? (HTLinkType *)
						      HTAtom_for(temp)
						      : INTERN_LT));	/* Type */
	    FREE(temp);
	    if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		 )) != NULL) {
		if (pdoctitle && !HTAnchor_title(dest))
		    HTAnchor_setTitle(dest, *pdoctitle);

		/* Don't allow CHARSET attribute to change *this* document's
		   charset assumption. - kw */
		if (dest == me->node_anchor)
		    dest = NULL;
		if (present[HTML_LINK_CHARSET] &&
		    non_empty(value[HTML_LINK_CHARSET])) {
		    dest_char_set = UCGetLYhndl_byMIME(value[HTML_LINK_CHARSET]);
		    if (dest_char_set < 0)
			dest_char_set = UCLYhndl_for_unrec;
		}
		if (dest && dest_char_set >= 0)
		    HTAnchor_setUCInfoStage(dest, dest_char_set,
					    UCT_STAGE_PARSER,
					    UCT_SETBY_LINK);
	    }
	    UPDATE_STYLE;
	    if (!HText_hasToolbar(me->text) &&
		(ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						  LYToolbarName,	/* Tag */
						  NULL,		/* Addresss */
						  (HTLinkType *) 0))) {		/* Type */
		HText_appendCharacter(me->text, '#');
		HText_setLastChar(me->text, ' ');	/* absorb white space */
		HText_beginAnchor(me->text, me->inUnderline, ID_A);
		HText_endAnchor(me->text, 0);
		HText_setToolbar(me->text);
	    } else {
		/*
		 * Add collapsible space to separate link from previous
		 * generated links.  - kw
		 */
		HTML_put_character(me, ' ');
	    }
	    HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
#ifdef USE_COLOR_STYLE
	    if (present && present[HTML_LINK_CLASS] &&
		non_empty(value[HTML_LINK_CLASS])) {
		char *tmp = 0;

		HTSprintf0(&tmp, "link.%s.%s", value[HTML_LINK_CLASS], title);
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.link: using style <%s>\n", tmp));

		HText_characterStyle(me->text, hash_code(tmp), 1);
		HTML_put_string(me, title);
		HTML_put_string(me, " (");
		HTML_put_string(me, value[HTML_LINK_CLASS]);
		HTML_put_string(me, ")");
		HText_characterStyle(me->text, hash_code(tmp), 0);
		FREE(tmp);
	    } else
#endif
		HTML_put_string(me, title);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
	    HText_endAnchor(me->text, 0);
	}
	FREE(href);
	FREE(title);
	break;

    case HTML_ISINDEX:
	if (((present)) &&
	    ((present[HTML_ISINDEX_HREF] && value[HTML_ISINDEX_HREF]) ||
	     (present[HTML_ISINDEX_ACTION] && value[HTML_ISINDEX_ACTION]))) {
	    /*
	     * Lynx was supporting ACTION, which never made it into the HTML
	     * 2.0 specs.  HTML 3.0 uses HREF, so we'll use that too, but allow
	     * use of ACTION as an alternate until people have fully switched
	     * over.  - FM
	     */
	    if (present[HTML_ISINDEX_HREF] && value[HTML_ISINDEX_HREF])
		StrAllocCopy(href, value[HTML_ISINDEX_HREF]);
	    else
		StrAllocCopy(href, value[HTML_ISINDEX_ACTION]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    Base = (me->inBASE && *href != '\0' && *href != '#')
		? me->base_href
		: me->node_anchor->address;
	    HTParseALL(&href, Base);
	    HTAnchor_setIndex(me->node_anchor, href);
	    FREE(href);

	} else {
	    Base = (me->inBASE) ?
		me->base_href : me->node_anchor->address;
	    HTAnchor_setIndex(me->node_anchor, Base);
	}
	/*
	 * Support HTML 3.0 PROMPT attribute.  - FM
	 */
	if (present &&
	    present[HTML_ISINDEX_PROMPT] &&
	    non_empty(value[HTML_ISINDEX_PROMPT])) {
	    StrAllocCopy(temp, value[HTML_ISINDEX_PROMPT]);
	    TRANSLATE_AND_UNESCAPE_ENTITIES(&temp, TRUE, FALSE);
	    LYTrimHead(temp);
	    LYTrimTail(temp);
	    if (*temp != '\0') {
		StrAllocCat(temp, " ");
		HTAnchor_setPrompt(me->node_anchor, temp);
	    } else {
		HTAnchor_setPrompt(me->node_anchor, ENTER_DATABASE_QUERY);
	    }
	    FREE(temp);
	} else {
	    HTAnchor_setPrompt(me->node_anchor, ENTER_DATABASE_QUERY);
	}
	break;

    case HTML_NEXTID:
	break;

    case HTML_STYLE:
	/*
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
	 */
	HTChunkClear(&me->style_block);
	break;

    case HTML_SCRIPT:
	/*
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
	 */
	HTChunkClear(&me->script);
	break;

    case HTML_BODY:
	CHECK_ID(HTML_BODY_ID);
	if (HText_hasToolbar(me->text))
	    HText_appendParagraph(me->text);
	break;

    case HTML_FRAMESET:
	break;

    case HTML_FRAME:
	if (present && present[HTML_FRAME_NAME] &&
	    non_empty(value[HTML_FRAME_NAME])) {
	    StrAllocCopy(id_string, value[HTML_FRAME_NAME]);
	    TRANSLATE_AND_UNESCAPE_ENTITIES(&id_string, TRUE, FALSE);
	    LYTrimHead(id_string);
	    LYTrimTail(id_string);
	}
	if (present && present[HTML_FRAME_SRC] &&
	    non_empty(value[HTML_FRAME_SRC])) {
	    StrAllocCopy(href, value[HTML_FRAME_SRC]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    if (me->inA) {
		SET_SKIP_STACK(HTML_A);
		HTML_end_element(me, HTML_A, include);
	    }
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
	    CAN_JUSTIFY_PUSH(FALSE);
	    LYEnsureSingleSpace(me);
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    HTML_put_string(me, "FRAME:");
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    HTML_put_character(me, ' ');

	    me->in_word = NO;
	    CHECK_ID(HTML_FRAME_ID);
	    HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    HTML_put_string(me, (id_string ? id_string : href));
	    FREE(href);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
	    HText_endAnchor(me->text, 0);
	    LYEnsureSingleSpace(me);
	    CAN_JUSTIFY_POP;
	} else {
	    CHECK_ID(HTML_FRAME_ID);
	}
	FREE(id_string);
	break;

    case HTML_NOFRAMES:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	break;

    case HTML_IFRAME:
	if (present && present[HTML_IFRAME_NAME] &&
	    non_empty(value[HTML_IFRAME_NAME])) {
	    StrAllocCopy(id_string, value[HTML_IFRAME_NAME]);
	    TRANSLATE_AND_UNESCAPE_ENTITIES(&id_string, TRUE, FALSE);
	    LYTrimHead(id_string);
	    LYTrimTail(id_string);
	}
	if (present && present[HTML_IFRAME_SRC] &&
	    non_empty(value[HTML_IFRAME_SRC])) {
	    StrAllocCopy(href, value[HTML_IFRAME_SRC]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    if (me->inA)
		HTML_end_element(me, HTML_A, include);

	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
	    LYEnsureDoubleSpace(me);
	    CAN_JUSTIFY_PUSH_F
		LYResetParagraphAlignment(me);
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    HTML_put_string(me, "IFRAME:");
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    HTML_put_character(me, ' ');

	    me->in_word = NO;
	    CHECK_ID(HTML_IFRAME_ID);
	    HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    HTML_put_string(me, (id_string ? id_string : href));
	    FREE(href);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
	    HText_endAnchor(me->text, 0);
	    LYEnsureSingleSpace(me);
	    CAN_JUSTIFY_POP;
	} else {
	    CHECK_ID(HTML_IFRAME_ID);
	}
	FREE(id_string);
	break;

    case HTML_BANNER:
    case HTML_MARQUEE:
	change_paragraph_style(me, styles[HTML_BANNER]);
	UPDATE_STYLE;
	if (me->sp->tag_number == (int) ElementNumber)
	    LYEnsureDoubleSpace(me);
	/*
	 * Treat this as a toolbar if we don't have one yet, and we are in the
	 * first half of the first page.  - FM
	 */
	if ((!HText_hasToolbar(me->text) &&
	     HText_getLines(me->text) < (display_lines / 2)) &&
	    (ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
					      LYToolbarName,	/* Tag */
					      NULL,	/* Addresss */
					      (HTLinkType *) 0))) {	/* Type */
	    HText_beginAnchor(me->text, me->inUnderline, ID_A);
	    HText_endAnchor(me->text, 0);
	    HText_setToolbar(me->text);
	}
	CHECK_ID(HTML_GEN_ID);
	break;

    case HTML_CENTER:
    case HTML_DIV:
	if (me->Division_Level < (MAX_NESTING - 1)) {
	    me->Division_Level++;
	} else {
	    CTRACE((tfp,
		    "HTML: ****** Maximum nesting of %d divisions exceeded!\n",
		    MAX_NESTING));
	}
	if (me->inP)
	    LYEnsureSingleSpace(me);	/* always at least break line - kw */
	if (ElementNumber == HTML_CENTER) {
	    me->DivisionAlignments[me->Division_Level] = HT_CENTER;
	    change_paragraph_style(me, styles[HTML_DCENTER]);
	    UPDATE_STYLE;
	    me->current_default_alignment = styles[HTML_DCENTER]->alignment;
	} else if (me->List_Nesting_Level >= 0 &&
		   !(present && present[HTML_DIV_ALIGN] &&
		     value[HTML_DIV_ALIGN] &&
		     (!strcasecomp(value[HTML_DIV_ALIGN], "center") ||
		      !strcasecomp(value[HTML_DIV_ALIGN], "right")))) {
	    if (present && present[HTML_DIV_ALIGN])
		me->current_default_alignment = HT_LEFT;
	    else if (me->Division_Level == 0)
		me->current_default_alignment = HT_LEFT;
	    else if (me->sp[0].tag_number == HTML_UL ||
		     me->sp[0].tag_number == HTML_OL ||
		     me->sp[0].tag_number == HTML_MENU ||
		     me->sp[0].tag_number == HTML_DIR ||
		     me->sp[0].tag_number == HTML_LI ||
		     me->sp[0].tag_number == HTML_LH ||
		     me->sp[0].tag_number == HTML_DD)
		me->current_default_alignment = HT_LEFT;
	    LYHandlePlike(me, present, value, include, HTML_DIV_ALIGN, TRUE);
	    me->DivisionAlignments[me->Division_Level] = (short)
		me->current_default_alignment;
	} else if (present && present[HTML_DIV_ALIGN] &&
		   non_empty(value[HTML_DIV_ALIGN])) {
	    if (!strcasecomp(value[HTML_DIV_ALIGN], "center")) {
		me->DivisionAlignments[me->Division_Level] = HT_CENTER;
		change_paragraph_style(me, styles[HTML_DCENTER]);
		UPDATE_STYLE;
		me->current_default_alignment = styles[HTML_DCENTER]->alignment;
	    } else if (!strcasecomp(value[HTML_DIV_ALIGN], "right")) {
		me->DivisionAlignments[me->Division_Level] = HT_RIGHT;
		change_paragraph_style(me, styles[HTML_DRIGHT]);
		UPDATE_STYLE;
		me->current_default_alignment = styles[HTML_DRIGHT]->alignment;
	    } else {
		me->DivisionAlignments[me->Division_Level] = HT_LEFT;
		change_paragraph_style(me, styles[HTML_DLEFT]);
		UPDATE_STYLE;
		me->current_default_alignment = styles[HTML_DLEFT]->alignment;
	    }
	} else {
	    me->DivisionAlignments[me->Division_Level] = HT_LEFT;
	    change_paragraph_style(me, styles[HTML_DLEFT]);
	    UPDATE_STYLE;
	    me->current_default_alignment = styles[HTML_DLEFT]->alignment;
	}
	CHECK_ID(HTML_DIV_ID);
	break;

    case HTML_H1:
    case HTML_H2:
    case HTML_H3:
    case HTML_H4:
    case HTML_H5:
    case HTML_H6:
	/*
	 * Close the previous style if not done by HTML doc.  Added to get rid
	 * of core dumps in BAD HTML on the net.
	 *              GAB 07-07-94
	 * But then again, these are actually allowed to nest.  I guess I have
	 * to depend on the HTML writers correct style.
	 *              GAB 07-12-94
	 if (i_prior_style != -1) {
	 HTML_end_element(me, i_prior_style);
	 }
	 i_prior_style = ElementNumber;
	 */

	/*
	 * Check whether we have an H# in a list, and if so, treat it as an LH. 
	 * - FM
	 */
	if ((me->List_Nesting_Level >= 0) &&
	    (me->sp[0].tag_number == HTML_UL ||
	     me->sp[0].tag_number == HTML_OL ||
	     me->sp[0].tag_number == HTML_MENU ||
	     me->sp[0].tag_number == HTML_DIR ||
	     me->sp[0].tag_number == HTML_LI)) {
	    if (HTML_dtd.tags[HTML_LH].contents == SGML_EMPTY) {
		ElementNumber = HTML_LH;
	    } else {
		me->new_style = me->sp[0].style;
		ElementNumber = (HTMLElement) me->sp[0].tag_number;
		UPDATE_STYLE;
	    }
	    /*
	     * Some authors use H# headers as a substitute for FONT, so check
	     * if this one immediately followed an LI.  If so, both me->inP and
	     * me->in_word will be FALSE (though the line might not be empty
	     * due to a bullet and/or nbsp) and we can assume it is just for a
	     * FONT change.  We thus will not create another line break nor add
	     * to the current left indentation.  - FM
	     */
	    if (!(me->inP == FALSE && me->in_word == NO)) {
		HText_appendParagraph(me->text);
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
		me->in_word = NO;
		me->inP = FALSE;
	    }
	    CHECK_ID(HTML_H_ID);
	    break;
	}

	if (present && present[HTML_H_ALIGN] &&
	    non_empty(value[HTML_H_ALIGN])) {
	    if (!strcasecomp(value[HTML_H_ALIGN], "center"))
		change_paragraph_style(me, styles[HTML_HCENTER]);
	    else if (!strcasecomp(value[HTML_H_ALIGN], "right"))
		change_paragraph_style(me, styles[HTML_HRIGHT]);
	    else if (!strcasecomp(value[HTML_H_ALIGN], "left") ||
		     !strcasecomp(value[HTML_H_ALIGN], "justify"))
		change_paragraph_style(me, styles[HTML_HLEFT]);
	    else
		change_paragraph_style(me, styles[ElementNumber]);
	} else if (me->Division_Level >= 0) {
	    if (me->DivisionAlignments[me->Division_Level] == HT_CENTER) {
		change_paragraph_style(me, styles[HTML_HCENTER]);
	    } else if (me->DivisionAlignments[me->Division_Level] == HT_LEFT) {
		change_paragraph_style(me, styles[HTML_HLEFT]);
	    } else if (me->DivisionAlignments[me->Division_Level] == HT_RIGHT) {
		change_paragraph_style(me, styles[HTML_HRIGHT]);
	    }
	} else {
	    change_paragraph_style(me, styles[ElementNumber]);
	}
	UPDATE_STYLE;
	CHECK_ID(HTML_H_ID);

	if ((bold_headers == TRUE ||
	     (ElementNumber == HTML_H1 && bold_H1 == TRUE)) &&
	    (styles[ElementNumber]->font & HT_BOLD)) {
	    if (me->inBoldA == FALSE && me->inBoldH == FALSE) {
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    }
	    me->inBoldH = TRUE;
	}
	break;

    case HTML_P:
	LYHandlePlike(me, present, value, include, HTML_P_ALIGN, TRUE);
	CHECK_ID(HTML_P_ID);
	break;

    case HTML_BR:
	UPDATE_STYLE;
	CHECK_ID(HTML_GEN_ID);
	/* Add a \r (new line) if these three conditions are true:
	 *   1. We are not collapsing BR's, and
	 *   2. The previous line has text on it, or
	 *   3. This line has text on it.
	 * Otherwise, don't do anything. -DH 980814, TD 980827
	 */
	if ((LYCollapseBRs == FALSE &&
	     !HText_PreviousLineEmpty(me->text, FALSE)) ||
	    !HText_LastLineEmpty(me->text, FALSE)) {
	    HText_setLastChar(me->text, ' ');	/* absorb white space */
	    HText_appendCharacter(me->text, '\r');
	}
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_WBR:
	UPDATE_STYLE;
	CHECK_ID(HTML_GEN_ID);
	HText_setBreakPoint(me->text);
	break;

    case HTML_HY:
    case HTML_SHY:
	UPDATE_STYLE;
	CHECK_ID(HTML_GEN_ID);
	HText_appendCharacter(me->text, LY_SOFT_HYPHEN);
	break;

    case HTML_HR:
	{
	    int width;

	    /*
	     * Start a new line only if we had printable characters following
	     * the previous newline, or remove the previous line if both it and
	     * the last line are blank.  - FM
	     */
	    UPDATE_STYLE;
	    if (!HText_LastLineEmpty(me->text, FALSE)) {
		HText_setLastChar(me->text, ' ');	/* absorb white space */
		HText_appendCharacter(me->text, '\r');
	    } else if (HText_PreviousLineEmpty(me->text, FALSE)) {
		HText_RemovePreviousLine(me->text);
	    }
	    me->in_word = NO;
	    me->inP = FALSE;

	    /*
	     * Add an ID link if needed.  - FM
	     */
	    CHECK_ID(HTML_HR_ID);

	    /*
	     * Center lines within the current margins, if a right or left
	     * ALIGNment is not specified.  If WIDTH="#%" is given and not
	     * garbage, use that to calculate the width, otherwise use the
	     * default width.  - FM
	     */
	    if (present && present[HTML_HR_ALIGN] && value[HTML_HR_ALIGN]) {
		if (!strcasecomp(value[HTML_HR_ALIGN], "right")) {
		    me->sp->style->alignment = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_HR_ALIGN], "left")) {
		    me->sp->style->alignment = HT_LEFT;
		} else {
		    me->sp->style->alignment = HT_CENTER;
		}
	    } else {
		me->sp->style->alignment = HT_CENTER;
	    }
	    width = LYcolLimit -
		me->new_style->leftIndent - me->new_style->rightIndent;
	    if (present && present[HTML_HR_WIDTH] && value[HTML_HR_WIDTH] &&
		isdigit(UCH(*value[HTML_HR_WIDTH])) &&
		value[HTML_HR_WIDTH][strlen(value[HTML_HR_WIDTH]) - 1] == '%') {
		char *percent = NULL;
		int Percent, Width;

		StrAllocCopy(percent, value[HTML_HR_WIDTH]);
		percent[strlen(percent) - 1] = '\0';
		Percent = atoi(percent);
		if (Percent > 100 || Percent < 1)
		    width -= 5;
		else {
		    Width = (width * Percent) / 100;
		    if (Width < 1)
			width = 1;
		    else
			width = Width;
		}
		FREE(percent);
	    } else {
		width -= 5;
	    }
	    for (i = 0; i < width; i++)
		HTML_put_character(me, '_');
	    HText_appendCharacter(me->text, '\r');
	    me->in_word = NO;
	    me->inP = FALSE;

	    /*
	     * Reset the alignment appropriately for the division and/or block. 
	     * - FM
	     */
	    if (me->List_Nesting_Level < 0 &&
		me->Division_Level >= 0) {
		me->sp->style->alignment =
		    me->DivisionAlignments[me->Division_Level];
	    } else if (me->sp->style->id == ST_HeadingCenter ||
		       me->sp->style->id == ST_Heading1) {
		me->sp->style->alignment = HT_CENTER;
	    } else if (me->sp->style->id == ST_HeadingRight) {
		me->sp->style->alignment = HT_RIGHT;
	    } else {
		me->sp->style->alignment = HT_LEFT;
	    }

	    /*
	     * Add a blank line and set the second line indentation for lists
	     * and addresses, or a paragraph separator for other blocks.  - FM
	     */
	    if (me->List_Nesting_Level >= 0 ||
		me->sp[0].tag_number == HTML_ADDRESS) {
		HText_setLastChar(me->text, ' ');	/* absorb white space */
		HText_appendCharacter(me->text, '\r');
	    } else {
		HText_appendParagraph(me->text);
	    }
	}
	break;

    case HTML_TAB:
	if (!present) {		/* Bad tag.  Must have at least one attribute. - FM */
	    CTRACE((tfp, "HTML: TAB tag has no attributes.  Ignored.\n"));
	    break;
	}
	/*
	 * If page author is using TAB within a TABLE, it's probably formatted
	 * specifically to work well for Lynx without simple table tracking
	 * code.  Cancel tracking, it would only make things worse.  - kw
	 */
	HText_cancelStbl(me->text);
	UPDATE_STYLE;

	CANT_JUSTIFY_THIS_LINE;
	if (present[HTML_TAB_ALIGN] && value[HTML_TAB_ALIGN] &&
	    (strcasecomp(value[HTML_TAB_ALIGN], "left") ||
	     !(present[HTML_TAB_TO] || present[HTML_TAB_INDENT]))) {
	    /*
	     * Just ensure a collapsible space, until we have the ALIGN and DP
	     * attributes implemented.  - FM
	     */
	    HTML_put_character(me, ' ');
	    CTRACE((tfp,
		    "HTML: ALIGN not 'left'.  Using space instead of TAB.\n"));

	} else if (!LYoverride_default_alignment(me) &&
		   me->current_default_alignment != HT_LEFT) {
	    /*
	     * Just ensure a collapsible space, until we can replace
	     * HText_getCurrentColumn() in GridText.c with code which doesn't
	     * require that the alignment be HT_LEFT.  - FM
	     */
	    HTML_put_character(me, ' ');
	    CTRACE((tfp, "HTML: Not HT_LEFT.  Using space instead of TAB.\n"));

	} else if ((present[HTML_TAB_TO] &&
		    non_empty(value[HTML_TAB_TO])) ||
		   (present[HTML_TAB_INDENT] &&
		    value[HTML_TAB_INDENT] &&
		    isdigit(UCH(*value[HTML_TAB_INDENT])))) {
	    int column, target = -1;
	    int enval = 2;

	    column = HText_getCurrentColumn(me->text);
	    if (present[HTML_TAB_TO]) {
		/*
		 * TO has priority over INDENT if both are present.  - FM
		 */
		StrAllocCopy(temp, value[HTML_TAB_TO]);
		TRANSLATE_AND_UNESCAPE_TO_STD(&temp);
		if (*temp) {
		    target = HText_getTabIDColumn(me->text, temp);
		}
	    } else if (isEmpty(temp) && present[HTML_TAB_INDENT] &&
		       value[HTML_TAB_INDENT] &&
		       isdigit(UCH(*value[HTML_TAB_INDENT]))) {
		/*
		 * The INDENT value is in "en" (enval per column) units.
		 * Divide it by enval, rounding odd values up.  - FM
		 */
		target =
		    (int) (((1.0 * atoi(value[HTML_TAB_INDENT])) / enval) + (0.5));
	    }
	    FREE(temp);
	    /*
	     * If we are being directed to a column too far to the left or
	     * right, just add a collapsible space, otherwise, add the
	     * appropriate number of spaces.  - FM
	     */

	    if (target < column ||
		target > HText_getMaximumColumn(me->text)) {
		HTML_put_character(me, ' ');
		CTRACE((tfp,
			"HTML: Column out of bounds.  Using space instead of TAB.\n"));
	    } else {
		for (i = column; i < target; i++)
		    HText_appendCharacter(me->text, ' ');
		HText_setLastChar(me->text, ' ');	/* absorb white space */
	    }
	}
	me->in_word = NO;

	/*
	 * If we have an ID attribute, save it together with the value of the
	 * column we've reached.  - FM
	 */
	if (present[HTML_TAB_ID] &&
	    non_empty(value[HTML_TAB_ID])) {
	    StrAllocCopy(temp, value[HTML_TAB_ID]);
	    TRANSLATE_AND_UNESCAPE_TO_STD(&temp);
	    if (*temp)
		HText_setTabID(me->text, temp);
	    FREE(temp);
	}
	break;

    case HTML_BASEFONT:
	break;

    case HTML_FONT:

	/*
	 * FONT *may* have been declared SGML_EMPTY in HTMLDTD.c, and
	 * SGML_character() in SGML.c *may* check for a FONT end tag to call
	 * HTML_end_element() directly (with a check in that to bypass
	 * decrementing of the HTML parser's stack).  Or this may have been
	 * really a </FONT> end tag, for which some incarnations of SGML.c
	 * would fake a <FONT> start tag instead.  - fm & kw
	 *
	 * But if we have an open FONT, DON'T close that one now, since FONT
	 * tags can be legally nested AFAIK, and Lynx currently doesn't do
	 * anything with them anyway...  - kw
	 */
#ifdef NOTUSED_FOTEMODS
	if (me->inFONT == TRUE)
	    HTML_end_element(me, HTML_FONT, &include);
#endif /* NOTUSED_FOTEMODS */

	/*
	 * Set flag to know we are in a FONT container, and add code to do
	 * something about it, someday.  - FM
	 */
	me->inFONT = TRUE;
	break;

    case HTML_B:		/* Physical character highlighting */
    case HTML_BLINK:
    case HTML_I:
    case HTML_U:

    case HTML_CITE:		/* Logical character highlighting */
    case HTML_EM:
    case HTML_STRONG:
	UPDATE_STYLE;
	me->Underline_Level++;
	CHECK_ID(HTML_GEN_ID);
	/*
	 * Ignore this if inside of a bold anchor or header.  Can't display
	 * both underline and bold at same time.
	 */
	if (me->inBoldA == TRUE || me->inBoldH == TRUE) {
	    CTRACE((tfp, "Underline Level is %d\n", me->Underline_Level));
	    break;
	}
	if (me->inUnderline == FALSE) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    me->inUnderline = TRUE;
	    CTRACE((tfp, "Beginning underline\n"));
	} else {
	    CTRACE((tfp, "Underline Level is %d\n", me->Underline_Level));
	}
	break;

    case HTML_ABBREV:		/* Miscellaneous character containers */
    case HTML_ACRONYM:
    case HTML_AU:
    case HTML_AUTHOR:
    case HTML_BIG:
    case HTML_CODE:
    case HTML_DFN:
    case HTML_KBD:
    case HTML_SAMP:
    case HTML_SMALL:
    case HTML_TT:
    case HTML_VAR:
	CHECK_ID(HTML_GEN_ID);
	break;			/* ignore */

    case HTML_SUP:
	HText_appendCharacter(me->text, '^');
	CHECK_ID(HTML_GEN_ID);
	break;

    case HTML_SUB:
	HText_appendCharacter(me->text, '[');
	CHECK_ID(HTML_GEN_ID);
	break;

    case HTML_DEL:
    case HTML_S:
    case HTML_STRIKE:
	CHECK_ID(HTML_GEN_ID);
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	HTML_put_string(me, "[DEL:");
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	HTML_put_character(me, ' ');
	me->in_word = NO;
	break;

    case HTML_INS:
	CHECK_ID(HTML_GEN_ID);
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	HTML_put_string(me, "[INS:");
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	HTML_put_character(me, ' ');
	me->in_word = NO;
	break;

    case HTML_Q:
	CHECK_ID(HTML_GEN_ID);
	/*
	 * Should check LANG and/or DIR attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * to determine whether we should use chevrons, but for now we'll
	 * always use double- or single-quotes.  - FM
	 */
	if (!(me->Quote_Level & 1))
	    HTML_put_character(me, '"');
	else
	    HTML_put_character(me, '`');
	me->Quote_Level++;
	break;

    case HTML_PRE:		/* Formatted text */
	/*
	 * Set our inPRE flag to FALSE so that a newline immediately following
	 * the PRE start tag will be ignored.  HTML_put_character() will set it
	 * to TRUE when the first character within the PRE block is received. 
	 * - FM
	 */
	me->inPRE = FALSE;
	/* FALLTHRU */
    case HTML_LISTING:		/* Literal text */
	/* FALLTHRU */
    case HTML_XMP:
	/* FALLTHRU */
    case HTML_PLAINTEXT:
	change_paragraph_style(me, styles[ElementNumber]);
	UPDATE_STYLE;
	CHECK_ID(HTML_GEN_ID);
	if (me->comment_end)
	    HText_appendText(me->text, me->comment_end);
	break;

    case HTML_BLOCKQUOTE:
    case HTML_BQ:
	change_paragraph_style(me, styles[ElementNumber]);
	UPDATE_STYLE;
	if (me->sp->tag_number == (int) ElementNumber)
	    LYEnsureDoubleSpace(me);
	CHECK_ID(HTML_BQ_ID);
	break;

    case HTML_NOTE:
	change_paragraph_style(me, styles[ElementNumber]);
	UPDATE_STYLE;
	if (me->sp->tag_number == (int) ElementNumber)
	    LYEnsureDoubleSpace(me);
	CHECK_ID(HTML_NOTE_ID);
	{
	    char *note = NULL;

	    /*
	     * Indicate the type of NOTE.
	     */
	    if (present && present[HTML_NOTE_CLASS] &&
		value[HTML_NOTE_CLASS] &&
		(!strcasecomp(value[HTML_NOTE_CLASS], "CAUTION") ||
		 !strcasecomp(value[HTML_NOTE_CLASS], "WARNING"))) {
		StrAllocCopy(note, value[HTML_NOTE_CLASS]);
		LYUpperCase(note);
		StrAllocCat(note, ":");
	    } else if (present && present[HTML_NOTE_ROLE] &&
		       value[HTML_NOTE_ROLE] &&
		       (!strcasecomp(value[HTML_NOTE_ROLE], "CAUTION") ||
			!strcasecomp(value[HTML_NOTE_ROLE], "WARNING"))) {
		StrAllocCopy(note, value[HTML_NOTE_ROLE]);
		LYUpperCase(note);
		StrAllocCat(note, ":");
	    } else {
		StrAllocCopy(note, "NOTE:");
	    }
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    HTML_put_string(me, note);
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    HTML_put_character(me, ' ');
	    CAN_JUSTIFY_START;
	    FREE(note);
	}
	CAN_JUSTIFY_START;
	me->inLABEL = TRUE;
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_ADDRESS:
	change_paragraph_style(me, styles[ElementNumber]);
	UPDATE_STYLE;
	if (me->sp->tag_number == (int) ElementNumber)
	    LYEnsureDoubleSpace(me);
	CHECK_ID(HTML_ADDRESS_ID);
	break;

    case HTML_DL:
	me->List_Nesting_Level++;	/* increment the List nesting level */
	if (me->List_Nesting_Level <= 0) {
	    change_paragraph_style(me, present && present[HTML_DL_COMPACT]
				   ? styles[HTML_DLC] : styles[HTML_DL]);

	} else if (me->List_Nesting_Level >= 6) {
	    change_paragraph_style(me, present && present[HTML_DL_COMPACT]
				   ? styles[HTML_DLC6] : styles[HTML_DL6]);

	} else {
	    change_paragraph_style(me, present && present[HTML_DL_COMPACT]
				   ? styles[(HTML_DLC1 - 1) + me->List_Nesting_Level]
				   : styles[(HTML_DL1 - 1) + me->List_Nesting_Level]);
	}
	UPDATE_STYLE;		/* update to the new style */
	CHECK_ID(HTML_DL_ID);

	break;

    case HTML_DLC:
	me->List_Nesting_Level++;	/* increment the List nesting level */
	if (me->List_Nesting_Level <= 0) {
	    change_paragraph_style(me, styles[HTML_DLC]);

	} else if (me->List_Nesting_Level >= 6) {
	    change_paragraph_style(me, styles[HTML_DLC6]);

	} else {
	    change_paragraph_style(me,
				   styles[(HTML_DLC1 - 1) + me->List_Nesting_Level]);
	}
	UPDATE_STYLE;		/* update to the new style */
	CHECK_ID(HTML_DL_ID);
	break;

    case HTML_DT:
	CHECK_ID(HTML_GEN_ID);
	if (!me->style_change) {
	    BOOL in_line_1 = HText_inLineOne(me->text);
	    HTCoord saved_spaceBefore = me->sp->style->spaceBefore;
	    HTCoord saved_spaceAfter = me->sp->style->spaceAfter;

	    /*
	     * If there are several DT elements and this is not the first, and
	     * the preceding DT element's first (and normally only) line has
	     * not yet been ended, suppress intervening blank line by
	     * temporarily modifying the paragraph style in place.  Ugly but
	     * there's ample precedence.  - kw
	     */
	    if (in_line_1) {
		me->sp->style->spaceBefore = 0;		/* temporary change */
		me->sp->style->spaceAfter = 0;	/* temporary change */
	    }
	    HText_appendParagraph(me->text);
	    me->sp->style->spaceBefore = saved_spaceBefore;	/* undo */
	    me->sp->style->spaceAfter = saved_spaceAfter;	/* undo */
	    me->in_word = NO;
	    me->sp->style->alignment = HT_LEFT;
	}
	me->inP = FALSE;
	break;

    case HTML_DD:
	CHECK_ID(HTML_GEN_ID);
	HText_setLastChar(me->text, ' ');	/* absorb white space */
	if (!me->style_change) {
	    if (!HText_LastLineEmpty(me->text, FALSE)) {
		HText_appendCharacter(me->text, '\r');
	    } else {
		HText_NegateLineOne(me->text);
	    }
	} else {
	    UPDATE_STYLE;
	    HText_appendCharacter(me->text, '\t');
	}
	me->sp->style->alignment = HT_LEFT;
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_OL:
	/*
	 * Set the default TYPE.
	 */
	me->OL_Type[(me->List_Nesting_Level < 11 ?
		     me->List_Nesting_Level + 1 : 11)] = '1';

	/*
	 * Check whether we have a starting sequence number, or want to
	 * continue the numbering from a previous OL in this nest.  - FM
	 */
	if (present && (present[HTML_OL_SEQNUM] || present[HTML_OL_START])) {
	    int seqnum;

	    /*
	     * Give preference to the valid HTML 3.0 SEQNUM attribute name over
	     * the Netscape START attribute name (too bad the Netscape
	     * developers didn't read the HTML 3.0 specs before re-inventing
	     * the "wheel" as "we'll").  - FM
	     */
	    if (present[HTML_OL_SEQNUM] &&
		non_empty(value[HTML_OL_SEQNUM])) {
		seqnum = atoi(value[HTML_OL_SEQNUM]);
	    } else if (present[HTML_OL_START] &&
		       non_empty(value[HTML_OL_START])) {
		seqnum = atoi(value[HTML_OL_START]);
	    } else {
		seqnum = 1;
	    }

	    /*
	     * Don't allow negative numbers less than or equal to our flags, or
	     * numbers less than 1 if an Alphabetic or Roman TYPE.  - FM
	     */
	    if (present[HTML_OL_TYPE] && value[HTML_OL_TYPE]) {
		if (*value[HTML_OL_TYPE] == 'A') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'A';
		    if (seqnum < 1)
			seqnum = 1;
		} else if (*value[HTML_OL_TYPE] == 'a') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'a';
		    if (seqnum < 1)
			seqnum = 1;
		} else if (*value[HTML_OL_TYPE] == 'I') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'I';
		    if (seqnum < 1)
			seqnum = 1;
		} else if (*value[HTML_OL_TYPE] == 'i') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'i';
		    if (seqnum < 1)
			seqnum = 1;
		} else {
		    if (seqnum <= OL_VOID)
			seqnum = OL_VOID + 1;
		}
	    } else if (seqnum <= OL_VOID) {
		seqnum = OL_VOID + 1;
	    }

	    me->OL_Counter[(me->List_Nesting_Level < 11 ?
			    me->List_Nesting_Level + 1 : 11)] = seqnum;

	} else if (present && present[HTML_OL_CONTINUE]) {
	    me->OL_Counter[me->List_Nesting_Level < 11 ?
			   me->List_Nesting_Level + 1 : 11] = OL_CONTINUE;

	} else {
	    me->OL_Counter[(me->List_Nesting_Level < 11 ?
			    me->List_Nesting_Level + 1 : 11)] = 1;
	    if (present && present[HTML_OL_TYPE] && value[HTML_OL_TYPE]) {
		if (*value[HTML_OL_TYPE] == 'A') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'A';
		} else if (*value[HTML_OL_TYPE] == 'a') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'a';
		} else if (*value[HTML_OL_TYPE] == 'I') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'I';
		} else if (*value[HTML_OL_TYPE] == 'i') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'i';
		}
	    }
	}
	me->List_Nesting_Level++;

	if (me->List_Nesting_Level <= 0) {
	    change_paragraph_style(me, styles[ElementNumber]);

	} else if (me->List_Nesting_Level >= 6) {
	    change_paragraph_style(me, styles[HTML_OL6]);

	} else {
	    change_paragraph_style(me,
				   styles[HTML_OL1 + me->List_Nesting_Level - 1]);
	}
	UPDATE_STYLE;		/* update to the new style */
	CHECK_ID(HTML_OL_ID);
	break;

    case HTML_UL:
	me->List_Nesting_Level++;

	if (me->List_Nesting_Level <= 0) {
	    if (!(present && present[HTML_UL_PLAIN]) &&
		!(present && present[HTML_UL_TYPE] &&
		  value[HTML_UL_TYPE] &&
		  0 == strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
		change_paragraph_style(me, styles[ElementNumber]);
	    } else {
		change_paragraph_style(me, styles[HTML_DIR]);
		ElementNumber = HTML_DIR;
	    }

	} else if (me->List_Nesting_Level >= 6) {
	    if (!(present && present[HTML_UL_PLAIN]) &&
		!(present && present[HTML_UL_TYPE] &&
		  value[HTML_UL_TYPE] &&
		  0 == strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
		change_paragraph_style(me, styles[HTML_OL6]);
	    } else {
		change_paragraph_style(me, styles[HTML_MENU6]);
		ElementNumber = HTML_DIR;
	    }

	} else {
	    if (!(present && present[HTML_UL_PLAIN]) &&
		!(present && present[HTML_UL_TYPE] &&
		  value[HTML_UL_TYPE] &&
		  0 == strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
		change_paragraph_style(me,
				       styles[HTML_OL1 + me->List_Nesting_Level
					      - 1]);
	    } else {
		change_paragraph_style(me,
				       styles[HTML_MENU1 + me->List_Nesting_Level
					      - 1]);
		ElementNumber = HTML_DIR;
	    }
	}
	UPDATE_STYLE;		/* update to the new style */
	CHECK_ID(HTML_UL_ID);
	break;

    case HTML_MENU:
    case HTML_DIR:
	me->List_Nesting_Level++;

	if (me->List_Nesting_Level <= 0) {
	    change_paragraph_style(me, styles[ElementNumber]);

	} else if (me->List_Nesting_Level >= 6) {
	    change_paragraph_style(me, styles[HTML_MENU6]);

	} else {
	    change_paragraph_style(me,
				   styles[HTML_MENU1 + me->List_Nesting_Level
					  - 1]);
	}
	UPDATE_STYLE;		/* update to the new style */
	CHECK_ID(HTML_UL_ID);
	break;

    case HTML_LH:
	UPDATE_STYLE;		/* update to the new style */
	HText_appendParagraph(me->text);
	CHECK_ID(HTML_GEN_ID);
	HTML_put_character(me, HT_NON_BREAK_SPACE);
	HText_setLastChar(me->text, ' ');
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_LI:
	UPDATE_STYLE;		/* update to the new style */
	HText_appendParagraph(me->text);
	me->sp->style->alignment = HT_LEFT;
	CHECK_ID(HTML_LI_ID);
	{
	    int surrounding_tag_number = me->sp[0].tag_number;

	    /*
	     * No, a LI should never occur directly within another LI, but this
	     * may result from incomplete error recovery.  So check one more
	     * surrounding level in this case.  - kw
	     */
	    if (surrounding_tag_number == HTML_LI &&
		me->sp < (me->stack + MAX_NESTING - 1))
		surrounding_tag_number = me->sp[1].tag_number;
	    if (surrounding_tag_number == HTML_OL) {
		char number_string[20];
		int counter, seqnum;
		char seqtype;

		counter = me->List_Nesting_Level < 11 ?
		    me->List_Nesting_Level : 11;
		if (present && present[HTML_LI_TYPE] && value[HTML_LI_TYPE]) {
		    if (*value[HTML_LI_TYPE] == '1') {
			me->OL_Type[counter] = '1';
		    } else if (*value[HTML_LI_TYPE] == 'A') {
			me->OL_Type[counter] = 'A';
		    } else if (*value[HTML_LI_TYPE] == 'a') {
			me->OL_Type[counter] = 'a';
		    } else if (*value[HTML_LI_TYPE] == 'I') {
			me->OL_Type[counter] = 'I';
		    } else if (*value[HTML_LI_TYPE] == 'i') {
			me->OL_Type[counter] = 'i';
		    }
		}
		if (present && present[HTML_LI_VALUE] &&
		    ((value[HTML_LI_VALUE] != NULL) &&
		     (*value[HTML_LI_VALUE] != '\0')) &&
		    ((isdigit(UCH(*value[HTML_LI_VALUE]))) ||
		     (*value[HTML_LI_VALUE] == '-' &&
		      isdigit(UCH(*(value[HTML_LI_VALUE] + 1)))))) {
		    seqnum = atoi(value[HTML_LI_VALUE]);
		    if (seqnum <= OL_VOID)
			seqnum = OL_VOID + 1;
		    seqtype = me->OL_Type[counter];
		    if (seqtype != '1' && seqnum < 1)
			seqnum = 1;
		    me->OL_Counter[counter] = seqnum + 1;
		} else if (me->OL_Counter[counter] >= OL_VOID) {
		    seqnum = me->OL_Counter[counter]++;
		    seqtype = me->OL_Type[counter];
		    if (seqtype != '1' && seqnum < 1) {
			seqnum = 1;
			me->OL_Counter[counter] = seqnum + 1;
		    }
		} else {
		    seqnum = me->Last_OL_Count + 1;
		    seqtype = me->Last_OL_Type;
		    for (i = (counter - 1); i >= 0; i--) {
			if (me->OL_Counter[i] > OL_VOID) {
			    seqnum = me->OL_Counter[i]++;
			    seqtype = me->OL_Type[i];
			    i = 0;
			}
		    }
		}
		if (seqtype == 'A') {
		    sprintf(number_string, LYUppercaseA_OL_String(seqnum));
		} else if (seqtype == 'a') {
		    sprintf(number_string, LYLowercaseA_OL_String(seqnum));
		} else if (seqtype == 'I') {
		    sprintf(number_string, LYUppercaseI_OL_String(seqnum));
		} else if (seqtype == 'i') {
		    sprintf(number_string, LYLowercaseI_OL_String(seqnum));
		} else {
		    sprintf(number_string, "%2d.", seqnum);
		}
		me->Last_OL_Count = seqnum;
		me->Last_OL_Type = seqtype;
		/*
		 * Hack, because there is no append string!
		 */
		for (i = 0; number_string[i] != '\0'; i++)
		    if (number_string[i] == ' ')
			HTML_put_character(me, HT_NON_BREAK_SPACE);
		    else
			HTML_put_character(me, number_string[i]);

		/*
		 * Use HTML_put_character so that any other spaces coming
		 * through will be collapsed.  We'll use nbsp, so it won't
		 * break at the spacing character if there are no spaces in the
		 * subsequent text up to the right margin, but will declare it
		 * as a normal space to ensure collapsing if a normal space
		 * does immediately follow it.  - FM
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
	    } else if (surrounding_tag_number == HTML_UL) {
		/*
		 * Hack, because there is no append string!
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		switch (me->List_Nesting_Level % 7) {
		case 0:
		    HTML_put_character(me, '*');
		    break;
		case 1:
		    HTML_put_character(me, '+');
		    break;
		case 2:
		    HTML_put_character(me, 'o');
		    break;
		case 3:
		    HTML_put_character(me, '#');
		    break;
		case 4:
		    HTML_put_character(me, '@@');
		    break;
		case 5:
		    HTML_put_character(me, '-');
		    break;
		case 6:
		    HTML_put_character(me, '=');
		    break;

		}
		/*
		 * Keep using HTML_put_character so that any other spaces
		 * coming through will be collapsed.  We use nbsp, so we won't
		 * wrap at the spacing character if there are no spaces in the
		 * subsequent text up to the right margin, but will declare it
		 * as a normal space to ensure collapsing if a normal space
		 * does immediately follow it.  - FM
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
	    } else {
		/*
		 * Hack, because there is no append string!
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
	    }
	}
	CAN_JUSTIFY_START;
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_SPAN:
	CHECK_ID(HTML_GEN_ID);
	/*
	 * Should check LANG and/or DIR attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * and do something here.  - FM
	 */
	break;

    case HTML_BDO:
	CHECK_ID(HTML_GEN_ID);
	/*
	 * Should check DIR (and LANG) attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * and do something here.  - FM
	 */
	break;

    case HTML_SPOT:
	CHECK_ID(HTML_GEN_ID);
	break;

    case HTML_FN:
	change_paragraph_style(me, styles[ElementNumber]);
	UPDATE_STYLE;
	if (me->sp->tag_number == (int) ElementNumber)
	    LYEnsureDoubleSpace(me);
	CHECK_ID(HTML_FN_ID);
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	HTML_put_string(me, "FOOTNOTE:");
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	HTML_put_character(me, ' ');
	CAN_JUSTIFY_START
	    me->inLABEL = TRUE;
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_A:
	/*
	 * If we are looking for client-side image maps, then handle an A
	 * within a MAP that has a COORDS attribute as an AREA tag. 
	 * Unfortunately we lose the anchor text this way for the LYNXIMGMAP,
	 * we would have to do much more parsing to collect it.  After
	 * potentially handling the A as AREA, always return immediately if
	 * only looking for image maps, without pushing anything on the style
	 * stack.  - kw
	 */
	if (me->map_address && present && present[HTML_A_COORDS])
	    LYStartArea(me,
			present[HTML_A_HREF] ? value[HTML_A_HREF] : NULL,
			NULL,
			present[HTML_A_TITLE] ? value[HTML_A_TITLE] : NULL,
			tag_charset);
	if (LYMapsOnly) {
	    return HT_OK;
	}
	/*
	 * A may have been declared SGML_EMPTY in HTMLDTD.c, and
	 * SGML_character() in SGML.c may check for an A end tag to call
	 * HTML_end_element() directly (with a check in that to bypass
	 * decrementing of the HTML parser's stack), so if we have an open A,
	 * close that one now.  - FM & kw
	 */
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	/*
	 * Set to know we are in an anchor.
	 */
	me->inA = TRUE;

	/*
	 * Load id_string if we have an ID or NAME.  - FM
	 */
	if (present && present[HTML_A_ID] &&
	    non_empty(value[HTML_A_ID])) {
	    StrAllocCopy(id_string, value[HTML_A_ID]);
	} else if (present && present[HTML_A_NAME] &&
		   non_empty(value[HTML_A_NAME])) {
	    StrAllocCopy(id_string, value[HTML_A_NAME]);
	}
	if (id_string)
	    TRANSLATE_AND_UNESCAPE_TO_STD(&id_string);

	/*
	 * Handle the reference.  - FM
	 */
	if (present && present[HTML_A_HREF]) {
	    /*
	     * Set to know we are making the content bold.
	     */
	    me->inBoldA = TRUE;

	    StrAllocCopy(href, value[HTML_A_HREF]);
	    if (isEmpty(href))
		StrAllocCopy(href, "#");
	    CHECK_FOR_INTERN(intern_flag, href);	/* '#' */

	    if (intern_flag) { /*** FAST WAY: ***/
		TRANSLATE_AND_UNESCAPE_TO_STD(&href);

	    } else {
		url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);

		/*
		 * Deal with our ftp gateway kludge.  - FM
		 */
		if (!url_type && !strncmp(href, "/foo/..", 7) &&
		    (isFTP_URL(me->node_anchor->address) ||
		     isFILE_URL(me->node_anchor->address))) {
		    for (i = 0; (href[i] = href[i + 7]) != 0; i++) ;
		}
	    }

	    if (present[HTML_A_ISMAP])	/*??? */
		intern_flag = FALSE;
	} else {
	    if (bold_name_anchors == TRUE) {
		me->inBoldA = TRUE;
	    }
	}

	if (present && present[HTML_A_TYPE] && value[HTML_A_TYPE]) {
	    StrAllocCopy(temp, value[HTML_A_TYPE]);
	    if (!intern_flag &&
		!strcasecomp(value[HTML_A_TYPE], HTAtom_name(HTInternalLink)) &&
		!LYIsUIPage3(me->node_anchor->address, UIP_LIST_PAGE, 0) &&
		!LYIsUIPage3(me->node_anchor->address, UIP_ADDRLIST_PAGE, 0) &&
		!isLYNXIMGMAP(me->node_anchor->address)) {
		/* Some kind of spoof?
		 * Found TYPE="internal link" but not in a valid context
		 * where we have written it. - kw
		 */
		CTRACE((tfp, "HTML: Found invalid HREF=\"%s\" TYPE=\"%s\"!\n",
			href, temp));
		FREE(temp);
	    }
	}

	me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						 id_string,	/* Tag */
						 href,	/* Address */
						 (temp
						  ? (HTLinkType *)
						  HTAtom_for(temp)
						  : INTERN_LT));	/* Type */
	FREE(temp);
	FREE(id_string);

	if (me->CurrentA && present) {
	    if (present[HTML_A_TITLE] &&
		non_empty(value[HTML_A_TITLE])) {
		StrAllocCopy(title, value[HTML_A_TITLE]);
		TRANSLATE_AND_UNESCAPE_ENTITIES(&title, TRUE, FALSE);
		LYTrimHead(title);
		LYTrimTail(title);
		if (*title == '\0') {
		    FREE(title);
		}
	    }
	    if (present[HTML_A_ISMAP])
		dest_ismap = TRUE;
	    if (present[HTML_A_CHARSET] &&
		non_empty(value[HTML_A_CHARSET])) {
		/*
		 * Set up to load the anchor's chartrans structures
		 * appropriately for the current display character set if it
		 * can handle what's claimed.  - FM
		 */
		StrAllocCopy(temp, value[HTML_A_CHARSET]);
		TRANSLATE_AND_UNESCAPE_TO_STD(&temp);
		dest_char_set = UCGetLYhndl_byMIME(temp);
		if (dest_char_set < 0) {
		    dest_char_set = UCLYhndl_for_unrec;
		}
	    }
	    if (title != NULL || dest_ismap == TRUE || dest_char_set >= 0) {
		dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		    );
	    }
	    if (dest && title != NULL && HTAnchor_title(dest) == NULL)
		HTAnchor_setTitle(dest, title);
	    if (dest && dest_ismap)
		dest->isISMAPScript = TRUE;
	    /* Don't allow CHARSET attribute to change *this* document's
	       charset assumption. - kw */
	    if (dest && dest != me->node_anchor && dest_char_set >= 0) {
		/*
		 * Load the anchor's chartrans structures.  This should be done
		 * more intelligently when setting up the structured object,
		 * but it gets the job done for now.  - FM
		 */
		HTAnchor_setUCInfoStage(dest, dest_char_set,
					UCT_STAGE_MIME,
					UCT_SETBY_DEFAULT);
		HTAnchor_setUCInfoStage(dest, dest_char_set,
					UCT_STAGE_PARSER,
					UCT_SETBY_LINK);
	    }
	    FREE(temp);
	    dest = NULL;
	    dest_ismap = FALSE;
	    FREE(title);
	}
	me->CurrentANum = HText_beginAnchor(me->text,
					    me->inUnderline, me->CurrentA);
	if (me->inBoldA == TRUE && me->inBoldH == FALSE)
	    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
#if defined(NOTUSED_FOTEMODS)
	/*
	 * Close an HREF-less NAMED-ed now if we aren't making their content
	 * bold, and let the check in HTML_end_element() deal with any dangling
	 * end tag this creates.  - FM
	 */
	if (href == NULL && me->inBoldA == FALSE) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
#else
	/*Close an HREF-less NAMED-ed now if force_empty_hrefless_a was
	   requested - VH */
	if (href == NULL && force_empty_hrefless_a) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
#endif
	FREE(href);
	break;

    case HTML_IMG:		/* Images */
	/*
	 * If we're in an anchor, get the destination, and if it's a clickable
	 * image for the current anchor, set our flags for faking a 0,0
	 * coordinate pair, which typically returns the image's default.  - FM
	 */
	if (me->inA && me->CurrentA) {
	    if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		 )) != NULL) {
		if (dest->isISMAPScript == TRUE) {
		    dest_ismap = TRUE;
		    CTRACE((tfp, "HTML: '%s' is an ISMAP script\n",
			    dest->address));
		} else if (present && present[HTML_IMG_ISMAP]) {
		    dest_ismap = TRUE;
		    dest->isISMAPScript = TRUE;
		    CTRACE((tfp, "HTML: Designating '%s' as an ISMAP script\n",
			    dest->address));
		}
	    }
	}

	intern_flag = FALSE;	/* unless set below - kw */
	/*
	 * If there's a USEMAP, resolve it.  - FM
	 */
	if (present && present[HTML_IMG_USEMAP] &&
	    non_empty(value[HTML_IMG_USEMAP])) {
	    StrAllocCopy(map_href, value[HTML_IMG_USEMAP]);
	    CHECK_FOR_INTERN(intern_flag, map_href);
	    url_type = LYLegitimizeHREF(me, &map_href, TRUE, TRUE);
	    /*
	     * If map_href ended up zero-length or otherwise doesn't have a
	     * hash, it can't be valid, so ignore it.  - FM
	     */
	    if (findPoundSelector(map_href) == NULL) {
		FREE(map_href);
	    }
	}

	/*
	 * Handle a MAP reference if we have one at this point.  - FM
	 */
	if (map_href) {
	    /*
	     * If the MAP reference doesn't yet begin with a scheme, check
	     * whether a base tag is in effect.  - FM
	     */
	    /*
	     * If the USEMAP value is a lone fragment and LYSeekFragMAPinCur is
	     * set, we'll use the current document's URL for resolving. 
	     * Otherwise use the BASE.  - kw
	     */
	    Base = (me->inBASE &&
		    !(*map_href == '#' && LYSeekFragMAPinCur == TRUE)) ?
		me->base_href : me->node_anchor->address;
	    HTParseALL(&map_href, Base);

	    /*
	     * Prepend our client-side MAP access field.  - FM
	     */
	    StrAllocCopy(temp, STR_LYNXIMGMAP);
	    StrAllocCat(temp, map_href);
	    StrAllocCopy(map_href, temp);
	    FREE(temp);
	}

	/*
	 * Check whether we want to suppress the server-side ISMAP link if a
	 * client-side MAP is present.  - FM
	 */
	if (LYNoISMAPifUSEMAP && map_href && dest_ismap) {
	    dest_ismap = FALSE;
	    dest = NULL;
	}

	/*
	 * Check for a TITLE attribute.  - FM
	 */
	if (present && present[HTML_IMG_TITLE] &&
	    non_empty(value[HTML_IMG_TITLE])) {
	    StrAllocCopy(title, value[HTML_IMG_TITLE]);
	    TRANSLATE_AND_UNESCAPE_ENTITIES(&title, TRUE, FALSE);
	    LYTrimHead(title);
	    LYTrimTail(title);
	    if (*title == '\0') {
		FREE(title);
	    }
	}

	/*
	 * If there's an ALT string, use it, unless the ALT string is
	 * zero-length or just spaces and we are making all SRCs links or have
	 * a USEMAP link.  - FM
	 */
	if (((present) &&
	     (present[HTML_IMG_ALT] && value[HTML_IMG_ALT])) &&
	    (!clickable_images ||
	     ((clickable_images || map_href) &&
	      *value[HTML_IMG_ALT] != '\0'))) {
	    StrAllocCopy(alt_string, value[HTML_IMG_ALT]);
	    TRANSLATE_AND_UNESCAPE_ENTITIES(&alt_string,
					    me->UsePlainSpace, me->HiddenValue);
	    /*
	     * If it's all spaces and we are making SRC or USEMAP links, treat
	     * it as zero-length.  - FM
	     */
	    if (clickable_images || map_href) {
		LYTrimHead(alt_string);
		LYTrimTail(alt_string);
		if (*alt_string == '\0') {
		    if (map_href) {
			StrAllocCopy(alt_string, (title ? title :
						  (temp = MakeNewMapValue(value,
									  "USEMAP"))));
			FREE(temp);
		    } else if (dest_ismap) {
			StrAllocCopy(alt_string, (title ? title :
						  (temp = MakeNewMapValue(value,
									  "ISMAP"))));
			FREE(temp);

		    } else if (me->inA == TRUE && dest) {
			StrAllocCopy(alt_string, (title ?
						  title :
						  VERBOSE_IMG(value, HTML_IMG_SRC,
							      "[LINK]")));

		    } else {
			StrAllocCopy(alt_string,
				     (title ? title :
				      ((present &&
					present[HTML_IMG_ISOBJECT]) ?
				       "(OBJECT)" :
				       VERBOSE_IMG(value, HTML_IMG_SRC,
						   "[INLINE]"))));
		    }
		}
	    }

	} else if (map_href) {
	    StrAllocCopy(alt_string, (title ? title :
				      (temp = MakeNewMapValue(value, "USEMAP"))));
	    FREE(temp);

	} else if ((dest_ismap == TRUE) ||
		   (me->inA && present && present[HTML_IMG_ISMAP])) {
	    StrAllocCopy(alt_string, (title ? title :
				      (temp = MakeNewMapValue(value, "ISMAP"))));
	    FREE(temp);

	} else if (me->inA == TRUE && dest) {
	    StrAllocCopy(alt_string, (title ?
				      title :
				      VERBOSE_IMG(value, HTML_IMG_SRC,
						  "[LINK]")));

	} else {
	    if (pseudo_inline_alts || clickable_images)
		StrAllocCopy(alt_string, (title ? title :
					  ((present &&
					    present[HTML_IMG_ISOBJECT]) ?
					   "(OBJECT)" :
					   VERBOSE_IMG(value, HTML_IMG_SRC,
						       "[INLINE]"))));
	    else
		StrAllocCopy(alt_string, NonNull(title));
	}
	if (*alt_string == '\0' && map_href) {
	    StrAllocCopy(alt_string, (temp = MakeNewMapValue(value, "USEMAP")));
	    FREE(temp);
	}

	CTRACE((tfp, "HTML IMG: USEMAP=%d ISMAP=%d ANCHOR=%d PARA=%d\n",
		map_href ? 1 : 0,
		(dest_ismap == TRUE) ? 1 : 0,
		me->inA, me->inP));

	/*
	 * Check for an ID attribute.  - FM
	 */
	if (present && present[HTML_IMG_ID] &&
	    non_empty(value[HTML_IMG_ID])) {
	    StrAllocCopy(id_string, value[HTML_IMG_ID]);
	    TRANSLATE_AND_UNESCAPE_TO_STD(&id_string);
	    if (*id_string == '\0') {
		FREE(id_string);
	    }
	}

	/*
	 * Create links to the SRC for all images, if desired.  - FM
	 */
	if (clickable_images &&
	    present && present[HTML_IMG_SRC] &&
	    non_empty(value[HTML_IMG_SRC])) {
	    StrAllocCopy(href, value[HTML_IMG_SRC]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    /*
	     * If it's an ISMAP and/or USEMAP, or graphic for an anchor, end
	     * that anchor and start one for the SRC.  - FM
	     */
	    if (me->inA) {
		/*
		 * If we have a USEMAP, end this anchor and start a new one for
		 * the client-side MAP.  - FM
		 */
		if (map_href) {
		    if (dest_ismap) {
			HTML_put_character(me, ' ');
			me->in_word = NO;
			HTML_put_string(me,
					(temp = MakeNewMapValue(value, "ISMAP")));
			FREE(temp);
		    } else if (dest) {
			HTML_put_character(me, ' ');
			me->in_word = NO;
			HTML_put_string(me, "[LINK]");
		    }
		    if (me->inBoldA == TRUE && me->inBoldH == FALSE) {
			HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		    }
		    me->inBoldA = FALSE;
		    HText_endAnchor(me->text, me->CurrentANum);
		    me->CurrentANum = 0;
		    if (dest_ismap || dest)
			HTML_put_character(me, '-');
		    if (id_string) {
			if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							      id_string,	/* Tag */
							      NULL,	/* Addresss */
							      0)) != NULL) {	/* Type */
			    HText_beginAnchor(me->text, me->inUnderline, ID_A);
			    HText_endAnchor(me->text, 0);
			}
		    }
		    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							     NULL,	/* Tag */
							     map_href,	/* Addresss */
							     INTERN_LT);	/* Type */
		    if (me->CurrentA && title) {
			if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
			     )) != NULL) {
			    if (!HTAnchor_title(dest))
				HTAnchor_setTitle(dest, title);
			}
		    }
		    me->CurrentANum = HText_beginAnchor(me->text,
							me->inUnderline,
							me->CurrentA);
		    if (me->inBoldA == FALSE && me->inBoldH == FALSE) {
			HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		    }
		    me->inBoldA = TRUE;
		} else {
		    HTML_put_character(me, ' ');	/* space char may be ignored */
		    me->in_word = NO;
		}
		HTML_put_string(me, alt_string);
		if (me->inBoldA == TRUE && me->inBoldH == FALSE) {
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		}
		me->inBoldA = FALSE;
		HText_endAnchor(me->text, me->CurrentANum);
		me->CurrentANum = 0;
		HTML_put_character(me, '-');
		FREE(newtitle);
		StrAllocCopy(alt_string,
			     ((present &&
			       present[HTML_IMG_ISOBJECT]) ?
			      ((map_href || dest_ismap) ?
			       "(IMAGE)" : "(OBJECT)") :
			      VERBOSE_IMG(value, HTML_IMG_SRC, "[IMAGE]")));
		if (id_string && !map_href) {
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  id_string,	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
			HText_beginAnchor(me->text, me->inUnderline, ID_A);
			HText_endAnchor(me->text, 0);
		    }
		}
	    } else if (map_href) {
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
		if (id_string) {
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  id_string,	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
			HText_beginAnchor(me->text, me->inUnderline, ID_A);
			HText_endAnchor(me->text, 0);
		    }
		}
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 map_href,	/* Addresss */
							 INTERN_LT);	/* Type */
		if (me->CurrentA && title) {
		    if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
			 )) != NULL) {
			if (!HTAnchor_title(dest))
			    HTAnchor_setTitle(dest, title);
		    }
		}
		me->CurrentANum = HText_beginAnchor(me->text,
						    me->inUnderline,
						    me->CurrentA);
		if (me->inBoldA == FALSE && me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		me->inBoldA = TRUE;
		HTML_put_string(me, alt_string);
		if (me->inBoldA == TRUE && me->inBoldH == FALSE) {
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		}
		me->inBoldA = FALSE;
		HText_endAnchor(me->text, me->CurrentANum);
		me->CurrentANum = 0;
		HTML_put_character(me, '-');
		FREE(newtitle);
		StrAllocCopy(alt_string,
			     ((present &&
			       present[HTML_IMG_ISOBJECT]) ?
			      "(IMAGE)" :
			      VERBOSE_IMG(value, HTML_IMG_SRC, "[IMAGE]")));
	    } else {
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
		if (id_string) {
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  id_string,	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
			HText_beginAnchor(me->text, me->inUnderline, ID_A);
			HText_endAnchor(me->text, 0);
		    }
		}
	    }

	    /*
	     * Create the link to the SRC.  - FM
	     */
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
	    FREE(href);
	    me->CurrentANum = HText_beginAnchor(me->text,
						me->inUnderline,
						me->CurrentA);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    HTML_put_string(me, alt_string);
	    if (!me->inA) {
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, me->CurrentANum);
		me->CurrentANum = 0;
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
	    } else {
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
		me->inBoldA = TRUE;
	    }
	} else if (map_href) {
	    if (me->inA) {
		/*
		 * We're in an anchor and have a USEMAP, so end the anchor and
		 * start a new one for the client-side MAP.  - FM
		 */
		if (dest_ismap) {
		    HTML_put_character(me, ' ');	/* space char may be ignored */
		    me->in_word = NO;
		    HTML_put_string(me, (temp = MakeNewMapValue(value, "ISMAP")));
		    FREE(temp);
		} else if (dest) {
		    HTML_put_character(me, ' ');	/* space char may be ignored */
		    me->in_word = NO;
		    HTML_put_string(me, "[LINK]");
		}
		if (me->inBoldA == TRUE && me->inBoldH == FALSE) {
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		}
		me->inBoldA = FALSE;
		HText_endAnchor(me->text, me->CurrentANum);
		me->CurrentANum = 0;
		if (dest_ismap || dest) {
		    HTML_put_character(me, '-');
		}
	    } else {
		HTML_put_character(me, ' ');
		me->in_word = NO;
	    }
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     map_href,	/* Addresss */
						     INTERN_LT);	/* Type */
	    if (me->CurrentA && title) {
		if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		     )) != NULL) {
		    if (!HTAnchor_title(dest))
			HTAnchor_setTitle(dest, title);
		}
	    }
	    me->CurrentANum = HText_beginAnchor(me->text,
						me->inUnderline,
						me->CurrentA);
	    if (me->inBoldA == FALSE && me->inBoldH == FALSE) {
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    }
	    me->inBoldA = TRUE;
	    HTML_put_string(me, alt_string);
	    if (!me->inA) {
		if (me->inBoldA == TRUE && me->inBoldH == FALSE) {
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		}
		me->inBoldA = FALSE;
		HText_endAnchor(me->text, me->CurrentANum);
		me->CurrentANum = 0;
	    }
	} else {
	    /*
	     * Just put in the ALT or pseudo-ALT string for the current anchor
	     * or inline, with an ID link if indicated.  - FM
	     */
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	    me->in_word = NO;
	    if (id_string) {
		if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						      id_string,	/* Tag */
						      NULL,	/* Addresss */
						      (HTLinkType *) 0)) != NULL) {	/* Type */
		    HText_beginAnchor(me->text, me->inUnderline, ID_A);
		    HText_endAnchor(me->text, 0);
		}
	    }
	    HTML_put_string(me, alt_string);
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	    me->in_word = NO;
	}
	FREE(map_href);
	FREE(alt_string);
	FREE(id_string);
	FREE(title);
	FREE(newtitle);
	dest = NULL;
	dest_ismap = FALSE;
	break;

    case HTML_MAP:
	/*
	 * Load id_string if we have a NAME or ID.  - FM
	 */
	if (present && present[HTML_MAP_NAME] &&
	    non_empty(value[HTML_MAP_NAME])) {
	    StrAllocCopy(id_string, value[HTML_MAP_NAME]);
	} else if (present && present[HTML_MAP_ID] &&
		   non_empty(value[HTML_MAP_ID])) {
	    StrAllocCopy(id_string, value[HTML_MAP_ID]);
	}
	if (id_string) {
	    TRANSLATE_AND_UNESCAPE_TO_STD(&id_string);
	    if (*id_string == '\0') {
		FREE(id_string);
	    }
	}

	/*
	 * Generate a target anchor in this place in the containing document. 
	 * MAP can now contain block markup, if it doesn't contain any AREAs
	 * (or A anchors with COORDS converted to AREAs) the current location
	 * can be used as a fallback for following a USEMAP link.  - kw
	 */
	if (!LYMapsOnly)
	    LYHandleID(me, id_string);

	/*
	 * Load map_address.  - FM
	 */
	if (id_string) {
	    /*
	     * The MAP must be in the current stream, even if it had a BASE
	     * tag, so we'll use its address here, but still use the BASE, if
	     * present, when resolving the AREA elements in it's content,
	     * unless the AREA's HREF is a lone fragment and
	     * LYSeekFragAREAinCur is set.  - FM && KW
	     */
	    StrAllocCopy(me->map_address, me->node_anchor->address);
	    if ((cp = strchr(me->map_address, '#')) != NULL)
		*cp = '\0';
	    StrAllocCat(me->map_address, "#");
	    StrAllocCat(me->map_address, id_string);
	    FREE(id_string);
	    if (present && present[HTML_MAP_TITLE] &&
		non_empty(value[HTML_MAP_TITLE])) {
		StrAllocCopy(title, value[HTML_MAP_TITLE]);
		TRANSLATE_AND_UNESCAPE_ENTITIES(&title, TRUE, FALSE);
		LYTrimHead(title);
		LYTrimTail(title);
		if (*title == '\0') {
		    FREE(title);
		}
	    }
	    LYAddImageMap(me->map_address, title, me->node_anchor);
	    FREE(title);
	}
	break;

    case HTML_AREA:
	if (me->map_address &&
	    present && present[HTML_AREA_HREF] &&
	    non_empty(value[HTML_AREA_HREF])) {
	    /*
	     * Resolve the HREF.  - FM
	     */
	    StrAllocCopy(href, value[HTML_AREA_HREF]);
	    CHECK_FOR_INTERN(intern_flag, href);
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    /*
	     * Check whether a BASE tag is in effect, and use it for resolving,
	     * even though we used this stream's address for locating the MAP
	     * itself, unless the HREF is a lone fragment and
	     * LYSeekFragAREAinCur is set.  - FM
	     */
	    Base = ((me->inBASE && *href != '\0') &&
		    !(*href == '#' && LYSeekFragAREAinCur == TRUE)) ?
		me->base_href : me->node_anchor->address;
	    HTParseALL(&href, Base);

	    /*
	     * Check for an ALT.  - FM
	     */
	    if (present[HTML_AREA_ALT] &&
		non_empty(value[HTML_AREA_ALT])) {
		StrAllocCopy(alt_string, value[HTML_AREA_ALT]);
	    } else if (present[HTML_AREA_TITLE] &&
		       non_empty(value[HTML_AREA_TITLE])) {
		/*
		 * Use the TITLE as an ALT.  - FM
		 */
		StrAllocCopy(alt_string, value[HTML_AREA_TITLE]);
	    }
	    if (alt_string != NULL) {
		TRANSLATE_AND_UNESCAPE_ENTITIES(&alt_string,
						me->UsePlainSpace,
						me->HiddenValue);
		/*
		 * Make sure it's not just space(s).  - FM
		 */
		LYTrimHead(alt_string);
		LYTrimTail(alt_string);
		if (*alt_string == '\0') {
		    StrAllocCopy(alt_string, href);
		}
	    } else {
		/*
		 * Use the HREF as an ALT.  - FM
		 */
		StrAllocCopy(alt_string, href);
	    }

	    LYAddMapElement(me->map_address, href, alt_string,
			    me->node_anchor, intern_flag);
	    FREE(href);
	    FREE(alt_string);
	}
	break;

    case HTML_PARAM:
	/*
	 * We may need to look at this someday to deal with MAPs, OBJECTs or
	 * APPLETs optimally, but just ignore it for now.  - FM
	 */
	break;

    case HTML_BODYTEXT:
	CHECK_ID(HTML_BODYTEXT_ID);
	/*
	 * We may need to look at this someday to deal with OBJECTs optimally,
	 * but just ignore it for now.  - FM
	 */
	break;

    case HTML_TEXTFLOW:
	CHECK_ID(HTML_BODYTEXT_ID);
	/*
	 * We may need to look at this someday to deal with APPLETs optimally,
	 * but just ignore it for now.  - FM
	 */
	break;

    case HTML_FIG:
	if (present)
	    LYHandleFIG(me, present, value,
			present[HTML_FIG_ISOBJECT],
			present[HTML_FIG_IMAGEMAP],
			present[HTML_FIG_ID] ? value[HTML_FIG_ID] : NULL,
			present[HTML_FIG_SRC] ? value[HTML_FIG_SRC] : NULL,
			YES, TRUE, &intern_flag);
	else
	    LYHandleFIG(me, NULL, NULL,
			0,
			0,
			NULL,
			NULL, YES, TRUE, &intern_flag);
	break;

    case HTML_OBJECT:
	if (!me->object_started) {
	    /*
	     * This is an outer OBJECT start tag, i.e., not a nested OBJECT, so
	     * save it's relevant attributes.  - FM
	     */
	    if (present) {
		if (present[HTML_OBJECT_DECLARE])
		    me->object_declare = TRUE;
		if (present[HTML_OBJECT_SHAPES])
		    me->object_shapes = TRUE;
		if (present[HTML_OBJECT_ISMAP])
		    me->object_ismap = TRUE;
		if (present[HTML_OBJECT_USEMAP] &&
		    non_empty(value[HTML_OBJECT_USEMAP])) {
		    StrAllocCopy(me->object_usemap, value[HTML_OBJECT_USEMAP]);
		    TRANSLATE_AND_UNESCAPE_TO_STD(&me->object_usemap);
		    if (*me->object_usemap == '\0') {
			FREE(me->object_usemap);
		    }
		}
		if (present[HTML_OBJECT_ID] &&
		    non_empty(value[HTML_OBJECT_ID])) {
		    StrAllocCopy(me->object_id, value[HTML_OBJECT_ID]);
		    TRANSLATE_AND_UNESCAPE_TO_STD(&me->object_id);
		    if (*me->object_id == '\0') {
			FREE(me->object_id);
		    }
		}
		if (present[HTML_OBJECT_TITLE] &&
		    non_empty(value[HTML_OBJECT_TITLE])) {
		    StrAllocCopy(me->object_title, value[HTML_OBJECT_TITLE]);
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&me->object_title, TRUE, FALSE);
		    LYTrimHead(me->object_title);
		    LYTrimTail(me->object_title);
		    if (me->object_title == '\0') {
			FREE(me->object_title);
		    }
		}
		if (present[HTML_OBJECT_DATA] &&
		    non_empty(value[HTML_OBJECT_DATA])) {
		    StrAllocCopy(me->object_data, value[HTML_OBJECT_DATA]);
		    TRANSLATE_AND_UNESCAPE_TO_STD(&me->object_data);
		    if (*me->object_data == '\0') {
			FREE(me->object_data);
		    }
		}
		if (present[HTML_OBJECT_TYPE] &&
		    non_empty(value[HTML_OBJECT_TYPE])) {
		    StrAllocCopy(me->object_type, value[HTML_OBJECT_TYPE]);
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&me->object_type, TRUE, FALSE);
		    LYTrimHead(me->object_type);
		    LYTrimTail(me->object_type);
		    if (me->object_type == '\0') {
			FREE(me->object_type);
		    }
		}
		if (present[HTML_OBJECT_CLASSID] &&
		    value[HTML_OBJECT_CLASSID] &&
		    *value[HTML_OBJECT_CLASSID]) {
		    StrAllocCopy(me->object_classid,
				 value[HTML_OBJECT_CLASSID]);
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&me->object_classid, TRUE, FALSE);
		    LYTrimHead(me->object_classid);
		    LYTrimTail(me->object_classid);
		    if (me->object_classid == '\0') {
			FREE(me->object_classid);
		    }
		}
		if (present[HTML_OBJECT_CODEBASE] &&
		    value[HTML_OBJECT_CODEBASE] &&
		    *value[HTML_OBJECT_CODEBASE]) {
		    StrAllocCopy(me->object_codebase,
				 value[HTML_OBJECT_CODEBASE]);
		    TRANSLATE_AND_UNESCAPE_TO_STD(&me->object_codebase);
		    if (*me->object_codebase == '\0') {
			FREE(me->object_codebase);
		    }
		}
		if (present[HTML_OBJECT_CODETYPE] &&
		    value[HTML_OBJECT_CODETYPE] &&
		    *value[HTML_OBJECT_CODETYPE]) {
		    StrAllocCopy(me->object_codetype,
				 value[HTML_OBJECT_CODETYPE]);
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&me->object_codetype,
						    TRUE,
						    FALSE);
		    LYTrimHead(me->object_codetype);
		    LYTrimTail(me->object_codetype);
		    if (me->object_codetype == '\0') {
			FREE(me->object_codetype);
		    }
		}
		if (present[HTML_OBJECT_NAME] &&
		    non_empty(value[HTML_OBJECT_NAME])) {
		    StrAllocCopy(me->object_name, value[HTML_OBJECT_NAME]);
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&me->object_name, TRUE, FALSE);
		    LYTrimHead(me->object_name);
		    LYTrimTail(me->object_name);
		    if (me->object_name == '\0') {
			FREE(me->object_name);
		    }
		}
	    }
	    /*
	     * If we can determine now that we are not going to do anything
	     * special to the OBJECT element's SGML contents, like skipping it
	     * completely or collecting it up in order to add something after
	     * it, then generate any output that should be emitted in the place
	     * of the OBJECT start tag NOW, then don't initialize special
	     * handling but return, letting our SGML parser know that further
	     * content is to be parsed normally not literally.  We could defer
	     * this until we have collected the contents and then recycle the
	     * contents (as was previously always done), but that has a higher
	     * chance of completely losing content in case of nesting errors in
	     * the input, incomplete transmissions, etc.  - kw
	     */
	    if ((!present ||
		 (me->object_declare == FALSE && me->object_name == NULL &&
		  me->object_shapes == FALSE && me->object_usemap == NULL))) {
		if (!LYMapsOnly) {
		    if (!clickable_images || me->object_data == NULL ||
			!(me->object_data != NULL &&
			  me->object_classid == NULL &&
			  me->object_codebase == NULL &&
			  me->object_codetype == NULL))
			FREE(me->object_data);
		    if (me->object_data) {
			HTStartAnchor5(me,
				       me->object_id ? value[HTML_OBJECT_ID]
				       : NULL,
				       value[HTML_OBJECT_DATA],
				       value[HTML_OBJECT_TYPE],
				       tag_charset);
			if ((me->object_type != NULL) &&
			    !strncasecomp(me->object_type, "image/", 6))
			    HTML_put_string(me, "(IMAGE)");
			else
			    HTML_put_string(me, "(OBJECT)");
			HTML_end_element(me, HTML_A, NULL);
		    } else if (me->object_id)
			LYHandleID(me, me->object_id);
		}
		clear_objectdata(me);
		/*
		 * We do NOT want the HTML_put_* functions that are going to be
		 * called for the OBJECT's character content to add to the
		 * chunk, so we don't push on the stack.  Instead we keep a
		 * counter for open OBJECT tags that are treated this way, so
		 * HTML_end_element can skip handling the corresponding end tag
		 * that is going to arrive unexpectedly as far as our stack is
		 * concerned.
		 */
		status = HT_PARSER_OTHER_CONTENT;
		if (me->sp[0].tag_number == HTML_FIG &&
		    me->objects_figged_open > 0) {
		    ElementNumber = (HTMLElement) HTML_OBJECT_M;
		} else {
		    me->objects_mixed_open++;
		    SET_SKIP_STACK(HTML_OBJECT);
		}
	    } else if (me->object_declare == FALSE && me->object_name == NULL &&
		       me->object_shapes == TRUE) {
		LYHandleFIG(me, present, value,
			    1,
			    1 || me->object_ismap,
			    me->object_id,
			    ((me->object_data && !me->object_classid)
			     ? value[HTML_OBJECT_DATA]
			     : NULL),
			    NO, TRUE, &intern_flag);
		clear_objectdata(me);
		status = HT_PARSER_OTHER_CONTENT;
		me->objects_figged_open++;
		ElementNumber = HTML_FIG;

	    } else {
		/*
		 * Set flag that we are accumulating OBJECT content.  - FM
		 */
		me->object_started = TRUE;
	    }
	}
	break;

    case HTML_OVERLAY:
	if (clickable_images && me->inFIG &&
	    present && present[HTML_OVERLAY_SRC] &&
	    non_empty(value[HTML_OVERLAY_SRC])) {
	    StrAllocCopy(href, value[HTML_OVERLAY_SRC]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href) {

		if (me->inA) {
		    SET_SKIP_STACK(HTML_A);
		    HTML_end_element(me, HTML_A, include);
		}
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 (HTLinkType *) 0);	/* Type */
		HTML_put_character(me, ' ');
		HText_appendCharacter(me->text, '+');
		me->CurrentANum = HText_beginAnchor(me->text,
						    me->inUnderline,
						    me->CurrentA);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		HTML_put_string(me, "[OVERLAY]");
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, me->CurrentANum);
		HTML_put_character(me, ' ');
		me->in_word = NO;
	    }
	    FREE(href);
	}
	break;

    case HTML_APPLET:
	me->inAPPLET = TRUE;
	me->inAPPLETwithP = FALSE;
	HTML_put_character(me, ' ');	/* space char may be ignored */
	/*
	 * Load id_string if we have an ID or NAME.  - FM
	 */
	if (present && present[HTML_APPLET_ID] &&
	    non_empty(value[HTML_APPLET_ID])) {
	    StrAllocCopy(id_string, value[HTML_APPLET_ID]);
	} else if (present && present[HTML_APPLET_NAME] &&
		   non_empty(value[HTML_APPLET_NAME])) {
	    StrAllocCopy(id_string, value[HTML_APPLET_NAME]);
	}
	if (id_string) {
	    TRANSLATE_AND_UNESCAPE_TO_STD(&id_string);
	    LYHandleID(me, id_string);
	    FREE(id_string);
	}
	me->in_word = NO;

	/*
	 * If there's an ALT string, use it, unless the ALT string is
	 * zero-length and we are making all sources links.  - FM
	 */
	if (present && present[HTML_APPLET_ALT] && value[HTML_APPLET_ALT] &&
	    (!clickable_images ||
	     (clickable_images && *value[HTML_APPLET_ALT] != '\0'))) {
	    StrAllocCopy(alt_string, value[HTML_APPLET_ALT]);
	    TRANSLATE_AND_UNESCAPE_ENTITIES(&alt_string,
					    me->UsePlainSpace, me->HiddenValue);
	    /*
	     * If it's all spaces and we are making sources links, treat it as
	     * zero-length.  - FM
	     */
	    if (clickable_images) {
		LYTrimHead(alt_string);
		LYTrimTail(alt_string);
		if (*alt_string == '\0') {
		    StrAllocCopy(alt_string, "[APPLET]");
		}
	    }

	} else {
	    if (clickable_images)
		StrAllocCopy(alt_string, "[APPLET]");
	    else
		StrAllocCopy(alt_string, "");
	}

	/*
	 * If we're making all sources links, get the source.  - FM
	 */
	if (clickable_images && present && present[HTML_APPLET_CODE] &&
	    non_empty(value[HTML_APPLET_CODE])) {
	    char *base = NULL;

	    Base = (me->inBASE)
		? me->base_href
		: me->node_anchor->address;
	    /*
	     * Check for a CODEBASE attribute.  - FM
	     */
	    if (present[HTML_APPLET_CODEBASE] &&
		non_empty(value[HTML_APPLET_CODEBASE])) {
		StrAllocCopy(base, value[HTML_APPLET_CODEBASE]);
		LYRemoveBlanks(base);
		TRANSLATE_AND_UNESCAPE_TO_STD(&base);
		/*
		 * Force it to be a directory.  - FM
		 */
		if (*base == '\0')
		    StrAllocCopy(base, "/");
		LYAddHtmlSep(&base);
		LYLegitimizeHREF(me, &base, TRUE, FALSE);

		HTParseALL(&base, Base);
	    }

	    StrAllocCopy(href, value[HTML_APPLET_CODE]);
	    LYLegitimizeHREF(me, &href, TRUE, FALSE);
	    HTParseALL(&href, (base ? base : Base));
	    FREE(base);

	    if (*href) {
		if (me->inA) {
		    if (me->inBoldA == TRUE && me->inBoldH == FALSE)
			HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		    HText_endAnchor(me->text, me->CurrentANum);
		    HTML_put_character(me, '-');
		}
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 (HTLinkType *) 0);	/* Type */
		me->CurrentANum = HText_beginAnchor(me->text,
						    me->inUnderline,
						    me->CurrentA);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		HTML_put_string(me, alt_string);
		if (me->inA == FALSE) {
		    if (me->inBoldH == FALSE)
			HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		    HText_endAnchor(me->text, me->CurrentANum);
		    me->CurrentANum = 0;
		}
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
	    }
	    FREE(href);
	} else if (*alt_string) {
	    /*
	     * Just put up the ALT string, if non-zero.  - FM
	     */
	    HTML_put_string(me, alt_string);
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	    me->in_word = NO;
	}
	FREE(alt_string);
	FREE(id_string);
	break;

    case HTML_BGSOUND:
	/*
	 * If we're making all sources links, get the source.  - FM
	 */
	if (clickable_images && present && present[HTML_BGSOUND_SRC] &&
	    non_empty(value[HTML_BGSOUND_SRC])) {
	    StrAllocCopy(href, value[HTML_BGSOUND_SRC]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href == '\0') {
		FREE(href);
		break;
	    }

	    if (me->inA) {
		if (me->inBoldA == TRUE && me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, me->CurrentANum);
		HTML_put_character(me, '-');
	    } else {
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
	    }
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
	    me->CurrentANum = HText_beginAnchor(me->text,
						me->inUnderline,
						me->CurrentA);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    HTML_put_string(me, "[BGSOUND]");
	    if (me->inA == FALSE) {
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, me->CurrentANum);
		me->CurrentANum = 0;
	    }
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	    me->in_word = NO;
	    FREE(href);
	}
	break;

    case HTML_EMBED:
	if (pseudo_inline_alts || clickable_images)
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	/*
	 * Load id_string if we have an ID or NAME.  - FM
	 */
	if (present && present[HTML_EMBED_ID] &&
	    non_empty(value[HTML_EMBED_ID])) {
	    StrAllocCopy(id_string, value[HTML_EMBED_ID]);
	} else if (present && present[HTML_EMBED_NAME] &&
		   non_empty(value[HTML_EMBED_NAME])) {
	    StrAllocCopy(id_string, value[HTML_EMBED_NAME]);
	}
	if (id_string) {
	    TRANSLATE_AND_UNESCAPE_TO_STD(&id_string);
	    LYHandleID(me, id_string);
	    FREE(id_string);
	}
	if (pseudo_inline_alts || clickable_images)
	    me->in_word = NO;

	/*
	 * If there's an ALT string, use it, unless the ALT string is
	 * zero-length and we are making all sources links.  - FM
	 */
	if (present && present[HTML_EMBED_ALT] && value[HTML_EMBED_ALT] &&
	    (!clickable_images ||
	     (clickable_images && *value[HTML_EMBED_ALT] != '\0'))) {
	    StrAllocCopy(alt_string, value[HTML_EMBED_ALT]);
	    TRANSLATE_AND_UNESCAPE_ENTITIES(&alt_string,
					    me->UsePlainSpace, me->HiddenValue);
	    /*
	     * If it's all spaces and we are making sources links, treat it as
	     * zero-length.  - FM
	     */
	    if (clickable_images) {
		LYTrimHead(alt_string);
		LYTrimTail(alt_string);
		if (*alt_string == '\0') {
		    StrAllocCopy(alt_string, "[EMBED]");
		}
	    }
	} else {
	    if (pseudo_inline_alts || clickable_images)
		StrAllocCopy(alt_string, "[EMBED]");
	    else
		StrAllocCopy(alt_string, "");
	}

	/*
	 * If we're making all sources links, get the source.  - FM
	 */
	if (clickable_images && present && present[HTML_EMBED_SRC] &&
	    non_empty(value[HTML_EMBED_SRC])) {
	    StrAllocCopy(href, value[HTML_EMBED_SRC]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href) {
		if (me->inA) {
		    if (me->inBoldA == TRUE && me->inBoldH == FALSE)
			HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		    HText_endAnchor(me->text, me->CurrentANum);
		    HTML_put_character(me, '-');
		}
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 (HTLinkType *) 0);	/* Type */
		me->CurrentANum = HText_beginAnchor(me->text,
						    me->inUnderline,
						    me->CurrentA);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		HTML_put_string(me, alt_string);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		if (me->inA == FALSE) {
		    if (me->inBoldH == FALSE)
			HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		    HText_endAnchor(me->text, me->CurrentANum);
		    me->CurrentANum = 0;
		}
		HTML_put_character(me, ' ');
		me->in_word = NO;
	    }
	    FREE(href);
	} else if (*alt_string) {
	    /*
	     * Just put up the ALT string, if non-zero.  - FM
	     */
	    HTML_put_string(me, alt_string);
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	    me->in_word = NO;
	}
	FREE(alt_string);
	FREE(id_string);
	break;

    case HTML_CREDIT:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	me->inCREDIT = TRUE;
	CHECK_ID(HTML_CREDIT_ID);
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	HTML_put_string(me, "CREDIT:");
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	HTML_put_character(me, ' ');
	CAN_JUSTIFY_START;

	if (me->inFIG)
	    /*
	     * Assume all text in the FIG container is intended to be
	     * paragraphed.  - FM
	     */
	    me->inFIGwithP = TRUE;

	if (me->inAPPLET)
	    /*
	     * Assume all text in the APPLET container is intended to be
	     * paragraphed.  - FM
	     */
	    me->inAPPLETwithP = TRUE;

	me->inLABEL = TRUE;
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_CAPTION:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	me->inCAPTION = TRUE;
	CHECK_ID(HTML_CAPTION_ID);
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	HTML_put_string(me, "CAPTION:");
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	HTML_put_character(me, ' ');
	CAN_JUSTIFY_START;

	if (me->inFIG)
	    /*
	     * Assume all text in the FIG container is intended to be
	     * paragraphed.  - FM
	     */
	    me->inFIGwithP = TRUE;

	if (me->inAPPLET)
	    /*
	     * Assume all text in the APPLET container is intended to be
	     * paragraphed.  - FM
	     */
	    me->inAPPLETwithP = TRUE;

	me->inLABEL = TRUE;
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_FORM:
	{
	    char *action = NULL;
	    char *method = NULL;
	    char *enctype = NULL;
	    const char *accept_cs = NULL;

	    HTChildAnchor *source;
	    HTAnchor *link_dest;

	    /*
	     * FORM may have been declared SGML_EMPTY in HTMLDTD.c, and
	     * SGML_character() in SGML.c may check for a FORM end tag to call
	     * HTML_end_element() directly (with a check in that to bypass
	     * decrementing of the HTML parser's stack), so if we have an open
	     * FORM, close that one now.  - FM
	     */
	    if (me->inFORM) {
		CTRACE((tfp, "HTML: Missing FORM end tag.  Faking it!\n"));
		SET_SKIP_STACK(HTML_FORM);
		HTML_end_element(me, HTML_FORM, include);
	    }

	    /*
	     * Set to know we are in a new form.
	     */
	    me->inFORM = TRUE;
	    EMIT_IFDEF_EXP_JUSTIFY_ELTS(form_in_htext = TRUE);

	    if (present && present[HTML_FORM_ACCEPT_CHARSET]) {
		accept_cs = value[HTML_FORM_ACCEPT_CHARSET] ?
		    value[HTML_FORM_ACCEPT_CHARSET] : "UNKNOWN";
	    }

	    Base = (me->inBASE)
		? me->base_href
		: me->node_anchor->address;

	    if (present && present[HTML_FORM_ACTION] &&
		value[HTML_FORM_ACTION]) {

		StrAllocCopy(action, value[HTML_FORM_ACTION]);
		LYLegitimizeHREF(me, &action, TRUE, TRUE);

		/*
		 * Check whether a base tag is in effect.  Note that actions
		 * always are resolved w.r.t.  to the base, even if the action
		 * is empty.  - FM
		 */
		HTParseALL(&action, Base);

	    } else {
		StrAllocCopy(action, Base);
	    }

	    source = HTAnchor_findChildAndLink(me->node_anchor,
					       NULL,
					       action,
					       (HTLinkType *) 0);
	    if ((link_dest = HTAnchor_followLink(source)) != NULL) {
		/*
		 * Memory leak fixed.  05-28-94 Lynx 2-3-1 Garrett Arch Blythe
		 */
		char *cp_freeme = HTAnchor_address(link_dest);

		if (cp_freeme != NULL) {
		    StrAllocCopy(action, cp_freeme);
		    FREE(cp_freeme);
		} else {
		    StrAllocCopy(action, "");
		}
	    }

	    if (present && present[HTML_FORM_METHOD])
		StrAllocCopy(method, value[HTML_FORM_METHOD] ?
			     value[HTML_FORM_METHOD] : "GET");

	    if (present && present[HTML_FORM_ENCTYPE] &&
		non_empty(value[HTML_FORM_ENCTYPE])) {
		StrAllocCopy(enctype, value[HTML_FORM_ENCTYPE]);
		LYLowerCase(enctype);
	    }

	    if (present) {
		/*
		 * Check for a TITLE attribute, and if none is present, check
		 * for a SUBJECT attribute as a synonym.  - FM
		 */
		if (present[HTML_FORM_TITLE] &&
		    value[HTML_FORM_TITLE] &&
		    *value[HTML_FORM_TITLE] != '\0') {
		    StrAllocCopy(title, value[HTML_FORM_TITLE]);
		} else if (present[HTML_FORM_SUBJECT] &&
			   value[HTML_FORM_SUBJECT] &&
			   *value[HTML_FORM_SUBJECT] != '\0') {
		    StrAllocCopy(title, value[HTML_FORM_SUBJECT]);
		}
		if (non_empty(title)) {
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&title, TRUE, FALSE);
		    LYTrimHead(title);
		    LYTrimTail(title);
		    if (*title == '\0') {
			FREE(title);
		    }
		}
	    }

	    HText_beginForm(action, method, enctype, title, accept_cs);

	    FREE(action);
	    FREE(method);
	    FREE(enctype);
	    FREE(title);
	}
	CHECK_ID(HTML_FORM_ID);
	break;

    case HTML_FIELDSET:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	CHECK_ID(HTML_FIELDSET_ID);
	break;

    case HTML_LEGEND:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	CHECK_ID(HTML_LEGEND_ID);
	break;

    case HTML_LABEL:
	CHECK_ID(HTML_LABEL_ID);
	break;

    case HTML_KEYGEN:
	CHECK_ID(HTML_KEYGEN_ID);
	break;

    case HTML_BUTTON:
	{
	    InputFieldData I;
	    int chars;

	    /* init */
	    I.align = NULL;
	    I.accept = NULL;
	    I.checked = NO;
	    I.iclass = NULL;
	    I.disabled = NO;
	    I.error = NULL;
	    I.height = NULL;
	    I.id = NULL;
	    I.lang = NULL;
	    I.max = NULL;
	    I.maxlength = NULL;
	    I.md = NULL;
	    I.min = NULL;
	    I.name = NULL;
	    I.size = 0;
	    I.src = NULL;
	    I.type = NULL;
	    I.value = NULL;
	    I.width = NULL;
	    I.accept_cs = NULL;
	    I.name_cs = ATTR_CS_IN;
	    I.value_cs = ATTR_CS_IN;

	    UPDATE_STYLE;
	    if ((present && present[HTML_BUTTON_TYPE] &&
		 value[HTML_BUTTON_TYPE]) &&
		(!strcasecomp(value[HTML_BUTTON_TYPE], "submit") ||
		 !strcasecomp(value[HTML_BUTTON_TYPE], "reset"))) {
		/*
		 * It's a button for submitting or resetting a form.  - FM
		 */
		I.type = value[HTML_BUTTON_TYPE];
	    } else {
		/*
		 * Ugh, it's a button for a script.  - FM
		 */
		HTML_put_string(me, " [BUTTON] ");
		break;
	    }

	    /*
	     * Make sure we're in a form.
	     */
	    if (!me->inFORM) {
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: BUTTON tag not within FORM tag\n"));
		/*
		 * We'll process it, since the chances of a crash are small,
		 * and we probably do have a form started.  - FM
		 *
		 break;
		 */
	    }

	    /*
	     * Before any input field, add a collapsible space if we're not in
	     * a PRE block, to promote a wrap there for any long values that
	     * would extend past the right margin from our current position in
	     * the line.  If we are in a PRE block, start a new line if the
	     * last line already is within 6 characters of the wrap point for
	     * PRE blocks.  - FM
	     */
	    if (me->sp[0].tag_number != HTML_PRE && !me->inPRE &&
		me->sp->style->freeFormat) {
		HTML_put_character(me, ' ');
		me->in_word = NO;
	    } else if (HText_LastLineSize(me->text, FALSE) > (LYcolLimit - 6)) {
		HTML_put_character(me, '\n');
		me->in_word = NO;
	    }
	    HTML_put_character(me, '(');

	    if (!(present && present[HTML_BUTTON_NAME] &&
		  value[HTML_BUTTON_NAME])) {
		I.name = "";
	    } else if (strchr(value[HTML_BUTTON_NAME], '&') == NULL) {
		I.name = value[HTML_BUTTON_NAME];
	    } else {
		StrAllocCopy(I_name, value[HTML_BUTTON_NAME]);
		UNESCAPE_FIELDNAME_TO_STD(&I_name);
		I.name = I_name;
	    }

	    if (present && present[HTML_BUTTON_VALUE] &&
		non_empty(value[HTML_BUTTON_VALUE])) {
		/*
		 * Convert any HTML entities or decimal escaping.  - FM
		 */
		StrAllocCopy(I_value, value[HTML_BUTTON_VALUE]);
		me->UsePlainSpace = TRUE;
		TRANSLATE_AND_UNESCAPE_ENTITIES(&I_value, TRUE, me->HiddenValue);
		me->UsePlainSpace = FALSE;
		I.value = I_value;
		/*
		 * Convert any newlines or tabs to spaces, and trim any lead or
		 * trailing spaces.  - FM
		 */
		LYReduceBlanks(I.value);
	    }

	    if (present && present[HTML_BUTTON_DISABLED])
		I.disabled = YES;

	    if (present && present[HTML_BUTTON_CLASS] &&	/* Not yet used. */
		non_empty(value[HTML_BUTTON_CLASS]))
		I.iclass = value[HTML_BUTTON_CLASS];

	    if (present && present[HTML_BUTTON_ID] &&
		non_empty(value[HTML_BUTTON_ID])) {
		I.id = value[HTML_BUTTON_ID];
		CHECK_ID(HTML_BUTTON_ID);
	    }

	    if (present && present[HTML_BUTTON_LANG] &&		/* Not yet used. */
		non_empty(value[HTML_BUTTON_LANG]))
		I.lang = value[HTML_BUTTON_LANG];

	    chars = HText_beginInput(me->text, me->inUnderline, &I);
	    /*
	     * Submit and reset buttons have values which don't change, so
	     * HText_beginInput() sets I.value to the string which should be
	     * displayed, and we'll enter that instead of underscore
	     * placeholders into the HText structure to see it instead of
	     * underscores when dumping or printing.  We also won't worry about
	     * a wrap in PRE blocks, because the line editor never is invoked
	     * for submit or reset buttons.  - LE & FM
	     */
	    if (me->sp[0].tag_number == HTML_PRE ||
		!me->sp->style->freeFormat) {
		/*
		 * We have a submit or reset button in a PRE block, so output
		 * the entire value from the markup.  If it extends to the
		 * right margin, it will wrap there, and only the portion
		 * before that wrap will be hightlighted on screen display
		 * (Yuk!) but we may as well show the rest of the full value on
		 * the next or more lines.  - FM
		 */
		while (I.value[i])
		    HTML_put_character(me, I.value[i++]);
	    } else {
		/*
		 * The submit or reset button is not in a PRE block.  Note that
		 * if a wrap occurs before outputting the entire value, the
		 * wrapped portion will not be highlighted or clearly indicated
		 * as part of the link for submission or reset (Yuk!).  We'll
		 * replace any spaces in the submit or reset button value with
		 * nbsp, to promote a wrap at the space we ensured would be
		 * present before the start of the string, as when we use all
		 * underscores instead of the INPUT's actual value, but we
		 * could still get a wrap at the right margin, instead, if the
		 * value is greater than a line width for the current style. 
		 * Also, if chars somehow ended up longer than the length of
		 * the actual value (shouldn't have), we'll continue padding
		 * with nbsp up to the length of chars.  - FM
		 */
		for (i = 0; I.value[i]; i++) {
		    HTML_put_character(me,
				       (char) (I.value[i] == ' ' ?
					       HT_NON_BREAK_SPACE : I.value[i]));
		}
		while (i++ < chars) {
		    HTML_put_character(me, HT_NON_BREAK_SPACE);
		}
	    }
	    HTML_put_character(me, ')');
	    if (me->sp[0].tag_number != HTML_PRE &&
		me->sp->style->freeFormat) {
		HTML_put_character(me, ' ');
		me->in_word = NO;
	    }
	    FREE(I_value);
	    FREE(I_name);
	}
	break;

    case HTML_INPUT:
	{
	    InputFieldData I;
	    int chars;
	    BOOL UseALTasVALUE = FALSE;
	    BOOL HaveSRClink = FALSE;
	    char *ImageSrc = NULL;
	    BOOL IsSubmitOrReset = FALSE;
	    HTkcode kcode = NOKANJI;
	    HTkcode specified_kcode = NOKANJI;

	    /* init */
	    I.align = NULL;
	    I.accept = NULL;
	    I.checked = NO;
	    I.iclass = NULL;
	    I.disabled = NO;
	    I.error = NULL;
	    I.height = NULL;
	    I.id = NULL;
	    I.lang = NULL;
	    I.max = NULL;
	    I.maxlength = NULL;
	    I.md = NULL;
	    I.min = NULL;
	    I.name = NULL;
	    I.size = 0;
	    I.src = NULL;
	    I.type = NULL;
	    I.value = NULL;
	    I.width = NULL;
	    I.accept_cs = NULL;
	    I.name_cs = ATTR_CS_IN;
	    I.value_cs = ATTR_CS_IN;

	    UPDATE_STYLE;

	    /*
	     * Before any input field, add a collapsible space if we're not in
	     * a PRE block, to promote a wrap there for any long values that
	     * would extend past the right margin from our current position in
	     * the line.  If we are in a PRE block, start a new line if the
	     * last line already is within 6 characters of the wrap point for
	     * PRE blocks.  - FM
	     */
	    if (me->sp[0].tag_number != HTML_PRE && !me->inPRE &&
		me->sp->style->freeFormat) {
		HTML_put_character(me, ' ');
		me->in_word = NO;
	    } else if (HText_LastLineSize(me->text, FALSE) > (LYcolLimit - 6)) {
		HTML_put_character(me, '\n');
		me->in_word = NO;
	    }

	    /*
	     * Get the TYPE and make sure we can handle it.  - FM
	     */
	    if (present && present[HTML_INPUT_TYPE] &&
		non_empty(value[HTML_INPUT_TYPE])) {
		const char *not_impl = NULL;
		char *usingval = NULL;

		I.type = value[HTML_INPUT_TYPE];

		if (!strcasecomp(I.type, "range")) {
		    if (present[HTML_INPUT_MIN])
			I.min = value[HTML_INPUT_MIN];
		    if (present[HTML_INPUT_MAX])
			I.max = value[HTML_INPUT_MAX];
		    /*
		     * Not yet implemented.
		     */
		    not_impl = "[RANGE Input]";
#ifdef NOTDEFINED
		    if (me->inFORM)
			HText_DisableCurrentForm();
#endif /* NOTDEFINED */
		    CTRACE((tfp, "HTML: Ignoring TYPE=\"range\"\n"));
		    break;

		} else if (!strcasecomp(I.type, "file")) {
		    if (present[HTML_INPUT_ACCEPT])
			I.accept = value[HTML_INPUT_ACCEPT];
#ifndef USE_FILE_UPLOAD
		    not_impl = "[FILE Input]";
		    CTRACE((tfp, "Attempting to fake as: %s\n", I.type));
#ifdef NOTDEFINED
		    if (me->inFORM)
			HText_DisableCurrentForm();
#endif /* NOTDEFINED */
		    CTRACE((tfp, "HTML: Ignoring TYPE=\"file\"\n"));
#endif /* USE_FILE_UPLOAD */

		} else if (!strcasecomp(I.type, "button")) {
		    /*
		     * Ugh, a button for a script.
		     */
		    HTML_put_string(me, "[BUTTON] ");
		    break;
		}
		if (not_impl != NULL) {
		    if (me->inUnderline == FALSE) {
			HText_appendCharacter(me->text,
					      LY_UNDERLINE_START_CHAR);
		    }
		    HTML_put_string(me, not_impl);
		    if (usingval != NULL) {
			HTML_put_string(me, usingval);
			FREE(usingval);
		    } else {
			HTML_put_string(me, " (not implemented)");
		    }
		    if (me->inUnderline == FALSE) {
			HText_appendCharacter(me->text,
					      LY_UNDERLINE_END_CHAR);
		    }
		}
	    }

	    /*
	     * Check if we're in a form.  - FM
	     */
	    if (!me->inFORM) {
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: INPUT tag not within FORM tag\n"));
		/*
		 * We'll process it, since the chances of a crash are small,
		 * and we probably do have a form started.  - FM
		 *
		 break;
		 */
	    }

	    CTRACE((tfp, "Ok, we're trying type=[%s]\n", NONNULL(I.type)));

	    /*
	     * Check for an unclosed TEXTAREA.
	     */
	    if (me->inTEXTAREA) {
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag.\n"));
	    }

	    /*
	     * Check for an unclosed SELECT, try to close it if found.
	     */
	    if (me->inSELECT) {
		CTRACE((tfp, "HTML: Missing SELECT end tag, faking it...\n"));
		if (me->sp->tag_number != HTML_SELECT) {
		    SET_SKIP_STACK(HTML_SELECT);
		}
		HTML_end_element(me, HTML_SELECT, include);
	    }

	    /*
	     * Handle the INPUT as for a FORM.  - FM
	     */
	    if (!(present && present[HTML_INPUT_NAME] &&
		  value[HTML_INPUT_NAME])) {
		I.name = "";
	    } else if (strchr(value[HTML_INPUT_NAME], '&') == NULL) {
		I.name = value[HTML_INPUT_NAME];
	    } else {
		StrAllocCopy(I_name, value[HTML_INPUT_NAME]);
		UNESCAPE_FIELDNAME_TO_STD(&I_name);
		I.name = I_name;
	    }
	    if ((present && present[HTML_INPUT_ALT] &&
		 non_empty(value[HTML_INPUT_ALT]) &&
		 I.type && !strcasecomp(I.type, "image")) &&
		!(present && present[HTML_INPUT_VALUE] &&
		  non_empty(value[HTML_INPUT_VALUE]))) {
		/*
		 * This is a TYPE="image" using an ALT rather than VALUE
		 * attribute to indicate the link string for text clients or
		 * GUIs with image loading off, so set the flag to use that as
		 * if it were a VALUE attribute.  - FM
		 */
		UseALTasVALUE = TRUE;
	    }
	    if (verbose_img && !clickable_images &&
		present && present[HTML_INPUT_SRC] &&
		non_empty(value[HTML_INPUT_SRC]) &&
		I.type && !strcasecomp(I.type, "image")) {
		ImageSrc = MakeNewImageValue(value);
	    } else if (clickable_images == TRUE &&
		       present && present[HTML_INPUT_SRC] &&
		       non_empty(value[HTML_INPUT_SRC]) &&
		       I.type && !strcasecomp(I.type, "image")) {
		StrAllocCopy(href, value[HTML_INPUT_SRC]);
		/*
		 * We have a TYPE="image" with a non-zero-length SRC attribute
		 * and want clickable images.  Make the SRC's value a link if
		 * it's still not zero-length legitimizing it.  - FM
		 */
		LYLegitimizeHREF(me, &href, TRUE, TRUE);
		if (*href) {

		    if (me->inA) {
			SET_SKIP_STACK(HTML_A);
			HTML_end_element(me, HTML_A, include);
		    }
		    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							     NULL,	/* Tag */
							     href,	/* Addresss */
							     (HTLinkType *) 0);		/* Type */
		    HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
		    if (me->inBoldH == FALSE)
			HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		    HTML_put_string(me, VERBOSE_IMG(value,
						    HTML_INPUT_SRC,
						    "[IMAGE]"));
		    FREE(newtitle);
		    if (me->inBoldH == FALSE)
			HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		    HText_endAnchor(me->text, 0);
		    HTML_put_character(me, '-');
		    HaveSRClink = TRUE;
		}
		FREE(href);
	    }
	    CTRACE((tfp, "2.Ok, we're trying type=[%s] (present=%p)\n",
		    NONNULL(I.type),
		    present));
	    /* text+file don't go in here */
	    if ((UseALTasVALUE == TRUE) ||
		(present && present[HTML_INPUT_VALUE] &&
		 value[HTML_INPUT_VALUE] &&
		 (*value[HTML_INPUT_VALUE] ||
		  (I.type && (!strcasecomp(I.type, "checkbox") ||
			      !strcasecomp(I.type, "radio")))))) {

		/*
		 * Convert any HTML entities or decimal escaping.  - FM
		 */
		int CurrentCharSet = current_char_set;
		BOOL CurrentEightBitRaw = HTPassEightBitRaw;
		BOOLEAN CurrentUseDefaultRawMode = LYUseDefaultRawMode;
		HTCJKlang CurrentHTCJK = HTCJK;

		if (I.type && !strcasecomp(I.type, "hidden")) {
		    me->HiddenValue = TRUE;
		    current_char_set = LATIN1;	/* Default ISO-Latin1 */
		    LYUseDefaultRawMode = TRUE;
		    HTMLSetCharacterHandling(current_char_set);
		}

		CTRACE((tfp, "3.Ok, we're trying type=[%s]\n", NONNULL(I.type)));
		if (!I.type)
		    me->UsePlainSpace = TRUE;
		else if (!strcasecomp(I.type, "text") ||
#ifdef USE_FILE_UPLOAD
			 !strcasecomp(I.type, "file") ||
#endif
			 !strcasecomp(I.type, "submit") ||
			 !strcasecomp(I.type, "image") ||
			 !strcasecomp(I.type, "reset")) {
		    CTRACE((tfp, "normal field type: %s\n", NONNULL(I.type)));
		    me->UsePlainSpace = TRUE;
		}

		StrAllocCopy(I_value,
			     ((UseALTasVALUE == TRUE) ?
			      value[HTML_INPUT_ALT] :
			      value[HTML_INPUT_VALUE]));
		if (me->UsePlainSpace && !me->HiddenValue) {
		    I.value_cs = current_char_set;
		}
		CTRACE((tfp, "4.Ok, we're trying type=[%s]\n", NONNULL(I.type)));
		TRANSLATE_AND_UNESCAPE_ENTITIES6(&I_value,
						 ATTR_CS_IN,
						 I.value_cs,
						 (BOOL) (me->UsePlainSpace &&
							 !me->HiddenValue),
						 me->UsePlainSpace,
						 me->HiddenValue);
		I.value = I_value;
		if (me->UsePlainSpace == TRUE) {
		    /*
		     * Convert any newlines or tabs to spaces, and trim any
		     * lead or trailing spaces.  - FM
		     */
		    LYReduceBlanks(I.value);
		}
		me->UsePlainSpace = FALSE;

		if (I.type && !strcasecomp(I.type, "hidden")) {
		    me->HiddenValue = FALSE;
		    current_char_set = CurrentCharSet;
		    LYUseDefaultRawMode = CurrentUseDefaultRawMode;
		    HTMLSetCharacterHandling(current_char_set);
		    HTPassEightBitRaw = CurrentEightBitRaw;
		    HTCJK = CurrentHTCJK;
		}
	    } else if (HaveSRClink == TRUE) {
		/*
		 * We put up an [IMAGE] link and '-' for a TYPE="image" and
		 * didn't get a VALUE or ALT string, so fake a "Submit" value. 
		 * If we didn't put up a link, then HText_beginInput() will use
		 * "[IMAGE]-Submit".  - FM
		 */
		StrAllocCopy(I_value, "Submit");
		I.value = I_value;
	    } else if (ImageSrc) {
		/* [IMAGE]-Submit with verbose images and not clickable images.
		 * Use ImageSrc if no other alt or value is supplied. --LE
		 */
		I.value = ImageSrc;
	    }
	    if (present && present[HTML_INPUT_CHECKED])
		I.checked = YES;
	    if (present && present[HTML_INPUT_SIZE] &&
		non_empty(value[HTML_INPUT_SIZE]))
		I.size = atoi(value[HTML_INPUT_SIZE]);
	    LimitValue(I.size, MAX_LINE);
	    if (present && present[HTML_INPUT_MAXLENGTH] &&
		non_empty(value[HTML_INPUT_MAXLENGTH]))
		I.maxlength = value[HTML_INPUT_MAXLENGTH];
	    if (present && present[HTML_INPUT_DISABLED])
		I.disabled = YES;

	    if (present && present[HTML_INPUT_ACCEPT_CHARSET]) {	/* Not yet used. */
		I.accept_cs = (value[HTML_INPUT_ACCEPT_CHARSET]
			       ? value[HTML_INPUT_ACCEPT_CHARSET]
			       : "UNKNOWN");
	    }
	    if (present && present[HTML_INPUT_ALIGN] &&		/* Not yet used. */
		non_empty(value[HTML_INPUT_ALIGN]))
		I.align = value[HTML_INPUT_ALIGN];
	    if (present && present[HTML_INPUT_CLASS] &&		/* Not yet used. */
		non_empty(value[HTML_INPUT_CLASS]))
		I.iclass = value[HTML_INPUT_CLASS];
	    if (present && present[HTML_INPUT_ERROR] &&		/* Not yet used. */
		non_empty(value[HTML_INPUT_ERROR]))
		I.error = value[HTML_INPUT_ERROR];
	    if (present && present[HTML_INPUT_HEIGHT] &&	/* Not yet used. */
		non_empty(value[HTML_INPUT_HEIGHT]))
		I.height = value[HTML_INPUT_HEIGHT];
	    if (present && present[HTML_INPUT_WIDTH] &&		/* Not yet used. */
		non_empty(value[HTML_INPUT_WIDTH]))
		I.width = value[HTML_INPUT_WIDTH];
	    if (present && present[HTML_INPUT_ID] &&
		non_empty(value[HTML_INPUT_ID])) {
		I.id = value[HTML_INPUT_ID];
		CHECK_ID(HTML_INPUT_ID);
	    }
	    if (present && present[HTML_INPUT_LANG] &&	/* Not yet used. */
		non_empty(value[HTML_INPUT_LANG]))
		I.lang = value[HTML_INPUT_LANG];
	    if (present && present[HTML_INPUT_MD] &&	/* Not yet used. */
		non_empty(value[HTML_INPUT_MD]))
		I.md = value[HTML_INPUT_MD];

	    chars = HText_beginInput(me->text, me->inUnderline, &I);
#ifndef USE_FILE_UPLOAD
	    CTRACE((tfp,
		    "I.%s have %d chars, or something\n",
		    NONNULL(I.type),
		    chars));
#endif
	    /*
	     * Submit and reset buttons have values which don't change, so
	     * HText_beginInput() sets I.value to the string which should be
	     * displayed, and we'll enter that instead of underscore
	     * placeholders into the HText structure to see it instead of
	     * underscores when dumping or printing.  We also won't worry about
	     * a wrap in PRE blocks, because the line editor never is invoked
	     * for submit or reset buttons.  - LE & FM
	     */
	    if (I.type &&
		(!strcasecomp(I.type, "submit") ||
		 !strcasecomp(I.type, "reset") ||
		 !strcasecomp(I.type, "image")))
		IsSubmitOrReset = TRUE;

	    if (I.type && chars == 3 &&
		!strcasecomp(I.type, "radio")) {
		/*
		 * Put a (_) placeholder, and one space (collapsible) before
		 * the label that is expected to follow.  - FM
		 */
		HTML_put_string(me, "(_)");
		HText_endInput(me->text);
		chars = 0;
		me->in_word = YES;
		if (me->sp[0].tag_number != HTML_PRE &&
		    me->sp->style->freeFormat) {
		    HTML_put_character(me, ' ');
		    me->in_word = NO;
		}
	    } else if (I.type && chars == 3 &&
		       !strcasecomp(I.type, "checkbox")) {
		/*
		 * Put a [_] placeholder, and one space (collapsible) before
		 * the label that is expected to follow.  - FM
		 */
		HTML_put_string(me, "[_]");
		HText_endInput(me->text);
		chars = 0;
		me->in_word = YES;
		if (me->sp[0].tag_number != HTML_PRE &&
		    me->sp->style->freeFormat) {
		    HTML_put_character(me, ' ');
		    me->in_word = NO;
		}
	    } else if ((me->sp[0].tag_number == HTML_PRE ||
			!me->sp->style->freeFormat)
		       && chars > 6 &&
		       IsSubmitOrReset == FALSE) {
		/*
		 * This is not a submit or reset button, and we are in a PRE
		 * block with a field intended to exceed 6 character widths. 
		 * The code inadequately handles INPUT fields in PRE tags if
		 * wraps occur (at the right margin) for the underscore
		 * placeholders.  We'll put up a minimum of 6 underscores,
		 * since we should have wrapped artificially, above, if the
		 * INPUT begins within 6 columns of the right margin, and if
		 * any more would exceed the wrap column, we'll ignore them. 
		 * Note that if we somehow get tripped up and a wrap still does
		 * occur before all 6 of the underscores are output, the
		 * wrapped ones won't be treated as part of the editing window,
		 * nor be highlighted when not editing (Yuk!).  - FM
		 */
		for (i = 0; i < 6; i++) {
		    HTML_put_character(me, '_');
		    chars--;
		}
		HText_setIgnoreExcess(me->text, TRUE);
	    }
#ifndef USE_FILE_UPLOAD
	    CTRACE((tfp, "I.%s, %d\n", NONNULL(I.type), IsSubmitOrReset));
#endif
	    if (IsSubmitOrReset == FALSE) {
		/*
		 * This is not a submit or reset button, so output the rest of
		 * the underscore placeholders, if any more are needed.  - FM
		 */
		if (chars > 0) {
		    for (; chars > 0; chars--)
			HTML_put_character(me, '_');
		    HText_endInput(me->text);
		}
	    } else {
		if (HTCJK == JAPANESE) {
		    kcode = HText_getKcode(me->text);
		    HText_updateKcode(me->text, kanji_code);
		    specified_kcode = HText_getSpecifiedKcode(me->text);
		    HText_updateSpecifiedKcode(me->text, kanji_code);
		}
		if (me->sp[0].tag_number == HTML_PRE ||
		    !me->sp->style->freeFormat) {
		    /*
		     * We have a submit or reset button in a PRE block, so
		     * output the entire value from the markup.  If it extends
		     * to the right margin, it will wrap there, and only the
		     * portion before that wrap will be hightlighted on screen
		     * display (Yuk!) but we may as well show the rest of the
		     * full value on the next or more lines.  - FM
		     */
		    while (I.value[i])
			HTML_put_character(me, I.value[i++]);
		} else {
		    /*
		     * The submit or reset button is not in a PRE block.  Note
		     * that if a wrap occurs before outputting the entire
		     * value, the wrapped portion will not be highlighted or
		     * clearly indicated as part of the link for submission or
		     * reset (Yuk!).  We'll replace any spaces in the submit or
		     * reset button value with nbsp, to promote a wrap at the
		     * space we ensured would be present before the start of
		     * the string, as when we use all underscores instead of
		     * the INPUT's actual value, but we could still get a wrap
		     * at the right margin, instead, if the value is greater
		     * than a line width for the current style.  Also, if chars
		     * somehow ended up longer than the length of the actual
		     * value (shouldn't have), we'll continue padding with nbsp
		     * up to the length of chars.  - FM
		     */
		    for (i = 0; I.value[i]; i++)
			HTML_put_character(me,
					   (char) (I.value[i] == ' '
						   ? HT_NON_BREAK_SPACE
						   : I.value[i]));
		    while (i++ < chars)
			HTML_put_character(me, HT_NON_BREAK_SPACE);
		}
		if (HTCJK == JAPANESE) {
		    HText_updateKcode(me->text, kcode);
		    HText_updateSpecifiedKcode(me->text, specified_kcode);
		}
	    }
	    if (chars != 0) {
		HText_endInput(me->text);
	    }
	    HText_setIgnoreExcess(me->text, FALSE);
	    FREE(ImageSrc);
	    FREE(I_value);
	    FREE(I_name);
	}
	break;

    case HTML_TEXTAREA:
	/*
	 * Make sure we're in a form.
	 */
	if (!me->inFORM) {
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: TEXTAREA start tag not within FORM tag\n"));
	    /*
	     * Too likely to cause a crash, so we'll ignore it.  - FM
	     */
	    break;
	}

	/*
	 * Set to know we are in a textarea.
	 */
	me->inTEXTAREA = TRUE;

	/*
	 * Get ready for the value.
	 */
	HTChunkClear(&me->textarea);
	if (present && present[HTML_TEXTAREA_NAME] &&
	    value[HTML_TEXTAREA_NAME]) {
	    StrAllocCopy(me->textarea_name, value[HTML_TEXTAREA_NAME]);
	    me->textarea_name_cs = ATTR_CS_IN;
	    if (strchr(value[HTML_TEXTAREA_NAME], '&') != NULL) {
		UNESCAPE_FIELDNAME_TO_STD(&me->textarea_name);
	    }
	} else {
	    StrAllocCopy(me->textarea_name, "");
	}

	if (present && present[HTML_TEXTAREA_ACCEPT_CHARSET]) {
	    if (value[HTML_TEXTAREA_ACCEPT_CHARSET]) {
		StrAllocCopy(me->textarea_accept_cs, value[HTML_TEXTAREA_ACCEPT_CHARSET]);
		TRANSLATE_AND_UNESCAPE_TO_STD(&me->textarea_accept_cs);
	    } else {
		StrAllocCopy(me->textarea_accept_cs, "UNKNOWN");
	    }
	} else {
	    FREE(me->textarea_accept_cs);
	}

	if (present && present[HTML_TEXTAREA_COLS] &&
	    value[HTML_TEXTAREA_COLS] &&
	    isdigit(UCH(*value[HTML_TEXTAREA_COLS])))
	    me->textarea_cols = atoi(value[HTML_TEXTAREA_COLS]);
	else {
	    int width;

	    width = LYcolLimit -
		me->new_style->leftIndent - me->new_style->rightIndent;
	    if (dump_output_immediately)	/* don't waste too much for this */
		width = HTMIN(width, DFT_TEXTAREA_COLS);
	    if (width > 1 && (width - 1) * 6 < MAX_LINE - 3 -
		me->new_style->leftIndent - me->new_style->rightIndent)
		me->textarea_cols = width;
	    else
		me->textarea_cols = DFT_TEXTAREA_COLS;
	}
	LimitValue(me->textarea_cols, MAX_TEXTAREA_COLS);

	if (present && present[HTML_TEXTAREA_ROWS] &&
	    value[HTML_TEXTAREA_ROWS] &&
	    isdigit(UCH(*value[HTML_TEXTAREA_ROWS])))
	    me->textarea_rows = atoi(value[HTML_TEXTAREA_ROWS]);
	else
	    me->textarea_rows = DFT_TEXTAREA_ROWS;
	LimitValue(me->textarea_rows, MAX_TEXTAREA_ROWS);

	if (present && present[HTML_TEXTAREA_DISABLED])
	    me->textarea_disabled = YES;
	else
	    me->textarea_disabled = NO;

	if (present && present[HTML_TEXTAREA_ID]
	    && non_empty(value[HTML_TEXTAREA_ID])) {
	    StrAllocCopy(id_string, value[HTML_TEXTAREA_ID]);
	    TRANSLATE_AND_UNESCAPE_TO_STD(&id_string);
	    if ((id_string != '\0') &&
		(ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						  id_string,	/* Tag */
						  NULL,		/* Addresss */
						  (HTLinkType *) 0))) {		/* Type */
		HText_beginAnchor(me->text, me->inUnderline, ID_A);
		HText_endAnchor(me->text, 0);
		StrAllocCopy(me->textarea_id, id_string);
	    } else {
		FREE(me->textarea_id);
	    }
	    FREE(id_string);
	} else {
	    FREE(me->textarea_id);
	}
	break;

    case HTML_SELECT:
	/*
	 * Check for an already open SELECT block.  - FM
	 */
	if (me->inSELECT) {
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: SELECT start tag in SELECT element.  Faking SELECT end tag. *****\n"));
	    if (me->sp->tag_number != HTML_SELECT) {
		SET_SKIP_STACK(HTML_SELECT);
	    }
	    HTML_end_element(me, HTML_SELECT, include);
	}

	/*
	 * Start a new SELECT block. - FM
	 */
	LYHandleSELECT(me,
		       present, (const char **) value,
		       include,
		       TRUE);
	break;

    case HTML_OPTION:
	{
	    /*
	     * An option is a special case of an input field.
	     */
	    InputFieldData I;

	    /*
	     * Make sure we're in a select tag.
	     */
	    if (!me->inSELECT) {
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: OPTION tag not within SELECT tag\n"));

		/*
		 * Too likely to cause a crash, so we'll ignore it.  - FM
		 */
		break;
	    }

	    if (!me->first_option) {
		/*
		 * Finish the data off.
		 */
		HTChunkTerminate(&me->option);

		/*
		 * Finish the previous option @@@@@@@@@@
		 */
		HText_setLastOptionValue(me->text,
					 me->option.data,
					 me->LastOptionValue,
					 MIDDLE_ORDER,
					 me->LastOptionChecked,
					 me->UCLYhndl,
					 ATTR_CS_IN);
	    }

	    /*
	     * If it's not a multiple option list and select popups are
	     * enabled, then don't use the checkbox/button method, and don't
	     * put anything on the screen yet.
	     */
	    if (me->first_option ||
		HTCurSelectGroupType == F_CHECKBOX_TYPE ||
		LYSelectPopups == FALSE) {
		if (HTCurSelectGroupType == F_CHECKBOX_TYPE ||
		    LYSelectPopups == FALSE) {
		    /*
		     * Start a newline before each option.
		     */
		    LYEnsureSingleSpace(me);
		} else {
		    /*
		     * Add option list designation character.
		     */
		    HText_appendCharacter(me->text, '[');
		    me->in_word = YES;
		}

		/*
		 * Inititialize.
		 */
		I.align = NULL;
		I.accept = NULL;
		I.checked = NO;
		I.iclass = NULL;
		I.disabled = NO;
		I.error = NULL;
		I.height = NULL;
		I.id = NULL;
		I.lang = NULL;
		I.max = NULL;
		I.maxlength = NULL;
		I.md = NULL;
		I.min = NULL;
		I.name = NULL;
		I.size = 0;
		I.src = NULL;
		I.type = NULL;
		I.value = NULL;
		I.width = NULL;
		I.accept_cs = NULL;
		I.name_cs = -1;
		I.value_cs = current_char_set;

		I.type = "OPTION";

		if ((present && present[HTML_OPTION_SELECTED]) ||
		    (me->first_option && LYSelectPopups == FALSE &&
		     HTCurSelectGroupType == F_RADIO_TYPE))
		    I.checked = YES;

		if (present && present[HTML_OPTION_VALUE] &&
		    value[HTML_OPTION_VALUE]) {
		    /*
		     * Convert any HTML entities or decimal escaping.  - FM
		     */
		    StrAllocCopy(I_value, value[HTML_OPTION_VALUE]);
		    me->HiddenValue = TRUE;
		    TRANSLATE_AND_UNESCAPE_ENTITIES6(&I_value,
						     ATTR_CS_IN,
						     ATTR_CS_IN,
						     NO,
						     me->UsePlainSpace, me->HiddenValue);
		    I.value_cs = ATTR_CS_IN;
		    me->HiddenValue = FALSE;

		    I.value = I_value;
		}

		if (me->select_disabled ||
		    (present && present[HTML_OPTION_DISABLED]))
		    I.disabled = YES;

		if (present && present[HTML_OPTION_ID]
		    && non_empty(value[HTML_OPTION_ID])) {
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  value[HTML_OPTION_ID],	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
			HText_beginAnchor(me->text, me->inUnderline, ID_A);
			HText_endAnchor(me->text, 0);
			I.id = value[HTML_OPTION_ID];
		    }
		}

		HText_beginInput(me->text, me->inUnderline, &I);

		if (HTCurSelectGroupType == F_CHECKBOX_TYPE) {
		    /*
		     * Put a "[_]" placeholder, and one space (collapsible)
		     * before the label that is expected to follow.  - FM
		     */
		    HText_appendCharacter(me->text, '[');
		    HText_appendCharacter(me->text, '_');
		    HText_appendCharacter(me->text, ']');
		    HText_appendCharacter(me->text, ' ');
		    HText_setLastChar(me->text, ' ');	/* absorb white space */
		    me->in_word = NO;
		} else if (LYSelectPopups == FALSE) {
		    /*
		     * Put a "(_)" placeholder, and one space (collapsible)
		     * before the label that is expected to follow.  - FM
		     */
		    HText_appendCharacter(me->text, '(');
		    HText_appendCharacter(me->text, '_');
		    HText_appendCharacter(me->text, ')');
		    HText_appendCharacter(me->text, ' ');
		    HText_setLastChar(me->text, ' ');	/* absorb white space */
		    me->in_word = NO;
		}
	    }

	    /*
	     * Get ready for the next value.
	     */
	    HTChunkClear(&me->option);
	    if ((present && present[HTML_OPTION_SELECTED]) ||
		(me->first_option && LYSelectPopups == FALSE &&
		 HTCurSelectGroupType == F_RADIO_TYPE))
		me->LastOptionChecked = TRUE;
	    else
		me->LastOptionChecked = FALSE;
	    me->first_option = FALSE;

	    if (present && present[HTML_OPTION_VALUE] &&
		value[HTML_OPTION_VALUE]) {
		if (!I_value) {
		    /*
		     * Convert any HTML entities or decimal escaping.  - FM
		     */
		    StrAllocCopy(I_value, value[HTML_OPTION_VALUE]);
		    me->HiddenValue = TRUE;
		    TRANSLATE_AND_UNESCAPE_ENTITIES6(&I_value,
						     ATTR_CS_IN,
						     ATTR_CS_IN,
						     NO,
						     me->UsePlainSpace, me->HiddenValue);
		    me->HiddenValue = FALSE;
		}
		StrAllocCopy(me->LastOptionValue, I_value);
	    } else {
		StrAllocCopy(me->LastOptionValue, me->option.data);
	    }

	    /*
	     * If this is a popup option, print its option for use in selecting
	     * option by number.  - LE
	     */
	    if (HTCurSelectGroupType == F_RADIO_TYPE &&
		LYSelectPopups &&
		fields_are_numbered()) {
		char marker[8];
		int opnum = HText_getOptionNum(me->text);

		if (opnum > 0 && opnum < 100000) {
		    sprintf(marker, "(%d)", opnum);
		    HTML_put_string(me, marker);
		    for (i = strlen(marker); i < 5; ++i) {
			HTML_put_character(me, '_');
		    }
		}
	    }
	    FREE(I_value);
	}
	break;

    case HTML_TABLE:
	/*
	 * Not fully implemented.  Just treat as a division with respect to any
	 * ALIGN attribute, with a default of HT_LEFT, or leave as a PRE block
	 * if we are presently in one.  - FM
	 *
	 * Also notify simple table tracking code unless in a preformatted
	 * section, or (currently) non-left alignment.
	 *
	 * If page author is using a TABLE within PRE, it's probably formatted
	 * specifically to work well for Lynx without simple table tracking
	 * code.  Cancel tracking, it would only make things worse.  - kw
	 */
#ifdef EXP_NESTED_TABLES
	if (!nested_tables)
#endif
	    HText_cancelStbl(me->text);

	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	if (me->Underline_Level > 0) {
	    SET_SKIP_STACK(HTML_U);
	    HTML_end_element(me, HTML_U, include);
	}
	me->inTABLE = TRUE;
	if (me->sp->style->id == ST_Preformatted) {
	    UPDATE_STYLE;
	    CHECK_ID(HTML_TABLE_ID);
	    break;
	}
	if (me->Division_Level < (MAX_NESTING - 1)) {
	    me->Division_Level++;
	} else {
	    CTRACE((tfp,
		    "HTML: ****** Maximum nesting of %d divisions/tables exceeded!\n",
		    MAX_NESTING));
	}
	if (present && present[HTML_TABLE_ALIGN] &&
	    non_empty(value[HTML_TABLE_ALIGN])) {
	    if (!strcasecomp(value[HTML_TABLE_ALIGN], "center")) {
		if (no_table_center) {
		    me->DivisionAlignments[me->Division_Level] = HT_LEFT;
		    change_paragraph_style(me, styles[HTML_DLEFT]);
		    UPDATE_STYLE;
		    me->current_default_alignment =
			styles[HTML_DLEFT]->alignment;
		} else {
		    me->DivisionAlignments[me->Division_Level] = HT_CENTER;
		    change_paragraph_style(me, styles[HTML_DCENTER]);
		    UPDATE_STYLE;
		    me->current_default_alignment =
			styles[HTML_DCENTER]->alignment;
		}

		stbl_align = HT_CENTER;

	    } else if (!strcasecomp(value[HTML_TABLE_ALIGN], "right")) {
		me->DivisionAlignments[me->Division_Level] = HT_RIGHT;
		change_paragraph_style(me, styles[HTML_DRIGHT]);
		UPDATE_STYLE;
		me->current_default_alignment = styles[HTML_DRIGHT]->alignment;
		stbl_align = HT_RIGHT;
	    } else {
		me->DivisionAlignments[me->Division_Level] = HT_LEFT;
		change_paragraph_style(me, styles[HTML_DLEFT]);
		UPDATE_STYLE;
		me->current_default_alignment = styles[HTML_DLEFT]->alignment;
		if (!strcasecomp(value[HTML_TABLE_ALIGN], "left") ||
		    !strcasecomp(value[HTML_TABLE_ALIGN], "justify"))
		    stbl_align = HT_LEFT;
	    }
	} else {
	    me->DivisionAlignments[me->Division_Level] = HT_LEFT;
	    change_paragraph_style(me, styles[HTML_DLEFT]);
	    UPDATE_STYLE;
	    me->current_default_alignment = styles[HTML_DLEFT]->alignment;
	    /* stbl_align remains HT_ALIGN_NONE */
	}
	CHECK_ID(HTML_TABLE_ID);
	HText_startStblTABLE(me->text, stbl_align);
	break;

    case HTML_TR:
	/*
	 * Not fully implemented.  Just start a new row, if needed, act on an
	 * ALIGN attribute if present, and check for an ID link.  - FM
	 * Also notify simple table tracking code.  - kw
	 */
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	if (me->Underline_Level > 0) {
	    SET_SKIP_STACK(HTML_U);
	    HTML_end_element(me, HTML_U, include);
	}
	UPDATE_STYLE;
	if (!HText_LastLineEmpty(me->text, FALSE)) {
	    HText_setLastChar(me->text, ' ');	/* absorb white space */
	    HText_appendCharacter(me->text, '\r');
	}
	me->in_word = NO;

	if (me->sp->style->id == ST_Preformatted) {
	    CHECK_ID(HTML_TR_ID);
	    me->inP = FALSE;
/*	    HText_cancelStbl(me->text);  seems unnecessary here - kw */
	    break;
	}
	if (LYoverride_default_alignment(me)) {
	    me->sp->style->alignment = styles[me->sp[0].tag_number]->alignment;
	} else if (me->List_Nesting_Level >= 0 ||
		   ((me->Division_Level < 0) &&
		    (me->sp->style->id == ST_Normal ||
		     me->sp->style->id == ST_Preformatted))) {
	    me->sp->style->alignment = HT_LEFT;
	} else {
	    me->sp->style->alignment = (short) me->current_default_alignment;
	}
	if (present && present[HTML_TR_ALIGN] && value[HTML_TR_ALIGN]) {
	    if (!strcasecomp(value[HTML_TR_ALIGN], "center") &&
		!(me->List_Nesting_Level >= 0 && !me->inP)) {
		if (no_table_center)
		    me->sp->style->alignment = HT_LEFT;
		else
		    me->sp->style->alignment = HT_CENTER;
		stbl_align = HT_CENTER;
	    } else if (!strcasecomp(value[HTML_TR_ALIGN], "right") &&
		       !(me->List_Nesting_Level >= 0 && !me->inP)) {
		me->sp->style->alignment = HT_RIGHT;
		stbl_align = HT_RIGHT;
	    } else if (!strcasecomp(value[HTML_TR_ALIGN], "left") ||
		       !strcasecomp(value[HTML_TR_ALIGN], "justify")) {
		me->sp->style->alignment = HT_LEFT;
		stbl_align = HT_LEFT;
	    }
	}

	CHECK_ID(HTML_TR_ID);
	me->inP = FALSE;
	HText_startStblTR(me->text, stbl_align);
	break;

    case HTML_THEAD:
    case HTML_TFOOT:
    case HTML_TBODY:
	HText_endStblTR(me->text);
	/*
	 * Not fully implemented.  Just check for an ID link.  - FM
	 */
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	if (me->Underline_Level > 0) {
	    SET_SKIP_STACK(HTML_U);
	    HTML_end_element(me, HTML_U, include);
	}
	UPDATE_STYLE;
	if (me->inTABLE) {
	    if (present && present[HTML_TR_ALIGN] && value[HTML_TR_ALIGN]) {
		if (!strcasecomp(value[HTML_TR_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_TR_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_TR_ALIGN], "left") ||
			   !strcasecomp(value[HTML_TR_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblRowGroup(me->text, stbl_align);
	}
	CHECK_ID(HTML_TR_ID);
	break;

    case HTML_COL:
    case HTML_COLGROUP:
	/*
	 * Not fully implemented.  Just check for an ID link.  - FM
	 */
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	if (me->Underline_Level > 0) {
	    SET_SKIP_STACK(HTML_U);
	    HTML_end_element(me, HTML_U, include);
	}
	UPDATE_STYLE;
	if (me->inTABLE) {
	    int span = 1;

	    if (present && present[HTML_COL_SPAN] &&
		value[HTML_COL_SPAN] &&
		isdigit(UCH(*value[HTML_COL_SPAN])))
		span = atoi(value[HTML_COL_SPAN]);
	    if (present && present[HTML_COL_ALIGN] && value[HTML_COL_ALIGN]) {
		if (!strcasecomp(value[HTML_COL_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_COL_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_COL_ALIGN], "left") ||
			   !strcasecomp(value[HTML_COL_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblCOL(me->text, span, stbl_align,
			       (BOOL) (ElementNumber == HTML_COLGROUP));
	}
	CHECK_ID(HTML_COL_ID);
	break;

    case HTML_TH:
    case HTML_TD:
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	if (me->Underline_Level > 0) {
	    SET_SKIP_STACK(HTML_U);
	    HTML_end_element(me, HTML_U, include);
	}
	UPDATE_STYLE;
	CHECK_ID(HTML_TD_ID);
	/*
	 * Not fully implemented.  Just add a collapsible space and break - FM
	 * Also notify simple table tracking code.  - kw
	 */
	HTML_put_character(me, ' ');
	{
	    int colspan = 1, rowspan = 1;

	    if (present && present[HTML_TD_COLSPAN] &&
		value[HTML_TD_COLSPAN] &&
		isdigit(UCH(*value[HTML_TD_COLSPAN])))
		colspan = atoi(value[HTML_TD_COLSPAN]);
	    if (present && present[HTML_TD_ROWSPAN] &&
		value[HTML_TD_ROWSPAN] &&
		isdigit(UCH(*value[HTML_TD_ROWSPAN])))
		rowspan = atoi(value[HTML_TD_ROWSPAN]);
	    if (present && present[HTML_TD_ALIGN] && value[HTML_TD_ALIGN]) {
		if (!strcasecomp(value[HTML_TD_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_TD_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_TD_ALIGN], "left") ||
			   !strcasecomp(value[HTML_TD_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblTD(me->text, colspan, rowspan, stbl_align,
			      (BOOL) (ElementNumber == HTML_TH));
	}
	me->in_word = NO;
	break;

    case HTML_MATH:
	/*
	 * We're getting it as Literal text, which, until we can process it,
	 * we'll display as is, within brackets to alert the user.  - FM
	 */
	HTChunkClear(&me->math);
	CHECK_ID(HTML_GEN_ID);
	break;

    default:
	break;

    }				/* end switch */

    if (ElementNumber >= HTML_ELEMENTS ||
	HTML_dtd.tags[ElementNumber].contents != SGML_EMPTY) {
	if (me->skip_stack > 0) {
	    CTRACE((tfp,
		    "HTML:begin_element: internal call (level %d), leaving on stack - `%s'\n",
		    me->skip_stack, NONNULL(me->sp->style->name)));
	    me->skip_stack--;
	    return status;
	}
	if (me->sp == me->stack) {
	    if (me->stack_overrun == FALSE) {
		HTAlert(HTML_STACK_OVERRUN);
		CTRACE((tfp,
			"HTML: ****** Maximum nesting of %d tags exceeded!\n",
			MAX_NESTING));
		me->stack_overrun = TRUE;
	    }
	    return HT_ERROR;
	}

	CTRACE((tfp,
		"HTML:begin_element[%d]: adding style to stack - %s (%s)\n",
		(int) STACKLEVEL(me),
		NONNULL(me->new_style->name),
		HTML_dtd.tags[ElementNumber].name));
	(me->sp)--;
	me->sp[0].style = me->new_style;	/* Stack new style */
	me->sp[0].tag_number = ElementNumber;
#ifdef EXP_JUSTIFY_ELTS
	if (wait_for_this_stacked_elt < 0 &&
	    HTML_dtd.tags[ElementNumber].can_justify == FALSE)
	    wait_for_this_stacked_elt = me->stack - me->sp + MAX_NESTING;
#endif
    }
#ifdef EXP_JUSTIFY_ELTS
    if (in_DT && ElementNumber == HTML_DD)
	in_DT = FALSE;
    else if (ElementNumber == HTML_DT)
	in_DT = TRUE;
#endif

#if defined(USE_COLOR_STYLE)
/* end really empty tags straight away */

    if (ReallyEmptyTagNum(element_number)) {
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE.begin_element:ending \"EMPTY\" element style\n"));
	HText_characterStyle(me->text, HCODE_TO_STACK_OFF(hcode), STACK_OFF);

#  if !OMIT_SCN_KEEPING
	FastTrimColorClass(HTML_dtd.tags[element_number].name,
			   HTML_dtd.tags[element_number].name_len,
			   Style_className,
			   &Style_className_end, &hcode);
#  endif
    }
#endif /* USE_COLOR_STYLE */
    return status;
}

/*		End Element
 *		-----------
 *
 *	When we end an element, the style must be returned to that
 *	in effect before that element.	Note that anchors (etc?)
 *	don't have an associated style, so that we must scan down the
 *	stack for an element with a defined style. (In fact, the styles
 *	should be linked to the whole stack not just the top one.)
 *	TBL 921119
 *
 *	We don't turn on "CAREFUL" check because the parser produces
 *	(internal code errors apart) good nesting.  The parser checks
 *	incoming code errors, not this module.
 */
static int HTML_end_element(HTStructured * me, int element_number,
			    char **include)
{
    int i = 0;
    int status = HT_OK;
    char *temp = NULL, *cp = NULL;
    BOOL BreakFlag = FALSE;
    BOOL intern_flag = FALSE;
    BOOL skip_stack_requested = FALSE;
    EMIT_IFDEF_EXP_JUSTIFY_ELTS(BOOL reached_awaited_stacked_elt = FALSE);

#ifdef USE_PRETTYSRC
    if (psrc_view && !sgml_in_psrc_was_initialized) {
	if (!psrc_nested_call) {
	    HTTag *tag = &HTML_dtd.tags[element_number];
	    char buf[200];
	    int tag_charset = 0;

	    psrc_nested_call = TRUE;
	    PSRCSTART(abracket);
	    PUTS("</");
	    PSRCSTOP(abracket);
	    PSRCSTART(tag);
	    if (tagname_transform != 0)
		PUTS(tag->name);
	    else {
		LYstrncpy(buf, tag->name, sizeof(buf) - 1);
		LYLowerCase(buf);
		PUTS(buf);
	    }
	    PSRCSTOP(tag);
	    PSRCSTART(abracket);
	    PUTC('>');
	    PSRCSTOP(abracket);
	    psrc_nested_call = FALSE;
	    return HT_OK;
	}
	/*fall through */
    }
#endif

    if ((me->sp >= (me->stack + MAX_NESTING - 1) ||
	 element_number != me->sp[0].tag_number) &&
	HTML_dtd.tags[element_number].contents != SGML_EMPTY) {
	CTRACE((tfp,
		"HTML: end of element %s when expecting end of %s\n",
		HTML_dtd.tags[element_number].name,
		(me->sp == me->stack + MAX_NESTING - 1) ? "none" :
		(me->sp->tag_number < 0) ? "*invalid tag*" :
		(me->sp->tag_number >= HTML_ELEMENTS) ? "special tag" :
		HTML_dtd.tags[me->sp->tag_number].name));
#ifdef CAREFUL			/* parser assumed to produce good nesting */
	/* panic */
#endif /* CAREFUL */
    }

    /*
     * If we're seeking MAPs, skip everything that's not a MAP or AREA tag.  -
     * FM
     */
    if (LYMapsOnly) {
	if (!(element_number == HTML_MAP || element_number == HTML_AREA ||
	      element_number == HTML_OBJECT)) {
	    return HT_OK;
	}
    }

    /*
     * Pop state off stack if we didn't declare the element SGML_EMPTY in
     * HTMLDTD.c.  - FM & KW
     */
    if (HTML_dtd.tags[element_number].contents != SGML_EMPTY) {
	skip_stack_requested = (BOOL) (me->skip_stack > 0);
	if ((element_number != me->sp[0].tag_number) &&
	    me->skip_stack <= 0 &&
	    HTML_dtd.tags[HTML_LH].contents != SGML_EMPTY &&
	    (me->sp[0].tag_number == HTML_UL ||
	     me->sp[0].tag_number == HTML_OL ||
	     me->sp[0].tag_number == HTML_MENU ||
	     me->sp[0].tag_number == HTML_DIR ||
	     me->sp[0].tag_number == HTML_LI) &&
	    (element_number == HTML_H1 ||
	     element_number == HTML_H2 ||
	     element_number == HTML_H3 ||
	     element_number == HTML_H4 ||
	     element_number == HTML_H6 ||
	     element_number == HTML_H6)) {
	    /*
	     * Set the break flag if we're popping a dummy HTML_LH substituted
	     * for an HTML_H# encountered in a list.
	     */
	    BreakFlag = TRUE;
	}
	if (me->skip_stack == 0 && element_number == HTML_OBJECT &&
	    me->sp[0].tag_number == HTML_OBJECT_M &&
	    (me->sp < (me->stack + MAX_NESTING - 1)))
	    me->sp[0].tag_number = HTML_OBJECT;
	if (me->skip_stack > 0) {
	    CTRACE2(TRACE_STYLE,
		    (tfp,
		     "HTML:end_element: Internal call (level %d), leaving on stack - %s\n",
		     me->skip_stack, NONNULL(me->sp->style->name)));
	    me->skip_stack--;
	} else if (element_number == HTML_OBJECT &&
		   me->sp[0].tag_number != HTML_OBJECT &&
		   me->sp[0].tag_number != HTML_OBJECT_M &&
		   me->objects_mixed_open > 0 &&
		   !(me->objects_figged_open > 0 &&
		     me->sp[0].tag_number == HTML_FIG)) {
	    /*
	     * Ignore non-corresponding OBJECT tags that we didn't push because
	     * the SGML parser was supposed to go on parsing the contents
	     * non-literally.  - kw
	     */
	    CTRACE2(TRACE_STYLE,
		    (tfp, "HTML:end_element[%d]: %s (level %d), %s - %s\n",
		     (int) STACKLEVEL(me),
		     "Special OBJECT handling", me->objects_mixed_open,
		     "leaving on stack",
		     NONNULL(me->sp->style->name)));
	    me->objects_mixed_open--;
	} else if (me->stack_overrun == TRUE &&
		   element_number != me->sp[0].tag_number) {
	    /*
	     * Ignore non-corresponding tags if we had a stack overrun.  This
	     * is not a completely fail-safe strategy for protection against
	     * any seriously adverse consequences of a stack overrun, and the
	     * rendering of the document will not be as intended, but we expect
	     * overruns to be rare, and this should offer reasonable protection
	     * against crashes if an overrun does occur.  - FM
	     */
	    return HT_OK;	/* let's pretend... */
	} else if (element_number == HTML_SELECT &&
		   me->sp[0].tag_number != HTML_SELECT) {
	    /*
	     * Ignore non-corresponding SELECT tags, since we probably popped
	     * it and closed the SELECT block to deal with markup which amounts
	     * to a nested SELECT, or an out of order FORM end tag.  - FM
	     */
	    return HT_OK;
	} else if ((element_number != me->sp[0].tag_number) &&
		   HTML_dtd.tags[HTML_LH].contents == SGML_EMPTY &&
		   (me->sp[0].tag_number == HTML_UL ||
		    me->sp[0].tag_number == HTML_OL ||
		    me->sp[0].tag_number == HTML_MENU ||
		    me->sp[0].tag_number == HTML_DIR ||
		    me->sp[0].tag_number == HTML_LI) &&
		   (element_number == HTML_H1 ||
		    element_number == HTML_H2 ||
		    element_number == HTML_H3 ||
		    element_number == HTML_H4 ||
		    element_number == HTML_H6 ||
		    element_number == HTML_H6)) {
	    /*
	     * It's an H# for which we substituted an HTML_LH, which we've
	     * declared as SGML_EMPTY, so just return.  - FM
	     */
	    return HT_OK;
	} else if (me->sp < (me->stack + MAX_NESTING - 1)) {
#ifdef EXP_JUSTIFY_ELTS
	    if (wait_for_this_stacked_elt == me->stack - me->sp + MAX_NESTING)
		reached_awaited_stacked_elt = TRUE;
#endif
	    if (element_number == HTML_OBJECT) {
		if (me->sp[0].tag_number == HTML_FIG &&
		    me->objects_figged_open > 0) {
		    /*
		     * It's an OBJECT for which we substituted a FIG, so pop
		     * the FIG and pretend that's what we are being called for. 
		     * - kw
		     */
		    CTRACE2(TRACE_STYLE,
			    (tfp,
			     "HTML:end_element[%d]: %s (level %d), %s - %s\n",
			     (int) STACKLEVEL(me),
			     "Special OBJECT->FIG handling",
			     me->objects_figged_open,
			     "treating as end FIG",
			     NONNULL(me->sp->style->name)));
		    me->objects_figged_open--;
		    element_number = HTML_FIG;
		}
	    }
	    (me->sp)++;
	    CTRACE2(TRACE_STYLE,
		    (tfp,
		     "HTML:end_element[%d]: Popped style off stack - %s\n",
		     (int) STACKLEVEL(me),
		     NONNULL(me->sp->style->name)));
	} else {
	    CTRACE2(TRACE_STYLE, (tfp,
				  "Stack underflow error!  Tried to pop off more styles than exist in stack\n"));
	}
    }
    if (BreakFlag == TRUE) {
#ifdef EXP_JUSTIFY_ELTS
	if (reached_awaited_stacked_elt)
	    wait_for_this_stacked_elt = -1;
#endif
	return HT_OK;		/* let's pretend... */
    }

    /*
     * Check for unclosed TEXTAREA.  - FM
     */
    if (me->inTEXTAREA && element_number != HTML_TEXTAREA) {
	if (LYBadHTML(me))
	    CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag\n"));
    }

    if (!me->text && !LYMapsOnly) {
	UPDATE_STYLE;
    }

    /*
     * Handle the end tag.  - FM
     */
    switch (element_number) {

    case HTML_HTML:
	if (me->inA || me->inSELECT || me->inTEXTAREA) {
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: %s%s%s%s%s not closed before HTML end tag *****\n",
			me->inSELECT ? "SELECT" : "",
			(me->inSELECT && me->inTEXTAREA) ? ", " : "",
			me->inTEXTAREA ? "TEXTAREA" : "",
			(((me->inSELECT || me->inTEXTAREA) && me->inA)
			 ? ", "
			 : ""),
			me->inA ? "A" : ""));
	}
	break;

    case HTML_HEAD:
	if (me->inBASE &&
	    (LYIsUIPage3(me->node_anchor->address, UIP_LIST_PAGE, 0) ||
	     LYIsUIPage3(me->node_anchor->address, UIP_ADDRLIST_PAGE, 0))) {
	    /* If we are parsing the List Page, and have a BASE after we are
	     * done with the HEAD element, propagate it back to the node_anchor
	     * object.  The base should have been inserted by showlist() to
	     * record what document the List Page is about, and other functions
	     * may later look for it in the anchor.  - kw
	     */
	    StrAllocCopy(me->node_anchor->content_base, me->base_href);
	}
	if (HText_hasToolbar(me->text))
	    HText_appendParagraph(me->text);
	break;

    case HTML_TITLE:
	HTChunkTerminate(&me->title);
	HTAnchor_setTitle(me->node_anchor, me->title.data);
	HTChunkClear(&me->title);
	/*
	 * Check if it's a bookmark file, and if so, and multiple bookmark
	 * support is on, or it's off but this isn't the default bookmark file
	 * (e.g., because it was on before, and this is another bookmark file
	 * that has been retrieved as a previous document), insert the current
	 * description string and filepath for it.  We pass the strings back to
	 * the SGML parser so that any 8 bit or multibyte/CJK characters will
	 * be handled by the parser's state and charset routines.  - FM
	 */
	if (non_empty(me->node_anchor->bookmark)) {
	    if ((LYMultiBookmarks != MBM_OFF) ||
		(non_empty(bookmark_page) &&
		 strcmp(me->node_anchor->bookmark, bookmark_page))) {
		if (!include)
		    include = &me->xinclude;
		for (i = 0; i <= MBM_V_MAXFILES; i++) {
		    if (MBM_A_subbookmark[i] &&
			!strcmp(MBM_A_subbookmark[i],
				me->node_anchor->bookmark)) {
			StrAllocCat(*include, "<H2><EM>");
			StrAllocCat(*include, gettext("Description:"));
			StrAllocCat(*include, "</EM> ");
			StrAllocCopy(temp,
				     ((MBM_A_subdescript[i] &&
				       *MBM_A_subdescript[i]) ?
				      MBM_A_subdescript[i] : gettext("(none)")));
			LYEntify(&temp, TRUE);
			StrAllocCat(*include, temp);
			StrAllocCat(*include, "<BR><EM>&nbsp;&nbsp;&nbsp;");
			StrAllocCat(*include, gettext("Filepath:"));
			StrAllocCat(*include, "</EM> ");
			StrAllocCopy(temp,
				     ((MBM_A_subbookmark[i] &&
				       *MBM_A_subbookmark[i])
				      ? MBM_A_subbookmark[i]
				      : gettext("(unknown)")));
			LYEntify(&temp, TRUE);
			StrAllocCat(*include, temp);
			FREE(temp);
			StrAllocCat(*include, "</H2>");
			break;
		    }
		}
	    }
	}
	break;

    case HTML_STYLE:
	/*
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
	 */
	HTChunkTerminate(&me->style_block);
	CTRACE2(TRACE_STYLE,
		(tfp, "HTML: STYLE content =\n%s\n",
		 me->style_block.data));
	HTChunkClear(&me->style_block);
	break;

    case HTML_SCRIPT:
	/*
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
	 */
	HTChunkTerminate(&me->script);
	CTRACE((tfp, "HTML: SCRIPT content =\n%s\n",
		me->script.data));
	HTChunkClear(&me->script);
	break;

    case HTML_BODY:
	if (me->inA || me->inSELECT || me->inTEXTAREA) {
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: %s%s%s%s%s not closed before BODY end tag *****\n",
			me->inSELECT ? "SELECT" : "",
			(me->inSELECT && me->inTEXTAREA) ? ", " : "",
			me->inTEXTAREA ? "TEXTAREA" : "",
			(((me->inSELECT || me->inTEXTAREA) && me->inA)
			 ? ", "
			 : ""),
			me->inA ? "A" : ""));
	}
	break;

    case HTML_FRAMESET:
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_NOFRAMES:
    case HTML_IFRAME:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_BANNER:
    case HTML_MARQUEE:
    case HTML_BLOCKQUOTE:
    case HTML_BQ:
    case HTML_ADDRESS:
	/*
	 * Set flag to know that style has ended.  Fall through.
	 i_prior_style = -1;
	 */
	change_paragraph_style(me, me->sp->style);
	UPDATE_STYLE;
	if (me->sp->tag_number == element_number)
	    LYEnsureDoubleSpace(me);
	if (me->List_Nesting_Level >= 0)
	    HText_NegateLineOne(me->text);
	break;

    case HTML_CENTER:
    case HTML_DIV:
	if (me->Division_Level >= 0)
	    me->Division_Level--;
	if (me->Division_Level >= 0) {
	    if (me->sp->style->alignment !=
		me->DivisionAlignments[me->Division_Level]) {
		if (me->inP)
		    LYEnsureSingleSpace(me);
		me->sp->style->alignment =
		    me->DivisionAlignments[me->Division_Level];
	    }
	}
	change_paragraph_style(me, me->sp->style);
	if (me->style_change) {
	    actually_set_style(me);
	    if (me->List_Nesting_Level >= 0)
		HText_NegateLineOne(me->text);
	} else if (me->inP)
	    LYEnsureSingleSpace(me);
	me->current_default_alignment = me->sp->style->alignment;
	break;

    case HTML_H1:		/* header styles */
    case HTML_H2:
    case HTML_H3:
    case HTML_H4:
    case HTML_H5:
    case HTML_H6:
	if (me->Division_Level >= 0) {
	    me->sp->style->alignment =
		me->DivisionAlignments[me->Division_Level];
	} else if (me->sp->style->id == ST_HeadingCenter ||
		   me->sp->style->id == ST_Heading1) {
	    me->sp->style->alignment = HT_CENTER;
	} else if (me->sp->style->id == ST_HeadingRight) {
	    me->sp->style->alignment = HT_RIGHT;
	} else {
	    me->sp->style->alignment = HT_LEFT;
	}
	change_paragraph_style(me, me->sp->style);
	UPDATE_STYLE;
	if (styles[element_number]->font & HT_BOLD) {
	    if (me->inBoldA == FALSE && me->inBoldH == TRUE) {
		HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
	    }
	    me->inBoldH = FALSE;
	}
	if (me->List_Nesting_Level >= 0)
	    HText_NegateLineOne(me->text);
	if (me->Underline_Level > 0 && me->inUnderline == FALSE) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    me->inUnderline = TRUE;
	}
	break;

    case HTML_P:
	LYHandlePlike(me,
		      (const BOOL *) 0, (const char **) 0,
		      include, 0,
		      FALSE);
	break;

    case HTML_FONT:
	me->inFONT = FALSE;
	break;

    case HTML_B:		/* Physical character highlighting */
    case HTML_BLINK:
    case HTML_I:
    case HTML_U:

    case HTML_CITE:		/* Logical character highlighting */
    case HTML_EM:
    case HTML_STRONG:
	/*
	 * Ignore any emphasis end tags if the Underline_Level is not set.  -
	 * FM
	 */
	if (me->Underline_Level <= 0)
	    break;

	/*
	 * Adjust the Underline level counter, and turn off underlining if
	 * appropriate.  - FM
	 */
	me->Underline_Level--;
	if (me->inUnderline && me->Underline_Level < 1) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    me->inUnderline = FALSE;
	    CTRACE((tfp, "Ending underline\n"));
	} else {
	    CTRACE((tfp, "Underline Level is %d\n", me->Underline_Level));
	}
	break;

    case HTML_ABBREV:		/* Miscellaneous character containers */
    case HTML_ACRONYM:
    case HTML_AU:
    case HTML_AUTHOR:
    case HTML_BIG:
    case HTML_CODE:
    case HTML_DFN:
    case HTML_KBD:
    case HTML_SAMP:
    case HTML_SMALL:
    case HTML_SUP:
    case HTML_TT:
    case HTML_VAR:
	break;

    case HTML_SUB:
	HText_appendCharacter(me->text, ']');
	break;

    case HTML_DEL:
    case HTML_S:
    case HTML_STRIKE:
	HTML_put_character(me, ' ');
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	HTML_put_string(me, ":DEL]");
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	HTML_put_character(me, ' ');
	me->in_word = NO;
	break;

    case HTML_INS:
	HTML_put_character(me, ' ');
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	HTML_put_string(me, ":INS]");
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	HTML_put_character(me, ' ');
	me->in_word = NO;
	break;

    case HTML_Q:
	if (me->Quote_Level > 0)
	    me->Quote_Level--;
	/*
	 * Should check LANG and/or DIR attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * to determine whether we should use chevrons, but for now we'll
	 * always use double- or single-quotes.  - FM
	 */
	if (!(me->Quote_Level & 1))
	    HTML_put_character(me, '"');
	else
	    HTML_put_character(me, '\'');
	break;

    case HTML_PRE:		/* Formatted text */
	/*
	 * Set to know that we are no longer in a PRE block.
	 */
	me->inPRE = FALSE;
	/* FALLTHRU */
    case HTML_LISTING:		/* Literal text */
	/* FALLTHRU */
    case HTML_XMP:
	/* FALLTHRU */
    case HTML_PLAINTEXT:
	if (me->comment_start)
	    HText_appendText(me->text, me->comment_start);
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	if (me->List_Nesting_Level >= 0) {
	    UPDATE_STYLE;
	    HText_NegateLineOne(me->text);
	}
	break;

    case HTML_NOTE:
    case HTML_FN:
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	UPDATE_STYLE;
	if (me->sp->tag_number == element_number)
	    LYEnsureDoubleSpace(me);
	if (me->List_Nesting_Level >= 0)
	    HText_NegateLineOne(me->text);
	me->inLABEL = FALSE;
	break;

    case HTML_OL:
	me->OL_Counter[me->List_Nesting_Level < 11 ?
		       me->List_Nesting_Level : 11] = OL_VOID;
	/* FALLTHRU */
    case HTML_DL:
	/* FALLTHRU */
    case HTML_UL:
	/* FALLTHRU */
    case HTML_MENU:
	/* FALLTHRU */
    case HTML_DIR:
	me->List_Nesting_Level--;
	CTRACE((tfp, "HTML_end_element: Reducing List Nesting Level to %d\n",
		me->List_Nesting_Level));
#ifdef EXP_JUSTIFY_ELTS
	if (element_number == HTML_DL)
	    in_DT = FALSE;	/*close the term that was without definition. */
#endif
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	UPDATE_STYLE;
	if (me->List_Nesting_Level >= 0)
	    LYEnsureSingleSpace(me);
	break;

    case HTML_SPAN:
	/*
	 * Should undo anything we did based on LANG and/or DIR attributes, and
	 * the me->node_anchor->charset and/or yet to be added structure
	 * elements.  - FM
	 */
	break;

    case HTML_BDO:
	/*
	 * Should undo anything we did based on DIR (and/or LANG) attributes,
	 * and the me->node_anchor->charset and/or yet to be added structure
	 * elements.  - FM
	 */
	break;

    case HTML_A:
	/*
	 * Ignore any spurious A end tags.  - FM
	 */
	if (me->inA == FALSE)
	    break;
	/*
	 * Set to know that we are no longer in an anchor.
	 */
	me->inA = FALSE;
#ifdef MARK_HIDDEN_LINKS
	if (non_empty(hidden_link_marker) &&
	    HText_isAnchorBlank(me->text, me->CurrentANum)) {
	    HText_appendText(me->text, hidden_link_marker);
	}
#endif
	UPDATE_STYLE;
	if (me->inBoldA == TRUE && me->inBoldH == FALSE)
	    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
	HText_endAnchor(me->text, me->CurrentANum);
	me->CurrentANum = 0;
	me->inBoldA = FALSE;
	if (me->Underline_Level > 0 && me->inUnderline == FALSE) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    me->inUnderline = TRUE;
	}
	break;

    case HTML_MAP:
	FREE(me->map_address);
	break;

    case HTML_BODYTEXT:
	/*
	 * We may need to look at this someday to deal with OBJECTs optimally,
	 * but just ignore it for now.  - FM
	 */
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_TEXTFLOW:
	/*
	 * We may need to look at this someday to deal with APPLETs optimally,
	 * but just ignore it for now.  - FM
	 */
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_FIG:
	LYHandleFIG(me, NULL, NULL,
		    0,
		    0,
		    NULL,
		    NULL, NO, FALSE, &intern_flag);
	break;

    case HTML_OBJECT:
	/*
	 * Finish the data off.
	 */
	{
	    int s = 0, e = 0;
	    char *start = NULL, *first_end = NULL, *last_end = NULL;
	    char *first_map = NULL, *last_map = NULL;
	    BOOL have_param = FALSE;
	    char *data = NULL;

	    HTChunkTerminate(&me->object);
	    data = me->object.data;
	    while ((cp = strchr(data, '<')) != NULL) {
		/*
		 * Look for nested OBJECTs.  This procedure could get tripped
		 * up if invalid comments are present in the content, or if an
		 * OBJECT end tag is present in a quoted attribute.  - FM
		 */
		if (!strncmp(cp, "<!--", 4)) {
		    data = LYFindEndOfComment(cp);
		    cp = data;
		} else if (s == 0 && !strncasecomp(cp, "<PARAM", 6) &&
			   !IsNmChar(cp[6])) {
		    have_param = TRUE;
		} else if (!strncasecomp(cp, "<OBJECT", 7) &&
			   !IsNmChar(cp[7])) {
		    if (s == 0)
			start = cp;
		    s++;
		} else if (!strncasecomp(cp, "</OBJECT", 8) &&
			   !IsNmChar(cp[8])) {
		    if (e == 0)
			first_end = cp;
		    last_end = cp;
		    e++;
		} else if (!strncasecomp(cp, "<MAP", 4) &&
			   !IsNmChar(cp[4])) {
		    if (!first_map)
			first_map = cp;
		    last_map = cp;
		} else if (!strncasecomp(cp, "</MAP", 5) &&
			   !IsNmChar(cp[5])) {
		    last_map = cp;
		}
		data = ++cp;
	    }
	    if (s < e) {
		/*
		 * We had more end tags than start tags, so we have bad HTML or
		 * otherwise misparsed.  - FM
		 */
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content:\n%s\n",
			    me->object.data));
		goto End_Object;
	    }
	    if (s > e) {
		if (!me->object_declare && !me->object_name &&
		    !(me->object_shapes && !LYMapsOnly) &&
		    !(me->object_usemap != NULL && !LYMapsOnly) &&
		    !(clickable_images && !LYMapsOnly &&
		      me->object_data != NULL &&
		      !have_param &&
		      me->object_classid == NULL &&
		      me->object_codebase == NULL &&
		      me->object_codetype == NULL)) {
		    /*
		     * We have nested OBJECT tags, and not yet all of the end
		     * tags, but have a case where the content needs to be
		     * parsed again (not dropped) and where we don't want to
		     * output anything special at the point when we
		     * *do* have accumulated all the end tags.  So recycle
		     * the incomplete contents now, and signal the SGML parser
		     * that it should not regard the current OBJECT ended but
		     * should treat its contents as mixed.  Normally these
		     * cases would have already handled in the real
		     * start_element call, so this block may not be necessary. 
		     * - kw
		     */
		    CTRACE((tfp, "%s:\n%s\n",
			    "HTML: Nested OBJECT tags.  Recycling incomplete contents",
			    me->object.data));
		    status = HT_PARSER_OTHER_CONTENT;
		    me->object.size--;
		    HTChunkPuts(&me->object, "</OBJECT>");
		    if (!include)	/* error, should not happen */
			include = &me->xinclude;
		    StrnAllocCat(*include, me->object.data, me->object.size);
		    clear_objectdata(me);
		    /* an internal fake call to keep our stack happy: */
		    HTML_start_element(me, HTML_OBJECT, NULL, NULL,
				       me->tag_charset, include);
		    break;
		}
		/*
		 * We have nested OBJECT tags, and not yet all of the end tags,
		 * and we want the end tags.  So restore an end tag to the
		 * content, and signal to the SGML parser that it should resume
		 * the accumulation of OBJECT content (after calling back to
		 * start_element) in a way that is equivalent to passing it a
		 * dummy start tag.  - FM, kw
		 */
		CTRACE((tfp, "HTML: Nested OBJECT tags.  Recycling.\n"));
		status = HT_PARSER_REOPEN_ELT;
		me->object.size--;
		HTChunkPuts(&me->object, "</OBJECT>");
		if (!LYMapsOnly)
		    change_paragraph_style(me, me->sp->style);
		break;
	    }

	    /*
	     * OBJECT start and end tags are fully matched, assuming we weren't
	     * tripped up by comments or quoted attributes.  - FM
	     */
	    CTRACE((tfp, "HTML:OBJECT content:\n%s\n", me->object.data));

	    /*
	     * OBJECTs with DECLARE should be saved but not instantiated, and
	     * if nested, can have only other DECLAREd OBJECTs.  Until we have
	     * code to handle these, we'll just create an anchor for the ID, if
	     * present, and discard the content (sigh 8-).  - FM
	     */
	    if (me->object_declare == TRUE) {
		if (non_empty(me->object_id) && !LYMapsOnly)
		    LYHandleID(me, me->object_id);
		CTRACE((tfp, "HTML: DECLAREd OBJECT.  Ignoring!\n"));
		goto End_Object;
	    }

	    /*
	     * OBJECTs with NAME are for FORM submissions.  We'll just create
	     * an anchor for the ID, if present, and discard the content until
	     * we have code to handle these.  (sigh 8-).  - FM
	     */
	    if (me->object_name != NULL && !LYMapsOnly) {
		if (non_empty(me->object_id))
		    LYHandleID(me, me->object_id);
		CTRACE((tfp, "HTML: NAMEd OBJECT.  Ignoring!\n"));
		goto End_Object;
	    }

	    /*
	     * Deal with any nested OBJECTs by descending to the inner-most
	     * OBJECT.  - FM
	     */
	    if (s > 0) {
		if (start != NULL &&
		    first_end != NULL && first_end > start) {
		    /*
		     * Minumum requirements for the ad hoc parsing to have
		     * succeeded are met.  We'll hope that it did succeed.  -
		     * FM
		     */
		    if (LYMapsOnly) {
			/*
			 * Well we don't need to do this any more, nested
			 * objects should either not get here any more at all
			 * or can be handled fine by other code below.  Leave
			 * in place for now as a special case for LYMapsOnly. 
			 * - kw
			 */
			if (LYMapsOnly && (!last_map || last_map < first_end))
			    *first_end = '\0';
			else
			    e = 0;
			data = NULL;
			if (LYMapsOnly && (!first_map || first_map > start))
			    StrAllocCopy(data, start);
			else
			    StrAllocCopy(data, me->object.data);
			if (e > 0) {
			    for (i = e; i > 0; i--) {
				StrAllocCat(data, "</OBJECT>");
			    }
			}
			if (!include)	/* error, should not happen */
			    include = &me->xinclude;
			StrAllocCat(*include, data);
			CTRACE((tfp, "HTML: Recycling nested OBJECT%s.\n",
				(s > 1) ? "s" : ""));
			FREE(data);
			goto End_Object;
		    }
		} else {
		    if (LYBadHTML(me))
			CTRACE((tfp,
				"Bad HTML: Unmatched OBJECT start and end tags.  Discarding content.\n"));
		    goto End_Object;
		}
	    }

	    /*
	     * If its content has SHAPES, convert it to FIG.  - FM
	     *
	     * This is now handled in our start_element without using include
	     * if the SGML parser cooperates, so this block may be unnecessary. 
	     * - kw
	     */
	    if (me->object_shapes == TRUE && !LYMapsOnly) {
		CTRACE((tfp, "HTML: OBJECT has SHAPES.  Converting to FIG.\n"));
		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
		StrAllocCat(*include, "<FIG ISOBJECT IMAGEMAP");
		if (me->object_ismap == TRUE)
		    StrAllocCat(*include, " IMAGEMAP");
		if (me->object_id != NULL) {
		    StrAllocCat(*include, " ID=\"");
		    StrAllocCat(*include, me->object_id);
		    StrAllocCat(*include, "\"");
		}
		if (me->object_data != NULL &&
		    me->object_classid == NULL) {
		    StrAllocCat(*include, " SRC=\"");
		    StrAllocCat(*include, me->object_data);
		    StrAllocCat(*include, "\"");
		}
		StrAllocCat(*include, ">");
		me->object.size--;
		HTChunkPuts(&me->object, "</FIG>");
		HTChunkTerminate(&me->object);
		StrAllocCat(*include, me->object.data);
		goto End_Object;
	    }

	    /*
	     * If it has a USEMAP attribute and didn't have SHAPES, convert it
	     * to IMG.  - FM
	     */
	    if (me->object_usemap != NULL && !LYMapsOnly) {
		CTRACE((tfp, "HTML: OBJECT has USEMAP.  Converting to IMG.\n"));

		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
		StrAllocCat(*include, "<IMG ISOBJECT");
		if (me->object_id != NULL) {
		    /*
		     * Pass the ID.  - FM
		     */
		    StrAllocCat(*include, " ID=\"");
		    StrAllocCat(*include, me->object_id);
		    StrAllocCat(*include, "\"");
		}
		if (me->object_data != NULL &&
		    me->object_classid == NULL) {
		    /*
		     * We have DATA with no CLASSID, so let's hope it'
		     * equivalent to an SRC.  - FM
		     */
		    StrAllocCat(*include, " SRC=\"");
		    StrAllocCat(*include, me->object_data);
		    StrAllocCat(*include, "\"");
		}
		if (me->object_title != NULL) {
		    /*
		     * Use the TITLE for both the MAP and the IMGs ALT.  - FM
		     */
		    StrAllocCat(*include, " TITLE=\"");
		    StrAllocCat(*include, me->object_title);
		    StrAllocCat(*include, "\" ALT=\"");
		    StrAllocCat(*include, me->object_title);
		    StrAllocCat(*include, "\"");
		}
		/*
		 * Add the USEMAP, and an ISMAP if present.  - FM
		 */
		if (me->object_usemap != NULL) {
		    StrAllocCat(*include, " USEMAP=\"");
		    StrAllocCat(*include, me->object_usemap);
		    if (me->object_ismap == TRUE)
			StrAllocCat(*include, "\" ISMAP>");
		    else
			StrAllocCat(*include, "\">");
		} else {
		    StrAllocCat(*include, ">");
		}
		/*
		 * Add the content if it has <MAP, since that may be the MAP
		 * this usemap points to.  But if we have nested objects, try
		 * to eliminate portions that cannot contribute to the quest
		 * for MAP.  This is not perfect, we may get too much content;
		 * this seems preferable over losing too much.  - kw
		 */
		if (first_map) {
		    if (s == 0) {
			StrAllocCat(*include, me->object.data);
			CTRACE((tfp,
				"HTML: MAP found, recycling object contents.\n"));
			goto End_Object;
		    }
		    /* s > 0 and s == e */
		    data = NULL;
		    if (last_map < start) {
			*start = '\0';
			i = 0;
		    } else if (last_map < first_end) {
			*first_end = '\0';
			i = e;
		    } else if (last_map < last_end) {
			*last_end = '\0';
			i = 1;
		    } else {
			i = 0;
		    }
		    if (first_map > last_end) {
			/* fake empty object to keep stacks stack happy */
			StrAllocCopy(data, "<OBJECT><");
			StrAllocCat(data, last_end + 1);
			i = 0;
		    } else if (first_map > start) {
			StrAllocCopy(data, start);
		    } else {
			StrAllocCopy(data, me->object.data);
		    }
		    for (; i > 0; i--) {
			StrAllocCat(data, "</OBJECT>");
		    }
		    CTRACE((tfp, "%s:\n%s\n",
			    "HTML: MAP and nested OBJECT tags.  Recycling parts",
			    data));
		    StrAllocCat(*include, data);
		    FREE(data);
		}
		goto End_Object;
	    }

	    /*
	     * Add an ID link if needed.  - FM
	     */
	    if (non_empty(me->object_id) && !LYMapsOnly)
		LYHandleID(me, me->object_id);

	    /*
	     * Add the OBJECTs content if not empty.  - FM
	     */
	    if (me->object.size > 1) {
		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
		StrAllocCat(*include, me->object.data);
	    }

	    /*
	     * Create a link to the DATA, if desired, and we can rule out that
	     * it involves scripting code.  This a risky thing to do, but we
	     * can toggle clickable_images mode off if it really screws things
	     * up, and so we may as well give it a try.  - FM
	     */
	    if (clickable_images) {
		if (!LYMapsOnly &&
		    me->object_data != NULL &&
		    !have_param &&
		    me->object_classid == NULL &&
		    me->object_codebase == NULL &&
		    me->object_codetype == NULL) {
		    /*
		     * We have a DATA value and no need for scripting code, so
		     * close the current Anchor, if one is open, and add an
		     * Anchor for this source.  If we also have a TYPE value,
		     * check whether it's an image or not, and set the link
		     * name accordingly.  - FM
		     */
		    if (!include)	/* error, should not happen */
			include = &me->xinclude;
		    if (me->inA)
			StrAllocCat(*include, "</A>");
		    StrAllocCat(*include, " -<A HREF=\"");
		    StrAllocCat(*include, me->object_data);
		    StrAllocCat(*include, "\">");
		    if ((me->object_type != NULL) &&
			!strncasecomp(me->object_type, "image/", 6)) {
			StrAllocCat(*include, "(IMAGE)");
		    } else {
			StrAllocCat(*include, "(OBJECT)");
		    }
		    StrAllocCat(*include, "</A> ");
		}
	    }
	}

	/*
	 * Re-intialize all of the OBJECT elements.  - FM
	 */
      End_Object:
	clear_objectdata(me);

	if (!LYMapsOnly)
	    change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_APPLET:
	if (me->inAPPLETwithP) {
	    LYEnsureDoubleSpace(me);
	} else {
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	}
	LYResetParagraphAlignment(me);
	me->inAPPLETwithP = FALSE;
	me->inAPPLET = FALSE;
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_CAPTION:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	me->inCAPTION = FALSE;
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	me->inLABEL = FALSE;
	break;

    case HTML_CREDIT:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	me->inCREDIT = FALSE;
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	me->inLABEL = FALSE;
	break;

    case HTML_FORM:
	/*
	 * Check if we had a FORM start tag, and issue a message if not, but
	 * fall through to check for an open SELECT and ensure that the
	 * FORM-related globals in GridText.c are initialized.  - FM
	 */
	if (!me->inFORM) {
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Unmatched FORM end tag\n"));
	}
	EMIT_IFDEF_EXP_JUSTIFY_ELTS(form_in_htext = FALSE);

	/*
	 * Check if we still have a SELECT element open.  FORM may have been
	 * declared SGML_EMPTY in HTMLDTD.c, and in that case SGML_character()
	 * in SGML.c is not able to ensure correct nesting; or it may have
	 * failed to enforce valid nesting.  If a SELECT is open, issue a
	 * message, then call HTML_end_element() directly (with a check in that
	 * to bypass decrementing of the HTML parser's stack) to close the
	 * SELECT.  - kw
	 */
	if (me->inSELECT) {
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: Open SELECT at FORM end. Faking SELECT end tag. *****\n"));
	    if (me->sp->tag_number != HTML_SELECT) {
		SET_SKIP_STACK(HTML_SELECT);
	    }
	    HTML_end_element(me, HTML_SELECT, include);
	}

	/*
	 * Set to know that we are no longer in an form.
	 */
	me->inFORM = FALSE;

	HText_endForm(me->text);
	/*
	 * If we are in a list and are on the first line with no text following
	 * a bullet or number, don't force a newline.  This could happen if we
	 * were called from HTML_start_element() due to a missing FORM end tag. 
	 * - FM
	 */
	if (!(me->List_Nesting_Level >= 0 && !me->inP))
	    LYEnsureSingleSpace(me);
	break;

    case HTML_FIELDSET:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_LEGEND:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_LABEL:
	break;

    case HTML_BUTTON:
	break;

    case HTML_TEXTAREA:
	{
	    InputFieldData I;
	    int chars;
	    char *data;

	    /*
	     * Make sure we had a textarea start tag.
	     */
	    if (!me->inTEXTAREA) {
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Unmatched TEXTAREA end tag\n"));
		break;
	    }

	    /*
	     * Set to know that we are no longer in a textarea tag.
	     */
	    me->inTEXTAREA = FALSE;

	    /*
	     * Initialize.
	     */
	    I.align = NULL;
	    I.accept = NULL;
	    I.checked = NO;
	    I.iclass = NULL;
	    I.disabled = NO;
	    I.error = NULL;
	    I.height = NULL;
	    I.id = NULL;
	    I.lang = NULL;
	    I.max = NULL;
	    I.maxlength = NULL;
	    I.md = NULL;
	    I.min = NULL;
	    I.name = NULL;
	    I.size = 0;
	    I.src = NULL;
	    I.type = NULL;
	    I.value = NULL;
	    I.width = NULL;
	    I.value_cs = current_char_set;

	    UPDATE_STYLE;
	    /*
	     * Before any input field add a space if necessary.
	     */
	    HTML_put_character(me, ' ');
	    me->in_word = NO;
	    /*
	     * Add a return.
	     */
	    HText_appendCharacter(me->text, '\r');

	    /*
	     * Finish the data off.
	     */
	    HTChunkTerminate(&me->textarea);
	    FREE(temp);

	    I.type = "textarea";
	    I.size = me->textarea_cols;
	    I.name = me->textarea_name;
	    I.name_cs = me->textarea_name_cs;
	    I.accept_cs = me->textarea_accept_cs;
	    me->textarea_accept_cs = NULL;
	    I.disabled = me->textarea_disabled;
	    I.id = me->textarea_id;

	    /*
	     * Transform the TEXTAREA content as needed, then parse it into
	     * individual lines to be handled as a series series of INPUT
	     * fields (ugh!).  Any raw 8-bit or multibyte characters already
	     * have been handled in relation to the display character set in
	     * SGML_character().
	     *
	     * If TEXTAREA is handled as SGML_LITTERAL (the old way), we need
	     * to SGML-unescape any character references and NCRs here. 
	     * Otherwise this will already have happened in the SGML.c parsing. 
	     * - kw
	     */
	    me->UsePlainSpace = TRUE;

	    if (HTML_dtd.tags[element_number].contents == SGML_LITTERAL) {
		TRANSLATE_AND_UNESCAPE_ENTITIES6(&me->textarea.data,
						 me->UCLYhndl,
						 current_char_set,
						 NO,
						 me->UsePlainSpace, me->HiddenValue);
	    } else {
		/*
		 * This shouldn't have anything to do, normally, but just in
		 * case...  There shouldn't be lynx special character codes in
		 * the chunk ("DTD" flag Tgf_nolyspcl tells SGML.c not to
		 * generate them).  If there were, we could set the last
		 * parameter ('Back') below to YES, which would take them out
		 * of the data.  The data may however contain non break space,
		 * soft hyphen, or en space etc., in the me->UCLYhndl character
		 * encoding.  If that's a problem, perhaps for the (line or
		 * other) editor, setting 'Back' to YES should also help to
		 * always convert them to plain spaces (or drop them).  - kw
		 */
		TRANSLATE_HTML7(&me->textarea.data,
				me->UCLYhndl,
				current_char_set,
				NO,
				me->UsePlainSpace, me->HiddenValue,
				NO);
	    }
	    data = me->textarea.data;

	    /*
	     * Trim any trailing newlines and skip any lead newlines.  - FM
	     */
	    if (*data != '\0') {
		cp = (data + strlen(data)) - 1;
		while (cp >= data && *cp == '\n') {
		    *cp-- = '\0';
		}
		while (*data == '\n') {
		    data++;
		}
	    }
	    /*
	     * Load the first text line, or set up for all blank rows.  - FM
	     */
	    if ((cp = strchr(data, '\n')) != NULL) {
		*cp = '\0';
		StrAllocCopy(temp, data);
		*cp = '\n';
		data = (cp + 1);
	    } else {
		if (*data != '\0') {
		    StrAllocCopy(temp, data);
		} else {
		    FREE(temp);
		}
		data = "";
	    }
	    /*
	     * Display at least the requested number of text lines and/or blank
	     * rows.  - FM
	     */
	    for (i = 0; i < me->textarea_rows; i++) {
		int j;

		for (j = 0; temp && temp[j]; j++) {
		    if (temp[j] == '\r')
			temp[j] = (char) (temp[j + 1] ? ' ' : '\0');
		}
		I.value = temp;
		chars = HText_beginInput(me->text, me->inUnderline, &I);
		for (; chars > 0; chars--)
		    HTML_put_character(me, '_');
		HText_appendCharacter(me->text, '\r');
		if (*data != '\0') {
		    if (*data == '\n') {
			FREE(temp);
			data++;
		    } else if ((cp = strchr(data, '\n')) != NULL) {
			*cp = '\0';
			StrAllocCopy(temp, data);
			*cp = '\n';
			data = (cp + 1);
		    } else {
			StrAllocCopy(temp, data);
			data = "";
		    }
		} else {
		    FREE(temp);
		}
	    }
	    /*
	     * Check for more data lines than the rows attribute.  We add them
	     * to the display, because we support only horizontal and not also
	     * vertical scrolling.  - FM
	     */
	    while (*data != '\0' || temp != NULL) {
		int j;

		for (j = 0; temp && temp[j]; j++) {
		    if (temp[j] == '\r')
			temp[j] = (char) (temp[j + 1] ? ' ' : '\0');
		}
		I.value = temp;
		chars = HText_beginInput(me->text, me->inUnderline, &I);
		for (chars = me->textarea_cols; chars > 0; chars--)
		    HTML_put_character(me, '_');
		HText_appendCharacter(me->text, '\r');
		if (*data == '\n') {
		    FREE(temp);
		    data++;
		} else if ((cp = strchr(data, '\n')) != NULL) {
		    *cp = '\0';
		    StrAllocCopy(temp, data);
		    *cp = '\n';
		    data = (cp + 1);
		} else if (*data != '\0') {
		    StrAllocCopy(temp, data);
		    data = "";
		} else {
		    FREE(temp);
		}
	    }
	    FREE(temp);
	    cp = NULL;
	    me->UsePlainSpace = FALSE;

	    HTChunkClear(&me->textarea);
	    FREE(me->textarea_name);
	    me->textarea_name_cs = -1;
	    FREE(me->textarea_id);
	    break;
	}

    case HTML_SELECT:
	{
	    char *ptr;

	    /*
	     * Make sure we had a select start tag.
	     */
	    if (!me->inSELECT) {
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Unmatched SELECT end tag *****\n"));
		break;
	    }

	    /*
	     * Set to know that we are no longer in a select tag.
	     */
	    me->inSELECT = FALSE;

	    /*
	     * Clear the disable attribute.
	     */
	    me->select_disabled = FALSE;

	    /*
	     * Make sure we're in a form.
	     */
	    if (!me->inFORM) {
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: SELECT end tag not within FORM element *****\n"));
		/*
		 * Hopefully won't crash, so we'll ignore it.  - kw
		 */
	    }

	    /*
	     * Finish the data off.
	     */
	    HTChunkTerminate(&me->option);
	    /*
	     * Finish the previous option.
	     */
	    ptr = HText_setLastOptionValue(me->text,
					   me->option.data,
					   me->LastOptionValue,
					   LAST_ORDER,
					   me->LastOptionChecked,
					   me->UCLYhndl,
					   ATTR_CS_IN);
	    FREE(me->LastOptionValue);

	    me->LastOptionChecked = FALSE;

	    if (HTCurSelectGroupType == F_CHECKBOX_TYPE ||
		LYSelectPopups == FALSE) {
		/*
		 * Start a newline after the last checkbox/button option.
		 */
		LYEnsureSingleSpace(me);
	    } else {
		/*
		 * Output popup box with the default option to screen, but use
		 * non-breaking spaces for output.
		 */
		if (ptr &&
		    (me->sp[0].tag_number == HTML_PRE || me->inPRE == TRUE ||
		     !me->sp->style->freeFormat) &&
		    strlen(ptr) > 6) {
		    /*
		     * The code inadequately handles OPTION fields in PRE tags. 
		     * We'll put up a minimum of 6 characters, and if any more
		     * would exceed the wrap column, we'll ignore them.
		     */
		    for (i = 0; i < 6; i++) {
			if (*ptr == ' ')
			    HText_appendCharacter(me->text, HT_NON_BREAK_SPACE);
			else
			    HText_appendCharacter(me->text, *ptr);
			ptr++;
		    }
		    HText_setIgnoreExcess(me->text, TRUE);
		}
		for (; non_empty(ptr); ptr++) {
		    if (*ptr == ' ')
			HText_appendCharacter(me->text, HT_NON_BREAK_SPACE);
		    else {
			HTkcode kcode = NOKANJI;
			HTkcode specified_kcode = NOKANJI;

			if (HTCJK == JAPANESE) {
			    kcode = HText_getKcode(me->text);
			    HText_updateKcode(me->text, kanji_code);
			    specified_kcode = HText_getSpecifiedKcode(me->text);
			    HText_updateSpecifiedKcode(me->text, kanji_code);
			}
			HText_appendCharacter(me->text, *ptr);
			if (HTCJK == JAPANESE) {
			    HText_updateKcode(me->text, kcode);
			    HText_updateSpecifiedKcode(me->text, specified_kcode);
			}
		    }
		}
		/*
		 * Add end option character.
		 */
		if (!me->first_option) {
		    HText_appendCharacter(me->text, ']');
		    HText_endInput(me->text);
		    HText_setLastChar(me->text, ']');
		    me->in_word = YES;
		}
		HText_setIgnoreExcess(me->text, FALSE);
	    }
	    HTChunkClear(&me->option);

	    if (me->Underline_Level > 0 && me->inUnderline == FALSE) {
		HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
		me->inUnderline = TRUE;
	    }
	    if (me->needBoldH == TRUE && me->inBoldH == FALSE) {
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		me->inBoldH = TRUE;
		me->needBoldH = FALSE;
	    }
	}
	break;

    case HTML_TABLE:
#ifdef EXP_NESTED_TABLES
	if (!nested_tables)
#endif
	    me->inTABLE = FALSE;

	if (me->sp->style->id == ST_Preformatted) {
	    break;
	}
	if (me->Division_Level >= 0)
	    me->Division_Level--;
	if (me->Division_Level >= 0)
	    me->sp->style->alignment =
		me->DivisionAlignments[me->Division_Level];
	change_paragraph_style(me, me->sp->style);
	UPDATE_STYLE;

#ifdef EXP_NESTED_TABLES
	if (nested_tables) {
	    me->inTABLE = HText_endStblTABLE(me->text);
	} else {
	    HText_endStblTABLE(me->text);
	}
#else
	HText_endStblTABLE(me->text);
#endif

	me->current_default_alignment = me->sp->style->alignment;
	if (me->List_Nesting_Level >= 0)
	    HText_NegateLineOne(me->text);
	break;

/* These TABLE related elements may now not be SGML_EMPTY. - kw */
    case HTML_TR:
	HText_endStblTR(me->text);
	if (!HText_LastLineEmpty(me->text, FALSE)) {
	    HText_setLastChar(me->text, ' ');	/* absorb next white space */
	    HText_appendCharacter(me->text, '\r');
	}
	me->in_word = NO;
	break;

    case HTML_THEAD:
    case HTML_TFOOT:
    case HTML_TBODY:
	break;

    case HTML_COLGROUP:
	if (me->inTABLE)
	    HText_endStblCOLGROUP(me->text);
	break;

    case HTML_TH:
    case HTML_TD:
	HText_endStblTD(me->text);
	break;

/* More stuff that may now not be SGML_EMPTY any more: */
    case HTML_DT:
    case HTML_DD:
    case HTML_LH:
    case HTML_LI:
    case HTML_OVERLAY:
	break;

    case HTML_MATH:
	/*
	 * We're getting it as Literal text, which, until we can process it,
	 * we'll display as is, within brackets to alert the user.  - FM
	 */
	HTChunkPutc(&me->math, ' ');
	HTChunkTerminate(&me->math);
	if (me->math.size > 2) {
	    LYEnsureSingleSpace(me);
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    HTML_put_string(me, "[MATH:");
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    HTML_put_character(me, ' ');
	    HTML_put_string(me, me->math.data);
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    HTML_put_string(me, ":MATH]");
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    LYEnsureSingleSpace(me);
	}
	HTChunkClear(&me->math);
	break;

    default:
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    }				/* switch */

#ifdef EXP_JUSTIFY_ELTS
    if (reached_awaited_stacked_elt)
	wait_for_this_stacked_elt = -1;
#endif

    if (me->xinclude) {
	HText_appendText(me->text, " *** LYNX ERROR ***\rUnparsed data:\r");
	HText_appendText(me->text, me->xinclude);
	FREE(me->xinclude);
    }
#ifdef USE_COLOR_STYLE
    if (!skip_stack_requested) {	/*don't emit stylechanges if skipped stack element - VH */
# if !OMIT_SCN_KEEPING
	FastTrimColorClass(HTML_dtd.tags[element_number].name,
			   HTML_dtd.tags[element_number].name_len,
			   Style_className,
			   &Style_className_end, &hcode);
#  endif

	if (!ReallyEmptyTagNum(element_number)) {
	    CTRACE2(TRACE_STYLE,
		    (tfp,
		     "STYLE.end_element: ending non-\"EMPTY\" style <%s...>\n",
		     HTML_dtd.tags[element_number].name));
	    HText_characterStyle(me->text, HCODE_TO_STACK_OFF(hcode), STACK_OFF);
	}
    }
#endif /* USE_COLOR_STYLE */
    return status;
}

/*		Expanding entities
 *		------------------
 */
/*	(In fact, they all shrink!)
*/
int HTML_put_entity(HTStructured * me, int entity_number)
{
    int nent = HTML_dtd.number_of_entities;

    if (entity_number < nent) {
	HTML_put_string(me, p_entity_values[entity_number]);
	return HT_OK;
    }
    return HT_CANNOT_TRANSLATE;
}

/*	Free an HTML object
 *	-------------------
 *
 *	If the document is empty, the text object will not yet exist.
 *	So we could in fact abandon creating the document and return
 *	an error code.	In fact an empty document is an important type
 *	of document, so we don't.
 *
 *	If non-interactive, everything is freed off.   No: crashes -listrefs
 *	Otherwise, the interactive object is left.
 */
static void HTML_free(HTStructured * me)
{
    char *include = NULL;

    if (LYMapsOnly && !me->text) {
	/*
	 * We only handled MAP, AREA and BASE tags, and didn't create an HText
	 * structure for the document nor want one now, so just make sure we
	 * free anything that might have been allocated.  - FM
	 */
	FREE(me->base_href);
	FREE(me->map_address);
	clear_objectdata(me);
	FREE(me->xinclude);
	FREE(me);
	return;
    }

    UPDATE_STYLE;		/* Creates empty document here! */
    if (me->comment_end)
	HTML_put_string(me, me->comment_end);
    if (me->text) {
	/*
	 * Emphasis containers, A, FONT, and FORM may be declared SGML_EMPTY in
	 * HTMLDTD.c, and SGML_character() in SGML.c may check for their end
	 * tags to call HTML_end_element() directly (with a check in that to
	 * bypass decrementing of the HTML parser's stack).  So if we still
	 * have the emphasis (Underline) on, or any open A, FONT, or FORM
	 * containers, turn it off or close them now.  - FM & kw
	 *
	 * IF those tags are not declared SGML_EMPTY, but we let the SGML.c
	 * parser take care of correctly stacked ordering, and of correct
	 * wind-down on end-of-stream (in SGML_free SGML_abort), THEN these and
	 * other checks here in HTML.c should not be necessary.  Still it can't
	 * hurt to include them.  - kw
	 */
	if (me->inUnderline) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    me->inUnderline = FALSE;
	    me->Underline_Level = 0;
	    CTRACE((tfp, "HTML_free: Ending underline\n"));
	}
	if (me->inA) {
	    HTML_end_element(me, HTML_A, &include);
	    me->inA = FALSE;
	    CTRACE((tfp, "HTML_free: Ending HTML_A\n"));
	}
	if (me->inFONT) {
	    HTML_end_element(me, HTML_FONT, &include);
	    me->inFONT = FALSE;
	}
	if (me->inFORM) {
	    HTML_end_element(me, HTML_FORM, &include);
	    me->inFORM = FALSE;
	}
	if (me->option.size > 0) {
	    /*
	     * If we still have data in the me->option chunk after forcing a
	     * close of a still-open form, something must have gone very wrong. 
	     * - kw
	     */
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: SELECT or OPTION not ended properly *****\n"));
	    HTChunkTerminate(&me->option);
	    /*
	     * Output the left-over data as text, maybe it was invalid markup
	     * meant to be shown somewhere.  - kw
	     */
	    CTRACE((tfp, "HTML_free: ***** leftover option data: %s\n",
		    me->option.data));
	    HTML_put_string(me, me->option.data);
	    HTChunkClear(&me->option);
	}
	if (me->textarea.size > 0) {
	    /*
	     * If we still have data in the me->textarea chunk after forcing a
	     * close of a still-open form, something must have gone very wrong. 
	     * - kw
	     */
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: TEXTAREA not used properly *****\n"));
	    HTChunkTerminate(&me->textarea);
	    /*
	     * Output the left-over data as text, maybe it was invalid markup
	     * meant to be shown somewhere.  - kw
	     */
	    CTRACE((tfp, "HTML_free: ***** leftover textarea data: %s\n",
		    me->textarea.data));
	    HTML_put_string(me, me->textarea.data);
	    HTChunkClear(&me->textarea);
	}
	/*
	 * If we're interactive and have hidden links but no visible links, add
	 * a message informing the user about this and suggesting use of the
	 * 'l'ist command.  - FM
	 */
	if (!dump_output_immediately &&
	    HText_sourceAnchors(me->text) < 1 &&
	    HText_HiddenLinkCount(me->text) > 0) {
	    HTML_start_element(me, HTML_P, 0, 0, -1, &include);
	    HTML_put_character(me, '[');
	    HTML_start_element(me, HTML_EM, 0, 0, -1, &include);
	    HTML_put_string(me,
			    gettext("Document has only hidden links.  Use the 'l'ist command."));
	    HTML_end_element(me, HTML_EM, &include);
	    HTML_put_character(me, ']');
	    HTML_end_element(me, HTML_P, &include);
	}
	if (me->xinclude) {
	    HText_appendText(me->text, " *** LYNX ERROR ***\rUnparsed data:\r");
	    HText_appendText(me->text, me->xinclude);
	    FREE(me->xinclude);
	}

	/*
	 * Now call the cleanup function.  - FM
	 */
	HText_endAppend(me->text);
    }
    if (me->option.size > 0) {
	/*
	 * If we still have data in the me->option chunk after forcing a close
	 * of a still-open form, something must have gone very wrong.  - kw
	 */
	if (LYBadHTML(me))
	    CTRACE((tfp,
		    "Bad HTML: SELECT or OPTION not ended properly *****\n"));
	if (TRACE) {
	    HTChunkTerminate(&me->option);
	    CTRACE((tfp, "HTML_free: ***** leftover option data: %s\n",
		    me->option.data));
	}
	HTChunkClear(&me->option);
    }
    if (me->textarea.size > 0) {
	/*
	 * If we still have data in the me->textarea chunk after forcing a
	 * close of a still-open form, something must have gone very wrong.  -
	 * kw
	 */
	if (LYBadHTML(me))
	    CTRACE((tfp,
		    "Bad HTML: TEXTAREA not used properly *****\n"));
	if (TRACE) {
	    HTChunkTerminate(&me->textarea);
	    CTRACE((tfp, "HTML_free: ***** leftover textarea data: %s\n",
		    me->textarea.data));
	}
	HTChunkClear(&me->textarea);
    }

    if (me->target) {
	(*me->targetClass._free) (me->target);
    }
    if (me->sp && me->sp->style && me->sp->style->name) {
	if (me->sp->style->id == ST_DivCenter ||
	    me->sp->style->id == ST_HeadingCenter ||
	    me->sp->style->id == ST_Heading1) {
	    me->sp->style->alignment = HT_CENTER;
	} else if (me->sp->style->id == ST_DivRight ||
		   me->sp->style->id == ST_HeadingRight) {
	    me->sp->style->alignment = HT_RIGHT;
	} else {
	    me->sp->style->alignment = HT_LEFT;
	}
	styles[HTML_PRE]->alignment = HT_LEFT;
    }
    FREE(me->base_href);
    FREE(me->map_address);
    FREE(me->LastOptionValue);
    clear_objectdata(me);
    FREE(me);
}

static void HTML_abort(HTStructured * me, HTError e)
{
    char *include = NULL;

    if (me->text) {
	/*
	 * If we have emphasis on, or open A, FONT, or FORM containers, turn it
	 * off or close them now.  - FM
	 */
	if (me->inUnderline) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    me->inUnderline = FALSE;
	    me->Underline_Level = 0;
	}
	if (me->inA) {
	    HTML_end_element(me, HTML_A, &include);
	    me->inA = FALSE;
	}
	if (me->inFONT) {
	    HTML_end_element(me, HTML_FONT, &include);
	    me->inFONT = FALSE;
	}
	if (me->inFORM) {
	    HTML_end_element(me, HTML_FORM, &include);
	    me->inFORM = FALSE;
	}

	/*
	 * Now call the cleanup function.  - FM
	 */
	HText_endAppend(me->text);
    }

    if (me->option.size > 0) {
	/*
	 * If we still have data in the me->option chunk after forcing a close
	 * of a still-open form, something must have gone very wrong.  - kw
	 */
	if (TRACE) {
	    CTRACE((tfp,
		    "HTML_abort: SELECT or OPTION not ended properly *****\n"));
	    HTChunkTerminate(&me->option);
	    CTRACE((tfp, "HTML_abort: ***** leftover option data: %s\n",
		    me->option.data));
	}
	HTChunkClear(&me->option);
    }
    if (me->textarea.size > 0) {
	/*
	 * If we still have data in the me->textarea chunk after forcing a
	 * close of a still-open form, something must have gone very wrong.  -
	 * kw
	 */
	if (TRACE) {
	    CTRACE((tfp, "HTML_abort: TEXTAREA not used properly *****\n"));
	    HTChunkTerminate(&me->textarea);
	    CTRACE((tfp, "HTML_abort: ***** leftover textarea data: %s\n",
		    me->textarea.data));
	}
	HTChunkClear(&me->textarea);
    }

    if (me->target) {
	(*me->targetClass._abort) (me->target, e);
    }
    if (me->sp && me->sp->style && me->sp->style->name) {
	if (me->sp->style->id == ST_DivCenter ||
	    me->sp->style->id == ST_HeadingCenter ||
	    me->sp->style->id == ST_Heading1) {
	    me->sp->style->alignment = HT_CENTER;
	} else if (me->sp->style->id == ST_DivRight ||
		   me->sp->style->id == ST_HeadingRight) {
	    me->sp->style->alignment = HT_RIGHT;
	} else {
	    me->sp->style->alignment = HT_LEFT;
	}
	styles[HTML_PRE]->alignment = HT_LEFT;
    }
    FREE(me->base_href);
    FREE(me->map_address);
    FREE(me->textarea_name);
    FREE(me->textarea_accept_cs);
    FREE(me->textarea_id);
    FREE(me->LastOptionValue);
    FREE(me->xinclude);
    clear_objectdata(me);
    FREE(me);
}

/*	Get Styles from style sheet
 *	---------------------------
 */
static void get_styles(void)
{
    HTStyle **st = NULL;

    styleSheet = DefaultStyle(&st);	/* sets st[] array */

    default_style = st[ST_Normal];

    styles[HTML_H1] = st[ST_Heading1];
    styles[HTML_H2] = st[ST_Heading2];
    styles[HTML_H3] = st[ST_Heading3];
    styles[HTML_H4] = st[ST_Heading4];
    styles[HTML_H5] = st[ST_Heading5];
    styles[HTML_H6] = st[ST_Heading6];
    styles[HTML_HCENTER] = st[ST_HeadingCenter];
    styles[HTML_HLEFT] = st[ST_HeadingLeft];
    styles[HTML_HRIGHT] = st[ST_HeadingRight];

    styles[HTML_DCENTER] = st[ST_DivCenter];
    styles[HTML_DLEFT] = st[ST_DivLeft];
    styles[HTML_DRIGHT] = st[ST_DivRight];

    styles[HTML_DL] = st[ST_Glossary];
    /* nested list styles */
    styles[HTML_DL1] = st[ST_Glossary1];
    styles[HTML_DL2] = st[ST_Glossary2];
    styles[HTML_DL3] = st[ST_Glossary3];
    styles[HTML_DL4] = st[ST_Glossary4];
    styles[HTML_DL5] = st[ST_Glossary5];
    styles[HTML_DL6] = st[ST_Glossary6];

    styles[HTML_UL] =
	styles[HTML_OL] = st[ST_List];
    /* nested list styles */
    styles[HTML_OL1] = st[ST_List1];
    styles[HTML_OL2] = st[ST_List2];
    styles[HTML_OL3] = st[ST_List3];
    styles[HTML_OL4] = st[ST_List4];
    styles[HTML_OL5] = st[ST_List5];
    styles[HTML_OL6] = st[ST_List6];

    styles[HTML_MENU] =
	styles[HTML_DIR] = st[ST_Menu];
    /* nested list styles */
    styles[HTML_MENU1] = st[ST_Menu1];
    styles[HTML_MENU2] = st[ST_Menu2];
    styles[HTML_MENU3] = st[ST_Menu3];
    styles[HTML_MENU4] = st[ST_Menu4];
    styles[HTML_MENU5] = st[ST_Menu5];
    styles[HTML_MENU6] = st[ST_Menu6];

    styles[HTML_DLC] = st[ST_GlossaryCompact];
    /* nested list styles */
    styles[HTML_DLC1] = st[ST_GlossaryCompact1];
    styles[HTML_DLC2] = st[ST_GlossaryCompact2];
    styles[HTML_DLC3] = st[ST_GlossaryCompact3];
    styles[HTML_DLC4] = st[ST_GlossaryCompact4];
    styles[HTML_DLC5] = st[ST_GlossaryCompact5];
    styles[HTML_DLC6] = st[ST_GlossaryCompact6];

    styles[HTML_ADDRESS] = st[ST_Address];
    styles[HTML_BANNER] = st[ST_Banner];
    styles[HTML_BLOCKQUOTE] = st[ST_Blockquote];
    styles[HTML_BQ] = st[ST_Bq];
    styles[HTML_FN] = st[ST_Footnote];
    styles[HTML_NOTE] = st[ST_Note];
    styles[HTML_PLAINTEXT] =
	styles[HTML_XMP] = st[ST_Example];
    styles[HTML_PRE] = st[ST_Preformatted];
    styles[HTML_LISTING] = st[ST_Listing];
}

/*
 * If we're called from another module, make sure we've initialized styles
 * array first.
 */
HTStyle *LYstyles(int style_number)
{
    if (styles[style_number] == 0)
	get_styles();
    return styles[style_number];
}

/*				P U B L I C
*/

/*	Structured Object Class
 *	-----------------------
 */
const HTStructuredClass HTMLPresentation =	/* As opposed to print etc */
{
    "Lynx_HTML_Handler",
    HTML_free,
    HTML_abort,
    HTML_put_character, HTML_put_string, HTML_write,
    HTML_start_element, HTML_end_element,
    HTML_put_entity
};

/*		New Structured Text object
 *		--------------------------
 *
 *	The structured stream can generate either presentation,
 *	or plain text, or HTML.
 */
HTStructured *HTML_new(HTParentAnchor *anchor,
		       HTFormat format_out,
		       HTStream *stream)
{

    HTStructured *me;

    if (format_out != WWW_PLAINTEXT && format_out != WWW_PRESENT) {
	HTStream *intermediate = HTStreamStack(WWW_HTML, format_out,
					       stream, anchor);

	if (intermediate)
	    return HTMLGenerator(intermediate);
	fprintf(stderr, "\n** Internal error: can't parse HTML to %s\n",
		HTAtom_name(format_out));
	exit_immediately(EXIT_FAILURE);
    }

    me = typecalloc(HTStructured);
    if (me == NULL)
	outofmem(__FILE__, "HTML_new");

    /*
     * This used to call 'get_styles()' only on the first time through this
     * function.  However, if the user reloads a page with ^R, the styles[]
     * array is not necessarily the same as it was from 'get_styles()'.  So
     * we reinitialize the whole thing.
     */
    get_styles();

    me->isa = &HTMLPresentation;
    me->node_anchor = anchor;

    me->CurrentA = NULL;
    me->CurrentANum = 0;
    me->base_href = NULL;
    me->map_address = NULL;

    HTChunkInit(&me->title, 128);

    HTChunkInit(&me->object, 128);
    me->object_started = FALSE;
    me->object_declare = FALSE;
    me->object_shapes = FALSE;
    me->object_ismap = FALSE;
    me->object_id = NULL;
    me->object_title = NULL;
    me->object_data = NULL;
    me->object_type = NULL;
    me->object_classid = NULL;
    me->object_codebase = NULL;
    me->object_codetype = NULL;
    me->object_usemap = NULL;
    me->object_name = NULL;

    HTChunkInit(&me->option, 128);
    me->first_option = TRUE;
    me->LastOptionValue = NULL;
    me->LastOptionChecked = FALSE;
    me->select_disabled = FALSE;

    HTChunkInit(&me->textarea, 128);
    me->textarea_name = NULL;
    me->textarea_name_cs = -1;
    me->textarea_accept_cs = NULL;
    me->textarea_cols = 0;
    me->textarea_rows = 4;
    me->textarea_disabled = NO;
    me->textarea_id = NULL;

    HTChunkInit(&me->math, 128);

    HTChunkInit(&me->style_block, 128);

    HTChunkInit(&me->script, 128);

    me->text = 0;
    me->style_change = YES;	/* Force check leading to text creation */
    me->new_style = default_style;
    me->old_style = 0;
    me->current_default_alignment = HT_LEFT;
    me->sp = (me->stack + MAX_NESTING - 1);
    me->skip_stack = 0;
    me->sp->tag_number = -1;	/* INVALID */
    me->sp->style = default_style;	/* INVALID */
    me->sp->style->alignment = HT_LEFT;
    me->stack_overrun = FALSE;

    me->Division_Level = -1;
    me->Underline_Level = 0;
    me->Quote_Level = 0;

    me->UsePlainSpace = FALSE;
    me->HiddenValue = FALSE;
    me->lastraw = -1;

    /*
     * Used for nested lists.  - FM
     */
    me->List_Nesting_Level = -1;	/* counter for list nesting level */
    LYZero_OL_Counter(me);	/* Initializes OL_Counter[] and OL_Type[] */
    me->Last_OL_Count = 0;	/* last count in ordered lists */
    me->Last_OL_Type = '1';	/* last type in ordered lists */

    me->inA = FALSE;
    me->inAPPLET = FALSE;
    me->inAPPLETwithP = FALSE;
    me->inBadBASE = FALSE;
    me->inBadHREF = FALSE;
    me->inBadHTML = FALSE;
    me->inBASE = FALSE;
    me->node_anchor->inBASE = FALSE;
    me->inBoldA = FALSE;
    me->inBoldH = FALSE;
    me->inCAPTION = FALSE;
    me->inCREDIT = FALSE;
    me->inFIG = FALSE;
    me->inFIGwithP = FALSE;
    me->inFONT = FALSE;
    me->inFORM = FALSE;
    me->inLABEL = FALSE;
    me->inP = FALSE;
    me->inPRE = FALSE;
    me->inSELECT = FALSE;
    me->inTABLE = FALSE;
    me->inUnderline = FALSE;

    me->needBoldH = FALSE;

    me->comment_start = NULL;
    me->comment_end = NULL;

#ifdef USE_COLOR_STYLE
#ifdef LY_FIND_LEAKS
    if (Style_className == 0) {
	atexit(free_Style_className);
    }
#endif
    addClassName("", "", 0);
    class_string[0] = '\0';
#endif

    /*
     * Create a chartrans stage info structure for the anchor, if it does not
     * exist already (in which case the default MIME stage info will be loaded
     * as well), and load the HTML stage info into me->UCI and me->UCLYhndl.  -
     * FM
     */
    LYGetChartransInfo(me);
    UCTransParams_clear(&me->T);

    /*
     * Load the existing or default input charset info into the holding
     * elements.  We'll believe what is indicated for UCT_STAGE_PARSER.  - FM
     */
    me->inUCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor,
					  UCT_STAGE_PARSER);
    if (me->inUCLYhndl < 0) {
	me->inUCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor,
					      UCT_STAGE_MIME);
	me->inUCI = HTAnchor_getUCInfoStage(me->node_anchor,
					    UCT_STAGE_MIME);
    } else {
	me->inUCI = HTAnchor_getUCInfoStage(me->node_anchor,
					    UCT_STAGE_PARSER);
    }

    /*
     * Load the existing or default output charset info into the holding
     * elements, UCT_STAGE_STRUCTURED should be the same as UCT_STAGE_TEXT at
     * this point, but we could check, perhaps.  - FM
     */
    me->outUCI = HTAnchor_getUCInfoStage(me->node_anchor,
					 UCT_STAGE_STRUCTURED);
    me->outUCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor,
					   UCT_STAGE_STRUCTURED);

    me->target = stream;
    if (stream)
	me->targetClass = *stream->isa;		/* Copy pointers */

    return (HTStructured *) me;
}

#ifdef USE_SOURCE_CACHE

/*
 * A flag set by a file write error.  Used for only generating an alert the
 * first time such an error happens, since Lynx should still be usable if the
 * temp space becomes full, and an alert each time a cache file cannot be
 * written would be annoying.  Reset when lynx.cfg is being reloaded (user may
 * change SOURCE_CACHE setting).  - kw
 */
BOOLEAN source_cache_file_error = FALSE;

/*
 * Pass-thru cache HTStream
 */

static void CacheThru_do_free(HTStream *me)
{
    if (me->anchor->source_cache_file) {
	CTRACE((tfp, "SourceCacheWriter: Removing previous file %s\n",
		me->anchor->source_cache_file));
	LYRemoveTemp(me->anchor->source_cache_file);
	FREE(me->anchor->source_cache_file);
    }
    if (me->anchor->source_cache_chunk) {
	CTRACE((tfp, "SourceCacheWriter: Removing previous memory chunk %p\n",
		(void *) me->anchor->source_cache_chunk));
	HTChunkFree(me->anchor->source_cache_chunk);
	me->anchor->source_cache_chunk = NULL;
    }
    if (me->fp) {
	fflush(me->fp);
	if (ferror(me->fp))
	    me->status = HT_ERROR;
	LYCloseTempFP(me->fp);
	if (me->status == HT_OK) {
	    char *cp_freeme = 0;

	    me->anchor->source_cache_file = me->filename;
	    CTRACE((tfp,
		    "SourceCacheWriter: Committing file %s for URL %s to anchor\n",
		    me->filename,
		    cp_freeme = HTAnchor_address((HTAnchor *) me->anchor)));
	    FREE(cp_freeme);
	} else {
	    if (source_cache_file_error == FALSE) {
		HTAlert(gettext("Source cache error - disk full?"));
		source_cache_file_error = TRUE;
	    }
	    LYRemoveTemp(me->filename);
	    me->anchor->source_cache_file = NULL;
	}
    } else if (me->status != HT_OK) {
	if (me->chunk) {
	    CTRACE((tfp, "SourceCacheWriter: memory chunk %p had errors.\n",
		    me->chunk));
	    HTChunkFree(me->chunk);
	    me->chunk = NULL;
	}
	HTAlert(gettext("Source cache error - not enough memory!"));
    }
    if (me->chunk) {
	char *cp_freeme = NULL;

	me->anchor->source_cache_chunk = me->chunk;
	CTRACE((tfp,
		"SourceCacheWriter: Committing memory chunk %p for URL %s to anchor\n",
		(void *) me->chunk,
		cp_freeme = HTAnchor_address((HTAnchor *) me->anchor)));
	FREE(cp_freeme);
    }
}

static void CacheThru_free(HTStream *me)
{
    CacheThru_do_free(me);
    (*me->actions->_free) (me->target);
    FREE(me);
}

static void CacheThru_abort(HTStream *me, HTError e)
{
    if (me->fp)
	LYCloseTempFP(me->fp);
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((tfp, "SourceCacheWriter: Removing active file %s\n",
		    me->filename));
	    LYRemoveTemp(me->filename);
	    FREE(me->filename);
	}
	if (me->chunk) {
	    CTRACE((tfp,
		    "SourceCacheWriter: Removing active memory chunk %p\n",
		    (void *) me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	/*fake it */
	CacheThru_do_free(me);
    }
    (*me->actions->_abort) (me->target, e);
    FREE(me);
}

static void CacheThru_put_character(HTStream *me, char c_in)
{
    if (me->status == HT_OK) {
	if (me->fp) {
	    fputc(c_in, me->fp);
	} else if (me->chunk) {
	    HTChunkPutc(me->chunk, c_in);
	    if (me->chunk->allocated == 0)
		me->status = HT_ERROR;
	}
    }
    (*me->actions->put_character) (me->target, c_in);
}

static void CacheThru_put_string(HTStream *me, const char *str)
{
    if (me->status == HT_OK) {
	if (me->fp) {
	    fputs(str, me->fp);
	} else if (me->chunk) {
	    HTChunkPuts(me->chunk, str);
	    if (me->chunk->allocated == 0 && *str)
		me->status = HT_ERROR;
	}
    }
    (*me->actions->put_string) (me->target, str);
}

static void CacheThru_write(HTStream *me, const char *str,
			    int l)
{
    if (me->status == HT_OK) {
	if (me->fp) {
	    fwrite(str, 1, l, me->fp);
	    if (ferror(me->fp))
		me->status = HT_ERROR;
	} else if (me->chunk) {
	    HTChunkPutb(me->chunk, str, l);
	    if (me->chunk->allocated == 0 && l != 0)
		me->status = HT_ERROR;
	}
    }
    (*me->actions->put_block) (me->target, str, l);
}

static const HTStreamClass PassThruCache =
{
    "PassThruCache",
    CacheThru_free,
    CacheThru_abort,
    CacheThru_put_character,
    CacheThru_put_string,
    CacheThru_write
};

static HTStream *CacheThru_new(HTParentAnchor *anchor,
			       HTStream *target)
{
    char *cp_freeme = NULL;
    char filename[LY_MAXPATH];
    HTStream *stream = NULL;
    HTProtocol *p = (HTProtocol *) anchor->protocol;

    /*
     * Neatly and transparently vanish if source caching is disabled.
     */
    if (LYCacheSource == SOURCE_CACHE_NONE)
	return target;

#ifndef DEBUG_SOURCE_CACHE
    /*  Only remote HTML documents may benefit from HTreparse_document(),  */
    /*  oh, assume http protocol:                                          */
    if (strcmp(p->name, "http") != 0
	&& strcmp(p->name, "https") != 0) {
	CTRACE((tfp, "SourceCacheWriter: Protocol is \"%s\"; not caching\n", p->name));
	return target;
    }
#else
    /* all HTStreams will be cached */
#endif

    stream = (HTStream *) malloc(sizeof(*stream));
    if (!stream)
	outofmem(__FILE__, "CacheThru_new");

    stream->isa = &PassThruCache;
    stream->anchor = anchor;
    stream->fp = NULL;
    stream->filename = NULL;
    stream->chunk = NULL;
    stream->target = target;
    stream->actions = target->isa;
    stream->status = HT_OK;

    if (LYCacheSource == SOURCE_CACHE_FILE) {

	if (anchor->source_cache_file) {
	    CTRACE((tfp,
		    "SourceCacheWriter: If successful, will replace source cache file %s\n",
		    anchor->source_cache_file));
	}

	/*
	 * We open the temp file in binary mode to make sure that
	 * end-of-line stuff and high-bit Latin-1 (or other) characters
	 * don't get munged; this way, the file should (knock on wood)
	 * contain exactly what came in from the network.
	 */
	if (!(stream->fp = LYOpenTemp(filename, HTML_SUFFIX, BIN_W))) {
	    CTRACE((tfp,
		    "SourceCacheWriter: Cannot open source cache file for URL %s\n",
		    cp_freeme = HTAnchor_address((HTAnchor *) anchor)));
	    FREE(stream);
	    FREE(cp_freeme);
	    return target;
	}

	StrAllocCopy(stream->filename, filename);

	CTRACE((tfp,
		"SourceCacheWriter: Caching source for URL %s in file %s\n",
		cp_freeme = HTAnchor_address((HTAnchor *) anchor),
		filename));
	FREE(cp_freeme);
    }

    if (LYCacheSource == SOURCE_CACHE_MEMORY) {
	if (anchor->source_cache_chunk) {
	    CTRACE((tfp,
		    "SourceCacheWriter: If successful, will replace memory chunk %p\n",
		    (void *) anchor->source_cache_chunk));
	}
#ifdef SAVE_TIME_NOT_SPACE
	stream->chunk = HTChunkCreateMayFail(4096, 1);
#else
	stream->chunk = HTChunkCreateMayFail(128, 1);
#endif
	if (!stream->chunk)	/* failed already? pretty bad... - kw */
	    stream->status = HT_ERROR;

	CTRACE((tfp,
		"SourceCacheWriter: Caching source for URL %s in memory chunk %p\n",
		cp_freeme = HTAnchor_address((HTAnchor *) anchor),
		(void *) stream->chunk));
	FREE(cp_freeme);
    }

    return stream;
}
#else
#define CacheThru_new(anchor, target) target
#endif

/*	HTConverter for HTML to plain text
 *	----------------------------------
 *
 *	This will convert from HTML to presentation or plain text.
 *
 *	It is registered in HTInit.c, but never actually used by lynx.
 *	- kw 1999-03-15
 */
HTStream *HTMLToPlain(HTPresentation *pres,
		      HTParentAnchor *anchor,
		      HTStream *sink)
{
    CTRACE((tfp, "HTMLToPlain calling CacheThru_new\n"));
    return CacheThru_new(anchor,
			 SGML_new(&HTML_dtd, anchor,
				  HTML_new(anchor, pres->rep_out, sink)));
}

/*	HTConverter for HTML source to plain text
 *	-----------------------------------------
 *
 *	This will preparse HTML and convert back to presentation or plain text.
 *
 *	It is registered in HTInit.c and used by lynx if invoked with
 *	-preparsed.  The stream generated here will be fed with HTML text,
 *	It feeds that to the SGML.c parser, which in turn feeds an HTMLGen.c
 *	structured stream for regenerating flat text; the latter should
 *	end up being handled as text/plain. - kw
 */
HTStream *HTMLParsedPresent(HTPresentation *pres,
			    HTParentAnchor *anchor,
			    HTStream *sink)
{
    HTStream *intermediate = sink;

    if (!intermediate) {
	/*
	 * Trick to prevent HTPlainPresent from translating again.  Temporarily
	 * change UCT_STAGE_PARSER setting in anchor while the HTPlain stream
	 * is initialized, so that HTPlain sees its input and output charsets
	 * as the same.  - kw
	 */
	int old_parser_cset = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_PARSER);
	int structured_cset = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_STRUCTURED);

	if (structured_cset < 0)
	    structured_cset = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_HTEXT);
	if (structured_cset < 0)
	    structured_cset = current_char_set;
	HTAnchor_setUCInfoStage(anchor, structured_cset,
				UCT_STAGE_PARSER, UCT_SETBY_MIME);
	if (pres->rep_out == WWW_SOURCE) {
	    /*  same effect as
	       intermediate = HTPlainPresent(pres, anchor, NULL);
	       just written in a more general way:
	     */
	    intermediate = HTStreamStack(WWW_PLAINTEXT, WWW_PRESENT,
					 NULL, anchor);
	} else {
	    /*  this too should amount to calling HTPlainPresent: */
	    intermediate = HTStreamStack(WWW_PLAINTEXT, pres->rep_out,
					 NULL, anchor);
	}
	if (old_parser_cset != structured_cset) {
	    HTAnchor_resetUCInfoStage(anchor, old_parser_cset,
				      UCT_STAGE_PARSER, UCT_SETBY_NONE);
	    if (old_parser_cset >= 0) {
		HTAnchor_setUCInfoStage(anchor, old_parser_cset,
					UCT_STAGE_PARSER,
					UCT_SETBY_DEFAULT + 1);
	    }
	}
    }
    if (!intermediate)
	return NULL;
    CTRACE((tfp, "HTMLParsedPresent calling CacheThru_new\n"));
    return CacheThru_new(anchor,
			 SGML_new(&HTML_dtd, anchor,
				  HTMLGenerator(intermediate)));
}

/*	HTConverter for HTML to C code
 *	------------------------------
 *
 *	C code is like plain text but all non-preformatted code
 *	is commented out.
 *	This will convert from HTML to presentation or plain text.
 *
 *	It is registered in HTInit.c, but normally not used by lynx.
 *	- kw 1999-03-15
 */
HTStream *HTMLToC(HTPresentation *pres GCC_UNUSED,
		  HTParentAnchor *anchor,
		  HTStream *sink)
{
    HTStructured *html;

    if (sink)
	(*sink->isa->put_string) (sink, "/* ");		/* Before even title */
    html = HTML_new(anchor, WWW_PLAINTEXT, sink);
    html->comment_start = "/* ";
    html->comment_end = " */\n";	/* Must start in col 1 for cpp */
    if (!sink)
	HTML_put_string(html, html->comment_start);
    CTRACE((tfp, "HTMLToC calling CacheThru_new\n"));
    return CacheThru_new(anchor,
			 SGML_new(&HTML_dtd, anchor, html));
}

/*	Presenter for HTML
 *	------------------
 *
 *	This will convert from HTML to presentation or plain text.
 *
 * (Comment from original libwww:)
 *	Override this if you have a windows version
 */
#ifndef GUI
HTStream *HTMLPresent(HTPresentation *pres GCC_UNUSED,
		      HTParentAnchor *anchor,
		      HTStream *sink GCC_UNUSED)
{
    CTRACE((tfp, "HTMLPresent calling CacheThru_new\n"));
    return CacheThru_new(anchor,
			 SGML_new(&HTML_dtd, anchor,
				  HTML_new(anchor, WWW_PRESENT, NULL)));
}
#endif /* !GUI */

/* (Comments from original libwww:) */
/*	Record error message as a hypertext object
 *	------------------------------------------
 *
 *	The error message should be marked as an error so that
 *	it can be reloaded later.
 *	This implementation just throws up an error message
 *	and leaves the document unloaded.
 *	A smarter implementation would load an error document,
 *	marking at such so that it is retried on reload.
 *
 * On entry,
 *	sink	is a stream to the output device if any
 *	number	is the HTTP error number
 *	message is the human readable message.
 *
 * On exit,
 *	returns a negative number to indicate lack of success in the load.
 */
/* (We don't actually do any of that hypertext stuff for errors,
   the trivial implementation for lynx just generates a message
   and returns. - kw 1999-03-15)
*/
int HTLoadError(HTStream *sink GCC_UNUSED, int number,
		const char *message)
{
    HTAlert(message);		/* @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ */
    return -number;
}

static char *MakeNewTitle(const char **value, int src_type)
{
    char *ptr;
    char *newtitle = NULL;

    StrAllocCopy(newtitle, "[");
    if (value != 0 && value[src_type] != 0)
	ptr = strrchr(value[src_type], '/');
    else
	ptr = 0;
    if (!ptr) {
	StrAllocCat(newtitle, value[src_type]);
    } else {
	StrAllocCat(newtitle, ptr + 1);
    }
#ifdef SH_EX			/* 1998/04/02 (Thu) 16:02:00 */

    /* for proxy server 1998/12/19 (Sat) 11:53:30 */
    if (AS_casecomp(newtitle + 1, "internal-gopher-menu") == 0) {
	StrAllocCopy(newtitle, "+");
    } else if (AS_casecomp(newtitle + 1, "internal-gopher-unknown") == 0) {
	StrAllocCopy(newtitle, " ");
    } else {
	/* normal title */
	ptr = strrchr(newtitle, '.');
	if (ptr) {
	    if (AS_casecomp(ptr, ".gif") == 0)
		*ptr = '\0';
	    else if (AS_casecomp(ptr, ".jpg") == 0)
		*ptr = '\0';
	    else if (AS_casecomp(ptr, ".jpeg") == 0)
		*ptr = '\0';
	}
	StrAllocCat(newtitle, "]");
    }
#else
    StrAllocCat(newtitle, "]");
#endif
    return newtitle;
}

static char *MakeNewImageValue(const char **value)
{
    char *ptr;
    char *newtitle = NULL;

    StrAllocCopy(newtitle, "[");
    ptr = strrchr(value[HTML_INPUT_SRC], '/');
    if (!ptr) {
	StrAllocCat(newtitle, value[HTML_INPUT_SRC]);
    } else {
	StrAllocCat(newtitle, ptr + 1);
    }
    StrAllocCat(newtitle, "]-Submit");
    return newtitle;
}

static char *MakeNewMapValue(const char **value, const char *mapstr)
{
    char *ptr;
    char *newtitle = NULL;

    StrAllocCopy(newtitle, "[");
    StrAllocCat(newtitle, mapstr);	/* ISMAP or USEMAP */
    if (verbose_img && non_empty(value[HTML_IMG_SRC])) {
	StrAllocCat(newtitle, ":");
	ptr = strrchr(value[HTML_IMG_SRC], '/');
	if (!ptr) {
	    StrAllocCat(newtitle, value[HTML_IMG_SRC]);
	} else {
	    StrAllocCat(newtitle, ptr + 1);
	}
    }
    StrAllocCat(newtitle, "]");
    return newtitle;
}
@


1.10
log
@automatic merge
@
text
@d122 1
a122 1
char *LYToolbarName = "LynxPseudoToolbar";
d701 1
a701 1
	    Style_className = malloc(Style_className_len);
d703 1
a703 1
	    Style_className = realloc(Style_className, Style_className_len);
d923 1
a923 1
    HTMLElement ElementNumber = element_number;
d1845 1
a1845 1
		ElementNumber = me->sp[0].tag_number;
d3152 1
a3152 2
		StrAllocCopy(alt_string, (title ?
					  title : ""));
d3752 1
a3752 1
		    ElementNumber = HTML_OBJECT_M;
d4289 1
a4289 1
	    I.class = NULL;
a4374 2
		int len;

d4384 1
a4384 6
		convert_to_spaces(I.value, FALSE);
		while (I.value && I.value[0] == ' ')
		    I.value++;
		len = strlen(I.value) - 1;
		while (len > 0 && I.value[len] == ' ')
		    I.value[len--] = '\0';
d4392 1
a4392 1
		I.class = value[HTML_BUTTON_CLASS];
d4470 2
a4471 2
	    HTkcode kcode = 0;
	    HTkcode specified_kcode = 0;
d4477 1
a4477 1
	    I.class = NULL;
d4521 1
a4521 1
		char *not_impl = NULL;
a4701 1
		int len;
d4745 1
a4745 6
		    convert_to_spaces(I.value, FALSE);
		    while (I.value && I.value[0] == ' ')
			I.value++;
		    len = strlen(I.value) - 1;
		    while (len > 0 && I.value[len] == ' ')
			I.value[len--] = '\0';
d4794 1
a4794 1
		I.class = value[HTML_INPUT_CLASS];
d5152 1
a5152 1
		I.class = NULL;
d6798 1
a6798 1
	    I.class = NULL;
d7074 2
a7075 2
			HTkcode kcode = 0;
			HTkcode specified_kcode = 0;
d7860 2
d7865 3
a7867 1
		    me->filename, HTAnchor_address((HTAnchor *) me->anchor)));
d7886 2
d7891 3
a7893 1
		(void *) me->chunk, HTAnchor_address((HTAnchor *) me->anchor)));
d7987 1
d8024 1
d8040 1
a8040 1
		    HTAnchor_address((HTAnchor *) anchor)));
d8042 1
d8050 3
a8052 1
		HTAnchor_address((HTAnchor *) anchor), filename));
d8071 3
a8073 2
		HTAnchor_address((HTAnchor *) anchor), (void *) stream->chunk));

@


1.9
log
@automatic merge; regen configure
@
text
@d83 13
d780 1
a780 1
    if (title && *title) {
d817 1
a817 1
	if (id && *id) {
d826 1
a826 1
	if (clickable_images && src && *src) {
d1150 1
a1150 1
	    value[HTML_BASE_HREF] && *value[HTML_BASE_HREF]) {
d1444 1
a1444 1
		value[HTML_LINK_TITLE] && *value[HTML_LINK_TITLE] != '\0') {
d1452 1
a1452 1
	    if (!(title && *title)) {
d1489 1
a1489 1
		    value[HTML_LINK_CHARSET] && *value[HTML_LINK_CHARSET] != '\0') {
d1522 1
a1522 1
		value && *value[HTML_LINK_CLASS] != '\0') {
d1580 1
a1580 1
	    value[HTML_ISINDEX_PROMPT] && *value[HTML_ISINDEX_PROMPT]) {
d1627 1
a1627 1
	    value[HTML_FRAME_NAME] && *value[HTML_FRAME_NAME]) {
d1634 1
a1634 1
	    value[HTML_FRAME_SRC] && *value[HTML_FRAME_SRC]) {
d1680 1
a1680 1
	    value[HTML_IFRAME_NAME] && *value[HTML_IFRAME_NAME]) {
d1687 1
a1687 1
	    value[HTML_IFRAME_SRC] && *value[HTML_IFRAME_SRC]) {
d1786 1
a1786 1
		   value[HTML_DIV_ALIGN] && *value[HTML_DIV_ALIGN]) {
d1868 1
a1868 1
	    value[HTML_H_ALIGN] && *value[HTML_H_ALIGN]) {
d2077 1
a2077 1
		    value[HTML_TAB_TO] && *value[HTML_TAB_TO]) ||
d2094 1
a2094 1
	    } else if (!(temp && *temp) && present[HTML_TAB_INDENT] &&
d2129 1
a2129 1
	    value[HTML_TAB_ID] && *value[HTML_TAB_ID]) {
d2443 1
a2443 1
		value[HTML_OL_SEQNUM] && *value[HTML_OL_SEQNUM]) {
d2446 1
a2446 1
		       value[HTML_OL_START] && *value[HTML_OL_START]) {
d2832 1
a2832 1
	    value[HTML_A_ID] && *value[HTML_A_ID]) {
d2835 1
a2835 1
		   value[HTML_A_NAME] && *value[HTML_A_NAME]) {
d2908 1
a2908 1
		value[HTML_A_TITLE] && *value[HTML_A_TITLE] != '\0') {
d2920 1
a2920 1
		value[HTML_A_CHARSET] && *value[HTML_A_CHARSET] != '\0') {
d3013 1
a3013 1
	    value[HTML_IMG_USEMAP] && *value[HTML_IMG_USEMAP]) {
d3066 1
a3066 1
	    value[HTML_IMG_TITLE] && *value[HTML_IMG_TITLE]) {
d3169 1
a3169 1
	    value[HTML_IMG_ID] && *value[HTML_IMG_ID]) {
d3182 1
a3182 1
	    value[HTML_IMG_SRC] && *value[HTML_IMG_SRC]) {
d3443 1
a3443 1
	    value[HTML_MAP_NAME] && *value[HTML_MAP_NAME]) {
d3446 1
a3446 1
		   value[HTML_MAP_ID] && *value[HTML_MAP_ID]) {
d3483 1
a3483 1
		value[HTML_MAP_TITLE] && *value[HTML_MAP_TITLE] != '\0') {
d3500 1
a3500 1
	    value[HTML_AREA_HREF] && *value[HTML_AREA_HREF]) {
d3523 1
a3523 1
		value[HTML_AREA_ALT] && *value[HTML_AREA_ALT]) {
d3526 1
a3526 1
		       value[HTML_AREA_TITLE] && *value[HTML_AREA_TITLE]) {
d3611 1
a3611 1
		    value[HTML_OBJECT_USEMAP] && *value[HTML_OBJECT_USEMAP]) {
d3619 1
a3619 1
		    value[HTML_OBJECT_ID] && *value[HTML_OBJECT_ID]) {
d3627 1
a3627 1
		    value[HTML_OBJECT_TITLE] && *value[HTML_OBJECT_TITLE]) {
d3637 1
a3637 1
		    value[HTML_OBJECT_DATA] && *value[HTML_OBJECT_DATA]) {
d3645 1
a3645 1
		    value[HTML_OBJECT_TYPE] && *value[HTML_OBJECT_TYPE]) {
d3691 1
a3691 1
		    value[HTML_OBJECT_NAME] && *value[HTML_OBJECT_NAME]) {
d3785 1
a3785 1
	    value[HTML_OVERLAY_SRC] && *value[HTML_OVERLAY_SRC]) {
d3824 1
a3824 1
	    value[HTML_APPLET_ID] && *value[HTML_APPLET_ID]) {
d3827 1
a3827 1
		   value[HTML_APPLET_NAME] && *value[HTML_APPLET_NAME]) {
d3870 1
a3870 1
	    value[HTML_APPLET_CODE] && *value[HTML_APPLET_CODE]) {
d3880 1
a3880 1
		value[HTML_APPLET_CODEBASE] && *value[HTML_APPLET_CODEBASE]) {
d3944 1
a3944 1
	    value[HTML_BGSOUND_SRC] && *value[HTML_BGSOUND_SRC]) {
d3990 1
a3990 1
	    value[HTML_EMBED_ID] && *value[HTML_EMBED_ID]) {
d3993 1
a3993 1
		   value[HTML_EMBED_NAME] && *value[HTML_EMBED_NAME]) {
d4036 1
a4036 1
	    value[HTML_EMBED_SRC] && *value[HTML_EMBED_SRC]) {
d4222 1
a4222 1
		value[HTML_FORM_ENCTYPE] && *value[HTML_FORM_ENCTYPE]) {
d4241 1
a4241 1
		if (title != NULL && *title != '\0') {
d4301 1
a4301 1
	    I.size = NULL;
d4372 1
a4372 1
		value[HTML_BUTTON_VALUE] && *value[HTML_BUTTON_VALUE]) {
d4399 1
a4399 1
		value[HTML_BUTTON_CLASS] && *value[HTML_BUTTON_CLASS])
d4403 1
a4403 1
		value[HTML_BUTTON_ID] && *value[HTML_BUTTON_ID]) {
d4409 1
a4409 1
		value[HTML_BUTTON_LANG] && *value[HTML_BUTTON_LANG])
d4496 1
a4496 1
	    I.size = NULL;
d4528 1
a4528 1
		value[HTML_INPUT_TYPE] && *value[HTML_INPUT_TYPE]) {
d4639 1
a4639 1
		 value[HTML_INPUT_ALT] && *value[HTML_INPUT_ALT] &&
d4642 1
a4642 1
		  value[HTML_INPUT_VALUE] && *value[HTML_INPUT_VALUE])) {
d4653 1
a4653 1
		value[HTML_INPUT_SRC] && *value[HTML_INPUT_SRC] &&
d4658 1
a4658 1
		       value[HTML_INPUT_SRC] && *value[HTML_INPUT_SRC] &&
d4789 3
a4791 2
		value[HTML_INPUT_SIZE] && *value[HTML_INPUT_SIZE])
		I.size = value[HTML_INPUT_SIZE];
d4793 1
a4793 1
		value[HTML_INPUT_MAXLENGTH] && *value[HTML_INPUT_MAXLENGTH])
d4799 3
a4801 2
		I.accept_cs = value[HTML_INPUT_ACCEPT_CHARSET] ?
		    value[HTML_INPUT_ACCEPT_CHARSET] : "UNKNOWN";
d4804 1
a4804 1
		value[HTML_INPUT_ALIGN] && *value[HTML_INPUT_ALIGN])
d4807 1
a4807 1
		value[HTML_INPUT_CLASS] && *value[HTML_INPUT_CLASS])
d4810 1
a4810 1
		value[HTML_INPUT_ERROR] && *value[HTML_INPUT_ERROR])
d4813 1
a4813 1
		value[HTML_INPUT_HEIGHT] && *value[HTML_INPUT_HEIGHT])
d4816 1
a4816 1
		value[HTML_INPUT_WIDTH] && *value[HTML_INPUT_WIDTH])
d4819 1
a4819 1
		value[HTML_INPUT_ID] && *value[HTML_INPUT_ID]) {
d4824 1
a4824 1
		value[HTML_INPUT_LANG] && *value[HTML_INPUT_LANG])
d4827 1
a4827 1
		value[HTML_INPUT_MD] && *value[HTML_INPUT_MD])
d5026 1
a5026 1
	    StrAllocCopy(me->textarea_cols, value[HTML_TEXTAREA_COLS]);
d5033 1
a5033 1
		width = HTMIN(width, 60);
d5036 1
a5036 1
		HTSprintf0(&me->textarea_cols, "%d", width);
d5038 1
a5038 1
		StrAllocCopy(me->textarea_cols, "60");
d5040 1
d5047 2
a5048 1
	    me->textarea_rows = 4;
d5056 1
a5056 1
	    && value[HTML_TEXTAREA_ID] && *value[HTML_TEXTAREA_ID]) {
d5177 1
a5177 1
		I.size = NULL;
d5216 1
a5216 1
		    && value[HTML_OPTION_ID] && *value[HTML_OPTION_ID]) {
d5348 1
a5348 1
	    value[HTML_TABLE_ALIGN] && *value[HTML_TABLE_ALIGN]) {
d5917 1
a5917 1
	if (me->node_anchor->bookmark && *me->node_anchor->bookmark) {
d5919 1
a5919 1
		((bookmark_page && *bookmark_page) &&
d6257 1
a6257 1
	if (hidden_link_marker && *hidden_link_marker &&
d6428 1
a6428 1
		if (me->object_id && *me->object_id && !LYMapsOnly)
d6440 1
a6440 1
		if (me->object_id && *me->object_id)
d6633 1
a6633 1
	    if (me->object_id && *me->object_id && !LYMapsOnly)
d6823 1
a6823 1
	    I.size = NULL;
d6973 1
a6973 1
		for (chars = atoi(me->textarea_cols); chars > 0; chars--)
a6997 1
	    FREE(me->textarea_cols);
d7084 1
a7084 1
		for (; ptr && *ptr != '\0'; ptr++) {
a7539 1
    FREE(me->textarea_cols);
d7720 1
a7720 1
    me->textarea_cols = NULL;
d8305 1
a8305 1
    if (verbose_img && value[HTML_IMG_SRC] && *value[HTML_IMG_SRC]) {
@


1.8
log
@back out the -iz patch; slashdot.org and symlink.lu look
way different (not the front page, but the articles), and
also on www.heise.de/newsticker/ there is no left spacing
at the left side of the text, which is confusing in a
full-screen xterm
@
text
@d1967 1
a1967 1
	    width = LYcols - 1 -
d4341 1
a4341 1
	    } else if (HText_LastLineSize(me->text, FALSE) > (LYcols - 7)) {
d4506 1
a4506 1
	    } else if (HText_LastLineSize(me->text, FALSE) > (LYcols - 7)) {
d5015 1
a5015 1
	    width = LYcols - 1 -
d8079 1
d8142 1
d8171 1
d8189 1
@


1.7
log
@automatic merge of lynx-current
@
text
@d5307 1
a5307 2
	    if (tables_disable & TABLES_DISABLE_TABLE_IN_TABLE)
		HText_cancelStbl(me->text);
@


1.6
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 12
a13 12
**		============================================
**
**	This generates a hypertext object.  It converts from the
**	structured stream interface of HTML events into the style-
**	oriented interface of the HText.h interface.  This module is
**	only used in clients and should not be linked into servers.
**
**	Override this module if making a new GUI browser.
**
**   Being Overidden
**
*/
d64 1
a64 1
# define HCODE_TO_STACK_OFF(x) /*(CSHASHSIZE+1)*/ 88888  /*special value.*/
d66 1
a66 1
# define HCODE_TO_STACK_OFF(x) x /*pass computed value*/
d84 1
a84 1
    const HTStreamClass *	isa;
d86 7
a92 7
    HTParentAnchor *		anchor;
    FILE *			fp;
    char *			filename;
    HTChunk *			chunk;
    const HTStreamClass *	actions;
    HTStream *			target;
    int				status;
d98 1
a98 1
static HTStyleSheet * styleSheet = NULL;	/* Application-wide */
d102 2
a103 1
static HTStyle *styles[HTML_ELEMENTS+LYNX_HTML_EXTRA_ELEMENTS];
d118 8
a125 11
static int HTML_end_element (HTStructured *me,
				      int element_number,
				      char **include);

static int HTML_start_element (
	HTStructured *		me,
	int			element_number,
	const BOOL*		present,
	const char **		value,
	int			tag_charset,
	char **			include);
d133 3
a135 3
static char* MakeNewTitle (const char ** value, int src_type);
static char* MakeNewImageValue (const char ** value);
static char* MakeNewMapValue (const char ** value, const char* mapstr);
d138 2
a139 2
**	is only internal and the stack manipulation should be skipped. - kw
*/
d143 1
a143 1
void strtolower (char* i)
d145 6
a150 2
    if (!i) return;
    while (*i) { *i = (char)TOLOWER(*i); i++; }
d154 7
a160 7
**		------------------------------
**
On the NeXT, and on any read-only browser, it is simpler for the text to have
a sequence of styles, rather than a nested tree of styles.  In this
case we have to flatten the structure as it arrives from SGML tags into
a sequence of styles.
*/
d163 3
a165 3
**  If style really needs to be set, call this.
*/
void actually_set_style (HTStructured * me)
d167 1
a167 1
    if (!me->text) {			/* First time through */
d170 1
a170 1
		     me->UCLYhndl, me->UCI,
d189 3
a191 3
**  If you THINK you need to change style, call this.
*/
static void change_paragraph_style (HTStructured * me, HTStyle * style)
d200 1
a200 2
BOOL LYBadHTML (
    HTStructured *	me)
d211 3
a213 3
**
**			A C T I O N	R O U T I N E S
*/
d228 3
a230 3
**	------------------
*/
void HTML_put_character (HTStructured * me, char c)
d233 1
a233 2
     *	Ignore all non-MAP content when just
     *	scanning a document for MAPs. - FM
d239 1
a239 1
     *	Do EOL conversion if needed. - FM
d241 4
a244 4
     *	Convert EOL styles:
     *	 macintosh:  cr    --> lf
     *	 ascii:      cr-lf --> lf
     *	 unix:	     lf    --> lf
d255 1
a255 1
     *	Handle SGML_LITTERAL tags that have HTChunk elements. - FM
d260 1
a260 1
	return; /* Do Nothing */
d306 9
a314 9
	     *	If we are within a SELECT not caught by the cases
	     *	above - HTML_SELECT or HTML_OPTION may not be the
	     *	last element pushed on the style stack if there were
	     *	invalid markup tags within a SELECT element.  For error
	     *	recovery, treat text as part of the OPTION text, it is
	     *	probably meant to show up as user-visible text.
	     *	Having A as an open element while in SELECT is really sick,
	     *	don't make anchor text part of the option text in that case
	     *	since the option text will probably just be discarded. - kw
d322 1
a322 1
    } /* end first switch */
d325 1
a325 1
     *	Handle all other tag content. - FM
d329 1
a329 1
    case HTML_PRE:				/* Formatted text */
d331 2
a332 2
	 *  We guarantee that the style is up-to-date in begin_litteral
	 *  But we still want to strip \r's
d344 1
a344 1
    case HTML_LISTING:				/* Literal text */
d348 2
a349 2
	 *  We guarantee that the style is up-to-date in begin_litteral
	 *  But we still want to strip \r's
d351 1
a351 1
	if (c != '\r')	{
d360 1
a360 1
	 *  Free format text.
d406 1
a406 1
	       /* ignore */
d415 1
a415 1
    } /* end second switch */
d418 1
a418 1
	HText_setLastChar(me->text, ' '); /* set it to a generic separator */
d421 2
a422 3
	 *  \r's are ignored.  In order to keep collapsing spaces
	 *  correctly we must default back to the previous
	 *  separator if there was one
d425 1
a425 1
	HText_setLastChar(me->text, ' '); /* set it to a generic separator */
d432 6
a437 6
**	---------------
**
**	This is written separately from put_character because the loop can
**	in some cases be promoted to a higher function call level for speed.
*/
void HTML_put_string (HTStructured * me, const char * s)
d440 1
a440 1
    char* translated_string = NULL;
d447 1
a447 1
	StrAllocCopy(translated_string,s);
d456 1
a456 1
	break;					/* Do Nothing */
d470 2
a471 2
    case HTML_PRE:				/* Formatted text */
    case HTML_LISTING:				/* Literal text */
d475 1
a475 1
	 *  We guarantee that the style is up-to-date in begin_litteral
d497 1
a497 1
    default:					/* Free format text? */
d500 3
a502 3
	     *	If we are within a preformatted text style not caught
	     *	by the cases above (HTML_PRE or similar may not be the
	     *	last element pushed on the style stack). - kw
d512 1
a512 1
		for(; *s; ++s)
d516 1
a516 1
	    HText_appendText(me->text, s);
d521 1
d524 1
a524 2
			      (*p == ' ') || (*p == '\t')); p++)
		    ;	/* Ignore leaders */
d532 3
a534 3
		     *	Treat any '\r' which is not followed by '\n'
		     *	as '\n', to account for macintosh lineend in
		     *	ALT attributes etc. - kw
d542 1
a542 1
			continue;  /* Ignore it */
d555 1
a555 1
		   if (HText_getLastChar(me->text) != ' ')
d559 1
a559 1
			/* ignore */
d572 4
a575 4
		     *	\r's are ignored.  In order to keep collapsing
		     *	spaces correctly, we must default back to the
		     *	previous separator, if there was one.  So we
		     *	set LastChar to a generic separator.
d582 1
a582 1
	    } /* for */
d584 1
a584 1
    } /* end switch */
d594 3
a596 3
**	------------
*/
void HTML_write (HTStructured * me, const char* s, int l)
d598 2
a599 2
    const char* p;
    const char* e = s+l;
a663 1

d665 2
a666 2
static char* Style_className = 0;
static char* Style_className_end = 0;
d671 1
a671 1
static void free_Style_className (void)
d677 3
a679 4
static void addClassName (
	const char *	prefix,
	const char *	actual,
	int		length)
d706 1
a706 1
#define addClassName(prefix, actual, length) /* nothing */
a708 1

d711 2
a712 5
static void HTMLSRC_apply_markup (
	    HTStructured *   context,
	    HTlexeme	      lexeme,
	    BOOL	      start,
	    int	      tag_charset)
d714 1
a714 1
    HT_tagspec* ts = *( ( start ? lexeme_start : lexeme_end ) + lexeme);
d725 1
a725 1
	CTRACE((tfp,ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n",(int)lexeme));
d727 6
a732 7
	    HTML_start_element(
		context,
		ts->element,
		ts->present,
		(const char **)ts->value,
		tag_charset,
		NULL);
d734 3
a736 4
	    HTML_end_element(
		context,
		ts->element,
		NULL);
d749 1
a749 1
#endif /* USE_PRETTYSRC*/
d751 4
a754 6
static void LYStartArea (
	HTStructured *		obj,
	const char *		href,
	const char *		alt,
	const char *		title,
	int			tag_charset)
d756 2
a757 2
    BOOL		new_present[HTML_AREA_ATTRIBUTES];
    const char *	new_value[HTML_AREA_ATTRIBUTES];
d761 1
a761 1
	 new_present[i] = NO;
d765 1
a765 1
	new_value[HTML_AREA_ALT] = (const char *)alt;
d769 1
a769 1
	new_value[HTML_AREA_TITLE] = (const char *)title;
d773 1
a773 1
	new_value[HTML_AREA_HREF] = (const char *)href;
d776 2
a777 2
    (*obj->isa->start_element)(obj, HTML_AREA, new_present, new_value,
			       tag_charset, 0);
d780 9
a788 11
static void LYHandleFIG (
	HTStructured *		me,
	const BOOL*		present,
	const char **		value,
	BOOL			isobject,
	BOOL			imagemap,
	const char *		id,
	const char *		src,
	BOOL			convert,
	BOOL			start,
	BOOL *			intern_flag GCC_UNUSED)
d802 1
a802 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d815 1
d817 1
a817 1
	    CHECK_FOR_INTERN(*intern_flag,href);
d820 4
a823 5
		me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					INTERN_LT);		/* Type */
d827 5
a831 2
		HTML_put_string(me, (isobject ?
		      (imagemap ? "(IMAGE)" : "(OBJECT)") : "[FIGURE]"));
d836 1
a836 1
		HTML_put_character(me, ' '); /* space char may be ignored */
d845 1
a845 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d850 1
a850 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d858 1
a858 2
static void clear_objectdata (
	HTStructured *		me)
d885 7
a891 9
**	-------------
*/
static int HTML_start_element (
	HTStructured *		me,
	int			element_number,
	const BOOL*		present,
	const char **		value,
	int			tag_charset,
	char **		include)
d905 3
a907 3
    HTParentAnchor *dest = NULL;	     /* An anchor's destination */
    BOOL dest_ismap = FALSE;		     /* Is dest an image map script? */
    HTChildAnchor *ID_A = NULL;		     /* HTML_foo_ID anchor */
d914 1
d923 1
a923 1
	    HTTag * tag = &HTML_dtd.tags[element_number];
d925 2
a926 1
	    const char* p;
d933 1
a933 1
		*/
d942 4
a945 2
	    /*write markup for tags and exit*/
	    PSRCSTART(abracket); PUTC('<'); PSRCSTOP(abracket);
d947 1
a947 1
	    if (tagname_transform!=0)
d950 1
a950 1
		LYstrncpy(buf, tag->name, sizeof(buf)-1);
d959 1
a959 1
			if (attrname_transform!=0)
d962 3
a964 1
			    LYstrncpy(buf, tag->attributes[i].name, sizeof(buf)-1);
d969 9
a977 7
			    char q='"';
				/*0 in dquotes, 1 - in quotes, 2 mixed*/
			    char kind= (char) ( !strchr(value[i], '"') ?
					 0 :
					 !strchr(value[i], '\'') ?
					 q='\'',1 :
					 2);
d984 2
a985 2
				HTStartAnchor(me,value[i],NULL);
				HTML_end_element(me,HTML_A,NULL);
d988 1
a988 1
				HTStartAnchor(me,NULL,value[i]);
d990 1
a990 1
			    if (kind!=2)
d1000 1
a1000 1
				HTML_end_element(me,HTML_A,NULL);
d1005 3
a1007 3
			} /* if value */
		    } /* if present[i] */
	    }/* if present*/
d1009 4
a1012 2
	    PSRCSTART(abracket); PUTC('>'); PSRCSTOP(abracket);
	    psrc_nested_call=FALSE;
d1014 2
a1015 2
	} /*if (!psrc_nested_call) */
	/*fall through*/
d1027 1
a1027 3
    }

    {
d1031 2
a1032 2
	if ((me->tag_charset != j) || (j < 0  /* for trace entry */)) {
	    CTRACE((tfp, "me->tag_charset: %d -> %d", me->tag_charset, j ));
d1034 1
a1034 1
		   me->UCLYhndl, tag_charset));
d1042 3
a1044 3
    addClassName(";", 
	         HTML_dtd.tags[element_number].name,
	         HTML_dtd.tags[element_number].name_len);
d1051 2
a1052 2
			  ? -1
			  : cached_tag_styles[element_number];
d1066 1
a1066 1
	    if (!hashStyles[hcode].name) { /* None such -> classless version */
d1069 3
a1071 2
			(tfp, "STYLE.start_element: <%s> (class <%s> not configured), hcode=%d.\n",
			HTML_dtd.tags[element_number].name, class_name, hcode));
d1077 1
a1077 1
			HTML_dtd.tags[element_number].name, class_name, hcode));
d1084 1
a1084 1
    } else { /* (current_tag_style!=-1)	 */
d1092 1
a1092 1
		HTML_dtd.tags[element_number].name, hcode));
d1097 1
a1097 1
    if (!class_used && ElementNumber == HTML_INPUT) { /* For some other too? */
d1106 1
a1106 1
	if (!hashStyles[hcode].name) { /* None such -> classless version */
d1110 1
a1110 1
			   type));
d1116 1
a1116 1
			  HTML_dtd.tags[element_number].name, type, hcode));
d1119 1
a1119 1
#endif	/* !OMIT_SCN_KEEPING */
d1125 1
a1125 1
     *	Handle the start tag. - FM
d1146 1
a1146 1
			    NonNull(base)));
d1154 5
a1158 6
		 *  These have a non-standard form, basically
		 *  strip the prefix or the code below would insert
		 *  a nonsense host into the pseudo URL.  These
		 *  should never occur where they would be used for
		 *  resolution of relative URLs anyway.  We can
		 *  also strip the #map part. - kw
d1166 1
a1166 1
	     *	Get parent's address for defaulted fields.
d1171 1
a1171 1
	     *	Create the access field.
d1173 1
a1173 1
	    temp = HTParse(base, related, PARSE_ACCESS+PARSE_PUNCTUATION);
d1178 1
a1178 1
	     *	Create the host[:port] field.
d1180 1
a1180 1
	    temp = HTParse(base, "", PARSE_HOST+PARSE_PUNCTUATION);
d1192 1
a1192 1
					    PARSE_HOST+PARSE_PUNCTUATION)));
d1198 1
a1198 1
	     *	Create the path field.
d1200 1
a1200 1
	    temp = HTParse(base, "", PARSE_PATH+PARSE_PUNCTUATION);
d1203 1
d1208 1
a1208 1
		    *(p+1) = '\0';  /* strip after the last slash */
d1244 1
a1244 1
	    CHECK_FOR_INTERN(intern_flag,value[HTML_LINK_HREF]);
d1246 1
a1246 1
	     *	Prepare to do housekeeping on the reference. - FM
d1250 2
a1251 2
			? me->base_href
			: me->node_anchor->address;
d1258 2
a1259 2
			? me->base_href
			: me->node_anchor->address;
d1264 1
a1264 1
	     *	Handle links with a REV attribute. - FM
d1269 1
a1269 1
		 *  Handle REV="made" or REV="owner". - LM & FM
d1274 1
a1274 1
		     *	Load the owner element. - FM
d1281 2
a1282 2
		     *	Load the RevTitle element if a TITLE attribute
		     *	and value are present. - FM
d1300 1
a1300 1
	     *	Handle REL links. - FM
d1306 1
a1306 1
		 *  Ignore style sheets, for now. - FM
d1315 4
a1318 2
		    CTRACE2(TRACE_STYLE, (tfp, "HTML: StyleSheet link found.\n"));
		    CTRACE2(TRACE_STYLE, (tfp, "        StyleSheets not yet implemented.\n"));
d1325 6
a1330 6
		 *  Ignore anything not registered in the 28-Mar-95
		 *  IETF HTML 3.0 draft and W3C HTML 3.2 draft, or not
		 *  appropriate for Lynx banner links in the expired
		 *  Maloney and Quin relrev draft.  We'll make this more
		 *  efficient when the situation stabilizes, and for now,
		 *  we'll treat "Banner" as another toolbar element. - FM
d1361 17
a1377 18
		    pdoctitle = &title;	/* for setting HTAnchor's title */
		} else
		if (!strcasecomp(value[HTML_LINK_REL], "Up") ||
		    !strcasecomp(value[HTML_LINK_REL], "Next") ||
		    !strcasecomp(value[HTML_LINK_REL], "Previous") ||
		    !strcasecomp(value[HTML_LINK_REL], "Prev") ||
		    !strcasecomp(value[HTML_LINK_REL], "Child") ||
		    !strcasecomp(value[HTML_LINK_REL], "Sibling") ||
		    !strcasecomp(value[HTML_LINK_REL], "Parent") ||
		    !strcasecomp(value[HTML_LINK_REL], "Meta") ||
		    !strcasecomp(value[HTML_LINK_REL], "URC") ||
		    !strcasecomp(value[HTML_LINK_REL], "Pointer") ||
		    !strcasecomp(value[HTML_LINK_REL], "Translation") ||
		    !strcasecomp(value[HTML_LINK_REL], "Definition") ||
		    !strcasecomp(value[HTML_LINK_REL], "Alternate") ||
		    !strcasecomp(value[HTML_LINK_REL], "Section") ||
		    !strcasecomp(value[HTML_LINK_REL], "Subsection") ||
		    !strcasecomp(value[HTML_LINK_REL], "Chapter")) {
d1399 1
a1399 1
				 value[HTML_LINK_REL]));
d1407 2
a1408 2
	     *	If no HREF was specified, handle special REL links
	     *	with self-designated HREFs. - FM
d1417 3
a1419 2
		CTRACE((tfp, "HTML: LINK with REL=\"%s\" and no HREF ignored.\n",
			    value[HTML_LINK_REL]));
d1427 2
a1428 3
	     *	Create a title (link name) from the TITLE value,
	     *	if present, or default to the REL value that was
	     *	loaded into title. - FM
d1437 1
a1437 1
		FREE(temp); /* forget about recording RelTitle - kw */
d1447 3
a1449 4
		 *  Ugh!  The LINK tag, which is a HEAD element,
		 *  is in an Anchor, which is BODY element.  All
		 *  we can do is close the Anchor and cross our
		 *  fingers. - FM
d1456 1
a1456 2
	     *	Create anchors for the links that simulate
	     *	a toolbar. - FM
d1458 7
a1464 7
	    me->CurrentA = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				NULL,			/* Tag */
				href,			/* Addresss */
				temp
				   ? (HTLinkType*)HTAtom_for(temp)
				   : INTERN_LT);	/* Type */
d1466 2
a1467 3
	    if ((dest = HTAnchor_parent(
			    HTAnchor_followLink(me->CurrentA)
				      )) != NULL) {
d1488 4
a1491 5
		(ID_A = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					LYToolbarName,		/* Tag */
					NULL,			/* Addresss */
					(HTLinkType*)0))) {	/* Type */
d1493 1
a1493 1
		HText_setLastChar(me->text, ' ');  /* absorb white space */
d1499 2
a1500 2
		 *  Add collapsible space to separate link from previous
		 *  generated links. - kw
d1509 1
a1509 2
	    value && *value[HTML_LINK_CLASS]!='\0')
	    {
d1511 1
d1523 1
a1523 2
	    }
	    else
d1525 1
a1525 1
	    HTML_put_string(me, title);
d1539 4
a1542 4
	     *	Lynx was supporting ACTION, which never made it into
	     *	the HTML 2.0 specs.  HTML 3.0 uses HREF, so we'll
	     *	use that too, but allow use of ACTION as an alternate
	     *	until people have fully switched over. - FM
d1551 2
a1552 2
		    ? me->base_href
		    : me->node_anchor->address;
d1559 1
a1559 1
			me->base_href : me->node_anchor->address;
d1563 1
a1563 1
	 *  Support HTML 3.0 PROMPT attribute. - FM
d1589 2
a1590 2
	 *  We're getting it as Literal text, which, for now,
	 *  we'll just ignore. - FM
d1597 2
a1598 2
	 *  We're getting it as Literal text, which, for now,
	 *  we'll just ignore. - FM
d1629 4
a1632 5
	    me->CurrentA = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				NULL,			/* Tag */
				href,			/* Addresss */
				(HTLinkType*)0);	/* Type */
d1681 4
a1684 5
	    me->CurrentA = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				NULL,			/* Tag */
				href,			/* Addresss */
				(HTLinkType*)0);	/* Type */
d1687 1
a1687 1
	    LYResetParagraphAlignment(me);
d1720 2
a1721 3
	 *  Treat this as a toolbar if we don't have one
	 *  yet, and we are in the first half of the
	 *  first page. - FM
d1724 5
a1728 6
	     HText_getLines(me->text) < (display_lines/2)) &&
	    (ID_A = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					LYToolbarName,		/* Tag */
					NULL,			/* Addresss */
					(HTLinkType*)0))) {	/* Type */
d1742 2
a1743 2
		"HTML: ****** Maximum nesting of %d divisions exceeded!\n",
		MAX_NESTING));
d1746 1
a1746 1
	    LYEnsureSingleSpace(me); /* always at least break line - kw */
d1806 10
a1815 10
	 *  Close the previous style if not done by HTML doc.
	 *  Added to get rid of core dumps in BAD HTML on the net.
	 *		GAB 07-07-94
	 *  But then again, these are actually allowed to nest.  I guess
	 *  I have to depend on the HTML writers correct style.
	 *		GAB 07-12-94
	if (i_prior_style != -1) {
	    HTML_end_element(me, i_prior_style);
	}
	i_prior_style = ElementNumber;
d1819 2
a1820 2
	 *  Check whether we have an H# in a list,
	 *  and if so, treat it as an LH. - FM
d1836 6
a1841 8
	     *	Some authors use H# headers as a substitute for
	     *	FONT, so check if this one immediately followed
	     *	an LI.	If so, both me->inP and me->in_word will
	     *	be FALSE (though the line might not be empty due
	     *	to a bullet and/or nbsp) and we can assume it is
	     *	just for a FONT change.  We thus will not create
	     *	another line break nor add to the current left
	     *	indentation. - FM
d1881 1
a1881 1
	    (styles[ElementNumber]->font&HT_BOLD)) {
d1897 6
a1902 6
	  /* Add a \r (new line) if these three conditions are true:
	   *   1. We are not collapsing BR's, and
	   *   2. The previous line has text on it, or
	   *   3. This line has text on it.
	   * Otherwise, don't do anything. -DH 980814, TD 980827
	   */
d1906 1
a1906 1
	    HText_setLastChar(me->text, ' ');  /* absorb white space */
d1931 3
a1933 4
	     *	Start a new line only if we had printable
	     *	characters following the previous newline,
	     *	or remove the previous line if both it and
	     *	the last line are blank. - FM
d1937 1
a1937 1
		HText_setLastChar(me->text, ' ');  /* absorb white space */
d1946 1
a1946 1
	     *	Add an ID link if needed. - FM
d1950 6
a1955 7
	   /*
	    *  Center lines within the current margins, if
	    *  a right or left ALIGNment is not specified.
	    *  If WIDTH="#%" is given and not garbage,
	    *  use that to calculate the width, otherwise
	    *  use the default width. - FM
	    */
d1968 1
a1968 1
		    me->new_style->leftIndent - me->new_style->rightIndent;
d1971 1
a1971 1
		value[HTML_HR_WIDTH][strlen(value[HTML_HR_WIDTH])-1] == '%') {
d1974 1
d1976 1
a1976 1
		percent[strlen(percent)-1] = '\0';
d1998 2
a1999 2
	     *	Reset the alignment appropriately
	     *	for the division and/or block. - FM
d2004 1
a2004 1
				me->DivisionAlignments[me->Division_Level];
d2015 2
a2016 3
	     *	Add a blank line and set the second line
	     *	indentation for lists and addresses, or a
	     *	paragraph separator for other blocks. - FM
d2020 1
a2020 1
		HText_setLastChar(me->text, ' ');  /* absorb white space */
d2029 1
a2029 1
	if (!present) { /* Bad tag.  Must have at least one attribute. - FM */
d2034 3
a2036 4
	 *  If page author is using TAB within a TABLE, it's probably
	 *  formatted specifically to work well for Lynx without simple
	 *  table tracking code.  Cancel tracking, it would only make
	 *  things worse. - kw
d2046 2
a2047 2
	     *	Just ensure a collapsible space, until we have
	     *	the ALIGN and DP attributes implemented. - FM
d2050 2
a2051 1
	    CTRACE((tfp, "HTML: ALIGN not 'left'.  Using space instead of TAB.\n"));
d2056 3
a2058 4
	     *	Just ensure a collapsible space, until we
	     *	can replace HText_getCurrentColumn() in
	     *	GridText.c with code which doesn't require
	     *	that the alignment be HT_LEFT. - FM
d2074 1
a2074 1
		 *  TO has priority over INDENT if both are present. - FM
d2085 2
a2086 2
		 *  The INDENT value is in "en" (enval per column) units.
		 *  Divide it by enval, rounding odd values up. - FM
d2089 1
a2089 1
		   (int)(((1.0 * atoi(value[HTML_TAB_INDENT]))/enval)+(0.5));
d2093 3
a2095 3
	     *	If we are being directed to a column too far to the left
	     *	or right, just add a collapsible space, otherwise, add the
	     *	appropriate number of spaces. - FM
d2101 2
a2102 1
		CTRACE((tfp, "HTML: Column out of bounds.  Using space instead of TAB.\n"));
d2106 1
a2106 1
		HText_setLastChar(me->text, ' ');  /* absorb white space */
d2112 2
a2113 2
	 *  If we have an ID attribute, save it together
	 *  with the value of the column we've reached. - FM
d2131 6
a2136 7
	 *  FONT *may* have been declared SGML_EMPTY in HTMLDTD.c, and
	 *  SGML_character() in SGML.c *may* check for a FONT end
	 *  tag to call HTML_end_element() directly (with a
	 *  check in that to bypass decrementing of the HTML
	 *  parser's stack).  Or this may have been really a </FONT>
	 *  end tag, for which some incarnations of SGML.c would fake
	 *  a <FONT> start tag instead. - fm & kw
d2138 3
a2140 3
	 *  But if we have an open FONT, DON'T close that one now,
	 *  since FONT tags can be legally nested AFAIK, and Lynx
	 *  currently doesn't do anything with them anyway... - kw
d2148 2
a2149 2
	 *  Set flag to know we are in a FONT container, and
	 *  add code to do something about it, someday. - FM
d2154 1
a2154 1
    case HTML_B:			/* Physical character highlighting */
d2159 1
a2159 1
    case HTML_CITE:			/* Logical character highlighting */
d2166 2
a2167 2
	 *  Ignore this if inside of a bold anchor or header.
	 *  Can't display both underline and bold at same time.
d2176 1
a2176 1
	    CTRACE((tfp,"Beginning underline\n"));
d2178 1
a2178 1
	    CTRACE((tfp,"Underline Level is %d\n", me->Underline_Level));
d2182 1
a2182 1
    case HTML_ABBREV:	/* Miscellaneous character containers */
d2195 1
a2195 1
	break; /* ignore */
d2234 4
a2237 5
	 *  Should check LANG and/or DIR attributes, and the
	 *  me->node_anchor->charset and/or yet to be added
	 *  structure elements, to determine whether we should
	 *  use chevrons, but for now we'll always use double-
	 *  or single-quotes. - FM
d2246 1
a2246 1
    case HTML_PRE:				/* Formatted text */
d2248 5
a2252 6
	**  Set our inPRE flag to FALSE so that a newline
	**  immediately following the PRE start tag will
	**  be ignored.  HTML_put_character() will set it
	**  to TRUE when the first character within the
	**  PRE block is received. - FM
	*/
d2255 1
a2255 1
    case HTML_LISTING:				/* Literal text */
d2286 1
a2286 1
	     *	Indicate the type of NOTE.
d2329 1
a2329 1
	me->List_Nesting_Level++;  /* increment the List nesting level */
d2332 1
a2332 1
				      ? styles[HTML_DLC] : styles[HTML_DL]);
d2336 1
a2336 1
				      ? styles[HTML_DLC6] : styles[HTML_DL6]);
d2340 2
a2341 2
		 ? styles[(HTML_DLC1 - 1) + me->List_Nesting_Level]
		 : styles[(HTML_DL1 - 1) + me->List_Nesting_Level]);
d2343 1
a2343 1
	UPDATE_STYLE;	  /* update to the new style */
d2349 1
a2349 1
	me->List_Nesting_Level++;  /* increment the List nesting level */
d2358 1
a2358 1
			    styles[(HTML_DLC1 - 1) + me->List_Nesting_Level]);
d2360 1
a2360 1
	UPDATE_STYLE;	  /* update to the new style */
d2370 1
d2372 5
a2376 5
	     *  If there are several DT elements and this is not the first,
	     *  and the preceding DT element's first (and normally only) line
	     *  has not yet been ended, suppress intervening blank line by
	     *  temporarily modifying the paragraph style in place.  Ugly
	     *  but there's ample precedence. - kw
d2379 1
a2379 1
		me->sp->style->spaceBefore = 0;	/* temporary change */
d2383 2
a2384 2
	    me->sp->style->spaceBefore = saved_spaceBefore; /* undo */
	    me->sp->style->spaceAfter = saved_spaceAfter; /* undo */
d2393 2
a2394 2
	HText_setLastChar(me->text, ' ');  /* absorb white space */
	if (!me->style_change)	{
d2413 2
a2414 2
	 me->OL_Type[(me->List_Nesting_Level < 11 ?
			 me->List_Nesting_Level+1 : 11)] = '1';
d2417 2
a2418 3
	 *  Check whether we have a starting sequence number,
	 *  or want to continue the numbering from a previous
	 *  OL in this nest. - FM
d2424 4
a2427 4
	     *	Give preference to the valid HTML 3.0 SEQNUM attribute name
	     *	over the Netscape START attribute name (too bad the Netscape
	     *	developers didn't read the HTML 3.0 specs before re-inventing
	     *	the "wheel" as "we'll"). - FM
d2440 2
a2441 3
	     *	Don't allow negative numbers less than
	     *	or equal to our flags, or numbers less
	     *	than 1 if an Alphabetic or Roman TYPE. - FM
d2446 1
a2446 1
				    me->List_Nesting_Level+1 : 11)] = 'A';
d2451 1
a2451 1
				    me->List_Nesting_Level+1 : 11)] = 'a';
d2456 1
a2456 1
				    me->List_Nesting_Level+1 : 11)] = 'I';
d2461 1
a2461 1
				    me->List_Nesting_Level+1 : 11)] = 'i';
d2465 2
a2466 2
		  if (seqnum <= OL_VOID)
		      seqnum = OL_VOID + 1;
d2473 1
a2473 1
			       me->List_Nesting_Level+1 : 11)] = seqnum;
d2477 1
a2477 1
			      me->List_Nesting_Level+1 : 11] = OL_CONTINUE;
d2481 1
a2481 1
			       me->List_Nesting_Level+1 : 11)] = 1;
d2485 1
a2485 1
				    me->List_Nesting_Level+1 : 11)] = 'A';
d2488 1
a2488 1
				    me->List_Nesting_Level+1 : 11)] = 'a';
d2491 1
a2491 1
				    me->List_Nesting_Level+1 : 11)] = 'I';
d2494 1
a2494 1
				    me->List_Nesting_Level+1 : 11)] = 'i';
d2508 1
a2508 1
			  styles[HTML_OL1 + me->List_Nesting_Level - 1]);
d2510 1
a2510 1
	UPDATE_STYLE;  /* update to the new style */
d2521 1
a2521 1
		  0==strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
d2532 1
a2532 1
		  0==strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
d2543 1
a2543 1
		  0==strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
d2545 2
a2546 1
			  styles[HTML_OL1 + me->List_Nesting_Level - 1]);
d2549 2
a2550 1
			  styles[HTML_MENU1 + me->List_Nesting_Level - 1]);
d2554 1
a2554 1
	UPDATE_STYLE;  /* update to the new style */
d2570 2
a2571 1
			  styles[HTML_MENU1 + me->List_Nesting_Level - 1]);
d2573 1
a2573 1
	UPDATE_STYLE;  /* update to the new style */
d2578 1
a2578 1
	UPDATE_STYLE;  /* update to the new style */
d2588 1
a2588 1
	UPDATE_STYLE;  /* update to the new style */
d2594 1
d2596 3
a2598 3
	     *  No, a LI should never occur directly within another LI,
	     *  but this may result from incomplete error recovery.
	     *  So check one more surrounding level in this case. - kw
d2668 1
a2668 1
		 *	Hack, because there is no append string!
d2677 6
a2682 7
		 *	Use HTML_put_character so that any other spaces
		 *	coming through will be collapsed.  We'll use
		 *	nbsp, so it won't break at the spacing character
		 *	if there are no spaces in the subsequent text up
		 *	to the right margin, but will declare it as a
		 *	normal space to ensure collapsing if a normal
		 *	space does immediately follow it. - FM
d2688 1
a2688 1
		 *	Hack, because there is no append string!
d2692 1
a2692 1
		switch(me->List_Nesting_Level % 7) {
d2717 6
a2722 7
		 *	Keep using HTML_put_character so that any other
		 *	spaces coming through will be collapsed.  We use
		 *	nbsp, so we won't wrap at the spacing character
		 *	if there are no spaces in the subsequent text up
		 *	to the right margin, but will declare it as a
		 *	normal space to ensure collapsing if a normal
		 *	space does immediately follow it. - FM
d2728 1
a2728 1
		 *	Hack, because there is no append string!
d2743 3
a2745 3
	 *  Should check LANG and/or DIR attributes, and the
	 *  me->node_anchor->charset and/or yet to be added
	 *  structure elements, and do something here. - FM
d2752 3
a2754 3
	 *  Should check DIR (and LANG) attributes, and the
	 *  me->node_anchor->charset and/or yet to be added
	 *  structure elements, and do something here. - FM
d2775 1
a2775 1
	me->inLABEL = TRUE;
d2781 9
a2789 10
	    /*
	     *  If we are looking for client-side image maps,
	     *  then handle an A within a MAP that has a COORDS
	     *  attribute as an AREA tag.  Unfortunately we lose
	     *  the anchor text this way for the LYNXIMGMAP, we
	     *  would have to do much more parsing to collect it.
	     *  After potentially handling the A as AREA, always return
	     *  immediately if only looking for image maps, without
	     *  pushing anything on the style stack. - kw
	     */
d2800 5
a2804 6
	 *  A may have been declared SGML_EMPTY in HTMLDTD.c, and
	 *  SGML_character() in SGML.c may check for an A end
	 *  tag to call HTML_end_element() directly (with a
	 *  check in that to bypass decrementing of the HTML
	 *  parser's stack), so if we have an open A, close
	 *  that one now. - FM & kw
d2811 1
a2811 1
	 *  Set to know we are in an anchor.
d2816 1
a2816 1
	 *  Load id_string if we have an ID or NAME. - FM
d2829 1
a2829 1
	 *  Handle the reference. - FM
d2840 1
a2840 1
	    CHECK_FOR_INTERN(intern_flag,href);	 /* '#'*/
d2852 3
a2854 4
		      (isFTP_URL(me->node_anchor->address) ||
		       isFILE_URL(me->node_anchor->address))) {
		    for (i = 0; (href[i] = href[i+7]) != 0; i++)
			;
d2858 1
a2858 1
	    if (present[HTML_A_ISMAP]) /*???*/
d2874 3
a2876 3
		** Found TYPE="internal link" but not in a valid context
		** where we have written it. - kw
		*/
d2878 1
a2878 1
			    href, temp));
d2883 7
a2889 6
	me->CurrentA = HTAnchor_findChildAndLink(
			me->node_anchor,			/* Parent */
			id_string,				/* Tag */
			href,					/* Address */
			temp ?
		(HTLinkType*)HTAtom_for(temp) : INTERN_LT);  /* Type */
d2909 4
a2912 4
		**  Set up to load the anchor's chartrans structures
		**  appropriately for the current display character
		**  set if it can handle what's claimed. - FM
		*/
d2917 1
a2917 1
			dest_char_set = UCLYhndl_for_unrec;
d2921 2
a2922 3
		dest = HTAnchor_parent(
			HTAnchor_followLink(me->CurrentA)
				      );
d2932 4
a2935 5
		**  Load the anchor's chartrans structures.
		**  This should be done more intelligently
		**  when setting up the structured object,
		**  but it gets the job done for now. - FM
		*/
d2954 3
a2956 3
	 *  Close an HREF-less NAMED-ed now if we aren't making their
	 *  content bold, and let the check in HTML_end_element() deal
	 *  with any dangling end tag this creates. - FM
d2964 1
a2964 1
	    requested - VH*/
d2973 1
a2973 1
    case HTML_IMG:			/* Images */
d2975 3
a2977 4
	 *  If we're in an anchor, get the destination, and if it's a
	 *  clickable image for the current anchor, set our flags for
	 *  faking a 0,0 coordinate pair, which typically returns the
	 *  image's default. - FM
d2980 2
a2981 3
	    if ((dest = HTAnchor_parent(
			HTAnchor_followLink(me->CurrentA)
				      )) != NULL) {
d2985 1
a2985 1
				dest->address));
d2990 1
a2990 1
				dest->address));
d2997 1
a2997 1
	 *  If there's a USEMAP, resolve it. - FM
d3002 1
a3002 1
	    CHECK_FOR_INTERN(intern_flag,map_href);
d3005 2
a3006 2
	     *	If map_href ended up zero-length or otherwise doesn't
	     *	have a hash, it can't be valid, so ignore it. - FM
d3014 1
a3014 1
	 *  Handle a MAP reference if we have one at this point. - FM
d3018 7
a3024 2
	     *	If the MAP reference doesn't yet begin with a scheme,
	     *	check whether a base tag is in effect. - FM
a3025 6
		/*
		 *  If the
		 *  USEMAP value is a lone fragment and LYSeekFragMAPinCur
		 *  is set, we'll use the current document's URL for
		 *  resolving.	Otherwise use the BASE. - kw
		 */
d3027 2
a3028 2
			!(*map_href == '#' && LYSeekFragMAPinCur == TRUE)) ?
				me->base_href : me->node_anchor->address;
d3032 1
a3032 1
	     *	Prepend our client-side MAP access field. - FM
d3041 2
a3042 2
	 *  Check whether we want to suppress the server-side
	 *  ISMAP link if a client-side MAP is present. - FM
d3050 1
a3050 1
	 *  Check for a TITLE attribute. - FM
d3064 3
a3066 3
	 *  If there's an ALT string, use it, unless the ALT string
	 *  is zero-length or just spaces and we are making all SRCs
	 *  links or have a USEMAP link. - FM
d3077 2
a3078 2
	     *	If it's all spaces and we are making SRC or
	     *	USEMAP links, treat it as zero-length. - FM
d3086 2
a3087 1
				     (temp = MakeNewMapValue(value,"USEMAP"))));
d3091 2
a3092 1
				     (temp = MakeNewMapValue(value,"ISMAP"))));
d3098 2
a3099 1
						  VERBOSE_IMG(value, HTML_IMG_SRC, "[LINK]")));
d3103 6
a3108 5
					     (title ? title :
						  ((present &&
						    present[HTML_IMG_ISOBJECT]) ?
						    "(OBJECT)" :
						    VERBOSE_IMG(value, HTML_IMG_SRC, "[INLINE]"))));
d3115 1
a3115 1
				      (temp = MakeNewMapValue(value,"USEMAP"))));
d3121 1
a3121 1
				      (temp = MakeNewMapValue(value,"ISMAP"))));
d3127 2
a3128 1
				      VERBOSE_IMG(value, HTML_IMG_SRC, "[LINK]")));
d3133 5
a3137 4
			  ((present &&
			    present[HTML_IMG_ISOBJECT]) ?
					     "(OBJECT)" :
					     VERBOSE_IMG(value, HTML_IMG_SRC, "[INLINE]"))));
d3143 1
a3143 1
	    StrAllocCopy(alt_string, (temp = MakeNewMapValue(value,"USEMAP")));
d3148 3
a3150 3
		    map_href ? 1 : 0,
		    (dest_ismap == TRUE) ? 1 : 0,
		    me->inA, me->inP));
d3153 1
a3153 1
	 *  Check for an ID attribute. - FM
d3165 1
a3165 1
	 *  Create links to the SRC for all images, if desired. - FM
d3174 2
a3175 2
	     *	If it's an ISMAP and/or USEMAP, or graphic for an
	     *	anchor, end that anchor and start one for the SRC. - FM
d3179 2
a3180 2
		 *  If we have a USEMAP, end this anchor and
		 *  start a new one for the client-side MAP. - FM
d3186 2
a3187 1
			HTML_put_string(me, (temp = MakeNewMapValue(value,"ISMAP")));
d3203 4
a3206 5
			if ((ID_A = HTAnchor_findChildAndLink(
				  me->node_anchor,	/* Parent */
				  id_string,		/* Tag */
				  NULL,			/* Addresss */
				  (HTLinkType*)0)) != NULL) {	/* Type */
d3211 4
a3214 5
		    me->CurrentA = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				NULL,			/* Tag */
				map_href,		/* Addresss */
				INTERN_LT);		/* Type */
d3216 2
a3217 3
			if ((dest = HTAnchor_parent(
				HTAnchor_followLink(me->CurrentA)
						  )) != NULL) {
d3230 1
a3230 1
		    HTML_put_character(me, ' ');/* space char may be ignored */
d3245 3
a3247 3
		   ((map_href || dest_ismap) ?
				   "(IMAGE)" : "(OBJECT)") :
				   VERBOSE_IMG(value, HTML_IMG_SRC, "[IMAGE]")));
d3249 4
a3252 5
		    if ((ID_A = HTAnchor_findChildAndLink(
				  me->node_anchor,	/* Parent */
				  id_string,		/* Tag */
				  NULL,			/* Addresss */
				  (HTLinkType*)0)) != NULL) {	/* Type */
d3258 1
a3258 1
		HTML_put_character(me, ' ');  /* space char may be ignored */
d3261 4
a3264 5
		    if ((ID_A = HTAnchor_findChildAndLink(
				  me->node_anchor,	/* Parent */
				  id_string,		/* Tag */
				  NULL,			/* Addresss */
				  (HTLinkType*)0)) != NULL) {	/* Type */
d3269 4
a3272 5
		me->CurrentA = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				NULL,			/* Tag */
				map_href,		/* Addresss */
				INTERN_LT);		/* Type */
d3274 2
a3275 3
		    if ((dest = HTAnchor_parent(
				HTAnchor_followLink(me->CurrentA)
					      )) != NULL) {
d3298 2
a3299 2
						 "(IMAGE)" :
						 VERBOSE_IMG(value, HTML_IMG_SRC, "[IMAGE]")));
d3301 1
a3301 1
		HTML_put_character(me, ' ');  /* space char may be ignored */
d3304 4
a3307 5
		    if ((ID_A = HTAnchor_findChildAndLink(
				  me->node_anchor,	/* Parent */
				  id_string,		/* Tag */
				  NULL,			/* Addresss */
				  (HTLinkType*)0)) != NULL) {	/* Type */
d3315 1
a3315 1
	     *	Create the link to the SRC. - FM
d3317 4
a3320 5
	    me->CurrentA = HTAnchor_findChildAndLink(
			me->node_anchor,		/* Parent */
			NULL,				/* Tag */
			href,				/* Addresss */
			(HTLinkType*)0);		/* Type */
d3333 1
a3333 1
		HTML_put_character(me, ' ');  /* space char may be ignored */
d3336 1
a3336 1
		HTML_put_character(me, ' ');  /* space char may be ignored */
d3343 2
a3344 2
		 *  We're in an anchor and have a USEMAP, so end the anchor
		 *  and start a new one for the client-side MAP. - FM
d3347 1
a3347 1
		    HTML_put_character(me, ' ');/* space char may be ignored */
d3349 1
a3349 1
		    HTML_put_string(me, (temp = MakeNewMapValue(value,"ISMAP")));
d3352 1
a3352 1
		    HTML_put_character(me, ' ');/* space char may be ignored */
d3369 4
a3372 5
	    me->CurrentA = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				NULL,			/* Tag */
				map_href,		/* Addresss */
				INTERN_LT);		/* Type */
d3374 2
a3375 3
		if ((dest = HTAnchor_parent(
				HTAnchor_followLink(me->CurrentA)
					  )) != NULL) {
d3398 2
a3399 3
	     *	Just put in the ALT or pseudo-ALT string
	     *	for the current anchor or inline, with an
	     *	ID link if indicated. - FM
d3401 1
a3401 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d3404 4
a3407 5
		if ((ID_A = HTAnchor_findChildAndLink(
				  me->node_anchor,	/* Parent */
				  id_string,		/* Tag */
				  NULL,			/* Addresss */
				  (HTLinkType*)0)) != NULL) {	/* Type */
d3413 1
a3413 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d3427 1
a3427 1
	 *  Load id_string if we have a NAME or ID. - FM
d3444 4
a3447 5
	 *  Generate a target anchor in this place in the containing
	 *  document.  MAP can now contain block markup, if it doesn't
	 *  contain any AREAs (or A anchors with COORDS converted to AREAs)
	 *  the current location can be used as a fallback for following
	 *  a USEMAP link. - kw
d3449 2
a3450 2
	 if (!LYMapsOnly)
	     LYHandleID(me, id_string);
d3453 1
a3453 1
	 *  Load map_address. - FM
d3457 5
a3461 6
	     *	The MAP must be in the current stream, even if it
	     *	had a BASE tag, so we'll use its address here, but
	     *	still use the BASE, if present, when resolving the
	     *	AREA elements in it's content, unless the AREA's
	     *	HREF is a lone fragment and LYSeekFragAREAinCur is
	     *	set. - FM && KW
d3489 1
a3489 1
	     *	Resolve the HREF. - FM
d3492 1
a3492 1
	    CHECK_FOR_INTERN(intern_flag,href);
d3496 4
a3499 5
	     *	Check whether a BASE tag is in effect, and use it
	     *	for resolving, even though we used this stream's
	     *	address for locating the MAP itself, unless the
	     *	HREF is a lone fragment and LYSeekFragAREAinCur
	     *	is set. - FM
d3502 2
a3503 2
			!(*href == '#' && LYSeekFragAREAinCur == TRUE)) ?
				me->base_href : me->node_anchor->address;
d3507 1
a3507 1
	     *	Check for an ALT. - FM
d3513 1
a3513 1
		value[HTML_AREA_TITLE] && *value[HTML_AREA_TITLE]) {
d3515 1
a3515 1
		 *  Use the TITLE as an ALT. - FM
d3524 1
a3524 1
		 *  Make sure it's not just space(s). - FM
d3533 1
a3533 1
		 *  Use the HREF as an ALT. - FM
d3547 2
a3548 3
	 *  We may need to look at this someday to deal with
	 *  MAPs, OBJECTs or APPLETs optimally, but just ignore
	 *  it for now. - FM
d3555 2
a3556 2
	 *  We may need to look at this someday to deal with
	 *  OBJECTs optimally, but just ignore it for now. - FM
d3563 2
a3564 2
	 *  We may need to look at this someday to deal with
	 *  APPLETs optimally, but just ignore it for now. - FM
d3587 2
a3588 3
	     *	This is an outer OBJECT start tag,
	     *	i.e., not a nested OBJECT, so save
	     *	it's relevant attributes. - FM
d3668 3
a3670 1
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&me->object_codetype, TRUE, FALSE);
d3689 11
a3699 11
	     *  If we can determine now that we are not going to do anything
	     *  special to the OBJECT element's SGML contents, like skipping
	     *  it completely or collecting it up in order to add something
	     *  after it, then generate any output that should be emitted in the
	     *  place of the OBJECT start tag NOW, then don't initialize special
	     *  handling but return, letting our SGML parser know that further
	     *  content is to be parsed normally not literally.  We could defer
	     *  this until we have collected the contents and then recycle the
	     *  contents (as was previously always done), but that has a higher
	     *  chance of completely losing content in case of nesting errors
	     *  in the input, incomplete transmissions, etc. - kw
d3714 1
a3714 1
					: NULL,
d3723 1
a3723 1
			HTML_end_element(me,HTML_A,NULL);
d3729 7
a3735 7
		 *  We do NOT want the HTML_put_* functions that are going
		 *  to be called for the OBJECT's character content to
		 *  add to the chunk, so we don't push on the stack.
		 *  Instead we keep a counter for open OBJECT tags that
		 *  are treated this way, so HTML_end_element can skip
		 *  handling the corresponding end tag that is going to
		 *  arrive unexpectedly as far as our stack is concerned.
d3748 7
a3754 5
		    1,
		    1 || me->object_ismap,
		    me->object_id,
		    (me->object_data && !me->object_classid) ? value[HTML_OBJECT_DATA] : NULL,
		    NO, TRUE, &intern_flag);
d3762 1
a3762 1
		 *	Set flag that we are accumulating OBJECT content. - FM
d3781 4
a3784 5
		me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					(HTLinkType*)0);	/* Type */
d3806 1
a3806 1
	HTML_put_character(me, ' ');  /* space char may be ignored */
d3808 1
a3808 1
	 *  Load id_string if we have an ID or NAME. - FM
d3825 2
a3826 2
	 *  If there's an ALT string, use it, unless the ALT string
	 *  is zero-length and we are making all sources links. - FM
d3833 1
a3833 1
						   me->UsePlainSpace, me->HiddenValue);
d3835 2
a3836 2
	     *	If it's all spaces and we are making sources links,
	     *	treat it as zero-length. - FM
d3854 1
a3854 1
	 *  If we're making all sources links, get the source. - FM
d3858 1
a3858 1
	    char * base = NULL;
d3861 2
a3862 2
		    ? me->base_href
		    : me->node_anchor->address;
d3864 1
a3864 1
	     *	Check for a CODEBASE attribute. - FM
d3872 1
a3872 1
		 *  Force it to be a directory. - FM
d3894 4
a3897 5
		me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					(HTLinkType*)0);	/* Type */
d3910 1
a3910 1
		HTML_put_character(me, ' ');  /* space char may be ignored */
d3916 1
a3916 1
	     *	Just put up the ALT string, if non-zero. - FM
d3919 1
a3919 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d3928 1
a3928 1
	 *  If we're making all sources links, get the source. - FM
d3945 1
a3945 1
		HTML_put_character(me, ' ');  /* space char may be ignored */
d3948 4
a3951 5
	    me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					(HTLinkType*)0);	/* Type */
d3964 1
a3964 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d3972 1
a3972 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d3974 1
a3974 1
	 *  Load id_string if we have an ID or NAME. - FM
d3992 2
a3993 2
	 *  If there's an ALT string, use it, unless the ALT string
	 *  is zero-length and we are making all sources links. - FM
d4000 1
a4000 1
						   me->UsePlainSpace, me->HiddenValue);
d4002 2
a4003 2
	     *	If it's all spaces and we are making sources links,
	     *	treat it as zero-length. - FM
d4020 1
a4020 1
	 *  If we're making all sources links, get the source. - FM
d4033 4
a4036 5
		me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					(HTLinkType*)0);	/* Type */
d4057 1
a4057 1
	     *	Just put up the ALT string, if non-zero. - FM
d4060 1
a4060 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d4082 2
a4083 2
	     *	Assume all text in the FIG container is intended
	     *	to be paragraphed. - FM
d4089 2
a4090 2
	     *	Assume all text in the APPLET container is intended
	     *	to be paragraphed. - FM
d4114 2
a4115 2
	     *	Assume all text in the FIG container is intended
	     *	to be paragraphed. - FM
d4121 2
a4122 2
	     *	Assume all text in the APPLET container is intended
	     *	to be paragraphed. - FM
d4133 4
a4136 4
	    char * action = NULL;
	    char * method = NULL;
	    char * enctype = NULL;
	    const char * accept_cs = NULL;
d4138 1
a4138 1
	    HTChildAnchor * source;
d4142 5
a4146 6
	     *	FORM may have been declared SGML_EMPTY in HTMLDTD.c, and
	     *	SGML_character() in SGML.c may check for a FORM end
	     *	tag to call HTML_end_element() directly (with a
	     *	check in that to bypass decrementing of the HTML
	     *	parser's stack), so if we have an open FORM, close
	     *	that one now. - FM
d4155 1
a4155 1
	     *	Set to know we are in a new form.
d4162 1
a4162 1
			    value[HTML_FORM_ACCEPT_CHARSET] : "UNKNOWN";
d4166 2
a4167 2
		    ? me->base_href
		    : me->node_anchor->address;
d4176 3
a4178 3
		 *  Check whether a base tag is in effect.  Note that
		 *  actions always are resolved w.r.t. to the base,
		 *  even if the action is empty. - FM
d4187 3
a4189 3
						   NULL,
						   action,
						   (HTLinkType*)0);
d4192 1
a4192 2
		 *  Memory leak fixed.
		 *  05-28-94 Lynx 2-3-1 Garrett Arch Blythe
d4194 2
a4195 1
		char* cp_freeme = HTAnchor_address(link_dest);
d4206 1
a4206 1
				     value[HTML_FORM_METHOD] : "GET");
d4216 2
a4217 2
		 *  Check for a TITLE attribute, and if none is present,
		 *  check for a SUBJECT attribute as a synonym. - FM
d4274 19
a4292 5
	    I.align=NULL; I.accept=NULL; I.checked=NO; I.class=NULL;
	    I.disabled=NO; I.error=NULL; I.height= NULL; I.id=NULL;
	    I.lang=NULL; I.max=NULL; I.maxlength=NULL; I.md=NULL;
	    I.min=NULL; I.name=NULL; I.size=NULL; I.src=NULL;
	    I.type=NULL; I.value=NULL; I.width=NULL;
d4303 1
a4303 1
		 *  It's a button for submitting or resetting a form. - FM
d4308 1
a4308 1
		 *  Ugh, it's a button for a script. - FM
d4310 1
a4310 1
		HTML_put_string(me," [BUTTON] ");
d4315 1
a4315 1
	     *	Make sure we're in a form.
d4322 2
a4323 2
		 *  We'll process it, since the chances of a crash are
		 *  small, and we probably do have a form started. - FM
d4325 1
a4325 1
		break;
d4330 6
a4335 7
	     *	Before any input field, add a collapsible space if
	     *	we're not in a PRE block, to promote a wrap there
	     *	for any long values that would extend past the right
	     *	margin from our current position in the line.  If
	     *	we are in a PRE block, start a new line if the last
	     *	line already is within 6 characters of the wrap point
	     *	for PRE blocks. - FM
d4361 1
a4361 1
		 *  Convert any HTML entities or decimal escaping. - FM
d4371 2
a4372 2
		 *  Convert any newlines or tabs to spaces,
		 *  and trim any lead or trailing spaces. - FM
d4385 1
a4385 1
	    if (present && present[HTML_BUTTON_CLASS] && /* Not yet used. */
d4395 1
a4395 1
	    if (present && present[HTML_BUTTON_LANG] && /* Not yet used. */
d4401 7
a4407 8
	     *	Submit and reset buttons have values which don't change,
	     *	so HText_beginInput() sets I.value to the string which
	     *	should be displayed, and we'll enter that instead of
	     *	underscore placeholders into the HText structure to
	     *	see it instead of underscores when dumping or printing.
	     *	We also won't worry about a wrap in PRE blocks, because
	     *	the line editor never is invoked for submit or reset
	     *	buttons. - LE & FM
d4410 1
a4410 1
		    !me->sp->style->freeFormat) {
d4412 6
a4417 7
		 *  We have a submit or reset button in a PRE block,
		 *  so output the entire value from the markup.  If
		 *  it extends to the right margin, it will wrap
		 *  there, and only the portion before that wrap will
		 *  be hightlighted on screen display (Yuk!) but we
		 *  may as well show the rest of the full value on
		 *  the next or more lines. - FM
d4423 13
a4435 16
		 *  The submit or reset button is not in a PRE block.
		 *  Note that if a wrap occurs before outputting the
		 *  entire value, the wrapped portion will not be
		 *  highlighted or clearly indicated as part of the
		 *  link for submission or reset (Yuk!).
		 *  We'll replace any spaces in the submit or reset
		 *  button value with nbsp, to promote a wrap at the
		 *  space we ensured would be present before the start
		 *  of the string, as when we use all underscores
		 *  instead of the INPUT's actual value, but we could
		 *  still get a wrap at the right margin, instead, if
		 *  the value is greater than a line width for the
		 *  current style.  Also, if chars somehow ended up
		 *  longer than the length of the actual value
		 *  (shouldn't have), we'll continue padding with nbsp
		 *  up to the length of chars. - FM
d4439 2
a4440 2
				       (char)(I.value[i] ==  ' ' ?
					      HT_NON_BREAK_SPACE : I.value[i]));
d4463 1
a4463 1
	    char* ImageSrc = NULL;
d4467 1
d4469 19
a4487 5
	    I.align=NULL; I.accept=NULL; I.checked=NO; I.class=NULL;
	    I.disabled=NO; I.error=NULL; I.height= NULL; I.id=NULL;
	    I.lang=NULL; I.max=NULL; I.maxlength=NULL; I.md=NULL;
	    I.min=NULL; I.name=NULL; I.size=NULL; I.src=NULL;
	    I.type=NULL; I.value=NULL; I.width=NULL;
d4495 6
a4500 7
	     *	Before any input field, add a collapsible space if
	     *	we're not in a PRE block, to promote a wrap there
	     *	for any long values that would extend past the right
	     *	margin from our current position in the line.  If
	     *	we are in a PRE block, start a new line if the last
	     *	line already is within 6 characters of the wrap point
	     *	for PRE blocks. - FM
d4512 1
a4512 1
	     *	Get the TYPE and make sure we can handle it. - FM
d4527 1
a4527 1
		     *	Not yet implemented.
d4552 1
a4552 1
		     *	Ugh, a button for a script.
d4554 1
a4554 1
		    HTML_put_string(me,"[BUTTON] ");
d4577 1
a4577 1
	     *	Check if we're in a form. - FM
d4584 2
a4585 2
		 *  We'll process it, since the chances of a crash are
		 *  small, and we probably do have a form started. - FM
d4587 1
a4587 1
		break;
d4594 1
a4594 1
	     *	Check for an unclosed TEXTAREA.
d4602 1
a4602 1
	     *	Check for an unclosed SELECT, try to close it if found.
d4613 1
a4613 1
	     *	Handle the INPUT as for a FORM. - FM
d4631 4
a4634 5
		 *  This is a TYPE="image" using an ALT rather than
		 *  VALUE attribute to indicate the link string for
		 *  text clients or GUIs with image loading off, so
		 *  set the flag to use that as if it were a VALUE
		 *  attribute. - FM
d4644 3
a4646 3
		present && present[HTML_INPUT_SRC] &&
		value[HTML_INPUT_SRC] && *value[HTML_INPUT_SRC] &&
		I.type && !strcasecomp(I.type, "image")) {
d4649 3
a4651 4
		 *  We have a TYPE="image" with a non-zero-length SRC
		 *  attribute and want clickable images.  Make the
		 *  SRC's value a link if it's still not zero-length
		 *  legitimizing it. - FM
d4660 4
a4663 5
		    me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					(HTLinkType*)0);	/* Type */
d4667 3
a4669 1
		    HTML_put_string(me, VERBOSE_IMG(value,HTML_INPUT_SRC,"[IMAGE]"));
d4679 3
a4681 1
	    CTRACE((tfp, "2.Ok, we're trying type=[%s] (present=%p)\n", NONNULL(I.type), present));
d4686 3
a4688 3
		(*value[HTML_INPUT_VALUE] ||
		 (I.type && (!strcasecomp(I.type, "checkbox") ||
			     !strcasecomp(I.type, "radio")))))) {
d4691 1
a4691 1
		 *  Convert any HTML entities or decimal escaping. - FM
d4722 2
a4723 2
				value[HTML_INPUT_ALT] :
				value[HTML_INPUT_VALUE]));
d4728 7
a4734 7
		TRANSLATE_AND_UNESCAPE_ENTITIES6(
		    &I_value,
		    ATTR_CS_IN,
		    I.value_cs,
		    (BOOL)(me->UsePlainSpace && !me->HiddenValue),
		    me->UsePlainSpace,
		    me->HiddenValue);
d4738 2
a4739 2
		     *	Convert any newlines or tabs to spaces,
		     *	and trim any lead or trailing spaces. - FM
a4749 1

d4760 4
a4763 4
		 *  We put up an [IMAGE] link and '-' for a TYPE="image"
		 *  and didn't get a VALUE or ALT string, so fake a
		 *  "Submit" value.  If we didn't put up a link, then
		 *  HText_beginInput() will use "[IMAGE]-Submit". - FM
d4767 1
a4767 1
	    } else if ( ImageSrc ) {
d4784 1
a4784 1
	    if (present && present[HTML_INPUT_ACCEPT_CHARSET]) { /* Not yet used. */
d4786 1
a4786 1
			      value[HTML_INPUT_ACCEPT_CHARSET] : "UNKNOWN";
d4788 1
a4788 1
	    if (present && present[HTML_INPUT_ALIGN] && /* Not yet used. */
d4791 1
a4791 1
	    if (present && present[HTML_INPUT_CLASS] && /* Not yet used. */
d4794 1
a4794 1
	    if (present && present[HTML_INPUT_ERROR] && /* Not yet used. */
d4797 1
a4797 1
	    if (present && present[HTML_INPUT_HEIGHT] && /* Not yet used. */
d4800 1
a4800 1
	    if (present && present[HTML_INPUT_WIDTH] && /* Not yet used. */
d4808 1
a4808 1
	    if (present && present[HTML_INPUT_LANG] && /* Not yet used. */
d4811 1
a4811 1
	    if (present && present[HTML_INPUT_MD] && /* Not yet used. */
d4817 4
a4820 1
	    CTRACE((tfp, "I.%s have %d chars, or something\n", NONNULL(I.type), chars));
d4823 7
a4829 8
	     *	Submit and reset buttons have values which don't change,
	     *	so HText_beginInput() sets I.value to the string which
	     *	should be displayed, and we'll enter that instead of
	     *	underscore placeholders into the HText structure to
	     *	see it instead of underscores when dumping or printing.
	     *	We also won't worry about a wrap in PRE blocks, because
	     *	the line editor never is invoked for submit or reset
	     *	buttons. - LE & FM
d4832 3
a4834 3
		(!strcasecomp(I.type,"submit") ||
		 !strcasecomp(I.type,"reset") ||
		 !strcasecomp(I.type,"image")))
d4840 2
a4841 3
		 *  Put a (_) placeholder, and one space
		 *  (collapsible) before the label that is
		 *  expected to follow. - FM
d4853 1
a4853 1
		!strcasecomp(I.type, "checkbox")) {
d4855 2
a4856 3
		 *  Put a [_] placeholder, and one space
		 *  (collapsible) before the label that is
		 *  expected to follow. - FM
d4872 12
a4883 14
		 *  This is not a submit or reset button, and we are
		 *  in a PRE block with a field intended to exceed 6
		 *  character widths.  The code inadequately handles
		 *  INPUT fields in PRE tags if wraps occur (at the
		 *  right margin) for the underscore placeholders.
		 *  We'll put up a minimum of 6 underscores, since we
		 *  should have wrapped artificially, above, if the
		 *  INPUT begins within 6 columns of the right margin,
		 *  and if any more would exceed the wrap column, we'll
		 *  ignore them.  Note that if we somehow get tripped
		 *  up and a wrap still does occur before all 6 of the
		 *  underscores are output, the wrapped ones won't be
		 *  treated as part of the editing window, nor be
		 *  highlighted when not editing (Yuk!). - FM
d4896 2
a4897 3
		 *  This is not a submit or reset button,
		 *  so output the rest of the underscore
		 *  placeholders, if any more are needed. - FM
d4914 6
a4919 7
		     *	We have a submit or reset button in a PRE block,
		     *	so output the entire value from the markup.  If
		     *	it extends to the right margin, it will wrap
		     *	there, and only the portion before that wrap will
		     *	be hightlighted on screen display (Yuk!) but we
		     *	may as well show the rest of the full value on
		     *	the next or more lines. - FM
d4925 14
a4938 16
		     *	The submit or reset button is not in a PRE block.
		     *	Note that if a wrap occurs before outputting the
		     *	entire value, the wrapped portion will not be
		     *	highlighted or clearly indicated as part of the
		     *	link for submission or reset (Yuk!).
		     *	We'll replace any spaces in the submit or reset
		     *	button value with nbsp, to promote a wrap at the
		     *	space we ensured would be present before the start
		     *	of the string, as when we use all underscores
		     *	instead of the INPUT's actual value, but we could
		     *	still get a wrap at the right margin, instead, if
		     *	the value is greater than a line width for the
		     *	current style.	Also, if chars somehow ended up
		     *	longer than the length of the actual value
		     *	(shouldn't have), we'll continue padding with nbsp
		     *	up to the length of chars. - FM
d4942 1
a4942 1
					   (char)(I.value[i] ==  ' '
d4965 1
a4965 1
	 *  Make sure we're in a form.
d4969 2
a4970 1
		CTRACE((tfp, "Bad HTML: TEXTAREA start tag not within FORM tag\n"));
d4972 1
a4972 1
	     *	Too likely to cause a crash, so we'll ignore it. - FM
d4978 1
a4978 1
	 *  Set to know we are in a textarea.
d4983 1
a4983 1
	 *  Get ready for the value.
d5014 1
d5016 2
a5017 2
		    me->new_style->leftIndent - me->new_style->rightIndent;
	    if (dump_output_immediately) /* don't waste too much for this */
d5019 1
a5019 1
	    if (width > 1 && (width-1)*6 < MAX_LINE - 3 -
d5043 4
a5046 5
		(ID_A = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				id_string,		/* Tag */
				NULL,			/* Addresss */
				(HTLinkType*)0))) {	/* Type */
d5061 1
a5061 1
	 *  Check for an already open SELECT block. - FM
d5065 2
a5066 1
		CTRACE((tfp, "Bad HTML: SELECT start tag in SELECT element.  Faking SELECT end tag. *****\n"));
d5077 1
a5077 1
		       present, (const char **)value,
d5085 1
a5085 1
	     *	An option is a special case of an input field.
d5090 1
a5090 1
	     *	Make sure we're in a select tag.
d5094 2
a5095 1
		    CTRACE((tfp, "Bad HTML: OPTION tag not within SELECT tag\n"));
d5098 1
a5098 1
		 *  Too likely to cause a crash, so we'll ignore it. - FM
d5105 1
a5105 1
		 *  Finish the data off.
d5110 1
a5110 1
		 *  Finish the previous option @@@@@@@@@@
d5122 3
a5124 3
	     *	If it's not a multiple option list and select popups
	     *	are enabled, then don't use the checkbox/button method,
	     *	and don't put anything on the screen yet.
d5132 1
a5132 1
		     *	Start a newline before each option.
d5137 1
a5137 1
		     *	Add option list designation character.
d5144 1
a5144 1
		 *  Inititialize.
d5146 19
a5164 5
		I.align=NULL; I.accept=NULL; I.checked=NO; I.class=NULL;
		I.disabled=NO; I.error=NULL; I.height= NULL; I.id=NULL;
		I.lang=NULL; I.max=NULL; I.maxlength=NULL; I.md=NULL;
		I.min=NULL; I.name=NULL; I.size=NULL; I.src=NULL;
		I.type=NULL; I.value=NULL; I.width=NULL;
d5174 1
a5174 1
		    I.checked=YES;
d5179 1
a5179 1
		     *	Convert any HTML entities or decimal escaping. - FM
d5184 4
a5187 4
						       ATTR_CS_IN,
						       ATTR_CS_IN,
							NO,
						       me->UsePlainSpace, me->HiddenValue);
d5195 2
a5196 2
		   (present && present[HTML_OPTION_DISABLED]))
		    I.disabled=YES;
d5200 4
a5203 5
		    if ((ID_A = HTAnchor_findChildAndLink(
				    me->node_anchor,	   /* Parent */
				    value[HTML_OPTION_ID], /* Tag */
				    NULL,		   /* Addresss */
				    (HTLinkType*)0)) != NULL) {    /* Type */
d5214 2
a5215 3
		     *	Put a "[_]" placeholder, and one space
		     *	(collapsible) before the label that is
		     *	expected to follow. - FM
d5221 1
a5221 1
		    HText_setLastChar(me->text, ' ');  /* absorb white space */
d5225 2
a5226 3
		     *	Put a "(_)" placeholder, and one space
		     *	(collapsible) before the label that is
		     *	expected to follow. - FM
d5232 1
a5232 1
		    HText_setLastChar(me->text, ' ');  /* absorb white space */
d5238 1
a5238 1
	     *	Get ready for the next value.
d5253 1
a5253 1
		     *	Convert any HTML entities or decimal escaping. - FM
d5258 4
a5261 4
						       ATTR_CS_IN,
						       ATTR_CS_IN,
							NO,
						       me->UsePlainSpace, me->HiddenValue);
d5270 2
a5271 2
	     *	If this is a popup option, print its option
	     *	for use in selecting option by number. - LE
d5280 1
a5280 1
		    sprintf(marker,"(%d)", opnum);
d5293 3
a5295 4
	 *  Not fully implemented.  Just treat as a division
	 *  with respect to any ALIGN attribute, with
	 *  a default of HT_LEFT, or leave as a PRE
	 *  block if we are presently in one. - FM
d5297 2
a5298 3
	 *  Also notify simple table tracking code unless
	 *  in a preformatted section, or (currently) non-left
	 *  alignment.
d5300 3
a5302 4
	 *  If page author is using a TABLE within PRE, it's probably
	 *  formatted specifically to work well for Lynx without simple
	 *  table tracking code.  Cancel tracking, it would only make
	 *  things worse. - kw
d5307 2
a5308 1
	HText_cancelStbl(me->text);
d5328 1
a5328 1
	    "HTML: ****** Maximum nesting of %d divisions/tables exceeded!\n",
d5339 1
a5339 1
				styles[HTML_DLEFT]->alignment;
d5345 1
a5345 1
					styles[HTML_DCENTER]->alignment;
d5378 3
a5380 4
	 *  Not fully implemented.  Just start a new row,
	 *  if needed, act on an ALIGN attribute if present,
	 *  and check for an ID link. - FM
	 *  Also notify simple table tracking code. - kw
d5392 1
a5392 1
	    HText_setLastChar(me->text, ' ');  /* absorb white space */
d5409 1
a5409 1
		me->sp->style->alignment = HT_LEFT;
d5442 1
a5442 1
	 *  Not fully implemented.  Just check for an ID link. - FM
d5472 1
a5472 1
	 *  Not fully implemented.  Just check for an ID link. - FM
d5485 1
d5501 1
a5501 1
			       (BOOL)(ElementNumber == HTML_COLGROUP));
d5519 2
a5520 2
	 *  Not fully implemented.  Just add a collapsible space and break. - FM
	 *  Also notify simple table tracking code. - kw
d5525 1
d5545 1
a5545 1
			      (BOOL)(ElementNumber == HTML_TH));
d5552 2
a5553 2
	 *  We're getting it as Literal text, which, until we can process
	 *  it, we'll display as is, within brackets to alert the user. - FM
d5562 1
a5562 1
    } /* end switch */
d5568 2
a5569 2
    "HTML:begin_element: internal call (level %d), leaving on stack - `%s'\n",
			me->skip_stack, NONNULL(me->sp->style->name)));
d5584 5
a5588 4
	CTRACE((tfp, "HTML:begin_element[%d]: adding style to stack - %s (%s)\n",
		     (int) STACKLEVEL(me),
		     NONNULL(me->new_style->name),
		     HTML_dtd.tags[ElementNumber].name));
d5594 1
a5594 1
		HTML_dtd.tags[ElementNumber].can_justify == FALSE)
a5597 1

d5608 1
a5608 2
    if (ReallyEmptyTagNum(element_number))
    {
d5625 15
a5639 17
**		-----------
**
**	When we end an element, the style must be returned to that
**	in effect before that element.	Note that anchors (etc?)
**	don't have an associated style, so that we must scan down the
**	stack for an element with a defined style. (In fact, the styles
**	should be linked to the whole stack not just the top one.)
**	TBL 921119
**
**	We don't turn on "CAREFUL" check because the parser produces
**	(internal code errors apart) good nesting.  The parser checks
**	incoming code errors, not this module.
*/
static int HTML_end_element (
	HTStructured *		me,
	int			element_number,
	char **		include)
d5652 1
a5652 1
	    HTTag * tag = &HTML_dtd.tags[element_number];
d5654 1
a5654 1
	    int tag_charset=0;
d5656 4
a5659 2
	    psrc_nested_call=TRUE;
	    PSRCSTART(abracket); PUTS("</"); PSRCSTOP(abracket);
d5661 1
a5661 1
	    if (tagname_transform!=0)
d5664 1
a5664 1
		LYstrncpy(buf, tag->name, sizeof(buf)-1);
d5669 4
a5672 2
	    PSRCSTART(abracket); PUTC('>'); PSRCSTOP(abracket);
	    psrc_nested_call=FALSE;
d5675 1
a5675 1
	/*fall through*/
d5685 3
a5687 3
	       (me->sp == me->stack + MAX_NESTING - 1) ? "none" :
	       (me->sp->tag_number < 0) ? "*invalid tag*" :
	       (me->sp->tag_number >= HTML_ELEMENTS) ? "special tag" :
d5690 1
a5690 1
		/* panic */
d5695 2
a5696 2
     *	If we're seeking MAPs, skip everything that's
     *	not a MAP or AREA tag. - FM
d5706 2
a5707 2
     *	Pop state off stack if we didn't declare the element
     *	SGML_EMPTY in HTMLDTD.c. - FM & KW
d5726 2
a5727 3
	     *	Set the break flag if we're popping
	     *	a dummy HTML_LH substituted for an
	     *	HTML_H# encountered in a list.
d5737 3
a5739 2
		    (tfp, "HTML:end_element: Internal call (level %d), leaving on stack - %s\n",
			  me->skip_stack, NONNULL(me->sp->style->name)));
d5746 1
a5746 1
		       me->sp[0].tag_number == HTML_FIG)) {
d5748 3
a5750 3
	     *	Ignore non-corresponding OBJECT tags that we
	     *	didn't push because the SGML parser was supposed
	     *  to go on parsing the contents non-literally. - kw
d5754 4
a5757 4
			   (int) STACKLEVEL(me),
			   "Special OBJECT handling", me->objects_mixed_open,
			   "leaving on stack",
			   NONNULL(me->sp->style->name)));
d5760 1
a5760 1
	    element_number != me->sp[0].tag_number) {
d5762 6
a5767 9
	     *	Ignore non-corresponding tags if we had
	     *	a stack overrun.  This is not a completely
	     *	fail-safe strategy for protection against
	     *	any seriously adverse consequences of a
	     *	stack overrun, and the rendering of the
	     *	document will not be as intended, but we
	     *	expect overruns to be rare, and this should
	     *	offer reasonable protection against crashes
	     *	if an overrun does occur. - FM
d5769 1
a5769 1
	    return HT_OK; /* let's pretend... */
d5771 1
a5771 1
	    me->sp[0].tag_number != HTML_SELECT) {
d5773 3
a5775 4
	     *	Ignore non-corresponding SELECT tags, since we
	     *	probably popped it and closed the SELECT block
	     *	to deal with markup which amounts to a nested
	     *	SELECT, or an out of order FORM end tag. - FM
d5779 12
a5790 12
	    HTML_dtd.tags[HTML_LH].contents == SGML_EMPTY &&
	    (me->sp[0].tag_number == HTML_UL ||
	     me->sp[0].tag_number == HTML_OL ||
	     me->sp[0].tag_number == HTML_MENU ||
	     me->sp[0].tag_number == HTML_DIR ||
	     me->sp[0].tag_number == HTML_LI) &&
	    (element_number == HTML_H1 ||
	     element_number == HTML_H2 ||
	     element_number == HTML_H3 ||
	     element_number == HTML_H4 ||
	     element_number == HTML_H6 ||
	     element_number == HTML_H6)) {
d5792 2
a5793 3
	     *	It's an H# for which we substituted
	     *	an HTML_LH, which we've declared as
	     *	SGML_EMPTY, so just return. - FM
d5805 3
a5807 3
		     *  It's an OBJECT for which we substituted a FIG,
		     *  so pop the FIG and pretend that's what we are
		     *  being called for. - kw
d5810 7
a5816 6
			    (tfp, "HTML:end_element[%d]: %s (level %d), %s - %s\n",
				  (int) STACKLEVEL(me),
				  "Special OBJECT->FIG handling",
				  me->objects_figged_open,
				  "treating as end FIG",
				  NONNULL(me->sp->style->name)));
d5823 4
a5826 3
		    (tfp, "HTML:end_element[%d]: Popped style off stack - %s\n",
			  (int) STACKLEVEL(me),
			  NONNULL(me->sp->style->name)));
d5829 1
a5829 1
  "Stack underflow error!  Tried to pop off more styles than exist in stack\n"));
d5834 2
a5835 2
	    if (reached_awaited_stacked_elt)
		wait_for_this_stacked_elt=-1;
d5837 1
a5837 1
	return HT_OK; /* let's pretend... */
d5841 1
a5841 1
     *	Check for unclosed TEXTAREA. - FM
d5853 1
a5853 1
     *	Handle the end tag. - FM
d5855 1
a5855 1
    switch(element_number) {
d5865 3
a5867 1
			((me->inSELECT || me->inTEXTAREA) && me->inA) ? ", " : "",
d5876 5
a5880 6
	    /*	If we are parsing the List Page, and have a BASE after
	     *	we are done with the HEAD element, propagate it back
	     *	to the node_anchor object.  The base should have been
	     *	inserted by showlist() to record what document the List
	     *	Page is about, and other functions may later look for it
	     *	in the anchor. - kw
d5893 7
a5899 9
	 *  Check if it's a bookmark file, and if so, and multiple
	 *  bookmark support is on, or it's off but this isn't the
	 *  default bookmark file (e.g., because it was on before,
	 *  and this is another bookmark file that has been retrieved
	 *  as a previous document), insert the current description
	 *  string and filepath for it.  We pass the strings back to
	 *  the SGML parser so that any 8 bit or multibyte/CJK
	 *  characters will be handled by the parser's state and
	 *  charset routines. - FM
d5917 1
a5917 1
					 MBM_A_subdescript[i] : gettext("(none)")));
d5925 3
a5927 2
				       *MBM_A_subbookmark[i]) ?
					 MBM_A_subbookmark[i] : gettext("(unknown)")));
d5941 2
a5942 2
	 *  We're getting it as Literal text, which, for now,
	 *  we'll just ignore. - FM
d5947 1
a5947 1
		      me->style_block.data));
d5953 2
a5954 2
	 *  We're getting it as Literal text, which, for now,
	 *  we'll just ignore. - FM
d5958 1
a5958 1
			    me->script.data));
d5970 3
a5972 1
			((me->inSELECT || me->inTEXTAREA) && me->inA) ? ", " : "",
d5978 1
a5978 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d5985 1
a5985 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d5993 4
a5996 5
		/*
		 *  Set flag to know that style has ended.
		 *  Fall through.
		i_prior_style = -1;
		 */
d6015 1
a6015 1
				me->DivisionAlignments[me->Division_Level];
d6028 1
a6028 1
    case HTML_H1:			/* header styles */
d6036 1
a6036 1
				me->DivisionAlignments[me->Division_Level];
d6063 3
a6065 3
		 (const BOOL*)0, (const char **)0,
		 include, 0,
		 FALSE);
d6072 1
a6072 1
    case HTML_B:			/* Physical character highlighting */
d6077 1
a6077 1
    case HTML_CITE:			/* Logical character highlighting */
d6081 2
a6082 2
	 *  Ignore any emphasis end tags if the
	 *  Underline_Level is not set. - FM
d6088 2
a6089 2
	 *  Adjust the Underline level counter, and
	 *  turn off underlining if appropriate. - FM
d6101 1
a6101 1
    case HTML_ABBREV:	/* Miscellaneous character containers */
d6148 4
a6151 5
	 *  Should check LANG and/or DIR attributes, and the
	 *  me->node_anchor->charset and/or yet to be added
	 *  structure elements, to determine whether we should
	 *  use chevrons, but for now we'll always use double-
	 *  or single-quotes. - FM
d6159 1
a6159 1
    case HTML_PRE:				/* Formatted text */
d6161 1
a6161 1
	 *  Set to know that we are no longer in a PRE block.
d6165 1
a6165 1
    case HTML_LISTING:				/* Literal text */
d6172 1
a6172 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6181 1
a6181 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6192 1
a6192 1
			    me->List_Nesting_Level : 11] = OL_VOID;
d6203 1
a6203 1
		    me->List_Nesting_Level));
d6206 1
a6206 1
	    in_DT = FALSE; /*close the term that was without definition. */
d6208 1
a6208 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6216 3
a6218 3
	 *  Should undo anything we did based on LANG and/or DIR
	 *  attributes, and the me->node_anchor->charset and/or
	 *  yet to be added structure elements. - FM
d6224 3
a6226 3
	 *  Should undo anything we did based on DIR (and/or LANG)
	 *  attributes, and the me->node_anchor->charset and/or
	 *  yet to be added structure elements. - FM
d6232 1
a6232 1
	 *  Ignore any spurious A end tags. - FM
d6237 1
a6237 1
	 *  Set to know that we are no longer in an anchor.
d6242 2
a6243 2
		HText_isAnchorBlank(me->text, me->CurrentANum) ) {
	    HText_appendText(me->text,hidden_link_marker);
d6264 2
a6265 2
	 *  We may need to look at this someday to deal with
	 *  OBJECTs optimally, but just ignore it for now. - FM
d6267 1
a6267 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6272 2
a6273 2
	 *  We may need to look at this someday to deal with
	 *  APPLETs optimally, but just ignore it for now. - FM
d6275 1
a6275 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6288 1
a6288 1
	 *  Finish the data off.
d6301 3
a6303 4
		 *  Look for nested OBJECTs.  This procedure
		 *  could get tripped up if invalid comments
		 *  are present in the content, or if an OBJECT
		 *  end tag is present in a quoted attribute. - FM
d6309 1
a6309 1
		    !IsNmChar(cp[6])) {
d6312 1
a6312 1
		    !IsNmChar(cp[7])) {
d6317 1
a6317 1
		    !IsNmChar(cp[8])) {
d6323 1
a6323 1
		    !IsNmChar(cp[4])) {
d6328 1
a6328 1
		    !IsNmChar(cp[5])) {
d6335 2
a6336 2
		 *  We had more end tags than start tags, so
		 *  we have bad HTML or otherwise misparsed. - FM
d6339 2
a6340 1
		    CTRACE((tfp, "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content:\n%s\n",
d6355 11
a6365 11
		     *  We have nested OBJECT tags, and not yet all of the
		     *  end tags, but have a case where the content needs
		     *  to be parsed again (not dropped) and where we don't
		     *  want to output anything special at the point when we
		     *  *do* have accumulated all the end tags.  So recycle
		     *  the incomplete contents now, and signal the SGML
		     *  parser that it should not regard the current OBJECT
		     *  ended but should treat its contents as mixed.
		     *  Normally these cases would have already handled
		     *  in the real start_element call, so this block may
		     *  not be necessary. - kw
d6368 2
a6369 2
			   "HTML: Nested OBJECT tags.  Recycling incomplete contents",
			   me->object.data));
d6378 1
a6378 1
		    HTML_start_element(me, HTML_OBJECT, NULL,NULL,
d6383 6
a6388 6
		 *  We have nested OBJECT tags, and not yet all of the
		 *  end tags, and we want the end tags.  So restore an
		 *  end tag to the content, and signal to the SGML parser
		 *  that it should resume the accumulation of OBJECT content
		 *  (after calling back to start_element) in a way that
		 *  is equivalent to passing it a dummy start tag. - FM, kw
d6400 2
a6401 3
	     *	OBJECT start and end tags are fully matched,
	     *	assuming we weren't tripped up by comments
	     *	or quoted attributes. - FM
d6406 4
a6409 6
	     *	OBJECTs with DECLARE should be saved but
	     *	not instantiated, and if nested, can have
	     *	only other DECLAREd OBJECTs.  Until we have
	     *	code to handle these, we'll just create an
	     *	anchor for the ID, if present, and discard
	     *	the content (sigh 8-). - FM
d6419 3
a6421 4
	     *	OBJECTs with NAME are for FORM submissions.
	     *	We'll just create an anchor for the ID, if
	     *	present, and discard the content until we
	     *	have code to handle these. (sigh 8-). - FM
d6431 2
a6432 2
	     *	Deal with any nested OBJECTs by descending
	     *	to the inner-most OBJECT. - FM
d6438 3
a6440 3
		     *	Minumum requirements for the ad hoc parsing
		     *	to have succeeded are met.  We'll hope that
		     *	it did succeed. - FM
d6444 5
a6448 5
			 *  Well we don't need to do this any more,
			 *  nested objects should either not get here
			 *  any more at all or can be handled fine by
			 *  other code below.  Leave in place for now
			 *  as a special case for LYMapsOnly. - kw
d6468 1
a6468 1
			       (s > 1) ? "s" : ""));
d6474 2
a6475 1
			CTRACE((tfp, "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content.\n"));
d6481 1
a6481 1
	     *	If its content has SHAPES, convert it to FIG. - FM
d6483 3
a6485 3
	     *  This is now handled in our start_element without using
	     *  include if the SGML parser cooperates, so this block
	     *  may be unnecessary. - kw
d6514 2
a6515 2
	     *	If it has a USEMAP attribute and didn't have SHAPES,
	     *	convert it to IMG. - FM
d6525 1
a6525 1
		     *	Pass the ID. - FM
d6534 2
a6535 2
		     *	We have DATA with no CLASSID, so let's
		     *	hope it' equivalent to an SRC. - FM
d6543 1
a6543 2
		     *	Use the TITLE for both the MAP
		     *	and the IMGs ALT. - FM
d6552 1
a6552 1
		 *  Add the USEMAP, and an ISMAP if present. - FM
d6565 5
a6569 6
		 *  Add the content if it has <MAP, since that may
		 *  be the MAP this usemap points to.  But if we have
		 *  nested objects, try to eliminate portions that
		 *  cannot contribute to the quest for MAP.  This is
		 *  not perfect, we may get too much content; this seems
		 *  preferable over losing too much. - kw
d6574 2
a6575 1
			CTRACE((tfp, "HTML: MAP found, recycling object contents.\n"));
d6606 2
a6607 2
			   "HTML: MAP and nested OBJECT tags.  Recycling parts",
			   data));
d6615 1
a6615 1
	     *	Add an ID link if needed. - FM
d6621 1
a6621 1
	     *	Add the OBJECTs content if not empty. - FM
d6630 4
a6633 6
	     *	Create a link to the DATA, if desired, and
	     *	we can rule out that it involves scripting
	     *	code.  This a risky thing to do, but we can
	     *	toggle clickable_images mode off if it really
	     *	screws things up, and so we may as well give
	     *	it a try. - FM
d6643 5
a6647 6
		     *	We have a DATA value and no need for scripting
		     *	code, so close the current Anchor, if one is
		     *	open, and add an Anchor for this source.  If
		     *	we also have a TYPE value, check whether it's
		     *	an image or not, and set the link name
		     *	accordingly. - FM
d6668 1
a6668 1
	 *  Re-intialize all of the OBJECT elements. - FM
d6670 1
a6670 1
End_Object:
d6674 1
a6674 1
	    change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6681 1
a6681 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d6686 1
a6686 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6693 1
a6693 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6701 1
a6701 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6707 3
a6709 4
	 *  Check if we had a FORM start tag, and issue a
	 *  message if not, but fall through to check for
	 *  an open SELECT and ensure that the FORM-related
	 *  globals in GridText.c are initialized. - FM
d6718 7
a6724 9
	 *  Check if we still have a SELECT element open.
	 *  FORM may have been declared SGML_EMPTY in HTMLDTD.c,
	 *  and in that case SGML_character() in SGML.c is
	 *  not able to ensure correct nesting; or it may have
	 *  failed to enforce valid nesting.  If a SELECT is open,
	 *  issue a message, then
	 *  call HTML_end_element() directly (with a
	 *  check in that to bypass decrementing of the HTML
	 *  parser's stack) to close the SELECT. - kw
d6728 2
a6729 1
		CTRACE((tfp, "Bad HTML: Open SELECT at FORM end. Faking SELECT end tag. *****\n"));
d6737 1
a6737 1
	 *  Set to know that we are no longer in an form.
d6743 4
a6746 5
	 *  If we are in a list and are on the first line
	 *  with no text following a bullet or number,
	 *  don't force a newline.  This could happen if
	 *  we were called from HTML_start_element() due
	 *  to a missing FORM end tag. - FM
d6755 1
a6755 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6761 1
a6761 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6777 1
a6777 1
	     *	Make sure we had a textarea start tag.
d6786 1
a6786 1
	     *	Set to know that we are no longer in a textarea tag.
d6791 1
a6791 1
	     *	Initialize.
d6793 19
a6811 5
	    I.align=NULL; I.accept=NULL; I.checked=NO; I.class=NULL;
	    I.disabled=NO; I.error=NULL; I.height= NULL; I.id=NULL;
	    I.lang=NULL; I.max=NULL; I.maxlength=NULL; I.md=NULL;
	    I.min=NULL; I.name=NULL; I.size=NULL; I.src=NULL;
	    I.type=NULL; I.value=NULL; I.width=NULL;
d6816 1
a6816 1
	     *	Before any input field add a space if necessary.
d6821 1
a6821 1
	     *	Add a return.
d6826 1
a6826 1
	     *	Finish the data off.
d6841 5
a6845 6
	     *	Transform the TEXTAREA content as needed, then parse
	     *	it into individual lines to be handled as a series
	     *  series of INPUT fields (ugh!).
	     *	Any raw 8-bit or multibyte characters already have been
	     *	handled in relation to the display character set
	     *	in SGML_character().
d6847 4
a6850 4
	     *  If TEXTAREA is handled as SGML_LITTERAL (the old way),
	     *	we need to SGML-unescape any character references and NCRs
	     *  here.  Otherwise this will already have happened in the
	     *  SGML.c parsing. - kw
d6862 10
a6871 13
		 *  This shouldn't have anything to do, normally, but
		 *  just in case...
		 *  There shouldn't be lynx special character codes in
		 *  the chunk ("DTD" flag Tgf_nolyspcl tells SGML.c not
		 *  to generate them).  If there were, we could set the
		 *  last parameter ('Back') below to YES, which would
		 *  take them out of the data.
		 *  The data may however contain non break space, soft
		 *  hyphen, or en space etc., in the me->UCLYhndl character
		 *  encoding.  If that's a problem, perhaps for the (line
		 *  or other) editor, setting 'Back' to YES should also
		 *  help to always convert them to plain spaces (or drop
		 *  them). - kw
d6874 5
a6878 5
						    me->UCLYhndl,
						    current_char_set,
						    NO,
						    me->UsePlainSpace, me->HiddenValue,
						    NO);
d6883 1
a6883 2
	     *	Trim any trailing newlines and
	     *	skip any lead newlines. - FM
d6895 1
a6895 2
	     *	Load the first text line, or set
	     *	up for all blank rows. - FM
d6911 2
a6912 2
	     *	Display at least the requested number
	     *	of text lines and/or blank rows. - FM
d6916 1
d6919 1
a6919 1
			temp[j] = (char) (temp[j+1] ? ' ' : '\0');
d6944 3
a6946 3
	     *	Check for more data lines than the rows attribute.
	     *	We add them to the display, because we support only
	     *	horizontal and not also vertical scrolling. - FM
d6950 1
d6953 1
a6953 1
			temp[j] = (char) (temp[j+1] ? ' ' : '\0');
d6992 1
a6992 1
	     *	Make sure we had a select start tag.
d7001 1
a7001 1
	     *	Set to know that we are no longer in a select tag.
d7006 1
a7006 1
	     *	Clear the disable attribute.
d7011 1
a7011 1
	     *	Make sure we're in a form.
d7018 1
a7018 1
		 *  Hopefully won't crash, so we'll ignore it. - kw
d7023 1
a7023 1
	     *	Finish the data off.
d7027 1
a7027 1
	     *	Finish the previous option.
d7042 4
a7045 4
		    /*
		     *	Start a newline after the last checkbox/button option.
		     */
		    LYEnsureSingleSpace(me);
d7048 2
a7049 2
		 *  Output popup box with the default option to screen,
		 *  but use non-breaking spaces for output.
d7056 3
a7058 3
		     *	The code inadequately handles OPTION fields in PRE tags.
		     *	We'll put up a minimum of 6 characters, and if any
		     *	more would exceed the wrap column, we'll ignore them.
d7062 1
a7062 1
			    HText_appendCharacter(me->text,HT_NON_BREAK_SPACE);
d7064 1
a7064 1
			    HText_appendCharacter(me->text,*ptr);
d7071 1
a7071 1
			HText_appendCharacter(me->text,HT_NON_BREAK_SPACE);
d7075 1
d7082 1
a7082 1
			HText_appendCharacter(me->text,*ptr);
d7090 1
a7090 1
		 *  Add end option character.
d7118 1
a7118 1
	me->inTABLE = FALSE;
d7127 1
a7127 1
				me->DivisionAlignments[me->Division_Level];
d7150 1
a7150 1
	    HText_setLastChar(me->text, ' ');  /* absorb next white space */
d7181 2
a7182 2
	 *  We're getting it as Literal text, which, until we can process
	 *  it, we'll display as is, within brackets to alert the user. - FM
d7204 1
a7204 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d7207 1
a7207 1
    } /* switch */
d7210 2
a7211 2
	    if (reached_awaited_stacked_elt)
		wait_for_this_stacked_elt=-1;
a7218 1

d7220 1
a7220 1
    if (!skip_stack_requested) { /*don't emit stylechanges if skipped stack element - VH*/
d7228 1
a7228 2
	if (!ReallyEmptyTagNum(element_number))
	{
d7230 3
a7232 2
		    (tfp, "STYLE.end_element: ending non-\"EMPTY\" style <%s...>\n",
			  HTML_dtd.tags[element_number].name));
d7241 2
a7242 2
**		------------------
*/
d7245 1
a7245 1
int HTML_put_entity (HTStructured * me, int entity_number)
d7257 11
a7267 11
**	-------------------
**
**	If the document is empty, the text object will not yet exist.
**	So we could in fact abandon creating the document and return
**	an error code.	In fact an empty document is an important type
**	of document, so we don't.
**
**	If non-interactive, everything is freed off.   No: crashes -listrefs
**	Otherwise, the interactive object is left.
*/
static void HTML_free (HTStructured * me)
d7273 3
a7275 4
	 *  We only handled MAP, AREA and BASE tags, and didn't
	 *  create an HText structure for the document nor want
	 *  one now, so just make sure we free anything that might
	 *  have been allocated. - FM
d7290 6
a7295 7
	 *  Emphasis containers, A, FONT, and FORM may be declared
	 *  SGML_EMPTY in HTMLDTD.c, and SGML_character() in SGML.c
	 *  may check for their end tags to call HTML_end_element()
	 *  directly (with a check in that to bypass decrementing
	 *  of the HTML parser's stack).  So if we still have the
	 *  emphasis (Underline) on, or any open A, FONT, or FORM
	 *  containers, turn it off or close them now. - FM & kw
d7297 5
a7301 6
	 *  IF those tags are not declared SGML_EMPTY, but we let
	 *  the SGML.c parser take care of correctly stacked ordering,
	 *  and of correct wind-down on end-of-stream (in SGML_free
	 *  SGML_abort),
	 *  THEN these and other checks here in HTML.c should not be
	 *  necessary.	Still it can't hurt to include them. - kw
d7324 3
a7326 3
	     *	If we still have data in the me->option chunk after
	     *	forcing a close of a still-open form, something must
	     *	have gone very wrong. - kw
d7333 2
a7334 2
	     *	Output the left-over data as text, maybe it was invalid
	     *	markup meant to be shown somewhere. - kw
d7337 1
a7337 1
			me->option.data));
d7343 3
a7345 3
	     *	If we still have data in the me->textarea chunk after
	     *	forcing a close of a still-open form, something must
	     *	have gone very wrong. - kw
d7352 2
a7353 2
	     *	Output the left-over data as text, maybe it was invalid
	     *	markup meant to be shown somewhere. - kw
d7356 1
a7356 1
			me->textarea.data));
d7361 3
a7363 3
	 *  If we're interactive and have hidden links but no visible
	 *  links, add a message informing the user about this and
	 *  suggesting use of the 'l'ist command. - FM
d7372 1
a7372 1
		gettext("Document has only hidden links.  Use the 'l'ist command."));
d7384 1
a7384 1
	 *  Now call the cleanup function. - FM
d7390 2
a7391 3
	 *  If we still have data in the me->option chunk after
	 *  forcing a close of a still-open form, something must
	 *  have gone very wrong. - kw
d7399 1
a7399 1
			 me->option.data));
d7405 3
a7407 3
	 *  If we still have data in the me->textarea chunk after
	 *  forcing a close of a still-open form, something must
	 *  have gone very wrong. - kw
d7415 1
a7415 1
			 me->textarea.data));
d7421 1
a7421 1
	(*me->targetClass._free)(me->target);
d7431 1
a7431 1
	} else	{
d7443 1
a7443 1
static void HTML_abort (HTStructured * me, HTError e)
d7449 2
a7450 2
	 *  If we have emphasis on, or open A, FONT, or FORM
	 *  containers, turn it off or close them now. - FM
d7471 1
a7471 1
	 *  Now call the cleanup function. - FM
d7478 2
a7479 3
	 *  If we still have data in the me->option chunk after
	 *  forcing a close of a still-open form, something must
	 *  have gone very wrong. - kw
d7482 2
a7483 1
	    CTRACE((tfp, "HTML_abort: SELECT or OPTION not ended properly *****\n"));
d7486 1
a7486 1
			 me->option.data));
d7492 3
a7494 3
	 *  If we still have data in the me->textarea chunk after
	 *  forcing a close of a still-open form, something must
	 *  have gone very wrong. - kw
d7500 1
a7500 1
			 me->textarea.data));
d7506 1
a7506 1
	(*me->targetClass._abort)(me->target, e);
d7516 1
a7516 1
	} else	{
d7534 3
a7536 3
**	---------------------------
*/
static void get_styles (void)
d7538 1
a7538 2
    HTStyle** st = NULL;
    styleSheet = DefaultStyle(&st);  /* sets st[] array */
d7540 1
a7540 1
    default_style =		st[ST_Normal];
d7542 24
a7565 22
    styles[HTML_H1] =		st[ST_Heading1];
    styles[HTML_H2] =		st[ST_Heading2];
    styles[HTML_H3] =		st[ST_Heading3];
    styles[HTML_H4] =		st[ST_Heading4];
    styles[HTML_H5] =		st[ST_Heading5];
    styles[HTML_H6] =		st[ST_Heading6];
    styles[HTML_HCENTER] =	st[ST_HeadingCenter];
    styles[HTML_HLEFT] =	st[ST_HeadingLeft];
    styles[HTML_HRIGHT] =	st[ST_HeadingRight];

    styles[HTML_DCENTER] =	st[ST_DivCenter];
    styles[HTML_DLEFT] =	st[ST_DivLeft];
    styles[HTML_DRIGHT] =	st[ST_DivRight];

    styles[HTML_DL] =		st[ST_Glossary];
	/* nested list styles */
    styles[HTML_DL1] =		st[ST_Glossary1];
    styles[HTML_DL2] =		st[ST_Glossary2];
    styles[HTML_DL3] =		st[ST_Glossary3];
    styles[HTML_DL4] =		st[ST_Glossary4];
    styles[HTML_DL5] =		st[ST_Glossary5];
    styles[HTML_DL6] =		st[ST_Glossary6];
d7568 8
a7575 8
    styles[HTML_OL] =		st[ST_List];
	/* nested list styles */
    styles[HTML_OL1] =		st[ST_List1];
    styles[HTML_OL2] =		st[ST_List2];
    styles[HTML_OL3] =		st[ST_List3];
    styles[HTML_OL4] =		st[ST_List4];
    styles[HTML_OL5] =		st[ST_List5];
    styles[HTML_OL6] =		st[ST_List6];
d7578 24
a7601 24
    styles[HTML_DIR] =		st[ST_Menu];
	/* nested list styles */
    styles[HTML_MENU1] =	st[ST_Menu1];
    styles[HTML_MENU2] =	st[ST_Menu2];
    styles[HTML_MENU3] =	st[ST_Menu3];
    styles[HTML_MENU4] =	st[ST_Menu4];
    styles[HTML_MENU5] =	st[ST_Menu5];
    styles[HTML_MENU6] =	st[ST_Menu6];

    styles[HTML_DLC] =		st[ST_GlossaryCompact];
	/* nested list styles */
    styles[HTML_DLC1] =		st[ST_GlossaryCompact1];
    styles[HTML_DLC2] =		st[ST_GlossaryCompact2];
    styles[HTML_DLC3] =		st[ST_GlossaryCompact3];
    styles[HTML_DLC4] =		st[ST_GlossaryCompact4];
    styles[HTML_DLC5] =		st[ST_GlossaryCompact5];
    styles[HTML_DLC6] =		st[ST_GlossaryCompact6];

    styles[HTML_ADDRESS] =	st[ST_Address];
    styles[HTML_BANNER] =	st[ST_Banner];
    styles[HTML_BLOCKQUOTE] =	st[ST_Blockquote];
    styles[HTML_BQ] =		st[ST_Bq];
    styles[HTML_FN] =		st[ST_Footnote];
    styles[HTML_NOTE] =		st[ST_Note];
d7603 3
a7605 3
    styles[HTML_XMP] =		st[ST_Example];
    styles[HTML_PRE] =		st[ST_Preformatted];
    styles[HTML_LISTING] =	st[ST_Listing];
d7612 1
a7612 1
HTStyle *LYstyles (int style_number)
d7623 3
a7625 3
**	-----------------------
*/
const HTStructuredClass HTMLPresentation = /* As opposed to print etc */
d7627 6
a7632 6
	"Lynx_HTML_Handler",
	HTML_free,
	HTML_abort,
	HTML_put_character,	HTML_put_string,  HTML_write,
	HTML_start_element,	HTML_end_element,
	HTML_put_entity
d7636 8
a7643 9
**		--------------------------
**
**	The structured stream can generate either presentation,
**	or plain text, or HTML.
*/
HTStructured* HTML_new (
	HTParentAnchor *	anchor,
	HTFormat		format_out,
	HTStream*		stream)
d7646 1
a7646 1
    HTStructured * me;
d7649 3
a7651 2
	HTStream * intermediate = HTStreamStack(WWW_HTML, format_out,
						stream, anchor);
d7656 1
a7656 1
	exit_immediately (EXIT_FAILURE);
d7724 2
a7725 2
    me->sp->tag_number = -1;				/* INVALID */
    me->sp->style = default_style;			/* INVALID */
d7738 1
a7738 1
     *	Used for nested lists. - FM
d7740 4
a7743 4
    me->List_Nesting_Level = -1; /* counter for list nesting level */
    LYZero_OL_Counter(me);	 /* Initializes OL_Counter[] and OL_Type[] */
    me->Last_OL_Count = 0;	 /* last count in ordered lists */
    me->Last_OL_Type = '1';	 /* last type in ordered lists */
d7784 5
a7788 5
    **	Create a chartrans stage info structure for the anchor,
    **	if it does not exist already (in which case the default
    **	MIME stage info will be loaded as well), and load the
    **	HTML stage info into me->UCI and me->UCLYhndl. - FM
    */
d7793 3
a7795 4
    **	Load the existing or default input charset info
    **	into the holding elements.  We'll believe what
    **	is indicated for UCT_STAGE_PARSER. - FM
    */
d7809 4
a7812 5
    **	Load the existing or default output charset info
    **	into the holding elements, UCT_STAGE_STRUCTURED
    **	should be the same as UCT_STAGE_TEXT at this point,
    **	but we could check, perhaps. - FM
    */
d7820 1
a7820 1
	me->targetClass = *stream->isa;			/* Copy pointers */
d7822 1
a7822 1
    return (HTStructured*) me;
d7828 5
a7832 5
 *  A flag set by a file write error.  Used for only generating an alert
 *  the first time such an error happens, since Lynx should still be usable
 *  if the temp space becomes full, and an alert each time a cache file
 *  cannot be written would be annoying.  Reset when  lynx.cfg is being
 *  reloaded (user may change SOURCE_CACHE setting). - kw
d7840 1
a7840 2
static void CacheThru_do_free (
	HTStream *me)
d7850 1
a7850 1
		(void *)me->anchor->source_cache_chunk));
d7863 1
a7863 1
		    me->filename, HTAnchor_address((HTAnchor *)me->anchor)));
d7885 1
a7885 1
		(void *)me->chunk, HTAnchor_address((HTAnchor *)me->anchor)));
d7889 1
a7889 2
static void CacheThru_free (
	HTStream *	me)
d7892 1
a7892 1
    (*me->actions->_free)(me->target);
d7896 1
a7896 3
static void CacheThru_abort (
	HTStream *	me,
	HTError	e)
d7908 3
a7910 2
	    CTRACE((tfp, "SourceCacheWriter: Removing active memory chunk %p\n",
		    (void *)me->chunk));
d7914 1
a7914 1
	me->status = HT_OK;	/*fake it*/
d7917 1
a7917 1
    (*me->actions->_abort)(me->target, e);
d7921 1
a7921 3
static void CacheThru_put_character (
	HTStream *	me,
	char		c_in)
d7932 1
a7932 1
    (*me->actions->put_character)(me->target, c_in);
d7935 1
a7935 3
static void CacheThru_put_string (
	HTStream *	me,
	const char *	str)
d7946 1
a7946 1
    (*me->actions->put_string)(me->target, str);
d7949 2
a7950 4
static void CacheThru_write (
	HTStream *	me,
	const char *	str,
	int		l)
d7963 1
a7963 1
    (*me->actions->put_block)(me->target, str, l);
d7976 2
a7977 3
static HTStream* CacheThru_new (
	HTParentAnchor *	anchor,
	HTStream *		target)
d7981 1
a7981 1
    HTProtocol *p = (HTProtocol *)anchor->protocol;
d7993 1
a7993 1
     && strcmp(p->name, "https") != 0) {
d8016 2
a8017 1
	    CTRACE((tfp, "SourceCacheWriter: If successful, will replace source cache file %s\n",
d8028 3
a8030 2
	    CTRACE((tfp, "SourceCacheWriter: Cannot open source cache file for URL %s\n",
		   HTAnchor_address((HTAnchor *)anchor)));
d8037 3
a8039 2
	CTRACE((tfp, "SourceCacheWriter: Caching source for URL %s in file %s\n",
		     HTAnchor_address((HTAnchor *)anchor), filename));
d8046 1
a8046 1
		    (void *)anchor->source_cache_chunk));
a8047 1

d8056 3
a8058 2
	CTRACE((tfp, "SourceCacheWriter: Caching source for URL %s in memory chunk %p\n",
	       HTAnchor_address((HTAnchor *)anchor), (void *)stream->chunk));
d8069 10
a8078 11
**	----------------------------------
**
**	This will convert from HTML to presentation or plain text.
**
**	It is registered in HTInit.c, but never actually used by lynx.
**	- kw 1999-03-15
*/
HTStream* HTMLToPlain (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink)
d8086 13
a8098 14
**	-----------------------------------------
**
**	This will preparse HTML and convert back to presentation or plain text.
**
**	It is registered in HTInit.c and used by lynx if invoked with
**	-preparsed.  The stream generated here will be fed with HTML text,
**	It feeds that to the SGML.c parser, which in turn feeds an HTMLGen.c
**	structured stream for regenerating flat text; the latter should
**	end up being handled as text/plain. - kw
*/
HTStream* HTMLParsedPresent (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink)
d8100 2
a8101 1
    HTStream * intermediate = sink;
d8104 4
a8107 4
	 *  Trick to prevent HTPlainPresent from translating again.
	 *  Temporarily change UCT_STAGE_PARSER setting in anchor
	 *  while the HTPlain stream is initialized, so that HTPlain
	 *  sees its input and output charsets as the same.  - kw
d8109 3
a8111 2
	int old_parser_cset = HTAnchor_getUCLYhndl(anchor,UCT_STAGE_PARSER);
	int structured_cset = HTAnchor_getUCLYhndl(anchor,UCT_STAGE_STRUCTURED);
d8113 1
a8113 1
	    structured_cset = HTAnchor_getUCLYhndl(anchor,UCT_STAGE_HTEXT);
d8119 4
a8122 4
		/*  same effect as
	    intermediate = HTPlainPresent(pres, anchor, NULL);
		    just written in a more general way:
		 */
d8126 1
a8126 1
		/*  this too should amount to calling HTPlainPresent: */
d8136 1
a8136 1
					UCT_SETBY_DEFAULT+1);
d8148 12
a8159 13
**	------------------------------
**
**	C code is like plain text but all non-preformatted code
**	is commented out.
**	This will convert from HTML to presentation or plain text.
**
**	It is registered in HTInit.c, but normally not used by lynx.
**	- kw 1999-03-15
*/
HTStream* HTMLToC (
	HTPresentation *	pres GCC_UNUSED,
	HTParentAnchor *	anchor,
	HTStream *		sink)
d8161 2
a8162 1
    HTStructured * html;
d8164 1
a8164 1
	(*sink->isa->put_string)(sink, "/* ");	/* Before even title */
d8169 1
a8169 1
	HTML_put_string(html,html->comment_start);
d8175 7
a8181 7
**	------------------
**
**	This will convert from HTML to presentation or plain text.
**
** (Comment from original libwww:)
**	Override this if you have a windows version
*/
d8183 3
a8185 4
HTStream* HTMLPresent (
	HTPresentation *	pres GCC_UNUSED,
	HTParentAnchor *	anchor,
	HTStream *		sink GCC_UNUSED)
d8195 17
a8211 17
**	------------------------------------------
**
**	The error message should be marked as an error so that
**	it can be reloaded later.
**	This implementation just throws up an error message
**	and leaves the document unloaded.
**	A smarter implementation would load an error document,
**	marking at such so that it is retried on reload.
**
** On entry,
**	sink	is a stream to the output device if any
**	number	is the HTTP error number
**	message is the human readable message.
**
** On exit,
**	returns a negative number to indicate lack of success in the load.
*/
d8216 2
a8217 4
int HTLoadError (
	HTStream *	sink GCC_UNUSED,
	int		number,
	const char *	message)
d8223 1
a8223 1
static char * MakeNewTitle (const char ** value, int src_type)
d8238 1
a8238 1
#ifdef SH_EX	/* 1998/04/02 (Thu) 16:02:00 */
d8249 6
a8254 6
	  if (AS_casecomp(ptr, ".gif") == 0)
	    *ptr = '\0';
	  else if (AS_casecomp(ptr, ".jpg") == 0)
	    *ptr = '\0';
	  else if (AS_casecomp(ptr, ".jpeg") == 0)
	    *ptr = '\0';
d8264 1
a8264 1
static char * MakeNewImageValue (const char ** value)
d8280 1
a8280 1
static char * MakeNewMapValue (const char ** value, const char* mapstr)
d8286 3
a8288 3
    StrAllocCat(newtitle,mapstr); /* ISMAP or USEMAP */
    if ( verbose_img && value[HTML_IMG_SRC] && *value[HTML_IMG_SRC] ) {
	StrAllocCat(newtitle,":");
@


1.5
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d84 1
a84 1
    CONST HTStreamClass *	isa;
d90 1
a90 1
    CONST HTStreamClass *	actions;
d98 1
a98 1
PRIVATE HTStyleSheet * styleSheet = NULL;	/* Application-wide */
d102 1
a102 1
PRIVATE HTStyle *styles[HTML_ELEMENTS+LYNX_HTML_EXTRA_ELEMENTS];
d106 1
a106 1
PRIVATE HTStyle *default_style = NULL;
d108 1
a108 1
PUBLIC char *LYToolbarName = "LynxPseudoToolbar";
d111 1
a111 1
PRIVATE int i_prior_style = -1;
d117 1
a117 1
PRIVATE int HTML_end_element PARAMS((HTStructured *me,
d119 1
a119 1
				      char **include));
d121 1
a121 1
PRIVATE int HTML_start_element PARAMS((
d124 2
a125 2
	CONST BOOL*		present,
	CONST char **		value,
d127 1
a127 1
	char **			include));
d135 3
a137 3
PRIVATE char* MakeNewTitle PARAMS((CONST char ** value, int src_type));
PRIVATE char* MakeNewImageValue PARAMS((CONST char ** value));
PRIVATE char* MakeNewMapValue PARAMS((CONST char ** value, CONST char* mapstr));
d145 1
a145 1
PUBLIC void strtolower ARGS1(char*, i)
d163 1
a163 1
PUBLIC void actually_set_style ARGS1(HTStructured *, me)
d189 1
a189 1
PRIVATE void change_paragraph_style ARGS2(HTStructured *, me, HTStyle *,style)
d198 2
a199 2
PUBLIC BOOL LYBadHTML ARGS1(
    HTStructured *,	me)
d229 1
a229 1
PUBLIC void HTML_put_character ARGS2(HTStructured *, me, char, c)
d438 1
a438 1
PUBLIC void HTML_put_string ARGS2(HTStructured *, me, CONST char *, s)
d450 1
a450 1
	s = (CONST char *) translated_string;
d520 1
a520 1
	    CONST char *p = s;
d597 1
a597 1
PUBLIC void HTML_write ARGS3(HTStructured *, me, CONST char*, s, int, l)
d599 2
a600 2
    CONST char* p;
    CONST char* e = s+l;
d667 4
a670 4
PRIVATE char* Style_className = 0;
PRIVATE char* Style_className_end = 0;
PRIVATE unsigned Style_className_len = 0;
PRIVATE int hcode;
d673 1
a673 1
PRIVATE void free_Style_className NOARGS
d679 4
a682 4
PRIVATE void addClassName ARGS3(
	CONST char *,	prefix,
	CONST char *,	actual,
	int,		length)
d715 5
a719 5
PRIVATE void HTMLSRC_apply_markup ARGS4(
	    HTStructured *,   context,
	    HTlexeme,	      lexeme,
	    BOOL,	      start,
	    int,	      tag_charset)
d738 1
a738 1
		(CONST char **)ts->value,
a751 1
#if defined(__STDC__) || defined(_WIN_CC)
a753 4
#else
#  define PSRCSTART(x)	HTMLSRC_apply_markup(me,HTL_/**/x,START,tag_charset)
#  define PSRCSTOP(x)  HTMLSRC_apply_markup(me,HTL_/**/x,STOP,tag_charset)
#endif
d760 6
a765 6
PRIVATE void LYStartArea ARGS5(
	HTStructured *,		obj,
	CONST char *,		href,
	CONST char *,		alt,
	CONST char *,		title,
	int,			tag_charset)
d768 1
a768 1
    CONST char *	new_value[HTML_AREA_ATTRIBUTES];
d776 1
a776 1
	new_value[HTML_AREA_ALT] = (CONST char *)alt;
d780 1
a780 1
	new_value[HTML_AREA_TITLE] = (CONST char *)title;
d784 1
a784 1
	new_value[HTML_AREA_HREF] = (CONST char *)href;
d791 11
a801 11
PRIVATE void LYHandleFIG ARGS10(
	HTStructured *,		me,
	CONST BOOL*,		present,
	CONST char **,		value,
	BOOL,			isobject,
	BOOL,			imagemap,
	CONST char *,		id,
	CONST char *,		src,
	BOOL,			convert,
	BOOL,			start,
	BOOL *,			intern_flag GCC_UNUSED)
d868 2
a869 2
PRIVATE void clear_objectdata ARGS1(
	HTStructured *,		me)
d898 7
a904 7
PRIVATE int HTML_start_element ARGS6(
	HTStructured *,		me,
	int,			element_number,
	CONST BOOL*,		present,
	CONST char **,		value,
	int,			tag_charset,
	char **,		include)
d916 1
a916 1
    CONST char *Base = NULL;
d937 1
a937 1
	    CONST char* p;
d1102 1
a1102 1
	CONST char *type = "";
d1143 1
a1143 1
	    CONST char *related = NULL;
d4172 1
a4172 1
	    CONST char * accept_cs = NULL;
d5096 1
a5096 1
		       present, (CONST char **)value,
d5647 4
a5650 4
PRIVATE int HTML_end_element ARGS3(
	HTStructured *,		me,
	int,			element_number,
	char **,		include)
d6072 1
a6072 1
		 (CONST BOOL*)0, (CONST char **)0,
d7255 1
a7255 1
PUBLIC int HTML_put_entity ARGS2(HTStructured *, me, int, entity_number)
d7277 1
a7277 1
PRIVATE void HTML_free ARGS1(HTStructured *, me)
d7457 1
a7457 1
PRIVATE void HTML_abort ARGS2(HTStructured *, me, HTError, e)
d7550 1
a7550 1
PRIVATE void get_styles NOARGS
d7625 1
a7625 1
PUBLIC  HTStyle *LYstyles ARGS1(int, style_number)
d7638 1
a7638 1
PUBLIC CONST HTStructuredClass HTMLPresentation = /* As opposed to print etc */
d7654 4
a7657 4
PUBLIC HTStructured* HTML_new ARGS3(
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream*,		stream)
d7849 1
a7849 1
PUBLIC BOOLEAN source_cache_file_error = FALSE;
d7855 2
a7856 2
PRIVATE void CacheThru_do_free ARGS1(
	HTStream *,	me)
d7905 2
a7906 2
PRIVATE void CacheThru_free ARGS1(
	HTStream *,	me)
d7913 3
a7915 3
PRIVATE void CacheThru_abort ARGS2(
	HTStream *,	me,
	HTError,	e)
d7939 3
a7941 3
PRIVATE void CacheThru_put_character ARGS2(
	HTStream *,	me,
	char,		c_in)
d7955 3
a7957 3
PRIVATE void CacheThru_put_string ARGS2(
	HTStream *,	me,
	CONST char *,	str)
d7971 4
a7974 4
PRIVATE void CacheThru_write ARGS3(
	HTStream *,	me,
	CONST char *,	str,
	int,		l)
d7990 1
a7990 1
PRIVATE CONST HTStreamClass PassThruCache =
d8000 3
a8002 3
PRIVATE HTStream* CacheThru_new ARGS2(
	HTParentAnchor *,	anchor,
	HTStream *,		target)
d8098 4
a8101 4
PUBLIC HTStream* HTMLToPlain ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d8119 4
a8122 4
PUBLIC HTStream* HTMLParsedPresent ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d8179 4
a8182 4
PUBLIC HTStream* HTMLToC ARGS3(
	HTPresentation *,	pres GCC_UNUSED,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d8205 4
a8208 4
PUBLIC HTStream* HTMLPresent ARGS3(
	HTPresentation *,	pres GCC_UNUSED,
	HTParentAnchor *,	anchor,
	HTStream *,		sink GCC_UNUSED)
d8239 4
a8242 4
PUBLIC int HTLoadError ARGS3(
	HTStream *,	sink GCC_UNUSED,
	int,		number,
	CONST char *,	message)
d8248 1
a8248 1
PRIVATE char * MakeNewTitle ARGS2(CONST char **, value, int, src_type)
d8289 1
a8289 1
PRIVATE char * MakeNewImageValue ARGS1(CONST char **, value)
d8305 1
a8305 1
PRIVATE char * MakeNewMapValue ARGS2(CONST char **, value, CONST char*, mapstr)
@


1.4
log
@First step of lynx-2.8.5-dev16c merger
@
text
@a62 5
#define OPT_SCN 1
#define OMIT_SCN_KEEPING 0 /* whether to omit keeping of Style_className
    when lss support is on. 1 to increase performance. The value must
    correspond to one in LYCurses.c. Should be 0 if OPT_SCN=0 */

d71 1
a71 1
#ifdef SOURCE_CACHE
d85 1
a85 1
#ifdef SOURCE_CACHE
d148 1
a148 1
    while (*i) { *i=(char)tolower(*i); i++; }
d667 43
a709 9
# if !OPT_SCN
static char* Style_className = NULL;
static char myHash[128];
# else
PRIVATE char Style_className[4096];/* i hope it's enough :) HV */
PRIVATE char* Style_className_end=Style_className;/*this points to the
		    end of string in Style_className (it points to '\0') */
# endif
static int hcode;
d933 1
a933 1
    char* class_name;
a934 6
#  if OPT_SCN
#    if !OMIT_SCN_KEEPING
    char* Style_className_end_was = Style_className_end+1;
#    endif
    /* assume ';' will be appended*/
#  endif
d1052 4
a1055 11
#if !OPT_SCN
    HTSprintf (&Style_className, ";%s", HTML_dtd.tags[element_number].name);
#else
# if !OMIT_SCN_KEEPING
    *Style_className_end=';';
    memcpy(Style_className_end+1,
	   HTML_dtd.tags[element_number].name,
	   HTML_dtd.tags[element_number].name_len+1);
    Style_className_end += HTML_dtd.tags[element_number].name_len+1;
# endif
#endif
a1069 3
#if !OPT_SCN
	strcpy (myHash, HTML_dtd.tags[element_number].name);
#else
d1071 1
a1071 3
#endif
	if (class_name[0])
	{
a1072 12
	    char *oend = Style_className_end;
#if !OPT_SCN
	    int len = strlen(myHash);
	    sprintf(myHash, ".%.*s", (int)sizeof(myHash) - len - 2, class_name);
	    HTSprintf (&Style_className, ".%s", class_name);
#else
#   if !OMIT_SCN_KEEPING
	    int l = strlen(class_name);
	    *Style_className_end = '.';
	    memcpy(Style_className_end+1, class_name, l+1 );
	    Style_className_end += l+1;
#   endif
a1075 1
#endif
a1077 1
		*oend = '\0';
d1082 2
a1090 4
#if !OPT_SCN
	strtolower(myHash);
	hcode = hash_code(myHash);
#endif
a1092 22
#if !OPT_SCN
    if (TRACE)
    {
	CTRACE((tfp, "CSSTRIM:%s -> %d", myHash, hcode));
	if (hashStyles[hcode].code != hcode) {
	    char *rp = strrchr(myHash, '.');
	    CTRACE((tfp, " (undefined) %s\n", myHash));
	    if (rp) {
		int hcd;
		*rp = '\0'; /* trim the class */
		hcd = hash_code(myHash);
		CTRACE((tfp, "CSS:%s -> %d", myHash, hcd));
		if (hashStyles[hcd].code!=hcd)
		    CTRACE((tfp, " (undefined) %s\n", myHash));
		else
		    CTRACE((tfp, " ca=%d\n", hashStyles[hcd].color));
	    }
	} else {
	    CTRACE((tfp, " ca=%d\n", hashStyles[hcode].color));
	}
    }
#endif
d1095 1
a1095 12
#if !OPT_SCN
	    int len = strlen(myHash);
	    sprintf(myHash, ".%.*s", (int)sizeof(myHash) - len - 2, class_name);
	    HTSprintf (&Style_className, ".%s", class_name);
#else
#     if !OMIT_SCN_KEEPING
	    int l = strlen(class_name);
	    *Style_className_end = '.';
	    memcpy(Style_className_end+1,class_name, l + 1 );
	    Style_className_end += l + 1;
#     endif
#endif
d1105 1
a1105 10
#if !OPT_SCN
    strtolower(Style_className);
#else
#  if !OMIT_SCN_KEEPING
    strtolower(Style_className_end_was);/*only the part that wasn't
					  lowercased yet*/
#   endif
#endif

#if OPT_SCN && !OMIT_SCN_KEEPING	/* Can be done in other cases too... */
d1108 1
a1108 2
	char *oend = Style_className_end;
	int l, ohcode = hcode;
a1111 1
	l = strlen(type);
a1112 4
	*Style_className_end = '.';
	memcpy(Style_className_end+1, "type.", 5 );
	memcpy(Style_className_end+6, type, l+1 );
	Style_className_end += l+6;
a1116 1
	    *oend = '\0';
d1121 2
d1128 1
a1128 1
#endif	/* OPT_SCN && !OMIT_SCN_KEEPING */
d4560 1
a4560 1
#ifndef EXP_FILE_UPLOAD
d4568 1
a4568 1
#endif /* EXP_FILE_UPLOAD */
d4729 1
a4729 1
#ifdef EXP_FILE_UPLOAD
d4836 1
a4836 1
#ifndef EXP_FILE_UPLOAD
d4913 1
a4913 1
#ifndef EXP_FILE_UPLOAD
a5626 4
#if !OPT_SCN
	TrimColorClass(HTML_dtd.tags[element_number].name,
		       Style_className, &hcode);
#else
a5632 1
#endif
a7235 4
#if !OPT_SCN
	TrimColorClass(HTML_dtd.tags[element_number].name,
		       Style_className, &hcode);
#else
a7241 1
#endif
a7454 5
#ifdef USE_COLOR_STYLE
# if !OPT_SCN
    FREE(Style_className);
# endif
#endif
a7539 5
#ifdef USE_COLOR_STYLE
# if !OPT_SCN
    FREE(Style_className);
# endif
#endif
d7792 6
a7797 5
# if !OPT_SCN
    FREE(Style_className);
# else
    Style_className_end = Style_className;
# endif
d7845 1
a7845 1
#ifdef SOURCE_CACHE
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d2915 3
a2917 1
	    CHECK_FOR_INTERN(intern_flag,href);  /*NULL, '\0', or '#'*/
a2919 2
		if (isEmpty(href))
		    StrAllocCopy(href, "#");
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a37 1
#include <HTFont.h>
d51 1
a51 1
#ifdef USE_PSRC
d80 3
a87 8
extern BOOL HTPassEightBitRaw;
extern HTCJKlang HTCJK;

extern BOOLEAN HT_Is_Gopher_URL;

/* from Curses.h */
extern int LYcols;

d91 1
d93 1
d97 1
d107 2
a108 1
PRIVATE HTStyle *styles[HTML_ELEMENTS+31]; /* adding 24 nested list styles  */
d122 1
a122 1
PRIVATE void HTML_end_element PARAMS((HTStructured *me,
d126 1
a126 1
PRIVATE void HTML_start_element PARAMS((
a149 2
extern int hash_code PARAMS((char* i));

d152 2
a153 2
	if (!i) return;
	while (*i) { *i=tolower(*i); i++; }
d203 11
d240 1
a240 1
    if (LYMapsOnly)
d367 1
a367 1
	if (!strcmp(me->sp->style->name,"Preformatted")) {
d377 2
a378 2
	} else if (!strcmp(me->sp->style->name,"Listing") ||
		   !strcmp(me->sp->style->name,"Example")) {
d445 1
a445 1
#ifdef USE_PSRC
d449 1
a449 1
    if (LYMapsOnly || s == NULL)
d451 1
a451 1
#ifdef USE_PSRC
d456 1
a456 1
    };
d510 12
d556 1
a556 1
				me->in_word = NO;
d591 1
a591 1
#ifdef USE_PSRC
d607 1
a607 1
    if (LYMapsOnly)
d610 1
a610 1
    for (p = s; s < e; p++)
a657 1
#ifndef DONT_TRACK_INTERNAL_LINKS
d663 2
a664 2
   for overriding non-caching similar to LYoverride_no_cache. - kw */
#define CHECK_FOR_INTERN(s) intern_flag = (s && (*s=='#' || *s=='\0')) ? TRUE : FALSE;
d668 1
a668 3
#define INTERN_LT (HTLinkType *)(intern_flag ? LINK_INTERNAL : NULL)

#else  /* !DONT_TRACK_INTERNAL_LINKS */
a669 4
#define CHECK_FOR_INTERN(s)  /* do nothing */ ;
#define INTERN_LT (HTLinkType *)NULL

#endif /* DONT_TRACK_INTERNAL_LINKS */
d684 1
a684 1
#ifdef USE_PSRC
d688 1
a688 1
	    HTlexem,	      lexem,
d692 1
a692 1
    HT_tagspec* ts = *( ( start ? lexem_start : lexem_end ) + lexem);
d703 1
a703 1
	CTRACE(tfp,ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n",(int)lexem);
d722 2
d726 4
d734 136
a869 1
#endif /* USE_PSRC*/
d874 1
a874 1
PRIVATE void HTML_start_element ARGS6(
d892 2
a893 1
    int dest_char_set = UCLYhndl_for_unrec;
a895 1
    BOOL UseBASE = TRUE;		     /* Resoved vs. BASE if present? */
d899 1
a899 1
    int ElementNumber = element_number;
d901 2
d905 1
d914 1
a914 1
#ifdef USE_PSRC
d921 1
a921 1
		psrc_first_tag=FALSE;
d927 3
a929 3
		psrc_nested_call=TRUE;
		HTML_start_element(me,HTML_BODY, NULL,NULL,tag_charset,NULL);
		HTML_start_element(me,HTML_PRE, NULL,NULL,tag_charset,NULL);
d931 1
a931 1
		psrc_nested_call=FALSE;
d934 1
a934 1
	    psrc_nested_call=TRUE;
d941 1
a941 1
		strcpy(buf,tag->name);
d953 1
a953 1
			    strcpy(buf,tag->attributes[i].name);
d960 1
a960 1
			    char kind= ( !strchr(value[i], '"') ?
d998 1
a998 1
	    return;
d1002 1
a1002 1
#endif /* USE_PSRC */
d1006 3
a1008 2
	      ElementNumber == HTML_BASE)) {
	    return;
d1019 3
a1021 3
	    CTRACE(tfp, "me->tag_charset: %d -> %d", me->tag_charset, j );
	    CTRACE(tfp, " (me->UCLYhndl: %d, tag_charset: %d)\n",
		   me->UCLYhndl, tag_charset);
a1033 1
    /*strcpy(Style_className_end+1,HTML_dtd.tags[element_number].name);*/
d1051 1
d1053 1
a1053 1
    if (current_tag_style == -1) {
d1057 1
a1057 1
	hcode=hash_code_lowercase_on_fly(HTML_dtd.tags[element_number].name);
d1061 2
d1064 2
a1066 2
	    strcat (myHash, ".");
	    strcat (myHash, class_name);
a1067 1

d1069 1
a1069 1
	    int l=strlen(class_name);
d1078 12
d1091 1
d1101 5
a1105 7
	fprintf(tfp, "CSSTRIM:%s -> %d", myHash, hcode);
	if (hashStyles[hcode].code!=hcode)
	{
	    char *rp=strrchr(myHash, '.');
	    fprintf(tfp, " (undefined) %s\n", myHash);
	    if (rp)
	    {
d1107 1
a1107 1
		*rp='\0'; /* trim the class */
d1109 1
a1109 1
		fprintf(tfp, "CSS:%s -> %d", myHash, hcd);
d1111 1
a1111 1
		    fprintf(tfp, " (undefined) %s\n", myHash);
d1113 1
a1113 1
		    fprintf(tfp, " ca=%d\n", hashStyles[hcd].color);
d1115 2
a1117 2
	else
	    fprintf(tfp, " ca=%d\n", hashStyles[hcode].color);
a1119 7

	/* seems that this condition is always true - HV */
	if (displayStyles[element_number + STARTAT].color > -2) /* actually set */
	{
	    CTRACE(tfp, "CSSTRIM: start_element: top <%s>\n", HTML_dtd.tags[element_number].name);
	    HText_characterStyle(me->text, hcode, 1);
	}
d1123 2
a1125 2
	    strcat (myHash, ".");
	    strcat (myHash, class_name);
d1129 3
a1131 3
	    *Style_className_end='.';
	    memcpy(Style_className_end+1,class_name, l+1 );
	    Style_className_end+=l+1;
d1137 3
a1139 1
	HText_characterStyle(me->text, hcode , 1);
d1152 29
d1182 1
a1182 1

d1200 1
a1200 1
	    char *related = NULL;
d1203 2
d1206 2
a1207 2
		CTRACE(tfp, "HTML: BASE '%s' is not an absolute URL.\n",
			    (base ? base : ""));
d1222 3
a1224 8
		temp = HTParse(base + 11, "",
			       PARSE_ACCESS+PARSE_HOST+PARSE_PATH
			       +PARSE_PUNCTUATION);
		if (temp) {
		    FREE(base);
		    base = temp;
		    temp = NULL;
		}
d1230 1
a1230 1
	    StrAllocCopy(related, me->node_anchor->address);
d1235 2
a1236 9
	    if ((temp = HTParse(base, related,
				PARSE_ACCESS+PARSE_PUNCTUATION)) &&
		*temp != '\0') {
		StrAllocCopy(me->base_href, temp);
	    } else {
		FREE(temp);
		StrAllocCopy(me->base_href, (temp = HTParse(related, "",
					 PARSE_ACCESS+PARSE_PUNCTUATION)));
	    }
d1242 2
a1243 3
	    if ((temp = HTParse(base, "",
				PARSE_HOST+PARSE_PUNCTUATION)) &&
		!strncmp(temp, "//", 2)) {
d1249 1
a1249 1
		if (!strcmp(me->base_href, "file:")) {
d1251 1
a1251 1
		} else if (strcmp(me->base_href, "news:")) {
a1257 1
	    FREE(related);
d1262 9
a1270 3
	    if ((temp = HTParse(base, "",
				PARSE_PATH+PARSE_PUNCTUATION)) &&
		*temp != '\0') {
d1272 1
a1272 1
	    } else if (!strcmp(me->base_href, "news:")) {
d1274 3
a1276 3
	    } else if (!strncmp(me->base_href, "news:", 5) ||
		       !strncmp(me->base_href, "nntp:", 5) ||
		       !strncmp(me->base_href, "snews:", 6)) {
d1285 1
d1287 3
a1302 1
#ifndef DONT_TRACK_INTERNAL_LINKS
a1303 1
#endif
d1305 1
a1305 1
	    CHECK_FOR_INTERN(value[HTML_LINK_HREF]);
d1310 4
a1313 5
		if (me->inBASE && me->base_href && *me->base_href) {
		    StrAllocCopy(href, me->base_href);
		} else {
		    StrAllocCopy(href, me->node_anchor->address);
		}
d1317 5
a1324 20
	     *	Check whether a base tag is in effect. - FM
	     */
	    if ((me->inBASE && *href != '\0' && *href != '#') &&
		(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		*temp != '\0')
		/*
		 *  Use reference related to the base.
		 */
		StrAllocCopy(href, temp);
	    FREE(temp);

	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&href,
			       ((*href != '\0' && *href != '#' &&
				 me->inBASE) ?
			       me->base_href : me->node_anchor->address));

	    /*
a1336 12
		    if (!is_url(href)) {
			temp = HTParse(href,
				       (me->inBASE ?
				     me->base_href : me->node_anchor->address),
					PARSE_ALL);
			StrAllocCopy(href, temp);
			FREE(temp);
			LYFillLocalFileURL(&href,
					   (me->inBASE ?
					 me->base_href :
					 me->node_anchor->address));
		    }
d1338 1
a1338 1
		    CTRACE(tfp, "HTML: DOC OWNER '%s' found\n", href);
d1368 4
a1372 4
/*  lss and css has different syntax - lynx shouldn't try to
    parse them now (it tries to parse them as lss, so it exits with
    error message the 1st non-empty line) - HVV
*/
d1376 2
a1377 32
		    CTRACE(tfp, "HTML: StyleSheet link found.\n");
#ifdef LINKEDSTYLES
		    if (href && *href != '\0')
		    {
			int res = -999;
			if ((url_type = is_url(href)) == 0 ||
			    (url_type == FILE_URL_TYPE && LYisLocalFile(href))) {
			    if (url_type == FILE_URL_TYPE) {
				temp = HTParse(href, "", PARSE_PATH+PARSE_PUNCTUATION);
				HTUnEscape(temp);
				if (temp && *temp != '\0') {
				    res = style_readFromFile(temp);
				    if (res != 0)
					StrAllocCopy(href, temp);
				}
				FREE(temp);
			    } else {
				res = style_readFromFile(href);
			    }
			}
			CTRACE(tfp, "CSS: StyleSheet=%s %d\n", href, res);
			if (res == 0)
			    HTAnchor_setStyle (me->node_anchor, href);
		    }
		    else {
			CTRACE(tfp,
				"        non-local StyleSheets not yet implemented.\n");
		    }
#else
		    CTRACE(tfp,
				"        StyleSheets not yet implemented.\n");
#endif
d1384 1
a1384 1
		 *  Ignore anything not registered in the the 28-Mar-95
d1449 8
d1458 2
a1459 2
		    CTRACE(tfp, "HTML: LINK with REL=\"%s\" ignored.\n",
				 value[HTML_LINK_REL]);
d1477 2
a1478 2
		CTRACE(tfp, "HTML: LINK with REL=\"%s\" and no HREF ignored.\n",
			    value[HTML_LINK_REL]);
d1529 1
a1529 1
			    HTAnchor_followMainLink((HTAnchor*)me->CurrentA)
d1533 5
a1537 1
		dest = NULL;
a1542 2
		    if (dest_char_set < 0)  /* recover if not defined :-( */
			dest_char_set = UCLYhndl_for_unspec; /* always >= 0 */
d1544 1
a1544 1
		if (dest)
d1561 6
d1577 2
a1578 1
		CTRACE(tfp, "CSSTRIM:link=%s\n", tmp);
a1602 3
	    char * action = NULL;
	    char * isindex_href = NULL;

d1610 1
a1610 1
		StrAllocCopy(isindex_href, value[HTML_ISINDEX_HREF]);
d1612 2
a1613 2
		StrAllocCopy(isindex_href, value[HTML_ISINDEX_ACTION]);
	    url_type = LYLegitimizeHREF(me, &isindex_href, TRUE, TRUE);
d1615 6
a1620 16
	    /*
	     *	Check whether a base tag is in effect.
	     */
	    if (me->inBASE && *isindex_href != '\0' && *isindex_href != '#')
		action = HTParse(isindex_href, me->base_href, PARSE_ALL);
	    if (!(action && *action))
		action = HTParse(isindex_href,
				 me->node_anchor->address, PARSE_ALL);
	    FREE(isindex_href);

	    if (action && *action) {
		HTAnchor_setIndex(me->node_anchor, action);
	    } else {
		HTAnchor_setIndex(me->node_anchor, me->node_anchor->address);
	    }
	    FREE(action);
d1623 3
a1625 10
	    if (me->inBASE)
		/*
		 *  Use base.
		 */
		HTAnchor_setIndex(me->node_anchor, me->base_href);
	    else
		/*
		 *  Use index's address.
		 */
		HTAnchor_setIndex(me->node_anchor, me->node_anchor->address);
a1649 2
	/* if (present && present[NEXTID_N] && value[NEXTID_N])
		HText_setNextId(me->text, atoi(value[NEXTID_N])); */
d1686 1
a1686 1
	    value[HTML_FRAME_SRC] && *value[HTML_FRAME_SRC] != '\0') {
d1688 1
a1688 22
	    CHECK_FOR_INTERN(href);
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    /*
	     *	Check whether a base tag is in effect. - FM
	     */
	    if ((me->inBASE && *href != '\0' && *href != '#') &&
		(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		*temp != '\0')
		/*
		 *  Use reference related to the base.
		 */
		StrAllocCopy(href, temp);
	    FREE(temp);

	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&href,
			       ((*href != '\0' && *href != '#' &&
				 me->inBASE) ?
			       me->base_href : me->node_anchor->address));
d1698 2
a1699 1
				INTERN_LT);		/* Type */
d1707 1
d1719 1
d1740 1
a1740 1
	    value[HTML_IFRAME_SRC] && *value[HTML_IFRAME_SRC] != '\0') {
d1742 1
a1742 22
	    CHECK_FOR_INTERN(href);
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    /*
	     *	Check whether a base tag is in effect. - FM
	     */
	    if ((me->inBASE && *href != '\0' && *href != '#') &&
		(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		*temp != '\0')
		/*
		 *  Use reference related to the base.
		 */
		StrAllocCopy(href, temp);
	    FREE(temp);

	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&href,
			       ((*href != '\0' && *href != '#' &&
				 me->inBASE) ?
			       me->base_href : me->node_anchor->address));
d1746 1
d1751 1
a1751 1
				INTERN_LT);		/* Type */
d1753 1
d1761 1
d1773 1
d1784 1
a1784 1
	if (me->sp->tag_number == ElementNumber)
d1810 1
a1810 1
	    CTRACE(tfp,
d1812 1
a1812 1
		MAX_NESTING);
d1814 2
d1821 20
d1895 2
a1896 1
	     me->sp[0].tag_number == HTML_DIR)) {
d1961 2
a1962 1
	LYHandleP(me, present, value, include, TRUE);
d1975 2
a1976 2
	     HText_PreviousLineSize(me->text, FALSE)) ||
	    HText_LastLineSize(me->text, FALSE)) {
d2008 1
a2008 1
	    if (HText_LastLineSize(me->text, FALSE)) {
d2011 1
a2011 1
	    } else if (!HText_PreviousLineSize(me->text, FALSE)) {
d2043 1
a2043 1
		isdigit(*value[HTML_HR_WIDTH]) &&
d2077 2
a2078 2
	    } else if (!strcmp(me->sp->style->name, "HeadingCenter") ||
		       !strcmp(me->sp->style->name, "Heading1")) {
d2080 1
a2080 1
	    } else if (!strcmp(me->sp->style->name, "HeadingRight")) {
d2103 1
a2103 1
	    CTRACE(tfp, "HTML: TAB tag has no attributes.  Ignored.\n");
d2106 7
d2115 1
d2124 1
a2124 1
	    CTRACE(tfp, "HTML: ALIGN not 'left'.  Using space instead of TAB.\n");
d2135 1
a2135 1
	    CTRACE(tfp, "HTML: Not HT_LEFT.  Using space instead of TAB.\n");
d2141 1
a2141 1
		    isdigit(*value[HTML_TAB_INDENT]))) {
d2157 1
a2157 1
		       isdigit(*value[HTML_TAB_INDENT])) {
d2171 1
d2175 1
a2175 1
		CTRACE(tfp, "HTML: Column out of bounds.  Using space instead of TAB.\n");
d2244 1
a2244 1
	    CTRACE(tfp, "Underline Level is %d\n", me->Underline_Level);
d2250 1
a2250 1
	    CTRACE(tfp,"Beginning underline\n");
d2252 1
a2252 1
	    CTRACE(tfp,"Underline Level is %d\n", me->Underline_Level);
a2265 2
    case HTML_SUB:
    case HTML_SUP:
d2271 10
d2330 1
d2332 1
d2334 1
d2347 1
a2347 1
	if (me->sp->tag_number == ElementNumber)
d2355 1
a2355 1
	if (me->sp->tag_number == ElementNumber)
d2387 1
d2390 1
d2399 1
a2399 1
	if (me->sp->tag_number == ElementNumber)
d2421 1
d2470 1
a2470 1
	    if (HText_LastLineSize(me->text, FALSE)) {
d2666 42
a2707 38
	if (me->sp[0].tag_number == HTML_OL) {
	    char number_string[20];
	    int counter, seqnum;
	    char seqtype;

	    counter = me->List_Nesting_Level < 11 ?
			   me->List_Nesting_Level : 11;
	    if (present && present[HTML_LI_TYPE] && value[HTML_LI_TYPE]) {
		if (*value[HTML_LI_TYPE] == '1') {
		    me->OL_Type[counter] = '1';
		} else if (*value[HTML_LI_TYPE] == 'A') {
		    me->OL_Type[counter] = 'A';
		} else if (*value[HTML_LI_TYPE] == 'a') {
		    me->OL_Type[counter] = 'a';
		} else if (*value[HTML_LI_TYPE] == 'I') {
		    me->OL_Type[counter] = 'I';
		} else if (*value[HTML_LI_TYPE] == 'i') {
		    me->OL_Type[counter] = 'i';
		}
	    }
	    if (present && present[HTML_LI_VALUE] &&
		((value[HTML_LI_VALUE] != NULL) &&
		 (*value[HTML_LI_VALUE] != '\0')) &&
		((isdigit(*value[HTML_LI_VALUE])) ||
		 (*value[HTML_LI_VALUE] == '-' &&
		  isdigit(*(value[HTML_LI_VALUE] + 1))))) {
		seqnum = atoi(value[HTML_LI_VALUE]);
		if (seqnum <= OL_VOID)
		    seqnum = OL_VOID + 1;
		seqtype = me->OL_Type[counter];
		if (seqtype != '1' && seqnum < 1)
		    seqnum = 1;
		me->OL_Counter[counter] = seqnum + 1;
	    } else if (me->OL_Counter[counter] >= OL_VOID) {
		seqnum = me->OL_Counter[counter]++;
		seqtype = me->OL_Type[counter];
		if (seqtype != '1' && seqnum < 1) {
		    seqnum = 1;
d2709 17
d2727 10
a2736 9
	    } else {
		seqnum = me->Last_OL_Count + 1;
		seqtype = me->Last_OL_Type;
		for (i = (counter - 1); i >= 0; i--) {
		    if (me->OL_Counter[i] > OL_VOID) {
			seqnum = me->OL_Counter[i]++;
			seqtype = me->OL_Type[i];
			i = 0;
		    }
d2738 10
a2747 22
	    }
	    if (seqtype == 'A') {
		sprintf(number_string, LYUppercaseA_OL_String(seqnum));
	    } else if (seqtype == 'a') {
		sprintf(number_string, LYLowercaseA_OL_String(seqnum));
	    } else if (seqtype == 'I') {
		sprintf(number_string, LYUppercaseI_OL_String(seqnum));
	    } else if (seqtype == 'i') {
		sprintf(number_string, LYLowercaseI_OL_String(seqnum));
	    } else {
		sprintf(number_string, "%2d.", seqnum);
	    }
	    me->Last_OL_Count = seqnum;
	    me->Last_OL_Type = seqtype;
	    /*
	     *	Hack, because there is no append string!
	     */
	    for (i = 0; number_string[i] != '\0'; i++)
		if (number_string[i] == ' ')
		    HTML_put_character(me, HT_NON_BREAK_SPACE);
		else
		    HTML_put_character(me, number_string[i]);
d2749 18
a2766 18
	    /*
	     *	Use HTML_put_character so that any other spaces
	     *	coming through will be collapsed.  We'll use
	     *	nbsp, so it won't break at the spacing character
	     *	if there are no spaces in the subsequent text up
	     *	to the right margin, but will declare it as a
	     *	normal space to ensure collapsing if a normal
	     *	space does immediately follow it. - FM
	     */
	    HTML_put_character(me, HT_NON_BREAK_SPACE);
	    HText_setLastChar(me->text, ' ');
	} else if (me->sp[0].tag_number == HTML_UL) {
	    /*
	     *	Hack, because there is no append string!
	     */
	    HTML_put_character(me, HT_NON_BREAK_SPACE);
	    HTML_put_character(me, HT_NON_BREAK_SPACE);
	    switch(me->List_Nesting_Level % 7) {
d2789 19
d2809 2
a2810 19
	    /*
	     *	Keep using HTML_put_character so that any other
	     *	spaces coming through will be collapsed.  We use
	     *	nbsp, so we won't wrap at the spacing character
	     *	if there are no spaces in the subsequent text up
	     *	to the right margin, but will declare it as a
	     *	normal space to ensure collapsing if a normal
	     *	space does immediately follow it. - FM
	     */
	    HTML_put_character(me, HT_NON_BREAK_SPACE);
	    HText_setLastChar(me->text, ' ');
	} else {
	    /*
	     *	Hack, because there is no append string!
	     */
	    HTML_put_character(me, HT_NON_BREAK_SPACE);
	    HTML_put_character(me, HT_NON_BREAK_SPACE);
	    HText_setLastChar(me->text, ' ');
	}
d2840 1
a2840 1
	if (me->sp->tag_number == ElementNumber)
d2849 1
d2856 19
d2902 1
a2902 1
	if (id_string) {
a2903 4
	    if (*id_string == '\0') {
		FREE(id_string);
	    }
	}
a2908 6
#ifndef DONT_TRACK_INTERNAL_LINKS
	    if (present[HTML_A_ISMAP])
		intern_flag = FALSE;
	    else
		CHECK_FOR_INTERN(value[HTML_A_HREF]);
#endif
d2910 1
a2910 1
	     *	Prepare to do housekeeping on the reference. - FM
d2912 4
a2915 11
	    if (!value[HTML_A_HREF] || *value[HTML_A_HREF] == '\0') {
		StrAllocCopy(href, me->node_anchor->address);
	    } else if (*value[HTML_A_HREF] == '#') {
		StrAllocCopy(href, me->node_anchor->address);
		if (strlen(value[HTML_A_HREF]) > 1) {
		    StrAllocCat(href, value[HTML_A_HREF]);
		}
	    } else {
		StrAllocCopy(href, value[HTML_A_HREF]);
	    }
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
d2917 4
a2920 9
	    /*
	     *	Deal with our ftp gateway kludge. - FM
	     */
	    if (!url_type && !strncmp(href, "/foo/..", 7) &&
		(!strncmp(me->node_anchor->address, "ftp:", 4) ||
		 !strncmp(me->node_anchor->address, "file:", 5))) {
		for (i = 0; (href[i] = href[i+7]) != 0; i++)
		    ;
	    }
d2922 2
a2923 4
	    /*
	     *	Set to know we are making the content bold.
	     */
	    me->inBoldA = TRUE;
a2924 6
	    /*
	     *	Check whether a base tag is in effect. - FM
	     */
	    if ((me->inBASE && *href != '\0' && *href != '#') &&
		(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		*temp != '\0')
d2926 1
a2926 1
		 *  Use reference related to the base.
d2928 7
a2934 2
		StrAllocCopy(href, temp);
	    FREE(temp);
d2936 2
a2937 7
	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&href,
			       ((*href != '\0' && *href != '#' &&
				 me->inBASE) ?
			       me->base_href : me->node_anchor->address));
d2943 1
a2943 1
#ifndef DONT_TRACK_INTERNAL_LINKS
d2946 5
a2950 4
	    if (!intern_flag && href &&
		!strcasecomp(value[HTML_A_TYPE], HTAtom_name(LINK_INTERNAL)) &&
		0 != strcmp(me->node_anchor->address, LYlist_temp_url()) &&
		0 != strncmp(me->node_anchor->address, "LYNXIMGMAP:", 11)) {
d2955 2
a2956 2
		CTRACE(tfp, "HTML: Found invalid HREF=\"%s\" TYPE=\"%s\"!\n",
			    href, temp);
a2959 1
#endif /* DONT_TRACK_INTERNAL_LINKS */
a2994 2
		if (dest_char_set < 0) /* recover if not defined :-( */
			dest_char_set = UCLYhndl_for_unspec; /* always >= 0 */
d2999 1
a2999 1
			HTAnchor_followMainLink((HTAnchor*)me->CurrentA)
d3006 3
a3008 1
	    if (dest) {
d3031 1
a3031 1
#ifdef NOTUSED_FOTEMODS
d3039 8
a3046 1
	    HTML_end_element(me, HTML_A, &include);
d3048 1
a3048 1
#endif /* NOTUSED_FOTEMODS */
d3061 1
a3061 1
			HTAnchor_followMainLink((HTAnchor*)me->CurrentA)
d3065 2
a3066 2
		    CTRACE(tfp, "HTML: '%s' is an ISMAP script\n",
				dest->address);
d3070 2
a3071 2
		    CTRACE(tfp, "HTML: Designating '%s' as an ISMAP script\n",
				dest->address);
a3075 1
#ifndef DONT_TRACK_INTERNAL_LINKS
a3076 1
#endif
d3083 1
a3083 1
	    CHECK_FOR_INTERN(map_href);
d3089 1
a3089 1
	    if (strchr(map_href, '#') == NULL) {
a3101 1
	    if (!url_type && me->inBASE) {
d3108 4
a3111 37
		if ((*map_href == '#' &&
		     LYSeekFragMAPinCur == TRUE)) {
		    /*
		     *	Use reference related to the current stream. - FM
		     */
		    temp = HTParse(map_href, me->node_anchor->address,
				    PARSE_ALL);
		    StrAllocCopy(map_href, temp);
		    UseBASE = FALSE;
		} else {
		    /*
		     *	Use reference related to the base. - FM
		     */
		    temp = HTParse(map_href, me->base_href, PARSE_ALL);
		    StrAllocCopy(map_href, temp);
		    UseBASE = TRUE;
		}
		FREE(temp);
	    }

	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&map_href,
			       ((UseBASE && me->inBASE) ?
			  me->base_href : me->node_anchor->address));
	    UseBASE = TRUE;

	    /*
	     *	If it's not yet a URL, resolve versus
	     *	the current document's address. - FM
	     */
	    if (!(url_type = is_url(map_href))) {
		temp = HTParse(map_href, me->node_anchor->address, PARSE_ALL);
		StrAllocCopy(map_href, temp);
		FREE(temp);
	    }
d3116 1
a3116 1
	    StrAllocCopy(temp, "LYNXIMGMAP:");
d3223 1
a3223 1
	CTRACE(tfp, "HTML IMG: USEMAP=%d ISMAP=%d ANCHOR=%d PARA=%d\n",
d3226 1
a3226 1
		    me->inA, me->inP);
d3245 1
a3245 1
	    value[HTML_IMG_SRC] && *value[HTML_IMG_SRC] != '\0') {
d3247 1
a3247 21
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    /*
	     *	Check whether a base tag is in effect. - FM
	     */
	    if ((me->inBASE && *href != '\0' && *href != '#') &&
		(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		*temp != '\0')
		/*
		 *  Use reference related to the base.
		 */
		StrAllocCopy(href, temp);
	    FREE(temp);

	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&href,
			       ((*href != '\0' && *href != '#' &&
				 me->inBASE) ?
			       me->base_href : me->node_anchor->address));
d3294 1
a3294 1
				HTAnchor_followMainLink((HTAnchor*)me->CurrentA)
d3356 1
a3356 1
				HTAnchor_followMainLink((HTAnchor*)me->CurrentA)
d3460 1
a3460 1
				HTAnchor_followMainLink((HTAnchor*)me->CurrentA)
d3532 10
d3554 1
a3554 1
	    if ((cp = strrchr(me->map_address, '#')) != NULL)
d3582 1
a3582 1
	    CHECK_FOR_INTERN(href);
d3592 4
a3595 29
	    if (((me->inBASE && *href != '\0') &&
		 !(*href == '#' && LYSeekFragAREAinCur == TRUE)) &&
		(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		*temp != '\0')
		/*
		 *  Use reference related to the base.
		 */
		StrAllocCopy(href, temp);
	    FREE(temp);

	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&href,
			       ((((me->inBASE && *href != '\0') &&
				  !(*href == '#' &&
				    LYSeekFragAREAinCur == TRUE)))
						?
				  me->base_href : me->node_anchor->address));
	    if (!(url_type = is_url(href))) {
		temp = HTParse(href, me->node_anchor->address, PARSE_ALL);
		if (!(temp && *temp)) {
		   FREE(href);
		   FREE(temp);
		   break;
		}
		StrAllocCopy(href, temp);
		FREE(temp);
	    }
d3661 13
a3673 64
	me->inFIG = TRUE;
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	if (!present ||
	    (present && !present[HTML_FIG_ISOBJECT])) {
	    LYEnsureDoubleSpace(me);
	    LYResetParagraphAlignment(me);
	    me->inFIGwithP = TRUE;
	} else {
	    me->inFIGwithP = FALSE;
	    HTML_put_character(me, ' ');  /* space char may be ignored */
	}
	CHECK_ID(HTML_FIG_ID);
	me->in_word = NO;
	me->inP = FALSE;

	if (clickable_images && present && present[HTML_FIG_SRC] &&
	    value[HTML_FIG_SRC] && *value[HTML_FIG_SRC] != '\0') {
	    StrAllocCopy(href, value[HTML_FIG_SRC]);
	    CHECK_FOR_INTERN(href);
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href) {
		/*
		 *  Check whether a base tag is in effect. - FM
		 */
		if ((me->inBASE && *href != '#') &&
		    (temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		    *temp != '\0')
		    /*
		     *	Use reference related to the base.
		     */
		    StrAllocCopy(href, temp);
		FREE(temp);

		/*
		 *  Check whether to fill in localhost. - FM
		 */
		LYFillLocalFileURL(&href,
				   ((*href != '#' &&
				     me->inBASE) ?
				   me->base_href : me->node_anchor->address));

		me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					INTERN_LT);		/* Type */
		HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		HTML_put_string(me, (present[HTML_FIG_ISOBJECT] ?
		      (present[HTML_FIG_IMAGEMAP] ?
					"(IMAGE)" : "(OBJECT)") : "[FIGURE]"));
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, 0);
		HTML_put_character(me, '-');
		HTML_put_character(me, ' '); /* space char may be ignored */
		me->in_word = NO;
	    }
	    FREE(href);
	}
d3780 75
a3854 3
	     *	Set flag that we are accumulating OBJECT content. - FM
	     */
	    me->object_started = TRUE;
d3861 1
a3861 1
	    value[HTML_OVERLAY_SRC] && *value[HTML_OVERLAY_SRC] != '\0') {
d3863 1
a3863 2
	    CHECK_FOR_INTERN(href);
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
a3864 19
		/*
		 *  Check whether a base tag is in effect. - FM
		 */
		if ((me->inBASE && *href != '#') &&
		    (temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		    *temp != '\0')
		    /*
		     *	Use reference related to the base.
		     */
		    StrAllocCopy(href, temp);
		FREE(temp);

		/*
		 *  Check whether to fill in localhost. - FM
		 */
		LYFillLocalFileURL(&href,
				   ((*href != '#' &&
				     me->inBASE) ?
				   me->base_href : me->node_anchor->address));
d3874 1
a3874 1
					INTERN_LT);		/* Type */
d3947 1
a3947 1
	    value[HTML_APPLET_CODE] && *value[HTML_APPLET_CODE] != '\0') {
a3948 1
	    char * code = NULL;
d3950 3
d3967 1
a3967 8
		url_type = LYLegitimizeHREF(me, &base, TRUE, FALSE);

		/*
		 *  Check whether to fill in localhost. - FM
		 */
		LYFillLocalFileURL(&base,
				   (me->inBASE ?
				 me->base_href : me->node_anchor->address));
d3969 1
a3969 19
		if (!(url_type = is_url(base))) {
		    /*
		     *	Check whether a base tag is in effect.
		     */
		    if (me->inBASE) {
			temp = HTParse(base, me->base_href, PARSE_ALL);
		    } else {
			temp = HTParse(base, me->node_anchor->address,
							PARSE_ALL);
		    }
		    StrAllocCopy(base, temp);
		    FREE(temp);
		}
	    } else {
		if (me->inBASE) {
		    StrAllocCopy(base, me->base_href);
		} else {
		    StrAllocCopy(base, me->node_anchor->address);
		}
d3972 3
a3974 3
	    StrAllocCopy(code, value[HTML_APPLET_CODE]);
	    url_type = LYLegitimizeHREF(me, &code, TRUE, FALSE);
	    href = HTParse(code, base, PARSE_ALL);
a3975 1
	    FREE(code);
d3977 1
a3977 1
	    if (href && *href) {
d4022 1
a4022 1
	    value[HTML_BGSOUND_SRC] && *value[HTML_BGSOUND_SRC] != '\0') {
d4024 1
a4024 2
	    CHECK_FOR_INTERN(href);
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
a4029 20
	    /*
	     *	Check whether a base tag is in effect. - FM
	     */
	    if ((me->inBASE && *href != '#') &&
		(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		*temp != '\0')
		/*
		 *  Use reference related to the base.
		 */
		StrAllocCopy(href, temp);
	    FREE(temp);

	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&href,
			       ((*href != '#' &&
				 me->inBASE) ?
			       me->base_href : me->node_anchor->address));

d4043 1
a4043 1
					INTERN_LT);		/* Type */
d4115 1
a4115 1
	    value[HTML_EMBED_SRC] && *value[HTML_EMBED_SRC] != '\0') {
d4117 2
a4118 23
	    CHECK_FOR_INTERN(href);
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href != '\0') {
		/*
		 *  Check whether a base tag is in effect. - FM
		 */
		if ((me->inBASE && *href != '#') &&
		    (temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		    *temp != '\0')
		    /*
		     *	Use reference related to the base.
		     */
		    StrAllocCopy(href, temp);
		FREE(temp);

		/*
		 *  Check whether to fill in localhost. - FM
		 */
		LYFillLocalFileURL(&href,
				   ((*href != '#' &&
				     me->inBASE) ?
				   me->base_href : me->node_anchor->address));

d4129 1
a4129 1
					INTERN_LT);		/* Type */
d4171 1
d4203 1
d4243 1
a4243 1
		CTRACE(tfp, "HTML: Missing FORM end tag.  Faking it!\n");
d4252 1
d4258 5
d4264 2
a4265 4
		value[HTML_FORM_ACTION])  {
		/*
		 *  Prepare to do housekeeping on the reference. - FM
		 */
d4267 1
a4267 1
		url_type = LYLegitimizeHREF(me, &action, TRUE, TRUE);
d4274 4
a4277 19
		if ((me->inBASE && me->base_href && *me->base_href) &&
		    (temp = HTParse(action, me->base_href, PARSE_ALL)) &&
		    *temp != '\0') {
		    /*
		     *	Use action related to the base.
		     */
		    StrAllocCopy(action, temp);
		} else if ((temp = HTParse(action,
					   me->node_anchor->address,
					   PARSE_ALL)) &&
		    *temp != '\0') {
		    /*
		     *	Use action related to the current document.
		     */
		    StrAllocCopy(action, temp);
		} else {
		    FREE(action);
		}
		FREE(temp);
d4279 2
a4280 9
	    if (!(action && *action)) {
		if (me->inBASE && me->base_href && *me->base_href) {
		     StrAllocCopy(action, me->base_href);
		} else {
		     StrAllocCopy(action, me->node_anchor->address);
		}
	    }
	    if (action) {
		source = HTAnchor_findChildAndLink(me->node_anchor,
d4284 11
a4294 12
		if ((link_dest = HTAnchor_followMainLink((HTAnchor *)source)) != NULL) {
		    /*
		     *	Memory leak fixed.
		     *	05-28-94 Lynx 2-3-1 Garrett Arch Blythe
		     */
		    auto char *cp_freeme = HTAnchor_address(link_dest);
		    if (cp_freeme != NULL) {
			StrAllocCopy(action, cp_freeme);
			FREE(cp_freeme);
		    } else {
			StrAllocCopy(action, "");
		    }
d4398 3
a4400 7
		if (TRACE) {
		    fprintf(tfp,
			    "Bad HTML: BUTTON tag not within FORM tag\n");
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
d4525 2
a4526 2
				       (I.value[i] ==  ' ' ?
					HT_NON_BREAK_SPACE : I.value[i]));
d4528 1
a4528 1
		while (i < chars) {
d4551 2
a4552 1

d4588 3
d4601 1
a4601 1
		    HTML_put_string(me,"[RANGE Input] (Not yet implemented.)");
d4606 1
a4606 1
		    CTRACE(tfp, "HTML: Ignoring TYPE=\"range\"\n");
d4612 3
a4614 12
		    /*
		     *	Not yet implemented.
		     */
		    if (me->inUnderline == FALSE) {
			HText_appendCharacter(me->text,
					      LY_UNDERLINE_START_CHAR);
		    }
		    HTML_put_string(me,"[FILE Input] (Not yet implemented.)");
		    if (me->inUnderline == FALSE) {
			HText_appendCharacter(me->text,
					      LY_UNDERLINE_END_CHAR);
		    }
d4619 2
a4620 2
		    CTRACE(tfp, "HTML: Ignoring TYPE=\"file\"\n");
		    break;
d4629 17
d4652 3
a4654 7
		if (TRACE) {
		    fprintf(tfp,
			    "Bad HTML: INPUT tag not within FORM tag\n");
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
d4663 2
d4669 2
a4670 7
		if (TRACE) {
		    fprintf(tfp,
			    "Bad HTML: Missing TEXTAREA end tag.\n");
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
d4677 1
a4677 1
		CTRACE(tfp, "HTML: Missing SELECT end tag, faking it...\n");
d4727 1
a4727 1
		url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
a4728 20
		    /*
		     *	Check whether a base tag is in effect. - FM
		     */
		    if ((me->inBASE && *href != '#') &&
			(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
			*temp != '\0')
			/*
			 *  Use reference related to the base.
			 */
			StrAllocCopy(href, temp);
		    FREE(temp);

		    /*
		     *	Check whether to fill in localhost. - FM
		     */
		    LYFillLocalFileURL(&href,
				       ((*href != '#' &&
					 me->inBASE) ?
				       me->base_href :
				       me->node_anchor->address));
d4752 2
d4756 5
a4760 1
		 value[HTML_INPUT_VALUE] && *value[HTML_INPUT_VALUE])) {
d4777 1
d4781 3
d4786 2
a4787 1
			 !strcasecomp(I.type, "reset"))
d4789 2
d4798 1
d4803 3
a4805 2
		    (me->UsePlainSpace && !me->HiddenValue),
		    me->UsePlainSpace, me->HiddenValue);
d4888 3
d4915 1
d4931 1
d4956 1
a4956 1
		 *   treated as part of the editing window, nor be
d4965 3
d4974 5
a4978 2
		for (; chars > 0; chars--)
		    HTML_put_character(me, '_');
d4980 6
d5020 4
a5023 3
					   (I.value[i] ==  ' ' ?
					    HT_NON_BREAK_SPACE : I.value[i]));
		    while (i < chars)
d5026 7
d5046 2
a5047 7
	    if (TRACE) {
		fprintf(tfp,
			"Bad HTML: TEXTAREA start tag not within FORM tag\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d5087 1
a5087 1
	    isdigit((unsigned char)*value[HTML_TEXTAREA_COLS]))
d5089 12
a5100 2
	else
	    StrAllocCopy(me->textarea_cols, "60");
d5104 1
a5104 1
	    isdigit((unsigned char)*value[HTML_TEXTAREA_ROWS]))
d5141 2
a5142 7
	    if (TRACE) {
		fprintf(tfp,
		   "Bad HTML: SELECT start tag in SELECT element.  Faking SELECT end tag. *****\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d5169 2
a5170 7
		if (TRACE) {
		    fprintf(tfp,
			    "Bad HTML: OPTION tag not within SELECT tag\n");
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
d5197 1
a5197 1
	     *	If its not a multiple option list and select popups
a5312 1

d5339 1
a5339 1
		keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) {
d5357 1
a5357 1
	 *  Not implemented.  Just treat as a division
d5361 9
d5371 5
d5385 1
a5385 1
	if (!strcmp(me->sp->style->name, "Preformatted")) {
d5393 1
a5393 1
	    CTRACE(tfp,
d5395 1
a5395 1
		    MAX_NESTING);
d5400 16
a5415 4
		me->DivisionAlignments[me->Division_Level] = HT_CENTER;
		change_paragraph_style(me, styles[HTML_DCENTER]);
		UPDATE_STYLE;
		me->current_default_alignment = styles[HTML_DCENTER]->alignment;
d5421 1
d5427 3
d5436 1
d5439 1
d5444 1
a5444 1
	 *  Not yet implemented.  Just start a new row,
d5447 1
d5458 1
a5458 1
	if (HText_LastLineSize(me->text, FALSE)) {
d5464 1
a5464 1
	if (!strcmp(me->sp->style->name, "Preformatted")) {
d5467 1
d5474 2
a5475 2
		    (!strcmp(me->sp->style->name, "Normal") ||
		     !strcmp(me->sp->style->name, "Preformatted")))) {
d5478 1
a5478 1
	    me->sp->style->alignment = me->current_default_alignment;
d5482 8
a5489 4
		!(me->List_Nesting_Level >= 0 && !me->inP))
		me->sp->style->alignment = HT_CENTER;
	    else if (!strcasecomp(value[HTML_TR_ALIGN], "right") &&
		!(me->List_Nesting_Level >= 0 && !me->inP))
d5491 3
a5493 2
	    else if (!strcasecomp(value[HTML_TR_ALIGN], "left") ||
		     !strcasecomp(value[HTML_TR_ALIGN], "justify"))
d5495 2
d5501 1
d5507 1
d5509 1
a5509 1
	 *  Not yet implemented.  Just check for an ID link. - FM
d5520 13
d5539 1
a5539 1
	 *  Not yet implemented.  Just check for an ID link. - FM
d5550 19
d5573 1
d5585 2
a5586 1
	 *  Not yet implemented.  Just add a collapsible space and break. - FM
d5589 22
a5610 11
	me->in_word = NO;
	break;

    case HTML_TD:
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	if (me->Underline_Level > 0) {
	    SET_SKIP_STACK(HTML_U);
	    HTML_end_element(me, HTML_U, include);
a5611 6
	UPDATE_STYLE;
	CHECK_ID(HTML_TD_ID);
	/*
	 *  Not yet implemented.  Just add a collapsible space and break. - FM
	 */
	HTML_put_character(me, ' ');
d5629 2
a5630 1
    if (HTML_dtd.tags[ElementNumber].contents != SGML_EMPTY) {
d5632 3
a5634 2
	    CTRACE(tfp, "HTML:begin_element: internal call (level %d), leaving on stack - %s\n",
			me->skip_stack, me->sp->style->name);
d5636 1
a5636 1
	    return;
d5640 2
a5641 2
		if (TRACE) {
		    fprintf(tfp,
d5643 1
a5643 5
			MAX_NESTING);

		} else {
		    HTAlert(HTML_STACK_OVERRUN);
		}
d5646 1
a5646 1
	    return;
d5649 4
a5652 3
	CTRACE(tfp,"HTML:begin_element[%d]: adding style to stack - %s\n",
							(int) STACKLEVEL(me),
							me->new_style->name);
d5656 5
d5663 7
a5671 2
#define REALLY_EMPTY(e) ((HTML_dtd.tags[e].contents == SGML_EMPTY) && \
			 !(HTML_dtd.tags[e].flags & Tgf_nreie))
d5673 1
a5673 1
    if (REALLY_EMPTY(element_number))
d5675 2
a5676 4
	CTRACE(tfp, "STYLE:begin_element:ending EMPTY element style\n");
#if !defined(USE_HASH)
	HText_characterStyle(me->text, element_number+STARTAT, STACK_OFF);
#else
a5677 1
#endif /* USE_HASH */
d5692 1
d5709 1
a5709 1
PRIVATE void HTML_end_element ARGS3(
d5715 1
d5718 3
d5722 1
a5722 1
#ifdef USE_PSRC
d5735 1
a5735 1
		strcpy(buf,tag->name);
d5742 1
a5742 1
	    return;
d5748 2
a5749 2
#ifdef CAREFUL			/* parser assumed to produce good nesting */
    if (element_number != me->sp[0].tag_number &&
d5751 2
a5752 2
	CTRACE(tfp,
		"HTMLText: end of element %s when expecting end of %s\n",
d5754 5
a5758 1
		HTML_dtd.tags[me->sp->tag_number].name);
d5760 1
a5761 1
#endif /* CAREFUL */
d5768 3
a5770 2
	if (!(element_number == HTML_MAP || element_number == HTML_AREA)) {
	    return;
d5779 1
d5786 2
a5787 1
	     me->sp[0].tag_number == HTML_DIR) &&
d5801 4
d5806 3
a5808 2
	     CTRACE(tfp, "HTML:end_element: Internal call (level %d), leaving on stack - %s\n",
			me->skip_stack, me->sp->style->name);
d5810 18
d5841 1
a5841 1
	    return;
d5850 1
a5850 1
	    return;
d5856 2
a5857 1
	     me->sp[0].tag_number == HTML_DIR) &&
d5869 1
a5869 1
	    return;
d5871 23
d5895 4
a5898 3
	    CTRACE(tfp, "HTML:end_element[%d]: Popped style off stack - %s\n",
			(int) STACKLEVEL(me),
			me->sp->style->name);
d5900 2
a5901 2
	    CTRACE(tfp,
  "Stack underflow error!  Tried to pop off more styles than exist in stack\n");
d5904 7
a5910 2
    if (BreakFlag == TRUE)
	return;
d5916 2
a5917 6
	if (TRACE) {
	    fprintf(tfp, "Bad HTML: Missing TEXTAREA end tag\n");
	} else if (!me->inBadHTML) {
	    HTUserMsg(BAD_HTML_USE_TRACE);
	    me->inBadHTML = TRUE;
	}
d5931 2
a5932 2
	    if (TRACE) {
		fprintf(tfp,
d5938 1
a5938 5
			me->inA ? "A" : "");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d5944 2
a5945 1
	    !strcmp(me->node_anchor->address, LYlist_temp_url())) {
d5975 1
a5975 1
	    if ((LYMultiBookmarks == TRUE) ||
d5978 2
d6017 3
a6019 2
	CTRACE(tfp, "HTML: STYLE content =\n%s\n",
			    me->style_block.data);
d6029 2
a6030 2
	CTRACE(tfp, "HTML: SCRIPT content =\n%s\n",
			    me->script.data);
d6036 2
a6037 2
	    if (TRACE) {
		fprintf(tfp,
d6043 1
a6043 5
			me->inA ? "A" : "");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d6080 6
a6085 2
	if (me->Division_Level >= 0)
	    me->sp->style->alignment =
d6087 2
d6090 6
a6095 1
	UPDATE_STYLE;
a6096 2
	if (me->List_Nesting_Level >= 0)
	    HText_NegateLineOne(me->text);
d6108 2
a6109 2
	} else if (!strcmp(me->sp->style->name, "HeadingCenter") ||
		   !strcmp(me->sp->style->name, "Heading1")) {
d6111 1
a6111 1
	} else if (!strcmp(me->sp->style->name, "HeadingRight")) {
d6133 1
a6133 1
	LYHandleP(me,
d6135 1
a6135 1
		 include,
d6166 1
a6166 1
	    CTRACE(tfp, "Ending underline\n");
d6168 1
a6168 1
	    CTRACE(tfp, "Underline Level is %d\n", me->Underline_Level);
a6181 1
    case HTML_SUB:
d6187 4
d6236 1
d6238 1
d6240 1
d6265 1
d6267 1
d6269 1
d6271 1
d6274 6
a6279 2
	CTRACE(tfp, "HTML_end_element: Reducing List Nesting Level to %d\n",
		    me->List_Nesting_Level);
d6312 6
a6317 1

d6351 5
a6355 13
	if (me->inFIGwithP) {
	    LYEnsureDoubleSpace(me);
	} else {
	    HTML_put_character(me, ' ');  /* space char may be ignored */
	}
	LYResetParagraphAlignment(me);
	me->inFIGwithP = FALSE;
	me->inFIG = FALSE;
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
	if (me->List_Nesting_Level >= 0) {
	    UPDATE_STYLE;
	    HText_NegateLineOne(me->text);
	}
d6364 2
a6365 1
	    char *start = NULL, *first_end = NULL;
d6381 2
a6382 1
		} else if (s == 0 && !strncasecomp(cp, "<PARAM", 6)) {
d6384 2
a6385 1
		} else if (!strncasecomp(cp, "<OBJECT", 7)) {
d6389 2
a6390 1
		} else if (!strncasecomp(cp, "</OBJECT", 8)) {
d6393 1
d6395 8
d6406 10
d6417 37
d6456 8
a6463 12
		 *  end tags, so restore an end tag to the content, and
		 *  pass a dummy start tag to the SGML parser so that it
		 *  will resume the accumulation of OBJECT content. - FM
		 */
		CTRACE(tfp, "HTML: Nested OBJECT tags.  Recycling.\n");
		if (*include == NULL) {
		    StrAllocCopy(*include, "<OBJECT>");
		} else {
		    if (0 && strstr(*include, me->object.data) == NULL) {
			StrAllocCat(*include, "<OBJECT>");
		    }
		}
d6466 2
a6467 1
		change_paragraph_style(me, me->sp->style);
a6469 15
	    if (s < e) {
		/*
		 *  We had more end tags than start tags, so
		 *  we have bad HTML or otherwise misparsed. - FM
		 */
		if (TRACE) {
		    fprintf(tfp,
  "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content:\n%s\n",
			    me->object.data);
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
		goto End_Object;
	    }
d6476 1
a6476 1
	    CTRACE(tfp, "HTML:OBJECT content:\n%s\n", me->object.data);
d6487 1
a6487 1
		if (me->object_id && *me->object_id)
d6489 1
a6489 1
		CTRACE(tfp, "HTML: DECLAREd OBJECT.  Ignoring!\n");
d6499 1
a6499 1
	    if (me->object_name != NULL) {
d6502 1
a6502 1
		CTRACE(tfp, "HTML: NAMEd OBJECT.  Ignoring!\n");
d6518 21
a6538 6
		    *first_end = '\0';
		    data = NULL;
		    StrAllocCopy(data, start);
		    if (e > 1) {
			for (i = e; i > 1; i--) {
			    StrAllocCat(data, "</OBJECT><OBJECT>");
d6540 7
a6547 6
		    StrAllocCat(data, "</OBJECT>");
		    StrAllocCat(*include, data);
		    CTRACE(tfp, "HTML: Recycling nested OBJECT%s.\n",
					(e > 1) ? "s" : "");
		    FREE(data);
		    goto End_Object;
d6549 2
a6550 7
		    if (TRACE) {
			fprintf(tfp,
     "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content.\n");
		    } else if (!me->inBadHTML) {
			HTUserMsg(BAD_HTML_USE_TRACE);
			me->inBadHTML = TRUE;
		    }
d6556 10
a6565 4
	     *	If it's content has SHAPES, convert it to FIG. - FM
	     */
	    if (me->object_shapes == TRUE) {
		CTRACE(tfp, "HTML: OBJECT has SHAPES.  Converting to FIG.\n");
d6592 2
a6593 2
	    if (me->object_usemap != NULL) {
		CTRACE(tfp, "HTML: OBJECT has USEMAP.  Converting to IMG.\n");
d6595 2
d6640 47
d6693 1
a6693 1
	    if (me->object_id && *me->object_id)
d6699 3
a6701 1
	    if (me->object.size > 1)
d6703 1
d6714 2
a6715 1
		if (me->object_data != NULL &&
d6728 2
d6750 1
a6750 14
	HTChunkClear(&me->object);
	me->object_started = FALSE;
	me->object_declare = FALSE;
	me->object_shapes = FALSE;
	me->object_ismap = FALSE;
	FREE(me->object_usemap);
	FREE(me->object_id);
	FREE(me->object_title);
	FREE(me->object_data);
	FREE(me->object_type);
	FREE(me->object_classid);
	FREE(me->object_codebase);
	FREE(me->object_codetype);
	FREE(me->object_name);
d6752 2
a6753 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6792 2
a6793 6
	    if (TRACE) {
		fprintf(tfp, "Bad HTML: Unmatched FORM end tag\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d6795 1
d6809 2
a6810 7
	    if (TRACE) {
		fprintf(tfp,
		   "Bad HTML: Open SELECT at FORM end. Faking SELECT end tag. *****\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d6862 2
a6863 6
		if (TRACE) {
		    fprintf(tfp, "Bad HTML: Unmatched TEXTAREA end tag\n");
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
a6896 1
	    data = me->textarea.data;
d6909 3
a6911 3
	     *	SGML unescape any character references in TEXTAREA
	     *	content, then parse it into individual lines
	     *	to be handled as a series of INPUT fields (ugh!).
d6915 5
d6923 23
a6945 1
	    TRANSLATE_AND_UNESCAPE_ENTITIES5(&me->textarea.data,
d6948 5
a6952 1
						    me->UsePlainSpace, me->HiddenValue);
d6992 1
a6992 1
			temp[j] = (temp[j+1] ? ' ' : '\0');
d7025 1
a7025 1
			temp[j] = (temp[j+1] ? ' ' : '\0');
d7067 2
a7068 6
		if (TRACE) {
		    fprintf(tfp, "Bad HTML: Unmatched SELECT end tag *****\n");
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
d7086 3
a7088 7
		if (TRACE) {
		    fprintf(tfp,
			    "Bad HTML: SELECT end tag not within FORM element *****\n");
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
d7144 9
a7152 1
		    else
d7154 5
d7165 1
d7186 3
d7190 2
a7191 1
	if (!strcmp(me->sp->style->name, "Preformatted")) {
d7201 11
d7219 2
a7220 1
	if (HText_LastLineSize(me->text, FALSE)) {
d7233 2
a7237 2
	break;

d7239 1
d7279 12
d7292 1
d7294 2
a7295 2
    TrimColorClass(HTML_dtd.tags[element_number].name,
		   Style_className, &hcode);
d7298 4
a7301 4
    FastTrimColorClass(HTML_dtd.tags[element_number].name,
		       HTML_dtd.tags[element_number].name_len,
		       Style_className,
		       &Style_className_end, &hcode);
d7305 7
a7311 8
    if (!REALLY_EMPTY(element_number))
    {
	CTRACE(tfp, "STYLE:end_element: ending non-EMPTY style\n");
#if !defined(USE_HASH)
	HText_characterStyle(me->text, element_number+STARTAT, STACK_OFF);
#else
	HText_characterStyle(me->text, HCODE_TO_STACK_OFF(hcode), STACK_OFF);
#endif /* USE_HASH */
d7314 1
d7357 2
d7387 1
a7387 1
	    CTRACE(tfp,"HTML_free: Ending underline\n");
d7392 1
d7408 3
a7410 7
	    if (TRACE) {
		fprintf(tfp,
			"Bad HTML: SELECT or OPTION not ended properly *****\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d7416 2
a7417 2
	    CTRACE(tfp, "HTML_free: ***** leftover option data: %s\n",
			me->option.data);
d7427 3
a7429 7
	    if (TRACE) {
		fprintf(tfp,
			"Bad HTML: TEXTAREA not used properly *****\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d7435 2
a7436 2
	    CTRACE(tfp, "HTML_free: ***** leftover textarea data: %s\n",
			me->textarea.data);
d7457 5
d7474 3
a7476 7
	if (TRACE) {
	    fprintf(tfp,
		    "Bad HTML: SELECT or OPTION not ended properly *****\n");
	} else if (!me->inBadHTML) {
	    HTUserMsg(BAD_HTML_USE_TRACE);
	    me->inBadHTML = TRUE;
	}
d7479 2
a7480 2
	    fprintf(tfp, "HTML_free: ***** leftover option data: %s\n",
		    me->option.data);
d7490 3
a7492 7
	if (TRACE) {
	    fprintf(tfp,
		    "Bad HTML: TEXTAREA not used properly *****\n");
	} else if (!me->inBadHTML) {
	    HTUserMsg(BAD_HTML_USE_TRACE);
	    me->inBadHTML = TRUE;
	}
d7495 2
a7496 2
	    fprintf(tfp, "HTML_free: ***** leftover textarea data: %s\n",
		    me->textarea.data);
d7505 3
a7507 3
	if (!strcmp(me->sp->style->name, "DivCenter") ||
	    !strcmp(me->sp->style->name, "HeadingCenter") ||
	    !strcmp(me->sp->style->name, "Heading1")) {
d7509 2
a7510 2
	} else if (!strcmp(me->sp->style->name, "DivRight") ||
		   !strcmp(me->sp->style->name, "HeadingRight")) {
d7525 1
d7569 1
a7569 2
	    fprintf(tfp,
		    "HTML_abort: SELECT or OPTION not ended properly *****\n");
d7571 2
a7572 2
	    fprintf(tfp, "HTML_abort: ***** leftover option data: %s\n",
		    me->option.data);
d7583 1
a7583 2
	    fprintf(tfp,
		    "HTML_abort: TEXTAREA not used properly *****\n");
d7585 2
a7586 2
	    fprintf(tfp, "HTML_abort: ***** leftover textarea data: %s\n",
		    me->textarea.data);
d7595 3
a7597 3
	if (!strcmp(me->sp->style->name, "DivCenter") ||
	    !strcmp(me->sp->style->name, "HeadingCenter") ||
	    !strcmp(me->sp->style->name, "Heading1")) {
d7599 2
a7600 2
	} else if (!strcmp(me->sp->style->name, "DivRight") ||
		   !strcmp(me->sp->style->name, "HeadingRight")) {
d7619 2
d7629 2
a7630 2
    styleSheet = DefaultStyle();
    default_style =		HTStyleNamed(styleSheet, "Normal");
d7632 1
a7632 13
    styles[HTML_H1] =		HTStyleNamed(styleSheet, "Heading1");
    styles[HTML_H2] =		HTStyleNamed(styleSheet, "Heading2");
    styles[HTML_H3] =		HTStyleNamed(styleSheet, "Heading3");
    styles[HTML_H4] =		HTStyleNamed(styleSheet, "Heading4");
    styles[HTML_H5] =		HTStyleNamed(styleSheet, "Heading5");
    styles[HTML_H6] =		HTStyleNamed(styleSheet, "Heading6");
    styles[HTML_HCENTER] =	HTStyleNamed(styleSheet, "HeadingCenter");
    styles[HTML_HLEFT] =	HTStyleNamed(styleSheet, "HeadingLeft");
    styles[HTML_HRIGHT] =	HTStyleNamed(styleSheet, "HeadingRight");

    styles[HTML_DCENTER] =	HTStyleNamed(styleSheet, "DivCenter");
    styles[HTML_DLEFT] =	HTStyleNamed(styleSheet, "DivLeft");
    styles[HTML_DRIGHT] =	HTStyleNamed(styleSheet, "DivRight");
d7634 15
a7648 1
    styles[HTML_DL] =		HTStyleNamed(styleSheet, "Glossary");
d7650 6
a7655 6
    styles[HTML_DL1] =		HTStyleNamed(styleSheet, "Glossary1");
    styles[HTML_DL2] =		HTStyleNamed(styleSheet, "Glossary2");
    styles[HTML_DL3] =		HTStyleNamed(styleSheet, "Glossary3");
    styles[HTML_DL4] =		HTStyleNamed(styleSheet, "Glossary4");
    styles[HTML_DL5] =		HTStyleNamed(styleSheet, "Glossary5");
    styles[HTML_DL6] =		HTStyleNamed(styleSheet, "Glossary6");
d7658 1
a7658 1
    styles[HTML_OL] =		HTStyleNamed(styleSheet, "List");
d7660 6
a7665 6
    styles[HTML_OL1] =		HTStyleNamed(styleSheet, "List1");
    styles[HTML_OL2] =		HTStyleNamed(styleSheet, "List2");
    styles[HTML_OL3] =		HTStyleNamed(styleSheet, "List3");
    styles[HTML_OL4] =		HTStyleNamed(styleSheet, "List4");
    styles[HTML_OL5] =		HTStyleNamed(styleSheet, "List5");
    styles[HTML_OL6] =		HTStyleNamed(styleSheet, "List6");
d7668 1
a7668 1
    styles[HTML_DIR] =		HTStyleNamed(styleSheet, "Menu");
d7670 6
a7675 6
    styles[HTML_MENU1] =	HTStyleNamed(styleSheet, "Menu1");
    styles[HTML_MENU2] =	HTStyleNamed(styleSheet, "Menu2");
    styles[HTML_MENU3] =	HTStyleNamed(styleSheet, "Menu3");
    styles[HTML_MENU4] =	HTStyleNamed(styleSheet, "Menu4");
    styles[HTML_MENU5] =	HTStyleNamed(styleSheet, "Menu5");
    styles[HTML_MENU6] =	HTStyleNamed(styleSheet, "Menu6");
d7677 1
a7677 1
    styles[HTML_DLC] =		HTStyleNamed(styleSheet, "GlossaryCompact");
d7679 13
a7691 13
    styles[HTML_DLC1] =		HTStyleNamed(styleSheet, "GlossaryCompact1");
    styles[HTML_DLC2] =		HTStyleNamed(styleSheet, "GlossaryCompact2");
    styles[HTML_DLC3] =		HTStyleNamed(styleSheet, "GlossaryCompact3");
    styles[HTML_DLC4] =		HTStyleNamed(styleSheet, "GlossaryCompact4");
    styles[HTML_DLC5] =		HTStyleNamed(styleSheet, "GlossaryCompact5");
    styles[HTML_DLC6] =		HTStyleNamed(styleSheet, "GlossaryCompact6");

    styles[HTML_ADDRESS] =	HTStyleNamed(styleSheet, "Address");
    styles[HTML_BANNER] =	HTStyleNamed(styleSheet, "Banner");
    styles[HTML_BLOCKQUOTE] =	HTStyleNamed(styleSheet, "Blockquote");
    styles[HTML_BQ] =		HTStyleNamed(styleSheet, "Bq");
    styles[HTML_FN] =		HTStyleNamed(styleSheet, "Footnote");
    styles[HTML_NOTE] =		HTStyleNamed(styleSheet, "Note");
d7693 3
a7695 3
    styles[HTML_XMP] =		HTStyleNamed(styleSheet, "Example");
    styles[HTML_PRE] =		HTStyleNamed(styleSheet, "Preformatted");
    styles[HTML_LISTING] =	HTStyleNamed(styleSheet, "Listing");
d7746 1
a7746 1
	exit_immediately (-1);
d7749 1
a7749 1
    me = (HTStructured*) calloc(sizeof(*me),1);
d7769 3
a7771 9
    me->title.size = 0;
    me->title.growby = 128;
    me->title.allocated = 0;
    me->title.data = NULL;

    me->object.size = 0;
    me->object.growby = 128;
    me->object.allocated = 0;
    me->object.data = NULL;
d7786 1
a7786 4
    me->option.size = 0;
    me->option.growby = 128;
    me->option.allocated = 0;
    me->option.data = NULL;
d7792 1
a7792 4
    me->textarea.size = 0;
    me->textarea.growby = 128;
    me->textarea.allocated = 0;
    me->textarea.data = NULL;
d7801 5
a7805 14
    me->math.size = 0;
    me->math.growby = 128;
    me->math.allocated = 0;
    me->math.data = NULL;

    me->style_block.size = 0;
    me->style_block.growby = 128;
    me->style_block.allocated = 0;
    me->style_block.data = NULL;

    me->script.size = 0;
    me->script.growby = 128;
    me->script.allocated = 0;
    me->script.data = NULL;
d7842 1
a7871 47
#ifdef NOTUSED_FOTEMODS
    /*
    **	If the anchor already has stage info, make sure that it is
    **	appropriate for the current display charset.  HTMIMEConvert()
    **	does this for the http and https schemes, and HTCharsetFormat()
    **	does it for the file and and ftp schemes, be we need to do it,
    **	if necessary, for the gateway schemes. - FM
    */
    if (me->node_anchor->UCStages) {
	if (HTAnchor_getUCLYhndl(me->node_anchor,
				 UCT_STAGE_STRUCTURED) != current_char_set) {
	    /*
	    **	We are reloading due to a change in the display character
	    **	set.  Free the stage info and let the stage info creation
	    **	mechanisms create a new UCStages structure appropriate for
	    **	the current display character set. - FM
	    */
	    FREE(anchor->UCStages);
	} else if (HTAnchor_getUCLYhndl(me->node_anchor,
					UCT_STAGE_MIME) == current_char_set) {
	    /*
	    **	The MIME stage is set to the current display character
	    **	set.  If it is CJK, and HTCJK does not point to a CJK
	    **	character set, assume we are reloading due to a raw
	    **	mode toggle and reset the MIME and PARSER stages to
	    **	an ISO Latin 1 default. - FM
	    */
	    LYUCcharset *p_in = HTAnchor_getUCInfoStage(me->node_anchor,
							UCT_STAGE_MIME);
	    if (p_in->enc == UCT_ENC_CJK && HTCJK == NOCJK) {
		HTAnchor_resetUCInfoStage(me->node_anchor, LATIN1,
					  UCT_STAGE_MIME,
					  UCT_SETBY_DEFAULT);
		HTAnchor_setUCInfoStage(me->node_anchor, LATIN1,
					UCT_STAGE_MIME,
					UCT_SETBY_DEFAULT);
		HTAnchor_resetUCInfoStage(me->node_anchor, LATIN1,
					  UCT_STAGE_PARSER,
					  UCT_SETBY_DEFAULT);
		HTAnchor_setUCInfoStage(me->node_anchor, LATIN1,
					UCT_STAGE_PARSER,
					UCT_SETBY_DEFAULT);
	    }
	}
    }
#endif /* NOTUSED_FOTEMODS */

a7907 5
#ifdef NOTUSED_FOTEMODS
    UCSetTransParams(&me->T,
		     me->inUCLYhndl, me->inUCI,
		     me->outUCLYhndl, me->outUCI);
#endif
d7917 10
d7931 50
d7984 1
a7984 2
    if (me->fp)
	LYCloseTempFP(me->fp);
d7995 16
d8019 9
a8027 4
    if (me->fp)
	fputc(c_in, me->fp);
    else
	HTChunkPutc(me->chunk, c_in);
d8035 9
a8043 4
    if (me->fp)
	fputs(str, me->fp);
    else
	HTChunkPuts(me->chunk, str);
d8052 11
a8062 4
    if (me->fp)
	fwrite(str, 1, l, me->fp);
    else
	HTChunkPutb(me->chunk, str, l);
d8091 1
a8091 1
    /*  Only remote HTML documents may benefits from HTreparse_document(), */
d8093 3
a8095 2
    if (strcmp(p->name, "http") != 0) {
	CTRACE(tfp, "Protocol is \"%s\"; not caching\n", p->name);
d8107 1
d8109 1
d8113 1
d8116 3
a8118 5
	if (source_cache_filename) {
	    CTRACE(tfp, "Reusing source cache file %s\n",
		   source_cache_filename);
	    FREE(stream);
	    return target;
d8127 3
a8129 3
	if (!(stream->fp = LYOpenTemp(filename, HTML_SUFFIX, "wb"))) {
	    CTRACE(tfp, "Cannot get source cache file for URL %s\n",
		   HTAnchor_address((HTAnchor *)anchor));
d8134 1
a8134 4
	/*
	 * Yes, this is a Gross And Disgusting Hack(TM), I know...
	 */
	StrAllocCopy(source_cache_filename, filename);
d8136 2
a8137 2
	CTRACE(tfp, "Caching source for URL %s in file %s\n",
	       HTAnchor_address((HTAnchor *)anchor), filename);
d8141 4
a8144 5
	if (source_cache_chunk) {
	    CTRACE(tfp, "Reusing source memory cache %p\n",
		   (void *)source_cache_chunk);
	    FREE(stream);
	    return target;
d8147 10
a8156 4
	/* I think this is right... */
	source_cache_chunk = stream->chunk = HTChunkCreate(128);
	CTRACE(tfp, "Caching source for URL %s in memory cache %p\n",
	       HTAnchor_address((HTAnchor *)anchor), (void *)stream->chunk);
d8162 2
a8178 1
#ifdef SOURCE_CACHE
a8181 3
#else
    return SGML_new(&HTML_dtd, anchor, HTML_new(anchor, pres->rep_out, sink));
#endif
a8239 1
#ifdef SOURCE_CACHE
a8242 3
#else
    return SGML_new(&HTML_dtd, anchor, HTMLGenerator(intermediate));
#endif
d8252 1
a8252 1
**	It is registered in HTInit.c, but never actually used by lynx.
d8261 2
a8262 2

    (*sink->isa->put_string)(sink, "/* ");	/* Before even title */
d8266 2
a8267 2
/*    HTML_put_string(html,html->comment_start); */
#ifdef SOURCE_CACHE
a8269 3
#else
    return SGML_new(&HTML_dtd, anchor, html);
#endif
a8285 1
#ifdef SOURCE_CACHE
a8288 3
#else
    return SGML_new(&HTML_dtd, anchor, HTML_new(anchor, WWW_PRESENT, NULL));
#endif
d8339 21
d8361 1
d8388 1
a8388 1
    if ( verbose_img ) {
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 12
a13 12
 *		============================================
 *
 *	This generates a hypertext object.  It converts from the
 *	structured stream interface of HTML events into the style-
 *	oriented interface of the HText.h interface.  This module is
 *	only used in clients and should not be linked into servers.
 *
 *	Override this module if making a new GUI browser.
 *
 *   Being Overidden
 *
 */
d38 1
d52 1
a52 1
#ifdef USE_PRETTYSRC
d64 5
d70 1
a70 1
# define HCODE_TO_STACK_OFF(x) /*(CSHASHSIZE+1)*/ 88888		/*special value. */
d72 1
a72 1
# define HCODE_TO_STACK_OFF(x) x	/*pass computed value */
d77 1
a77 1
#ifdef USE_SOURCE_CACHE
a80 3
#include <LYCurses.h>
#include <LYJustify.h>

d86 2
a87 2
#define DFT_TEXTAREA_COLS 60
#define DFT_TEXTAREA_ROWS 4
d89 1
a89 2
#define MAX_TEXTAREA_COLS LYcolLimit
#define MAX_TEXTAREA_ROWS (3 * LYlines)
d91 2
a92 6
#define LimitValue(name, value) \
 	if (name > value) { \
		CTRACE((tfp, "Limited " #name " to %d, was %d\n", \
			value, name)); \
		name = value; \
	}
d95 6
a100 9
    const HTStreamClass *isa;
#ifdef USE_SOURCE_CACHE
    HTParentAnchor *anchor;
    FILE *fp;
    char *filename;
    HTChunk *chunk;
    const HTStreamClass *actions;
    HTStream *target;
    int status;
d106 1
a106 1
static HTStyleSheet *styleSheet = NULL;		/* Application-wide */
d110 1
a110 3
static HTStyle *styles[HTML_ELEMENTS + LYNX_HTML_EXTRA_ELEMENTS];

					   /* adding 24 nested list styles  */
d113 1
a113 1
static HTStyle *default_style = NULL;
d115 1
a115 1
const char *LYToolbarName = "LynxPseudoToolbar";
d118 1
a118 1
static int i_prior_style = -1;
d124 11
a134 8
static int HTML_end_element(HTStructured * me, int element_number,
			    char **include);

static int HTML_start_element(HTStructured * me, int element_number,
			      const BOOL *present,
			      const char **value,
			      int tag_charset,
			      char **include);
d142 3
a144 3
static char *MakeNewTitle(const char **value, int src_type);
static char *MakeNewImageValue(const char **value);
static char *MakeNewMapValue(const char **value, const char *mapstr);
d147 2
a148 2
 *	is only internal and the stack manipulation should be skipped. - kw
 */
d152 3
a154 1
void strtolower(char *i)
d156 2
a157 6
    if (!i)
	return;
    while (*i) {
	*i = (char) TOLOWER(*i);
	i++;
    }
d161 7
a167 7
 *		------------------------------
 *
 * On the NeXT, and on any read-only browser, it is simpler for the text to
 * have a sequence of styles, rather than a nested tree of styles.  In this
 * case we have to flatten the structure as it arrives from SGML tags into a
 * sequence of styles.
 */
d170 3
a172 3
 *  If style really needs to be set, call this.
 */
void actually_set_style(HTStructured * me)
d174 1
a174 1
    if (!me->text) {		/* First time through */
d177 1
a177 1
			 me->UCLYhndl, me->UCI,
d196 3
a198 3
 *  If you THINK you need to change style, call this.
 */
static void change_paragraph_style(HTStructured * me, HTStyle *style)
a206 10
BOOL LYBadHTML(HTStructured * me)
{
    if (!TRACE && !me->inBadHTML) {
	HTUserMsg(BAD_HTML_USE_TRACE);
	me->inBadHTML = TRUE;
	return FALSE;
    }
    return TRUE;
}

d208 3
a210 3
 *
 *			A C T I O N	R O U T I N E S
 */
d225 3
a227 3
 *	------------------
 */
void HTML_put_character(HTStructured * me, char c)
d230 2
a231 1
     * Ignore all non-MAP content when just scanning a document for MAPs.  - FM
d233 1
a233 1
    if (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT)
d237 1
a237 1
     * Do EOL conversion if needed.  - FM
d239 4
a242 4
     * Convert EOL styles:
     *   macintosh:  cr    --> lf
     *   ascii:      cr-lf --> lf
     *   unix:       lf    --> lf
d253 1
a253 1
     * Handle SGML_LITTERAL tags that have HTChunk elements.  - FM
d258 1
a258 1
	return;			/* Do Nothing */
d304 9
a312 9
	     * If we are within a SELECT not caught by the cases above -
	     * HTML_SELECT or HTML_OPTION may not be the last element pushed on
	     * the style stack if there were invalid markup tags within a
	     * SELECT element.  For error recovery, treat text as part of the
	     * OPTION text, it is probably meant to show up as user-visible
	     * text.  Having A as an open element while in SELECT is really
	     * sick, don't make anchor text part of the option text in that
	     * case since the option text will probably just be discarded.  -
	     * kw
d320 1
a320 1
    }				/* end first switch */
d323 1
a323 1
     * Handle all other tag content.  - FM
d327 1
a327 1
    case HTML_PRE:		/* Formatted text */
d329 2
a330 2
	 * We guarantee that the style is up-to-date in begin_litteral. But we
	 * still want to strip \r's.
d342 1
a342 1
    case HTML_LISTING:		/* Literal text */
d346 2
a347 2
	 * We guarantee that the style is up-to-date in begin_litteral.  But we
	 * still want to strip \r's.
d349 1
a349 1
	if (c != '\r') {
d358 1
a358 1
	 * Free format text.
d360 1
a360 1
	if (me->sp->style->id == ST_Preformatted) {
d370 2
a371 2
	} else if (me->sp->style->id == ST_Listing ||
		   me->sp->style->id == ST_Example) {
d404 1
a404 1
		/* ignore */
d413 1
a413 1
    }				/* end second switch */
d416 1
a416 1
	HText_setLastChar(me->text, ' ');	/* set it to a generic separator */
d419 3
a421 2
	 * \r's are ignored.  In order to keep collapsing spaces correctly we
	 * must default back to the previous separator if there was one.
d424 1
a424 1
	HText_setLastChar(me->text, ' ');	/* set it to a generic separator */
d431 6
a436 6
 *	---------------
 *
 *	This is written separately from put_character because the loop can
 *	in some cases be promoted to a higher function call level for speed.
 */
void HTML_put_string(HTStructured * me, const char *s)
d438 2
a439 2
#ifdef USE_PRETTYSRC
    char *translated_string = NULL;
d442 1
a442 1
    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
d444 1
a444 1
#ifdef USE_PRETTYSRC
d446 1
a446 1
	StrAllocCopy(translated_string, s);
d448 2
a449 2
	s = (const char *) translated_string;
    }
d455 1
a455 1
	break;			/* Do Nothing */
d469 2
a470 2
    case HTML_PRE:		/* Formatted text */
    case HTML_LISTING:		/* Literal text */
d474 1
a474 1
	 * We guarantee that the style is up-to-date in begin_litteral
d496 1
a496 1
    default:			/* Free format text? */
d499 5
a503 17
	     * If we are within a preformatted text style not caught by the
	     * cases above (HTML_PRE or similar may not be the last element
	     * pushed on the style stack).  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for (; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
		HText_appendText(me->text, s);
d506 1
a506 1
	    const char *p = s;
a507 1

d510 2
a511 1
			      (*p == ' ') || (*p == '\t')); p++) ;	/* Ignore leaders */
d519 3
a521 3
		     * Treat any '\r' which is not followed by '\n' as '\n', to
		     * account for macintosh lineend in ALT attributes etc.  -
		     * kw
d529 1
a529 1
			continue;	/* Ignore it */
d537 1
a537 1
			    me->in_word = NO;
d542 1
a542 1
		    if (HText_getLastChar(me->text) != ' ')
d546 1
a546 1
		    /* ignore */
d559 4
a562 4
		     * \r's are ignored.  In order to keep collapsing spaces
		     * correctly, we must default back to the previous
		     * separator, if there was one.  So we set LastChar to a
		     * generic separator.
d569 1
a569 1
	    }			/* for */
d571 2
a572 2
    }				/* end switch */
#ifdef USE_PRETTYSRC
d581 3
a583 3
 *	------------
 */
void HTML_write(HTStructured * me, const char *s, int l)
d585 2
a586 2
    const char *p;
    const char *e = s + l;
d588 1
a588 1
    if (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT)
d591 1
a591 1
    for (p = s; p < e; p++)
d639 1
d645 2
a646 2
   overriding non-caching similar to LYoverride_no_cache. - kw */
#define CHECK_FOR_INTERN(flag,s) flag = (s && (*s=='#' || *s=='\0')) ? TRUE : FALSE
d650 8
a657 1
#define INTERN_LT (HTLinkType *)(intern_flag ? HTInternalLink : NULL)
d660 8
a667 3
static char *Style_className = 0;
static char *Style_className_end = 0;
static unsigned Style_className_len = 0;
a668 6

#ifdef LY_FIND_LEAKS
static void free_Style_className(void)
{
    FREE(Style_className);
}
a670 31
static void addClassName(const char *prefix,
			 const char *actual,
			 int length)
{
    int offset = strlen(prefix);
    unsigned have = (Style_className_end - Style_className);
    unsigned need = (offset + length + 1);

    if ((have + need) >= Style_className_len) {
	Style_className_len += 1024 + 2 * (have + need);
	if (Style_className == 0) {
	    Style_className = typeMallocn(char, Style_className_len);
	} else {
	    Style_className = typeRealloc(char, Style_className, Style_className_len);
	}
	if (Style_className == NULL)
	    outofmem(__FILE__, "addClassName");
	Style_className_end = Style_className + have;
    }
    if (offset)
	strcpy(Style_className_end, prefix);
    if (length)
	memcpy(Style_className_end + offset, actual, length);
    Style_className_end[offset + length] = '\0';
    strtolower(Style_className_end);

    Style_className_end += (offset + length);
}
#else
#define addClassName(prefix, actual, length)	/* nothing */
#endif
d672 1
a672 1
#ifdef USE_PRETTYSRC
d674 5
a678 2
static void HTMLSRC_apply_markup(HTStructured * context, HTlexeme lexeme, BOOL start,
				 int tag_charset)
d680 1
a680 1
    HT_tagspec *ts = *((start ? lexeme_start : lexeme_end) + lexeme);
d691 1
a691 1
	CTRACE((tfp, ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n", (int) lexeme));
d693 7
a699 6
	    HTML_start_element(context,
			       ts->element,
			       ts->present,
			       (const char **) ts->value,
			       tag_charset,
			       NULL);
d701 4
a704 3
	    HTML_end_element(context,
			     ts->element,
			     NULL);
a709 1

d716 1
a716 134
#endif /* USE_PRETTYSRC */

static void LYStartArea(HTStructured * obj, const char *href,
			const char *alt,
			const char *title,
			int tag_charset)
{
    BOOL new_present[HTML_AREA_ATTRIBUTES];
    const char *new_value[HTML_AREA_ATTRIBUTES];
    int i;

    for (i = 0; i < HTML_AREA_ATTRIBUTES; i++)
	new_present[i] = NO;

    if (alt) {
	new_present[HTML_AREA_ALT] = YES;
	new_value[HTML_AREA_ALT] = (const char *) alt;
    }
    if (non_empty(title)) {
	new_present[HTML_AREA_TITLE] = YES;
	new_value[HTML_AREA_TITLE] = (const char *) title;
    }
    if (href) {
	new_present[HTML_AREA_HREF] = YES;
	new_value[HTML_AREA_HREF] = (const char *) href;
    }

    (*obj->isa->start_element) (obj, HTML_AREA, new_present, new_value,
				tag_charset, 0);
}

static void LYHandleFIG(HTStructured * me, const BOOL *present,
			const char **value,
			BOOL isobject,
			BOOL imagemap,
			const char *id,
			const char *src,
			BOOL convert,
			BOOL start,
			BOOL *intern_flag GCC_UNUSED)
{
    if (start == TRUE) {
	me->inFIG = TRUE;
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, NULL);
	}
	if (!isobject) {
	    LYEnsureDoubleSpace(me);
	    LYResetParagraphAlignment(me);
	    me->inFIGwithP = TRUE;
	} else {
	    me->inFIGwithP = FALSE;
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	}
	if (non_empty(id)) {
	    if (present && convert) {
		CHECK_ID(HTML_FIG_ID);
	    } else
		LYHandleID(me, id);
	}
	me->in_word = NO;
	me->inP = FALSE;

	if (clickable_images && non_empty(src)) {
	    char *href = NULL;

	    StrAllocCopy(href, src);
	    CHECK_FOR_INTERN(*intern_flag, href);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href) {
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 INTERN_LT);	/* Type */
		HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		HTML_put_string(me, (isobject
				     ? (imagemap
					? "(IMAGE)"
					: "(OBJECT)")
				     : "[FIGURE]"));
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, 0);
		HTML_put_character(me, '-');
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
	    }
	    FREE(href);
	}
    } else {			/* handle end tag */
	if (me->inFIGwithP) {
	    LYEnsureDoubleSpace(me);
	} else {
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	}
	LYResetParagraphAlignment(me);
	me->inFIGwithP = FALSE;
	me->inFIG = FALSE;
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	if (me->List_Nesting_Level >= 0) {
	    UPDATE_STYLE;
	    HText_NegateLineOne(me->text);
	}
    }
}

static void clear_objectdata(HTStructured * me)
{
    if (me) {
	HTChunkClear(&me->object);
	me->object_started = FALSE;
	me->object_declare = FALSE;
	me->object_shapes = FALSE;
	me->object_ismap = FALSE;
	FREE(me->object_usemap);
	FREE(me->object_id);
	FREE(me->object_title);
	FREE(me->object_data);
	FREE(me->object_type);
	FREE(me->object_classid);
	FREE(me->object_codebase);
	FREE(me->object_codetype);
	FREE(me->object_name);
    }
}

#define HTParseALL(pp,pconst)  \
	{ char* free_me = *pp; \
	  *pp = HTParse(*pp, pconst, PARSE_ALL); \
	  FREE(free_me);       \
	}
d719 9
a727 7
 *	-------------
 */
static int HTML_start_element(HTStructured * me, int element_number,
			      const BOOL *present,
			      const char **value,
			      int tag_charset,
			      char **include)
d739 5
a743 5
    const char *Base = NULL;
    int dest_char_set = -1;
    HTParentAnchor *dest = NULL;	/* An anchor's destination */
    BOOL dest_ismap = FALSE;	/* Is dest an image map script? */
    HTChildAnchor *ID_A = NULL;	/* HTML_foo_ID anchor */
d746 1
a746 1
    HTMLElement ElementNumber = (HTMLElement) element_number;
a747 3
    short stbl_align = HT_ALIGN_NONE;
    int status = HT_OK;

d749 7
a755 2
    char *class_name;
    int class_used = 0;
d758 1
a758 1
#ifdef USE_PRETTYSRC
d761 1
a761 1
	    HTTag *tag = &HTML_dtd.tags[element_number];
d763 1
a763 2
	    const char *p;

d765 1
a765 1
		psrc_first_tag = FALSE;
d770 4
a773 4
		 */
		psrc_nested_call = TRUE;
		HTML_start_element(me, HTML_BODY, NULL, NULL, tag_charset, NULL);
		HTML_start_element(me, HTML_PRE, NULL, NULL, tag_charset, NULL);
d775 1
a775 1
		psrc_nested_call = FALSE;
d778 3
a780 5
	    psrc_nested_call = TRUE;
	    /*write markup for tags and exit */
	    PSRCSTART(abracket);
	    PUTC('<');
	    PSRCSTOP(abracket);
d782 1
a782 1
	    if (tagname_transform != 0)
d785 1
a785 1
		LYstrncpy(buf, tag->name, sizeof(buf) - 1);
d794 1
a794 1
			if (attrname_transform != 0)
d797 1
a797 3
			    LYstrncpy(buf,
				      tag->attributes[i].name,
				      sizeof(buf) - 1);
d802 7
a808 9
			    char q = '"';

			    /*0 in dquotes, 1 - in quotes, 2 mixed */
			    char kind = (char) (!strchr(value[i], '"') ?
						0 :
						!strchr(value[i], '\'') ?
						q = '\'', 1 :
						2);

d815 2
a816 2
				HTStartAnchor(me, value[i], NULL);
				HTML_end_element(me, HTML_A, NULL);
d819 1
a819 1
				HTStartAnchor(me, NULL, value[i]);
d821 1
a821 1
			    if (kind != 2)
d831 1
a831 1
				HTML_end_element(me, HTML_A, NULL);
d836 3
a838 3
			}	/* if value */
		    }		/* if present[i] */
	    }			/* if present */
d840 5
a844 7
	    PSRCSTART(abracket);
	    PUTC('>');
	    PSRCSTOP(abracket);
	    psrc_nested_call = FALSE;
	    return HT_OK;
	}			/*if (!psrc_nested_call) */
	/*fall through */
d846 1
a846 1
#endif /* USE_PRETTYSRC */
d850 2
a851 3
	      ElementNumber == HTML_BASE || ElementNumber == HTML_OBJECT ||
	      ElementNumber == HTML_A)) {
	    return HT_OK;
d855 3
a857 1
    } {
d861 4
a864 4
	if ((me->tag_charset != j) || (j < 0 /* for trace entry */ )) {
	    CTRACE((tfp, "me->tag_charset: %d -> %d", me->tag_charset, j));
	    CTRACE((tfp, " (me->UCLYhndl: %d, tag_charset: %d)\n",
		    me->UCLYhndl, tag_charset));
d872 12
a883 4
    addClassName(";",
		 HTML_dtd.tags[element_number].name,
		 HTML_dtd.tags[element_number].name_len);

d889 2
a890 2
	    ? -1
	    : cached_tag_styles[element_number];
a894 1
    CTRACE2(TRACE_STYLE, (tfp, "CSS.elt:<%s>\n", HTML_dtd.tags[element_number].name));
d896 20
a915 4
    if (current_tag_style == -1) {	/* Append class_name */
	hcode = hash_code_lowercase_on_fly(HTML_dtd.tags[element_number].name);
	if (class_name[0]) {
	    int ohcode = hcode;
d919 26
a944 13
	    if (!hashStyles[hcode].name) {	/* None such -> classless version */
		hcode = ohcode;
		CTRACE2(TRACE_STYLE,
			(tfp,
			 "STYLE.start_element: <%s> (class <%s> not configured), hcode=%d.\n",
			 HTML_dtd.tags[element_number].name, class_name, hcode));
	    } else {
		addClassName(".", class_name, strlen(class_name));

		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.start_element: <%s>.<%s>, hcode=%d.\n",
			 HTML_dtd.tags[element_number].name, class_name, hcode));
		class_used = 1;
d947 4
d952 7
a958 3
	class_string[0] = '\0';

    } else {			/* (current_tag_style!=-1)  */
d960 12
a971 1
	    addClassName(".", class_name, strlen(class_name));
d975 1
a975 3
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE.start_element: <%s>, hcode=%d.\n",
		 HTML_dtd.tags[element_number].name, hcode));
d979 9
a987 17
#if !OMIT_SCN_KEEPING		/* Can be done in other cases too... */
    if (!class_used && ElementNumber == HTML_INPUT) {	/* For some other too? */
	const char *type = "";
	int ohcode = hcode;

	if (present && present[HTML_INPUT_TYPE] && value[HTML_INPUT_TYPE])
	    type = value[HTML_INPUT_TYPE];

	hcode = hash_code_aggregate_lower_str(".type.", hcode);
	hcode = hash_code_aggregate_lower_str(type, hcode);
	if (!hashStyles[hcode].name) {	/* None such -> classless version */
	    hcode = ohcode;
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.start_element: type <%s> not configured.\n",
		     type));
	} else {
	    addClassName(".type.", type, strlen(type));
a988 6
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.start_element: <%s>.type.<%s>, hcode=%d.\n",
		     HTML_dtd.tags[element_number].name, type, hcode));
	}
    }
#endif /* !OMIT_SCN_KEEPING */
a989 1
    HText_characterStyle(me->text, hcode, 1);
d993 1
a993 1
     * Handle the start tag.  - FM
d1005 1
a1005 1
	    non_empty(value[HTML_BASE_HREF])) {
d1007 1
a1007 1
	    const char *related = NULL;
a1009 2
	    CTRACE((tfp, "*HTML_BASE: initial href=`%s'\n", NonNull(base)));

d1011 2
a1012 2
		CTRACE((tfp, "HTML: BASE '%s' is not an absolute URL.\n",
			NonNull(base)));
d1020 6
a1025 5
		 * These have a non-standard form, basically strip the prefix
		 * or the code below would insert a nonsense host into the
		 * pseudo URL.  These should never occur where they would be
		 * used for resolution of relative URLs anyway.  We can also
		 * strip the #map part.  - kw
d1027 8
a1034 3
		temp = base;
		base = HTParse(base + 11, "", PARSE_ALL_WITHOUT_ANCHOR);
		FREE(temp);
d1038 1
a1038 1
	     * Get parent's address for defaulted fields.
d1040 1
a1040 1
	    related = me->node_anchor->address;
d1043 1
a1043 1
	     * Create the access field.
d1045 9
a1053 2
	    temp = HTParse(base, related, PARSE_ACCESS + PARSE_PUNCTUATION);
	    StrAllocCopy(me->base_href, temp);
d1057 1
a1057 1
	     * Create the host[:port] field.
d1059 3
a1061 2
	    temp = HTParse(base, "", PARSE_HOST + PARSE_PUNCTUATION);
	    if (!strncmp(temp, "//", 2)) {
d1067 1
a1067 1
		if (isFILE_URL(me->base_href)) {
d1069 1
a1069 1
		} else if (strcmp(me->base_href, STR_NEWS_URL)) {
d1072 1
a1072 1
							       PARSE_HOST + PARSE_PUNCTUATION)));
d1076 1
d1079 1
a1079 1
	     * Create the path field.
d1081 3
a1083 10
	    temp = HTParse(base, "", PARSE_PATH + PARSE_PUNCTUATION);
	    if (*temp != '\0') {
		char *p = strchr(temp, '?');

		if (p)
		    *p = '\0';
		p = strrchr(temp, '/');
		if (p)
		    *(p + 1) = '\0';	/* strip after the last slash */

d1085 1
a1085 1
	    } else if (!strcmp(me->base_href, STR_NEWS_URL)) {
d1087 3
a1089 3
	    } else if (isNEWS_URL(me->base_href) ||
		       isNNTP_URL(me->base_href) ||
		       isSNEWS_URL(me->base_href)) {
a1097 1
	    me->node_anchor->inBASE = TRUE;
a1098 3
	    /* me->base_href is a valid URL */

	    CTRACE((tfp, "*HTML_BASE: final href=`%s'\n", me->base_href));
d1112 1
d1114 1
d1116 1
a1116 1
	    CHECK_FOR_INTERN(intern_flag, value[HTML_LINK_HREF]);
d1118 1
a1118 1
	     * Prepare to do housekeeping on the reference.  - FM
d1121 5
a1125 4
		Base = (me->inBASE)
		    ? me->base_href
		    : me->node_anchor->address;
		StrAllocCopy(href, Base);
d1129 13
d1143 7
a1149 5
		Base = (me->inBASE && *href != '\0' && *href != '#')
		    ? me->base_href
		    : me->node_anchor->address;
		HTParseALL(&href, Base);
	    }
d1152 1
a1152 1
	     * Handle links with a REV attribute.  - FM
d1157 1
a1157 1
		 * Handle REV="made" or REV="owner".  - LM & FM
d1162 1
a1162 1
		     * Load the owner element.  - FM
d1164 12
d1177 1
a1177 1
		    CTRACE((tfp, "HTML: DOC OWNER '%s' found\n", href));
d1181 2
a1182 2
		     * Load the RevTitle element if a TITLE attribute and value
		     * are present.  - FM
d1200 1
a1200 1
	     * Handle REL links.  - FM
d1206 1
a1206 5
		 * Ignore style sheets, for now.  - FM
		 *
		 * lss and css have different syntax - lynx shouldn't try to
		 * parse them now (it tries to parse them as lss, so it exits
		 * with error message on the 1st non-empty line) - VH
d1208 4
d1215 32
a1246 4
		    CTRACE2(TRACE_STYLE,
			    (tfp, "HTML: StyleSheet link found.\n"));
		    CTRACE2(TRACE_STYLE,
			    (tfp, "        StyleSheets not yet implemented.\n"));
d1253 6
a1258 6
		 * Ignore anything not registered in the 28-Mar-95 IETF HTML
		 * 3.0 draft and W3C HTML 3.2 draft, or not appropriate for
		 * Lynx banner links in the expired Maloney and Quin relrev
		 * draft.  We'll make this more efficient when the situation
		 * stabilizes, and for now, we'll treat "Banner" as another
		 * toolbar element.  - FM
d1289 18
a1306 17
		    pdoctitle = &title;		/* for setting HTAnchor's title */
		} else if (!strcasecomp(value[HTML_LINK_REL], "Up") ||
			   !strcasecomp(value[HTML_LINK_REL], "Next") ||
			   !strcasecomp(value[HTML_LINK_REL], "Previous") ||
			   !strcasecomp(value[HTML_LINK_REL], "Prev") ||
			   !strcasecomp(value[HTML_LINK_REL], "Child") ||
			   !strcasecomp(value[HTML_LINK_REL], "Sibling") ||
			   !strcasecomp(value[HTML_LINK_REL], "Parent") ||
			   !strcasecomp(value[HTML_LINK_REL], "Meta") ||
			   !strcasecomp(value[HTML_LINK_REL], "URC") ||
			   !strcasecomp(value[HTML_LINK_REL], "Pointer") ||
			   !strcasecomp(value[HTML_LINK_REL], "Translation") ||
			   !strcasecomp(value[HTML_LINK_REL], "Definition") ||
			   !strcasecomp(value[HTML_LINK_REL], "Alternate") ||
			   !strcasecomp(value[HTML_LINK_REL], "Section") ||
			   !strcasecomp(value[HTML_LINK_REL], "Subsection") ||
			   !strcasecomp(value[HTML_LINK_REL], "Chapter")) {
a1317 8
#ifndef DISABLE_BIBP
		} else if (!strcasecomp(value[HTML_LINK_REL], "citehost")) {
		    /*  Citehost determination for bibp links. - RDC */
		    HTAnchor_setCitehost(me->node_anchor, href);
		    CTRACE((tfp, "HTML: citehost '%s' found\n", href));
		    FREE(href);
		    break;
#endif
d1319 2
a1320 2
		    CTRACE((tfp, "HTML: LINK with REL=\"%s\" ignored.\n",
			    value[HTML_LINK_REL]));
d1328 2
a1329 2
	     * If no HREF was specified, handle special REL links with
	     * self-designated HREFs.  - FM
d1338 2
a1339 3
		CTRACE((tfp,
			"HTML: LINK with REL=\"%s\" and no HREF ignored.\n",
			value[HTML_LINK_REL]));
d1347 3
a1349 2
	     * Create a title (link name) from the TITLE value, if present, or
	     * default to the REL value that was loaded into title.  - FM
d1352 1
a1352 1
		non_empty(value[HTML_LINK_TITLE])) {
d1358 1
a1358 1
		FREE(temp);	/* forget about recording RelTitle - kw */
d1360 1
a1360 1
	    if (isEmpty(title)) {
d1368 4
a1371 3
		 * Ugh!  The LINK tag, which is a HEAD element, is in an
		 * Anchor, which is BODY element.  All we can do is close the
		 * Anchor and cross our fingers.  - FM
d1378 2
a1379 1
	     * Create anchors for the links that simulate a toolbar.  - FM
d1381 7
a1387 7
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (temp
						      ? (HTLinkType *)
						      HTAtom_for(temp)
						      : INTERN_LT));	/* Type */
d1389 3
a1391 2
	    if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		 )) != NULL) {
d1394 1
a1394 5

		/* Don't allow CHARSET attribute to change *this* document's
		   charset assumption. - kw */
		if (dest == me->node_anchor)
		    dest = NULL;
d1396 1
a1396 1
		    non_empty(value[HTML_LINK_CHARSET])) {
d1400 2
d1403 1
a1403 1
		if (dest && dest_char_set >= 0)
d1410 5
a1414 4
		(ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						  LYToolbarName,	/* Tag */
						  NULL,		/* Addresss */
						  (HTLinkType *) 0))) {		/* Type */
d1416 1
a1416 1
		HText_setLastChar(me->text, ' ');	/* absorb white space */
a1419 6
	    } else {
		/*
		 * Add collapsible space to separate link from previous
		 * generated links.  - kw
		 */
		HTML_put_character(me, ' ');
d1426 2
a1427 1
		non_empty(value[HTML_LINK_CLASS])) {
a1428 1

d1430 1
a1430 2
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.link: using style <%s>\n", tmp));
d1439 2
a1440 1
	    } else
d1442 1
a1442 1
		HTML_put_string(me, title);
d1455 3
d1459 4
a1462 4
	     * Lynx was supporting ACTION, which never made it into the HTML
	     * 2.0 specs.  HTML 3.0 uses HREF, so we'll use that too, but allow
	     * use of ACTION as an alternate until people have fully switched
	     * over.  - FM
d1465 1
a1465 1
		StrAllocCopy(href, value[HTML_ISINDEX_HREF]);
d1467 2
a1468 2
		StrAllocCopy(href, value[HTML_ISINDEX_ACTION]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
d1470 16
a1485 6
	    Base = (me->inBASE && *href != '\0' && *href != '#')
		? me->base_href
		: me->node_anchor->address;
	    HTParseALL(&href, Base);
	    HTAnchor_setIndex(me->node_anchor, href);
	    FREE(href);
d1488 10
a1497 3
	    Base = (me->inBASE) ?
		me->base_href : me->node_anchor->address;
	    HTAnchor_setIndex(me->node_anchor, Base);
d1500 1
a1500 1
	 * Support HTML 3.0 PROMPT attribute.  - FM
d1504 1
a1504 1
	    non_empty(value[HTML_ISINDEX_PROMPT])) {
d1522 2
d1528 2
a1529 2
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
d1536 2
a1537 2
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
d1553 1
a1553 1
	    non_empty(value[HTML_FRAME_NAME])) {
d1560 1
a1560 1
	    non_empty(value[HTML_FRAME_SRC])) {
d1562 22
a1583 1
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
d1589 5
a1593 5
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
	    CAN_JUSTIFY_PUSH(FALSE);
a1600 1

a1611 1
	    CAN_JUSTIFY_POP;
d1625 1
a1625 1
	    non_empty(value[HTML_IFRAME_NAME])) {
d1632 1
a1632 1
	    non_empty(value[HTML_IFRAME_SRC])) {
d1634 22
a1655 1
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
d1659 5
a1663 5

	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
d1665 1
a1665 2
	    CAN_JUSTIFY_PUSH_F
		LYResetParagraphAlignment(me);
a1671 1

a1682 1
	    CAN_JUSTIFY_POP;
d1693 1
a1693 1
	if (me->sp->tag_number == (int) ElementNumber)
d1696 3
a1698 2
	 * Treat this as a toolbar if we don't have one yet, and we are in the
	 * first half of the first page.  - FM
d1701 6
a1706 5
	     HText_getLines(me->text) < (display_lines / 2)) &&
	    (ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
					      LYToolbarName,	/* Tag */
					      NULL,	/* Addresss */
					      (HTLinkType *) 0))) {	/* Type */
d1719 3
a1721 3
	    CTRACE((tfp,
		    "HTML: ****** Maximum nesting of %d divisions exceeded!\n",
		    MAX_NESTING));
a1722 2
	if (me->inP)
	    LYEnsureSingleSpace(me);	/* always at least break line - kw */
a1727 20
	} else if (me->List_Nesting_Level >= 0 &&
		   !(present && present[HTML_DIV_ALIGN] &&
		     value[HTML_DIV_ALIGN] &&
		     (!strcasecomp(value[HTML_DIV_ALIGN], "center") ||
		      !strcasecomp(value[HTML_DIV_ALIGN], "right")))) {
	    if (present && present[HTML_DIV_ALIGN])
		me->current_default_alignment = HT_LEFT;
	    else if (me->Division_Level == 0)
		me->current_default_alignment = HT_LEFT;
	    else if (me->sp[0].tag_number == HTML_UL ||
		     me->sp[0].tag_number == HTML_OL ||
		     me->sp[0].tag_number == HTML_MENU ||
		     me->sp[0].tag_number == HTML_DIR ||
		     me->sp[0].tag_number == HTML_LI ||
		     me->sp[0].tag_number == HTML_LH ||
		     me->sp[0].tag_number == HTML_DD)
		me->current_default_alignment = HT_LEFT;
	    LYHandlePlike(me, present, value, include, HTML_DIV_ALIGN, TRUE);
	    me->DivisionAlignments[me->Division_Level] = (short)
		me->current_default_alignment;
d1729 1
a1729 1
		   non_empty(value[HTML_DIV_ALIGN])) {
d1762 10
a1771 10
	 * Close the previous style if not done by HTML doc.  Added to get rid
	 * of core dumps in BAD HTML on the net.
	 *              GAB 07-07-94
	 * But then again, these are actually allowed to nest.  I guess I have
	 * to depend on the HTML writers correct style.
	 *              GAB 07-12-94
	 if (i_prior_style != -1) {
	 HTML_end_element(me, i_prior_style);
	 }
	 i_prior_style = ElementNumber;
d1775 2
a1776 2
	 * Check whether we have an H# in a list, and if so, treat it as an LH. 
	 * - FM
d1782 1
a1782 2
	     me->sp[0].tag_number == HTML_DIR ||
	     me->sp[0].tag_number == HTML_LI)) {
d1787 1
a1787 1
		ElementNumber = (HTMLElement) me->sp[0].tag_number;
d1791 8
a1798 6
	     * Some authors use H# headers as a substitute for FONT, so check
	     * if this one immediately followed an LI.  If so, both me->inP and
	     * me->in_word will be FALSE (though the line might not be empty
	     * due to a bullet and/or nbsp) and we can assume it is just for a
	     * FONT change.  We thus will not create another line break nor add
	     * to the current left indentation.  - FM
d1812 1
a1812 1
	    non_empty(value[HTML_H_ALIGN])) {
d1838 1
a1838 1
	    (styles[ElementNumber]->font & HT_BOLD)) {
d1847 1
a1847 2
	LYHandlePlike(me, present, value, include, HTML_P_ALIGN, TRUE);
	CHECK_ID(HTML_P_ID);
d1853 6
a1858 6
	/* Add a \r (new line) if these three conditions are true:
	 *   1. We are not collapsing BR's, and
	 *   2. The previous line has text on it, or
	 *   3. This line has text on it.
	 * Otherwise, don't do anything. -DH 980814, TD 980827
	 */
d1860 3
a1862 3
	     !HText_PreviousLineEmpty(me->text, FALSE)) ||
	    !HText_LastLineEmpty(me->text, FALSE)) {
	    HText_setLastChar(me->text, ' ');	/* absorb white space */
d1887 4
a1890 3
	     * Start a new line only if we had printable characters following
	     * the previous newline, or remove the previous line if both it and
	     * the last line are blank.  - FM
d1893 2
a1894 2
	    if (!HText_LastLineEmpty(me->text, FALSE)) {
		HText_setLastChar(me->text, ' ');	/* absorb white space */
d1896 1
a1896 1
	    } else if (HText_PreviousLineEmpty(me->text, FALSE)) {
d1903 1
a1903 1
	     * Add an ID link if needed.  - FM
d1907 7
a1913 6
	    /*
	     * Center lines within the current margins, if a right or left
	     * ALIGNment is not specified.  If WIDTH="#%" is given and not
	     * garbage, use that to calculate the width, otherwise use the
	     * default width.  - FM
	     */
d1925 2
a1926 2
	    width = LYcolLimit -
		me->new_style->leftIndent - me->new_style->rightIndent;
d1928 2
a1929 2
		isdigit(UCH(*value[HTML_HR_WIDTH])) &&
		value[HTML_HR_WIDTH][strlen(value[HTML_HR_WIDTH]) - 1] == '%') {
a1931 1

d1933 1
a1933 1
		percent[strlen(percent) - 1] = '\0';
d1955 2
a1956 2
	     * Reset the alignment appropriately for the division and/or block. 
	     * - FM
d1961 3
a1963 3
		    me->DivisionAlignments[me->Division_Level];
	    } else if (me->sp->style->id == ST_HeadingCenter ||
		       me->sp->style->id == ST_Heading1) {
d1965 1
a1965 1
	    } else if (me->sp->style->id == ST_HeadingRight) {
d1972 3
a1974 2
	     * Add a blank line and set the second line indentation for lists
	     * and addresses, or a paragraph separator for other blocks.  - FM
d1978 1
a1978 1
		HText_setLastChar(me->text, ' ');	/* absorb white space */
d1987 2
a1988 2
	if (!present) {		/* Bad tag.  Must have at least one attribute. - FM */
	    CTRACE((tfp, "HTML: TAB tag has no attributes.  Ignored.\n"));
a1990 6
	/*
	 * If page author is using TAB within a TABLE, it's probably formatted
	 * specifically to work well for Lynx without simple table tracking
	 * code.  Cancel tracking, it would only make things worse.  - kw
	 */
	HText_cancelStbl(me->text);
a1992 1
	CANT_JUSTIFY_THIS_LINE;
d1997 2
a1998 2
	     * Just ensure a collapsible space, until we have the ALIGN and DP
	     * attributes implemented.  - FM
d2001 1
a2001 2
	    CTRACE((tfp,
		    "HTML: ALIGN not 'left'.  Using space instead of TAB.\n"));
d2006 4
a2009 3
	     * Just ensure a collapsible space, until we can replace
	     * HText_getCurrentColumn() in GridText.c with code which doesn't
	     * require that the alignment be HT_LEFT.  - FM
d2012 1
a2012 1
	    CTRACE((tfp, "HTML: Not HT_LEFT.  Using space instead of TAB.\n"));
d2015 1
a2015 1
		    non_empty(value[HTML_TAB_TO])) ||
d2018 1
a2018 1
		    isdigit(UCH(*value[HTML_TAB_INDENT])))) {
d2025 1
a2025 1
		 * TO has priority over INDENT if both are present.  - FM
d2032 1
a2032 1
	    } else if (isEmpty(temp) && present[HTML_TAB_INDENT] &&
d2034 1
a2034 1
		       isdigit(UCH(*value[HTML_TAB_INDENT]))) {
d2036 2
a2037 2
		 * The INDENT value is in "en" (enval per column) units.
		 * Divide it by enval, rounding odd values up.  - FM
d2040 1
a2040 1
		    (int) (((1.0 * atoi(value[HTML_TAB_INDENT])) / enval) + (0.5));
d2044 3
a2046 3
	     * If we are being directed to a column too far to the left or
	     * right, just add a collapsible space, otherwise, add the
	     * appropriate number of spaces.  - FM
a2047 1

d2051 1
a2051 2
		CTRACE((tfp,
			"HTML: Column out of bounds.  Using space instead of TAB.\n"));
d2055 1
a2055 1
		HText_setLastChar(me->text, ' ');	/* absorb white space */
d2061 2
a2062 2
	 * If we have an ID attribute, save it together with the value of the
	 * column we've reached.  - FM
d2065 1
a2065 1
	    non_empty(value[HTML_TAB_ID])) {
d2080 7
a2086 6
	 * FONT *may* have been declared SGML_EMPTY in HTMLDTD.c, and
	 * SGML_character() in SGML.c *may* check for a FONT end tag to call
	 * HTML_end_element() directly (with a check in that to bypass
	 * decrementing of the HTML parser's stack).  Or this may have been
	 * really a </FONT> end tag, for which some incarnations of SGML.c
	 * would fake a <FONT> start tag instead.  - fm & kw
d2088 3
a2090 3
	 * But if we have an open FONT, DON'T close that one now, since FONT
	 * tags can be legally nested AFAIK, and Lynx currently doesn't do
	 * anything with them anyway...  - kw
d2098 2
a2099 2
	 * Set flag to know we are in a FONT container, and add code to do
	 * something about it, someday.  - FM
d2104 1
a2104 1
    case HTML_B:		/* Physical character highlighting */
d2109 1
a2109 1
    case HTML_CITE:		/* Logical character highlighting */
d2116 2
a2117 2
	 * Ignore this if inside of a bold anchor or header.  Can't display
	 * both underline and bold at same time.
d2120 1
a2120 1
	    CTRACE((tfp, "Underline Level is %d\n", me->Underline_Level));
d2126 1
a2126 1
	    CTRACE((tfp, "Beginning underline\n"));
d2128 1
a2128 1
	    CTRACE((tfp, "Underline Level is %d\n", me->Underline_Level));
d2132 1
a2132 1
    case HTML_ABBREV:		/* Miscellaneous character containers */
d2142 2
d2147 1
a2147 11
	break;			/* ignore */

    case HTML_SUP:
	HText_appendCharacter(me->text, '^');
	CHECK_ID(HTML_GEN_ID);
	break;

    case HTML_SUB:
	HText_appendCharacter(me->text, '[');
	CHECK_ID(HTML_GEN_ID);
	break;
d2176 5
a2180 4
	 * Should check LANG and/or DIR attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * to determine whether we should use chevrons, but for now we'll
	 * always use double- or single-quotes.  - FM
d2189 1
a2189 1
    case HTML_PRE:		/* Formatted text */
d2191 6
a2196 5
	 * Set our inPRE flag to FALSE so that a newline immediately following
	 * the PRE start tag will be ignored.  HTML_put_character() will set it
	 * to TRUE when the first character within the PRE block is received. 
	 * - FM
	 */
d2198 1
a2198 3
	/* FALLTHRU */
    case HTML_LISTING:		/* Literal text */
	/* FALLTHRU */
a2199 1
	/* FALLTHRU */
d2212 1
a2212 1
	if (me->sp->tag_number == (int) ElementNumber)
d2220 1
a2220 1
	if (me->sp->tag_number == (int) ElementNumber)
d2227 1
a2227 1
	     * Indicate the type of NOTE.
a2251 1
	    CAN_JUSTIFY_START;
a2253 1
	CAN_JUSTIFY_START;
d2262 1
a2262 1
	if (me->sp->tag_number == (int) ElementNumber)
d2268 1
a2268 1
	me->List_Nesting_Level++;	/* increment the List nesting level */
d2271 1
a2271 1
				   ? styles[HTML_DLC] : styles[HTML_DL]);
d2275 1
a2275 1
				   ? styles[HTML_DLC6] : styles[HTML_DL6]);
d2279 2
a2280 2
				   ? styles[(HTML_DLC1 - 1) + me->List_Nesting_Level]
				   : styles[(HTML_DL1 - 1) + me->List_Nesting_Level]);
d2282 1
a2282 1
	UPDATE_STYLE;		/* update to the new style */
a2283 1

d2287 1
a2287 1
	me->List_Nesting_Level++;	/* increment the List nesting level */
d2296 1
a2296 1
				   styles[(HTML_DLC1 - 1) + me->List_Nesting_Level]);
d2298 1
a2298 1
	UPDATE_STYLE;		/* update to the new style */
a2307 1

d2309 5
a2313 5
	     * If there are several DT elements and this is not the first, and
	     * the preceding DT element's first (and normally only) line has
	     * not yet been ended, suppress intervening blank line by
	     * temporarily modifying the paragraph style in place.  Ugly but
	     * there's ample precedence.  - kw
d2316 1
a2316 1
		me->sp->style->spaceBefore = 0;		/* temporary change */
d2320 2
a2321 2
	    me->sp->style->spaceBefore = saved_spaceBefore;	/* undo */
	    me->sp->style->spaceAfter = saved_spaceAfter;	/* undo */
d2330 3
a2332 3
	HText_setLastChar(me->text, ' ');	/* absorb white space */
	if (!me->style_change) {
	    if (!HText_LastLineEmpty(me->text, FALSE)) {
d2350 2
a2351 2
	me->OL_Type[(me->List_Nesting_Level < 11 ?
		     me->List_Nesting_Level + 1 : 11)] = '1';
d2354 3
a2356 2
	 * Check whether we have a starting sequence number, or want to
	 * continue the numbering from a previous OL in this nest.  - FM
d2362 4
a2365 4
	     * Give preference to the valid HTML 3.0 SEQNUM attribute name over
	     * the Netscape START attribute name (too bad the Netscape
	     * developers didn't read the HTML 3.0 specs before re-inventing
	     * the "wheel" as "we'll").  - FM
d2368 1
a2368 1
		non_empty(value[HTML_OL_SEQNUM])) {
d2371 1
a2371 1
		       non_empty(value[HTML_OL_START])) {
d2378 3
a2380 2
	     * Don't allow negative numbers less than or equal to our flags, or
	     * numbers less than 1 if an Alphabetic or Roman TYPE.  - FM
d2385 1
a2385 1
				 me->List_Nesting_Level + 1 : 11)] = 'A';
d2390 1
a2390 1
				 me->List_Nesting_Level + 1 : 11)] = 'a';
d2395 1
a2395 1
				 me->List_Nesting_Level + 1 : 11)] = 'I';
d2400 1
a2400 1
				 me->List_Nesting_Level + 1 : 11)] = 'i';
d2404 2
a2405 2
		    if (seqnum <= OL_VOID)
			seqnum = OL_VOID + 1;
d2412 1
a2412 1
			    me->List_Nesting_Level + 1 : 11)] = seqnum;
d2416 1
a2416 1
			   me->List_Nesting_Level + 1 : 11] = OL_CONTINUE;
d2420 1
a2420 1
			    me->List_Nesting_Level + 1 : 11)] = 1;
d2424 1
a2424 1
				 me->List_Nesting_Level + 1 : 11)] = 'A';
d2427 1
a2427 1
				 me->List_Nesting_Level + 1 : 11)] = 'a';
d2430 1
a2430 1
				 me->List_Nesting_Level + 1 : 11)] = 'I';
d2433 1
a2433 1
				 me->List_Nesting_Level + 1 : 11)] = 'i';
d2447 1
a2447 1
				   styles[HTML_OL1 + me->List_Nesting_Level - 1]);
d2449 1
a2449 1
	UPDATE_STYLE;		/* update to the new style */
d2460 1
a2460 1
		  0 == strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
d2471 1
a2471 1
		  0 == strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
d2482 1
a2482 1
		  0 == strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
d2484 1
a2484 2
				       styles[HTML_OL1 + me->List_Nesting_Level
					      - 1]);
d2487 1
a2487 2
				       styles[HTML_MENU1 + me->List_Nesting_Level
					      - 1]);
d2491 1
a2491 1
	UPDATE_STYLE;		/* update to the new style */
d2507 1
a2507 2
				   styles[HTML_MENU1 + me->List_Nesting_Level
					  - 1]);
d2509 1
a2509 1
	UPDATE_STYLE;		/* update to the new style */
d2514 1
a2514 1
	UPDATE_STYLE;		/* update to the new style */
d2524 1
a2524 1
	UPDATE_STYLE;		/* update to the new style */
d2528 38
a2565 43
	{
	    int surrounding_tag_number = me->sp[0].tag_number;

	    /*
	     * No, a LI should never occur directly within another LI, but this
	     * may result from incomplete error recovery.  So check one more
	     * surrounding level in this case.  - kw
	     */
	    if (surrounding_tag_number == HTML_LI &&
		me->sp < (me->stack + MAX_NESTING - 1))
		surrounding_tag_number = me->sp[1].tag_number;
	    if (surrounding_tag_number == HTML_OL) {
		char number_string[20];
		int counter, seqnum;
		char seqtype;

		counter = me->List_Nesting_Level < 11 ?
		    me->List_Nesting_Level : 11;
		if (present && present[HTML_LI_TYPE] && value[HTML_LI_TYPE]) {
		    if (*value[HTML_LI_TYPE] == '1') {
			me->OL_Type[counter] = '1';
		    } else if (*value[HTML_LI_TYPE] == 'A') {
			me->OL_Type[counter] = 'A';
		    } else if (*value[HTML_LI_TYPE] == 'a') {
			me->OL_Type[counter] = 'a';
		    } else if (*value[HTML_LI_TYPE] == 'I') {
			me->OL_Type[counter] = 'I';
		    } else if (*value[HTML_LI_TYPE] == 'i') {
			me->OL_Type[counter] = 'i';
		    }
		}
		if (present && present[HTML_LI_VALUE] &&
		    ((value[HTML_LI_VALUE] != NULL) &&
		     (*value[HTML_LI_VALUE] != '\0')) &&
		    ((isdigit(UCH(*value[HTML_LI_VALUE]))) ||
		     (*value[HTML_LI_VALUE] == '-' &&
		      isdigit(UCH(*(value[HTML_LI_VALUE] + 1)))))) {
		    seqnum = atoi(value[HTML_LI_VALUE]);
		    if (seqnum <= OL_VOID)
			seqnum = OL_VOID + 1;
		    seqtype = me->OL_Type[counter];
		    if (seqtype != '1' && seqnum < 1)
			seqnum = 1;
d2567 9
a2575 16
		} else if (me->OL_Counter[counter] >= OL_VOID) {
		    seqnum = me->OL_Counter[counter]++;
		    seqtype = me->OL_Type[counter];
		    if (seqtype != '1' && seqnum < 1) {
			seqnum = 1;
			me->OL_Counter[counter] = seqnum + 1;
		    }
		} else {
		    seqnum = me->Last_OL_Count + 1;
		    seqtype = me->Last_OL_Type;
		    for (i = (counter - 1); i >= 0; i--) {
			if (me->OL_Counter[i] > OL_VOID) {
			    seqnum = me->OL_Counter[i]++;
			    seqtype = me->OL_Type[i];
			    i = 0;
			}
d2578 22
a2599 21
		if (seqtype == 'A') {
		    sprintf(number_string, LYUppercaseA_OL_String(seqnum));
		} else if (seqtype == 'a') {
		    sprintf(number_string, LYLowercaseA_OL_String(seqnum));
		} else if (seqtype == 'I') {
		    sprintf(number_string, LYUppercaseI_OL_String(seqnum));
		} else if (seqtype == 'i') {
		    sprintf(number_string, LYLowercaseI_OL_String(seqnum));
		} else {
		    sprintf(number_string, "%2d.", seqnum);
		}
		me->Last_OL_Count = seqnum;
		me->Last_OL_Type = seqtype;
		/*
		 * Hack, because there is no append string!
		 */
		for (i = 0; number_string[i] != '\0'; i++)
		    if (number_string[i] == ' ')
			HTML_put_character(me, HT_NON_BREAK_SPACE);
		    else
			HTML_put_character(me, number_string[i]);
d2601 18
a2618 17
		/*
		 * Use HTML_put_character so that any other spaces coming
		 * through will be collapsed.  We'll use nbsp, so it won't
		 * break at the spacing character if there are no spaces in the
		 * subsequent text up to the right margin, but will declare it
		 * as a normal space to ensure collapsing if a normal space
		 * does immediately follow it.  - FM
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
	    } else if (surrounding_tag_number == HTML_UL) {
		/*
		 * Hack, because there is no append string!
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		switch (me->List_Nesting_Level % 7) {
a2640 18
		}
		/*
		 * Keep using HTML_put_character so that any other spaces
		 * coming through will be collapsed.  We use nbsp, so we won't
		 * wrap at the spacing character if there are no spaces in the
		 * subsequent text up to the right margin, but will declare it
		 * as a normal space to ensure collapsing if a normal space
		 * does immediately follow it.  - FM
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
	    } else {
		/*
		 * Hack, because there is no append string!
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
d2642 18
a2660 1
	CAN_JUSTIFY_START;
d2668 3
a2670 3
	 * Should check LANG and/or DIR attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * and do something here.  - FM
d2677 3
a2679 3
	 * Should check DIR (and LANG) attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * and do something here.  - FM
d2690 1
a2690 1
	if (me->sp->tag_number == (int) ElementNumber)
d2699 1
a2699 2
	CAN_JUSTIFY_START
	    me->inLABEL = TRUE;
d2706 6
a2711 23
	 * If we are looking for client-side image maps, then handle an A
	 * within a MAP that has a COORDS attribute as an AREA tag. 
	 * Unfortunately we lose the anchor text this way for the LYNXIMGMAP,
	 * we would have to do much more parsing to collect it.  After
	 * potentially handling the A as AREA, always return immediately if
	 * only looking for image maps, without pushing anything on the style
	 * stack.  - kw
	 */
	if (me->map_address && present && present[HTML_A_COORDS])
	    LYStartArea(me,
			present[HTML_A_HREF] ? value[HTML_A_HREF] : NULL,
			NULL,
			present[HTML_A_TITLE] ? value[HTML_A_TITLE] : NULL,
			tag_charset);
	if (LYMapsOnly) {
	    return HT_OK;
	}
	/*
	 * A may have been declared SGML_EMPTY in HTMLDTD.c, and
	 * SGML_character() in SGML.c may check for an A end tag to call
	 * HTML_end_element() directly (with a check in that to bypass
	 * decrementing of the HTML parser's stack), so if we have an open A,
	 * close that one now.  - FM & kw
d2718 1
a2718 1
	 * Set to know we are in an anchor.
d2723 1
a2723 1
	 * Load id_string if we have an ID or NAME.  - FM
d2726 1
a2726 1
	    non_empty(value[HTML_A_ID])) {
d2729 1
a2729 1
		   non_empty(value[HTML_A_NAME])) {
d2732 1
a2732 1
	if (id_string)
d2734 4
d2740 1
a2740 1
	 * Handle the reference.  - FM
d2743 6
d2750 1
a2750 1
	     * Set to know we are making the content bold.
d2752 11
a2762 1
	    me->inBoldA = TRUE;
d2764 9
a2772 4
	    StrAllocCopy(href, value[HTML_A_HREF]);
	    if (isEmpty(href))
		StrAllocCopy(href, "#");
	    CHECK_FOR_INTERN(intern_flag, href);	/* '#' */
d2774 4
a2777 5
	    if (intern_flag) { /*** FAST WAY: ***/
		TRANSLATE_AND_UNESCAPE_TO_STD(&href);

	    } else {
		url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
d2779 6
d2786 1
a2786 1
		 * Deal with our ftp gateway kludge.  - FM
d2788 2
a2789 6
		if (!url_type && !strncmp(href, "/foo/..", 7) &&
		    (isFTP_URL(me->node_anchor->address) ||
		     isFILE_URL(me->node_anchor->address))) {
		    for (i = 0; (href[i] = href[i + 7]) != 0; i++) ;
		}
	    }
d2791 7
a2797 2
	    if (present[HTML_A_ISMAP])	/*??? */
		intern_flag = FALSE;
d2803 1
a2803 1

d2806 4
a2809 5
	    if (!intern_flag &&
		!strcasecomp(value[HTML_A_TYPE], HTAtom_name(HTInternalLink)) &&
		!LYIsUIPage3(me->node_anchor->address, UIP_LIST_PAGE, 0) &&
		!LYIsUIPage3(me->node_anchor->address, UIP_ADDRLIST_PAGE, 0) &&
		!isLYNXIMGMAP(me->node_anchor->address)) {
d2811 5
a2815 5
		 * Found TYPE="internal link" but not in a valid context
		 * where we have written it. - kw
		 */
		CTRACE((tfp, "HTML: Found invalid HREF=\"%s\" TYPE=\"%s\"!\n",
			href, temp));
d2819 1
d2821 6
a2826 7
	me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						 id_string,	/* Tag */
						 href,	/* Address */
						 (temp
						  ? (HTLinkType *)
						  HTAtom_for(temp)
						  : INTERN_LT));	/* Type */
d2832 1
a2832 1
		non_empty(value[HTML_A_TITLE])) {
d2844 1
a2844 1
		non_empty(value[HTML_A_CHARSET])) {
d2846 4
a2849 4
		 * Set up to load the anchor's chartrans structures
		 * appropriately for the current display character set if it
		 * can handle what's claimed.  - FM
		 */
d2854 3
a2856 1
		    dest_char_set = UCLYhndl_for_unrec;
d2860 3
a2862 2
		dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		    );
d2868 7
a2874 8
	    /* Don't allow CHARSET attribute to change *this* document's
	       charset assumption. - kw */
	    if (dest && dest != me->node_anchor && dest_char_set >= 0) {
		/*
		 * Load the anchor's chartrans structures.  This should be done
		 * more intelligently when setting up the structured object,
		 * but it gets the job done for now.  - FM
		 */
d2891 1
a2891 1
#if defined(NOTUSED_FOTEMODS)
d2893 3
a2895 3
	 * Close an HREF-less NAMED-ed now if we aren't making their content
	 * bold, and let the check in HTML_end_element() deal with any dangling
	 * end tag this creates.  - FM
d2899 1
a2899 1
	    HTML_end_element(me, HTML_A, include);
d2901 1
a2901 8
#else
	/*Close an HREF-less NAMED-ed now if force_empty_hrefless_a was
	   requested - VH */
	if (href == NULL && force_empty_hrefless_a) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
#endif
d2905 1
a2905 1
    case HTML_IMG:		/* Images */
d2907 4
a2910 3
	 * If we're in an anchor, get the destination, and if it's a clickable
	 * image for the current anchor, set our flags for faking a 0,0
	 * coordinate pair, which typically returns the image's default.  - FM
d2913 3
a2915 2
	    if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		 )) != NULL) {
d2918 2
a2919 2
		    CTRACE((tfp, "HTML: '%s' is an ISMAP script\n",
			    dest->address));
d2923 2
a2924 2
		    CTRACE((tfp, "HTML: Designating '%s' as an ISMAP script\n",
			    dest->address));
d2929 1
d2931 1
d2933 1
a2933 1
	 * If there's a USEMAP, resolve it.  - FM
d2936 1
a2936 1
	    non_empty(value[HTML_IMG_USEMAP])) {
d2938 1
a2938 1
	    CHECK_FOR_INTERN(intern_flag, map_href);
d2941 2
a2942 2
	     * If map_href ended up zero-length or otherwise doesn't have a
	     * hash, it can't be valid, so ignore it.  - FM
d2944 1
a2944 1
	    if (findPoundSelector(map_href) == NULL) {
d2950 1
a2950 1
	 * Handle a MAP reference if we have one at this point.  - FM
d2954 32
a2985 2
	     * If the MAP reference doesn't yet begin with a scheme, check
	     * whether a base tag is in effect.  - FM
d2987 5
d2993 2
a2994 3
	     * If the USEMAP value is a lone fragment and LYSeekFragMAPinCur is
	     * set, we'll use the current document's URL for resolving. 
	     * Otherwise use the BASE.  - kw
d2996 5
a3000 4
	    Base = (me->inBASE &&
		    !(*map_href == '#' && LYSeekFragMAPinCur == TRUE)) ?
		me->base_href : me->node_anchor->address;
	    HTParseALL(&map_href, Base);
d3003 1
a3003 1
	     * Prepend our client-side MAP access field.  - FM
d3005 1
a3005 1
	    StrAllocCopy(temp, STR_LYNXIMGMAP);
d3012 2
a3013 2
	 * Check whether we want to suppress the server-side ISMAP link if a
	 * client-side MAP is present.  - FM
d3021 1
a3021 1
	 * Check for a TITLE attribute.  - FM
d3024 1
a3024 1
	    non_empty(value[HTML_IMG_TITLE])) {
d3035 3
a3037 3
	 * If there's an ALT string, use it, unless the ALT string is
	 * zero-length or just spaces and we are making all SRCs links or have
	 * a USEMAP link.  - FM
d3048 2
a3049 2
	     * If it's all spaces and we are making SRC or USEMAP links, treat
	     * it as zero-length.  - FM
d3057 1
a3057 2
						  (temp = MakeNewMapValue(value,
									  "USEMAP"))));
d3061 1
a3061 2
						  (temp = MakeNewMapValue(value,
									  "ISMAP"))));
d3067 1
a3067 2
						  VERBOSE_IMG(value, HTML_IMG_SRC,
							      "[LINK]")));
d3071 5
a3075 6
				     (title ? title :
				      ((present &&
					present[HTML_IMG_ISOBJECT]) ?
				       "(OBJECT)" :
				       VERBOSE_IMG(value, HTML_IMG_SRC,
						   "[INLINE]"))));
d3082 1
a3082 1
				      (temp = MakeNewMapValue(value, "USEMAP"))));
d3088 1
a3088 1
				      (temp = MakeNewMapValue(value, "ISMAP"))));
d3094 1
a3094 2
				      VERBOSE_IMG(value, HTML_IMG_SRC,
						  "[LINK]")));
d3099 4
a3102 5
					  ((present &&
					    present[HTML_IMG_ISOBJECT]) ?
					   "(OBJECT)" :
					   VERBOSE_IMG(value, HTML_IMG_SRC,
						       "[INLINE]"))));
d3104 2
a3105 1
		StrAllocCopy(alt_string, NonNull(title));
d3108 1
a3108 1
	    StrAllocCopy(alt_string, (temp = MakeNewMapValue(value, "USEMAP")));
d3112 4
a3115 4
	CTRACE((tfp, "HTML IMG: USEMAP=%d ISMAP=%d ANCHOR=%d PARA=%d\n",
		map_href ? 1 : 0,
		(dest_ismap == TRUE) ? 1 : 0,
		me->inA, me->inP));
d3118 1
a3118 1
	 * Check for an ID attribute.  - FM
d3121 1
a3121 1
	    non_empty(value[HTML_IMG_ID])) {
d3130 1
a3130 1
	 * Create links to the SRC for all images, if desired.  - FM
d3134 1
a3134 1
	    non_empty(value[HTML_IMG_SRC])) {
d3136 13
a3148 1
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
d3151 10
a3160 2
	     * If it's an ISMAP and/or USEMAP, or graphic for an anchor, end
	     * that anchor and start one for the SRC.  - FM
d3164 2
a3165 2
		 * If we have a USEMAP, end this anchor and start a new one for
		 * the client-side MAP.  - FM
d3171 1
a3171 2
			HTML_put_string(me,
					(temp = MakeNewMapValue(value, "ISMAP")));
d3187 5
a3191 4
			if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							      id_string,	/* Tag */
							      NULL,	/* Addresss */
							      0)) != NULL) {	/* Type */
d3196 5
a3200 4
		    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							     NULL,	/* Tag */
							     map_href,	/* Addresss */
							     INTERN_LT);	/* Type */
d3202 3
a3204 2
			if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
			     )) != NULL) {
d3217 1
a3217 1
		    HTML_put_character(me, ' ');	/* space char may be ignored */
d3232 3
a3234 3
			      ((map_href || dest_ismap) ?
			       "(IMAGE)" : "(OBJECT)") :
			      VERBOSE_IMG(value, HTML_IMG_SRC, "[IMAGE]")));
d3236 5
a3240 4
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  id_string,	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
d3246 1
a3246 1
		HTML_put_character(me, ' ');	/* space char may be ignored */
d3249 5
a3253 4
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  id_string,	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
d3258 5
a3262 4
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 map_href,	/* Addresss */
							 INTERN_LT);	/* Type */
d3264 3
a3266 2
		    if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
			 )) != NULL) {
d3289 2
a3290 2
			      "(IMAGE)" :
			      VERBOSE_IMG(value, HTML_IMG_SRC, "[IMAGE]")));
d3292 1
a3292 1
		HTML_put_character(me, ' ');	/* space char may be ignored */
d3295 5
a3299 4
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  id_string,	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
d3307 1
a3307 1
	     * Create the link to the SRC.  - FM
d3309 5
a3313 4
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
d3326 1
a3326 1
		HTML_put_character(me, ' ');	/* space char may be ignored */
d3329 1
a3329 1
		HTML_put_character(me, ' ');	/* space char may be ignored */
d3336 2
a3337 2
		 * We're in an anchor and have a USEMAP, so end the anchor and
		 * start a new one for the client-side MAP.  - FM
d3340 1
a3340 1
		    HTML_put_character(me, ' ');	/* space char may be ignored */
d3342 1
a3342 1
		    HTML_put_string(me, (temp = MakeNewMapValue(value, "ISMAP")));
d3345 1
a3345 1
		    HTML_put_character(me, ' ');	/* space char may be ignored */
d3362 5
a3366 4
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     map_href,	/* Addresss */
						     INTERN_LT);	/* Type */
d3368 3
a3370 2
		if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		     )) != NULL) {
d3393 3
a3395 2
	     * Just put in the ALT or pseudo-ALT string for the current anchor
	     * or inline, with an ID link if indicated.  - FM
d3397 1
a3397 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
d3400 5
a3404 4
		if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						      id_string,	/* Tag */
						      NULL,	/* Addresss */
						      (HTLinkType *) 0)) != NULL) {	/* Type */
d3410 1
a3410 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
d3424 1
a3424 1
	 * Load id_string if we have a NAME or ID.  - FM
d3427 1
a3427 1
	    non_empty(value[HTML_MAP_NAME])) {
d3430 1
a3430 1
		   non_empty(value[HTML_MAP_ID])) {
d3441 1
a3441 10
	 * Generate a target anchor in this place in the containing document. 
	 * MAP can now contain block markup, if it doesn't contain any AREAs
	 * (or A anchors with COORDS converted to AREAs) the current location
	 * can be used as a fallback for following a USEMAP link.  - kw
	 */
	if (!LYMapsOnly)
	    LYHandleID(me, id_string);

	/*
	 * Load map_address.  - FM
d3445 6
a3450 5
	     * The MAP must be in the current stream, even if it had a BASE
	     * tag, so we'll use its address here, but still use the BASE, if
	     * present, when resolving the AREA elements in it's content,
	     * unless the AREA's HREF is a lone fragment and
	     * LYSeekFragAREAinCur is set.  - FM && KW
d3453 1
a3453 1
	    if ((cp = strchr(me->map_address, '#')) != NULL)
d3459 1
a3459 1
		non_empty(value[HTML_MAP_TITLE])) {
d3476 1
a3476 1
	    non_empty(value[HTML_AREA_HREF])) {
d3478 1
a3478 1
	     * Resolve the HREF.  - FM
d3481 1
a3481 1
	    CHECK_FOR_INTERN(intern_flag, href);
d3485 35
a3519 9
	     * Check whether a BASE tag is in effect, and use it for resolving,
	     * even though we used this stream's address for locating the MAP
	     * itself, unless the HREF is a lone fragment and
	     * LYSeekFragAREAinCur is set.  - FM
	     */
	    Base = ((me->inBASE && *href != '\0') &&
		    !(*href == '#' && LYSeekFragAREAinCur == TRUE)) ?
		me->base_href : me->node_anchor->address;
	    HTParseALL(&href, Base);
d3522 1
a3522 1
	     * Check for an ALT.  - FM
d3525 1
a3525 1
		non_empty(value[HTML_AREA_ALT])) {
d3528 1
a3528 1
		       non_empty(value[HTML_AREA_TITLE])) {
d3530 1
a3530 1
		 * Use the TITLE as an ALT.  - FM
d3539 1
a3539 1
		 * Make sure it's not just space(s).  - FM
d3548 1
a3548 1
		 * Use the HREF as an ALT.  - FM
d3562 3
a3564 2
	 * We may need to look at this someday to deal with MAPs, OBJECTs or
	 * APPLETs optimally, but just ignore it for now.  - FM
d3571 2
a3572 2
	 * We may need to look at this someday to deal with OBJECTs optimally,
	 * but just ignore it for now.  - FM
d3578 71
a3648 20
	/*
	 * We may need to look at this someday to deal with APPLETs optimally,
	 * but just ignore it for now.  - FM
	 */
	break;

    case HTML_FIG:
	if (present)
	    LYHandleFIG(me, present, value,
			present[HTML_FIG_ISOBJECT],
			present[HTML_FIG_IMAGEMAP],
			present[HTML_FIG_ID] ? value[HTML_FIG_ID] : NULL,
			present[HTML_FIG_SRC] ? value[HTML_FIG_SRC] : NULL,
			YES, TRUE, &intern_flag);
	else
	    LYHandleFIG(me, NULL, NULL,
			0,
			0,
			NULL,
			NULL, YES, TRUE, &intern_flag);
d3654 3
a3656 2
	     * This is an outer OBJECT start tag, i.e., not a nested OBJECT, so
	     * save it's relevant attributes.  - FM
d3666 1
a3666 1
		    non_empty(value[HTML_OBJECT_USEMAP])) {
d3674 1
a3674 1
		    non_empty(value[HTML_OBJECT_ID])) {
d3682 1
a3682 1
		    non_empty(value[HTML_OBJECT_TITLE])) {
d3692 1
a3692 1
		    non_empty(value[HTML_OBJECT_DATA])) {
d3700 1
a3700 1
		    non_empty(value[HTML_OBJECT_TYPE])) {
d3736 1
a3736 3
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&me->object_codetype,
						    TRUE,
						    FALSE);
d3744 1
a3744 1
		    non_empty(value[HTML_OBJECT_NAME])) {
d3755 3
a3757 77
	     * If we can determine now that we are not going to do anything
	     * special to the OBJECT element's SGML contents, like skipping it
	     * completely or collecting it up in order to add something after
	     * it, then generate any output that should be emitted in the place
	     * of the OBJECT start tag NOW, then don't initialize special
	     * handling but return, letting our SGML parser know that further
	     * content is to be parsed normally not literally.  We could defer
	     * this until we have collected the contents and then recycle the
	     * contents (as was previously always done), but that has a higher
	     * chance of completely losing content in case of nesting errors in
	     * the input, incomplete transmissions, etc.  - kw
	     */
	    if ((!present ||
		 (me->object_declare == FALSE && me->object_name == NULL &&
		  me->object_shapes == FALSE && me->object_usemap == NULL))) {
		if (!LYMapsOnly) {
		    if (!clickable_images || me->object_data == NULL ||
			!(me->object_data != NULL &&
			  me->object_classid == NULL &&
			  me->object_codebase == NULL &&
			  me->object_codetype == NULL))
			FREE(me->object_data);
		    if (me->object_data) {
			HTStartAnchor5(me,
				       me->object_id ? value[HTML_OBJECT_ID]
				       : NULL,
				       value[HTML_OBJECT_DATA],
				       value[HTML_OBJECT_TYPE],
				       tag_charset);
			if ((me->object_type != NULL) &&
			    !strncasecomp(me->object_type, "image/", 6))
			    HTML_put_string(me, "(IMAGE)");
			else
			    HTML_put_string(me, "(OBJECT)");
			HTML_end_element(me, HTML_A, NULL);
		    } else if (me->object_id)
			LYHandleID(me, me->object_id);
		}
		clear_objectdata(me);
		/*
		 * We do NOT want the HTML_put_* functions that are going to be
		 * called for the OBJECT's character content to add to the
		 * chunk, so we don't push on the stack.  Instead we keep a
		 * counter for open OBJECT tags that are treated this way, so
		 * HTML_end_element can skip handling the corresponding end tag
		 * that is going to arrive unexpectedly as far as our stack is
		 * concerned.
		 */
		status = HT_PARSER_OTHER_CONTENT;
		if (me->sp[0].tag_number == HTML_FIG &&
		    me->objects_figged_open > 0) {
		    ElementNumber = (HTMLElement) HTML_OBJECT_M;
		} else {
		    me->objects_mixed_open++;
		    SET_SKIP_STACK(HTML_OBJECT);
		}
	    } else if (me->object_declare == FALSE && me->object_name == NULL &&
		       me->object_shapes == TRUE) {
		LYHandleFIG(me, present, value,
			    1,
			    1 || me->object_ismap,
			    me->object_id,
			    ((me->object_data && !me->object_classid)
			     ? value[HTML_OBJECT_DATA]
			     : NULL),
			    NO, TRUE, &intern_flag);
		clear_objectdata(me);
		status = HT_PARSER_OTHER_CONTENT;
		me->objects_figged_open++;
		ElementNumber = HTML_FIG;

	    } else {
		/*
		 * Set flag that we are accumulating OBJECT content.  - FM
		 */
		me->object_started = TRUE;
	    }
d3764 1
a3764 1
	    non_empty(value[HTML_OVERLAY_SRC])) {
d3766 2
a3767 1
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
d3769 19
d3793 5
a3797 4
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 (HTLinkType *) 0);	/* Type */
d3819 1
a3819 1
	HTML_put_character(me, ' ');	/* space char may be ignored */
d3821 1
a3821 1
	 * Load id_string if we have an ID or NAME.  - FM
d3824 1
a3824 1
	    non_empty(value[HTML_APPLET_ID])) {
d3827 1
a3827 1
		   non_empty(value[HTML_APPLET_NAME])) {
d3838 2
a3839 2
	 * If there's an ALT string, use it, unless the ALT string is
	 * zero-length and we are making all sources links.  - FM
d3846 1
a3846 1
					    me->UsePlainSpace, me->HiddenValue);
d3848 2
a3849 2
	     * If it's all spaces and we are making sources links, treat it as
	     * zero-length.  - FM
d3867 1
a3867 1
	 * If we're making all sources links, get the source.  - FM
d3870 3
a3872 2
	    non_empty(value[HTML_APPLET_CODE])) {
	    char *base = NULL;
a3873 3
	    Base = (me->inBASE)
		? me->base_href
		: me->node_anchor->address;
d3875 1
a3875 1
	     * Check for a CODEBASE attribute.  - FM
d3878 1
a3878 1
		non_empty(value[HTML_APPLET_CODEBASE])) {
d3883 1
a3883 1
		 * Force it to be a directory.  - FM
d3888 1
a3888 1
		LYLegitimizeHREF(me, &base, TRUE, FALSE);
d3890 26
a3915 1
		HTParseALL(&base, Base);
d3918 3
a3920 3
	    StrAllocCopy(href, value[HTML_APPLET_CODE]);
	    LYLegitimizeHREF(me, &href, TRUE, FALSE);
	    HTParseALL(&href, (base ? base : Base));
d3922 1
d3924 1
a3924 1
	    if (*href) {
d3931 5
a3935 4
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 (HTLinkType *) 0);	/* Type */
d3948 1
a3948 1
		HTML_put_character(me, ' ');	/* space char may be ignored */
d3954 1
a3954 1
	     * Just put up the ALT string, if non-zero.  - FM
d3957 1
a3957 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
d3966 1
a3966 1
	 * If we're making all sources links, get the source.  - FM
d3969 1
a3969 1
	    non_empty(value[HTML_BGSOUND_SRC])) {
d3971 2
a3972 1
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
d3978 20
d4004 1
a4004 1
		HTML_put_character(me, ' ');	/* space char may be ignored */
d4007 5
a4011 4
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
d4024 1
a4024 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
d4032 1
a4032 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
d4034 1
a4034 1
	 * Load id_string if we have an ID or NAME.  - FM
d4037 1
a4037 1
	    non_empty(value[HTML_EMBED_ID])) {
d4040 1
a4040 1
		   non_empty(value[HTML_EMBED_NAME])) {
d4052 2
a4053 2
	 * If there's an ALT string, use it, unless the ALT string is
	 * zero-length and we are making all sources links.  - FM
d4060 1
a4060 1
					    me->UsePlainSpace, me->HiddenValue);
d4062 2
a4063 2
	     * If it's all spaces and we are making sources links, treat it as
	     * zero-length.  - FM
d4080 1
a4080 1
	 * If we're making all sources links, get the source.  - FM
d4083 1
a4083 1
	    non_empty(value[HTML_EMBED_SRC])) {
d4085 23
a4107 2
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href) {
d4114 5
a4118 4
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 (HTLinkType *) 0);	/* Type */
d4139 1
a4139 1
	     * Just put up the ALT string, if non-zero.  - FM
d4142 1
a4142 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
a4159 1
	CAN_JUSTIFY_START;
d4163 2
a4164 2
	     * Assume all text in the FIG container is intended to be
	     * paragraphed.  - FM
d4170 2
a4171 2
	     * Assume all text in the APPLET container is intended to be
	     * paragraphed.  - FM
a4190 1
	CAN_JUSTIFY_START;
d4194 2
a4195 2
	     * Assume all text in the FIG container is intended to be
	     * paragraphed.  - FM
d4201 2
a4202 2
	     * Assume all text in the APPLET container is intended to be
	     * paragraphed.  - FM
d4213 4
a4216 4
	    char *action = NULL;
	    char *method = NULL;
	    char *enctype = NULL;
	    const char *accept_cs = NULL;
d4218 1
a4218 1
	    HTChildAnchor *source;
d4222 6
a4227 5
	     * FORM may have been declared SGML_EMPTY in HTMLDTD.c, and
	     * SGML_character() in SGML.c may check for a FORM end tag to call
	     * HTML_end_element() directly (with a check in that to bypass
	     * decrementing of the HTML parser's stack), so if we have an open
	     * FORM, close that one now.  - FM
d4230 1
a4230 1
		CTRACE((tfp, "HTML: Missing FORM end tag.  Faking it!\n"));
d4236 1
a4236 1
	     * Set to know we are in a new form.
a4238 1
	    EMIT_IFDEF_EXP_JUSTIFY_ELTS(form_in_htext = TRUE);
d4242 1
a4242 1
		    value[HTML_FORM_ACCEPT_CHARSET] : "UNKNOWN";
a4243 5

	    Base = (me->inBASE)
		? me->base_href
		: me->node_anchor->address;

d4245 4
a4248 2
		value[HTML_FORM_ACTION]) {

d4250 1
a4250 1
		LYLegitimizeHREF(me, &action, TRUE, TRUE);
d4253 3
a4255 3
		 * Check whether a base tag is in effect.  Note that actions
		 * always are resolved w.r.t.  to the base, even if the action
		 * is empty.  - FM
d4257 19
a4275 4
		HTParseALL(&action, Base);

	    } else {
		StrAllocCopy(action, Base);
d4277 3
a4279 14

	    source = HTAnchor_findChildAndLink(me->node_anchor,
					       NULL,
					       action,
					       (HTLinkType *) 0);
	    if ((link_dest = HTAnchor_followLink(source)) != NULL) {
		/*
		 * Memory leak fixed.  05-28-94 Lynx 2-3-1 Garrett Arch Blythe
		 */
		char *cp_freeme = HTAnchor_address(link_dest);

		if (cp_freeme != NULL) {
		    StrAllocCopy(action, cp_freeme);
		    FREE(cp_freeme);
d4281 20
a4300 1
		    StrAllocCopy(action, "");
d4306 1
a4306 1
			     value[HTML_FORM_METHOD] : "GET");
d4309 1
a4309 1
		non_empty(value[HTML_FORM_ENCTYPE])) {
d4316 2
a4317 2
		 * Check for a TITLE attribute, and if none is present, check
		 * for a SUBJECT attribute as a synonym.  - FM
d4328 1
a4328 1
		if (non_empty(title)) {
d4374 5
a4378 19
	    I.align = NULL;
	    I.accept = NULL;
	    I.checked = NO;
	    I.iclass = NULL;
	    I.disabled = NO;
	    I.error = NULL;
	    I.height = NULL;
	    I.id = NULL;
	    I.lang = NULL;
	    I.max = NULL;
	    I.maxlength = NULL;
	    I.md = NULL;
	    I.min = NULL;
	    I.name = NULL;
	    I.size = 0;
	    I.src = NULL;
	    I.type = NULL;
	    I.value = NULL;
	    I.width = NULL;
d4389 1
a4389 1
		 * It's a button for submitting or resetting a form.  - FM
d4394 1
a4394 1
		 * Ugh, it's a button for a script.  - FM
d4396 1
a4396 1
		HTML_put_string(me, " [BUTTON] ");
d4401 1
a4401 1
	     * Make sure we're in a form.
d4404 7
a4410 3
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: BUTTON tag not within FORM tag\n"));
d4412 2
a4413 2
		 * We'll process it, since the chances of a crash are small,
		 * and we probably do have a form started.  - FM
d4415 1
a4415 1
		 break;
d4420 7
a4426 6
	     * Before any input field, add a collapsible space if we're not in
	     * a PRE block, to promote a wrap there for any long values that
	     * would extend past the right margin from our current position in
	     * the line.  If we are in a PRE block, start a new line if the
	     * last line already is within 6 characters of the wrap point for
	     * PRE blocks.  - FM
d4432 1
a4432 1
	    } else if (HText_LastLineSize(me->text, FALSE) > (LYcolLimit - 6)) {
d4450 1
a4450 1
		non_empty(value[HTML_BUTTON_VALUE])) {
d4452 1
a4452 1
		 * Convert any HTML entities or decimal escaping.  - FM
d4454 2
d4462 2
a4463 2
		 * Convert any newlines or tabs to spaces, and trim any lead or
		 * trailing spaces.  - FM
d4465 6
a4470 1
		LYReduceBlanks(I.value);
d4476 3
a4478 3
	    if (present && present[HTML_BUTTON_CLASS] &&	/* Not yet used. */
		non_empty(value[HTML_BUTTON_CLASS]))
		I.iclass = value[HTML_BUTTON_CLASS];
d4481 1
a4481 1
		non_empty(value[HTML_BUTTON_ID])) {
d4486 2
a4487 2
	    if (present && present[HTML_BUTTON_LANG] &&		/* Not yet used. */
		non_empty(value[HTML_BUTTON_LANG]))
d4492 8
a4499 7
	     * Submit and reset buttons have values which don't change, so
	     * HText_beginInput() sets I.value to the string which should be
	     * displayed, and we'll enter that instead of underscore
	     * placeholders into the HText structure to see it instead of
	     * underscores when dumping or printing.  We also won't worry about
	     * a wrap in PRE blocks, because the line editor never is invoked
	     * for submit or reset buttons.  - LE & FM
d4502 1
a4502 1
		!me->sp->style->freeFormat) {
d4504 7
a4510 6
		 * We have a submit or reset button in a PRE block, so output
		 * the entire value from the markup.  If it extends to the
		 * right margin, it will wrap there, and only the portion
		 * before that wrap will be hightlighted on screen display
		 * (Yuk!) but we may as well show the rest of the full value on
		 * the next or more lines.  - FM
d4516 16
a4531 13
		 * The submit or reset button is not in a PRE block.  Note that
		 * if a wrap occurs before outputting the entire value, the
		 * wrapped portion will not be highlighted or clearly indicated
		 * as part of the link for submission or reset (Yuk!).  We'll
		 * replace any spaces in the submit or reset button value with
		 * nbsp, to promote a wrap at the space we ensured would be
		 * present before the start of the string, as when we use all
		 * underscores instead of the INPUT's actual value, but we
		 * could still get a wrap at the right margin, instead, if the
		 * value is greater than a line width for the current style. 
		 * Also, if chars somehow ended up longer than the length of
		 * the actual value (shouldn't have), we'll continue padding
		 * with nbsp up to the length of chars.  - FM
d4535 2
a4536 2
				       (char) (I.value[i] == ' ' ?
					       HT_NON_BREAK_SPACE : I.value[i]));
d4538 1
a4538 1
		while (i++ < chars) {
d4559 1
a4559 1
	    char *ImageSrc = NULL;
a4560 2
	    HTkcode kcode = NOKANJI;
	    HTkcode specified_kcode = NOKANJI;
d4563 5
a4567 19
	    I.align = NULL;
	    I.accept = NULL;
	    I.checked = NO;
	    I.iclass = NULL;
	    I.disabled = NO;
	    I.error = NULL;
	    I.height = NULL;
	    I.id = NULL;
	    I.lang = NULL;
	    I.max = NULL;
	    I.maxlength = NULL;
	    I.md = NULL;
	    I.min = NULL;
	    I.name = NULL;
	    I.size = 0;
	    I.src = NULL;
	    I.type = NULL;
	    I.value = NULL;
	    I.width = NULL;
d4575 7
a4581 6
	     * Before any input field, add a collapsible space if we're not in
	     * a PRE block, to promote a wrap there for any long values that
	     * would extend past the right margin from our current position in
	     * the line.  If we are in a PRE block, start a new line if the
	     * last line already is within 6 characters of the wrap point for
	     * PRE blocks.  - FM
d4587 1
a4587 1
	    } else if (HText_LastLineSize(me->text, FALSE) > (LYcolLimit - 6)) {
d4593 1
a4593 1
	     * Get the TYPE and make sure we can handle it.  - FM
d4596 1
a4596 4
		non_empty(value[HTML_INPUT_TYPE])) {
		const char *not_impl = NULL;
		char *usingval = NULL;

d4605 1
a4605 1
		     * Not yet implemented.
d4607 1
a4607 1
		    not_impl = "[RANGE Input]";
d4612 1
a4612 1
		    CTRACE((tfp, "HTML: Ignoring TYPE=\"range\"\n"));
a4617 11
#ifndef USE_FILE_UPLOAD
		    not_impl = "[FILE Input]";
		    CTRACE((tfp, "Attempting to fake as: %s\n", I.type));
#ifdef NOTDEFINED
		    if (me->inFORM)
			HText_DisableCurrentForm();
#endif /* NOTDEFINED */
		    CTRACE((tfp, "HTML: Ignoring TYPE=\"file\"\n"));
#endif /* USE_FILE_UPLOAD */

		} else if (!strcasecomp(I.type, "button")) {
d4619 1
a4619 1
		     * Ugh, a button for a script.
a4620 4
		    HTML_put_string(me, "[BUTTON] ");
		    break;
		}
		if (not_impl != NULL) {
d4625 1
a4625 7
		    HTML_put_string(me, not_impl);
		    if (usingval != NULL) {
			HTML_put_string(me, usingval);
			FREE(usingval);
		    } else {
			HTML_put_string(me, " (not implemented)");
		    }
d4630 13
d4647 1
a4647 1
	     * Check if we're in a form.  - FM
d4650 7
a4656 3
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: INPUT tag not within FORM tag\n"));
d4658 2
a4659 2
		 * We'll process it, since the chances of a crash are small,
		 * and we probably do have a form started.  - FM
d4661 1
a4661 1
		 break;
a4664 2
	    CTRACE((tfp, "Ok, we're trying type=[%s]\n", NONNULL(I.type)));

d4666 1
a4666 1
	     * Check for an unclosed TEXTAREA.
d4669 7
a4675 2
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag.\n"));
d4679 1
a4679 1
	     * Check for an unclosed SELECT, try to close it if found.
d4682 1
a4682 1
		CTRACE((tfp, "HTML: Missing SELECT end tag, faking it...\n"));
d4690 1
a4690 1
	     * Handle the INPUT as for a FORM.  - FM
d4703 1
a4703 1
		 non_empty(value[HTML_INPUT_ALT]) &&
d4706 1
a4706 1
		  non_empty(value[HTML_INPUT_VALUE]))) {
d4708 5
a4712 4
		 * This is a TYPE="image" using an ALT rather than VALUE
		 * attribute to indicate the link string for text clients or
		 * GUIs with image loading off, so set the flag to use that as
		 * if it were a VALUE attribute.  - FM
d4718 1
a4718 1
		non_empty(value[HTML_INPUT_SRC]) &&
d4722 3
a4724 3
		       present && present[HTML_INPUT_SRC] &&
		       non_empty(value[HTML_INPUT_SRC]) &&
		       I.type && !strcasecomp(I.type, "image")) {
d4727 4
a4730 3
		 * We have a TYPE="image" with a non-zero-length SRC attribute
		 * and want clickable images.  Make the SRC's value a link if
		 * it's still not zero-length legitimizing it.  - FM
d4732 1
a4732 1
		LYLegitimizeHREF(me, &href, TRUE, TRUE);
d4734 20
d4759 5
a4763 4
		    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							     NULL,	/* Tag */
							     href,	/* Addresss */
							     (HTLinkType *) 0);		/* Type */
d4767 1
a4767 3
		    HTML_put_string(me, VERBOSE_IMG(value,
						    HTML_INPUT_SRC,
						    "[IMAGE]"));
a4776 4
	    CTRACE((tfp, "2.Ok, we're trying type=[%s] (present=%p)\n",
		    NONNULL(I.type),
		    present));
	    /* text+file don't go in here */
d4779 1
a4779 5
		 value[HTML_INPUT_VALUE] &&
		 (*value[HTML_INPUT_VALUE] ||
		  (I.type && (!strcasecomp(I.type, "checkbox") ||
			      !strcasecomp(I.type, "radio")))))) {

d4781 1
a4781 1
		 * Convert any HTML entities or decimal escaping.  - FM
d4787 1
a4795 1
		CTRACE((tfp, "3.Ok, we're trying type=[%s]\n", NONNULL(I.type)));
a4798 3
#ifdef USE_FILE_UPLOAD
			 !strcasecomp(I.type, "file") ||
#endif
d4801 1
a4801 2
			 !strcasecomp(I.type, "reset")) {
		    CTRACE((tfp, "normal field type: %s\n", NONNULL(I.type)));
a4802 2
		}

d4805 2
a4806 2
			      value[HTML_INPUT_ALT] :
			      value[HTML_INPUT_VALUE]));
d4810 6
a4815 8
		CTRACE((tfp, "4.Ok, we're trying type=[%s]\n", NONNULL(I.type)));
		TRANSLATE_AND_UNESCAPE_ENTITIES6(&I_value,
						 ATTR_CS_IN,
						 I.value_cs,
						 (BOOL) (me->UsePlainSpace &&
							 !me->HiddenValue),
						 me->UsePlainSpace,
						 me->HiddenValue);
d4819 2
a4820 2
		     * Convert any newlines or tabs to spaces, and trim any
		     * lead or trailing spaces.  - FM
d4822 6
a4827 1
		    LYReduceBlanks(I.value);
d4831 1
d4842 4
a4845 4
		 * We put up an [IMAGE] link and '-' for a TYPE="image" and
		 * didn't get a VALUE or ALT string, so fake a "Submit" value. 
		 * If we didn't put up a link, then HText_beginInput() will use
		 * "[IMAGE]-Submit".  - FM
d4849 1
a4849 1
	    } else if (ImageSrc) {
d4858 2
a4859 3
		non_empty(value[HTML_INPUT_SIZE]))
		I.size = atoi(value[HTML_INPUT_SIZE]);
	    LimitValue(I.size, MAX_LINE);
d4861 1
a4861 1
		non_empty(value[HTML_INPUT_MAXLENGTH]))
d4866 3
a4868 4
	    if (present && present[HTML_INPUT_ACCEPT_CHARSET]) {	/* Not yet used. */
		I.accept_cs = (value[HTML_INPUT_ACCEPT_CHARSET]
			       ? value[HTML_INPUT_ACCEPT_CHARSET]
			       : "UNKNOWN");
d4870 2
a4871 2
	    if (present && present[HTML_INPUT_ALIGN] &&		/* Not yet used. */
		non_empty(value[HTML_INPUT_ALIGN]))
d4873 5
a4877 5
	    if (present && present[HTML_INPUT_CLASS] &&		/* Not yet used. */
		non_empty(value[HTML_INPUT_CLASS]))
		I.iclass = value[HTML_INPUT_CLASS];
	    if (present && present[HTML_INPUT_ERROR] &&		/* Not yet used. */
		non_empty(value[HTML_INPUT_ERROR]))
d4879 2
a4880 2
	    if (present && present[HTML_INPUT_HEIGHT] &&	/* Not yet used. */
		non_empty(value[HTML_INPUT_HEIGHT]))
d4882 2
a4883 2
	    if (present && present[HTML_INPUT_WIDTH] &&		/* Not yet used. */
		non_empty(value[HTML_INPUT_WIDTH]))
d4886 1
a4886 1
		non_empty(value[HTML_INPUT_ID])) {
d4890 2
a4891 2
	    if (present && present[HTML_INPUT_LANG] &&	/* Not yet used. */
		non_empty(value[HTML_INPUT_LANG]))
d4893 2
a4894 2
	    if (present && present[HTML_INPUT_MD] &&	/* Not yet used. */
		non_empty(value[HTML_INPUT_MD]))
a4897 6
#ifndef USE_FILE_UPLOAD
	    CTRACE((tfp,
		    "I.%s have %d chars, or something\n",
		    NONNULL(I.type),
		    chars));
#endif
d4899 8
a4906 7
	     * Submit and reset buttons have values which don't change, so
	     * HText_beginInput() sets I.value to the string which should be
	     * displayed, and we'll enter that instead of underscore
	     * placeholders into the HText structure to see it instead of
	     * underscores when dumping or printing.  We also won't worry about
	     * a wrap in PRE blocks, because the line editor never is invoked
	     * for submit or reset buttons.  - LE & FM
d4909 3
a4911 3
		(!strcasecomp(I.type, "submit") ||
		 !strcasecomp(I.type, "reset") ||
		 !strcasecomp(I.type, "image")))
d4917 3
a4919 2
		 * Put a (_) placeholder, and one space (collapsible) before
		 * the label that is expected to follow.  - FM
a4921 1
		HText_endInput(me->text);
d4930 1
a4930 1
		       !strcasecomp(I.type, "checkbox")) {
d4932 3
a4934 2
		 * Put a [_] placeholder, and one space (collapsible) before
		 * the label that is expected to follow.  - FM
a4936 1
		HText_endInput(me->text);
d4949 14
a4962 12
		 * This is not a submit or reset button, and we are in a PRE
		 * block with a field intended to exceed 6 character widths. 
		 * The code inadequately handles INPUT fields in PRE tags if
		 * wraps occur (at the right margin) for the underscore
		 * placeholders.  We'll put up a minimum of 6 underscores,
		 * since we should have wrapped artificially, above, if the
		 * INPUT begins within 6 columns of the right margin, and if
		 * any more would exceed the wrap column, we'll ignore them. 
		 * Note that if we somehow get tripped up and a wrap still does
		 * occur before all 6 of the underscores are output, the
		 * wrapped ones won't be treated as part of the editing window,
		 * nor be highlighted when not editing (Yuk!).  - FM
a4969 3
#ifndef USE_FILE_UPLOAD
	    CTRACE((tfp, "I.%s, %d\n", NONNULL(I.type), IsSubmitOrReset));
#endif
d4972 3
a4974 2
		 * This is not a submit or reset button, so output the rest of
		 * the underscore placeholders, if any more are needed.  - FM
d4976 2
a4977 5
		if (chars > 0) {
		    for (; chars > 0; chars--)
			HTML_put_character(me, '_');
		    HText_endInput(me->text);
		}
a4978 6
		if (HTCJK == JAPANESE) {
		    kcode = HText_getKcode(me->text);
		    HText_updateKcode(me->text, kanji_code);
		    specified_kcode = HText_getSpecifiedKcode(me->text);
		    HText_updateSpecifiedKcode(me->text, kanji_code);
		}
d4982 7
a4988 6
		     * We have a submit or reset button in a PRE block, so
		     * output the entire value from the markup.  If it extends
		     * to the right margin, it will wrap there, and only the
		     * portion before that wrap will be hightlighted on screen
		     * display (Yuk!) but we may as well show the rest of the
		     * full value on the next or more lines.  - FM
d4994 16
a5009 14
		     * The submit or reset button is not in a PRE block.  Note
		     * that if a wrap occurs before outputting the entire
		     * value, the wrapped portion will not be highlighted or
		     * clearly indicated as part of the link for submission or
		     * reset (Yuk!).  We'll replace any spaces in the submit or
		     * reset button value with nbsp, to promote a wrap at the
		     * space we ensured would be present before the start of
		     * the string, as when we use all underscores instead of
		     * the INPUT's actual value, but we could still get a wrap
		     * at the right margin, instead, if the value is greater
		     * than a line width for the current style.  Also, if chars
		     * somehow ended up longer than the length of the actual
		     * value (shouldn't have), we'll continue padding with nbsp
		     * up to the length of chars.  - FM
d5013 3
a5015 4
					   (char) (I.value[i] == ' '
						   ? HT_NON_BREAK_SPACE
						   : I.value[i]));
		    while (i++ < chars)
a5017 7
		if (HTCJK == JAPANESE) {
		    HText_updateKcode(me->text, kcode);
		    HText_updateSpecifiedKcode(me->text, specified_kcode);
		}
	    }
	    if (chars != 0) {
		HText_endInput(me->text);
d5028 1
a5028 1
	 * Make sure we're in a form.
d5031 7
a5037 3
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: TEXTAREA start tag not within FORM tag\n"));
d5039 1
a5039 1
	     * Too likely to cause a crash, so we'll ignore it.  - FM
d5045 1
a5045 1
	 * Set to know we are in a textarea.
d5050 1
a5050 1
	 * Get ready for the value.
d5077 4
a5080 16
	    isdigit(UCH(*value[HTML_TEXTAREA_COLS])))
	    me->textarea_cols = atoi(value[HTML_TEXTAREA_COLS]);
	else {
	    int width;

	    width = LYcolLimit -
		me->new_style->leftIndent - me->new_style->rightIndent;
	    if (dump_output_immediately)	/* don't waste too much for this */
		width = HTMIN(width, DFT_TEXTAREA_COLS);
	    if (width > 1 && (width - 1) * 6 < MAX_LINE - 3 -
		me->new_style->leftIndent - me->new_style->rightIndent)
		me->textarea_cols = width;
	    else
		me->textarea_cols = DFT_TEXTAREA_COLS;
	}
	LimitValue(me->textarea_cols, MAX_TEXTAREA_COLS);
d5084 1
a5084 1
	    isdigit(UCH(*value[HTML_TEXTAREA_ROWS])))
d5087 1
a5087 2
	    me->textarea_rows = DFT_TEXTAREA_ROWS;
	LimitValue(me->textarea_rows, MAX_TEXTAREA_ROWS);
d5095 1
a5095 1
	    && non_empty(value[HTML_TEXTAREA_ID])) {
d5099 5
a5103 4
		(ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						  id_string,	/* Tag */
						  NULL,		/* Addresss */
						  (HTLinkType *) 0))) {		/* Type */
d5118 1
a5118 1
	 * Check for an already open SELECT block.  - FM
d5121 7
a5127 3
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: SELECT start tag in SELECT element.  Faking SELECT end tag. *****\n"));
d5138 1
a5138 1
		       present, (const char **) value,
d5146 1
a5146 1
	     * An option is a special case of an input field.
d5151 1
a5151 1
	     * Make sure we're in a select tag.
d5154 7
a5160 3
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: OPTION tag not within SELECT tag\n"));
d5163 1
a5163 1
		 * Too likely to cause a crash, so we'll ignore it.  - FM
d5170 1
a5170 1
		 * Finish the data off.
d5175 1
a5175 1
		 * Finish the previous option @@@@@@@@@@
d5187 3
a5189 3
	     * If it's not a multiple option list and select popups are
	     * enabled, then don't use the checkbox/button method, and don't
	     * put anything on the screen yet.
d5197 1
a5197 1
		     * Start a newline before each option.
d5202 1
a5202 1
		     * Add option list designation character.
d5209 1
a5209 1
		 * Inititialize.
d5211 5
a5215 19
		I.align = NULL;
		I.accept = NULL;
		I.checked = NO;
		I.iclass = NULL;
		I.disabled = NO;
		I.error = NULL;
		I.height = NULL;
		I.id = NULL;
		I.lang = NULL;
		I.max = NULL;
		I.maxlength = NULL;
		I.md = NULL;
		I.min = NULL;
		I.name = NULL;
		I.size = 0;
		I.src = NULL;
		I.type = NULL;
		I.value = NULL;
		I.width = NULL;
d5225 1
a5225 1
		    I.checked = YES;
d5230 1
a5230 1
		     * Convert any HTML entities or decimal escaping.  - FM
d5235 4
a5238 4
						     ATTR_CS_IN,
						     ATTR_CS_IN,
						     NO,
						     me->UsePlainSpace, me->HiddenValue);
d5246 2
a5247 2
		    (present && present[HTML_OPTION_DISABLED]))
		    I.disabled = YES;
d5250 6
a5255 5
		    && non_empty(value[HTML_OPTION_ID])) {
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  value[HTML_OPTION_ID],	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
d5266 3
a5268 2
		     * Put a "[_]" placeholder, and one space (collapsible)
		     * before the label that is expected to follow.  - FM
d5274 1
a5274 1
		    HText_setLastChar(me->text, ' ');	/* absorb white space */
d5278 3
a5280 2
		     * Put a "(_)" placeholder, and one space (collapsible)
		     * before the label that is expected to follow.  - FM
d5286 1
a5286 1
		    HText_setLastChar(me->text, ' ');	/* absorb white space */
d5292 1
a5292 1
	     * Get ready for the next value.
d5303 1
d5308 1
a5308 1
		     * Convert any HTML entities or decimal escaping.  - FM
d5313 4
a5316 4
						     ATTR_CS_IN,
						     ATTR_CS_IN,
						     NO,
						     me->UsePlainSpace, me->HiddenValue);
d5325 2
a5326 2
	     * If this is a popup option, print its option for use in selecting
	     * option by number.  - LE
d5330 1
a5330 1
		fields_are_numbered()) {
d5335 1
a5335 1
		    sprintf(marker, "(%d)", opnum);
d5348 4
a5351 10
	 * Not fully implemented.  Just treat as a division with respect to any
	 * ALIGN attribute, with a default of HT_LEFT, or leave as a PRE block
	 * if we are presently in one.  - FM
	 *
	 * Also notify simple table tracking code unless in a preformatted
	 * section, or (currently) non-left alignment.
	 *
	 * If page author is using a TABLE within PRE, it's probably formatted
	 * specifically to work well for Lynx without simple table tracking
	 * code.  Cancel tracking, it would only make things worse.  - kw
a5352 5
#ifdef EXP_NESTED_TABLES
	if (!nested_tables)
#endif
	    HText_cancelStbl(me->text);

d5362 1
a5362 1
	if (me->sp->style->id == ST_Preformatted) {
d5370 3
a5372 3
	    CTRACE((tfp,
		    "HTML: ****** Maximum nesting of %d divisions/tables exceeded!\n",
		    MAX_NESTING));
d5375 1
a5375 1
	    non_empty(value[HTML_TABLE_ALIGN])) {
d5377 4
a5380 16
		if (no_table_center) {
		    me->DivisionAlignments[me->Division_Level] = HT_LEFT;
		    change_paragraph_style(me, styles[HTML_DLEFT]);
		    UPDATE_STYLE;
		    me->current_default_alignment =
			styles[HTML_DLEFT]->alignment;
		} else {
		    me->DivisionAlignments[me->Division_Level] = HT_CENTER;
		    change_paragraph_style(me, styles[HTML_DCENTER]);
		    UPDATE_STYLE;
		    me->current_default_alignment =
			styles[HTML_DCENTER]->alignment;
		}

		stbl_align = HT_CENTER;

a5385 1
		stbl_align = HT_RIGHT;
a5390 3
		if (!strcasecomp(value[HTML_TABLE_ALIGN], "left") ||
		    !strcasecomp(value[HTML_TABLE_ALIGN], "justify"))
		    stbl_align = HT_LEFT;
a5396 1
	    /* stbl_align remains HT_ALIGN_NONE */
a5398 1
	HText_startStblTABLE(me->text, stbl_align);
d5403 3
a5405 3
	 * Not fully implemented.  Just start a new row, if needed, act on an
	 * ALIGN attribute if present, and check for an ID link.  - FM
	 * Also notify simple table tracking code.  - kw
d5416 2
a5417 2
	if (!HText_LastLineEmpty(me->text, FALSE)) {
	    HText_setLastChar(me->text, ' ');	/* absorb white space */
d5422 1
a5422 1
	if (me->sp->style->id == ST_Preformatted) {
a5424 1
/*	    HText_cancelStbl(me->text);  seems unnecessary here - kw */
d5431 3
a5433 3
		    (me->sp->style->id == ST_Normal ||
		     me->sp->style->id == ST_Preformatted))) {
	    me->sp->style->alignment = HT_LEFT;
d5435 1
a5435 1
	    me->sp->style->alignment = (short) me->current_default_alignment;
d5439 4
a5442 8
		!(me->List_Nesting_Level >= 0 && !me->inP)) {
		if (no_table_center)
		    me->sp->style->alignment = HT_LEFT;
		else
		    me->sp->style->alignment = HT_CENTER;
		stbl_align = HT_CENTER;
	    } else if (!strcasecomp(value[HTML_TR_ALIGN], "right") &&
		       !(me->List_Nesting_Level >= 0 && !me->inP)) {
d5444 2
a5445 3
		stbl_align = HT_RIGHT;
	    } else if (!strcasecomp(value[HTML_TR_ALIGN], "left") ||
		       !strcasecomp(value[HTML_TR_ALIGN], "justify")) {
a5446 2
		stbl_align = HT_LEFT;
	    }
a5450 1
	HText_startStblTR(me->text, stbl_align);
a5455 1
	HText_endStblTR(me->text);
d5457 1
a5457 1
	 * Not fully implemented.  Just check for an ID link.  - FM
a5467 13
	if (me->inTABLE) {
	    if (present && present[HTML_TR_ALIGN] && value[HTML_TR_ALIGN]) {
		if (!strcasecomp(value[HTML_TR_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_TR_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_TR_ALIGN], "left") ||
			   !strcasecomp(value[HTML_TR_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblRowGroup(me->text, stbl_align);
	}
d5474 1
a5474 1
	 * Not fully implemented.  Just check for an ID link.  - FM
a5484 20
	if (me->inTABLE) {
	    int span = 1;

	    if (present && present[HTML_COL_SPAN] &&
		value[HTML_COL_SPAN] &&
		isdigit(UCH(*value[HTML_COL_SPAN])))
		span = atoi(value[HTML_COL_SPAN]);
	    if (present && present[HTML_COL_ALIGN] && value[HTML_COL_ALIGN]) {
		if (!strcasecomp(value[HTML_COL_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_COL_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_COL_ALIGN], "left") ||
			   !strcasecomp(value[HTML_COL_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblCOL(me->text, span, stbl_align,
			       (BOOL) (ElementNumber == HTML_COLGROUP));
	}
a5488 1
    case HTML_TD:
d5500 1
a5500 2
	 * Not fully implemented.  Just add a collapsible space and break - FM
	 * Also notify simple table tracking code.  - kw
d5503 2
a5504 2
	{
	    int colspan = 1, rowspan = 1;
d5506 8
a5513 20
	    if (present && present[HTML_TD_COLSPAN] &&
		value[HTML_TD_COLSPAN] &&
		isdigit(UCH(*value[HTML_TD_COLSPAN])))
		colspan = atoi(value[HTML_TD_COLSPAN]);
	    if (present && present[HTML_TD_ROWSPAN] &&
		value[HTML_TD_ROWSPAN] &&
		isdigit(UCH(*value[HTML_TD_ROWSPAN])))
		rowspan = atoi(value[HTML_TD_ROWSPAN]);
	    if (present && present[HTML_TD_ALIGN] && value[HTML_TD_ALIGN]) {
		if (!strcasecomp(value[HTML_TD_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_TD_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_TD_ALIGN], "left") ||
			   !strcasecomp(value[HTML_TD_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblTD(me->text, colspan, rowspan, stbl_align,
			      (BOOL) (ElementNumber == HTML_TH));
d5515 6
d5526 2
a5527 2
	 * We're getting it as Literal text, which, until we can process it,
	 * we'll display as is, within brackets to alert the user.  - FM
d5536 1
a5536 1
    }				/* end switch */
d5538 1
a5538 2
    if (ElementNumber >= HTML_ELEMENTS ||
	HTML_dtd.tags[ElementNumber].contents != SGML_EMPTY) {
d5540 2
a5541 3
	    CTRACE((tfp,
		    "HTML:begin_element: internal call (level %d), leaving on stack - `%s'\n",
		    me->skip_stack, NONNULL(me->sp->style->name)));
d5543 1
a5543 1
	    return status;
d5547 2
a5548 2
		HTAlert(HTML_STACK_OVERRUN);
		CTRACE((tfp,
d5550 5
a5554 1
			MAX_NESTING));
d5557 1
a5557 1
	    return HT_ERROR;
d5560 3
a5562 5
	CTRACE((tfp,
		"HTML:begin_element[%d]: adding style to stack - %s (%s)\n",
		(int) STACKLEVEL(me),
		NONNULL(me->new_style->name),
		HTML_dtd.tags[ElementNumber].name));
a5565 5
#ifdef EXP_JUSTIFY_ELTS
	if (wait_for_this_stacked_elt < 0 &&
	    HTML_dtd.tags[ElementNumber].can_justify == FALSE)
	    wait_for_this_stacked_elt = me->stack - me->sp + MAX_NESTING;
#endif
a5566 6
#ifdef EXP_JUSTIFY_ELTS
    if (in_DT && ElementNumber == HTML_DD)
	in_DT = FALSE;
    else if (ElementNumber == HTML_DT)
	in_DT = TRUE;
#endif
d5570 2
d5573 6
a5578 3
    if (ReallyEmptyTagNum(element_number)) {
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE.begin_element:ending \"EMPTY\" element style\n"));
d5580 1
d5582 4
d5592 1
a5594 1
    return status;
d5598 17
a5614 15
 *		-----------
 *
 *	When we end an element, the style must be returned to that
 *	in effect before that element.	Note that anchors (etc?)
 *	don't have an associated style, so that we must scan down the
 *	stack for an element with a defined style. (In fact, the styles
 *	should be linked to the whole stack not just the top one.)
 *	TBL 921119
 *
 *	We don't turn on "CAREFUL" check because the parser produces
 *	(internal code errors apart) good nesting.  The parser checks
 *	incoming code errors, not this module.
 */
static int HTML_end_element(HTStructured * me, int element_number,
			    char **include)
a5616 1
    int status = HT_OK;
a5618 3
    BOOL intern_flag = FALSE;
    BOOL skip_stack_requested = FALSE;
    EMIT_IFDEF_EXP_JUSTIFY_ELTS(BOOL reached_awaited_stacked_elt = FALSE);
d5620 1
a5620 1
#ifdef USE_PRETTYSRC
d5623 1
a5623 1
	    HTTag *tag = &HTML_dtd.tags[element_number];
d5625 1
a5625 1
	    int tag_charset = 0;
d5627 2
a5628 4
	    psrc_nested_call = TRUE;
	    PSRCSTART(abracket);
	    PUTS("</");
	    PSRCSTOP(abracket);
d5630 1
a5630 1
	    if (tagname_transform != 0)
d5633 1
a5633 1
		LYstrncpy(buf, tag->name, sizeof(buf) - 1);
d5638 3
a5640 5
	    PSRCSTART(abracket);
	    PUTC('>');
	    PSRCSTOP(abracket);
	    psrc_nested_call = FALSE;
	    return HT_OK;
d5642 1
a5642 1
	/*fall through */
d5646 2
a5647 2
    if ((me->sp >= (me->stack + MAX_NESTING - 1) ||
	 element_number != me->sp[0].tag_number) &&
d5649 2
a5650 2
	CTRACE((tfp,
		"HTML: end of element %s when expecting end of %s\n",
d5652 3
a5654 6
		(me->sp == me->stack + MAX_NESTING - 1) ? "none" :
		(me->sp->tag_number < 0) ? "*invalid tag*" :
		(me->sp->tag_number >= HTML_ELEMENTS) ? "special tag" :
		HTML_dtd.tags[me->sp->tag_number].name));
#ifdef CAREFUL			/* parser assumed to produce good nesting */
	/* panic */
a5655 1
    }
d5658 2
a5659 2
     * If we're seeking MAPs, skip everything that's not a MAP or AREA tag.  -
     * FM
d5662 2
a5663 3
	if (!(element_number == HTML_MAP || element_number == HTML_AREA ||
	      element_number == HTML_OBJECT)) {
	    return HT_OK;
d5668 2
a5669 2
     * Pop state off stack if we didn't declare the element SGML_EMPTY in
     * HTMLDTD.c.  - FM & KW
a5671 1
	skip_stack_requested = (BOOL) (me->skip_stack > 0);
d5678 1
a5678 2
	     me->sp[0].tag_number == HTML_DIR ||
	     me->sp[0].tag_number == HTML_LI) &&
d5686 3
a5688 2
	     * Set the break flag if we're popping a dummy HTML_LH substituted
	     * for an HTML_H# encountered in a list.
a5691 4
	if (me->skip_stack == 0 && element_number == HTML_OBJECT &&
	    me->sp[0].tag_number == HTML_OBJECT_M &&
	    (me->sp < (me->stack + MAX_NESTING - 1)))
	    me->sp[0].tag_number = HTML_OBJECT;
d5693 2
a5694 4
	    CTRACE2(TRACE_STYLE,
		    (tfp,
		     "HTML:end_element: Internal call (level %d), leaving on stack - %s\n",
		     me->skip_stack, NONNULL(me->sp->style->name)));
a5695 18
	} else if (element_number == HTML_OBJECT &&
		   me->sp[0].tag_number != HTML_OBJECT &&
		   me->sp[0].tag_number != HTML_OBJECT_M &&
		   me->objects_mixed_open > 0 &&
		   !(me->objects_figged_open > 0 &&
		     me->sp[0].tag_number == HTML_FIG)) {
	    /*
	     * Ignore non-corresponding OBJECT tags that we didn't push because
	     * the SGML parser was supposed to go on parsing the contents
	     * non-literally.  - kw
	     */
	    CTRACE2(TRACE_STYLE,
		    (tfp, "HTML:end_element[%d]: %s (level %d), %s - %s\n",
		     (int) STACKLEVEL(me),
		     "Special OBJECT handling", me->objects_mixed_open,
		     "leaving on stack",
		     NONNULL(me->sp->style->name)));
	    me->objects_mixed_open--;
d5697 1
a5697 1
		   element_number != me->sp[0].tag_number) {
d5699 9
a5707 6
	     * Ignore non-corresponding tags if we had a stack overrun.  This
	     * is not a completely fail-safe strategy for protection against
	     * any seriously adverse consequences of a stack overrun, and the
	     * rendering of the document will not be as intended, but we expect
	     * overruns to be rare, and this should offer reasonable protection
	     * against crashes if an overrun does occur.  - FM
d5709 1
a5709 1
	    return HT_OK;	/* let's pretend... */
d5711 1
a5711 1
		   me->sp[0].tag_number != HTML_SELECT) {
d5713 4
a5716 3
	     * Ignore non-corresponding SELECT tags, since we probably popped
	     * it and closed the SELECT block to deal with markup which amounts
	     * to a nested SELECT, or an out of order FORM end tag.  - FM
d5718 1
a5718 1
	    return HT_OK;
d5720 11
a5730 12
		   HTML_dtd.tags[HTML_LH].contents == SGML_EMPTY &&
		   (me->sp[0].tag_number == HTML_UL ||
		    me->sp[0].tag_number == HTML_OL ||
		    me->sp[0].tag_number == HTML_MENU ||
		    me->sp[0].tag_number == HTML_DIR ||
		    me->sp[0].tag_number == HTML_LI) &&
		   (element_number == HTML_H1 ||
		    element_number == HTML_H2 ||
		    element_number == HTML_H3 ||
		    element_number == HTML_H4 ||
		    element_number == HTML_H6 ||
		    element_number == HTML_H6)) {
d5732 3
a5734 2
	     * It's an H# for which we substituted an HTML_LH, which we've
	     * declared as SGML_EMPTY, so just return.  - FM
d5736 1
a5736 1
	    return HT_OK;
a5737 24
#ifdef EXP_JUSTIFY_ELTS
	    if (wait_for_this_stacked_elt == me->stack - me->sp + MAX_NESTING)
		reached_awaited_stacked_elt = TRUE;
#endif
	    if (element_number == HTML_OBJECT) {
		if (me->sp[0].tag_number == HTML_FIG &&
		    me->objects_figged_open > 0) {
		    /*
		     * It's an OBJECT for which we substituted a FIG, so pop
		     * the FIG and pretend that's what we are being called for. 
		     * - kw
		     */
		    CTRACE2(TRACE_STYLE,
			    (tfp,
			     "HTML:end_element[%d]: %s (level %d), %s - %s\n",
			     (int) STACKLEVEL(me),
			     "Special OBJECT->FIG handling",
			     me->objects_figged_open,
			     "treating as end FIG",
			     NONNULL(me->sp->style->name)));
		    me->objects_figged_open--;
		    element_number = HTML_FIG;
		}
	    }
d5739 3
a5741 5
	    CTRACE2(TRACE_STYLE,
		    (tfp,
		     "HTML:end_element[%d]: Popped style off stack - %s\n",
		     (int) STACKLEVEL(me),
		     NONNULL(me->sp->style->name)));
d5743 2
a5744 2
	    CTRACE2(TRACE_STYLE, (tfp,
				  "Stack underflow error!  Tried to pop off more styles than exist in stack\n"));
d5747 2
a5748 7
    if (BreakFlag == TRUE) {
#ifdef EXP_JUSTIFY_ELTS
	if (reached_awaited_stacked_elt)
	    wait_for_this_stacked_elt = -1;
#endif
	return HT_OK;		/* let's pretend... */
    }
d5751 1
a5751 1
     * Check for unclosed TEXTAREA.  - FM
d5754 6
a5759 2
	if (LYBadHTML(me))
	    CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag\n"));
d5767 1
a5767 1
     * Handle the end tag.  - FM
d5769 1
a5769 1
    switch (element_number) {
d5773 2
a5774 2
	    if (LYBadHTML(me))
		CTRACE((tfp,
d5779 6
a5784 4
			(((me->inSELECT || me->inTEXTAREA) && me->inA)
			 ? ", "
			 : ""),
			me->inA ? "A" : ""));
d5790 7
a5796 7
	    (LYIsUIPage3(me->node_anchor->address, UIP_LIST_PAGE, 0) ||
	     LYIsUIPage3(me->node_anchor->address, UIP_ADDRLIST_PAGE, 0))) {
	    /* If we are parsing the List Page, and have a BASE after we are
	     * done with the HEAD element, propagate it back to the node_anchor
	     * object.  The base should have been inserted by showlist() to
	     * record what document the List Page is about, and other functions
	     * may later look for it in the anchor.  - kw
d5809 13
a5821 11
	 * Check if it's a bookmark file, and if so, and multiple bookmark
	 * support is on, or it's off but this isn't the default bookmark file
	 * (e.g., because it was on before, and this is another bookmark file
	 * that has been retrieved as a previous document), insert the current
	 * description string and filepath for it.  We pass the strings back to
	 * the SGML parser so that any 8 bit or multibyte/CJK characters will
	 * be handled by the parser's state and charset routines.  - FM
	 */
	if (non_empty(me->node_anchor->bookmark)) {
	    if ((LYMultiBookmarks != MBM_OFF) ||
		(non_empty(bookmark_page) &&
a5822 2
		if (!include)
		    include = &me->xinclude;
d5833 1
a5833 1
				      MBM_A_subdescript[i] : gettext("(none)")));
d5841 2
a5842 3
				       *MBM_A_subbookmark[i])
				      ? MBM_A_subbookmark[i]
				      : gettext("(unknown)")));
d5856 2
a5857 2
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
d5860 2
a5861 3
	CTRACE2(TRACE_STYLE,
		(tfp, "HTML: STYLE content =\n%s\n",
		 me->style_block.data));
d5867 2
a5868 2
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
d5871 2
a5872 2
	CTRACE((tfp, "HTML: SCRIPT content =\n%s\n",
		me->script.data));
d5878 2
a5879 2
	    if (LYBadHTML(me))
		CTRACE((tfp,
d5884 6
a5889 4
			(((me->inSELECT || me->inTEXTAREA) && me->inA)
			 ? ", "
			 : ""),
			me->inA ? "A" : ""));
d5894 1
a5894 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d5901 1
a5901 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d5909 5
a5913 4
	/*
	 * Set flag to know that style has ended.  Fall through.
	 i_prior_style = -1;
	 */
d5926 3
a5928 9
	if (me->Division_Level >= 0) {
	    if (me->sp->style->alignment !=
		me->DivisionAlignments[me->Division_Level]) {
		if (me->inP)
		    LYEnsureSingleSpace(me);
		me->sp->style->alignment =
		    me->DivisionAlignments[me->Division_Level];
	    }
	}
d5930 1
a5930 6
	if (me->style_change) {
	    actually_set_style(me);
	    if (me->List_Nesting_Level >= 0)
		HText_NegateLineOne(me->text);
	} else if (me->inP)
	    LYEnsureSingleSpace(me);
d5932 2
d5936 1
a5936 1
    case HTML_H1:		/* header styles */
d5944 3
a5946 3
		me->DivisionAlignments[me->Division_Level];
	} else if (me->sp->style->id == ST_HeadingCenter ||
		   me->sp->style->id == ST_Heading1) {
d5948 1
a5948 1
	} else if (me->sp->style->id == ST_HeadingRight) {
d5970 4
a5973 4
	LYHandlePlike(me,
		      (const BOOL *) 0, (const char **) 0,
		      include, 0,
		      FALSE);
d5980 1
a5980 1
    case HTML_B:		/* Physical character highlighting */
d5985 1
a5985 1
    case HTML_CITE:		/* Logical character highlighting */
d5989 2
a5990 2
	 * Ignore any emphasis end tags if the Underline_Level is not set.  -
	 * FM
d5996 2
a5997 2
	 * Adjust the Underline level counter, and turn off underlining if
	 * appropriate.  - FM
d6003 1
a6003 1
	    CTRACE((tfp, "Ending underline\n"));
d6005 1
a6005 1
	    CTRACE((tfp, "Underline Level is %d\n", me->Underline_Level));
d6009 1
a6009 1
    case HTML_ABBREV:		/* Miscellaneous character containers */
d6019 1
a6024 4
    case HTML_SUB:
	HText_appendCharacter(me->text, ']');
	break;

d6053 5
a6057 4
	 * Should check LANG and/or DIR attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * to determine whether we should use chevrons, but for now we'll
	 * always use double- or single-quotes.  - FM
d6065 1
a6065 1
    case HTML_PRE:		/* Formatted text */
d6067 1
a6067 1
	 * Set to know that we are no longer in a PRE block.
d6070 1
a6070 3
	/* FALLTHRU */
    case HTML_LISTING:		/* Literal text */
	/* FALLTHRU */
a6071 1
	/* FALLTHRU */
d6075 1
a6075 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6084 1
a6084 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6095 1
a6095 2
		       me->List_Nesting_Level : 11] = OL_VOID;
	/* FALLTHRU */
a6096 1
	/* FALLTHRU */
a6097 1
	/* FALLTHRU */
a6098 1
	/* FALLTHRU */
d6101 3
a6103 7
	CTRACE((tfp, "HTML_end_element: Reducing List Nesting Level to %d\n",
		me->List_Nesting_Level));
#ifdef EXP_JUSTIFY_ELTS
	if (element_number == HTML_DL)
	    in_DT = FALSE;	/*close the term that was without definition. */
#endif
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6111 3
a6113 3
	 * Should undo anything we did based on LANG and/or DIR attributes, and
	 * the me->node_anchor->charset and/or yet to be added structure
	 * elements.  - FM
d6119 3
a6121 3
	 * Should undo anything we did based on DIR (and/or LANG) attributes,
	 * and the me->node_anchor->charset and/or yet to be added structure
	 * elements.  - FM
d6127 1
a6127 1
	 * Ignore any spurious A end tags.  - FM
d6132 1
a6132 1
	 * Set to know that we are no longer in an anchor.
d6135 1
a6135 6
#ifdef MARK_HIDDEN_LINKS
	if (non_empty(hidden_link_marker) &&
	    HText_isAnchorBlank(me->text, me->CurrentANum)) {
	    HText_appendText(me->text, hidden_link_marker);
	}
#endif
d6154 2
a6155 2
	 * We may need to look at this someday to deal with OBJECTs optimally,
	 * but just ignore it for now.  - FM
d6157 1
a6157 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6162 2
a6163 2
	 * We may need to look at this someday to deal with APPLETs optimally,
	 * but just ignore it for now.  - FM
d6165 1
a6165 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6169 13
a6181 5
	LYHandleFIG(me, NULL, NULL,
		    0,
		    0,
		    NULL,
		    NULL, NO, FALSE, &intern_flag);
d6186 1
a6186 1
	 * Finish the data off.
d6190 1
a6190 2
	    char *start = NULL, *first_end = NULL, *last_end = NULL;
	    char *first_map = NULL, *last_map = NULL;
d6198 4
a6201 3
		 * Look for nested OBJECTs.  This procedure could get tripped
		 * up if invalid comments are present in the content, or if an
		 * OBJECT end tag is present in a quoted attribute.  - FM
d6206 1
a6206 2
		} else if (s == 0 && !strncasecomp(cp, "<PARAM", 6) &&
			   !IsNmChar(cp[6])) {
d6208 1
a6208 2
		} else if (!strncasecomp(cp, "<OBJECT", 7) &&
			   !IsNmChar(cp[7])) {
d6212 1
a6212 2
		} else if (!strncasecomp(cp, "</OBJECT", 8) &&
			   !IsNmChar(cp[8])) {
a6214 1
		    last_end = cp;
a6215 8
		} else if (!strncasecomp(cp, "<MAP", 4) &&
			   !IsNmChar(cp[4])) {
		    if (!first_map)
			first_map = cp;
		    last_map = cp;
		} else if (!strncasecomp(cp, "</MAP", 5) &&
			   !IsNmChar(cp[5])) {
		    last_map = cp;
d6219 1
a6219 1
	    if (s < e) {
d6221 12
a6232 46
		 * We had more end tags than start tags, so we have bad HTML or
		 * otherwise misparsed.  - FM
		 */
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content:\n%s\n",
			    me->object.data));
		goto End_Object;
	    }
	    if (s > e) {
		if (!me->object_declare && !me->object_name &&
		    !(me->object_shapes && !LYMapsOnly) &&
		    !(me->object_usemap != NULL && !LYMapsOnly) &&
		    !(clickable_images && !LYMapsOnly &&
		      me->object_data != NULL &&
		      !have_param &&
		      me->object_classid == NULL &&
		      me->object_codebase == NULL &&
		      me->object_codetype == NULL)) {
		    /*
		     * We have nested OBJECT tags, and not yet all of the end
		     * tags, but have a case where the content needs to be
		     * parsed again (not dropped) and where we don't want to
		     * output anything special at the point when we
		     * *do* have accumulated all the end tags.  So recycle
		     * the incomplete contents now, and signal the SGML parser
		     * that it should not regard the current OBJECT ended but
		     * should treat its contents as mixed.  Normally these
		     * cases would have already handled in the real
		     * start_element call, so this block may not be necessary. 
		     * - kw
		     */
		    CTRACE((tfp, "%s:\n%s\n",
			    "HTML: Nested OBJECT tags.  Recycling incomplete contents",
			    me->object.data));
		    status = HT_PARSER_OTHER_CONTENT;
		    me->object.size--;
		    HTChunkPuts(&me->object, "</OBJECT>");
		    if (!include)	/* error, should not happen */
			include = &me->xinclude;
		    StrnAllocCat(*include, me->object.data, me->object.size);
		    clear_objectdata(me);
		    /* an internal fake call to keep our stack happy: */
		    HTML_start_element(me, HTML_OBJECT, NULL, NULL,
				       me->tag_charset, include);
		    break;
a6233 10
		/*
		 * We have nested OBJECT tags, and not yet all of the end tags,
		 * and we want the end tags.  So restore an end tag to the
		 * content, and signal to the SGML parser that it should resume
		 * the accumulation of OBJECT content (after calling back to
		 * start_element) in a way that is equivalent to passing it a
		 * dummy start tag.  - FM, kw
		 */
		CTRACE((tfp, "HTML: Nested OBJECT tags.  Recycling.\n"));
		status = HT_PARSER_REOPEN_ELT;
d6236 1
a6236 2
		if (!LYMapsOnly)
		    change_paragraph_style(me, me->sp->style);
d6239 15
d6256 5
a6260 4
	     * OBJECT start and end tags are fully matched, assuming we weren't
	     * tripped up by comments or quoted attributes.  - FM
	     */
	    CTRACE((tfp, "HTML:OBJECT content:\n%s\n", me->object.data));
d6263 6
a6268 4
	     * OBJECTs with DECLARE should be saved but not instantiated, and
	     * if nested, can have only other DECLAREd OBJECTs.  Until we have
	     * code to handle these, we'll just create an anchor for the ID, if
	     * present, and discard the content (sigh 8-).  - FM
d6271 1
a6271 1
		if (non_empty(me->object_id) && !LYMapsOnly)
d6273 1
a6273 1
		CTRACE((tfp, "HTML: DECLAREd OBJECT.  Ignoring!\n"));
d6278 4
a6281 3
	     * OBJECTs with NAME are for FORM submissions.  We'll just create
	     * an anchor for the ID, if present, and discard the content until
	     * we have code to handle these.  (sigh 8-).  - FM
d6283 2
a6284 2
	    if (me->object_name != NULL && !LYMapsOnly) {
		if (non_empty(me->object_id))
d6286 1
a6286 1
		CTRACE((tfp, "HTML: NAMEd OBJECT.  Ignoring!\n"));
d6291 2
a6292 2
	     * Deal with any nested OBJECTs by descending to the inner-most
	     * OBJECT.  - FM
d6298 3
a6300 3
		     * Minumum requirements for the ad hoc parsing to have
		     * succeeded are met.  We'll hope that it did succeed.  -
		     * FM
d6302 6
a6307 21
		    if (LYMapsOnly) {
			/*
			 * Well we don't need to do this any more, nested
			 * objects should either not get here any more at all
			 * or can be handled fine by other code below.  Leave
			 * in place for now as a special case for LYMapsOnly. 
			 * - kw
			 */
			if (LYMapsOnly && (!last_map || last_map < first_end))
			    *first_end = '\0';
			else
			    e = 0;
			data = NULL;
			if (LYMapsOnly && (!first_map || first_map > start))
			    StrAllocCopy(data, start);
			else
			    StrAllocCopy(data, me->object.data);
			if (e > 0) {
			    for (i = e; i > 0; i--) {
				StrAllocCat(data, "</OBJECT>");
			    }
a6308 7
			if (!include)	/* error, should not happen */
			    include = &me->xinclude;
			StrAllocCat(*include, data);
			CTRACE((tfp, "HTML: Recycling nested OBJECT%s.\n",
				(s > 1) ? "s" : ""));
			FREE(data);
			goto End_Object;
d6310 6
d6317 7
a6323 3
		    if (LYBadHTML(me))
			CTRACE((tfp,
				"Bad HTML: Unmatched OBJECT start and end tags.  Discarding content.\n"));
d6329 4
a6332 10
	     * If its content has SHAPES, convert it to FIG.  - FM
	     *
	     * This is now handled in our start_element without using include
	     * if the SGML parser cooperates, so this block may be unnecessary. 
	     * - kw
	     */
	    if (me->object_shapes == TRUE && !LYMapsOnly) {
		CTRACE((tfp, "HTML: OBJECT has SHAPES.  Converting to FIG.\n"));
		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
d6356 2
a6357 2
	     * If it has a USEMAP attribute and didn't have SHAPES, convert it
	     * to IMG.  - FM
d6359 2
a6360 2
	    if (me->object_usemap != NULL && !LYMapsOnly) {
		CTRACE((tfp, "HTML: OBJECT has USEMAP.  Converting to IMG.\n"));
a6361 2
		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
d6365 1
a6365 1
		     * Pass the ID.  - FM
d6374 2
a6375 2
		     * We have DATA with no CLASSID, so let's hope it'
		     * equivalent to an SRC.  - FM
d6383 2
a6384 1
		     * Use the TITLE for both the MAP and the IMGs ALT.  - FM
d6393 1
a6393 1
		 * Add the USEMAP, and an ISMAP if present.  - FM
a6404 47
		/*
		 * Add the content if it has <MAP, since that may be the MAP
		 * this usemap points to.  But if we have nested objects, try
		 * to eliminate portions that cannot contribute to the quest
		 * for MAP.  This is not perfect, we may get too much content;
		 * this seems preferable over losing too much.  - kw
		 */
		if (first_map) {
		    if (s == 0) {
			StrAllocCat(*include, me->object.data);
			CTRACE((tfp,
				"HTML: MAP found, recycling object contents.\n"));
			goto End_Object;
		    }
		    /* s > 0 and s == e */
		    data = NULL;
		    if (last_map < start) {
			*start = '\0';
			i = 0;
		    } else if (last_map < first_end) {
			*first_end = '\0';
			i = e;
		    } else if (last_map < last_end) {
			*last_end = '\0';
			i = 1;
		    } else {
			i = 0;
		    }
		    if (first_map > last_end) {
			/* fake empty object to keep stacks stack happy */
			StrAllocCopy(data, "<OBJECT><");
			StrAllocCat(data, last_end + 1);
			i = 0;
		    } else if (first_map > start) {
			StrAllocCopy(data, start);
		    } else {
			StrAllocCopy(data, me->object.data);
		    }
		    for (; i > 0; i--) {
			StrAllocCat(data, "</OBJECT>");
		    }
		    CTRACE((tfp, "%s:\n%s\n",
			    "HTML: MAP and nested OBJECT tags.  Recycling parts",
			    data));
		    StrAllocCat(*include, data);
		    FREE(data);
		}
d6409 1
a6409 1
	     * Add an ID link if needed.  - FM
d6411 1
a6411 1
	    if (non_empty(me->object_id) && !LYMapsOnly)
d6415 1
a6415 1
	     * Add the OBJECTs content if not empty.  - FM
d6417 1
a6417 3
	    if (me->object.size > 1) {
		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
a6418 1
	    }
d6421 6
a6426 4
	     * Create a link to the DATA, if desired, and we can rule out that
	     * it involves scripting code.  This a risky thing to do, but we
	     * can toggle clickable_images mode off if it really screws things
	     * up, and so we may as well give it a try.  - FM
d6429 1
a6429 2
		if (!LYMapsOnly &&
		    me->object_data != NULL &&
d6435 6
a6440 5
		     * We have a DATA value and no need for scripting code, so
		     * close the current Anchor, if one is open, and add an
		     * Anchor for this source.  If we also have a TYPE value,
		     * check whether it's an image or not, and set the link
		     * name accordingly.  - FM
a6441 2
		    if (!include)	/* error, should not happen */
			include = &me->xinclude;
d6459 1
a6459 1
	 * Re-intialize all of the OBJECT elements.  - FM
d6461 15
a6475 2
      End_Object:
	clear_objectdata(me);
d6477 1
a6477 2
	if (!LYMapsOnly)
	    change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6484 1
a6484 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
d6489 1
a6489 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6496 1
a6496 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6504 1
a6504 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6510 4
a6513 3
	 * Check if we had a FORM start tag, and issue a message if not, but
	 * fall through to check for an open SELECT and ensure that the
	 * FORM-related globals in GridText.c are initialized.  - FM
d6516 6
a6521 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Unmatched FORM end tag\n"));
a6522 1
	EMIT_IFDEF_EXP_JUSTIFY_ELTS(form_in_htext = FALSE);
d6525 9
a6533 7
	 * Check if we still have a SELECT element open.  FORM may have been
	 * declared SGML_EMPTY in HTMLDTD.c, and in that case SGML_character()
	 * in SGML.c is not able to ensure correct nesting; or it may have
	 * failed to enforce valid nesting.  If a SELECT is open, issue a
	 * message, then call HTML_end_element() directly (with a check in that
	 * to bypass decrementing of the HTML parser's stack) to close the
	 * SELECT.  - kw
d6536 7
a6542 3
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: Open SELECT at FORM end. Faking SELECT end tag. *****\n"));
d6550 1
a6550 1
	 * Set to know that we are no longer in an form.
d6556 5
a6560 4
	 * If we are in a list and are on the first line with no text following
	 * a bullet or number, don't force a newline.  This could happen if we
	 * were called from HTML_start_element() due to a missing FORM end tag. 
	 * - FM
d6569 1
a6569 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6575 1
a6575 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6591 1
a6591 1
	     * Make sure we had a textarea start tag.
d6594 6
a6599 2
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Unmatched TEXTAREA end tag\n"));
d6604 1
a6604 1
	     * Set to know that we are no longer in a textarea tag.
d6609 1
a6609 1
	     * Initialize.
d6611 5
a6615 19
	    I.align = NULL;
	    I.accept = NULL;
	    I.checked = NO;
	    I.iclass = NULL;
	    I.disabled = NO;
	    I.error = NULL;
	    I.height = NULL;
	    I.id = NULL;
	    I.lang = NULL;
	    I.max = NULL;
	    I.maxlength = NULL;
	    I.md = NULL;
	    I.min = NULL;
	    I.name = NULL;
	    I.size = 0;
	    I.src = NULL;
	    I.type = NULL;
	    I.value = NULL;
	    I.width = NULL;
d6620 1
a6620 1
	     * Before any input field add a space if necessary.
d6625 1
a6625 1
	     * Add a return.
d6630 1
a6630 1
	     * Finish the data off.
d6633 1
d6646 6
a6651 10
	     * Transform the TEXTAREA content as needed, then parse it into
	     * individual lines to be handled as a series series of INPUT
	     * fields (ugh!).  Any raw 8-bit or multibyte characters already
	     * have been handled in relation to the display character set in
	     * SGML_character().
	     *
	     * If TEXTAREA is handled as SGML_LITTERAL (the old way), we need
	     * to SGML-unescape any character references and NCRs here. 
	     * Otherwise this will already have happened in the SGML.c parsing. 
	     * - kw
d6655 4
a6658 27
	    if (HTML_dtd.tags[element_number].contents == SGML_LITTERAL) {
		TRANSLATE_AND_UNESCAPE_ENTITIES6(&me->textarea.data,
						 me->UCLYhndl,
						 current_char_set,
						 NO,
						 me->UsePlainSpace, me->HiddenValue);
	    } else {
		/*
		 * This shouldn't have anything to do, normally, but just in
		 * case...  There shouldn't be lynx special character codes in
		 * the chunk ("DTD" flag Tgf_nolyspcl tells SGML.c not to
		 * generate them).  If there were, we could set the last
		 * parameter ('Back') below to YES, which would take them out
		 * of the data.  The data may however contain non break space,
		 * soft hyphen, or en space etc., in the me->UCLYhndl character
		 * encoding.  If that's a problem, perhaps for the (line or
		 * other) editor, setting 'Back' to YES should also help to
		 * always convert them to plain spaces (or drop them).  - kw
		 */
		TRANSLATE_HTML7(&me->textarea.data,
				me->UCLYhndl,
				current_char_set,
				NO,
				me->UsePlainSpace, me->HiddenValue,
				NO);
	    }
	    data = me->textarea.data;
d6661 2
a6662 1
	     * Trim any trailing newlines and skip any lead newlines.  - FM
d6674 2
a6675 1
	     * Load the first text line, or set up for all blank rows.  - FM
d6691 2
a6692 2
	     * Display at least the requested number of text lines and/or blank
	     * rows.  - FM
a6695 1

d6698 1
a6698 1
			temp[j] = (char) (temp[j + 1] ? ' ' : '\0');
d6723 3
a6725 3
	     * Check for more data lines than the rows attribute.  We add them
	     * to the display, because we support only horizontal and not also
	     * vertical scrolling.  - FM
a6728 1

d6731 1
a6731 1
			temp[j] = (char) (temp[j + 1] ? ' ' : '\0');
d6735 1
a6735 1
		for (chars = me->textarea_cols; chars > 0; chars--)
d6760 1
d6770 1
a6770 1
	     * Make sure we had a select start tag.
d6773 6
a6778 2
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Unmatched SELECT end tag *****\n"));
d6783 1
a6783 1
	     * Set to know that we are no longer in a select tag.
d6788 1
a6788 1
	     * Clear the disable attribute.
d6793 1
a6793 1
	     * Make sure we're in a form.
d6796 7
a6802 3
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: SELECT end tag not within FORM element *****\n"));
d6804 1
a6804 1
		 * Hopefully won't crash, so we'll ignore it.  - kw
d6809 1
a6809 1
	     * Finish the data off.
d6813 1
a6813 1
	     * Finish the previous option.
d6828 4
a6831 4
		/*
		 * Start a newline after the last checkbox/button option.
		 */
		LYEnsureSingleSpace(me);
d6834 2
a6835 2
		 * Output popup box with the default option to screen, but use
		 * non-breaking spaces for output.
d6842 3
a6844 3
		     * The code inadequately handles OPTION fields in PRE tags. 
		     * We'll put up a minimum of 6 characters, and if any more
		     * would exceed the wrap column, we'll ignore them.
d6848 1
a6848 1
			    HText_appendCharacter(me->text, HT_NON_BREAK_SPACE);
d6850 1
a6850 1
			    HText_appendCharacter(me->text, *ptr);
d6855 1
a6855 1
		for (; non_empty(ptr); ptr++) {
d6857 3
a6859 17
			HText_appendCharacter(me->text, HT_NON_BREAK_SPACE);
		    else {
			HTkcode kcode = NOKANJI;
			HTkcode specified_kcode = NOKANJI;

			if (HTCJK == JAPANESE) {
			    kcode = HText_getKcode(me->text);
			    HText_updateKcode(me->text, kanji_code);
			    specified_kcode = HText_getSpecifiedKcode(me->text);
			    HText_updateSpecifiedKcode(me->text, kanji_code);
			}
			HText_appendCharacter(me->text, *ptr);
			if (HTCJK == JAPANESE) {
			    HText_updateKcode(me->text, kcode);
			    HText_updateSpecifiedKcode(me->text, specified_kcode);
			}
		    }
d6862 1
a6862 1
		 * Add end option character.
a6865 1
		    HText_endInput(me->text);
d6886 2
a6887 6
#ifdef EXP_NESTED_TABLES
	if (!nested_tables)
#endif
	    me->inTABLE = FALSE;

	if (me->sp->style->id == ST_Preformatted) {
d6894 1
a6894 1
		me->DivisionAlignments[me->Division_Level];
a6896 11

#ifdef EXP_NESTED_TABLES
	if (nested_tables) {
	    me->inTABLE = HText_endStblTABLE(me->text);
	} else {
	    HText_endStblTABLE(me->text);
	}
#else
	HText_endStblTABLE(me->text);
#endif

d6904 2
a6905 3
	HText_endStblTR(me->text);
	if (!HText_LastLineEmpty(me->text, FALSE)) {
	    HText_setLastChar(me->text, ' ');	/* absorb next white space */
a6916 2
	if (me->inTABLE)
	    HText_endStblCOLGROUP(me->text);
d6920 2
a6922 1
	HText_endStblTD(me->text);
d6935 2
a6936 2
	 * We're getting it as Literal text, which, until we can process it,
	 * we'll display as is, within brackets to alert the user.  - FM
d6958 1
a6958 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6961 1
a6961 12
    }				/* switch */

#ifdef EXP_JUSTIFY_ELTS
    if (reached_awaited_stacked_elt)
	wait_for_this_stacked_elt = -1;
#endif

    if (me->xinclude) {
	HText_appendText(me->text, " *** LYNX ERROR ***\rUnparsed data:\r");
	HText_appendText(me->text, me->xinclude);
	FREE(me->xinclude);
    }
d6963 4
a6966 1
    if (!skip_stack_requested) {	/*don't emit stylechanges if skipped stack element - VH */
d6968 4
a6971 4
	FastTrimColorClass(HTML_dtd.tags[element_number].name,
			   HTML_dtd.tags[element_number].name_len,
			   Style_className,
			   &Style_className_end, &hcode);
d6973 1
d6975 8
a6982 7
	if (!ReallyEmptyTagNum(element_number)) {
	    CTRACE2(TRACE_STYLE,
		    (tfp,
		     "STYLE.end_element: ending non-\"EMPTY\" style <%s...>\n",
		     HTML_dtd.tags[element_number].name));
	    HText_characterStyle(me->text, HCODE_TO_STACK_OFF(hcode), STACK_OFF);
	}
a6984 1
    return status;
d6988 2
a6989 2
 *		------------------
 */
d6992 1
a6992 1
int HTML_put_entity(HTStructured * me, int entity_number)
d7004 11
a7014 11
 *	-------------------
 *
 *	If the document is empty, the text object will not yet exist.
 *	So we could in fact abandon creating the document and return
 *	an error code.	In fact an empty document is an important type
 *	of document, so we don't.
 *
 *	If non-interactive, everything is freed off.   No: crashes -listrefs
 *	Otherwise, the interactive object is left.
 */
static void HTML_free(HTStructured * me)
d7020 4
a7023 3
	 * We only handled MAP, AREA and BASE tags, and didn't create an HText
	 * structure for the document nor want one now, so just make sure we
	 * free anything that might have been allocated.  - FM
a7026 2
	clear_objectdata(me);
	FREE(me->xinclude);
d7036 7
a7042 6
	 * Emphasis containers, A, FONT, and FORM may be declared SGML_EMPTY in
	 * HTMLDTD.c, and SGML_character() in SGML.c may check for their end
	 * tags to call HTML_end_element() directly (with a check in that to
	 * bypass decrementing of the HTML parser's stack).  So if we still
	 * have the emphasis (Underline) on, or any open A, FONT, or FORM
	 * containers, turn it off or close them now.  - FM & kw
d7044 6
a7049 5
	 * IF those tags are not declared SGML_EMPTY, but we let the SGML.c
	 * parser take care of correctly stacked ordering, and of correct
	 * wind-down on end-of-stream (in SGML_free SGML_abort), THEN these and
	 * other checks here in HTML.c should not be necessary.  Still it can't
	 * hurt to include them.  - kw
d7055 1
a7055 1
	    CTRACE((tfp, "HTML_free: Ending underline\n"));
a7059 1
	    CTRACE((tfp, "HTML_free: Ending HTML_A\n"));
d7071 11
a7081 7
	     * If we still have data in the me->option chunk after forcing a
	     * close of a still-open form, something must have gone very wrong. 
	     * - kw
	     */
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: SELECT or OPTION not ended properly *****\n"));
d7084 2
a7085 2
	     * Output the left-over data as text, maybe it was invalid markup
	     * meant to be shown somewhere.  - kw
d7087 2
a7088 2
	    CTRACE((tfp, "HTML_free: ***** leftover option data: %s\n",
		    me->option.data));
d7094 11
a7104 7
	     * If we still have data in the me->textarea chunk after forcing a
	     * close of a still-open form, something must have gone very wrong. 
	     * - kw
	     */
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: TEXTAREA not used properly *****\n"));
d7107 2
a7108 2
	     * Output the left-over data as text, maybe it was invalid markup
	     * meant to be shown somewhere.  - kw
d7110 2
a7111 2
	    CTRACE((tfp, "HTML_free: ***** leftover textarea data: %s\n",
		    me->textarea.data));
d7116 3
a7118 3
	 * If we're interactive and have hidden links but no visible links, add
	 * a message informing the user about this and suggesting use of the
	 * 'l'ist command.  - FM
d7127 1
a7127 1
			    gettext("Document has only hidden links.  Use the 'l'ist command."));
a7131 5
	if (me->xinclude) {
	    HText_appendText(me->text, " *** LYNX ERROR ***\rUnparsed data:\r");
	    HText_appendText(me->text, me->xinclude);
	    FREE(me->xinclude);
	}
d7134 1
a7134 1
	 * Now call the cleanup function.  - FM
d7140 3
a7142 2
	 * If we still have data in the me->option chunk after forcing a close
	 * of a still-open form, something must have gone very wrong.  - kw
d7144 7
a7150 3
	if (LYBadHTML(me))
	    CTRACE((tfp,
		    "Bad HTML: SELECT or OPTION not ended properly *****\n"));
d7153 2
a7154 2
	    CTRACE((tfp, "HTML_free: ***** leftover option data: %s\n",
		    me->option.data));
d7160 11
a7170 7
	 * If we still have data in the me->textarea chunk after forcing a
	 * close of a still-open form, something must have gone very wrong.  -
	 * kw
	 */
	if (LYBadHTML(me))
	    CTRACE((tfp,
		    "Bad HTML: TEXTAREA not used properly *****\n"));
d7173 2
a7174 2
	    CTRACE((tfp, "HTML_free: ***** leftover textarea data: %s\n",
		    me->textarea.data));
d7180 1
a7180 1
	(*me->targetClass._free) (me->target);
d7183 3
a7185 3
	if (me->sp->style->id == ST_DivCenter ||
	    me->sp->style->id == ST_HeadingCenter ||
	    me->sp->style->id == ST_Heading1) {
d7187 2
a7188 2
	} else if (me->sp->style->id == ST_DivRight ||
		   me->sp->style->id == ST_HeadingRight) {
d7190 1
a7190 1
	} else {
d7195 5
a7202 1
    clear_objectdata(me);
d7206 1
a7206 1
static void HTML_abort(HTStructured * me, HTError e)
d7212 2
a7213 2
	 * If we have emphasis on, or open A, FONT, or FORM containers, turn it
	 * off or close them now.  - FM
d7234 1
a7234 1
	 * Now call the cleanup function.  - FM
d7241 3
a7243 2
	 * If we still have data in the me->option chunk after forcing a close
	 * of a still-open form, something must have gone very wrong.  - kw
d7246 2
a7247 2
	    CTRACE((tfp,
		    "HTML_abort: SELECT or OPTION not ended properly *****\n"));
d7249 2
a7250 2
	    CTRACE((tfp, "HTML_abort: ***** leftover option data: %s\n",
		    me->option.data));
d7256 3
a7258 3
	 * If we still have data in the me->textarea chunk after forcing a
	 * close of a still-open form, something must have gone very wrong.  -
	 * kw
d7261 2
a7262 1
	    CTRACE((tfp, "HTML_abort: TEXTAREA not used properly *****\n"));
d7264 2
a7265 2
	    CTRACE((tfp, "HTML_abort: ***** leftover textarea data: %s\n",
		    me->textarea.data));
d7271 1
a7271 1
	(*me->targetClass._abort) (me->target, e);
d7274 3
a7276 3
	if (me->sp->style->id == ST_DivCenter ||
	    me->sp->style->id == ST_HeadingCenter ||
	    me->sp->style->id == ST_Heading1) {
d7278 2
a7279 2
	} else if (me->sp->style->id == ST_DivRight ||
		   me->sp->style->id == ST_HeadingRight) {
d7281 1
a7281 1
	} else {
d7286 5
d7295 1
a7297 2
    FREE(me->xinclude);
    clear_objectdata(me);
d7302 3
a7304 3
 *	---------------------------
 */
static void get_styles(void)
d7306 2
a7307 5
    HTStyle **st = NULL;

    styleSheet = DefaultStyle(&st);	/* sets st[] array */

    default_style = st[ST_Normal];
d7309 22
a7330 22
    styles[HTML_H1] = st[ST_Heading1];
    styles[HTML_H2] = st[ST_Heading2];
    styles[HTML_H3] = st[ST_Heading3];
    styles[HTML_H4] = st[ST_Heading4];
    styles[HTML_H5] = st[ST_Heading5];
    styles[HTML_H6] = st[ST_Heading6];
    styles[HTML_HCENTER] = st[ST_HeadingCenter];
    styles[HTML_HLEFT] = st[ST_HeadingLeft];
    styles[HTML_HRIGHT] = st[ST_HeadingRight];

    styles[HTML_DCENTER] = st[ST_DivCenter];
    styles[HTML_DLEFT] = st[ST_DivLeft];
    styles[HTML_DRIGHT] = st[ST_DivRight];

    styles[HTML_DL] = st[ST_Glossary];
    /* nested list styles */
    styles[HTML_DL1] = st[ST_Glossary1];
    styles[HTML_DL2] = st[ST_Glossary2];
    styles[HTML_DL3] = st[ST_Glossary3];
    styles[HTML_DL4] = st[ST_Glossary4];
    styles[HTML_DL5] = st[ST_Glossary5];
    styles[HTML_DL6] = st[ST_Glossary6];
d7333 8
a7340 8
	styles[HTML_OL] = st[ST_List];
    /* nested list styles */
    styles[HTML_OL1] = st[ST_List1];
    styles[HTML_OL2] = st[ST_List2];
    styles[HTML_OL3] = st[ST_List3];
    styles[HTML_OL4] = st[ST_List4];
    styles[HTML_OL5] = st[ST_List5];
    styles[HTML_OL6] = st[ST_List6];
d7343 24
a7366 24
	styles[HTML_DIR] = st[ST_Menu];
    /* nested list styles */
    styles[HTML_MENU1] = st[ST_Menu1];
    styles[HTML_MENU2] = st[ST_Menu2];
    styles[HTML_MENU3] = st[ST_Menu3];
    styles[HTML_MENU4] = st[ST_Menu4];
    styles[HTML_MENU5] = st[ST_Menu5];
    styles[HTML_MENU6] = st[ST_Menu6];

    styles[HTML_DLC] = st[ST_GlossaryCompact];
    /* nested list styles */
    styles[HTML_DLC1] = st[ST_GlossaryCompact1];
    styles[HTML_DLC2] = st[ST_GlossaryCompact2];
    styles[HTML_DLC3] = st[ST_GlossaryCompact3];
    styles[HTML_DLC4] = st[ST_GlossaryCompact4];
    styles[HTML_DLC5] = st[ST_GlossaryCompact5];
    styles[HTML_DLC6] = st[ST_GlossaryCompact6];

    styles[HTML_ADDRESS] = st[ST_Address];
    styles[HTML_BANNER] = st[ST_Banner];
    styles[HTML_BLOCKQUOTE] = st[ST_Blockquote];
    styles[HTML_BQ] = st[ST_Bq];
    styles[HTML_FN] = st[ST_Footnote];
    styles[HTML_NOTE] = st[ST_Note];
d7368 3
a7370 3
	styles[HTML_XMP] = st[ST_Example];
    styles[HTML_PRE] = st[ST_Preformatted];
    styles[HTML_LISTING] = st[ST_Listing];
d7377 1
a7377 1
HTStyle *LYstyles(int style_number)
d7388 3
a7390 3
 *	-----------------------
 */
const HTStructuredClass HTMLPresentation =	/* As opposed to print etc */
d7392 6
a7397 6
    "Lynx_HTML_Handler",
    HTML_free,
    HTML_abort,
    HTML_put_character, HTML_put_string, HTML_write,
    HTML_start_element, HTML_end_element,
    HTML_put_entity
d7401 9
a7409 8
 *		--------------------------
 *
 *	The structured stream can generate either presentation,
 *	or plain text, or HTML.
 */
HTStructured *HTML_new(HTParentAnchor *anchor,
		       HTFormat format_out,
		       HTStream *stream)
d7412 1
a7412 1
    HTStructured *me;
d7415 2
a7416 3
	HTStream *intermediate = HTStreamStack(WWW_HTML, format_out,
					       stream, anchor);

d7421 1
a7421 1
	exit_immediately(EXIT_FAILURE);
d7424 1
a7424 1
    me = typecalloc(HTStructured);
d7444 9
a7452 3
    HTChunkInit(&me->title, 128);

    HTChunkInit(&me->object, 128);
d7467 4
a7470 1
    HTChunkInit(&me->option, 128);
d7476 4
a7479 1
    HTChunkInit(&me->textarea, 128);
d7483 1
a7483 1
    me->textarea_cols = 0;
d7488 14
a7501 5
    HTChunkInit(&me->math, 128);

    HTChunkInit(&me->style_block, 128);

    HTChunkInit(&me->script, 128);
d7510 2
a7511 2
    me->sp->tag_number = -1;	/* INVALID */
    me->sp->style = default_style;	/* INVALID */
d7524 1
a7524 1
     * Used for nested lists.  - FM
d7526 4
a7529 4
    me->List_Nesting_Level = -1;	/* counter for list nesting level */
    LYZero_OL_Counter(me);	/* Initializes OL_Counter[] and OL_Type[] */
    me->Last_OL_Count = 0;	/* last count in ordered lists */
    me->Last_OL_Type = '1';	/* last type in ordered lists */
a7537 1
    me->node_anchor->inBASE = FALSE;
d7559 5
a7563 6
#ifdef LY_FIND_LEAKS
    if (Style_className == 0) {
	atexit(free_Style_className);
    }
#endif
    addClassName("", "", 0);
d7567 47
d7615 5
a7619 5
     * Create a chartrans stage info structure for the anchor, if it does not
     * exist already (in which case the default MIME stage info will be loaded
     * as well), and load the HTML stage info into me->UCI and me->UCLYhndl.  -
     * FM
     */
d7624 4
a7627 3
     * Load the existing or default input charset info into the holding
     * elements.  We'll believe what is indicated for UCT_STAGE_PARSER.  - FM
     */
d7641 5
a7645 4
     * Load the existing or default output charset info into the holding
     * elements, UCT_STAGE_STRUCTURED should be the same as UCT_STAGE_TEXT at
     * this point, but we could check, perhaps.  - FM
     */
d7650 5
d7658 1
a7658 1
	me->targetClass = *stream->isa;		/* Copy pointers */
d7660 1
a7660 1
    return (HTStructured *) me;
d7663 1
a7663 11
#ifdef USE_SOURCE_CACHE

/*
 * A flag set by a file write error.  Used for only generating an alert the
 * first time such an error happens, since Lynx should still be usable if the
 * temp space becomes full, and an alert each time a cache file cannot be
 * written would be annoying.  Reset when lynx.cfg is being reloaded (user may
 * change SOURCE_CACHE setting).  - kw
 */
BOOLEAN source_cache_file_error = FALSE;

d7668 2
a7669 1
static void CacheThru_do_free(HTStream *me)
d7671 1
a7671 16
    if (me->anchor->source_cache_file) {
	CTRACE((tfp, "SourceCacheWriter: Removing previous file %s\n",
		me->anchor->source_cache_file));
	LYRemoveTemp(me->anchor->source_cache_file);
	FREE(me->anchor->source_cache_file);
    }
    if (me->anchor->source_cache_chunk) {
	CTRACE((tfp, "SourceCacheWriter: Removing previous memory chunk %p\n",
		(void *) me->anchor->source_cache_chunk));
	HTChunkFree(me->anchor->source_cache_chunk);
	me->anchor->source_cache_chunk = NULL;
    }
    if (me->fp) {
	fflush(me->fp);
	if (ferror(me->fp))
	    me->status = HT_ERROR;
d7673 1
a7673 42
	if (me->status == HT_OK) {
	    char *cp_freeme = 0;

	    me->anchor->source_cache_file = me->filename;
	    CTRACE((tfp,
		    "SourceCacheWriter: Committing file %s for URL %s to anchor\n",
		    me->filename,
		    cp_freeme = HTAnchor_address((HTAnchor *) me->anchor)));
	    FREE(cp_freeme);
	} else {
	    if (source_cache_file_error == FALSE) {
		HTAlert(gettext("Source cache error - disk full?"));
		source_cache_file_error = TRUE;
	    }
	    LYRemoveTemp(me->filename);
	    me->anchor->source_cache_file = NULL;
	}
    } else if (me->status != HT_OK) {
	if (me->chunk) {
	    CTRACE((tfp, "SourceCacheWriter: memory chunk %p had errors.\n",
		    me->chunk));
	    HTChunkFree(me->chunk);
	    me->chunk = NULL;
	}
	HTAlert(gettext("Source cache error - not enough memory!"));
    }
    if (me->chunk) {
	char *cp_freeme = NULL;

	me->anchor->source_cache_chunk = me->chunk;
	CTRACE((tfp,
		"SourceCacheWriter: Committing memory chunk %p for URL %s to anchor\n",
		(void *) me->chunk,
		cp_freeme = HTAnchor_address((HTAnchor *) me->anchor)));
	FREE(cp_freeme);
    }
}

static void CacheThru_free(HTStream *me)
{
    CacheThru_do_free(me);
    (*me->actions->_free) (me->target);
d7677 3
a7679 1
static void CacheThru_abort(HTStream *me, HTError e)
d7683 1
a7683 18
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((tfp, "SourceCacheWriter: Removing active file %s\n",
		    me->filename));
	    LYRemoveTemp(me->filename);
	    FREE(me->filename);
	}
	if (me->chunk) {
	    CTRACE((tfp,
		    "SourceCacheWriter: Removing active memory chunk %p\n",
		    (void *) me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	/*fake it */
	CacheThru_do_free(me);
    }
    (*me->actions->_abort) (me->target, e);
d7687 3
a7689 1
static void CacheThru_put_character(HTStream *me, char c_in)
d7691 5
a7695 10
    if (me->status == HT_OK) {
	if (me->fp) {
	    fputc(c_in, me->fp);
	} else if (me->chunk) {
	    HTChunkPutc(me->chunk, c_in);
	    if (me->chunk->allocated == 0)
		me->status = HT_ERROR;
	}
    }
    (*me->actions->put_character) (me->target, c_in);
d7698 3
a7700 1
static void CacheThru_put_string(HTStream *me, const char *str)
d7702 5
a7706 10
    if (me->status == HT_OK) {
	if (me->fp) {
	    fputs(str, me->fp);
	} else if (me->chunk) {
	    HTChunkPuts(me->chunk, str);
	    if (me->chunk->allocated == 0 && *str)
		me->status = HT_ERROR;
	}
    }
    (*me->actions->put_string) (me->target, str);
d7709 4
a7712 2
static void CacheThru_write(HTStream *me, const char *str,
			    int l)
d7714 5
a7718 12
    if (me->status == HT_OK) {
	if (me->fp) {
	    fwrite(str, 1, l, me->fp);
	    if (ferror(me->fp))
		me->status = HT_ERROR;
	} else if (me->chunk) {
	    HTChunkPutb(me->chunk, str, l);
	    if (me->chunk->allocated == 0 && l != 0)
		me->status = HT_ERROR;
	}
    }
    (*me->actions->put_block) (me->target, str, l);
d7721 1
a7721 1
static const HTStreamClass PassThruCache =
d7731 3
a7733 2
static HTStream *CacheThru_new(HTParentAnchor *anchor,
			       HTStream *target)
a7734 1
    char *cp_freeme = NULL;
d7737 1
a7737 1
    HTProtocol *p = (HTProtocol *) anchor->protocol;
d7746 1
a7746 1
    /*  Only remote HTML documents may benefit from HTreparse_document(),  */
d7748 2
a7749 3
    if (strcmp(p->name, "http") != 0
	&& strcmp(p->name, "https") != 0) {
	CTRACE((tfp, "SourceCacheWriter: Protocol is \"%s\"; not caching\n", p->name));
a7760 1
    stream->anchor = anchor;
a7761 1
    stream->filename = NULL;
a7764 1
    stream->status = HT_OK;
d7767 5
a7771 5

	if (anchor->source_cache_file) {
	    CTRACE((tfp,
		    "SourceCacheWriter: If successful, will replace source cache file %s\n",
		    anchor->source_cache_file));
d7780 3
a7782 4
	if (!(stream->fp = LYOpenTemp(filename, HTML_SUFFIX, BIN_W))) {
	    CTRACE((tfp,
		    "SourceCacheWriter: Cannot open source cache file for URL %s\n",
		    cp_freeme = HTAnchor_address((HTAnchor *) anchor)));
a7783 1
	    FREE(cp_freeme);
d7787 4
a7790 1
	StrAllocCopy(stream->filename, filename);
d7792 2
a7793 5
	CTRACE((tfp,
		"SourceCacheWriter: Caching source for URL %s in file %s\n",
		cp_freeme = HTAnchor_address((HTAnchor *) anchor),
		filename));
	FREE(cp_freeme);
d7797 5
a7801 4
	if (anchor->source_cache_chunk) {
	    CTRACE((tfp,
		    "SourceCacheWriter: If successful, will replace memory chunk %p\n",
		    (void *) anchor->source_cache_chunk));
a7802 7
#ifdef SAVE_TIME_NOT_SPACE
	stream->chunk = HTChunkCreateMayFail(4096, 1);
#else
	stream->chunk = HTChunkCreateMayFail(128, 1);
#endif
	if (!stream->chunk)	/* failed already? pretty bad... - kw */
	    stream->status = HT_ERROR;
d7804 5
a7808 5
	CTRACE((tfp,
		"SourceCacheWriter: Caching source for URL %s in memory chunk %p\n",
		cp_freeme = HTAnchor_address((HTAnchor *) anchor),
		(void *) stream->chunk));
	FREE(cp_freeme);
a7812 2
#else
#define CacheThru_new(anchor, target) target
d7816 11
a7826 10
 *	----------------------------------
 *
 *	This will convert from HTML to presentation or plain text.
 *
 *	It is registered in HTInit.c, but never actually used by lynx.
 *	- kw 1999-03-15
 */
HTStream *HTMLToPlain(HTPresentation *pres,
		      HTParentAnchor *anchor,
		      HTStream *sink)
d7828 1
a7828 1
    CTRACE((tfp, "HTMLToPlain calling CacheThru_new\n"));
d7832 3
d7838 14
a7851 13
 *	-----------------------------------------
 *
 *	This will preparse HTML and convert back to presentation or plain text.
 *
 *	It is registered in HTInit.c and used by lynx if invoked with
 *	-preparsed.  The stream generated here will be fed with HTML text,
 *	It feeds that to the SGML.c parser, which in turn feeds an HTMLGen.c
 *	structured stream for regenerating flat text; the latter should
 *	end up being handled as text/plain. - kw
 */
HTStream *HTMLParsedPresent(HTPresentation *pres,
			    HTParentAnchor *anchor,
			    HTStream *sink)
d7853 1
a7853 2
    HTStream *intermediate = sink;

d7856 4
a7859 4
	 * Trick to prevent HTPlainPresent from translating again.  Temporarily
	 * change UCT_STAGE_PARSER setting in anchor while the HTPlain stream
	 * is initialized, so that HTPlain sees its input and output charsets
	 * as the same.  - kw
d7861 2
a7862 3
	int old_parser_cset = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_PARSER);
	int structured_cset = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_STRUCTURED);

d7864 1
a7864 1
	    structured_cset = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_HTEXT);
d7870 4
a7873 4
	    /*  same effect as
	       intermediate = HTPlainPresent(pres, anchor, NULL);
	       just written in a more general way:
	     */
d7877 1
a7877 1
	    /*  this too should amount to calling HTPlainPresent: */
d7887 1
a7887 1
					UCT_SETBY_DEFAULT + 1);
d7893 1
a7893 1
    CTRACE((tfp, "HTMLParsedPresent calling CacheThru_new\n"));
d7897 3
d7903 13
a7915 12
 *	------------------------------
 *
 *	C code is like plain text but all non-preformatted code
 *	is commented out.
 *	This will convert from HTML to presentation or plain text.
 *
 *	It is registered in HTInit.c, but normally not used by lynx.
 *	- kw 1999-03-15
 */
HTStream *HTMLToC(HTPresentation *pres GCC_UNUSED,
		  HTParentAnchor *anchor,
		  HTStream *sink)
d7917 1
a7917 1
    HTStructured *html;
d7919 1
a7919 2
    if (sink)
	(*sink->isa->put_string) (sink, "/* ");		/* Before even title */
d7923 2
a7924 3
    if (!sink)
	HTML_put_string(html, html->comment_start);
    CTRACE((tfp, "HTMLToC calling CacheThru_new\n"));
d7927 3
d7933 7
a7939 7
 *	------------------
 *
 *	This will convert from HTML to presentation or plain text.
 *
 * (Comment from original libwww:)
 *	Override this if you have a windows version
 */
d7941 4
a7944 3
HTStream *HTMLPresent(HTPresentation *pres GCC_UNUSED,
		      HTParentAnchor *anchor,
		      HTStream *sink GCC_UNUSED)
d7946 1
a7946 1
    CTRACE((tfp, "HTMLPresent calling CacheThru_new\n"));
d7950 3
d7958 17
a7974 17
 *	------------------------------------------
 *
 *	The error message should be marked as an error so that
 *	it can be reloaded later.
 *	This implementation just throws up an error message
 *	and leaves the document unloaded.
 *	A smarter implementation would load an error document,
 *	marking at such so that it is retried on reload.
 *
 * On entry,
 *	sink	is a stream to the output device if any
 *	number	is the HTTP error number
 *	message is the human readable message.
 *
 * On exit,
 *	returns a negative number to indicate lack of success in the load.
 */
d7979 4
a7982 2
int HTLoadError(HTStream *sink GCC_UNUSED, int number,
		const char *message)
d7988 1
a7988 1
static char *MakeNewTitle(const char **value, int src_type)
a8002 21
#ifdef SH_EX			/* 1998/04/02 (Thu) 16:02:00 */

    /* for proxy server 1998/12/19 (Sat) 11:53:30 */
    if (AS_casecomp(newtitle + 1, "internal-gopher-menu") == 0) {
	StrAllocCopy(newtitle, "+");
    } else if (AS_casecomp(newtitle + 1, "internal-gopher-unknown") == 0) {
	StrAllocCopy(newtitle, " ");
    } else {
	/* normal title */
	ptr = strrchr(newtitle, '.');
	if (ptr) {
	    if (AS_casecomp(ptr, ".gif") == 0)
		*ptr = '\0';
	    else if (AS_casecomp(ptr, ".jpg") == 0)
		*ptr = '\0';
	    else if (AS_casecomp(ptr, ".jpeg") == 0)
		*ptr = '\0';
	}
	StrAllocCat(newtitle, "]");
    }
#else
a8003 1
#endif
d8007 1
a8007 1
static char *MakeNewImageValue(const char **value)
d8023 1
a8023 1
static char *MakeNewMapValue(const char **value, const char *mapstr)
d8029 3
a8031 3
    StrAllocCat(newtitle, mapstr);	/* ISMAP or USEMAP */
    if (verbose_img && non_empty(value[HTML_IMG_SRC])) {
	StrAllocCat(newtitle, ":");
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d38 1
d52 1
a52 1
#ifdef USE_PRETTYSRC
a80 3
#include <LYCurses.h>
#include <LYJustify.h>

d86 8
a96 1
    HTParentAnchor *		anchor;
a97 1
    char *			filename;
a100 1
    int				status;
d110 1
a110 2
PRIVATE HTStyle *styles[HTML_ELEMENTS+LYNX_HTML_EXTRA_ELEMENTS];
					   /* adding 24 nested list styles  */
d124 1
a124 1
PRIVATE int HTML_end_element PARAMS((HTStructured *me,
d128 1
a128 1
PRIVATE int HTML_start_element PARAMS((
d152 2
d156 2
a157 2
    if (!i) return;
    while (*i) { *i=(char)tolower(*i); i++; }
a206 11
PUBLIC BOOL LYBadHTML ARGS1(
    HTStructured *,	me)
{
    if (!TRACE && !me->inBadHTML) {
	HTUserMsg(BAD_HTML_USE_TRACE);
	me->inBadHTML = TRUE;
	return FALSE;
    }
    return TRUE;
}

d233 1
a233 1
    if (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT)
d360 1
a360 1
	if (me->sp->style->id == ST_Preformatted) {
d370 2
a371 2
	} else if (me->sp->style->id == ST_Listing ||
		   me->sp->style->id == ST_Example) {
d438 1
a438 1
#ifdef USE_PRETTYSRC
d442 1
a442 1
    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
d444 1
a444 1
#ifdef USE_PRETTYSRC
d449 1
a449 1
    }
a502 12
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for(; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
d537 1
a537 1
			    me->in_word = NO;
d572 1
a572 1
#ifdef USE_PRETTYSRC
d588 1
a588 1
    if (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT)
d591 1
a591 1
    for (p = s; p < e; p++)
d639 1
d645 2
a646 2
   overriding non-caching similar to LYoverride_no_cache. - kw */
#define CHECK_FOR_INTERN(flag,s) flag = (s && (*s=='#' || *s=='\0')) ? TRUE : FALSE
d650 3
a652 1
#define INTERN_LT (HTLinkType *)(intern_flag ? HTInternalLink : NULL)
d654 4
d672 1
a672 1
#ifdef USE_PRETTYSRC
d676 1
a676 1
	    HTlexeme,	      lexeme,
d680 1
a680 1
    HT_tagspec* ts = *( ( start ? lexeme_start : lexeme_end ) + lexeme);
d691 1
a691 1
	CTRACE((tfp,ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n",(int)lexeme));
a709 2

#if defined(__STDC__) || defined(_WIN_CC)
a711 4
#else
#  define PSRCSTART(x)	HTMLSRC_apply_markup(me,HTL_/**/x,START,tag_charset)
#  define PSRCSTOP(x)  HTMLSRC_apply_markup(me,HTL_/**/x,STOP,tag_charset)
#endif
d716 1
a716 136
#endif /* USE_PRETTYSRC*/

PRIVATE void LYStartArea ARGS5(
	HTStructured *,		obj,
	CONST char *,		href,
	CONST char *,		alt,
	CONST char *,		title,
	int,			tag_charset)
{
    BOOL		new_present[HTML_AREA_ATTRIBUTES];
    CONST char *	new_value[HTML_AREA_ATTRIBUTES];
    int i;

    for (i = 0; i < HTML_AREA_ATTRIBUTES; i++)
	 new_present[i] = NO;

    if (alt) {
	new_present[HTML_AREA_ALT] = YES;
	new_value[HTML_AREA_ALT] = (CONST char *)alt;
    }
    if (title && *title) {
	new_present[HTML_AREA_TITLE] = YES;
	new_value[HTML_AREA_TITLE] = (CONST char *)title;
    }
    if (href) {
	new_present[HTML_AREA_HREF] = YES;
	new_value[HTML_AREA_HREF] = (CONST char *)href;
    }

    (*obj->isa->start_element)(obj, HTML_AREA, new_present, new_value,
			       tag_charset, 0);
}

PRIVATE void LYHandleFIG ARGS10(
	HTStructured *,		me,
	CONST BOOL*,		present,
	CONST char **,		value,
	BOOL,			isobject,
	BOOL,			imagemap,
	CONST char *,		id,
	CONST char *,		src,
	BOOL,			convert,
	BOOL,			start,
	BOOL *,			intern_flag GCC_UNUSED)
{
    if (start == TRUE) {
	me->inFIG = TRUE;
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, NULL);
	}
	if (!isobject) {
	    LYEnsureDoubleSpace(me);
	    LYResetParagraphAlignment(me);
	    me->inFIGwithP = TRUE;
	} else {
	    me->inFIGwithP = FALSE;
	    HTML_put_character(me, ' ');  /* space char may be ignored */
	}
	if (id && *id) {
	    if (present && convert) {
		CHECK_ID(HTML_FIG_ID);
	    } else
		LYHandleID(me, id);
	}
	me->in_word = NO;
	me->inP = FALSE;

	if (clickable_images && src && *src) {
	    char *href = NULL;
	    StrAllocCopy(href, src);
	    CHECK_FOR_INTERN(*intern_flag,href);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href) {
		me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					INTERN_LT);		/* Type */
		HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		HTML_put_string(me, (isobject ?
		      (imagemap ? "(IMAGE)" : "(OBJECT)") : "[FIGURE]"));
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, 0);
		HTML_put_character(me, '-');
		HTML_put_character(me, ' '); /* space char may be ignored */
		me->in_word = NO;
	    }
	    FREE(href);
	}
    } else {			/* handle end tag */
	if (me->inFIGwithP) {
	    LYEnsureDoubleSpace(me);
	} else {
	    HTML_put_character(me, ' ');  /* space char may be ignored */
	}
	LYResetParagraphAlignment(me);
	me->inFIGwithP = FALSE;
	me->inFIG = FALSE;
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
	if (me->List_Nesting_Level >= 0) {
	    UPDATE_STYLE;
	    HText_NegateLineOne(me->text);
	}
    }
}

PRIVATE void clear_objectdata ARGS1(
	HTStructured *,		me)
{
    if (me) {
	HTChunkClear(&me->object);
	me->object_started = FALSE;
	me->object_declare = FALSE;
	me->object_shapes = FALSE;
	me->object_ismap = FALSE;
	FREE(me->object_usemap);
	FREE(me->object_id);
	FREE(me->object_title);
	FREE(me->object_data);
	FREE(me->object_type);
	FREE(me->object_classid);
	FREE(me->object_codebase);
	FREE(me->object_codetype);
	FREE(me->object_name);
    }
}

#define HTParseALL(pp,pconst)  \
	{ char* free_me = *pp; \
	  *pp = HTParse(*pp, pconst, PARSE_ALL); \
	  FREE(free_me);       \
	}
d721 1
a721 1
PRIVATE int HTML_start_element ARGS6(
d739 1
a739 2
    CONST char *Base = NULL;
    int dest_char_set = -1;
d742 1
d746 1
a746 1
    HTMLElement ElementNumber = element_number;
a747 2
    short stbl_align = HT_ALIGN_NONE;
    int status = HT_OK;
a749 1
    int class_used = 0;
d758 1
a758 1
#ifdef USE_PRETTYSRC
d765 1
a765 1
		psrc_first_tag = FALSE;
d771 3
a773 3
		psrc_nested_call = TRUE;
		HTML_start_element(me, HTML_BODY, NULL, NULL, tag_charset, NULL);
		HTML_start_element(me, HTML_PRE, NULL, NULL, tag_charset, NULL);
d775 1
a775 1
		psrc_nested_call = FALSE;
d778 1
a778 1
	    psrc_nested_call = TRUE;
d785 1
a785 1
		LYstrncpy(buf, tag->name, sizeof(buf)-1);
d797 1
a797 1
			    LYstrncpy(buf, tag->attributes[i].name, sizeof(buf)-1);
d804 1
a804 1
			    char kind= (char) ( !strchr(value[i], '"') ?
d842 1
a842 1
	    return HT_OK;
d846 1
a846 1
#endif /* USE_PRETTYSRC */
d850 2
a851 3
	      ElementNumber == HTML_BASE || ElementNumber == HTML_OBJECT ||
	      ElementNumber == HTML_A)) {
	    return HT_OK;
d862 3
a864 3
	    CTRACE((tfp, "me->tag_charset: %d -> %d", me->tag_charset, j ));
	    CTRACE((tfp, " (me->UCLYhndl: %d, tag_charset: %d)\n",
		   me->UCLYhndl, tag_charset));
d877 1
a894 1
    CTRACE2(TRACE_STYLE, (tfp, "CSS.elt:<%s>\n", HTML_dtd.tags[element_number].name));
d896 1
a896 1
    if (current_tag_style == -1) {	/* Append class_name */
d900 1
a900 1
	hcode = hash_code_lowercase_on_fly(HTML_dtd.tags[element_number].name);
a903 2
	    int ohcode = hcode;
	    char *oend = Style_className_end;
a904 2
	    int len = strlen(myHash);
	    sprintf(myHash, ".%.*s", (int)sizeof(myHash) - len - 2, class_name);
d906 2
d909 1
d911 1
a911 1
	    int l = strlen(class_name);
a919 12
	    if (!hashStyles[hcode].name) { /* None such -> classless version */
		hcode = ohcode;
		*oend = '\0';
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.start_element: <%s> (class <%s> not configured), hcode=%d.\n",
			HTML_dtd.tags[element_number].name, class_name, hcode));
	    } else {
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.start_element: <%s>.<%s>, hcode=%d.\n",
			HTML_dtd.tags[element_number].name, class_name, hcode));
		class_used = 1;
	    }
a920 1

d930 7
a936 5
	CTRACE((tfp, "CSSTRIM:%s -> %d", myHash, hcode));
	if (hashStyles[hcode].code != hcode) {
	    char *rp = strrchr(myHash, '.');
	    CTRACE((tfp, " (undefined) %s\n", myHash));
	    if (rp) {
d938 1
a938 1
		*rp = '\0'; /* trim the class */
d940 1
a940 1
		CTRACE((tfp, "CSS:%s -> %d", myHash, hcd));
d942 1
a942 1
		    CTRACE((tfp, " (undefined) %s\n", myHash));
d944 1
a944 1
		    CTRACE((tfp, " ca=%d\n", hashStyles[hcd].color));
a945 2
	} else {
	    CTRACE((tfp, " ca=%d\n", hashStyles[hcode].color));
d947 2
d951 7
a960 2
	    int len = strlen(myHash);
	    sprintf(myHash, ".%.*s", (int)sizeof(myHash) - len - 2, class_name);
d962 2
d967 3
a969 3
	    *Style_className_end = '.';
	    memcpy(Style_className_end+1,class_name, l + 1 );
	    Style_className_end += l + 1;
d975 1
a975 3
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE.start_element: <%s>, hcode=%d.\n",
		HTML_dtd.tags[element_number].name, hcode));
a987 29
#if OPT_SCN && !OMIT_SCN_KEEPING	/* Can be done in other cases too... */
    if (!class_used && ElementNumber == HTML_INPUT) { /* For some other too? */
	CONST char *type = "";
	char *oend = Style_className_end;
	int l, ohcode = hcode;

	if (present && present[HTML_INPUT_TYPE] && value[HTML_INPUT_TYPE])
	    type = value[HTML_INPUT_TYPE];
	l = strlen(type);

	*Style_className_end = '.';
	memcpy(Style_className_end+1, "type.", 5 );
	memcpy(Style_className_end+6, type, l+1 );
	Style_className_end += l+6;
	hcode = hash_code_aggregate_lower_str(".type.", hcode);
	hcode = hash_code_aggregate_lower_str(type, hcode);
	if (!hashStyles[hcode].name) { /* None such -> classless version */
	    hcode = ohcode;
	    *oend = '\0';
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.start_element: type <%s> not configured.\n",
			   type));
	} else {
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.start_element: <%s>.type.<%s>, hcode=%d.\n",
			  HTML_dtd.tags[element_number].name, type, hcode));
	}
    }
#endif	/* OPT_SCN && !OMIT_SCN_KEEPING */
d989 1
a989 1
    HText_characterStyle(me->text, hcode, 1);
d1007 1
a1007 1
	    CONST char *related = NULL;
a1009 2
	    CTRACE((tfp, "*HTML_BASE: initial href=`%s'\n", NonNull(base)));

d1011 2
a1012 2
		CTRACE((tfp, "HTML: BASE '%s' is not an absolute URL.\n",
			    NonNull(base)));
d1027 8
a1034 3
		temp = base;
		base = HTParse(base + 11, "", PARSE_ALL_WITHOUT_ANCHOR);
		FREE(temp);
d1040 1
a1040 1
	    related = me->node_anchor->address;
d1045 9
a1053 2
	    temp = HTParse(base, related, PARSE_ACCESS+PARSE_PUNCTUATION);
	    StrAllocCopy(me->base_href, temp);
d1059 3
a1061 2
	    temp = HTParse(base, "", PARSE_HOST+PARSE_PUNCTUATION);
	    if (!strncmp(temp, "//", 2)) {
d1067 1
a1067 1
		if (isFILE_URL(me->base_href)) {
d1069 1
a1069 1
		} else if (strcmp(me->base_href, STR_NEWS_URL)) {
d1076 1
d1081 3
a1083 9
	    temp = HTParse(base, "", PARSE_PATH+PARSE_PUNCTUATION);
	    if (*temp != '\0') {
		char *p = strchr(temp, '?');
		if (p)
		    *p = '\0';
		p = strrchr(temp, '/');
		if (p)
		    *(p+1) = '\0';  /* strip after the last slash */

d1085 1
a1085 1
	    } else if (!strcmp(me->base_href, STR_NEWS_URL)) {
d1087 3
a1089 3
	    } else if (isNEWS_URL(me->base_href) ||
		       isNNTP_URL(me->base_href) ||
		       isSNEWS_URL(me->base_href)) {
a1097 1
	    me->node_anchor->inBASE = TRUE;
a1098 3
	    /* me->base_href is a valid URL */

	    CTRACE((tfp, "*HTML_BASE: final href=`%s'\n", me->base_href));
d1112 1
d1114 1
d1116 1
a1116 1
	    CHECK_FOR_INTERN(intern_flag,value[HTML_LINK_HREF]);
d1121 5
a1125 4
		Base = (me->inBASE)
			? me->base_href
			: me->node_anchor->address;
		StrAllocCopy(href, Base);
d1129 13
d1143 7
a1149 5
		Base = (me->inBASE && *href != '\0' && *href != '#')
			? me->base_href
			: me->node_anchor->address;
		HTParseALL(&href, Base);
	    }
d1164 12
d1177 1
a1177 1
		    CTRACE((tfp, "HTML: DOC OWNER '%s' found\n", href));
a1206 4
		 *
		 * lss and css have different syntax - lynx shouldn't try to
		 * parse them now (it tries to parse them as lss, so it exits
		 * with error message on the 1st non-empty line) - VH
d1208 4
d1215 32
a1246 2
		    CTRACE2(TRACE_STYLE, (tfp, "HTML: StyleSheet link found.\n"));
		    CTRACE2(TRACE_STYLE, (tfp, "        StyleSheets not yet implemented.\n"));
d1253 1
a1253 1
		 *  Ignore anything not registered in the 28-Mar-95
a1317 8
#ifndef DISABLE_BIBP
		} else if (!strcasecomp(value[HTML_LINK_REL], "citehost")) {
		    /*  Citehost determination for bibp links. - RDC */
		    HTAnchor_setCitehost(me->node_anchor, href);
		    CTRACE((tfp, "HTML: citehost '%s' found\n", href));
		    FREE(href);
		    break;
#endif
d1319 2
a1320 2
		    CTRACE((tfp, "HTML: LINK with REL=\"%s\" ignored.\n",
				 value[HTML_LINK_REL]));
d1338 2
a1339 2
		CTRACE((tfp, "HTML: LINK with REL=\"%s\" and no HREF ignored.\n",
			    value[HTML_LINK_REL]));
d1390 1
a1390 1
			    HTAnchor_followLink(me->CurrentA)
d1394 1
a1394 5

		/* Don't allow CHARSET attribute to change *this* document's
		   charset assumption. - kw */
		if (dest == me->node_anchor)
		    dest = NULL;
d1400 2
d1403 1
a1403 1
		if (dest && dest_char_set >= 0)
a1419 6
	    } else {
		/*
		 *  Add collapsible space to separate link from previous
		 *  generated links. - kw
		 */
		HTML_put_character(me, ' ');
d1430 1
a1430 2
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.link: using style <%s>\n", tmp));
d1455 3
d1465 1
a1465 1
		StrAllocCopy(href, value[HTML_ISINDEX_HREF]);
d1467 12
a1478 2
		StrAllocCopy(href, value[HTML_ISINDEX_ACTION]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
d1480 6
a1485 6
	    Base = (me->inBASE && *href != '\0' && *href != '#')
		    ? me->base_href
		    : me->node_anchor->address;
	    HTParseALL(&href, Base);
	    HTAnchor_setIndex(me->node_anchor, href);
	    FREE(href);
d1488 10
a1497 3
	    Base = (me->inBASE) ?
			me->base_href : me->node_anchor->address;
	    HTAnchor_setIndex(me->node_anchor, Base);
d1522 2
d1560 1
a1560 1
	    value[HTML_FRAME_SRC] && *value[HTML_FRAME_SRC]) {
d1562 22
a1583 1
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
d1593 1
a1593 2
				(HTLinkType*)0);	/* Type */
	    CAN_JUSTIFY_PUSH(FALSE);
a1600 1

a1611 1
	    CAN_JUSTIFY_POP;
d1632 1
a1632 1
	    value[HTML_IFRAME_SRC] && *value[HTML_IFRAME_SRC]) {
d1634 22
a1655 1
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
a1658 1

d1663 1
a1663 1
				(HTLinkType*)0);	/* Type */
a1664 1
	    CAN_JUSTIFY_PUSH_F
a1671 1

a1682 1
	    CAN_JUSTIFY_POP;
d1693 1
a1693 1
	if (me->sp->tag_number == (int) ElementNumber)
d1719 1
a1719 1
	    CTRACE((tfp,
d1721 1
a1721 1
		MAX_NESTING));
a1722 2
	if (me->inP)
	    LYEnsureSingleSpace(me); /* always at least break line - kw */
a1727 20
	} else if (me->List_Nesting_Level >= 0 &&
		   !(present && present[HTML_DIV_ALIGN] &&
		     value[HTML_DIV_ALIGN] &&
		     (!strcasecomp(value[HTML_DIV_ALIGN], "center") ||
		      !strcasecomp(value[HTML_DIV_ALIGN], "right")))) {
	    if (present && present[HTML_DIV_ALIGN])
		me->current_default_alignment = HT_LEFT;
	    else if (me->Division_Level == 0)
		me->current_default_alignment = HT_LEFT;
	    else if (me->sp[0].tag_number == HTML_UL ||
		     me->sp[0].tag_number == HTML_OL ||
		     me->sp[0].tag_number == HTML_MENU ||
		     me->sp[0].tag_number == HTML_DIR ||
		     me->sp[0].tag_number == HTML_LI ||
		     me->sp[0].tag_number == HTML_LH ||
		     me->sp[0].tag_number == HTML_DD)
		me->current_default_alignment = HT_LEFT;
	    LYHandlePlike(me, present, value, include, HTML_DIV_ALIGN, TRUE);
	    me->DivisionAlignments[me->Division_Level] = (short)
		me->current_default_alignment;
d1782 1
a1782 2
	     me->sp[0].tag_number == HTML_DIR ||
	     me->sp[0].tag_number == HTML_LI)) {
d1847 1
a1847 2
	LYHandlePlike(me, present, value, include, HTML_P_ALIGN, TRUE);
	CHECK_ID(HTML_P_ID);
d1860 2
a1861 2
	     !HText_PreviousLineEmpty(me->text, FALSE)) ||
	    !HText_LastLineEmpty(me->text, FALSE)) {
d1893 1
a1893 1
	    if (!HText_LastLineEmpty(me->text, FALSE)) {
d1896 1
a1896 1
	    } else if (HText_PreviousLineEmpty(me->text, FALSE)) {
d1928 1
a1928 1
		isdigit(UCH(*value[HTML_HR_WIDTH])) &&
d1962 2
a1963 2
	    } else if (me->sp->style->id == ST_HeadingCenter ||
		       me->sp->style->id == ST_Heading1) {
d1965 1
a1965 1
	    } else if (me->sp->style->id == ST_HeadingRight) {
d1988 1
a1988 1
	    CTRACE((tfp, "HTML: TAB tag has no attributes.  Ignored.\n"));
a1990 7
	/*
	 *  If page author is using TAB within a TABLE, it's probably
	 *  formatted specifically to work well for Lynx without simple
	 *  table tracking code.  Cancel tracking, it would only make
	 *  things worse. - kw
	 */
	HText_cancelStbl(me->text);
a1992 1
	CANT_JUSTIFY_THIS_LINE;
d2001 1
a2001 1
	    CTRACE((tfp, "HTML: ALIGN not 'left'.  Using space instead of TAB.\n"));
d2012 1
a2012 1
	    CTRACE((tfp, "HTML: Not HT_LEFT.  Using space instead of TAB.\n"));
d2018 1
a2018 1
		    isdigit(UCH(*value[HTML_TAB_INDENT])))) {
d2034 1
a2034 1
		       isdigit(UCH(*value[HTML_TAB_INDENT]))) {
a2047 1

d2051 1
a2051 1
		CTRACE((tfp, "HTML: Column out of bounds.  Using space instead of TAB.\n"));
d2120 1
a2120 1
	    CTRACE((tfp, "Underline Level is %d\n", me->Underline_Level));
d2126 1
a2126 1
	    CTRACE((tfp,"Beginning underline\n"));
d2128 1
a2128 1
	    CTRACE((tfp,"Underline Level is %d\n", me->Underline_Level));
d2142 2
a2148 10
    case HTML_SUP:
	HText_appendCharacter(me->text, '^');
	CHECK_ID(HTML_GEN_ID);
	break;

    case HTML_SUB:
	HText_appendCharacter(me->text, '[');
	CHECK_ID(HTML_GEN_ID);
	break;

a2197 1
	/* FALLTHRU */
a2198 1
	/* FALLTHRU */
a2199 1
	/* FALLTHRU */
d2212 1
a2212 1
	if (me->sp->tag_number == (int) ElementNumber)
d2220 1
a2220 1
	if (me->sp->tag_number == (int) ElementNumber)
a2251 1
	    CAN_JUSTIFY_START;
a2253 1
	CAN_JUSTIFY_START;
d2262 1
a2262 1
	if (me->sp->tag_number == (int) ElementNumber)
a2283 1

d2332 1
a2332 1
	    if (!HText_LastLineEmpty(me->text, FALSE)) {
d2528 38
a2565 42
	{
	    int surrounding_tag_number = me->sp[0].tag_number;
	    /*
	     *  No, a LI should never occur directly within another LI,
	     *  but this may result from incomplete error recovery.
	     *  So check one more surrounding level in this case. - kw
	     */
	    if (surrounding_tag_number == HTML_LI &&
		me->sp < (me->stack + MAX_NESTING - 1))
		surrounding_tag_number = me->sp[1].tag_number;
	    if (surrounding_tag_number == HTML_OL) {
		char number_string[20];
		int counter, seqnum;
		char seqtype;

		counter = me->List_Nesting_Level < 11 ?
		    me->List_Nesting_Level : 11;
		if (present && present[HTML_LI_TYPE] && value[HTML_LI_TYPE]) {
		    if (*value[HTML_LI_TYPE] == '1') {
			me->OL_Type[counter] = '1';
		    } else if (*value[HTML_LI_TYPE] == 'A') {
			me->OL_Type[counter] = 'A';
		    } else if (*value[HTML_LI_TYPE] == 'a') {
			me->OL_Type[counter] = 'a';
		    } else if (*value[HTML_LI_TYPE] == 'I') {
			me->OL_Type[counter] = 'I';
		    } else if (*value[HTML_LI_TYPE] == 'i') {
			me->OL_Type[counter] = 'i';
		    }
		}
		if (present && present[HTML_LI_VALUE] &&
		    ((value[HTML_LI_VALUE] != NULL) &&
		     (*value[HTML_LI_VALUE] != '\0')) &&
		    ((isdigit(UCH(*value[HTML_LI_VALUE]))) ||
		     (*value[HTML_LI_VALUE] == '-' &&
		      isdigit(UCH(*(value[HTML_LI_VALUE] + 1)))))) {
		    seqnum = atoi(value[HTML_LI_VALUE]);
		    if (seqnum <= OL_VOID)
			seqnum = OL_VOID + 1;
		    seqtype = me->OL_Type[counter];
		    if (seqtype != '1' && seqnum < 1)
			seqnum = 1;
d2567 9
a2575 16
		} else if (me->OL_Counter[counter] >= OL_VOID) {
		    seqnum = me->OL_Counter[counter]++;
		    seqtype = me->OL_Type[counter];
		    if (seqtype != '1' && seqnum < 1) {
			seqnum = 1;
			me->OL_Counter[counter] = seqnum + 1;
		    }
		} else {
		    seqnum = me->Last_OL_Count + 1;
		    seqtype = me->Last_OL_Type;
		    for (i = (counter - 1); i >= 0; i--) {
			if (me->OL_Counter[i] > OL_VOID) {
			    seqnum = me->OL_Counter[i]++;
			    seqtype = me->OL_Type[i];
			    i = 0;
			}
d2578 22
a2599 21
		if (seqtype == 'A') {
		    sprintf(number_string, LYUppercaseA_OL_String(seqnum));
		} else if (seqtype == 'a') {
		    sprintf(number_string, LYLowercaseA_OL_String(seqnum));
		} else if (seqtype == 'I') {
		    sprintf(number_string, LYUppercaseI_OL_String(seqnum));
		} else if (seqtype == 'i') {
		    sprintf(number_string, LYLowercaseI_OL_String(seqnum));
		} else {
		    sprintf(number_string, "%2d.", seqnum);
		}
		me->Last_OL_Count = seqnum;
		me->Last_OL_Type = seqtype;
		/*
		 *	Hack, because there is no append string!
		 */
		for (i = 0; number_string[i] != '\0'; i++)
		    if (number_string[i] == ' ')
			HTML_put_character(me, HT_NON_BREAK_SPACE);
		    else
			HTML_put_character(me, number_string[i]);
d2601 18
a2618 18
		/*
		 *	Use HTML_put_character so that any other spaces
		 *	coming through will be collapsed.  We'll use
		 *	nbsp, so it won't break at the spacing character
		 *	if there are no spaces in the subsequent text up
		 *	to the right margin, but will declare it as a
		 *	normal space to ensure collapsing if a normal
		 *	space does immediately follow it. - FM
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
	    } else if (surrounding_tag_number == HTML_UL) {
		/*
		 *	Hack, because there is no append string!
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		switch(me->List_Nesting_Level % 7) {
a2640 19
		}
		/*
		 *	Keep using HTML_put_character so that any other
		 *	spaces coming through will be collapsed.  We use
		 *	nbsp, so we won't wrap at the spacing character
		 *	if there are no spaces in the subsequent text up
		 *	to the right margin, but will declare it as a
		 *	normal space to ensure collapsing if a normal
		 *	space does immediately follow it. - FM
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
	    } else {
		/*
		 *	Hack, because there is no append string!
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
d2642 18
a2660 1
	CAN_JUSTIFY_START;
d2690 1
a2690 1
	if (me->sp->tag_number == (int) ElementNumber)
a2698 1
	CAN_JUSTIFY_START
a2704 19
	    /*
	     *  If we are looking for client-side image maps,
	     *  then handle an A within a MAP that has a COORDS
	     *  attribute as an AREA tag.  Unfortunately we lose
	     *  the anchor text this way for the LYNXIMGMAP, we
	     *  would have to do much more parsing to collect it.
	     *  After potentially handling the A as AREA, always return
	     *  immediately if only looking for image maps, without
	     *  pushing anything on the style stack. - kw
	     */
	if (me->map_address && present && present[HTML_A_COORDS])
	    LYStartArea(me,
			present[HTML_A_HREF] ? value[HTML_A_HREF] : NULL,
			NULL,
			present[HTML_A_TITLE] ? value[HTML_A_TITLE] : NULL,
			tag_charset);
	if (LYMapsOnly) {
	    return HT_OK;
	}
d2732 1
a2732 1
	if (id_string)
d2734 4
d2743 6
d2750 1
a2750 1
	     * Set to know we are making the content bold.
d2752 11
a2762 1
	    me->inBoldA = TRUE;
d2764 9
a2772 2
	    StrAllocCopy(href, value[HTML_A_HREF]);
	    CHECK_FOR_INTERN(intern_flag,href);  /*NULL, '\0', or '#'*/
d2774 4
a2777 7
	    if (intern_flag) { /*** FAST WAY: ***/
		if (isEmpty(href))
		    StrAllocCopy(href, "#");
		TRANSLATE_AND_UNESCAPE_TO_STD(&href);

	    } else {
		url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
d2779 6
d2786 1
a2786 1
		 * Deal with our ftp gateway kludge.  - FM
d2788 2
a2789 7
		if (!url_type && !strncmp(href, "/foo/..", 7) &&
		      (isFTP_URL(me->node_anchor->address) ||
		       isFILE_URL(me->node_anchor->address))) {
		    for (i = 0; (href[i] = href[i+7]) != 0; i++)
			;
		}
	    }
d2791 7
a2797 2
	    if (present[HTML_A_ISMAP]) /*???*/
		intern_flag = FALSE;
d2803 1
a2803 1

d2806 4
a2809 5
	    if (!intern_flag &&
		!strcasecomp(value[HTML_A_TYPE], HTAtom_name(HTInternalLink)) &&
		!LYIsUIPage3(me->node_anchor->address, UIP_LIST_PAGE, 0) &&
		!LYIsUIPage3(me->node_anchor->address, UIP_ADDRLIST_PAGE, 0) &&
		!isLYNXIMGMAP(me->node_anchor->address)) {
d2814 2
a2815 2
		CTRACE((tfp, "HTML: Found invalid HREF=\"%s\" TYPE=\"%s\"!\n",
			    href, temp));
d2819 1
d2855 2
d2861 1
a2861 1
			HTAnchor_followLink(me->CurrentA)
d2868 1
a2868 3
	    /* Don't allow CHARSET attribute to change *this* document's
	       charset assumption. - kw */
	    if (dest && dest != me->node_anchor && dest_char_set >= 0) {
d2891 1
a2891 1
#if defined(NOTUSED_FOTEMODS)
d2899 1
a2899 1
	    HTML_end_element(me, HTML_A, include);
d2901 1
a2901 8
#else
	/*Close an HREF-less NAMED-ed now if force_empty_hrefless_a was
	    requested - VH*/
	if (href == NULL && force_empty_hrefless_a) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
#endif
d2914 1
a2914 1
			HTAnchor_followLink(me->CurrentA)
d2918 2
a2919 2
		    CTRACE((tfp, "HTML: '%s' is an ISMAP script\n",
				dest->address));
d2923 2
a2924 2
		    CTRACE((tfp, "HTML: Designating '%s' as an ISMAP script\n",
				dest->address));
d2929 1
d2931 1
d2938 1
a2938 1
	    CHECK_FOR_INTERN(intern_flag,map_href);
d2944 1
a2944 1
	    if (findPoundSelector(map_href) == NULL) {
d2957 1
d2964 37
a3000 4
	    Base = (me->inBASE &&
			!(*map_href == '#' && LYSeekFragMAPinCur == TRUE)) ?
				me->base_href : me->node_anchor->address;
	    HTParseALL(&map_href, Base);
d3005 1
a3005 1
	    StrAllocCopy(temp, STR_LYNXIMGMAP);
d3112 1
a3112 1
	CTRACE((tfp, "HTML IMG: USEMAP=%d ISMAP=%d ANCHOR=%d PARA=%d\n",
d3115 1
a3115 1
		    me->inA, me->inP));
d3134 1
a3134 1
	    value[HTML_IMG_SRC] && *value[HTML_IMG_SRC]) {
d3136 21
a3156 1
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
d3203 1
a3203 1
				HTAnchor_followLink(me->CurrentA)
d3265 1
a3265 1
				HTAnchor_followLink(me->CurrentA)
d3369 1
a3369 1
				HTAnchor_followLink(me->CurrentA)
a3440 10
	 *  Generate a target anchor in this place in the containing
	 *  document.  MAP can now contain block markup, if it doesn't
	 *  contain any AREAs (or A anchors with COORDS converted to AREAs)
	 *  the current location can be used as a fallback for following
	 *  a USEMAP link. - kw
	 */
	 if (!LYMapsOnly)
	     LYHandleID(me, id_string);

	/*
d3453 1
a3453 1
	    if ((cp = strchr(me->map_address, '#')) != NULL)
d3481 1
a3481 1
	    CHECK_FOR_INTERN(intern_flag,href);
d3491 29
a3519 4
	    Base = ((me->inBASE && *href != '\0') &&
			!(*href == '#' && LYSeekFragAREAinCur == TRUE)) ?
				me->base_href : me->node_anchor->address;
	    HTParseALL(&href, Base);
d3585 64
a3648 13
	if (present)
	    LYHandleFIG(me, present, value,
			present[HTML_FIG_ISOBJECT],
			present[HTML_FIG_IMAGEMAP],
			present[HTML_FIG_ID] ? value[HTML_FIG_ID] : NULL,
			present[HTML_FIG_SRC] ? value[HTML_FIG_SRC] : NULL,
			YES, TRUE, &intern_flag);
	else
	    LYHandleFIG(me, NULL, NULL,
			0,
			0,
			NULL,
			NULL, YES, TRUE, &intern_flag);
d3755 3
a3757 75
	     *  If we can determine now that we are not going to do anything
	     *  special to the OBJECT element's SGML contents, like skipping
	     *  it completely or collecting it up in order to add something
	     *  after it, then generate any output that should be emitted in the
	     *  place of the OBJECT start tag NOW, then don't initialize special
	     *  handling but return, letting our SGML parser know that further
	     *  content is to be parsed normally not literally.  We could defer
	     *  this until we have collected the contents and then recycle the
	     *  contents (as was previously always done), but that has a higher
	     *  chance of completely losing content in case of nesting errors
	     *  in the input, incomplete transmissions, etc. - kw
	     */
	    if ((!present ||
		 (me->object_declare == FALSE && me->object_name == NULL &&
		  me->object_shapes == FALSE && me->object_usemap == NULL))) {
		if (!LYMapsOnly) {
		    if (!clickable_images || me->object_data == NULL ||
			!(me->object_data != NULL &&
			  me->object_classid == NULL &&
			  me->object_codebase == NULL &&
			  me->object_codetype == NULL))
			FREE(me->object_data);
		    if (me->object_data) {
			HTStartAnchor5(me,
				       me->object_id ? value[HTML_OBJECT_ID]
					: NULL,
				       value[HTML_OBJECT_DATA],
				       value[HTML_OBJECT_TYPE],
				       tag_charset);
			if ((me->object_type != NULL) &&
			    !strncasecomp(me->object_type, "image/", 6))
			    HTML_put_string(me, "(IMAGE)");
			else
			    HTML_put_string(me, "(OBJECT)");
			HTML_end_element(me,HTML_A,NULL);
		    } else if (me->object_id)
			LYHandleID(me, me->object_id);
		}
		clear_objectdata(me);
		/*
		 *  We do NOT want the HTML_put_* functions that are going
		 *  to be called for the OBJECT's character content to
		 *  add to the chunk, so we don't push on the stack.
		 *  Instead we keep a counter for open OBJECT tags that
		 *  are treated this way, so HTML_end_element can skip
		 *  handling the corresponding end tag that is going to
		 *  arrive unexpectedly as far as our stack is concerned.
		 */
		status = HT_PARSER_OTHER_CONTENT;
		if (me->sp[0].tag_number == HTML_FIG &&
		    me->objects_figged_open > 0) {
		    ElementNumber = HTML_OBJECT_M;
		} else {
		    me->objects_mixed_open++;
		    SET_SKIP_STACK(HTML_OBJECT);
		}
	    } else if (me->object_declare == FALSE && me->object_name == NULL &&
		       me->object_shapes == TRUE) {
		LYHandleFIG(me, present, value,
		    1,
		    1 || me->object_ismap,
		    me->object_id,
		    (me->object_data && !me->object_classid) ? value[HTML_OBJECT_DATA] : NULL,
		    NO, TRUE, &intern_flag);
		clear_objectdata(me);
		status = HT_PARSER_OTHER_CONTENT;
		me->objects_figged_open++;
		ElementNumber = HTML_FIG;

	    } else {
		/*
		 *	Set flag that we are accumulating OBJECT content. - FM
		 */
		me->object_started = TRUE;
	    }
d3764 1
a3764 1
	    value[HTML_OVERLAY_SRC] && *value[HTML_OVERLAY_SRC]) {
d3766 2
a3767 1
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
d3769 19
d3797 1
a3797 1
					(HTLinkType*)0);	/* Type */
d3870 1
a3870 1
	    value[HTML_APPLET_CODE] && *value[HTML_APPLET_CODE]) {
d3872 1
a3873 3
	    Base = (me->inBASE)
		    ? me->base_href
		    : me->node_anchor->address;
d3888 8
a3895 1
		LYLegitimizeHREF(me, &base, TRUE, FALSE);
d3897 19
a3915 1
		HTParseALL(&base, Base);
d3918 3
a3920 3
	    StrAllocCopy(href, value[HTML_APPLET_CODE]);
	    LYLegitimizeHREF(me, &href, TRUE, FALSE);
	    HTParseALL(&href, (base ? base : Base));
d3922 1
d3924 1
a3924 1
	    if (*href) {
d3969 1
a3969 1
	    value[HTML_BGSOUND_SRC] && *value[HTML_BGSOUND_SRC]) {
d3971 2
a3972 1
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
d3978 20
d4011 1
a4011 1
					(HTLinkType*)0);	/* Type */
d4083 1
a4083 1
	    value[HTML_EMBED_SRC] && *value[HTML_EMBED_SRC]) {
d4085 23
a4107 2
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href) {
d4118 1
a4118 1
					(HTLinkType*)0);	/* Type */
a4159 1
	CAN_JUSTIFY_START;
a4190 1
	CAN_JUSTIFY_START;
d4230 1
a4230 1
		CTRACE((tfp, "HTML: Missing FORM end tag.  Faking it!\n"));
a4238 1
	    EMIT_IFDEF_EXP_JUSTIFY_ELTS(form_in_htext = TRUE);
a4243 5

	    Base = (me->inBASE)
		    ? me->base_href
		    : me->node_anchor->address;

d4245 4
a4248 2
		value[HTML_FORM_ACTION]) {

d4250 1
a4250 1
		LYLegitimizeHREF(me, &action, TRUE, TRUE);
d4257 26
a4282 4
		HTParseALL(&action, Base);

	    } else {
		StrAllocCopy(action, Base);
d4284 2
a4285 2

	    source = HTAnchor_findChildAndLink(me->node_anchor,
d4289 12
a4300 11
	    if ((link_dest = HTAnchor_followLink(source)) != NULL) {
		/*
		 *  Memory leak fixed.
		 *  05-28-94 Lynx 2-3-1 Garrett Arch Blythe
		 */
		char* cp_freeme = HTAnchor_address(link_dest);
		if (cp_freeme != NULL) {
		    StrAllocCopy(action, cp_freeme);
		    FREE(cp_freeme);
		} else {
		    StrAllocCopy(action, "");
d4404 7
a4410 3
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: BUTTON tag not within FORM tag\n"));
d4535 2
a4536 2
				       (char)(I.value[i] ==  ' ' ?
					      HT_NON_BREAK_SPACE : I.value[i]));
d4538 1
a4538 1
		while (i++ < chars) {
d4561 1
a4561 2
	    HTkcode kcode = 0;
	    HTkcode specified_kcode = 0;
a4596 3
		char *not_impl = NULL;
		char *usingval = NULL;

d4607 1
a4607 1
		    not_impl = "[RANGE Input]";
d4612 1
a4612 1
		    CTRACE((tfp, "HTML: Ignoring TYPE=\"range\"\n"));
d4618 12
a4629 3
#ifndef EXP_FILE_UPLOAD
		    not_impl = "[FILE Input]";
		    CTRACE((tfp, "Attempting to fake as: %s\n", I.type));
d4634 2
a4635 2
		    CTRACE((tfp, "HTML: Ignoring TYPE=\"file\"\n"));
#endif /* EXP_FILE_UPLOAD */
a4643 17
		if (not_impl != NULL) {
		    if (me->inUnderline == FALSE) {
			HText_appendCharacter(me->text,
					      LY_UNDERLINE_START_CHAR);
		    }
		    HTML_put_string(me, not_impl);
		    if (usingval != NULL) {
			HTML_put_string(me, usingval);
			FREE(usingval);
		    } else {
			HTML_put_string(me, " (not implemented)");
		    }
		    if (me->inUnderline == FALSE) {
			HText_appendCharacter(me->text,
					      LY_UNDERLINE_END_CHAR);
		    }
		}
d4650 7
a4656 3
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: INPUT tag not within FORM tag\n"));
a4664 2
	    CTRACE((tfp, "Ok, we're trying type=[%s]\n", NONNULL(I.type)));

d4669 7
a4675 2
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag.\n"));
d4682 1
a4682 1
		CTRACE((tfp, "HTML: Missing SELECT end tag, faking it...\n"));
d4732 1
a4732 1
		LYLegitimizeHREF(me, &href, TRUE, TRUE);
d4734 20
a4776 2
	    CTRACE((tfp, "2.Ok, we're trying type=[%s] (present=%p)\n", NONNULL(I.type), present));
	    /* text+file don't go in here */
d4779 1
a4779 5
		 value[HTML_INPUT_VALUE] &&
		(*value[HTML_INPUT_VALUE] ||
		 (I.type && (!strcasecomp(I.type, "checkbox") ||
			     !strcasecomp(I.type, "radio")))))) {

a4795 1
		CTRACE((tfp, "3.Ok, we're trying type=[%s]\n", NONNULL(I.type)));
a4798 3
#ifdef EXP_FILE_UPLOAD
			 !strcasecomp(I.type, "file") ||
#endif
d4801 1
a4801 2
			 !strcasecomp(I.type, "reset")) {
		    CTRACE((tfp, "normal field type: %s\n", NONNULL(I.type)));
a4802 2
		}

a4809 1
		CTRACE((tfp, "4.Ok, we're trying type=[%s]\n", NONNULL(I.type)));
d4814 2
a4815 3
		    (BOOL)(me->UsePlainSpace && !me->HiddenValue),
		    me->UsePlainSpace,
		    me->HiddenValue);
a4897 3
#ifndef EXP_FILE_UPLOAD
	    CTRACE((tfp, "I.%s have %d chars, or something\n", NONNULL(I.type), chars));
#endif
a4921 1
		HText_endInput(me->text);
a4936 1
		HText_endInput(me->text);
d4961 1
a4961 1
		 *  treated as part of the editing window, nor be
a4969 3
#ifndef EXP_FILE_UPLOAD
	    CTRACE((tfp, "I.%s, %d\n", NONNULL(I.type), IsSubmitOrReset));
#endif
d4976 2
a4977 5
		if (chars > 0) {
		    for (; chars > 0; chars--)
			HTML_put_character(me, '_');
		    HText_endInput(me->text);
		}
a4978 6
		if (HTCJK == JAPANESE) {
		    kcode = HText_getKcode(me->text);
		    HText_updateKcode(me->text, kanji_code);
		    specified_kcode = HText_getSpecifiedKcode(me->text);
		    HText_updateSpecifiedKcode(me->text, kanji_code);
		}
d5013 3
a5015 4
					   (char)(I.value[i] ==  ' '
						   ? HT_NON_BREAK_SPACE
						   : I.value[i]));
		    while (i++ < chars)
a5017 7
		if (HTCJK == JAPANESE) {
		    HText_updateKcode(me->text, kcode);
		    HText_updateSpecifiedKcode(me->text, specified_kcode);
		}
	    }
	    if (chars != 0) {
		HText_endInput(me->text);
d5031 7
a5037 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: TEXTAREA start tag not within FORM tag\n"));
d5077 1
a5077 1
	    isdigit(UCH(*value[HTML_TEXTAREA_COLS])))
d5079 2
a5080 12
	else {
	    int width;
	    width = LYcols - 1 -
		    me->new_style->leftIndent - me->new_style->rightIndent;
	    if (dump_output_immediately) /* don't waste too much for this */
		width = HTMIN(width, 60);
	    if (width > 1 && (width-1)*6 < MAX_LINE - 3 -
		me->new_style->leftIndent - me->new_style->rightIndent)
		HTSprintf0(&me->textarea_cols, "%d", width);
	    else
		StrAllocCopy(me->textarea_cols, "60");
	}
d5084 1
a5084 1
	    isdigit(UCH(*value[HTML_TEXTAREA_ROWS])))
d5121 7
a5127 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: SELECT start tag in SELECT element.  Faking SELECT end tag. *****\n"));
d5154 7
a5160 2
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: OPTION tag not within SELECT tag\n"));
d5187 1
a5187 1
	     *	If it's not a multiple option list and select popups
d5303 1
d5330 1
a5330 1
		fields_are_numbered()) {
d5348 1
a5348 1
	 *  Not fully implemented.  Just treat as a division
a5351 9
	 *
	 *  Also notify simple table tracking code unless
	 *  in a preformatted section, or (currently) non-left
	 *  alignment.
	 *
	 *  If page author is using a TABLE within PRE, it's probably
	 *  formatted specifically to work well for Lynx without simple
	 *  table tracking code.  Cancel tracking, it would only make
	 *  things worse. - kw
a5352 5
#ifdef EXP_NESTED_TABLES
	if (!nested_tables)
#endif
	HText_cancelStbl(me->text);

d5362 1
a5362 1
	if (me->sp->style->id == ST_Preformatted) {
d5370 1
a5370 1
	    CTRACE((tfp,
d5372 1
a5372 1
		    MAX_NESTING));
d5377 4
a5380 16
		if (no_table_center) {
		    me->DivisionAlignments[me->Division_Level] = HT_LEFT;
		    change_paragraph_style(me, styles[HTML_DLEFT]);
		    UPDATE_STYLE;
		    me->current_default_alignment =
				styles[HTML_DLEFT]->alignment;
		} else {
		    me->DivisionAlignments[me->Division_Level] = HT_CENTER;
		    change_paragraph_style(me, styles[HTML_DCENTER]);
		    UPDATE_STYLE;
		    me->current_default_alignment =
					styles[HTML_DCENTER]->alignment;
		}

		stbl_align = HT_CENTER;

a5385 1
		stbl_align = HT_RIGHT;
a5390 3
		if (!strcasecomp(value[HTML_TABLE_ALIGN], "left") ||
		    !strcasecomp(value[HTML_TABLE_ALIGN], "justify"))
		    stbl_align = HT_LEFT;
a5396 1
	    /* stbl_align remains HT_ALIGN_NONE */
a5398 1
	HText_startStblTABLE(me->text, stbl_align);
d5403 1
a5403 1
	 *  Not fully implemented.  Just start a new row,
a5405 1
	 *  Also notify simple table tracking code. - kw
d5416 1
a5416 1
	if (!HText_LastLineEmpty(me->text, FALSE)) {
d5422 1
a5422 1
	if (me->sp->style->id == ST_Preformatted) {
a5424 1
/*	    HText_cancelStbl(me->text);  seems unnecessary here - kw */
d5431 2
a5432 2
		    (me->sp->style->id == ST_Normal ||
		     me->sp->style->id == ST_Preformatted))) {
d5435 1
a5435 1
	    me->sp->style->alignment = (short) me->current_default_alignment;
d5439 4
a5442 8
		!(me->List_Nesting_Level >= 0 && !me->inP)) {
		if (no_table_center)
		    me->sp->style->alignment = HT_LEFT;
		else
		    me->sp->style->alignment = HT_CENTER;
		stbl_align = HT_CENTER;
	    } else if (!strcasecomp(value[HTML_TR_ALIGN], "right") &&
		       !(me->List_Nesting_Level >= 0 && !me->inP)) {
d5444 2
a5445 3
		stbl_align = HT_RIGHT;
	    } else if (!strcasecomp(value[HTML_TR_ALIGN], "left") ||
		       !strcasecomp(value[HTML_TR_ALIGN], "justify")) {
a5446 2
		stbl_align = HT_LEFT;
	    }
a5450 1
	HText_startStblTR(me->text, stbl_align);
a5455 1
	HText_endStblTR(me->text);
d5457 1
a5457 1
	 *  Not fully implemented.  Just check for an ID link. - FM
a5467 13
	if (me->inTABLE) {
	    if (present && present[HTML_TR_ALIGN] && value[HTML_TR_ALIGN]) {
		if (!strcasecomp(value[HTML_TR_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_TR_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_TR_ALIGN], "left") ||
			   !strcasecomp(value[HTML_TR_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblRowGroup(me->text, stbl_align);
	}
d5474 1
a5474 1
	 *  Not fully implemented.  Just check for an ID link. - FM
a5484 19
	if (me->inTABLE) {
	    int span = 1;
	    if (present && present[HTML_COL_SPAN] &&
		value[HTML_COL_SPAN] &&
		isdigit(UCH(*value[HTML_COL_SPAN])))
		span = atoi(value[HTML_COL_SPAN]);
	    if (present && present[HTML_COL_ALIGN] && value[HTML_COL_ALIGN]) {
		if (!strcasecomp(value[HTML_COL_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_COL_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_COL_ALIGN], "left") ||
			   !strcasecomp(value[HTML_COL_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblCOL(me->text, span, stbl_align,
			       (BOOL)(ElementNumber == HTML_COLGROUP));
	}
d5489 17
d5518 1
a5518 2
	 *  Not fully implemented.  Just add a collapsible space and break. - FM
	 *  Also notify simple table tracking code. - kw
a5520 23
	{
	    int colspan = 1, rowspan = 1;
	    if (present && present[HTML_TD_COLSPAN] &&
		value[HTML_TD_COLSPAN] &&
		isdigit(UCH(*value[HTML_TD_COLSPAN])))
		colspan = atoi(value[HTML_TD_COLSPAN]);
	    if (present && present[HTML_TD_ROWSPAN] &&
		value[HTML_TD_ROWSPAN] &&
		isdigit(UCH(*value[HTML_TD_ROWSPAN])))
		rowspan = atoi(value[HTML_TD_ROWSPAN]);
	    if (present && present[HTML_TD_ALIGN] && value[HTML_TD_ALIGN]) {
		if (!strcasecomp(value[HTML_TD_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_TD_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_TD_ALIGN], "left") ||
			   !strcasecomp(value[HTML_TD_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblTD(me->text, colspan, rowspan, stbl_align,
			      (BOOL)(ElementNumber == HTML_TH));
	}
d5538 1
a5538 2
    if (ElementNumber >= HTML_ELEMENTS ||
	HTML_dtd.tags[ElementNumber].contents != SGML_EMPTY) {
d5540 2
a5541 3
	    CTRACE((tfp,
    "HTML:begin_element: internal call (level %d), leaving on stack - `%s'\n",
			me->skip_stack, NONNULL(me->sp->style->name)));
d5543 1
a5543 1
	    return status;
d5547 2
a5548 2
		HTAlert(HTML_STACK_OVERRUN);
		CTRACE((tfp,
d5550 5
a5554 1
			MAX_NESTING));
d5557 1
a5557 1
	    return HT_ERROR;
d5560 3
a5562 4
	CTRACE((tfp, "HTML:begin_element[%d]: adding style to stack - %s (%s)\n",
		     (int) STACKLEVEL(me),
		     NONNULL(me->new_style->name),
		     HTML_dtd.tags[ElementNumber].name));
a5565 5
#ifdef EXP_JUSTIFY_ELTS
	if (wait_for_this_stacked_elt < 0 &&
		HTML_dtd.tags[ElementNumber].can_justify == FALSE)
	    wait_for_this_stacked_elt = me->stack - me->sp + MAX_NESTING;
#endif
a5567 7
#ifdef EXP_JUSTIFY_ELTS
    if (in_DT && ElementNumber == HTML_DD)
	in_DT = FALSE;
    else if (ElementNumber == HTML_DT)
	in_DT = TRUE;
#endif

d5570 2
d5573 1
a5573 1
    if (ReallyEmptyTagNum(element_number))
d5575 4
a5578 2
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE.begin_element:ending \"EMPTY\" element style\n"));
d5580 1
a5594 1
    return status;
d5611 1
a5611 1
PRIVATE int HTML_end_element ARGS3(
a5616 1
    int status = HT_OK;
a5618 3
    BOOL intern_flag = FALSE;
    BOOL skip_stack_requested = FALSE;
    EMIT_IFDEF_EXP_JUSTIFY_ELTS(BOOL reached_awaited_stacked_elt = FALSE);
d5620 1
a5620 1
#ifdef USE_PRETTYSRC
d5633 1
a5633 1
		LYstrncpy(buf, tag->name, sizeof(buf)-1);
d5640 1
a5640 1
	    return HT_OK;
d5646 2
a5647 2
    if ((me->sp >= (me->stack + MAX_NESTING - 1) ||
	 element_number != me->sp[0].tag_number) &&
d5649 2
a5650 2
	CTRACE((tfp,
		"HTML: end of element %s when expecting end of %s\n",
d5652 1
a5652 5
	       (me->sp == me->stack + MAX_NESTING - 1) ? "none" :
	       (me->sp->tag_number < 0) ? "*invalid tag*" :
	       (me->sp->tag_number >= HTML_ELEMENTS) ? "special tag" :
		HTML_dtd.tags[me->sp->tag_number].name));
#ifdef CAREFUL			/* parser assumed to produce good nesting */
d5654 1
a5655 1
    }
d5662 2
a5663 3
	if (!(element_number == HTML_MAP || element_number == HTML_AREA ||
	      element_number == HTML_OBJECT)) {
	    return HT_OK;
a5671 1
	skip_stack_requested = (BOOL) (me->skip_stack > 0);
d5678 1
a5678 2
	     me->sp[0].tag_number == HTML_DIR ||
	     me->sp[0].tag_number == HTML_LI) &&
a5691 4
	if (me->skip_stack == 0 && element_number == HTML_OBJECT &&
	    me->sp[0].tag_number == HTML_OBJECT_M &&
	    (me->sp < (me->stack + MAX_NESTING - 1)))
	    me->sp[0].tag_number = HTML_OBJECT;
d5693 2
a5694 3
	    CTRACE2(TRACE_STYLE,
		    (tfp, "HTML:end_element: Internal call (level %d), leaving on stack - %s\n",
			  me->skip_stack, NONNULL(me->sp->style->name)));
a5695 18
	} else if (element_number == HTML_OBJECT &&
		   me->sp[0].tag_number != HTML_OBJECT &&
		   me->sp[0].tag_number != HTML_OBJECT_M &&
		   me->objects_mixed_open > 0 &&
		   !(me->objects_figged_open > 0 &&
		       me->sp[0].tag_number == HTML_FIG)) {
	    /*
	     *	Ignore non-corresponding OBJECT tags that we
	     *	didn't push because the SGML parser was supposed
	     *  to go on parsing the contents non-literally. - kw
	     */
	    CTRACE2(TRACE_STYLE,
		    (tfp, "HTML:end_element[%d]: %s (level %d), %s - %s\n",
			   (int) STACKLEVEL(me),
			   "Special OBJECT handling", me->objects_mixed_open,
			   "leaving on stack",
			   NONNULL(me->sp->style->name)));
	    me->objects_mixed_open--;
d5709 1
a5709 1
	    return HT_OK; /* let's pretend... */
d5718 1
a5718 1
	    return HT_OK;
d5724 1
a5724 2
	     me->sp[0].tag_number == HTML_DIR ||
	     me->sp[0].tag_number == HTML_LI) &&
d5736 1
a5736 1
	    return HT_OK;
a5737 23
#ifdef EXP_JUSTIFY_ELTS
	    if (wait_for_this_stacked_elt == me->stack - me->sp + MAX_NESTING)
		reached_awaited_stacked_elt = TRUE;
#endif
	    if (element_number == HTML_OBJECT) {
		if (me->sp[0].tag_number == HTML_FIG &&
		    me->objects_figged_open > 0) {
		    /*
		     *  It's an OBJECT for which we substituted a FIG,
		     *  so pop the FIG and pretend that's what we are
		     *  being called for. - kw
		     */
		    CTRACE2(TRACE_STYLE,
			    (tfp, "HTML:end_element[%d]: %s (level %d), %s - %s\n",
				  (int) STACKLEVEL(me),
				  "Special OBJECT->FIG handling",
				  me->objects_figged_open,
				  "treating as end FIG",
				  NONNULL(me->sp->style->name)));
		    me->objects_figged_open--;
		    element_number = HTML_FIG;
		}
	    }
d5739 3
a5741 4
	    CTRACE2(TRACE_STYLE,
		    (tfp, "HTML:end_element[%d]: Popped style off stack - %s\n",
			  (int) STACKLEVEL(me),
			  NONNULL(me->sp->style->name)));
d5743 2
a5744 2
	    CTRACE2(TRACE_STYLE, (tfp,
  "Stack underflow error!  Tried to pop off more styles than exist in stack\n"));
d5747 2
a5748 7
    if (BreakFlag == TRUE) {
#ifdef EXP_JUSTIFY_ELTS
	    if (reached_awaited_stacked_elt)
		wait_for_this_stacked_elt=-1;
#endif
	return HT_OK; /* let's pretend... */
    }
d5754 6
a5759 2
	if (LYBadHTML(me))
	    CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag\n"));
d5773 2
a5774 2
	    if (LYBadHTML(me))
		CTRACE((tfp,
d5780 5
a5784 1
			me->inA ? "A" : ""));
d5790 1
a5790 2
	    (LYIsUIPage3(me->node_anchor->address, UIP_LIST_PAGE, 0) ||
	     LYIsUIPage3(me->node_anchor->address, UIP_ADDRLIST_PAGE, 0))) {
d5820 1
a5820 1
	    if ((LYMultiBookmarks != MBM_OFF) ||
a5822 2
		if (!include)
		    include = &me->xinclude;
d5860 2
a5861 3
	CTRACE2(TRACE_STYLE,
		(tfp, "HTML: STYLE content =\n%s\n",
		      me->style_block.data));
d5871 2
a5872 2
	CTRACE((tfp, "HTML: SCRIPT content =\n%s\n",
			    me->script.data));
d5878 2
a5879 2
	    if (LYBadHTML(me))
		CTRACE((tfp,
d5885 5
a5889 1
			me->inA ? "A" : ""));
d5926 2
a5927 6
	if (me->Division_Level >= 0) {
	    if (me->sp->style->alignment !=
		me->DivisionAlignments[me->Division_Level]) {
		if (me->inP)
		    LYEnsureSingleSpace(me);
		me->sp->style->alignment =
a5928 2
	    }
	}
d5930 1
a5930 6
	if (me->style_change) {
	    actually_set_style(me);
	    if (me->List_Nesting_Level >= 0)
		HText_NegateLineOne(me->text);
	} else if (me->inP)
	    LYEnsureSingleSpace(me);
d5932 2
d5945 2
a5946 2
	} else if (me->sp->style->id == ST_HeadingCenter ||
		   me->sp->style->id == ST_Heading1) {
d5948 1
a5948 1
	} else if (me->sp->style->id == ST_HeadingRight) {
d5970 1
a5970 1
	LYHandlePlike(me,
d5972 1
a5972 1
		 include, 0,
d6003 1
a6003 1
	    CTRACE((tfp, "Ending underline\n"));
d6005 1
a6005 1
	    CTRACE((tfp, "Underline Level is %d\n", me->Underline_Level));
d6019 1
a6024 4
    case HTML_SUB:
	HText_appendCharacter(me->text, ']');
	break;

a6069 1
	/* FALLTHRU */
a6070 1
	/* FALLTHRU */
a6071 1
	/* FALLTHRU */
a6095 1
	/* FALLTHRU */
a6096 1
	/* FALLTHRU */
a6097 1
	/* FALLTHRU */
a6098 1
	/* FALLTHRU */
d6101 2
a6102 6
	CTRACE((tfp, "HTML_end_element: Reducing List Nesting Level to %d\n",
		    me->List_Nesting_Level));
#ifdef EXP_JUSTIFY_ELTS
	if (element_number == HTML_DL)
	    in_DT = FALSE; /*close the term that was without definition. */
#endif
d6135 1
a6135 6
#ifdef MARK_HIDDEN_LINKS
	if (hidden_link_marker && *hidden_link_marker &&
		HText_isAnchorBlank(me->text, me->CurrentANum) ) {
	    HText_appendText(me->text,hidden_link_marker);
	}
#endif
d6169 13
a6181 5
	LYHandleFIG(me, NULL, NULL,
		    0,
		    0,
		    NULL,
		    NULL, NO, FALSE, &intern_flag);
d6190 1
a6190 2
	    char *start = NULL, *first_end = NULL, *last_end = NULL;
	    char *first_map = NULL, *last_map = NULL;
d6206 1
a6206 2
		} else if (s == 0 && !strncasecomp(cp, "<PARAM", 6) &&
		    !IsNmChar(cp[6])) {
d6208 1
a6208 2
		} else if (!strncasecomp(cp, "<OBJECT", 7) &&
		    !IsNmChar(cp[7])) {
d6212 1
a6212 2
		} else if (!strncasecomp(cp, "</OBJECT", 8) &&
		    !IsNmChar(cp[8])) {
a6214 1
		    last_end = cp;
a6215 8
		} else if (!strncasecomp(cp, "<MAP", 4) &&
		    !IsNmChar(cp[4])) {
		    if (!first_map)
			first_map = cp;
		    last_map = cp;
		} else if (!strncasecomp(cp, "</MAP", 5) &&
		    !IsNmChar(cp[5])) {
		    last_map = cp;
d6219 20
d6244 8
a6251 3
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content:\n%s\n",
			    me->object.data));
a6253 54
	    if (s > e) {
		if (!me->object_declare && !me->object_name &&
		    !(me->object_shapes && !LYMapsOnly) &&
		    !(me->object_usemap != NULL && !LYMapsOnly) &&
		    !(clickable_images && !LYMapsOnly &&
		      me->object_data != NULL &&
		      !have_param &&
		      me->object_classid == NULL &&
		      me->object_codebase == NULL &&
		      me->object_codetype == NULL)) {
		    /*
		     *  We have nested OBJECT tags, and not yet all of the
		     *  end tags, but have a case where the content needs
		     *  to be parsed again (not dropped) and where we don't
		     *  want to output anything special at the point when we
		     *  *do* have accumulated all the end tags.  So recycle
		     *  the incomplete contents now, and signal the SGML
		     *  parser that it should not regard the current OBJECT
		     *  ended but should treat its contents as mixed.
		     *  Normally these cases would have already handled
		     *  in the real start_element call, so this block may
		     *  not be necessary. - kw
		     */
		    CTRACE((tfp, "%s:\n%s\n",
			   "HTML: Nested OBJECT tags.  Recycling incomplete contents",
			   me->object.data));
		    status = HT_PARSER_OTHER_CONTENT;
		    me->object.size--;
		    HTChunkPuts(&me->object, "</OBJECT>");
		    if (!include)	/* error, should not happen */
			include = &me->xinclude;
		    StrnAllocCat(*include, me->object.data, me->object.size);
		    clear_objectdata(me);
		    /* an internal fake call to keep our stack happy: */
		    HTML_start_element(me, HTML_OBJECT, NULL,NULL,
				       me->tag_charset, include);
		    break;
		}
		/*
		 *  We have nested OBJECT tags, and not yet all of the
		 *  end tags, and we want the end tags.  So restore an
		 *  end tag to the content, and signal to the SGML parser
		 *  that it should resume the accumulation of OBJECT content
		 *  (after calling back to start_element) in a way that
		 *  is equivalent to passing it a dummy start tag. - FM, kw
		 */
		CTRACE((tfp, "HTML: Nested OBJECT tags.  Recycling.\n"));
		status = HT_PARSER_REOPEN_ELT;
		me->object.size--;
		HTChunkPuts(&me->object, "</OBJECT>");
		if (!LYMapsOnly)
		    change_paragraph_style(me, me->sp->style);
		break;
	    }
d6260 1
a6260 1
	    CTRACE((tfp, "HTML:OBJECT content:\n%s\n", me->object.data));
d6271 1
a6271 1
		if (me->object_id && *me->object_id && !LYMapsOnly)
d6273 1
a6273 1
		CTRACE((tfp, "HTML: DECLAREd OBJECT.  Ignoring!\n"));
d6283 1
a6283 1
	    if (me->object_name != NULL && !LYMapsOnly) {
d6286 1
a6286 1
		CTRACE((tfp, "HTML: NAMEd OBJECT.  Ignoring!\n"));
d6302 6
a6307 21
		    if (LYMapsOnly) {
			/*
			 *  Well we don't need to do this any more,
			 *  nested objects should either not get here
			 *  any more at all or can be handled fine by
			 *  other code below.  Leave in place for now
			 *  as a special case for LYMapsOnly. - kw
			 */
			if (LYMapsOnly && (!last_map || last_map < first_end))
			    *first_end = '\0';
			else
			    e = 0;
			data = NULL;
			if (LYMapsOnly && (!first_map || first_map > start))
			    StrAllocCopy(data, start);
			else
			    StrAllocCopy(data, me->object.data);
			if (e > 0) {
			    for (i = e; i > 0; i--) {
				StrAllocCat(data, "</OBJECT>");
			    }
a6308 7
			if (!include)	/* error, should not happen */
			    include = &me->xinclude;
			StrAllocCat(*include, data);
			CTRACE((tfp, "HTML: Recycling nested OBJECT%s.\n",
			       (s > 1) ? "s" : ""));
			FREE(data);
			goto End_Object;
d6310 6
d6317 7
a6323 2
		    if (LYBadHTML(me))
			CTRACE((tfp, "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content.\n"));
d6329 4
a6332 10
	     *	If its content has SHAPES, convert it to FIG. - FM
	     *
	     *  This is now handled in our start_element without using
	     *  include if the SGML parser cooperates, so this block
	     *  may be unnecessary. - kw
	     */
	    if (me->object_shapes == TRUE && !LYMapsOnly) {
		CTRACE((tfp, "HTML: OBJECT has SHAPES.  Converting to FIG.\n"));
		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
d6359 2
a6360 2
	    if (me->object_usemap != NULL && !LYMapsOnly) {
		CTRACE((tfp, "HTML: OBJECT has USEMAP.  Converting to IMG.\n"));
a6361 2
		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
a6404 47
		/*
		 *  Add the content if it has <MAP, since that may
		 *  be the MAP this usemap points to.  But if we have
		 *  nested objects, try to eliminate portions that
		 *  cannot contribute to the quest for MAP.  This is
		 *  not perfect, we may get too much content; this seems
		 *  preferable over losing too much. - kw
		 */
		if (first_map) {
		    if (s == 0) {
			StrAllocCat(*include, me->object.data);
			CTRACE((tfp, "HTML: MAP found, recycling object contents.\n"));
			goto End_Object;
		    }
		    /* s > 0 and s == e */
		    data = NULL;
		    if (last_map < start) {
			*start = '\0';
			i = 0;
		    } else if (last_map < first_end) {
			*first_end = '\0';
			i = e;
		    } else if (last_map < last_end) {
			*last_end = '\0';
			i = 1;
		    } else {
			i = 0;
		    }
		    if (first_map > last_end) {
			/* fake empty object to keep stacks stack happy */
			StrAllocCopy(data, "<OBJECT><");
			StrAllocCat(data, last_end + 1);
			i = 0;
		    } else if (first_map > start) {
			StrAllocCopy(data, start);
		    } else {
			StrAllocCopy(data, me->object.data);
		    }
		    for (; i > 0; i--) {
			StrAllocCat(data, "</OBJECT>");
		    }
		    CTRACE((tfp, "%s:\n%s\n",
			   "HTML: MAP and nested OBJECT tags.  Recycling parts",
			   data));
		    StrAllocCat(*include, data);
		    FREE(data);
		}
d6411 1
a6411 1
	    if (me->object_id && *me->object_id && !LYMapsOnly)
d6417 1
a6417 3
	    if (me->object.size > 1) {
		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
a6418 1
	    }
d6429 1
a6429 2
		if (!LYMapsOnly &&
		    me->object_data != NULL &&
a6441 2
		    if (!include)	/* error, should not happen */
			include = &me->xinclude;
d6462 14
a6475 1
	clear_objectdata(me);
d6477 1
a6477 2
	if (!LYMapsOnly)
	    change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6516 6
a6521 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Unmatched FORM end tag\n"));
a6522 1
	EMIT_IFDEF_EXP_JUSTIFY_ELTS(form_in_htext = FALSE);
d6536 7
a6542 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Open SELECT at FORM end. Faking SELECT end tag. *****\n"));
d6594 6
a6599 2
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Unmatched TEXTAREA end tag\n"));
d6633 1
d6646 3
a6648 3
	     *	Transform the TEXTAREA content as needed, then parse
	     *	it into individual lines to be handled as a series
	     *  series of INPUT fields (ugh!).
a6651 5
	     *
	     *  If TEXTAREA is handled as SGML_LITTERAL (the old way),
	     *	we need to SGML-unescape any character references and NCRs
	     *  here.  Otherwise this will already have happened in the
	     *  SGML.c parsing. - kw
d6655 1
a6655 23
	    if (HTML_dtd.tags[element_number].contents == SGML_LITTERAL) {
		TRANSLATE_AND_UNESCAPE_ENTITIES6(&me->textarea.data,
						 me->UCLYhndl,
						 current_char_set,
						 NO,
						 me->UsePlainSpace, me->HiddenValue);
	    } else {
		/*
		 *  This shouldn't have anything to do, normally, but
		 *  just in case...
		 *  There shouldn't be lynx special character codes in
		 *  the chunk ("DTD" flag Tgf_nolyspcl tells SGML.c not
		 *  to generate them).  If there were, we could set the
		 *  last parameter ('Back') below to YES, which would
		 *  take them out of the data.
		 *  The data may however contain non break space, soft
		 *  hyphen, or en space etc., in the me->UCLYhndl character
		 *  encoding.  If that's a problem, perhaps for the (line
		 *  or other) editor, setting 'Back' to YES should also
		 *  help to always convert them to plain spaces (or drop
		 *  them). - kw
		 */
		TRANSLATE_HTML7(&me->textarea.data,
d6658 1
a6658 5
						    NO,
						    me->UsePlainSpace, me->HiddenValue,
						    NO);
	    }
	    data = me->textarea.data;
d6698 1
a6698 1
			temp[j] = (char) (temp[j+1] ? ' ' : '\0');
d6731 1
a6731 1
			temp[j] = (char) (temp[j+1] ? ' ' : '\0');
d6773 6
a6778 2
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Unmatched SELECT end tag *****\n"));
d6796 7
a6802 3
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: SELECT end tag not within FORM element *****\n"));
d6858 1
a6858 9
		    else {
			HTkcode kcode = 0;
			HTkcode specified_kcode = 0;
			if (HTCJK == JAPANESE) {
			    kcode = HText_getKcode(me->text);
			    HText_updateKcode(me->text, kanji_code);
			    specified_kcode = HText_getSpecifiedKcode(me->text);
			    HText_updateSpecifiedKcode(me->text, kanji_code);
			}
a6859 5
			if (HTCJK == JAPANESE) {
			    HText_updateKcode(me->text, kcode);
			    HText_updateSpecifiedKcode(me->text, specified_kcode);
			}
		    }
a6865 1
		    HText_endInput(me->text);
a6885 3
#ifdef EXP_NESTED_TABLES
	if (!nested_tables)
#endif
d6887 1
a6887 2

	if (me->sp->style->id == ST_Preformatted) {
a6896 11

#ifdef EXP_NESTED_TABLES
	if (nested_tables) {
	    me->inTABLE = HText_endStblTABLE(me->text);
	} else {
	    HText_endStblTABLE(me->text);
	}
#else
	HText_endStblTABLE(me->text);
#endif

d6904 1
a6904 2
	HText_endStblTR(me->text);
	if (!HText_LastLineEmpty(me->text, FALSE)) {
a6916 2
	if (me->inTABLE)
	    HText_endStblCOLGROUP(me->text);
d6920 2
a6922 1
	HText_endStblTD(me->text);
a6961 12

#ifdef EXP_JUSTIFY_ELTS
	    if (reached_awaited_stacked_elt)
		wait_for_this_stacked_elt=-1;
#endif

    if (me->xinclude) {
	HText_appendText(me->text, " *** LYNX ERROR ***\rUnparsed data:\r");
	HText_appendText(me->text, me->xinclude);
	FREE(me->xinclude);
    }

a6962 1
    if (!skip_stack_requested) { /*don't emit stylechanges if skipped stack element - VH*/
d6964 2
a6965 2
	TrimColorClass(HTML_dtd.tags[element_number].name,
		       Style_className, &hcode);
d6968 4
a6971 4
	FastTrimColorClass(HTML_dtd.tags[element_number].name,
			   HTML_dtd.tags[element_number].name_len,
			   Style_className,
			   &Style_className_end, &hcode);
d6975 8
a6982 7
	if (!ReallyEmptyTagNum(element_number))
	{
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.end_element: ending non-\"EMPTY\" style <%s...>\n",
			  HTML_dtd.tags[element_number].name));
	    HText_characterStyle(me->text, HCODE_TO_STACK_OFF(hcode), STACK_OFF);
	}
a6984 1
    return status;
a7026 2
	clear_objectdata(me);
	FREE(me->xinclude);
d7055 1
a7055 1
	    CTRACE((tfp, "HTML_free: Ending underline\n"));
a7059 1
	    CTRACE((tfp, "HTML_free: Ending HTML_A\n"));
d7075 7
a7081 3
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: SELECT or OPTION not ended properly *****\n"));
d7087 2
a7088 2
	    CTRACE((tfp, "HTML_free: ***** leftover option data: %s\n",
			me->option.data));
d7098 7
a7104 3
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: TEXTAREA not used properly *****\n"));
d7110 2
a7111 2
	    CTRACE((tfp, "HTML_free: ***** leftover textarea data: %s\n",
			me->textarea.data));
a7131 5
	if (me->xinclude) {
	    HText_appendText(me->text, " *** LYNX ERROR ***\rUnparsed data:\r");
	    HText_appendText(me->text, me->xinclude);
	    FREE(me->xinclude);
	}
d7144 7
a7150 3
	if (LYBadHTML(me))
	    CTRACE((tfp,
		    "Bad HTML: SELECT or OPTION not ended properly *****\n"));
d7153 2
a7154 2
	    CTRACE((tfp, "HTML_free: ***** leftover option data: %s\n",
			 me->option.data));
d7164 7
a7170 3
	if (LYBadHTML(me))
	    CTRACE((tfp,
		    "Bad HTML: TEXTAREA not used properly *****\n"));
d7173 2
a7174 2
	    CTRACE((tfp, "HTML_free: ***** leftover textarea data: %s\n",
			 me->textarea.data));
d7183 3
a7185 3
	if (me->sp->style->id == ST_DivCenter ||
	    me->sp->style->id == ST_HeadingCenter ||
	    me->sp->style->id == ST_Heading1) {
d7187 2
a7188 2
	} else if (me->sp->style->id == ST_DivRight ||
		   me->sp->style->id == ST_HeadingRight) {
a7202 1
    clear_objectdata(me);
d7246 2
a7247 1
	    CTRACE((tfp, "HTML_abort: SELECT or OPTION not ended properly *****\n"));
d7249 2
a7250 2
	    CTRACE((tfp, "HTML_abort: ***** leftover option data: %s\n",
			 me->option.data));
d7261 2
a7262 1
	    CTRACE((tfp, "HTML_abort: TEXTAREA not used properly *****\n"));
d7264 2
a7265 2
	    CTRACE((tfp, "HTML_abort: ***** leftover textarea data: %s\n",
			 me->textarea.data));
d7274 3
a7276 3
	if (me->sp->style->id == ST_DivCenter ||
	    me->sp->style->id == ST_HeadingCenter ||
	    me->sp->style->id == ST_Heading1) {
d7278 2
a7279 2
	} else if (me->sp->style->id == ST_DivRight ||
		   me->sp->style->id == ST_HeadingRight) {
a7297 2
    FREE(me->xinclude);
    clear_objectdata(me);
d7306 2
a7307 2
    HTStyle** st = NULL;
    styleSheet = DefaultStyle(&st);  /* sets st[] array */
d7309 13
a7321 1
    default_style =		st[ST_Normal];
d7323 1
a7323 15
    styles[HTML_H1] =		st[ST_Heading1];
    styles[HTML_H2] =		st[ST_Heading2];
    styles[HTML_H3] =		st[ST_Heading3];
    styles[HTML_H4] =		st[ST_Heading4];
    styles[HTML_H5] =		st[ST_Heading5];
    styles[HTML_H6] =		st[ST_Heading6];
    styles[HTML_HCENTER] =	st[ST_HeadingCenter];
    styles[HTML_HLEFT] =	st[ST_HeadingLeft];
    styles[HTML_HRIGHT] =	st[ST_HeadingRight];

    styles[HTML_DCENTER] =	st[ST_DivCenter];
    styles[HTML_DLEFT] =	st[ST_DivLeft];
    styles[HTML_DRIGHT] =	st[ST_DivRight];

    styles[HTML_DL] =		st[ST_Glossary];
d7325 6
a7330 6
    styles[HTML_DL1] =		st[ST_Glossary1];
    styles[HTML_DL2] =		st[ST_Glossary2];
    styles[HTML_DL3] =		st[ST_Glossary3];
    styles[HTML_DL4] =		st[ST_Glossary4];
    styles[HTML_DL5] =		st[ST_Glossary5];
    styles[HTML_DL6] =		st[ST_Glossary6];
d7333 1
a7333 1
    styles[HTML_OL] =		st[ST_List];
d7335 6
a7340 6
    styles[HTML_OL1] =		st[ST_List1];
    styles[HTML_OL2] =		st[ST_List2];
    styles[HTML_OL3] =		st[ST_List3];
    styles[HTML_OL4] =		st[ST_List4];
    styles[HTML_OL5] =		st[ST_List5];
    styles[HTML_OL6] =		st[ST_List6];
d7343 1
a7343 1
    styles[HTML_DIR] =		st[ST_Menu];
d7345 6
a7350 6
    styles[HTML_MENU1] =	st[ST_Menu1];
    styles[HTML_MENU2] =	st[ST_Menu2];
    styles[HTML_MENU3] =	st[ST_Menu3];
    styles[HTML_MENU4] =	st[ST_Menu4];
    styles[HTML_MENU5] =	st[ST_Menu5];
    styles[HTML_MENU6] =	st[ST_Menu6];
d7352 1
a7352 1
    styles[HTML_DLC] =		st[ST_GlossaryCompact];
d7354 13
a7366 13
    styles[HTML_DLC1] =		st[ST_GlossaryCompact1];
    styles[HTML_DLC2] =		st[ST_GlossaryCompact2];
    styles[HTML_DLC3] =		st[ST_GlossaryCompact3];
    styles[HTML_DLC4] =		st[ST_GlossaryCompact4];
    styles[HTML_DLC5] =		st[ST_GlossaryCompact5];
    styles[HTML_DLC6] =		st[ST_GlossaryCompact6];

    styles[HTML_ADDRESS] =	st[ST_Address];
    styles[HTML_BANNER] =	st[ST_Banner];
    styles[HTML_BLOCKQUOTE] =	st[ST_Blockquote];
    styles[HTML_BQ] =		st[ST_Bq];
    styles[HTML_FN] =		st[ST_Footnote];
    styles[HTML_NOTE] =		st[ST_Note];
d7368 3
a7370 3
    styles[HTML_XMP] =		st[ST_Example];
    styles[HTML_PRE] =		st[ST_Preformatted];
    styles[HTML_LISTING] =	st[ST_Listing];
d7421 1
a7421 1
	exit_immediately (EXIT_FAILURE);
d7424 1
a7424 1
    me = typecalloc(HTStructured);
d7444 9
a7452 3
    HTChunkInit(&me->title, 128);

    HTChunkInit(&me->object, 128);
d7467 4
a7470 1
    HTChunkInit(&me->option, 128);
d7476 4
a7479 1
    HTChunkInit(&me->textarea, 128);
d7488 14
a7501 5
    HTChunkInit(&me->math, 128);

    HTChunkInit(&me->style_block, 128);

    HTChunkInit(&me->script, 128);
a7537 1
    me->node_anchor->inBASE = FALSE;
d7567 47
d7650 5
a7663 10

/*
 *  A flag set by a file write error.  Used for only generating an alert
 *  the first time such an error happens, since Lynx should still be usable
 *  if the temp space becomes full, and an alert each time a cache file
 *  cannot be written would be annoying.  Reset when  lynx.cfg is being
 *  reloaded (user may change SOURCE_CACHE setting). - kw
 */
PUBLIC BOOLEAN source_cache_file_error = FALSE;

d7668 1
a7668 1
PRIVATE void CacheThru_do_free ARGS1(
d7671 1
a7671 16
    if (me->anchor->source_cache_file) {
	CTRACE((tfp, "SourceCacheWriter: Removing previous file %s\n",
		me->anchor->source_cache_file));
	LYRemoveTemp(me->anchor->source_cache_file);
	FREE(me->anchor->source_cache_file);
    }
    if (me->anchor->source_cache_chunk) {
	CTRACE((tfp, "SourceCacheWriter: Removing previous memory chunk %p\n",
		(void *)me->anchor->source_cache_chunk));
	HTChunkFree(me->anchor->source_cache_chunk);
	me->anchor->source_cache_chunk = NULL;
    }
    if (me->fp) {
	fflush(me->fp);
	if (ferror(me->fp))
	    me->status = HT_ERROR;
a7672 34
	if (me->status == HT_OK) {
	    me->anchor->source_cache_file = me->filename;
	    CTRACE((tfp,
		    "SourceCacheWriter: Committing file %s for URL %s to anchor\n",
		    me->filename, HTAnchor_address((HTAnchor *)me->anchor)));
	} else {
	    if (source_cache_file_error == FALSE) {
		HTAlert(gettext("Source cache error - disk full?"));
		source_cache_file_error = TRUE;
	    }
	    LYRemoveTemp(me->filename);
	    me->anchor->source_cache_file = NULL;
	}
    } else if (me->status != HT_OK) {
	if (me->chunk) {
	    CTRACE((tfp, "SourceCacheWriter: memory chunk %p had errors.\n",
		    me->chunk));
	    HTChunkFree(me->chunk);
	    me->chunk = NULL;
	}
	HTAlert(gettext("Source cache error - not enough memory!"));
    }
    if (me->chunk) {
	me->anchor->source_cache_chunk = me->chunk;
	CTRACE((tfp,
		"SourceCacheWriter: Committing memory chunk %p for URL %s to anchor\n",
		(void *)me->chunk, HTAnchor_address((HTAnchor *)me->anchor)));
    }
}

PRIVATE void CacheThru_free ARGS1(
	HTStream *,	me)
{
    CacheThru_do_free(me);
a7682 16
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((tfp, "SourceCacheWriter: Removing active file %s\n",
		    me->filename));
	    LYRemoveTemp(me->filename);
	    FREE(me->filename);
	}
	if (me->chunk) {
	    CTRACE((tfp, "SourceCacheWriter: Removing active memory chunk %p\n",
		    (void *)me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	/*fake it*/
	CacheThru_do_free(me);
    }
d7691 4
a7694 9
    if (me->status == HT_OK) {
	if (me->fp) {
	    fputc(c_in, me->fp);
	} else if (me->chunk) {
	    HTChunkPutc(me->chunk, c_in);
	    if (me->chunk->allocated == 0)
		me->status = HT_ERROR;
	}
    }
d7702 4
a7705 9
    if (me->status == HT_OK) {
	if (me->fp) {
	    fputs(str, me->fp);
	} else if (me->chunk) {
	    HTChunkPuts(me->chunk, str);
	    if (me->chunk->allocated == 0 && *str)
		me->status = HT_ERROR;
	}
    }
d7714 4
a7717 11
    if (me->status == HT_OK) {
	if (me->fp) {
	    fwrite(str, 1, l, me->fp);
	    if (ferror(me->fp))
		me->status = HT_ERROR;
	} else if (me->chunk) {
	    HTChunkPutb(me->chunk, str, l);
	    if (me->chunk->allocated == 0 && l != 0)
		me->status = HT_ERROR;
	}
    }
d7746 1
a7746 1
    /*  Only remote HTML documents may benefit from HTreparse_document(),  */
d7748 2
a7749 3
    if (strcmp(p->name, "http") != 0
     && strcmp(p->name, "https") != 0) {
	CTRACE((tfp, "SourceCacheWriter: Protocol is \"%s\"; not caching\n", p->name));
a7760 1
    stream->anchor = anchor;
a7761 1
    stream->filename = NULL;
a7764 1
    stream->status = HT_OK;
d7767 5
a7771 3
	if (anchor->source_cache_file) {
	    CTRACE((tfp, "SourceCacheWriter: If successful, will replace source cache file %s\n",
		    anchor->source_cache_file));
d7780 3
a7782 3
	if (!(stream->fp = LYOpenTemp(filename, HTML_SUFFIX, BIN_W))) {
	    CTRACE((tfp, "SourceCacheWriter: Cannot open source cache file for URL %s\n",
		   HTAnchor_address((HTAnchor *)anchor)));
d7787 4
a7790 1
	StrAllocCopy(stream->filename, filename);
d7792 2
a7793 2
	CTRACE((tfp, "SourceCacheWriter: Caching source for URL %s in file %s\n",
		     HTAnchor_address((HTAnchor *)anchor), filename));
d7797 5
a7801 4
	if (anchor->source_cache_chunk) {
	    CTRACE((tfp,
		    "SourceCacheWriter: If successful, will replace memory chunk %p\n",
		    (void *)anchor->source_cache_chunk));
d7804 4
a7807 10
#ifdef SAVE_TIME_NOT_SPACE
	stream->chunk = HTChunkCreateMayFail(4096, 1);
#else
	stream->chunk = HTChunkCreateMayFail(128, 1);
#endif
	if (!stream->chunk)	/* failed already? pretty bad... - kw */
	    stream->status = HT_ERROR;

	CTRACE((tfp, "SourceCacheWriter: Caching source for URL %s in memory chunk %p\n",
	       HTAnchor_address((HTAnchor *)anchor), (void *)stream->chunk));
a7812 2
#else
#define CacheThru_new(anchor, target) target
d7828 1
d7832 3
d7893 1
d7897 3
d7909 1
a7909 1
**	It is registered in HTInit.c, but normally not used by lynx.
d7918 2
a7919 2
    if (sink)
	(*sink->isa->put_string)(sink, "/* ");	/* Before even title */
d7923 2
a7924 2
    if (!sink)
	HTML_put_string(html,html->comment_start);
d7927 3
d7946 1
d7950 3
a8002 21
#ifdef SH_EX	/* 1998/04/02 (Thu) 16:02:00 */

    /* for proxy server 1998/12/19 (Sat) 11:53:30 */
    if (AS_casecomp(newtitle + 1, "internal-gopher-menu") == 0) {
	StrAllocCopy(newtitle, "+");
    } else if (AS_casecomp(newtitle + 1, "internal-gopher-unknown") == 0) {
	StrAllocCopy(newtitle, " ");
    } else {
	/* normal title */
	ptr = strrchr(newtitle, '.');
	if (ptr) {
	  if (AS_casecomp(ptr, ".gif") == 0)
	    *ptr = '\0';
	  else if (AS_casecomp(ptr, ".jpg") == 0)
	    *ptr = '\0';
	  else if (AS_casecomp(ptr, ".jpeg") == 0)
	    *ptr = '\0';
	}
	StrAllocCat(newtitle, "]");
    }
#else
a8003 1
#endif
d8030 1
a8030 1
    if ( verbose_img && value[HTML_IMG_SRC] && *value[HTML_IMG_SRC] ) {
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@d2915 1
a2915 3
	    if (isEmpty(href))
		StrAllocCopy(href, "#");
	    CHECK_FOR_INTERN(intern_flag,href);	 /* '#'*/
d2918 2
@


1.1.3.3
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d63 5
d76 1
a76 1
#ifdef USE_SOURCE_CACHE
d90 1
a90 1
#ifdef USE_SOURCE_CACHE
d153 1
a153 1
    while (*i) { *i = (char)TOLOWER(*i); i++; }
d672 9
a680 43
PRIVATE char* Style_className = 0;
PRIVATE char* Style_className_end = 0;
PRIVATE unsigned Style_className_len = 0;
PRIVATE int hcode;

#ifdef LY_FIND_LEAKS
PRIVATE void free_Style_className NOARGS
{
    FREE(Style_className);
}
#endif

PRIVATE void addClassName ARGS3(
	CONST char *,	prefix,
	CONST char *,	actual,
	int,		length)
{
    int offset = strlen(prefix);
    unsigned have = (Style_className_end - Style_className);
    unsigned need = (offset + length + 1);

    if ((have + need) >= Style_className_len) {
	Style_className_len += 1024 + 2 * (have + need);
	if (Style_className == 0) {
	    Style_className = malloc(Style_className_len);
	} else {
	    Style_className = realloc(Style_className, Style_className_len);
	}
	if (Style_className == NULL)
	    outofmem(__FILE__, "addClassName");
	Style_className_end = Style_className + have;
    }
    if (offset)
	strcpy(Style_className_end, prefix);
    if (length)
	memcpy(Style_className_end + offset, actual, length);
    Style_className_end[offset + length] = '\0';
    strtolower(Style_className_end);

    Style_className_end += (offset + length);
}
#else
#define addClassName(prefix, actual, length) /* nothing */
d904 1
a904 1
    char *class_name;
d906 6
d1029 11
a1039 4
    addClassName(";", 
	         HTML_dtd.tags[element_number].name,
	         HTML_dtd.tags[element_number].name_len);

d1054 3
d1058 3
a1060 1
	if (class_name[0]) {
d1062 12
d1077 1
d1080 1
a1084 2
		addClassName(".", class_name, strlen(class_name));

d1092 4
d1098 22
d1122 12
a1133 1
	    addClassName(".", class_name, strlen(class_name));
d1143 10
a1152 1
#if !OMIT_SCN_KEEPING		/* Can be done in other cases too... */
d1155 2
a1156 1
	int ohcode = hcode;
d1160 1
d1162 4
d1170 1
a1174 2
	    addClassName(".type.", type, strlen(type));

d1180 1
a1180 1
#endif	/* !OMIT_SCN_KEEPING */
d4612 1
a4612 1
#ifndef USE_FILE_UPLOAD
d4620 1
a4620 1
#endif /* USE_FILE_UPLOAD */
d4781 1
a4781 1
#ifdef USE_FILE_UPLOAD
d4888 1
a4888 1
#ifndef USE_FILE_UPLOAD
d4965 1
a4965 1
#ifndef USE_FILE_UPLOAD
d5679 4
d5689 1
d7293 4
d7303 1
d7517 5
d7607 5
d7864 5
a7868 6
#ifdef LY_FIND_LEAKS
    if (Style_className == 0) {
	atexit(free_Style_className);
    }
#endif
    addClassName("", "", 0);
d7916 1
a7916 1
#ifdef USE_SOURCE_CACHE
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d84 1
a84 1
    const HTStreamClass *	isa;
d90 1
a90 1
    const HTStreamClass *	actions;
d98 1
a98 1
static HTStyleSheet * styleSheet = NULL;	/* Application-wide */
d102 1
a102 1
static HTStyle *styles[HTML_ELEMENTS+LYNX_HTML_EXTRA_ELEMENTS];
d106 1
a106 1
static HTStyle *default_style = NULL;
d108 1
a108 1
char *LYToolbarName = "LynxPseudoToolbar";
d111 1
a111 1
static int i_prior_style = -1;
d117 1
a117 1
static int HTML_end_element (HTStructured *me,
d119 1
a119 1
				      char **include);
d121 1
a121 1
static int HTML_start_element (
d124 2
a125 2
	const BOOL*		present,
	const char **		value,
d127 1
a127 1
	char **			include);
d135 3
a137 3
static char* MakeNewTitle (const char ** value, int src_type);
static char* MakeNewImageValue (const char ** value);
static char* MakeNewMapValue (const char ** value, const char* mapstr);
d145 1
a145 1
void strtolower (char* i)
d163 1
a163 1
void actually_set_style (HTStructured * me)
d189 1
a189 1
static void change_paragraph_style (HTStructured * me, HTStyle * style)
d198 2
a199 2
BOOL LYBadHTML (
    HTStructured *	me)
d229 1
a229 1
void HTML_put_character (HTStructured * me, char c)
d438 1
a438 1
void HTML_put_string (HTStructured * me, const char * s)
d450 1
a450 1
	s = (const char *) translated_string;
d520 1
a520 1
	    const char *p = s;
d597 1
a597 1
void HTML_write (HTStructured * me, const char* s, int l)
d599 2
a600 2
    const char* p;
    const char* e = s+l;
d667 4
a670 4
static char* Style_className = 0;
static char* Style_className_end = 0;
static unsigned Style_className_len = 0;
static int hcode;
d673 1
a673 1
static void free_Style_className (void)
d679 4
a682 4
static void addClassName (
	const char *	prefix,
	const char *	actual,
	int		length)
d715 5
a719 5
static void HTMLSRC_apply_markup (
	    HTStructured *   context,
	    HTlexeme	      lexeme,
	    BOOL	      start,
	    int	      tag_charset)
d738 1
a738 1
		(const char **)ts->value,
d752 1
d755 4
d765 6
a770 6
static void LYStartArea (
	HTStructured *		obj,
	const char *		href,
	const char *		alt,
	const char *		title,
	int			tag_charset)
d773 1
a773 1
    const char *	new_value[HTML_AREA_ATTRIBUTES];
d781 1
a781 1
	new_value[HTML_AREA_ALT] = (const char *)alt;
d785 1
a785 1
	new_value[HTML_AREA_TITLE] = (const char *)title;
d789 1
a789 1
	new_value[HTML_AREA_HREF] = (const char *)href;
d796 11
a806 11
static void LYHandleFIG (
	HTStructured *		me,
	const BOOL*		present,
	const char **		value,
	BOOL			isobject,
	BOOL			imagemap,
	const char *		id,
	const char *		src,
	BOOL			convert,
	BOOL			start,
	BOOL *			intern_flag GCC_UNUSED)
d873 2
a874 2
static void clear_objectdata (
	HTStructured *		me)
d903 7
a909 7
static int HTML_start_element (
	HTStructured *		me,
	int			element_number,
	const BOOL*		present,
	const char **		value,
	int			tag_charset,
	char **		include)
d921 1
a921 1
    const char *Base = NULL;
d942 1
a942 1
	    const char* p;
d1107 1
a1107 1
	const char *type = "";
d1148 1
a1148 1
	    const char *related = NULL;
d4177 1
a4177 1
	    const char * accept_cs = NULL;
d5101 1
a5101 1
		       present, (const char **)value,
d5652 4
a5655 4
static int HTML_end_element (
	HTStructured *		me,
	int			element_number,
	char **		include)
d6077 1
a6077 1
		 (const BOOL*)0, (const char **)0,
d7260 1
a7260 1
int HTML_put_entity (HTStructured * me, int entity_number)
d7282 1
a7282 1
static void HTML_free (HTStructured * me)
d7462 1
a7462 1
static void HTML_abort (HTStructured * me, HTError e)
d7555 1
a7555 1
static void get_styles (void)
d7630 1
a7630 1
HTStyle *LYstyles (int style_number)
d7643 1
a7643 1
const HTStructuredClass HTMLPresentation = /* As opposed to print etc */
d7659 4
a7662 4
HTStructured* HTML_new (
	HTParentAnchor *	anchor,
	HTFormat		format_out,
	HTStream*		stream)
d7854 1
a7854 1
BOOLEAN source_cache_file_error = FALSE;
d7860 2
a7861 2
static void CacheThru_do_free (
	HTStream *me)
d7910 2
a7911 2
static void CacheThru_free (
	HTStream *	me)
d7918 3
a7920 3
static void CacheThru_abort (
	HTStream *	me,
	HTError	e)
d7944 3
a7946 3
static void CacheThru_put_character (
	HTStream *	me,
	char		c_in)
d7960 3
a7962 3
static void CacheThru_put_string (
	HTStream *	me,
	const char *	str)
d7976 4
a7979 4
static void CacheThru_write (
	HTStream *	me,
	const char *	str,
	int		l)
d7995 1
a7995 1
static const HTStreamClass PassThruCache =
d8005 3
a8007 3
static HTStream* CacheThru_new (
	HTParentAnchor *	anchor,
	HTStream *		target)
d8103 4
a8106 4
HTStream* HTMLToPlain (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink)
d8124 4
a8127 4
HTStream* HTMLParsedPresent (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink)
d8184 4
a8187 4
HTStream* HTMLToC (
	HTPresentation *	pres GCC_UNUSED,
	HTParentAnchor *	anchor,
	HTStream *		sink)
d8210 4
a8213 4
HTStream* HTMLPresent (
	HTPresentation *	pres GCC_UNUSED,
	HTParentAnchor *	anchor,
	HTStream *		sink GCC_UNUSED)
d8244 4
a8247 4
int HTLoadError (
	HTStream *	sink GCC_UNUSED,
	int		number,
	const char *	message)
d8253 1
a8253 1
static char * MakeNewTitle (const char ** value, int src_type)
d8294 1
a8294 1
static char * MakeNewImageValue (const char ** value)
d8310 1
a8310 1
static char * MakeNewMapValue (const char ** value, const char* mapstr)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 12
a13 12
 *		============================================
 *
 *	This generates a hypertext object.  It converts from the
 *	structured stream interface of HTML events into the style-
 *	oriented interface of the HText.h interface.  This module is
 *	only used in clients and should not be linked into servers.
 *
 *	Override this module if making a new GUI browser.
 *
 *   Being Overidden
 *
 */
d64 1
a64 1
# define HCODE_TO_STACK_OFF(x) /*(CSHASHSIZE+1)*/ 88888		/*special value. */
d66 1
a66 1
# define HCODE_TO_STACK_OFF(x) x	/*pass computed value */
d84 1
a84 1
    const HTStreamClass *isa;
d86 7
a92 7
    HTParentAnchor *anchor;
    FILE *fp;
    char *filename;
    HTChunk *chunk;
    const HTStreamClass *actions;
    HTStream *target;
    int status;
d98 1
a98 1
static HTStyleSheet *styleSheet = NULL;		/* Application-wide */
d102 1
a102 2
static HTStyle *styles[HTML_ELEMENTS + LYNX_HTML_EXTRA_ELEMENTS];

d117 11
a127 8
static int HTML_end_element(HTStructured * me, int element_number,
			    char **include);

static int HTML_start_element(HTStructured * me, int element_number,
			      const BOOL *present,
			      const char **value,
			      int tag_charset,
			      char **include);
d135 3
a137 3
static char *MakeNewTitle(const char **value, int src_type);
static char *MakeNewImageValue(const char **value);
static char *MakeNewMapValue(const char **value, const char *mapstr);
d140 2
a141 2
 *	is only internal and the stack manipulation should be skipped. - kw
 */
d145 1
a145 1
void strtolower(char *i)
d147 2
a148 6
    if (!i)
	return;
    while (*i) {
	*i = (char) TOLOWER(*i);
	i++;
    }
d152 7
a158 7
 *		------------------------------
 *
 * On the NeXT, and on any read-only browser, it is simpler for the text to
 * have a sequence of styles, rather than a nested tree of styles.  In this
 * case we have to flatten the structure as it arrives from SGML tags into a
 * sequence of styles.
 */
d161 3
a163 3
 *  If style really needs to be set, call this.
 */
void actually_set_style(HTStructured * me)
d165 1
a165 1
    if (!me->text) {		/* First time through */
d168 1
a168 1
			 me->UCLYhndl, me->UCI,
d187 3
a189 3
 *  If you THINK you need to change style, call this.
 */
static void change_paragraph_style(HTStructured * me, HTStyle *style)
d198 2
a199 1
BOOL LYBadHTML(HTStructured * me)
d210 3
a212 3
 *
 *			A C T I O N	R O U T I N E S
 */
d227 3
a229 3
 *	------------------
 */
void HTML_put_character(HTStructured * me, char c)
d232 2
a233 1
     * Ignore all non-MAP content when just scanning a document for MAPs.  - FM
d239 1
a239 1
     * Do EOL conversion if needed.  - FM
d241 4
a244 4
     * Convert EOL styles:
     *   macintosh:  cr    --> lf
     *   ascii:      cr-lf --> lf
     *   unix:       lf    --> lf
d255 1
a255 1
     * Handle SGML_LITTERAL tags that have HTChunk elements.  - FM
d260 1
a260 1
	return;			/* Do Nothing */
d306 9
a314 9
	     * If we are within a SELECT not caught by the cases above -
	     * HTML_SELECT or HTML_OPTION may not be the last element pushed on
	     * the style stack if there were invalid markup tags within a
	     * SELECT element.  For error recovery, treat text as part of the
	     * OPTION text, it is probably meant to show up as user-visible
	     * text.  Having A as an open element while in SELECT is really
	     * sick, don't make anchor text part of the option text in that
	     * case since the option text will probably just be discarded.  -
	     * kw
d322 1
a322 1
    }				/* end first switch */
d325 1
a325 1
     * Handle all other tag content.  - FM
d329 1
a329 1
    case HTML_PRE:		/* Formatted text */
d331 2
a332 2
	 * We guarantee that the style is up-to-date in begin_litteral. But we
	 * still want to strip \r's.
d344 1
a344 1
    case HTML_LISTING:		/* Literal text */
d348 2
a349 2
	 * We guarantee that the style is up-to-date in begin_litteral.  But we
	 * still want to strip \r's.
d351 1
a351 1
	if (c != '\r') {
d360 1
a360 1
	 * Free format text.
d406 1
a406 1
		/* ignore */
d415 1
a415 1
    }				/* end second switch */
d418 1
a418 1
	HText_setLastChar(me->text, ' ');	/* set it to a generic separator */
d421 3
a423 2
	 * \r's are ignored.  In order to keep collapsing spaces correctly we
	 * must default back to the previous separator if there was one.
d426 1
a426 1
	HText_setLastChar(me->text, ' ');	/* set it to a generic separator */
d433 6
a438 6
 *	---------------
 *
 *	This is written separately from put_character because the loop can
 *	in some cases be promoted to a higher function call level for speed.
 */
void HTML_put_string(HTStructured * me, const char *s)
d441 1
a441 1
    char *translated_string = NULL;
d448 1
a448 1
	StrAllocCopy(translated_string, s);
d457 1
a457 1
	break;			/* Do Nothing */
d471 2
a472 2
    case HTML_PRE:		/* Formatted text */
    case HTML_LISTING:		/* Literal text */
d476 1
a476 1
	 * We guarantee that the style is up-to-date in begin_litteral
d498 1
a498 1
    default:			/* Free format text? */
d501 3
a503 3
	     * If we are within a preformatted text style not caught by the
	     * cases above (HTML_PRE or similar may not be the last element
	     * pushed on the style stack).  - kw
d513 1
a513 1
		for (; *s; ++s)
d517 1
a517 1
		HText_appendText(me->text, s);
a521 1

d524 2
a525 1
			      (*p == ' ') || (*p == '\t')); p++) ;	/* Ignore leaders */
d533 3
a535 3
		     * Treat any '\r' which is not followed by '\n' as '\n', to
		     * account for macintosh lineend in ALT attributes etc.  -
		     * kw
d543 1
a543 1
			continue;	/* Ignore it */
d556 1
a556 1
		    if (HText_getLastChar(me->text) != ' ')
d560 1
a560 1
		    /* ignore */
d573 4
a576 4
		     * \r's are ignored.  In order to keep collapsing spaces
		     * correctly, we must default back to the previous
		     * separator, if there was one.  So we set LastChar to a
		     * generic separator.
d583 1
a583 1
	    }			/* for */
d585 1
a585 1
    }				/* end switch */
d595 3
a597 3
 *	------------
 */
void HTML_write(HTStructured * me, const char *s, int l)
d599 2
a600 2
    const char *p;
    const char *e = s + l;
d665 1
d667 2
a668 2
static char *Style_className = 0;
static char *Style_className_end = 0;
d673 1
a673 1
static void free_Style_className(void)
d679 4
a682 3
static void addClassName(const char *prefix,
			 const char *actual,
			 int length)
d709 1
a709 1
#define addClassName(prefix, actual, length)	/* nothing */
d712 1
d715 5
a719 2
static void HTMLSRC_apply_markup(HTStructured * context, HTlexeme lexeme, BOOL start,
				 int tag_charset)
d721 1
a721 1
    HT_tagspec *ts = *((start ? lexeme_start : lexeme_end) + lexeme);
d732 1
a732 1
	CTRACE((tfp, ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n", (int) lexeme));
d734 7
a740 6
	    HTML_start_element(context,
			       ts->element,
			       ts->present,
			       (const char **) ts->value,
			       tag_charset,
			       NULL);
d742 4
a745 3
	    HTML_end_element(context,
			     ts->element,
			     NULL);
d758 1
a758 1
#endif /* USE_PRETTYSRC */
d760 6
a765 4
static void LYStartArea(HTStructured * obj, const char *href,
			const char *alt,
			const char *title,
			int tag_charset)
d767 2
a768 2
    BOOL new_present[HTML_AREA_ATTRIBUTES];
    const char *new_value[HTML_AREA_ATTRIBUTES];
d772 1
a772 1
	new_present[i] = NO;
d776 1
a776 1
	new_value[HTML_AREA_ALT] = (const char *) alt;
d780 1
a780 1
	new_value[HTML_AREA_TITLE] = (const char *) title;
d784 1
a784 1
	new_value[HTML_AREA_HREF] = (const char *) href;
d787 2
a788 2
    (*obj->isa->start_element) (obj, HTML_AREA, new_present, new_value,
				tag_charset, 0);
d791 11
a801 9
static void LYHandleFIG(HTStructured * me, const BOOL *present,
			const char **value,
			BOOL isobject,
			BOOL imagemap,
			const char *id,
			const char *src,
			BOOL convert,
			BOOL start,
			BOOL *intern_flag GCC_UNUSED)
d815 1
a815 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
a827 1

d829 1
a829 1
	    CHECK_FOR_INTERN(*intern_flag, href);
d832 5
a836 4
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 INTERN_LT);	/* Type */
d840 2
a841 5
		HTML_put_string(me, (isobject
				     ? (imagemap
					? "(IMAGE)"
					: "(OBJECT)")
				     : "[FIGURE]"));
d846 1
a846 1
		HTML_put_character(me, ' ');	/* space char may be ignored */
d855 1
a855 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
d860 1
a860 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d868 2
a869 1
static void clear_objectdata(HTStructured * me)
d896 9
a904 7
 *	-------------
 */
static int HTML_start_element(HTStructured * me, int element_number,
			      const BOOL *present,
			      const char **value,
			      int tag_charset,
			      char **include)
d918 3
a920 3
    HTParentAnchor *dest = NULL;	/* An anchor's destination */
    BOOL dest_ismap = FALSE;	/* Is dest an image map script? */
    HTChildAnchor *ID_A = NULL;	/* HTML_foo_ID anchor */
a926 1

d935 1
a935 1
	    HTTag *tag = &HTML_dtd.tags[element_number];
d937 1
a937 2
	    const char *p;

d944 1
a944 1
		 */
d953 2
a954 4
	    /*write markup for tags and exit */
	    PSRCSTART(abracket);
	    PUTC('<');
	    PSRCSTOP(abracket);
d956 1
a956 1
	    if (tagname_transform != 0)
d959 1
a959 1
		LYstrncpy(buf, tag->name, sizeof(buf) - 1);
d968 1
a968 1
			if (attrname_transform != 0)
d971 1
a971 3
			    LYstrncpy(buf,
				      tag->attributes[i].name,
				      sizeof(buf) - 1);
d976 7
a982 9
			    char q = '"';

			    /*0 in dquotes, 1 - in quotes, 2 mixed */
			    char kind = (char) (!strchr(value[i], '"') ?
						0 :
						!strchr(value[i], '\'') ?
						q = '\'', 1 :
						2);

d989 2
a990 2
				HTStartAnchor(me, value[i], NULL);
				HTML_end_element(me, HTML_A, NULL);
d993 1
a993 1
				HTStartAnchor(me, NULL, value[i]);
d995 1
a995 1
			    if (kind != 2)
d1005 1
a1005 1
				HTML_end_element(me, HTML_A, NULL);
d1010 3
a1012 3
			}	/* if value */
		    }		/* if present[i] */
	    }			/* if present */
d1014 2
a1015 4
	    PSRCSTART(abracket);
	    PUTC('>');
	    PSRCSTOP(abracket);
	    psrc_nested_call = FALSE;
d1017 2
a1018 2
	}			/*if (!psrc_nested_call) */
	/*fall through */
d1030 3
a1032 1
    } {
d1036 2
a1037 2
	if ((me->tag_charset != j) || (j < 0 /* for trace entry */ )) {
	    CTRACE((tfp, "me->tag_charset: %d -> %d", me->tag_charset, j));
d1039 1
a1039 1
		    me->UCLYhndl, tag_charset));
d1047 3
a1049 3
    addClassName(";",
		 HTML_dtd.tags[element_number].name,
		 HTML_dtd.tags[element_number].name_len);
d1056 2
a1057 2
	    ? -1
	    : cached_tag_styles[element_number];
d1071 1
a1071 1
	    if (!hashStyles[hcode].name) {	/* None such -> classless version */
d1074 2
a1075 3
			(tfp,
			 "STYLE.start_element: <%s> (class <%s> not configured), hcode=%d.\n",
			 HTML_dtd.tags[element_number].name, class_name, hcode));
d1081 1
a1081 1
			 HTML_dtd.tags[element_number].name, class_name, hcode));
d1088 1
a1088 1
    } else {			/* (current_tag_style!=-1)  */
d1096 1
a1096 1
		 HTML_dtd.tags[element_number].name, hcode));
d1101 1
a1101 1
    if (!class_used && ElementNumber == HTML_INPUT) {	/* For some other too? */
d1110 1
a1110 1
	if (!hashStyles[hcode].name) {	/* None such -> classless version */
d1114 1
a1114 1
		     type));
d1120 1
a1120 1
		     HTML_dtd.tags[element_number].name, type, hcode));
d1123 1
a1123 1
#endif /* !OMIT_SCN_KEEPING */
d1129 1
a1129 1
     * Handle the start tag.  - FM
d1150 1
a1150 1
			NonNull(base)));
d1158 6
a1163 5
		 * These have a non-standard form, basically strip the prefix
		 * or the code below would insert a nonsense host into the
		 * pseudo URL.  These should never occur where they would be
		 * used for resolution of relative URLs anyway.  We can also
		 * strip the #map part.  - kw
d1171 1
a1171 1
	     * Get parent's address for defaulted fields.
d1176 1
a1176 1
	     * Create the access field.
d1178 1
a1178 1
	    temp = HTParse(base, related, PARSE_ACCESS + PARSE_PUNCTUATION);
d1183 1
a1183 1
	     * Create the host[:port] field.
d1185 1
a1185 1
	    temp = HTParse(base, "", PARSE_HOST + PARSE_PUNCTUATION);
d1197 1
a1197 1
							       PARSE_HOST + PARSE_PUNCTUATION)));
d1203 1
a1203 1
	     * Create the path field.
d1205 1
a1205 1
	    temp = HTParse(base, "", PARSE_PATH + PARSE_PUNCTUATION);
a1207 1

d1212 1
a1212 1
		    *(p + 1) = '\0';	/* strip after the last slash */
d1248 1
a1248 1
	    CHECK_FOR_INTERN(intern_flag, value[HTML_LINK_HREF]);
d1250 1
a1250 1
	     * Prepare to do housekeeping on the reference.  - FM
d1254 2
a1255 2
		    ? me->base_href
		    : me->node_anchor->address;
d1262 2
a1263 2
		    ? me->base_href
		    : me->node_anchor->address;
d1268 1
a1268 1
	     * Handle links with a REV attribute.  - FM
d1273 1
a1273 1
		 * Handle REV="made" or REV="owner".  - LM & FM
d1278 1
a1278 1
		     * Load the owner element.  - FM
d1285 2
a1286 2
		     * Load the RevTitle element if a TITLE attribute and value
		     * are present.  - FM
d1304 1
a1304 1
	     * Handle REL links.  - FM
d1310 1
a1310 1
		 * Ignore style sheets, for now.  - FM
d1319 2
a1320 4
		    CTRACE2(TRACE_STYLE,
			    (tfp, "HTML: StyleSheet link found.\n"));
		    CTRACE2(TRACE_STYLE,
			    (tfp, "        StyleSheets not yet implemented.\n"));
d1327 6
a1332 6
		 * Ignore anything not registered in the 28-Mar-95 IETF HTML
		 * 3.0 draft and W3C HTML 3.2 draft, or not appropriate for
		 * Lynx banner links in the expired Maloney and Quin relrev
		 * draft.  We'll make this more efficient when the situation
		 * stabilizes, and for now, we'll treat "Banner" as another
		 * toolbar element.  - FM
d1363 18
a1380 17
		    pdoctitle = &title;		/* for setting HTAnchor's title */
		} else if (!strcasecomp(value[HTML_LINK_REL], "Up") ||
			   !strcasecomp(value[HTML_LINK_REL], "Next") ||
			   !strcasecomp(value[HTML_LINK_REL], "Previous") ||
			   !strcasecomp(value[HTML_LINK_REL], "Prev") ||
			   !strcasecomp(value[HTML_LINK_REL], "Child") ||
			   !strcasecomp(value[HTML_LINK_REL], "Sibling") ||
			   !strcasecomp(value[HTML_LINK_REL], "Parent") ||
			   !strcasecomp(value[HTML_LINK_REL], "Meta") ||
			   !strcasecomp(value[HTML_LINK_REL], "URC") ||
			   !strcasecomp(value[HTML_LINK_REL], "Pointer") ||
			   !strcasecomp(value[HTML_LINK_REL], "Translation") ||
			   !strcasecomp(value[HTML_LINK_REL], "Definition") ||
			   !strcasecomp(value[HTML_LINK_REL], "Alternate") ||
			   !strcasecomp(value[HTML_LINK_REL], "Section") ||
			   !strcasecomp(value[HTML_LINK_REL], "Subsection") ||
			   !strcasecomp(value[HTML_LINK_REL], "Chapter")) {
d1402 1
a1402 1
			    value[HTML_LINK_REL]));
d1410 2
a1411 2
	     * If no HREF was specified, handle special REL links with
	     * self-designated HREFs.  - FM
d1420 2
a1421 3
		CTRACE((tfp,
			"HTML: LINK with REL=\"%s\" and no HREF ignored.\n",
			value[HTML_LINK_REL]));
d1429 3
a1431 2
	     * Create a title (link name) from the TITLE value, if present, or
	     * default to the REL value that was loaded into title.  - FM
d1440 1
a1440 1
		FREE(temp);	/* forget about recording RelTitle - kw */
d1450 4
a1453 3
		 * Ugh!  The LINK tag, which is a HEAD element, is in an
		 * Anchor, which is BODY element.  All we can do is close the
		 * Anchor and cross our fingers.  - FM
d1460 2
a1461 1
	     * Create anchors for the links that simulate a toolbar.  - FM
d1463 7
a1469 7
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (temp
						      ? (HTLinkType *)
						      HTAtom_for(temp)
						      : INTERN_LT));	/* Type */
d1471 3
a1473 2
	    if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		 )) != NULL) {
d1494 5
a1498 4
		(ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						  LYToolbarName,	/* Tag */
						  NULL,		/* Addresss */
						  (HTLinkType *) 0))) {		/* Type */
d1500 1
a1500 1
		HText_setLastChar(me->text, ' ');	/* absorb white space */
d1506 2
a1507 2
		 * Add collapsible space to separate link from previous
		 * generated links.  - kw
d1516 2
a1517 1
		value && *value[HTML_LINK_CLASS] != '\0') {
a1518 1

d1530 2
a1531 1
	    } else
d1533 1
a1533 1
		HTML_put_string(me, title);
d1547 4
a1550 4
	     * Lynx was supporting ACTION, which never made it into the HTML
	     * 2.0 specs.  HTML 3.0 uses HREF, so we'll use that too, but allow
	     * use of ACTION as an alternate until people have fully switched
	     * over.  - FM
d1559 2
a1560 2
		? me->base_href
		: me->node_anchor->address;
d1567 1
a1567 1
		me->base_href : me->node_anchor->address;
d1571 1
a1571 1
	 * Support HTML 3.0 PROMPT attribute.  - FM
d1597 2
a1598 2
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
d1605 2
a1606 2
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
d1637 5
a1641 4
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
d1690 5
a1694 4
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
d1697 1
a1697 1
		LYResetParagraphAlignment(me);
d1730 3
a1732 2
	 * Treat this as a toolbar if we don't have one yet, and we are in the
	 * first half of the first page.  - FM
d1735 6
a1740 5
	     HText_getLines(me->text) < (display_lines / 2)) &&
	    (ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
					      LYToolbarName,	/* Tag */
					      NULL,	/* Addresss */
					      (HTLinkType *) 0))) {	/* Type */
d1754 2
a1755 2
		    "HTML: ****** Maximum nesting of %d divisions exceeded!\n",
		    MAX_NESTING));
d1758 1
a1758 1
	    LYEnsureSingleSpace(me);	/* always at least break line - kw */
d1818 10
a1827 10
	 * Close the previous style if not done by HTML doc.  Added to get rid
	 * of core dumps in BAD HTML on the net.
	 *              GAB 07-07-94
	 * But then again, these are actually allowed to nest.  I guess I have
	 * to depend on the HTML writers correct style.
	 *              GAB 07-12-94
	 if (i_prior_style != -1) {
	 HTML_end_element(me, i_prior_style);
	 }
	 i_prior_style = ElementNumber;
d1831 2
a1832 2
	 * Check whether we have an H# in a list, and if so, treat it as an LH. 
	 * - FM
d1848 8
a1855 6
	     * Some authors use H# headers as a substitute for FONT, so check
	     * if this one immediately followed an LI.  If so, both me->inP and
	     * me->in_word will be FALSE (though the line might not be empty
	     * due to a bullet and/or nbsp) and we can assume it is just for a
	     * FONT change.  We thus will not create another line break nor add
	     * to the current left indentation.  - FM
d1895 1
a1895 1
	    (styles[ElementNumber]->font & HT_BOLD)) {
d1911 6
a1916 6
	/* Add a \r (new line) if these three conditions are true:
	 *   1. We are not collapsing BR's, and
	 *   2. The previous line has text on it, or
	 *   3. This line has text on it.
	 * Otherwise, don't do anything. -DH 980814, TD 980827
	 */
d1920 1
a1920 1
	    HText_setLastChar(me->text, ' ');	/* absorb white space */
d1945 4
a1948 3
	     * Start a new line only if we had printable characters following
	     * the previous newline, or remove the previous line if both it and
	     * the last line are blank.  - FM
d1952 1
a1952 1
		HText_setLastChar(me->text, ' ');	/* absorb white space */
d1961 1
a1961 1
	     * Add an ID link if needed.  - FM
d1965 7
a1971 6
	    /*
	     * Center lines within the current margins, if a right or left
	     * ALIGNment is not specified.  If WIDTH="#%" is given and not
	     * garbage, use that to calculate the width, otherwise use the
	     * default width.  - FM
	     */
d1984 1
a1984 1
		me->new_style->leftIndent - me->new_style->rightIndent;
d1987 1
a1987 1
		value[HTML_HR_WIDTH][strlen(value[HTML_HR_WIDTH]) - 1] == '%') {
a1989 1

d1991 1
a1991 1
		percent[strlen(percent) - 1] = '\0';
d2013 2
a2014 2
	     * Reset the alignment appropriately for the division and/or block. 
	     * - FM
d2019 1
a2019 1
		    me->DivisionAlignments[me->Division_Level];
d2030 3
a2032 2
	     * Add a blank line and set the second line indentation for lists
	     * and addresses, or a paragraph separator for other blocks.  - FM
d2036 1
a2036 1
		HText_setLastChar(me->text, ' ');	/* absorb white space */
d2045 1
a2045 1
	if (!present) {		/* Bad tag.  Must have at least one attribute. - FM */
d2050 4
a2053 3
	 * If page author is using TAB within a TABLE, it's probably formatted
	 * specifically to work well for Lynx without simple table tracking
	 * code.  Cancel tracking, it would only make things worse.  - kw
d2063 2
a2064 2
	     * Just ensure a collapsible space, until we have the ALIGN and DP
	     * attributes implemented.  - FM
d2067 1
a2067 2
	    CTRACE((tfp,
		    "HTML: ALIGN not 'left'.  Using space instead of TAB.\n"));
d2072 4
a2075 3
	     * Just ensure a collapsible space, until we can replace
	     * HText_getCurrentColumn() in GridText.c with code which doesn't
	     * require that the alignment be HT_LEFT.  - FM
d2091 1
a2091 1
		 * TO has priority over INDENT if both are present.  - FM
d2102 2
a2103 2
		 * The INDENT value is in "en" (enval per column) units.
		 * Divide it by enval, rounding odd values up.  - FM
d2106 1
a2106 1
		    (int) (((1.0 * atoi(value[HTML_TAB_INDENT])) / enval) + (0.5));
d2110 3
a2112 3
	     * If we are being directed to a column too far to the left or
	     * right, just add a collapsible space, otherwise, add the
	     * appropriate number of spaces.  - FM
d2118 1
a2118 2
		CTRACE((tfp,
			"HTML: Column out of bounds.  Using space instead of TAB.\n"));
d2122 1
a2122 1
		HText_setLastChar(me->text, ' ');	/* absorb white space */
d2128 2
a2129 2
	 * If we have an ID attribute, save it together with the value of the
	 * column we've reached.  - FM
d2147 7
a2153 6
	 * FONT *may* have been declared SGML_EMPTY in HTMLDTD.c, and
	 * SGML_character() in SGML.c *may* check for a FONT end tag to call
	 * HTML_end_element() directly (with a check in that to bypass
	 * decrementing of the HTML parser's stack).  Or this may have been
	 * really a </FONT> end tag, for which some incarnations of SGML.c
	 * would fake a <FONT> start tag instead.  - fm & kw
d2155 3
a2157 3
	 * But if we have an open FONT, DON'T close that one now, since FONT
	 * tags can be legally nested AFAIK, and Lynx currently doesn't do
	 * anything with them anyway...  - kw
d2165 2
a2166 2
	 * Set flag to know we are in a FONT container, and add code to do
	 * something about it, someday.  - FM
d2171 1
a2171 1
    case HTML_B:		/* Physical character highlighting */
d2176 1
a2176 1
    case HTML_CITE:		/* Logical character highlighting */
d2183 2
a2184 2
	 * Ignore this if inside of a bold anchor or header.  Can't display
	 * both underline and bold at same time.
d2193 1
a2193 1
	    CTRACE((tfp, "Beginning underline\n"));
d2195 1
a2195 1
	    CTRACE((tfp, "Underline Level is %d\n", me->Underline_Level));
d2199 1
a2199 1
    case HTML_ABBREV:		/* Miscellaneous character containers */
d2212 1
a2212 1
	break;			/* ignore */
d2251 5
a2255 4
	 * Should check LANG and/or DIR attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * to determine whether we should use chevrons, but for now we'll
	 * always use double- or single-quotes.  - FM
d2264 1
a2264 1
    case HTML_PRE:		/* Formatted text */
d2266 6
a2271 5
	 * Set our inPRE flag to FALSE so that a newline immediately following
	 * the PRE start tag will be ignored.  HTML_put_character() will set it
	 * to TRUE when the first character within the PRE block is received. 
	 * - FM
	 */
d2274 1
a2274 1
    case HTML_LISTING:		/* Literal text */
d2305 1
a2305 1
	     * Indicate the type of NOTE.
d2348 1
a2348 1
	me->List_Nesting_Level++;	/* increment the List nesting level */
d2351 1
a2351 1
				   ? styles[HTML_DLC] : styles[HTML_DL]);
d2355 1
a2355 1
				   ? styles[HTML_DLC6] : styles[HTML_DL6]);
d2359 2
a2360 2
				   ? styles[(HTML_DLC1 - 1) + me->List_Nesting_Level]
				   : styles[(HTML_DL1 - 1) + me->List_Nesting_Level]);
d2362 1
a2362 1
	UPDATE_STYLE;		/* update to the new style */
d2368 1
a2368 1
	me->List_Nesting_Level++;	/* increment the List nesting level */
d2377 1
a2377 1
				   styles[(HTML_DLC1 - 1) + me->List_Nesting_Level]);
d2379 1
a2379 1
	UPDATE_STYLE;		/* update to the new style */
a2388 1

d2390 5
a2394 5
	     * If there are several DT elements and this is not the first, and
	     * the preceding DT element's first (and normally only) line has
	     * not yet been ended, suppress intervening blank line by
	     * temporarily modifying the paragraph style in place.  Ugly but
	     * there's ample precedence.  - kw
d2397 1
a2397 1
		me->sp->style->spaceBefore = 0;		/* temporary change */
d2401 2
a2402 2
	    me->sp->style->spaceBefore = saved_spaceBefore;	/* undo */
	    me->sp->style->spaceAfter = saved_spaceAfter;	/* undo */
d2411 2
a2412 2
	HText_setLastChar(me->text, ' ');	/* absorb white space */
	if (!me->style_change) {
d2431 2
a2432 2
	me->OL_Type[(me->List_Nesting_Level < 11 ?
		     me->List_Nesting_Level + 1 : 11)] = '1';
d2435 3
a2437 2
	 * Check whether we have a starting sequence number, or want to
	 * continue the numbering from a previous OL in this nest.  - FM
d2443 4
a2446 4
	     * Give preference to the valid HTML 3.0 SEQNUM attribute name over
	     * the Netscape START attribute name (too bad the Netscape
	     * developers didn't read the HTML 3.0 specs before re-inventing
	     * the "wheel" as "we'll").  - FM
d2459 3
a2461 2
	     * Don't allow negative numbers less than or equal to our flags, or
	     * numbers less than 1 if an Alphabetic or Roman TYPE.  - FM
d2466 1
a2466 1
				 me->List_Nesting_Level + 1 : 11)] = 'A';
d2471 1
a2471 1
				 me->List_Nesting_Level + 1 : 11)] = 'a';
d2476 1
a2476 1
				 me->List_Nesting_Level + 1 : 11)] = 'I';
d2481 1
a2481 1
				 me->List_Nesting_Level + 1 : 11)] = 'i';
d2485 2
a2486 2
		    if (seqnum <= OL_VOID)
			seqnum = OL_VOID + 1;
d2493 1
a2493 1
			    me->List_Nesting_Level + 1 : 11)] = seqnum;
d2497 1
a2497 1
			   me->List_Nesting_Level + 1 : 11] = OL_CONTINUE;
d2501 1
a2501 1
			    me->List_Nesting_Level + 1 : 11)] = 1;
d2505 1
a2505 1
				 me->List_Nesting_Level + 1 : 11)] = 'A';
d2508 1
a2508 1
				 me->List_Nesting_Level + 1 : 11)] = 'a';
d2511 1
a2511 1
				 me->List_Nesting_Level + 1 : 11)] = 'I';
d2514 1
a2514 1
				 me->List_Nesting_Level + 1 : 11)] = 'i';
d2528 1
a2528 1
				   styles[HTML_OL1 + me->List_Nesting_Level - 1]);
d2530 1
a2530 1
	UPDATE_STYLE;		/* update to the new style */
d2541 1
a2541 1
		  0 == strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
d2552 1
a2552 1
		  0 == strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
d2563 1
a2563 1
		  0 == strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
d2565 1
a2565 2
				       styles[HTML_OL1 + me->List_Nesting_Level
					      - 1]);
d2568 1
a2568 2
				       styles[HTML_MENU1 + me->List_Nesting_Level
					      - 1]);
d2572 1
a2572 1
	UPDATE_STYLE;		/* update to the new style */
d2588 1
a2588 2
				   styles[HTML_MENU1 + me->List_Nesting_Level
					  - 1]);
d2590 1
a2590 1
	UPDATE_STYLE;		/* update to the new style */
d2595 1
a2595 1
	UPDATE_STYLE;		/* update to the new style */
d2605 1
a2605 1
	UPDATE_STYLE;		/* update to the new style */
a2610 1

d2612 3
a2614 3
	     * No, a LI should never occur directly within another LI, but this
	     * may result from incomplete error recovery.  So check one more
	     * surrounding level in this case.  - kw
d2684 1
a2684 1
		 * Hack, because there is no append string!
d2693 7
a2699 6
		 * Use HTML_put_character so that any other spaces coming
		 * through will be collapsed.  We'll use nbsp, so it won't
		 * break at the spacing character if there are no spaces in the
		 * subsequent text up to the right margin, but will declare it
		 * as a normal space to ensure collapsing if a normal space
		 * does immediately follow it.  - FM
d2705 1
a2705 1
		 * Hack, because there is no append string!
d2709 1
a2709 1
		switch (me->List_Nesting_Level % 7) {
d2734 7
a2740 6
		 * Keep using HTML_put_character so that any other spaces
		 * coming through will be collapsed.  We use nbsp, so we won't
		 * wrap at the spacing character if there are no spaces in the
		 * subsequent text up to the right margin, but will declare it
		 * as a normal space to ensure collapsing if a normal space
		 * does immediately follow it.  - FM
d2746 1
a2746 1
		 * Hack, because there is no append string!
d2761 3
a2763 3
	 * Should check LANG and/or DIR attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * and do something here.  - FM
d2770 3
a2772 3
	 * Should check DIR (and LANG) attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * and do something here.  - FM
d2793 1
a2793 1
	    me->inLABEL = TRUE;
d2799 10
a2808 9
	/*
	 * If we are looking for client-side image maps, then handle an A
	 * within a MAP that has a COORDS attribute as an AREA tag. 
	 * Unfortunately we lose the anchor text this way for the LYNXIMGMAP,
	 * we would have to do much more parsing to collect it.  After
	 * potentially handling the A as AREA, always return immediately if
	 * only looking for image maps, without pushing anything on the style
	 * stack.  - kw
	 */
d2819 6
a2824 5
	 * A may have been declared SGML_EMPTY in HTMLDTD.c, and
	 * SGML_character() in SGML.c may check for an A end tag to call
	 * HTML_end_element() directly (with a check in that to bypass
	 * decrementing of the HTML parser's stack), so if we have an open A,
	 * close that one now.  - FM & kw
d2831 1
a2831 1
	 * Set to know we are in an anchor.
d2836 1
a2836 1
	 * Load id_string if we have an ID or NAME.  - FM
d2849 1
a2849 1
	 * Handle the reference.  - FM
d2860 1
a2860 1
	    CHECK_FOR_INTERN(intern_flag, href);	/* '#' */
d2872 4
a2875 3
		    (isFTP_URL(me->node_anchor->address) ||
		     isFILE_URL(me->node_anchor->address))) {
		    for (i = 0; (href[i] = href[i + 7]) != 0; i++) ;
d2879 1
a2879 1
	    if (present[HTML_A_ISMAP])	/*??? */
d2895 3
a2897 3
		 * Found TYPE="internal link" but not in a valid context
		 * where we have written it. - kw
		 */
d2899 1
a2899 1
			href, temp));
d2904 6
a2909 7
	me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						 id_string,	/* Tag */
						 href,	/* Address */
						 (temp
						  ? (HTLinkType *)
						  HTAtom_for(temp)
						  : INTERN_LT));	/* Type */
d2929 4
a2932 4
		 * Set up to load the anchor's chartrans structures
		 * appropriately for the current display character set if it
		 * can handle what's claimed.  - FM
		 */
d2937 1
a2937 1
		    dest_char_set = UCLYhndl_for_unrec;
d2941 3
a2943 2
		dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		    );
d2953 5
a2957 4
		 * Load the anchor's chartrans structures.  This should be done
		 * more intelligently when setting up the structured object,
		 * but it gets the job done for now.  - FM
		 */
d2976 3
a2978 3
	 * Close an HREF-less NAMED-ed now if we aren't making their content
	 * bold, and let the check in HTML_end_element() deal with any dangling
	 * end tag this creates.  - FM
d2986 1
a2986 1
	   requested - VH */
d2995 1
a2995 1
    case HTML_IMG:		/* Images */
d2997 4
a3000 3
	 * If we're in an anchor, get the destination, and if it's a clickable
	 * image for the current anchor, set our flags for faking a 0,0
	 * coordinate pair, which typically returns the image's default.  - FM
d3003 3
a3005 2
	    if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		 )) != NULL) {
d3009 1
a3009 1
			    dest->address));
d3014 1
a3014 1
			    dest->address));
d3021 1
a3021 1
	 * If there's a USEMAP, resolve it.  - FM
d3026 1
a3026 1
	    CHECK_FOR_INTERN(intern_flag, map_href);
d3029 2
a3030 2
	     * If map_href ended up zero-length or otherwise doesn't have a
	     * hash, it can't be valid, so ignore it.  - FM
d3038 1
a3038 1
	 * Handle a MAP reference if we have one at this point.  - FM
d3042 2
a3043 7
	     * If the MAP reference doesn't yet begin with a scheme, check
	     * whether a base tag is in effect.  - FM
	     */
	    /*
	     * If the USEMAP value is a lone fragment and LYSeekFragMAPinCur is
	     * set, we'll use the current document's URL for resolving. 
	     * Otherwise use the BASE.  - kw
d3045 6
d3052 2
a3053 2
		    !(*map_href == '#' && LYSeekFragMAPinCur == TRUE)) ?
		me->base_href : me->node_anchor->address;
d3057 1
a3057 1
	     * Prepend our client-side MAP access field.  - FM
d3066 2
a3067 2
	 * Check whether we want to suppress the server-side ISMAP link if a
	 * client-side MAP is present.  - FM
d3075 1
a3075 1
	 * Check for a TITLE attribute.  - FM
d3089 3
a3091 3
	 * If there's an ALT string, use it, unless the ALT string is
	 * zero-length or just spaces and we are making all SRCs links or have
	 * a USEMAP link.  - FM
d3102 2
a3103 2
	     * If it's all spaces and we are making SRC or USEMAP links, treat
	     * it as zero-length.  - FM
d3111 1
a3111 2
						  (temp = MakeNewMapValue(value,
									  "USEMAP"))));
d3115 1
a3115 2
						  (temp = MakeNewMapValue(value,
									  "ISMAP"))));
d3121 1
a3121 2
						  VERBOSE_IMG(value, HTML_IMG_SRC,
							      "[LINK]")));
d3125 5
a3129 6
				     (title ? title :
				      ((present &&
					present[HTML_IMG_ISOBJECT]) ?
				       "(OBJECT)" :
				       VERBOSE_IMG(value, HTML_IMG_SRC,
						   "[INLINE]"))));
d3136 1
a3136 1
				      (temp = MakeNewMapValue(value, "USEMAP"))));
d3142 1
a3142 1
				      (temp = MakeNewMapValue(value, "ISMAP"))));
d3148 1
a3148 2
				      VERBOSE_IMG(value, HTML_IMG_SRC,
						  "[LINK]")));
d3153 4
a3156 5
					  ((present &&
					    present[HTML_IMG_ISOBJECT]) ?
					   "(OBJECT)" :
					   VERBOSE_IMG(value, HTML_IMG_SRC,
						       "[INLINE]"))));
d3162 1
a3162 1
	    StrAllocCopy(alt_string, (temp = MakeNewMapValue(value, "USEMAP")));
d3167 3
a3169 3
		map_href ? 1 : 0,
		(dest_ismap == TRUE) ? 1 : 0,
		me->inA, me->inP));
d3172 1
a3172 1
	 * Check for an ID attribute.  - FM
d3184 1
a3184 1
	 * Create links to the SRC for all images, if desired.  - FM
d3193 2
a3194 2
	     * If it's an ISMAP and/or USEMAP, or graphic for an anchor, end
	     * that anchor and start one for the SRC.  - FM
d3198 2
a3199 2
		 * If we have a USEMAP, end this anchor and start a new one for
		 * the client-side MAP.  - FM
d3205 1
a3205 2
			HTML_put_string(me,
					(temp = MakeNewMapValue(value, "ISMAP")));
d3221 5
a3225 4
			if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							      id_string,	/* Tag */
							      NULL,	/* Addresss */
							      0)) != NULL) {	/* Type */
d3230 5
a3234 4
		    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							     NULL,	/* Tag */
							     map_href,	/* Addresss */
							     INTERN_LT);	/* Type */
d3236 3
a3238 2
			if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
			     )) != NULL) {
d3251 1
a3251 1
		    HTML_put_character(me, ' ');	/* space char may be ignored */
d3266 3
a3268 3
			      ((map_href || dest_ismap) ?
			       "(IMAGE)" : "(OBJECT)") :
			      VERBOSE_IMG(value, HTML_IMG_SRC, "[IMAGE]")));
d3270 5
a3274 4
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  id_string,	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
d3280 1
a3280 1
		HTML_put_character(me, ' ');	/* space char may be ignored */
d3283 5
a3287 4
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  id_string,	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
d3292 5
a3296 4
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 map_href,	/* Addresss */
							 INTERN_LT);	/* Type */
d3298 3
a3300 2
		    if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
			 )) != NULL) {
d3323 2
a3324 2
			      "(IMAGE)" :
			      VERBOSE_IMG(value, HTML_IMG_SRC, "[IMAGE]")));
d3326 1
a3326 1
		HTML_put_character(me, ' ');	/* space char may be ignored */
d3329 5
a3333 4
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  id_string,	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
d3341 1
a3341 1
	     * Create the link to the SRC.  - FM
d3343 5
a3347 4
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
d3360 1
a3360 1
		HTML_put_character(me, ' ');	/* space char may be ignored */
d3363 1
a3363 1
		HTML_put_character(me, ' ');	/* space char may be ignored */
d3370 2
a3371 2
		 * We're in an anchor and have a USEMAP, so end the anchor and
		 * start a new one for the client-side MAP.  - FM
d3374 1
a3374 1
		    HTML_put_character(me, ' ');	/* space char may be ignored */
d3376 1
a3376 1
		    HTML_put_string(me, (temp = MakeNewMapValue(value, "ISMAP")));
d3379 1
a3379 1
		    HTML_put_character(me, ' ');	/* space char may be ignored */
d3396 5
a3400 4
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     map_href,	/* Addresss */
						     INTERN_LT);	/* Type */
d3402 3
a3404 2
		if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		     )) != NULL) {
d3427 3
a3429 2
	     * Just put in the ALT or pseudo-ALT string for the current anchor
	     * or inline, with an ID link if indicated.  - FM
d3431 1
a3431 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
d3434 5
a3438 4
		if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						      id_string,	/* Tag */
						      NULL,	/* Addresss */
						      (HTLinkType *) 0)) != NULL) {	/* Type */
d3444 1
a3444 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
d3458 1
a3458 1
	 * Load id_string if we have a NAME or ID.  - FM
d3475 5
a3479 4
	 * Generate a target anchor in this place in the containing document. 
	 * MAP can now contain block markup, if it doesn't contain any AREAs
	 * (or A anchors with COORDS converted to AREAs) the current location
	 * can be used as a fallback for following a USEMAP link.  - kw
d3481 2
a3482 2
	if (!LYMapsOnly)
	    LYHandleID(me, id_string);
d3485 1
a3485 1
	 * Load map_address.  - FM
d3489 6
a3494 5
	     * The MAP must be in the current stream, even if it had a BASE
	     * tag, so we'll use its address here, but still use the BASE, if
	     * present, when resolving the AREA elements in it's content,
	     * unless the AREA's HREF is a lone fragment and
	     * LYSeekFragAREAinCur is set.  - FM && KW
d3522 1
a3522 1
	     * Resolve the HREF.  - FM
d3525 1
a3525 1
	    CHECK_FOR_INTERN(intern_flag, href);
d3529 5
a3533 4
	     * Check whether a BASE tag is in effect, and use it for resolving,
	     * even though we used this stream's address for locating the MAP
	     * itself, unless the HREF is a lone fragment and
	     * LYSeekFragAREAinCur is set.  - FM
d3536 2
a3537 2
		    !(*href == '#' && LYSeekFragAREAinCur == TRUE)) ?
		me->base_href : me->node_anchor->address;
d3541 1
a3541 1
	     * Check for an ALT.  - FM
d3547 1
a3547 1
		       value[HTML_AREA_TITLE] && *value[HTML_AREA_TITLE]) {
d3549 1
a3549 1
		 * Use the TITLE as an ALT.  - FM
d3558 1
a3558 1
		 * Make sure it's not just space(s).  - FM
d3567 1
a3567 1
		 * Use the HREF as an ALT.  - FM
d3581 3
a3583 2
	 * We may need to look at this someday to deal with MAPs, OBJECTs or
	 * APPLETs optimally, but just ignore it for now.  - FM
d3590 2
a3591 2
	 * We may need to look at this someday to deal with OBJECTs optimally,
	 * but just ignore it for now.  - FM
d3598 2
a3599 2
	 * We may need to look at this someday to deal with APPLETs optimally,
	 * but just ignore it for now.  - FM
d3622 3
a3624 2
	     * This is an outer OBJECT start tag, i.e., not a nested OBJECT, so
	     * save it's relevant attributes.  - FM
d3704 1
a3704 3
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&me->object_codetype,
						    TRUE,
						    FALSE);
d3723 11
a3733 11
	     * If we can determine now that we are not going to do anything
	     * special to the OBJECT element's SGML contents, like skipping it
	     * completely or collecting it up in order to add something after
	     * it, then generate any output that should be emitted in the place
	     * of the OBJECT start tag NOW, then don't initialize special
	     * handling but return, letting our SGML parser know that further
	     * content is to be parsed normally not literally.  We could defer
	     * this until we have collected the contents and then recycle the
	     * contents (as was previously always done), but that has a higher
	     * chance of completely losing content in case of nesting errors in
	     * the input, incomplete transmissions, etc.  - kw
d3748 1
a3748 1
				       : NULL,
d3757 1
a3757 1
			HTML_end_element(me, HTML_A, NULL);
d3763 7
a3769 7
		 * We do NOT want the HTML_put_* functions that are going to be
		 * called for the OBJECT's character content to add to the
		 * chunk, so we don't push on the stack.  Instead we keep a
		 * counter for open OBJECT tags that are treated this way, so
		 * HTML_end_element can skip handling the corresponding end tag
		 * that is going to arrive unexpectedly as far as our stack is
		 * concerned.
d3782 5
a3786 7
			    1,
			    1 || me->object_ismap,
			    me->object_id,
			    ((me->object_data && !me->object_classid)
			     ? value[HTML_OBJECT_DATA]
			     : NULL),
			    NO, TRUE, &intern_flag);
d3794 1
a3794 1
		 * Set flag that we are accumulating OBJECT content.  - FM
d3813 5
a3817 4
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 (HTLinkType *) 0);	/* Type */
d3839 1
a3839 1
	HTML_put_character(me, ' ');	/* space char may be ignored */
d3841 1
a3841 1
	 * Load id_string if we have an ID or NAME.  - FM
d3858 2
a3859 2
	 * If there's an ALT string, use it, unless the ALT string is
	 * zero-length and we are making all sources links.  - FM
d3866 1
a3866 1
					    me->UsePlainSpace, me->HiddenValue);
d3868 2
a3869 2
	     * If it's all spaces and we are making sources links, treat it as
	     * zero-length.  - FM
d3887 1
a3887 1
	 * If we're making all sources links, get the source.  - FM
d3891 1
a3891 1
	    char *base = NULL;
d3894 2
a3895 2
		? me->base_href
		: me->node_anchor->address;
d3897 1
a3897 1
	     * Check for a CODEBASE attribute.  - FM
d3905 1
a3905 1
		 * Force it to be a directory.  - FM
d3927 5
a3931 4
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 (HTLinkType *) 0);	/* Type */
d3944 1
a3944 1
		HTML_put_character(me, ' ');	/* space char may be ignored */
d3950 1
a3950 1
	     * Just put up the ALT string, if non-zero.  - FM
d3953 1
a3953 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
d3962 1
a3962 1
	 * If we're making all sources links, get the source.  - FM
d3979 1
a3979 1
		HTML_put_character(me, ' ');	/* space char may be ignored */
d3982 5
a3986 4
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
d3999 1
a3999 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
d4007 1
a4007 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
d4009 1
a4009 1
	 * Load id_string if we have an ID or NAME.  - FM
d4027 2
a4028 2
	 * If there's an ALT string, use it, unless the ALT string is
	 * zero-length and we are making all sources links.  - FM
d4035 1
a4035 1
					    me->UsePlainSpace, me->HiddenValue);
d4037 2
a4038 2
	     * If it's all spaces and we are making sources links, treat it as
	     * zero-length.  - FM
d4055 1
a4055 1
	 * If we're making all sources links, get the source.  - FM
d4068 5
a4072 4
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 (HTLinkType *) 0);	/* Type */
d4093 1
a4093 1
	     * Just put up the ALT string, if non-zero.  - FM
d4096 1
a4096 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
d4118 2
a4119 2
	     * Assume all text in the FIG container is intended to be
	     * paragraphed.  - FM
d4125 2
a4126 2
	     * Assume all text in the APPLET container is intended to be
	     * paragraphed.  - FM
d4150 2
a4151 2
	     * Assume all text in the FIG container is intended to be
	     * paragraphed.  - FM
d4157 2
a4158 2
	     * Assume all text in the APPLET container is intended to be
	     * paragraphed.  - FM
d4169 4
a4172 4
	    char *action = NULL;
	    char *method = NULL;
	    char *enctype = NULL;
	    const char *accept_cs = NULL;
d4174 1
a4174 1
	    HTChildAnchor *source;
d4178 6
a4183 5
	     * FORM may have been declared SGML_EMPTY in HTMLDTD.c, and
	     * SGML_character() in SGML.c may check for a FORM end tag to call
	     * HTML_end_element() directly (with a check in that to bypass
	     * decrementing of the HTML parser's stack), so if we have an open
	     * FORM, close that one now.  - FM
d4192 1
a4192 1
	     * Set to know we are in a new form.
d4199 1
a4199 1
		    value[HTML_FORM_ACCEPT_CHARSET] : "UNKNOWN";
d4203 2
a4204 2
		? me->base_href
		: me->node_anchor->address;
d4213 3
a4215 3
		 * Check whether a base tag is in effect.  Note that actions
		 * always are resolved w.r.t.  to the base, even if the action
		 * is empty.  - FM
d4224 3
a4226 3
					       NULL,
					       action,
					       (HTLinkType *) 0);
d4229 2
a4230 1
		 * Memory leak fixed.  05-28-94 Lynx 2-3-1 Garrett Arch Blythe
d4232 1
a4232 2
		char *cp_freeme = HTAnchor_address(link_dest);

d4243 1
a4243 1
			     value[HTML_FORM_METHOD] : "GET");
d4253 2
a4254 2
		 * Check for a TITLE attribute, and if none is present, check
		 * for a SUBJECT attribute as a synonym.  - FM
d4311 5
a4315 19
	    I.align = NULL;
	    I.accept = NULL;
	    I.checked = NO;
	    I.class = NULL;
	    I.disabled = NO;
	    I.error = NULL;
	    I.height = NULL;
	    I.id = NULL;
	    I.lang = NULL;
	    I.max = NULL;
	    I.maxlength = NULL;
	    I.md = NULL;
	    I.min = NULL;
	    I.name = NULL;
	    I.size = NULL;
	    I.src = NULL;
	    I.type = NULL;
	    I.value = NULL;
	    I.width = NULL;
d4326 1
a4326 1
		 * It's a button for submitting or resetting a form.  - FM
d4331 1
a4331 1
		 * Ugh, it's a button for a script.  - FM
d4333 1
a4333 1
		HTML_put_string(me, " [BUTTON] ");
d4338 1
a4338 1
	     * Make sure we're in a form.
d4345 2
a4346 2
		 * We'll process it, since the chances of a crash are small,
		 * and we probably do have a form started.  - FM
d4348 1
a4348 1
		 break;
d4353 7
a4359 6
	     * Before any input field, add a collapsible space if we're not in
	     * a PRE block, to promote a wrap there for any long values that
	     * would extend past the right margin from our current position in
	     * the line.  If we are in a PRE block, start a new line if the
	     * last line already is within 6 characters of the wrap point for
	     * PRE blocks.  - FM
d4385 1
a4385 1
		 * Convert any HTML entities or decimal escaping.  - FM
d4395 2
a4396 2
		 * Convert any newlines or tabs to spaces, and trim any lead or
		 * trailing spaces.  - FM
d4409 1
a4409 1
	    if (present && present[HTML_BUTTON_CLASS] &&	/* Not yet used. */
d4419 1
a4419 1
	    if (present && present[HTML_BUTTON_LANG] &&		/* Not yet used. */
d4425 8
a4432 7
	     * Submit and reset buttons have values which don't change, so
	     * HText_beginInput() sets I.value to the string which should be
	     * displayed, and we'll enter that instead of underscore
	     * placeholders into the HText structure to see it instead of
	     * underscores when dumping or printing.  We also won't worry about
	     * a wrap in PRE blocks, because the line editor never is invoked
	     * for submit or reset buttons.  - LE & FM
d4435 1
a4435 1
		!me->sp->style->freeFormat) {
d4437 7
a4443 6
		 * We have a submit or reset button in a PRE block, so output
		 * the entire value from the markup.  If it extends to the
		 * right margin, it will wrap there, and only the portion
		 * before that wrap will be hightlighted on screen display
		 * (Yuk!) but we may as well show the rest of the full value on
		 * the next or more lines.  - FM
d4449 16
a4464 13
		 * The submit or reset button is not in a PRE block.  Note that
		 * if a wrap occurs before outputting the entire value, the
		 * wrapped portion will not be highlighted or clearly indicated
		 * as part of the link for submission or reset (Yuk!).  We'll
		 * replace any spaces in the submit or reset button value with
		 * nbsp, to promote a wrap at the space we ensured would be
		 * present before the start of the string, as when we use all
		 * underscores instead of the INPUT's actual value, but we
		 * could still get a wrap at the right margin, instead, if the
		 * value is greater than a line width for the current style. 
		 * Also, if chars somehow ended up longer than the length of
		 * the actual value (shouldn't have), we'll continue padding
		 * with nbsp up to the length of chars.  - FM
d4468 2
a4469 2
				       (char) (I.value[i] == ' ' ?
					       HT_NON_BREAK_SPACE : I.value[i]));
d4492 1
a4492 1
	    char *ImageSrc = NULL;
a4495 1

d4497 5
a4501 19
	    I.align = NULL;
	    I.accept = NULL;
	    I.checked = NO;
	    I.class = NULL;
	    I.disabled = NO;
	    I.error = NULL;
	    I.height = NULL;
	    I.id = NULL;
	    I.lang = NULL;
	    I.max = NULL;
	    I.maxlength = NULL;
	    I.md = NULL;
	    I.min = NULL;
	    I.name = NULL;
	    I.size = NULL;
	    I.src = NULL;
	    I.type = NULL;
	    I.value = NULL;
	    I.width = NULL;
d4509 7
a4515 6
	     * Before any input field, add a collapsible space if we're not in
	     * a PRE block, to promote a wrap there for any long values that
	     * would extend past the right margin from our current position in
	     * the line.  If we are in a PRE block, start a new line if the
	     * last line already is within 6 characters of the wrap point for
	     * PRE blocks.  - FM
d4527 1
a4527 1
	     * Get the TYPE and make sure we can handle it.  - FM
d4542 1
a4542 1
		     * Not yet implemented.
d4567 1
a4567 1
		     * Ugh, a button for a script.
d4569 1
a4569 1
		    HTML_put_string(me, "[BUTTON] ");
d4592 1
a4592 1
	     * Check if we're in a form.  - FM
d4599 2
a4600 2
		 * We'll process it, since the chances of a crash are small,
		 * and we probably do have a form started.  - FM
d4602 1
a4602 1
		 break;
d4609 1
a4609 1
	     * Check for an unclosed TEXTAREA.
d4617 1
a4617 1
	     * Check for an unclosed SELECT, try to close it if found.
d4628 1
a4628 1
	     * Handle the INPUT as for a FORM.  - FM
d4646 5
a4650 4
		 * This is a TYPE="image" using an ALT rather than VALUE
		 * attribute to indicate the link string for text clients or
		 * GUIs with image loading off, so set the flag to use that as
		 * if it were a VALUE attribute.  - FM
d4660 3
a4662 3
		       present && present[HTML_INPUT_SRC] &&
		       value[HTML_INPUT_SRC] && *value[HTML_INPUT_SRC] &&
		       I.type && !strcasecomp(I.type, "image")) {
d4665 4
a4668 3
		 * We have a TYPE="image" with a non-zero-length SRC attribute
		 * and want clickable images.  Make the SRC's value a link if
		 * it's still not zero-length legitimizing it.  - FM
d4677 5
a4681 4
		    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							     NULL,	/* Tag */
							     href,	/* Addresss */
							     (HTLinkType *) 0);		/* Type */
d4685 1
a4685 3
		    HTML_put_string(me, VERBOSE_IMG(value,
						    HTML_INPUT_SRC,
						    "[IMAGE]"));
d4695 1
a4695 3
	    CTRACE((tfp, "2.Ok, we're trying type=[%s] (present=%p)\n",
		    NONNULL(I.type),
		    present));
d4700 3
a4702 3
		 (*value[HTML_INPUT_VALUE] ||
		  (I.type && (!strcasecomp(I.type, "checkbox") ||
			      !strcasecomp(I.type, "radio")))))) {
d4705 1
a4705 1
		 * Convert any HTML entities or decimal escaping.  - FM
d4736 2
a4737 2
			      value[HTML_INPUT_ALT] :
			      value[HTML_INPUT_VALUE]));
d4742 7
a4748 7
		TRANSLATE_AND_UNESCAPE_ENTITIES6(&I_value,
						 ATTR_CS_IN,
						 I.value_cs,
						 (BOOL) (me->UsePlainSpace &&
							 !me->HiddenValue),
						 me->UsePlainSpace,
						 me->HiddenValue);
d4752 2
a4753 2
		     * Convert any newlines or tabs to spaces, and trim any
		     * lead or trailing spaces.  - FM
d4764 1
d4775 4
a4778 4
		 * We put up an [IMAGE] link and '-' for a TYPE="image" and
		 * didn't get a VALUE or ALT string, so fake a "Submit" value. 
		 * If we didn't put up a link, then HText_beginInput() will use
		 * "[IMAGE]-Submit".  - FM
d4782 1
a4782 1
	    } else if (ImageSrc) {
d4799 1
a4799 1
	    if (present && present[HTML_INPUT_ACCEPT_CHARSET]) {	/* Not yet used. */
d4801 1
a4801 1
		    value[HTML_INPUT_ACCEPT_CHARSET] : "UNKNOWN";
d4803 1
a4803 1
	    if (present && present[HTML_INPUT_ALIGN] &&		/* Not yet used. */
d4806 1
a4806 1
	    if (present && present[HTML_INPUT_CLASS] &&		/* Not yet used. */
d4809 1
a4809 1
	    if (present && present[HTML_INPUT_ERROR] &&		/* Not yet used. */
d4812 1
a4812 1
	    if (present && present[HTML_INPUT_HEIGHT] &&	/* Not yet used. */
d4815 1
a4815 1
	    if (present && present[HTML_INPUT_WIDTH] &&		/* Not yet used. */
d4823 1
a4823 1
	    if (present && present[HTML_INPUT_LANG] &&	/* Not yet used. */
d4826 1
a4826 1
	    if (present && present[HTML_INPUT_MD] &&	/* Not yet used. */
d4832 1
a4832 4
	    CTRACE((tfp,
		    "I.%s have %d chars, or something\n",
		    NONNULL(I.type),
		    chars));
d4835 8
a4842 7
	     * Submit and reset buttons have values which don't change, so
	     * HText_beginInput() sets I.value to the string which should be
	     * displayed, and we'll enter that instead of underscore
	     * placeholders into the HText structure to see it instead of
	     * underscores when dumping or printing.  We also won't worry about
	     * a wrap in PRE blocks, because the line editor never is invoked
	     * for submit or reset buttons.  - LE & FM
d4845 3
a4847 3
		(!strcasecomp(I.type, "submit") ||
		 !strcasecomp(I.type, "reset") ||
		 !strcasecomp(I.type, "image")))
d4853 3
a4855 2
		 * Put a (_) placeholder, and one space (collapsible) before
		 * the label that is expected to follow.  - FM
d4867 1
a4867 1
		       !strcasecomp(I.type, "checkbox")) {
d4869 3
a4871 2
		 * Put a [_] placeholder, and one space (collapsible) before
		 * the label that is expected to follow.  - FM
d4887 14
a4900 12
		 * This is not a submit or reset button, and we are in a PRE
		 * block with a field intended to exceed 6 character widths. 
		 * The code inadequately handles INPUT fields in PRE tags if
		 * wraps occur (at the right margin) for the underscore
		 * placeholders.  We'll put up a minimum of 6 underscores,
		 * since we should have wrapped artificially, above, if the
		 * INPUT begins within 6 columns of the right margin, and if
		 * any more would exceed the wrap column, we'll ignore them. 
		 * Note that if we somehow get tripped up and a wrap still does
		 * occur before all 6 of the underscores are output, the
		 * wrapped ones won't be treated as part of the editing window,
		 * nor be highlighted when not editing (Yuk!).  - FM
d4913 3
a4915 2
		 * This is not a submit or reset button, so output the rest of
		 * the underscore placeholders, if any more are needed.  - FM
d4932 7
a4938 6
		     * We have a submit or reset button in a PRE block, so
		     * output the entire value from the markup.  If it extends
		     * to the right margin, it will wrap there, and only the
		     * portion before that wrap will be hightlighted on screen
		     * display (Yuk!) but we may as well show the rest of the
		     * full value on the next or more lines.  - FM
d4944 16
a4959 14
		     * The submit or reset button is not in a PRE block.  Note
		     * that if a wrap occurs before outputting the entire
		     * value, the wrapped portion will not be highlighted or
		     * clearly indicated as part of the link for submission or
		     * reset (Yuk!).  We'll replace any spaces in the submit or
		     * reset button value with nbsp, to promote a wrap at the
		     * space we ensured would be present before the start of
		     * the string, as when we use all underscores instead of
		     * the INPUT's actual value, but we could still get a wrap
		     * at the right margin, instead, if the value is greater
		     * than a line width for the current style.  Also, if chars
		     * somehow ended up longer than the length of the actual
		     * value (shouldn't have), we'll continue padding with nbsp
		     * up to the length of chars.  - FM
d4963 1
a4963 1
					   (char) (I.value[i] == ' '
d4986 1
a4986 1
	 * Make sure we're in a form.
d4990 1
a4990 2
		CTRACE((tfp,
			"Bad HTML: TEXTAREA start tag not within FORM tag\n"));
d4992 1
a4992 1
	     * Too likely to cause a crash, so we'll ignore it.  - FM
d4998 1
a4998 1
	 * Set to know we are in a textarea.
d5003 1
a5003 1
	 * Get ready for the value.
a5033 1

d5035 2
a5036 2
		me->new_style->leftIndent - me->new_style->rightIndent;
	    if (dump_output_immediately)	/* don't waste too much for this */
d5038 1
a5038 1
	    if (width > 1 && (width - 1) * 6 < MAX_LINE - 3 -
d5062 5
a5066 4
		(ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						  id_string,	/* Tag */
						  NULL,		/* Addresss */
						  (HTLinkType *) 0))) {		/* Type */
d5081 1
a5081 1
	 * Check for an already open SELECT block.  - FM
d5085 1
a5085 2
		CTRACE((tfp,
			"Bad HTML: SELECT start tag in SELECT element.  Faking SELECT end tag. *****\n"));
d5096 1
a5096 1
		       present, (const char **) value,
d5104 1
a5104 1
	     * An option is a special case of an input field.
d5109 1
a5109 1
	     * Make sure we're in a select tag.
d5113 1
a5113 2
		    CTRACE((tfp,
			    "Bad HTML: OPTION tag not within SELECT tag\n"));
d5116 1
a5116 1
		 * Too likely to cause a crash, so we'll ignore it.  - FM
d5123 1
a5123 1
		 * Finish the data off.
d5128 1
a5128 1
		 * Finish the previous option @@@@@@@@@@
d5140 3
a5142 3
	     * If it's not a multiple option list and select popups are
	     * enabled, then don't use the checkbox/button method, and don't
	     * put anything on the screen yet.
d5150 1
a5150 1
		     * Start a newline before each option.
d5155 1
a5155 1
		     * Add option list designation character.
d5162 1
a5162 1
		 * Inititialize.
d5164 5
a5168 19
		I.align = NULL;
		I.accept = NULL;
		I.checked = NO;
		I.class = NULL;
		I.disabled = NO;
		I.error = NULL;
		I.height = NULL;
		I.id = NULL;
		I.lang = NULL;
		I.max = NULL;
		I.maxlength = NULL;
		I.md = NULL;
		I.min = NULL;
		I.name = NULL;
		I.size = NULL;
		I.src = NULL;
		I.type = NULL;
		I.value = NULL;
		I.width = NULL;
d5178 1
a5178 1
		    I.checked = YES;
d5183 1
a5183 1
		     * Convert any HTML entities or decimal escaping.  - FM
d5188 4
a5191 4
						     ATTR_CS_IN,
						     ATTR_CS_IN,
						     NO,
						     me->UsePlainSpace, me->HiddenValue);
d5199 2
a5200 2
		    (present && present[HTML_OPTION_DISABLED]))
		    I.disabled = YES;
d5204 5
a5208 4
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  value[HTML_OPTION_ID],	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
d5219 3
a5221 2
		     * Put a "[_]" placeholder, and one space (collapsible)
		     * before the label that is expected to follow.  - FM
d5227 1
a5227 1
		    HText_setLastChar(me->text, ' ');	/* absorb white space */
d5231 3
a5233 2
		     * Put a "(_)" placeholder, and one space (collapsible)
		     * before the label that is expected to follow.  - FM
d5239 1
a5239 1
		    HText_setLastChar(me->text, ' ');	/* absorb white space */
d5245 1
a5245 1
	     * Get ready for the next value.
d5260 1
a5260 1
		     * Convert any HTML entities or decimal escaping.  - FM
d5265 4
a5268 4
						     ATTR_CS_IN,
						     ATTR_CS_IN,
						     NO,
						     me->UsePlainSpace, me->HiddenValue);
d5277 2
a5278 2
	     * If this is a popup option, print its option for use in selecting
	     * option by number.  - LE
d5287 1
a5287 1
		    sprintf(marker, "(%d)", opnum);
d5300 4
a5303 3
	 * Not fully implemented.  Just treat as a division with respect to any
	 * ALIGN attribute, with a default of HT_LEFT, or leave as a PRE block
	 * if we are presently in one.  - FM
d5305 3
a5307 2
	 * Also notify simple table tracking code unless in a preformatted
	 * section, or (currently) non-left alignment.
d5309 4
a5312 3
	 * If page author is using a TABLE within PRE, it's probably formatted
	 * specifically to work well for Lynx without simple table tracking
	 * code.  Cancel tracking, it would only make things worse.  - kw
d5317 1
a5317 1
	    HText_cancelStbl(me->text);
d5337 1
a5337 1
		    "HTML: ****** Maximum nesting of %d divisions/tables exceeded!\n",
d5348 1
a5348 1
			styles[HTML_DLEFT]->alignment;
d5354 1
a5354 1
			styles[HTML_DCENTER]->alignment;
d5387 4
a5390 3
	 * Not fully implemented.  Just start a new row, if needed, act on an
	 * ALIGN attribute if present, and check for an ID link.  - FM
	 * Also notify simple table tracking code.  - kw
d5402 1
a5402 1
	    HText_setLastChar(me->text, ' ');	/* absorb white space */
d5419 1
a5419 1
	    me->sp->style->alignment = HT_LEFT;
d5452 1
a5452 1
	 * Not fully implemented.  Just check for an ID link.  - FM
d5482 1
a5482 1
	 * Not fully implemented.  Just check for an ID link.  - FM
a5494 1

d5510 1
a5510 1
			       (BOOL) (ElementNumber == HTML_COLGROUP));
d5528 2
a5529 2
	 * Not fully implemented.  Just add a collapsible space and break - FM
	 * Also notify simple table tracking code.  - kw
a5533 1

d5553 1
a5553 1
			      (BOOL) (ElementNumber == HTML_TH));
d5560 2
a5561 2
	 * We're getting it as Literal text, which, until we can process it,
	 * we'll display as is, within brackets to alert the user.  - FM
d5570 1
a5570 1
    }				/* end switch */
d5576 2
a5577 2
		    "HTML:begin_element: internal call (level %d), leaving on stack - `%s'\n",
		    me->skip_stack, NONNULL(me->sp->style->name)));
d5592 4
a5595 5
	CTRACE((tfp,
		"HTML:begin_element[%d]: adding style to stack - %s (%s)\n",
		(int) STACKLEVEL(me),
		NONNULL(me->new_style->name),
		HTML_dtd.tags[ElementNumber].name));
d5601 1
a5601 1
	    HTML_dtd.tags[ElementNumber].can_justify == FALSE)
d5605 1
d5616 2
a5617 1
    if (ReallyEmptyTagNum(element_number)) {
d5634 17
a5650 15
 *		-----------
 *
 *	When we end an element, the style must be returned to that
 *	in effect before that element.	Note that anchors (etc?)
 *	don't have an associated style, so that we must scan down the
 *	stack for an element with a defined style. (In fact, the styles
 *	should be linked to the whole stack not just the top one.)
 *	TBL 921119
 *
 *	We don't turn on "CAREFUL" check because the parser produces
 *	(internal code errors apart) good nesting.  The parser checks
 *	incoming code errors, not this module.
 */
static int HTML_end_element(HTStructured * me, int element_number,
			    char **include)
d5663 1
a5663 1
	    HTTag *tag = &HTML_dtd.tags[element_number];
d5665 1
a5665 1
	    int tag_charset = 0;
d5667 2
a5668 4
	    psrc_nested_call = TRUE;
	    PSRCSTART(abracket);
	    PUTS("</");
	    PSRCSTOP(abracket);
d5670 1
a5670 1
	    if (tagname_transform != 0)
d5673 1
a5673 1
		LYstrncpy(buf, tag->name, sizeof(buf) - 1);
d5678 2
a5679 4
	    PSRCSTART(abracket);
	    PUTC('>');
	    PSRCSTOP(abracket);
	    psrc_nested_call = FALSE;
d5682 1
a5682 1
	/*fall through */
d5692 3
a5694 3
		(me->sp == me->stack + MAX_NESTING - 1) ? "none" :
		(me->sp->tag_number < 0) ? "*invalid tag*" :
		(me->sp->tag_number >= HTML_ELEMENTS) ? "special tag" :
d5697 1
a5697 1
	/* panic */
d5702 2
a5703 2
     * If we're seeking MAPs, skip everything that's not a MAP or AREA tag.  -
     * FM
d5713 2
a5714 2
     * Pop state off stack if we didn't declare the element SGML_EMPTY in
     * HTMLDTD.c.  - FM & KW
d5733 3
a5735 2
	     * Set the break flag if we're popping a dummy HTML_LH substituted
	     * for an HTML_H# encountered in a list.
d5745 2
a5746 3
		    (tfp,
		     "HTML:end_element: Internal call (level %d), leaving on stack - %s\n",
		     me->skip_stack, NONNULL(me->sp->style->name)));
d5753 1
a5753 1
		     me->sp[0].tag_number == HTML_FIG)) {
d5755 3
a5757 3
	     * Ignore non-corresponding OBJECT tags that we didn't push because
	     * the SGML parser was supposed to go on parsing the contents
	     * non-literally.  - kw
d5761 4
a5764 4
		     (int) STACKLEVEL(me),
		     "Special OBJECT handling", me->objects_mixed_open,
		     "leaving on stack",
		     NONNULL(me->sp->style->name)));
d5767 1
a5767 1
		   element_number != me->sp[0].tag_number) {
d5769 9
a5777 6
	     * Ignore non-corresponding tags if we had a stack overrun.  This
	     * is not a completely fail-safe strategy for protection against
	     * any seriously adverse consequences of a stack overrun, and the
	     * rendering of the document will not be as intended, but we expect
	     * overruns to be rare, and this should offer reasonable protection
	     * against crashes if an overrun does occur.  - FM
d5779 1
a5779 1
	    return HT_OK;	/* let's pretend... */
d5781 1
a5781 1
		   me->sp[0].tag_number != HTML_SELECT) {
d5783 4
a5786 3
	     * Ignore non-corresponding SELECT tags, since we probably popped
	     * it and closed the SELECT block to deal with markup which amounts
	     * to a nested SELECT, or an out of order FORM end tag.  - FM
d5790 12
a5801 12
		   HTML_dtd.tags[HTML_LH].contents == SGML_EMPTY &&
		   (me->sp[0].tag_number == HTML_UL ||
		    me->sp[0].tag_number == HTML_OL ||
		    me->sp[0].tag_number == HTML_MENU ||
		    me->sp[0].tag_number == HTML_DIR ||
		    me->sp[0].tag_number == HTML_LI) &&
		   (element_number == HTML_H1 ||
		    element_number == HTML_H2 ||
		    element_number == HTML_H3 ||
		    element_number == HTML_H4 ||
		    element_number == HTML_H6 ||
		    element_number == HTML_H6)) {
d5803 3
a5805 2
	     * It's an H# for which we substituted an HTML_LH, which we've
	     * declared as SGML_EMPTY, so just return.  - FM
d5817 3
a5819 3
		     * It's an OBJECT for which we substituted a FIG, so pop
		     * the FIG and pretend that's what we are being called for. 
		     * - kw
d5822 6
a5827 7
			    (tfp,
			     "HTML:end_element[%d]: %s (level %d), %s - %s\n",
			     (int) STACKLEVEL(me),
			     "Special OBJECT->FIG handling",
			     me->objects_figged_open,
			     "treating as end FIG",
			     NONNULL(me->sp->style->name)));
d5834 3
a5836 4
		    (tfp,
		     "HTML:end_element[%d]: Popped style off stack - %s\n",
		     (int) STACKLEVEL(me),
		     NONNULL(me->sp->style->name)));
d5839 1
a5839 1
				  "Stack underflow error!  Tried to pop off more styles than exist in stack\n"));
d5844 2
a5845 2
	if (reached_awaited_stacked_elt)
	    wait_for_this_stacked_elt = -1;
d5847 1
a5847 1
	return HT_OK;		/* let's pretend... */
d5851 1
a5851 1
     * Check for unclosed TEXTAREA.  - FM
d5863 1
a5863 1
     * Handle the end tag.  - FM
d5865 1
a5865 1
    switch (element_number) {
d5875 1
a5875 3
			(((me->inSELECT || me->inTEXTAREA) && me->inA)
			 ? ", "
			 : ""),
d5884 6
a5889 5
	    /* If we are parsing the List Page, and have a BASE after we are
	     * done with the HEAD element, propagate it back to the node_anchor
	     * object.  The base should have been inserted by showlist() to
	     * record what document the List Page is about, and other functions
	     * may later look for it in the anchor.  - kw
d5902 9
a5910 7
	 * Check if it's a bookmark file, and if so, and multiple bookmark
	 * support is on, or it's off but this isn't the default bookmark file
	 * (e.g., because it was on before, and this is another bookmark file
	 * that has been retrieved as a previous document), insert the current
	 * description string and filepath for it.  We pass the strings back to
	 * the SGML parser so that any 8 bit or multibyte/CJK characters will
	 * be handled by the parser's state and charset routines.  - FM
d5928 1
a5928 1
				      MBM_A_subdescript[i] : gettext("(none)")));
d5936 2
a5937 3
				       *MBM_A_subbookmark[i])
				      ? MBM_A_subbookmark[i]
				      : gettext("(unknown)")));
d5951 2
a5952 2
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
d5957 1
a5957 1
		 me->style_block.data));
d5963 2
a5964 2
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
d5968 1
a5968 1
		me->script.data));
d5980 1
a5980 3
			(((me->inSELECT || me->inTEXTAREA) && me->inA)
			 ? ", "
			 : ""),
d5986 1
a5986 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d5993 1
a5993 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6001 5
a6005 4
	/*
	 * Set flag to know that style has ended.  Fall through.
	 i_prior_style = -1;
	 */
d6024 1
a6024 1
		    me->DivisionAlignments[me->Division_Level];
d6037 1
a6037 1
    case HTML_H1:		/* header styles */
d6045 1
a6045 1
		me->DivisionAlignments[me->Division_Level];
d6072 3
a6074 3
		      (const BOOL *) 0, (const char **) 0,
		      include, 0,
		      FALSE);
d6081 1
a6081 1
    case HTML_B:		/* Physical character highlighting */
d6086 1
a6086 1
    case HTML_CITE:		/* Logical character highlighting */
d6090 2
a6091 2
	 * Ignore any emphasis end tags if the Underline_Level is not set.  -
	 * FM
d6097 2
a6098 2
	 * Adjust the Underline level counter, and turn off underlining if
	 * appropriate.  - FM
d6110 1
a6110 1
    case HTML_ABBREV:		/* Miscellaneous character containers */
d6157 5
a6161 4
	 * Should check LANG and/or DIR attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * to determine whether we should use chevrons, but for now we'll
	 * always use double- or single-quotes.  - FM
d6169 1
a6169 1
    case HTML_PRE:		/* Formatted text */
d6171 1
a6171 1
	 * Set to know that we are no longer in a PRE block.
d6175 1
a6175 1
    case HTML_LISTING:		/* Literal text */
d6182 1
a6182 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6191 1
a6191 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6202 1
a6202 1
		       me->List_Nesting_Level : 11] = OL_VOID;
d6213 1
a6213 1
		me->List_Nesting_Level));
d6216 1
a6216 1
	    in_DT = FALSE;	/*close the term that was without definition. */
d6218 1
a6218 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6226 3
a6228 3
	 * Should undo anything we did based on LANG and/or DIR attributes, and
	 * the me->node_anchor->charset and/or yet to be added structure
	 * elements.  - FM
d6234 3
a6236 3
	 * Should undo anything we did based on DIR (and/or LANG) attributes,
	 * and the me->node_anchor->charset and/or yet to be added structure
	 * elements.  - FM
d6242 1
a6242 1
	 * Ignore any spurious A end tags.  - FM
d6247 1
a6247 1
	 * Set to know that we are no longer in an anchor.
d6252 2
a6253 2
	    HText_isAnchorBlank(me->text, me->CurrentANum)) {
	    HText_appendText(me->text, hidden_link_marker);
d6274 2
a6275 2
	 * We may need to look at this someday to deal with OBJECTs optimally,
	 * but just ignore it for now.  - FM
d6277 1
a6277 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6282 2
a6283 2
	 * We may need to look at this someday to deal with APPLETs optimally,
	 * but just ignore it for now.  - FM
d6285 1
a6285 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6298 1
a6298 1
	 * Finish the data off.
d6311 4
a6314 3
		 * Look for nested OBJECTs.  This procedure could get tripped
		 * up if invalid comments are present in the content, or if an
		 * OBJECT end tag is present in a quoted attribute.  - FM
d6320 1
a6320 1
			   !IsNmChar(cp[6])) {
d6323 1
a6323 1
			   !IsNmChar(cp[7])) {
d6328 1
a6328 1
			   !IsNmChar(cp[8])) {
d6334 1
a6334 1
			   !IsNmChar(cp[4])) {
d6339 1
a6339 1
			   !IsNmChar(cp[5])) {
d6346 2
a6347 2
		 * We had more end tags than start tags, so we have bad HTML or
		 * otherwise misparsed.  - FM
d6350 1
a6350 2
		    CTRACE((tfp,
			    "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content:\n%s\n",
d6365 11
a6375 11
		     * We have nested OBJECT tags, and not yet all of the end
		     * tags, but have a case where the content needs to be
		     * parsed again (not dropped) and where we don't want to
		     * output anything special at the point when we
		     * *do* have accumulated all the end tags.  So recycle
		     * the incomplete contents now, and signal the SGML parser
		     * that it should not regard the current OBJECT ended but
		     * should treat its contents as mixed.  Normally these
		     * cases would have already handled in the real
		     * start_element call, so this block may not be necessary. 
		     * - kw
d6378 2
a6379 2
			    "HTML: Nested OBJECT tags.  Recycling incomplete contents",
			    me->object.data));
d6388 1
a6388 1
		    HTML_start_element(me, HTML_OBJECT, NULL, NULL,
d6393 6
a6398 6
		 * We have nested OBJECT tags, and not yet all of the end tags,
		 * and we want the end tags.  So restore an end tag to the
		 * content, and signal to the SGML parser that it should resume
		 * the accumulation of OBJECT content (after calling back to
		 * start_element) in a way that is equivalent to passing it a
		 * dummy start tag.  - FM, kw
d6410 3
a6412 2
	     * OBJECT start and end tags are fully matched, assuming we weren't
	     * tripped up by comments or quoted attributes.  - FM
d6417 6
a6422 4
	     * OBJECTs with DECLARE should be saved but not instantiated, and
	     * if nested, can have only other DECLAREd OBJECTs.  Until we have
	     * code to handle these, we'll just create an anchor for the ID, if
	     * present, and discard the content (sigh 8-).  - FM
d6432 4
a6435 3
	     * OBJECTs with NAME are for FORM submissions.  We'll just create
	     * an anchor for the ID, if present, and discard the content until
	     * we have code to handle these.  (sigh 8-).  - FM
d6445 2
a6446 2
	     * Deal with any nested OBJECTs by descending to the inner-most
	     * OBJECT.  - FM
d6452 3
a6454 3
		     * Minumum requirements for the ad hoc parsing to have
		     * succeeded are met.  We'll hope that it did succeed.  -
		     * FM
d6458 5
a6462 5
			 * Well we don't need to do this any more, nested
			 * objects should either not get here any more at all
			 * or can be handled fine by other code below.  Leave
			 * in place for now as a special case for LYMapsOnly. 
			 * - kw
d6482 1
a6482 1
				(s > 1) ? "s" : ""));
d6488 1
a6488 2
			CTRACE((tfp,
				"Bad HTML: Unmatched OBJECT start and end tags.  Discarding content.\n"));
d6494 1
a6494 1
	     * If its content has SHAPES, convert it to FIG.  - FM
d6496 3
a6498 3
	     * This is now handled in our start_element without using include
	     * if the SGML parser cooperates, so this block may be unnecessary. 
	     * - kw
d6527 2
a6528 2
	     * If it has a USEMAP attribute and didn't have SHAPES, convert it
	     * to IMG.  - FM
d6538 1
a6538 1
		     * Pass the ID.  - FM
d6547 2
a6548 2
		     * We have DATA with no CLASSID, so let's hope it'
		     * equivalent to an SRC.  - FM
d6556 2
a6557 1
		     * Use the TITLE for both the MAP and the IMGs ALT.  - FM
d6566 1
a6566 1
		 * Add the USEMAP, and an ISMAP if present.  - FM
d6579 6
a6584 5
		 * Add the content if it has <MAP, since that may be the MAP
		 * this usemap points to.  But if we have nested objects, try
		 * to eliminate portions that cannot contribute to the quest
		 * for MAP.  This is not perfect, we may get too much content;
		 * this seems preferable over losing too much.  - kw
d6589 1
a6589 2
			CTRACE((tfp,
				"HTML: MAP found, recycling object contents.\n"));
d6620 2
a6621 2
			    "HTML: MAP and nested OBJECT tags.  Recycling parts",
			    data));
d6629 1
a6629 1
	     * Add an ID link if needed.  - FM
d6635 1
a6635 1
	     * Add the OBJECTs content if not empty.  - FM
d6644 6
a6649 4
	     * Create a link to the DATA, if desired, and we can rule out that
	     * it involves scripting code.  This a risky thing to do, but we
	     * can toggle clickable_images mode off if it really screws things
	     * up, and so we may as well give it a try.  - FM
d6659 6
a6664 5
		     * We have a DATA value and no need for scripting code, so
		     * close the current Anchor, if one is open, and add an
		     * Anchor for this source.  If we also have a TYPE value,
		     * check whether it's an image or not, and set the link
		     * name accordingly.  - FM
d6685 1
a6685 1
	 * Re-intialize all of the OBJECT elements.  - FM
d6687 1
a6687 1
      End_Object:
d6691 1
a6691 1
	    change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6698 1
a6698 1
	    HTML_put_character(me, ' ');	/* space char may be ignored */
d6703 1
a6703 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6710 1
a6710 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6718 1
a6718 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6724 4
a6727 3
	 * Check if we had a FORM start tag, and issue a message if not, but
	 * fall through to check for an open SELECT and ensure that the
	 * FORM-related globals in GridText.c are initialized.  - FM
d6736 9
a6744 7
	 * Check if we still have a SELECT element open.  FORM may have been
	 * declared SGML_EMPTY in HTMLDTD.c, and in that case SGML_character()
	 * in SGML.c is not able to ensure correct nesting; or it may have
	 * failed to enforce valid nesting.  If a SELECT is open, issue a
	 * message, then call HTML_end_element() directly (with a check in that
	 * to bypass decrementing of the HTML parser's stack) to close the
	 * SELECT.  - kw
d6748 1
a6748 2
		CTRACE((tfp,
			"Bad HTML: Open SELECT at FORM end. Faking SELECT end tag. *****\n"));
d6756 1
a6756 1
	 * Set to know that we are no longer in an form.
d6762 5
a6766 4
	 * If we are in a list and are on the first line with no text following
	 * a bullet or number, don't force a newline.  This could happen if we
	 * were called from HTML_start_element() due to a missing FORM end tag. 
	 * - FM
d6775 1
a6775 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6781 1
a6781 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d6797 1
a6797 1
	     * Make sure we had a textarea start tag.
d6806 1
a6806 1
	     * Set to know that we are no longer in a textarea tag.
d6811 1
a6811 1
	     * Initialize.
d6813 5
a6817 19
	    I.align = NULL;
	    I.accept = NULL;
	    I.checked = NO;
	    I.class = NULL;
	    I.disabled = NO;
	    I.error = NULL;
	    I.height = NULL;
	    I.id = NULL;
	    I.lang = NULL;
	    I.max = NULL;
	    I.maxlength = NULL;
	    I.md = NULL;
	    I.min = NULL;
	    I.name = NULL;
	    I.size = NULL;
	    I.src = NULL;
	    I.type = NULL;
	    I.value = NULL;
	    I.width = NULL;
d6822 1
a6822 1
	     * Before any input field add a space if necessary.
d6827 1
a6827 1
	     * Add a return.
d6832 1
a6832 1
	     * Finish the data off.
d6847 6
a6852 5
	     * Transform the TEXTAREA content as needed, then parse it into
	     * individual lines to be handled as a series series of INPUT
	     * fields (ugh!).  Any raw 8-bit or multibyte characters already
	     * have been handled in relation to the display character set in
	     * SGML_character().
d6854 4
a6857 4
	     * If TEXTAREA is handled as SGML_LITTERAL (the old way), we need
	     * to SGML-unescape any character references and NCRs here. 
	     * Otherwise this will already have happened in the SGML.c parsing. 
	     * - kw
d6869 13
a6881 10
		 * This shouldn't have anything to do, normally, but just in
		 * case...  There shouldn't be lynx special character codes in
		 * the chunk ("DTD" flag Tgf_nolyspcl tells SGML.c not to
		 * generate them).  If there were, we could set the last
		 * parameter ('Back') below to YES, which would take them out
		 * of the data.  The data may however contain non break space,
		 * soft hyphen, or en space etc., in the me->UCLYhndl character
		 * encoding.  If that's a problem, perhaps for the (line or
		 * other) editor, setting 'Back' to YES should also help to
		 * always convert them to plain spaces (or drop them).  - kw
d6884 5
a6888 5
				me->UCLYhndl,
				current_char_set,
				NO,
				me->UsePlainSpace, me->HiddenValue,
				NO);
d6893 2
a6894 1
	     * Trim any trailing newlines and skip any lead newlines.  - FM
d6906 2
a6907 1
	     * Load the first text line, or set up for all blank rows.  - FM
d6923 2
a6924 2
	     * Display at least the requested number of text lines and/or blank
	     * rows.  - FM
a6927 1

d6930 1
a6930 1
			temp[j] = (char) (temp[j + 1] ? ' ' : '\0');
d6955 3
a6957 3
	     * Check for more data lines than the rows attribute.  We add them
	     * to the display, because we support only horizontal and not also
	     * vertical scrolling.  - FM
a6960 1

d6963 1
a6963 1
			temp[j] = (char) (temp[j + 1] ? ' ' : '\0');
d7002 1
a7002 1
	     * Make sure we had a select start tag.
d7011 1
a7011 1
	     * Set to know that we are no longer in a select tag.
d7016 1
a7016 1
	     * Clear the disable attribute.
d7021 1
a7021 1
	     * Make sure we're in a form.
d7028 1
a7028 1
		 * Hopefully won't crash, so we'll ignore it.  - kw
d7033 1
a7033 1
	     * Finish the data off.
d7037 1
a7037 1
	     * Finish the previous option.
d7052 4
a7055 4
		/*
		 * Start a newline after the last checkbox/button option.
		 */
		LYEnsureSingleSpace(me);
d7058 2
a7059 2
		 * Output popup box with the default option to screen, but use
		 * non-breaking spaces for output.
d7066 3
a7068 3
		     * The code inadequately handles OPTION fields in PRE tags. 
		     * We'll put up a minimum of 6 characters, and if any more
		     * would exceed the wrap column, we'll ignore them.
d7072 1
a7072 1
			    HText_appendCharacter(me->text, HT_NON_BREAK_SPACE);
d7074 1
a7074 1
			    HText_appendCharacter(me->text, *ptr);
d7081 1
a7081 1
			HText_appendCharacter(me->text, HT_NON_BREAK_SPACE);
a7084 1

d7091 1
a7091 1
			HText_appendCharacter(me->text, *ptr);
d7099 1
a7099 1
		 * Add end option character.
d7127 1
a7127 1
	    me->inTABLE = FALSE;
d7136 1
a7136 1
		me->DivisionAlignments[me->Division_Level];
d7159 1
a7159 1
	    HText_setLastChar(me->text, ' ');	/* absorb next white space */
d7190 2
a7191 2
	 * We're getting it as Literal text, which, until we can process it,
	 * we'll display as is, within brackets to alert the user.  - FM
d7213 1
a7213 1
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
d7216 1
a7216 1
    }				/* switch */
d7219 2
a7220 2
    if (reached_awaited_stacked_elt)
	wait_for_this_stacked_elt = -1;
d7228 1
d7230 1
a7230 1
    if (!skip_stack_requested) {	/*don't emit stylechanges if skipped stack element - VH */
d7238 2
a7239 1
	if (!ReallyEmptyTagNum(element_number)) {
d7241 2
a7242 3
		    (tfp,
		     "STYLE.end_element: ending non-\"EMPTY\" style <%s...>\n",
		     HTML_dtd.tags[element_number].name));
d7251 2
a7252 2
 *		------------------
 */
d7255 1
a7255 1
int HTML_put_entity(HTStructured * me, int entity_number)
d7267 11
a7277 11
 *	-------------------
 *
 *	If the document is empty, the text object will not yet exist.
 *	So we could in fact abandon creating the document and return
 *	an error code.	In fact an empty document is an important type
 *	of document, so we don't.
 *
 *	If non-interactive, everything is freed off.   No: crashes -listrefs
 *	Otherwise, the interactive object is left.
 */
static void HTML_free(HTStructured * me)
d7283 4
a7286 3
	 * We only handled MAP, AREA and BASE tags, and didn't create an HText
	 * structure for the document nor want one now, so just make sure we
	 * free anything that might have been allocated.  - FM
d7301 7
a7307 6
	 * Emphasis containers, A, FONT, and FORM may be declared SGML_EMPTY in
	 * HTMLDTD.c, and SGML_character() in SGML.c may check for their end
	 * tags to call HTML_end_element() directly (with a check in that to
	 * bypass decrementing of the HTML parser's stack).  So if we still
	 * have the emphasis (Underline) on, or any open A, FONT, or FORM
	 * containers, turn it off or close them now.  - FM & kw
d7309 6
a7314 5
	 * IF those tags are not declared SGML_EMPTY, but we let the SGML.c
	 * parser take care of correctly stacked ordering, and of correct
	 * wind-down on end-of-stream (in SGML_free SGML_abort), THEN these and
	 * other checks here in HTML.c should not be necessary.  Still it can't
	 * hurt to include them.  - kw
d7337 3
a7339 3
	     * If we still have data in the me->option chunk after forcing a
	     * close of a still-open form, something must have gone very wrong. 
	     * - kw
d7346 2
a7347 2
	     * Output the left-over data as text, maybe it was invalid markup
	     * meant to be shown somewhere.  - kw
d7350 1
a7350 1
		    me->option.data));
d7356 3
a7358 3
	     * If we still have data in the me->textarea chunk after forcing a
	     * close of a still-open form, something must have gone very wrong. 
	     * - kw
d7365 2
a7366 2
	     * Output the left-over data as text, maybe it was invalid markup
	     * meant to be shown somewhere.  - kw
d7369 1
a7369 1
		    me->textarea.data));
d7374 3
a7376 3
	 * If we're interactive and have hidden links but no visible links, add
	 * a message informing the user about this and suggesting use of the
	 * 'l'ist command.  - FM
d7385 1
a7385 1
			    gettext("Document has only hidden links.  Use the 'l'ist command."));
d7397 1
a7397 1
	 * Now call the cleanup function.  - FM
d7403 3
a7405 2
	 * If we still have data in the me->option chunk after forcing a close
	 * of a still-open form, something must have gone very wrong.  - kw
d7413 1
a7413 1
		    me->option.data));
d7419 3
a7421 3
	 * If we still have data in the me->textarea chunk after forcing a
	 * close of a still-open form, something must have gone very wrong.  -
	 * kw
d7429 1
a7429 1
		    me->textarea.data));
d7435 1
a7435 1
	(*me->targetClass._free) (me->target);
d7445 1
a7445 1
	} else {
d7457 1
a7457 1
static void HTML_abort(HTStructured * me, HTError e)
d7463 2
a7464 2
	 * If we have emphasis on, or open A, FONT, or FORM containers, turn it
	 * off or close them now.  - FM
d7485 1
a7485 1
	 * Now call the cleanup function.  - FM
d7492 3
a7494 2
	 * If we still have data in the me->option chunk after forcing a close
	 * of a still-open form, something must have gone very wrong.  - kw
d7497 1
a7497 2
	    CTRACE((tfp,
		    "HTML_abort: SELECT or OPTION not ended properly *****\n"));
d7500 1
a7500 1
		    me->option.data));
d7506 3
a7508 3
	 * If we still have data in the me->textarea chunk after forcing a
	 * close of a still-open form, something must have gone very wrong.  -
	 * kw
d7514 1
a7514 1
		    me->textarea.data));
d7520 1
a7520 1
	(*me->targetClass._abort) (me->target, e);
d7530 1
a7530 1
	} else {
d7548 3
a7550 3
 *	---------------------------
 */
static void get_styles(void)
d7552 2
a7553 1
    HTStyle **st = NULL;
d7555 1
a7555 1
    styleSheet = DefaultStyle(&st);	/* sets st[] array */
d7557 22
a7578 24
    default_style = st[ST_Normal];

    styles[HTML_H1] = st[ST_Heading1];
    styles[HTML_H2] = st[ST_Heading2];
    styles[HTML_H3] = st[ST_Heading3];
    styles[HTML_H4] = st[ST_Heading4];
    styles[HTML_H5] = st[ST_Heading5];
    styles[HTML_H6] = st[ST_Heading6];
    styles[HTML_HCENTER] = st[ST_HeadingCenter];
    styles[HTML_HLEFT] = st[ST_HeadingLeft];
    styles[HTML_HRIGHT] = st[ST_HeadingRight];

    styles[HTML_DCENTER] = st[ST_DivCenter];
    styles[HTML_DLEFT] = st[ST_DivLeft];
    styles[HTML_DRIGHT] = st[ST_DivRight];

    styles[HTML_DL] = st[ST_Glossary];
    /* nested list styles */
    styles[HTML_DL1] = st[ST_Glossary1];
    styles[HTML_DL2] = st[ST_Glossary2];
    styles[HTML_DL3] = st[ST_Glossary3];
    styles[HTML_DL4] = st[ST_Glossary4];
    styles[HTML_DL5] = st[ST_Glossary5];
    styles[HTML_DL6] = st[ST_Glossary6];
d7581 8
a7588 8
	styles[HTML_OL] = st[ST_List];
    /* nested list styles */
    styles[HTML_OL1] = st[ST_List1];
    styles[HTML_OL2] = st[ST_List2];
    styles[HTML_OL3] = st[ST_List3];
    styles[HTML_OL4] = st[ST_List4];
    styles[HTML_OL5] = st[ST_List5];
    styles[HTML_OL6] = st[ST_List6];
d7591 24
a7614 24
	styles[HTML_DIR] = st[ST_Menu];
    /* nested list styles */
    styles[HTML_MENU1] = st[ST_Menu1];
    styles[HTML_MENU2] = st[ST_Menu2];
    styles[HTML_MENU3] = st[ST_Menu3];
    styles[HTML_MENU4] = st[ST_Menu4];
    styles[HTML_MENU5] = st[ST_Menu5];
    styles[HTML_MENU6] = st[ST_Menu6];

    styles[HTML_DLC] = st[ST_GlossaryCompact];
    /* nested list styles */
    styles[HTML_DLC1] = st[ST_GlossaryCompact1];
    styles[HTML_DLC2] = st[ST_GlossaryCompact2];
    styles[HTML_DLC3] = st[ST_GlossaryCompact3];
    styles[HTML_DLC4] = st[ST_GlossaryCompact4];
    styles[HTML_DLC5] = st[ST_GlossaryCompact5];
    styles[HTML_DLC6] = st[ST_GlossaryCompact6];

    styles[HTML_ADDRESS] = st[ST_Address];
    styles[HTML_BANNER] = st[ST_Banner];
    styles[HTML_BLOCKQUOTE] = st[ST_Blockquote];
    styles[HTML_BQ] = st[ST_Bq];
    styles[HTML_FN] = st[ST_Footnote];
    styles[HTML_NOTE] = st[ST_Note];
d7616 3
a7618 3
	styles[HTML_XMP] = st[ST_Example];
    styles[HTML_PRE] = st[ST_Preformatted];
    styles[HTML_LISTING] = st[ST_Listing];
d7625 1
a7625 1
HTStyle *LYstyles(int style_number)
d7636 3
a7638 3
 *	-----------------------
 */
const HTStructuredClass HTMLPresentation =	/* As opposed to print etc */
d7640 6
a7645 6
    "Lynx_HTML_Handler",
    HTML_free,
    HTML_abort,
    HTML_put_character, HTML_put_string, HTML_write,
    HTML_start_element, HTML_end_element,
    HTML_put_entity
d7649 9
a7657 8
 *		--------------------------
 *
 *	The structured stream can generate either presentation,
 *	or plain text, or HTML.
 */
HTStructured *HTML_new(HTParentAnchor *anchor,
		       HTFormat format_out,
		       HTStream *stream)
d7660 1
a7660 1
    HTStructured *me;
d7663 2
a7664 3
	HTStream *intermediate = HTStreamStack(WWW_HTML, format_out,
					       stream, anchor);

d7669 1
a7669 1
	exit_immediately(EXIT_FAILURE);
d7737 2
a7738 2
    me->sp->tag_number = -1;	/* INVALID */
    me->sp->style = default_style;	/* INVALID */
d7751 1
a7751 1
     * Used for nested lists.  - FM
d7753 4
a7756 4
    me->List_Nesting_Level = -1;	/* counter for list nesting level */
    LYZero_OL_Counter(me);	/* Initializes OL_Counter[] and OL_Type[] */
    me->Last_OL_Count = 0;	/* last count in ordered lists */
    me->Last_OL_Type = '1';	/* last type in ordered lists */
d7797 5
a7801 5
     * Create a chartrans stage info structure for the anchor, if it does not
     * exist already (in which case the default MIME stage info will be loaded
     * as well), and load the HTML stage info into me->UCI and me->UCLYhndl.  -
     * FM
     */
d7806 4
a7809 3
     * Load the existing or default input charset info into the holding
     * elements.  We'll believe what is indicated for UCT_STAGE_PARSER.  - FM
     */
d7823 5
a7827 4
     * Load the existing or default output charset info into the holding
     * elements, UCT_STAGE_STRUCTURED should be the same as UCT_STAGE_TEXT at
     * this point, but we could check, perhaps.  - FM
     */
d7835 1
a7835 1
	me->targetClass = *stream->isa;		/* Copy pointers */
d7837 1
a7837 1
    return (HTStructured *) me;
d7843 5
a7847 5
 * A flag set by a file write error.  Used for only generating an alert the
 * first time such an error happens, since Lynx should still be usable if the
 * temp space becomes full, and an alert each time a cache file cannot be
 * written would be annoying.  Reset when lynx.cfg is being reloaded (user may
 * change SOURCE_CACHE setting).  - kw
d7855 2
a7856 1
static void CacheThru_do_free(HTStream *me)
d7866 1
a7866 1
		(void *) me->anchor->source_cache_chunk));
d7879 1
a7879 1
		    me->filename, HTAnchor_address((HTAnchor *) me->anchor)));
d7901 1
a7901 1
		(void *) me->chunk, HTAnchor_address((HTAnchor *) me->anchor)));
d7905 2
a7906 1
static void CacheThru_free(HTStream *me)
d7909 1
a7909 1
    (*me->actions->_free) (me->target);
d7913 3
a7915 1
static void CacheThru_abort(HTStream *me, HTError e)
d7927 2
a7928 3
	    CTRACE((tfp,
		    "SourceCacheWriter: Removing active memory chunk %p\n",
		    (void *) me->chunk));
d7932 1
a7932 1
	me->status = HT_OK;	/*fake it */
d7935 1
a7935 1
    (*me->actions->_abort) (me->target, e);
d7939 3
a7941 1
static void CacheThru_put_character(HTStream *me, char c_in)
d7952 1
a7952 1
    (*me->actions->put_character) (me->target, c_in);
d7955 3
a7957 1
static void CacheThru_put_string(HTStream *me, const char *str)
d7968 1
a7968 1
    (*me->actions->put_string) (me->target, str);
d7971 4
a7974 2
static void CacheThru_write(HTStream *me, const char *str,
			    int l)
d7987 1
a7987 1
    (*me->actions->put_block) (me->target, str, l);
d8000 3
a8002 2
static HTStream *CacheThru_new(HTParentAnchor *anchor,
			       HTStream *target)
d8006 1
a8006 1
    HTProtocol *p = (HTProtocol *) anchor->protocol;
d8018 1
a8018 1
	&& strcmp(p->name, "https") != 0) {
d8041 1
a8041 2
	    CTRACE((tfp,
		    "SourceCacheWriter: If successful, will replace source cache file %s\n",
d8052 2
a8053 3
	    CTRACE((tfp,
		    "SourceCacheWriter: Cannot open source cache file for URL %s\n",
		    HTAnchor_address((HTAnchor *) anchor)));
d8060 2
a8061 3
	CTRACE((tfp,
		"SourceCacheWriter: Caching source for URL %s in file %s\n",
		HTAnchor_address((HTAnchor *) anchor), filename));
d8068 1
a8068 1
		    (void *) anchor->source_cache_chunk));
d8070 1
d8079 2
a8080 3
	CTRACE((tfp,
		"SourceCacheWriter: Caching source for URL %s in memory chunk %p\n",
		HTAnchor_address((HTAnchor *) anchor), (void *) stream->chunk));
d8091 11
a8101 10
 *	----------------------------------
 *
 *	This will convert from HTML to presentation or plain text.
 *
 *	It is registered in HTInit.c, but never actually used by lynx.
 *	- kw 1999-03-15
 */
HTStream *HTMLToPlain(HTPresentation *pres,
		      HTParentAnchor *anchor,
		      HTStream *sink)
d8109 14
a8122 13
 *	-----------------------------------------
 *
 *	This will preparse HTML and convert back to presentation or plain text.
 *
 *	It is registered in HTInit.c and used by lynx if invoked with
 *	-preparsed.  The stream generated here will be fed with HTML text,
 *	It feeds that to the SGML.c parser, which in turn feeds an HTMLGen.c
 *	structured stream for regenerating flat text; the latter should
 *	end up being handled as text/plain. - kw
 */
HTStream *HTMLParsedPresent(HTPresentation *pres,
			    HTParentAnchor *anchor,
			    HTStream *sink)
d8124 1
a8124 2
    HTStream *intermediate = sink;

d8127 4
a8130 4
	 * Trick to prevent HTPlainPresent from translating again.  Temporarily
	 * change UCT_STAGE_PARSER setting in anchor while the HTPlain stream
	 * is initialized, so that HTPlain sees its input and output charsets
	 * as the same.  - kw
d8132 2
a8133 3
	int old_parser_cset = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_PARSER);
	int structured_cset = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_STRUCTURED);

d8135 1
a8135 1
	    structured_cset = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_HTEXT);
d8141 4
a8144 4
	    /*  same effect as
	       intermediate = HTPlainPresent(pres, anchor, NULL);
	       just written in a more general way:
	     */
d8148 1
a8148 1
	    /*  this too should amount to calling HTPlainPresent: */
d8158 1
a8158 1
					UCT_SETBY_DEFAULT + 1);
d8170 13
a8182 12
 *	------------------------------
 *
 *	C code is like plain text but all non-preformatted code
 *	is commented out.
 *	This will convert from HTML to presentation or plain text.
 *
 *	It is registered in HTInit.c, but normally not used by lynx.
 *	- kw 1999-03-15
 */
HTStream *HTMLToC(HTPresentation *pres GCC_UNUSED,
		  HTParentAnchor *anchor,
		  HTStream *sink)
d8184 1
a8184 2
    HTStructured *html;

d8186 1
a8186 1
	(*sink->isa->put_string) (sink, "/* ");		/* Before even title */
d8191 1
a8191 1
	HTML_put_string(html, html->comment_start);
d8197 7
a8203 7
 *	------------------
 *
 *	This will convert from HTML to presentation or plain text.
 *
 * (Comment from original libwww:)
 *	Override this if you have a windows version
 */
d8205 4
a8208 3
HTStream *HTMLPresent(HTPresentation *pres GCC_UNUSED,
		      HTParentAnchor *anchor,
		      HTStream *sink GCC_UNUSED)
d8218 17
a8234 17
 *	------------------------------------------
 *
 *	The error message should be marked as an error so that
 *	it can be reloaded later.
 *	This implementation just throws up an error message
 *	and leaves the document unloaded.
 *	A smarter implementation would load an error document,
 *	marking at such so that it is retried on reload.
 *
 * On entry,
 *	sink	is a stream to the output device if any
 *	number	is the HTTP error number
 *	message is the human readable message.
 *
 * On exit,
 *	returns a negative number to indicate lack of success in the load.
 */
d8239 4
a8242 2
int HTLoadError(HTStream *sink GCC_UNUSED, int number,
		const char *message)
d8248 1
a8248 1
static char *MakeNewTitle(const char **value, int src_type)
d8263 1
a8263 1
#ifdef SH_EX			/* 1998/04/02 (Thu) 16:02:00 */
d8274 6
a8279 6
	    if (AS_casecomp(ptr, ".gif") == 0)
		*ptr = '\0';
	    else if (AS_casecomp(ptr, ".jpg") == 0)
		*ptr = '\0';
	    else if (AS_casecomp(ptr, ".jpeg") == 0)
		*ptr = '\0';
d8289 1
a8289 1
static char *MakeNewImageValue(const char **value)
d8305 1
a8305 1
static char *MakeNewMapValue(const char **value, const char *mapstr)
d8311 3
a8313 3
    StrAllocCat(newtitle, mapstr);	/* ISMAP or USEMAP */
    if (verbose_img && value[HTML_IMG_SRC] && *value[HTML_IMG_SRC]) {
	StrAllocCat(newtitle, ":");
@


1.1.3.6
log
@Lynx 2.8.6dev.5 amended with the 2.8.6dev.3-iz2 patch
@
text
@d5307 1
a5307 2
	    if (tables_disable & TABLES_DISABLE_TABLE_IN_TABLE)
		HText_cancelStbl(me->text);
@


1.1.3.7
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d1967 1
a1967 1
	    width = LYcolLimit -
d4341 1
a4341 1
	    } else if (HText_LastLineSize(me->text, FALSE) > (LYcolLimit - 6)) {
d4506 1
a4506 1
	    } else if (HText_LastLineSize(me->text, FALSE) > (LYcolLimit - 6)) {
d5015 1
a5015 1
	    width = LYcolLimit -
d5307 2
a5308 1
	    HText_cancelStbl(me->text);
a8079 1
    CTRACE((tfp, "HTMLToPlain calling CacheThru_new\n"));
a8141 1
    CTRACE((tfp, "HTMLParsedPresent calling CacheThru_new\n"));
a8169 1
    CTRACE((tfp, "HTMLToC calling CacheThru_new\n"));
a8186 1
    CTRACE((tfp, "HTMLPresent calling CacheThru_new\n"));
@


1.1.3.8
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@a82 13
#define DFT_TEXTAREA_COLS 60
#define DFT_TEXTAREA_ROWS 4

#define MAX_TEXTAREA_COLS LYcolLimit
#define MAX_TEXTAREA_ROWS (3 * LYlines)

#define LimitValue(name, value) \
 	if (name > value) { \
		CTRACE((tfp, "Limited " #name " to %d, was %d\n", \
			value, name)); \
		name = value; \
	}

d767 1
a767 1
    if (non_empty(title)) {
d804 1
a804 1
	if (non_empty(id)) {
d813 1
a813 1
	if (clickable_images && non_empty(src)) {
d1137 1
a1137 1
	    non_empty(value[HTML_BASE_HREF])) {
d1431 1
a1431 1
		non_empty(value[HTML_LINK_TITLE])) {
d1439 1
a1439 1
	    if (isEmpty(title)) {
d1476 1
a1476 1
		    non_empty(value[HTML_LINK_CHARSET])) {
d1509 1
a1509 1
		non_empty(value[HTML_LINK_CLASS])) {
d1567 1
a1567 1
	    non_empty(value[HTML_ISINDEX_PROMPT])) {
d1614 1
a1614 1
	    non_empty(value[HTML_FRAME_NAME])) {
d1621 1
a1621 1
	    non_empty(value[HTML_FRAME_SRC])) {
d1667 1
a1667 1
	    non_empty(value[HTML_IFRAME_NAME])) {
d1674 1
a1674 1
	    non_empty(value[HTML_IFRAME_SRC])) {
d1773 1
a1773 1
		   non_empty(value[HTML_DIV_ALIGN])) {
d1855 1
a1855 1
	    non_empty(value[HTML_H_ALIGN])) {
d2064 1
a2064 1
		    non_empty(value[HTML_TAB_TO])) ||
d2081 1
a2081 1
	    } else if (isEmpty(temp) && present[HTML_TAB_INDENT] &&
d2116 1
a2116 1
	    non_empty(value[HTML_TAB_ID])) {
d2430 1
a2430 1
		non_empty(value[HTML_OL_SEQNUM])) {
d2433 1
a2433 1
		       non_empty(value[HTML_OL_START])) {
d2819 1
a2819 1
	    non_empty(value[HTML_A_ID])) {
d2822 1
a2822 1
		   non_empty(value[HTML_A_NAME])) {
d2895 1
a2895 1
		non_empty(value[HTML_A_TITLE])) {
d2907 1
a2907 1
		non_empty(value[HTML_A_CHARSET])) {
d3000 1
a3000 1
	    non_empty(value[HTML_IMG_USEMAP])) {
d3053 1
a3053 1
	    non_empty(value[HTML_IMG_TITLE])) {
d3156 1
a3156 1
	    non_empty(value[HTML_IMG_ID])) {
d3169 1
a3169 1
	    non_empty(value[HTML_IMG_SRC])) {
d3430 1
a3430 1
	    non_empty(value[HTML_MAP_NAME])) {
d3433 1
a3433 1
		   non_empty(value[HTML_MAP_ID])) {
d3470 1
a3470 1
		non_empty(value[HTML_MAP_TITLE])) {
d3487 1
a3487 1
	    non_empty(value[HTML_AREA_HREF])) {
d3510 1
a3510 1
		non_empty(value[HTML_AREA_ALT])) {
d3513 1
a3513 1
		       non_empty(value[HTML_AREA_TITLE])) {
d3598 1
a3598 1
		    non_empty(value[HTML_OBJECT_USEMAP])) {
d3606 1
a3606 1
		    non_empty(value[HTML_OBJECT_ID])) {
d3614 1
a3614 1
		    non_empty(value[HTML_OBJECT_TITLE])) {
d3624 1
a3624 1
		    non_empty(value[HTML_OBJECT_DATA])) {
d3632 1
a3632 1
		    non_empty(value[HTML_OBJECT_TYPE])) {
d3678 1
a3678 1
		    non_empty(value[HTML_OBJECT_NAME])) {
d3772 1
a3772 1
	    non_empty(value[HTML_OVERLAY_SRC])) {
d3811 1
a3811 1
	    non_empty(value[HTML_APPLET_ID])) {
d3814 1
a3814 1
		   non_empty(value[HTML_APPLET_NAME])) {
d3857 1
a3857 1
	    non_empty(value[HTML_APPLET_CODE])) {
d3867 1
a3867 1
		non_empty(value[HTML_APPLET_CODEBASE])) {
d3931 1
a3931 1
	    non_empty(value[HTML_BGSOUND_SRC])) {
d3977 1
a3977 1
	    non_empty(value[HTML_EMBED_ID])) {
d3980 1
a3980 1
		   non_empty(value[HTML_EMBED_NAME])) {
d4023 1
a4023 1
	    non_empty(value[HTML_EMBED_SRC])) {
d4209 1
a4209 1
		non_empty(value[HTML_FORM_ENCTYPE])) {
d4228 1
a4228 1
		if (non_empty(title)) {
d4288 1
a4288 1
	    I.size = 0;
d4359 1
a4359 1
		non_empty(value[HTML_BUTTON_VALUE])) {
d4386 1
a4386 1
		non_empty(value[HTML_BUTTON_CLASS]))
d4390 1
a4390 1
		non_empty(value[HTML_BUTTON_ID])) {
d4396 1
a4396 1
		non_empty(value[HTML_BUTTON_LANG]))
d4483 1
a4483 1
	    I.size = 0;
d4515 1
a4515 1
		non_empty(value[HTML_INPUT_TYPE])) {
d4626 1
a4626 1
		 non_empty(value[HTML_INPUT_ALT]) &&
d4629 1
a4629 1
		  non_empty(value[HTML_INPUT_VALUE]))) {
d4640 1
a4640 1
		non_empty(value[HTML_INPUT_SRC]) &&
d4645 1
a4645 1
		       non_empty(value[HTML_INPUT_SRC]) &&
d4776 2
a4777 3
		non_empty(value[HTML_INPUT_SIZE]))
		I.size = atoi(value[HTML_INPUT_SIZE]);
	    LimitValue(I.size, MAX_LINE);
d4779 1
a4779 1
		non_empty(value[HTML_INPUT_MAXLENGTH]))
d4785 2
a4786 3
		I.accept_cs = (value[HTML_INPUT_ACCEPT_CHARSET]
			       ? value[HTML_INPUT_ACCEPT_CHARSET]
			       : "UNKNOWN");
d4789 1
a4789 1
		non_empty(value[HTML_INPUT_ALIGN]))
d4792 1
a4792 1
		non_empty(value[HTML_INPUT_CLASS]))
d4795 1
a4795 1
		non_empty(value[HTML_INPUT_ERROR]))
d4798 1
a4798 1
		non_empty(value[HTML_INPUT_HEIGHT]))
d4801 1
a4801 1
		non_empty(value[HTML_INPUT_WIDTH]))
d4804 1
a4804 1
		non_empty(value[HTML_INPUT_ID])) {
d4809 1
a4809 1
		non_empty(value[HTML_INPUT_LANG]))
d4812 1
a4812 1
		non_empty(value[HTML_INPUT_MD]))
d5011 1
a5011 1
	    me->textarea_cols = atoi(value[HTML_TEXTAREA_COLS]);
d5018 1
a5018 1
		width = HTMIN(width, DFT_TEXTAREA_COLS);
d5021 1
a5021 1
		me->textarea_cols = width;
d5023 1
a5023 1
		me->textarea_cols = DFT_TEXTAREA_COLS;
a5024 1
	LimitValue(me->textarea_cols, MAX_TEXTAREA_COLS);
d5031 1
a5031 2
	    me->textarea_rows = DFT_TEXTAREA_ROWS;
	LimitValue(me->textarea_rows, MAX_TEXTAREA_ROWS);
d5039 1
a5039 1
	    && non_empty(value[HTML_TEXTAREA_ID])) {
d5160 1
a5160 1
		I.size = 0;
d5199 1
a5199 1
		    && non_empty(value[HTML_OPTION_ID])) {
d5331 1
a5331 1
	    non_empty(value[HTML_TABLE_ALIGN])) {
d5900 1
a5900 1
	if (non_empty(me->node_anchor->bookmark)) {
d5902 1
a5902 1
		(non_empty(bookmark_page) &&
d6240 1
a6240 1
	if (non_empty(hidden_link_marker) &&
d6411 1
a6411 1
		if (non_empty(me->object_id) && !LYMapsOnly)
d6423 1
a6423 1
		if (non_empty(me->object_id))
d6616 1
a6616 1
	    if (non_empty(me->object_id) && !LYMapsOnly)
d6806 1
a6806 1
	    I.size = 0;
d6956 1
a6956 1
		for (chars = me->textarea_cols; chars > 0; chars--)
d6981 1
d7068 1
a7068 1
		for (; non_empty(ptr); ptr++) {
d7524 1
d7705 1
a7705 1
    me->textarea_cols = 0;
d8290 1
a8290 1
    if (verbose_img && non_empty(value[HTML_IMG_SRC])) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d38 1
d52 1
a52 1
#ifdef USE_PRETTYSRC
a80 2
#include <LYJustify.h>

d87 1
a96 1
    HTParentAnchor *		anchor;
a97 1
    char *			filename;
a100 1
    int				status;
d110 1
a110 2
PRIVATE HTStyle *styles[HTML_ELEMENTS+LYNX_HTML_EXTRA_ELEMENTS];
					   /* adding 24 nested list styles  */
d124 1
a124 1
PRIVATE int HTML_end_element PARAMS((HTStructured *me,
d128 1
a128 1
PRIVATE int HTML_start_element PARAMS((
d152 2
d156 2
a157 2
    if (!i) return;
    while (*i) { *i=(char)tolower(*i); i++; }
a206 11
PUBLIC BOOL LYBadHTML ARGS1(
    HTStructured *,	me)
{
    if (!TRACE && !me->inBadHTML) {
	HTUserMsg(BAD_HTML_USE_TRACE);
	me->inBadHTML = TRUE;
	return FALSE;
    }
    return TRUE;
}

d233 1
a233 1
    if (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT)
d438 1
a438 1
#ifdef USE_PRETTYSRC
d442 1
a442 1
    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
d444 1
a444 1
#ifdef USE_PRETTYSRC
d449 1
a449 1
    }
a502 12
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for(; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
d537 1
a537 1
			    me->in_word = NO;
d572 1
a572 1
#ifdef USE_PRETTYSRC
d588 1
a588 1
    if (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT)
d591 1
a591 1
    for (p = s; p < e; p++)
d645 2
a646 2
   overriding non-caching similar to LYoverride_no_cache. - kw */
#define CHECK_FOR_INTERN(flag,s) flag = (s && (*s=='#' || *s=='\0')) ? TRUE : FALSE
d654 1
a654 1
#define CHECK_FOR_INTERN(flag,s)  /* do nothing */ ;
d672 1
a672 1
#ifdef USE_PRETTYSRC
d676 1
a676 1
	    HTlexeme,	      lexeme,
d680 1
a680 1
    HT_tagspec* ts = *( ( start ? lexeme_start : lexeme_end ) + lexeme);
d691 1
a691 1
	CTRACE((tfp,ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n",(int)lexeme));
a709 2

#if defined(__STDC__) || _WIN_CC
a711 4
#else
#  define PSRCSTART(x)	HTMLSRC_apply_markup(me,HTL_/**/x,START,tag_charset)
#  define PSRCSTOP(x)  HTMLSRC_apply_markup(me,HTL_/**/x,STOP,tag_charset)
#endif
d716 1
a716 151
#endif /* USE_PRETTYSRC*/

PRIVATE void LYStartArea ARGS5(
	HTStructured *,		obj,
	CONST char *,		href,
	CONST char *,		alt,
	CONST char *,		title,
	int,			tag_charset)
{
    BOOL		new_present[HTML_AREA_ATTRIBUTES];
    CONST char *	new_value[HTML_AREA_ATTRIBUTES];
    int i;

    for (i = 0; i < HTML_AREA_ATTRIBUTES; i++)
	 new_present[i] = NO;

    if (alt) {
	new_present[HTML_AREA_ALT] = YES;
	new_value[HTML_AREA_ALT] = (CONST char *)alt;
    }
    if (title && *title) {
	new_present[HTML_AREA_TITLE] = YES;
	new_value[HTML_AREA_TITLE] = (CONST char *)title;
    }
    if (href) {
	new_present[HTML_AREA_HREF] = YES;
	new_value[HTML_AREA_HREF] = (CONST char *)href;
    }

    (*obj->isa->start_element)(obj, HTML_AREA, new_present, new_value,
			       tag_charset, 0);
}

PRIVATE void LYHandleFIG ARGS10(
	HTStructured *,		me,
	CONST BOOL*,		present,
	CONST char **,		value,
	BOOL,			isobject,
	BOOL,			imagemap,
	CONST char *,		id,
	CONST char *,		src,
	BOOL,			convert,
	BOOL,			start,
	BOOL *,			intern_flag GCC_UNUSED)
{
    if (start == TRUE) {
	me->inFIG = TRUE;
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, NULL);
	}
	if (!isobject) {
	    LYEnsureDoubleSpace(me);
	    LYResetParagraphAlignment(me);
	    me->inFIGwithP = TRUE;
	} else {
	    me->inFIGwithP = FALSE;
	    HTML_put_character(me, ' ');  /* space char may be ignored */
	}
	if (id && *id) {
	    if (present && convert) {
		CHECK_ID(HTML_FIG_ID);
	    } else
		LYHandleID(me, id);
	}
	me->in_word = NO;
	me->inP = FALSE;

	if (clickable_images && src && src != '\0') {
	    char *href = NULL;
	    StrAllocCopy(href, src);
	    CHECK_FOR_INTERN(*intern_flag,href);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href) {
		char *temp = NULL;
		/*
		 *  Check whether a base tag is in effect. - FM
		 */
		if ((me->inBASE && *href != '#') &&
		    (temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		    *temp != '\0')
		    /*
		     *	Use reference related to the base.
		     */
		    StrAllocCopy(href, temp);
		FREE(temp);

		/*
		 *  Check whether to fill in localhost. - FM
		 */
		LYFillLocalFileURL(&href,
				   ((*href != '#' &&
				     me->inBASE) ?
				   me->base_href : me->node_anchor->address));

		me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					INTERN_LT);		/* Type */
		HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		HTML_put_string(me, (isobject ?
		      (imagemap ? "(IMAGE)" : "(OBJECT)") : "[FIGURE]"));
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, 0);
		HTML_put_character(me, '-');
		HTML_put_character(me, ' '); /* space char may be ignored */
		me->in_word = NO;
	    }
	    FREE(href);
	}
    } else {			/* handle end tag */
	if (me->inFIGwithP) {
	    LYEnsureDoubleSpace(me);
	} else {
	    HTML_put_character(me, ' ');  /* space char may be ignored */
	}
	LYResetParagraphAlignment(me);
	me->inFIGwithP = FALSE;
	me->inFIG = FALSE;
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
	if (me->List_Nesting_Level >= 0) {
	    UPDATE_STYLE;
	    HText_NegateLineOne(me->text);
	}
    }
}

PRIVATE void clear_objectdata ARGS1(
	HTStructured *,		me)
{
    if (me) {
	HTChunkClear(&me->object);
	me->object_started = FALSE;
	me->object_declare = FALSE;
	me->object_shapes = FALSE;
	me->object_ismap = FALSE;
	FREE(me->object_usemap);
	FREE(me->object_id);
	FREE(me->object_title);
	FREE(me->object_data);
	FREE(me->object_type);
	FREE(me->object_classid);
	FREE(me->object_codebase);
	FREE(me->object_codetype);
	FREE(me->object_name);
    }
}
d721 1
a721 1
PRIVATE int HTML_start_element ARGS6(
d739 1
a739 1
    int dest_char_set = -1;
d742 1
a742 1
    BOOL UseBASE = TRUE;		     /* Resolved vs. BASE if present? */
d746 1
a746 1
    HTMLElement ElementNumber = element_number;
a747 2
    short stbl_align = HT_ALIGN_NONE;
    int status = HT_OK;
a749 1
    int class_used = 0;
d758 1
a758 1
#ifdef USE_PRETTYSRC
d765 1
a765 1
		psrc_first_tag = FALSE;
d771 3
a773 3
		psrc_nested_call = TRUE;
		HTML_start_element(me, HTML_BODY, NULL, NULL, tag_charset, NULL);
		HTML_start_element(me, HTML_PRE, NULL, NULL, tag_charset, NULL);
d775 1
a775 1
		psrc_nested_call = FALSE;
d778 1
a778 1
	    psrc_nested_call = TRUE;
d785 1
a785 1
		LYstrncpy(buf, tag->name, sizeof(buf)-1);
d797 1
a797 1
			    LYstrncpy(buf, tag->attributes[i].name, sizeof(buf)-1);
d804 1
a804 1
			    char kind= (char) ( !strchr(value[i], '"') ?
d842 1
a842 1
	    return HT_OK;
d846 1
a846 1
#endif /* USE_PRETTYSRC */
d850 2
a851 3
	      ElementNumber == HTML_BASE || ElementNumber == HTML_OBJECT ||
	      ElementNumber == HTML_A)) {
	    return HT_OK;
d862 3
a864 3
	    CTRACE((tfp, "me->tag_charset: %d -> %d", me->tag_charset, j ));
	    CTRACE((tfp, " (me->UCLYhndl: %d, tag_charset: %d)\n",
		   me->UCLYhndl, tag_charset));
d877 1
a894 1
    CTRACE2(TRACE_STYLE, (tfp, "CSS.elt:<%s>\n", HTML_dtd.tags[element_number].name));
d896 1
a896 1
    if (current_tag_style == -1) {	/* Append class_name */
d900 1
a900 1
	hcode = hash_code_lowercase_on_fly(HTML_dtd.tags[element_number].name);
a903 2
	    int ohcode = hcode;
	    char *oend = Style_className_end;
a904 2
	    int len = strlen(myHash);
	    sprintf(myHash, ".%.*s", (int)sizeof(myHash) - len - 2, class_name);
d906 2
d909 1
d911 1
a911 1
	    int l = strlen(class_name);
a919 12
	    if (!hashStyles[hcode].name) { /* None such -> classless version */
		hcode = ohcode;
		*oend = '\0';
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.start_element: <%s> (class <%s> not configured), hcode=%d.\n",
			HTML_dtd.tags[element_number].name, class_name, hcode));
	    } else {
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.start_element: <%s>.<%s>, hcode=%d.\n",
			HTML_dtd.tags[element_number].name, class_name, hcode));
		class_used = 1;
	    }
a920 1

d930 7
a936 5
	CTRACE((tfp, "CSSTRIM:%s -> %d", myHash, hcode));
	if (hashStyles[hcode].code != hcode) {
	    char *rp = strrchr(myHash, '.');
	    CTRACE((tfp, " (undefined) %s\n", myHash));
	    if (rp) {
d938 1
a938 1
		*rp = '\0'; /* trim the class */
d940 1
a940 1
		CTRACE((tfp, "CSS:%s -> %d", myHash, hcd));
d942 1
a942 1
		    CTRACE((tfp, " (undefined) %s\n", myHash));
d944 1
a944 1
		    CTRACE((tfp, " ca=%d\n", hashStyles[hcd].color));
a945 2
	} else {
	    CTRACE((tfp, " ca=%d\n", hashStyles[hcode].color));
d947 2
d951 7
a960 2
	    int len = strlen(myHash);
	    sprintf(myHash, ".%.*s", (int)sizeof(myHash) - len - 2, class_name);
d962 2
d967 3
a969 3
	    *Style_className_end = '.';
	    memcpy(Style_className_end+1,class_name, l + 1 );
	    Style_className_end += l + 1;
d975 1
a975 3
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE.start_element: <%s>, hcode=%d.\n",
		HTML_dtd.tags[element_number].name, hcode));
a987 29
#if OPT_SCN && !OMIT_SCN_KEEPING	/* Can be done in other cases too... */
    if (!class_used && ElementNumber == HTML_INPUT) { /* For some other too? */
	CONST char *type = "";
	char *oend = Style_className_end;
	int l, ohcode = hcode;

	if (present && present[HTML_INPUT_TYPE] && value[HTML_INPUT_TYPE])
	    type = value[HTML_INPUT_TYPE];
	l = strlen(type);

	*Style_className_end = '.';
	memcpy(Style_className_end+1, "type.", 5 );
	memcpy(Style_className_end+6, type, l+1 );
	Style_className_end += l+6;
	hcode = hash_code_aggregate_lower_str(".type.", hcode);
	hcode = hash_code_aggregate_lower_str(type, hcode);
	if (!hashStyles[hcode].name) { /* None such -> classless version */
	    hcode = ohcode;
	    *oend = '\0';
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.start_element: type <%s> not configured.\n",
			   type));
	} else {
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.start_element: <%s>.type.<%s>, hcode=%d.\n",
			  HTML_dtd.tags[element_number].name, type, hcode));
	}
    }
#endif	/* OPT_SCN && !OMIT_SCN_KEEPING */
d989 1
a989 1
    HText_characterStyle(me->text, hcode, 1);
d1011 2
a1012 2
		CTRACE((tfp, "HTML: BASE '%s' is not an absolute URL.\n",
			    (base ? base : "")));
d1116 1
a1116 1
	    CHECK_FOR_INTERN(intern_flag,value[HTML_LINK_HREF]);
d1177 1
a1177 1
		    CTRACE((tfp, "HTML: DOC OWNER '%s' found\n", href));
a1206 4
		 *
		 * lss and css have different syntax - lynx shouldn't try to
		 * parse them now (it tries to parse them as lss, so it exits
		 * with error message on the 1st non-empty line) - VH
d1208 4
d1215 32
a1246 2
		    CTRACE2(TRACE_STYLE, (tfp, "HTML: StyleSheet link found.\n"));
		    CTRACE2(TRACE_STYLE, (tfp, "        StyleSheets not yet implemented.\n"));
d1253 1
a1253 1
		 *  Ignore anything not registered in the 28-Mar-95
a1317 8
#ifndef DISABLE_BIBP
		} else if (!strcasecomp(value[HTML_LINK_REL], "citehost")) {
		    /*  Citehost determination for bibp links. - RDC */
		    HTAnchor_setCitehost(me->node_anchor, href);
		    CTRACE((tfp, "HTML: citehost '%s' found\n", href));
		    FREE(href);
		    break;
#endif
d1319 2
a1320 2
		    CTRACE((tfp, "HTML: LINK with REL=\"%s\" ignored.\n",
				 value[HTML_LINK_REL]));
d1338 2
a1339 2
		CTRACE((tfp, "HTML: LINK with REL=\"%s\" and no HREF ignored.\n",
			    value[HTML_LINK_REL]));
d1394 1
a1394 5

		/* Don't allow CHARSET attribute to change *this* document's
		   charset assumption. - kw */
		if (dest == me->node_anchor)
		    dest = NULL;
d1400 2
d1403 1
a1403 1
		if (dest && dest_char_set >= 0)
a1419 6
	    } else {
		/*
		 *  Add collapsible space to separate link from previous
		 *  generated links. - kw
		 */
		HTML_put_character(me, ' ');
d1430 1
a1430 2
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.link: using style <%s>\n", tmp));
d1522 2
d1562 1
a1562 1
	    CHECK_FOR_INTERN(intern_flag,href);
a1593 1
	    CAN_JUSTIFY_PUSH(FALSE);
a1600 1

a1611 1
	    CAN_JUSTIFY_POP;
d1634 1
a1634 1
	    CHECK_FOR_INTERN(intern_flag,href);
a1664 1
	    CAN_JUSTIFY_PUSH_F
a1671 1

a1682 1
	    CAN_JUSTIFY_POP;
d1693 1
a1693 1
	if (me->sp->tag_number == (int) ElementNumber)
d1719 1
a1719 1
	    CTRACE((tfp,
d1721 1
a1721 1
		MAX_NESTING));
a1722 2
	if (me->inP)
	    LYEnsureSingleSpace(me); /* always at least break line - kw */
a1727 20
	} else if (me->List_Nesting_Level >= 0 &&
		   !(present && present[HTML_DIV_ALIGN] &&
		     value[HTML_DIV_ALIGN] &&
		     (!strcasecomp(value[HTML_DIV_ALIGN], "center") ||
		      !strcasecomp(value[HTML_DIV_ALIGN], "right")))) {
	    if (present && present[HTML_DIV_ALIGN])
		me->current_default_alignment = HT_LEFT;
	    else if (me->Division_Level == 0)
		me->current_default_alignment = HT_LEFT;
	    else if (me->sp[0].tag_number == HTML_UL ||
		     me->sp[0].tag_number == HTML_OL ||
		     me->sp[0].tag_number == HTML_MENU ||
		     me->sp[0].tag_number == HTML_DIR ||
		     me->sp[0].tag_number == HTML_LI ||
		     me->sp[0].tag_number == HTML_LH ||
		     me->sp[0].tag_number == HTML_DD)
		me->current_default_alignment = HT_LEFT;
	    LYHandlePlike(me, present, value, include, HTML_DIV_ALIGN, TRUE);
	    me->DivisionAlignments[me->Division_Level] = (short)
		me->current_default_alignment;
d1782 1
a1782 2
	     me->sp[0].tag_number == HTML_DIR ||
	     me->sp[0].tag_number == HTML_LI)) {
d1847 1
a1847 2
	LYHandlePlike(me, present, value, include, HTML_P_ALIGN, TRUE);
	CHECK_ID(HTML_P_ID);
d1928 1
a1928 1
		isdigit(UCH(*value[HTML_HR_WIDTH])) &&
d1988 1
a1988 1
	    CTRACE((tfp, "HTML: TAB tag has no attributes.  Ignored.\n"));
a1990 7
	/*
	 *  If page author is using TAB within a TABLE, it's probably
	 *  formatted specifically to work well for Lynx without simple
	 *  table tracking code.  Cancel tracking, it would only make
	 *  things worse. - kw
	 */
	HText_cancelStbl(me->text);
a1992 1
	CANT_JUSTIFY_THIS_LINE;
d2001 1
a2001 1
	    CTRACE((tfp, "HTML: ALIGN not 'left'.  Using space instead of TAB.\n"));
d2012 1
a2012 1
	    CTRACE((tfp, "HTML: Not HT_LEFT.  Using space instead of TAB.\n"));
d2018 1
a2018 1
		    isdigit(UCH(*value[HTML_TAB_INDENT])))) {
d2034 1
a2034 1
		       isdigit(UCH(*value[HTML_TAB_INDENT]))) {
a2047 1

d2051 1
a2051 1
		CTRACE((tfp, "HTML: Column out of bounds.  Using space instead of TAB.\n"));
d2120 1
a2120 1
	    CTRACE((tfp, "Underline Level is %d\n", me->Underline_Level));
d2126 1
a2126 1
	    CTRACE((tfp,"Beginning underline\n"));
d2128 1
a2128 1
	    CTRACE((tfp,"Underline Level is %d\n", me->Underline_Level));
d2142 2
a2148 12
    case HTML_SUP:
	if (isxdigit(UCH(HText_getLastChar(me->text)))) {
	    HText_appendCharacter(me->text, '^');
	}
	CHECK_ID(HTML_GEN_ID);
	break;

    case HTML_SUB:
	HText_appendCharacter(me->text, '[');
	CHECK_ID(HTML_GEN_ID);
	break;

a2197 1
	/* FALLTHRU */
a2198 1
	/* FALLTHRU */
a2199 1
	/* FALLTHRU */
d2212 1
a2212 1
	if (me->sp->tag_number == (int) ElementNumber)
d2220 1
a2220 1
	if (me->sp->tag_number == (int) ElementNumber)
a2251 1
	    CAN_JUSTIFY_START;
a2253 1
	CAN_JUSTIFY_START;
d2262 1
a2262 1
	if (me->sp->tag_number == (int) ElementNumber)
a2283 1

d2528 38
a2565 42
	{
	    int surrounding_tag_number = me->sp[0].tag_number;
	    /*
	     *  No, a LI should never occur directly within another LI,
	     *  but this may result from incomplete error recovery.
	     *  So check one more surrounding level in this case. - kw
	     */
	    if (surrounding_tag_number == HTML_LI &&
		me->sp < (me->stack + MAX_NESTING - 1))
		surrounding_tag_number = me->sp[1].tag_number;
	    if (surrounding_tag_number == HTML_OL) {
		char number_string[20];
		int counter, seqnum;
		char seqtype;

		counter = me->List_Nesting_Level < 11 ?
		    me->List_Nesting_Level : 11;
		if (present && present[HTML_LI_TYPE] && value[HTML_LI_TYPE]) {
		    if (*value[HTML_LI_TYPE] == '1') {
			me->OL_Type[counter] = '1';
		    } else if (*value[HTML_LI_TYPE] == 'A') {
			me->OL_Type[counter] = 'A';
		    } else if (*value[HTML_LI_TYPE] == 'a') {
			me->OL_Type[counter] = 'a';
		    } else if (*value[HTML_LI_TYPE] == 'I') {
			me->OL_Type[counter] = 'I';
		    } else if (*value[HTML_LI_TYPE] == 'i') {
			me->OL_Type[counter] = 'i';
		    }
		}
		if (present && present[HTML_LI_VALUE] &&
		    ((value[HTML_LI_VALUE] != NULL) &&
		     (*value[HTML_LI_VALUE] != '\0')) &&
		    ((isdigit(UCH(*value[HTML_LI_VALUE]))) ||
		     (*value[HTML_LI_VALUE] == '-' &&
		      isdigit(UCH(*(value[HTML_LI_VALUE] + 1)))))) {
		    seqnum = atoi(value[HTML_LI_VALUE]);
		    if (seqnum <= OL_VOID)
			seqnum = OL_VOID + 1;
		    seqtype = me->OL_Type[counter];
		    if (seqtype != '1' && seqnum < 1)
			seqnum = 1;
d2567 9
a2575 16
		} else if (me->OL_Counter[counter] >= OL_VOID) {
		    seqnum = me->OL_Counter[counter]++;
		    seqtype = me->OL_Type[counter];
		    if (seqtype != '1' && seqnum < 1) {
			seqnum = 1;
			me->OL_Counter[counter] = seqnum + 1;
		    }
		} else {
		    seqnum = me->Last_OL_Count + 1;
		    seqtype = me->Last_OL_Type;
		    for (i = (counter - 1); i >= 0; i--) {
			if (me->OL_Counter[i] > OL_VOID) {
			    seqnum = me->OL_Counter[i]++;
			    seqtype = me->OL_Type[i];
			    i = 0;
			}
d2578 22
a2599 21
		if (seqtype == 'A') {
		    sprintf(number_string, LYUppercaseA_OL_String(seqnum));
		} else if (seqtype == 'a') {
		    sprintf(number_string, LYLowercaseA_OL_String(seqnum));
		} else if (seqtype == 'I') {
		    sprintf(number_string, LYUppercaseI_OL_String(seqnum));
		} else if (seqtype == 'i') {
		    sprintf(number_string, LYLowercaseI_OL_String(seqnum));
		} else {
		    sprintf(number_string, "%2d.", seqnum);
		}
		me->Last_OL_Count = seqnum;
		me->Last_OL_Type = seqtype;
		/*
		 *	Hack, because there is no append string!
		 */
		for (i = 0; number_string[i] != '\0'; i++)
		    if (number_string[i] == ' ')
			HTML_put_character(me, HT_NON_BREAK_SPACE);
		    else
			HTML_put_character(me, number_string[i]);
d2601 18
a2618 18
		/*
		 *	Use HTML_put_character so that any other spaces
		 *	coming through will be collapsed.  We'll use
		 *	nbsp, so it won't break at the spacing character
		 *	if there are no spaces in the subsequent text up
		 *	to the right margin, but will declare it as a
		 *	normal space to ensure collapsing if a normal
		 *	space does immediately follow it. - FM
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
	    } else if (surrounding_tag_number == HTML_UL) {
		/*
		 *	Hack, because there is no append string!
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		switch(me->List_Nesting_Level % 7) {
a2640 19
		}
		/*
		 *	Keep using HTML_put_character so that any other
		 *	spaces coming through will be collapsed.  We use
		 *	nbsp, so we won't wrap at the spacing character
		 *	if there are no spaces in the subsequent text up
		 *	to the right margin, but will declare it as a
		 *	normal space to ensure collapsing if a normal
		 *	space does immediately follow it. - FM
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
	    } else {
		/*
		 *	Hack, because there is no append string!
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
d2642 18
a2660 1
	CAN_JUSTIFY_START;
d2690 1
a2690 1
	if (me->sp->tag_number == (int) ElementNumber)
a2698 1
	CAN_JUSTIFY_START
a2704 19
	    /*
	     *  If we are looking for client-side image maps,
	     *  then handle an A within a MAP that has a COORDS
	     *  attribute as an AREA tag.  Unfortunately we lose
	     *  the anchor text this way for the LYNXIMGMAP, we
	     *  would have to do much more parsing to collect it.
	     *  After potentially handling the A as AREA, always return
	     *  immediately if only looking for image maps, without
	     *  pushing anything on the style stack. - kw
	     */
	if (me->map_address && present && present[HTML_A_COORDS])
	    LYStartArea(me,
			present[HTML_A_HREF] ? value[HTML_A_HREF] : NULL,
			NULL,
			present[HTML_A_TITLE] ? value[HTML_A_TITLE] : NULL,
			tag_charset);
	if (LYMapsOnly) {
	    return HT_OK;
	}
d2747 1
a2747 1
		CHECK_FOR_INTERN(intern_flag,value[HTML_A_HREF]);
d2808 1
a2808 2
		!LYIsUIPage3(me->node_anchor->address, UIP_LIST_PAGE, 0) &&
		!LYIsUIPage3(me->node_anchor->address, UIP_ADDRLIST_PAGE, 0) &&
d2814 2
a2815 2
		CTRACE((tfp, "HTML: Found invalid HREF=\"%s\" TYPE=\"%s\"!\n",
			    href, temp));
d2855 2
d2868 1
a2868 3
	    /* Don't allow CHARSET attribute to change *this* document's
	       charset assumption. - kw */
	    if (dest && dest != me->node_anchor && dest_char_set >= 0) {
d2891 1
a2891 1
#if defined(NOTUSED_FOTEMODS)
d2899 1
a2899 1
	    HTML_end_element(me, HTML_A, include);
d2901 1
a2901 8
#else
	/*Close an HREF-less NAMED-ed now if force_empty_hrefless_a was
	    requested - VH*/
	if (href == NULL && force_empty_hrefless_a) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
#endif
d2918 2
a2919 2
		    CTRACE((tfp, "HTML: '%s' is an ISMAP script\n",
				dest->address));
d2923 2
a2924 2
		    CTRACE((tfp, "HTML: Designating '%s' as an ISMAP script\n",
				dest->address));
d2938 1
a2938 1
	    CHECK_FOR_INTERN(intern_flag,map_href);
d3112 1
a3112 1
	CTRACE((tfp, "HTML IMG: USEMAP=%d ISMAP=%d ANCHOR=%d PARA=%d\n",
d3115 1
a3115 1
		    me->inA, me->inP));
a3440 10
	 *  Generate a target anchor in this place in the containing
	 *  document.  MAP can now contain block markup, if it doesn't
	 *  contain any AREAs (or A anchors with COORDS converted to AREAs)
	 *  the current location can be used as a fallback for following
	 *  a USEMAP link. - kw
	 */
	 if (!LYMapsOnly)
	     LYHandleID(me, id_string);

	/*
d3481 1
a3481 1
	    CHECK_FOR_INTERN(intern_flag,href);
d3585 65
a3649 14
	if (present)
	    LYHandleFIG(me, present, value,
			present[HTML_FIG_ISOBJECT],
			present[HTML_FIG_IMAGEMAP],
			present[HTML_FIG_ID] ? value[HTML_FIG_ID] : NULL,
			present[HTML_FIG_SRC] ? value[HTML_FIG_SRC] : NULL,
			YES, TRUE, &intern_flag);
	else
	    LYHandleFIG(me, NULL, NULL,
			0,
			0,
			NULL,
			NULL, YES, TRUE, &intern_flag);
	break;
d3755 3
a3757 75
	     *  If we can determine now that we are not going to do anything
	     *  special to the OBJECT element's SGML contents, like skipping
	     *  it completely or collecting it up in order to add something
	     *  after it, then generate any output that should be emitted in the
	     *  place of the OBJECT start tag NOW, then don't initialize special
	     *  handling but return, letting our SGML parser know that further
	     *  content is to be parsed normally not literally.  We could defer
	     *  this until we have collected the contents and then recycle the
	     *  contents (as was previously always done), but that has a higher
	     *  chance of completely losing content in case of nesting errors
	     *  in the input, incomplete transmissions, etc. - kw
	     */
	    if ((!present ||
		 (me->object_declare == FALSE && me->object_name == NULL &&
		  me->object_shapes == FALSE && me->object_usemap == NULL))) {
		if (!LYMapsOnly) {
		    if (!clickable_images || me->object_data == NULL ||
			!(me->object_data != NULL &&
			  me->object_classid == NULL &&
			  me->object_codebase == NULL &&
			  me->object_codetype == NULL))
			FREE(me->object_data);
		    if (me->object_data) {
			HTStartAnchor5(me,
				       me->object_id ? value[HTML_OBJECT_ID]
					: NULL,
				       value[HTML_OBJECT_DATA],
				       value[HTML_OBJECT_TYPE],
				       tag_charset);
			if ((me->object_type != NULL) &&
			    !strncasecomp(me->object_type, "image/", 6))
			    HTML_put_string(me, "(IMAGE)");
			else
			    HTML_put_string(me, "(OBJECT)");
			HTML_end_element(me,HTML_A,NULL);
		    } else if (me->object_id)
			LYHandleID(me, me->object_id);
		}
		clear_objectdata(me);
		/*
		 *  We do NOT want the HTML_put_* functions that are going
		 *  to be called for the OBJECT's character content to
		 *  add to the chunk, so we don't push on the stack.
		 *  Instead we keep a counter for open OBJECT tags that
		 *  are treated this way, so HTML_end_element can skip
		 *  handling the corresponding end tag that is going to
		 *  arrive unexpectedly as far as our stack is concerned.
		 */
		status = HT_PARSER_OTHER_CONTENT;
		if (me->sp[0].tag_number == HTML_FIG &&
		    me->objects_figged_open > 0) {
		    ElementNumber = HTML_OBJECT_M;
		} else {
		    me->objects_mixed_open++;
		    SET_SKIP_STACK(HTML_OBJECT);
		}
	    } else if (me->object_declare == FALSE && me->object_name == NULL &&
		       me->object_shapes == TRUE) {
		LYHandleFIG(me, present, value,
		    1,
		    1 || me->object_ismap,
		    me->object_id,
		    (me->object_data && !me->object_classid) ? value[HTML_OBJECT_DATA] : NULL,
		    NO, TRUE, &intern_flag);
		clear_objectdata(me);
		status = HT_PARSER_OTHER_CONTENT;
		me->objects_figged_open++;
		ElementNumber = HTML_FIG;

	    } else {
		/*
		 *	Set flag that we are accumulating OBJECT content. - FM
		 */
		me->object_started = TRUE;
	    }
d3766 1
a3766 1
	    CHECK_FOR_INTERN(intern_flag,href);
d3971 1
a3971 1
	    CHECK_FOR_INTERN(intern_flag,href);
d4085 1
a4085 1
	    CHECK_FOR_INTERN(intern_flag,href);
a4159 1
	CAN_JUSTIFY_START;
a4190 1
	CAN_JUSTIFY_START;
d4230 1
a4230 1
		CTRACE((tfp, "HTML: Missing FORM end tag.  Faking it!\n"));
a4238 1
	    EMIT_IFDEF_EXP_JUSTIFY_ELTS(form_in_htext = TRUE);
d4404 7
a4410 3
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: BUTTON tag not within FORM tag\n"));
d4535 2
a4536 2
				       (char)(I.value[i] ==  ' ' ?
					      HT_NON_BREAK_SPACE : I.value[i]));
d4538 1
a4538 1
		while (i++ < chars) {
d4561 1
a4561 2
	    HTkcode kcode = 0;
	    HTkcode specified_kcode = 0;
d4612 1
a4612 1
		    CTRACE((tfp, "HTML: Ignoring TYPE=\"range\"\n"));
a4617 1
#ifdef EXP_FILE_UPLOAD
a4629 3
#else
		    CTRACE((tfp, "Attempting to fake as: %s\n", I.type));
#endif /* EXP_FILE_UPLOAD */
d4634 2
a4635 1
		    CTRACE((tfp, "HTML: Ignoring TYPE=\"file\"\n"));
d4650 7
a4656 3
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: INPUT tag not within FORM tag\n"));
a4664 2
	    CTRACE((tfp, "Ok, we're trying type=[%s]\n", NONNULL(I.type)));

d4669 7
a4675 2
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag.\n"));
d4682 1
a4682 1
		CTRACE((tfp, "HTML: Missing SELECT end tag, faking it...\n"));
a4776 2
	    CTRACE((tfp, "2.Ok, we're trying type=[%s] (present=%p)\n", NONNULL(I.type), present));
	    /* text+file don't go in here */
d4779 1
a4779 5
		 value[HTML_INPUT_VALUE] &&
		(*value[HTML_INPUT_VALUE] ||
		 (I.type && (!strcasecomp(I.type, "checkbox") ||
			     !strcasecomp(I.type, "radio")))))) {

a4795 1
		CTRACE((tfp, "3.Ok, we're trying type=[%s]\n", NONNULL(I.type)));
a4798 3
#ifdef EXP_FILE_UPLOAD
			 !strcasecomp(I.type, "file") ||
#endif
d4801 1
a4801 2
			 !strcasecomp(I.type, "reset")) {
		    CTRACE((tfp, "normal field type: %s\n", NONNULL(I.type)));
a4802 2
		}

a4809 1
		CTRACE((tfp, "4.Ok, we're trying type=[%s]\n", NONNULL(I.type)));
d4814 2
a4815 3
		    (BOOL)(me->UsePlainSpace && !me->HiddenValue),
		    me->UsePlainSpace,
		    me->HiddenValue);
a4897 3
#ifndef EXP_FILE_UPLOAD
	    CTRACE((tfp, "I.%s have %d chars, or something\n", NONNULL(I.type), chars));
#endif
d4961 1
a4961 1
		 *  treated as part of the editing window, nor be
a4969 3
#ifndef EXP_FILE_UPLOAD
	    CTRACE((tfp, "I.%s, %d\n", NONNULL(I.type), IsSubmitOrReset));
#endif
a4978 6
		if (HTCJK == JAPANESE) {
		    kcode = HText_getKcode(me->text);
		    HText_updateKcode(me->text, kanji_code);
		    specified_kcode = HText_getSpecifiedKcode(me->text);
		    HText_updateSpecifiedKcode(me->text, kanji_code);
		}
d5013 3
a5015 4
					   (char)(I.value[i] ==  ' '
						   ? HT_NON_BREAK_SPACE
						   : I.value[i]));
		    while (i++ < chars)
a5017 4
		if (HTCJK == JAPANESE) {
		    HText_updateKcode(me->text, kcode);
		    HText_updateSpecifiedKcode(me->text, specified_kcode);
		}
d5031 7
a5037 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: TEXTAREA start tag not within FORM tag\n"));
d5077 1
a5077 1
	    isdigit(UCH(*value[HTML_TEXTAREA_COLS])))
d5079 2
a5080 12
	else {
	    int width;
	    width = LYcols - 1 -
		    me->new_style->leftIndent - me->new_style->rightIndent;
	    if (dump_output_immediately) /* don't waste too much for this */
		width = HTMIN(width, 60);
	    if (width > 1 && (width-1)*6 < MAX_LINE - 3 -
		me->new_style->leftIndent - me->new_style->rightIndent)
		HTSprintf0(&me->textarea_cols, "%d", width);
	    else
		StrAllocCopy(me->textarea_cols, "60");
	}
d5084 1
a5084 1
	    isdigit(UCH(*value[HTML_TEXTAREA_ROWS])))
d5121 7
a5127 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: SELECT start tag in SELECT element.  Faking SELECT end tag. *****\n"));
d5154 7
a5160 2
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: OPTION tag not within SELECT tag\n"));
d5330 1
a5330 1
		keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) {
d5348 1
a5348 1
	 *  Not fully implemented.  Just treat as a division
a5351 9
	 *
	 *  Also notify simple table tracking code unless
	 *  in a preformatted section, or (currently) non-left
	 *  alignment.
	 *
	 *  If page author is using a TABLE within PRE, it's probably
	 *  formatted specifically to work well for Lynx without simple
	 *  table tracking code.  Cancel tracking, it would only make
	 *  things worse. - kw
a5352 5
#ifdef EXP_NESTED_TABLES
	if (!nested_tables)
#endif
	HText_cancelStbl(me->text);

d5370 1
a5370 1
	    CTRACE((tfp,
d5372 1
a5372 1
		    MAX_NESTING));
a5376 15
#ifdef SH_EX	/* 1998/10/09 (Fri) 15:20:09 */
		if (no_table_center) {
		    me->DivisionAlignments[me->Division_Level] = HT_LEFT;
		    change_paragraph_style(me, styles[HTML_DLEFT]);
		    UPDATE_STYLE;
		    me->current_default_alignment =
				styles[HTML_DLEFT]->alignment;
		} else {
		    me->DivisionAlignments[me->Division_Level] = HT_CENTER;
		    change_paragraph_style(me, styles[HTML_DCENTER]);
		    UPDATE_STYLE;
		    me->current_default_alignment =
					styles[HTML_DCENTER]->alignment;
		}
#else
a5380 3
#endif
		stbl_align = HT_CENTER;

a5385 1
		stbl_align = HT_RIGHT;
a5390 3
		if (!strcasecomp(value[HTML_TABLE_ALIGN], "left") ||
		    !strcasecomp(value[HTML_TABLE_ALIGN], "justify"))
		    stbl_align = HT_LEFT;
a5396 1
	    /* stbl_align remains HT_ALIGN_NONE */
a5398 1
	HText_startStblTABLE(me->text, stbl_align);
d5403 1
a5403 1
	 *  Not fully implemented.  Just start a new row,
a5405 1
	 *  Also notify simple table tracking code. - kw
a5424 1
/*	    HText_cancelStbl(me->text);  seems unnecessary here - kw */
d5435 1
a5435 1
	    me->sp->style->alignment = (short) me->current_default_alignment;
d5439 1
a5439 7
		!(me->List_Nesting_Level >= 0 && !me->inP)) {
#ifdef SH_EX
		if (no_table_center)
		    me->sp->style->alignment = HT_LEFT;
		else
		    me->sp->style->alignment = HT_CENTER;
#else
d5441 2
a5442 4
#endif
		stbl_align = HT_CENTER;
	    } else if (!strcasecomp(value[HTML_TR_ALIGN], "right") &&
		       !(me->List_Nesting_Level >= 0 && !me->inP)) {
d5444 2
a5445 3
		stbl_align = HT_RIGHT;
	    } else if (!strcasecomp(value[HTML_TR_ALIGN], "left") ||
		       !strcasecomp(value[HTML_TR_ALIGN], "justify")) {
a5446 2
		stbl_align = HT_LEFT;
	    }
a5450 1
	HText_startStblTR(me->text, stbl_align);
a5455 1
	HText_endStblTR(me->text);
d5457 1
a5457 1
	 *  Not fully implemented.  Just check for an ID link. - FM
a5467 13
	if (me->inTABLE) {
	    if (present && present[HTML_TR_ALIGN] && value[HTML_TR_ALIGN]) {
		if (!strcasecomp(value[HTML_TR_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_TR_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_TR_ALIGN], "left") ||
			   !strcasecomp(value[HTML_TR_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblRowGroup(me->text, stbl_align);
	}
d5474 1
a5474 1
	 *  Not fully implemented.  Just check for an ID link. - FM
a5484 19
	if (me->inTABLE) {
	    int span = 1;
	    if (present && present[HTML_COL_SPAN] &&
		value[HTML_COL_SPAN] &&
		isdigit(UCH(*value[HTML_COL_SPAN])))
		span = atoi(value[HTML_COL_SPAN]);
	    if (present && present[HTML_COL_ALIGN] && value[HTML_COL_ALIGN]) {
		if (!strcasecomp(value[HTML_COL_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_COL_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_COL_ALIGN], "left") ||
			   !strcasecomp(value[HTML_COL_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblCOL(me->text, span, stbl_align,
			       (BOOL)(ElementNumber == HTML_COLGROUP));
	}
d5489 17
d5518 1
a5518 2
	 *  Not fully implemented.  Just add a collapsible space and break. - FM
	 *  Also notify simple table tracking code. - kw
a5520 23
	{
	    int colspan = 1, rowspan = 1;
	    if (present && present[HTML_TD_COLSPAN] &&
		value[HTML_TD_COLSPAN] &&
		isdigit(UCH(*value[HTML_TD_COLSPAN])))
		colspan = atoi(value[HTML_TD_COLSPAN]);
	    if (present && present[HTML_TD_ROWSPAN] &&
		value[HTML_TD_ROWSPAN] &&
		isdigit(UCH(*value[HTML_TD_ROWSPAN])))
		rowspan = atoi(value[HTML_TD_ROWSPAN]);
	    if (present && present[HTML_TD_ALIGN] && value[HTML_TD_ALIGN]) {
		if (!strcasecomp(value[HTML_TD_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_TD_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_TD_ALIGN], "left") ||
			   !strcasecomp(value[HTML_TD_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblTD(me->text, colspan, rowspan, stbl_align,
			      (BOOL)(ElementNumber == HTML_TH));
	}
d5538 1
a5538 2
    if (ElementNumber >= HTML_ELEMENTS ||
	HTML_dtd.tags[ElementNumber].contents != SGML_EMPTY) {
d5540 2
a5541 3
	    CTRACE((tfp,
    "HTML:begin_element: internal call (level %d), leaving on stack - `%s'\n",
			me->skip_stack, NONNULL(me->sp->style->name)));
d5543 1
a5543 1
	    return status;
d5547 2
a5548 2
		HTAlert(HTML_STACK_OVERRUN);
		CTRACE((tfp,
d5550 5
a5554 1
			MAX_NESTING));
d5557 1
a5557 1
	    return HT_ERROR;
d5560 3
a5562 4
	CTRACE((tfp, "HTML:begin_element[%d]: adding style to stack - %s (%s)\n",
		     (int) STACKLEVEL(me),
		     NONNULL(me->new_style->name),
		     HTML_dtd.tags[ElementNumber].name));
a5565 5
#ifdef EXP_JUSTIFY_ELTS
	if (wait_for_this_stacked_elt < 0 &&
		HTML_dtd.tags[ElementNumber].can_justify == FALSE)
	    wait_for_this_stacked_elt = me->stack - me->sp + MAX_NESTING;
#endif
a5567 7
#ifdef EXP_JUSTIFY_ELTS
    if (in_DT && ElementNumber == HTML_DD)
	in_DT = FALSE;
    else if (ElementNumber == HTML_DT)
	in_DT = TRUE;
#endif

d5570 2
d5573 1
a5573 1
    if (ReallyEmptyTagNum(element_number))
d5575 4
a5578 2
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE.begin_element:ending \"EMPTY\" element style\n"));
d5580 1
a5594 1
    return status;
d5611 1
a5611 1
PRIVATE int HTML_end_element ARGS3(
a5616 1
    int status = HT_OK;
a5618 3
    BOOL intern_flag = FALSE;
    BOOL skip_stack_requested = FALSE;
    EMIT_IFDEF_EXP_JUSTIFY_ELTS(BOOL reached_awaited_stacked_elt = FALSE);
d5620 1
a5620 1
#ifdef USE_PRETTYSRC
d5633 1
a5633 1
		LYstrncpy(buf, tag->name, sizeof(buf)-1);
d5640 1
a5640 1
	    return HT_OK;
d5646 2
a5647 2
    if ((me->sp >= (me->stack + MAX_NESTING - 1) ||
	 element_number != me->sp[0].tag_number) &&
d5649 2
a5650 2
	CTRACE((tfp,
		"HTML: end of element %s when expecting end of %s\n",
d5652 1
a5652 5
	       (me->sp == me->stack + MAX_NESTING - 1) ? "none" :
	       (me->sp->tag_number < 0) ? "*invalid tag*" :
	       (me->sp->tag_number >= HTML_ELEMENTS) ? "special tag" :
		HTML_dtd.tags[me->sp->tag_number].name));
#ifdef CAREFUL			/* parser assumed to produce good nesting */
d5654 1
a5655 1
    }
d5662 2
a5663 3
	if (!(element_number == HTML_MAP || element_number == HTML_AREA ||
	      element_number == HTML_OBJECT)) {
	    return HT_OK;
a5671 1
	skip_stack_requested = (BOOL) (me->skip_stack > 0);
d5678 1
a5678 2
	     me->sp[0].tag_number == HTML_DIR ||
	     me->sp[0].tag_number == HTML_LI) &&
a5691 4
	if (me->skip_stack == 0 && element_number == HTML_OBJECT &&
	    me->sp[0].tag_number == HTML_OBJECT_M &&
	    (me->sp < (me->stack + MAX_NESTING - 1)))
	    me->sp[0].tag_number = HTML_OBJECT;
d5693 2
a5694 3
	    CTRACE2(TRACE_STYLE,
		    (tfp, "HTML:end_element: Internal call (level %d), leaving on stack - %s\n",
			  me->skip_stack, NONNULL(me->sp->style->name)));
a5695 18
	} else if (element_number == HTML_OBJECT &&
		   me->sp[0].tag_number != HTML_OBJECT &&
		   me->sp[0].tag_number != HTML_OBJECT_M &&
		   me->objects_mixed_open > 0 &&
		   !(me->objects_figged_open > 0 &&
		       me->sp[0].tag_number == HTML_FIG)) {
	    /*
	     *	Ignore non-corresponding OBJECT tags that we
	     *	didn't push because the SGML parser was supposed
	     *  to go on parsing the contents non-literally. - kw
	     */
	    CTRACE2(TRACE_STYLE,
		    (tfp, "HTML:end_element[%d]: %s (level %d), %s - %s\n",
			   (int) STACKLEVEL(me),
			   "Special OBJECT handling", me->objects_mixed_open,
			   "leaving on stack",
			   NONNULL(me->sp->style->name)));
	    me->objects_mixed_open--;
d5709 1
a5709 1
	    return HT_OK; /* let's pretend... */
d5718 1
a5718 1
	    return HT_OK;
d5724 1
a5724 2
	     me->sp[0].tag_number == HTML_DIR ||
	     me->sp[0].tag_number == HTML_LI) &&
d5736 1
a5736 1
	    return HT_OK;
a5737 23
#ifdef EXP_JUSTIFY_ELTS
	    if (wait_for_this_stacked_elt == me->stack - me->sp + MAX_NESTING)
		reached_awaited_stacked_elt = TRUE;
#endif
	    if (element_number == HTML_OBJECT) {
		if (me->sp[0].tag_number == HTML_FIG &&
		    me->objects_figged_open > 0) {
		    /*
		     *  It's an OBJECT for which we substituted a FIG,
		     *  so pop the FIG and pretend that's what we are
		     *  being called for. - kw
		     */
		    CTRACE2(TRACE_STYLE,
			    (tfp, "HTML:end_element[%d]: %s (level %d), %s - %s\n",
				  (int) STACKLEVEL(me),
				  "Special OBJECT->FIG handling",
				  me->objects_figged_open,
				  "treating as end FIG",
				  NONNULL(me->sp->style->name)));
		    me->objects_figged_open--;
		    element_number = HTML_FIG;
		}
	    }
d5739 3
a5741 4
	    CTRACE2(TRACE_STYLE,
		    (tfp, "HTML:end_element[%d]: Popped style off stack - %s\n",
			  (int) STACKLEVEL(me),
			  NONNULL(me->sp->style->name)));
d5743 2
a5744 2
	    CTRACE2(TRACE_STYLE, (tfp,
  "Stack underflow error!  Tried to pop off more styles than exist in stack\n"));
d5747 2
a5748 7
    if (BreakFlag == TRUE) {
#ifdef EXP_JUSTIFY_ELTS
	    if (reached_awaited_stacked_elt)
		wait_for_this_stacked_elt=-1;
#endif
	return HT_OK; /* let's pretend... */
    }
d5754 6
a5759 2
	if (LYBadHTML(me))
	    CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag\n"));
d5773 2
a5774 2
	    if (LYBadHTML(me))
		CTRACE((tfp,
d5780 5
a5784 1
			me->inA ? "A" : ""));
d5790 1
a5790 2
	    (LYIsUIPage3(me->node_anchor->address, UIP_LIST_PAGE, 0) ||
	     LYIsUIPage3(me->node_anchor->address, UIP_ADDRLIST_PAGE, 0))) {
d5820 1
a5820 1
	    if ((LYMultiBookmarks != MBM_OFF) ||
a5822 2
		if (!include)
		    include = &me->xinclude;
d5860 2
a5861 3
	CTRACE2(TRACE_STYLE,
		(tfp, "HTML: STYLE content =\n%s\n",
		      me->style_block.data));
d5871 2
a5872 2
	CTRACE((tfp, "HTML: SCRIPT content =\n%s\n",
			    me->script.data));
d5878 2
a5879 2
	    if (LYBadHTML(me))
		CTRACE((tfp,
d5885 5
a5889 1
			me->inA ? "A" : ""));
d5926 2
a5927 6
	if (me->Division_Level >= 0) {
	    if (me->sp->style->alignment !=
		me->DivisionAlignments[me->Division_Level]) {
		if (me->inP)
		    LYEnsureSingleSpace(me);
		me->sp->style->alignment =
a5928 2
	    }
	}
d5930 1
a5930 6
	if (me->style_change) {
	    actually_set_style(me);
	    if (me->List_Nesting_Level >= 0)
		HText_NegateLineOne(me->text);
	} else if (me->inP)
	    LYEnsureSingleSpace(me);
d5932 2
d5970 1
a5970 1
	LYHandlePlike(me,
d5972 1
a5972 1
		 include, 0,
d6003 1
a6003 1
	    CTRACE((tfp, "Ending underline\n"));
d6005 1
a6005 1
	    CTRACE((tfp, "Underline Level is %d\n", me->Underline_Level));
d6019 1
a6024 4
    case HTML_SUB:
	HText_appendCharacter(me->text, ']');
	break;

a6069 1
	/* FALLTHRU */
a6070 1
	/* FALLTHRU */
a6071 1
	/* FALLTHRU */
a6095 1
	/* FALLTHRU */
a6096 1
	/* FALLTHRU */
a6097 1
	/* FALLTHRU */
a6098 1
	/* FALLTHRU */
d6101 2
a6102 6
	CTRACE((tfp, "HTML_end_element: Reducing List Nesting Level to %d\n",
		    me->List_Nesting_Level));
#ifdef EXP_JUSTIFY_ELTS
	if (element_number == HTML_DL)
	    in_DT = FALSE; /*close the term that was without definition. */
#endif
d6135 1
a6135 6
#ifdef MARK_HIDDEN_LINKS
	if (hidden_link_marker && *hidden_link_marker &&
		HText_isAnchorBlank(me->text, me->CurrentANum) ) {
	    HText_appendText(me->text,hidden_link_marker);
	}
#endif
d6169 13
a6181 5
	LYHandleFIG(me, NULL, NULL,
		    0,
		    0,
		    NULL,
		    NULL, NO, FALSE, &intern_flag);
d6190 1
a6190 2
	    char *start = NULL, *first_end = NULL, *last_end = NULL;
	    char *first_map = NULL, *last_map = NULL;
d6206 1
a6206 2
		} else if (s == 0 && !strncasecomp(cp, "<PARAM", 6) &&
		    !IsNmChar(cp[6])) {
d6208 1
a6208 2
		} else if (!strncasecomp(cp, "<OBJECT", 7) &&
		    !IsNmChar(cp[7])) {
d6212 1
a6212 2
		} else if (!strncasecomp(cp, "</OBJECT", 8) &&
		    !IsNmChar(cp[8])) {
a6214 1
		    last_end = cp;
a6215 8
		} else if (!strncasecomp(cp, "<MAP", 4) &&
		    !IsNmChar(cp[4])) {
		    if (!first_map)
			first_map = cp;
		    last_map = cp;
		} else if (!strncasecomp(cp, "</MAP", 5) &&
		    !IsNmChar(cp[5])) {
		    last_map = cp;
d6219 20
d6244 8
a6251 3
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content:\n%s\n",
			    me->object.data));
a6253 54
	    if (s > e) {
		if (!me->object_declare && !me->object_name &&
		    !(me->object_shapes && !LYMapsOnly) &&
		    !(me->object_usemap != NULL && !LYMapsOnly) &&
		    !(clickable_images && !LYMapsOnly &&
		      me->object_data != NULL &&
		      !have_param &&
		      me->object_classid == NULL &&
		      me->object_codebase == NULL &&
		      me->object_codetype == NULL)) {
		    /*
		     *  We have nested OBJECT tags, and not yet all of the
		     *  end tags, but have a case where the content needs
		     *  to be parsed again (not dropped) and where we don't
		     *  want to output anything special at the point when we
		     *  *do* have accumulated all the end tags.  So recycle
		     *  the incomplete contents now, and signal the SGML
		     *  parser that it should not regard the current OBJECT
		     *  ended but should treat its contents as mixed.
		     *  Normally these cases would have already handled
		     *  in the real start_element call, so this block may
		     *  not be necessary. - kw
		     */
		    CTRACE((tfp, "%s:\n%s\n",
			   "HTML: Nested OBJECT tags.  Recycling incomplete contents",
			   me->object.data));
		    status = HT_PARSER_OTHER_CONTENT;
		    me->object.size--;
		    HTChunkPuts(&me->object, "</OBJECT>");
		    if (!include)	/* error, should not happen */
			include = &me->xinclude;
		    StrnAllocCat(*include, me->object.data, me->object.size);
		    clear_objectdata(me);
		    /* an internal fake call to keep our stack happy: */
		    HTML_start_element(me, HTML_OBJECT, NULL,NULL,
				       me->tag_charset, include);
		    break;
		}
		/*
		 *  We have nested OBJECT tags, and not yet all of the
		 *  end tags, and we want the end tags.  So restore an
		 *  end tag to the content, and signal to the SGML parser
		 *  that it should resume the accumulation of OBJECT content
		 *  (after calling back to start_element) in a way that
		 *  is equivalent to passing it a dummy start tag. - FM, kw
		 */
		CTRACE((tfp, "HTML: Nested OBJECT tags.  Recycling.\n"));
		status = HT_PARSER_REOPEN_ELT;
		me->object.size--;
		HTChunkPuts(&me->object, "</OBJECT>");
		if (!LYMapsOnly)
		    change_paragraph_style(me, me->sp->style);
		break;
	    }
d6260 1
a6260 1
	    CTRACE((tfp, "HTML:OBJECT content:\n%s\n", me->object.data));
d6271 1
a6271 1
		if (me->object_id && *me->object_id && !LYMapsOnly)
d6273 1
a6273 1
		CTRACE((tfp, "HTML: DECLAREd OBJECT.  Ignoring!\n"));
d6283 1
a6283 1
	    if (me->object_name != NULL && !LYMapsOnly) {
d6286 1
a6286 1
		CTRACE((tfp, "HTML: NAMEd OBJECT.  Ignoring!\n"));
d6302 6
a6307 21
		    if (LYMapsOnly) {
			/*
			 *  Well we don't need to do this any more,
			 *  nested objects should either not get here
			 *  any more at all or can be handled fine by
			 *  other code below.  Leave in place for now
			 *  as a special case for LYMapsOnly. - kw
			 */
			if (LYMapsOnly && (!last_map || last_map < first_end))
			    *first_end = '\0';
			else
			    e = 0;
			data = NULL;
			if (LYMapsOnly && (!first_map || first_map > start))
			    StrAllocCopy(data, start);
			else
			    StrAllocCopy(data, me->object.data);
			if (e > 0) {
			    for (i = e; i > 0; i--) {
				StrAllocCat(data, "</OBJECT>");
			    }
a6308 7
			if (!include)	/* error, should not happen */
			    include = &me->xinclude;
			StrAllocCat(*include, data);
			CTRACE((tfp, "HTML: Recycling nested OBJECT%s.\n",
			       (s > 1) ? "s" : ""));
			FREE(data);
			goto End_Object;
d6310 6
d6317 7
a6323 2
		    if (LYBadHTML(me))
			CTRACE((tfp, "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content.\n"));
d6329 4
a6332 10
	     *	If its content has SHAPES, convert it to FIG. - FM
	     *
	     *  This is now handled in our start_element without using
	     *  include if the SGML parser cooperates, so this block
	     *  may be unnecessary. - kw
	     */
	    if (me->object_shapes == TRUE && !LYMapsOnly) {
		CTRACE((tfp, "HTML: OBJECT has SHAPES.  Converting to FIG.\n"));
		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
d6359 2
a6360 2
	    if (me->object_usemap != NULL && !LYMapsOnly) {
		CTRACE((tfp, "HTML: OBJECT has USEMAP.  Converting to IMG.\n"));
a6361 2
		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
a6404 47
		/*
		 *  Add the content if it has <MAP, since that may
		 *  be the MAP this usemap points to.  But if we have
		 *  nested objects, try to eliminate portions that
		 *  cannot contribute to the quest for MAP.  This is
		 *  not perfect, we may get too much content; this seems
		 *  preferable over losing too much. - kw
		 */
		if (first_map) {
		    if (s == 0) {
			StrAllocCat(*include, me->object.data);
			CTRACE((tfp, "HTML: MAP found, recycling object contents.\n"));
			goto End_Object;
		    }
		    /* s > 0 and s == e */
		    data = NULL;
		    if (last_map < start) {
			*start = '\0';
			i = 0;
		    } else if (last_map < first_end) {
			*first_end = '\0';
			i = e;
		    } else if (last_map < last_end) {
			*last_end = '\0';
			i = 1;
		    } else {
			i = 0;
		    }
		    if (first_map > last_end) {
			/* fake empty object to keep stacks stack happy */
			StrAllocCopy(data, "<OBJECT><");
			StrAllocCat(data, last_end + 1);
			i = 0;
		    } else if (first_map > start) {
			StrAllocCopy(data, start);
		    } else {
			StrAllocCopy(data, me->object.data);
		    }
		    for (; i > 0; i--) {
			StrAllocCat(data, "</OBJECT>");
		    }
		    CTRACE((tfp, "%s:\n%s\n",
			   "HTML: MAP and nested OBJECT tags.  Recycling parts",
			   data));
		    StrAllocCat(*include, data);
		    FREE(data);
		}
d6411 1
a6411 1
	    if (me->object_id && *me->object_id && !LYMapsOnly)
d6417 1
a6417 3
	    if (me->object.size > 1) {
		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
a6418 1
	    }
d6429 1
a6429 2
		if (!LYMapsOnly &&
		    me->object_data != NULL &&
a6441 2
		    if (!include)	/* error, should not happen */
			include = &me->xinclude;
d6462 14
a6475 1
	clear_objectdata(me);
d6477 1
a6477 2
	if (!LYMapsOnly)
	    change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6516 6
a6521 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Unmatched FORM end tag\n"));
a6522 1
	EMIT_IFDEF_EXP_JUSTIFY_ELTS(form_in_htext = FALSE);
d6536 7
a6542 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Open SELECT at FORM end. Faking SELECT end tag. *****\n"));
d6594 6
a6599 2
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Unmatched TEXTAREA end tag\n"));
d6633 1
d6646 3
a6648 3
	     *	Transform the TEXTAREA content as needed, then parse
	     *	it into individual lines to be handled as a series
	     *  series of INPUT fields (ugh!).
a6651 5
	     *
	     *  If TEXTAREA is handled as SGML_LITTERAL (the old way),
	     *	we need to SGML-unescape any character references and NCRs
	     *  here.  Otherwise this will already have happened in the
	     *  SGML.c parsing. - kw
d6655 1
a6655 23
	    if (HTML_dtd.tags[element_number].contents == SGML_LITTERAL) {
		TRANSLATE_AND_UNESCAPE_ENTITIES6(&me->textarea.data,
						 me->UCLYhndl,
						 current_char_set,
						 NO,
						 me->UsePlainSpace, me->HiddenValue);
	    } else {
		/*
		 *  This shouldn't have anything to do, normally, but
		 *  just in case...
		 *  There shouldn't be lynx special character codes in
		 *  the chunk ("DTD" flag Tgf_nolyspcl tells SGML.c not
		 *  to generate them).  If there were, we could set the
		 *  last parameter ('Back') below to YES, which would
		 *  take them out of the data.
		 *  The data may however contain non break space, soft
		 *  hyphen, or en space etc., in the me->UCLYhndl character
		 *  encoding.  If that's a problem, perhaps for the (line
		 *  or other) editor, setting 'Back' to YES should also
		 *  help to always convert them to plain spaces (or drop
		 *  them). - kw
		 */
		TRANSLATE_HTML7(&me->textarea.data,
d6658 1
a6658 5
						    NO,
						    me->UsePlainSpace, me->HiddenValue,
						    NO);
	    }
	    data = me->textarea.data;
d6698 1
a6698 1
			temp[j] = (char) (temp[j+1] ? ' ' : '\0');
d6731 1
a6731 1
			temp[j] = (char) (temp[j+1] ? ' ' : '\0');
d6773 6
a6778 2
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Unmatched SELECT end tag *****\n"));
d6796 7
a6802 3
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: SELECT end tag not within FORM element *****\n"));
d6858 1
a6858 9
		    else {
			HTkcode kcode = 0;
			HTkcode specified_kcode = 0;
			if (HTCJK == JAPANESE) {
			    kcode = HText_getKcode(me->text);
			    HText_updateKcode(me->text, kanji_code);
			    specified_kcode = HText_getSpecifiedKcode(me->text);
			    HText_updateSpecifiedKcode(me->text, kanji_code);
			}
a6859 5
			if (HTCJK == JAPANESE) {
			    HText_updateKcode(me->text, kcode);
			    HText_updateSpecifiedKcode(me->text, specified_kcode);
			}
		    }
a6885 3
#ifdef EXP_NESTED_TABLES
	if (!nested_tables)
#endif
a6886 1

a6896 7
#ifdef EXP_NESTED_TABLES
	if (nested_tables) {
	    me->inTABLE = HText_endStblTABLE(me->text);
	} else
#endif
	HText_endStblTABLE(me->text);

a6903 1
	HText_endStblTR(me->text);
a6916 2
	if (me->inTABLE)
	    HText_endStblCOLGROUP(me->text);
d6920 2
a6922 1
	HText_endStblTD(me->text);
a6961 12

#ifdef EXP_JUSTIFY_ELTS
	    if (reached_awaited_stacked_elt)
		wait_for_this_stacked_elt=-1;
#endif

    if (me->xinclude) {
	HText_appendText(me->text, " *** LYNX ERROR ***\rUnparsed data:\r");
	HText_appendText(me->text, me->xinclude);
	FREE(me->xinclude);
    }

a6962 1
    if (!skip_stack_requested) { /*don't emit stylechanges if skipped stack element - VH*/
d6964 2
a6965 2
	TrimColorClass(HTML_dtd.tags[element_number].name,
		       Style_className, &hcode);
d6968 4
a6971 4
	FastTrimColorClass(HTML_dtd.tags[element_number].name,
			   HTML_dtd.tags[element_number].name_len,
			   Style_className,
			   &Style_className_end, &hcode);
d6975 8
a6982 7
	if (!ReallyEmptyTagNum(element_number))
	{
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.end_element: ending non-\"EMPTY\" style <%s...>\n",
			  HTML_dtd.tags[element_number].name));
	    HText_characterStyle(me->text, HCODE_TO_STACK_OFF(hcode), STACK_OFF);
	}
a6984 1
    return status;
a7026 2
	clear_objectdata(me);
	FREE(me->xinclude);
d7055 1
a7055 1
	    CTRACE((tfp, "HTML_free: Ending underline\n"));
a7059 1
	    CTRACE((tfp, "HTML_free: Ending HTML_A\n"));
d7075 7
a7081 3
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: SELECT or OPTION not ended properly *****\n"));
d7087 2
a7088 2
	    CTRACE((tfp, "HTML_free: ***** leftover option data: %s\n",
			me->option.data));
d7098 7
a7104 3
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: TEXTAREA not used properly *****\n"));
d7110 2
a7111 2
	    CTRACE((tfp, "HTML_free: ***** leftover textarea data: %s\n",
			me->textarea.data));
a7131 5
	if (me->xinclude) {
	    HText_appendText(me->text, " *** LYNX ERROR ***\rUnparsed data:\r");
	    HText_appendText(me->text, me->xinclude);
	    FREE(me->xinclude);
	}
d7144 7
a7150 3
	if (LYBadHTML(me))
	    CTRACE((tfp,
		    "Bad HTML: SELECT or OPTION not ended properly *****\n"));
d7153 2
a7154 2
	    CTRACE((tfp, "HTML_free: ***** leftover option data: %s\n",
			 me->option.data));
d7164 7
a7170 3
	if (LYBadHTML(me))
	    CTRACE((tfp,
		    "Bad HTML: TEXTAREA not used properly *****\n"));
d7173 2
a7174 2
	    CTRACE((tfp, "HTML_free: ***** leftover textarea data: %s\n",
			 me->textarea.data));
a7202 1
    clear_objectdata(me);
d7246 2
a7247 1
	    CTRACE((tfp, "HTML_abort: SELECT or OPTION not ended properly *****\n"));
d7249 2
a7250 2
	    CTRACE((tfp, "HTML_abort: ***** leftover option data: %s\n",
			 me->option.data));
d7261 2
a7262 1
	    CTRACE((tfp, "HTML_abort: TEXTAREA not used properly *****\n"));
d7264 2
a7265 2
	    CTRACE((tfp, "HTML_abort: ***** leftover textarea data: %s\n",
			 me->textarea.data));
a7297 2
    FREE(me->xinclude);
    clear_objectdata(me);
d7421 1
a7421 1
	exit_immediately (EXIT_FAILURE);
d7424 1
a7424 1
    me = typecalloc(HTStructured);
d7444 9
a7452 3
    HTChunkInit(&me->title, 128);

    HTChunkInit(&me->object, 128);
d7467 4
a7470 1
    HTChunkInit(&me->option, 128);
d7476 4
a7479 1
    HTChunkInit(&me->textarea, 128);
d7488 14
a7501 5
    HTChunkInit(&me->math, 128);

    HTChunkInit(&me->style_block, 128);

    HTChunkInit(&me->script, 128);
d7567 47
d7650 5
a7663 10

/*
 *  A flag set by a file write error.  Used for only generating an alert
 *  the first time such an error happens, since Lynx should still be usable
 *  if the temp space becomes full, and an alert each time a cache file
 *  cannot be written would be annoying.  Reset when  lynx.cfg is being
 *  reloaded (user may change SOURCE_CACHE setting). - kw
 */
PUBLIC BOOLEAN source_cache_file_error = FALSE;

d7668 1
a7668 1
PRIVATE void CacheThru_do_free ARGS1(
d7671 1
a7671 16
    if (me->anchor->source_cache_file) {
	CTRACE((tfp, "SourceCacheWriter: Removing previous file %s\n",
		me->anchor->source_cache_file));
	LYRemoveTemp(me->anchor->source_cache_file);
	FREE(me->anchor->source_cache_file);
    }
    if (me->anchor->source_cache_chunk) {
	CTRACE((tfp, "SourceCacheWriter: Removing previous memory chunk %p\n",
		(void *)me->anchor->source_cache_chunk));
	HTChunkFree(me->anchor->source_cache_chunk);
	me->anchor->source_cache_chunk = NULL;
    }
    if (me->fp) {
	fflush(me->fp);
	if (ferror(me->fp))
	    me->status = HT_ERROR;
a7672 34
	if (me->status == HT_OK) {
	    me->anchor->source_cache_file = me->filename;
	    CTRACE((tfp,
		    "SourceCacheWriter: Committing file %s for URL %s to anchor\n",
		    me->filename, HTAnchor_address((HTAnchor *)me->anchor)));
	} else {
	    if (source_cache_file_error == FALSE) {
		HTAlert(gettext("Source cache error - disk full?"));
		source_cache_file_error = TRUE;
	    }
	    LYRemoveTemp(me->filename);
	    me->anchor->source_cache_file = NULL;
	}
    } else if (me->status != HT_OK) {
	if (me->chunk) {
	    CTRACE((tfp, "SourceCacheWriter: memory chunk %p had errors.\n",
		    me->chunk));
	    HTChunkFree(me->chunk);
	    me->chunk = NULL;
	}
	HTAlert(gettext("Source cache error - not enough memory!"));
    }
    if (me->chunk) {
	me->anchor->source_cache_chunk = me->chunk;
	CTRACE((tfp,
		"SourceCacheWriter: Committing memory chunk %p for URL %s to anchor\n",
		(void *)me->chunk, HTAnchor_address((HTAnchor *)me->anchor)));
    }
}

PRIVATE void CacheThru_free ARGS1(
	HTStream *,	me)
{
    CacheThru_do_free(me);
a7682 16
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((tfp, "SourceCacheWriter: Removing active file %s\n",
		    me->filename));
	    LYRemoveTemp(me->filename);
	    FREE(me->filename);
	}
	if (me->chunk) {
	    CTRACE((tfp, "SourceCacheWriter: Removing active memory chunk %p\n",
		    (void *)me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	/*fake it*/
	CacheThru_do_free(me);
    }
d7691 4
a7694 9
    if (me->status == HT_OK) {
	if (me->fp) {
	    fputc(c_in, me->fp);
	} else if (me->chunk) {
	    HTChunkPutc(me->chunk, c_in);
	    if (me->chunk->allocated == 0)
		me->status = HT_ERROR;
	}
    }
d7702 4
a7705 9
    if (me->status == HT_OK) {
	if (me->fp) {
	    fputs(str, me->fp);
	} else if (me->chunk) {
	    HTChunkPuts(me->chunk, str);
	    if (me->chunk->allocated == 0 && *str)
		me->status = HT_ERROR;
	}
    }
d7714 4
a7717 11
    if (me->status == HT_OK) {
	if (me->fp) {
	    fwrite(str, 1, l, me->fp);
	    if (ferror(me->fp))
		me->status = HT_ERROR;
	} else if (me->chunk) {
	    HTChunkPutb(me->chunk, str, l);
	    if (me->chunk->allocated == 0 && l != 0)
		me->status = HT_ERROR;
	}
    }
d7749 1
a7749 1
	CTRACE((tfp, "SourceCacheWriter: Protocol is \"%s\"; not caching\n", p->name));
a7760 1
    stream->anchor = anchor;
a7761 1
    stream->filename = NULL;
a7764 1
    stream->status = HT_OK;
d7767 5
a7771 3
	if (anchor->source_cache_file) {
	    CTRACE((tfp, "SourceCacheWriter: If successful, will replace source cache file %s\n",
		    anchor->source_cache_file));
d7780 3
a7782 3
	if (!(stream->fp = LYOpenTemp(filename, HTML_SUFFIX, BIN_W))) {
	    CTRACE((tfp, "SourceCacheWriter: Cannot open source cache file for URL %s\n",
		   HTAnchor_address((HTAnchor *)anchor)));
d7787 4
a7790 1
	StrAllocCopy(stream->filename, filename);
d7792 2
a7793 2
	CTRACE((tfp, "SourceCacheWriter: Caching source for URL %s in file %s\n",
		     HTAnchor_address((HTAnchor *)anchor), filename));
d7797 5
a7801 4
	if (anchor->source_cache_chunk) {
	    CTRACE((tfp,
		    "SourceCacheWriter: If successful, will replace memory chunk %p\n",
		    (void *)anchor->source_cache_chunk));
d7804 4
a7807 10
#ifdef SAVE_TIME_NOT_SPACE
	stream->chunk = HTChunkCreateMayFail(4096, 1);
#else
	stream->chunk = HTChunkCreateMayFail(128, 1);
#endif
	if (!stream->chunk)	/* failed already? pretty bad... - kw */
	    stream->status = HT_ERROR;

	CTRACE((tfp, "SourceCacheWriter: Caching source for URL %s in memory chunk %p\n",
	       HTAnchor_address((HTAnchor *)anchor), (void *)stream->chunk));
a7812 2
#else
#define CacheThru_new(anchor, target) target
d7828 1
d7832 3
d7893 1
d7897 3
d7909 1
a7909 1
**	It is registered in HTInit.c, but normally not used by lynx.
d7918 2
a7919 2
    if (sink)
	(*sink->isa->put_string)(sink, "/* ");	/* Before even title */
d7923 2
a7924 2
    if (!sink)
	HTML_put_string(html,html->comment_start);
d7927 3
d7946 1
d7950 3
a8002 21
#ifdef SH_EX	/* 1998/04/02 (Thu) 16:02:00 */

    /* for proxy server 1998/12/19 (Sat) 11:53:30 */
    if (AS_casecomp(newtitle + 1, "internal-gopher-menu") == 0) {
	StrAllocCopy(newtitle, "+");
    } else if (AS_casecomp(newtitle + 1, "internal-gopher-unknown") == 0) {
	StrAllocCopy(newtitle, " ");
    } else {
	/* normal title */
	ptr = strrchr(newtitle, '.');
	if (ptr) {
	  if (AS_casecomp(ptr, ".gif") == 0)
	    *ptr = '\0';
	  else if (AS_casecomp(ptr, ".jpg") == 0)
	    *ptr = '\0';
	  else if (AS_casecomp(ptr, ".jpeg") == 0)
	    *ptr = '\0';
	}
	StrAllocCat(newtitle, "]");
    }
#else
a8003 1
#endif
d8030 1
a8030 1
    if ( verbose_img && value[HTML_IMG_SRC] && *value[HTML_IMG_SRC] ) {
@

