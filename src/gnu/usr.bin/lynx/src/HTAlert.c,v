head	1.10;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.9
	tg-mergefixes-1-branch:1.9.0.4
	tg-mergefixes-1-base:1.9
	MIROS_X:1.9.0.2
	MIROS_X_BASE:1.9
	MIRBSD_XP_MIRPPC:1.7.0.4
	lynx-2_8_6dev_7b:1.1.3.8
	lynx-2_8_6dev_6:1.1.3.7
	MIRBSD_XP_SPARC_BASE:1.7
	MIRBSD_XP_SPARC:1.7.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.6
	lynx-2_8_6dev_5:1.1.3.6
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.1.3.2
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.5
	lynx-2_8_5:1.1.3.4
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.3
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.1.3.2.0.6
	MIRBSD_7:1.1.3.2.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.1.3.2
	MIRBSD_7_DEV:1.1.3.2.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2005.01.03.00.45.53;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.20.10.26.24;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.11.20.30.39;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.15.18.16.48;	author tg;	state Stab;
branches;
next	1.6;

1.6
date	2004.04.30.16.32.30;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.08.19.48.58;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.07.20.02.30;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.27;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.25;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.16;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.15;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.21;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.46.11;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.01.18.15.34.42;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.02.08.13.11.17;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.04.30.16.16.03;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.07.15.15.53.22;	author tg;	state Exp;
branches;
next	1.1.3.7;

1.1.3.7
date	2004.10.11.20.16.23;	author tg;	state Exp;
branches;
next	1.1.3.8;

1.1.3.8
date	2004.10.20.10.10.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.10
log
@soft merge
@
text
@/* $MirBSD: src/gnu/usr.bin/lynx/src/HTAlert.c,v 1.9 2004/10/20 10:26:24 tg Exp $ */

/*	Displaying messages and getting input for Lynx Browser
 *	==========================================================
 *
 *	REPLACE THIS MODULE with a GUI version in a GUI environment!
 *
 * History:
 *	   Jun 92 Created May 1992 By C.T. Barker
 *	   Feb 93 Simplified, portablised TBL
 *
 */

#include <HTUtils.h>
#include <HTAlert.h>
#include <LYGlobalDefs.h>
#include <LYCurses.h>
#include <LYStrings.h>
#include <LYUtils.h>
#include <LYClean.h>
#include <GridText.h>
#include <LYCookie.h>
#include <LYHistory.h>		/* store statusline messages */

#include <LYLeaks.h>

#include <HTParse.h>

#undef timezone			/* U/Win defines this in time.h, hides implementation detail */

#if defined(HAVE_FTIME) && defined(HAVE_SYS_TIMEB_H)
#include <sys/timeb.h>
#endif

/*
 * 'napms()' is preferable to 'sleep()' in any case because it does not
 * interfere with output, but also because it can be less than a second.
 */
#ifdef HAVE_NAPMS
#define LYSleep(n) napms(n)
#else
#define LYSleep(n) sleep(n)
#endif

/*	Issue a message about a problem.		HTAlert()
 *	--------------------------------
 */
void HTAlert(const char *Msg)
{
    CTRACE((tfp, "\nAlert!: %s\n\n", Msg));
    CTRACE_FLUSH(tfp);
    _user_message(ALERT_FORMAT, Msg);
    LYstore_message2(ALERT_FORMAT, Msg);

    LYSleepAlert();
}

void HTAlwaysAlert(const char *extra_prefix,
		   const char *Msg)
{
    if (!dump_output_immediately && LYCursesON) {
	HTAlert(Msg);
    } else {
	if (extra_prefix) {
	    fprintf(((TRACE) ? stdout : stderr),
		    "%s %s!\n",
		    extra_prefix, Msg);
	    fflush(stdout);
	    LYstore_message2(ALERT_FORMAT, Msg);
	    LYSleepAlert();
	} else {
	    fprintf(((TRACE) ? stdout : stderr), ALERT_FORMAT, NonNull(Msg));
	    fflush(stdout);
	    LYstore_message2(ALERT_FORMAT, Msg);
	    LYSleepAlert();
	    fprintf(((TRACE) ? stdout : stderr), "\n");
	}
	CTRACE((tfp, "\nAlert!: %s\n\n", Msg));
	CTRACE_FLUSH(tfp);
    }
}

/*	Issue an informational message.			HTInfoMsg()
 *	--------------------------------
 */
void HTInfoMsg(const char *Msg)
{
    _statusline(Msg);
    if (non_empty(Msg)) {
	CTRACE((tfp, "Info message: %s\n", Msg));
	LYstore_message(Msg);
	LYSleepInfo();
    }
}

/*	Issue an important message.			HTUserMsg()
 *	--------------------------------
 */
void HTUserMsg(const char *Msg)
{
    _statusline(Msg);
    if (non_empty(Msg)) {
	CTRACE((tfp, "User message: %s\n", Msg));
	LYstore_message(Msg);
#if !(defined(USE_SLANG) || defined(WIDEC_CURSES))
	if (HTCJK != NOCJK) {
	    clearok(curscr, TRUE);
	    LYrefresh();
	}
#endif
	LYSleepMsg();
    }
}

void HTUserMsg2(const char *Msg2, const char *Arg)
{
    _user_message(Msg2, Arg);
    if (non_empty(Msg2)) {
	CTRACE((tfp, "User message: "));
	CTRACE((tfp, Msg2, Arg));
	CTRACE((tfp, "\n"));
	LYstore_message2(Msg2, Arg);
	LYSleepMsg();
    }
}

/*	Issue a progress message.			HTProgress()
 *	-------------------------
 */
void HTProgress(const char *Msg)
{
    statusline(Msg);
    LYstore_message(Msg);
    CTRACE((tfp, "%s\n", Msg));
    LYSleepDebug();
}

const char *HTProgressUnits(int rate)
{
    static const char *bunits = 0;
    static const char *kbunits = 0;

    if (!bunits) {
	bunits = gettext("bytes");
	kbunits = gettext("KiB");
    }
    return ((rate == rateKB)
#ifdef USE_READPROGRESS
	    || (rate == rateEtaKB)
#endif
	)? kbunits : bunits;
}

static const char *sprint_bytes(char *s, long n, const char *was_units)
{
    static long kb_units = 1024;
    const char *u = HTProgressUnits(LYTransferRate);

    if (LYTransferRate == rateKB || LYTransferRate == rateEtaKB_maybe) {
	if (n >= 10 * kb_units) {
	    sprintf(s, "%ld", n / kb_units);
	} else if (n > 999) {	/* Avoid switching between 1016b/s and 1K/s */
	    sprintf(s, "%.2g", ((double) n) / kb_units);
	} else {
	    sprintf(s, "%ld", n);
	    u = HTProgressUnits(rateBYTES);
	}
    } else {
	sprintf(s, "%ld", n);
    }

    if (!was_units || was_units != u)
	sprintf(s + strlen(s), " %s", u);
    return u;
}

#ifdef USE_READPROGRESS
#define TIME_HMS_LENGTH (16)
static char *sprint_tbuf(char *s, long t)
{
    if (t > 3600)
	sprintf(s, "%ldh%ldm%lds", t / 3600, (t / 60) % 60, t % 60);
    else if (t > 60)
	sprintf(s, "%ldm%lds", t / 60, t % 60);
    else
	sprintf(s, "%ld sec", t);
    return s;
}
#endif /* USE_READPROGRESS */

/*	Issue a read-progress message.			HTReadProgress()
 *	------------------------------
 */
void HTReadProgress(long bytes, long total)
{
    static long bytes_last, total_last;
    static long transfer_rate = 0;
    static char *line = NULL;
    char bytesp[80], totalp[80], transferp[80];
    int renew = 0;
    const char *was_units;

#ifdef HAVE_GETTIMEOFDAY
    struct timeval tv;
    double now;
    static double first, last, last_active;

    gettimeofday(&tv, (struct timezone *) 0);
    now = tv.tv_sec + tv.tv_usec / 1000000.;
#else
#if defined(HAVE_FTIME) && defined(HAVE_SYS_TIMEB_H)
    static double now, first, last, last_active;
    struct timeb tb;

    ftime(&tb);
    now = tb.time + (double) tb.millitm / 1000;
#else
    time_t now = time((time_t *) 0);	/* once per second */
    static time_t first, last, last_active;
#endif
#endif

    if (!LYShowTransferRate)
	LYTransferRate = rateOFF;

    if (bytes == 0) {
	first = last = last_active = now;
	bytes_last = bytes;
    } else if (bytes < 0) {	/* stalled */
	bytes = bytes_last;
	total = total_last;
    }
    if ((bytes > 0) &&
	(now != first))
	/* 1 sec delay for transfer_rate calculation without g-t-o-d */  {
	if (transfer_rate <= 0)	/* the very first time */
	    transfer_rate = (long) ((bytes) / (now - first));	/* bytes/sec */
	total_last = total;

	/*
	 * Optimal refresh time:  every 0.2 sec
	 */
#if defined(HAVE_GETTIMEOFDAY) || (defined(HAVE_FTIME) && defined(HAVE_SYS_TIMEB_H))
	if (now >= last + 0.2)
	    renew = 1;
#else
	/*
	 * Use interpolation.  (The transfer rate may be not constant
	 * when we have partial content in a proxy.  We adjust transfer_rate
	 * once a second to minimize interpolation error below.)
	 */
	if ((now != last) || ((bytes - bytes_last) > (transfer_rate / 5))) {
	    renew = 1;
	    bytes_last += (transfer_rate / 5);	/* until we got next second */
	}
#endif
	if (renew) {
	    if (now != last) {
		last = now;
		if (bytes_last != bytes)
		    last_active = now;
		bytes_last = bytes;
		transfer_rate = (long) (bytes / (now - first));		/* more accurate value */
	    }

	    if (total > 0)
		was_units = sprint_bytes(totalp, total, 0);
	    else
		was_units = 0;
	    sprint_bytes(bytesp, bytes, was_units);

	    if (total > 0)
		HTSprintf0(&line, gettext("Read %s of %s of data"), bytesp, totalp);
	    else
		HTSprintf0(&line, gettext("Read %s of data"), bytesp);

	    if (LYTransferRate != rateOFF
		&& transfer_rate > 0) {
		sprint_bytes(transferp, transfer_rate, 0);
		HTSprintf(&line, gettext(", %s/sec"), transferp);
	    }
#ifdef USE_READPROGRESS
	    if (LYTransferRate == rateEtaBYTES
		|| LYTransferRate == rateEtaKB) {
		char tbuf[TIME_HMS_LENGTH];

		if (now - last_active >= 5)
		    HTSprintf(&line,
			      gettext(" (stalled for %s)"),
			      sprint_tbuf(tbuf, (long) (now - last_active)));
		if (total > 0 && transfer_rate)
		    HTSprintf(&line,
			      gettext(", ETA %s"),
			      sprint_tbuf(tbuf, (long) ((total - bytes) / transfer_rate)));
	    }
#endif

	    StrAllocCat(line, ".");
	    if (total < -1)
		StrAllocCat(line, gettext(" (Press 'z' to abort)"));

	    /* do not store the message for history page. */
	    statusline(line);
	    CTRACE((tfp, "%s\n", line));
	}
	}
#ifdef LY_FIND_LEAKS
    FREE(line);
#endif
}

static BOOL conf_cancelled = NO;	/* used by HTConfirm only - kw */

BOOL HTLastConfirmCancelled(void)
{
    if (conf_cancelled) {
	conf_cancelled = NO;	/* reset */
	return (YES);
    } else {
	return (NO);
    }
}

/*
 * Prompt for yes/no response, but let a configuration variable override
 * the prompt entirely.
 */
int HTForcedPrompt(int option, const char *msg, int dft)
{
    int result = FALSE;
    const char *show = NULL;
    char *msg2 = NULL;

    if (option == FORCE_PROMPT_DFT) {
	result = HTConfirmDefault(msg, dft);
    } else {
	if (option == FORCE_PROMPT_YES) {
	    show = gettext("yes");
	    result = YES;
	} else if (option == FORCE_PROMPT_NO) {
	    show = gettext("no");
	    result = NO;
	} else {
	    return HTConfirmDefault(msg, dft);	/* bug... */
	}
	HTSprintf(&msg2, "%s %s", msg, show);
	HTUserMsg(msg2);
	free(msg2);
    }
    return result;
}

#define DFT_CONFIRM ~(YES|NO)

/*	Seek confirmation with default answer.		HTConfirmDefault()
 *	--------------------------------------
 */
int HTConfirmDefault(const char *Msg, int Dft)
{
/* Meta-note: don't move the following note from its place right
   in front of the first gettext().  As it is now, it should
   automatically appear in generated lynx.pot files. - kw
 */

/* NOTE TO TRANSLATORS:  If you provide a translation for "yes", lynx
 * will take the first byte of the translation as a positive response
 * to Yes/No questions.  If you provide a translation for "no", lynx
 * will take the first byte of the translation as a negative response
 * to Yes/No questions.  For both, lynx will also try to show the
 * first byte in the prompt as a character, instead of (y) or (n),
 * respectively.  This will not work right for multibyte charsets!
 * Don't translate "yes" and "no" for CJK character sets (or translate
 * them to "yes" and "no").  For a translation using UTF-8, don't
 * translate if the translation would begin with anything but a 7-bit
 * (US_ASCII) character.  That also means do not translate if the
 * translation would begin with anything but a 7-bit character, if
 * you use a single-byte character encoding (a charset like ISO-8859-n)
 * but anticipate that the message catalog may be used re-encoded in
 * UTF-8 form.
 * For translations using other character sets, you may also wish to
 * leave "yes" and "no" untranslated, if using (y) and (n) is the
 * preferred behavior.
 * Lynx will also accept y Y n N as responses unless there is a conflict
 * with the first letter of the "yes" or "no" translation.
 */
    const char *msg_yes = gettext("yes");
    const char *msg_no = gettext("no");
    int result = -1;

    /* If they're not really distinct in the first letter, revert to English */
    if (TOUPPER(*msg_yes) == TOUPPER(*msg_no)) {
	msg_yes = "yes";
	msg_no = "no";
    }

    conf_cancelled = NO;
    if (dump_output_immediately) {	/* Non-interactive, can't respond */
	if (Dft == DFT_CONFIRM) {
	    CTRACE((tfp, "Confirm: %s (%c/%c) ", Msg, *msg_yes, *msg_no));
	} else {
	    CTRACE((tfp, "Confirm: %s (%c) ", Msg, (Dft == YES) ? *msg_yes : *msg_no));
	}
	CTRACE((tfp, "- NO, not interactive.\n"));
	result = NO;
    } else {
	char *msg = NULL;
	char fallback_y = 'y';	/* English letter response as fallback */
	char fallback_n = 'n';	/* English letter response as fallback */

	if (fallback_y == *msg_yes || fallback_y == *msg_no)
	    fallback_y = '\0';	/* conflict or duplication, don't use */
	if (fallback_n == *msg_yes || fallback_n == *msg_no)
	    fallback_n = '\0';	/* conflict or duplication, don't use */

	if (Dft == DFT_CONFIRM)
	    HTSprintf0(&msg, "%s (%c/%c) ", Msg, *msg_yes, *msg_no);
	else
	    HTSprintf0(&msg, "%s (%c) ", Msg, (Dft == YES) ? *msg_yes : *msg_no);
	if (LYTraceLogFP) {
	    CTRACE((tfp, "Confirm: %s", msg));
	}
	_statusline(msg);
	FREE(msg);

	while (result < 0) {
	    int c = LYgetch_single();

#ifdef VMS
	    if (HadVMSInterrupt) {
		HadVMSInterrupt = FALSE;
		c = TOUPPER(*msg_no);
	    }
#endif /* VMS */
	    if (c == TOUPPER(*msg_yes)) {
		result = YES;
	    } else if (c == TOUPPER(*msg_no)) {
		result = NO;
	    } else if (fallback_y && c == fallback_y) {
		result = YES;
	    } else if (fallback_n && c == fallback_n) {
		result = NO;
	    } else if (LYCharIsINTERRUPT(c)) {	/* remember we had ^G or ^C */
		conf_cancelled = YES;
		result = NO;
	    } else if (Dft != DFT_CONFIRM) {
		result = Dft;
		break;
	    }
	}
	CTRACE((tfp, "- %s%s.\n",
		(result != NO) ? "YES" : "NO",
		conf_cancelled ? ", cancelled" : ""));
    }
    return (result);
}

/*	Seek confirmation.				HTConfirm()
 *	------------------
 */
BOOL HTConfirm(const char *Msg)
{
    return (BOOL) HTConfirmDefault(Msg, DFT_CONFIRM);
}

/*
 * Ask a post resubmission prompt with some indication of what would
 * be resubmitted, useful especially for going backward in history.
 * Try to use parts of the address or, if given, the title, depending
 * on how much fits on the statusline.
 * if_imgmap and if_file indicate how to handle an address that is
 * a "LYNXIMGMAP:", or a "file:" URL (presumably the List Page file),
 * respectively:  0:  auto-deny, 1:  auto-confirm, 2:  prompt.
 * - kw
 */

BOOL confirm_post_resub(const char *address,
			const char *title,
			int if_imgmap,
			int if_file)
{
    size_t len1;
    const char *msg = CONFIRM_POST_RESUBMISSION_TO;
    char buf[240];
    char *temp = NULL;
    BOOL res;
    size_t maxlen = LYcolLimit - 5;

    if (!address) {
	return (NO);
    } else if (isLYNXIMGMAP(address)) {
	if (if_imgmap <= 0)
	    return (NO);
	else if (if_imgmap == 1)
	    return (YES);
	else
	    msg = CONFIRM_POST_LIST_RELOAD;
    } else if (isFILE_URL(address)) {
	if (if_file <= 0)
	    return (NO);
	else if (if_file == 1)
	    return (YES);
	else
	    msg = CONFIRM_POST_LIST_RELOAD;
    } else if (dump_output_immediately) {
	return (NO);
    }
    if (maxlen >= sizeof(buf))
	maxlen = sizeof(buf) - 1;
    if ((len1 = strlen(msg)) +
	strlen(address) <= maxlen) {
	sprintf(buf, msg, address);
	return HTConfirm(buf);
    }
    if (len1 + strlen(temp = HTParse(address, "",
				     PARSE_ACCESS + PARSE_HOST + PARSE_PATH
				     + PARSE_PUNCTUATION)) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return (res);
    }
    FREE(temp);
    if (title && (len1 + strlen(title) <= maxlen)) {
	sprintf(buf, msg, title);
	return HTConfirm(buf);
    }
    if (len1 + strlen(temp = HTParse(address, "",
				     PARSE_ACCESS + PARSE_HOST
				     + PARSE_PUNCTUATION)) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return (res);
    }
    FREE(temp);
    if ((temp = HTParse(address, "", PARSE_HOST)) && *temp &&
	len1 + strlen(temp) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return (res);
    }
    FREE(temp);
    return HTConfirm(CONFIRM_POST_RESUBMISSION);
}

/*	Prompt for answer and get text back.		HTPrompt()
 *	------------------------------------
 */
char *HTPrompt(const char *Msg, const char *deflt)
{
    char *rep = NULL;
    char Tmp[200];

    Tmp[0] = '\0';
    Tmp[sizeof(Tmp) - 1] = '\0';

    _statusline(Msg);
    if (deflt)
	strncpy(Tmp, deflt, sizeof(Tmp) - 1);

    if (!dump_output_immediately)
	LYgetstr(Tmp, VISIBLE, sizeof(Tmp), NORECALL);

    StrAllocCopy(rep, Tmp);

    return rep;
}

/*
 *	Prompt for password without echoing the reply.	HTPromptPassword()
 *	----------------------------------------------
 */
char *HTPromptPassword(const char *Msg)
{
    char *result = NULL;
    char pw[120];

    pw[0] = '\0';

    if (!dump_output_immediately) {
	_statusline(Msg ? Msg : PASSWORD_PROMPT);
	LYgetstr(pw, HIDDEN, sizeof(pw), NORECALL);	/* hidden */
	StrAllocCopy(result, pw);
    } else {
	printf("\n%s\n", PASSWORD_REQUIRED);
	StrAllocCopy(result, "");
    }
    return result;
}

/*	Prompt both username and password.	 HTPromptUsernameAndPassword()
 *	----------------------------------
 *
 *  On entry,
 *	Msg		is the prompting message.
 *	*username and
 *	*password	are char pointers which contain default
 *			or zero-length strings; they are changed
 *			to point to result strings.
 *	IsProxy 	should be TRUE if this is for
 *			proxy authentication.
 *
 *			If *username is not NULL, it is taken
 *			to point to a default value.
 *			Initial value of *password is
 *			completely discarded.
 *
 *  On exit,
 *	*username and *password point to newly allocated
 *	strings -- original strings pointed to by them
 *	are NOT freed.
 *
 */
void HTPromptUsernameAndPassword(const char *Msg,
				 char **username,
				 char **password,
				 BOOL IsProxy)
{
    if ((IsProxy == FALSE &&
	 authentication_info[0] && authentication_info[1]) ||
	(IsProxy == TRUE &&
	 proxyauth_info[0] && proxyauth_info[1])) {
	/*
	 * The -auth or -pauth parameter gave us both the username
	 * and password to use for the first realm or proxy server,
	 * respectively, so just use them without any prompting.  - FM
	 */
	StrAllocCopy(*username, (IsProxy ?
				 proxyauth_info[0] : authentication_info[0]));
	if (IsProxy) {
	    FREE(proxyauth_info[0]);
	} else {
	    FREE(authentication_info[0]);
	}
	StrAllocCopy(*password, (IsProxy ?
				 proxyauth_info[1] : authentication_info[1]));
	if (IsProxy) {
	    FREE(proxyauth_info[1]);
	} else {
	    FREE(authentication_info[1]);
	}
    } else if (dump_output_immediately) {
	/*
	 * We are not interactive and don't have both the
	 * username and password from the command line,
	 * but might have one or the other.  - FM
	 */
	if ((IsProxy == FALSE && authentication_info[0]) ||
	    (IsProxy == TRUE && proxyauth_info[0])) {
	    /*
	     * Use the command line username.  - FM
	     */
	    StrAllocCopy(*username, (IsProxy ?
				     proxyauth_info[0] : authentication_info[0]));
	    if (IsProxy) {
		FREE(proxyauth_info[0]);
	    } else {
		FREE(authentication_info[0]);
	    }
	} else {
	    /*
	     * Default to "WWWuser".  - FM
	     */
	    StrAllocCopy(*username, "WWWuser");
	}
	if ((IsProxy == FALSE && authentication_info[1]) ||
	    (IsProxy == TRUE && proxyauth_info[1])) {
	    /*
	     * Use the command line password.  - FM
	     */
	    StrAllocCopy(*password, (IsProxy ?
				     proxyauth_info[1] : authentication_info[1]));
	    if (IsProxy) {
		FREE(proxyauth_info[1]);
	    } else {
		FREE(authentication_info[1]);
	    }
	} else {
	    /*
	     * Default to a zero-length string.  - FM
	     */
	    StrAllocCopy(*password, "");
	}
	printf("\n%s\n", USERNAME_PASSWORD_REQUIRED);

    } else {
	/*
	 * We are interactive and don't have both the
	 * username and password from the command line,
	 * but might have one or the other.  - FM
	 */
	if ((IsProxy == FALSE && authentication_info[0]) ||
	    (IsProxy == TRUE && proxyauth_info[0])) {
	    /*
	     * Offer the command line username in the
	     * prompt for the first realm.  - FM
	     */
	    StrAllocCopy(*username, (IsProxy ?
				     proxyauth_info[0] : authentication_info[0]));
	    if (IsProxy) {
		FREE(proxyauth_info[0]);
	    } else {
		FREE(authentication_info[0]);
	    }
	}
	/*
	 * Prompt for confirmation or entry of the username.  - FM
	 */
	if (Msg != NULL) {
	    *username = HTPrompt(Msg, *username);
	} else {
	    *username = HTPrompt(USERNAME_PROMPT, *username);
	}
	if ((IsProxy == FALSE && authentication_info[1]) ||
	    (IsProxy == TRUE && proxyauth_info[1])) {
	    /*
	     * Use the command line password for the first realm.  - FM
	     */
	    StrAllocCopy(*password, (IsProxy ?
				     proxyauth_info[1] : authentication_info[1]));
	    if (IsProxy) {
		FREE(proxyauth_info[1]);
	    } else {
		FREE(authentication_info[1]);
	    }
	} else if (non_empty(*username)) {
	    /*
	     * We have a non-zero length username,
	     * so prompt for the password.  - FM
	     */
	    *password = HTPromptPassword(PASSWORD_PROMPT);
	} else {
	    /*
	     * Return a zero-length password.  - FM
	     */
	    StrAllocCopy(*password, "");
	}
    }
}

/*	Confirm a cookie operation.			HTConfirmCookie()
 *	---------------------------
 *
 *  On entry,
 *	server			is the server sending the Set-Cookie.
 *	domain			is the domain of the cookie.
 *	path			is the path of the cookie.
 *	name			is the name of the cookie.
 *	value			is the value of the cookie.
 *
 *  On exit,
 *	Returns FALSE on cancel,
 *		TRUE if the cookie should be set.
 */
BOOL HTConfirmCookie(domain_entry * de, const char *server,
		     const char *name,
		     const char *value)
{
    int ch;
    const char *prompt = ADVANCED_COOKIE_CONFIRMATION;

    if (de == NULL)
	return FALSE;

    /* If the user has specified a list of domains to allow or deny
     * from the config file, then they'll already have de->bv set to
     * ACCEPT_ALWAYS or REJECT_ALWAYS so we can relax and let the
     * default cookie handling code cope with this fine.
     */

    /*
     * If the user has specified a constant action, don't prompt at all.
     */
    if (de->bv == ACCEPT_ALWAYS)
	return TRUE;
    if (de->bv == REJECT_ALWAYS)
	return FALSE;

    if (dump_output_immediately) {
	/*
	 * Non-interactive, can't respond.  Use the LYSetCookies value
	 * based on its compilation or configuration setting, or on the
	 * command line toggle.  - FM
	 */
	return LYSetCookies;
    }

    /*
     * Estimate how much of the cookie we can show.
     */
    if (!LYAcceptAllCookies) {
	int namelen, valuelen, space_free, percentage;
	char *message = 0;

	space_free = (LYcolLimit
		      - (strlen(prompt)
			 - 10)	/* %s and %.*s and %.*s chars */
		      -strlen(server));
	if (space_free < 0)
	    space_free = 0;
	namelen = strlen(name);
	valuelen = strlen(value);
	if ((namelen + valuelen) > space_free) {
	    /*
	     * Argh...  there isn't enough space on our single line for
	     * the whole cookie.  Reduce them both by a percentage.
	     * This should be smarter.
	     */
	    percentage = (100 * space_free) / (namelen + valuelen);
	    namelen = (percentage * namelen) / 100;
	    valuelen = (percentage * valuelen) / 100;
	}
	HTSprintf(&message, prompt, server, namelen, name, valuelen, value);
	_statusline(message);
	FREE(message);
    }
    for (;;) {
	if (LYAcceptAllCookies) {
	    ch = 'A';
	} else {
	    ch = LYgetch_single();
#if defined(LOCALE) && defined(HAVE_GETTEXT)
	    {
#define L_PAREN '('
#define R_PAREN ')'
		/*
		 * Special-purpose workaround for gettext support (we should do
		 * this in a more general way) -TD
		 *
		 * NOTE TO TRANSLATORS:  If the prompt has been rendered into
		 * another language, and if yes/no are distinct, assume the
		 * translator can make an ordered list in parentheses with one
		 * capital letter for each as we assumed in HTConfirmDefault().
		 * The list has to be in the same order as in the original message,
		 * and the four capital letters chosen to not match those in the
		 * original unless they have the same position.
		 *
		 * Example:
		 * (Y/N/Always/neVer)              - English (original)
		 * (O/N/Toujours/Jamais)           - French
		 */
		char *p = gettext("Y/N/A/V");	/* placeholder for comment */
		char *s = "YNAV\007\003";	/* see ADVANCED_COOKIE_CONFIRMATION */

		if (strchr(s, ch) == 0
		    && isalpha(ch)
		    && (p = strrchr(prompt, L_PAREN)) != 0) {

		    CTRACE((tfp, "Looking for %c in %s\n", ch, p));
		    while (*p != R_PAREN && *p != 0 && isalpha(UCH(*s))) {
			if (isalpha(UCH(*p)) && (*p == TOUPPER(*p))) {
			    CTRACE((tfp, "...testing %c/%c\n", *p, *s));
			    if (*p == ch) {
				ch = *s;
				break;
			    }
			    ++s;
			}
			++p;
		    }
		}
	    }
#endif
	}
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    ch = 'N';
	}
#endif /* VMS */
	switch (ch) {
	case 'A':
	    /*
	     * Set to accept all cookies for this domain.
	     */
	    de->bv = ACCEPT_ALWAYS;
	    HTUserMsg2(ALWAYS_ALLOWING_COOKIES, de->domain);
	    return TRUE;

	case 'N':
	    /*
	     * Reject the cookie.
	     */
	  reject:
	    HTUserMsg(REJECTING_COOKIE);
	    return FALSE;

	case 'V':
	    /*
	     * Set to reject all cookies from this domain.
	     */
	    de->bv = REJECT_ALWAYS;
	    HTUserMsg2(NEVER_ALLOWING_COOKIES, de->domain);
	    return FALSE;

	case 'Y':
	    /*
	     * Accept the cookie.
	     */
	    HTInfoMsg(ALLOWING_COOKIE);
	    return TRUE;

	default:
	    if (LYCharIsINTERRUPT(ch))
		goto reject;
	    continue;
	}
    }
}

/*	Confirm redirection of POST.		HTConfirmPostRedirect()
 *	----------------------------
 *
 *  On entry,
 *	Redirecting_url 	    is the Location.
 *	server_status		    is the server status code.
 *
 *  On exit,
 *	Returns 0 on cancel,
 *	  1 for redirect of POST with content,
 *	303 for redirect as GET without content
 */
int HTConfirmPostRedirect(const char *Redirecting_url, int server_status)
{
    int result = -1;
    char *show_POST_url = NULL;
    char *StatusInfo = 0;
    char *url = 0;
    int on_screen = 0;		/* 0 - show menu

				 * 1 - show url
				 * 2 - menu is already on screen */

    if (server_status == 303 ||
	server_status == 302) {
	/*
	 * HTTP.c should not have called us for either of
	 * these because we're treating 302 as historical,
	 * so just return 303.  - FM
	 */
	return 303;
    }

    if (dump_output_immediately) {
	if (server_status == 301) {
	    /*
	     * Treat 301 as historical, i.e., like 303 (GET
	     * without content), when not interactive.  - FM
	     */
	    return 303;
	} else {
	    /*
	     * Treat anything else (e.g., 305, 306 or 307) as too
	     * dangerous to redirect without confirmation, and thus
	     * cancel when not interactive.  - FM
	     */
	    return 0;
	}
    }

    if (user_mode == NOVICE_MODE) {
	on_screen = 2;
	LYmove(LYlines - 2, 0);
	HTSprintf0(&StatusInfo, SERVER_ASKED_FOR_REDIRECTION, server_status);
	LYaddstr(StatusInfo);
	LYclrtoeol();
	LYmove(LYlines - 1, 0);
	HTSprintf0(&url, "URL: %.*s",
		   (LYcols < 250 ? LYcolLimit - 5 : 250), Redirecting_url);
	LYaddstr(url);
	LYclrtoeol();
	if (server_status == 301) {
	    _statusline(PROCEED_GET_CANCEL);
	} else {
	    _statusline(PROCEED_OR_CANCEL);
	}
    } else {
	HTSprintf0(&StatusInfo, "%d %.*s",
		   server_status,
		   251,
		   ((server_status == 301) ?
		    ADVANCED_POST_GET_REDIRECT :
		    ADVANCED_POST_REDIRECT));
	StrAllocCopy(show_POST_url, LOCATION_HEADER);
	StrAllocCat(show_POST_url, Redirecting_url);
    }
    while (result < 0) {
	int c;

	switch (on_screen) {
	case 0:
	    _statusline(StatusInfo);
	    break;
	case 1:
	    _statusline(show_POST_url);
	}
	c = LYgetch_single();
	switch (c) {
	case 'P':
	    /*
	     * Proceed with 301 or 307 redirect of POST
	     * with same method and POST content.  - FM
	     */
	    FREE(show_POST_url);
	    result = 1;
	    break;

	case 7:
	case 'C':
	    /*
	     * Cancel request.
	     */
	    FREE(show_POST_url);
	    result = 0;
	    break;

	case 'U':
	    /*
	     * Show URL for intermediate or advanced mode.
	     */
	    if (user_mode != NOVICE_MODE) {
		if (on_screen == 1) {
		    on_screen = 0;
		} else {
		    on_screen = 1;
		}
	    }
	    break;

	case 'G':
	    if (server_status == 301) {
		/*
		 * Treat as 303 (GET without content).
		 */
		FREE(show_POST_url);
		result = 303;
		break;
	    }
	    /* fall through to default */

	default:
	    /*
	     * Get another character.
	     */
	    if (on_screen == 1) {
		on_screen = 0;
	    } else {
		on_screen = 2;
	    }
	}
    }
    FREE(StatusInfo);
    FREE(url);
    return (result);
}

#define okToSleep() (!crawl && !traversal && LYCursesON)

/*
 * Sleep for the given message class's time.
 */
void LYSleepAlert(void)
{
    if (okToSleep())
	LYSleep(AlertSecs);
}

void LYSleepDebug(void)
{
    if (okToSleep())
	LYSleep(DebugSecs);
}

void LYSleepInfo(void)
{
    if (okToSleep())
	LYSleep(InfoSecs);
}

void LYSleepMsg(void)
{
    if (okToSleep())
	LYSleep(MessageSecs);
}

#ifdef EXP_CMD_LOGGING
void LYSleepReplay(void)
{
    if (okToSleep())
	LYSleep(ReplaySecs);
}
#endif /* EXP_CMD_LOGGING */

/*
 * LYstrerror emulates the ANSI strerror() function.
 */
#ifndef LYStrerror
char *LYStrerror(int code)
{
    static char temp[80];

    sprintf(temp, "System errno is %d.\r\n", code);
    return temp;
}
#endif /* HAVE_STRERROR */
@


1.9
log
@automatic merge
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/HTAlert.c,v 1.8 2004/10/11 20:30:39 tg Exp $ */
d331 1
a331 1
    char *show = NULL;
d386 2
a387 2
    char *msg_yes = gettext("yes");
    char *msg_no = gettext("no");
d761 1
a761 1
    char *prompt = ADVANCED_COOKIE_CONFIRMATION;
@


1.8
log
@automatic merge; regen configure
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/HTAlert.c,v 1.7 2004/07/15 18:16:48 tg Stab $ */
d89 1
a89 1
    if (Msg && *Msg) {
d102 1
a102 1
    if (Msg && *Msg) {
d118 1
a118 1
    if (Msg2 && *Msg2) {
d727 1
a727 1
	} else if (*username != NULL && *username[0] != '\0') {
@


1.7
log
@automatic merge of lynx-current
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/HTAlert.c,v 1.6 2004/04/30 16:32:30 tg Exp $ */
d486 1
a486 1
    size_t maxlen = LYcols - 6;
d796 1
a796 1
	space_free = ((LYcols - 1)
d823 1
a823 17
#if defined(LOCALE) && defined(HAVE_GETTEXT) && !defined(gettext)
	    /*
	     * Special-purpose workaround for gettext support (we should do
	     * this in a more general way -- after 2.8.3).
	     *
	     * NOTE TO TRANSLATORS:  If the prompt has been rendered into
	     * another language, and if yes/no are distinct, assume the
	     * translator can make an ordered list in parentheses with one
	     * capital letter for each as we assumed in HTConfirmDefault().
	     * The list has to be in the same order as in the original message,
	     * and the four capital letters chosen to not match those in the
	     * original unless they have the same position.
	     *
	     * Example:
	     * (Y/N/Always/neVer)              - English (original)
	     * (O/N/Toujours/Jamais)           - French
	     */
d827 17
a843 1
		char *p;
d970 1
a970 1
		   (LYcols < 250 ? LYcols - 6 : 250), Redirecting_url);
@


1.6
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/HTAlert.c,v 1.5 2004/02/08 19:48:58 tg Exp $ */
d4 9
a12 9
**	==========================================================
**
**	REPLACE THIS MODULE with a GUI version in a GUI environment!
**
** History:
**	   Jun 92 Created May 1992 By C.T. Barker
**	   Feb 93 Simplified, portablised TBL
**
*/
d23 1
a23 1
#include <LYHistory.h> /* store statusline messages */
d29 1
a29 1
#undef timezone	/* U/Win defines this in time.h, hides implementation detail */
d46 3
a48 4
**	--------------------------------
*/
void HTAlert (
	const char *	Msg)
d58 2
a59 3
void HTAlwaysAlert (
	const char *	extra_prefix,
	const char *	Msg)
d84 3
a86 4
**	--------------------------------
*/
void HTInfoMsg (
	const char *	Msg)
d97 3
a99 4
**	--------------------------------
*/
void HTUserMsg (
	const char *	Msg)
d115 1
a115 3
void HTUserMsg2 (
	const char *	Msg2,
	const char *	Arg)
d128 3
a130 4
**	-------------------------
*/
void HTProgress (
	const char *	Msg)
d138 1
a138 2
const char *HTProgressUnits (
	int		rate)
d149 1
a149 1
    	    || (rate == rateEtaKB)
d151 1
a151 1
	    ) ? kbunits : bunits;
d154 1
a154 4
static const char *sprint_bytes (
	char *		s,
	long		n,
	const char * 	was_units)
d161 1
a161 1
	    sprintf(s, "%ld", n/kb_units);
d163 1
a163 1
	    sprintf(s, "%.2g", ((double)n)/kb_units);
d179 1
a179 3
static char *sprint_tbuf (
	char *	       s,
	long	       t)
d182 1
a182 1
	sprintf (s, "%ldh%ldm%lds", t / 3600, (t / 60) % 60, t % 60);
d184 1
a184 1
	sprintf (s, "%ldm%lds", t / 60, t % 60);
d186 1
a186 1
	sprintf (s, "%ld sec", t);
d192 3
a194 5
**	------------------------------
*/
void HTReadProgress (
	long		bytes,
	long		total)
d207 3
a209 2
    gettimeofday(&tv, (struct timezone *)0);
    now = tv.tv_sec + tv.tv_usec/1000000. ;
d216 1
a216 1
    now = tb.time + (double)tb.millitm / 1000;
d218 1
a218 1
    time_t now = time((time_t *)0);  /* once per second */
d234 4
a237 4
	       (now != first))
		/* 1 sec delay for transfer_rate calculation without g-t-o-d */ {
	if (transfer_rate <= 0)    /* the very first time */
	    transfer_rate = (long)((bytes) / (now - first));   /* bytes/sec */
d263 1
a263 1
		transfer_rate = (long)(bytes / (now - first)); /* more accurate value */
d273 1
a273 1
		HTSprintf0 (&line, gettext("Read %s of %s of data"), bytesp, totalp);
d275 1
a275 1
		HTSprintf0 (&line, gettext("Read %s of data"), bytesp);
d278 1
a278 1
	     && transfer_rate > 0) {
d280 1
a280 1
		HTSprintf (&line, gettext(", %s/sec"), transferp);
a281 1

d284 1
a284 1
	     || LYTransferRate == rateEtaKB) {
d286 1
d288 3
a290 3
		    HTSprintf (&line,
			       gettext(" (stalled for %s)"),
			       sprint_tbuf (tbuf, (long)(now - last_active)));
d292 3
a294 3
		    HTSprintf (&line,
			       gettext(", ETA %s"),
			       sprint_tbuf (tbuf, (long)((total - bytes)/transfer_rate)));
d298 1
a298 1
	    StrAllocCat (line, ".");
d306 1
a306 1
    }
d312 1
a312 1
static BOOL conf_cancelled = NO; /* used by HTConfirm only - kw */
d314 1
a314 1
BOOL HTLastConfirmCancelled (void)
d318 1
a318 1
	return(YES);
d320 1
a320 1
	return(NO);
d328 1
a328 4
int HTForcedPrompt (
	int		option,
	const char *	msg,
	int		dft)
d356 3
a358 3
**	--------------------------------------
*/
int HTConfirmDefault (const char * Msg, int Dft)
d365 20
a384 20
/*  NOTE TO TRANSLATORS:  If you provide a translation for "yes", lynx
 *  will take the first byte of the translation as a positive response
 *  to Yes/No questions.  If you provide a translation for "no", lynx
 *  will take the first byte of the translation as a negative response
 *  to Yes/No questions.  For both, lynx will also try to show the
 *  first byte in the prompt as a character, instead of (y) or (n),
 *  respectively.  This will not work right for multibyte charsets!
 *  Don't translate "yes" and "no" for CJK character sets (or translate
 *  them to "yes" and "no").  For a translation using UTF-8, don't
 *  translate if the translation would begin with anything but a 7-bit
 *  (US_ASCII) character.  That also means do not translate if the
 *  translation would begin with anything but a 7-bit character, if
 *  you use a single-byte character encoding (a charset like ISO-8859-n)
 *  but anticipate that the message catalog may be used re-encoded in
 *  UTF-8 form.
 *  For translations using other character sets, you may also wish to
 *  leave "yes" and "no" untranslated, if using (y) and (n) is the
 *  preferred behavior.
 *  Lynx will also accept y Y n N as responses unless there is a conflict
 *  with the first letter of the "yes" or "no" translation.
d387 1
a387 1
    char *msg_no  = gettext("no");
d397 1
a397 1
    if (dump_output_immediately) { /* Non-interactive, can't respond */
d427 1
d442 1
a442 1
	    } else if (LYCharIsINTERRUPT(c)) { /* remember we had ^G or ^C */
d451 2
a452 2
	       (result != NO) ? "YES" : "NO",
	       conf_cancelled ? ", cancelled" : ""));
d458 3
a460 3
**	------------------
*/
BOOL HTConfirm (const char * Msg)
d466 8
a473 8
 *  Ask a post resubmission prompt with some indication of what would
 *  be resubmitted, useful especially for going backward in history.
 *  Try to use parts of the address or, if given, the title, depending
 *  on how much fits on the statusline.
 *  if_imgmap and if_file indicate how to handle an address that is
 *  a "LYNXIMGMAP:", or a "file:" URL (presumably the List Page file),
 *  respectively: 0: auto-deny, 1: auto-confirm, 2: prompt.
 *  - kw
d476 4
a479 5
BOOL confirm_post_resub (
    const char*	address,
    const char*	title,
    int		if_imgmap,
    int		if_file)
d487 1
d489 1
a489 1
	return(NO);
d492 1
a492 1
	    return(NO);
d494 1
a494 1
	    return(YES);
d499 1
a499 1
	    return(NO);
d501 1
a501 1
	    return(YES);
d505 1
a505 1
	return(NO);
d515 2
a516 2
				     PARSE_ACCESS+PARSE_HOST+PARSE_PATH
				     +PARSE_PUNCTUATION)) <= maxlen) {
d520 1
a520 1
	return(res);
d528 2
a529 2
				     PARSE_ACCESS+PARSE_HOST
				     +PARSE_PUNCTUATION)) <= maxlen) {
d533 1
a533 1
	return(res);
d541 1
a541 1
	return(res);
d548 3
a550 5
**	------------------------------------
*/
char * HTPrompt (
	const char *	Msg,
	const char *	deflt)
d552 1
a552 1
    char * rep = NULL;
d556 1
a556 1
    Tmp[sizeof(Tmp)-1] = '\0';
d560 1
a560 1
	strncpy(Tmp, deflt, sizeof(Tmp)-1);
d571 4
a574 5
**	Prompt for password without echoing the reply.	HTPromptPassword()
**	----------------------------------------------
*/
char * HTPromptPassword (
	const char *	Msg)
d583 1
a583 1
	LYgetstr(pw, HIDDEN, sizeof(pw), NORECALL); /* hidden */
d593 26
a618 27
**	----------------------------------
**
**  On entry,
**	Msg		is the prompting message.
**	*username and
**	*password	are char pointers which contain default
**			or zero-length strings; they are changed
**			to point to result strings.
**	IsProxy 	should be TRUE if this is for
**			proxy authentication.
**
**			If *username is not NULL, it is taken
**			to point to a default value.
**			Initial value of *password is
**			completely discarded.
**
**  On exit,
**	*username and *password point to newly allocated
**	strings -- original strings pointed to by them
**	are NOT freed.
**
*/
void HTPromptUsernameAndPassword (
	const char *	Msg,
	char **	username,
	char **	password,
	BOOL		IsProxy)
d625 4
a628 4
	**  The -auth or -pauth parameter gave us both the username
	**  and password to use for the first realm or proxy server,
	**  respectively, so just use them without any prompting. - FM
	*/
d630 1
a630 1
		       proxyauth_info[0] : authentication_info[0]));
d637 1
a637 1
		       proxyauth_info[1] : authentication_info[1]));
d645 3
a647 3
	 *  We are not interactive and don't have both the
	 *  username and password from the command line,
	 *  but might have one or the other. - FM
d652 2
a653 2
	    **	Use the command line username. - FM
	    */
d655 1
a655 1
			   proxyauth_info[0] : authentication_info[0]));
d663 2
a664 2
	    **	Default to "WWWuser". - FM
	    */
d670 2
a671 2
	    **	Use the command line password. - FM
	    */
d673 1
a673 1
			   proxyauth_info[1] : authentication_info[1]));
d681 2
a682 2
	    **	Default to a zero-length string. - FM
	    */
d689 3
a691 3
	 *  We are interactive and don't have both the
	 *  username and password from the command line,
	 *  but might have one or the other. - FM
d696 3
a698 3
	    **	Offer the command line username in the
	    **	prompt for the first realm. - FM
	    */
d700 1
a700 1
			   proxyauth_info[0] : authentication_info[0]));
d708 1
a708 1
	 *  Prompt for confirmation or entry of the username. - FM
d718 2
a719 2
	    **	Use the command line password for the first realm. - FM
	    */
d721 1
a721 1
			   proxyauth_info[1] : authentication_info[1]));
d729 3
a731 3
	    **	We have a non-zero length username,
	    **	so prompt for the password. - FM
	    */
d735 2
a736 2
	    **	Return a zero-length password. - FM
	    */
d743 16
a758 18
**	---------------------------
**
**  On entry,
**	server			is the server sending the Set-Cookie.
**	domain			is the domain of the cookie.
**	path			is the path of the cookie.
**	name			is the name of the cookie.
**	value			is the value of the cookie.
**
**  On exit,
**	Returns FALSE on cancel,
**		TRUE if the cookie should be set.
*/
BOOL HTConfirmCookie (
	domain_entry * de,
	const char *	server,
	const char *	name,
	const char *	value)
d766 5
a770 5
    /*	If the user has specified a list of domains to allow or deny
    **	from the config file, then they'll already have de->bv set to
    **	ACCEPT_ALWAYS or REJECT_ALWAYS so we can relax and let the
    **	default cookie handling code cope with this fine.
    */
d773 2
a774 2
    **	If the user has specified a constant action, don't prompt at all.
    */
d782 4
a785 4
	**  Non-interactive, can't respond.  Use the LYSetCookies value
	*   based on its compilation or configuration setting, or on the
	**  command line toggle. - FM
	*/
d790 3
a792 3
    **	Estimate how much of the cookie we can show.
    */
    if(!LYAcceptAllCookies) {
d798 2
a799 2
			 - 10)		/* %s and %.*s and %.*s chars */
		      - strlen(server));
d806 4
a809 4
	    **  Argh... there isn't enough space on our single line for
	    **  the whole cookie.  Reduce them both by a percentage.
	    **  This should be smarter.
	    */
d819 1
a819 1
	if(LYAcceptAllCookies) {
d837 2
a838 2
	     *	(Y/N/Always/neVer)		- English (original)
	     *	(O/N/Toujours/Jamais)		- French
d844 1
a844 1
		char *s = "YNAV\007\003"; /* see ADVANCED_COOKIE_CONFIRMATION */
d847 2
a848 2
		 && isalpha(ch)
		 && (p = strrchr(prompt, L_PAREN)) != 0) {
d872 16
a887 8
	switch(ch) {
	    case 'A':
		/*
		**  Set to accept all cookies for this domain.
		*/
		de->bv = ACCEPT_ALWAYS;
		HTUserMsg2(ALWAYS_ALLOWING_COOKIES, de->domain);
		return TRUE;
d889 7
a895 7
	    case 'N':
		/*
		**  Reject the cookie.
		*/
	      reject:
		HTUserMsg(REJECTING_COOKIE);
		return FALSE;
d897 6
a902 7
	    case 'V':
		/*
		**  Set to reject all cookies from this domain.
		*/
		de->bv = REJECT_ALWAYS;
		HTUserMsg2(NEVER_ALLOWING_COOKIES, de->domain);
		return FALSE;
d904 4
a907 11
	    case 'Y':
		/*
		**  Accept the cookie.
		*/
		HTInfoMsg(ALLOWING_COOKIE);
		return TRUE;

	    default:
		if (LYCharIsINTERRUPT(ch))
		    goto reject;
		continue;
d913 12
a924 14
**	----------------------------
**
**  On entry,
**	Redirecting_url 	    is the Location.
**	server_status		    is the server status code.
**
**  On exit,
**	Returns 0 on cancel,
**	  1 for redirect of POST with content,
**	303 for redirect as GET without content
*/
int HTConfirmPostRedirect (
	const char *	Redirecting_url,
	int		server_status)
d930 4
a933 3
    int on_screen = 0;	/* 0 - show menu
			 * 1 - show url
			 * 2 - menu is already on screen */
d938 3
a940 3
	 *  HTTP.c should not have called us for either of
	 *  these because we're treating 302 as historical,
	 *  so just return 303. - FM
d948 3
a950 3
	    **	Treat 301 as historical, i.e., like 303 (GET
	    **	without content), when not interactive. - FM
	    */
d954 4
a957 4
	    **	Treat anything else (e.g., 305, 306 or 307) as too
	    **	dangerous to redirect without confirmation, and thus
	    **	cancel when not interactive. - FM
	    */
d964 1
a964 1
	LYmove(LYlines-2, 0);
d968 1
a968 1
	LYmove(LYlines-1, 0);
d970 1
a970 1
		    (LYcols < 250 ? LYcols-6 : 250), Redirecting_url);
d980 5
a984 5
			    server_status,
			    251,
			    ((server_status == 301) ?
			 ADVANCED_POST_GET_REDIRECT :
			 ADVANCED_POST_REDIRECT));
d992 5
a996 5
	    case 0:
		_statusline(StatusInfo);
		break;
	    case 1:
		_statusline(show_POST_url);
d1000 8
a1007 8
	    case 'P':
		/*
		**  Proceed with 301 or 307 redirect of POST
		**  with same method and POST content. - FM
		*/
		FREE(show_POST_url);
		result = 1;
		break;
d1009 8
a1016 8
	    case 7:
	    case 'C':
		/*
		**  Cancel request.
		*/
		FREE(show_POST_url);
		result = 0;
		break;
d1018 5
a1022 28
	    case 'U':
		/*
		**  Show URL for intermediate or advanced mode.
		*/
		if (user_mode != NOVICE_MODE) {
		    if (on_screen == 1) {
			on_screen = 0;
		    } else {
			on_screen = 1;
		    }
		}
		break;

	    case 'G':
		if (server_status == 301) {
		    /*
		    **	Treat as 303 (GET without content).
		    */
		    FREE(show_POST_url);
		    result = 303;
		    break;
		}
		/* fall through to default */

	    default:
		/*
		**  Get another character.
		*/
d1026 1
a1026 1
		    on_screen = 2;
d1028 23
d1063 1
a1063 1
void LYSleepAlert (void)
d1069 1
a1069 1
void LYSleepDebug (void)
d1075 1
a1075 1
void LYSleepInfo (void)
d1081 1
a1081 1
void LYSleepMsg (void)
d1088 1
a1088 1
void LYSleepReplay (void)
d1096 1
a1096 1
 *  LYstrerror emulates the ANSI strerror() function.
d1098 2
a1099 4
#ifdef LYStrerror
    /* defined as macro in .h file. */
#else
char *LYStrerror (int code)
d1102 1
@


1.5
log
@* bump to 0x079D (a bit late for tiff, but hey)
* sync lists
* regenerate configure files
* remove MirLibtool, go back to gcc3 libtool :-(
* fix for $stuff
* remove dupes (libz, etc.) and unused (libintl, getopt)
* update lynx
* update texinfo.tex
etc.

XXX borked commit, eleventh try
@
text
@d1 1
a1 1
/* $MirBSD$ */
d48 2
a49 2
PUBLIC void HTAlert ARGS1(
	CONST char *,	Msg)
d59 3
a61 3
PUBLIC void HTAlwaysAlert ARGS2(
	CONST char *,	extra_prefix,
	CONST char *,	Msg)
d88 2
a89 2
PUBLIC void HTInfoMsg ARGS1(
	CONST char *,	Msg)
d102 2
a103 2
PUBLIC void HTUserMsg ARGS1(
	CONST char *,	Msg)
d119 3
a121 3
PUBLIC void HTUserMsg2 ARGS2(
	CONST char *,	Msg2,
	CONST char *,	Arg)
d136 2
a137 2
PUBLIC void HTProgress ARGS1(
	CONST char *,	Msg)
d145 2
a146 2
PUBLIC CONST char *HTProgressUnits ARGS1(
	int,		rate)
d148 2
a149 2
    static CONST char *bunits = 0;
    static CONST char *kbunits = 0;
d162 4
a165 4
PRIVATE CONST char *sprint_bytes ARGS3(
	char *,		s,
	long,		n,
	CONST char *, 	was_units)
d168 1
a168 1
    CONST char *u = HTProgressUnits(LYTransferRate);
d170 10
a179 7
    if ( (LYTransferRate == rateKB || LYTransferRate == rateEtaKB_maybe)
	 && (n >= 10 * kb_units) )
	sprintf(s, "%ld", n/kb_units);
    else if ((LYTransferRate == rateKB || LYTransferRate == rateEtaKB_maybe)
	     && (n > 999))	/* Avoid switching between 1016b/s and 1K/s */
	sprintf(s, "%.2g", ((double)n)/kb_units);
    else {
d190 3
a192 3
PRIVATE char *sprint_tbuf ARGS2(
	char *,	       s,
	long,	       t)
d207 3
a209 3
PUBLIC void HTReadProgress ARGS2(
	long,		bytes,
	long,		total)
d216 1
a216 1
    CONST char *was_units;
d326 1
a326 1
PRIVATE BOOL conf_cancelled = NO; /* used by HTConfirm only - kw */
d328 1
a328 1
PUBLIC BOOL HTLastConfirmCancelled NOARGS
d342 4
a345 4
PUBLIC int HTForcedPrompt ARGS3(
	int,		option,
	CONST char *,	msg,
	int,		dft)
d375 1
a375 1
PUBLIC int HTConfirmDefault ARGS2(CONST char *, Msg, int, Dft)
d476 1
a476 1
PUBLIC BOOL HTConfirm ARGS1(CONST char *, Msg)
d492 5
a496 5
PUBLIC BOOL confirm_post_resub ARGS4(
    CONST char*,	address,
    CONST char*,	title,
    int,		if_imgmap,
    int,		if_file)
d499 1
a499 1
    CONST char *msg = CONFIRM_POST_RESUBMISSION_TO;
d566 3
a568 3
PUBLIC char * HTPrompt ARGS2(
	CONST char *,	Msg,
	CONST char *,	deflt)
d592 2
a593 2
PUBLIC char * HTPromptPassword ARGS1(
	CONST char *,	Msg)
d634 5
a638 5
PUBLIC void HTPromptUsernameAndPassword ARGS4(
	CONST char *,	Msg,
	char **,	username,
	char **,	password,
	BOOL,		IsProxy)
d776 5
a780 5
PUBLIC BOOL HTConfirmCookie ARGS4(
	domain_entry *, de,
	CONST char *,	server,
	CONST char *,	name,
	CONST char *,	value)
d946 3
a948 3
PUBLIC int HTConfirmPostRedirect ARGS2(
	CONST char *,	Redirecting_url,
	int,		server_status)
d1086 1
a1086 1
PUBLIC void LYSleepAlert NOARGS
d1092 1
a1092 1
PUBLIC void LYSleepDebug NOARGS
d1098 1
a1098 1
PUBLIC void LYSleepInfo NOARGS
d1104 1
a1104 1
PUBLIC void LYSleepMsg NOARGS
d1111 1
a1111 1
PUBLIC void LYSleepReplay NOARGS
d1124 1
a1124 1
PUBLIC char *LYStrerror ARGS1(int, code)
@


1.4
log
@some gettimeofday fixes from OpenBSD
@
text
@d1 1
a1 19
/* $MirBSD: licence.template,v 1.4 2003/07/07 19:03:08 tg Exp $
 *-
 * Copyright (c) 2002, 2003 Thorsten Glaser <x86@@ePost.de>
 *
 * Subject to these terms, everybody who obtained a copy of this work
 * is hereby permitted to deal in the work without restriction inclu-
 * ding without limitation the rights to use, distribute, sell, modi-
 * fy, publically perform, give away, merge or sublicense it provided
 * this notice is kept and the authors and contributors are given due
 * credit in derivates or accompanying documents.
 * This work is provided "as is" with no explicit or implicit warran-
 * ties whatsoever to the maximum extend permitted by applicable law;
 * in no event may an author or contributor be held liable for damage
 * that is, directly or indirectly, caused by the work, even if advi-
 * sed of the possibility of such damage.
 *-
 * These are patches to the Lynx web browser, which is licensed under
 * the GNU General Public License, Version 2.
 */
d145 2
a146 4
PRIVATE char *sprint_bytes ARGS3(
	char *,		s,
	long,		n,
	char *, 	was_units)
d148 2
a149 4
    static long kb_units = 1024;
    static char *bunits;
    static char *kbunits;
    char *u;
d153 1
a153 1
	kbunits = gettext("KB");
d155 14
a169 1
    u = kbunits;
a177 1
	u = bunits;
d185 1
a185 1
#ifdef EXP_READPROGRESS
d199 1
a199 1
#endif /* EXP_READPROGRESS */
d213 1
a213 1
    char *was_units;
d294 1
a294 1
#ifdef EXP_READPROGRESS
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d1 20
d227 1
a227 2
    int dummy = gettimeofday(&tv, (struct timezone *)0);
    double now = tv.tv_sec + tv.tv_usec/1000000. ;
d229 2
a230 1
    (void)dummy;		/* quiet unused-assignment warning */
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d25 18
d49 1
a49 1
    CTRACE(tfp, "\nAlert!: %s\n\n", Msg);
d54 1
a54 1
    sleep(AlertSecs);
d69 2
a70 1
	    sleep(AlertSecs);
d72 1
a72 3
	    fprintf(((TRACE) ? stdout : stderr),
		    ALERT_FORMAT,
		    (Msg == 0) ? "" : Msg);
d74 2
a75 1
	    sleep(AlertSecs);
d78 1
a78 1
	CTRACE(tfp, "\nAlert!: %s\n\n", Msg);
d91 1
a91 1
	CTRACE(tfp, "Info message: %s\n", Msg);
d93 1
a93 1
	sleep(InfoSecs);
d105 1
a105 1
	CTRACE(tfp, "User message: %s\n", Msg);
d107 7
a113 1
	sleep(MessageSecs);
d123 3
a125 3
	CTRACE(tfp, "User message: ");
	CTRACE(tfp, Msg2, Arg);
	CTRACE(tfp, "\n");
d127 1
a127 1
	sleep(MessageSecs);
d139 49
a187 1
    CTRACE(tfp, "%s\n", Msg);
d189 1
d198 1
a198 3
    static long kb_units = 1024;
    static time_t first, last;
    static long bytes_last;
d200 19
a218 2
    long divisor;
    char line[80];
d220 6
a225 1
    static char *units = "bytes";
d228 1
a228 1
	first = last = now;
d230 5
a234 1
    } else if ((bytes > 0) &&
d236 1
a236 1
		/* 1 sec delay for transfer_rate calculation :-( */ {
d238 2
a239 1
	    transfer_rate = (bytes) / (now - first);   /* bytes/sec */
d242 1
a242 3
	 * Optimal refresh time:  every 0.2 sec, use interpolation.  Transfer
	 * rate is not constant when we have partial content in a proxy, so
	 * interpolation lies - will check every second at least for sure.
d244 11
a254 2
	if (((bytes - bytes_last) > (transfer_rate / 5)) || (now != last)) {

d256 3
a258 1

d261 2
d264 1
a264 1
		transfer_rate = (bytes_last) / (last - first); /* more accurate here */
d267 5
a271 9
	    units = gettext("bytes");
	    divisor = 1;
	    if (LYshow_kb_rate
	      && (total >= kb_units || bytes >= kb_units)) {
		units = gettext("KB");
		divisor = kb_units;
		bytes /= divisor;
		if (total > 0) total /= divisor;
	    }
d273 2
a274 2
	    if (total >  0)
		sprintf (line, gettext("Read %ld of %ld %s of data"), bytes, total, units);
d276 6
a281 9
		sprintf (line, gettext("Read %ld %s of data"), bytes, units);
	    if ((transfer_rate > 0)
		  && (!LYshow_kb_rate || (bytes * divisor >= kb_units)))
		sprintf (line + strlen(line), gettext(", %ld %s/sec."), transfer_rate / divisor, units);
	    else
		sprintf (line + strlen(line), ".");
	    if (total <  0) {
		if (total < -1)
		    strcat(line, gettext(" (Press 'z' to abort)"));
d284 19
d305 1
a305 1
	    CTRACE(tfp, "%s\n", line);
d308 3
d325 32
d359 2
a360 2
/*	Seek confirmation.				HTConfirm()
**	------------------
d362 1
a362 1
PUBLIC BOOL HTConfirmDefault ARGS2(CONST char *, Msg, int, Dft)
d364 26
d394 6
d402 6
d411 7
d423 3
d430 1
a430 1
	    int c = LYgetch();
d434 1
a434 1
		c = *msg_no;
d437 9
a445 1
	    if (c == 7 || c == 3) { /* remember we had ^G or ^C */
a447 4
	    } else if (TOUPPER(c) == TOUPPER(*msg_yes)) {
		result = YES;
	    } else if (TOUPPER(c) == TOUPPER(*msg_no)) {
		return(NO);
d449 2
a450 1
		return(Dft);
d453 3
d460 3
d465 83
a547 1
    return HTConfirmDefault(Msg, DFT_CONFIRM);
d764 1
a764 1
	void *, 	dp,
d769 2
a770 2
    domain_entry *de;
    int ch, namelen, valuelen, space_free;
d772 1
a772 1
    if ((de = (domain_entry *)dp) == NULL)
a774 1
#ifdef ENHANCED_COOKIES
d778 1
a778 1
    **	default cookie handling code cope with this fine.  I hope.
d780 1
a780 1
#endif
d784 1
a784 1
    if (de->bv == ACCEPT_ALWAYS || de->bv == FROM_FILE)
a800 24
    if (de != NULL) {
	if (de->bv == ACCEPT_ALWAYS)
	    return TRUE;
	if (de->bv == REJECT_ALWAYS)
	    return FALSE;
    }
    space_free = (((LYcols - 1)
	       - strlen(ADVANCED_COOKIE_CONFIRMATION))
	       - strlen(server));
    if (space_free < 0)
	space_free = 0;
    namelen = strlen(name);
    valuelen = strlen(value);
    if ((namelen + valuelen) > space_free) {
	/*
	**  Argh... there isn't enough space on our single line for
	**  the whole cookie.  Reduce them both by a percentage.
	**  This should be smarter.
	*/
        int percentage;  /* no float */
        percentage = (100 * space_free) / (namelen + valuelen);
        namelen = (percentage * namelen) / 100;
        valuelen = (percentage * valuelen) / 100;
    }
d802 1
d804 20
a823 2
	HTSprintf(&message, ADVANCED_COOKIE_CONFIRMATION,
		 server, namelen, name, valuelen, value);
d827 3
a829 3
    while (1) {
	if(!LYAcceptAllCookies) {
	    ch = LYgetch();
d831 43
a873 1
	    ch = 'A';
d881 1
a881 1
	switch(TOUPPER(ch)) {
a890 2
	    case 7:	/* Ctrl-G */
	    case 3:	/* Ctrl-C */
d894 1
d914 2
d974 1
a974 1
	move(LYlines-2, 0);
d976 3
a978 3
	addstr(StatusInfo);
	clrtoeol();
	move(LYlines-1, 0);
d981 2
a982 2
	addstr(url);
	clrtoeol();
d1008 2
a1009 2
	c = LYgetch();
	switch (TOUPPER(c)) {
d1067 51
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 9
a10 9
 *	==========================================================
 *
 *	REPLACE THIS MODULE with a GUI version in a GUI environment!
 *
 * History:
 *	   Jun 92 Created May 1992 By C.T. Barker
 *	   Feb 93 Simplified, portablised TBL
 *
 */
d21 1
a21 1
#include <LYHistory.h>		/* store statusline messages */
a24 18
#include <HTParse.h>

#undef timezone			/* U/Win defines this in time.h, hides implementation detail */

#if defined(HAVE_FTIME) && defined(HAVE_SYS_TIMEB_H)
#include <sys/timeb.h>
#endif

/*
 * 'napms()' is preferable to 'sleep()' in any case because it does not
 * interfere with output, but also because it can be less than a second.
 */
#ifdef HAVE_NAPMS
#define LYSleep(n) napms(n)
#else
#define LYSleep(n) sleep(n)
#endif

d26 4
a29 3
 *	--------------------------------
 */
void HTAlert(const char *Msg)
d31 1
a31 1
    CTRACE((tfp, "\nAlert!: %s\n\n", Msg));
d36 1
a36 1
    LYSleepAlert();
d39 3
a41 2
void HTAlwaysAlert(const char *extra_prefix,
		   const char *Msg)
d51 1
a51 2
	    LYstore_message2(ALERT_FORMAT, Msg);
	    LYSleepAlert();
d53 3
a55 1
	    fprintf(((TRACE) ? stdout : stderr), ALERT_FORMAT, NonNull(Msg));
d57 1
a57 2
	    LYstore_message2(ALERT_FORMAT, Msg);
	    LYSleepAlert();
d60 1
a60 1
	CTRACE((tfp, "\nAlert!: %s\n\n", Msg));
d66 4
a69 3
 *	--------------------------------
 */
void HTInfoMsg(const char *Msg)
d72 2
a73 2
    if (non_empty(Msg)) {
	CTRACE((tfp, "Info message: %s\n", Msg));
d75 1
a75 1
	LYSleepInfo();
d80 4
a83 3
 *	--------------------------------
 */
void HTUserMsg(const char *Msg)
d86 2
a87 2
    if (non_empty(Msg)) {
	CTRACE((tfp, "User message: %s\n", Msg));
d89 1
a89 7
#if !(defined(USE_SLANG) || defined(WIDEC_CURSES))
	if (HTCJK != NOCJK) {
	    clearok(curscr, TRUE);
	    LYrefresh();
	}
#endif
	LYSleepMsg();
d93 3
a95 1
void HTUserMsg2(const char *Msg2, const char *Arg)
d98 4
a101 4
    if (non_empty(Msg2)) {
	CTRACE((tfp, "User message: "));
	CTRACE((tfp, Msg2, Arg));
	CTRACE((tfp, "\n"));
d103 1
a103 1
	LYSleepMsg();
d108 4
a111 3
 *	-------------------------
 */
void HTProgress(const char *Msg)
d115 1
a115 2
    CTRACE((tfp, "%s\n", Msg));
    LYSleepDebug();
d118 6
a123 17
const char *HTProgressUnits(int rate)
{
    static const char *bunits = 0;
    static const char *kbunits = 0;

    if (!bunits) {
	bunits = gettext("bytes");
	kbunits = gettext(LYTransferName);
    }
    return ((rate == rateKB)
#ifdef USE_READPROGRESS
	    || (rate == rateEtaKB)
#endif
	)? kbunits : bunits;
}

static const char *sprint_bytes(char *s, long n, const char *was_units)
d126 2
a127 40
    const char *u = HTProgressUnits(LYTransferRate);

    if (LYTransferRate == rateKB || LYTransferRate == rateEtaKB_maybe) {
	if (n >= 10 * kb_units) {
	    sprintf(s, "%ld", n / kb_units);
	} else if (n > 999) {	/* Avoid switching between 1016b/s and 1K/s */
	    sprintf(s, "%.2g", ((double) n) / kb_units);
	} else {
	    sprintf(s, "%ld", n);
	    u = HTProgressUnits(rateBYTES);
	}
    } else {
	sprintf(s, "%ld", n);
    }

    if (!was_units || was_units != u)
	sprintf(s + strlen(s), " %s", u);
    return u;
}

#ifdef USE_READPROGRESS
#define TIME_HMS_LENGTH (16)
static char *sprint_tbuf(char *s, long t)
{
    if (t > 3600)
	sprintf(s, "%ldh%ldm%lds", t / 3600, (t / 60) % 60, t % 60);
    else if (t > 60)
	sprintf(s, "%ldm%lds", t / 60, t % 60);
    else
	sprintf(s, "%ld sec", t);
    return s;
}
#endif /* USE_READPROGRESS */

/*	Issue a read-progress message.			HTReadProgress()
 *	------------------------------
 */
void HTReadProgress(long bytes, long total)
{
    static long bytes_last, total_last;
d129 4
a132 27
    static char *line = NULL;
    char bytesp[80], totalp[80], transferp[80];
    int renew = 0;
    const char *was_units;

#ifdef HAVE_GETTIMEOFDAY
    struct timeval tv;
    double now;
    static double first, last, last_active;

    gettimeofday(&tv, (struct timezone *) 0);
    now = tv.tv_sec + tv.tv_usec / 1000000.;
#else
#if defined(HAVE_FTIME) && defined(HAVE_SYS_TIMEB_H)
    static double now, first, last, last_active;
    struct timeb tb;

    ftime(&tb);
    now = tb.time + (double) tb.millitm / 1000;
#else
    time_t now = time((time_t *) 0);	/* once per second */
    static time_t first, last, last_active;
#endif
#endif

    if (!LYShowTransferRate)
	LYTransferRate = rateOFF;
d135 1
a135 1
	first = last = last_active = now;
d137 5
a141 10
    } else if (bytes < 0) {	/* stalled */
	bytes = bytes_last;
	total = total_last;
    }
    if ((bytes > 0) &&
	(now != first))
	/* 1 sec delay for transfer_rate calculation without g-t-o-d */  {
	if (transfer_rate <= 0)	/* the very first time */
	    transfer_rate = (long) ((bytes) / (now - first));	/* bytes/sec */
	total_last = total;
d144 3
a146 1
	 * Optimal refresh time:  every 0.2 sec
d148 2
a149 11
#if defined(HAVE_GETTIMEOFDAY) || (defined(HAVE_FTIME) && defined(HAVE_SYS_TIMEB_H))
	if (now >= last + 0.2)
	    renew = 1;
#else
	/*
	 * Use interpolation.  (The transfer rate may be not constant
	 * when we have partial content in a proxy.  We adjust transfer_rate
	 * once a second to minimize interpolation error below.)
	 */
	if ((now != last) || ((bytes - bytes_last) > (transfer_rate / 5))) {
	    renew = 1;
d151 1
a151 3
	}
#endif
	if (renew) {
a153 2
		if (bytes_last != bytes)
		    last_active = now;
d155 1
a155 1
		transfer_rate = (long) (bytes / (now - first));		/* more accurate value */
d158 12
a169 2
	    if (total > 0)
		was_units = sprint_bytes(totalp, total, 0);
d171 4
a174 5
		was_units = 0;
	    sprint_bytes(bytesp, bytes, was_units);

	    if (total > 0)
		HTSprintf0(&line, gettext("Read %s of %s of data"), bytesp, totalp);
d176 4
a179 20
		HTSprintf0(&line, gettext("Read %s of data"), bytesp);

	    if (LYTransferRate != rateOFF
		&& transfer_rate > 0) {
		sprint_bytes(transferp, transfer_rate, 0);
		HTSprintf(&line, gettext(", %s/sec"), transferp);
	    }
#ifdef USE_READPROGRESS
	    if (LYTransferRate == rateEtaBYTES
		|| LYTransferRate == rateEtaKB) {
		char tbuf[TIME_HMS_LENGTH];

		if (now - last_active >= 5)
		    HTSprintf(&line,
			      gettext(" (stalled for %s)"),
			      sprint_tbuf(tbuf, (long) (now - last_active)));
		if (total > 0 && transfer_rate)
		    HTSprintf(&line,
			      gettext(", ETA %s"),
			      sprint_tbuf(tbuf, (long) ((total - bytes) / transfer_rate)));
a180 5
#endif

	    StrAllocCat(line, ".");
	    if (total < -1)
		StrAllocCat(line, gettext(" (Press 'z' to abort)"));
d184 1
a184 1
	    CTRACE((tfp, "%s\n", line));
d186 1
a186 4
	}
#ifdef LY_FIND_LEAKS
    FREE(line);
#endif
d189 1
a189 1
static BOOL conf_cancelled = NO;	/* used by HTConfirm only - kw */
d191 1
a191 1
BOOL HTLastConfirmCancelled(void)
d195 1
a195 18
	return (YES);
    } else {
	return (NO);
    }
}

/*
 * Prompt for yes/no response, but let a configuration variable override
 * the prompt entirely.
 */
int HTForcedPrompt(int option, const char *msg, int dft)
{
    int result = FALSE;
    const char *show = NULL;
    char *msg2 = NULL;

    if (option == FORCE_PROMPT_DFT) {
	result = HTConfirmDefault(msg, dft);
d197 1
a197 12
	if (option == FORCE_PROMPT_YES) {
	    show = gettext("yes");
	    result = YES;
	} else if (option == FORCE_PROMPT_NO) {
	    show = gettext("no");
	    result = NO;
	} else {
	    return HTConfirmDefault(msg, dft);	/* bug... */
	}
	HTSprintf(&msg2, "%s %s", msg, show);
	HTUserMsg(msg2);
	free(msg2);
a198 1
    return result;
d203 4
a206 4
/*	Seek confirmation with default answer.		HTConfirmDefault()
 *	--------------------------------------
 */
int HTConfirmDefault(const char *Msg, int Dft)
d208 2
a209 28
/* Meta-note: don't move the following note from its place right
   in front of the first gettext().  As it is now, it should
   automatically appear in generated lynx.pot files. - kw
 */

/* NOTE TO TRANSLATORS:  If you provide a translation for "yes", lynx
 * will take the first byte of the translation as a positive response
 * to Yes/No questions.  If you provide a translation for "no", lynx
 * will take the first byte of the translation as a negative response
 * to Yes/No questions.  For both, lynx will also try to show the
 * first byte in the prompt as a character, instead of (y) or (n),
 * respectively.  This will not work right for multibyte charsets!
 * Don't translate "yes" and "no" for CJK character sets (or translate
 * them to "yes" and "no").  For a translation using UTF-8, don't
 * translate if the translation would begin with anything but a 7-bit
 * (US_ASCII) character.  That also means do not translate if the
 * translation would begin with anything but a 7-bit character, if
 * you use a single-byte character encoding (a charset like ISO-8859-n)
 * but anticipate that the message catalog may be used re-encoded in
 * UTF-8 form.
 * For translations using other character sets, you may also wish to
 * leave "yes" and "no" untranslated, if using (y) and (n) is the
 * preferred behavior.
 * Lynx will also accept y Y n N as responses unless there is a conflict
 * with the first letter of the "yes" or "no" translation.
 */
    const char *msg_yes = gettext("yes");
    const char *msg_no = gettext("no");
a211 6
    /* If they're not really distinct in the first letter, revert to English */
    if (TOUPPER(*msg_yes) == TOUPPER(*msg_no)) {
	msg_yes = "yes";
	msg_no = "no";
    }

d213 1
a213 7
    if (dump_output_immediately) {	/* Non-interactive, can't respond */
	if (Dft == DFT_CONFIRM) {
	    CTRACE((tfp, "Confirm: %s (%c/%c) ", Msg, *msg_yes, *msg_no));
	} else {
	    CTRACE((tfp, "Confirm: %s (%c) ", Msg, (Dft == YES) ? *msg_yes : *msg_no));
	}
	CTRACE((tfp, "- NO, not interactive.\n"));
a216 7
	char fallback_y = 'y';	/* English letter response as fallback */
	char fallback_n = 'n';	/* English letter response as fallback */

	if (fallback_y == *msg_yes || fallback_y == *msg_no)
	    fallback_y = '\0';	/* conflict or duplication, don't use */
	if (fallback_n == *msg_yes || fallback_n == *msg_no)
	    fallback_n = '\0';	/* conflict or duplication, don't use */
a221 3
	if (LYTraceLogFP) {
	    CTRACE((tfp, "Confirm: %s", msg));
	}
d226 1
a226 2
	    int c = LYgetch_single();

d230 1
a230 1
		c = TOUPPER(*msg_no);
d233 2
a234 3
	    if (c == TOUPPER(*msg_yes)) {
		result = YES;
	    } else if (c == TOUPPER(*msg_no)) {
d236 1
a236 1
	    } else if (fallback_y && c == fallback_y) {
d238 2
a239 5
	    } else if (fallback_n && c == fallback_n) {
		result = NO;
	    } else if (LYCharIsINTERRUPT(c)) {	/* remember we had ^G or ^C */
		conf_cancelled = YES;
		result = NO;
d241 1
a241 2
		result = Dft;
		break;
a243 3
	CTRACE((tfp, "- %s%s.\n",
		(result != NO) ? "YES" : "NO",
		conf_cancelled ? ", cancelled" : ""));
d248 1
a248 4
/*	Seek confirmation.				HTConfirm()
 *	------------------
 */
BOOL HTConfirm(const char *Msg)
d250 1
a250 83
    return (BOOL) HTConfirmDefault(Msg, DFT_CONFIRM);
}

/*
 * Ask a post resubmission prompt with some indication of what would
 * be resubmitted, useful especially for going backward in history.
 * Try to use parts of the address or, if given, the title, depending
 * on how much fits on the statusline.
 * if_imgmap and if_file indicate how to handle an address that is
 * a "LYNXIMGMAP:", or a "file:" URL (presumably the List Page file),
 * respectively:  0:  auto-deny, 1:  auto-confirm, 2:  prompt.
 * - kw
 */

BOOL confirm_post_resub(const char *address,
			const char *title,
			int if_imgmap,
			int if_file)
{
    size_t len1;
    const char *msg = CONFIRM_POST_RESUBMISSION_TO;
    char buf[240];
    char *temp = NULL;
    BOOL res;
    size_t maxlen = LYcolLimit - 5;

    if (!address) {
	return (NO);
    } else if (isLYNXIMGMAP(address)) {
	if (if_imgmap <= 0)
	    return (NO);
	else if (if_imgmap == 1)
	    return (YES);
	else
	    msg = CONFIRM_POST_LIST_RELOAD;
    } else if (isFILE_URL(address)) {
	if (if_file <= 0)
	    return (NO);
	else if (if_file == 1)
	    return (YES);
	else
	    msg = CONFIRM_POST_LIST_RELOAD;
    } else if (dump_output_immediately) {
	return (NO);
    }
    if (maxlen >= sizeof(buf))
	maxlen = sizeof(buf) - 1;
    if ((len1 = strlen(msg)) +
	strlen(address) <= maxlen) {
	sprintf(buf, msg, address);
	return HTConfirm(buf);
    }
    if (len1 + strlen(temp = HTParse(address, "",
				     PARSE_ACCESS + PARSE_HOST + PARSE_PATH
				     + PARSE_PUNCTUATION)) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return (res);
    }
    FREE(temp);
    if (title && (len1 + strlen(title) <= maxlen)) {
	sprintf(buf, msg, title);
	return HTConfirm(buf);
    }
    if (len1 + strlen(temp = HTParse(address, "",
				     PARSE_ACCESS + PARSE_HOST
				     + PARSE_PUNCTUATION)) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return (res);
    }
    FREE(temp);
    if ((temp = HTParse(address, "", PARSE_HOST)) && *temp &&
	len1 + strlen(temp) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return (res);
    }
    FREE(temp);
    return HTConfirm(CONFIRM_POST_RESUBMISSION);
d254 5
a258 3
 *	------------------------------------
 */
char *HTPrompt(const char *Msg, const char *deflt)
d260 1
a260 1
    char *rep = NULL;
d264 1
a264 1
    Tmp[sizeof(Tmp) - 1] = '\0';
d268 1
a268 1
	strncpy(Tmp, deflt, sizeof(Tmp) - 1);
d279 5
a283 4
 *	Prompt for password without echoing the reply.	HTPromptPassword()
 *	----------------------------------------------
 */
char *HTPromptPassword(const char *Msg)
d292 1
a292 1
	LYgetstr(pw, HIDDEN, sizeof(pw), NORECALL);	/* hidden */
d302 27
a328 26
 *	----------------------------------
 *
 *  On entry,
 *	Msg		is the prompting message.
 *	*username and
 *	*password	are char pointers which contain default
 *			or zero-length strings; they are changed
 *			to point to result strings.
 *	IsProxy 	should be TRUE if this is for
 *			proxy authentication.
 *
 *			If *username is not NULL, it is taken
 *			to point to a default value.
 *			Initial value of *password is
 *			completely discarded.
 *
 *  On exit,
 *	*username and *password point to newly allocated
 *	strings -- original strings pointed to by them
 *	are NOT freed.
 *
 */
void HTPromptUsernameAndPassword(const char *Msg,
				 char **username,
				 char **password,
				 BOOL IsProxy)
d335 4
a338 4
	 * The -auth or -pauth parameter gave us both the username
	 * and password to use for the first realm or proxy server,
	 * respectively, so just use them without any prompting.  - FM
	 */
d340 1
a340 1
				 proxyauth_info[0] : authentication_info[0]));
d347 1
a347 1
				 proxyauth_info[1] : authentication_info[1]));
d355 3
a357 3
	 * We are not interactive and don't have both the
	 * username and password from the command line,
	 * but might have one or the other.  - FM
d362 2
a363 2
	     * Use the command line username.  - FM
	     */
d365 1
a365 1
				     proxyauth_info[0] : authentication_info[0]));
d373 2
a374 2
	     * Default to "WWWuser".  - FM
	     */
d380 2
a381 2
	     * Use the command line password.  - FM
	     */
d383 1
a383 1
				     proxyauth_info[1] : authentication_info[1]));
d391 2
a392 2
	     * Default to a zero-length string.  - FM
	     */
d399 3
a401 3
	 * We are interactive and don't have both the
	 * username and password from the command line,
	 * but might have one or the other.  - FM
d406 3
a408 3
	     * Offer the command line username in the
	     * prompt for the first realm.  - FM
	     */
d410 1
a410 1
				     proxyauth_info[0] : authentication_info[0]));
d418 1
a418 1
	 * Prompt for confirmation or entry of the username.  - FM
d428 2
a429 2
	     * Use the command line password for the first realm.  - FM
	     */
d431 1
a431 1
				     proxyauth_info[1] : authentication_info[1]));
d437 1
a437 1
	} else if (non_empty(*username)) {
d439 3
a441 3
	     * We have a non-zero length username,
	     * so prompt for the password.  - FM
	     */
d445 2
a446 2
	     * Return a zero-length password.  - FM
	     */
d453 18
a470 16
 *	---------------------------
 *
 *  On entry,
 *	server			is the server sending the Set-Cookie.
 *	domain			is the domain of the cookie.
 *	path			is the path of the cookie.
 *	name			is the name of the cookie.
 *	value			is the value of the cookie.
 *
 *  On exit,
 *	Returns FALSE on cancel,
 *		TRUE if the cookie should be set.
 */
BOOL HTConfirmCookie(domain_entry * de, const char *server,
		     const char *name,
		     const char *value)
d472 2
a473 2
    int ch;
    const char *prompt = ADVANCED_COOKIE_CONFIRMATION;
d475 1
a475 1
    if (de == NULL)
d478 7
a484 6
    /* If the user has specified a list of domains to allow or deny
     * from the config file, then they'll already have de->bv set to
     * ACCEPT_ALWAYS or REJECT_ALWAYS so we can relax and let the
     * default cookie handling code cope with this fine.
     */

d486 3
a488 3
     * If the user has specified a constant action, don't prompt at all.
     */
    if (de->bv == ACCEPT_ALWAYS)
d495 4
a498 4
	 * Non-interactive, can't respond.  Use the LYSetCookies value
	 * based on its compilation or configuration setting, or on the
	 * command line toggle.  - FM
	 */
d503 27
a529 4
     * Estimate how much of the cookie we can show.
     */
    if (!LYAcceptAllCookies) {
	int namelen, valuelen, space_free, percentage;
d531 2
a532 20

	space_free = (LYcolLimit
		      - (strlen(prompt)
			 - 10)	/* %s and %.*s and %.*s chars */
		      -strlen(server));
	if (space_free < 0)
	    space_free = 0;
	namelen = strlen(name);
	valuelen = strlen(value);
	if ((namelen + valuelen) > space_free) {
	    /*
	     * Argh...  there isn't enough space on our single line for
	     * the whole cookie.  Reduce them both by a percentage.
	     * This should be smarter.
	     */
	    percentage = (100 * space_free) / (namelen + valuelen);
	    namelen = (percentage * namelen) / 100;
	    valuelen = (percentage * valuelen) / 100;
	}
	HTSprintf(&message, prompt, server, namelen, name, valuelen, value);
d536 4
a539 2
    for (;;) {
	if (LYAcceptAllCookies) {
a540 44
	} else {
	    ch = LYgetch_single();
#if defined(LOCALE) && defined(HAVE_GETTEXT)
	    {
#define L_PAREN '('
#define R_PAREN ')'
		/*
		 * Special-purpose workaround for gettext support (we should do
		 * this in a more general way) -TD
		 *
		 * NOTE TO TRANSLATORS:  If the prompt has been rendered into
		 * another language, and if yes/no are distinct, assume the
		 * translator can make an ordered list in parentheses with one
		 * capital letter for each as we assumed in HTConfirmDefault().
		 * The list has to be in the same order as in the original message,
		 * and the four capital letters chosen to not match those in the
		 * original unless they have the same position.
		 *
		 * Example:
		 * (Y/N/Always/neVer)              - English (original)
		 * (O/N/Toujours/Jamais)           - French
		 */
		char *p = gettext("Y/N/A/V");	/* placeholder for comment */
		char *s = "YNAV\007\003";	/* see ADVANCED_COOKIE_CONFIRMATION */

		if (strchr(s, ch) == 0
		    && isalpha(ch)
		    && (p = strrchr(prompt, L_PAREN)) != 0) {

		    CTRACE((tfp, "Looking for %c in %s\n", ch, p));
		    while (*p != R_PAREN && *p != 0 && isalpha(UCH(*s))) {
			if (isalpha(UCH(*p)) && (*p == TOUPPER(*p))) {
			    CTRACE((tfp, "...testing %c/%c\n", *p, *s));
			    if (*p == ch) {
				ch = *s;
				break;
			    }
			    ++s;
			}
			++p;
		    }
		}
	    }
#endif
d548 17
a564 8
	switch (ch) {
	case 'A':
	    /*
	     * Set to accept all cookies for this domain.
	     */
	    de->bv = ACCEPT_ALWAYS;
	    HTUserMsg2(ALWAYS_ALLOWING_COOKIES, de->domain);
	    return TRUE;
d566 7
a572 7
	case 'N':
	    /*
	     * Reject the cookie.
	     */
	  reject:
	    HTUserMsg(REJECTING_COOKIE);
	    return FALSE;
d574 6
a579 7
	case 'V':
	    /*
	     * Set to reject all cookies from this domain.
	     */
	    de->bv = REJECT_ALWAYS;
	    HTUserMsg2(NEVER_ALLOWING_COOKIES, de->domain);
	    return FALSE;
d581 2
a582 11
	case 'Y':
	    /*
	     * Accept the cookie.
	     */
	    HTInfoMsg(ALLOWING_COOKIE);
	    return TRUE;

	default:
	    if (LYCharIsINTERRUPT(ch))
		goto reject;
	    continue;
d588 14
a601 12
 *	----------------------------
 *
 *  On entry,
 *	Redirecting_url 	    is the Location.
 *	server_status		    is the server status code.
 *
 *  On exit,
 *	Returns 0 on cancel,
 *	  1 for redirect of POST with content,
 *	303 for redirect as GET without content
 */
int HTConfirmPostRedirect(const char *Redirecting_url, int server_status)
d607 3
a609 4
    int on_screen = 0;		/* 0 - show menu

				 * 1 - show url
				 * 2 - menu is already on screen */
d614 3
a616 3
	 * HTTP.c should not have called us for either of
	 * these because we're treating 302 as historical,
	 * so just return 303.  - FM
d624 3
a626 3
	     * Treat 301 as historical, i.e., like 303 (GET
	     * without content), when not interactive.  - FM
	     */
d630 4
a633 4
	     * Treat anything else (e.g., 305, 306 or 307) as too
	     * dangerous to redirect without confirmation, and thus
	     * cancel when not interactive.  - FM
	     */
d640 1
a640 1
	LYmove(LYlines - 2, 0);
d642 3
a644 3
	LYaddstr(StatusInfo);
	LYclrtoeol();
	LYmove(LYlines - 1, 0);
d646 3
a648 3
		   (LYcols < 250 ? LYcolLimit - 5 : 250), Redirecting_url);
	LYaddstr(url);
	LYclrtoeol();
d656 5
a660 5
		   server_status,
		   251,
		   ((server_status == 301) ?
		    ADVANCED_POST_GET_REDIRECT :
		    ADVANCED_POST_REDIRECT));
d668 5
a672 5
	case 0:
	    _statusline(StatusInfo);
	    break;
	case 1:
	    _statusline(show_POST_url);
d674 32
a705 10
	c = LYgetch_single();
	switch (c) {
	case 'P':
	    /*
	     * Proceed with 301 or 307 redirect of POST
	     * with same method and POST content.  - FM
	     */
	    FREE(show_POST_url);
	    result = 1;
	    break;
d707 10
a716 8
	case 7:
	case 'C':
	    /*
	     * Cancel request.
	     */
	    FREE(show_POST_url);
	    result = 0;
	    break;
d718 4
a721 5
	case 'U':
	    /*
	     * Show URL for intermediate or advanced mode.
	     */
	    if (user_mode != NOVICE_MODE) {
d725 1
a725 1
		    on_screen = 1;
a726 23
	    }
	    break;

	case 'G':
	    if (server_status == 301) {
		/*
		 * Treat as 303 (GET without content).
		 */
		FREE(show_POST_url);
		result = 303;
		break;
	    }
	    /* fall through to default */

	default:
	    /*
	     * Get another character.
	     */
	    if (on_screen == 1) {
		on_screen = 0;
	    } else {
		on_screen = 2;
	    }
a732 50

#define okToSleep() (!crawl && !traversal && LYCursesON)

/*
 * Sleep for the given message class's time.
 */
void LYSleepAlert(void)
{
    if (okToSleep())
	LYSleep(AlertSecs);
}

void LYSleepDebug(void)
{
    if (okToSleep())
	LYSleep(DebugSecs);
}

void LYSleepInfo(void)
{
    if (okToSleep())
	LYSleep(InfoSecs);
}

void LYSleepMsg(void)
{
    if (okToSleep())
	LYSleep(MessageSecs);
}

#ifdef EXP_CMD_LOGGING
void LYSleepReplay(void)
{
    if (okToSleep())
	LYSleep(ReplaySecs);
}
#endif /* EXP_CMD_LOGGING */

/*
 * LYstrerror emulates the ANSI strerror() function.
 */
#ifndef LYStrerror
char *LYStrerror(int code)
{
    static char temp[80];

    sprintf(temp, "System errno is %d.\r\n", code);
    return temp;
}
#endif /* HAVE_STRERROR */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a24 18
#include <HTParse.h>

#undef timezone	/* U/Win defines this in time.h, hides implementation detail */

#if defined(HAVE_FTIME) && defined(HAVE_SYS_TIMEB_H)
#include <sys/timeb.h>
#endif

/*
 * 'napms()' is preferable to 'sleep()' in any case because it does not
 * interfere with output, but also because it can be less than a second.
 */
#ifdef HAVE_NAPMS
#define LYSleep(n) napms(n)
#else
#define LYSleep(n) sleep(n)
#endif

d31 1
a31 1
    CTRACE((tfp, "\nAlert!: %s\n\n", Msg));
d36 1
a36 1
    LYSleepAlert();
d51 1
a51 2
	    LYstore_message2(ALERT_FORMAT, Msg);
	    LYSleepAlert();
d53 3
a55 1
	    fprintf(((TRACE) ? stdout : stderr), ALERT_FORMAT, NonNull(Msg));
d57 1
a57 2
	    LYstore_message2(ALERT_FORMAT, Msg);
	    LYSleepAlert();
d60 1
a60 1
	CTRACE((tfp, "\nAlert!: %s\n\n", Msg));
d73 1
a73 1
	CTRACE((tfp, "Info message: %s\n", Msg));
d75 1
a75 1
	LYSleepInfo();
d87 1
a87 1
	CTRACE((tfp, "User message: %s\n", Msg));
d89 1
a89 7
#if !(defined(USE_SLANG) || defined(WIDEC_CURSES))
	if (HTCJK != NOCJK) {
	    clearok(curscr, TRUE);
	    LYrefresh();
	}
#endif
	LYSleepMsg();
d99 3
a101 3
	CTRACE((tfp, "User message: "));
	CTRACE((tfp, Msg2, Arg));
	CTRACE((tfp, "\n"));
d103 1
a103 1
	LYSleepMsg();
d115 1
a115 49
    CTRACE((tfp, "%s\n", Msg));
    LYSleepDebug();
}

PRIVATE char *sprint_bytes ARGS3(
	char *,		s,
	long,		n,
	char *, 	was_units)
{
    static long kb_units = 1024;
    static char *bunits;
    static char *kbunits;
    char *u;

    if (!bunits) {
	bunits = gettext("bytes");
	kbunits = gettext("KB");
    }

    u = kbunits;
    if ( (LYTransferRate == rateKB || LYTransferRate == rateEtaKB_maybe)
	 && (n >= 10 * kb_units) )
	sprintf(s, "%ld", n/kb_units);
    else if ((LYTransferRate == rateKB || LYTransferRate == rateEtaKB_maybe)
	     && (n > 999))	/* Avoid switching between 1016b/s and 1K/s */
	sprintf(s, "%.2g", ((double)n)/kb_units);
    else {
	sprintf(s, "%ld", n);
	u = bunits;
    }

    if (!was_units || was_units != u)
	sprintf(s + strlen(s), " %s", u);
    return u;
}

#ifdef EXP_READPROGRESS
#define TIME_HMS_LENGTH (16)
PRIVATE char *sprint_tbuf ARGS2(
	char *,	       s,
	long,	       t)
{
    if (t > 3600)
	sprintf (s, "%ldh%ldm%lds", t / 3600, (t / 60) % 60, t % 60);
    else if (t > 60)
	sprintf (s, "%ldm%lds", t / 60, t % 60);
    else
	sprintf (s, "%ld sec", t);
    return s;
a116 1
#endif /* EXP_READPROGRESS */
d125 3
a127 1
    static long bytes_last, total_last;
d129 2
a130 19
    static char *line = NULL;
    char bytesp[80], totalp[80], transferp[80];
    int renew = 0;
    char *was_units;

#ifdef HAVE_GETTIMEOFDAY
    struct timeval tv;
    int dummy = gettimeofday(&tv, (struct timezone *)0);
    double now = tv.tv_sec + tv.tv_usec/1000000. ;
    static double first, last, last_active;
    (void)dummy;		/* quiet unused-assignment warning */
#else
#if defined(HAVE_FTIME) && defined(HAVE_SYS_TIMEB_H)
    static double now, first, last, last_active;
    struct timeb tb;

    ftime(&tb);
    now = tb.time + (double)tb.millitm / 1000;
#else
d132 1
a132 6
    static time_t first, last, last_active;
#endif
#endif

    if (!LYShowTransferRate)
	LYTransferRate = rateOFF;
d135 1
a135 1
	first = last = last_active = now;
d137 1
a137 5
    } else if (bytes < 0) {	/* stalled */
	bytes = bytes_last;
	total = total_last;
    }
    if ((bytes > 0) &&
d139 1
a139 1
		/* 1 sec delay for transfer_rate calculation without g-t-o-d */ {
d141 1
a141 2
	    transfer_rate = (long)((bytes) / (now - first));   /* bytes/sec */
	total_last = total;
d144 3
a146 1
	 * Optimal refresh time:  every 0.2 sec
d148 2
a149 11
#if defined(HAVE_GETTIMEOFDAY) || (defined(HAVE_FTIME) && defined(HAVE_SYS_TIMEB_H))
	if (now >= last + 0.2)
	    renew = 1;
#else
	/*
	 * Use interpolation.  (The transfer rate may be not constant
	 * when we have partial content in a proxy.  We adjust transfer_rate
	 * once a second to minimize interpolation error below.)
	 */
	if ((now != last) || ((bytes - bytes_last) > (transfer_rate / 5))) {
	    renew = 1;
d151 1
a151 3
	}
#endif
	if (renew) {
a153 2
		if (bytes_last != bytes)
		    last_active = now;
d155 11
a165 1
		transfer_rate = (long)(bytes / (now - first)); /* more accurate value */
d168 2
a169 2
	    if (total > 0)
		was_units = sprint_bytes(totalp, total, 0);
d171 4
a174 5
		was_units = 0;
	    sprint_bytes(bytesp, bytes, was_units);

	    if (total > 0)
		HTSprintf0 (&line, gettext("Read %s of %s of data"), bytesp, totalp);
d176 4
a179 6
		HTSprintf0 (&line, gettext("Read %s of data"), bytesp);

	    if (LYTransferRate != rateOFF
	     && transfer_rate > 0) {
		sprint_bytes(transferp, transfer_rate, 0);
		HTSprintf (&line, gettext(", %s/sec"), transferp);
a181 19
#ifdef EXP_READPROGRESS
	    if (LYTransferRate == rateEtaBYTES
	     || LYTransferRate == rateEtaKB) {
		char tbuf[TIME_HMS_LENGTH];
		if (now - last_active >= 5)
		    HTSprintf (&line,
			       gettext(" (stalled for %s)"),
			       sprint_tbuf (tbuf, (long)(now - last_active)));
		if (total > 0 && transfer_rate)
		    HTSprintf (&line,
			       gettext(", ETA %s"),
			       sprint_tbuf (tbuf, (long)((total - bytes)/transfer_rate)));
	    }
#endif

	    StrAllocCat (line, ".");
	    if (total < -1)
		StrAllocCat(line, gettext(" (Press 'z' to abort)"));

d184 1
a184 1
	    CTRACE((tfp, "%s\n", line));
a186 3
#ifdef LY_FIND_LEAKS
    FREE(line);
#endif
a200 32
/*
 * Prompt for yes/no response, but let a configuration variable override
 * the prompt entirely.
 */
PUBLIC int HTForcedPrompt ARGS3(
	int,		option,
	CONST char *,	msg,
	int,		dft)
{
    int result = FALSE;
    char *show = NULL;
    char *msg2 = NULL;

    if (option == FORCE_PROMPT_DFT) {
	result = HTConfirmDefault(msg, dft);
    } else {
	if (option == FORCE_PROMPT_YES) {
	    show = gettext("yes");
	    result = YES;
	} else if (option == FORCE_PROMPT_NO) {
	    show = gettext("no");
	    result = NO;
	} else {
	    return HTConfirmDefault(msg, dft);	/* bug... */
	}
	HTSprintf(&msg2, "%s %s", msg, show);
	HTUserMsg(msg2);
	free(msg2);
    }
    return result;
}

d203 2
a204 2
/*	Seek confirmation with default answer.		HTConfirmDefault()
**	--------------------------------------
d206 1
a206 1
PUBLIC int HTConfirmDefault ARGS2(CONST char *, Msg, int, Dft)
a207 26
/* Meta-note: don't move the following note from its place right
   in front of the first gettext().  As it is now, it should
   automatically appear in generated lynx.pot files. - kw
 */

/*  NOTE TO TRANSLATORS:  If you provide a translation for "yes", lynx
 *  will take the first byte of the translation as a positive response
 *  to Yes/No questions.  If you provide a translation for "no", lynx
 *  will take the first byte of the translation as a negative response
 *  to Yes/No questions.  For both, lynx will also try to show the
 *  first byte in the prompt as a character, instead of (y) or (n),
 *  respectively.  This will not work right for multibyte charsets!
 *  Don't translate "yes" and "no" for CJK character sets (or translate
 *  them to "yes" and "no").  For a translation using UTF-8, don't
 *  translate if the translation would begin with anything but a 7-bit
 *  (US_ASCII) character.  That also means do not translate if the
 *  translation would begin with anything but a 7-bit character, if
 *  you use a single-byte character encoding (a charset like ISO-8859-n)
 *  but anticipate that the message catalog may be used re-encoded in
 *  UTF-8 form.
 *  For translations using other character sets, you may also wish to
 *  leave "yes" and "no" untranslated, if using (y) and (n) is the
 *  preferred behavior.
 *  Lynx will also accept y Y n N as responses unless there is a conflict
 *  with the first letter of the "yes" or "no" translation.
 */
a211 6
    /* If they're not really distinct in the first letter, revert to English */
    if (TOUPPER(*msg_yes) == TOUPPER(*msg_no)) {
	msg_yes = "yes";
	msg_no = "no";
    }

a213 6
	if (Dft == DFT_CONFIRM) {
	    CTRACE((tfp, "Confirm: %s (%c/%c) ", Msg, *msg_yes, *msg_no));
	} else {
	    CTRACE((tfp, "Confirm: %s (%c) ", Msg, (Dft == YES) ? *msg_yes : *msg_no));
	}
	CTRACE((tfp, "- NO, not interactive.\n"));
a216 7
	char fallback_y = 'y';	/* English letter response as fallback */
	char fallback_n = 'n';	/* English letter response as fallback */

	if (fallback_y == *msg_yes || fallback_y == *msg_no)
	    fallback_y = '\0';	/* conflict or duplication, don't use */
	if (fallback_n == *msg_yes || fallback_n == *msg_no)
	    fallback_n = '\0';	/* conflict or duplication, don't use */
a221 3
	if (LYTraceLogFP) {
	    CTRACE((tfp, "Confirm: %s", msg));
	}
d226 1
a226 1
	    int c = LYgetch_single();
d230 1
a230 1
		c = TOUPPER(*msg_no);
d233 2
a234 3
	    if (c == TOUPPER(*msg_yes)) {
		result = YES;
	    } else if (c == TOUPPER(*msg_no)) {
d236 1
a236 1
	    } else if (fallback_y && c == fallback_y) {
d238 2
a239 5
	    } else if (fallback_n && c == fallback_n) {
		result = NO;
	    } else if (LYCharIsINTERRUPT(c)) { /* remember we had ^G or ^C */
		conf_cancelled = YES;
		result = NO;
d241 1
a241 2
		result = Dft;
		break;
a243 3
	CTRACE((tfp, "- %s%s.\n",
	       (result != NO) ? "YES" : "NO",
	       conf_cancelled ? ", cancelled" : ""));
a247 3
/*	Seek confirmation.				HTConfirm()
**	------------------
*/
d250 1
a250 83
    return (BOOL) HTConfirmDefault(Msg, DFT_CONFIRM);
}

/*
 *  Ask a post resubmission prompt with some indication of what would
 *  be resubmitted, useful especially for going backward in history.
 *  Try to use parts of the address or, if given, the title, depending
 *  on how much fits on the statusline.
 *  if_imgmap and if_file indicate how to handle an address that is
 *  a "LYNXIMGMAP:", or a "file:" URL (presumably the List Page file),
 *  respectively: 0: auto-deny, 1: auto-confirm, 2: prompt.
 *  - kw
 */

PUBLIC BOOL confirm_post_resub ARGS4(
    CONST char*,	address,
    CONST char*,	title,
    int,		if_imgmap,
    int,		if_file)
{
    size_t len1;
    CONST char *msg = CONFIRM_POST_RESUBMISSION_TO;
    char buf[240];
    char *temp = NULL;
    BOOL res;
    size_t maxlen = LYcols - 6;
    if (!address) {
	return(NO);
    } else if (isLYNXIMGMAP(address)) {
	if (if_imgmap <= 0)
	    return(NO);
	else if (if_imgmap == 1)
	    return(YES);
	else
	    msg = CONFIRM_POST_LIST_RELOAD;
    } else if (isFILE_URL(address)) {
	if (if_file <= 0)
	    return(NO);
	else if (if_file == 1)
	    return(YES);
	else
	    msg = CONFIRM_POST_LIST_RELOAD;
    } else if (dump_output_immediately) {
	return(NO);
    }
    if (maxlen >= sizeof(buf))
	maxlen = sizeof(buf) - 1;
    if ((len1 = strlen(msg)) +
	strlen(address) <= maxlen) {
	sprintf(buf, msg, address);
	return HTConfirm(buf);
    }
    if (len1 + strlen(temp = HTParse(address, "",
				     PARSE_ACCESS+PARSE_HOST+PARSE_PATH
				     +PARSE_PUNCTUATION)) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return(res);
    }
    FREE(temp);
    if (title && (len1 + strlen(title) <= maxlen)) {
	sprintf(buf, msg, title);
	return HTConfirm(buf);
    }
    if (len1 + strlen(temp = HTParse(address, "",
				     PARSE_ACCESS+PARSE_HOST
				     +PARSE_PUNCTUATION)) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return(res);
    }
    FREE(temp);
    if ((temp = HTParse(address, "", PARSE_HOST)) && *temp &&
	len1 + strlen(temp) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return(res);
    }
    FREE(temp);
    return HTConfirm(CONFIRM_POST_RESUBMISSION);
d467 1
a467 1
	domain_entry *, de,
d472 2
a473 2
    int ch;
    char *prompt = ADVANCED_COOKIE_CONFIRMATION;
d475 1
a475 1
    if (de == NULL)
d478 1
d482 1
a482 1
    **	default cookie handling code cope with this fine.
d484 1
a484 1

d488 1
a488 1
    if (de->bv == ACCEPT_ALWAYS)
d505 24
a529 1
	int namelen, valuelen, space_free, percentage;
d531 2
a532 20

	space_free = ((LYcols - 1)
		      - (strlen(prompt)
			 - 10)		/* %s and %.*s and %.*s chars */
		      - strlen(server));
	if (space_free < 0)
	    space_free = 0;
	namelen = strlen(name);
	valuelen = strlen(value);
	if ((namelen + valuelen) > space_free) {
	    /*
	    **  Argh... there isn't enough space on our single line for
	    **  the whole cookie.  Reduce them both by a percentage.
	    **  This should be smarter.
	    */
	    percentage = (100 * space_free) / (namelen + valuelen);
	    namelen = (percentage * namelen) / 100;
	    valuelen = (percentage * valuelen) / 100;
	}
	HTSprintf(&message, prompt, server, namelen, name, valuelen, value);
d536 4
a539 2
    for (;;) {
	if(LYAcceptAllCookies) {
a540 44
	} else {
	    ch = LYgetch_single();
#if defined(LOCALE) && defined(HAVE_GETTEXT) && !defined(gettext)
	    /*
	     * Special-purpose workaround for gettext support (we should do
	     * this in a more general way -- after 2.8.3).
	     *
	     * NOTE TO TRANSLATORS:  If the prompt has been rendered into
	     * another language, and if yes/no are distinct, assume the
	     * translator can make an ordered list in parentheses with one
	     * capital letter for each as we assumed in HTConfirmDefault().
	     * The list has to be in the same order as in the original message,
	     * and the four capital letters chosen to not match those in the
	     * original unless they have the same position.
	     *
	     * Example:
	     *	(Y/N/Always/neVer)		- English (original)
	     *	(O/N/Toujours/Jamais)		- French
	     */
	    {
#define L_PAREN '('
#define R_PAREN ')'
		char *p;
		char *s = "YNAV\007\003"; /* see ADVANCED_COOKIE_CONFIRMATION */

		if (strchr(s, ch) == 0
		 && isalpha(ch)
		 && (p = strrchr(prompt, L_PAREN)) != 0) {

		    CTRACE((tfp, "Looking for %c in %s\n", ch, p));
		    while (*p != R_PAREN && *p != 0 && isalpha(UCH(*s))) {
			if (isalpha(UCH(*p)) && (*p == TOUPPER(*p))) {
			    CTRACE((tfp, "...testing %c/%c\n", *p, *s));
			    if (*p == ch) {
				ch = *s;
				break;
			    }
			    ++s;
			}
			++p;
		    }
		}
	    }
#endif
d548 1
a548 1
	switch(ch) {
d558 2
a562 1
	      reject:
a581 2
		if (LYCharIsINTERRUPT(ch))
		    goto reject;
d640 1
a640 1
	LYmove(LYlines-2, 0);
d642 3
a644 3
	LYaddstr(StatusInfo);
	LYclrtoeol();
	LYmove(LYlines-1, 0);
d647 2
a648 2
	LYaddstr(url);
	LYclrtoeol();
d674 2
a675 2
	c = LYgetch_single();
	switch (c) {
a732 51

#define okToSleep() (!crawl && !traversal && LYCursesON)

/*
 * Sleep for the given message class's time.
 */
PUBLIC void LYSleepAlert NOARGS
{
    if (okToSleep())
	LYSleep(AlertSecs);
}

PUBLIC void LYSleepDebug NOARGS
{
    if (okToSleep())
	LYSleep(DebugSecs);
}

PUBLIC void LYSleepInfo NOARGS
{
    if (okToSleep())
	LYSleep(InfoSecs);
}

PUBLIC void LYSleepMsg NOARGS
{
    if (okToSleep())
	LYSleep(MessageSecs);
}

#ifdef EXP_CMD_LOGGING
PUBLIC void LYSleepReplay NOARGS
{
    if (okToSleep())
	LYSleep(ReplaySecs);
}
#endif /* EXP_CMD_LOGGING */

/*
 *  LYstrerror emulates the ANSI strerror() function.
 */
#ifdef LYStrerror
    /* defined as macro in .h file. */
#else
PUBLIC char *LYStrerror ARGS1(int, code)
{
    static char temp[80];
    sprintf(temp, "System errno is %d.\r\n", code);
    return temp;
}
#endif /* HAVE_STRERROR */
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@d207 2
a208 1
    double now;
d210 1
a210 2
    gettimeofday(&tv, (struct timezone *)0);
    now = tv.tv_sec + tv.tv_usec/1000000. ;
@


1.1.3.3
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d175 1
a175 1
#ifdef USE_READPROGRESS
d189 1
a189 1
#endif /* USE_READPROGRESS */
d284 1
a284 1
#ifdef USE_READPROGRESS
@


1.1.3.4
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@d143 4
a146 2
PUBLIC CONST char *HTProgressUnits ARGS1(
	int,		rate)
d148 4
a151 2
    static CONST char *bunits = 0;
    static CONST char *kbunits = 0;
d155 1
a155 1
	kbunits = gettext(LYTransferName);
a156 14
    return ((rate == rateKB)
#ifdef USE_READPROGRESS
    	    || (rate == rateEtaKB)
#endif
	    ) ? kbunits : bunits;
}

PRIVATE CONST char *sprint_bytes ARGS3(
	char *,		s,
	long,		n,
	CONST char *, 	was_units)
{
    static long kb_units = 1024;
    CONST char *u = HTProgressUnits(LYTransferRate);
d158 1
d167 1
d203 1
a203 1
    CONST char *was_units;
@


1.1.3.5
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d46 2
a47 2
void HTAlert (
	const char *	Msg)
d57 3
a59 3
void HTAlwaysAlert (
	const char *	extra_prefix,
	const char *	Msg)
d86 2
a87 2
void HTInfoMsg (
	const char *	Msg)
d100 2
a101 2
void HTUserMsg (
	const char *	Msg)
d117 3
a119 3
void HTUserMsg2 (
	const char *	Msg2,
	const char *	Arg)
d134 2
a135 2
void HTProgress (
	const char *	Msg)
d143 2
a144 2
const char *HTProgressUnits (
	int		rate)
d146 2
a147 2
    static const char *bunits = 0;
    static const char *kbunits = 0;
d160 4
a163 4
static const char *sprint_bytes (
	char *		s,
	long		n,
	const char * 	was_units)
d166 1
a166 1
    const char *u = HTProgressUnits(LYTransferRate);
d168 7
a174 10
    if (LYTransferRate == rateKB || LYTransferRate == rateEtaKB_maybe) {
	if (n >= 10 * kb_units) {
	    sprintf(s, "%ld", n/kb_units);
	} else if (n > 999) {	/* Avoid switching between 1016b/s and 1K/s */
	    sprintf(s, "%.2g", ((double)n)/kb_units);
	} else {
	    sprintf(s, "%ld", n);
	    u = HTProgressUnits(rateBYTES);
	}
    } else {
d185 3
a187 3
static char *sprint_tbuf (
	char *	       s,
	long	       t)
d202 3
a204 3
void HTReadProgress (
	long		bytes,
	long		total)
d211 1
a211 1
    const char *was_units;
d321 1
a321 1
static BOOL conf_cancelled = NO; /* used by HTConfirm only - kw */
d323 1
a323 1
BOOL HTLastConfirmCancelled (void)
d337 4
a340 4
int HTForcedPrompt (
	int		option,
	const char *	msg,
	int		dft)
d370 1
a370 1
int HTConfirmDefault (const char * Msg, int Dft)
d471 1
a471 1
BOOL HTConfirm (const char * Msg)
d487 5
a491 5
BOOL confirm_post_resub (
    const char*	address,
    const char*	title,
    int		if_imgmap,
    int		if_file)
d494 1
a494 1
    const char *msg = CONFIRM_POST_RESUBMISSION_TO;
d561 3
a563 3
char * HTPrompt (
	const char *	Msg,
	const char *	deflt)
d587 2
a588 2
char * HTPromptPassword (
	const char *	Msg)
d629 5
a633 5
void HTPromptUsernameAndPassword (
	const char *	Msg,
	char **	username,
	char **	password,
	BOOL		IsProxy)
d771 5
a775 5
BOOL HTConfirmCookie (
	domain_entry * de,
	const char *	server,
	const char *	name,
	const char *	value)
d941 3
a943 3
int HTConfirmPostRedirect (
	const char *	Redirecting_url,
	int		server_status)
d1081 1
a1081 1
void LYSleepAlert (void)
d1087 1
a1087 1
void LYSleepDebug (void)
d1093 1
a1093 1
void LYSleepInfo (void)
d1099 1
a1099 1
void LYSleepMsg (void)
d1106 1
a1106 1
void LYSleepReplay (void)
d1119 1
a1119 1
char *LYStrerror (int code)
@


1.1.3.6
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 9
a10 9
 *	==========================================================
 *
 *	REPLACE THIS MODULE with a GUI version in a GUI environment!
 *
 * History:
 *	   Jun 92 Created May 1992 By C.T. Barker
 *	   Feb 93 Simplified, portablised TBL
 *
 */
d21 1
a21 1
#include <LYHistory.h>		/* store statusline messages */
d27 1
a27 1
#undef timezone			/* U/Win defines this in time.h, hides implementation detail */
d44 4
a47 3
 *	--------------------------------
 */
void HTAlert(const char *Msg)
d57 3
a59 2
void HTAlwaysAlert(const char *extra_prefix,
		   const char *Msg)
d84 4
a87 3
 *	--------------------------------
 */
void HTInfoMsg(const char *Msg)
d98 4
a101 3
 *	--------------------------------
 */
void HTUserMsg(const char *Msg)
d117 3
a119 1
void HTUserMsg2(const char *Msg2, const char *Arg)
d132 4
a135 3
 *	-------------------------
 */
void HTProgress(const char *Msg)
d143 2
a144 1
const char *HTProgressUnits(int rate)
d155 1
a155 1
	    || (rate == rateEtaKB)
d157 1
a157 1
	)? kbunits : bunits;
d160 4
a163 1
static const char *sprint_bytes(char *s, long n, const char *was_units)
d170 1
a170 1
	    sprintf(s, "%ld", n / kb_units);
d172 1
a172 1
	    sprintf(s, "%.2g", ((double) n) / kb_units);
d188 3
a190 1
static char *sprint_tbuf(char *s, long t)
d193 1
a193 1
	sprintf(s, "%ldh%ldm%lds", t / 3600, (t / 60) % 60, t % 60);
d195 1
a195 1
	sprintf(s, "%ldm%lds", t / 60, t % 60);
d197 1
a197 1
	sprintf(s, "%ld sec", t);
d203 5
a207 3
 *	------------------------------
 */
void HTReadProgress(long bytes, long total)
d220 2
a221 3

    gettimeofday(&tv, (struct timezone *) 0);
    now = tv.tv_sec + tv.tv_usec / 1000000.;
d228 1
a228 1
    now = tb.time + (double) tb.millitm / 1000;
d230 1
a230 1
    time_t now = time((time_t *) 0);	/* once per second */
d246 4
a249 4
	(now != first))
	/* 1 sec delay for transfer_rate calculation without g-t-o-d */  {
	if (transfer_rate <= 0)	/* the very first time */
	    transfer_rate = (long) ((bytes) / (now - first));	/* bytes/sec */
d275 1
a275 1
		transfer_rate = (long) (bytes / (now - first));		/* more accurate value */
d285 1
a285 1
		HTSprintf0(&line, gettext("Read %s of %s of data"), bytesp, totalp);
d287 1
a287 1
		HTSprintf0(&line, gettext("Read %s of data"), bytesp);
d290 1
a290 1
		&& transfer_rate > 0) {
d292 1
a292 1
		HTSprintf(&line, gettext(", %s/sec"), transferp);
d294 1
d297 1
a297 1
		|| LYTransferRate == rateEtaKB) {
a298 1

d300 3
a302 3
		    HTSprintf(&line,
			      gettext(" (stalled for %s)"),
			      sprint_tbuf(tbuf, (long) (now - last_active)));
d304 3
a306 3
		    HTSprintf(&line,
			      gettext(", ETA %s"),
			      sprint_tbuf(tbuf, (long) ((total - bytes) / transfer_rate)));
d310 1
a310 1
	    StrAllocCat(line, ".");
d318 1
a318 1
	}
d324 1
a324 1
static BOOL conf_cancelled = NO;	/* used by HTConfirm only - kw */
d326 1
a326 1
BOOL HTLastConfirmCancelled(void)
d330 1
a330 1
	return (YES);
d332 1
a332 1
	return (NO);
d340 4
a343 1
int HTForcedPrompt(int option, const char *msg, int dft)
d371 3
a373 3
 *	--------------------------------------
 */
int HTConfirmDefault(const char *Msg, int Dft)
d380 20
a399 20
/* NOTE TO TRANSLATORS:  If you provide a translation for "yes", lynx
 * will take the first byte of the translation as a positive response
 * to Yes/No questions.  If you provide a translation for "no", lynx
 * will take the first byte of the translation as a negative response
 * to Yes/No questions.  For both, lynx will also try to show the
 * first byte in the prompt as a character, instead of (y) or (n),
 * respectively.  This will not work right for multibyte charsets!
 * Don't translate "yes" and "no" for CJK character sets (or translate
 * them to "yes" and "no").  For a translation using UTF-8, don't
 * translate if the translation would begin with anything but a 7-bit
 * (US_ASCII) character.  That also means do not translate if the
 * translation would begin with anything but a 7-bit character, if
 * you use a single-byte character encoding (a charset like ISO-8859-n)
 * but anticipate that the message catalog may be used re-encoded in
 * UTF-8 form.
 * For translations using other character sets, you may also wish to
 * leave "yes" and "no" untranslated, if using (y) and (n) is the
 * preferred behavior.
 * Lynx will also accept y Y n N as responses unless there is a conflict
 * with the first letter of the "yes" or "no" translation.
d402 1
a402 1
    char *msg_no = gettext("no");
d412 1
a412 1
    if (dump_output_immediately) {	/* Non-interactive, can't respond */
a441 1

d456 1
a456 1
	    } else if (LYCharIsINTERRUPT(c)) {	/* remember we had ^G or ^C */
d465 2
a466 2
		(result != NO) ? "YES" : "NO",
		conf_cancelled ? ", cancelled" : ""));
d472 3
a474 3
 *	------------------
 */
BOOL HTConfirm(const char *Msg)
d480 8
a487 8
 * Ask a post resubmission prompt with some indication of what would
 * be resubmitted, useful especially for going backward in history.
 * Try to use parts of the address or, if given, the title, depending
 * on how much fits on the statusline.
 * if_imgmap and if_file indicate how to handle an address that is
 * a "LYNXIMGMAP:", or a "file:" URL (presumably the List Page file),
 * respectively:  0:  auto-deny, 1:  auto-confirm, 2:  prompt.
 * - kw
d490 5
a494 4
BOOL confirm_post_resub(const char *address,
			const char *title,
			int if_imgmap,
			int if_file)
a501 1

d503 1
a503 1
	return (NO);
d506 1
a506 1
	    return (NO);
d508 1
a508 1
	    return (YES);
d513 1
a513 1
	    return (NO);
d515 1
a515 1
	    return (YES);
d519 1
a519 1
	return (NO);
d529 2
a530 2
				     PARSE_ACCESS + PARSE_HOST + PARSE_PATH
				     + PARSE_PUNCTUATION)) <= maxlen) {
d534 1
a534 1
	return (res);
d542 2
a543 2
				     PARSE_ACCESS + PARSE_HOST
				     + PARSE_PUNCTUATION)) <= maxlen) {
d547 1
a547 1
	return (res);
d555 1
a555 1
	return (res);
d562 5
a566 3
 *	------------------------------------
 */
char *HTPrompt(const char *Msg, const char *deflt)
d568 1
a568 1
    char *rep = NULL;
d572 1
a572 1
    Tmp[sizeof(Tmp) - 1] = '\0';
d576 1
a576 1
	strncpy(Tmp, deflt, sizeof(Tmp) - 1);
d587 5
a591 4
 *	Prompt for password without echoing the reply.	HTPromptPassword()
 *	----------------------------------------------
 */
char *HTPromptPassword(const char *Msg)
d600 1
a600 1
	LYgetstr(pw, HIDDEN, sizeof(pw), NORECALL);	/* hidden */
d610 27
a636 26
 *	----------------------------------
 *
 *  On entry,
 *	Msg		is the prompting message.
 *	*username and
 *	*password	are char pointers which contain default
 *			or zero-length strings; they are changed
 *			to point to result strings.
 *	IsProxy 	should be TRUE if this is for
 *			proxy authentication.
 *
 *			If *username is not NULL, it is taken
 *			to point to a default value.
 *			Initial value of *password is
 *			completely discarded.
 *
 *  On exit,
 *	*username and *password point to newly allocated
 *	strings -- original strings pointed to by them
 *	are NOT freed.
 *
 */
void HTPromptUsernameAndPassword(const char *Msg,
				 char **username,
				 char **password,
				 BOOL IsProxy)
d643 4
a646 4
	 * The -auth or -pauth parameter gave us both the username
	 * and password to use for the first realm or proxy server,
	 * respectively, so just use them without any prompting.  - FM
	 */
d648 1
a648 1
				 proxyauth_info[0] : authentication_info[0]));
d655 1
a655 1
				 proxyauth_info[1] : authentication_info[1]));
d663 3
a665 3
	 * We are not interactive and don't have both the
	 * username and password from the command line,
	 * but might have one or the other.  - FM
d670 2
a671 2
	     * Use the command line username.  - FM
	     */
d673 1
a673 1
				     proxyauth_info[0] : authentication_info[0]));
d681 2
a682 2
	     * Default to "WWWuser".  - FM
	     */
d688 2
a689 2
	     * Use the command line password.  - FM
	     */
d691 1
a691 1
				     proxyauth_info[1] : authentication_info[1]));
d699 2
a700 2
	     * Default to a zero-length string.  - FM
	     */
d707 3
a709 3
	 * We are interactive and don't have both the
	 * username and password from the command line,
	 * but might have one or the other.  - FM
d714 3
a716 3
	     * Offer the command line username in the
	     * prompt for the first realm.  - FM
	     */
d718 1
a718 1
				     proxyauth_info[0] : authentication_info[0]));
d726 1
a726 1
	 * Prompt for confirmation or entry of the username.  - FM
d736 2
a737 2
	     * Use the command line password for the first realm.  - FM
	     */
d739 1
a739 1
				     proxyauth_info[1] : authentication_info[1]));
d747 3
a749 3
	     * We have a non-zero length username,
	     * so prompt for the password.  - FM
	     */
d753 2
a754 2
	     * Return a zero-length password.  - FM
	     */
d761 18
a778 16
 *	---------------------------
 *
 *  On entry,
 *	server			is the server sending the Set-Cookie.
 *	domain			is the domain of the cookie.
 *	path			is the path of the cookie.
 *	name			is the name of the cookie.
 *	value			is the value of the cookie.
 *
 *  On exit,
 *	Returns FALSE on cancel,
 *		TRUE if the cookie should be set.
 */
BOOL HTConfirmCookie(domain_entry * de, const char *server,
		     const char *name,
		     const char *value)
d786 5
a790 5
    /* If the user has specified a list of domains to allow or deny
     * from the config file, then they'll already have de->bv set to
     * ACCEPT_ALWAYS or REJECT_ALWAYS so we can relax and let the
     * default cookie handling code cope with this fine.
     */
d793 2
a794 2
     * If the user has specified a constant action, don't prompt at all.
     */
d802 4
a805 4
	 * Non-interactive, can't respond.  Use the LYSetCookies value
	 * based on its compilation or configuration setting, or on the
	 * command line toggle.  - FM
	 */
d810 3
a812 3
     * Estimate how much of the cookie we can show.
     */
    if (!LYAcceptAllCookies) {
d818 2
a819 2
			 - 10)	/* %s and %.*s and %.*s chars */
		      -strlen(server));
d826 4
a829 4
	     * Argh...  there isn't enough space on our single line for
	     * the whole cookie.  Reduce them both by a percentage.
	     * This should be smarter.
	     */
d839 1
a839 1
	if (LYAcceptAllCookies) {
d857 2
a858 2
	     * (Y/N/Always/neVer)              - English (original)
	     * (O/N/Toujours/Jamais)           - French
d864 1
a864 1
		char *s = "YNAV\007\003";	/* see ADVANCED_COOKIE_CONFIRMATION */
d867 2
a868 2
		    && isalpha(ch)
		    && (p = strrchr(prompt, L_PAREN)) != 0) {
d892 8
a899 8
	switch (ch) {
	case 'A':
	    /*
	     * Set to accept all cookies for this domain.
	     */
	    de->bv = ACCEPT_ALWAYS;
	    HTUserMsg2(ALWAYS_ALLOWING_COOKIES, de->domain);
	    return TRUE;
d901 7
a907 7
	case 'N':
	    /*
	     * Reject the cookie.
	     */
	  reject:
	    HTUserMsg(REJECTING_COOKIE);
	    return FALSE;
d909 7
a915 7
	case 'V':
	    /*
	     * Set to reject all cookies from this domain.
	     */
	    de->bv = REJECT_ALWAYS;
	    HTUserMsg2(NEVER_ALLOWING_COOKIES, de->domain);
	    return FALSE;
d917 11
a927 11
	case 'Y':
	    /*
	     * Accept the cookie.
	     */
	    HTInfoMsg(ALLOWING_COOKIE);
	    return TRUE;

	default:
	    if (LYCharIsINTERRUPT(ch))
		goto reject;
	    continue;
d933 14
a946 12
 *	----------------------------
 *
 *  On entry,
 *	Redirecting_url 	    is the Location.
 *	server_status		    is the server status code.
 *
 *  On exit,
 *	Returns 0 on cancel,
 *	  1 for redirect of POST with content,
 *	303 for redirect as GET without content
 */
int HTConfirmPostRedirect(const char *Redirecting_url, int server_status)
d952 3
a954 4
    int on_screen = 0;		/* 0 - show menu

				 * 1 - show url
				 * 2 - menu is already on screen */
d959 3
a961 3
	 * HTTP.c should not have called us for either of
	 * these because we're treating 302 as historical,
	 * so just return 303.  - FM
d969 3
a971 3
	     * Treat 301 as historical, i.e., like 303 (GET
	     * without content), when not interactive.  - FM
	     */
d975 4
a978 4
	     * Treat anything else (e.g., 305, 306 or 307) as too
	     * dangerous to redirect without confirmation, and thus
	     * cancel when not interactive.  - FM
	     */
d985 1
a985 1
	LYmove(LYlines - 2, 0);
d989 1
a989 1
	LYmove(LYlines - 1, 0);
d991 1
a991 1
		   (LYcols < 250 ? LYcols - 6 : 250), Redirecting_url);
d1001 5
a1005 5
		   server_status,
		   251,
		   ((server_status == 301) ?
		    ADVANCED_POST_GET_REDIRECT :
		    ADVANCED_POST_REDIRECT));
d1013 5
a1017 5
	case 0:
	    _statusline(StatusInfo);
	    break;
	case 1:
	    _statusline(show_POST_url);
d1021 30
a1050 8
	case 'P':
	    /*
	     * Proceed with 301 or 307 redirect of POST
	     * with same method and POST content.  - FM
	     */
	    FREE(show_POST_url);
	    result = 1;
	    break;
d1052 10
a1061 8
	case 7:
	case 'C':
	    /*
	     * Cancel request.
	     */
	    FREE(show_POST_url);
	    result = 0;
	    break;
d1063 4
a1066 5
	case 'U':
	    /*
	     * Show URL for intermediate or advanced mode.
	     */
	    if (user_mode != NOVICE_MODE) {
d1070 1
a1070 1
		    on_screen = 1;
a1071 23
	    }
	    break;

	case 'G':
	    if (server_status == 301) {
		/*
		 * Treat as 303 (GET without content).
		 */
		FREE(show_POST_url);
		result = 303;
		break;
	    }
	    /* fall through to default */

	default:
	    /*
	     * Get another character.
	     */
	    if (on_screen == 1) {
		on_screen = 0;
	    } else {
		on_screen = 2;
	    }
d1084 1
a1084 1
void LYSleepAlert(void)
d1090 1
a1090 1
void LYSleepDebug(void)
d1096 1
a1096 1
void LYSleepInfo(void)
d1102 1
a1102 1
void LYSleepMsg(void)
d1109 1
a1109 1
void LYSleepReplay(void)
d1117 1
a1117 1
 * LYstrerror emulates the ANSI strerror() function.
d1119 4
a1122 2
#ifndef LYStrerror
char *LYStrerror(int code)
a1124 1

@


1.1.3.7
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d484 1
a484 1
    size_t maxlen = LYcolLimit - 5;
d794 1
a794 1
	space_free = (LYcolLimit
d821 17
a837 1
#if defined(LOCALE) && defined(HAVE_GETTEXT)
d841 1
a841 17
		/*
		 * Special-purpose workaround for gettext support (we should do
		 * this in a more general way) -TD
		 *
		 * NOTE TO TRANSLATORS:  If the prompt has been rendered into
		 * another language, and if yes/no are distinct, assume the
		 * translator can make an ordered list in parentheses with one
		 * capital letter for each as we assumed in HTConfirmDefault().
		 * The list has to be in the same order as in the original message,
		 * and the four capital letters chosen to not match those in the
		 * original unless they have the same position.
		 *
		 * Example:
		 * (Y/N/Always/neVer)              - English (original)
		 * (O/N/Toujours/Jamais)           - French
		 */
		char *p = gettext("Y/N/A/V");	/* placeholder for comment */
d968 1
a968 1
		   (LYcols < 250 ? LYcolLimit - 5 : 250), Redirecting_url);
@


1.1.3.8
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d87 1
a87 1
    if (non_empty(Msg)) {
d100 1
a100 1
    if (non_empty(Msg)) {
d116 1
a116 1
    if (non_empty(Msg2)) {
d725 1
a725 1
	} else if (non_empty(*username)) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a24 18
#include <HTParse.h>

#undef timezone	/* U/Win defines this in time.h, hides implementation detail */

#if defined(HAVE_FTIME) && defined(HAVE_SYS_TIMEB_H)
#include <sys/timeb.h>
#endif

/*
 * 'napms()' is preferable to 'sleep()' in any case because it does not
 * interfere with output, but also because it can be less than a second.
 */
#ifdef HAVE_NAPMS
#define LYSleep(n) napms(n)
#else
#define LYSleep(n) sleep(n)
#endif

d31 1
a31 1
    CTRACE((tfp, "\nAlert!: %s\n\n", Msg));
d36 1
a36 1
    LYSleepAlert();
d51 1
a51 2
	    LYstore_message2(ALERT_FORMAT, Msg);
	    LYSleepAlert();
d57 1
a57 2
	    LYstore_message2(ALERT_FORMAT, Msg);
	    LYSleepAlert();
d60 1
a60 1
	CTRACE((tfp, "\nAlert!: %s\n\n", Msg));
d73 1
a73 1
	CTRACE((tfp, "Info message: %s\n", Msg));
d75 1
a75 1
	LYSleep(InfoSecs);
d87 1
a87 1
	CTRACE((tfp, "User message: %s\n", Msg));
d89 1
a89 1
	LYSleepMsg();
d99 3
a101 3
	CTRACE((tfp, "User message: "));
	CTRACE((tfp, Msg2, Arg));
	CTRACE((tfp, "\n"));
d103 1
a103 1
	LYSleepMsg();
d115 1
a115 39
    CTRACE((tfp, "%s\n", Msg));
#if defined(SH_EX) && defined(WIN_EX)	/* 1997/10/11 (Sat) 12:51:02 */
    {
	if (debug_delay != 0)
	    Sleep(debug_delay);	/* XXX msec */
    }
#endif
}

PRIVATE char *sprint_bytes ARGS3(
	char *,		s,
	long,		n,
	char *, 	was_units)
{
    static long kb_units = 1024;
    static char *bunits;
    static char *kbunits;
    char *u;

    if (!bunits) {
	bunits = gettext("bytes");
	kbunits = gettext("KB");
    }

    u = kbunits;
    if ( (LYTransferRate == rateKB || LYTransferRate == rateEtaKB_maybe)
	 && (n >= 10 * kb_units) )
	sprintf(s, "%ld", n/kb_units);
    else if ((LYTransferRate == rateKB || LYTransferRate == rateEtaKB_maybe)
	     && (n > 999))	/* Avoid switching between 1016b/s and 1K/s */
	sprintf(s, "%.2g", ((double)n)/kb_units);
    else {
	sprintf(s, "%ld", n);
	u = bunits;
    }

    if (!was_units || was_units != u)
	sprintf(s + strlen(s), " %s", u);
    return u;
d125 3
a127 1
    static long bytes_last, total_last;
d129 2
a130 19
    static char *line = NULL;
    char bytesp[80], totalp[80], transferp[80];
    int renew = 0;
    char *was_units;

#ifdef HAVE_GETTIMEOFDAY
    struct timeval tv;
    double now;
    static double first, last, last_active;
    gettimeofday(&tv, (struct timezone *)0);
    now = tv.tv_sec + tv.tv_usec/1000000. ;
#else
#if defined(HAVE_FTIME) && defined(HAVE_SYS_TIMEB_H)
    static double now, first, last, last_active;
    struct timeb tb;

    ftime(&tb);
    now = tb.time + (double)tb.millitm / 1000;
#else
d132 1
a132 6
    static time_t first, last, last_active;
#endif
#endif

    if (!LYShowTransferRate)
	LYTransferRate = rateOFF;
d135 1
a135 1
	first = last = last_active = now;
d137 1
a137 5
    } else if (bytes < 0) {	/* stalled */
	bytes = bytes_last;
	total = total_last;
    }
    if ((bytes > 0) &&
d139 1
a139 1
		/* 1 sec delay for transfer_rate calculation without g-t-o-d */ {
d141 1
a141 2
	    transfer_rate = (long)((bytes) / (now - first));   /* bytes/sec */
	total_last = total;
a147 4
#ifdef HAVE_GETTIMEOFDAY
	if (now >= last + 0.2)
	    renew = 1;
#else
d149 1
a149 1
	    renew = 1;
d151 1
a151 3
	}
#endif
	if (renew) {
a153 2
		if (bytes_last != bytes)
		    last_active = now;
d155 1
a155 1
		transfer_rate = (long)(bytes / (now - first)); /* more accurate here */
d158 12
a169 2
	    if (total > 0)
		was_units = sprint_bytes(totalp, total, 0);
d171 4
a174 5
		was_units = 0;
	    sprint_bytes(bytesp, bytes, was_units);

	    if (total > 0)
		HTSprintf0 (&line, gettext("Read %s of %s of data"), bytesp, totalp);
d176 4
a179 6
		HTSprintf0 (&line, gettext("Read %s of data"), bytesp);

	    if (LYTransferRate != rateOFF
	     && transfer_rate > 0) {
		sprint_bytes(transferp, transfer_rate, 0);
		HTSprintf (&line, gettext(", %s/sec"), transferp);
a181 14
#ifdef EXP_READPROGRESS
	    if (LYTransferRate == rateEtaBYTES
	     || LYTransferRate == rateEtaKB) {
		if (now - last_active >= 5)
		    HTSprintf (&line, gettext(" (stalled for %ld sec)"), (long)(now - last_active));
		if (total > 0 && transfer_rate)
		    HTSprintf (&line, gettext(", ETA %ld sec"), (long)((total - bytes)/transfer_rate));
	    }
#endif

	    StrAllocCat (line, ".");
	    if (total < -1)
		StrAllocCat(line, gettext(" (Press 'z' to abort)"));

d184 1
a184 1
	    CTRACE((tfp, "%s\n", line));
a186 3
#ifdef LY_FIND_LEAKS
    FREE(line);
#endif
d203 2
a204 2
/*	Seek confirmation with default answer.		HTConfirmDefault()
**	--------------------------------------
d206 1
a206 1
PUBLIC int HTConfirmDefault ARGS2(CONST char *, Msg, int, Dft)
a207 26
/* Meta-note: don't move the following note from its place right
   in front of the first gettext().  As it is now, it should
   automatically appear in generated lynx.pot files. - kw
 */

/*  NOTE TO TRANSLATORS:  If you provide a translation for "yes", lynx
 *  will take the first byte of the translation as a positive response
 *  to Yes/No questions.  If you provide a translation for "no", lynx
 *  will take the first byte of the translation as a negative response
 *  to Yes/No questions.  For both, lynx will also try to show the
 *  first byte in the prompt as a character, instead of (y) or (n),
 *  respectively.  This will not work right for multibyte charsets!
 *  Don't translate "yes" and "no" for CJK character sets (or translate
 *  them to "yes" and "no").  For a translation using UTF-8, don't
 *  translate if the translation would begin with anything but a 7-bit
 *  (US_ASCII) character.  That also means do not translate if the
 *  translation would begin with anything but a 7-bit character, if
 *  you use a single-byte character encoding (a charset like ISO-8859-n)
 *  but anticipate that the message catalog may be used re-encoded in
 *  UTF-8 form.
 *  For translations using other character sets, you may also wish to
 *  leave "yes" and "no" untranslated, if using (y) and (n) is the
 *  preferred behavior.
 *  Lynx will also accept y Y n N as responses unless there is a conflict
 *  with the first letter of the "yes" or "no" translation.
 */
a211 6
    /* If they're not really distinct in the first letter, revert to English */
    if (TOUPPER(*msg_yes) == TOUPPER(*msg_no)) {
	msg_yes = "yes";
	msg_no = "no";
    }

a213 6
	if (Dft == DFT_CONFIRM) {
	    CTRACE((tfp, "Confirm: %s (%c/%c) ", Msg, *msg_yes, *msg_no));
	} else {
	    CTRACE((tfp, "Confirm: %s (%c) ", Msg, (Dft == YES) ? *msg_yes : *msg_no));
	}
	CTRACE((tfp, "- NO, not interactive.\n"));
a216 7
	char fallback_y = 'y';	/* English letter response as fallback */
	char fallback_n = 'n';	/* English letter response as fallback */

	if (fallback_y == *msg_yes || fallback_y == *msg_no)
	    fallback_y = '\0';	/* conflict or duplication, don't use */
	if (fallback_n == *msg_yes || fallback_n == *msg_no)
	    fallback_n = '\0';	/* conflict or duplication, don't use */
a221 3
	if (LYTraceLogFP) {
	    CTRACE((tfp, "Confirm: %s", msg));
	}
d226 1
a226 1
	    int c = LYgetch_single();
d230 1
a230 1
		c = TOUPPER(*msg_no);
d233 2
a234 3
	    if (c == TOUPPER(*msg_yes)) {
		result = YES;
	    } else if (c == TOUPPER(*msg_no)) {
d236 1
a236 1
	    } else if (fallback_y && c == fallback_y) {
d238 2
a239 5
	    } else if (fallback_n && c == fallback_n) {
		result = NO;
	    } else if (LYCharIsINTERRUPT(c)) { /* remember we had ^G or ^C */
		conf_cancelled = YES;
		result = NO;
d241 1
a241 2
		result = Dft;
		break;
a243 3
	CTRACE((tfp, "- %s%s.\n",
	       (result != NO) ? "YES" : "NO",
	       conf_cancelled ? ", cancelled" : ""));
a247 3
/*	Seek confirmation.				HTConfirm()
**	------------------
*/
d250 1
a250 83
    return (BOOL) HTConfirmDefault(Msg, DFT_CONFIRM);
}

/*
 *  Ask a post resubmission prompt with some indication of what would
 *  be resubmitted, useful especially for going backward in history.
 *  Try to use parts of the address or, if given, the title, depending
 *  on how much fits on the statusline.
 *  if_imgmap and if_file indicate how to handle an address that is
 *  a "LYNXIMGMAP:", or a "file:" URL (presumably the List Page file),
 *  respectively: 0: auto-deny, 1: auto-confirm, 2: prompt.
 *  - kw
 */

PUBLIC BOOL confirm_post_resub ARGS4(
    CONST char*,	address,
    CONST char*,	title,
    int,		if_imgmap,
    int,		if_file)
{
    size_t len1;
    CONST char *msg = CONFIRM_POST_RESUBMISSION_TO;
    char buf[240];
    char *temp = NULL;
    BOOL res;
    size_t maxlen = LYcols - 6;
    if (!address) {
	return(NO);
    } else if (!strncmp(address, "LYNXIMGMAP:", 11)) {
	if (if_imgmap <= 0)
	    return(NO);
	else if (if_imgmap == 1)
	    return(YES);
	else
	    msg = CONFIRM_POST_LIST_RELOAD;
    } else if (!strncmp(address, "file:", 5)) {
	if (if_file <= 0)
	    return(NO);
	else if (if_file == 1)
	    return(YES);
	else
	    msg = CONFIRM_POST_LIST_RELOAD;
    } else if (dump_output_immediately) {
	return(NO);
    }
    if (maxlen >= sizeof(buf))
	maxlen = sizeof(buf) - 1;
    if ((len1 = strlen(msg)) +
	strlen(address) <= maxlen) {
	sprintf(buf, msg, address);
	return HTConfirm(buf);
    }
    if (len1 + strlen(temp = HTParse(address, "",
				     PARSE_ACCESS+PARSE_HOST+PARSE_PATH
				     +PARSE_PUNCTUATION)) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return(res);
    }
    FREE(temp);
    if (title && (len1 + strlen(title) <= maxlen)) {
	sprintf(buf, msg, title);
	return HTConfirm(buf);
    }
    if (len1 + strlen(temp = HTParse(address, "",
				     PARSE_ACCESS+PARSE_HOST
				     +PARSE_PUNCTUATION)) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return(res);
    }
    FREE(temp);
    if ((temp = HTParse(address, "", PARSE_HOST)) && *temp &&
	len1 + strlen(temp) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return(res);
    }
    FREE(temp);
    return HTConfirm(CONFIRM_POST_RESUBMISSION);
d467 1
a467 1
	domain_entry *, de,
d472 2
a473 2
    int ch;
    char *prompt = ADVANCED_COOKIE_CONFIRMATION;
d475 1
a475 1
    if (de == NULL)
d478 1
d482 1
a482 1
    **	default cookie handling code cope with this fine.
d484 1
a484 1

d488 1
a488 1
    if (de->bv == ACCEPT_ALWAYS)
d505 24
a529 1
	int namelen, valuelen, space_free, percentage;
d531 2
a532 20

	space_free = ((LYcols - 1)
		      - (strlen(prompt)
			 - 10)		/* %s and %.*s and %.*s chars */
		      - strlen(server));
	if (space_free < 0)
	    space_free = 0;
	namelen = strlen(name);
	valuelen = strlen(value);
	if ((namelen + valuelen) > space_free) {
	    /*
	    **  Argh... there isn't enough space on our single line for
	    **  the whole cookie.  Reduce them both by a percentage.
	    **  This should be smarter.
	    */
	    percentage = (100 * space_free) / (namelen + valuelen);
	    namelen = (percentage * namelen) / 100;
	    valuelen = (percentage * valuelen) / 100;
	}
	HTSprintf(&message, prompt, server, namelen, name, valuelen, value);
d537 3
a539 1
	if(LYAcceptAllCookies) {
a540 42
	} else {
	    ch = LYgetch_single();
#if defined(LOCALE) && defined(HAVE_GETTEXT) && !defined(gettext)
	    /*
	     * Special-purpose workaround for gettext support (we should do
	     * this in a more general way -- after 2.8.3).
	     *
	     * NOTE TO TRANSLATORS:  If the prompt has been rendered into
	     * another language, and if yes/no are distinct, assume the
	     * translator can make an ordered list in parentheses with one
	     * capital letter for each as we assumed in HTConfirmDefault().
	     * The list has to be in the same order as in the original message,
	     * and the four capital letters chosen to not match those in the
	     * original unless they have the same position.
	     *
	     * Example:
	     *	(Y/N/Always/neVer)		- English (original)
	     *	(O/N/Toujours/Jamais)		- French
	     */
	    {
#define L_PAREN '('
#define R_PAREN ')'
		char *p;
		char *s = "YNAV\007\003"; /* see ADVANCED_COOKIE_CONFIRMATION */

		if (strchr(s, ch) == 0
		 && isalpha(ch)
		 && (p = strrchr(prompt, L_PAREN)) != 0) {

		    while (*p != R_PAREN && *p != 0 && isalpha(UCH(*s))) {
			if (*p == ch) {
			    ch = *s;
			    break;
			} else {
			    if (isalpha(UCH(*p)) && (*p == TOUPPER(*p)))
				s++;
			    p++;
			}
		    }
		}
	    }
#endif
d548 1
a548 1
	switch(ch) {
d558 2
a562 1
	      reject:
a581 2
		if (LYCharIsINTERRUPT(ch))
		    goto reject;
d640 1
a640 1
	LYmove(LYlines-2, 0);
d642 3
a644 3
	LYaddstr(StatusInfo);
	LYclrtoeol();
	LYmove(LYlines-1, 0);
d647 2
a648 2
	LYaddstr(url);
	LYclrtoeol();
d674 2
a675 2
	c = LYgetch_single();
	switch (c) {
a732 37

#define okToSleep() (!crawl && !traversal && LYCursesON)

/*
 * Sleep for the given message class's time.
 */
PUBLIC void LYSleepAlert NOARGS
{
    if (okToSleep())
	LYSleep(AlertSecs);
}

PUBLIC void LYSleepInfo NOARGS
{
    if (okToSleep())
	LYSleep(InfoSecs);
}

PUBLIC void LYSleepMsg NOARGS
{
    if (okToSleep())
	LYSleep(MessageSecs);
}

/*
 *  LYstrerror emulates the ANSI strerror() function.
 */
#ifdef LYStrerror
    /* defined as macro in .h file. */
#else
PUBLIC char *LYStrerror ARGS1(int, code)
{
    static char temp[80];
    sprintf(temp, "System errno is %d.\r\n", code);
    return temp;
}
#endif /* HAVE_STRERROR */
@

