head	1.8;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.7
	tg-mergefixes-1-branch:1.7.0.4
	tg-mergefixes-1-base:1.7
	MIROS_X:1.7.0.2
	MIROS_X_BASE:1.7
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2005.01.03.00.45.57;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.20.10.26.28;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.11.20.30.40;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.16.55;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.32;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.34;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.31;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.22;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.51;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.20;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.16.00;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.52.49;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.10.11.20.16.25;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.20.10.10.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@soft merge
@
text
@#include <HTUtils.h>
#include <HTTP.h>
#include <HTAnchor.h>		/* Anchor class */
#include <HTAccess.h>
#include <HTParse.h>
#include <LYCurses.h>
#include <GridText.h>
#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <LYCharSets.h>
#include <LYCharUtils.h>
#include <HTAlert.h>
#include <LYSignal.h>
#include <LYGetFile.h>
#include <LYPrint.h>
#include <LYOptions.h>
#include <LYStrings.h>
#include <LYClean.h>
#include <LYDownload.h>
#include <LYNews.h>
#include <LYMail.h>
#include <LYKeymap.h>
#include <LYBookmark.h>
#include <LYMap.h>
#include <LYList.h>
#ifdef DIRED_SUPPORT
#include <LYLocal.h>
#endif /* DIRED_SUPPORT */
#include <LYReadCFG.h>
#include <LYHistory.h>
#include <LYPrettySrc.h>

#include <LYexit.h>
#include <LYLeaks.h>

static int fix_httplike_urls(DocInfo *doc, UrlTypes type);

#ifdef VMS
#define STRNADDRCOMP strncasecomp
#else
#define STRNADDRCOMP strncmp
#endif /* !VMS */

int HTNoDataOK = 0;

/*
 * getfile is the main mechanism to load a new document (or a previously loaded
 * one whose rendering is cached in a HText structure) from mainloop, nearly
 * everything goes through it.
 * It should return one of the values
 *     NORMAL     - requested document loaded successfully, usually [always?]
 *                  its rendering is available as HTMainText.  It can be an
 *                  HTTP error message page or similar, we make no
 *                  distinction here.
 *     NOT_FOUND  - requested document cannot be accessed, and the reason
 *                  is a real error (as may be caused by an invalid link),
 *                  not just that lynx disallows access because of some
 *                  permission restrictions, and we have no error page
 *                  to show for it either.
 *     NULLFILE   - requested document not loaded into HTMainText, either
 *                  some interactive protocol was requested (like telnet),
 *                  or lynx does not allow access.
 * The distinction between NOT_FOUND and NULLFILE is not very crucial, but
 * getting it right prevents mainloop from exiting with the wrong message if it
 * happens for the first file, and from logging (or not logging) errors
 * inappropriately with -traversal, and from sending bogus error mail with
 * MAIL_SYSTEM_ERROR_LOGGING:TRUE.  - kw
 */
int getfile(DocInfo *doc, int *target)
{
    UrlTypes url_type = NOT_A_URL_TYPE;
    char *pound;
    char *cp = NULL;
    char *temp = NULL;
    DocAddress WWWDoc;		/* a WWW absolute doc address struct */

    /*
     * Reset LYCancelDownload to prevent unwanted delayed effect.  - KW
     */
    if (LYCancelDownload) {
	CTRACE((tfp, "getfile:    resetting LYCancelDownload to FALSE\n"));
	LYCancelDownload = FALSE;
    }

    /*
     * Reset fake 'Z' to prevent unwanted delayed effect.  - kw
     */
    LYFakeZap(NO);

    /*
     * Reset redirection counter to prevent bogus TOO_MANY_REDIRECTIONS in rare
     * situations if the previous cycle got to the limit, but did not fail for
     * that reason because the URL of the final location was handled specially,
     * not via HTLoadAbsolute.  - kw
     */
    redirection_attempts = 0;

  Try_Redirected_URL:
    /*
     * Load the WWWDoc struct in case we need to use it.
     */
    WWWDoc.address = doc->address;
    WWWDoc.post_data = doc->post_data;
    WWWDoc.post_content_type = doc->post_content_type;
    WWWDoc.bookmark = doc->bookmark;
    WWWDoc.isHEAD = doc->isHEAD;
    WWWDoc.safe = doc->safe;

    /*
     * Reset HTPermitRedir, it has done its job if it was set.  - kw
     */
    HTPermitRedir = FALSE;

    /*
     * Reset WWW_Download_File just in case.
     */
    FREE(WWW_Download_File);

    /*
     * Reset redirect_post_content just in case.
     */
    redirect_post_content = FALSE;

    /*
     * This flag is a hack to allow us to pass on the fact that 'no data' may
     * not really be an error although HTLoadAbsolute returned NO.  There
     * should be a better way...  HT_NO_DATA should always mean 'not data but
     * not an error', and be passed on to us as that, but current usage if
     * HT_NO_DATA vs HT_NOT_LOADED has to be reviewed everywhere.  Anyway, some
     * protocol module can set it to say 'I really mean it', we have to reset
     * it here.  - kw
     */
    HTNoDataOK = 0;

    CTRACE((tfp, "getfile: getting %s\n\n", doc->address));

    /*
     * Protect against denial of service attacks via the port 19 CHARGEN
     * service, and block connections to the port 25 ESMTP service.  Also
     * reject any likely spoof attempts via wrap arounds at 65536.  - FM
     */
    if ((temp = HTParse(doc->address, "", PARSE_HOST)) != NULL &&
	strlen(temp) > 3) {
	char *cp1;

	if ((cp1 = strchr(temp, '@@')) == NULL)
	    cp1 = temp;
	if ((cp = strrchr(cp1, ':')) != NULL) {
	    long int value;

	    cp++;
	    if (sscanf(cp, "%ld", &value) == 1) {
		if (value == 19 || value == 65555) {
		    HTAlert(PORT_NINETEEN_INVALID);
		    FREE(temp);
		    return (NULLFILE);
		} else if (value == 25 || value == 65561) {
		    HTAlert(PORT_TWENTYFIVE_INVALID);
		    FREE(temp);
		    return (NULLFILE);
		} else if (value > 65535 || value < 0) {
		    char *msg = 0;

		    HTSprintf0(&msg, PORT_INVALID, (unsigned long) value);
		    HTAlert(msg);
		    FREE(msg);
		    FREE(temp);
		    return (NULLFILE);
		}
	    } else if (isdigit(UCH(*cp))) {
		HTAlert(URL_PORT_BAD);
		FREE(temp);
		return (NULLFILE);
	    }
	}
    }
    cp = NULL;
    FREE(temp);

    /*
     * Check to see if this is a universal document ID that lib WWW wants to
     * handle.
     *
     * Some special URL's we handle ourselves.  :)
     */
    if ((url_type = is_url(doc->address)) != 0) {
	if (LYValidate && !LYPermitURL) {
	    if (!(url_type == HTTP_URL_TYPE ||
		  url_type == HTTPS_URL_TYPE ||
		  url_type == LYNXHIST_URL_TYPE ||
		  url_type == LYNXKEYMAP_URL_TYPE ||
		  url_type == LYNXIMGMAP_URL_TYPE ||
		  url_type == LYNXCOOKIE_URL_TYPE ||
		  url_type == LYNXMESSAGES_URL_TYPE ||
		  (url_type == LYNXOPTIONS_URL_TYPE &&
		   WWWDoc.post_data) ||
		  0 == STRNADDRCOMP(WWWDoc.address, helpfilepath,
				    strlen(helpfilepath)) ||
		  (lynxlistfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxlistfile,
				     strlen(lynxlistfile))) ||
		  (lynxlinksfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxlinksfile,
				     strlen(lynxlinksfile))) ||
		  (lynxjumpfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
				     strlen(lynxjumpfile))))) {
		HTUserMsg(NOT_HTTP_URL_OR_ACTION);
		return (NULLFILE);
	    }
	}
	if (traversal) {
	    /*
	     * Only traverse http URLs.
	     */
	    if (url_type != HTTP_URL_TYPE &&
		url_type != LYNXIMGMAP_URL_TYPE) {
		return (NULLFILE);
	    }
	} else if (check_realm && !LYPermitURL && !LYJumpFileURL) {
	    if (!(0 == strncmp(startrealm, WWWDoc.address,
			       strlen(startrealm)) ||
		  url_type == LYNXHIST_URL_TYPE ||
		  url_type == LYNXKEYMAP_URL_TYPE ||
		  url_type == LYNXIMGMAP_URL_TYPE ||
		  url_type == LYNXCOOKIE_URL_TYPE ||
		  url_type == LYNXPRINT_URL_TYPE ||
		  url_type == LYNXOPTIONS_URL_TYPE ||
		  url_type == LYNXCFG_URL_TYPE ||
		  url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
		  url_type == LYNXMESSAGES_URL_TYPE ||
		  url_type == LYNXDOWNLOAD_URL_TYPE ||
		  url_type == MAILTO_URL_TYPE ||
		  url_type == NEWSPOST_URL_TYPE ||
		  url_type == NEWSREPLY_URL_TYPE ||
		  url_type == SNEWSPOST_URL_TYPE ||
		  url_type == SNEWSREPLY_URL_TYPE ||
		  (!LYUserSpecifiedURL &&
		   (url_type == LYNXEXEC_URL_TYPE ||
		    url_type == LYNXPROG_URL_TYPE ||
		    url_type == LYNXCGI_URL_TYPE)) ||
		  (WWWDoc.bookmark != NULL &&
		   *WWWDoc.bookmark != '\0') ||
		  0 == STRNADDRCOMP(WWWDoc.address, helpfilepath,
				    strlen(helpfilepath)) ||
		  (lynxlistfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxlistfile,
				     strlen(lynxlistfile))) ||
		  (lynxjumpfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
				     strlen(lynxjumpfile))))) {
		HTUserMsg(NOT_IN_STARTING_REALM);
		return (NULLFILE);
	    }
	}
	if (WWWDoc.post_data &&
	    url_type != HTTP_URL_TYPE &&
	    url_type != HTTPS_URL_TYPE &&
	    url_type != LYNXCGI_URL_TYPE &&
	    url_type != LYNXIMGMAP_URL_TYPE &&
	    url_type != GOPHER_URL_TYPE &&
	    url_type != CSO_URL_TYPE &&
	    url_type != PROXY_URL_TYPE &&
	    url_type != LYNXOPTIONS_URL_TYPE &&
	    !(url_type == FILE_URL_TYPE &&
	      (LYIsUIPage(WWWDoc.address, UIP_LIST_PAGE) ||
	       LYIsUIPage(WWWDoc.address, UIP_ADDRLIST_PAGE)))) {
	    CTRACE((tfp, "getfile: dropping post_data!\n"));
	    HTAlert(IGNORED_POST);
	    LYFreePostData(doc);
	    WWWDoc.post_data = NULL;
	    WWWDoc.post_content_type = NULL;
	}
#ifdef SYSLOG_REQUESTED_URLS
	LYSyslog(doc->address);
#endif
	if (url_type == UNKNOWN_URL_TYPE ||
	    url_type == AFS_URL_TYPE ||
	    url_type == PROSPERO_URL_TYPE) {
	    HTAlert(UNSUPPORTED_URL_SCHEME);
	    return (NULLFILE);

	} else if (url_type == DATA_URL_TYPE) {
	    HTAlert(UNSUPPORTED_DATA_URL);
	    return (NULLFILE);

	} else if (url_type == LYNXPRINT_URL_TYPE) {
	    return (printfile(doc));

#ifndef NO_OPTION_FORMS
	} else if (url_type == LYNXOPTIONS_URL_TYPE) {
	    /* proceed forms-based options menu */
	    return (postoptions(doc));
#endif

	} else if (url_type == LYNXCFG_URL_TYPE &&
		   !no_lynxcfg_info) {
	    /* @@@@@@ maybe we should generate a specific error message
	       if attempted but restricted. - kw */
	    /* show/change/reload lynx.cfg settings */
	    return (lynx_cfg_infopage(doc));

#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
	} else if (url_type == LYNXCOMPILE_OPTS_URL_TYPE &&
		   !no_compileopts_info) {
	    /* @@@@@@ maybe we should generate a specific error message
	       if attempted but restricted or not supported. - kw */
	    /* show compile-time settings */
	    return (lynx_compile_opts(doc));
#endif

#ifndef DISABLE_NEWS
	} else if (url_type == NEWSPOST_URL_TYPE ||
		   url_type == NEWSREPLY_URL_TYPE ||
		   url_type == SNEWSPOST_URL_TYPE ||
		   url_type == SNEWSREPLY_URL_TYPE) {

	    if (no_newspost) {
		HTUserMsg(NEWSPOSTING_DISABLED);
		return (NULLFILE);
	    } else if (!news_ok && (url_type == NEWSPOST_URL_TYPE ||
				    url_type == NEWSREPLY_URL_TYPE)) {
		HTUserMsg(NEWS_DISABLED);
		return (NULLFILE);
	    } else {
		HTLoadAbsolute(&WWWDoc);
		return (NULLFILE);
	    }
#endif

	} else if (url_type == LYNXDOWNLOAD_URL_TYPE) {
	    LYDownload(doc->address);
#ifdef VMS
	    if (LYDidRename) {
		/*
		 * The temporary file was saved to disk via a rename(), so we
		 * can't access the temporary file again via the download menu. 
		 * Clear the flag, and return NULLFILE to pop.  - FM
		 */
		LYDidRename = FALSE;
		return (NULLFILE);
	    }
#endif /* VMS */
	    return (NORMAL);
	} else if (url_type == LYNXDIRED_URL_TYPE) {
#ifdef DIRED_SUPPORT
	    if (!no_dired_support) {
		local_dired(doc);
		WWWDoc.address = doc->address;
		WWWDoc.post_data = doc->post_data;
		WWWDoc.post_content_type = doc->post_content_type;
		WWWDoc.bookmark = doc->bookmark;
		WWWDoc.isHEAD = doc->isHEAD;
		WWWDoc.safe = doc->safe;

		if (!HTLoadAbsolute(&WWWDoc)) {
		    return (NOT_FOUND);
		}
		return (NORMAL);
	    }
#endif /* DIRED_SUPPORT */
	    HTUserMsg(DIRED_DISABLED);
	    return (NULLFILE);
	}

	if (LYNoRefererHeader == FALSE &&
	    LYNoRefererForThis == FALSE) {
	    const char *ref_url = HTLoadedDocumentURL();

	    if (isLYNXIMGMAP(ref_url))
		ref_url += LEN_LYNXIMGMAP;
	    if (no_filereferer == TRUE && isFILE_URL(ref_url)) {
		LYNoRefererForThis = TRUE;
	    }
	    if (LYNoRefererForThis == FALSE &&
		(cp = strchr(ref_url, '?')) != NULL &&
		strchr(cp, '=') != NULL) {
		/*
		 * Don't send a Referer header if the URL is the reply from a
		 * form with method GET, in case the content has personal data
		 * (e.g., a password or credit card number) which would become
		 * visible in logs.  - FM
		 *
		 * Changed 1999-11-01 to be controlled by REFERER_WITH_QUERY
		 * option.  - kw
		 */
		if (LYRefererWithQuery == 'S') {	/* SEND */
		    StrAllocCopy(LYRequestReferer, ref_url);
		} else if (LYRefererWithQuery == 'P') {		/* PARTIAL */
		    FREE(LYRequestReferer);	/* just to be sure */
		    LYRequestReferer = HTParse(ref_url, "",
					       PARSE_ACCESS
					       | PARSE_HOST
					       | PARSE_STRICTPATH
					       | PARSE_PUNCTUATION);
		} else {	/* Everything else - don't send Referer */
		    LYNoRefererForThis = TRUE;
		}
		cp = NULL;
	    } else if (LYNoRefererForThis == FALSE) {
		StrAllocCopy(LYRequestReferer, ref_url);
	    }
	} else {
	    StrAllocCopy(LYRequestReferer, HTLoadedDocumentURL());
	}
	if (url_type == LYNXHIST_URL_TYPE) {
	    /*
	     * 'doc' will change to the new file if we had a successful
	     * LYpop_num(), and the return value will be FALSE if we had a
	     * cancel.  - FM
	     */
	    if ((historytarget(doc) == FALSE) ||
		!doc || !doc->address) {
		return (NOT_FOUND);
	    }

	    /*
	     * We changed it so reload.
	     */
	    WWWDoc.address = doc->address;
	    WWWDoc.post_data = doc->post_data;
	    WWWDoc.post_content_type = doc->post_content_type;
	    WWWDoc.bookmark = doc->bookmark;
	    WWWDoc.isHEAD = doc->isHEAD;
	    WWWDoc.safe = doc->safe;
#ifndef DONT_TRACK_INTERNAL_LINKS
	    if (doc->internal_link && !reloading) {
		LYinternal_flag = TRUE;
	    }
#endif

#ifdef DIRED_SUPPORT
	    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
	    if (!HTLoadAbsolute(&WWWDoc)) {
		return (NOT_FOUND);
	    }
	    return (NORMAL);

	} else if (url_type == LYNXEXEC_URL_TYPE ||
		   url_type == LYNXPROG_URL_TYPE) {
#ifdef EXEC_LINKS
	    if (no_exec &&
		!exec_ok(HTLoadedDocumentURL(),
			 doc->address + 9, ALWAYS_EXEC_PATH)) {
		HTUserMsg(EXECUTION_DISABLED);
	    } else if (no_bookmark_exec &&
		       HTLoadedDocumentBookmark()) {
		HTUserMsg(BOOKMARK_EXEC_DISABLED);
	    } else if (local_exec || (local_exec_on_local_files &&
				      exec_ok(HTLoadedDocumentURL(),
					      doc->address + 9, EXEC_PATH))) {

		char *p = NULL;

		/*
		 * Bug puts slash on end if none is in the string.
		 */
		char *last_slash = strrchr(doc->address, '/');

		if (last_slash - doc->address
		    == (int) strlen(doc->address) - 1)
		    doc->address[strlen(doc->address) - 1] = '\0';

		/*
		 * Convert '~' to $HOME.
		 */
		if ((cp = strchr(doc->address, '~'))) {
		    HTSprintf0(&p, "%.*s%s%s",
			       cp - doc->address,
			       doc->address,
			       wwwName(Home_Dir()),
			       cp + 1);
		} else {
		    StrAllocCopy(p, doc->address);
		}
		/*
		 * Show URL before executing it.
		 */
		HTInfoMsg(doc->address);
		stop_curses();
		/*
		 * Run the command.
		 */
		if (strstr(p, "//") == p + 9)
		    LYSystem(p + 11);
		else
		    LYSystem(p + 9);
		FREE(p);

		if (url_type != LYNXPROG_URL_TYPE) {
		    /*
		     * Make sure user gets to see screen output.
		     */
#ifndef VMS
		    signal(SIGINT, SIG_IGN);
#endif /* !VMS */
		    printf("\n%s", RETURN_TO_LYNX);
		    fflush(stdout);
		    (void) LYgetch();
#ifdef VMS
		    HadVMSInterrupt = FALSE;
#endif /* VMS */
		}
		if (!dump_output_immediately) {
		    start_curses();
		    LYAddVisitedLink(doc);
		}

	    } else {
		char *buf = 0;

		HTSprintf0(&buf,
			   EXECUTION_DISABLED_FOR_FILE,
			   key_for_func(LYK_OPTIONS));
		HTAlert(buf);
		FREE(buf);
	    }
#else /* no exec_links */
	    HTUserMsg(EXECUTION_NOT_COMPILED);
#endif /* EXEC_LINKS */
	    return (NULLFILE);

	} else if (url_type == MAILTO_URL_TYPE) {
	    if (no_mail) {
		HTUserMsg(MAIL_DISABLED);
	    } else {
		HTParentAnchor *tmpanchor = HTAnchor_findAddress(&WWWDoc);
		const char *title;
		char *tmptitle = NULL;

		title = "";
		if (HTAnchor_title(tmpanchor)) {
		    title = HTAnchor_title(tmpanchor);
		} else if (HTMainAnchor && !LYUserSpecifiedURL) {
		    title = HTAnchor_subject(HTMainAnchor);
		    if (non_empty(title)) {
			if (strncasecomp(title, "Re:", 3)) {
			    StrAllocCopy(tmptitle, "Re: ");
			    StrAllocCat(tmptitle, title);
			    title = tmptitle;
			}
		    } else {
			title = "";
		    }
		}
		cp = strchr(doc->address, ':') + 1;
		reply_by_mail(cp,
			      ((HTMainAnchor && !LYUserSpecifiedURL) ?
			       (char *) HTMainAnchor->address :
			       (char *) doc->address),
			      title,
			      (HTMainAnchor && !LYUserSpecifiedURL) ?
			      HTMainAnchor->message_id : NULL);
		FREE(tmptitle);
	    }
	    return (NULLFILE);

	    /*
	     * From here on we could have a remote host, so check if that's
	     * allowed.
	     */
	} else if (local_host_only &&
		   url_type != LYNXKEYMAP_URL_TYPE &&
		   url_type != LYNXIMGMAP_URL_TYPE &&
		   url_type != LYNXCOOKIE_URL_TYPE &&
		   url_type != LYNXMESSAGES_URL_TYPE &&
		   url_type != LYNXCGI_URL_TYPE &&
		   !(url_type == NEWS_URL_TYPE &&
		     strncmp(doc->address, "news://", 7)) &&
		   !(LYisLocalHost(doc->address) ||
		     LYisLocalAlias(doc->address))) {
	    HTUserMsg(ACCESS_ONLY_LOCALHOST);
	    return (NULLFILE);

	    /*
	     * Disable www telnet access if not telnet_ok.
	     */
	} else if (url_type == TELNET_URL_TYPE ||
		   url_type == TN3270_URL_TYPE ||
		   url_type == TELNET_GOPHER_URL_TYPE) {
	    char *proxy;

	    if (!telnet_ok) {
		HTUserMsg(TELNET_DISABLED);
		return (NULLFILE);
	    } else if (no_telnet_port && strchr(doc->address + 7, ':')) {
		HTUserMsg(TELNET_PORT_SPECS_DISABLED);
		return (NULLFILE);
		/*
		 * Detect weird case where interactive protocol would be
		 * proxied, and to a non-interactive protocol at that.
		 */
	    } else if ((proxy = LYGetEnv(((url_type == TN3270_URL_TYPE)
					  ? "tn3270_proxy"
					  :
					  ((url_type == TELNET_GOPHER_URL_TYPE)
					   ? "gopher_proxy"
					   : "telnet_proxy")))) != NULL &&
		       !override_proxy(doc->address) &&
		       (!isTELNET_URL(proxy) &&
			!isTN3270_URL(proxy) &&
			!isRLOGIN_URL(proxy))) {
		/* Do nothing, fall through to generic code - kw */
	    } else {
		stop_curses();
		HTLoadAbsolute(&WWWDoc);
		if (!dump_output_immediately) {
		    start_curses();
		    fflush(stdout);
		    LYAddVisitedLink(doc);
		}
		return (NULLFILE);
	    }

	    /*
	     * Disable www news access if not news_ok.
	     */
#ifndef DISABLE_NEWS
	} else if (!news_ok && (url_type == NEWS_URL_TYPE ||
				url_type == NNTP_URL_TYPE)) {
	    HTUserMsg(NEWS_DISABLED);
	    return (NULLFILE);
#endif

	} else if (url_type == RLOGIN_URL_TYPE) {
	    char *proxy;

	    if (!rlogin_ok) {
		HTUserMsg(RLOGIN_DISABLED);
		return (NULLFILE);
		/*
		 * Detect weird case where interactive protocol would be
		 * proxied, and to a non-interactive protocol at that.
		 */
	    } else if ((proxy = LYGetEnv("rlogin_proxy")) != NULL &&
		       !override_proxy(doc->address) &&
		       (!isTELNET_URL(proxy) &&
			!isTN3270_URL(proxy) &&
			!isRLOGIN_URL(proxy))) {
		/* Do nothing, fall through to generic code - kw */
	    } else {
		stop_curses();
		HTLoadAbsolute(&WWWDoc);
		fflush(stdout);
		if (!dump_output_immediately) {
		    start_curses();
		    LYAddVisitedLink(doc);
		}
		return (NULLFILE);
	    }

	    /*
	     * If it's a gopher index type and there isn't a search term
	     * already attached then do this.  Otherwise just load it!
	     */
	} else if (url_type == INDEX_GOPHER_URL_TYPE &&
		   strchr(doc->address, '?') == NULL) {
	    int status;

	    /*
	     * Make sure we don't have a gopher+ escaped tab instead of a
	     * gopher0 question mark delimiting the search term.  - FM
	     */
	    if ((cp = strstr(doc->address, "%09")) != NULL) {
		*cp = '\0';
		StrAllocCopy(temp, doc->address);
		cp += 3;
		if (*cp && strncmp(cp, "%09", 3)) {
		    StrAllocCat(temp, "?");
		    StrAllocCat(temp, cp);
		    if ((cp = strstr(temp, "%09")) != NULL) {
			*cp = '\0';
		    }
		}
		StrAllocCopy(doc->address, temp);
		FREE(temp);
		goto Try_Redirected_URL;
	    }
	    /*
	     * Load it because the do_www_search routine uses the base url of
	     * the currently loaded document :(
	     */
	    if (!HTLoadAbsolute(&WWWDoc)) {
		return (NOT_FOUND);
	    }
	    status = do_www_search(doc);
	    if (status == NULLFILE) {
		LYpop(doc);
		WWWDoc.address = doc->address;
		WWWDoc.post_data = doc->post_data;
		WWWDoc.post_content_type = doc->post_content_type;
		WWWDoc.bookmark = doc->bookmark;
		WWWDoc.isHEAD = doc->isHEAD;
		WWWDoc.safe = doc->safe;
		status = HTLoadAbsolute(&WWWDoc);
#ifdef DIRED_SUPPORT
	    } else {
		lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
	    }
	    return (status);
	}

	if (!ftp_ok
	    && (url_type == FTP_URL_TYPE
		|| url_type == NCFTP_URL_TYPE)) {
	    HTUserMsg(FTP_DISABLED);
	    return (NULLFILE);
	} else if (url_type == HTML_GOPHER_URL_TYPE) {
	    char *tmp = NULL;

	    /*
	     * If tuple's Path=GET%20/...  convert to an http URL.
	     */
	    if ((cp = strchr(doc->address + 9, '/')) != NULL &&
		0 == strncmp(++cp, "hGET%20/", 8)) {
		StrAllocCopy(tmp, "http://");
		CTRACE((tfp, "getfile: URL '%s'\n",
			doc->address));
		*cp = '\0';
		StrAllocCat(tmp, doc->address + 9);
		/*
		 * If the port is defaulted, it should stay 70.
		 */
		if (strchr(tmp + 6, ':') == NULL) {
		    StrAllocCat(tmp, "70/");
		    tmp[strlen(tmp) - 4] = ':';
		}
		if (strlen(cp + 7) > 1)
		    StrAllocCat(tmp, cp + 8);
		StrAllocCopy(doc->address, tmp);
		CTRACE((tfp, "  changed to '%s'\n",
			doc->address));
		FREE(tmp);
		url_type = HTTP_URL_TYPE;
	    }
	}

	if (url_type == HTTP_URL_TYPE ||
	    url_type == HTTPS_URL_TYPE ||
	    url_type == FTP_URL_TYPE ||
	    url_type == NCFTP_URL_TYPE ||
	    url_type == CSO_URL_TYPE) {
	    fix_httplike_urls(doc, url_type);
	}

	WWWDoc.address = doc->address;	/* possible reload */
#ifdef DIRED_SUPPORT
	lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */

#ifndef DISABLE_BIBP
	if (url_type == BIBP_URL_TYPE) {
	    char *bibpTmp = NULL;

	    if (!BibP_bibhost_checked)
		LYCheckBibHost();
	    if (BibP_bibhost_available) {
		StrAllocCopy(bibpTmp, BibP_bibhost);
	    } else if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
		StrAllocCopy(bibpTmp, HTAnchor_citehost(HTMainAnchor));
	    } else {
		StrAllocCopy(bibpTmp, BibP_globalserver);
	    }
	    if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
		StrAllocCat(bibpTmp, "bibp1.0/resolve?citehost=");
		StrAllocCat(bibpTmp, HTAnchor_citehost(HTMainAnchor));
		StrAllocCat(bibpTmp, "&usin=");
	    } else {
		StrAllocCat(bibpTmp, "bibp1.0/resolve?usin=");
	    }
	    StrAllocCat(bibpTmp, doc->address + 5);	/* USIN after bibp: */
	    StrAllocCopy(doc->address, bibpTmp);
	    WWWDoc.address = doc->address;
	    FREE(bibpTmp);
	}
#endif /* !DISABLE_BIBP */

	if (url_type == FILE_URL_TYPE) {
	    /*
	     * If a file URL has a '~' as the lead character of its first
	     * symbolic element, convert the '~' to Home_Dir(), then append
	     * the rest of of path, if present, skipping "user" if "~user"
	     * was entered, simplifying, and eliminating any residual
	     * relative elements.  - FM
	     */
	    if (((cp = HTParse(doc->address, "",
			       PARSE_PATH + PARSE_ANCHOR + PARSE_PUNCTUATION))
		 != NULL) &&
		!strncmp(cp, "/~", 2)) {
		char *cp1 = strstr(doc->address, "/~");
		char *cp2;

		CTRACE((tfp, "getfile: URL '%s'\n",
			doc->address));
		*cp1 = '\0';
		cp1 += 2;
		StrAllocCopy(temp, doc->address);
		StrAllocCopy(cp, wwwName(Home_Dir()));
		if (!LYIsHtmlSep(*cp))
		    LYAddHtmlSep(&temp);
		StrAllocCat(temp, cp);
		if ((cp2 = strchr(cp1, '/')) != NULL) {
		    LYTrimRelFromAbsPath(cp2);
		    StrAllocCat(temp, cp2);
		}
		StrAllocCopy(doc->address, temp);
		FREE(temp);
		CTRACE((tfp, "  changed to '%s'\n",
			doc->address));
		WWWDoc.address = doc->address;
	    }
	    FREE(cp);
	}
	CTRACE_SLEEP(MessageSecs);
	user_message(WWW_WAIT_MESSAGE, doc->address);

	if (TRACE) {
#ifdef USE_SLANG
	    if (LYCursesON) {
		LYaddstr("*\n");
		LYrefresh();
	    }
#endif /* USE_SLANG */
	    CTRACE((tfp, "\n"));
	}

	if (!HTLoadAbsolute(&WWWDoc)) {
	    /*
	     * Check for redirection.
	     */
	    if (use_this_url_instead != NULL) {
		if (!is_url(use_this_url_instead)) {
		    /*
		     * The server did not return a complete URL in its
		     * Location:  header, probably due to a FORM or other
		     * CGI script written by someone who doesn't know that
		     * the http protocol requires that it be a complete
		     * URL, or using a server which does not treat such a
		     * redirect string from the script as an instruction to
		     * resolve it versus the initial request, check
		     * authentication with that URL, and then act on it
		     * without returning redirection to us.  We'll violate
		     * the http protocol and resolve it ourselves using the
		     * URL of the original request as the BASE, rather than
		     * doing the RIGHT thing and returning an invalid
		     * address message.  - FM
		     */
		    HTUserMsg(LOCATION_NOT_ABSOLUTE);
		    temp = HTParse(use_this_url_instead,
				   WWWDoc.address,
				   PARSE_ALL);
		    if (non_empty(temp)) {
			StrAllocCopy(use_this_url_instead, temp);
		    }
		    FREE(temp);
		}
		url_type = is_url(use_this_url_instead);
		if (!HTPermitRedir &&
		    (url_type == LYNXDOWNLOAD_URL_TYPE ||
		     url_type == LYNXEXEC_URL_TYPE ||
		     url_type == LYNXPROG_URL_TYPE ||
#ifdef DIRED_SUPPORT
		     url_type == LYNXDIRED_URL_TYPE ||
#endif /* DIRED_SUPPORT */
		     url_type == LYNXPRINT_URL_TYPE ||
		     url_type == LYNXOPTIONS_URL_TYPE ||
		     url_type == LYNXCFG_URL_TYPE ||
		     url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
		     url_type == LYNXHIST_URL_TYPE ||
		     url_type == LYNXCOOKIE_URL_TYPE ||
		     url_type == LYNXMESSAGES_URL_TYPE ||
		     (LYValidate &&
		      url_type != HTTP_URL_TYPE &&
		      url_type != HTTPS_URL_TYPE) ||
		     ((no_file_url || no_goto_file) &&
		      url_type == FILE_URL_TYPE) ||
		     (no_goto_lynxcgi &&
		      url_type == LYNXCGI_URL_TYPE) ||
#ifndef DISABLE_BIBP
		     (no_goto_bibp &&
		      url_type == BIBP_URL_TYPE) ||
#endif
		     (no_goto_cso &&
		      url_type == CSO_URL_TYPE) ||
		     (no_goto_finger &&
		      url_type == FINGER_URL_TYPE) ||
		     (no_goto_ftp &&
		      (url_type == FTP_URL_TYPE ||
		       url_type == NCFTP_URL_TYPE)) ||
		     (no_goto_gopher &&
		      url_type == GOPHER_URL_TYPE) ||
		     (no_goto_http &&
		      url_type == HTTP_URL_TYPE) ||
		     (no_goto_https &&
		      url_type == HTTPS_URL_TYPE) ||
		     (no_goto_mailto &&
		      url_type == MAILTO_URL_TYPE) ||
#ifndef DISABLE_NEWS
		     (no_goto_news &&
		      url_type == NEWS_URL_TYPE) ||
		     (no_goto_nntp &&
		      url_type == NNTP_URL_TYPE) ||
#endif
		     (no_goto_rlogin &&
		      url_type == RLOGIN_URL_TYPE) ||
#ifndef DISABLE_NEWS
		     (no_goto_snews &&
		      url_type == SNEWS_URL_TYPE) ||
#endif
		     (no_goto_telnet &&
		      url_type == TELNET_URL_TYPE) ||
		     (no_goto_tn3270 &&
		      url_type == TN3270_URL_TYPE) ||
		     (no_goto_wais &&
		      url_type == WAIS_URL_TYPE))) {
		    /*
		     * Some schemes are not acceptable from server
		     * redirections.  - KW & FM
		     */
		    HTAlert(ILLEGAL_REDIRECTION_URL);
		    if (LYCursesON) {
			HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE,
				   use_this_url_instead);
		    } else {
			fprintf(stderr,
				WWW_ILLEGAL_URL_MESSAGE,
				use_this_url_instead);
		    }
		    FREE(use_this_url_instead);
		    return (NULLFILE);
		}
		if ((pound = findPoundSelector(doc->address)) != NULL
		    && findPoundSelector(use_this_url_instead) == NULL) {
		    /*
		     * Our requested URL had a fragment associated with it,
		     * and the redirection URL doesn't, so we'll append the
		     * fragment associated with the original request.  If
		     * it's bogus for the redirection URL, we'll be
		     * positioned at the top of that document, so there's
		     * no harm done.  - FM
		     */
		    CTRACE((tfp,
			    "getfile: Adding fragment '%s' to redirection URL.\n",
			    pound));
		    StrAllocCat(use_this_url_instead, pound);
		    doc->link = -1;
		}
		CTRACE_SLEEP(MessageSecs);
		HTUserMsg2(WWW_USING_MESSAGE, use_this_url_instead);
		CTRACE((tfp, "\n"));
		StrAllocCopy(doc->address,
			     use_this_url_instead);
		FREE(use_this_url_instead);
		if (redirect_post_content == FALSE) {
		    /*
		     * Freeing the content also yields a GET request.  - FM
		     */
		    LYFreePostData(doc);
		}
		/*
		 * Go to top to check for URL's which get special handling
		 * and/or security checks in Lynx.  - FM
		 */
		goto Try_Redirected_URL;
	    }
	    if (HTNoDataOK) {
		return (NULLFILE);
	    } else {
		return (NOT_FOUND);
	    }
	} else {

	    lynx_mode = NORMAL_LYNX_MODE;

	    /*
	     * Some URL's don't actually return a document; compare
	     * doc->address with the document that is actually loaded and
	     * return NULLFILE if not loaded.  If www_search_result is not -1
	     * then this is a reference to a named anchor within the same
	     * document; do NOT return NULLFILE in that case.
	     */

	    /*
	     * Check for a #fragment selector.
	     */
	    pound = findPoundSelector(doc->address);

	    /*
	     * Check to see if there is a temp file waiting for us to
	     * download.
	     */
	    if (WWW_Download_File) {
		HTParentAnchor *tmpanchor = HTAnchor_findAddress(&WWWDoc);
		char *fname = NULL;

		/*
		 * Check for a suggested filename from the
		 * Content-Disposition header.  - FM
		 */
		if (HTAnchor_SugFname(tmpanchor) != NULL) {
		    StrAllocCopy(fname, HTAnchor_SugFname(tmpanchor));
		} else {
		    StrAllocCopy(fname, doc->address);
		}
		/*
		 * Check whether this is a compressed file, which we don't
		 * uncompress for downloads, and adjust any suffix
		 * appropriately.  - FM
		 */
		HTCheckFnameForCompression(&fname, tmpanchor, FALSE);

		if (LYdownload_options(&fname,
				       WWW_Download_File) < 0) {
		    FREE(fname);
		    return (NOT_FOUND);
		}
		LYAddVisitedLink(doc);
		StrAllocCopy(doc->address, fname);
		FREE(fname);
		doc->internal_link = FALSE;
		WWWDoc.address = doc->address;
		LYFreePostData(doc);
		WWWDoc.post_data = NULL;
		WWWDoc.post_content_type = NULL;
		WWWDoc.bookmark = doc->bookmark = FALSE;
		WWWDoc.isHEAD = doc->isHEAD = FALSE;
		WWWDoc.safe = doc->safe = FALSE;
		HTOutputFormat = WWW_PRESENT;
		if (!HTLoadAbsolute(&WWWDoc)) {
		    return (NOT_FOUND);
		} else {
		    return (NORMAL);
		}

	    } else if (pound == NULL &&
		/*
		 * HTAnchor hash-table searches are now case-sensitive
		 * (hopefully, without anchor deletion problems), so this
		 * is too.  - FM
		 */
		       (strcmp(doc->address,
			       HTLoadedDocumentURL()) ||
		/*
		 * Also check the post_data elements.  - FM
		 */
			!BINEQ(doc->post_data,
			       HTLoadedDocumentPost_data()) ||
		/*
		 * Also check the isHEAD element.  - FM
		 */
			doc->isHEAD != HTLoadedDocumentIsHEAD())) {
		/*
		 * Nothing needed to be shown.
		 */
		LYAddVisitedLink(doc);
		return (NULLFILE);

	    } else {
		if (pound != NULL) {
		    if (!HTMainText) {	/* this should not happen... */
			return (NULLFILE);	/* but it can. - kw */
		    }
		    /*
		     * May set www_search_result.
		     */
		    if (HTFindPoundSelector(pound + 1)) {
			*target = www_search_result;
			doc->link = -1;
		    }
		}
		return (NORMAL);
	    }
	}
    } else {
	CTRACE_SLEEP(MessageSecs);
	HTUserMsg2(WWW_BAD_ADDR_MESSAGE, doc->address);
	CTRACE((tfp, "\n"));
	return (NULLFILE);
    }
}

/*
 * Set source mode for the next retrieval via getfile or HTreparse_document.
 * mode == -1:  force normal presentation
 * mode == 1:  force source presentation
 * mode == 0:  reset to normal if it was set to source
 * - kw
 */
void srcmode_for_next_retrieval(int mode)
{
    if (mode < 0) {
	HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	psrc_view = FALSE;
#endif

    } else if (mode == 0) {
	if (HTOutputFormat == WWW_SOURCE)
	    HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	else if (LYpsrc)
	    psrc_view = FALSE;
#endif

    } else {
#ifdef USE_PRETTYSRC
	if (LYpsrc)
	    psrc_view = TRUE;
	else
	    HTOutputFormat = WWW_SOURCE;
#else
	HTOutputFormat = WWW_SOURCE;
#endif
    }
}

/*
 * The user wants to select a link or page by number.
 *
 * If follow_link_number returns DO_LINK_STUFF do_link will be run immediately
 * following its execution.
 *
 * If follow_link_number returns DO_GOTOLINK_STUFF it has updated the passed in
 * doc for positioning on a link.
 *
 * If follow_link_number returns DO_GOTOPAGE_STUFF it has set doc->line to the
 * top line of the desired page for displaying that page.
 *
 * If follow_link_number returns PRINT_ERROR an error message will be given to
 * the user.
 *
 * If follow_link_number returns DO_FORMS_STUFF some forms stuff will be done. 
 * (Not yet implemented.)
 *
 * If follow_link_number returns DO_NOTHING nothing special will run after it.
 */
int follow_link_number(int c,
		       int cur,
		       DocInfo *doc,
		       int *num)
{
    char temp[120];
    char *p = temp;
    int rel = 0;
    int new_top, new_link;
    BOOL want_go;
    int curline = *num;		/* passed in from mainloop() */

    CTRACE((tfp, "follow_link_number(%d,%d,...)\n", c, cur));
    temp[0] = (char) c;
    temp[1] = '\0';
    *num = -1;
    _statusline(FOLLOW_LINK_NUMBER);
    /*
     * Get the number, possibly with a letter suffix, from the user.
     */
    if (LYgetstr(temp, VISIBLE, sizeof(temp), NORECALL) < 0 || *temp == 0) {
	HTInfoMsg(CANCELLED);
	return (DO_NOTHING);
    }
    *num = atoi(p);
    while (isdigit(UCH(*p)))
	++p;
    c = *p;			/* reuse c; 0 or g or p or + or - */
    switch (c) {
    case '+':
    case '-':
	/* 123+ or 123- */
	rel = c;
	c = *++p;
	break;
    default:
	rel = *++p;
	break;
    case 0:
	break;
    }
    /* don't currently check for errors typing suffix */

    CTRACE((tfp, "  temp=%s, *num=%d, rel='%c'\n", temp, *num, rel));
    /*
     * Check if we had a 'p' or 'P' following the number as a flag for
     * displaying the page with that number.  - FM
     */
    if ((c == 'p' || c == 'P') && display_lines == 0) {
	CTRACE((tfp, " curline=%d, LYlines=%d, display too small!\n",
		curline, LYlines));
	return (PRINT_ERROR);
    } else if (c == 'p' || c == 'P') {
	int nlines = HText_getNumOfLines();
	int npages = ((nlines + 1) > display_lines) ?
	(((nlines + 1) + (display_lines - 1)) / (display_lines))
	: 1;
	int curpage = ((curline + 1) > display_lines) ?
	(((curline + 1) + (display_lines - 1)) / (display_lines))
	: 1;

	CTRACE((tfp, " nlines=%d, npages=%d, curline=%d, curpage=%d\n",
		nlines, npages, curline, curpage));
	if (*num < 1)
	    *num = rel ? 0 : 1;
	if (rel == '+')
	    *num = curpage + *num;
	else if (rel == '-')
	    *num = curpage - *num;
	doc->line = (npages <= 1) ?
	    1 :
	    ((*num <= npages) ? (((*num - 1) * display_lines) + 1)
	     : (((npages - 1) * display_lines) + 1));
	return (DO_GOTOPAGE_STUFF);
    }

    /*
     * Check if we want to make the link corresponding to the number the
     * current link, rather than ACTIVATE-ing it.
     */
    want_go = (BOOL) (c == 'g' || c == 'G');

    /* If rel, add or subtract num from current link, or
     * nearest previous/subsequent link if current link is not on screen.
     */
    if (rel)
	*num = HTGetRelLinkNum(*num, rel, cur);
    /*
     * If we have a valid number, act on it.
     */
    if (*num > 0) {
	int info;
	char *text = NULL;

	/*
	 * Get the lname, and hightext, directly from www structures and add it
	 * to the cur link so that we can pass it transparently on to
	 * getfile(), and load new_top and new_link if we instead want to make
	 * the link number current.  These things are done so that a link can
	 * be selected anywhere in the current document, whether it is
	 * displayed on the screen or not!
	 */
	info = HTGetLinkInfo(*num,
			     want_go,
			     &new_top,
			     &new_link,
			     &text,
			     &links[cur].lname);
	if (text != NULL)
	    LYSetHilite(cur, text);
	if (info == WWW_INTERN_LINK_TYPE) {
	    links[cur].type = WWW_INTERN_LINK_TYPE;
	    return (DO_LINK_STUFF);
	} else if (info == LINK_LINE_FOUND) {
	    doc->line = new_top + 1;
	    doc->link = new_link;
	    return (DO_GOTOLINK_STUFF);
	} else if (info) {
	    links[cur].type = WWW_LINK_TYPE;
	    return (DO_LINK_STUFF);
	} else {
	    return (PRINT_ERROR);
	}
    } else {
	return (PRINT_ERROR);
    }
}

#if defined(EXEC_LINKS) || defined(LYNXCGI_LINKS)

struct trust {
    char *src;
    char *path;
    int type;
    struct trust *next;
};

static struct trust trusted_exec_default =
{
    "file://localhost/", "", EXEC_PATH, NULL
};
static struct trust always_trusted_exec_default =
{
    "none", "", ALWAYS_EXEC_PATH, NULL
};
static struct trust trusted_cgi_default =
{
    "", "", CGI_PATH, NULL
};

static struct trust *trusted_exec = &trusted_exec_default;
static struct trust *always_trusted_exec = &always_trusted_exec_default;
static struct trust *trusted_cgi = &trusted_cgi_default;

#ifdef LY_FIND_LEAKS
static void LYTrusted_free(void)
{
    struct trust *cur;
    struct trust *next;

    if (trusted_exec != &trusted_exec_default) {
	cur = trusted_exec;
	while (cur) {
	    FREE(cur->src);
	    FREE(cur->path);
	    next = cur->next;
	    FREE(cur);
	    cur = next;
	}
    }

    if (always_trusted_exec != &always_trusted_exec_default) {
	cur = always_trusted_exec;
	while (cur) {
	    FREE(cur->src);
	    FREE(cur->path);
	    next = cur->next;
	    FREE(cur);
	    cur = next;
	}
    }

    if (trusted_cgi != &trusted_cgi_default) {
	cur = trusted_cgi;
	while (cur) {
	    FREE(cur->src);
	    FREE(cur->path);
	    next = cur->next;
	    FREE(cur);
	    cur = next;
	}
    }

    return;
}
#endif /* LY_FIND_LEAKS */

void add_trusted(char *str,
		 int type)
{
    struct trust *tp;
    char *path;
    char *src = str;
    int Type = type;
    static BOOLEAN first = TRUE;

    if (!src)
	return;
    if (first) {
#ifdef LY_FIND_LEAKS
	atexit(LYTrusted_free);
#endif
	first = FALSE;
    }

    path = strchr(src, '\t');
    if (path)
	*path++ = '\0';
    else
	path = "";

    tp = (struct trust *) malloc(sizeof(*tp));
    if (tp == NULL)
	outofmem(__FILE__, "add_trusted");
    tp->src = NULL;
    tp->path = NULL;
    tp->type = Type;
    StrAllocCopy(tp->src, src);
    StrAllocCopy(tp->path, path);
    if (Type == EXEC_PATH) {
	if (trusted_exec == &trusted_exec_default)
	    tp->next = NULL;
	else
	    tp->next = trusted_exec;
	trusted_exec = tp;
    } else if (Type == ALWAYS_EXEC_PATH) {
	if (always_trusted_exec == &always_trusted_exec_default)
	    tp->next = NULL;
	else
	    tp->next = always_trusted_exec;
	always_trusted_exec = tp;
    } else if (Type == CGI_PATH) {
	if (trusted_cgi == &trusted_cgi_default)
	    tp->next = NULL;
	else
	    tp->next = trusted_cgi;
	trusted_cgi = tp;
    }
}

/*
 * Check to see if the supplied paths is allowed to be executed.
 */
BOOLEAN exec_ok(const char *source,
		const char *linktext,
		int type)
{
    struct trust *tp;
    const char *cp;
    const char *allowed_extra_chars;
    int Type = type;

    /*
     * Always OK if it is a jump file shortcut.
     */
    if (LYJumpFileURL)
	return TRUE;

    /*
     * Choose the trust structure based on the type.
     */
    if (Type == EXEC_PATH) {
	tp = trusted_exec;
    } else if (Type == ALWAYS_EXEC_PATH) {
	tp = always_trusted_exec;
    } else if (Type == CGI_PATH) {
	tp = trusted_cgi;
    } else {
	HTAlert(MALFORMED_EXEC_REQUEST);
	return FALSE;
    }

#ifdef VMS
    /*
     * Security:  reject on relative path.
     */
    if ((cp = strchr(linktext, '[')) != NULL) {
	char *cp1;

	if (((cp1 = strchr(cp, '-')) != NULL) &&
	    strchr(cp1, ']') != NULL) {
	    while (cp1[1] == '-')
		cp1++;
	    if (cp1[1] == ']' ||
		cp1[1] == '.') {
		HTAlert(RELPATH_IN_EXEC_LINK);
		return FALSE;
	    }
	}
    }
#else
    /*
     * Security:  reject on relative path.
     */
    if (strstr(linktext, "../") != NULL) {
	HTAlert(RELPATH_IN_EXEC_LINK);
	return FALSE;
    }

    /*
     * Security:  reject on strange character.
     */
    if (Type == CGI_PATH)
	allowed_extra_chars = " _-:./@@~$&+=\t";
    else
	allowed_extra_chars = " _-:./@@~$+=\t";
    for (cp = linktext; *cp != '\0'; cp++) {
	if (!isalnum(UCH(*cp)) && !strchr(allowed_extra_chars, *cp)) {
	    char *buf = 0;

	    HTSprintf0(&buf,
		       BADCHAR_IN_EXEC_LINK,
		       *cp);
	    HTAlert(buf);
	    FREE(buf);
	    return FALSE;
	}
    }
#endif /* VMS */

  check_tp_for_entry:
    while (tp) {
	if (tp->type == Type) {
	    char const *command = linktext;

	    if (strstr(command, "//") == linktext) {
		command += 2;
	    }
	    if (STRNADDRCOMP(source, tp->src, strlen(tp->src)) == 0 &&
		STRNADDRCOMP(command, tp->path, strlen(tp->path)) == 0)
		return TRUE;
	}
	tp = tp->next;
    }
    if (Type == EXEC_PATH &&
	always_trusted_exec != &always_trusted_exec_default) {
	Type = ALWAYS_EXEC_PATH;
	tp = always_trusted_exec;
	goto check_tp_for_entry;
    }
    if (!(no_exec && type == ALWAYS_EXEC_PATH))
	HTAlert(BADLOCPATH_IN_EXEC_LINK);
    return FALSE;
}
#endif /* EXEC_LINKS || LYNXCGI_LINKS */

static int fix_httplike_urls(DocInfo *doc, UrlTypes type)
{
    char *slash;

    /*
     * If there's a fragment present, our simplistic methods won't work.  - kw
     */
    if (findPoundSelector(doc->address) != NULL)
	return 0;

#ifndef DISABLE_FTP
    /*
     * If it's an ftp URL with a trailing slash, trim it off.
     */
    if (type == FTP_URL_TYPE &&
	LYIsHtmlSep(doc->address[strlen(doc->address) - 1])) {
	char *proxy;
	char *path = HTParse(doc->address, "", PARSE_PATH | PARSE_PUNCTUATION);

	/*
	 * If the path is a lone slash, we're done.  - FM
	 */
	if (path) {
	    if (LYIsHtmlSep(path[0]) && path[1] == '\0') {
		FREE(path);
		return 0;
	    }
	    FREE(path);
	}

	/*
	 * If we're proxying ftp, don't trim anything.  - KW
	 */
	if (((proxy = LYGetEnv("ftp_proxy")) != NULL) &&
	    !override_proxy(doc->address))
	    return 0;

	/*
	 * If we get to here, trim the trailing slash.  - FM
	 */
	CTRACE((tfp, "fix_httplike_urls: URL '%s'\n", doc->address));
	LYTrimHtmlSep(doc->address);
	CTRACE((tfp, "            changed to '%s'\n", doc->address));
	CTRACE_SLEEP(MessageSecs);
    } else if (type == NCFTP_URL_TYPE) {
	char *path = NULL;
	char *first = doc->address;
	char *second = strchr(first, ':');

	CTRACE((tfp, "fix_httplike_urls: URL '%s'\n", doc->address));

	*second++ = '\0';
	HTSprintf0(&path, "%s//%s%s", STR_FTP_URL, first, second);
	FREE(doc->address);
	doc->address = path;

	CTRACE((tfp, "            changed to '%s'\n", doc->address));
	CTRACE_SLEEP(MessageSecs);
    }
#endif /* DISABLE_FTP */

    /*
     * If there isn't a slash besides the two at the beginning, append one.
     */
    if ((slash = strrchr(doc->address, '/')) != NULL) {
	if (!LYIsHtmlSep(*(slash - 1)) || *(slash - 2) != ':') {
	    return (0);
	}
	if (type == HTTP_URL_TYPE ||
	    type == HTTPS_URL_TYPE) {
	    if ((slash - 2) != strchr(doc->address, ':')) {
		/*
		 * Turns out we were not looking at the right slash after all,
		 * there must have been more than one "://" which is valid at
		 * least for http URLs (later occurrences can be part of a
		 * query string, for example), so leave this alone, too.  - kw
		 */
		return (0);
	    }
	    if (strchr(doc->address, '?')) {
		/*
		 * If there is a question mark that appears to be part of the
		 * hostname, don't append anything either.  Leave it to HTParse
		 * to interpret the question mark as ending the hostname.  - kw
		 */
		return (0);
	    }
	}
    }
    CTRACE((tfp, "fix_httplike_urls: URL '%s'\n", doc->address));
    LYAddHtmlSep(&(doc->address));
    CTRACE((tfp, "            changed to '%s'\n", doc->address));
    CTRACE_SLEEP(MessageSecs);

    return (1);
}
@


1.7
log
@automatic merge
@
text
@d69 1
a69 1
int getfile(DocInfo *doc)
d71 1
a71 1
    int url_type = 0;
d274 1
a274 1
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
d368 1
a368 1
	    char *ref_url = HTLoadedDocumentURL();
d948 1
d1068 4
a1071 1
		    HTFindPoundSelector(pound + 1);
@


1.6
log
@automatic merge; regen configure
@
text
@d537 1
a537 1
		    if (title && *title) {
d854 1
a854 1
		    if (temp && *temp) {
@


1.5
log
@automatic merge of lynx-current
@
text
@d72 1
d157 1
a157 2
		}
		if (value == 25 || value == 65561) {
d161 1
a161 2
		}
		if (value > 65535 || value < 0) {
d703 9
d713 24
a736 6
	} {
	    if (!ftp_ok
		&& (url_type == FTP_URL_TYPE
		    || url_type == NCFTP_URL_TYPE)) {
		HTUserMsg(FTP_DISABLED);
		return (NULLFILE);
d738 1
d740 7
a746 2
	    if (url_type == HTML_GOPHER_URL_TYPE) {
		char *tmp = NULL;
d748 1
a748 33
		/*
		 * If tuple's Path=GET%20/...  convert to an http URL.
		 */
		if ((cp = strchr(doc->address + 9, '/')) != NULL &&
		    0 == strncmp(++cp, "hGET%20/", 8)) {
		    StrAllocCopy(tmp, "http://");
		    CTRACE((tfp, "getfile: URL '%s'\n",
			    doc->address));
		    *cp = '\0';
		    StrAllocCat(tmp, doc->address + 9);
		    /*
		     * If the port is defaulted, it should stay 70.
		     */
		    if (strchr(tmp + 6, ':') == NULL) {
			StrAllocCat(tmp, "70/");
			tmp[strlen(tmp) - 4] = ':';
		    }
		    if (strlen(cp + 7) > 1)
			StrAllocCat(tmp, cp + 8);
		    StrAllocCopy(doc->address, tmp);
		    CTRACE((tfp, "  changed to '%s'\n",
			    doc->address));
		    FREE(tmp);
		    url_type = HTTP_URL_TYPE;
		}
	    }
	    if (url_type == HTTP_URL_TYPE ||
		url_type == HTTPS_URL_TYPE ||
		url_type == FTP_URL_TYPE ||
		url_type == NCFTP_URL_TYPE ||
		url_type == CSO_URL_TYPE)
		fix_httplike_urls(doc, url_type);
	    WWWDoc.address = doc->address;	/* possible reload */
d750 1
a750 1
	    lynx_edit_mode = FALSE;
d752 1
d754 2
a755 2
	    if (url_type == BIBP_URL_TYPE) {
		char *bibpTmp = NULL;
d757 15
a771 20
		if (!BibP_bibhost_checked)
		    LYCheckBibHost();
		if (BibP_bibhost_available) {
		    StrAllocCopy(bibpTmp, BibP_bibhost);
		} else if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
		    StrAllocCopy(bibpTmp, HTAnchor_citehost(HTMainAnchor));
		} else {
		    StrAllocCopy(bibpTmp, BibP_globalserver);
		}
		if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
		    StrAllocCat(bibpTmp, "bibp1.0/resolve?citehost=");
		    StrAllocCat(bibpTmp, HTAnchor_citehost(HTMainAnchor));
		    StrAllocCat(bibpTmp, "&usin=");
		} else {
		    StrAllocCat(bibpTmp, "bibp1.0/resolve?usin=");
		}
		StrAllocCat(bibpTmp, doc->address + 5);		/* USIN after bibp: */
		StrAllocCopy(doc->address, bibpTmp);
		WWWDoc.address = doc->address;
		FREE(bibpTmp);
d773 5
d780 27
a806 33
	    if (url_type == FILE_URL_TYPE) {
		/*
		 * If a file URL has a '~' as the lead character of its first
		 * symbolic element, convert the '~' to Home_Dir(), then append
		 * the rest of of path, if present, skipping "user" if "~user"
		 * was entered, simplifying, and eliminating any residual
		 * relative elements.  - FM
		 */
		if (((cp = HTParse(doc->address, "",
				   PARSE_PATH + PARSE_ANCHOR + PARSE_PUNCTUATION))
		     != NULL) &&
		    !strncmp(cp, "/~", 2)) {
		    char *cp1 = strstr(doc->address, "/~");
		    char *cp2;

		    CTRACE((tfp, "getfile: URL '%s'\n",
			    doc->address));
		    *cp1 = '\0';
		    cp1 += 2;
		    StrAllocCopy(temp, doc->address);
		    StrAllocCopy(cp, wwwName(Home_Dir()));
		    if (!LYIsHtmlSep(*cp))
			LYAddHtmlSep(&temp);
		    StrAllocCat(temp, cp);
		    if ((cp2 = strchr(cp1, '/')) != NULL) {
			LYTrimRelFromAbsPath(cp2);
			StrAllocCat(temp, cp2);
		    }
		    StrAllocCopy(doc->address, temp);
		    FREE(temp);
		    CTRACE((tfp, "  changed to '%s'\n",
			    doc->address));
		    WWWDoc.address = doc->address;
d808 5
a812 1
		FREE(cp);
d814 4
a817 2
	    CTRACE_SLEEP(MessageSecs);
	    user_message(WWW_WAIT_MESSAGE, doc->address);
d819 1
a819 1
	    if (TRACE) {
d821 4
a824 4
		if (LYCursesON) {
		    LYaddstr("*\n");
		    LYrefresh();
		}
d826 2
a827 8
		CTRACE((tfp, "\n"));
	    }
	    if (!HTLoadAbsolute(&WWWDoc)) {
		/*
		 * Check for redirection.
		 */
		if (use_this_url_instead != NULL) {
		    char *pound;
d829 27
a855 24
		    if (!is_url(use_this_url_instead)) {
			/*
			 * The server did not return a complete URL in its
			 * Location:  header, probably due to a FORM or other
			 * CGI script written by someone who doesn't know that
			 * the http protocol requires that it be a complete
			 * URL, or using a server which does not treat such a
			 * redirect string from the script as an instruction to
			 * resolve it versus the initial request, check
			 * authentication with that URL, and then act on it
			 * without returning redirection to us.  We'll violate
			 * the http protocol and resolve it ourselves using the
			 * URL of the original request as the BASE, rather than
			 * doing the RIGHT thing and returning an invalid
			 * address message.  - FM
			 */
			HTUserMsg(LOCATION_NOT_ABSOLUTE);
			temp = HTParse(use_this_url_instead,
				       WWWDoc.address,
				       PARSE_ALL);
			if (temp && *temp) {
			    StrAllocCopy(use_this_url_instead, temp);
			}
			FREE(temp);
d857 7
a863 5
		    url_type = is_url(use_this_url_instead);
		    if (!HTPermitRedir &&
			(url_type == LYNXDOWNLOAD_URL_TYPE ||
			 url_type == LYNXEXEC_URL_TYPE ||
			 url_type == LYNXPROG_URL_TYPE ||
d865 1
a865 1
			 url_type == LYNXDIRED_URL_TYPE ||
d867 14
a880 14
			 url_type == LYNXPRINT_URL_TYPE ||
			 url_type == LYNXOPTIONS_URL_TYPE ||
			 url_type == LYNXCFG_URL_TYPE ||
			 url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
			 url_type == LYNXHIST_URL_TYPE ||
			 url_type == LYNXCOOKIE_URL_TYPE ||
			 url_type == LYNXMESSAGES_URL_TYPE ||
			 (LYValidate &&
			  url_type != HTTP_URL_TYPE &&
			  url_type != HTTPS_URL_TYPE) ||
			 ((no_file_url || no_goto_file) &&
			  url_type == FILE_URL_TYPE) ||
			 (no_goto_lynxcgi &&
			  url_type == LYNXCGI_URL_TYPE) ||
d882 2
a883 2
			 (no_goto_bibp &&
			  url_type == BIBP_URL_TYPE) ||
d885 15
a899 15
			 (no_goto_cso &&
			  url_type == CSO_URL_TYPE) ||
			 (no_goto_finger &&
			  url_type == FINGER_URL_TYPE) ||
			 (no_goto_ftp &&
			  (url_type == FTP_URL_TYPE ||
			   url_type == NCFTP_URL_TYPE)) ||
			 (no_goto_gopher &&
			  url_type == GOPHER_URL_TYPE) ||
			 (no_goto_http &&
			  url_type == HTTP_URL_TYPE) ||
			 (no_goto_https &&
			  url_type == HTTPS_URL_TYPE) ||
			 (no_goto_mailto &&
			  url_type == MAILTO_URL_TYPE) ||
d901 4
a904 4
			 (no_goto_news &&
			  url_type == NEWS_URL_TYPE) ||
			 (no_goto_nntp &&
			  url_type == NNTP_URL_TYPE) ||
d906 2
a907 2
			 (no_goto_rlogin &&
			  url_type == RLOGIN_URL_TYPE) ||
d909 2
a910 2
			 (no_goto_snews &&
			  url_type == SNEWS_URL_TYPE) ||
d912 18
a929 21
			 (no_goto_telnet &&
			  url_type == TELNET_URL_TYPE) ||
			 (no_goto_tn3270 &&
			  url_type == TN3270_URL_TYPE) ||
			 (no_goto_wais &&
			  url_type == WAIS_URL_TYPE))) {
			/*
			 * Some schemes are not acceptable from server
			 * redirections.  - KW & FM
			 */
			HTAlert(ILLEGAL_REDIRECTION_URL);
			if (LYCursesON) {
			    HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE,
				       use_this_url_instead);
			} else {
			    fprintf(stderr,
				    WWW_ILLEGAL_URL_MESSAGE,
				    use_this_url_instead);
			}
			FREE(use_this_url_instead);
			return (NULLFILE);
a930 20
		    if ((pound = findPoundSelector(doc->address)) != NULL
			&& findPoundSelector(use_this_url_instead) == NULL) {
			/*
			 * Our requested URL had a fragment associated with it,
			 * and the redirection URL doesn't, so we'll append the
			 * fragment associated with the original request.  If
			 * it's bogus for the redirection URL, we'll be
			 * positioned at the top of that document, so there's
			 * no harm done.  - FM
			 */
			CTRACE((tfp,
				"getfile: Adding fragment '%s' to redirection URL.\n",
				pound));
			StrAllocCat(use_this_url_instead, pound);
		    }
		    CTRACE_SLEEP(MessageSecs);
		    HTUserMsg2(WWW_USING_MESSAGE, use_this_url_instead);
		    CTRACE((tfp, "\n"));
		    StrAllocCopy(doc->address,
				 use_this_url_instead);
d932 4
a935 6
		    if (redirect_post_content == FALSE) {
			/*
			 * Freeing the content also yields a GET request.  - FM
			 */
			LYFreePostData(doc);
		    }
d937 6
a942 2
		     * Go to top to check for URL's which get special handling
		     * and/or security checks in Lynx.  - FM
d944 4
a947 1
		    goto Try_Redirected_URL;
d949 11
a959 2
		if (HTNoDataOK) {
		    return (NULLFILE);
d961 9
d972 1
d983 13
a995 2
	    {
		char *pound;
d998 2
a999 1
		 * Check for a #fragment selector.
d1001 34
a1034 1
		pound = findPoundSelector(doc->address);
d1036 8
d1045 1
a1045 2
		 * Check to see if there is a temp file waiting for us to
		 * download.
d1047 11
a1057 3
		if (WWW_Download_File) {
		    HTParentAnchor *tmpanchor = HTAnchor_findAddress(&WWWDoc);
		    char *fname = NULL;
d1059 4
a1062 8
		    /*
		     * Check for a suggested filename from the
		     * Content-Disposition header.  - FM
		     */
		    if (HTAnchor_SugFname(tmpanchor) != NULL) {
			StrAllocCopy(fname, HTAnchor_SugFname(tmpanchor));
		    } else {
			StrAllocCopy(fname, doc->address);
d1065 1
a1065 3
		     * Check whether this is a compressed file, which we don't
		     * uncompress for downloads, and adjust any suffix
		     * appropriately.  - FM
d1067 1
a1067 59
		    HTCheckFnameForCompression(&fname, tmpanchor, FALSE);

		    if (LYdownload_options(&fname,
					   WWW_Download_File) < 0) {
			FREE(fname);
			return (NOT_FOUND);
		    }
		    LYAddVisitedLink(doc);
		    StrAllocCopy(doc->address, fname);
		    FREE(fname);
		    doc->internal_link = FALSE;
		    WWWDoc.address = doc->address;
		    LYFreePostData(doc);
		    WWWDoc.post_data = NULL;
		    WWWDoc.post_content_type = NULL;
		    WWWDoc.bookmark = doc->bookmark = FALSE;
		    WWWDoc.isHEAD = doc->isHEAD = FALSE;
		    WWWDoc.safe = doc->safe = FALSE;
		    HTOutputFormat = WWW_PRESENT;
		    if (!HTLoadAbsolute(&WWWDoc)) {
			return (NOT_FOUND);
		    } else {
			return (NORMAL);
		    }

		} else if (pound == NULL &&
		    /*
		     * HTAnchor hash-table searches are now case-sensitive
		     * (hopefully, without anchor deletion problems), so this
		     * is too.  - FM
		     */
			   (strcmp(doc->address,
				   HTLoadedDocumentURL()) ||
		    /*
		     * Also check the post_data elements.  - FM
		     */
			    !BINEQ(doc->post_data,
				   HTLoadedDocumentPost_data()) ||
		    /*
		     * Also check the isHEAD element.  - FM
		     */
			    doc->isHEAD != HTLoadedDocumentIsHEAD())) {
		    /*
		     * Nothing needed to be shown.
		     */
		    LYAddVisitedLink(doc);
		    return (NULLFILE);

		} else {
		    if (pound != NULL) {
			if (!HTMainText) {	/* this should not happen... */
			    return (NULLFILE);	/* but it can. - kw */
			}
			/*
			 * May set www_search_result.
			 */
			HTFindPoundSelector(pound + 1);
		    }
		    return (NORMAL);
d1069 1
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d3 1
a3 1
#include <HTAnchor.h>	    /* Anchor class */
d36 1
a36 1
static int fix_httplike_urls (DocInfo *doc, UrlTypes type);
d47 4
a50 4
 *  getfile is the main mechanism to load a new document (or a previously
 *  loaded one whose rendering is cached in a HText structure) from
 *  mainloop, nearly everything goes through it.
 *  It should return one of the values
d63 5
a67 5
 *  The distinction between NOT_FOUND and NULLFILE is not very crucial,
 *  but getting it right prevents mainloop from exiting with the wrong
 *  message if it happens for the first file, and from logging (or not
 *  logging) errors inappropriately with -traversal, and from sending
 *  bogus error mail with MAIL_SYSTEM_ERROR_LOGGING:TRUE. - kw
d69 1
a69 2
int getfile (
	DocInfo *	doc)
d74 1
a74 1
    DocAddress WWWDoc;  /* a WWW absolute doc address struct */
d77 1
a77 1
     *  Reset LYCancelDownload to prevent unwanted delayed effect. - KW
d85 1
a85 1
     *  Reset fake 'Z' to prevent unwanted delayed effect. - kw
d90 4
a93 4
     *  Reset redirection counter to prevent bogus TOO_MANY_REDIRECTIONS
     *  in rare situations if the previous cycle got to the limit, but
     *  did not fail for that reason because the URL of the final location
     *  was handled specially, not via HTLoadAbsolute. - kw
d97 1
a97 1
Try_Redirected_URL:
d99 1
a99 1
     *  Load the WWWDoc struct in case we need to use it.
d109 1
a109 1
     *  Reset HTPermitRedir, it has done its job if it was set. - kw
d114 1
a114 1
     *  Reset WWW_Download_File just in case.
d119 1
a119 1
     *  Reset redirect_post_content just in case.
d124 7
a130 9
     *  This flag is a hack to allow us to pass on the fact
     *  that 'no data' may not really be an error although
     *  HTLoadAbsolute returned NO.  There should be a better
     *  way...  HT_NO_DATA should always mean 'not data but
     *  not an error', and be passed on to us as that, but
     *  current usage if HT_NO_DATA vs HT_NOT_LOADED has
     *  to be reviewed everywhere.
     *  Anyway, some protocol module can set it to say
     *  'I really mean it', we have to reset it here. - kw
d134 1
a134 1
    CTRACE((tfp,"getfile: getting %s\n\n",doc->address));
d137 3
a139 5
     *  Protect against denial of service attacks
     *  via the port 19 CHARGEN service, and block
     *  connections to the port 25 ESMTP service.
     *  Also reject any likely spoof attempts via
     *  wrap arounds at 65536. - FM
d155 1
a155 1
		    return(NULLFILE);
d160 1
a160 1
		    return(NULLFILE);
d164 2
a165 1
		    HTSprintf0(&msg, PORT_INVALID, (unsigned long)value);
d169 1
a169 1
		    return(NULLFILE);
d174 1
a174 1
		return(NULLFILE);
d182 2
a183 2
     *  Check to see if this is a universal document ID
     *  that lib WWW wants to handle.
d185 1
a185 1
     *  Some special URL's we handle ourselves. :)
d198 2
a199 2
		  0==STRNADDRCOMP(WWWDoc.address, helpfilepath,
				  strlen(helpfilepath)) ||
d201 2
a202 2
		   0==STRNADDRCOMP(WWWDoc.address, lynxlistfile,
				  strlen(lynxlistfile))) ||
d204 2
a205 2
		   0==STRNADDRCOMP(WWWDoc.address, lynxlinksfile,
				  strlen(lynxlinksfile))) ||
d207 2
a208 2
		   0==STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
				  strlen(lynxjumpfile))))) {
d210 1
a210 1
		return(NULLFILE);
d215 1
a215 1
	     *	Only traverse http URLs.
d219 1
a219 1
		return(NULLFILE);
d222 2
a223 2
	    if (!(0==strncmp(startrealm, WWWDoc.address,
			     strlen(startrealm)) ||
d245 2
a246 2
		  0==STRNADDRCOMP(WWWDoc.address, helpfilepath,
				  strlen(helpfilepath)) ||
d248 2
a249 2
		   0==STRNADDRCOMP(WWWDoc.address, lynxlistfile,
				  strlen(lynxlistfile))) ||
d251 2
a252 2
		   0==STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
				  strlen(lynxjumpfile))))) {
d254 1
a254 1
		return(NULLFILE);
d276 1
a276 1
	LYSyslog (doc->address);
d282 1
a282 1
	    return(NULLFILE);
d286 1
a286 1
	    return(NULLFILE);
d289 1
a289 1
	    return(printfile(doc));
d294 1
a294 1
	    return(postoptions(doc));
d298 1
a298 1
	    !no_lynxcfg_info) {
d302 1
a302 1
	    return(lynx_cfg_infopage(doc));
d306 1
a306 1
	    !no_compileopts_info) {
d310 1
a310 1
	    return(lynx_compile_opts(doc));
d321 3
a323 4
		return(NULLFILE);
	    } else if (!news_ok && (
		url_type == NEWSPOST_URL_TYPE ||
		url_type == NEWSREPLY_URL_TYPE)) {
d325 1
a325 1
		return(NULLFILE);
d328 1
a328 1
		return(NULLFILE);
d337 3
a339 4
		 *  The temporary file was saved to disk via a
		 *  rename(), so we can't access the temporary
		 *  file again via the download menu.  Clear the
		 *  flag, and return NULLFILE to pop. - FM
d342 1
a342 1
		return(NULLFILE);
d345 1
a345 1
	    return(NORMAL);
d349 12
a360 12
	       local_dired(doc);
	       WWWDoc.address = doc->address;
	       WWWDoc.post_data = doc->post_data;
	       WWWDoc.post_content_type = doc->post_content_type;
	       WWWDoc.bookmark = doc->bookmark;
	       WWWDoc.isHEAD = doc->isHEAD;
	       WWWDoc.safe = doc->safe;

	       if (!HTLoadAbsolute(&WWWDoc)) {
		   return(NOT_FOUND);
	       }
	       return(NORMAL);
d364 1
a364 1
	    return(NULLFILE);
d370 1
d380 4
a383 5
		 *  Don't send a Referer header if the URL is
		 *  the reply from a form with method GET, in
		 *  case the content has personal data (e.g.,
		 *  a password or credit card number) which
		 *  would become visible in logs. - FM
d385 2
a386 2
		 *  Changed 1999-11-01 to be controlled by
		 *  REFERER_WITH_QUERY option. - kw
d388 1
a388 1
		if (LYRefererWithQuery == 'S') { /* SEND */
d390 2
a391 2
		} else if (LYRefererWithQuery == 'P') { /* PARTIAL */
		    FREE(LYRequestReferer); /* just to be sure */
d393 5
a397 2
					       PARSE_ACCESS|PARSE_HOST|PARSE_STRICTPATH|PARSE_PUNCTUATION);
		} else { /* Everything else - don't send Referer */
d409 3
a411 4
	     *	'doc' will change to the new file
	     *	if we had a successful LYpop_num(),
	     *	and the return value will be FALSE
	     *	if we had a cancel. - FM
d415 1
a415 1
		return(NOT_FOUND);
d419 1
a419 1
	     *	We changed it so reload.
d437 1
a437 1
		return(NOT_FOUND);
d439 1
a439 1
	    return(NORMAL);
d446 1
a446 1
			 doc->address+9, ALWAYS_EXEC_PATH)) {
d452 2
a453 2
		       exec_ok(HTLoadedDocumentURL(),
			       doc->address+9, EXEC_PATH))) {
d458 1
a458 1
		 *  Bug puts slash on end if none is in the string.
d460 2
a461 1
		char *last_slash = strrchr(doc->address,'/');
d463 2
a464 2
		 == (int)strlen(doc->address) - 1)
		    doc->address[strlen(doc->address)-1] = '\0';
d467 1
a467 1
		 *  Convert '~' to $HOME.
d471 4
a474 4
				   cp - doc->address,
				   doc->address,
				   wwwName(Home_Dir()),
				   cp + 1);
d479 1
a479 1
		 *  Show URL before executing it.
d484 1
a484 1
		 *  Run the command.
d486 2
a487 2
		if (strstr(p,"//") == p+9)
		    LYSystem(p+11);
d489 1
a489 1
		    LYSystem(p+9);
d494 1
a494 1
		     *	Make sure user gets to see screen output.
d511 1
a511 1
	     } else {
d515 2
a516 2
			EXECUTION_DISABLED_FOR_FILE,
			key_for_func(LYK_OPTIONS));
d519 1
a519 1
	     }
d521 1
a521 1
	     HTUserMsg(EXECUTION_NOT_COMPILED);
d523 1
a523 1
	     return(NULLFILE);
d535 1
a535 1
			title = HTAnchor_title(tmpanchor);
d548 1
a548 1
		cp = strchr(doc->address,':')+1;
d551 2
a552 2
			       (char *)HTMainAnchor->address :
			       (char *)doc->address),
d555 1
a555 1
			       HTMainAnchor->message_id : NULL);
d558 1
a558 1
	    return(NULLFILE);
d560 4
a563 4
	/*
	 *  From here on we could have a remote host,
	 *  so check if that's allowed.
	 */
d575 1
a575 1
	    return(NULLFILE);
d577 3
a579 3
	/*
	 *  Disable www telnet access if not telnet_ok.
	 */
d583 2
a584 1
	    char * proxy;
d587 2
a588 2
		return(NULLFILE);
	    } else if (no_telnet_port && strchr(doc->address+7, ':')) {
d590 11
a600 9
		return(NULLFILE);
	    /*
	     *  Detect weird case where interactive protocol would
	     *  be proxied, and to a non-interactive protocol at that.
	     */
	    } else if ((proxy = LYGetEnv(
		(url_type==TN3270_URL_TYPE) ? "tn3270_proxy" :
		(url_type==TELNET_GOPHER_URL_TYPE) ? "gopher_proxy" :
		"telnet_proxy")) != NULL &&
d614 1
a614 1
		return(NULLFILE);
d617 3
a619 3
	/*
	 *  Disable www news access if not news_ok.
	 */
d621 2
a622 3
	} else if (!news_ok && (
	    url_type == NEWS_URL_TYPE ||
	    url_type == NNTP_URL_TYPE)) {
d624 1
a624 1
	    return(NULLFILE);
d628 2
a629 1
	    char * proxy;
d632 6
a637 7
		return(NULLFILE);
	    /*
	     *  Detect weird case where interactive protocol would
	     *  be proxied, and to a non-interactive protocol at that.
	     */
	    } else if ((proxy = LYGetEnv(
		"rlogin_proxy")) != NULL &&
d651 1
a651 1
		return(NULLFILE);
d654 4
a657 5
	/*
	 *  If it's a gopher index type and there isn't a search
	 *  term already attached then do this.  Otherwise
	 *  just load it!
	 */
d659 1
a659 1
		   strchr(doc->address,'?') == NULL) {
d661 1
d663 2
a664 3
	     *	Make sure we don't have a gopher+ escaped tab
	     *	instead of a gopher0 question mark delimiting
	     *	the search term. - FM
d682 2
a683 3
	     *	Load it because the do_www_search routine
	     *	uses the base url of the currently loaded
	     *	document :(
d686 1
a686 1
		return(NOT_FOUND);
d703 1
a703 1
	    return(status);
d705 1
a705 2
	}
	{
d707 2
a708 2
	     && (url_type == FTP_URL_TYPE
	      || url_type == NCFTP_URL_TYPE)) {
d710 1
a710 1
		return(NULLFILE);
d714 7
a720 6
		char *tmp=NULL;
	       /*
		*  If tuple's Path=GET%20/... convert to an http URL.
		*/
		if ((cp=strchr(doc->address+9, '/')) != NULL &&
		   0==strncmp(++cp, "hGET%20/", 8)) {
d723 1
a723 1
				doc->address));
d725 5
a729 5
		    StrAllocCat(tmp, doc->address+9);
		   /*
		    *  If the port is defaulted, it should stay 70.
		    */
		    if (strchr(tmp+6, ':') == NULL) {
d731 1
a731 1
			tmp[strlen(tmp)-4] = ':';
d733 2
a734 2
		    if (strlen(cp+7) > 1)
			StrAllocCat(tmp, cp+8);
d737 1
a737 1
				doc->address));
d748 1
a748 1
	    WWWDoc.address = doc->address;  /* possible reload */
d755 1
d772 1
a772 1
		StrAllocCat(bibpTmp, doc->address+5); /* USIN after bibp: */
d781 5
a785 6
		 *  If a file URL has a '~' as the lead character
		 *  of its first symbolic element, convert the '~'
		 *  to Home_Dir(), then append the rest of of path,
		 *  if present, skipping "user" if "~user" was
		 *  entered, simplifying, and eliminating any
		 *  residual relative elements. - FM
d788 2
a789 2
			   PARSE_PATH+PARSE_ANCHOR+PARSE_PUNCTUATION))
		      != NULL) &&
d795 1
a795 1
				doc->address));
d810 1
a810 1
				doc->address));
d829 1
a829 1
		 *  Check for redirection.
d836 13
a848 16
			 *  The server did not return a complete
			 *  URL in its Location: header, probably
			 *  due to a FORM or other CGI script written
			 *  by someone who doesn't know that the http
			 *  protocol requires that it be a complete
			 *  URL, or using a server which does not treat
			 *  such a redirect string from the script as
			 *  an instruction to resolve it versus the
			 *  initial request, check authentication with
			 *  that URL, and then act on it without
			 *  returning redirection to us.  We'll
			 *  violate the http protocol and resolve it
			 *  ourselves using the URL of the original
			 *  request as the BASE, rather than doing
			 *  the RIGHT thing and returning an invalid
			 *  address message. - FM
d861 3
a863 3
		       (url_type == LYNXDOWNLOAD_URL_TYPE ||
			url_type == LYNXEXEC_URL_TYPE ||
			url_type == LYNXPROG_URL_TYPE ||
d865 1
a865 1
			url_type == LYNXDIRED_URL_TYPE ||
d867 14
a880 14
			url_type == LYNXPRINT_URL_TYPE ||
			url_type == LYNXOPTIONS_URL_TYPE ||
			url_type == LYNXCFG_URL_TYPE ||
			url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
			url_type == LYNXHIST_URL_TYPE ||
			url_type == LYNXCOOKIE_URL_TYPE ||
			url_type == LYNXMESSAGES_URL_TYPE ||
			(LYValidate &&
			 url_type != HTTP_URL_TYPE &&
			 url_type != HTTPS_URL_TYPE) ||
			((no_file_url || no_goto_file) &&
			 url_type == FILE_URL_TYPE) ||
			(no_goto_lynxcgi &&
			 url_type == LYNXCGI_URL_TYPE) ||
d882 2
a883 2
			(no_goto_bibp &&
			 url_type == BIBP_URL_TYPE) ||
d885 15
a899 15
			(no_goto_cso &&
			 url_type == CSO_URL_TYPE) ||
			(no_goto_finger &&
			 url_type == FINGER_URL_TYPE) ||
			(no_goto_ftp &&
			 (url_type == FTP_URL_TYPE ||
			  url_type == NCFTP_URL_TYPE)) ||
			(no_goto_gopher &&
			 url_type == GOPHER_URL_TYPE) ||
			(no_goto_http &&
			 url_type == HTTP_URL_TYPE) ||
			(no_goto_https &&
			 url_type == HTTPS_URL_TYPE) ||
			(no_goto_mailto &&
			 url_type == MAILTO_URL_TYPE) ||
d901 4
a904 4
			(no_goto_news &&
			 url_type == NEWS_URL_TYPE) ||
			(no_goto_nntp &&
			 url_type == NNTP_URL_TYPE) ||
d906 2
a907 2
			(no_goto_rlogin &&
			 url_type == RLOGIN_URL_TYPE) ||
d909 2
a910 2
			(no_goto_snews &&
			 url_type == SNEWS_URL_TYPE) ||
d912 6
a917 6
			(no_goto_telnet &&
			 url_type == TELNET_URL_TYPE) ||
			(no_goto_tn3270 &&
			 url_type == TN3270_URL_TYPE) ||
			(no_goto_wais &&
			 url_type == WAIS_URL_TYPE))) {
d919 2
a920 2
			 *  Some schemes are not acceptable from
			 *  server redirections. - KW & FM
d932 1
a932 1
			return(NULLFILE);
d935 1
a935 1
		     && findPoundSelector(use_this_url_instead) == NULL) {
d937 6
a942 7
			 *  Our requested URL had a fragment
			 *  associated with it, and the redirection
			 *  URL doesn't, so we'll append the fragment
			 *  associated with the original request.  If
			 *  it's bogus for the redirection URL, we'll
			 *  be positioned at the top of that document,
			 *  so there's no harm done. - FM
d945 2
a946 2
		"getfile: Adding fragment '%s' to redirection URL.\n",
			    pound));
d953 1
a953 1
				use_this_url_instead);
d957 1
a957 2
			 *  Freeing the content also yields
			 *  a GET request. - FM
d962 2
a963 3
		     *	Go to top to check for URL's which get
		     *	special handling and/or security checks
		     *	in Lynx. - FM
d968 1
a968 1
		    return(NULLFILE);
d970 1
a970 1
		return(NOT_FOUND);
d976 5
a980 7
	     *	Some URL's don't actually return a document;
	     *	compare doc->address with the document that is
	     *	actually loaded and return NULLFILE if not
	     *	loaded.  If www_search_result is not -1
	     *	then this is a reference to a named anchor
	     *	within the same document; do NOT return
	     *	NULLFILE in that case.
d984 1
d986 1
a986 1
		 *  Check for a #fragment selector.
d991 2
a992 2
		 *  Check to see if there is a temp
		 *  file waiting for us to download.
d999 2
a1000 2
		     *	Check for a suggested filename from
		     *	the Content-Disposition header. - FM
d1008 3
a1010 3
		     *	Check whether this is a compressed file,
		     *	which we don't uncompress for downloads,
		     *	and adjust any suffix appropriately. - FM
d1017 1
a1017 1
			return(NOT_FOUND);
d1032 1
a1032 1
			return(NOT_FOUND);
d1034 1
a1034 1
			return(NORMAL);
d1038 5
a1042 6
			   /*
			    *  HTAnchor hash-table searches are now
			    *  case-sensitive (hopefully, without
			    *  anchor deletion problems), so this
			    *  is too. - FM
			    */
a1044 9
			   /*
			    *  Also check the post_data elements. - FM
			    */
			   !BINEQ(doc->post_data,
				  HTLoadedDocumentPost_data()) ||
			   /*
			    *  Also check the isHEAD element. - FM
			    */
			   doc->isHEAD != HTLoadedDocumentIsHEAD())) {
d1046 10
a1055 1
		     *	Nothing needed to be shown.
d1058 1
a1058 1
		    return(NULLFILE);
d1062 2
a1063 2
			if (!HTMainText) { /* this should not happen... */
			    return(NULLFILE); /* but it can. - kw */
d1066 1
a1066 1
			 *  May set www_search_result.
d1068 1
a1068 1
			HTFindPoundSelector(pound+1);
d1070 1
a1070 1
		    return(NORMAL);
d1077 2
a1078 2
	CTRACE((tfp,"\n"));
	return(NULLFILE);
d1083 5
a1087 5
 *  Set source mode for the next retrieval via getfile or HTreparse_document.
 *  mode == -1: force normal presentation
 *  mode ==  1: force source presentation
 *  mode ==  0: reset to normal if it was set to source
 *  - kw
d1089 1
a1089 2
void srcmode_for_next_retrieval (
    int	mode)
d1118 18
a1135 14
 *  The user wants to select a link or page by number.
 *  If follow_link_number returns DO_LINK_STUFF do_link
 *   will be run immediately following its execution.
 *  If follow_link_number returns DO_GOTOLINK_STUFF
 *   it has updated the passed in doc for positioning on a link.
 *  If follow_link_number returns DO_GOTOPAGE_STUFF
 *   it has set doc->line to the top line of the desired page
 *   for displaying that page.
 *  If follow_link_number returns PRINT_ERROR an error message
 *   will be given to the user.
 *  If follow_link_number returns DO_FORMS_STUFF some forms stuff
 *   will be done. (Not yet implemented.)
 *  If follow_link_number returns DO_NOTHING nothing special
 *   will run after it.
d1137 4
a1140 5
int follow_link_number (
	int		c,
	int		cur,
	DocInfo *	doc,
	int *		num)
d1147 1
a1147 1
    int curline = *num; /* passed in from mainloop() */
d1149 1
a1149 1
    CTRACE((tfp,"follow_link_number(%d,%d,...)\n",c,cur));
d1155 1
a1155 1
     *	Get the number, possibly with a letter suffix, from the user.
d1159 1
a1159 1
	return(DO_NOTHING);
d1162 1
a1162 1
    while ( isdigit(UCH(*p)) )
d1164 4
a1167 3
    c = *p; /* reuse c; 0 or g or p or + or - */
    switch ( c ) {
    case '+': case '-':
d1169 2
a1170 1
	rel = c; c = *++p;
d1180 1
a1180 1
    CTRACE((tfp,"  temp=%s, *num=%d, rel='%c'\n",temp,*num,rel));
d1182 2
a1183 2
     *	Check if we had a 'p' or 'P' following the number as
     *	a flag for displaying the page with that number. - FM
d1185 5
a1189 5
    if (( c == 'p' || c == 'P') && display_lines == 0) {
	CTRACE((tfp," curline=%d, LYlines=%d, display too small!\n",
	       curline,LYlines));
	return(PRINT_ERROR);
    } else if ( c == 'p' || c == 'P' ) {
d1192 2
a1193 2
		(((nlines + 1) + (display_lines - 1))/(display_lines))
						    : 1;
d1195 5
a1199 4
		     (((curline + 1) + (display_lines - 1))/(display_lines))
						      : 1;
	CTRACE((tfp," nlines=%d, npages=%d, curline=%d, curpage=%d\n",
		nlines,npages,curline,curpage));
d1202 1
a1202 1
	if ( rel == '+' )
d1204 1
a1204 1
	else if ( rel == '-' )
d1207 4
a1210 4
				1 :
		((*num <= npages) ? (((*num - 1) * display_lines) + 1)
				  : (((npages - 1) * display_lines) + 1));
	return(DO_GOTOPAGE_STUFF);
d1214 2
a1215 2
     *	Check if we want to make the link corresponding to the
     *	number the current link, rather than ACTIVATE-ing it.
d1217 1
a1217 1
    want_go = (BOOL) ( c == 'g' || c == 'G' );
d1222 6
a1227 6
    if ( rel )
	*num = HTGetRelLinkNum( *num, rel, cur );
   /*
    *  If we have a valid number, act on it.
    */
   if (*num > 0) {
d1232 6
a1237 8
	 *  Get the lname, and hightext, directly from www
	 *  structures and add it to the cur link so that
	 *  we can pass it transparently on to getfile(),
	 *  and load new_top and new_link if we instead want
	 *  to make the link number current.  These things
	 *  are done so that a link can be selected anywhere
	 *  in the current document, whether it is displayed
	 *  on the screen or not!
d1249 1
a1249 1
	    return(DO_LINK_STUFF);
d1253 1
a1253 1
	    return(DO_GOTOLINK_STUFF);
d1256 1
a1256 1
	    return(DO_LINK_STUFF);
d1258 1
a1258 1
	    return(PRINT_ERROR);
d1261 1
a1261 1
	return(PRINT_ERROR);
d1268 4
a1271 4
	char *src;
	char *path;
	int type;
	struct trust *next;
d1274 3
a1276 2
static struct trust trusted_exec_default = {
  "file://localhost/",	"",	EXEC_PATH,		NULL
d1278 3
a1280 2
static struct trust always_trusted_exec_default = {
  "none",		"",	ALWAYS_EXEC_PATH,	NULL
d1282 3
a1284 2
static struct trust trusted_cgi_default = {
  "",			"",	CGI_PATH,		NULL
d1292 1
a1292 1
static void LYTrusted_free (void)
d1334 2
a1335 3
void add_trusted (
	char *		str,
	int		type)
d1358 1
a1358 1
    tp = (struct trust *)malloc(sizeof(*tp));
d1388 1
a1388 1
 *  Check to see if the supplied paths is allowed to be executed.
d1390 3
a1392 4
BOOLEAN exec_ok (
	const char *	source,
	const char *	linktext,
	int		type)
d1400 1
a1400 1
     *	Always OK if it is a jump file shortcut.
d1406 1
a1406 1
     *	Choose the trust structure based on the type.
d1421 1
a1421 1
     *	Security: reject on relative path.
d1425 1
d1439 1
a1439 1
     *	Security: reject on relative path.
d1447 1
a1447 1
     *	Security: reject on strange character.
d1458 2
a1459 2
		    BADCHAR_IN_EXEC_LINK,
		    *cp);
d1467 1
a1467 1
check_tp_for_entry:
d1472 1
a1472 1
	    if (strstr(command,"//") == linktext) {
d1493 1
a1493 3
static int fix_httplike_urls (
	DocInfo *	doc,
	UrlTypes	type)
d1498 1
a1498 2
     *  If there's a fragment present, our simplistic methods won't
     *  work.  - kw
d1505 1
a1505 1
     *	If it's an ftp URL with a trailing slash, trim it off.
d1508 3
a1510 3
	LYIsHtmlSep(doc->address[strlen(doc->address)-1])) {
	char * proxy;
	char *path = HTParse(doc->address, "", PARSE_PATH|PARSE_PUNCTUATION);
d1513 1
a1513 1
	 *  If the path is a lone slash, we're done. - FM
d1524 1
a1524 1
	 *  If we're proxying ftp, don't trim anything. - KW
d1531 1
a1531 1
	 *  If we get to here, trim the trailing slash. - FM
d1555 1
a1555 1
     *	If there isn't a slash besides the two at the beginning, append one.
d1558 2
a1559 2
	if (!LYIsHtmlSep(*(slash-1)) || *(slash-2) != ':') {
	    return(0);
d1563 1
a1563 1
	    if ((slash-2) != strchr(doc->address, ':')) {
d1565 4
a1568 4
		 *  Turns out we were not looking at the right slash after all,
		 *  there must have been more than one "://" which is valid
		 *  at least for http URLs (later occurrences can be part of
		 *  a query string, for example), so leave this alone, too. - kw
d1570 1
a1570 1
		return(0);
d1574 3
a1576 4
		 *  If there is a question mark that appears to be part
		 *  of the hostname, don't append anything either. Leave
		 *  it to HTParse to interpret the question mark as ending
		 *  the hostname. - kw
d1578 1
a1578 1
		return(0);
d1587 1
a1587 1
    return(1);
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d36 1
a36 1
PRIVATE int fix_httplike_urls PARAMS((DocInfo *doc, UrlTypes type));
d44 1
a44 1
PUBLIC int HTNoDataOK = 0;
d69 2
a70 2
PUBLIC int getfile ARGS1(
	DocInfo *,	doc)
d533 1
a533 1
		CONST char *title;
d1100 2
a1101 2
PUBLIC void srcmode_for_next_retrieval ARGS1(
    int,	mode)
d1145 5
a1149 5
PUBLIC int follow_link_number ARGS4(
	int,		c,
	int,		cur,
	DocInfo *,	doc,
	int *,		num)
d1297 1
a1297 1
PRIVATE void LYTrusted_free NOARGS
d1339 3
a1341 3
PUBLIC void add_trusted ARGS2(
	char *,		str,
	int,		type)
d1396 4
a1399 4
PUBLIC BOOLEAN exec_ok ARGS3(
	CONST char *,	source,
	CONST char *,	linktext,
	int,		type)
d1402 2
a1403 2
    CONST char *cp;
    CONST char *allowed_extra_chars;
d1476 1
a1476 1
	    char CONST *command = linktext;
d1499 3
a1501 3
PRIVATE int fix_httplike_urls ARGS2(
	DocInfo *,	doc,
	UrlTypes,	type)
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a16 1
#include <LYHistory.h>
d30 2
d36 6
a41 4
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
#include <syslog.h>
#endif /* SYSLOG_REQUESTED_URLS */
d44 1
a44 5
PRIVATE int fix_http_urls PARAMS((document *doc));
extern char * WWW_Download_File;
#ifdef VMS
extern BOOLEAN LYDidRename;
#endif /* VMS */
d46 25
a70 2
PUBLIC BOOLEAN getfile ARGS1(
	document *,	doc)
d72 12
a83 4
	int url_type = 0;
	char *cp = NULL;
	char *temp = NULL;
	DocAddress WWWDoc;  /* a WWW absolute doc address struct */
d85 4
a88 7
	/*
	 *  Reset LYCancelDownload to prevent unwanted delayed effect. - KW
	 */
	if (LYCancelDownload) {
	    CTRACE(tfp, "getfile:    resetting LYCancelDownload to FALSE\n");
	    LYCancelDownload = FALSE;
	}
d90 7
a96 4
	/*
	 *  Reset fake 'Z' to prevent unwanted delayed effect. - kw
	 */
	LYFakeZap(NO);
d99 24
a122 9
	/*
	 *  Load the WWWDoc struct in case we need to use it.
	 */
	WWWDoc.address = doc->address;
	WWWDoc.post_data = doc->post_data;
	WWWDoc.post_content_type = doc->post_content_type;
	WWWDoc.bookmark = doc->bookmark;
	WWWDoc.isHEAD = doc->isHEAD;
	WWWDoc.safe = doc->safe;
d124 12
a135 4
	/*
	 *  Reset WWW_Download_File just in case.
	 */
	FREE(WWW_Download_File);
d137 1
a137 4
	/*
	 *  Reset redirect_post_content just in case.
	 */
	redirect_post_content = FALSE;
d139 10
a148 1
	CTRACE(tfp,"getfile: getting %s\n\n",doc->address);
d150 22
a171 38
	/*
	 *  Protect against denial of service attacks
	 *  via the port 19 CHARGEN service, and block
	 *  connections to the port 25 ESMTP service.
	 *  Also reject any likely spoof attempts via
	 *  wrap arounds at 65536. - FM
	 */
	if ((temp = HTParse(doc->address, "", PARSE_HOST)) != NULL &&
	    strlen(temp) > 3) {
	    char *cp1;

	    if ((cp1 = strchr(temp, '@@')) == NULL)
		cp1 = temp;
	    if ((cp = strrchr(cp1, ':')) != NULL) {
		long int value;

		cp++;
		if (sscanf(cp, "%ld", &value) == 1) {
		    if (value == 19 || value == 65555) {
			HTAlert(PORT_NINETEEN_INVALID);
			FREE(temp);
			return(NULLFILE);
		    }
		    if (value == 25 || value == 65561) {
			HTAlert(PORT_TWENTYFIVE_INVALID);
			FREE(temp);
			return(NULLFILE);
		    }
		    if (value > 65535 || value < 0) {
			char *msg = 0;
			HTSprintf0(&msg, PORT_INVALID, (unsigned long)value);
			HTAlert(msg);
			FREE(msg);
			FREE(temp);
			return(NULLFILE);
		    }
		} else if (isdigit((unsigned char)*cp)) {
		    HTAlert(URL_PORT_BAD);
d175 4
d181 3
a183 2
	cp = NULL;
	FREE(temp);
d185 106
a290 105
	/*
	 *  Check to see if this is a universal document ID
	 *  that lib WWW wants to handle.
	 *
	 *  Some special URL's we handle ourselves. :)
	 */
	if ((url_type = is_url(doc->address)) != 0) {
		if (LYValidate && !LYPermitURL) {
		    if (!(url_type == HTTP_URL_TYPE ||
			  url_type == HTTPS_URL_TYPE ||
			  url_type == LYNXHIST_URL_TYPE ||
			  url_type == LYNXKEYMAP_URL_TYPE ||
			  url_type == LYNXIMGMAP_URL_TYPE ||
			  url_type == LYNXCOOKIE_URL_TYPE ||
			  0==strncasecomp(WWWDoc.address, helpfilepath,
					  strlen(helpfilepath)) ||
			  (lynxlistfile != NULL &&
			   0==strncasecomp(WWWDoc.address, lynxlistfile,
					  strlen(lynxlistfile))) ||
			  (lynxlinksfile != NULL &&
			   0==strncasecomp(WWWDoc.address, lynxlinksfile,
					  strlen(lynxlinksfile))) ||
			  (lynxjumpfile != NULL &&
			   0==strncasecomp(WWWDoc.address, lynxjumpfile,
					  strlen(lynxjumpfile))))) {
			HTUserMsg(NOT_HTTP_URL_OR_ACTION);
			return(NULLFILE);
		    }
		}
		if (traversal) {
		    /*
		     *	Only traverse http URLs.
		     */
		    if (url_type != HTTP_URL_TYPE &&
			url_type != LYNXIMGMAP_URL_TYPE)
			return(NULLFILE);
		} else if (check_realm && !LYPermitURL && !LYJumpFileURL) {
		    if (!(0==strncmp(startrealm, WWWDoc.address,
				     strlen(startrealm)) ||
			  url_type == LYNXHIST_URL_TYPE ||
			  url_type == LYNXKEYMAP_URL_TYPE ||
			  url_type == LYNXIMGMAP_URL_TYPE ||
			  url_type == LYNXCOOKIE_URL_TYPE ||
			  url_type == LYNXPRINT_URL_TYPE ||
			  url_type == LYNXOPTIONS_URL_TYPE ||
			  url_type == LYNXCFG_URL_TYPE ||
			  url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
			  url_type == LYNXDOWNLOAD_URL_TYPE ||
			  url_type == MAILTO_URL_TYPE ||
			  url_type == NEWSPOST_URL_TYPE ||
			  url_type == NEWSREPLY_URL_TYPE ||
			  url_type == SNEWSPOST_URL_TYPE ||
			  url_type == SNEWSREPLY_URL_TYPE ||
			  (!LYUserSpecifiedURL &&
			   (url_type == LYNXEXEC_URL_TYPE ||
			    url_type == LYNXPROG_URL_TYPE ||
			    url_type == LYNXCGI_URL_TYPE)) ||
			  (WWWDoc.bookmark != NULL &&
			   *WWWDoc.bookmark != '\0') ||
			  0==strncasecomp(WWWDoc.address, helpfilepath,
					  strlen(helpfilepath)) ||
			  (lynxlistfile != NULL &&
			   0==strncasecomp(WWWDoc.address, lynxlistfile,
					  strlen(lynxlistfile))) ||
			  (lynxjumpfile != NULL &&
			   0==strncasecomp(WWWDoc.address, lynxjumpfile,
					  strlen(lynxjumpfile))))) {
			HTUserMsg(NOT_IN_STARTING_REALM);
			return(NULLFILE);
		    }
		}
		if (WWWDoc.post_data &&
		    url_type != HTTP_URL_TYPE &&
		    url_type != HTTPS_URL_TYPE &&
		    url_type != LYNXCGI_URL_TYPE &&
		    url_type != LYNXIMGMAP_URL_TYPE &&
		    url_type != GOPHER_URL_TYPE &&
		    url_type != CSO_URL_TYPE &&
		    url_type != PROXY_URL_TYPE &&
		    url_type != LYNXOPTIONS_URL_TYPE &&
		    !(url_type == FILE_URL_TYPE &&
		      *(LYlist_temp_url()) &&
		      !strncmp(WWWDoc.address, LYlist_temp_url(),
			       strlen(LYlist_temp_url())))) {
		    CTRACE(tfp, "getfile: dropping post_data!\n");
		    HTAlert(IGNORED_POST);
		    FREE(doc->post_data);
		    FREE(doc->post_content_type);
		    WWWDoc.post_data = NULL;
		    WWWDoc.post_content_type = NULL;
		}
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
		syslog(LOG_INFO|LOG_LOCAL5, "%s", doc->address);
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */
		if (url_type == UNKNOWN_URL_TYPE ||
		    url_type == AFS_URL_TYPE ||
		    url_type == PROSPERO_URL_TYPE) {
		    HTAlert(UNSUPPORTED_URL_SCHEME);
		    return(NULLFILE);

		} else if (url_type == DATA_URL_TYPE) {
		    HTAlert(UNSUPPORTED_DATA_URL);
		    return(NULLFILE);
d292 2
a293 2
		} else if (url_type == LYNXPRINT_URL_TYPE) {
		    return(printfile(doc));
d296 3
a298 3
		} else if (url_type == LYNXOPTIONS_URL_TYPE) {
		    /* proceed forms-based options menu */
		    return(postoptions(doc));
d301 6
a306 3
		} else if (url_type == LYNXCFG_URL_TYPE) {
		    /* show/change/reload lynx.cfg settings */
		    return(lynx_cfg_infopage(doc));
d309 6
a314 3
		} else if (url_type == LYNXCOMPILE_OPTS_URL_TYPE) {
		    /* show compile-time settings */
		    return(lynx_compile_opts(doc));
a316 4
		} else if (url_type == LYNXMESSAGES_URL_TYPE) {
		    /* show list of recent statusline messages */
		    return(LYshow_statusline_messages(doc));

d318 17
a334 12
		} else if (url_type == NEWSPOST_URL_TYPE ||
			   url_type == NEWSREPLY_URL_TYPE ||
			   url_type == SNEWSPOST_URL_TYPE ||
			   url_type == SNEWSREPLY_URL_TYPE) {

		    if (no_newspost) {
			HTUserMsg(NEWSPOSTING_DISABLED);
			return(NULLFILE);
		    } else {
			HTLoadAbsolute(&WWWDoc);
			return(NULLFILE);
		    }
d337 2
a338 2
		} else if (url_type == LYNXDOWNLOAD_URL_TYPE) {
		    LYDownload(doc->address);
d340 10
a349 14
		    if (LYDidRename) {
			/*
			 *  The temporary file was saved to disk via a
			 *  rename(), so we can't access the temporary
			 *  file again via the download menu.  Clear the
			 *  flag, and return NULLFILE to pop. - FM
			 */
			LYDidRename = FALSE;
			return(NULLFILE);
		    } else {
			return(NORMAL);
		    }
#else
		    return(NORMAL);
d351 2
a352 1
		} else if (url_type == LYNXDIRED_URL_TYPE) {
d354 14
a367 19
		    if (no_dired_support) {
		       HTUserMsg(DIRED_DISABLED);
		       return(NULLFILE);
		    } else {
		       local_dired(doc);
		       WWWDoc.address = doc->address;
		       WWWDoc.post_data = doc->post_data;
		       WWWDoc.post_content_type = doc->post_content_type;
		       WWWDoc.bookmark = doc->bookmark;
		       WWWDoc.isHEAD = doc->isHEAD;
		       WWWDoc.safe = doc->safe;

		       if (!HTLoadAbsolute(&WWWDoc))
			   return(NOT_FOUND);
		       return(NORMAL);
		    }
#else
		    HTUserMsg(DIRED_DISABLED);
		    return(NULLFILE);
d369 3
d373 48
a420 11
		} else if (url_type == LYNXHIST_URL_TYPE) {
		    /*
		     *	'doc' will change to the new file
		     *	if we had a successful LYpop_num(),
		     *	and the return value will be FALSE
		     *	if we had a cancel. - FM
		     */
		    if ((historytarget(doc) == FALSE) ||
			!doc || !doc->address) {
			return(NOT_FOUND);
		    }
d422 9
a430 9
		    /*
		     *	We changed it so reload.
		     */
		    WWWDoc.address = doc->address;
		    WWWDoc.post_data = doc->post_data;
		    WWWDoc.post_content_type = doc->post_content_type;
		    WWWDoc.bookmark = doc->bookmark;
		    WWWDoc.isHEAD = doc->isHEAD;
		    WWWDoc.safe = doc->safe;
d432 3
a434 3
		    if (doc->internal_link && !reloading) {
			LYinternal_flag = TRUE;
		    }
d437 7
a443 4
		    if (!HTLoadAbsolute(&WWWDoc)) {
			return(NOT_FOUND);
		    }
		    return(NORMAL);
d445 2
a446 2
		} else if (url_type == LYNXEXEC_URL_TYPE ||
			   url_type == LYNXPROG_URL_TYPE) {
d448 10
a457 10
		    if (no_exec &&
			!exec_ok(HTLoadedDocumentURL(),
				 doc->address+9, ALWAYS_EXEC_PATH)) {
			HTUserMsg(EXECUTION_DISABLED);
		    } else if (no_bookmark_exec &&
			       HTLoadedDocumentBookmark()) {
			HTUserMsg(BOOKMARK_EXEC_DISABLED);
		    } else if (local_exec || (local_exec_on_local_files &&
			       exec_ok(HTLoadedDocumentURL(),
				       doc->address+9, EXEC_PATH))) {
d459 1
a459 1
			char *p, addressbuf[1024];
d461 33
a493 7
			/*
			 *  Bug puts slash on end if none is in the string.
			 */
			char *last_slash = strrchr(doc->address,'/');
			if (last_slash - doc->address
			 == (int)strlen(doc->address) - 1)
			    doc->address[strlen(doc->address)-1] = '\0';
d495 4
a498 28
			p = doc->address;
			/*
			 *  Convert '~' to $HOME.
			 */
			if ((cp = strchr(doc->address, '~'))) {
			    strncpy(addressbuf, doc->address, cp-doc->address);
			    addressbuf[cp - doc->address] = '\0';
			    p = wwwName(Home_Dir());
			    strcat(addressbuf, p);
			    strcat(addressbuf, cp+1);
			    p = addressbuf;
			}
			/*
			 *  Show URL before executing it.
			 */
			HTInfoMsg(doc->address);
			stop_curses();
			/*
			 *  Run the command.
			 */
			if (strstr(p,"//") == p+9)
			    LYSystem(p+11);
			else
			    LYSystem(p+9);
			if (url_type != LYNXPROG_URL_TYPE) {
			    /*
			     *	Make sure user gets to see screen output.
			     */
d500 1
a500 1
			    signal(SIGINT, SIG_IGN);
d502 3
a504 3
			    printf("\n%s", RETURN_TO_LYNX);
			    fflush(stdout);
			    LYgetch();
d506 1
a506 1
			    HadVMSInterrupt = FALSE;
d508 5
a512 3
			}
			start_curses();
			LYAddVisitedLink(doc);
d514 2
a515 2
		     } else {
			char *buf = 0;
d517 6
a522 6
			HTSprintf0(&buf,
				EXECUTION_DISABLED_FOR_FILE,
				key_for_func(LYK_OPTIONS));
			HTAlert(buf);
			FREE(buf);
		     }
d524 1
a524 1
		     HTUserMsg(EXECUTION_NOT_COMPILED);
d526 1
a526 1
		     return(NULLFILE);
d528 19
a546 3
		} else if (url_type == MAILTO_URL_TYPE) {
		    if (no_mail) {
			HTUserMsg(MAIL_DISABLED);
a547 4
			HTParentAnchor *tmpanchor;
			CONST char *title;
			char *tmptitle = NULL;

a548 26
			if ((tmpanchor = HTAnchor_parent(
						HTAnchor_findAddress(&WWWDoc)
							)) != NULL &&
			    HTAnchor_title(tmpanchor)) {
				title = HTAnchor_title(tmpanchor);
			} else if (HTMainAnchor && !LYUserSpecifiedURL) {
			    title = HTAnchor_subject(HTMainAnchor);
			    if (title && *title) {
				if (strncasecomp(title, "Re:", 3)) {
				    StrAllocCopy(tmptitle, "Re: ");
				    StrAllocCat(tmptitle, title);
				    title = tmptitle;
				}
			    } else {
				title = "";
			    }
			}
			cp = (char *)strchr(doc->address,':')+1;
			reply_by_mail(cp,
				      ((HTMainAnchor && !LYUserSpecifiedURL) ?
				       (char *)HTMainAnchor->address :
				       (char *)doc->address),
				      title,
				      (HTMainAnchor && !LYUserSpecifiedURL) ?
				       HTMainAnchor->message_id : NULL);
			FREE(tmptitle);
d550 12
a561 1
		    return(NULLFILE);
d563 16
a578 14
		/*
		 *  From here on we could have a remote host,
		 *  so check if that's allowed.
		 */
		} else if (local_host_only &&
			   url_type != NEWS_URL_TYPE &&
			   url_type != LYNXKEYMAP_URL_TYPE &&
			   url_type != LYNXIMGMAP_URL_TYPE &&
			   url_type != LYNXCOOKIE_URL_TYPE &&
			   url_type != LYNXCGI_URL_TYPE &&
			   !(LYisLocalHost(doc->address) ||
			     LYisLocalAlias(doc->address))) {
		    HTUserMsg(ACCESS_ONLY_LOCALHOST);
		    return(NULLFILE);
d580 36
a615 18
		/*
		 *  Disable www telnet access if not telnet_ok.
		 */
		} else if (url_type == TELNET_URL_TYPE ||
			   url_type == TN3270_URL_TYPE ||
			   url_type == TELNET_GOPHER_URL_TYPE) {
		    if (!telnet_ok) {
			HTUserMsg(TELNET_DISABLED);
		    } else if (no_telnet_port && strchr(doc->address+7, ':')) {
			HTUserMsg(TELNET_PORT_SPECS_DISABLED);
		    } else {
			stop_curses();
			HTLoadAbsolute(&WWWDoc);
			start_curses();
			fflush(stdout);
			LYAddVisitedLink(doc);
		    }
		    return(NULLFILE);
d617 3
a619 3
		/*
		 *  Disable www news access if not news_ok.
		 */
d621 5
a625 3
		} else if (url_type == NEWS_URL_TYPE && !news_ok) {
		    HTUserMsg(NEWS_DISABLED);
		    return(NULLFILE);
d628 26
a653 11
		} else if (url_type == RLOGIN_URL_TYPE) {
		    if (!rlogin_ok) {
			HTUserMsg(RLOGIN_DISABLED);
		    } else {
			stop_curses();
			HTLoadAbsolute(&WWWDoc);
			fflush(stdout);
			start_curses();
			LYAddVisitedLink(doc);
		    }
		    return(NULLFILE);
d655 21
a675 14
		/*
		 *  If its a gopher index type and there isn't a search
		 *  term already attached then do this.  Otherwise
		 *  just load it!
		 */
		} else if (url_type == INDEX_GOPHER_URL_TYPE &&
					strchr(doc->address,'?') == NULL) {
		    int status;
		    /*
		     *	Make sure we don't have a gopher+ escaped tab
		     *	instead of a gopher0 question mark delimiting
		     *	the search term. - FM
		     */
		    if ((cp = strstr(doc->address, "%09")) != NULL) {
a676 12
			StrAllocCopy(temp, doc->address);
			cp += 3;
			if (*cp && strncmp(cp, "%09", 3)) {
			    StrAllocCat(temp, "?");
			    StrAllocCat(temp, cp);
			    if ((cp = strstr(temp, "%09")) != NULL) {
				*cp = '\0';
			    }
			}
			StrAllocCopy(doc->address, temp);
			FREE(temp);
			goto Try_Redirected_URL;
d678 38
a715 19
		    /*
		     *	Load it because the do_www_search routine
		     *	uses the base url of the currently loaded
		     *	document :(
		     */
		    if (!HTLoadAbsolute(&WWWDoc))
			return(NOT_FOUND);
		    status = do_www_search(doc);
		    if (status == NULLFILE) {
			LYpop(doc);
			WWWDoc.address = doc->address;
			WWWDoc.post_data = doc->post_data;
			WWWDoc.post_content_type = doc->post_content_type;
			WWWDoc.bookmark = doc->bookmark;
			WWWDoc.isHEAD = doc->isHEAD;
			WWWDoc.safe = doc->safe;
			status = HTLoadAbsolute(&WWWDoc);
		    }
		    return(status);
d717 47
d765 15
d781 28
a808 3
		    if (url_type == FTP_URL_TYPE && !ftp_ok) {
			HTUserMsg(FTP_DISABLED);
			return(NULLFILE);
d810 10
d821 41
a861 26
		    if (url_type == HTML_GOPHER_URL_TYPE) {
			char *tmp=NULL;
		       /*
			*  If tuple's Path=GET%20/... convert to an http URL.
			*/
			if ((cp=strchr(doc->address+9, '/')) != NULL &&
			   0==strncmp(++cp, "hGET%20/", 8)) {
			    StrAllocCopy(tmp, "http://");
			    CTRACE(tfp, "getfile: URL '%s'\n",
					doc->address);
			    *cp = '\0';
			    StrAllocCat(tmp, doc->address+9);
			   /*
			    *  If the port is defaulted, it should stay 70.
			    */
			    if (strchr(tmp+6, ':') == NULL) {
				StrAllocCat(tmp, "70/");
				tmp[strlen(tmp)-4] = ':';
			    }
			    if (strlen(cp+7) > 1)
				StrAllocCat(tmp, cp+8);
			    StrAllocCopy(doc->address, tmp);
			    CTRACE(tfp, "  changed to '%s'\n",
					doc->address);
			    FREE(tmp);
			    url_type = HTTP_URL_TYPE;
d863 1
d865 5
a869 6
		    if (url_type == HTTP_URL_TYPE ||
			url_type == HTTPS_URL_TYPE ||
			url_type == FTP_URL_TYPE ||
			url_type == CSO_URL_TYPE)
			fix_http_urls(doc);
		    WWWDoc.address = doc->address;  /* possible reload */
d871 1
a871 1
		    lynx_edit_mode = FALSE;
d873 51
a923 2

		    if (url_type == FILE_URL_TYPE) {
d925 2
a926 6
			 *  If a file URL has a '~' as the lead character
			 *  of its first symbolic element, convert the '~'
			 *  to Home_Dir(), then append the rest of of path,
			 *  if present, skipping "user" if "~user" was
			 *  entered, simplifying, and eliminating any
			 *  residual relative elements. - FM
d928 1
a928 32
			if (((cp = HTParse(doc->address, "",
				   PARSE_PATH+PARSE_ANCHOR+PARSE_PUNCTUATION))
			      != NULL) &&
			    !strncmp(cp, "/~", 2)) {
			    char *cp1 = strstr(doc->address, "/~");
			    char *cp2;

			    CTRACE(tfp, "getfile: URL '%s'\n",
					doc->address);
			    *cp1 = '\0';
			    cp1 += 2;
			    StrAllocCopy(temp, doc->address);
			    StrAllocCopy(cp, wwwName(Home_Dir()));
			    if (!LYIsHtmlSep(*cp))
				LYAddHtmlSep(&temp);
			    StrAllocCat(temp, cp);
			    if ((cp2 = strchr(cp1, '/')) != NULL) {
				LYTrimRelFromAbsPath(cp2);
				StrAllocCat(temp, cp2);
			    }
			    StrAllocCopy(doc->address, temp);
			    FREE(temp);
			    CTRACE(tfp, "  changed to '%s'\n",
					doc->address);
			    WWWDoc.address = doc->address;
			}
			FREE(cp);
		    }
		    CTRACE_SLEEP(MessageSecs);
		    user_message(WWW_WAIT_MESSAGE, doc->address);
		    if (TRACE) {
#ifdef USE_SLANG
d930 6
a935 2
			    addstr("*\n");
			    refresh();
d937 2
a938 2
#endif /* USE_SLANG */
			fprintf(tfp,"\n");
d940 2
a941 6
		    if ((LYNoRefererHeader == FALSE &&
			 LYNoRefererForThis == FALSE) &&
			(url_type == HTTP_URL_TYPE ||
			 url_type == HTTPS_URL_TYPE) &&
			(cp = strchr(HTLoadedDocumentURL(), '?')) != NULL &&
			strchr(cp, '=') != NULL) {
d943 7
a949 5
			 *  Don't send a Referer header if the URL is
			 *  the reply from a form with method GET, in
			 *  case the content has personal data (e.g.,
			 *  a password or credit card number) which
			 *  would become visible in logs. - FM
d951 4
a954 1
			LYNoRefererForThis = TRUE;
d956 7
a962 2
		    cp = NULL;
		    if (!HTLoadAbsolute(&WWWDoc)) {
d964 2
a965 1
			 *  Check for redirection.
d967 56
a1022 2
			if (use_this_url_instead != NULL) {
			    char *pound;
d1024 18
a1041 136
			    if (!is_url(use_this_url_instead)) {
				/*
				 *  The server did not return a complete
				 *  URL in its Location: header, probably
				 *  due to a FORM or other CGI script written
				 *  by someone who doesn't know that the http
				 *  protocol requires that it be a complete
				 *  URL, or using a server which does not treat
				 *  such a redirect string from the script as
				 *  an instruction to resolve it versus the
				 *  initial request, check authentication with
				 *  that URL, and then act on it without
				 *  returning redirection to us.  We'll
				 *  violate the http protocol and resolve it
				 *  ourselves using the URL of the original
				 *  request as the BASE, rather than doing
				 *  the RIGHT thing and returning an invalid
				 *  address message. - FM
				 */
				HTUserMsg(LOCATION_NOT_ABSOLUTE);
				temp = HTParse(use_this_url_instead,
					       WWWDoc.address,
					       PARSE_ALL);
				if (temp && *temp) {
				    StrAllocCopy(use_this_url_instead, temp);
				}
				FREE(temp);
			    }
			    url_type = is_url(use_this_url_instead);
			    if (url_type == LYNXDOWNLOAD_URL_TYPE ||
				url_type == LYNXEXEC_URL_TYPE ||
				url_type == LYNXPROG_URL_TYPE ||
#ifdef DIRED_SUPPORT
				url_type == LYNXDIRED_URL_TYPE ||
#endif /* DIRED_SUPPORT */
				url_type == LYNXPRINT_URL_TYPE ||
				url_type == LYNXOPTIONS_URL_TYPE ||
				url_type == LYNXCFG_URL_TYPE ||
				url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
				url_type == LYNXHIST_URL_TYPE ||
				url_type == LYNXCOOKIE_URL_TYPE ||
				(LYValidate &&
				 url_type != HTTP_URL_TYPE &&
				 url_type != HTTPS_URL_TYPE) ||
				((no_file_url || no_goto_file) &&
				 url_type == FILE_URL_TYPE) ||
				(no_goto_lynxcgi &&
				 url_type == LYNXCGI_URL_TYPE) ||
				(no_goto_cso &&
				 url_type == CSO_URL_TYPE) ||
				(no_goto_finger &&
				 url_type == FINGER_URL_TYPE) ||
				(no_goto_ftp &&
				 url_type == FTP_URL_TYPE) ||
				(no_goto_gopher &&
				 url_type == GOPHER_URL_TYPE) ||
				(no_goto_http &&
				 url_type == HTTP_URL_TYPE) ||
				(no_goto_https &&
				 url_type == HTTPS_URL_TYPE) ||
				(no_goto_mailto &&
				 url_type == MAILTO_URL_TYPE) ||
#ifndef DISABLE_NEWS
				(no_goto_news &&
				 url_type == NEWS_URL_TYPE) ||
				(no_goto_nntp &&
				 url_type == NNTP_URL_TYPE) ||
#endif
				(no_goto_rlogin &&
				 url_type == RLOGIN_URL_TYPE) ||
#ifndef DISABLE_NEWS
				(no_goto_snews &&
				 url_type == SNEWS_URL_TYPE) ||
#endif
				(no_goto_telnet &&
				 url_type == TELNET_URL_TYPE) ||
				(no_goto_tn3270 &&
				 url_type == TN3270_URL_TYPE) ||
				(no_goto_wais &&
				 url_type == WAIS_URL_TYPE)) {
				/*
				 *  Some schemes are not acceptable from
				 *  server redirections. - KW & FM
				 */
				HTAlert(ILLEGAL_REDIRECTION_URL);
				if (LYCursesON) {
				    _user_message(WWW_ILLEGAL_URL_MESSAGE,
						  use_this_url_instead);
				    sleep(AlertSecs);
				} else {
				    fprintf(stderr,
					    WWW_ILLEGAL_URL_MESSAGE,
					    use_this_url_instead);
				}
				FREE(use_this_url_instead);
				return(NULLFILE);
			    }
			    if ((pound = strchr(doc->address, '#')) != NULL &&
				strchr(use_this_url_instead, '#') == NULL) {
				/*
				 *  Our requested URL had a fragment
				 *  associated with it, and the redirection
				 *  URL doesn't, so we'll append the fragment
				 *  associated with the original request.  If
				 *  it's bogus for the redirection URL, we'll
				 *  be positioned at the top of that document,
				 *  so there's no harm done. - FM
				 */
				CTRACE(tfp,
			"getfile: Adding fragment '%s' to redirection URL.\n",
				    pound);
				StrAllocCat(use_this_url_instead, pound);
			    }
			    CTRACE_SLEEP(MessageSecs);
			    _user_message(WWW_USING_MESSAGE,
					  use_this_url_instead);
			    sleep(InfoSecs);
			    CTRACE(tfp, "\n");
			    StrAllocCopy(doc->address,
					use_this_url_instead);
			    FREE(use_this_url_instead);
			    if (redirect_post_content == FALSE) {
				/*
				 *  Freeing the content also yields
				 *  a GET request. - FM
				 */
				FREE(doc->post_data);
				FREE(doc->post_content_type);
			    }
			    /*
			     *	Go to top to check for URL's which get
			     *	special handling and/or security checks
			     *	in Lynx. - FM
			     */
			    goto Try_Redirected_URL;
			}
d1043 2
d1047 18
a1064 2
		    lynx_mode = NORMAL_LYNX_MODE;

d1066 1
a1066 7
		     *	Some URL's don't actually return a document
		     *	compare doc->address with the document that is
		     *	actually loaded and return NULL if not
		     *	loaded.  If www_search_result is not -1
		     *	then this is a reference to a named anchor
		     *	within the same document.  Do NOT return
		     *	NULL.
d1068 2
a1069 6
		    {
			char *pound;
			/*
			 *  Check for a #fragment selector.
			 */
			pound = (char *)strchr(doc->address, '#');
d1071 5
a1075 79
			/*
			 *  Check to see if there is a temp
			 *  file waiting for us to download.
			 */
			if (WWW_Download_File) {
			    HTParentAnchor *tmpanchor;
			    char *fname = NULL;

			    /*
			     *	Check for a suggested filename from
			     *	the Content-Disposition header. - FM
			     */
			    if (((tmpanchor = HTAnchor_parent(
						HTAnchor_findAddress(&WWWDoc)
							     )) != NULL) &&
				HTAnchor_SugFname(tmpanchor) != NULL) {
				StrAllocCopy(fname,
					     HTAnchor_SugFname(tmpanchor));
			    } else {
				StrAllocCopy(fname, doc->address);
			    }
			    /*
			     *	Check whether this is a compressed file,
			     *	which we don't uncompress for downloads,
			     *	and adjust any suffix appropriately. - FM
			     */
			    if (tmpanchor != NULL) {
				HTCheckFnameForCompression(&fname, tmpanchor,
							   FALSE);
			    }
			    if (LYdownload_options(&fname,
						   WWW_Download_File) < 0) {
				FREE(fname);
				return(NOT_FOUND);
			    }
			    LYAddVisitedLink(doc);
			    StrAllocCopy(doc->address, fname);
			    FREE(fname);
			    doc->internal_link = FALSE;
			    WWWDoc.address = doc->address;
			    FREE(doc->post_data);
			    WWWDoc.post_data = NULL;
			    FREE(doc->post_content_type);
			    WWWDoc.post_content_type = NULL;
			    WWWDoc.bookmark = doc->bookmark = FALSE;
			    WWWDoc.isHEAD = doc->isHEAD = FALSE;
			    WWWDoc.safe = doc->safe = FALSE;
			    HTOutputFormat = WWW_PRESENT;
			    if (!HTLoadAbsolute(&WWWDoc))
				return(NOT_FOUND);
			    else
				return(NORMAL);

			} else if (pound == NULL &&
				   /*
				    *  HTAnchor hash-table searches are now
				    *  case-sensitive (hopefully, without
				    *  anchor deletion problems), so this
				    *  is too. - FM
				    */
				   (strcmp(doc->address,
					   HTLoadedDocumentURL()) ||
				   /*
				    *  Also check the post_data elements. - FM
				    */
				   strcmp((doc->post_data ?
					   doc->post_data : ""),
					  HTLoadedDocumentPost_data()) ||
				   /*
				    *  Also check the isHEAD element. - FM
				    */
				   doc->isHEAD != HTLoadedDocumentIsHEAD())) {
			    /*
			     *	Nothing needed to be shown.
			     */
			    LYAddVisitedLink(doc);
			    return(NULLFILE);

			} else {
d1079 1
a1079 4
			    if (pound != NULL)
				HTFindPoundSelector(pound+1);
			    return(NORMAL);
			}
d1081 1
d1083 44
a1126 6
	  } else {
	      CTRACE_SLEEP(MessageSecs);
	      HTUserMsg2(WWW_BAD_ADDR_MESSAGE, doc->address);
	      CTRACE(tfp,"\n");
	      return(NULLFILE);
	  }
d1148 1
a1148 1
	document *,	doc,
d1158 2
a1159 2
    CTRACE(tfp,"follow_link_number(%d,%d,...)\n",c,cur);
    temp[0] = c;
d1171 1
a1171 1
    while ( isdigit(*p) )
d1181 1
d1187 1
a1187 1
    CTRACE(tfp,"  temp=%s, *num=%d, rel='%c'\n",temp,*num,rel);
d1192 5
a1196 1
    if ( c == 'p' || c == 'P' ) {
d1204 2
a1205 2
	CTRACE(tfp," nlines=%d, npages=%d, curline=%d, curpage=%d\n",
		nlines,npages,curline,curpage);
d1223 1
a1223 1
    want_go = ( c == 'g' || c == 'G' );
d1235 2
d1247 9
a1255 6
	if ((info = HTGetLinkInfo(*num,
				  want_go,
				  &new_top,
				  &new_link,
				  &links[cur].hightext,
			  &links[cur].lname)) == WWW_INTERN_LINK_TYPE) {
d1403 1
d1455 4
d1460 1
a1460 6
	if (!isalnum(*cp) &&
	    *cp != '_' && *cp != '-' && *cp != ' ' &&
	    *cp != ':' && *cp != '.' && *cp != '/' &&
	    *cp != '@@' && *cp != '~' && *cp != '$' &&
	    *cp != '&' && *cp != '+' && *cp != '=' &&
	    *cp != '\t') {
d1481 2
a1482 7
#ifdef VMS
	    if (strncasecomp(source, tp->src, strlen(tp->src)) == 0 &&
		strncasecomp(command, tp->path, strlen(tp->path)) == 0)
#else
	    if (strncmp(source, tp->src, strlen(tp->src)) == 0 &&
		strncmp(command, tp->path, strlen(tp->path)) == 0)
#endif /* VMS */
d1499 3
a1501 2
PRIVATE int fix_http_urls ARGS1(
	document *,	doc)
d1506 8
d1516 1
a1516 1
    if (!strncmp(doc->address, "ftp", 3) &&
d1535 2
a1536 2
	if (((proxy = (char *)getenv("ftp_proxy")) != NULL) &&
	    *proxy != '\0' && !override_proxy(doc->address))
d1542 1
a1542 1
	CTRACE(tfp, "fix_http_urls: URL '%s'\n", doc->address);
d1544 15
a1558 1
	CTRACE(tfp, "        changed to '%s'\n", doc->address);
d1561 1
d1570 21
d1592 1
a1592 1
    CTRACE(tfp, "fix_http_urls: URL '%s'\n", doc->address);
d1594 1
a1594 1
    CTRACE(tfp, "        changed to '%s'\n",doc->address);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d3 1
a3 1
#include <HTAnchor.h>		/* Anchor class */
d17 1
a30 2
#include <LYHistory.h>
#include <LYPrettySrc.h>
d35 5
a39 1
static int fix_httplike_urls(DocInfo *doc, UrlTypes type);
d41 2
d44 2
a45 6
#define STRNADDRCOMP strncasecomp
#else
#define STRNADDRCOMP strncmp
#endif /* !VMS */

int HTNoDataOK = 0;
d47 2
a48 24
/*
 * getfile is the main mechanism to load a new document (or a previously loaded
 * one whose rendering is cached in a HText structure) from mainloop, nearly
 * everything goes through it.
 * It should return one of the values
 *     NORMAL     - requested document loaded successfully, usually [always?]
 *                  its rendering is available as HTMainText.  It can be an
 *                  HTTP error message page or similar, we make no
 *                  distinction here.
 *     NOT_FOUND  - requested document cannot be accessed, and the reason
 *                  is a real error (as may be caused by an invalid link),
 *                  not just that lynx disallows access because of some
 *                  permission restrictions, and we have no error page
 *                  to show for it either.
 *     NULLFILE   - requested document not loaded into HTMainText, either
 *                  some interactive protocol was requested (like telnet),
 *                  or lynx does not allow access.
 * The distinction between NOT_FOUND and NULLFILE is not very crucial, but
 * getting it right prevents mainloop from exiting with the wrong message if it
 * happens for the first file, and from logging (or not logging) errors
 * inappropriately with -traversal, and from sending bogus error mail with
 * MAIL_SYSTEM_ERROR_LOGGING:TRUE.  - kw
 */
int getfile(DocInfo *doc, int *target)
d50 4
a53 5
    UrlTypes url_type = NOT_A_URL_TYPE;
    char *pound;
    char *cp = NULL;
    char *temp = NULL;
    DocAddress WWWDoc;		/* a WWW absolute doc address struct */
d55 7
a61 7
    /*
     * Reset LYCancelDownload to prevent unwanted delayed effect.  - KW
     */
    if (LYCancelDownload) {
	CTRACE((tfp, "getfile:    resetting LYCancelDownload to FALSE\n"));
	LYCancelDownload = FALSE;
    }
d63 4
a66 4
    /*
     * Reset fake 'Z' to prevent unwanted delayed effect.  - kw
     */
    LYFakeZap(NO);
d68 10
a77 7
    /*
     * Reset redirection counter to prevent bogus TOO_MANY_REDIRECTIONS in rare
     * situations if the previous cycle got to the limit, but did not fail for
     * that reason because the URL of the final location was handled specially,
     * not via HTLoadAbsolute.  - kw
     */
    redirection_attempts = 0;
d79 4
a82 10
  Try_Redirected_URL:
    /*
     * Load the WWWDoc struct in case we need to use it.
     */
    WWWDoc.address = doc->address;
    WWWDoc.post_data = doc->post_data;
    WWWDoc.post_content_type = doc->post_content_type;
    WWWDoc.bookmark = doc->bookmark;
    WWWDoc.isHEAD = doc->isHEAD;
    WWWDoc.safe = doc->safe;
d84 4
a87 9
    /*
     * Reset HTPermitRedir, it has done its job if it was set.  - kw
     */
    HTPermitRedir = FALSE;

    /*
     * Reset WWW_Download_File just in case.
     */
    FREE(WWW_Download_File);
d89 1
a89 4
    /*
     * Reset redirect_post_content just in case.
     */
    redirect_post_content = FALSE;
d91 38
a128 43
    /*
     * This flag is a hack to allow us to pass on the fact that 'no data' may
     * not really be an error although HTLoadAbsolute returned NO.  There
     * should be a better way...  HT_NO_DATA should always mean 'not data but
     * not an error', and be passed on to us as that, but current usage if
     * HT_NO_DATA vs HT_NOT_LOADED has to be reviewed everywhere.  Anyway, some
     * protocol module can set it to say 'I really mean it', we have to reset
     * it here.  - kw
     */
    HTNoDataOK = 0;

    CTRACE((tfp, "getfile: getting %s\n\n", doc->address));

    /*
     * Protect against denial of service attacks via the port 19 CHARGEN
     * service, and block connections to the port 25 ESMTP service.  Also
     * reject any likely spoof attempts via wrap arounds at 65536.  - FM
     */
    if ((temp = HTParse(doc->address, "", PARSE_HOST)) != NULL &&
	strlen(temp) > 3) {
	char *cp1;

	if ((cp1 = strchr(temp, '@@')) == NULL)
	    cp1 = temp;
	if ((cp = strrchr(cp1, ':')) != NULL) {
	    long int value;

	    cp++;
	    if (sscanf(cp, "%ld", &value) == 1) {
		if (value == 19 || value == 65555) {
		    HTAlert(PORT_NINETEEN_INVALID);
		    FREE(temp);
		    return (NULLFILE);
		} else if (value == 25 || value == 65561) {
		    HTAlert(PORT_TWENTYFIVE_INVALID);
		    FREE(temp);
		    return (NULLFILE);
		} else if (value > 65535 || value < 0) {
		    char *msg = 0;

		    HTSprintf0(&msg, PORT_INVALID, (unsigned long) value);
		    HTAlert(msg);
		    FREE(msg);
d130 1
a130 1
		    return (NULLFILE);
a131 4
	    } else if (isdigit(UCH(*cp))) {
		HTAlert(URL_PORT_BAD);
		FREE(temp);
		return (NULLFILE);
d134 2
a135 3
    }
    cp = NULL;
    FREE(temp);
d137 92
a228 94
    /*
     * Check to see if this is a universal document ID that lib WWW wants to
     * handle.
     *
     * Some special URL's we handle ourselves.  :)
     */
    if ((url_type = is_url(doc->address)) != 0) {
	if (LYValidate && !LYPermitURL) {
	    if (!(url_type == HTTP_URL_TYPE ||
		  url_type == HTTPS_URL_TYPE ||
		  url_type == LYNXHIST_URL_TYPE ||
		  url_type == LYNXKEYMAP_URL_TYPE ||
		  url_type == LYNXIMGMAP_URL_TYPE ||
		  url_type == LYNXCOOKIE_URL_TYPE ||
		  url_type == LYNXMESSAGES_URL_TYPE ||
		  (url_type == LYNXOPTIONS_URL_TYPE &&
		   WWWDoc.post_data) ||
		  0 == STRNADDRCOMP(WWWDoc.address, helpfilepath,
				    strlen(helpfilepath)) ||
		  (lynxlistfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxlistfile,
				     strlen(lynxlistfile))) ||
		  (lynxlinksfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxlinksfile,
				     strlen(lynxlinksfile))) ||
		  (lynxjumpfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
				     strlen(lynxjumpfile))))) {
		HTUserMsg(NOT_HTTP_URL_OR_ACTION);
		return (NULLFILE);
	    }
	}
	if (traversal) {
	    /*
	     * Only traverse http URLs.
	     */
	    if (url_type != HTTP_URL_TYPE &&
		url_type != LYNXIMGMAP_URL_TYPE) {
		return (NULLFILE);
	    }
	} else if (check_realm && !LYPermitURL && !LYJumpFileURL) {
	    if (!(0 == strncmp(startrealm, WWWDoc.address,
			       strlen(startrealm)) ||
		  url_type == LYNXHIST_URL_TYPE ||
		  url_type == LYNXKEYMAP_URL_TYPE ||
		  url_type == LYNXIMGMAP_URL_TYPE ||
		  url_type == LYNXCOOKIE_URL_TYPE ||
		  url_type == LYNXPRINT_URL_TYPE ||
		  url_type == LYNXOPTIONS_URL_TYPE ||
		  url_type == LYNXCFG_URL_TYPE ||
		  url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
		  url_type == LYNXMESSAGES_URL_TYPE ||
		  url_type == LYNXDOWNLOAD_URL_TYPE ||
		  url_type == MAILTO_URL_TYPE ||
		  url_type == NEWSPOST_URL_TYPE ||
		  url_type == NEWSREPLY_URL_TYPE ||
		  url_type == SNEWSPOST_URL_TYPE ||
		  url_type == SNEWSREPLY_URL_TYPE ||
		  (!LYUserSpecifiedURL &&
		   (url_type == LYNXEXEC_URL_TYPE ||
		    url_type == LYNXPROG_URL_TYPE ||
		    url_type == LYNXCGI_URL_TYPE)) ||
		  (WWWDoc.bookmark != NULL &&
		   *WWWDoc.bookmark != '\0') ||
		  0 == STRNADDRCOMP(WWWDoc.address, helpfilepath,
				    strlen(helpfilepath)) ||
		  (lynxlistfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxlistfile,
				     strlen(lynxlistfile))) ||
		  (lynxjumpfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
				     strlen(lynxjumpfile))))) {
		HTUserMsg(NOT_IN_STARTING_REALM);
		return (NULLFILE);
	    }
	}
	if (WWWDoc.post_data &&
	    url_type != HTTP_URL_TYPE &&
	    url_type != HTTPS_URL_TYPE &&
	    url_type != LYNXCGI_URL_TYPE &&
	    url_type != LYNXIMGMAP_URL_TYPE &&
	    url_type != GOPHER_URL_TYPE &&
	    url_type != CSO_URL_TYPE &&
	    url_type != PROXY_URL_TYPE &&
	    url_type != LYNXOPTIONS_URL_TYPE &&
	    !(url_type == FILE_URL_TYPE &&
	      (LYIsUIPage(WWWDoc.address, UIP_LIST_PAGE) ||
	       LYIsUIPage(WWWDoc.address, UIP_ADDRLIST_PAGE)))) {
	    CTRACE((tfp, "getfile: dropping post_data!\n"));
	    HTAlert(IGNORED_POST);
	    LYFreePostData(doc);
	    WWWDoc.post_data = NULL;
	    WWWDoc.post_content_type = NULL;
	}
d230 12
a241 11
	LYSyslog(doc->address);
#endif
	if (url_type == UNKNOWN_URL_TYPE ||
	    url_type == AFS_URL_TYPE ||
	    url_type == PROSPERO_URL_TYPE) {
	    HTAlert(UNSUPPORTED_URL_SCHEME);
	    return (NULLFILE);

	} else if (url_type == DATA_URL_TYPE) {
	    HTAlert(UNSUPPORTED_DATA_URL);
	    return (NULLFILE);
d243 2
a244 2
	} else if (url_type == LYNXPRINT_URL_TYPE) {
	    return (printfile(doc));
d247 3
a249 3
	} else if (url_type == LYNXOPTIONS_URL_TYPE) {
	    /* proceed forms-based options menu */
	    return (postoptions(doc));
d252 3
a254 6
	} else if (url_type == LYNXCFG_URL_TYPE &&
		   !no_lynxcfg_info) {
	    /* @@@@@@ maybe we should generate a specific error message
	       if attempted but restricted. - kw */
	    /* show/change/reload lynx.cfg settings */
	    return (lynx_cfg_infopage(doc));
d257 3
a259 6
	} else if (url_type == LYNXCOMPILE_OPTS_URL_TYPE &&
		   !no_compileopts_info) {
	    /* @@@@@@ maybe we should generate a specific error message
	       if attempted but restricted or not supported. - kw */
	    /* show compile-time settings */
	    return (lynx_compile_opts(doc));
d262 4
d267 12
a278 16
	} else if (url_type == NEWSPOST_URL_TYPE ||
		   url_type == NEWSREPLY_URL_TYPE ||
		   url_type == SNEWSPOST_URL_TYPE ||
		   url_type == SNEWSREPLY_URL_TYPE) {

	    if (no_newspost) {
		HTUserMsg(NEWSPOSTING_DISABLED);
		return (NULLFILE);
	    } else if (!news_ok && (url_type == NEWSPOST_URL_TYPE ||
				    url_type == NEWSREPLY_URL_TYPE)) {
		HTUserMsg(NEWS_DISABLED);
		return (NULLFILE);
	    } else {
		HTLoadAbsolute(&WWWDoc);
		return (NULLFILE);
	    }
d281 2
a282 2
	} else if (url_type == LYNXDOWNLOAD_URL_TYPE) {
	    LYDownload(doc->address);
d284 14
a297 9
	    if (LYDidRename) {
		/*
		 * The temporary file was saved to disk via a rename(), so we
		 * can't access the temporary file again via the download menu. 
		 * Clear the flag, and return NULLFILE to pop.  - FM
		 */
		LYDidRename = FALSE;
		return (NULLFILE);
	    }
d299 1
a299 2
	    return (NORMAL);
	} else if (url_type == LYNXDIRED_URL_TYPE) {
d301 19
a319 14
	    if (!no_dired_support) {
		local_dired(doc);
		WWWDoc.address = doc->address;
		WWWDoc.post_data = doc->post_data;
		WWWDoc.post_content_type = doc->post_content_type;
		WWWDoc.bookmark = doc->bookmark;
		WWWDoc.isHEAD = doc->isHEAD;
		WWWDoc.safe = doc->safe;

		if (!HTLoadAbsolute(&WWWDoc)) {
		    return (NOT_FOUND);
		}
		return (NORMAL);
	    }
a320 3
	    HTUserMsg(DIRED_DISABLED);
	    return (NULLFILE);
	}
d322 11
a332 50
	if (LYNoRefererHeader == FALSE &&
	    LYNoRefererForThis == FALSE) {
	    const char *ref_url = HTLoadedDocumentURL();

	    if (isLYNXIMGMAP(ref_url))
		ref_url += LEN_LYNXIMGMAP;
	    if (no_filereferer == TRUE && isFILE_URL(ref_url)) {
		LYNoRefererForThis = TRUE;
	    }
	    if (LYNoRefererForThis == FALSE &&
		(cp = strchr(ref_url, '?')) != NULL &&
		strchr(cp, '=') != NULL) {
		/*
		 * Don't send a Referer header if the URL is the reply from a
		 * form with method GET, in case the content has personal data
		 * (e.g., a password or credit card number) which would become
		 * visible in logs.  - FM
		 *
		 * Changed 1999-11-01 to be controlled by REFERER_WITH_QUERY
		 * option.  - kw
		 */
		if (LYRefererWithQuery == 'S') {	/* SEND */
		    StrAllocCopy(LYRequestReferer, ref_url);
		} else if (LYRefererWithQuery == 'P') {		/* PARTIAL */
		    FREE(LYRequestReferer);	/* just to be sure */
		    LYRequestReferer = HTParse(ref_url, "",
					       PARSE_ACCESS
					       | PARSE_HOST
					       | PARSE_STRICTPATH
					       | PARSE_PUNCTUATION);
		} else {	/* Everything else - don't send Referer */
		    LYNoRefererForThis = TRUE;
		}
		cp = NULL;
	    } else if (LYNoRefererForThis == FALSE) {
		StrAllocCopy(LYRequestReferer, ref_url);
	    }
	} else {
	    StrAllocCopy(LYRequestReferer, HTLoadedDocumentURL());
	}
	if (url_type == LYNXHIST_URL_TYPE) {
	    /*
	     * 'doc' will change to the new file if we had a successful
	     * LYpop_num(), and the return value will be FALSE if we had a
	     * cancel.  - FM
	     */
	    if ((historytarget(doc) == FALSE) ||
		!doc || !doc->address) {
		return (NOT_FOUND);
	    }
d334 9
a342 9
	    /*
	     * We changed it so reload.
	     */
	    WWWDoc.address = doc->address;
	    WWWDoc.post_data = doc->post_data;
	    WWWDoc.post_content_type = doc->post_content_type;
	    WWWDoc.bookmark = doc->bookmark;
	    WWWDoc.isHEAD = doc->isHEAD;
	    WWWDoc.safe = doc->safe;
d344 3
a346 3
	    if (doc->internal_link && !reloading) {
		LYinternal_flag = TRUE;
	    }
d349 4
a352 7
#ifdef DIRED_SUPPORT
	    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
	    if (!HTLoadAbsolute(&WWWDoc)) {
		return (NOT_FOUND);
	    }
	    return (NORMAL);
d354 2
a355 2
	} else if (url_type == LYNXEXEC_URL_TYPE ||
		   url_type == LYNXPROG_URL_TYPE) {
d357 49
a405 52
	    if (no_exec &&
		!exec_ok(HTLoadedDocumentURL(),
			 doc->address + 9, ALWAYS_EXEC_PATH)) {
		HTUserMsg(EXECUTION_DISABLED);
	    } else if (no_bookmark_exec &&
		       HTLoadedDocumentBookmark()) {
		HTUserMsg(BOOKMARK_EXEC_DISABLED);
	    } else if (local_exec || (local_exec_on_local_files &&
				      exec_ok(HTLoadedDocumentURL(),
					      doc->address + 9, EXEC_PATH))) {

		char *p = NULL;

		/*
		 * Bug puts slash on end if none is in the string.
		 */
		char *last_slash = strrchr(doc->address, '/');

		if (last_slash - doc->address
		    == (int) strlen(doc->address) - 1)
		    doc->address[strlen(doc->address) - 1] = '\0';

		/*
		 * Convert '~' to $HOME.
		 */
		if ((cp = strchr(doc->address, '~'))) {
		    HTSprintf0(&p, "%.*s%s%s",
			       cp - doc->address,
			       doc->address,
			       wwwName(Home_Dir()),
			       cp + 1);
		} else {
		    StrAllocCopy(p, doc->address);
		}
		/*
		 * Show URL before executing it.
		 */
		HTInfoMsg(doc->address);
		stop_curses();
		/*
		 * Run the command.
		 */
		if (strstr(p, "//") == p + 9)
		    LYSystem(p + 11);
		else
		    LYSystem(p + 9);
		FREE(p);

		if (url_type != LYNXPROG_URL_TYPE) {
		    /*
		     * Make sure user gets to see screen output.
		     */
d407 1
a407 1
		    signal(SIGINT, SIG_IGN);
d409 3
a411 3
		    printf("\n%s", RETURN_TO_LYNX);
		    fflush(stdout);
		    (void) LYgetch();
d413 1
a413 1
		    HadVMSInterrupt = FALSE;
d415 3
a417 5
		}
		if (!dump_output_immediately) {
		    start_curses();
		    LYAddVisitedLink(doc);
		}
d419 2
a420 2
	    } else {
		char *buf = 0;
d422 6
a427 6
		HTSprintf0(&buf,
			   EXECUTION_DISABLED_FOR_FILE,
			   key_for_func(LYK_OPTIONS));
		HTAlert(buf);
		FREE(buf);
	    }
d429 1
a429 1
	    HTUserMsg(EXECUTION_NOT_COMPILED);
d431 1
a431 1
	    return (NULLFILE);
d433 3
a435 19
	} else if (url_type == MAILTO_URL_TYPE) {
	    if (no_mail) {
		HTUserMsg(MAIL_DISABLED);
	    } else {
		HTParentAnchor *tmpanchor = HTAnchor_findAddress(&WWWDoc);
		const char *title;
		char *tmptitle = NULL;

		title = "";
		if (HTAnchor_title(tmpanchor)) {
		    title = HTAnchor_title(tmpanchor);
		} else if (HTMainAnchor && !LYUserSpecifiedURL) {
		    title = HTAnchor_subject(HTMainAnchor);
		    if (non_empty(title)) {
			if (strncasecomp(title, "Re:", 3)) {
			    StrAllocCopy(tmptitle, "Re: ");
			    StrAllocCat(tmptitle, title);
			    title = tmptitle;
			}
d437 4
d442 26
d469 16
a484 12
		}
		cp = strchr(doc->address, ':') + 1;
		reply_by_mail(cp,
			      ((HTMainAnchor && !LYUserSpecifiedURL) ?
			       (char *) HTMainAnchor->address :
			       (char *) doc->address),
			      title,
			      (HTMainAnchor && !LYUserSpecifiedURL) ?
			      HTMainAnchor->message_id : NULL);
		FREE(tmptitle);
	    }
	    return (NULLFILE);
a485 31
	    /*
	     * From here on we could have a remote host, so check if that's
	     * allowed.
	     */
	} else if (local_host_only &&
		   url_type != LYNXKEYMAP_URL_TYPE &&
		   url_type != LYNXIMGMAP_URL_TYPE &&
		   url_type != LYNXCOOKIE_URL_TYPE &&
		   url_type != LYNXMESSAGES_URL_TYPE &&
		   url_type != LYNXCGI_URL_TYPE &&
		   !(url_type == NEWS_URL_TYPE &&
		     strncmp(doc->address, "news://", 7)) &&
		   !(LYisLocalHost(doc->address) ||
		     LYisLocalAlias(doc->address))) {
	    HTUserMsg(ACCESS_ONLY_LOCALHOST);
	    return (NULLFILE);

	    /*
	     * Disable www telnet access if not telnet_ok.
	     */
	} else if (url_type == TELNET_URL_TYPE ||
		   url_type == TN3270_URL_TYPE ||
		   url_type == TELNET_GOPHER_URL_TYPE) {
	    char *proxy;

	    if (!telnet_ok) {
		HTUserMsg(TELNET_DISABLED);
		return (NULLFILE);
	    } else if (no_telnet_port && strchr(doc->address + 7, ':')) {
		HTUserMsg(TELNET_PORT_SPECS_DISABLED);
		return (NULLFILE);
d487 1
a487 2
		 * Detect weird case where interactive protocol would be
		 * proxied, and to a non-interactive protocol at that.
d489 15
a503 21
	    } else if ((proxy = LYGetEnv(((url_type == TN3270_URL_TYPE)
					  ? "tn3270_proxy"
					  :
					  ((url_type == TELNET_GOPHER_URL_TYPE)
					   ? "gopher_proxy"
					   : "telnet_proxy")))) != NULL &&
		       !override_proxy(doc->address) &&
		       (!isTELNET_URL(proxy) &&
			!isTN3270_URL(proxy) &&
			!isRLOGIN_URL(proxy))) {
		/* Do nothing, fall through to generic code - kw */
	    } else {
		stop_curses();
		HTLoadAbsolute(&WWWDoc);
		if (!dump_output_immediately) {
		    start_curses();
		    fflush(stdout);
		    LYAddVisitedLink(doc);
		}
		return (NULLFILE);
	    }
d505 3
a507 3
	    /*
	     * Disable www news access if not news_ok.
	     */
d509 3
a511 4
	} else if (!news_ok && (url_type == NEWS_URL_TYPE ||
				url_type == NNTP_URL_TYPE)) {
	    HTUserMsg(NEWS_DISABLED);
	    return (NULLFILE);
d514 11
a524 2
	} else if (url_type == RLOGIN_URL_TYPE) {
	    char *proxy;
a525 3
	    if (!rlogin_ok) {
		HTUserMsg(RLOGIN_DISABLED);
		return (NULLFILE);
d527 3
a529 2
		 * Detect weird case where interactive protocol would be
		 * proxied, and to a non-interactive protocol at that.
d531 9
a539 37
	    } else if ((proxy = LYGetEnv("rlogin_proxy")) != NULL &&
		       !override_proxy(doc->address) &&
		       (!isTELNET_URL(proxy) &&
			!isTN3270_URL(proxy) &&
			!isRLOGIN_URL(proxy))) {
		/* Do nothing, fall through to generic code - kw */
	    } else {
		stop_curses();
		HTLoadAbsolute(&WWWDoc);
		fflush(stdout);
		if (!dump_output_immediately) {
		    start_curses();
		    LYAddVisitedLink(doc);
		}
		return (NULLFILE);
	    }

	    /*
	     * If it's a gopher index type and there isn't a search term
	     * already attached then do this.  Otherwise just load it!
	     */
	} else if (url_type == INDEX_GOPHER_URL_TYPE &&
		   strchr(doc->address, '?') == NULL) {
	    int status;

	    /*
	     * Make sure we don't have a gopher+ escaped tab instead of a
	     * gopher0 question mark delimiting the search term.  - FM
	     */
	    if ((cp = strstr(doc->address, "%09")) != NULL) {
		*cp = '\0';
		StrAllocCopy(temp, doc->address);
		cp += 3;
		if (*cp && strncmp(cp, "%09", 3)) {
		    StrAllocCat(temp, "?");
		    StrAllocCat(temp, cp);
		    if ((cp = strstr(temp, "%09")) != NULL) {
d541 12
d554 19
a572 29
		}
		StrAllocCopy(doc->address, temp);
		FREE(temp);
		goto Try_Redirected_URL;
	    }
	    /*
	     * Load it because the do_www_search routine uses the base url of
	     * the currently loaded document :(
	     */
	    if (!HTLoadAbsolute(&WWWDoc)) {
		return (NOT_FOUND);
	    }
	    status = do_www_search(doc);
	    if (status == NULLFILE) {
		LYpop(doc);
		WWWDoc.address = doc->address;
		WWWDoc.post_data = doc->post_data;
		WWWDoc.post_content_type = doc->post_content_type;
		WWWDoc.bookmark = doc->bookmark;
		WWWDoc.isHEAD = doc->isHEAD;
		WWWDoc.safe = doc->safe;
		status = HTLoadAbsolute(&WWWDoc);
#ifdef DIRED_SUPPORT
	    } else {
		lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
	    }
	    return (status);
	}
d574 1
a574 34
	if (!ftp_ok
	    && (url_type == FTP_URL_TYPE
		|| url_type == NCFTP_URL_TYPE)) {
	    HTUserMsg(FTP_DISABLED);
	    return (NULLFILE);
	} else if (url_type == HTML_GOPHER_URL_TYPE) {
	    char *tmp = NULL;

	    /*
	     * If tuple's Path=GET%20/...  convert to an http URL.
	     */
	    if ((cp = strchr(doc->address + 9, '/')) != NULL &&
		0 == strncmp(++cp, "hGET%20/", 8)) {
		StrAllocCopy(tmp, "http://");
		CTRACE((tfp, "getfile: URL '%s'\n",
			doc->address));
		*cp = '\0';
		StrAllocCat(tmp, doc->address + 9);
		/*
		 * If the port is defaulted, it should stay 70.
		 */
		if (strchr(tmp + 6, ':') == NULL) {
		    StrAllocCat(tmp, "70/");
		    tmp[strlen(tmp) - 4] = ':';
		}
		if (strlen(cp + 7) > 1)
		    StrAllocCat(tmp, cp + 8);
		StrAllocCopy(doc->address, tmp);
		CTRACE((tfp, "  changed to '%s'\n",
			doc->address));
		FREE(tmp);
		url_type = HTTP_URL_TYPE;
	    }
	}
d576 4
a579 7
	if (url_type == HTTP_URL_TYPE ||
	    url_type == HTTPS_URL_TYPE ||
	    url_type == FTP_URL_TYPE ||
	    url_type == NCFTP_URL_TYPE ||
	    url_type == CSO_URL_TYPE) {
	    fix_httplike_urls(doc, url_type);
	}
d581 34
a614 1
	WWWDoc.address = doc->address;	/* possible reload */
d616 1
a616 1
	lynx_edit_mode = FALSE;
d619 40
a658 67
#ifndef DISABLE_BIBP
	if (url_type == BIBP_URL_TYPE) {
	    char *bibpTmp = NULL;

	    if (!BibP_bibhost_checked)
		LYCheckBibHost();
	    if (BibP_bibhost_available) {
		StrAllocCopy(bibpTmp, BibP_bibhost);
	    } else if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
		StrAllocCopy(bibpTmp, HTAnchor_citehost(HTMainAnchor));
	    } else {
		StrAllocCopy(bibpTmp, BibP_globalserver);
	    }
	    if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
		StrAllocCat(bibpTmp, "bibp1.0/resolve?citehost=");
		StrAllocCat(bibpTmp, HTAnchor_citehost(HTMainAnchor));
		StrAllocCat(bibpTmp, "&usin=");
	    } else {
		StrAllocCat(bibpTmp, "bibp1.0/resolve?usin=");
	    }
	    StrAllocCat(bibpTmp, doc->address + 5);	/* USIN after bibp: */
	    StrAllocCopy(doc->address, bibpTmp);
	    WWWDoc.address = doc->address;
	    FREE(bibpTmp);
	}
#endif /* !DISABLE_BIBP */

	if (url_type == FILE_URL_TYPE) {
	    /*
	     * If a file URL has a '~' as the lead character of its first
	     * symbolic element, convert the '~' to Home_Dir(), then append
	     * the rest of of path, if present, skipping "user" if "~user"
	     * was entered, simplifying, and eliminating any residual
	     * relative elements.  - FM
	     */
	    if (((cp = HTParse(doc->address, "",
			       PARSE_PATH + PARSE_ANCHOR + PARSE_PUNCTUATION))
		 != NULL) &&
		!strncmp(cp, "/~", 2)) {
		char *cp1 = strstr(doc->address, "/~");
		char *cp2;

		CTRACE((tfp, "getfile: URL '%s'\n",
			doc->address));
		*cp1 = '\0';
		cp1 += 2;
		StrAllocCopy(temp, doc->address);
		StrAllocCopy(cp, wwwName(Home_Dir()));
		if (!LYIsHtmlSep(*cp))
		    LYAddHtmlSep(&temp);
		StrAllocCat(temp, cp);
		if ((cp2 = strchr(cp1, '/')) != NULL) {
		    LYTrimRelFromAbsPath(cp2);
		    StrAllocCat(temp, cp2);
		}
		StrAllocCopy(doc->address, temp);
		FREE(temp);
		CTRACE((tfp, "  changed to '%s'\n",
			doc->address));
		WWWDoc.address = doc->address;
	    }
	    FREE(cp);
	}
	CTRACE_SLEEP(MessageSecs);
	user_message(WWW_WAIT_MESSAGE, doc->address);

	if (TRACE) {
d660 4
a663 4
	    if (LYCursesON) {
		LYaddstr("*\n");
		LYrefresh();
	    }
d665 16
a680 30
	    CTRACE((tfp, "\n"));
	}

	if (!HTLoadAbsolute(&WWWDoc)) {
	    /*
	     * Check for redirection.
	     */
	    if (use_this_url_instead != NULL) {
		if (!is_url(use_this_url_instead)) {
		    /*
		     * The server did not return a complete URL in its
		     * Location:  header, probably due to a FORM or other
		     * CGI script written by someone who doesn't know that
		     * the http protocol requires that it be a complete
		     * URL, or using a server which does not treat such a
		     * redirect string from the script as an instruction to
		     * resolve it versus the initial request, check
		     * authentication with that URL, and then act on it
		     * without returning redirection to us.  We'll violate
		     * the http protocol and resolve it ourselves using the
		     * URL of the original request as the BASE, rather than
		     * doing the RIGHT thing and returning an invalid
		     * address message.  - FM
		     */
		    HTUserMsg(LOCATION_NOT_ABSOLUTE);
		    temp = HTParse(use_this_url_instead,
				   WWWDoc.address,
				   PARSE_ALL);
		    if (non_empty(temp)) {
			StrAllocCopy(use_this_url_instead, temp);
d682 40
a721 7
		    FREE(temp);
		}
		url_type = is_url(use_this_url_instead);
		if (!HTPermitRedir &&
		    (url_type == LYNXDOWNLOAD_URL_TYPE ||
		     url_type == LYNXEXEC_URL_TYPE ||
		     url_type == LYNXPROG_URL_TYPE ||
d723 1
a723 1
		     url_type == LYNXDIRED_URL_TYPE ||
d725 27
a751 33
		     url_type == LYNXPRINT_URL_TYPE ||
		     url_type == LYNXOPTIONS_URL_TYPE ||
		     url_type == LYNXCFG_URL_TYPE ||
		     url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
		     url_type == LYNXHIST_URL_TYPE ||
		     url_type == LYNXCOOKIE_URL_TYPE ||
		     url_type == LYNXMESSAGES_URL_TYPE ||
		     (LYValidate &&
		      url_type != HTTP_URL_TYPE &&
		      url_type != HTTPS_URL_TYPE) ||
		     ((no_file_url || no_goto_file) &&
		      url_type == FILE_URL_TYPE) ||
		     (no_goto_lynxcgi &&
		      url_type == LYNXCGI_URL_TYPE) ||
#ifndef DISABLE_BIBP
		     (no_goto_bibp &&
		      url_type == BIBP_URL_TYPE) ||
#endif
		     (no_goto_cso &&
		      url_type == CSO_URL_TYPE) ||
		     (no_goto_finger &&
		      url_type == FINGER_URL_TYPE) ||
		     (no_goto_ftp &&
		      (url_type == FTP_URL_TYPE ||
		       url_type == NCFTP_URL_TYPE)) ||
		     (no_goto_gopher &&
		      url_type == GOPHER_URL_TYPE) ||
		     (no_goto_http &&
		      url_type == HTTP_URL_TYPE) ||
		     (no_goto_https &&
		      url_type == HTTPS_URL_TYPE) ||
		     (no_goto_mailto &&
		      url_type == MAILTO_URL_TYPE) ||
d753 4
a756 4
		     (no_goto_news &&
		      url_type == NEWS_URL_TYPE) ||
		     (no_goto_nntp &&
		      url_type == NNTP_URL_TYPE) ||
d758 2
a759 2
		     (no_goto_rlogin &&
		      url_type == RLOGIN_URL_TYPE) ||
d761 2
a762 2
		     (no_goto_snews &&
		      url_type == SNEWS_URL_TYPE) ||
d764 63
a826 18
		     (no_goto_telnet &&
		      url_type == TELNET_URL_TYPE) ||
		     (no_goto_tn3270 &&
		      url_type == TN3270_URL_TYPE) ||
		     (no_goto_wais &&
		      url_type == WAIS_URL_TYPE))) {
		    /*
		     * Some schemes are not acceptable from server
		     * redirections.  - KW & FM
		     */
		    HTAlert(ILLEGAL_REDIRECTION_URL);
		    if (LYCursesON) {
			HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE,
				   use_this_url_instead);
		    } else {
			fprintf(stderr,
				WWW_ILLEGAL_URL_MESSAGE,
				use_this_url_instead);
a827 82
		    FREE(use_this_url_instead);
		    return (NULLFILE);
		}
		if ((pound = findPoundSelector(doc->address)) != NULL
		    && findPoundSelector(use_this_url_instead) == NULL) {
		    /*
		     * Our requested URL had a fragment associated with it,
		     * and the redirection URL doesn't, so we'll append the
		     * fragment associated with the original request.  If
		     * it's bogus for the redirection URL, we'll be
		     * positioned at the top of that document, so there's
		     * no harm done.  - FM
		     */
		    CTRACE((tfp,
			    "getfile: Adding fragment '%s' to redirection URL.\n",
			    pound));
		    StrAllocCat(use_this_url_instead, pound);
		    doc->link = -1;
		}
		CTRACE_SLEEP(MessageSecs);
		HTUserMsg2(WWW_USING_MESSAGE, use_this_url_instead);
		CTRACE((tfp, "\n"));
		StrAllocCopy(doc->address,
			     use_this_url_instead);
		FREE(use_this_url_instead);
		if (redirect_post_content == FALSE) {
		    /*
		     * Freeing the content also yields a GET request.  - FM
		     */
		    LYFreePostData(doc);
		}
		/*
		 * Go to top to check for URL's which get special handling
		 * and/or security checks in Lynx.  - FM
		 */
		goto Try_Redirected_URL;
	    }
	    if (HTNoDataOK) {
		return (NULLFILE);
	    } else {
		return (NOT_FOUND);
	    }
	} else {

	    lynx_mode = NORMAL_LYNX_MODE;

	    /*
	     * Some URL's don't actually return a document; compare
	     * doc->address with the document that is actually loaded and
	     * return NULLFILE if not loaded.  If www_search_result is not -1
	     * then this is a reference to a named anchor within the same
	     * document; do NOT return NULLFILE in that case.
	     */

	    /*
	     * Check for a #fragment selector.
	     */
	    pound = findPoundSelector(doc->address);

	    /*
	     * Check to see if there is a temp file waiting for us to
	     * download.
	     */
	    if (WWW_Download_File) {
		HTParentAnchor *tmpanchor = HTAnchor_findAddress(&WWWDoc);
		char *fname = NULL;

		/*
		 * Check for a suggested filename from the
		 * Content-Disposition header.  - FM
		 */
		if (HTAnchor_SugFname(tmpanchor) != NULL) {
		    StrAllocCopy(fname, HTAnchor_SugFname(tmpanchor));
		} else {
		    StrAllocCopy(fname, doc->address);
		}
		/*
		 * Check whether this is a compressed file, which we don't
		 * uncompress for downloads, and adjust any suffix
		 * appropriately.  - FM
		 */
		HTCheckFnameForCompression(&fname, tmpanchor, FALSE);
d829 1
a829 22
		if (LYdownload_options(&fname,
				       WWW_Download_File) < 0) {
		    FREE(fname);
		    return (NOT_FOUND);
		}
		LYAddVisitedLink(doc);
		StrAllocCopy(doc->address, fname);
		FREE(fname);
		doc->internal_link = FALSE;
		WWWDoc.address = doc->address;
		LYFreePostData(doc);
		WWWDoc.post_data = NULL;
		WWWDoc.post_content_type = NULL;
		WWWDoc.bookmark = doc->bookmark = FALSE;
		WWWDoc.isHEAD = doc->isHEAD = FALSE;
		WWWDoc.safe = doc->safe = FALSE;
		HTOutputFormat = WWW_PRESENT;
		if (!HTLoadAbsolute(&WWWDoc)) {
		    return (NOT_FOUND);
		} else {
		    return (NORMAL);
		}
a830 28
	    } else if (pound == NULL &&
		/*
		 * HTAnchor hash-table searches are now case-sensitive
		 * (hopefully, without anchor deletion problems), so this
		 * is too.  - FM
		 */
		       (strcmp(doc->address,
			       HTLoadedDocumentURL()) ||
		/*
		 * Also check the post_data elements.  - FM
		 */
			!BINEQ(doc->post_data,
			       HTLoadedDocumentPost_data()) ||
		/*
		 * Also check the isHEAD element.  - FM
		 */
			doc->isHEAD != HTLoadedDocumentIsHEAD())) {
		/*
		 * Nothing needed to be shown.
		 */
		LYAddVisitedLink(doc);
		return (NULLFILE);

	    } else {
		if (pound != NULL) {
		    if (!HTMainText) {	/* this should not happen... */
			return (NULLFILE);	/* but it can. - kw */
		    }
d832 7
a838 1
		     * May set www_search_result.
d840 93
a932 3
		    if (HTFindPoundSelector(pound + 1)) {
			*target = www_search_result;
			doc->link = -1;
d935 6
a940 44
		return (NORMAL);
	    }
	}
    } else {
	CTRACE_SLEEP(MessageSecs);
	HTUserMsg2(WWW_BAD_ADDR_MESSAGE, doc->address);
	CTRACE((tfp, "\n"));
	return (NULLFILE);
    }
}

/*
 * Set source mode for the next retrieval via getfile or HTreparse_document.
 * mode == -1:  force normal presentation
 * mode == 1:  force source presentation
 * mode == 0:  reset to normal if it was set to source
 * - kw
 */
void srcmode_for_next_retrieval(int mode)
{
    if (mode < 0) {
	HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	psrc_view = FALSE;
#endif

    } else if (mode == 0) {
	if (HTOutputFormat == WWW_SOURCE)
	    HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	else if (LYpsrc)
	    psrc_view = FALSE;
#endif

    } else {
#ifdef USE_PRETTYSRC
	if (LYpsrc)
	    psrc_view = TRUE;
	else
	    HTOutputFormat = WWW_SOURCE;
#else
	HTOutputFormat = WWW_SOURCE;
#endif
    }
d944 14
a957 18
 * The user wants to select a link or page by number.
 *
 * If follow_link_number returns DO_LINK_STUFF do_link will be run immediately
 * following its execution.
 *
 * If follow_link_number returns DO_GOTOLINK_STUFF it has updated the passed in
 * doc for positioning on a link.
 *
 * If follow_link_number returns DO_GOTOPAGE_STUFF it has set doc->line to the
 * top line of the desired page for displaying that page.
 *
 * If follow_link_number returns PRINT_ERROR an error message will be given to
 * the user.
 *
 * If follow_link_number returns DO_FORMS_STUFF some forms stuff will be done. 
 * (Not yet implemented.)
 *
 * If follow_link_number returns DO_NOTHING nothing special will run after it.
d959 5
a963 4
int follow_link_number(int c,
		       int cur,
		       DocInfo *doc,
		       int *num)
d970 1
a970 1
    int curline = *num;		/* passed in from mainloop() */
d972 2
a973 2
    CTRACE((tfp, "follow_link_number(%d,%d,...)\n", c, cur));
    temp[0] = (char) c;
d978 1
a978 1
     * Get the number, possibly with a letter suffix, from the user.
d982 1
a982 1
	return (DO_NOTHING);
d985 1
a985 1
    while (isdigit(UCH(*p)))
d987 3
a989 4
    c = *p;			/* reuse c; 0 or g or p or + or - */
    switch (c) {
    case '+':
    case '-':
d991 1
a991 2
	rel = c;
	c = *++p;
a994 1
	break;
d1000 1
a1000 1
    CTRACE((tfp, "  temp=%s, *num=%d, rel='%c'\n", temp, *num, rel));
d1002 2
a1003 2
     * Check if we had a 'p' or 'P' following the number as a flag for
     * displaying the page with that number.  - FM
d1005 1
a1005 5
    if ((c == 'p' || c == 'P') && display_lines == 0) {
	CTRACE((tfp, " curline=%d, LYlines=%d, display too small!\n",
		curline, LYlines));
	return (PRINT_ERROR);
    } else if (c == 'p' || c == 'P') {
d1008 2
a1009 2
	(((nlines + 1) + (display_lines - 1)) / (display_lines))
	: 1;
d1011 4
a1014 5
	(((curline + 1) + (display_lines - 1)) / (display_lines))
	: 1;

	CTRACE((tfp, " nlines=%d, npages=%d, curline=%d, curpage=%d\n",
		nlines, npages, curline, curpage));
d1017 1
a1017 1
	if (rel == '+')
d1019 1
a1019 1
	else if (rel == '-')
d1022 4
a1025 4
	    1 :
	    ((*num <= npages) ? (((*num - 1) * display_lines) + 1)
	     : (((npages - 1) * display_lines) + 1));
	return (DO_GOTOPAGE_STUFF);
d1029 2
a1030 2
     * Check if we want to make the link corresponding to the number the
     * current link, rather than ACTIVATE-ing it.
d1032 1
a1032 1
    want_go = (BOOL) (c == 'g' || c == 'G');
d1037 6
a1042 6
    if (rel)
	*num = HTGetRelLinkNum(*num, rel, cur);
    /*
     * If we have a valid number, act on it.
     */
    if (*num > 0) {
a1043 2
	char *text = NULL;

d1045 8
a1052 6
	 * Get the lname, and hightext, directly from www structures and add it
	 * to the cur link so that we can pass it transparently on to
	 * getfile(), and load new_top and new_link if we instead want to make
	 * the link number current.  These things are done so that a link can
	 * be selected anywhere in the current document, whether it is
	 * displayed on the screen or not!
d1054 6
a1059 9
	info = HTGetLinkInfo(*num,
			     want_go,
			     &new_top,
			     &new_link,
			     &text,
			     &links[cur].lname);
	if (text != NULL)
	    LYSetHilite(cur, text);
	if (info == WWW_INTERN_LINK_TYPE) {
d1061 1
a1061 1
	    return (DO_LINK_STUFF);
d1065 1
a1065 1
	    return (DO_GOTOLINK_STUFF);
d1068 1
a1068 1
	    return (DO_LINK_STUFF);
d1070 1
a1070 1
	    return (PRINT_ERROR);
d1073 1
a1073 1
	return (PRINT_ERROR);
d1080 4
a1083 4
    char *src;
    char *path;
    int type;
    struct trust *next;
d1086 2
a1087 3
static struct trust trusted_exec_default =
{
    "file://localhost/", "", EXEC_PATH, NULL
d1089 2
a1090 3
static struct trust always_trusted_exec_default =
{
    "none", "", ALWAYS_EXEC_PATH, NULL
d1092 2
a1093 3
static struct trust trusted_cgi_default =
{
    "", "", CGI_PATH, NULL
d1101 1
a1101 1
static void LYTrusted_free(void)
d1143 3
a1145 2
void add_trusted(char *str,
		 int type)
d1168 1
a1168 1
    tp = (struct trust *) malloc(sizeof(*tp));
d1198 1
a1198 1
 * Check to see if the supplied paths is allowed to be executed.
d1200 4
a1203 3
BOOLEAN exec_ok(const char *source,
		const char *linktext,
		int type)
d1206 1
a1206 2
    const char *cp;
    const char *allowed_extra_chars;
d1210 1
a1210 1
     * Always OK if it is a jump file shortcut.
d1216 1
a1216 1
     * Choose the trust structure based on the type.
d1231 1
a1231 1
     * Security:  reject on relative path.
a1234 1

d1248 1
a1248 1
     * Security:  reject on relative path.
d1256 1
a1256 1
     * Security:  reject on strange character.
a1257 4
    if (Type == CGI_PATH)
	allowed_extra_chars = " _-:./@@~$&+=\t";
    else
	allowed_extra_chars = " _-:./@@~$+=\t";
d1259 6
a1264 1
	if (!isalnum(UCH(*cp)) && !strchr(allowed_extra_chars, *cp)) {
d1268 2
a1269 2
		       BADCHAR_IN_EXEC_LINK,
		       *cp);
d1277 1
a1277 1
  check_tp_for_entry:
d1280 1
a1280 1
	    char const *command = linktext;
d1282 1
a1282 1
	    if (strstr(command, "//") == linktext) {
d1285 7
a1291 2
	    if (STRNADDRCOMP(source, tp->src, strlen(tp->src)) == 0 &&
		STRNADDRCOMP(command, tp->path, strlen(tp->path)) == 0)
d1308 2
a1309 1
static int fix_httplike_urls(DocInfo *doc, UrlTypes type)
d1314 1
a1314 1
     * If there's a fragment present, our simplistic methods won't work.  - kw
d1316 4
a1319 11
    if (findPoundSelector(doc->address) != NULL)
	return 0;

#ifndef DISABLE_FTP
    /*
     * If it's an ftp URL with a trailing slash, trim it off.
     */
    if (type == FTP_URL_TYPE &&
	LYIsHtmlSep(doc->address[strlen(doc->address) - 1])) {
	char *proxy;
	char *path = HTParse(doc->address, "", PARSE_PATH | PARSE_PUNCTUATION);
d1322 1
a1322 1
	 * If the path is a lone slash, we're done.  - FM
d1333 1
a1333 1
	 * If we're proxying ftp, don't trim anything.  - KW
d1335 2
a1336 2
	if (((proxy = LYGetEnv("ftp_proxy")) != NULL) &&
	    !override_proxy(doc->address))
d1340 1
a1340 1
	 * If we get to here, trim the trailing slash.  - FM
d1342 1
a1342 1
	CTRACE((tfp, "fix_httplike_urls: URL '%s'\n", doc->address));
d1344 1
a1344 15
	CTRACE((tfp, "            changed to '%s'\n", doc->address));
	CTRACE_SLEEP(MessageSecs);
    } else if (type == NCFTP_URL_TYPE) {
	char *path = NULL;
	char *first = doc->address;
	char *second = strchr(first, ':');

	CTRACE((tfp, "fix_httplike_urls: URL '%s'\n", doc->address));

	*second++ = '\0';
	HTSprintf0(&path, "%s//%s%s", STR_FTP_URL, first, second);
	FREE(doc->address);
	doc->address = path;

	CTRACE((tfp, "            changed to '%s'\n", doc->address));
a1346 1
#endif /* DISABLE_FTP */
d1349 1
a1349 1
     * If there isn't a slash besides the two at the beginning, append one.
d1352 2
a1353 22
	if (!LYIsHtmlSep(*(slash - 1)) || *(slash - 2) != ':') {
	    return (0);
	}
	if (type == HTTP_URL_TYPE ||
	    type == HTTPS_URL_TYPE) {
	    if ((slash - 2) != strchr(doc->address, ':')) {
		/*
		 * Turns out we were not looking at the right slash after all,
		 * there must have been more than one "://" which is valid at
		 * least for http URLs (later occurrences can be part of a
		 * query string, for example), so leave this alone, too.  - kw
		 */
		return (0);
	    }
	    if (strchr(doc->address, '?')) {
		/*
		 * If there is a question mark that appears to be part of the
		 * hostname, don't append anything either.  Leave it to HTParse
		 * to interpret the question mark as ending the hostname.  - kw
		 */
		return (0);
	    }
d1356 1
a1356 1
    CTRACE((tfp, "fix_httplike_urls: URL '%s'\n", doc->address));
d1358 1
a1358 1
    CTRACE((tfp, "            changed to '%s'\n", doc->address));
d1361 1
a1361 1
    return (1);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d17 1
a30 2
#include <LYHistory.h>
#include <LYPrettySrc.h>
d35 5
a39 1
PRIVATE int fix_httplike_urls PARAMS((DocInfo *doc, UrlTypes type));
d41 2
d44 2
a45 6
#define STRNADDRCOMP strncasecomp
#else
#define STRNADDRCOMP strncmp
#endif /* !VMS */

PUBLIC int HTNoDataOK = 0;
d47 2
a48 25
/*
 *  getfile is the main mechanism to load a new document (or a previously
 *  loaded one whose rendering is cached in a HText structure) from
 *  mainloop, nearly everything goes through it.
 *  It should return one of the values
 *     NORMAL     - requested document loaded successfully, usually [always?]
 *                  its rendering is available as HTMainText.  It can be an
 *                  HTTP error message page or similar, we make no
 *                  distinction here.
 *     NOT_FOUND  - requested document cannot be accessed, and the reason
 *                  is a real error (as may be caused by an invalid link),
 *                  not just that lynx disallows access because of some
 *                  permission restrictions, and we have no error page
 *                  to show for it either.
 *     NULLFILE   - requested document not loaded into HTMainText, either
 *                  some interactive protocol was requested (like telnet),
 *                  or lynx does not allow access.
 *  The distinction between NOT_FOUND and NULLFILE is not very crucial,
 *  but getting it right prevents mainloop from exiting with the wrong
 *  message if it happens for the first file, and from logging (or not
 *  logging) errors inappropriately with -traversal, and from sending
 *  bogus error mail with MAIL_SYSTEM_ERROR_LOGGING:TRUE. - kw
 */
PUBLIC int getfile ARGS1(
	DocInfo *,	doc)
d50 4
a53 4
    int url_type = 0;
    char *cp = NULL;
    char *temp = NULL;
    DocAddress WWWDoc;  /* a WWW absolute doc address struct */
d55 7
a61 7
    /*
     *  Reset LYCancelDownload to prevent unwanted delayed effect. - KW
     */
    if (LYCancelDownload) {
	CTRACE((tfp, "getfile:    resetting LYCancelDownload to FALSE\n"));
	LYCancelDownload = FALSE;
    }
d63 4
a66 12
    /*
     *  Reset fake 'Z' to prevent unwanted delayed effect. - kw
     */
    LYFakeZap(NO);

    /*
     *  Reset redirection counter to prevent bogus TOO_MANY_REDIRECTIONS
     *  in rare situations if the previous cycle got to the limit, but
     *  did not fail for that reason because the URL of the final location
     *  was handled specially, not via HTLoadAbsolute. - kw
     */
    redirection_attempts = 0;
d69 9
a77 9
    /*
     *  Load the WWWDoc struct in case we need to use it.
     */
    WWWDoc.address = doc->address;
    WWWDoc.post_data = doc->post_data;
    WWWDoc.post_content_type = doc->post_content_type;
    WWWDoc.bookmark = doc->bookmark;
    WWWDoc.isHEAD = doc->isHEAD;
    WWWDoc.safe = doc->safe;
d79 4
a82 4
    /*
     *  Reset HTPermitRedir, it has done its job if it was set. - kw
     */
    HTPermitRedir = FALSE;
d84 4
a87 4
    /*
     *  Reset WWW_Download_File just in case.
     */
    FREE(WWW_Download_File);
d89 1
a89 4
    /*
     *  Reset redirect_post_content just in case.
     */
    redirect_post_content = FALSE;
d91 38
a128 35
    /*
     *  This flag is a hack to allow us to pass on the fact
     *  that 'no data' may not really be an error although
     *  HTLoadAbsolute returned NO.  There should be a better
     *  way...  HT_NO_DATA should always mean 'not data but
     *  not an error', and be passed on to us as that, but
     *  current usage if HT_NO_DATA vs HT_NOT_LOADED has
     *  to be reviewed everywhere.
     *  Anyway, some protocol module can set it to say
     *  'I really mean it', we have to reset it here. - kw
     */
    HTNoDataOK = 0;

    CTRACE((tfp,"getfile: getting %s\n\n",doc->address));

    /*
     *  Protect against denial of service attacks
     *  via the port 19 CHARGEN service, and block
     *  connections to the port 25 ESMTP service.
     *  Also reject any likely spoof attempts via
     *  wrap arounds at 65536. - FM
     */
    if ((temp = HTParse(doc->address, "", PARSE_HOST)) != NULL &&
	strlen(temp) > 3) {
	char *cp1;

	if ((cp1 = strchr(temp, '@@')) == NULL)
	    cp1 = temp;
	if ((cp = strrchr(cp1, ':')) != NULL) {
	    long int value;

	    cp++;
	    if (sscanf(cp, "%ld", &value) == 1) {
		if (value == 19 || value == 65555) {
		    HTAlert(PORT_NINETEEN_INVALID);
d132 95
a226 4
		if (value == 25 || value == 65561) {
		    HTAlert(PORT_TWENTYFIVE_INVALID);
		    FREE(temp);
		    return(NULLFILE);
d228 9
a236 6
		if (value > 65535 || value < 0) {
		    char *msg = 0;
		    HTSprintf0(&msg, PORT_INVALID, (unsigned long)value);
		    HTAlert(msg);
		    FREE(msg);
		    FREE(temp);
a237 10
		}
	    } else if (isdigit(UCH(*cp))) {
		HTAlert(URL_PORT_BAD);
		FREE(temp);
		return(NULLFILE);
	    }
	}
    }
    cp = NULL;
    FREE(temp);
d239 3
a241 106
    /*
     *  Check to see if this is a universal document ID
     *  that lib WWW wants to handle.
     *
     *  Some special URL's we handle ourselves. :)
     */
    if ((url_type = is_url(doc->address)) != 0) {
	if (LYValidate && !LYPermitURL) {
	    if (!(url_type == HTTP_URL_TYPE ||
		  url_type == HTTPS_URL_TYPE ||
		  url_type == LYNXHIST_URL_TYPE ||
		  url_type == LYNXKEYMAP_URL_TYPE ||
		  url_type == LYNXIMGMAP_URL_TYPE ||
		  url_type == LYNXCOOKIE_URL_TYPE ||
		  url_type == LYNXMESSAGES_URL_TYPE ||
		  (url_type == LYNXOPTIONS_URL_TYPE &&
		   WWWDoc.post_data) ||
		  0==STRNADDRCOMP(WWWDoc.address, helpfilepath,
				  strlen(helpfilepath)) ||
		  (lynxlistfile != NULL &&
		   0==STRNADDRCOMP(WWWDoc.address, lynxlistfile,
				  strlen(lynxlistfile))) ||
		  (lynxlinksfile != NULL &&
		   0==STRNADDRCOMP(WWWDoc.address, lynxlinksfile,
				  strlen(lynxlinksfile))) ||
		  (lynxjumpfile != NULL &&
		   0==STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
				  strlen(lynxjumpfile))))) {
		HTUserMsg(NOT_HTTP_URL_OR_ACTION);
		return(NULLFILE);
	    }
	}
	if (traversal) {
	    /*
	     *	Only traverse http URLs.
	     */
	    if (url_type != HTTP_URL_TYPE &&
		url_type != LYNXIMGMAP_URL_TYPE) {
		return(NULLFILE);
	    }
	} else if (check_realm && !LYPermitURL && !LYJumpFileURL) {
	    if (!(0==strncmp(startrealm, WWWDoc.address,
			     strlen(startrealm)) ||
		  url_type == LYNXHIST_URL_TYPE ||
		  url_type == LYNXKEYMAP_URL_TYPE ||
		  url_type == LYNXIMGMAP_URL_TYPE ||
		  url_type == LYNXCOOKIE_URL_TYPE ||
		  url_type == LYNXPRINT_URL_TYPE ||
		  url_type == LYNXOPTIONS_URL_TYPE ||
		  url_type == LYNXCFG_URL_TYPE ||
		  url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
		  url_type == LYNXMESSAGES_URL_TYPE ||
		  url_type == LYNXDOWNLOAD_URL_TYPE ||
		  url_type == MAILTO_URL_TYPE ||
		  url_type == NEWSPOST_URL_TYPE ||
		  url_type == NEWSREPLY_URL_TYPE ||
		  url_type == SNEWSPOST_URL_TYPE ||
		  url_type == SNEWSREPLY_URL_TYPE ||
		  (!LYUserSpecifiedURL &&
		   (url_type == LYNXEXEC_URL_TYPE ||
		    url_type == LYNXPROG_URL_TYPE ||
		    url_type == LYNXCGI_URL_TYPE)) ||
		  (WWWDoc.bookmark != NULL &&
		   *WWWDoc.bookmark != '\0') ||
		  0==STRNADDRCOMP(WWWDoc.address, helpfilepath,
				  strlen(helpfilepath)) ||
		  (lynxlistfile != NULL &&
		   0==STRNADDRCOMP(WWWDoc.address, lynxlistfile,
				  strlen(lynxlistfile))) ||
		  (lynxjumpfile != NULL &&
		   0==STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
				  strlen(lynxjumpfile))))) {
		HTUserMsg(NOT_IN_STARTING_REALM);
		return(NULLFILE);
	    }
	}
	if (WWWDoc.post_data &&
	    url_type != HTTP_URL_TYPE &&
	    url_type != HTTPS_URL_TYPE &&
	    url_type != LYNXCGI_URL_TYPE &&
	    url_type != LYNXIMGMAP_URL_TYPE &&
	    url_type != GOPHER_URL_TYPE &&
	    url_type != CSO_URL_TYPE &&
	    url_type != PROXY_URL_TYPE &&
	    url_type != LYNXOPTIONS_URL_TYPE &&
	    !(url_type == FILE_URL_TYPE &&
	      (LYIsUIPage(WWWDoc.address, UIP_LIST_PAGE) ||
	       LYIsUIPage(WWWDoc.address, UIP_ADDRLIST_PAGE)))) {
	    CTRACE((tfp, "getfile: dropping post_data!\n"));
	    HTAlert(IGNORED_POST);
	    LYFreePostData(doc);
	    WWWDoc.post_data = NULL;
	    WWWDoc.post_content_type = NULL;
	}
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
	LYSyslog (doc->address);
#endif
	if (url_type == UNKNOWN_URL_TYPE ||
	    url_type == AFS_URL_TYPE ||
	    url_type == PROSPERO_URL_TYPE) {
	    HTAlert(UNSUPPORTED_URL_SCHEME);
	    return(NULLFILE);

	} else if (url_type == DATA_URL_TYPE) {
	    HTAlert(UNSUPPORTED_DATA_URL);
	    return(NULLFILE);
d243 2
a244 2
	} else if (url_type == LYNXPRINT_URL_TYPE) {
	    return(printfile(doc));
d247 3
a249 3
	} else if (url_type == LYNXOPTIONS_URL_TYPE) {
	    /* proceed forms-based options menu */
	    return(postoptions(doc));
d252 3
a254 6
	} else if (url_type == LYNXCFG_URL_TYPE &&
	    !no_lynxcfg_info) {
	    /* @@@@@@ maybe we should generate a specific error message
	       if attempted but restricted. - kw */
	    /* show/change/reload lynx.cfg settings */
	    return(lynx_cfg_infopage(doc));
d257 3
a259 6
	} else if (url_type == LYNXCOMPILE_OPTS_URL_TYPE &&
	    !no_compileopts_info) {
	    /* @@@@@@ maybe we should generate a specific error message
	       if attempted but restricted or not supported. - kw */
	    /* show compile-time settings */
	    return(lynx_compile_opts(doc));
d262 4
d267 12
a278 17
	} else if (url_type == NEWSPOST_URL_TYPE ||
		   url_type == NEWSREPLY_URL_TYPE ||
		   url_type == SNEWSPOST_URL_TYPE ||
		   url_type == SNEWSREPLY_URL_TYPE) {

	    if (no_newspost) {
		HTUserMsg(NEWSPOSTING_DISABLED);
		return(NULLFILE);
	    } else if (!news_ok && (
		url_type == NEWSPOST_URL_TYPE ||
		url_type == NEWSREPLY_URL_TYPE)) {
		HTUserMsg(NEWS_DISABLED);
		return(NULLFILE);
	    } else {
		HTLoadAbsolute(&WWWDoc);
		return(NULLFILE);
	    }
d281 2
a282 2
	} else if (url_type == LYNXDOWNLOAD_URL_TYPE) {
	    LYDownload(doc->address);
d284 14
a297 10
	    if (LYDidRename) {
		/*
		 *  The temporary file was saved to disk via a
		 *  rename(), so we can't access the temporary
		 *  file again via the download menu.  Clear the
		 *  flag, and return NULLFILE to pop. - FM
		 */
		LYDidRename = FALSE;
		return(NULLFILE);
	    }
d299 1
a299 2
	    return(NORMAL);
	} else if (url_type == LYNXDIRED_URL_TYPE) {
d301 19
a319 14
	    if (!no_dired_support) {
	       local_dired(doc);
	       WWWDoc.address = doc->address;
	       WWWDoc.post_data = doc->post_data;
	       WWWDoc.post_content_type = doc->post_content_type;
	       WWWDoc.bookmark = doc->bookmark;
	       WWWDoc.isHEAD = doc->isHEAD;
	       WWWDoc.safe = doc->safe;

	       if (!HTLoadAbsolute(&WWWDoc)) {
		   return(NOT_FOUND);
	       }
	       return(NORMAL);
	    }
a320 3
	    HTUserMsg(DIRED_DISABLED);
	    return(NULLFILE);
	}
d322 11
a332 48
	if (LYNoRefererHeader == FALSE &&
	    LYNoRefererForThis == FALSE) {
	    char *ref_url = HTLoadedDocumentURL();
	    if (isLYNXIMGMAP(ref_url))
		ref_url += LEN_LYNXIMGMAP;
	    if (no_filereferer == TRUE && isFILE_URL(ref_url)) {
		LYNoRefererForThis = TRUE;
	    }
	    if (LYNoRefererForThis == FALSE &&
		(cp = strchr(ref_url, '?')) != NULL &&
		strchr(cp, '=') != NULL) {
		/*
		 *  Don't send a Referer header if the URL is
		 *  the reply from a form with method GET, in
		 *  case the content has personal data (e.g.,
		 *  a password or credit card number) which
		 *  would become visible in logs. - FM
		 *
		 *  Changed 1999-11-01 to be controlled by
		 *  REFERER_WITH_QUERY option. - kw
		 */
		if (LYRefererWithQuery == 'S') { /* SEND */
		    StrAllocCopy(LYRequestReferer, ref_url);
		} else if (LYRefererWithQuery == 'P') { /* PARTIAL */
		    FREE(LYRequestReferer); /* just to be sure */
		    LYRequestReferer = HTParse(ref_url, "",
					       PARSE_ACCESS|PARSE_HOST|PARSE_STRICTPATH|PARSE_PUNCTUATION);
		} else { /* Everything else - don't send Referer */
		    LYNoRefererForThis = TRUE;
		}
		cp = NULL;
	    } else if (LYNoRefererForThis == FALSE) {
		StrAllocCopy(LYRequestReferer, ref_url);
	    }
	} else {
	    StrAllocCopy(LYRequestReferer, HTLoadedDocumentURL());
	}
	if (url_type == LYNXHIST_URL_TYPE) {
	    /*
	     *	'doc' will change to the new file
	     *	if we had a successful LYpop_num(),
	     *	and the return value will be FALSE
	     *	if we had a cancel. - FM
	     */
	    if ((historytarget(doc) == FALSE) ||
		!doc || !doc->address) {
		return(NOT_FOUND);
	    }
d334 9
a342 9
	    /*
	     *	We changed it so reload.
	     */
	    WWWDoc.address = doc->address;
	    WWWDoc.post_data = doc->post_data;
	    WWWDoc.post_content_type = doc->post_content_type;
	    WWWDoc.bookmark = doc->bookmark;
	    WWWDoc.isHEAD = doc->isHEAD;
	    WWWDoc.safe = doc->safe;
d344 3
a346 3
	    if (doc->internal_link && !reloading) {
		LYinternal_flag = TRUE;
	    }
d349 4
a352 7
#ifdef DIRED_SUPPORT
	    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
	    if (!HTLoadAbsolute(&WWWDoc)) {
		return(NOT_FOUND);
	    }
	    return(NORMAL);
d354 2
a355 2
	} else if (url_type == LYNXEXEC_URL_TYPE ||
		   url_type == LYNXPROG_URL_TYPE) {
d357 10
a366 10
	    if (no_exec &&
		!exec_ok(HTLoadedDocumentURL(),
			 doc->address+9, ALWAYS_EXEC_PATH)) {
		HTUserMsg(EXECUTION_DISABLED);
	    } else if (no_bookmark_exec &&
		       HTLoadedDocumentBookmark()) {
		HTUserMsg(BOOKMARK_EXEC_DISABLED);
	    } else if (local_exec || (local_exec_on_local_files &&
		       exec_ok(HTLoadedDocumentURL(),
			       doc->address+9, EXEC_PATH))) {
d368 1
a368 1
		char *p = NULL;
d370 7
a376 7
		/*
		 *  Bug puts slash on end if none is in the string.
		 */
		char *last_slash = strrchr(doc->address,'/');
		if (last_slash - doc->address
		 == (int)strlen(doc->address) - 1)
		    doc->address[strlen(doc->address)-1] = '\0';
d378 28
a405 30
		/*
		 *  Convert '~' to $HOME.
		 */
		if ((cp = strchr(doc->address, '~'))) {
		    HTSprintf0(&p, "%.*s%s%s",
				   cp - doc->address,
				   doc->address,
				   wwwName(Home_Dir()),
				   cp + 1);
		} else {
		    StrAllocCopy(p, doc->address);
		}
		/*
		 *  Show URL before executing it.
		 */
		HTInfoMsg(doc->address);
		stop_curses();
		/*
		 *  Run the command.
		 */
		if (strstr(p,"//") == p+9)
		    LYSystem(p+11);
		else
		    LYSystem(p+9);
		FREE(p);

		if (url_type != LYNXPROG_URL_TYPE) {
		    /*
		     *	Make sure user gets to see screen output.
		     */
d407 1
a407 1
		    signal(SIGINT, SIG_IGN);
d409 3
a411 3
		    printf("\n%s", RETURN_TO_LYNX);
		    fflush(stdout);
		    (void) LYgetch();
d413 1
a413 1
		    HadVMSInterrupt = FALSE;
d415 3
a417 5
		}
		if (!dump_output_immediately) {
		    start_curses();
		    LYAddVisitedLink(doc);
		}
d419 2
a420 2
	     } else {
		char *buf = 0;
d422 6
a427 6
		HTSprintf0(&buf,
			EXECUTION_DISABLED_FOR_FILE,
			key_for_func(LYK_OPTIONS));
		HTAlert(buf);
		FREE(buf);
	     }
d429 1
a429 1
	     HTUserMsg(EXECUTION_NOT_COMPILED);
d431 1
a431 1
	     return(NULLFILE);
d433 3
a435 19
	} else if (url_type == MAILTO_URL_TYPE) {
	    if (no_mail) {
		HTUserMsg(MAIL_DISABLED);
	    } else {
		HTParentAnchor *tmpanchor = HTAnchor_findAddress(&WWWDoc);
		CONST char *title;
		char *tmptitle = NULL;

		title = "";
		if (HTAnchor_title(tmpanchor)) {
			title = HTAnchor_title(tmpanchor);
		} else if (HTMainAnchor && !LYUserSpecifiedURL) {
		    title = HTAnchor_subject(HTMainAnchor);
		    if (title && *title) {
			if (strncasecomp(title, "Re:", 3)) {
			    StrAllocCopy(tmptitle, "Re: ");
			    StrAllocCat(tmptitle, title);
			    title = tmptitle;
			}
d437 4
d442 26
d469 1
a469 12
		}
		cp = strchr(doc->address,':')+1;
		reply_by_mail(cp,
			      ((HTMainAnchor && !LYUserSpecifiedURL) ?
			       (char *)HTMainAnchor->address :
			       (char *)doc->address),
			      title,
			      (HTMainAnchor && !LYUserSpecifiedURL) ?
			       HTMainAnchor->message_id : NULL);
		FREE(tmptitle);
	    }
	    return(NULLFILE);
d471 14
a484 16
	/*
	 *  From here on we could have a remote host,
	 *  so check if that's allowed.
	 */
	} else if (local_host_only &&
		   url_type != LYNXKEYMAP_URL_TYPE &&
		   url_type != LYNXIMGMAP_URL_TYPE &&
		   url_type != LYNXCOOKIE_URL_TYPE &&
		   url_type != LYNXMESSAGES_URL_TYPE &&
		   url_type != LYNXCGI_URL_TYPE &&
		   !(url_type == NEWS_URL_TYPE &&
		     strncmp(doc->address, "news://", 7)) &&
		   !(LYisLocalHost(doc->address) ||
		     LYisLocalAlias(doc->address))) {
	    HTUserMsg(ACCESS_ONLY_LOCALHOST);
	    return(NULLFILE);
d486 18
a503 36
	/*
	 *  Disable www telnet access if not telnet_ok.
	 */
	} else if (url_type == TELNET_URL_TYPE ||
		   url_type == TN3270_URL_TYPE ||
		   url_type == TELNET_GOPHER_URL_TYPE) {
	    char * proxy;
	    if (!telnet_ok) {
		HTUserMsg(TELNET_DISABLED);
		return(NULLFILE);
	    } else if (no_telnet_port && strchr(doc->address+7, ':')) {
		HTUserMsg(TELNET_PORT_SPECS_DISABLED);
		return(NULLFILE);
	    /*
	     *  Detect weird case where interactive protocol would
	     *  be proxied, and to a non-interactive protocol at that.
	     */
	    } else if ((proxy = LYGetEnv(
		(url_type==TN3270_URL_TYPE) ? "tn3270_proxy" :
		(url_type==TELNET_GOPHER_URL_TYPE) ? "gopher_proxy" :
		"telnet_proxy")) != NULL &&
		       !override_proxy(doc->address) &&
		       (!isTELNET_URL(proxy) &&
			!isTN3270_URL(proxy) &&
			!isRLOGIN_URL(proxy))) {
		/* Do nothing, fall through to generic code - kw */
	    } else {
		stop_curses();
		HTLoadAbsolute(&WWWDoc);
		if (!dump_output_immediately) {
		    start_curses();
		    fflush(stdout);
		    LYAddVisitedLink(doc);
		}
		return(NULLFILE);
	    }
d505 3
a507 3
	/*
	 *  Disable www news access if not news_ok.
	 */
d509 3
a511 5
	} else if (!news_ok && (
	    url_type == NEWS_URL_TYPE ||
	    url_type == NNTP_URL_TYPE)) {
	    HTUserMsg(NEWS_DISABLED);
	    return(NULLFILE);
d514 11
a524 26
	} else if (url_type == RLOGIN_URL_TYPE) {
	    char * proxy;
	    if (!rlogin_ok) {
		HTUserMsg(RLOGIN_DISABLED);
		return(NULLFILE);
	    /*
	     *  Detect weird case where interactive protocol would
	     *  be proxied, and to a non-interactive protocol at that.
	     */
	    } else if ((proxy = LYGetEnv(
		"rlogin_proxy")) != NULL &&
		       !override_proxy(doc->address) &&
		       (!isTELNET_URL(proxy) &&
			!isTN3270_URL(proxy) &&
			!isRLOGIN_URL(proxy))) {
		/* Do nothing, fall through to generic code - kw */
	    } else {
		stop_curses();
		HTLoadAbsolute(&WWWDoc);
		fflush(stdout);
		if (!dump_output_immediately) {
		    start_curses();
		    LYAddVisitedLink(doc);
		}
		return(NULLFILE);
	    }
d526 14
a539 21
	/*
	 *  If it's a gopher index type and there isn't a search
	 *  term already attached then do this.  Otherwise
	 *  just load it!
	 */
	} else if (url_type == INDEX_GOPHER_URL_TYPE &&
		   strchr(doc->address,'?') == NULL) {
	    int status;
	    /*
	     *	Make sure we don't have a gopher+ escaped tab
	     *	instead of a gopher0 question mark delimiting
	     *	the search term. - FM
	     */
	    if ((cp = strstr(doc->address, "%09")) != NULL) {
		*cp = '\0';
		StrAllocCopy(temp, doc->address);
		cp += 3;
		if (*cp && strncmp(cp, "%09", 3)) {
		    StrAllocCat(temp, "?");
		    StrAllocCat(temp, cp);
		    if ((cp = strstr(temp, "%09")) != NULL) {
d541 12
d554 19
a572 29
		}
		StrAllocCopy(doc->address, temp);
		FREE(temp);
		goto Try_Redirected_URL;
	    }
	    /*
	     *	Load it because the do_www_search routine
	     *	uses the base url of the currently loaded
	     *	document :(
	     */
	    if (!HTLoadAbsolute(&WWWDoc)) {
		return(NOT_FOUND);
	    }
	    status = do_www_search(doc);
	    if (status == NULLFILE) {
		LYpop(doc);
		WWWDoc.address = doc->address;
		WWWDoc.post_data = doc->post_data;
		WWWDoc.post_content_type = doc->post_content_type;
		WWWDoc.bookmark = doc->bookmark;
		WWWDoc.isHEAD = doc->isHEAD;
		WWWDoc.safe = doc->safe;
		status = HTLoadAbsolute(&WWWDoc);
#ifdef DIRED_SUPPORT
	    } else {
		lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
	    }
	    return(status);
a573 56
	}
	{
	    if (!ftp_ok
	     && (url_type == FTP_URL_TYPE
	      || url_type == NCFTP_URL_TYPE)) {
		HTUserMsg(FTP_DISABLED);
		return(NULLFILE);
	    }

	    if (url_type == HTML_GOPHER_URL_TYPE) {
		char *tmp=NULL;
	       /*
		*  If tuple's Path=GET%20/... convert to an http URL.
		*/
		if ((cp=strchr(doc->address+9, '/')) != NULL &&
		   0==strncmp(++cp, "hGET%20/", 8)) {
		    StrAllocCopy(tmp, "http://");
		    CTRACE((tfp, "getfile: URL '%s'\n",
				doc->address));
		    *cp = '\0';
		    StrAllocCat(tmp, doc->address+9);
		   /*
		    *  If the port is defaulted, it should stay 70.
		    */
		    if (strchr(tmp+6, ':') == NULL) {
			StrAllocCat(tmp, "70/");
			tmp[strlen(tmp)-4] = ':';
		    }
		    if (strlen(cp+7) > 1)
			StrAllocCat(tmp, cp+8);
		    StrAllocCopy(doc->address, tmp);
		    CTRACE((tfp, "  changed to '%s'\n",
				doc->address));
		    FREE(tmp);
		    url_type = HTTP_URL_TYPE;
		}
	    }
	    if (url_type == HTTP_URL_TYPE ||
		url_type == HTTPS_URL_TYPE ||
		url_type == FTP_URL_TYPE ||
		url_type == NCFTP_URL_TYPE ||
		url_type == CSO_URL_TYPE)
		fix_httplike_urls(doc, url_type);
	    WWWDoc.address = doc->address;  /* possible reload */
#ifdef DIRED_SUPPORT
	    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
#ifndef DISABLE_BIBP
	    if (url_type == BIBP_URL_TYPE) {
		char *bibpTmp = NULL;
		if (!BibP_bibhost_checked)
		    LYCheckBibHost();
		if (BibP_bibhost_available) {
		    StrAllocCopy(bibpTmp, BibP_bibhost);
		} else if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
		    StrAllocCopy(bibpTmp, HTAnchor_citehost(HTMainAnchor));
a574 15
		    StrAllocCopy(bibpTmp, BibP_globalserver);
		}
		if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
		    StrAllocCat(bibpTmp, "bibp1.0/resolve?citehost=");
		    StrAllocCat(bibpTmp, HTAnchor_citehost(HTMainAnchor));
		    StrAllocCat(bibpTmp, "&usin=");
		} else {
		    StrAllocCat(bibpTmp, "bibp1.0/resolve?usin=");
		}
		StrAllocCat(bibpTmp, doc->address+5); /* USIN after bibp: */
		StrAllocCopy(doc->address, bibpTmp);
		WWWDoc.address = doc->address;
		FREE(bibpTmp);
	    }
#endif /* !DISABLE_BIBP */
d576 3
a578 28
	    if (url_type == FILE_URL_TYPE) {
		/*
		 *  If a file URL has a '~' as the lead character
		 *  of its first symbolic element, convert the '~'
		 *  to Home_Dir(), then append the rest of of path,
		 *  if present, skipping "user" if "~user" was
		 *  entered, simplifying, and eliminating any
		 *  residual relative elements. - FM
		 */
		if (((cp = HTParse(doc->address, "",
			   PARSE_PATH+PARSE_ANCHOR+PARSE_PUNCTUATION))
		      != NULL) &&
		    !strncmp(cp, "/~", 2)) {
		    char *cp1 = strstr(doc->address, "/~");
		    char *cp2;

		    CTRACE((tfp, "getfile: URL '%s'\n",
				doc->address));
		    *cp1 = '\0';
		    cp1 += 2;
		    StrAllocCopy(temp, doc->address);
		    StrAllocCopy(cp, wwwName(Home_Dir()));
		    if (!LYIsHtmlSep(*cp))
			LYAddHtmlSep(&temp);
		    StrAllocCat(temp, cp);
		    if ((cp2 = strchr(cp1, '/')) != NULL) {
			LYTrimRelFromAbsPath(cp2);
			StrAllocCat(temp, cp2);
a579 10
		    StrAllocCopy(doc->address, temp);
		    FREE(temp);
		    CTRACE((tfp, "  changed to '%s'\n",
				doc->address));
		    WWWDoc.address = doc->address;
		}
		FREE(cp);
	    }
	    CTRACE_SLEEP(MessageSecs);
	    user_message(WWW_WAIT_MESSAGE, doc->address);
d581 26
a606 41
	    if (TRACE) {
#ifdef USE_SLANG
		if (LYCursesON) {
		    LYaddstr("*\n");
		    LYrefresh();
		}
#endif /* USE_SLANG */
		CTRACE((tfp, "\n"));
	    }
	    if (!HTLoadAbsolute(&WWWDoc)) {
		/*
		 *  Check for redirection.
		 */
		if (use_this_url_instead != NULL) {
		    char *pound;

		    if (!is_url(use_this_url_instead)) {
			/*
			 *  The server did not return a complete
			 *  URL in its Location: header, probably
			 *  due to a FORM or other CGI script written
			 *  by someone who doesn't know that the http
			 *  protocol requires that it be a complete
			 *  URL, or using a server which does not treat
			 *  such a redirect string from the script as
			 *  an instruction to resolve it versus the
			 *  initial request, check authentication with
			 *  that URL, and then act on it without
			 *  returning redirection to us.  We'll
			 *  violate the http protocol and resolve it
			 *  ourselves using the URL of the original
			 *  request as the BASE, rather than doing
			 *  the RIGHT thing and returning an invalid
			 *  address message. - FM
			 */
			HTUserMsg(LOCATION_NOT_ABSOLUTE);
			temp = HTParse(use_this_url_instead,
				       WWWDoc.address,
				       PARSE_ALL);
			if (temp && *temp) {
			    StrAllocCopy(use_this_url_instead, temp);
a607 1
			FREE(temp);
d609 6
a614 5
		    url_type = is_url(use_this_url_instead);
		    if (!HTPermitRedir &&
		       (url_type == LYNXDOWNLOAD_URL_TYPE ||
			url_type == LYNXEXEC_URL_TYPE ||
			url_type == LYNXPROG_URL_TYPE ||
d616 1
a616 1
			url_type == LYNXDIRED_URL_TYPE ||
d618 2
a619 51
			url_type == LYNXPRINT_URL_TYPE ||
			url_type == LYNXOPTIONS_URL_TYPE ||
			url_type == LYNXCFG_URL_TYPE ||
			url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
			url_type == LYNXHIST_URL_TYPE ||
			url_type == LYNXCOOKIE_URL_TYPE ||
			url_type == LYNXMESSAGES_URL_TYPE ||
			(LYValidate &&
			 url_type != HTTP_URL_TYPE &&
			 url_type != HTTPS_URL_TYPE) ||
			((no_file_url || no_goto_file) &&
			 url_type == FILE_URL_TYPE) ||
			(no_goto_lynxcgi &&
			 url_type == LYNXCGI_URL_TYPE) ||
#ifndef DISABLE_BIBP
			(no_goto_bibp &&
			 url_type == BIBP_URL_TYPE) ||
#endif
			(no_goto_cso &&
			 url_type == CSO_URL_TYPE) ||
			(no_goto_finger &&
			 url_type == FINGER_URL_TYPE) ||
			(no_goto_ftp &&
			 (url_type == FTP_URL_TYPE ||
			  url_type == NCFTP_URL_TYPE)) ||
			(no_goto_gopher &&
			 url_type == GOPHER_URL_TYPE) ||
			(no_goto_http &&
			 url_type == HTTP_URL_TYPE) ||
			(no_goto_https &&
			 url_type == HTTPS_URL_TYPE) ||
			(no_goto_mailto &&
			 url_type == MAILTO_URL_TYPE) ||
#ifndef DISABLE_NEWS
			(no_goto_news &&
			 url_type == NEWS_URL_TYPE) ||
			(no_goto_nntp &&
			 url_type == NNTP_URL_TYPE) ||
#endif
			(no_goto_rlogin &&
			 url_type == RLOGIN_URL_TYPE) ||
#ifndef DISABLE_NEWS
			(no_goto_snews &&
			 url_type == SNEWS_URL_TYPE) ||
#endif
			(no_goto_telnet &&
			 url_type == TELNET_URL_TYPE) ||
			(no_goto_tn3270 &&
			 url_type == TN3270_URL_TYPE) ||
			(no_goto_wais &&
			 url_type == WAIS_URL_TYPE))) {
d621 6
a626 2
			 *  Some schemes are not acceptable from
			 *  server redirections. - KW & FM
d628 32
a659 1
			HTAlert(ILLEGAL_REDIRECTION_URL);
d661 2
a662 6
			    HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE,
				       use_this_url_instead);
			} else {
			    fprintf(stderr,
				    WWW_ILLEGAL_URL_MESSAGE,
				    use_this_url_instead);
d664 2
a665 2
			FREE(use_this_url_instead);
			return(NULLFILE);
d667 6
a672 2
		    if ((pound = findPoundSelector(doc->address)) != NULL
		     && findPoundSelector(use_this_url_instead) == NULL) {
d674 5
a678 7
			 *  Our requested URL had a fragment
			 *  associated with it, and the redirection
			 *  URL doesn't, so we'll append the fragment
			 *  associated with the original request.  If
			 *  it's bogus for the redirection URL, we'll
			 *  be positioned at the top of that document,
			 *  so there's no harm done. - FM
d680 1
a680 4
			CTRACE((tfp,
		"getfile: Adding fragment '%s' to redirection URL.\n",
			    pound));
			StrAllocCat(use_this_url_instead, pound);
d682 2
a683 7
		    CTRACE_SLEEP(MessageSecs);
		    HTUserMsg2(WWW_USING_MESSAGE, use_this_url_instead);
		    CTRACE((tfp, "\n"));
		    StrAllocCopy(doc->address,
				use_this_url_instead);
		    FREE(use_this_url_instead);
		    if (redirect_post_content == FALSE) {
d685 1
a685 2
			 *  Freeing the content also yields
			 *  a GET request. - FM
d687 140
a826 1
			LYFreePostData(doc);
a827 14
		    /*
		     *	Go to top to check for URL's which get
		     *	special handling and/or security checks
		     *	in Lynx. - FM
		     */
		    goto Try_Redirected_URL;
		}
		if (HTNoDataOK) {
		    return(NULLFILE);
		}
		return(NOT_FOUND);
	    }

	    lynx_mode = NORMAL_LYNX_MODE;
d829 1
a829 23
	    /*
	     *	Some URL's don't actually return a document;
	     *	compare doc->address with the document that is
	     *	actually loaded and return NULLFILE if not
	     *	loaded.  If www_search_result is not -1
	     *	then this is a reference to a named anchor
	     *	within the same document; do NOT return
	     *	NULLFILE in that case.
	     */
	    {
		char *pound;
		/*
		 *  Check for a #fragment selector.
		 */
		pound = findPoundSelector(doc->address);

		/*
		 *  Check to see if there is a temp
		 *  file waiting for us to download.
		 */
		if (WWW_Download_File) {
		    HTParentAnchor *tmpanchor = HTAnchor_findAddress(&WWWDoc);
		    char *fname = NULL;
d832 7
a838 2
		     *	Check for a suggested filename from
		     *	the Content-Disposition header. - FM
d840 6
a845 11
		    if (HTAnchor_SugFname(tmpanchor) != NULL) {
			StrAllocCopy(fname, HTAnchor_SugFname(tmpanchor));
		    } else {
			StrAllocCopy(fname, doc->address);
		    }
		    /*
		     *	Check whether this is a compressed file,
		     *	which we don't uncompress for downloads,
		     *	and adjust any suffix appropriately. - FM
		     */
		    HTCheckFnameForCompression(&fname, tmpanchor, FALSE);
d847 77
a923 22
		    if (LYdownload_options(&fname,
					   WWW_Download_File) < 0) {
			FREE(fname);
			return(NOT_FOUND);
		    }
		    LYAddVisitedLink(doc);
		    StrAllocCopy(doc->address, fname);
		    FREE(fname);
		    doc->internal_link = FALSE;
		    WWWDoc.address = doc->address;
		    LYFreePostData(doc);
		    WWWDoc.post_data = NULL;
		    WWWDoc.post_content_type = NULL;
		    WWWDoc.bookmark = doc->bookmark = FALSE;
		    WWWDoc.isHEAD = doc->isHEAD = FALSE;
		    WWWDoc.safe = doc->safe = FALSE;
		    HTOutputFormat = WWW_PRESENT;
		    if (!HTLoadAbsolute(&WWWDoc)) {
			return(NOT_FOUND);
		    } else {
			return(NORMAL);
		    }
d925 1
a925 29
		} else if (pound == NULL &&
			   /*
			    *  HTAnchor hash-table searches are now
			    *  case-sensitive (hopefully, without
			    *  anchor deletion problems), so this
			    *  is too. - FM
			    */
			   (strcmp(doc->address,
				   HTLoadedDocumentURL()) ||
			   /*
			    *  Also check the post_data elements. - FM
			    */
			   !BINEQ(doc->post_data,
				  HTLoadedDocumentPost_data()) ||
			   /*
			    *  Also check the isHEAD element. - FM
			    */
			   doc->isHEAD != HTLoadedDocumentIsHEAD())) {
		    /*
		     *	Nothing needed to be shown.
		     */
		    LYAddVisitedLink(doc);
		    return(NULLFILE);

		} else {
		    if (pound != NULL) {
			if (!HTMainText) { /* this should not happen... */
			    return(NULLFILE); /* but it can. - kw */
			}
d929 4
a932 1
			HTFindPoundSelector(pound+1);
a933 1
		    return(NORMAL);
d935 6
a940 44
	    }
	}
    } else {
	CTRACE_SLEEP(MessageSecs);
	HTUserMsg2(WWW_BAD_ADDR_MESSAGE, doc->address);
	CTRACE((tfp,"\n"));
	return(NULLFILE);
    }
}

/*
 *  Set source mode for the next retrieval via getfile or HTreparse_document.
 *  mode == -1: force normal presentation
 *  mode ==  1: force source presentation
 *  mode ==  0: reset to normal if it was set to source
 *  - kw
 */
PUBLIC void srcmode_for_next_retrieval ARGS1(
    int,	mode)
{
    if (mode < 0) {
	HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	psrc_view = FALSE;
#endif

    } else if (mode == 0) {
	if (HTOutputFormat == WWW_SOURCE)
	    HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	else if (LYpsrc)
	    psrc_view = FALSE;
#endif

    } else {
#ifdef USE_PRETTYSRC
	if (LYpsrc)
	    psrc_view = TRUE;
	else
	    HTOutputFormat = WWW_SOURCE;
#else
	HTOutputFormat = WWW_SOURCE;
#endif
    }
d962 1
a962 1
	DocInfo *,	doc,
d972 2
a973 2
    CTRACE((tfp,"follow_link_number(%d,%d,...)\n",c,cur));
    temp[0] = (char) c;
d985 1
a985 1
    while ( isdigit(UCH(*p)) )
a994 1
	break;
d1000 1
a1000 1
    CTRACE((tfp,"  temp=%s, *num=%d, rel='%c'\n",temp,*num,rel));
d1005 1
a1005 5
    if (( c == 'p' || c == 'P') && display_lines == 0) {
	CTRACE((tfp," curline=%d, LYlines=%d, display too small!\n",
	       curline,LYlines));
	return(PRINT_ERROR);
    } else if ( c == 'p' || c == 'P' ) {
d1013 2
a1014 2
	CTRACE((tfp," nlines=%d, npages=%d, curline=%d, curpage=%d\n",
		nlines,npages,curline,curpage));
d1032 1
a1032 1
    want_go = (BOOL) ( c == 'g' || c == 'G' );
a1043 2
	char *text = NULL;

d1054 6
a1059 9
	info = HTGetLinkInfo(*num,
			     want_go,
			     &new_top,
			     &new_link,
			     &text,
			     &links[cur].lname);
	if (text != NULL)
	    LYSetHilite(cur, text);
	if (info == WWW_INTERN_LINK_TYPE) {
a1206 1
    CONST char *allowed_extra_chars;
a1257 4
    if (Type == CGI_PATH)
	allowed_extra_chars = " _-:./@@~$&+=\t";
    else
	allowed_extra_chars = " _-:./@@~$+=\t";
d1259 6
a1264 1
	if (!isalnum(UCH(*cp)) && !strchr(allowed_extra_chars, *cp)) {
d1285 7
a1291 2
	    if (STRNADDRCOMP(source, tp->src, strlen(tp->src)) == 0 &&
		STRNADDRCOMP(command, tp->path, strlen(tp->path)) == 0)
d1308 2
a1309 3
PRIVATE int fix_httplike_urls ARGS2(
	DocInfo *,	doc,
	UrlTypes,	type)
a1313 8
     *  If there's a fragment present, our simplistic methods won't
     *  work.  - kw
     */
    if (findPoundSelector(doc->address) != NULL)
	return 0;

#ifndef DISABLE_FTP
    /*
d1316 1
a1316 1
    if (type == FTP_URL_TYPE &&
d1335 2
a1336 2
	if (((proxy = LYGetEnv("ftp_proxy")) != NULL) &&
	    !override_proxy(doc->address))
d1342 1
a1342 1
	CTRACE((tfp, "fix_httplike_urls: URL '%s'\n", doc->address));
d1344 1
a1344 15
	CTRACE((tfp, "            changed to '%s'\n", doc->address));
	CTRACE_SLEEP(MessageSecs);
    } else if (type == NCFTP_URL_TYPE) {
	char *path = NULL;
	char *first = doc->address;
	char *second = strchr(first, ':');

	CTRACE((tfp, "fix_httplike_urls: URL '%s'\n", doc->address));

	*second++ = '\0';
	HTSprintf0(&path, "%s//%s%s", STR_FTP_URL, first, second);
	FREE(doc->address);
	doc->address = path;

	CTRACE((tfp, "            changed to '%s'\n", doc->address));
a1346 1
#endif /* DISABLE_FTP */
a1354 21
	if (type == HTTP_URL_TYPE ||
	    type == HTTPS_URL_TYPE) {
	    if ((slash-2) != strchr(doc->address, ':')) {
		/*
		 *  Turns out we were not looking at the right slash after all,
		 *  there must have been more than one "://" which is valid
		 *  at least for http URLs (later occurrences can be part of
		 *  a query string, for example), so leave this alone, too. - kw
		 */
		return(0);
	    }
	    if (strchr(doc->address, '?')) {
		/*
		 *  If there is a question mark that appears to be part
		 *  of the hostname, don't append anything either. Leave
		 *  it to HTParse to interpret the question mark as ending
		 *  the hostname. - kw
		 */
		return(0);
	    }
	}
d1356 1
a1356 1
    CTRACE((tfp, "fix_httplike_urls: URL '%s'\n", doc->address));
d1358 1
a1358 1
    CTRACE((tfp, "            changed to '%s'\n", doc->address));
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d36 1
a36 1
static int fix_httplike_urls (DocInfo *doc, UrlTypes type);
d44 1
a44 1
int HTNoDataOK = 0;
d69 2
a70 2
int getfile (
	DocInfo *	doc)
d533 1
a533 1
		const char *title;
d1100 2
a1101 2
void srcmode_for_next_retrieval (
    int	mode)
d1145 5
a1149 5
int follow_link_number (
	int		c,
	int		cur,
	DocInfo *	doc,
	int *		num)
d1297 1
a1297 1
static void LYTrusted_free (void)
d1339 3
a1341 3
void add_trusted (
	char *		str,
	int		type)
d1396 4
a1399 4
BOOLEAN exec_ok (
	const char *	source,
	const char *	linktext,
	int		type)
d1402 2
a1403 2
    const char *cp;
    const char *allowed_extra_chars;
d1476 1
a1476 1
	    char const *command = linktext;
d1499 3
a1501 3
static int fix_httplike_urls (
	DocInfo *	doc,
	UrlTypes	type)
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d3 1
a3 1
#include <HTAnchor.h>		/* Anchor class */
d36 1
a36 1
static int fix_httplike_urls(DocInfo *doc, UrlTypes type);
d47 4
a50 4
 * getfile is the main mechanism to load a new document (or a previously loaded
 * one whose rendering is cached in a HText structure) from mainloop, nearly
 * everything goes through it.
 * It should return one of the values
d63 5
a67 5
 * The distinction between NOT_FOUND and NULLFILE is not very crucial, but
 * getting it right prevents mainloop from exiting with the wrong message if it
 * happens for the first file, and from logging (or not logging) errors
 * inappropriately with -traversal, and from sending bogus error mail with
 * MAIL_SYSTEM_ERROR_LOGGING:TRUE.  - kw
d69 2
a70 1
int getfile(DocInfo *doc)
d75 1
a75 1
    DocAddress WWWDoc;		/* a WWW absolute doc address struct */
d78 1
a78 1
     * Reset LYCancelDownload to prevent unwanted delayed effect.  - KW
d86 1
a86 1
     * Reset fake 'Z' to prevent unwanted delayed effect.  - kw
d91 4
a94 4
     * Reset redirection counter to prevent bogus TOO_MANY_REDIRECTIONS in rare
     * situations if the previous cycle got to the limit, but did not fail for
     * that reason because the URL of the final location was handled specially,
     * not via HTLoadAbsolute.  - kw
d98 1
a98 1
  Try_Redirected_URL:
d100 1
a100 1
     * Load the WWWDoc struct in case we need to use it.
d110 1
a110 1
     * Reset HTPermitRedir, it has done its job if it was set.  - kw
d115 1
a115 1
     * Reset WWW_Download_File just in case.
d120 1
a120 1
     * Reset redirect_post_content just in case.
d125 9
a133 7
     * This flag is a hack to allow us to pass on the fact that 'no data' may
     * not really be an error although HTLoadAbsolute returned NO.  There
     * should be a better way...  HT_NO_DATA should always mean 'not data but
     * not an error', and be passed on to us as that, but current usage if
     * HT_NO_DATA vs HT_NOT_LOADED has to be reviewed everywhere.  Anyway, some
     * protocol module can set it to say 'I really mean it', we have to reset
     * it here.  - kw
d137 1
a137 1
    CTRACE((tfp, "getfile: getting %s\n\n", doc->address));
d140 5
a144 3
     * Protect against denial of service attacks via the port 19 CHARGEN
     * service, and block connections to the port 25 ESMTP service.  Also
     * reject any likely spoof attempts via wrap arounds at 65536.  - FM
d160 1
a160 1
		    return (NULLFILE);
d165 1
a165 1
		    return (NULLFILE);
d169 1
a169 2

		    HTSprintf0(&msg, PORT_INVALID, (unsigned long) value);
d173 1
a173 1
		    return (NULLFILE);
d178 1
a178 1
		return (NULLFILE);
d186 2
a187 2
     * Check to see if this is a universal document ID that lib WWW wants to
     * handle.
d189 1
a189 1
     * Some special URL's we handle ourselves.  :)
d202 2
a203 2
		  0 == STRNADDRCOMP(WWWDoc.address, helpfilepath,
				    strlen(helpfilepath)) ||
d205 2
a206 2
		   0 == STRNADDRCOMP(WWWDoc.address, lynxlistfile,
				     strlen(lynxlistfile))) ||
d208 2
a209 2
		   0 == STRNADDRCOMP(WWWDoc.address, lynxlinksfile,
				     strlen(lynxlinksfile))) ||
d211 2
a212 2
		   0 == STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
				     strlen(lynxjumpfile))))) {
d214 1
a214 1
		return (NULLFILE);
d219 1
a219 1
	     * Only traverse http URLs.
d223 1
a223 1
		return (NULLFILE);
d226 2
a227 2
	    if (!(0 == strncmp(startrealm, WWWDoc.address,
			       strlen(startrealm)) ||
d249 2
a250 2
		  0 == STRNADDRCOMP(WWWDoc.address, helpfilepath,
				    strlen(helpfilepath)) ||
d252 2
a253 2
		   0 == STRNADDRCOMP(WWWDoc.address, lynxlistfile,
				     strlen(lynxlistfile))) ||
d255 2
a256 2
		   0 == STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
				     strlen(lynxjumpfile))))) {
d258 1
a258 1
		return (NULLFILE);
d280 1
a280 1
	LYSyslog(doc->address);
d286 1
a286 1
	    return (NULLFILE);
d290 1
a290 1
	    return (NULLFILE);
d293 1
a293 1
	    return (printfile(doc));
d298 1
a298 1
	    return (postoptions(doc));
d302 1
a302 1
		   !no_lynxcfg_info) {
d306 1
a306 1
	    return (lynx_cfg_infopage(doc));
d310 1
a310 1
		   !no_compileopts_info) {
d314 1
a314 1
	    return (lynx_compile_opts(doc));
d325 4
a328 3
		return (NULLFILE);
	    } else if (!news_ok && (url_type == NEWSPOST_URL_TYPE ||
				    url_type == NEWSREPLY_URL_TYPE)) {
d330 1
a330 1
		return (NULLFILE);
d333 1
a333 1
		return (NULLFILE);
d342 4
a345 3
		 * The temporary file was saved to disk via a rename(), so we
		 * can't access the temporary file again via the download menu. 
		 * Clear the flag, and return NULLFILE to pop.  - FM
d348 1
a348 1
		return (NULLFILE);
d351 1
a351 1
	    return (NORMAL);
d355 12
a366 12
		local_dired(doc);
		WWWDoc.address = doc->address;
		WWWDoc.post_data = doc->post_data;
		WWWDoc.post_content_type = doc->post_content_type;
		WWWDoc.bookmark = doc->bookmark;
		WWWDoc.isHEAD = doc->isHEAD;
		WWWDoc.safe = doc->safe;

		if (!HTLoadAbsolute(&WWWDoc)) {
		    return (NOT_FOUND);
		}
		return (NORMAL);
d370 1
a370 1
	    return (NULLFILE);
a375 1

d385 5
a389 4
		 * Don't send a Referer header if the URL is the reply from a
		 * form with method GET, in case the content has personal data
		 * (e.g., a password or credit card number) which would become
		 * visible in logs.  - FM
d391 2
a392 2
		 * Changed 1999-11-01 to be controlled by REFERER_WITH_QUERY
		 * option.  - kw
d394 1
a394 1
		if (LYRefererWithQuery == 'S') {	/* SEND */
d396 2
a397 2
		} else if (LYRefererWithQuery == 'P') {		/* PARTIAL */
		    FREE(LYRequestReferer);	/* just to be sure */
d399 2
a400 5
					       PARSE_ACCESS
					       | PARSE_HOST
					       | PARSE_STRICTPATH
					       | PARSE_PUNCTUATION);
		} else {	/* Everything else - don't send Referer */
d412 4
a415 3
	     * 'doc' will change to the new file if we had a successful
	     * LYpop_num(), and the return value will be FALSE if we had a
	     * cancel.  - FM
d419 1
a419 1
		return (NOT_FOUND);
d423 1
a423 1
	     * We changed it so reload.
d441 1
a441 1
		return (NOT_FOUND);
d443 1
a443 1
	    return (NORMAL);
d450 1
a450 1
			 doc->address + 9, ALWAYS_EXEC_PATH)) {
d456 2
a457 2
				      exec_ok(HTLoadedDocumentURL(),
					      doc->address + 9, EXEC_PATH))) {
d462 1
a462 1
		 * Bug puts slash on end if none is in the string.
d464 1
a464 2
		char *last_slash = strrchr(doc->address, '/');

d466 2
a467 2
		    == (int) strlen(doc->address) - 1)
		    doc->address[strlen(doc->address) - 1] = '\0';
d470 1
a470 1
		 * Convert '~' to $HOME.
d474 4
a477 4
			       cp - doc->address,
			       doc->address,
			       wwwName(Home_Dir()),
			       cp + 1);
d482 1
a482 1
		 * Show URL before executing it.
d487 1
a487 1
		 * Run the command.
d489 2
a490 2
		if (strstr(p, "//") == p + 9)
		    LYSystem(p + 11);
d492 1
a492 1
		    LYSystem(p + 9);
d497 1
a497 1
		     * Make sure user gets to see screen output.
d514 1
a514 1
	    } else {
d518 2
a519 2
			   EXECUTION_DISABLED_FOR_FILE,
			   key_for_func(LYK_OPTIONS));
d522 1
a522 1
	    }
d524 1
a524 1
	    HTUserMsg(EXECUTION_NOT_COMPILED);
d526 1
a526 1
	    return (NULLFILE);
d538 1
a538 1
		    title = HTAnchor_title(tmpanchor);
d551 1
a551 1
		cp = strchr(doc->address, ':') + 1;
d554 2
a555 2
			       (char *) HTMainAnchor->address :
			       (char *) doc->address),
d558 1
a558 1
			      HTMainAnchor->message_id : NULL);
d561 1
a561 1
	    return (NULLFILE);
d563 4
a566 4
	    /*
	     * From here on we could have a remote host, so check if that's
	     * allowed.
	     */
d578 1
a578 1
	    return (NULLFILE);
d580 3
a582 3
	    /*
	     * Disable www telnet access if not telnet_ok.
	     */
d586 1
a586 2
	    char *proxy;

d589 2
a590 2
		return (NULLFILE);
	    } else if (no_telnet_port && strchr(doc->address + 7, ':')) {
d592 9
a600 11
		return (NULLFILE);
		/*
		 * Detect weird case where interactive protocol would be
		 * proxied, and to a non-interactive protocol at that.
		 */
	    } else if ((proxy = LYGetEnv(((url_type == TN3270_URL_TYPE)
					  ? "tn3270_proxy"
					  :
					  ((url_type == TELNET_GOPHER_URL_TYPE)
					   ? "gopher_proxy"
					   : "telnet_proxy")))) != NULL &&
d614 1
a614 1
		return (NULLFILE);
d617 3
a619 3
	    /*
	     * Disable www news access if not news_ok.
	     */
d621 3
a623 2
	} else if (!news_ok && (url_type == NEWS_URL_TYPE ||
				url_type == NNTP_URL_TYPE)) {
d625 1
a625 1
	    return (NULLFILE);
d629 1
a629 2
	    char *proxy;

d632 7
a638 6
		return (NULLFILE);
		/*
		 * Detect weird case where interactive protocol would be
		 * proxied, and to a non-interactive protocol at that.
		 */
	    } else if ((proxy = LYGetEnv("rlogin_proxy")) != NULL &&
d652 1
a652 1
		return (NULLFILE);
d655 5
a659 4
	    /*
	     * If it's a gopher index type and there isn't a search term
	     * already attached then do this.  Otherwise just load it!
	     */
d661 1
a661 1
		   strchr(doc->address, '?') == NULL) {
a662 1

d664 3
a666 2
	     * Make sure we don't have a gopher+ escaped tab instead of a
	     * gopher0 question mark delimiting the search term.  - FM
d684 3
a686 2
	     * Load it because the do_www_search routine uses the base url of
	     * the currently loaded document :(
d689 1
a689 1
		return (NOT_FOUND);
d706 1
a706 1
	    return (status);
d708 2
a709 1
	} {
d711 2
a712 2
		&& (url_type == FTP_URL_TYPE
		    || url_type == NCFTP_URL_TYPE)) {
d714 1
a714 1
		return (NULLFILE);
d718 6
a723 7
		char *tmp = NULL;

		/*
		 * If tuple's Path=GET%20/...  convert to an http URL.
		 */
		if ((cp = strchr(doc->address + 9, '/')) != NULL &&
		    0 == strncmp(++cp, "hGET%20/", 8)) {
d726 1
a726 1
			    doc->address));
d728 5
a732 5
		    StrAllocCat(tmp, doc->address + 9);
		    /*
		     * If the port is defaulted, it should stay 70.
		     */
		    if (strchr(tmp + 6, ':') == NULL) {
d734 1
a734 1
			tmp[strlen(tmp) - 4] = ':';
d736 2
a737 2
		    if (strlen(cp + 7) > 1)
			StrAllocCat(tmp, cp + 8);
d740 1
a740 1
			    doc->address));
d751 1
a751 1
	    WWWDoc.address = doc->address;	/* possible reload */
a757 1

d774 1
a774 1
		StrAllocCat(bibpTmp, doc->address + 5);		/* USIN after bibp: */
d783 6
a788 5
		 * If a file URL has a '~' as the lead character of its first
		 * symbolic element, convert the '~' to Home_Dir(), then append
		 * the rest of of path, if present, skipping "user" if "~user"
		 * was entered, simplifying, and eliminating any residual
		 * relative elements.  - FM
d791 2
a792 2
				   PARSE_PATH + PARSE_ANCHOR + PARSE_PUNCTUATION))
		     != NULL) &&
d798 1
a798 1
			    doc->address));
d813 1
a813 1
			    doc->address));
d832 1
a832 1
		 * Check for redirection.
d839 16
a854 13
			 * The server did not return a complete URL in its
			 * Location:  header, probably due to a FORM or other
			 * CGI script written by someone who doesn't know that
			 * the http protocol requires that it be a complete
			 * URL, or using a server which does not treat such a
			 * redirect string from the script as an instruction to
			 * resolve it versus the initial request, check
			 * authentication with that URL, and then act on it
			 * without returning redirection to us.  We'll violate
			 * the http protocol and resolve it ourselves using the
			 * URL of the original request as the BASE, rather than
			 * doing the RIGHT thing and returning an invalid
			 * address message.  - FM
d867 3
a869 3
			(url_type == LYNXDOWNLOAD_URL_TYPE ||
			 url_type == LYNXEXEC_URL_TYPE ||
			 url_type == LYNXPROG_URL_TYPE ||
d871 1
a871 1
			 url_type == LYNXDIRED_URL_TYPE ||
d873 14
a886 14
			 url_type == LYNXPRINT_URL_TYPE ||
			 url_type == LYNXOPTIONS_URL_TYPE ||
			 url_type == LYNXCFG_URL_TYPE ||
			 url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
			 url_type == LYNXHIST_URL_TYPE ||
			 url_type == LYNXCOOKIE_URL_TYPE ||
			 url_type == LYNXMESSAGES_URL_TYPE ||
			 (LYValidate &&
			  url_type != HTTP_URL_TYPE &&
			  url_type != HTTPS_URL_TYPE) ||
			 ((no_file_url || no_goto_file) &&
			  url_type == FILE_URL_TYPE) ||
			 (no_goto_lynxcgi &&
			  url_type == LYNXCGI_URL_TYPE) ||
d888 2
a889 2
			 (no_goto_bibp &&
			  url_type == BIBP_URL_TYPE) ||
d891 15
a905 15
			 (no_goto_cso &&
			  url_type == CSO_URL_TYPE) ||
			 (no_goto_finger &&
			  url_type == FINGER_URL_TYPE) ||
			 (no_goto_ftp &&
			  (url_type == FTP_URL_TYPE ||
			   url_type == NCFTP_URL_TYPE)) ||
			 (no_goto_gopher &&
			  url_type == GOPHER_URL_TYPE) ||
			 (no_goto_http &&
			  url_type == HTTP_URL_TYPE) ||
			 (no_goto_https &&
			  url_type == HTTPS_URL_TYPE) ||
			 (no_goto_mailto &&
			  url_type == MAILTO_URL_TYPE) ||
d907 4
a910 4
			 (no_goto_news &&
			  url_type == NEWS_URL_TYPE) ||
			 (no_goto_nntp &&
			  url_type == NNTP_URL_TYPE) ||
d912 2
a913 2
			 (no_goto_rlogin &&
			  url_type == RLOGIN_URL_TYPE) ||
d915 2
a916 2
			 (no_goto_snews &&
			  url_type == SNEWS_URL_TYPE) ||
d918 6
a923 6
			 (no_goto_telnet &&
			  url_type == TELNET_URL_TYPE) ||
			 (no_goto_tn3270 &&
			  url_type == TN3270_URL_TYPE) ||
			 (no_goto_wais &&
			  url_type == WAIS_URL_TYPE))) {
d925 2
a926 2
			 * Some schemes are not acceptable from server
			 * redirections.  - KW & FM
d938 1
a938 1
			return (NULLFILE);
d941 1
a941 1
			&& findPoundSelector(use_this_url_instead) == NULL) {
d943 7
a949 6
			 * Our requested URL had a fragment associated with it,
			 * and the redirection URL doesn't, so we'll append the
			 * fragment associated with the original request.  If
			 * it's bogus for the redirection URL, we'll be
			 * positioned at the top of that document, so there's
			 * no harm done.  - FM
d952 2
a953 2
				"getfile: Adding fragment '%s' to redirection URL.\n",
				pound));
d960 1
a960 1
				 use_this_url_instead);
d964 2
a965 1
			 * Freeing the content also yields a GET request.  - FM
d970 3
a972 2
		     * Go to top to check for URL's which get special handling
		     * and/or security checks in Lynx.  - FM
d977 1
a977 1
		    return (NULLFILE);
d979 1
a979 1
		return (NOT_FOUND);
d985 7
a991 5
	     * Some URL's don't actually return a document; compare
	     * doc->address with the document that is actually loaded and
	     * return NULLFILE if not loaded.  If www_search_result is not -1
	     * then this is a reference to a named anchor within the same
	     * document; do NOT return NULLFILE in that case.
a994 1

d996 1
a996 1
		 * Check for a #fragment selector.
d1001 2
a1002 2
		 * Check to see if there is a temp file waiting for us to
		 * download.
d1009 2
a1010 2
		     * Check for a suggested filename from the
		     * Content-Disposition header.  - FM
d1018 3
a1020 3
		     * Check whether this is a compressed file, which we don't
		     * uncompress for downloads, and adjust any suffix
		     * appropriately.  - FM
d1027 1
a1027 1
			return (NOT_FOUND);
d1042 1
a1042 1
			return (NOT_FOUND);
d1044 1
a1044 1
			return (NORMAL);
d1048 6
a1053 5
		    /*
		     * HTAnchor hash-table searches are now case-sensitive
		     * (hopefully, without anchor deletion problems), so this
		     * is too.  - FM
		     */
d1056 9
d1066 1
a1066 10
		     * Also check the post_data elements.  - FM
		     */
			    !BINEQ(doc->post_data,
				   HTLoadedDocumentPost_data()) ||
		    /*
		     * Also check the isHEAD element.  - FM
		     */
			    doc->isHEAD != HTLoadedDocumentIsHEAD())) {
		    /*
		     * Nothing needed to be shown.
d1069 1
a1069 1
		    return (NULLFILE);
d1073 2
a1074 2
			if (!HTMainText) {	/* this should not happen... */
			    return (NULLFILE);	/* but it can. - kw */
d1077 1
a1077 1
			 * May set www_search_result.
d1079 1
a1079 1
			HTFindPoundSelector(pound + 1);
d1081 1
a1081 1
		    return (NORMAL);
d1088 2
a1089 2
	CTRACE((tfp, "\n"));
	return (NULLFILE);
d1094 5
a1098 5
 * Set source mode for the next retrieval via getfile or HTreparse_document.
 * mode == -1:  force normal presentation
 * mode == 1:  force source presentation
 * mode == 0:  reset to normal if it was set to source
 * - kw
d1100 2
a1101 1
void srcmode_for_next_retrieval(int mode)
d1130 14
a1143 18
 * The user wants to select a link or page by number.
 *
 * If follow_link_number returns DO_LINK_STUFF do_link will be run immediately
 * following its execution.
 *
 * If follow_link_number returns DO_GOTOLINK_STUFF it has updated the passed in
 * doc for positioning on a link.
 *
 * If follow_link_number returns DO_GOTOPAGE_STUFF it has set doc->line to the
 * top line of the desired page for displaying that page.
 *
 * If follow_link_number returns PRINT_ERROR an error message will be given to
 * the user.
 *
 * If follow_link_number returns DO_FORMS_STUFF some forms stuff will be done. 
 * (Not yet implemented.)
 *
 * If follow_link_number returns DO_NOTHING nothing special will run after it.
d1145 5
a1149 4
int follow_link_number(int c,
		       int cur,
		       DocInfo *doc,
		       int *num)
d1156 1
a1156 1
    int curline = *num;		/* passed in from mainloop() */
d1158 1
a1158 1
    CTRACE((tfp, "follow_link_number(%d,%d,...)\n", c, cur));
d1164 1
a1164 1
     * Get the number, possibly with a letter suffix, from the user.
d1168 1
a1168 1
	return (DO_NOTHING);
d1171 1
a1171 1
    while (isdigit(UCH(*p)))
d1173 3
a1175 4
    c = *p;			/* reuse c; 0 or g or p or + or - */
    switch (c) {
    case '+':
    case '-':
d1177 1
a1177 2
	rel = c;
	c = *++p;
d1187 1
a1187 1
    CTRACE((tfp, "  temp=%s, *num=%d, rel='%c'\n", temp, *num, rel));
d1189 2
a1190 2
     * Check if we had a 'p' or 'P' following the number as a flag for
     * displaying the page with that number.  - FM
d1192 5
a1196 5
    if ((c == 'p' || c == 'P') && display_lines == 0) {
	CTRACE((tfp, " curline=%d, LYlines=%d, display too small!\n",
		curline, LYlines));
	return (PRINT_ERROR);
    } else if (c == 'p' || c == 'P') {
d1199 2
a1200 2
	(((nlines + 1) + (display_lines - 1)) / (display_lines))
	: 1;
d1202 4
a1205 5
	(((curline + 1) + (display_lines - 1)) / (display_lines))
	: 1;

	CTRACE((tfp, " nlines=%d, npages=%d, curline=%d, curpage=%d\n",
		nlines, npages, curline, curpage));
d1208 1
a1208 1
	if (rel == '+')
d1210 1
a1210 1
	else if (rel == '-')
d1213 4
a1216 4
	    1 :
	    ((*num <= npages) ? (((*num - 1) * display_lines) + 1)
	     : (((npages - 1) * display_lines) + 1));
	return (DO_GOTOPAGE_STUFF);
d1220 2
a1221 2
     * Check if we want to make the link corresponding to the number the
     * current link, rather than ACTIVATE-ing it.
d1223 1
a1223 1
    want_go = (BOOL) (c == 'g' || c == 'G');
d1228 6
a1233 6
    if (rel)
	*num = HTGetRelLinkNum(*num, rel, cur);
    /*
     * If we have a valid number, act on it.
     */
    if (*num > 0) {
d1238 8
a1245 6
	 * Get the lname, and hightext, directly from www structures and add it
	 * to the cur link so that we can pass it transparently on to
	 * getfile(), and load new_top and new_link if we instead want to make
	 * the link number current.  These things are done so that a link can
	 * be selected anywhere in the current document, whether it is
	 * displayed on the screen or not!
d1257 1
a1257 1
	    return (DO_LINK_STUFF);
d1261 1
a1261 1
	    return (DO_GOTOLINK_STUFF);
d1264 1
a1264 1
	    return (DO_LINK_STUFF);
d1266 1
a1266 1
	    return (PRINT_ERROR);
d1269 1
a1269 1
	return (PRINT_ERROR);
d1276 4
a1279 4
    char *src;
    char *path;
    int type;
    struct trust *next;
d1282 2
a1283 3
static struct trust trusted_exec_default =
{
    "file://localhost/", "", EXEC_PATH, NULL
d1285 2
a1286 3
static struct trust always_trusted_exec_default =
{
    "none", "", ALWAYS_EXEC_PATH, NULL
d1288 2
a1289 3
static struct trust trusted_cgi_default =
{
    "", "", CGI_PATH, NULL
d1297 1
a1297 1
static void LYTrusted_free(void)
d1339 3
a1341 2
void add_trusted(char *str,
		 int type)
d1364 1
a1364 1
    tp = (struct trust *) malloc(sizeof(*tp));
d1394 1
a1394 1
 * Check to see if the supplied paths is allowed to be executed.
d1396 4
a1399 3
BOOLEAN exec_ok(const char *source,
		const char *linktext,
		int type)
d1407 1
a1407 1
     * Always OK if it is a jump file shortcut.
d1413 1
a1413 1
     * Choose the trust structure based on the type.
d1428 1
a1428 1
     * Security:  reject on relative path.
a1431 1

d1445 1
a1445 1
     * Security:  reject on relative path.
d1453 1
a1453 1
     * Security:  reject on strange character.
d1464 2
a1465 2
		       BADCHAR_IN_EXEC_LINK,
		       *cp);
d1473 1
a1473 1
  check_tp_for_entry:
d1478 1
a1478 1
	    if (strstr(command, "//") == linktext) {
d1499 3
a1501 1
static int fix_httplike_urls(DocInfo *doc, UrlTypes type)
d1506 2
a1507 1
     * If there's a fragment present, our simplistic methods won't work.  - kw
d1514 1
a1514 1
     * If it's an ftp URL with a trailing slash, trim it off.
d1517 3
a1519 3
	LYIsHtmlSep(doc->address[strlen(doc->address) - 1])) {
	char *proxy;
	char *path = HTParse(doc->address, "", PARSE_PATH | PARSE_PUNCTUATION);
d1522 1
a1522 1
	 * If the path is a lone slash, we're done.  - FM
d1533 1
a1533 1
	 * If we're proxying ftp, don't trim anything.  - KW
d1540 1
a1540 1
	 * If we get to here, trim the trailing slash.  - FM
d1564 1
a1564 1
     * If there isn't a slash besides the two at the beginning, append one.
d1567 2
a1568 2
	if (!LYIsHtmlSep(*(slash - 1)) || *(slash - 2) != ':') {
	    return (0);
d1572 1
a1572 1
	    if ((slash - 2) != strchr(doc->address, ':')) {
d1574 4
a1577 4
		 * Turns out we were not looking at the right slash after all,
		 * there must have been more than one "://" which is valid at
		 * least for http URLs (later occurrences can be part of a
		 * query string, for example), so leave this alone, too.  - kw
d1579 1
a1579 1
		return (0);
d1583 4
a1586 3
		 * If there is a question mark that appears to be part of the
		 * hostname, don't append anything either.  Leave it to HTParse
		 * to interpret the question mark as ending the hostname.  - kw
d1588 1
a1588 1
		return (0);
d1597 1
a1597 1
    return (1);
@


1.1.3.4
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@a71 1
    char *pound;
d156 2
a157 1
		} else if (value == 25 || value == 65561) {
d161 2
a162 1
		} else if (value > 65535 || value < 0) {
a703 1
	}
d705 10
a714 7
	if (!ftp_ok
	    && (url_type == FTP_URL_TYPE
		|| url_type == NCFTP_URL_TYPE)) {
	    HTUserMsg(FTP_DISABLED);
	    return (NULLFILE);
	} else if (url_type == HTML_GOPHER_URL_TYPE) {
	    char *tmp = NULL;
a715 10
	    /*
	     * If tuple's Path=GET%20/...  convert to an http URL.
	     */
	    if ((cp = strchr(doc->address + 9, '/')) != NULL &&
		0 == strncmp(++cp, "hGET%20/", 8)) {
		StrAllocCopy(tmp, "http://");
		CTRACE((tfp, "getfile: URL '%s'\n",
			doc->address));
		*cp = '\0';
		StrAllocCat(tmp, doc->address + 9);
d717 1
a717 1
		 * If the port is defaulted, it should stay 70.
d719 30
a748 23
		if (strchr(tmp + 6, ':') == NULL) {
		    StrAllocCat(tmp, "70/");
		    tmp[strlen(tmp) - 4] = ':';
		}
		if (strlen(cp + 7) > 1)
		    StrAllocCat(tmp, cp + 8);
		StrAllocCopy(doc->address, tmp);
		CTRACE((tfp, "  changed to '%s'\n",
			doc->address));
		FREE(tmp);
		url_type = HTTP_URL_TYPE;
	    }
	}

	if (url_type == HTTP_URL_TYPE ||
	    url_type == HTTPS_URL_TYPE ||
	    url_type == FTP_URL_TYPE ||
	    url_type == NCFTP_URL_TYPE ||
	    url_type == CSO_URL_TYPE) {
	    fix_httplike_urls(doc, url_type);
	}

	WWWDoc.address = doc->address;	/* possible reload */
d750 1
a750 1
	lynx_edit_mode = FALSE;
a751 1

d753 2
a754 2
	if (url_type == BIBP_URL_TYPE) {
	    char *bibpTmp = NULL;
d756 20
a775 15
	    if (!BibP_bibhost_checked)
		LYCheckBibHost();
	    if (BibP_bibhost_available) {
		StrAllocCopy(bibpTmp, BibP_bibhost);
	    } else if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
		StrAllocCopy(bibpTmp, HTAnchor_citehost(HTMainAnchor));
	    } else {
		StrAllocCopy(bibpTmp, BibP_globalserver);
	    }
	    if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
		StrAllocCat(bibpTmp, "bibp1.0/resolve?citehost=");
		StrAllocCat(bibpTmp, HTAnchor_citehost(HTMainAnchor));
		StrAllocCat(bibpTmp, "&usin=");
	    } else {
		StrAllocCat(bibpTmp, "bibp1.0/resolve?usin=");
a776 5
	    StrAllocCat(bibpTmp, doc->address + 5);	/* USIN after bibp: */
	    StrAllocCopy(doc->address, bibpTmp);
	    WWWDoc.address = doc->address;
	    FREE(bibpTmp);
	}
d779 33
a811 27
	if (url_type == FILE_URL_TYPE) {
	    /*
	     * If a file URL has a '~' as the lead character of its first
	     * symbolic element, convert the '~' to Home_Dir(), then append
	     * the rest of of path, if present, skipping "user" if "~user"
	     * was entered, simplifying, and eliminating any residual
	     * relative elements.  - FM
	     */
	    if (((cp = HTParse(doc->address, "",
			       PARSE_PATH + PARSE_ANCHOR + PARSE_PUNCTUATION))
		 != NULL) &&
		!strncmp(cp, "/~", 2)) {
		char *cp1 = strstr(doc->address, "/~");
		char *cp2;

		CTRACE((tfp, "getfile: URL '%s'\n",
			doc->address));
		*cp1 = '\0';
		cp1 += 2;
		StrAllocCopy(temp, doc->address);
		StrAllocCopy(cp, wwwName(Home_Dir()));
		if (!LYIsHtmlSep(*cp))
		    LYAddHtmlSep(&temp);
		StrAllocCat(temp, cp);
		if ((cp2 = strchr(cp1, '/')) != NULL) {
		    LYTrimRelFromAbsPath(cp2);
		    StrAllocCat(temp, cp2);
d813 1
a813 5
		StrAllocCopy(doc->address, temp);
		FREE(temp);
		CTRACE((tfp, "  changed to '%s'\n",
			doc->address));
		WWWDoc.address = doc->address;
d815 2
a816 4
	    FREE(cp);
	}
	CTRACE_SLEEP(MessageSecs);
	user_message(WWW_WAIT_MESSAGE, doc->address);
d818 1
a818 1
	if (TRACE) {
d820 6
a825 3
	    if (LYCursesON) {
		LYaddstr("*\n");
		LYrefresh();
d827 6
a832 3
#endif /* USE_SLANG */
	    CTRACE((tfp, "\n"));
	}
d834 24
a857 27
	if (!HTLoadAbsolute(&WWWDoc)) {
	    /*
	     * Check for redirection.
	     */
	    if (use_this_url_instead != NULL) {
		if (!is_url(use_this_url_instead)) {
		    /*
		     * The server did not return a complete URL in its
		     * Location:  header, probably due to a FORM or other
		     * CGI script written by someone who doesn't know that
		     * the http protocol requires that it be a complete
		     * URL, or using a server which does not treat such a
		     * redirect string from the script as an instruction to
		     * resolve it versus the initial request, check
		     * authentication with that URL, and then act on it
		     * without returning redirection to us.  We'll violate
		     * the http protocol and resolve it ourselves using the
		     * URL of the original request as the BASE, rather than
		     * doing the RIGHT thing and returning an invalid
		     * address message.  - FM
		     */
		    HTUserMsg(LOCATION_NOT_ABSOLUTE);
		    temp = HTParse(use_this_url_instead,
				   WWWDoc.address,
				   PARSE_ALL);
		    if (temp && *temp) {
			StrAllocCopy(use_this_url_instead, temp);
d859 5
a863 7
		    FREE(temp);
		}
		url_type = is_url(use_this_url_instead);
		if (!HTPermitRedir &&
		    (url_type == LYNXDOWNLOAD_URL_TYPE ||
		     url_type == LYNXEXEC_URL_TYPE ||
		     url_type == LYNXPROG_URL_TYPE ||
d865 1
a865 1
		     url_type == LYNXDIRED_URL_TYPE ||
d867 14
a880 14
		     url_type == LYNXPRINT_URL_TYPE ||
		     url_type == LYNXOPTIONS_URL_TYPE ||
		     url_type == LYNXCFG_URL_TYPE ||
		     url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
		     url_type == LYNXHIST_URL_TYPE ||
		     url_type == LYNXCOOKIE_URL_TYPE ||
		     url_type == LYNXMESSAGES_URL_TYPE ||
		     (LYValidate &&
		      url_type != HTTP_URL_TYPE &&
		      url_type != HTTPS_URL_TYPE) ||
		     ((no_file_url || no_goto_file) &&
		      url_type == FILE_URL_TYPE) ||
		     (no_goto_lynxcgi &&
		      url_type == LYNXCGI_URL_TYPE) ||
d882 2
a883 2
		     (no_goto_bibp &&
		      url_type == BIBP_URL_TYPE) ||
d885 15
a899 15
		     (no_goto_cso &&
		      url_type == CSO_URL_TYPE) ||
		     (no_goto_finger &&
		      url_type == FINGER_URL_TYPE) ||
		     (no_goto_ftp &&
		      (url_type == FTP_URL_TYPE ||
		       url_type == NCFTP_URL_TYPE)) ||
		     (no_goto_gopher &&
		      url_type == GOPHER_URL_TYPE) ||
		     (no_goto_http &&
		      url_type == HTTP_URL_TYPE) ||
		     (no_goto_https &&
		      url_type == HTTPS_URL_TYPE) ||
		     (no_goto_mailto &&
		      url_type == MAILTO_URL_TYPE) ||
d901 4
a904 4
		     (no_goto_news &&
		      url_type == NEWS_URL_TYPE) ||
		     (no_goto_nntp &&
		      url_type == NNTP_URL_TYPE) ||
d906 2
a907 2
		     (no_goto_rlogin &&
		      url_type == RLOGIN_URL_TYPE) ||
d909 2
a910 2
		     (no_goto_snews &&
		      url_type == SNEWS_URL_TYPE) ||
d912 36
a947 18
		     (no_goto_telnet &&
		      url_type == TELNET_URL_TYPE) ||
		     (no_goto_tn3270 &&
		      url_type == TN3270_URL_TYPE) ||
		     (no_goto_wais &&
		      url_type == WAIS_URL_TYPE))) {
		    /*
		     * Some schemes are not acceptable from server
		     * redirections.  - KW & FM
		     */
		    HTAlert(ILLEGAL_REDIRECTION_URL);
		    if (LYCursesON) {
			HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE,
				   use_this_url_instead);
		    } else {
			fprintf(stderr,
				WWW_ILLEGAL_URL_MESSAGE,
				use_this_url_instead);
d949 5
d955 6
a960 4
		    return (NULLFILE);
		}
		if ((pound = findPoundSelector(doc->address)) != NULL
		    && findPoundSelector(use_this_url_instead) == NULL) {
d962 2
a963 6
		     * Our requested URL had a fragment associated with it,
		     * and the redirection URL doesn't, so we'll append the
		     * fragment associated with the original request.  If
		     * it's bogus for the redirection URL, we'll be
		     * positioned at the top of that document, so there's
		     * no harm done.  - FM
d965 1
a965 4
		    CTRACE((tfp,
			    "getfile: Adding fragment '%s' to redirection URL.\n",
			    pound));
		    StrAllocCat(use_this_url_instead, pound);
d967 2
a968 11
		CTRACE_SLEEP(MessageSecs);
		HTUserMsg2(WWW_USING_MESSAGE, use_this_url_instead);
		CTRACE((tfp, "\n"));
		StrAllocCopy(doc->address,
			     use_this_url_instead);
		FREE(use_this_url_instead);
		if (redirect_post_content == FALSE) {
		    /*
		     * Freeing the content also yields a GET request.  - FM
		     */
		    LYFreePostData(doc);
a969 9
		/*
		 * Go to top to check for URL's which get special handling
		 * and/or security checks in Lynx.  - FM
		 */
		goto Try_Redirected_URL;
	    }
	    if (HTNoDataOK) {
		return (NULLFILE);
	    } else {
a971 1
	} else {
d982 2
a983 13

	    /*
	     * Check for a #fragment selector.
	     */
	    pound = findPoundSelector(doc->address);

	    /*
	     * Check to see if there is a temp file waiting for us to
	     * download.
	     */
	    if (WWW_Download_File) {
		HTParentAnchor *tmpanchor = HTAnchor_findAddress(&WWWDoc);
		char *fname = NULL;
d986 1
a986 2
		 * Check for a suggested filename from the
		 * Content-Disposition header.  - FM
d988 2
a989 5
		if (HTAnchor_SugFname(tmpanchor) != NULL) {
		    StrAllocCopy(fname, HTAnchor_SugFname(tmpanchor));
		} else {
		    StrAllocCopy(fname, doc->address);
		}
d991 2
a992 3
		 * Check whether this is a compressed file, which we don't
		 * uncompress for downloads, and adjust any suffix
		 * appropriately.  - FM
d994 19
a1012 1
		HTCheckFnameForCompression(&fname, tmpanchor, FALSE);
d1014 7
a1020 2
		if (LYdownload_options(&fname,
				       WWW_Download_File) < 0) {
d1022 14
a1035 19
		    return (NOT_FOUND);
		}
		LYAddVisitedLink(doc);
		StrAllocCopy(doc->address, fname);
		FREE(fname);
		doc->internal_link = FALSE;
		WWWDoc.address = doc->address;
		LYFreePostData(doc);
		WWWDoc.post_data = NULL;
		WWWDoc.post_content_type = NULL;
		WWWDoc.bookmark = doc->bookmark = FALSE;
		WWWDoc.isHEAD = doc->isHEAD = FALSE;
		WWWDoc.safe = doc->safe = FALSE;
		HTOutputFormat = WWW_PRESENT;
		if (!HTLoadAbsolute(&WWWDoc)) {
		    return (NOT_FOUND);
		} else {
		    return (NORMAL);
		}
d1037 22
a1058 22
	    } else if (pound == NULL &&
		/*
		 * HTAnchor hash-table searches are now case-sensitive
		 * (hopefully, without anchor deletion problems), so this
		 * is too.  - FM
		 */
		       (strcmp(doc->address,
			       HTLoadedDocumentURL()) ||
		/*
		 * Also check the post_data elements.  - FM
		 */
			!BINEQ(doc->post_data,
			       HTLoadedDocumentPost_data()) ||
		/*
		 * Also check the isHEAD element.  - FM
		 */
			doc->isHEAD != HTLoadedDocumentIsHEAD())) {
		/*
		 * Nothing needed to be shown.
		 */
		LYAddVisitedLink(doc);
		return (NULLFILE);
d1060 9
a1068 4
	    } else {
		if (pound != NULL) {
		    if (!HTMainText) {	/* this should not happen... */
			return (NULLFILE);	/* but it can. - kw */
d1070 1
a1070 4
		    /*
		     * May set www_search_result.
		     */
		    HTFindPoundSelector(pound + 1);
a1071 1
		return (NORMAL);
@


1.1.3.5
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d537 1
a537 1
		    if (non_empty(title)) {
d854 1
a854 1
		    if (non_empty(temp)) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d17 1
a30 2
#include <LYHistory.h>
#include <LYPrettySrc.h>
d35 5
a39 1
PRIVATE int fix_httplike_urls PARAMS((document *doc, UrlTypes type));
d41 2
d47 1
a47 32
#ifdef VMS
#define STRNADDRCOMP strncasecomp
#else
#define STRNADDRCOMP strncmp
#endif /* !VMS */

PUBLIC int HTNoDataOK = 0;

/*
 *  getfile is the main mechanism to load a new document (or a previously
 *  loaded one whose rendering is cached in a HText structure) from
 *  mainloop, nearly everything goes through it.
 *  It should return one of the values
 *     NORMAL     - requested document loaded successfully, usually [always?]
 *                  its rendering is available as HTMainText.  It can be an
 *                  HTTP error message page or similar, we make no
 *                  distinction here.
 *     NOT_FOUND  - requested document cannot be accessed, and the reason
 *                  is a real error (as may be caused by an invalid link),
 *                  not just that lynx disallows access because of some
 *                  permission restrictions, and we have no error page
 *                  to show for it either.
 *     NULLFILE   - requested document not loaded into HTMainText, either
 *                  some interactive protocol was requested (like telnet),
 *                  or lynx does not allow access.
 *  The distinction between NOT_FOUND and NULLFILE is not very crucial,
 *  but getting it right prevents mainloop from exiting with the wrong
 *  message if it happens for the first file, and from logging (or not
 *  logging) errors inappropriately with -traversal, and from sending
 *  bogus error mail with MAIL_SYSTEM_ERROR_LOGGING:TRUE. - kw
 */
PUBLIC int getfile ARGS1(
d59 1
a59 1
	    CTRACE((tfp, "getfile:    resetting LYCancelDownload to FALSE\n"));
a67 8
	/*
	 *  Reset redirection counter to prevent bogus TOO_MANY_REDIRECTIONS
	 *  in rare situations if the previous cycle got to the limit, but
	 *  did not fail for that reason because the URL of the final location
	 *  was handled specially, not via HTLoadAbsolute. - kw
	 */
	redirection_attempts = 0;

a79 5
	 *  Reset HTPermitRedir, it has done its job if it was set. - kw
	 */
	HTPermitRedir = FALSE;

	/*
d89 1
a89 14
	/*
	 *  This flag is a hack to allow us to pass on the fact
	 *  that 'no data' may not really be an error although
	 *  HTLoadAbsolute returned NO.  There should be a better
	 *  way...  HT_NO_DATA should always mean 'not data but
	 *  not an error', and be passed on to us as that, but
	 *  current usage if HT_NO_DATA vs HT_NOT_LOADED has
	 *  to be reviewed everywhere.
	 *  Anyway, some protocol module can set it to say
	 *  'I really mean it', we have to reset it here. - kw
	 */
	HTNoDataOK = 0;

	CTRACE((tfp,"getfile: getting %s\n\n",doc->address));
d127 1
a127 1
		} else if (isdigit(UCH(*cp))) {
d151 1
a151 4
			  url_type == LYNXMESSAGES_URL_TYPE ||
			  (url_type == LYNXOPTIONS_URL_TYPE &&
			   WWWDoc.post_data) ||
			  0==STRNADDRCOMP(WWWDoc.address, helpfilepath,
d154 1
a154 1
			   0==STRNADDRCOMP(WWWDoc.address, lynxlistfile,
d157 1
a157 1
			   0==STRNADDRCOMP(WWWDoc.address, lynxlinksfile,
d160 1
a160 1
			   0==STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
a183 1
			  url_type == LYNXMESSAGES_URL_TYPE ||
d196 1
a196 1
			  0==STRNADDRCOMP(WWWDoc.address, helpfilepath,
d199 1
a199 1
			   0==STRNADDRCOMP(WWWDoc.address, lynxlistfile,
d202 1
a202 1
			   0==STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
d218 4
a221 3
		      (LYIsUIPage(WWWDoc.address, UIP_LIST_PAGE) ||
		       LYIsUIPage(WWWDoc.address, UIP_ADDRLIST_PAGE)))) {
		    CTRACE((tfp, "getfile: dropping post_data!\n"));
d228 5
a232 3
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
		LYSyslog (doc->address);
#endif
d252 1
a252 4
		} else if (url_type == LYNXCFG_URL_TYPE &&
		    !no_lynxcfg_info) {
		    /* @@@@@@ maybe we should generate a specific error message
		       if attempted but restricted. - kw */
d257 1
a257 4
		} else if (url_type == LYNXCOMPILE_OPTS_URL_TYPE &&
		    !no_compileopts_info) {
		    /* @@@@@@ maybe we should generate a specific error message
		       if attempted but restricted or not supported. - kw */
d262 4
a274 5
		    } else if (!news_ok && (
			url_type == NEWSPOST_URL_TYPE ||
			url_type == NEWSREPLY_URL_TYPE)) {
			HTUserMsg(NEWS_DISABLED);
			return(NULLFILE);
d293 2
d296 2
a298 1
		    return(NORMAL);
d301 4
a304 1
		    if (!no_dired_support) {
d317 1
a317 1
#endif /* DIRED_SUPPORT */
d320 1
a320 1
		}
d322 1
a322 39
		if (LYNoRefererHeader == FALSE &&
		    LYNoRefererForThis == FALSE) {
		    char *ref_url = HTLoadedDocumentURL();
		    if (!strncmp(ref_url, "LYNXIMGMAP:", 11))
			ref_url += 11;
		    if (no_filereferer == TRUE &&
			!strncmp(ref_url, "file:", 5)) {
			LYNoRefererForThis = TRUE;
		    }
		    if (LYNoRefererForThis == FALSE &&
			(cp = strchr(ref_url, '?')) != NULL &&
			strchr(cp, '=') != NULL) {
			/*
			 *  Don't send a Referer header if the URL is
			 *  the reply from a form with method GET, in
			 *  case the content has personal data (e.g.,
			 *  a password or credit card number) which
			 *  would become visible in logs. - FM
			 *
			 *  Changed 1999-11-01 to be controlled by
			 *  REFERER_WITH_QUERY option. - kw
			 */
			if (LYRefererWithQuery == 'S') { /* SEND */
			    StrAllocCopy(LYRequestReferer, ref_url);
			} else if (LYRefererWithQuery == 'P') { /* PARTIAL */
			    FREE(LYRequestReferer); /* just to be sure */
			    LYRequestReferer = HTParse(ref_url, "",
		PARSE_ACCESS|PARSE_HOST|PARSE_STRICTPATH|PARSE_PUNCTUATION);
			} else { /* Everyhting else - don't send Referer */
			    LYNoRefererForThis = TRUE;
			}
			cp = NULL;
		    } else if (LYNoRefererForThis == FALSE) {
			StrAllocCopy(LYRequestReferer, ref_url);
		    }
		} else {
		    StrAllocCopy(LYRequestReferer, HTLoadedDocumentURL());
		}
		if (url_type == LYNXHIST_URL_TYPE) {
a348 3
#ifdef DIRED_SUPPORT
		    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
d368 1
a368 1
			char *p = NULL;
d378 1
d383 6
a388 7
			    HTSprintf0(&p, "%.*s%s%s",
					   cp - doc->address,
					   doc->address,
					   wwwName(Home_Dir()),
					   cp + 1);
			} else {
			    StrAllocCopy(p, doc->address);
a401 2
			FREE(p);

d411 1
a411 1
			    (void) LYgetch();
d416 2
a417 4
			if (!dump_output_immediately) {
			    start_curses();
			    LYAddVisitedLink(doc);
			}
d476 1
a479 1
			   url_type != LYNXMESSAGES_URL_TYPE &&
a480 2
			   !(url_type == NEWS_URL_TYPE &&
			     strncmp(doc->address, "news://", 7)) &&
a491 1
		    char * proxy;
a493 1
			return(NULLFILE);
a495 15
			return(NULLFILE);
		    /*
		     *  Detect weird case where interactive protocol would
		     *  be proxied, and to a non-interactive protocol at that.
		     */
		    } else if ((proxy = (char *)getenv(
			(url_type==TN3270_URL_TYPE) ? "tn3270_proxy" :
			(url_type==TELNET_GOPHER_URL_TYPE) ? "gopher_proxy" :
			"telnet_proxy")) != NULL &&
			       *proxy != '\0' &&
			       !override_proxy(doc->address) &&
			       (strncmp(proxy, "telnet:", 7) &&
				strncmp(proxy, "tn3270:", 7) &&
				strncmp(proxy, "rlogin:", 7))) {
			/* Do nothing, fall through to generic code - kw */
d499 3
a501 6
			if (!dump_output_immediately) {
			    start_curses();
			    fflush(stdout);
			    LYAddVisitedLink(doc);
			}
			return(NULLFILE);
d503 1
d509 1
a509 3
		} else if (!news_ok && (
		    url_type == NEWS_URL_TYPE ||
		    url_type == NNTP_URL_TYPE)) {
a514 1
		    char * proxy;
a516 13
			return(NULLFILE);
		    /*
		     *  Detect weird case where interactive protocol would
		     *  be proxied, and to a non-interactive protocol at that.
		     */
		    } else if ((proxy = (char *)getenv(
			"rlogin_proxy")) != NULL &&
			       *proxy != '\0' &&
			       !override_proxy(doc->address) &&
			       (strncmp(proxy, "telnet:", 7) &&
				strncmp(proxy, "tn3270:", 7) &&
				strncmp(proxy, "rlogin:", 7))) {
			/* Do nothing, fall through to generic code - kw */
d521 2
a522 5
			if (!dump_output_immediately) {
			    start_curses();
			    LYAddVisitedLink(doc);
			}
			return(NULLFILE);
d524 1
a570 4
#ifdef DIRED_SUPPORT
		    } else {
			lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
d574 1
a574 2
		}
		{
d589 2
a590 2
			    CTRACE((tfp, "getfile: URL '%s'\n",
					doc->address));
d603 2
a604 2
			    CTRACE((tfp, "  changed to '%s'\n",
					doc->address));
d613 1
a613 1
			fix_httplike_urls(doc, url_type);
a617 25
#ifndef DISABLE_BIBP
		    if (url_type == BIBP_URL_TYPE) {
			char *bibpTmp = NULL;
			if (!BibP_bibhost_checked)
			    LYCheckBibHost();
			if (BibP_bibhost_available) {
			    StrAllocCopy(bibpTmp, BibP_bibhost);
			} else if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
			    StrAllocCopy(bibpTmp, HTAnchor_citehost(HTMainAnchor));
			} else {
			    StrAllocCopy(bibpTmp, BibP_globalserver);
			}
			if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
			    StrAllocCat(bibpTmp, "bibp1.0/resolve?citehost=");
			    StrAllocCat(bibpTmp, HTAnchor_citehost(HTMainAnchor));
			    StrAllocCat(bibpTmp, "&usin=");
			} else {
			    StrAllocCat(bibpTmp, "bibp1.0/resolve?usin=");
			}
			StrAllocCat(bibpTmp, doc->address+5); /* USIN after bibp: */
			StrAllocCopy(doc->address, bibpTmp);
			WWWDoc.address = doc->address;
			FREE(bibpTmp);
		    }
#endif /* !DISABLE_BIBP */
d635 2
a636 2
			    CTRACE((tfp, "getfile: URL '%s'\n",
					doc->address));
d650 2
a651 2
			    CTRACE((tfp, "  changed to '%s'\n",
					doc->address));
a657 1

d661 2
a662 2
			    LYaddstr("*\n");
			    LYrefresh();
d665 16
a680 1
			CTRACE((tfp, "\n"));
d682 1
d719 1
a719 2
			    if (!HTPermitRedir &&
			       (url_type == LYNXDOWNLOAD_URL_TYPE ||
a730 1
				url_type == LYNXMESSAGES_URL_TYPE ||
a737 4
#ifndef DISABLE_BIBP
				(no_goto_bibp &&
				 url_type == BIBP_URL_TYPE) ||
#endif
d769 1
a769 1
				 url_type == WAIS_URL_TYPE))) {
d778 1
a778 1
				    LYSleepAlert();
d798 1
a798 1
				CTRACE((tfp,
d800 1
a800 1
				    pound));
d806 2
a807 2
			    LYSleepInfo();
			    CTRACE((tfp, "\n"));
a825 2
			if (HTNoDataOK)
			    return(NULLFILE);
d832 1
a832 1
		     *	Some URL's don't actually return a document;
d834 1
a834 1
		     *	actually loaded and return NULLFILE if not
d837 2
a838 2
		     *	within the same document; do NOT return
		     *	NULLFILE in that case.
d926 4
a929 6
			    if (pound != NULL) {
				if (!HTMainText) /* this should not happen... */
				    return(NULLFILE); /* but it can. - kw */
				/*
				 *  May set www_search_result.
				 */
a930 1
			    }
d938 1
a938 1
	      CTRACE((tfp,"\n"));
a943 36
 *  Set source mode for the next retrieval via getfile or HTreparse_document.
 *  mode == -1: force normal presentation
 *  mode ==  1: force source presentation
 *  mode ==  0: reset to normal if it was set to source
 *  - kw
 */
PUBLIC void srcmode_for_next_retrieval ARGS1(
    int,	mode)
{
    if (mode < 0) {
	HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	psrc_view = FALSE;
#endif

    } else if (mode == 0) {
	if (HTOutputFormat == WWW_SOURCE)
	    HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	else if (LYpsrc)
	    psrc_view = FALSE;
#endif

    } else {
#ifdef USE_PRETTYSRC
	if (LYpsrc)
	    psrc_view = TRUE;
	else
	    HTOutputFormat = WWW_SOURCE;
#else
	HTOutputFormat = WWW_SOURCE;
#endif
    }
}

/*
d972 2
a973 2
    CTRACE((tfp,"follow_link_number(%d,%d,...)\n",c,cur));
    temp[0] = (char) c;
d985 1
a985 1
    while ( isdigit(UCH(*p)) )
a994 1
	break;
d1000 1
a1000 1
    CTRACE((tfp,"  temp=%s, *num=%d, rel='%c'\n",temp,*num,rel));
d1005 1
a1005 5
    if (( c == 'p' || c == 'P') && display_lines == 0) {
	CTRACE((tfp," curline=%d, LYlines=%d, display too small!\n",
	       curline,LYlines));
	return(PRINT_ERROR);
    } else if ( c == 'p' || c == 'P' ) {
d1013 2
a1014 2
	CTRACE((tfp," nlines=%d, npages=%d, curline=%d, curpage=%d\n",
		nlines,npages,curline,curpage));
d1032 1
a1032 1
    want_go = (BOOL) ( c == 'g' || c == 'G' );
a1206 1
    CONST char *allowed_extra_chars;
a1257 4
    if (Type == CGI_PATH)
	allowed_extra_chars = " _-:./@@~$&+=\t";
    else
	allowed_extra_chars = " _-:./@@~$+=\t";
d1259 6
a1264 1
	if (!isalnum(UCH(*cp)) && !strchr(allowed_extra_chars, *cp)) {
d1285 7
a1291 2
	    if (STRNADDRCOMP(source, tp->src, strlen(tp->src)) == 0 &&
		STRNADDRCOMP(command, tp->path, strlen(tp->path)) == 0)
d1308 2
a1309 3
PRIVATE int fix_httplike_urls ARGS2(
	document *,	doc,
	UrlTypes,	type)
a1313 8
     *  If there's a fragment present, our simplistic methods won't
     *  work.  - kw
     */
    if (strchr(doc->address, '#'))
	return 0;

#ifndef DISABLE_FTP
    /*
d1316 1
a1316 1
    if (type == FTP_URL_TYPE &&
d1342 1
a1342 1
	CTRACE((tfp, "fix_httplike_urls: URL '%s'\n", doc->address));
d1344 1
a1344 1
	CTRACE((tfp, "            changed to '%s'\n", doc->address));
a1346 1
#endif /* DISABLE_FTP */
a1354 21
	if (type == HTTP_URL_TYPE ||
	    type == HTTPS_URL_TYPE) {
	    if ((slash-2) - strchr(doc->address, ':')) {
	    /*
	     *  Turns out we were not looking at the right slash after all,
	     *  there must have been more than one "://" which is valid
	     *  at least for http URLs (later occurrences can be part of
	     *  a query string, for example), so leave this alone, too. - kw
	     */
		return(0);
	    }
	    if (strchr(doc->address, '?')) {
		/*
		 *  If there is a question mark that appears to be part
		 *  of the hostname, don't append anything either. Leave
		 *  it to HTParse to interpret the question mark as ending
		 *  the hostname. - kw
		 */
		return(0);
	    }
	}
d1356 1
a1356 1
    CTRACE((tfp, "fix_httplike_urls: URL '%s'\n", doc->address));
d1358 1
a1358 1
    CTRACE((tfp, "            changed to '%s'\n", doc->address));
@

