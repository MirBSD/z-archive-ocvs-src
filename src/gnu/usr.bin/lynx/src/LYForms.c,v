head	1.4;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.6
	tg-mergefixes-1-branch:1.1.3.6.0.4
	tg-mergefixes-1-base:1.1.3.6
	MIROS_X:1.1.3.6.0.2
	MIROS_X_BASE:1.1.3.6
	MIRBSD_XP_MIRPPC:1.1.3.4.0.4
	lynx-2_8_6dev_7b:1.1.3.6
	lynx-2_8_6dev_6:1.1.3.5
	MIRBSD_XP_SPARC_BASE:1.1.3.4
	MIRBSD_XP_SPARC:1.1.3.4.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2005.01.03.00.45.57;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.33;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.31;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.22;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.49;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.20;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.08.13.11.05;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.16.00;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.52.53;	author tg;	state Stab;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.11.20.16.25;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.20.10.10.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@soft merge
@
text
@#include <HTUtils.h>
#include <HTCJK.h>
#include <HTTP.h>
#include <HTAlert.h>
#include <LYCurses.h>
#include <GridText.h>
#include <LYCharSets.h>
#include <UCAux.h>
#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <LYStrings.h>
#include <LYKeymap.h>
#include <LYClean.h>

#include <LYLeaks.h>

#ifdef USE_COLOR_STYLE
#include <AttrList.h>
#include <LYHash.h>
#endif

#if defined(VMS) && !defined(USE_SLANG)
#define CTRL_W_HACK DO_NOTHING
#else
#define CTRL_W_HACK 23		/* CTRL-W refresh without clearok */
#endif /* VMS && !USE_SLANG */

static int form_getstr(int cur,
		       BOOLEAN use_last_tfpos,
		       BOOLEAN redraw_only);

/*
 * Returns an array of pointers to the given list
 */
static char **options_list(OptionType * opt_ptr)
{
    char **result = 0;
    size_t len;
    int pass;
    OptionType *tmp_ptr;

    for (pass = 0; pass < 2; pass++) {
	for (tmp_ptr = opt_ptr, len = 0; tmp_ptr != 0; tmp_ptr = tmp_ptr->next) {
	    if (pass != 0)
		result[len] = tmp_ptr->name;
	    len++;
	}
	if (pass == 0) {
	    len++;
	    result = typecallocn(char *, len);
	} else {
	    result[len] = 0;
	}
    }

    return result;
}

int change_form_link_ex(int cur,
			DocInfo *newdoc,
			BOOLEAN *refresh_screen,
			BOOLEAN use_last_tfpos,
			BOOLEAN immediate_submit,
			BOOLEAN redraw_only)
{
    FormInfo *form = links[cur].l_form;
    char *link_name = form->name;
    char *link_value = form->value;
    int newdoc_changed = 0;
    int c = DO_NOTHING;
    int OrigNumValue;
    char **my_data = 0;

    /*
     * If there is no form to perform action on, don't do anything.
     */
    if (form == NULL) {
	return (c);
    }
    my_data = options_list(form->select_list);

    /*
     * Move to the link position.
     */
    LYmove(links[cur].ly, links[cur].lx);

    switch (form->type) {
    case F_CHECKBOX_TYPE:
	if (form->disabled == YES)
	    break;
	LYSetHilite(cur, form->num_value ? unchecked_box : checked_box);
	form->num_value = !form->num_value;
	break;

    case F_OPTION_LIST_TYPE:
	if (form->select_list == 0) {
	    HTAlert(BAD_HTML_NO_POPUP);
	    c = DO_NOTHING;
	    break;
	}

	if (form->disabled == YES) {
	    int dummy;

	    dummy = LYhandlePopupList(form->num_value,
				      links[cur].ly,
				      links[cur].lx,
				      (const char **) my_data,
				      form->size,
				      form->size_l,
				      form->disabled,
				      FALSE,
				      FALSE);
#if CTRL_W_HACK != DO_NOTHING
	    if (!enable_scrollback)
		c = CTRL_W_HACK;	/* CTRL-W refresh without clearok */
	    else
#endif
		c = 12;		/* CTRL-L for repaint */
	    break;
	}
	OrigNumValue = form->num_value;
	form->num_value = LYhandlePopupList(form->num_value,
					    links[cur].ly,
					    links[cur].lx,
					    (const char **) my_data,
					    form->size,
					    form->size_l,
					    form->disabled,
					    FALSE,
					    FALSE);
	{
	    OptionType *opt_ptr = form->select_list;
	    int i;

	    for (i = 0; i < form->num_value; i++, opt_ptr = opt_ptr->next) ;	/* null body */
	    /*
	     * Set the name.
	     */
	    form->value = opt_ptr->name;
	    /*
	     * Set the value.
	     */
	    form->cp_submit_value = opt_ptr->cp_submit_value;
	    /*
	     * Set charset in which we have the submit value.  - kw
	     */
	    form->value_cs = opt_ptr->value_cs;
	}
#if CTRL_W_HACK != DO_NOTHING
	if (!enable_scrollback)
	    c = CTRL_W_HACK;	/* CTRL-W refresh without clearok */
	else
#endif
	    c = 12;		/* CTRL-L for repaint */
	break;

    case F_RADIO_TYPE:
	if (form->disabled == YES)
	    break;
	/*
	 * Radio buttons must have one and only one down at a time!
	 */
	if (form->num_value) {
	    if (user_mode == NOVICE_MODE) {
		HTUserMsg(NEED_CHECKED_RADIO_BUTTON);
	    }
	} else {
	    int i;

	    /*
	     * Run though list of the links on the screen and unselect any that
	     * are selected.  :)
	     */
	    lynx_start_radio_color();
	    for (i = 0; i < nlinks; i++) {
		if (links[i].type == WWW_FORM_LINK_TYPE
		    && links[i].l_form->type == F_RADIO_TYPE
		    && links[i].l_form->number == form->number
		/*
		 * If it has the same name and its on...
		 */
		    && !strcmp(links[i].l_form->name, form->name)
		    && links[i].l_form->num_value) {
		    LYmove(links[i].ly, links[i].lx);
		    LYaddstr(unchecked_radio);
		    LYSetHilite(i, unchecked_radio);
		}
	    }
	    lynx_stop_radio_color();
	    /*
	     * Will unselect other button and select this one.
	     */
	    HText_activateRadioButton(form);
	    /*
	     * Now highlight this one.
	     */
	    LYSetHilite(cur, checked_radio);
	}
	break;

    case F_FILE_TYPE:
    case F_TEXT_TYPE:
    case F_TEXTAREA_TYPE:
    case F_PASSWORD_TYPE:
	c = form_getstr(cur, use_last_tfpos, redraw_only);
	LYSetHilite(cur, (form->type == F_PASSWORD_TYPE)
		    ? STARS(strlen(form->value))
		    : form->value);
	break;

    case F_RESET_TYPE:
	if (form->disabled == YES)
	    break;
	HText_ResetForm(form);
	*refresh_screen = TRUE;
	break;

    case F_TEXT_SUBMIT_TYPE:
	if (redraw_only) {
	    c = form_getstr(cur, use_last_tfpos, TRUE);
	    break;
	}
	if (!immediate_submit)
	    c = form_getstr(cur, use_last_tfpos, FALSE);
	if (form->disabled == YES &&
	    (c == '\r' || c == '\n' || immediate_submit)) {
	    if (peek_mouse_link() >= 0)
		c = LAC_TO_LKC0(LYK_ACTIVATE);
	    else
		c = '\t';
	    break;
	}
	/*
	 * If immediate_submit is set, we didn't enter the line editor above,
	 * and will now try to call HText_SubmitForm() directly.  If
	 * immediate_submit is not set, c is the lynxkeycode returned from line
	 * editing.  Then if c indicates that a key was pressed that means we
	 * should submit, but with some extra considerations (i.e.  NOCACHE,
	 * DOWNLOAD, different from simple Enter), or if we should act on some
	 * *other* link selected with the mouse, we'll just return c and leave
	 * it to mainloop() to do the right thing; if everything checks out, it
	 * should call this function again, with immediate_submit set.
	 *
	 * If c indicates that line editing ended with Enter, we still defer to
	 * mainloop() for further checking if the submit action URL could
	 * require more checks than we do here.  Only in the remaining cases do
	 * we proceed to call HText_SubmitForm() directly before returning.  -
	 * kw
	 */
	if (immediate_submit ||
	    ((c == '\r' || c == '\n' || c == LAC_TO_LKC0(LYK_SUBMIT)) &&
	     peek_mouse_link() == -1)) {
	    LYSetHilite(cur, form->value);
#ifdef TEXT_SUBMIT_CONFIRM_WANTED
	    if (!immediate_submit && (c == '\r' || c == '\n') &&
		!HTConfirmDefault(NO_SUBMIT_BUTTON_QUERY), YES) {
		/* User was prompted and declined; if canceled with ^G
		 * let mainloop stay on this field, otherwise move on to
		 * the next field or link. - kw
		 */
		if (HTLastConfirmCancelled())
		    c = DO_NOTHING;
		else
		    c = LAC_TO_LKC(LYK_NEXT_LINK);
		break;
	    }
#endif
	    if (!form->submit_action || *form->submit_action == '\0') {
		HTUserMsg(NO_FORM_ACTION);
		c = DO_NOTHING;
		break;
	    } else if (form->submit_method == URL_MAIL_METHOD && no_mail) {
		HTAlert(FORM_MAILTO_DISALLOWED);
		c = DO_NOTHING;
		break;
	    } else if (!immediate_submit &&
		       ((no_file_url &&
			 isFILE_URL(form->submit_action)) ||
			!strncasecomp(form->submit_action, "lynx", 4))) {
		c = LAC_TO_LKC0(LYK_SUBMIT);
		break;
	    } else {
		if (form->no_cache &&
		    form->submit_method != URL_MAIL_METHOD) {
		    LYforce_no_cache = TRUE;
		    reloading = TRUE;
		}
		newdoc_changed =
		    HText_SubmitForm(form, newdoc, link_name, form->value);
	    }
	    if (form->submit_method == URL_MAIL_METHOD) {
		*refresh_screen = TRUE;
	    } else {
		/*
		 * Returns new document URL.
		 */
		newdoc->link = 0;
		newdoc->internal_link = FALSE;
	    }
	    c = DO_NOTHING;
	    break;
	} else {
	    LYSetHilite(cur, form->value);
	}
	break;

    case F_SUBMIT_TYPE:
    case F_IMAGE_SUBMIT_TYPE:
	if (form->disabled == YES)
	    break;
	if (form->no_cache &&
	    form->submit_method != URL_MAIL_METHOD) {
	    LYforce_no_cache = TRUE;
	    reloading = TRUE;
	}
	newdoc_changed =
	    HText_SubmitForm(form, newdoc, link_name, link_value);
	if (form->submit_method == URL_MAIL_METHOD)
	    *refresh_screen = TRUE;
	else {
	    /* returns new document URL */
	    newdoc->link = 0;
	    newdoc->internal_link = FALSE;
	}
	break;

    }

    if (newdoc_changed) {
	c = LKC_DONE;
    } else {
	/*
	 * These flags may have been set in mainloop, anticipating that a
	 * request will be submitted.  But if we haven't filled in newdoc, that
	 * won't actually be the case, so unset them.  - kw
	 */
	LYforce_no_cache = FALSE;
	reloading = FALSE;
    }
    FREE(my_data);
    return (c);
}

int change_form_link(int cur,
		     DocInfo *newdoc,
		     BOOLEAN *refresh_screen,
		     BOOLEAN use_last_tfpos,
		     BOOLEAN immediate_submit)
{
    /*pass all our args and FALSE as last arg */
    return change_form_link_ex(cur,
			       newdoc,
			       refresh_screen,
			       use_last_tfpos,
			       immediate_submit,
			       FALSE /*redraw_only */ );
}

static int LastTFPos = -1;	/* remember last text field position */

static void LYSetLastTFPos(int pos)
{
    LastTFPos = pos;
}

static int form_getstr(int cur,
		       BOOLEAN use_last_tfpos,
		       BOOLEAN redraw_only)
{
    FormInfo *form = links[cur].l_form;
    char *value = form->value;
    int ch;
    int far_col;
    int max_length;
    int startcol, startline;
    BOOL HaveMaxlength = FALSE;
    int action, repeat;
    int last_xlkc = -1;

#ifdef SUPPORT_MULTIBYTE_EDIT
    BOOL refresh_mb = TRUE;
#endif

    EditFieldData MyEdit;
    BOOLEAN Edited = FALSE;	/* Value might be updated? */

    /*
     * Get the initial position of the cursor.
     */
    LYGetYX(startline, startcol);
    if ((startcol + form->size) > LYcolLimit)
	far_col = LYcolLimit;
    else
	far_col = (startcol + form->size);

    /*
     * Make sure the form field value does not exceed our buffer.  - FM
     */
    max_length = ((form->maxlength > 0 &&
		   form->maxlength < sizeof(MyEdit.buffer)) ?
		  form->maxlength :
		  (sizeof(MyEdit.buffer) - 1));
    if (strlen(form->value) > (size_t) max_length) {
	/*
	 * We can't fit the entire value into the editing buffer, so enter as
	 * much of the tail as fits.  - FM
	 */
	value += (strlen(form->value) - max_length);
	if (!form->disabled &&
	    !(form->submit_method == URL_MAIL_METHOD && no_mail)) {
	    /*
	     * If we can edit it, report that we are using the tail.  - FM
	     */
	    HTUserMsg(FORM_VALUE_TOO_LONG);
	    show_formlink_statusline(form, redraw_only ? FOR_PANEL : FOR_INPUT);
	    LYmove(startline, startcol);
	}
    }

    /*
     * Print panned line
     */
    LYSetupEdit(&MyEdit, value, max_length, (far_col - startcol));
    MyEdit.pad = '_';
    MyEdit.hidden = (BOOL) (form->type == F_PASSWORD_TYPE);
    if (use_last_tfpos && LastTFPos >= 0 && LastTFPos < MyEdit.strlen) {
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
	if (redraw_only) {
	    if (!(MyEdit.strlen >= MyEdit.dspwdth &&
		  LastTFPos >= MyEdit.dspwdth - MyEdit.margin)) {
		MyEdit.pos = LastTFPos;
		if (MyEdit.strlen >= MyEdit.dspwdth)
		    textinput_redrawn = FALSE;
	    }
	} else
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
	    MyEdit.pos = LastTFPos;
#ifdef ENHANCED_LINEEDIT
	if (MyEdit.pos == 0)
	    MyEdit.mark = -1 - MyEdit.strlen;	/* Do not show the region. */
#endif
    }
    /* Try to prepare for setting position based on the last mouse event */
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
    if (!redraw_only) {
	if (peek_mouse_levent()) {
	    if (!use_last_tfpos && !textinput_redrawn) {
		MyEdit.pos = 0;
	    }
	}
	textinput_redrawn = FALSE;
    }
#else
    if (peek_mouse_levent()) {
	if (!use_last_tfpos)
	    MyEdit.pos = 0;
    }
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
    LYRefreshEdit(&MyEdit);
    if (redraw_only)
	return 0;		/*return value won't be analysed */

    /*
     * And go for it!
     */
    for (;;) {
      again:
	repeat = -1;
	get_mouse_link();	/* Reset mouse_link. */

	ch = LYgetch_input();
#ifdef SUPPORT_MULTIBYTE_EDIT
	if (!refresh_mb
	    && (EditBinding(ch) != LYE_CHAR)
#ifndef WIN_EX
	    && (EditBinding(ch) != LYE_AIX)
#endif
	    )
	    goto again;
#endif /* SUPPORT_MULTIBYTE_EDIT */
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    ch = LYCharINTERRUPT2;
	}
#endif /* VMS */

	action = 0;
#ifdef USE_MOUSE
#  if defined(NCURSES) || defined(PDCURSES)
	if (ch != -1 && (ch & LKC_ISLAC) && !(ch & LKC_ISLECLAC))	/* already lynxactioncode? */
	    break;		/* @@@@@@ maybe move these 2 lines outside ifdef -kw */
	if (ch == MOUSE_KEY) {	/* Need to process ourselves */
#if defined(PDCURSES)
	    int curx, cury;

	    request_mouse_pos();
	    LYGetYX(cury, curx);
	    if (MOUSE_Y_POS == cury) {
		repeat = MOUSE_X_POS - curx;
		if (repeat < 0) {
		    action = LYE_BACK;
		    repeat = -repeat;
		} else
		    action = LYE_FORW;
	    }
#else
	    MEVENT event;
	    int curx, cury;

	    getmouse(&event);
	    LYGetYX(cury, curx);
	    if (event.y == cury) {
		repeat = event.x - curx;
		if (repeat < 0) {
		    action = LYE_BACK;
		    repeat = -repeat;
		} else
		    action = LYE_FORW;
	    }
#endif /* PDCURSES */
	    else {
		/* Mouse event passed to us as MOUSE_KEY, and apparently not on
		 * this field's line?  Something is not as it should be...
		 *
		 * A call to statusline() may have happened, possibly from
		 * within a mouse menu.  Let's at least make sure here that the
		 * cursor position gets restored.  - kw
		 */
		MyEdit.dirty = TRUE;
	    }
	    last_xlkc = -1;
	} else
#  endif			/* NCURSES || PDCURSES */
#endif /* USE_MOUSE */

	{
	    if (!(ch & LKC_ISLECLAC))
		ch |= MyEdit.current_modifiers;
	    MyEdit.current_modifiers = 0;
	    if (last_xlkc != -1) {
		if (ch == last_xlkc)
		    ch |= LKC_MOD3;
		last_xlkc = -1;	/* consumed */
	    }
	}
	if (peek_mouse_link() != -1)
	    break;

	if (!action)
	    action = EditBinding(ch);
	if ((action & LYE_DF) && !(action & LYE_FORM_LAC)) {
	    last_xlkc = ch;
	    action &= ~LYE_DF;
	} else {
	    last_xlkc = -1;
	}

	if (action == LYE_SETM1) {
	    /*
	     * Set flag for modifier 1.
	     */
	    MyEdit.current_modifiers |= LKC_MOD1;
	    continue;
	}
	if (action == LYE_SETM2) {
	    /*
	     * Set flag for modifier 2.
	     */
	    MyEdit.current_modifiers |= LKC_MOD2;
	    continue;
	}
	/*
	 * Filter out global navigation keys that should not be passed to line
	 * editor, and LYK_REFRESH.
	 */
	if (action == LYE_ENTER)
	    break;
	if (action == LYE_FORM_PASS)
	    break;
	if (action & LYE_FORM_LAC) {
	    ch = (action & LAC_MASK) | LKC_ISLAC;
	    break;
	}
	if (action == LYE_LKCMD) {
	    _statusline(ENTER_LYNX_COMMAND);
	    ch = LYgetch();
#ifdef VMS
	    if (HadVMSInterrupt) {
		HadVMSInterrupt = FALSE;
		ch = LYCharINTERRUPT2;
	    }
#endif /* VMS */
	    break;
	}
#ifdef CAN_CUT_AND_PASTE	/* 1998/10/01 (Thu) 19:19:22 */
	if (action == LYE_PASTE) {
	    unsigned char *s = (unsigned char *) get_clip_grab(), *e;
	    char *buf = NULL;
	    int len;

	    if (!s)
		break;
	    len = strlen((const char *) s);
	    e = s + len;

	    if (len > 0) {
		unsigned char *e1 = s;

		while (e1 < e) {
		    if (*e1 < ' ') {	/* Stop here? */
			if (e1 > s)
			    LYEditInsert(&MyEdit, s, e1 - s, -1, TRUE);
			s = e1;
			if (*e1 == '\t') {	/* Replace by space */
			    LYEditInsert(&MyEdit, (unsigned char *) " ", 1,
					 -1, TRUE);
			    s = ++e1;
			} else
			    break;
		    } else
			++e1;
		}
		if (e1 > s)
		    LYEditInsert(&MyEdit, s, e1 - s, -1, TRUE);
		while (e1 < e && *e1 == '\r')
		    e1++;
		if (e1 + 1 < e && *e1 == '\n')
		    StrAllocCopy(buf, (char *) e1 + 1);		/* Survive _release() */
		get_clip_release();
		if (MyEdit.strlen >= max_length) {
		    HaveMaxlength = TRUE;
		} else if (HaveMaxlength &&
			   MyEdit.strlen < max_length) {
		    HaveMaxlength = FALSE;
		    _statusline(ENTER_TEXT_ARROWS_OR_TAB);
		}
		if (strcmp(value, MyEdit.buffer) != 0) {
		    Edited = TRUE;
		}
		if (buf) {
		    put_clip(buf);
		    FREE(buf);
		    ch = '\n';	/* Sometimes moves to the next line */
		    break;
		}
		LYRefreshEdit(&MyEdit);
	    } else {
		HTInfoMsg(gettext("Clipboard empty or Not text data."));
		continue;
	    }
	}
#endif
#ifndef WIN_EX
	if (action == LYE_AIX &&
	    (HTCJK == NOCJK && LYlowest_eightbit[current_char_set] > 0x97))
	    break;
#endif
	if (action == LYE_TAB) {
	    ch = (int) ('\t');
	    break;
	}
	if (action == LYE_ABORT) {
	    return (DO_NOTHING);
	}
	if (action == LYE_STOP) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    textfields_need_activation = TRUE;
	    break;
#else
#ifdef ENHANCED_LINEEDIT
	    if (MyEdit.mark >= 0)
		MyEdit.mark = -1 - MyEdit.strlen;	/* Disable. */
#endif
#endif
	}
	if (action == LYE_NOP && LKC_TO_LAC(keymap, ch) == LYK_REFRESH)
	    break;
#ifdef SH_EX
/* ASATAKU emacskey hack 1997/08/26 (Tue) 09:19:23 */
	if (emacs_keys &&
	    (EditBinding(ch) == LYE_FORWW || EditBinding(ch) == LYE_BACKW))
	    goto breakfor;
/* ASATAKU emacskey hack */
#endif
	switch (ch) {
	default:
	    /* [ 1999/04/14 (Wed) 15:01:33 ]
	     * Left arrrow in column 0 deserves special treatment here, else
	     * you can get trapped in a form without submit button!
	     */
	    if (action == LYE_BACK && MyEdit.pos == 0 && repeat == -1) {
		int c = YES;	/* Go back immediately if no changes */

		if (textfield_prompt_at_left_edge) {
		    c = HTConfirmDefault(PREV_DOC_QUERY, NO);
		} else if (strcmp(MyEdit.buffer, value)) {
		    c = HTConfirmDefault(PREV_DOC_QUERY, NO);
		}
		if (c == YES) {
		    return (ch);
		} else {
		    if (form->disabled == YES)
			_statusline(ARROWS_OR_TAB_TO_MOVE);
		    else
			_statusline(ENTER_TEXT_ARROWS_OR_TAB);
		}
	    }
	    if (form->disabled == YES) {
		/*
		 * Allow actions that don't modify the contents even in
		 * disabled form fields, so the user can scroll through the
		 * line for reading if necessary.  - kw
		 */
		switch (action) {
		case LYE_BOL:
		case LYE_EOL:
		case LYE_FORW:
		case LYE_FORW_RL:
		case LYE_BACK:
		case LYE_BACK_LL:
		case LYE_FORWW:
		case LYE_BACKW:
#ifdef EXP_KEYBOARD_LAYOUT
		case LYE_SWMAP:
#endif
#ifdef ENHANCED_LINEEDIT
		case LYE_SETMARK:
		case LYE_XPMARK:
#endif
		    break;
		default:
		    goto again;
		}
	    }
	    /*
	     * Make sure the statusline uses editmode help.
	     */
	    if (repeat < 0)
		repeat = 1;
	    while (repeat--) {
		int rc = LYEdit1(&MyEdit, ch, action & ~LYE_DF, TRUE);

		if (rc < 0) {
		    ch = -rc;
		    /* FORW_RL and BACK_LL may require special attention.
		       BACK_LL wanted to switch to the previous link on
		       the same line.  However, if there is no such link,
		       then we would either disactivate the form
		       (with -tna), or will reenter the form, thus we jump
		       to the end of the line; both are counterintuitive.
		       Unfortunately, we do not have access to curdoc.link,
		       so we deduce it ourselves.  We don't have the info
		       to do it inside LYLineEdit().
		       This should work for prompts too.  */
		    if ((action != LYE_BACK_LL && action != LYE_FORW_RL)
			|| (cur >= 0
			    && cur < nlinks
			    && (action == LYE_FORW_RL
				? cur < nlinks - 1
				: cur > 0)
			    && links[cur + ((action == LYE_FORW_RL)
					    ? 1
					    : -1)].ly
			    == links[cur].ly))
			goto breakfor;
		}
#ifdef SUPPORT_MULTIBYTE_EDIT
		if (rc == 0) {
		    if (HTCJK != NOCJK && (0x80 <= ch)
			&& (ch <= 0xfe) && refresh_mb)
			refresh_mb = FALSE;
		    else
			refresh_mb = TRUE;
		} else {
		    if (!refresh_mb) {
			LYEdit1(&MyEdit, 0, LYE_DELP, TRUE);
		    }
		}
#endif /* SUPPORT_MULTIBYTE_EDIT */
	    }
	    if (MyEdit.strlen >= max_length) {
		HaveMaxlength = TRUE;
	    } else if (HaveMaxlength &&
		       MyEdit.strlen < max_length) {
		HaveMaxlength = FALSE;
		_statusline(ENTER_TEXT_ARROWS_OR_TAB);
	    }
	    if (strcmp(value, MyEdit.buffer)) {
		Edited = TRUE;
	    }
#ifdef SUPPORT_MULTIBYTE_EDIT
	    if (refresh_mb)
#endif
		LYRefreshEdit(&MyEdit);
	    LYSetLastTFPos(MyEdit.pos);
	}
    }
  breakfor:
    if (Edited) {
	char *p;

	/*
	 * Load the new value.
	 */
	if (value == form->value) {
	    /*
	     * The previous value did fit in the line buffer, so replace it
	     * with the new value.  - FM
	     */
	    StrAllocCopy(form->value, MyEdit.buffer);
	} else {
	    /*
	     * Combine the modified tail with the unmodified head.  - FM
	     */
	    form->value[(strlen(form->value) - strlen(value))] = '\0';
	    StrAllocCat(form->value, MyEdit.buffer);
	    HTUserMsg(FORM_TAIL_COMBINED_WITH_HEAD);
	}

	/* 2.8.4pre.3 - most browsers appear to preserve trailing spaces -VH */
	/*
	 * Remove trailing spaces
	 *
	 * Do we really need to do that here?  Trailing spaces will only be
	 * there if user keyed them in.  Rather rude to throw away their hard
	 * earned spaces.  Better deal with trailing spaces when submitting the
	 * form????
	 */
	if (LYtrimInputFields) {
	    p = &(form->value[strlen(form->value)]);
	    while ((p != form->value) && (p[-1] == ' '))
		p--;
	    *p = '\0';
	}

	/*
	 * If the field has been changed, assume that it is now in current
	 * display character set, even if for some reason it wasn't!  Hopefully
	 * a user will only submit the form if the non-ASCII characters are
	 * displayed correctly, which means (assuming that the display
	 * character set has been set truthfully) the user confirms by changing
	 * the field that the character encoding is right.  - kw
	 */
	if (non_empty(form->value))
	    form->value_cs = current_char_set;
    }
    return (ch);
}

/*
 * Display statusline info tailored for the current form field.
 */
void show_formlink_statusline(const FormInfo * form,
			      int for_what)
{
    switch (form->type) {
    case F_PASSWORD_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_PASSWORD_UNM_MSG);
	else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	if (for_what == FOR_PANEL)
	    statusline(FORM_LINK_PASSWORD_MESSAGE_INA);
	else
#endif
	    statusline(FORM_LINK_PASSWORD_MESSAGE);
	break;
    case F_OPTION_LIST_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
	else
	    statusline(FORM_LINK_OPTION_LIST_MESSAGE);
	break;
    case F_CHECKBOX_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_CHECKBOX_UNM_MSG);
	else
	    statusline(FORM_LINK_CHECKBOX_MESSAGE);
	break;
    case F_RADIO_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_RADIO_UNM_MSG);
	else
	    statusline(FORM_LINK_RADIO_MESSAGE);
	break;
    case F_TEXT_SUBMIT_TYPE:
	if (form->disabled == YES) {
	    statusline(FORM_LINK_TEXT_SUBMIT_UNM_MSG);
	} else if (form->submit_method ==
		   URL_MAIL_METHOD) {
	    if (no_mail)
		statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_DIS_MSG);
	    else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (for_what == FOR_PANEL)
		statusline(FORM_TEXT_SUBMIT_MAILTO_MSG_INA);
	    else
#endif
		statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_MSG);
	} else if (form->no_cache) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (for_what == FOR_PANEL)
		statusline(FORM_TEXT_RESUBMIT_MESSAGE_INA);
	    else
#endif
		statusline(FORM_LINK_TEXT_RESUBMIT_MESSAGE);
	} else {
	    char *submit_str = NULL;
	    char *xkey_info = key_for_func_ext(LYK_NOCACHE, for_what);

	    if (non_empty(xkey_info)) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    HTSprintf0(&submit_str, FORM_TEXT_SUBMIT_MESSAGE_INA_X,
			       xkey_info);
		else
#endif
		    HTSprintf0(&submit_str, FORM_LINK_TEXT_SUBMIT_MESSAGE_X,
			       xkey_info);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE_INA);
		else
#endif
		    statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE);
	    }
	    FREE(xkey_info);
	}
	break;
    case F_SUBMIT_TYPE:
    case F_IMAGE_SUBMIT_TYPE:
	if (form->disabled == YES) {
	    statusline(FORM_LINK_SUBMIT_DIS_MSG);
	} else if (form->submit_method ==
		   URL_MAIL_METHOD) {
	    if (no_mail) {
		statusline(FORM_LINK_SUBMIT_MAILTO_DIS_MSG);
	    } else {
		if (user_mode == ADVANCED_MODE) {
		    char *submit_str = NULL;

		    StrAllocCopy(submit_str, FORM_LINK_SUBMIT_MAILTO_PREFIX);
		    StrAllocCat(submit_str, form->submit_action);
		    statusline(submit_str);
		    FREE(submit_str);
		} else {
		    statusline(FORM_LINK_SUBMIT_MAILTO_MSG);
		}
	    }
	} else if (form->no_cache) {
	    if (user_mode == ADVANCED_MODE) {
		char *submit_str = NULL;

		StrAllocCopy(submit_str, FORM_LINK_RESUBMIT_PREFIX);
		StrAllocCat(submit_str, form->submit_action);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
		statusline(FORM_LINK_RESUBMIT_MESSAGE);
	    }
	} else {
	    if (user_mode == ADVANCED_MODE) {
		char *submit_str = NULL;

		StrAllocCopy(submit_str, FORM_LINK_SUBMIT_PREFIX);
		StrAllocCat(submit_str, form->submit_action);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
		statusline(FORM_LINK_SUBMIT_MESSAGE);
	    }
	}
	break;
    case F_RESET_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_RESET_DIS_MSG);
	else
	    statusline(FORM_LINK_RESET_MESSAGE);
	break;
    case F_FILE_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_FILE_UNM_MSG);
	else
	    statusline(FORM_LINK_FILE_MESSAGE);
	break;
    case F_TEXT_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_TEXT_UNM_MSG);
	else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	if (for_what == FOR_PANEL)
	    statusline(FORM_LINK_TEXT_MESSAGE_INA);
	else
#endif
	    statusline(FORM_LINK_TEXT_MESSAGE);
	break;
    case F_TEXTAREA_TYPE:
	if (form->disabled == YES) {
	    statusline(FORM_LINK_TEXT_UNM_MSG);
	} else {
	    char *submit_str = NULL;
	    char *xkey_info = NULL;

	    if (!no_editor && editor && editor) {
		xkey_info = key_for_func_ext(LYK_EDIT_TEXTAREA, for_what);
#ifdef TEXTAREA_AUTOEXTEDIT
		if (!xkey_info)
		    xkey_info = key_for_func_ext(LYK_DWIMEDIT, for_what);
#endif
	    }
	    if (non_empty(xkey_info)) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    HTSprintf0(&submit_str, FORM_LINK_TEXTAREA_MESSAGE_INA_E,
			       xkey_info);
		else
#endif
		    HTSprintf0(&submit_str, FORM_LINK_TEXTAREA_MESSAGE_E,
			       xkey_info);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    statusline(FORM_LINK_TEXTAREA_MESSAGE_INA);
		else
#endif
		    statusline(FORM_LINK_TEXTAREA_MESSAGE);
	    }
	    FREE(xkey_info);
	}
	break;
    }
}
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d25 1
a25 1
#define CTRL_W_HACK 23  /* CTRL-W refresh without clearok */
d28 3
a30 4
PRIVATE int form_getstr PARAMS((
	int		cur,
	BOOLEAN		use_last_tfpos,
	BOOLEAN		redraw_only));
d35 1
a35 2
PRIVATE char ** options_list ARGS1(
	OptionType *,	opt_ptr)
d59 6
a64 7
PUBLIC int change_form_link_ex ARGS6(
	int,		cur,
	DocInfo *,	newdoc,
	BOOLEAN *,	refresh_screen,
	BOOLEAN,	use_last_tfpos,
	BOOLEAN,	immediate_submit,
	BOOLEAN,	redraw_only)
d75 1
a75 1
     *  If there is no form to perform action on, don't do anything.
d78 1
a78 1
	return(c);
d83 1
a83 1
     *  Move to the link position.
d87 12
a98 6
    switch(form->type) {
	case F_CHECKBOX_TYPE:
	    if (form->disabled == YES)
		break;
	    LYSetHilite(cur, form->num_value ? unchecked_box : checked_box);
	    form->num_value = ! form->num_value;
d100 1
d102 2
a103 6
	case F_OPTION_LIST_TYPE:
	    if (form->select_list == 0) {
		HTAlert(BAD_HTML_NO_POPUP);
		c = DO_NOTHING;
		break;
	    }
d105 9
a113 47
	    if (form->disabled == YES) {
		int dummy;
		dummy = LYhandlePopupList(form->num_value,
					  links[cur].ly,
					  links[cur].lx,
					  (CONST char **)my_data,
					  form->size,
					  form->size_l,
					  form->disabled,
					  FALSE,
					  FALSE);
#if CTRL_W_HACK != DO_NOTHING
		if (!enable_scrollback)
		    c = CTRL_W_HACK;  /* CTRL-W refresh without clearok */
		else
#endif
		    c = 12;  /* CTRL-L for repaint */
		break;
	    }
	    OrigNumValue = form->num_value;
	    form->num_value = LYhandlePopupList(form->num_value,
						links[cur].ly,
						links[cur].lx,
						(CONST char **)my_data,
						form->size,
						form->size_l,
						form->disabled,
						FALSE,
						FALSE);
	    {
		OptionType * opt_ptr = form->select_list;
		int i;
		for (i = 0; i < form->num_value; i++, opt_ptr = opt_ptr->next)
		    ; /* null body */
		/*
		 *  Set the name.
		 */
		form->value = opt_ptr->name;
		/*
		 *  Set the value.
		 */
		form->cp_submit_value = opt_ptr->cp_submit_value;
		 /*
		  *  Set charset in which we have the submit value. - kw
		  */
		form->value_cs = opt_ptr->value_cs;
	    }
d116 1
a116 1
		c = CTRL_W_HACK;	 /* CTRL-W refresh without clearok */
d119 1
a119 1
		c = 12;	 /* CTRL-L for repaint */
d121 36
d158 8
a165 8
	case F_RADIO_TYPE:
	    if (form->disabled == YES)
		break;
		/*
		 *  Radio buttons must have one and
		 *  only one down at a time!
		 */
	    if (form->num_value) {
d167 13
a179 2
	    } else {
		int i;
d181 1
a181 2
		 *  Run though list of the links on the screen and
		 *  unselect any that are selected. :)
d183 5
a187 14
		lynx_start_radio_color ();
		for (i = 0; i < nlinks; i++) {
		    if (links[i].type == WWW_FORM_LINK_TYPE
		     && links[i].l_form->type == F_RADIO_TYPE
		     && links[i].l_form->number == form->number
			/*
			 *  If it has the same name and its on...
			 */
		     && !strcmp(links[i].l_form->name, form->name)
		     && links[i].l_form->num_value) {
			LYmove(links[i].ly, links[i].lx);
			LYaddstr(unchecked_radio);
			LYSetHilite(i, unchecked_radio);
		    }
a188 9
		lynx_stop_radio_color ();
		/*
		 *  Will unselect other button and select this one.
		 */
		HText_activateRadioButton(form);
		/*
		 *  Now highlight this one.
		 */
		LYSetHilite(cur, checked_radio);
d190 24
d215 3
d219 3
a221 8
	case F_FILE_TYPE:
	case F_TEXT_TYPE:
	case F_TEXTAREA_TYPE:
	case F_PASSWORD_TYPE:
	    c = form_getstr(cur, use_last_tfpos, redraw_only);
	    LYSetHilite(cur, (form->type == F_PASSWORD_TYPE)
			? STARS(strlen(form->value))
			: form->value);
d223 9
a231 6

	case F_RESET_TYPE:
	    if (form->disabled == YES)
		break;
	    HText_ResetForm(form);
	    *refresh_screen = TRUE;
d233 31
a263 12

	case F_TEXT_SUBMIT_TYPE:
	    if (redraw_only) {
		c = form_getstr(cur, use_last_tfpos, TRUE);
		break;
	    }
	    if (!immediate_submit)
		c = form_getstr(cur, use_last_tfpos, FALSE);
	    if (form->disabled == YES &&
		(c == '\r' || c == '\n' || immediate_submit)) {
		if (peek_mouse_link() >= 0)
		    c = LAC_TO_LKC0(LYK_ACTIVATE);
d265 1
a265 1
		    c = '\t';
a267 34
	    /*
	     *  If immediate_submit is set, we didn't enter the line editor
	     *  above, and will now try to call HText_SubmitForm() directly.
	     *  If immediate_submit is not set, c is the lynxkeycode returned
	     *  from line editing.   Then if c indicates that a key was pressed
	     *  that means we should submit, but with some extra considerations
	     *  (i.e. NOCACHE, DOWNLOAD, different from simple Enter), or if
	     *  we should act on some *other* link selected with the mouse,
	     *  we'll just return c and leave it to mainloop() to do the
	     *  right thing; if everything checks out, it should call this
	     *  function again, with immediate_submit set.
	     *  If c indicates that line editing ended with Enter, we still
	     *  defer to mainloop() for further checking if the submit
	     *  action URL could require more checks than we do here.
	     *  Only in the remaining cases do we proceed to call
	     *  HText_SubmitForm() directly before returning. - kw
	     */
	    if (immediate_submit ||
		((c == '\r' || c == '\n' || c == LAC_TO_LKC0(LYK_SUBMIT)) &&
		 peek_mouse_link() == -1)) {
		LYSetHilite(cur, form->value);
#ifdef TEXT_SUBMIT_CONFIRM_WANTED
		if (!immediate_submit && (c == '\r' || c == '\n') &&
		    !HTConfirmDefault(NO_SUBMIT_BUTTON_QUERY), YES) {
		    /* User was prompted and declined; if canceled with ^G
		     * let mainloop stay on this field, otherwise move on to
		     * the next field or link. - kw
		     */
		    if (HTLastConfirmCancelled())
			c = DO_NOTHING;
		    else
			c = LAC_TO_LKC(LYK_NEXT_LINK);
		    break;
		}
d269 6
a274 32
		if (!form->submit_action || *form->submit_action == '\0') {
		    HTUserMsg(NO_FORM_ACTION);
		    c = DO_NOTHING;
		    break;
		} else if (form->submit_method == URL_MAIL_METHOD && no_mail) {
		    HTAlert(FORM_MAILTO_DISALLOWED);
		    c = DO_NOTHING;
		    break;
		} else if (!immediate_submit &&
			   ((no_file_url &&
			     isFILE_URL(form->submit_action)) ||
			    !strncasecomp(form->submit_action, "lynx", 4))) {
		    c = LAC_TO_LKC0(LYK_SUBMIT);
		    break;
		} else {
		    if (form->no_cache &&
			form->submit_method != URL_MAIL_METHOD) {
			LYforce_no_cache = TRUE;
			reloading = TRUE;
		    }
		    newdoc_changed =
			HText_SubmitForm(form, newdoc, link_name, form->value);
		}
		if (form->submit_method == URL_MAIL_METHOD) {
		    *refresh_screen = TRUE;
		} else {
		    /*
		     *  Returns new document URL.
		     */
		    newdoc->link = 0;
		    newdoc->internal_link = FALSE;
		}
d277 6
d284 7
a290 1
		LYSetHilite(cur, form->value);
d292 1
a292 14
	    break;

	case F_SUBMIT_TYPE:
	case F_IMAGE_SUBMIT_TYPE:
	    if (form->disabled == YES)
		break;
	    if (form->no_cache &&
		form->submit_method != URL_MAIL_METHOD) {
		LYforce_no_cache = TRUE;
		reloading = TRUE;
	    }
	    newdoc_changed =
		HText_SubmitForm(form, newdoc, link_name, link_value);
	    if (form->submit_method == URL_MAIL_METHOD)
d294 4
a297 2
	    else {
		/* returns new document URL */
d301 10
d312 15
d334 3
a336 3
	 *  These flags may have been set in mainloop, anticipating that
	 *  a request will be submitted.  But if we haven't filled in
	 *  newdoc, that won't actually be the case, so unset them. - kw
d342 1
a342 1
    return(c);
d345 5
a349 6
PUBLIC int change_form_link ARGS5(
	int,		cur,
	DocInfo *,	newdoc,
	BOOLEAN *,	refresh_screen,
	BOOLEAN,	use_last_tfpos,
	BOOLEAN,	immediate_submit)
d351 1
a351 1
    /*pass all our args and FALSE as last arg*/
d357 1
a357 1
			       FALSE /*redraw_only*/ );
d360 1
a360 1
PRIVATE int LastTFPos = -1;	/* remember last text field position */
d362 1
a362 2
PRIVATE void LYSetLastTFPos ARGS1(
    int,	pos)
d367 3
a369 4
PRIVATE int form_getstr ARGS3(
	int,		cur,
	BOOLEAN,	use_last_tfpos,
	BOOLEAN,	redraw_only)
d380 1
d386 1
a386 1
    BOOLEAN Edited = FALSE;		/* Value might be updated? */
d389 1
a389 1
     *  Get the initial position of the cursor.
d392 2
a393 2
    if ((startcol + form->size) > (LYcols - 1))
	far_col = (LYcols - 1);
d398 1
a398 1
     *  Make sure the form field value does not exceed our buffer. - FM
d402 3
a404 3
					    form->maxlength :
					    (sizeof(MyEdit.buffer) - 1));
    if (strlen(form->value) > (size_t)max_length) {
d406 2
a407 2
	 *  We can't fit the entire value into the editing buffer,
	 *  so enter as much of the tail as fits. - FM
d413 1
a413 1
	     *  If we can edit it, report that we are using the tail. - FM
d416 1
a416 1
	    show_formlink_statusline(form, redraw_only? FOR_PANEL : FOR_INPUT);
d422 1
a422 1
     *  Print panned line
d462 1
a462 1
	return 0;		/*return value won't be analysed*/
d465 1
a465 1
     *  And go for it!
d468 1
a468 1
again:
d475 1
a475 1
	 && (EditBinding(ch) != LYE_CHAR)
d477 1
a477 1
	 && (EditBinding(ch) != LYE_AIX)
d492 3
a494 3
	if (ch != -1 && (ch & LKC_ISLAC) && !(ch & LKC_ISLECLAC)) /* already lynxactioncode? */
	    break;	/* @@@@@@ maybe move these 2 lines outside ifdef -kw */
	if (ch == MOUSE_KEY) {		/* Need to process ourselves */
d504 1
a504 1
		    repeat = - repeat;
d509 1
a509 1
	    MEVENT	event;
d518 1
a518 1
		    repeat = - repeat;
d524 6
a529 6
		/*  Mouse event passed to us as MOUSE_KEY, and apparently
		 *  not on this field's line?  Something is not as it
		 *  should be...
		 *  A call to statusline() may have happened, possibly from
		 *  within a mouse menu.  Let's at least make sure here
		 *  that the cursor position gets restored.  - kw
d535 1
a535 1
#  endif     /* NCURSES || PDCURSES */
d562 1
a562 1
	     *  Set flag for modifier 1.
d569 1
a569 1
	     *  Set flag for modifier 2.
d575 2
a576 2
	 *  Filter out global navigation keys that should not be passed
	 *  to line editor, and LYK_REFRESH.
a596 1

d599 1
a599 1
	    unsigned char *s = get_clip_grab(), *e;
d605 1
a605 1
	    len = strlen(s);
d612 1
a612 1
		    if (*e1 < ' ') { /* Stop here? */
d616 3
a618 2
			if (*e1 == '\t') { /* Replace by space */
			    LYEditInsert(&MyEdit, " ", 1, -1, TRUE);
d630 1
a630 1
		    StrAllocCopy(buf, e1 + 1);	/* Survive _release() */
d645 1
a645 1
		    ch = '\n';		/* Sometimes moves to the next line */
d661 1
a661 1
	    ch = (int)('\t');
d665 1
a665 1
	    return(DO_NOTHING);
d678 1
a678 1
	if (action == LYE_NOP && LKC_TO_LAC(keymap,ch) == LYK_REFRESH)
d688 20
a707 20
	    default:
	    /*	[ 1999/04/14 (Wed) 15:01:33 ]
	     *  Left arrrow in column 0 deserves special treatment here,
	     *  else you can get trapped in a form without submit button!
	     */
		if (action == LYE_BACK && MyEdit.pos == 0 && repeat == -1) {
		    int c = YES;    /* Go back immediately if no changes */
		    if (textfield_prompt_at_left_edge) {
			c = HTConfirmDefault(PREV_DOC_QUERY, NO);
		    } else if (strcmp(MyEdit.buffer, value)) {
			c = HTConfirmDefault(PREV_DOC_QUERY, NO);
		    }
		    if (c == YES) {
			return(ch);
		    } else {
			if (form->disabled == YES)
			    _statusline(ARROWS_OR_TAB_TO_MOVE);
			else
			    _statusline(ENTER_TEXT_ARROWS_OR_TAB);
		    }
d709 16
a724 15
		if (form->disabled == YES) {
		    /*
		     *  Allow actions that don't modify the contents even
		     *  in disabled form fields, so the user can scroll
		     *  through the line for reading if necessary. - kw
		     */
		    switch(action) {
		    case LYE_BOL:
		    case LYE_EOL:
		    case LYE_FORW:
		    case LYE_FORW_RL:
		    case LYE_BACK:
		    case LYE_BACK_LL:
		    case LYE_FORWW:
		    case LYE_BACKW:
d726 1
a726 1
		    case LYE_SWMAP:
d729 2
a730 2
		    case LYE_SETMARK:
		    case LYE_XPMARK:
d732 36
a767 4
			break;
		    default:
			goto again;
		    }
a768 32
		/*
		 *  Make sure the statusline uses editmode help.
		 */
		if (repeat < 0)
		    repeat = 1;
		while (repeat--) {
		    int rc = LYEdit1(&MyEdit, ch, action & ~LYE_DF, TRUE);

		    if (rc < 0) {
			ch = -rc;
			/* FORW_RL and BACK_LL may require special attention.
			   BACK_LL wanted to switch to the previous link on
			   the same line.  However, if there is no such link,
			   then we would either disactivate the form
			   (with -tna), or will reenter the form, thus we jump
			   to the end of the line; both are counterintuitive.
			   Unfortunately, we do not have access to curdoc.link,
			   so we deduce it ourselves.  We don't have the info
			   to do it inside LYLineEdit().
			   This should work for prompts too.  */
			if ( (action != LYE_BACK_LL && action != LYE_FORW_RL)
			     || (cur >= 0
				&& cur < nlinks
				&& (action==LYE_FORW_RL
				    ? cur < nlinks - 1
				    : cur > 0)
				&& links[cur + ((action==LYE_FORW_RL)
						? 1
						: -1)].ly
				   == links[cur].ly))
			    goto breakfor;
		    }
d770 2
a771 2
		    if (rc == 0) {
			if (HTCJK != NOCJK && (0x80 <= ch)
d773 6
a778 7
			    refresh_mb = FALSE;
			else
			    refresh_mb = TRUE;
		    } else {
			if (!refresh_mb) {
			    LYEdit1(&MyEdit, 0, LYE_DELP, TRUE);
			}
d780 1
d782 11
a792 11
		}
		if (MyEdit.strlen >= max_length) {
		    HaveMaxlength = TRUE;
		} else if (HaveMaxlength &&
			   MyEdit.strlen < max_length) {
		    HaveMaxlength = FALSE;
		    _statusline(ENTER_TEXT_ARROWS_OR_TAB);
		}
		if (strcmp(value, MyEdit.buffer)) {
		    Edited = TRUE;
		}
d794 1
a794 1
		if (refresh_mb)
d797 1
a797 1
		LYSetLastTFPos(MyEdit.pos);
d802 1
a802 1
	char  *p;
d805 1
a805 1
	 *  Load the new value.
d809 2
a810 2
	     *  The previous value did fit in the line buffer,
	     *  so replace it with the new value. - FM
d815 1
a815 1
	     *  Combine the modified tail with the unmodified head. - FM
d824 1
a824 1
	 *  Remove trailing spaces
d826 4
a829 4
	 *  Do we really need to do that here?  Trailing spaces will only
	 *  be there if user keyed them in.  Rather rude to throw away
	 *  their hard earned spaces.  Better deal with trailing spaces
	 *  when submitting the form????
d839 6
a844 7
	 *  If the field has been changed, assume that it is now in
	 *  current display character set, even if for some reason
	 *  it wasn't!  Hopefully a user will only submit the form
	 *  if the non-ASCII characters are displayed correctly, which
	 *  means (assuming that the display character set has been set
	 *  truthfully) the user confirms by changing the field that
	 *  the character encoding is right. - kw
d846 1
a846 1
	if (form->value && *form->value)
d849 1
a849 1
    return(ch);
d853 1
a853 1
 *  Display statusline info tailored for the current form field.
d855 2
a856 3
PUBLIC void show_formlink_statusline ARGS2(
    CONST FormInfo *,	form,
    int,		for_what)
d858 1
a858 1
    switch(form->type) {
d864 3
a866 3
	    if (for_what == FOR_PANEL)
		statusline(FORM_LINK_PASSWORD_MESSAGE_INA);
	    else
d897 3
a899 3
		if (for_what == FOR_PANEL)
		    statusline(FORM_TEXT_SUBMIT_MAILTO_MSG_INA);
		else
d908 1
a908 1
	    statusline(FORM_LINK_TEXT_RESUBMIT_MESSAGE);
d912 2
a913 1
	    if (xkey_info && *xkey_info) {
d930 1
a930 1
		statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE);
d944 1
a944 1
		if(user_mode == ADVANCED_MODE) {
d956 1
a956 1
	    if(user_mode == ADVANCED_MODE) {
d967 1
a967 1
	    if(user_mode == ADVANCED_MODE) {
d996 3
a998 3
	    if (for_what == FOR_PANEL)
		statusline(FORM_LINK_TEXT_MESSAGE_INA);
	    else
d1008 1
d1016 1
a1016 1
	    if (xkey_info && *xkey_info) {
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d9 1
a10 1
#include <LYStructs.h>  /* includes HTForms.h */
a11 1
#include <LYGlobalDefs.h>
d22 5
a26 1
extern HTCJKlang HTCJK;
d29 31
a59 9
	struct link *	form_link));
PRIVATE int popup_options PARAMS((
	int		cur_selection,
	OptionType *	list,
	int		ly,
	int		lx,
	int		width,
	int		i_length,
	int		disabled));
d61 3
a63 3
PUBLIC int change_form_link ARGS5(
	struct link *,	form_link,
	document *,	newdoc,
d65 3
a67 2
	char *,		link_name,
	char *,		link_value)
d69 4
a72 1
    FormInfo *form = form_link->form;
d75 1
d77 7
a83 6
	/*
	 *  If there is no form to perform action on, don't do anything.
	 */
	if (form == NULL) {
	    return(c);
	}
d88 1
a88 1
    move(form_link->ly, form_link->lx);
d94 2
a95 7
	    if (form->num_value) {
		form_link->hightext = unchecked_box;
		form->num_value = 0;
	    } else {
		form_link->hightext = checked_box;
		form->num_value = 1;
	    }
d99 1
a99 1
	    if (!form->select_list) {
d107 10
a116 4
		dummy = popup_options(form->num_value, form->select_list,
				form_link->ly, form_link->lx, form->size,
				form->size_l, form->disabled);
#if defined(FANCY_CURSES) || defined(USE_SLANG)
d118 1
a118 5
#if defined(VMS) && !defined(USE_SLANG)
		    c = DO_NOTHING;
#else
		    c = 23;  /* CTRL-W refresh without clearok */
#endif /* VMS && !USE_SLANG */
d120 1
a120 1
#endif /* FANCY_CURSES || USE_SLANG */
d125 9
a133 4
	    form->num_value = popup_options(form->num_value, form->select_list,
				form_link->ly, form_link->lx, form->size,
				form->size_l, form->disabled);

d152 1
a152 1
#if defined(FANCY_CURSES) || defined(USE_SLANG)
d154 1
a154 6
#if defined(VMS) && !defined(USE_SLANG)
		if (form->num_value == OrigNumValue)
		    c = DO_NOTHING;
		else
#endif /* VMS && !USE_SLANG*/
		c = 23;	 /* CTRL-W refresh without clearok */
d156 3
a158 3
#endif /* FANCY_CURSES || USE_SLANG */
                c = 12;  /* CTRL-L for repaint */
            break;
d177 3
a179 3
		    if (links[i].type == WWW_FORM_LINK_TYPE &&
			links[i].form->type == F_RADIO_TYPE &&
			links[i].form->number == form->number &&
d183 5
a187 5
			!strcmp(links[i].form->name, form->name) &&
			links[i].form->num_value) {
			move(links[i].ly, links[i].lx);
			addstr(unchecked_radio);
			links[i].hightext = unchecked_radio;
d198 1
a198 1
		form_link->hightext = checked_radio;
d202 1
d206 4
a209 5
	    c = form_getstr(form_link);
	    if (form->type == F_PASSWORD_TYPE)
		form_link->hightext = STARS(strlen(form->value));
	    else
		form_link->hightext = form->value;
d220 6
a225 1
	    c = form_getstr(form_link);
d227 5
a231 2
		(c == '\r' || c == '\n')) {
		c = '\t';
d234 35
a268 2
	    if (c == '\r' || c == '\n') {
		form_link->hightext = form->value;
d277 6
d289 2
a290 1
		    HText_SubmitForm(form, newdoc, link_name, form->value);
d304 1
a304 1
		form_link->hightext = form->value;
d317 2
a318 1
	    HText_SubmitForm(form, newdoc, link_name, link_value);
d330 12
d345 28
a372 2
PRIVATE int form_getstr ARGS1(
	struct link *,	form_link)
d374 1
a374 1
    FormInfo *form = form_link->form;
d381 5
a385 1
    int action, repeat, non_first = 0;
d418 2
a419 23
	    switch(form->type) {
		case F_PASSWORD_TYPE:
		    statusline(FORM_LINK_PASSWORD_MESSAGE);
		    break;
		case F_TEXT_SUBMIT_TYPE:
		    if (form->submit_method == URL_MAIL_METHOD) {
			statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_MSG);
		    } else if (form->no_cache) {
			statusline(FORM_LINK_TEXT_RESUBMIT_MESSAGE);
		    } else {
			statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE);
		    }
		    break;
		case F_TEXT_TYPE:
		    statusline(FORM_LINK_TEXT_MESSAGE);
		    break;
		case F_TEXTAREA_TYPE:
		    statusline(FORM_LINK_TEXTAREA_MESSAGE);
		    break;
		default:
		    break;
	    }
	    move(startline, startcol);
d428 34
a461 1
    MyEdit.hidden = (form->type == F_PASSWORD_TYPE);
d463 2
d472 1
a472 4
	get_mouse_link();		/* Reset mouse_link. */
	/* Try to set position basing on the last mouse event */
	if (!non_first++)
	    peek_mouse_levent();
d474 10
a483 1
	ch = LYgetch_for(FOR_INPUT);
d487 1
a487 1
	    ch = 7;
d490 6
a495 1
#  ifdef NCURSES_MOUSE_VERSION
d497 14
d519 1
a519 1
		    ch = LTARROW;
d522 26
a547 1
		    ch = RTARROW;
a549 1
#  endif	/* defined NCURSES_MOUSE_VERSION */
d552 24
a579 1
	action = EditBinding(ch);
d584 4
d594 1
a594 1
		ch = 7;
d599 59
d661 1
d669 12
a680 1
	if (keymap[ch + 1] == LYK_REFRESH)
d682 7
d690 2
a691 13
#ifdef NOTDEFINED	/* The first four are mapped to LYE_FORM_PASS now */
	    case DNARROW:
	    case UPARROW:
	    case PGUP:
	    case PGDOWN:
	    case HOME:
	    case END_KEY:
	    case FIND_KEY:
	    case SELECT_KEY:
		goto breakfor;
#endif /* NOTDEFINED */

	    /*
d695 1
a695 2
	    case LTARROW:
		if (MyEdit.pos == 0 && repeat == -1) {
d697 3
a699 1
		    if (strcmp(MyEdit.buffer, value)) {
d711 27
a737 5
		/* fall through */

	    default:
		if (form->disabled == YES)
		    goto again;
d743 41
a783 2
		while (repeat--)
		    LYLineEdit(&MyEdit, ch, TRUE);
d794 3
d798 1
d801 1
a801 3
#ifdef NOTDEFINED
breakfor:
#endif /* NOTDEFINED */
d823 1
d832 6
a837 4
	p = &(form->value[strlen(form->value)]);
	while ((p != form->value) && (p[-1] == ' '))
	    p--;
	*p = '\0';
d855 5
a859 7
**  This function prompts for an option or page number.
**  If a 'g' or 'p' suffix is included, that will be
**  loaded into c.  Otherwise, c is zeroed. - FM & LE
*/
PRIVATE int get_popup_option_number ARGS2(
	int *,		c,
	int *,		rel)
d861 87
a947 3
    char temp[120];
    char *p = temp;
    int num;
d949 22
a970 6
    /*
     *  Load the c argument into the prompt buffer.
     */
    temp[0] = *c;
    temp[1] = '\0';
    _statusline(SELECT_OPTION_NUMBER);
d972 14
a985 18
    /*
     *  Get the number, possibly with a suffix, from the user.
     */
    if (LYgetstr(temp, VISIBLE, sizeof(temp), NORECALL) < 0 || *temp == 0) {
	HTInfoMsg(CANCELLED);
	*c = '\0';
	*rel = '\0';
	return(0);
    }

    *rel = '\0';
    num = atoi(p);
    while ( isdigit(*p) )
	++p;
    switch ( *p ) {
    case '+': case '-':
	/* 123+ or 123- */
	*rel = *p++; *c = *p;
d987 5
a991 4
    default:
	*c = *p++;
	*rel = *p;
    case 0:
d993 8
a1000 36
    }

    /*
     *  If we had a 'g' or 'p' suffix, load it into c.
     *  Otherwise, zero c.  Then return the number.
     */
    if ( *p == 'g' || *p == 'G' ) {
	*c = 'g';
    } else if (*p == 'p' || *p == 'P' ) {
	*c = 'p';
    } else {
	*c = '\0';
    }
    if ( *rel != '+' && *rel != '-' )
	*rel = 0;
    return num;
}

/* Use this rather than the 'wprintw()' function to write a blank-padded
 * string to the given window, since someone's asserted that printw doesn't
 * handle 8-bit characters unlike addstr (though more info would be useful).
 *
 * We're blank-filling so that with SVr4 curses, it'll show the background
 * color to a uniform width in the popup-menu.
 */
#ifndef USE_SLANG
PRIVATE void paddstr ARGS3(
	WINDOW *,	the_window,
	int,		width,
	char *, 	the_string)
{
    width -= strlen(the_string);
    waddstr(the_window, the_string);
    while (width-- > 0)
	waddstr(the_window, " ");
}
d1002 5
a1006 113


PRIVATE int popup_options ARGS7(
	int,		cur_selection,
	OptionType *,	list,
	int,		ly,
	int,		lx,
	int,		width,
	int,		i_length,
	int,		disabled)
{
    /*
     *  Revamped to handle within-tag VALUE's, if present,
     *  and to position the popup window appropriately,
     *  taking the user_mode setting into account. -- FM
     */
    int c = 0, cmd = 0, i = 0, j = 0, rel = 0;
    int orig_selection = cur_selection;
#ifndef USE_SLANG
    WINDOW * form_window;
#endif /* !USE_SLANG */
    int num_options = 0, top, bottom, length = -1;
    OptionType * opt_ptr = list;
    int window_offset = 0;
    int lines_to_show;
    int npages;
    static char prev_target[512];		/* Search string buffer */
    static char prev_target_buffer[512];	/* Next search buffer */
    static BOOL first = TRUE;
    char *cp;
    int ch = 0, recall;
    int QueryTotal;
    int QueryNum;
    BOOLEAN FirstRecall = TRUE;
    OptionType * tmp_ptr;
    BOOLEAN ReDraw = FALSE;
    int number;

    /*
     * Initialize the search string buffer. - FM
     */
    if (first) {
	*prev_target_buffer = '\0';
	first = FALSE;
    }
    *prev_target = '\0';
    QueryTotal = (search_queries ? HTList_count(search_queries) : 0);
    recall = ((QueryTotal >= 1) ? RECALL : NORECALL);
    QueryNum = QueryTotal;

    /*
     *  Set lines_to_show based on the user_mode global.
     */
    if (user_mode == NOVICE_MODE)
	lines_to_show = LYlines-4;
    else
	lines_to_show = LYlines-2;

    /*
     *  Counting the number of options to be displayed.
     *   num_options ranges 0...n
     */
    for (; opt_ptr->next; num_options++, opt_ptr = opt_ptr->next)
	 ; /* null body */

    /*
     *  Let's assume for the sake of sanity that ly is the number
     *   corresponding to the line the selection box is on.
     *  Let's also assume that cur_selection is the number of the
     *   item that should be initially selected, as 0 beign the
     *   first item.
     *  So what we have, is the top equal to the current screen line
     *   subtracting the cur_selection + 1 (the one must be for the
     *   top line we will draw in a box).  If the top goes under 0,
     *   consider it 0.
     */
    top = ly - (cur_selection + 1);
    if (top < 0)
	top = 0;

    /*
     *  Check and see if we need to put the i_length parameter up to
     *  the number of real options.
     */
    if (!i_length) {
	i_length = num_options;
    } else {
	/*
	 *  Otherwise, it is really one number too high.
	 */
	i_length--;
    }

    /*
     *  The bottom is the value of the top plus the number of options
     *  to view plus 3 (one for the top line, one for the bottom line,
     *  and one to offset the 0 counted in the num_options).
     */
    bottom = top + i_length + 3;

    /*
     *  Hmm...  If the bottom goes beyond the number of lines available,
     */
    if (bottom > lines_to_show) {
	/*
	 *  Position the window at the top if we have more
	 *  options than will fit in the window.
	 */
	if (i_length+3 > lines_to_show) {
	    top = 0;
	    bottom = top + i_length+3;
	    if (bottom > lines_to_show)
		bottom = lines_to_show + 1;
d1008 29
a1036 8
	    /*
	     *  Try to position the window so that the selected option will
	     *    appear where the selection box currently is positioned.
	     *  It could end up too high, at this point, but we'll move it
	     *    down latter, if that has happened.
	     */
	    top = (lines_to_show + 1) - (i_length + 3);
	    bottom = (lines_to_show + 1);
d1038 1
a1039 846

    /*
     *  This is really fun, when the length is 4, it means 0-4, or 5.
     */
    length = (bottom - top) - 2;

    /*
     *  Move the window down if it's too high.
     */
    if (bottom < ly + 2) {
	bottom = ly + 2;
	if (bottom > lines_to_show + 1)
	    bottom = lines_to_show + 1;
	top = bottom - length - 2;
    }

    /*
     *  Set up the overall window, including the boxing characters ('*'),
     *  if it all fits.  Otherwise, set up the widest window possible. - FM
     */
#ifdef USE_SLANG
    SLsmg_fill_region(top, lx - 1, bottom - top, width + 4, ' ');
#else
    if (!(form_window = newwin(bottom - top, width + 4, top, lx - 1)) &&
	!(form_window = newwin(bottom - top, 0, top, 0))) {
	HTAlert(POPUP_FAILED);
	return(orig_selection);
    }
    scrollok(form_window, TRUE);
#ifdef PDCURSES
    keypad(form_window, TRUE);
#endif /* PDCURSES */
#ifdef NCURSES
    LYsubwindow(form_window);
#endif
#if defined(HAVE_GETBKGD) /* not defined in ncurses 1.8.7 */
    wbkgd(form_window, getbkgd(stdscr));
    wbkgdset(form_window, getbkgd(stdscr));
#endif
#endif /* USE_SLANG */

    /*
     *  Set up the window_offset for options.
     *   cur_selection ranges from 0...n
     *   length ranges from 0...m
     */
    if (cur_selection >= length) {
	window_offset = cur_selection - length + 1;
    }

    /*
     *  Compute the number of popup window pages. - FM
     */
    npages = ((num_options + 1) > length) ?
		(((num_options + 1) + (length - 1))/(length))
					  : 1;
/*
 * OH!  I LOVE GOTOs! hack hack hack
 *        07-11-94 GAB
 *      MORE hack hack hack
 *        09-05-94 FM
 */
redraw:
    opt_ptr = list;

    /*
     *  Display the boxed options.
     */
    for (i = 0; i <= num_options; i++, opt_ptr = opt_ptr->next) {
	if (i >= window_offset && i - window_offset < length) {
#ifdef USE_SLANG
	    SLsmg_gotorc(top + ((i + 1) - window_offset), (lx - 1 + 2));
	    SLsmg_write_nstring(opt_ptr->name, width);
#else
	    wmove(form_window, ((i + 1) - window_offset), 2);
	    paddstr(form_window, width, opt_ptr->name);
#endif /* USE_SLANG */
	}
    }
#ifdef USE_SLANG
    SLsmg_draw_box(top, (lx - 1), (bottom - top), (width + 4));
#else
#ifdef VMS
    VMSbox(form_window, (bottom - top), (width + 4));
#else
    LYbox(form_window, TRUE);
#endif /* VMS */
    wrefresh(form_window);
#endif /* USE_SLANG */
    opt_ptr = NULL;

    /*
     *  Loop on user input.
     */
    while (cmd != LYK_ACTIVATE) {

	/*
	 *  Unreverse cur selection.
	 */
	if (opt_ptr != NULL) {
#ifdef USE_SLANG
	    SLsmg_gotorc((top + ((i + 1) - window_offset)), (lx - 1 + 2));
	    SLsmg_write_nstring(opt_ptr->name, width);
#else
	    wmove(form_window, ((i + 1) - window_offset), 2);
	    paddstr(form_window, width, opt_ptr->name);
#endif /* USE_SLANG */
	}

	opt_ptr = list;

	for (i = 0; i < cur_selection; i++, opt_ptr = opt_ptr->next)
	    ; /* null body */

#ifdef USE_SLANG
	SLsmg_set_color(2);
	SLsmg_gotorc((top + ((i + 1) - window_offset)), (lx - 1 + 2));
	SLsmg_write_nstring(opt_ptr->name, width);
	SLsmg_set_color(0);
	/*
	 *  If LYShowCursor is ON, move the cursor to the left
	 *  of the current option, so that blind users, who are
	 *  most likely to have LYShowCursor ON, will have it's
	 *  string spoken or passed to the braille interface as
	 *  each option is made current.  Otherwise, move it to
	 *  the bottom, right column of the screen, to "hide"
	 *  the cursor as for the main document, and let sighted
	 *  users rely on the current option's highlighting or
	 *  color without the distraction of a blinking cursor
	 *  in the window. - FM
	 */
	if (LYShowCursor)
	    SLsmg_gotorc((top + ((i + 1) - window_offset)), (lx - 1 + 1));
	else
	    SLsmg_gotorc((LYlines - 1), (LYcols - 1));
	SLsmg_refresh();
#else
	wmove(form_window, ((i + 1) - window_offset), 2);
	wstart_reverse(form_window);
	paddstr(form_window, width, opt_ptr->name);
	wstop_reverse(form_window);
	/*
	 *  If LYShowCursor is ON, move the cursor to the left
	 *  of the current option, so that blind users, who are
	 *  most likely to have LYShowCursor ON, will have it's
	 *  string spoken or passed to the braille interface as
	 *  each option is made current.  Otherwise, leave it to
	 *  the right of the current option, since we can't move
	 *  it out of the window, and let sighted users rely on
	 *  the highlighting of the current option without the
	 *  distraction of a blinking cursor preceding it. - FM
	 */
	if (LYShowCursor)
	    wmove(form_window, ((i + 1) - window_offset), 1);
	wrefresh(form_window);
#endif /* USE_SLANG  */

	c = LYgetch_for(FOR_CHOICE);
	if (c == 3 || c == 7) {	/* Control-C or Control-G */
	    cmd = LYK_QUIT;
#ifndef USE_SLANG
	} else if (c == MOUSE_KEY) {
	    if ((cmd = fancy_mouse(form_window, i + 1 + window_offset, &cur_selection)) < 0)
		goto redraw;
	    if  (cmd == LYK_ACTIVATE)
		break;
#endif
	} else {
	    cmd = keymap[c+1];
	}
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    cmd = LYK_QUIT;
	}
#endif /* VMS */

	switch(cmd) {
	    case LYK_F_LINK_NUM:
		c = '\0';
	    case LYK_1:
	    case LYK_2:
	    case LYK_3:
	    case LYK_4:
	    case LYK_5:
	    case LYK_6:
	    case LYK_7:
	    case LYK_8:
	    case LYK_9:
		/*
		 *  Get a number from the user, possibly with
		 *  a 'g' or 'p' suffix (which will be loaded
		 *  into c). - FM & LE
		 */
		number = get_popup_option_number((int *)&c,(int *)&rel);

		/* handle + or - suffix */
		CTRACE(tfp,"got popup option number %d, ",number);
		CTRACE(tfp,"rel='%c', c='%c', cur_selection=%d\n",
				rel,c,cur_selection);
		if ( c == 'p' ) {
		    int curpage = ((cur_selection + 1) > length) ?
			(((cur_selection + 1) + (length - 1))/(length))
					  : 1;
		    CTRACE(tfp,"  curpage=%d\n",curpage);
		    if ( rel == '+' )
			number = curpage + number;
		    else if ( rel == '-' )
			number = curpage - number;
		} else if ( rel == '+' ) {
		    number = cur_selection + number + 1;
		} else if ( rel == '-' ) {
		    number = cur_selection - number + 1;
		}
		if ( rel ) CTRACE(tfp,"new number=%d\n",number);
		/*
		 *  Check for a 'p' suffix. - FM
		 */
		if (c == 'p') {
		    /*
		     *  Treat 1 or less as the first page. - FM
		     */
		    if (number <= 1) {
			if (window_offset == 0) {
			    HTUserMsg(ALREADY_AT_OPTION_BEGIN);
			    if (disabled) {
				_statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			    } else {
				_statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			    }
			    break;
			}
			window_offset = 0;
			cur_selection = 0;
			if (disabled) {
			    _statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			} else {
			    _statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			}
			goto redraw;
		    }

		    /*
		     *  Treat a number equal to or greater than the
		     *  number of pages as the last page. - FM
		     */
		    if (number >= npages) {
			if (window_offset >= ((num_options - length) + 1)) {
			    HTUserMsg(ALREADY_AT_OPTION_END);
			    if (disabled) {
				_statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			    } else {
				_statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			    }
			    break;
			}
			window_offset = ((npages - 1) * length);
			if (window_offset > (num_options - length)) {
			    window_offset = (num_options - length + 1);
			}
			if (cur_selection < window_offset)
			    cur_selection = window_offset;
			if (disabled) {
			    _statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			} else {
			    _statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			}
			goto redraw;
		    }

		    /*
		     *  We want an intermediate page. - FM
		     */
		    if (((number - 1) * length) == window_offset) {
			char *msg = 0;
			HTSprintf0(&msg, ALREADY_AT_OPTION_PAGE, number);
			HTUserMsg(msg);
			FREE(msg);
			if (disabled) {
			    _statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			} else {
			    _statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			}
			break;
		    }
		    cur_selection = window_offset = ((number - 1) * length);
		    if (disabled) {
			_statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
		    } else {
			_statusline(FORM_LINK_OPTION_LIST_MESSAGE);
		    }
		    goto redraw;

		}

		/*
		 *  Check for a positive number, which signifies
		 *  that an option should be sought. - FM
		 */
		if (number > 0) {
		    /*
		     *  Decrement the number so as to correspond
		     *  with our cur_selection values. - FM
		     */
		    number--;

		    /*
		     *  If the number is in range and had no legal
		     *  suffix, select the indicated option. - FM
		     */
		    if (number <= num_options && c == '\0') {
			cur_selection = number;
			cmd = LYK_ACTIVATE;
			break;
		    }

		    /*
		     *  Verify that we had a 'g' suffix,
		     *  and act on the number. - FM
		     */
		    if (c == 'g') {
			if (cur_selection == number) {
			    /*
			     *  The option already is current. - FM
			     */
			    char *msg = 0;
			    HTSprintf0(&msg, OPTION_ALREADY_CURRENT, (number + 1));
			    HTUserMsg(msg);
			    FREE(msg);
			    if (disabled) {
				_statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			    } else {
				_statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			    }
			    break;
			}

			if (number <= num_options) {
			    /*
			     *  The number is in range and had a 'g'
			     *  suffix, so make it the current option,
			     *  scrolling if needed. - FM
			     */
			    j = (number - cur_selection);
			    cur_selection = number;
			    if ((j > 0) &&
				(cur_selection - window_offset) >= length) {
				window_offset += j;
				if (window_offset > (num_options - length + 1))
				    window_offset = (num_options - length + 1);
			    } else if ((cur_selection - window_offset) < 0) {
				window_offset -= abs(j);
				if (window_offset < 0)
				    window_offset = 0;
			    }
			    if (disabled) {
				_statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			    } else {
				_statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			    }
			    goto redraw;
			}

			/*
			 *  Not in range. - FM
			 */
			HTUserMsg(BAD_OPTION_NUM_ENTERED);
		    }
		}

		/*
		 *  Restore the popup statusline. - FM
		 */
		if (disabled) {
		    _statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
		} else {
		    _statusline(FORM_LINK_OPTION_LIST_MESSAGE);
		}
		break;

	    case LYK_PREV_LINK:
	    case LYK_FASTBACKW_LINK:
	    case LYK_UP_LINK:

		if (cur_selection > 0)
		    cur_selection--;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_selection - window_offset) < 0) {
		    window_offset--;
		    goto redraw;
		}
		break;

	    case LYK_NEXT_LINK:
	    case LYK_FASTFORW_LINK:
	    case LYK_DOWN_LINK:
		if (cur_selection < num_options)
		    cur_selection++;

		/*
		 *  Scroll the window down if necessary
		 */
		if ((cur_selection - window_offset) >= length) {
		    window_offset++;
		    goto redraw;
		}
		break;

	    case LYK_NEXT_PAGE:
		/*
		 *  Okay, are we on the last page of the list?
		 *  If not then,
		 */
		if (window_offset != (num_options - length + 1)) {
		    /*
		     *  Modify the current selection to not be a
		     *  coordinate in the list, but a coordinate
		     *  on the item selected in the window.
		     */
		    cur_selection -= window_offset;

		    /*
		     *  Page down the proper length for the list.
		     *  If simply to far, back up.
		     */
		    window_offset += length;
		    if (window_offset > (num_options - length)) {
			window_offset = (num_options - length + 1);
		    }

		    /*
		     *  Readjust the current selection to be a
		     *  list coordinate rather than window.
		     *  Redraw this thing.
		     */
		    cur_selection += window_offset;
		    goto redraw;
		}
		else if (cur_selection < num_options) {
		    /*
		     *  Already on last page of the list so just
		     *  redraw it with the last item selected.
		     */
		    cur_selection = num_options;
		}
		break;

	    case LYK_PREV_PAGE:
		/*
		 *  Are we on the first page of the list?
		 *  If not then,
		 */
		if (window_offset != 0) {
		    /*
		     *  Modify the current selection to not be a
		     *  list coordinate, but a window coordinate.
		     */
		    cur_selection -= window_offset;

		    /*
		     *  Page up the proper length.
		     *  If too far, back up.
		     */
		    window_offset -= length;
		    if (window_offset < 0) {
			window_offset = 0;
		    }

		    /*
		     *  Readjust the current selection.
		     */
		    cur_selection += window_offset;
		    goto redraw;
		} else if (cur_selection > 0) {
		    /*
		     *  Already on the first page so just
		     *  back up to the first item.
		     */
		    cur_selection = 0;
		}
		break;

	    case LYK_HOME:
		cur_selection = 0;
		if (window_offset > 0) {
		    window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_END:
		cur_selection = num_options;
		if (window_offset != (num_options - length + 1)) {
		    window_offset = (num_options - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_DOWN_TWO:
		cur_selection += 2;
		if (cur_selection > num_options)
		    cur_selection = num_options;

		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_selection - window_offset) >= length) {
		    window_offset += 2;
		    if (window_offset > (num_options - length + 1))
			window_offset = (num_options - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_UP_TWO:
		cur_selection -= 2;
		if (cur_selection < 0)
		    cur_selection = 0;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_selection - window_offset) < 0) {
		    window_offset -= 2;
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_DOWN_HALF:
		cur_selection += (length/2);
		if (cur_selection > num_options)
		    cur_selection = num_options;

		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_selection - window_offset) >= length) {
		    window_offset += (length/2);
		    if (window_offset > (num_options - length + 1))
			window_offset = (num_options - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_UP_HALF:
		cur_selection -= (length/2);
		if (cur_selection < 0)
		    cur_selection = 0;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_selection - window_offset) < 0) {
		    window_offset -= (length/2);
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_REFRESH:
		lynx_force_repaint();
		refresh();
		break;

	    case LYK_NEXT:
		if (recall && *prev_target_buffer == '\0') {
		    /*
		     *  We got a 'n'ext command with no prior query
		     *  specified within the popup window.  See if
		     *  one was entered when the popup was retracted,
		     *  and if so, assume that's what's wanted.  Note
		     *  that it will become the default within popups,
		     *  unless another is entered within a popup.  If
		     *  the within popup default is to be changed at
		     *  that point, use WHEREIS ('/') and enter it,
		     *  or the up- or down-arrow keys to seek any of
		     *  the previously entered queries, regardless of
		     *  whether they were entered within or outside
		     *  of a popup window. - FM
		     */
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      0)) != NULL) {
			strcpy(prev_target_buffer, cp);
			QueryNum = 0;
			FirstRecall = FALSE;
		    }
		}
		strcpy(prev_target, prev_target_buffer);
	    case LYK_WHEREIS:
		if (*prev_target == '\0' ) {
		    _statusline(ENTER_WHEREIS_QUERY);
		    if ((ch = LYgetstr(prev_target, VISIBLE,
				       sizeof(prev_target_buffer),
				       recall)) < 0) {
			/*
			 *  User cancelled the search via ^G. - FM
			 */
			HTInfoMsg(CANCELLED);
			goto restore_popup_statusline;
		    }
		}

check_recall:
		if (*prev_target == '\0' &&
		    !(recall && (ch == UPARROW || ch == DNARROW))) {
		    /*
		     *  No entry.  Simply break.   - FM
		     */
		    HTInfoMsg(CANCELLED);
		    goto restore_popup_statusline;
		}

		if (recall && ch == UPARROW) {
		    if (FirstRecall) {
			/*
			 *  Use the current string or
			 *  last query in the list. - FM
			 */
			FirstRecall = FALSE;
			if (*prev_target_buffer) {
			    for (QueryNum = (QueryTotal - 1);
				 QueryNum > 0; QueryNum--) {
				if ((cp = (char *)HTList_objectAt(
							search_queries,
							QueryNum)) != NULL &&
				    !strcmp(prev_target_buffer, cp)) {
				    break;
				}
			    }
			} else {
			    QueryNum = 0;
			}
		    } else {
			/*
			 *  Go back to the previous query in the list. - FM
			 */
			QueryNum++;
		    }
		    if (QueryNum >= QueryTotal)
			/*
			 *  Roll around to the last query in the list. - FM
			 */
			QueryNum = 0;
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			strcpy(prev_target, cp);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer && QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				      QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
				sizeof(prev_target_buffer), recall)) < 0) {
			    /*
			     *  User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
		    }
		} else if (recall && ch == DNARROW) {
		    if (FirstRecall) {
		    /*
		     *  Use the current string or
		     *  first query in the list. - FM
		     */
		    FirstRecall = FALSE;
		    if (*prev_target_buffer) {
			for (QueryNum = 0;
			     QueryNum < (QueryTotal - 1); QueryNum++) {
			    if ((cp = (char *)HTList_objectAt(
							search_queries,
							QueryNum)) != NULL &&
				!strcmp(prev_target_buffer, cp)) {
				    break;
			    }
			}
		    } else {
			QueryNum = (QueryTotal - 1);
		    }
		} else {
		    /*
		     *  Advance to the next query in the list. - FM
		     */
		    QueryNum--;
		}
		if (QueryNum < 0)
		    /*
		     *  Roll around to the first query in the list. - FM
		     */
		    QueryNum = (QueryTotal - 1);
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			strcpy(prev_target, cp);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer &&
				    QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				    QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
					   sizeof(prev_target_buffer),
					   recall)) < 0) {
			    /*
			     * User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
		    }
		}
		/*
		 *  Replace the search string buffer with the new target. - FM
		 */
		strcpy(prev_target_buffer, prev_target);
		HTAddSearchQuery(prev_target_buffer);

		/*
		 *  Start search at the next option. - FM
		 */
		for (j = 1, tmp_ptr = opt_ptr->next;
		     tmp_ptr != NULL; tmp_ptr = tmp_ptr->next, j++) {
		    if (case_sensitive) {
			if (strstr(tmp_ptr->name, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(tmp_ptr->name, prev_target_buffer) != NULL)
			    break;
		    }
		}
		if (tmp_ptr != NULL) {
		    /*
		     *  We have a hit, so make that option the current. - FM
		     */
		    cur_selection += j;
		    /*
		     *  Scroll the window down if necessary.
		     */
		    if ((cur_selection - window_offset) >= length) {
			window_offset += j;
			if (window_offset > (num_options - length + 1))
			    window_offset = (num_options - length + 1);
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
		}

		/*
		 *  If we started at the beginning, it can't be present. - FM
		 */
		if (cur_selection == 0) {
		    HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
		    goto restore_popup_statusline;
		}

		/*
		 *  Search from the beginning to the current option. - FM
		 */
		for (j = 0, tmp_ptr = list;
		     j < cur_selection; tmp_ptr = tmp_ptr->next, j++) {
		    if (case_sensitive) {
			if (strstr(tmp_ptr->name, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(tmp_ptr->name, prev_target_buffer) != NULL)
			    break;
		    }
		}
		if (j < cur_selection) {
		    /*
		     *  We have a hit, so make that option the current. - FM
		     */
		    j = (cur_selection - j);
		    cur_selection -= j;
		    /*
		     *  Scroll the window up if necessary.
		     */
		    if ((cur_selection - window_offset) < 0) {
			window_offset -= j;
			if (window_offset < 0)
			    window_offset = 0;
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
		}

		/*
		 *  Didn't find it in the preceding options either. - FM
		 */
		HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);

restore_popup_statusline:
		/*
		 *  Restore the popup statusline and
		 *  reset the search variables. - FM
		 */
		if (disabled)
		    _statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
		else
		    _statusline(FORM_LINK_OPTION_LIST_MESSAGE);
		*prev_target = '\0';
		QueryTotal = (search_queries ? HTList_count(search_queries)
					     : 0);
		recall = ((QueryTotal >= 1) ? RECALL : NORECALL);
		QueryNum = QueryTotal;
		if (ReDraw == TRUE) {
		    ReDraw = FALSE;
		    goto redraw;
		}
		break;

	    case LYK_QUIT:
	    case LYK_ABORT:
	    case LYK_PREV_DOC:
		cur_selection = orig_selection;
		cmd = LYK_ACTIVATE; /* to exit */
		break;
	}

    }
#ifndef USE_SLANG
    delwin(form_window);
#ifdef NCURSES
    LYsubwindow(0);
#endif
#endif /* !USE_SLANG */

    return(disabled ? orig_selection : cur_selection);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a8 1
#include <LYGlobalDefs.h>
d10 1
d12 1
d23 1
a23 36
#if defined(VMS) && !defined(USE_SLANG)
#define CTRL_W_HACK DO_NOTHING
#else
#define CTRL_W_HACK 23		/* CTRL-W refresh without clearok */
#endif /* VMS && !USE_SLANG */

static int form_getstr(int cur,
		       BOOLEAN use_last_tfpos,
		       BOOLEAN redraw_only);

/*
 * Returns an array of pointers to the given list
 */
static char **options_list(OptionType * opt_ptr)
{
    char **result = 0;
    size_t len;
    int pass;
    OptionType *tmp_ptr;

    for (pass = 0; pass < 2; pass++) {
	for (tmp_ptr = opt_ptr, len = 0; tmp_ptr != 0; tmp_ptr = tmp_ptr->next) {
	    if (pass != 0)
		result[len] = tmp_ptr->name;
	    len++;
	}
	if (pass == 0) {
	    len++;
	    result = typecallocn(char *, len);
	} else {
	    result[len] = 0;
	}
    }

    return result;
}
d25 17
a41 6
int change_form_link_ex(int cur,
			DocInfo *newdoc,
			BOOLEAN *refresh_screen,
			BOOLEAN use_last_tfpos,
			BOOLEAN immediate_submit,
			BOOLEAN redraw_only)
d43 1
a43 4
    FormInfo *form = links[cur].l_form;
    char *link_name = form->name;
    char *link_value = form->value;
    int newdoc_changed = 0;
a45 1
    char **my_data = 0;
d47 6
a52 7
    /*
     * If there is no form to perform action on, don't do anything.
     */
    if (form == NULL) {
	return (c);
    }
    my_data = options_list(form->select_list);
d55 1
a55 1
     * Move to the link position.
d57 1
a57 1
    LYmove(links[cur].ly, links[cur].lx);
d59 11
a69 3
    switch (form->type) {
    case F_CHECKBOX_TYPE:
	if (form->disabled == YES)
a70 3
	LYSetHilite(cur, form->num_value ? unchecked_box : checked_box);
	form->num_value = !form->num_value;
	break;
d72 6
a77 6
    case F_OPTION_LIST_TYPE:
	if (form->select_list == 0) {
	    HTAlert(BAD_HTML_NO_POPUP);
	    c = DO_NOTHING;
	    break;
	}
d79 41
a119 13
	if (form->disabled == YES) {
	    int dummy;

	    dummy = LYhandlePopupList(form->num_value,
				      links[cur].ly,
				      links[cur].lx,
				      (const char **) my_data,
				      form->size,
				      form->size_l,
				      form->disabled,
				      FALSE,
				      FALSE);
#if CTRL_W_HACK != DO_NOTHING
d121 6
a126 1
		c = CTRL_W_HACK;	/* CTRL-W refresh without clearok */
d128 3
a130 17
#endif
		c = 12;		/* CTRL-L for repaint */
	    break;
	}
	OrigNumValue = form->num_value;
	form->num_value = LYhandlePopupList(form->num_value,
					    links[cur].ly,
					    links[cur].lx,
					    (const char **) my_data,
					    form->size,
					    form->size_l,
					    form->disabled,
					    FALSE,
					    FALSE);
	{
	    OptionType *opt_ptr = form->select_list;
	    int i;
d132 8
a139 30
	    for (i = 0; i < form->num_value; i++, opt_ptr = opt_ptr->next) ;	/* null body */
	    /*
	     * Set the name.
	     */
	    form->value = opt_ptr->name;
	    /*
	     * Set the value.
	     */
	    form->cp_submit_value = opt_ptr->cp_submit_value;
	    /*
	     * Set charset in which we have the submit value.  - kw
	     */
	    form->value_cs = opt_ptr->value_cs;
	}
#if CTRL_W_HACK != DO_NOTHING
	if (!enable_scrollback)
	    c = CTRL_W_HACK;	/* CTRL-W refresh without clearok */
	else
#endif
	    c = 12;		/* CTRL-L for repaint */
	break;

    case F_RADIO_TYPE:
	if (form->disabled == YES)
	    break;
	/*
	 * Radio buttons must have one and only one down at a time!
	 */
	if (form->num_value) {
	    if (user_mode == NOVICE_MODE) {
d141 20
a160 21
	    }
	} else {
	    int i;

	    /*
	     * Run though list of the links on the screen and unselect any that
	     * are selected.  :)
	     */
	    lynx_start_radio_color();
	    for (i = 0; i < nlinks; i++) {
		if (links[i].type == WWW_FORM_LINK_TYPE
		    && links[i].l_form->type == F_RADIO_TYPE
		    && links[i].l_form->number == form->number
		/*
		 * If it has the same name and its on...
		 */
		    && !strcmp(links[i].l_form->name, form->name)
		    && links[i].l_form->num_value) {
		    LYmove(links[i].ly, links[i].lx);
		    LYaddstr(unchecked_radio);
		    LYSetHilite(i, unchecked_radio);
d162 9
d172 1
a172 11
	    lynx_stop_radio_color();
	    /*
	     * Will unselect other button and select this one.
	     */
	    HText_activateRadioButton(form);
	    /*
	     * Now highlight this one.
	     */
	    LYSetHilite(cur, checked_radio);
	}
	break;
d174 9
a182 9
    case F_FILE_TYPE:
    case F_TEXT_TYPE:
    case F_TEXTAREA_TYPE:
    case F_PASSWORD_TYPE:
	c = form_getstr(cur, use_last_tfpos, redraw_only);
	LYSetHilite(cur, (form->type == F_PASSWORD_TYPE)
		    ? STARS(strlen(form->value))
		    : form->value);
	break;
d184 5
a188 2
    case F_RESET_TYPE:
	if (form->disabled == YES)
a189 3
	HText_ResetForm(form);
	*refresh_screen = TRUE;
	break;
d191 4
a194 12
    case F_TEXT_SUBMIT_TYPE:
	if (redraw_only) {
	    c = form_getstr(cur, use_last_tfpos, TRUE);
	    break;
	}
	if (!immediate_submit)
	    c = form_getstr(cur, use_last_tfpos, FALSE);
	if (form->disabled == YES &&
	    (c == '\r' || c == '\n' || immediate_submit)) {
	    if (peek_mouse_link() >= 0)
		c = LAC_TO_LKC0(LYK_ACTIVATE);
	    else
a195 34
	    break;
	}
	/*
	 * If immediate_submit is set, we didn't enter the line editor above,
	 * and will now try to call HText_SubmitForm() directly.  If
	 * immediate_submit is not set, c is the lynxkeycode returned from line
	 * editing.  Then if c indicates that a key was pressed that means we
	 * should submit, but with some extra considerations (i.e.  NOCACHE,
	 * DOWNLOAD, different from simple Enter), or if we should act on some
	 * *other* link selected with the mouse, we'll just return c and leave
	 * it to mainloop() to do the right thing; if everything checks out, it
	 * should call this function again, with immediate_submit set.
	 *
	 * If c indicates that line editing ended with Enter, we still defer to
	 * mainloop() for further checking if the submit action URL could
	 * require more checks than we do here.  Only in the remaining cases do
	 * we proceed to call HText_SubmitForm() directly before returning.  -
	 * kw
	 */
	if (immediate_submit ||
	    ((c == '\r' || c == '\n' || c == LAC_TO_LKC0(LYK_SUBMIT)) &&
	     peek_mouse_link() == -1)) {
	    LYSetHilite(cur, form->value);
#ifdef TEXT_SUBMIT_CONFIRM_WANTED
	    if (!immediate_submit && (c == '\r' || c == '\n') &&
		!HTConfirmDefault(NO_SUBMIT_BUTTON_QUERY), YES) {
		/* User was prompted and declined; if canceled with ^G
		 * let mainloop stay on this field, otherwise move on to
		 * the next field or link. - kw
		 */
		if (HTLastConfirmCancelled())
		    c = DO_NOTHING;
		else
		    c = LAC_TO_LKC(LYK_NEXT_LINK);
d198 27
a224 3
#endif
	    if (!form->submit_action || *form->submit_action == '\0') {
		HTUserMsg(NO_FORM_ACTION);
d227 8
a234 9
	    } else if (form->submit_method == URL_MAIL_METHOD && no_mail) {
		HTAlert(FORM_MAILTO_DISALLOWED);
		c = DO_NOTHING;
		break;
	    } else if (!immediate_submit &&
		       ((no_file_url &&
			 isFILE_URL(form->submit_action)) ||
			!strncasecomp(form->submit_action, "lynx", 4))) {
		c = LAC_TO_LKC0(LYK_SUBMIT);
d236 4
a239 8
	    } else {
		if (form->no_cache &&
		    form->submit_method != URL_MAIL_METHOD) {
		    LYforce_no_cache = TRUE;
		    reloading = TRUE;
		}
		newdoc_changed =
		    HText_SubmitForm(form, newdoc, link_name, form->value);
d241 2
a242 1
	    if (form->submit_method == URL_MAIL_METHOD) {
d244 2
a245 4
	    } else {
		/*
		 * Returns new document URL.
		 */
a248 10
	    c = DO_NOTHING;
	    break;
	} else {
	    LYSetHilite(cur, form->value);
	}
	break;

    case F_SUBMIT_TYPE:
    case F_IMAGE_SUBMIT_TYPE:
	if (form->disabled == YES)
a249 15
	if (form->no_cache &&
	    form->submit_method != URL_MAIL_METHOD) {
	    LYforce_no_cache = TRUE;
	    reloading = TRUE;
	}
	newdoc_changed =
	    HText_SubmitForm(form, newdoc, link_name, link_value);
	if (form->submit_method == URL_MAIL_METHOD)
	    *refresh_screen = TRUE;
	else {
	    /* returns new document URL */
	    newdoc->link = 0;
	    newdoc->internal_link = FALSE;
	}
	break;
d253 1
a253 35
    if (newdoc_changed) {
	c = LKC_DONE;
    } else {
	/*
	 * These flags may have been set in mainloop, anticipating that a
	 * request will be submitted.  But if we haven't filled in newdoc, that
	 * won't actually be the case, so unset them.  - kw
	 */
	LYforce_no_cache = FALSE;
	reloading = FALSE;
    }
    FREE(my_data);
    return (c);
}

int change_form_link(int cur,
		     DocInfo *newdoc,
		     BOOLEAN *refresh_screen,
		     BOOLEAN use_last_tfpos,
		     BOOLEAN immediate_submit)
{
    /*pass all our args and FALSE as last arg */
    return change_form_link_ex(cur,
			       newdoc,
			       refresh_screen,
			       use_last_tfpos,
			       immediate_submit,
			       FALSE /*redraw_only */ );
}

static int LastTFPos = -1;	/* remember last text field position */

static void LYSetLastTFPos(int pos)
{
    LastTFPos = pos;
d256 2
a257 3
static int form_getstr(int cur,
		       BOOLEAN use_last_tfpos,
		       BOOLEAN redraw_only)
d259 1
a259 1
    FormInfo *form = links[cur].l_form;
d266 1
a266 6
    int action, repeat;
    int last_xlkc = -1;

#ifdef SUPPORT_MULTIBYTE_EDIT
    BOOL refresh_mb = TRUE;
#endif
d269 1
a269 1
    BOOLEAN Edited = FALSE;	/* Value might be updated? */
d272 1
a272 1
     * Get the initial position of the cursor.
d275 2
a276 2
    if ((startcol + form->size) > LYcolLimit)
	far_col = LYcolLimit;
d281 1
a281 1
     * Make sure the form field value does not exceed our buffer.  - FM
d285 3
a287 3
		  form->maxlength :
		  (sizeof(MyEdit.buffer) - 1));
    if (strlen(form->value) > (size_t) max_length) {
d289 2
a290 2
	 * We can't fit the entire value into the editing buffer, so enter as
	 * much of the tail as fits.  - FM
d296 1
a296 1
	     * If we can edit it, report that we are using the tail.  - FM
d299 23
a321 2
	    show_formlink_statusline(form, redraw_only ? FOR_PANEL : FOR_INPUT);
	    LYmove(startline, startcol);
d326 1
a326 1
     * Print panned line
d330 1
a330 34
    MyEdit.hidden = (BOOL) (form->type == F_PASSWORD_TYPE);
    if (use_last_tfpos && LastTFPos >= 0 && LastTFPos < MyEdit.strlen) {
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
	if (redraw_only) {
	    if (!(MyEdit.strlen >= MyEdit.dspwdth &&
		  LastTFPos >= MyEdit.dspwdth - MyEdit.margin)) {
		MyEdit.pos = LastTFPos;
		if (MyEdit.strlen >= MyEdit.dspwdth)
		    textinput_redrawn = FALSE;
	    }
	} else
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
	    MyEdit.pos = LastTFPos;
#ifdef ENHANCED_LINEEDIT
	if (MyEdit.pos == 0)
	    MyEdit.mark = -1 - MyEdit.strlen;	/* Do not show the region. */
#endif
    }
    /* Try to prepare for setting position based on the last mouse event */
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
    if (!redraw_only) {
	if (peek_mouse_levent()) {
	    if (!use_last_tfpos && !textinput_redrawn) {
		MyEdit.pos = 0;
	    }
	}
	textinput_redrawn = FALSE;
    }
#else
    if (peek_mouse_levent()) {
	if (!use_last_tfpos)
	    MyEdit.pos = 0;
    }
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
a331 2
    if (redraw_only)
	return 0;		/*return value won't be analysed */
d334 1
a334 1
     * And go for it!
d337 1
a337 1
      again:
d339 4
a342 1
	get_mouse_link();	/* Reset mouse_link. */
d344 1
a344 10
	ch = LYgetch_input();
#ifdef SUPPORT_MULTIBYTE_EDIT
	if (!refresh_mb
	    && (EditBinding(ch) != LYE_CHAR)
#ifndef WIN_EX
	    && (EditBinding(ch) != LYE_AIX)
#endif
	    )
	    goto again;
#endif /* SUPPORT_MULTIBYTE_EDIT */
d348 1
a348 1
	    ch = LYCharINTERRUPT2;
d351 3
a353 22

	action = 0;
#ifdef USE_MOUSE
#  if defined(NCURSES) || defined(PDCURSES)
	if (ch != -1 && (ch & LKC_ISLAC) && !(ch & LKC_ISLECLAC))	/* already lynxactioncode? */
	    break;		/* @@@@@@ maybe move these 2 lines outside ifdef -kw */
	if (ch == MOUSE_KEY) {	/* Need to process ourselves */
#if defined(PDCURSES)
	    int curx, cury;

	    request_mouse_pos();
	    LYGetYX(cury, curx);
	    if (MOUSE_Y_POS == cury) {
		repeat = MOUSE_X_POS - curx;
		if (repeat < 0) {
		    action = LYE_BACK;
		    repeat = -repeat;
		} else
		    action = LYE_FORW;
	    }
#else
	    MEVENT event;
d361 2
a362 2
		    action = LYE_BACK;
		    repeat = -repeat;
d364 1
a364 26
		    action = LYE_FORW;
	    }
#endif /* PDCURSES */
	    else {
		/* Mouse event passed to us as MOUSE_KEY, and apparently not on
		 * this field's line?  Something is not as it should be...
		 *
		 * A call to statusline() may have happened, possibly from
		 * within a mouse menu.  Let's at least make sure here that the
		 * cursor position gets restored.  - kw
		 */
		MyEdit.dirty = TRUE;
	    }
	    last_xlkc = -1;
	} else
#  endif			/* NCURSES || PDCURSES */
#endif /* USE_MOUSE */

	{
	    if (!(ch & LKC_ISLECLAC))
		ch |= MyEdit.current_modifiers;
	    MyEdit.current_modifiers = 0;
	    if (last_xlkc != -1) {
		if (ch == last_xlkc)
		    ch |= LKC_MOD3;
		last_xlkc = -1;	/* consumed */
d367 1
a369 24

	if (!action)
	    action = EditBinding(ch);
	if ((action & LYE_DF) && !(action & LYE_FORM_LAC)) {
	    last_xlkc = ch;
	    action &= ~LYE_DF;
	} else {
	    last_xlkc = -1;
	}

	if (action == LYE_SETM1) {
	    /*
	     * Set flag for modifier 1.
	     */
	    MyEdit.current_modifiers |= LKC_MOD1;
	    continue;
	}
	if (action == LYE_SETM2) {
	    /*
	     * Set flag for modifier 2.
	     */
	    MyEdit.current_modifiers |= LKC_MOD2;
	    continue;
	}
d371 2
a372 2
	 * Filter out global navigation keys that should not be passed to line
	 * editor, and LYK_REFRESH.
d374 1
a378 4
	if (action & LYE_FORM_LAC) {
	    ch = (action & LAC_MASK) | LKC_ISLAC;
	    break;
	}
d385 1
a385 1
		ch = LYCharINTERRUPT2;
a389 59
#ifdef CAN_CUT_AND_PASTE	/* 1998/10/01 (Thu) 19:19:22 */
	if (action == LYE_PASTE) {
	    unsigned char *s = (unsigned char *) get_clip_grab(), *e;
	    char *buf = NULL;
	    int len;

	    if (!s)
		break;
	    len = strlen((const char *) s);
	    e = s + len;

	    if (len > 0) {
		unsigned char *e1 = s;

		while (e1 < e) {
		    if (*e1 < ' ') {	/* Stop here? */
			if (e1 > s)
			    LYEditInsert(&MyEdit, s, e1 - s, -1, TRUE);
			s = e1;
			if (*e1 == '\t') {	/* Replace by space */
			    LYEditInsert(&MyEdit, (unsigned char *) " ", 1,
					 -1, TRUE);
			    s = ++e1;
			} else
			    break;
		    } else
			++e1;
		}
		if (e1 > s)
		    LYEditInsert(&MyEdit, s, e1 - s, -1, TRUE);
		while (e1 < e && *e1 == '\r')
		    e1++;
		if (e1 + 1 < e && *e1 == '\n')
		    StrAllocCopy(buf, (char *) e1 + 1);		/* Survive _release() */
		get_clip_release();
		if (MyEdit.strlen >= max_length) {
		    HaveMaxlength = TRUE;
		} else if (HaveMaxlength &&
			   MyEdit.strlen < max_length) {
		    HaveMaxlength = FALSE;
		    _statusline(ENTER_TEXT_ARROWS_OR_TAB);
		}
		if (strcmp(value, MyEdit.buffer) != 0) {
		    Edited = TRUE;
		}
		if (buf) {
		    put_clip(buf);
		    FREE(buf);
		    ch = '\n';	/* Sometimes moves to the next line */
		    break;
		}
		LYRefreshEdit(&MyEdit);
	    } else {
		HTInfoMsg(gettext("Clipboard empty or Not text data."));
		continue;
	    }
	}
#endif
#ifndef WIN_EX
a392 1
#endif
d394 1
a394 1
	    ch = (int) ('\t');
d398 1
a398 12
	    return (DO_NOTHING);
	}
	if (action == LYE_STOP) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    textfields_need_activation = TRUE;
	    break;
#else
#ifdef ENHANCED_LINEEDIT
	    if (MyEdit.mark >= 0)
		MyEdit.mark = -1 - MyEdit.strlen;	/* Disable. */
#endif
#endif
d400 1
a400 1
	if (action == LYE_NOP && LKC_TO_LAC(keymap, ch) == LYK_REFRESH)
a401 7
#ifdef SH_EX
/* ASATAKU emacskey hack 1997/08/26 (Tue) 09:19:23 */
	if (emacs_keys &&
	    (EditBinding(ch) == LYE_FORWW || EditBinding(ch) == LYE_BACKW))
	    goto breakfor;
/* ASATAKU emacskey hack */
#endif
d403 15
a417 4
	default:
	    /* [ 1999/04/14 (Wed) 15:01:33 ]
	     * Left arrrow in column 0 deserves special treatment here, else
	     * you can get trapped in a form without submit button!
d419 16
a434 2
	    if (action == LYE_BACK && MyEdit.pos == 0 && repeat == -1) {
		int c = YES;	/* Go back immediately if no changes */
d436 3
a438 15
		if (textfield_prompt_at_left_edge) {
		    c = HTConfirmDefault(PREV_DOC_QUERY, NO);
		} else if (strcmp(MyEdit.buffer, value)) {
		    c = HTConfirmDefault(PREV_DOC_QUERY, NO);
		}
		if (c == YES) {
		    return (ch);
		} else {
		    if (form->disabled == YES)
			_statusline(ARROWS_OR_TAB_TO_MOVE);
		    else
			_statusline(ENTER_TEXT_ARROWS_OR_TAB);
		}
	    }
	    if (form->disabled == YES) {
d440 12
a451 23
		 * Allow actions that don't modify the contents even in
		 * disabled form fields, so the user can scroll through the
		 * line for reading if necessary.  - kw
		 */
		switch (action) {
		case LYE_BOL:
		case LYE_EOL:
		case LYE_FORW:
		case LYE_FORW_RL:
		case LYE_BACK:
		case LYE_BACK_LL:
		case LYE_FORWW:
		case LYE_BACKW:
#ifdef EXP_KEYBOARD_LAYOUT
		case LYE_SWMAP:
#endif
#ifdef ENHANCED_LINEEDIT
		case LYE_SETMARK:
		case LYE_XPMARK:
#endif
		    break;
		default:
		    goto again;
d453 2
a454 44
	    }
	    /*
	     * Make sure the statusline uses editmode help.
	     */
	    if (repeat < 0)
		repeat = 1;
	    while (repeat--) {
		int rc = LYEdit1(&MyEdit, ch, action & ~LYE_DF, TRUE);

		if (rc < 0) {
		    ch = -rc;
		    /* FORW_RL and BACK_LL may require special attention.
		       BACK_LL wanted to switch to the previous link on
		       the same line.  However, if there is no such link,
		       then we would either disactivate the form
		       (with -tna), or will reenter the form, thus we jump
		       to the end of the line; both are counterintuitive.
		       Unfortunately, we do not have access to curdoc.link,
		       so we deduce it ourselves.  We don't have the info
		       to do it inside LYLineEdit().
		       This should work for prompts too.  */
		    if ((action != LYE_BACK_LL && action != LYE_FORW_RL)
			|| (cur >= 0
			    && cur < nlinks
			    && (action == LYE_FORW_RL
				? cur < nlinks - 1
				: cur > 0)
			    && links[cur + ((action == LYE_FORW_RL)
					    ? 1
					    : -1)].ly
			    == links[cur].ly))
			goto breakfor;
		}
#ifdef SUPPORT_MULTIBYTE_EDIT
		if (rc == 0) {
		    if (HTCJK != NOCJK && (0x80 <= ch)
			&& (ch <= 0xfe) && refresh_mb)
			refresh_mb = FALSE;
		    else
			refresh_mb = TRUE;
		} else {
		    if (!refresh_mb) {
			LYEdit1(&MyEdit, 0, LYE_DELP, TRUE);
		    }
a455 15
#endif /* SUPPORT_MULTIBYTE_EDIT */
	    }
	    if (MyEdit.strlen >= max_length) {
		HaveMaxlength = TRUE;
	    } else if (HaveMaxlength &&
		       MyEdit.strlen < max_length) {
		HaveMaxlength = FALSE;
		_statusline(ENTER_TEXT_ARROWS_OR_TAB);
	    }
	    if (strcmp(value, MyEdit.buffer)) {
		Edited = TRUE;
	    }
#ifdef SUPPORT_MULTIBYTE_EDIT
	    if (refresh_mb)
#endif
a456 1
	    LYSetLastTFPos(MyEdit.pos);
d459 3
a461 1
  breakfor:
d463 1
a463 1
	char *p;
d466 1
a466 1
	 * Load the new value.
d470 2
a471 2
	     * The previous value did fit in the line buffer, so replace it
	     * with the new value.  - FM
d476 1
a476 1
	     * Combine the modified tail with the unmodified head.  - FM
a482 1
	/* 2.8.4pre.3 - most browsers appear to preserve trailing spaces -VH */
d484 1
a484 1
	 * Remove trailing spaces
d486 4
a489 4
	 * Do we really need to do that here?  Trailing spaces will only be
	 * there if user keyed them in.  Rather rude to throw away their hard
	 * earned spaces.  Better deal with trailing spaces when submitting the
	 * form????
d491 4
a494 6
	if (LYtrimInputFields) {
	    p = &(form->value[strlen(form->value)]);
	    while ((p != form->value) && (p[-1] == ' '))
		p--;
	    *p = '\0';
	}
d497 7
a503 6
	 * If the field has been changed, assume that it is now in current
	 * display character set, even if for some reason it wasn't!  Hopefully
	 * a user will only submit the form if the non-ASCII characters are
	 * displayed correctly, which means (assuming that the display
	 * character set has been set truthfully) the user confirms by changing
	 * the field that the character encoding is right.  - kw
d505 1
a505 1
	if (non_empty(form->value))
d508 1
a508 1
    return (ch);
d512 7
a518 4
 * Display statusline info tailored for the current form field.
 */
void show_formlink_statusline(const FormInfo * form,
			      int for_what)
d520 29
a548 11
    switch (form->type) {
    case F_PASSWORD_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_PASSWORD_UNM_MSG);
	else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	if (for_what == FOR_PANEL)
	    statusline(FORM_LINK_PASSWORD_MESSAGE_INA);
	else
#endif
	    statusline(FORM_LINK_PASSWORD_MESSAGE);
d550 4
a553 5
    case F_OPTION_LIST_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
	else
	    statusline(FORM_LINK_OPTION_LIST_MESSAGE);
d555 36
a590 24
    case F_CHECKBOX_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_CHECKBOX_UNM_MSG);
	else
	    statusline(FORM_LINK_CHECKBOX_MESSAGE);
	break;
    case F_RADIO_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_RADIO_UNM_MSG);
	else
	    statusline(FORM_LINK_RADIO_MESSAGE);
	break;
    case F_TEXT_SUBMIT_TYPE:
	if (form->disabled == YES) {
	    statusline(FORM_LINK_TEXT_SUBMIT_UNM_MSG);
	} else if (form->submit_method ==
		   URL_MAIL_METHOD) {
	    if (no_mail)
		statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_DIS_MSG);
	    else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (for_what == FOR_PANEL)
		statusline(FORM_TEXT_SUBMIT_MAILTO_MSG_INA);
	    else
d592 113
a704 8
		statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_MSG);
	} else if (form->no_cache) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (for_what == FOR_PANEL)
		statusline(FORM_TEXT_RESUBMIT_MESSAGE_INA);
	    else
#endif
		statusline(FORM_LINK_TEXT_RESUBMIT_MESSAGE);
d706 25
a730 2
	    char *submit_str = NULL;
	    char *xkey_info = key_for_func_ext(LYK_NOCACHE, for_what);
d732 18
a749 6
	    if (non_empty(xkey_info)) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    HTSprintf0(&submit_str, FORM_TEXT_SUBMIT_MESSAGE_INA_X,
			       xkey_info);
		else
d751 3
a753 9
		    HTSprintf0(&submit_str, FORM_LINK_TEXT_SUBMIT_MESSAGE_X,
			       xkey_info);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE_INA);
		else
d755 38
a792 3
		    statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE);
	    }
	    FREE(xkey_info);
d794 12
a805 12
	break;
    case F_SUBMIT_TYPE:
    case F_IMAGE_SUBMIT_TYPE:
	if (form->disabled == YES) {
	    statusline(FORM_LINK_SUBMIT_DIS_MSG);
	} else if (form->submit_method ==
		   URL_MAIL_METHOD) {
	    if (no_mail) {
		statusline(FORM_LINK_SUBMIT_MAILTO_DIS_MSG);
	    } else {
		if (user_mode == ADVANCED_MODE) {
		    char *submit_str = NULL;
d807 4
a810 22
		    StrAllocCopy(submit_str, FORM_LINK_SUBMIT_MAILTO_PREFIX);
		    StrAllocCat(submit_str, form->submit_action);
		    statusline(submit_str);
		    FREE(submit_str);
		} else {
		    statusline(FORM_LINK_SUBMIT_MAILTO_MSG);
		}
	    }
	} else if (form->no_cache) {
	    if (user_mode == ADVANCED_MODE) {
		char *submit_str = NULL;

		StrAllocCopy(submit_str, FORM_LINK_RESUBMIT_PREFIX);
		StrAllocCat(submit_str, form->submit_action);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
		statusline(FORM_LINK_RESUBMIT_MESSAGE);
	    }
	} else {
	    if (user_mode == ADVANCED_MODE) {
		char *submit_str = NULL;
d812 11
a822 7
		StrAllocCopy(submit_str, FORM_LINK_SUBMIT_PREFIX);
		StrAllocCat(submit_str, form->submit_action);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
		statusline(FORM_LINK_SUBMIT_MESSAGE);
	    }
d824 25
a848 20
	break;
    case F_RESET_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_RESET_DIS_MSG);
	else
	    statusline(FORM_LINK_RESET_MESSAGE);
	break;
    case F_FILE_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_FILE_UNM_MSG);
	else
	    statusline(FORM_LINK_FILE_MESSAGE);
	break;
    case F_TEXT_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_TEXT_UNM_MSG);
	else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	if (for_what == FOR_PANEL)
	    statusline(FORM_LINK_TEXT_MESSAGE_INA);
d850 32
a882 5
	    statusline(FORM_LINK_TEXT_MESSAGE);
	break;
    case F_TEXTAREA_TYPE:
	if (form->disabled == YES) {
	    statusline(FORM_LINK_TEXT_UNM_MSG);
d884 369
a1252 2
	    char *submit_str = NULL;
	    char *xkey_info = NULL;
d1254 278
a1531 12
	    if (!no_editor && editor && editor) {
		xkey_info = key_for_func_ext(LYK_EDIT_TEXTAREA, for_what);
#ifdef TEXTAREA_AUTOEXTEDIT
		if (!xkey_info)
		    xkey_info = key_for_func_ext(LYK_DWIMEDIT, for_what);
#endif
	    }
	    if (non_empty(xkey_info)) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    HTSprintf0(&submit_str, FORM_LINK_TEXTAREA_MESSAGE_INA_E,
			       xkey_info);
d1533 18
a1550 14
#endif
		    HTSprintf0(&submit_str, FORM_LINK_TEXTAREA_MESSAGE_E,
			       xkey_info);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    statusline(FORM_LINK_TEXTAREA_MESSAGE_INA);
		else
#endif
		    statusline(FORM_LINK_TEXTAREA_MESSAGE);
	    }
	    FREE(xkey_info);
d1552 1
a1552 1
	break;
d1554 8
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a8 1
#include <LYGlobalDefs.h>
d10 1
d12 1
d23 1
a23 5
#if defined(VMS) && !defined(USE_SLANG)
#define CTRL_W_HACK DO_NOTHING
#else
#define CTRL_W_HACK 23  /* CTRL-W refresh without clearok */
#endif /* VMS && !USE_SLANG */
d26 9
a34 3
	int		cur,
	BOOLEAN		use_last_tfpos,
	BOOLEAN		redraw_only));
d36 3
a38 31
/*
 * Returns an array of pointers to the given list
 */
PRIVATE char ** options_list ARGS1(
	OptionType *,	opt_ptr)
{
    char **result = 0;
    size_t len;
    int pass;
    OptionType *tmp_ptr;

    for (pass = 0; pass < 2; pass++) {
	for (tmp_ptr = opt_ptr, len = 0; tmp_ptr != 0; tmp_ptr = tmp_ptr->next) {
	    if (pass != 0)
		result[len] = tmp_ptr->name;
	    len++;
	}
	if (pass == 0) {
	    len++;
	    result = typecallocn(char *, len);
	} else {
	    result[len] = 0;
	}
    }

    return result;
}

PUBLIC int change_form_link_ex ARGS6(
	int,		cur,
	DocInfo *,	newdoc,
d40 2
a41 3
	BOOLEAN,	use_last_tfpos,
	BOOLEAN,	immediate_submit,
	BOOLEAN,	redraw_only)
d43 1
a43 4
    FormInfo *form = links[cur].l_form;
    char *link_name = form->name;
    char *link_value = form->value;
    int newdoc_changed = 0;
a45 1
    char **my_data = 0;
d47 6
a52 7
    /*
     *  If there is no form to perform action on, don't do anything.
     */
    if (form == NULL) {
	return(c);
    }
    my_data = options_list(form->select_list);
d57 1
a57 1
    LYmove(links[cur].ly, links[cur].lx);
d63 7
a69 2
	    LYSetHilite(cur, form->num_value ? unchecked_box : checked_box);
	    form->num_value = ! form->num_value;
d73 1
a73 1
	    if (form->select_list == 0) {
d81 4
a84 10
		dummy = LYhandlePopupList(form->num_value,
					  links[cur].ly,
					  links[cur].lx,
					  (CONST char **)my_data,
					  form->size,
					  form->size_l,
					  form->disabled,
					  FALSE,
					  FALSE);
#if CTRL_W_HACK != DO_NOTHING
d86 5
a90 1
		    c = CTRL_W_HACK;  /* CTRL-W refresh without clearok */
d92 1
a92 1
#endif
d97 4
a100 9
	    form->num_value = LYhandlePopupList(form->num_value,
						links[cur].ly,
						links[cur].lx,
						(CONST char **)my_data,
						form->size,
						form->size_l,
						form->disabled,
						FALSE,
						FALSE);
d119 1
a119 1
#if CTRL_W_HACK != DO_NOTHING
d121 6
a126 1
		c = CTRL_W_HACK;	 /* CTRL-W refresh without clearok */
d128 3
a130 3
#endif
		c = 12;	 /* CTRL-L for repaint */
	    break;
d149 3
a151 3
		    if (links[i].type == WWW_FORM_LINK_TYPE
		     && links[i].l_form->type == F_RADIO_TYPE
		     && links[i].l_form->number == form->number
d155 5
a159 5
		     && !strcmp(links[i].l_form->name, form->name)
		     && links[i].l_form->num_value) {
			LYmove(links[i].ly, links[i].lx);
			LYaddstr(unchecked_radio);
			LYSetHilite(i, unchecked_radio);
d170 1
a170 1
		LYSetHilite(cur, checked_radio);
a173 1
	case F_FILE_TYPE:
d177 5
a181 4
	    c = form_getstr(cur, use_last_tfpos, redraw_only);
	    LYSetHilite(cur, (form->type == F_PASSWORD_TYPE)
			? STARS(strlen(form->value))
			: form->value);
d192 1
a192 6
	    if (redraw_only) {
		c = form_getstr(cur, use_last_tfpos, TRUE);
		break;
	    }
	    if (!immediate_submit)
		c = form_getstr(cur, use_last_tfpos, FALSE);
d194 2
a195 5
		(c == '\r' || c == '\n' || immediate_submit)) {
		if (peek_mouse_link() >= 0)
		    c = LAC_TO_LKC0(LYK_ACTIVATE);
		else
		    c = '\t';
d198 2
a199 35
	    /*
	     *  If immediate_submit is set, we didn't enter the line editor
	     *  above, and will now try to call HText_SubmitForm() directly.
	     *  If immediate_submit is not set, c is the lynxkeycode returned
	     *  from line editing.   Then if c indicates that a key was pressed
	     *  that means we should submit, but with some extra considerations
	     *  (i.e. NOCACHE, DOWNLOAD, different from simple Enter), or if
	     *  we should act on some *other* link selected with the mouse,
	     *  we'll just return c and leave it to mainloop() to do the
	     *  right thing; if everything checks out, it should call this
	     *  function again, with immediate_submit set.
	     *  If c indicates that line editing ended with Enter, we still
	     *  defer to mainloop() for further checking if the submit
	     *  action URL could require more checks than we do here.
	     *  Only in the remaining cases do we proceed to call
	     *  HText_SubmitForm() directly before returning. - kw
	     */
	    if (immediate_submit ||
		((c == '\r' || c == '\n' || c == LAC_TO_LKC0(LYK_SUBMIT)) &&
		 peek_mouse_link() == -1)) {
		LYSetHilite(cur, form->value);
#ifdef TEXT_SUBMIT_CONFIRM_WANTED
		if (!immediate_submit && (c == '\r' || c == '\n') &&
		    !HTConfirmDefault(NO_SUBMIT_BUTTON_QUERY), YES) {
		    /* User was prompted and declined; if canceled with ^G
		     * let mainloop stay on this field, otherwise move on to
		     * the next field or link. - kw
		     */
		    if (HTLastConfirmCancelled())
			c = DO_NOTHING;
		    else
			c = LAC_TO_LKC(LYK_NEXT_LINK);
		    break;
		}
#endif
a207 6
		} else if (!immediate_submit &&
			   ((no_file_url &&
			     isFILE_URL(form->submit_action)) ||
			    !strncasecomp(form->submit_action, "lynx", 4))) {
		    c = LAC_TO_LKC0(LYK_SUBMIT);
		    break;
d214 1
a214 2
		    newdoc_changed =
			HText_SubmitForm(form, newdoc, link_name, form->value);
d228 1
a228 1
		LYSetHilite(cur, form->value);
d241 1
a241 2
	    newdoc_changed =
		HText_SubmitForm(form, newdoc, link_name, link_value);
a252 12
    if (newdoc_changed) {
	c = LKC_DONE;
    } else {
	/*
	 *  These flags may have been set in mainloop, anticipating that
	 *  a request will be submitted.  But if we haven't filled in
	 *  newdoc, that won't actually be the case, so unset them. - kw
	 */
	LYforce_no_cache = FALSE;
	reloading = FALSE;
    }
    FREE(my_data);
d256 2
a257 28
PUBLIC int change_form_link ARGS5(
	int,		cur,
	DocInfo *,	newdoc,
	BOOLEAN *,	refresh_screen,
	BOOLEAN,	use_last_tfpos,
	BOOLEAN,	immediate_submit)
{
    /*pass all our args and FALSE as last arg*/
    return change_form_link_ex(cur,
			       newdoc,
			       refresh_screen,
			       use_last_tfpos,
			       immediate_submit,
			       FALSE /*redraw_only*/ );
}

PRIVATE int LastTFPos = -1;	/* remember last text field position */

PRIVATE void LYSetLastTFPos ARGS1(
    int,	pos)
{
    LastTFPos = pos;
}

PRIVATE int form_getstr ARGS3(
	int,		cur,
	BOOLEAN,	use_last_tfpos,
	BOOLEAN,	redraw_only)
d259 1
a259 1
    FormInfo *form = links[cur].l_form;
d266 1
a266 5
    int action, repeat;
    int last_xlkc = -1;
#ifdef SUPPORT_MULTIBYTE_EDIT
    BOOL refresh_mb = TRUE;
#endif
d299 23
a321 2
	    show_formlink_statusline(form, redraw_only? FOR_PANEL : FOR_INPUT);
	    LYmove(startline, startcol);
d330 1
a330 34
    MyEdit.hidden = (BOOL) (form->type == F_PASSWORD_TYPE);
    if (use_last_tfpos && LastTFPos >= 0 && LastTFPos < MyEdit.strlen) {
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
	if (redraw_only) {
	    if (!(MyEdit.strlen >= MyEdit.dspwdth &&
		  LastTFPos >= MyEdit.dspwdth - MyEdit.margin)) {
		MyEdit.pos = LastTFPos;
		if (MyEdit.strlen >= MyEdit.dspwdth)
		    textinput_redrawn = FALSE;
	    }
	} else
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
	    MyEdit.pos = LastTFPos;
#ifdef ENHANCED_LINEEDIT
	if (MyEdit.pos == 0)
	    MyEdit.mark = -1 - MyEdit.strlen;	/* Do not show the region. */
#endif
    }
    /* Try to prepare for setting position based on the last mouse event */
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
    if (!redraw_only) {
	if (peek_mouse_levent()) {
	    if (!use_last_tfpos && !textinput_redrawn) {
		MyEdit.pos = 0;
	    }
	}
	textinput_redrawn = FALSE;
    }
#else
    if (peek_mouse_levent()) {
	if (!use_last_tfpos)
	    MyEdit.pos = 0;
    }
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
a331 2
    if (redraw_only)
	return 0;		/*return value won't be analysed*/
d339 4
a342 1
	get_mouse_link();	/* Reset mouse_link. */
d344 1
a344 10
	ch = LYgetch_input();
#ifdef SUPPORT_MULTIBYTE_EDIT
	if (!refresh_mb
	 && (EditBinding(ch) != LYE_CHAR)
#ifndef WIN_EX
	 && (EditBinding(ch) != LYE_AIX)
#endif
	    )
	    goto again;
#endif /* SUPPORT_MULTIBYTE_EDIT */
d348 1
a348 1
	    ch = LYCharINTERRUPT2;
d351 1
a351 6

	action = 0;
#ifdef USE_MOUSE
#  if defined(NCURSES) || defined(PDCURSES)
	if (ch != -1 && (ch & LKC_ISLAC) && !(ch & LKC_ISLECLAC)) /* already lynxactioncode? */
	    break;	/* @@@@@@ maybe move these 2 lines outside ifdef -kw */
a352 14
#if defined(PDCURSES)
	    int curx, cury;

	    request_mouse_pos();
	    LYGetYX(cury, curx);
	    if (MOUSE_Y_POS == cury) {
		repeat = MOUSE_X_POS - curx;
		if (repeat < 0) {
		    action = LYE_BACK;
		    repeat = - repeat;
		} else
		    action = LYE_FORW;
	    }
#else
d361 1
a361 1
		    action = LYE_BACK;
d364 1
a364 26
		    action = LYE_FORW;
	    }
#endif /* PDCURSES */
	    else {
		/*  Mouse event passed to us as MOUSE_KEY, and apparently
		 *  not on this field's line?  Something is not as it
		 *  should be...
		 *  A call to statusline() may have happened, possibly from
		 *  within a mouse menu.  Let's at least make sure here
		 *  that the cursor position gets restored.  - kw
		 */
		MyEdit.dirty = TRUE;
	    }
	    last_xlkc = -1;
	} else
#  endif     /* NCURSES || PDCURSES */
#endif /* USE_MOUSE */

	{
	    if (!(ch & LKC_ISLECLAC))
		ch |= MyEdit.current_modifiers;
	    MyEdit.current_modifiers = 0;
	    if (last_xlkc != -1) {
		if (ch == last_xlkc)
		    ch |= LKC_MOD3;
		last_xlkc = -1;	/* consumed */
d367 1
a369 24

	if (!action)
	    action = EditBinding(ch);
	if ((action & LYE_DF) && !(action & LYE_FORM_LAC)) {
	    last_xlkc = ch;
	    action &= ~LYE_DF;
	} else {
	    last_xlkc = -1;
	}

	if (action == LYE_SETM1) {
	    /*
	     *  Set flag for modifier 1.
	     */
	    MyEdit.current_modifiers |= LKC_MOD1;
	    continue;
	}
	if (action == LYE_SETM2) {
	    /*
	     *  Set flag for modifier 2.
	     */
	    MyEdit.current_modifiers |= LKC_MOD2;
	    continue;
	}
d374 1
a378 4
	if (action & LYE_FORM_LAC) {
	    ch = (action & LAC_MASK) | LKC_ISLAC;
	    break;
	}
d385 1
a385 1
		ch = LYCharINTERRUPT2;
a389 59

#ifdef CAN_CUT_AND_PASTE	/* 1998/10/01 (Thu) 19:19:22 */
	if (action == LYE_PASTE) {
	    unsigned char *s = get_clip_grab(), *e;
	    char *buf = NULL;
	    int len;

	    if (!s)
		break;
	    len = strlen(s);
	    e = s + len;

	    if (len > 0) {
		unsigned char *e1 = s;

		while (e1 < e) {
		    if (*e1 < ' ') { /* Stop here? */
			if (e1 > s)
			    LYEditInsert(&MyEdit, s, e1 - s, -1, TRUE);
			s = e1;
			if (*e1 == '\t') { /* Replace by space */
			    LYEditInsert(&MyEdit, " ", 1, -1, TRUE);
			    s = ++e1;
			} else
			    break;
		    } else
			++e1;
		}
		if (e1 > s)
		    LYEditInsert(&MyEdit, s, e1 - s, -1, TRUE);
		while (e1 < e && *e1 == '\r')
		    e1++;
		if (e1 + 1 < e && *e1 == '\n')
		    StrAllocCopy(buf, e1 + 1);	/* Survive _release() */
		get_clip_release();
		if (MyEdit.strlen >= max_length) {
		    HaveMaxlength = TRUE;
		} else if (HaveMaxlength &&
			   MyEdit.strlen < max_length) {
		    HaveMaxlength = FALSE;
		    _statusline(ENTER_TEXT_ARROWS_OR_TAB);
		}
		if (strcmp(value, MyEdit.buffer) != 0) {
		    Edited = TRUE;
		}
		if (buf) {
		    put_clip(buf);
		    FREE(buf);
		    ch = '\n';		/* Sometimes moves to the next line */
		    break;
		}
		LYRefreshEdit(&MyEdit);
	    } else {
		HTInfoMsg(gettext("Clipboard empty or Not text data."));
		continue;
	    }
	}
#endif
#ifndef WIN_EX
a392 1
#endif
d400 1
a400 12
	if (action == LYE_STOP) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    textfields_need_activation = TRUE;
	    break;
#else
#ifdef ENHANCED_LINEEDIT
	    if (MyEdit.mark >= 0)
		MyEdit.mark = -1 - MyEdit.strlen;	/* Disable. */
#endif
#endif
	}
	if (action == LYE_NOP && LKC_TO_LAC(keymap,ch) == LYK_REFRESH)
a401 7
#ifdef SH_EX
/* ASATAKU emacskey hack 1997/08/26 (Tue) 09:19:23 */
	if (emacs_keys &&
	    (EditBinding(ch) == LYE_FORWW || EditBinding(ch) == LYE_BACKW))
	    goto breakfor;
/* ASATAKU emacskey hack */
#endif
d403 13
a415 2
	    default:
	    /*	[ 1999/04/14 (Wed) 15:01:33 ]
d419 2
a420 1
		if (action == LYE_BACK && MyEdit.pos == 0 && repeat == -1) {
d422 1
a422 3
		    if (textfield_prompt_at_left_edge) {
			c = HTConfirmDefault(PREV_DOC_QUERY, NO);
		    } else if (strcmp(MyEdit.buffer, value)) {
d434 5
a438 27
		if (form->disabled == YES) {
		    /*
		     *  Allow actions that don't modify the contents even
		     *  in disabled form fields, so the user can scroll
		     *  through the line for reading if necessary. - kw
		     */
		    switch(action) {
		    case LYE_BOL:
		    case LYE_EOL:
		    case LYE_FORW:
		    case LYE_FORW_RL:
		    case LYE_BACK:
		    case LYE_BACK_LL:
		    case LYE_FORWW:
		    case LYE_BACKW:
#ifdef EXP_KEYBOARD_LAYOUT
		    case LYE_SWMAP:
#endif
#ifdef ENHANCED_LINEEDIT
		    case LYE_SETMARK:
		    case LYE_XPMARK:
#endif
			break;
		    default:
			goto again;
		    }
		}
d444 2
a445 41
		while (repeat--) {
		    int rc = LYEdit1(&MyEdit, ch, action & ~LYE_DF, TRUE);

		    if (rc < 0) {
			ch = -rc;
			/* FORW_RL and BACK_LL may require special attention.
			   BACK_LL wanted to switch to the previous link on
			   the same line.  However, if there is no such link,
			   then we would either disactivate the form
			   (with -tna), or will reenter the form, thus we jump
			   to the end of the line; both are counterintuitive.
			   Unfortunately, we do not have access to curdoc.link,
			   so we deduce it ourselves.  We don't have the info
			   to do it inside LYLineEdit().
			   This should work for prompts too.  */
			if ( (action != LYE_BACK_LL && action != LYE_FORW_RL)
			     || (cur >= 0
				&& cur < nlinks
				&& (action==LYE_FORW_RL
				    ? cur < nlinks - 1
				    : cur > 0)
				&& links[cur + ((action==LYE_FORW_RL)
						? 1
						: -1)].ly
				   == links[cur].ly))
			    goto breakfor;
		    }
#ifdef SUPPORT_MULTIBYTE_EDIT
		    if (rc == 0) {
			if (HTCJK != NOCJK && (0x80 <= ch)
			&& (ch <= 0xfe) && refresh_mb)
			    refresh_mb = FALSE;
			else
			    refresh_mb = TRUE;
		    } else {
			if (!refresh_mb) {
			    LYEdit1(&MyEdit, 0, LYE_DELP, TRUE);
			}
		    }
#endif /* SUPPORT_MULTIBYTE_EDIT */
		}
a455 3
#ifdef SUPPORT_MULTIBYTE_EDIT
		if (refresh_mb)
#endif
a456 1
		LYSetLastTFPos(MyEdit.pos);
d459 3
a461 1
  breakfor:
a482 1
	/* 2.8.4pre.3 - most browsers appear to preserve trailing spaces -VH */
d491 4
a494 6
	if (LYtrimInputFields) {
	    p = &(form->value[strlen(form->value)]);
	    while ((p != form->value) && (p[-1] == ' '))
		p--;
	    *p = '\0';
	}
d512 7
a518 5
 *  Display statusline info tailored for the current form field.
 */
PUBLIC void show_formlink_statusline ARGS2(
    CONST FormInfo *,	form,
    int,		for_what)
d520 29
a548 11
    switch(form->type) {
    case F_PASSWORD_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_PASSWORD_UNM_MSG);
	else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (for_what == FOR_PANEL)
		statusline(FORM_LINK_PASSWORD_MESSAGE_INA);
	    else
#endif
	    statusline(FORM_LINK_PASSWORD_MESSAGE);
d550 4
a553 5
    case F_OPTION_LIST_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
	else
	    statusline(FORM_LINK_OPTION_LIST_MESSAGE);
d555 36
a590 24
    case F_CHECKBOX_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_CHECKBOX_UNM_MSG);
	else
	    statusline(FORM_LINK_CHECKBOX_MESSAGE);
	break;
    case F_RADIO_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_RADIO_UNM_MSG);
	else
	    statusline(FORM_LINK_RADIO_MESSAGE);
	break;
    case F_TEXT_SUBMIT_TYPE:
	if (form->disabled == YES) {
	    statusline(FORM_LINK_TEXT_SUBMIT_UNM_MSG);
	} else if (form->submit_method ==
		   URL_MAIL_METHOD) {
	    if (no_mail)
		statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_DIS_MSG);
	    else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    statusline(FORM_TEXT_SUBMIT_MAILTO_MSG_INA);
		else
d592 113
a704 8
		statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_MSG);
	} else if (form->no_cache) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (for_what == FOR_PANEL)
		statusline(FORM_TEXT_RESUBMIT_MESSAGE_INA);
	    else
#endif
	    statusline(FORM_LINK_TEXT_RESUBMIT_MESSAGE);
d706 44
a749 8
	    char *submit_str = NULL;
	    char *xkey_info = key_for_func_ext(LYK_NOCACHE, for_what);
	    if (xkey_info && *xkey_info) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    HTSprintf0(&submit_str, FORM_TEXT_SUBMIT_MESSAGE_INA_X,
			       xkey_info);
		else
d751 3
a753 9
		    HTSprintf0(&submit_str, FORM_LINK_TEXT_SUBMIT_MESSAGE_X,
			       xkey_info);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE_INA);
		else
d755 10
a764 16
		statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE);
	    }
	    FREE(xkey_info);
	}
	break;
    case F_SUBMIT_TYPE:
    case F_IMAGE_SUBMIT_TYPE:
	if (form->disabled == YES) {
	    statusline(FORM_LINK_SUBMIT_DIS_MSG);
	} else if (form->submit_method ==
		   URL_MAIL_METHOD) {
	    if (no_mail) {
		statusline(FORM_LINK_SUBMIT_MAILTO_DIS_MSG);
	    } else {
		if(user_mode == ADVANCED_MODE) {
		    char *submit_str = NULL;
d766 14
a779 22
		    StrAllocCopy(submit_str, FORM_LINK_SUBMIT_MAILTO_PREFIX);
		    StrAllocCat(submit_str, form->submit_action);
		    statusline(submit_str);
		    FREE(submit_str);
		} else {
		    statusline(FORM_LINK_SUBMIT_MAILTO_MSG);
		}
	    }
	} else if (form->no_cache) {
	    if(user_mode == ADVANCED_MODE) {
		char *submit_str = NULL;

		StrAllocCopy(submit_str, FORM_LINK_RESUBMIT_PREFIX);
		StrAllocCat(submit_str, form->submit_action);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
		statusline(FORM_LINK_RESUBMIT_MESSAGE);
	    }
	} else {
	    if(user_mode == ADVANCED_MODE) {
		char *submit_str = NULL;
d781 42
a822 7
		StrAllocCopy(submit_str, FORM_LINK_SUBMIT_PREFIX);
		StrAllocCat(submit_str, form->submit_action);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
		statusline(FORM_LINK_SUBMIT_MESSAGE);
	    }
d824 25
a848 4
	break;
    case F_RESET_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_RESET_DIS_MSG);
d850 32
a881 16
	    statusline(FORM_LINK_RESET_MESSAGE);
	break;
    case F_FILE_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_FILE_UNM_MSG);
	else
	    statusline(FORM_LINK_FILE_MESSAGE);
	break;
    case F_TEXT_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_TEXT_UNM_MSG);
	else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (for_what == FOR_PANEL)
		statusline(FORM_LINK_TEXT_MESSAGE_INA);
	    else
a882 5
	    statusline(FORM_LINK_TEXT_MESSAGE);
	break;
    case F_TEXTAREA_TYPE:
	if (form->disabled == YES) {
	    statusline(FORM_LINK_TEXT_UNM_MSG);
d884 648
a1531 14
	    char *submit_str = NULL;
	    char *xkey_info = NULL;
	    if (!no_editor && editor && editor) {
		xkey_info = key_for_func_ext(LYK_EDIT_TEXTAREA, for_what);
#ifdef TEXTAREA_AUTOEXTEDIT
		if (!xkey_info)
		    xkey_info = key_for_func_ext(LYK_DWIMEDIT, for_what);
#endif
	    }
	    if (xkey_info && *xkey_info) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    HTSprintf0(&submit_str, FORM_LINK_TEXTAREA_MESSAGE_INA_E,
			       xkey_info);
d1533 18
a1550 14
#endif
		    HTSprintf0(&submit_str, FORM_LINK_TEXTAREA_MESSAGE_E,
			       xkey_info);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    statusline(FORM_LINK_TEXTAREA_MESSAGE_INA);
		else
#endif
		    statusline(FORM_LINK_TEXTAREA_MESSAGE);
	    }
	    FREE(xkey_info);
d1552 1
a1552 1
	break;
d1554 8
@


1.1.3.2
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@d602 1
a602 1
	    unsigned char *s = (unsigned char *) get_clip_grab(), *e;
d608 1
a608 1
	    len = strlen((const char *) s);
d620 1
a620 1
			    LYEditInsert(&MyEdit, (unsigned char *) " ", 1, -1, TRUE);
d632 1
a632 1
		    StrAllocCopy(buf, (char *) e1 + 1);	/* Survive _release() */
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d28 1
a28 1
static int form_getstr (
d31 1
a31 1
	BOOLEAN		redraw_only);
d36 2
a37 2
static char ** options_list (
	OptionType *	opt_ptr)
d61 7
a67 7
int change_form_link_ex (
	int		cur,
	DocInfo *	newdoc,
	BOOLEAN *	refresh_screen,
	BOOLEAN	use_last_tfpos,
	BOOLEAN	immediate_submit,
	BOOLEAN	redraw_only)
d110 1
a110 1
					  (const char **)my_data,
d128 1
a128 1
						(const char **)my_data,
d345 6
a350 6
int change_form_link (
	int		cur,
	DocInfo *	newdoc,
	BOOLEAN *	refresh_screen,
	BOOLEAN	use_last_tfpos,
	BOOLEAN	immediate_submit)
d361 1
a361 1
static int LastTFPos = -1;	/* remember last text field position */
d363 2
a364 2
static void LYSetLastTFPos (
    int	pos)
d369 4
a372 4
static int form_getstr (
	int		cur,
	BOOLEAN	use_last_tfpos,
	BOOLEAN	redraw_only)
d857 3
a859 3
void show_formlink_statusline (
    const FormInfo *	form,
    int		for_what)
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d25 1
a25 1
#define CTRL_W_HACK 23		/* CTRL-W refresh without clearok */
d28 4
a31 3
static int form_getstr(int cur,
		       BOOLEAN use_last_tfpos,
		       BOOLEAN redraw_only);
d36 2
a37 1
static char **options_list(OptionType * opt_ptr)
d61 7
a67 6
int change_form_link_ex(int cur,
			DocInfo *newdoc,
			BOOLEAN *refresh_screen,
			BOOLEAN use_last_tfpos,
			BOOLEAN immediate_submit,
			BOOLEAN redraw_only)
d78 1
a78 1
     * If there is no form to perform action on, don't do anything.
d81 1
a81 1
	return (c);
d86 1
a86 1
     * Move to the link position.
d90 6
a95 3
    switch (form->type) {
    case F_CHECKBOX_TYPE:
	if (form->disabled == YES)
a96 3
	LYSetHilite(cur, form->num_value ? unchecked_box : checked_box);
	form->num_value = !form->num_value;
	break;
d98 6
a103 6
    case F_OPTION_LIST_TYPE:
	if (form->select_list == 0) {
	    HTAlert(BAD_HTML_NO_POPUP);
	    c = DO_NOTHING;
	    break;
	}
d105 47
a151 12
	if (form->disabled == YES) {
	    int dummy;

	    dummy = LYhandlePopupList(form->num_value,
				      links[cur].ly,
				      links[cur].lx,
				      (const char **) my_data,
				      form->size,
				      form->size_l,
				      form->disabled,
				      FALSE,
				      FALSE);
d154 1
a154 1
		c = CTRL_W_HACK;	/* CTRL-W refresh without clearok */
d157 1
a157 1
		c = 12;		/* CTRL-L for repaint */
a158 14
	}
	OrigNumValue = form->num_value;
	form->num_value = LYhandlePopupList(form->num_value,
					    links[cur].ly,
					    links[cur].lx,
					    (const char **) my_data,
					    form->size,
					    form->size_l,
					    form->disabled,
					    FALSE,
					    FALSE);
	{
	    OptionType *opt_ptr = form->select_list;
	    int i;
d160 11
a170 42
	    for (i = 0; i < form->num_value; i++, opt_ptr = opt_ptr->next) ;	/* null body */
	    /*
	     * Set the name.
	     */
	    form->value = opt_ptr->name;
	    /*
	     * Set the value.
	     */
	    form->cp_submit_value = opt_ptr->cp_submit_value;
	    /*
	     * Set charset in which we have the submit value.  - kw
	     */
	    form->value_cs = opt_ptr->value_cs;
	}
#if CTRL_W_HACK != DO_NOTHING
	if (!enable_scrollback)
	    c = CTRL_W_HACK;	/* CTRL-W refresh without clearok */
	else
#endif
	    c = 12;		/* CTRL-L for repaint */
	break;

    case F_RADIO_TYPE:
	if (form->disabled == YES)
	    break;
	/*
	 * Radio buttons must have one and only one down at a time!
	 */
	if (form->num_value) {
	    HTUserMsg(NEED_CHECKED_RADIO_BUTTON);
	} else {
	    int i;

	    /*
	     * Run though list of the links on the screen and unselect any that
	     * are selected.  :)
	     */
	    lynx_start_radio_color();
	    for (i = 0; i < nlinks; i++) {
		if (links[i].type == WWW_FORM_LINK_TYPE
		    && links[i].l_form->type == F_RADIO_TYPE
		    && links[i].l_form->number == form->number
d172 2
a173 1
		 * If it has the same name and its on...
d175 14
a188 5
		    && !strcmp(links[i].l_form->name, form->name)
		    && links[i].l_form->num_value) {
		    LYmove(links[i].ly, links[i].lx);
		    LYaddstr(unchecked_radio);
		    LYSetHilite(i, unchecked_radio);
d190 9
d200 1
a200 11
	    lynx_stop_radio_color();
	    /*
	     * Will unselect other button and select this one.
	     */
	    HText_activateRadioButton(form);
	    /*
	     * Now highlight this one.
	     */
	    LYSetHilite(cur, checked_radio);
	}
	break;
d202 9
a210 9
    case F_FILE_TYPE:
    case F_TEXT_TYPE:
    case F_TEXTAREA_TYPE:
    case F_PASSWORD_TYPE:
	c = form_getstr(cur, use_last_tfpos, redraw_only);
	LYSetHilite(cur, (form->type == F_PASSWORD_TYPE)
		    ? STARS(strlen(form->value))
		    : form->value);
	break;
d212 5
a216 2
    case F_RESET_TYPE:
	if (form->disabled == YES)
a217 3
	HText_ResetForm(form);
	*refresh_screen = TRUE;
	break;
d219 11
a229 45
    case F_TEXT_SUBMIT_TYPE:
	if (redraw_only) {
	    c = form_getstr(cur, use_last_tfpos, TRUE);
	    break;
	}
	if (!immediate_submit)
	    c = form_getstr(cur, use_last_tfpos, FALSE);
	if (form->disabled == YES &&
	    (c == '\r' || c == '\n' || immediate_submit)) {
	    if (peek_mouse_link() >= 0)
		c = LAC_TO_LKC0(LYK_ACTIVATE);
	    else
		c = '\t';
	    break;
	}
	/*
	 * If immediate_submit is set, we didn't enter the line editor above,
	 * and will now try to call HText_SubmitForm() directly.  If
	 * immediate_submit is not set, c is the lynxkeycode returned from line
	 * editing.  Then if c indicates that a key was pressed that means we
	 * should submit, but with some extra considerations (i.e.  NOCACHE,
	 * DOWNLOAD, different from simple Enter), or if we should act on some
	 * *other* link selected with the mouse, we'll just return c and leave
	 * it to mainloop() to do the right thing; if everything checks out, it
	 * should call this function again, with immediate_submit set.
	 *
	 * If c indicates that line editing ended with Enter, we still defer to
	 * mainloop() for further checking if the submit action URL could
	 * require more checks than we do here.  Only in the remaining cases do
	 * we proceed to call HText_SubmitForm() directly before returning.  -
	 * kw
	 */
	if (immediate_submit ||
	    ((c == '\r' || c == '\n' || c == LAC_TO_LKC0(LYK_SUBMIT)) &&
	     peek_mouse_link() == -1)) {
	    LYSetHilite(cur, form->value);
#ifdef TEXT_SUBMIT_CONFIRM_WANTED
	    if (!immediate_submit && (c == '\r' || c == '\n') &&
		!HTConfirmDefault(NO_SUBMIT_BUTTON_QUERY), YES) {
		/* User was prompted and declined; if canceled with ^G
		 * let mainloop stay on this field, otherwise move on to
		 * the next field or link. - kw
		 */
		if (HTLastConfirmCancelled())
		    c = DO_NOTHING;
d231 1
a231 1
		    c = LAC_TO_LKC(LYK_NEXT_LINK);
d234 34
d269 32
a300 6
	    if (!form->submit_action || *form->submit_action == '\0') {
		HTUserMsg(NO_FORM_ACTION);
		c = DO_NOTHING;
		break;
	    } else if (form->submit_method == URL_MAIL_METHOD && no_mail) {
		HTAlert(FORM_MAILTO_DISALLOWED);
a302 6
	    } else if (!immediate_submit &&
		       ((no_file_url &&
			 isFILE_URL(form->submit_action)) ||
			!strncasecomp(form->submit_action, "lynx", 4))) {
		c = LAC_TO_LKC0(LYK_SUBMIT);
		break;
d304 1
a304 7
		if (form->no_cache &&
		    form->submit_method != URL_MAIL_METHOD) {
		    LYforce_no_cache = TRUE;
		    reloading = TRUE;
		}
		newdoc_changed =
		    HText_SubmitForm(form, newdoc, link_name, form->value);
d306 14
a319 1
	    if (form->submit_method == URL_MAIL_METHOD) {
d321 2
a322 4
	    } else {
		/*
		 * Returns new document URL.
		 */
a325 10
	    c = DO_NOTHING;
	    break;
	} else {
	    LYSetHilite(cur, form->value);
	}
	break;

    case F_SUBMIT_TYPE:
    case F_IMAGE_SUBMIT_TYPE:
	if (form->disabled == YES)
a326 15
	if (form->no_cache &&
	    form->submit_method != URL_MAIL_METHOD) {
	    LYforce_no_cache = TRUE;
	    reloading = TRUE;
	}
	newdoc_changed =
	    HText_SubmitForm(form, newdoc, link_name, link_value);
	if (form->submit_method == URL_MAIL_METHOD)
	    *refresh_screen = TRUE;
	else {
	    /* returns new document URL */
	    newdoc->link = 0;
	    newdoc->internal_link = FALSE;
	}
	break;
d334 3
a336 3
	 * These flags may have been set in mainloop, anticipating that a
	 * request will be submitted.  But if we haven't filled in newdoc, that
	 * won't actually be the case, so unset them.  - kw
d342 1
a342 1
    return (c);
d345 6
a350 5
int change_form_link(int cur,
		     DocInfo *newdoc,
		     BOOLEAN *refresh_screen,
		     BOOLEAN use_last_tfpos,
		     BOOLEAN immediate_submit)
d352 1
a352 1
    /*pass all our args and FALSE as last arg */
d358 1
a358 1
			       FALSE /*redraw_only */ );
d363 2
a364 1
static void LYSetLastTFPos(int pos)
d369 4
a372 3
static int form_getstr(int cur,
		       BOOLEAN use_last_tfpos,
		       BOOLEAN redraw_only)
a382 1

d388 1
a388 1
    BOOLEAN Edited = FALSE;	/* Value might be updated? */
d391 1
a391 1
     * Get the initial position of the cursor.
d400 1
a400 1
     * Make sure the form field value does not exceed our buffer.  - FM
d404 3
a406 3
		  form->maxlength :
		  (sizeof(MyEdit.buffer) - 1));
    if (strlen(form->value) > (size_t) max_length) {
d408 2
a409 2
	 * We can't fit the entire value into the editing buffer, so enter as
	 * much of the tail as fits.  - FM
d415 1
a415 1
	     * If we can edit it, report that we are using the tail.  - FM
d418 1
a418 1
	    show_formlink_statusline(form, redraw_only ? FOR_PANEL : FOR_INPUT);
d424 1
a424 1
     * Print panned line
d464 1
a464 1
	return 0;		/*return value won't be analysed */
d467 1
a467 1
     * And go for it!
d470 1
a470 1
      again:
d477 1
a477 1
	    && (EditBinding(ch) != LYE_CHAR)
d479 1
a479 1
	    && (EditBinding(ch) != LYE_AIX)
d494 3
a496 3
	if (ch != -1 && (ch & LKC_ISLAC) && !(ch & LKC_ISLECLAC))	/* already lynxactioncode? */
	    break;		/* @@@@@@ maybe move these 2 lines outside ifdef -kw */
	if (ch == MOUSE_KEY) {	/* Need to process ourselves */
d506 1
a506 1
		    repeat = -repeat;
d511 1
a511 1
	    MEVENT event;
d520 1
a520 1
		    repeat = -repeat;
d526 6
a531 6
		/* Mouse event passed to us as MOUSE_KEY, and apparently not on
		 * this field's line?  Something is not as it should be...
		 *
		 * A call to statusline() may have happened, possibly from
		 * within a mouse menu.  Let's at least make sure here that the
		 * cursor position gets restored.  - kw
d537 1
a537 1
#  endif			/* NCURSES || PDCURSES */
d564 1
a564 1
	     * Set flag for modifier 1.
d571 1
a571 1
	     * Set flag for modifier 2.
d577 2
a578 2
	 * Filter out global navigation keys that should not be passed to line
	 * editor, and LYK_REFRESH.
d599 1
d615 1
a615 1
		    if (*e1 < ' ') {	/* Stop here? */
d619 2
a620 3
			if (*e1 == '\t') {	/* Replace by space */
			    LYEditInsert(&MyEdit, (unsigned char *) " ", 1,
					 -1, TRUE);
d632 1
a632 1
		    StrAllocCopy(buf, (char *) e1 + 1);		/* Survive _release() */
d647 1
a647 1
		    ch = '\n';	/* Sometimes moves to the next line */
d663 1
a663 1
	    ch = (int) ('\t');
d667 1
a667 1
	    return (DO_NOTHING);
d680 1
a680 1
	if (action == LYE_NOP && LKC_TO_LAC(keymap, ch) == LYK_REFRESH)
d690 20
a709 12
	default:
	    /* [ 1999/04/14 (Wed) 15:01:33 ]
	     * Left arrrow in column 0 deserves special treatment here, else
	     * you can get trapped in a form without submit button!
	     */
	    if (action == LYE_BACK && MyEdit.pos == 0 && repeat == -1) {
		int c = YES;	/* Go back immediately if no changes */

		if (textfield_prompt_at_left_edge) {
		    c = HTConfirmDefault(PREV_DOC_QUERY, NO);
		} else if (strcmp(MyEdit.buffer, value)) {
		    c = HTConfirmDefault(PREV_DOC_QUERY, NO);
d711 15
a725 24
		if (c == YES) {
		    return (ch);
		} else {
		    if (form->disabled == YES)
			_statusline(ARROWS_OR_TAB_TO_MOVE);
		    else
			_statusline(ENTER_TEXT_ARROWS_OR_TAB);
		}
	    }
	    if (form->disabled == YES) {
		/*
		 * Allow actions that don't modify the contents even in
		 * disabled form fields, so the user can scroll through the
		 * line for reading if necessary.  - kw
		 */
		switch (action) {
		case LYE_BOL:
		case LYE_EOL:
		case LYE_FORW:
		case LYE_FORW_RL:
		case LYE_BACK:
		case LYE_BACK_LL:
		case LYE_FORWW:
		case LYE_BACKW:
d727 1
a727 1
		case LYE_SWMAP:
d730 2
a731 2
		case LYE_SETMARK:
		case LYE_XPMARK:
d733 4
a736 36
		    break;
		default:
		    goto again;
		}
	    }
	    /*
	     * Make sure the statusline uses editmode help.
	     */
	    if (repeat < 0)
		repeat = 1;
	    while (repeat--) {
		int rc = LYEdit1(&MyEdit, ch, action & ~LYE_DF, TRUE);

		if (rc < 0) {
		    ch = -rc;
		    /* FORW_RL and BACK_LL may require special attention.
		       BACK_LL wanted to switch to the previous link on
		       the same line.  However, if there is no such link,
		       then we would either disactivate the form
		       (with -tna), or will reenter the form, thus we jump
		       to the end of the line; both are counterintuitive.
		       Unfortunately, we do not have access to curdoc.link,
		       so we deduce it ourselves.  We don't have the info
		       to do it inside LYLineEdit().
		       This should work for prompts too.  */
		    if ((action != LYE_BACK_LL && action != LYE_FORW_RL)
			|| (cur >= 0
			    && cur < nlinks
			    && (action == LYE_FORW_RL
				? cur < nlinks - 1
				: cur > 0)
			    && links[cur + ((action == LYE_FORW_RL)
					    ? 1
					    : -1)].ly
			    == links[cur].ly))
			goto breakfor;
d738 32
d771 2
a772 2
		if (rc == 0) {
		    if (HTCJK != NOCJK && (0x80 <= ch)
d774 7
a780 6
			refresh_mb = FALSE;
		    else
			refresh_mb = TRUE;
		} else {
		    if (!refresh_mb) {
			LYEdit1(&MyEdit, 0, LYE_DELP, TRUE);
d782 11
a793 12
#endif /* SUPPORT_MULTIBYTE_EDIT */
	    }
	    if (MyEdit.strlen >= max_length) {
		HaveMaxlength = TRUE;
	    } else if (HaveMaxlength &&
		       MyEdit.strlen < max_length) {
		HaveMaxlength = FALSE;
		_statusline(ENTER_TEXT_ARROWS_OR_TAB);
	    }
	    if (strcmp(value, MyEdit.buffer)) {
		Edited = TRUE;
	    }
d795 1
a795 1
	    if (refresh_mb)
d798 1
a798 1
	    LYSetLastTFPos(MyEdit.pos);
d803 1
a803 1
	char *p;
d806 1
a806 1
	 * Load the new value.
d810 2
a811 2
	     * The previous value did fit in the line buffer, so replace it
	     * with the new value.  - FM
d816 1
a816 1
	     * Combine the modified tail with the unmodified head.  - FM
d825 1
a825 1
	 * Remove trailing spaces
d827 4
a830 4
	 * Do we really need to do that here?  Trailing spaces will only be
	 * there if user keyed them in.  Rather rude to throw away their hard
	 * earned spaces.  Better deal with trailing spaces when submitting the
	 * form????
d840 7
a846 6
	 * If the field has been changed, assume that it is now in current
	 * display character set, even if for some reason it wasn't!  Hopefully
	 * a user will only submit the form if the non-ASCII characters are
	 * displayed correctly, which means (assuming that the display
	 * character set has been set truthfully) the user confirms by changing
	 * the field that the character encoding is right.  - kw
d851 1
a851 1
    return (ch);
d855 1
a855 1
 * Display statusline info tailored for the current form field.
d857 3
a859 2
void show_formlink_statusline(const FormInfo * form,
			      int for_what)
d861 1
a861 1
    switch (form->type) {
d867 3
a869 3
	if (for_what == FOR_PANEL)
	    statusline(FORM_LINK_PASSWORD_MESSAGE_INA);
	else
d900 3
a902 3
	    if (for_what == FOR_PANEL)
		statusline(FORM_TEXT_SUBMIT_MAILTO_MSG_INA);
	    else
d911 1
a911 1
		statusline(FORM_LINK_TEXT_RESUBMIT_MESSAGE);
a914 1

d932 1
a932 1
		    statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE);
d946 1
a946 1
		if (user_mode == ADVANCED_MODE) {
d958 1
a958 1
	    if (user_mode == ADVANCED_MODE) {
d969 1
a969 1
	    if (user_mode == ADVANCED_MODE) {
d998 3
a1000 3
	if (for_what == FOR_PANEL)
	    statusline(FORM_LINK_TEXT_MESSAGE_INA);
	else
a1009 1

@


1.1.3.5
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d390 2
a391 2
    if ((startcol + form->size) > LYcolLimit)
	far_col = LYcolLimit;
@


1.1.3.6
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d844 1
a844 1
	if (non_empty(form->value))
d911 1
a911 1
	    if (non_empty(xkey_info)) {
d1014 1
a1014 1
	    if (non_empty(xkey_info)) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a8 1
#include <LYGlobalDefs.h>
d10 1
d12 1
d23 1
a23 5
#if defined(VMS) && !defined(USE_SLANG)
#define CTRL_W_HACK DO_NOTHING
#else
#define CTRL_W_HACK 23  /* CTRL-W refresh without clearok */
#endif /* VMS && !USE_SLANG */
d26 9
a34 31
	struct link *	form_link,
	BOOLEAN		use_last_tfpos,
	BOOLEAN		redraw_only));

/*
 * Returns an array of pointers to the given list
 */
PRIVATE char ** options_list ARGS1(
	OptionType *,	opt_ptr)
{
    char **result = 0;
    size_t len;
    int pass;
    OptionType *tmp_ptr;

    for (pass = 0; pass < 2; pass++) {
	for (tmp_ptr = opt_ptr, len = 0; tmp_ptr != 0; tmp_ptr = tmp_ptr->next) {
	    if (pass != 0)
		result[len] = tmp_ptr->name;
	    len++;
	}
	if (pass == 0) {
	    len++;
	    result = typecallocn(char *, len);
	} else {
	    result[len] = 0;
	}
    }

    return result;
}
d36 1
a36 1
PUBLIC int change_form_link_ex ARGS8(
d41 1
a41 4
	char *,		link_value,
	BOOLEAN,	use_last_tfpos,
	BOOLEAN,	immediate_submit,
	BOOLEAN,	redraw_only)
a43 1
    int newdoc_changed = 0;
a45 1
    char **my_data = 0;
d47 6
a52 7
    /*
     *  If there is no form to perform action on, don't do anything.
     */
    if (form == NULL) {
	return(c);
    }
    my_data = options_list(form->select_list);
d57 1
a57 1
    LYmove(form_link->ly, form_link->lx);
d73 1
a73 1
	    if (form->select_list == 0) {
d81 4
a84 10
		dummy = LYhandlePopupList(form->num_value,
					  form_link->ly,
					  form_link->lx,
					  (CONST char **)my_data,
					  form->size,
					  form->size_l,
					  form->disabled,
					  FALSE,
					  FALSE);
#if CTRL_W_HACK != DO_NOTHING
d86 5
a90 1
		    c = CTRL_W_HACK;  /* CTRL-W refresh without clearok */
d92 1
a92 1
#endif
d97 4
a100 9
	    form->num_value = LYhandlePopupList(form->num_value,
						form_link->ly,
						form_link->lx,
						(CONST char **)my_data,
						form->size,
						form->size_l,
						form->disabled,
						FALSE,
						FALSE);
d119 1
a119 1
#if CTRL_W_HACK != DO_NOTHING
d121 6
a126 1
		c = CTRL_W_HACK;	 /* CTRL-W refresh without clearok */
d128 3
a130 3
#endif
		c = 12;	 /* CTRL-L for repaint */
	    break;
d157 2
a158 2
			LYmove(links[i].ly, links[i].lx);
			LYaddstr(unchecked_radio);
a173 1
	case F_FILE_TYPE:
d177 1
a177 1
	    c = form_getstr(form_link, use_last_tfpos, redraw_only);
d192 1
a192 6
	    if (redraw_only) {
		c = form_getstr(form_link, use_last_tfpos, TRUE);
		break;
	    }
	    if (!immediate_submit)
		c = form_getstr(form_link, use_last_tfpos, FALSE);
d194 2
a195 5
		(c == '\r' || c == '\n' || immediate_submit)) {
		if (peek_mouse_link() >= 0)
		    c = LAC_TO_LKC0(LYK_ACTIVATE);
		else
		    c = '\t';
d198 1
a198 20
	    /*
	     *  If immediate_submit is set, we didn't enter the line editor
	     *  above, and will now try to call HText_SubmitForm() directly.
	     *  If immediate_submit is not set, c is the lynxkeycode returned
	     *  from line editing.   Then if c indicates that a key was pressed
	     *  that means we should submit, but with some extra considerations
	     *  (i.e. NOCACHE, DOWNLOAD, different from simple Enter), or if
	     *  we should act on some *other* link selected with the mouse,
	     *  we'll just return c and leave it to mainloop() to do the
	     *  right thing; if everything checks out, it should call this
	     *  function again, with immediate_submit set.
	     *  If c indicates that line editing ended with Enter, we still
	     *  defer to mainloop() for further checking if the submit
	     *  action URL could require more checks than we do here.
	     *  Only in the remaining cases do we proceed to call
	     *  HText_SubmitForm() directly before returning. - kw
	     */
	    if (immediate_submit ||
		((c == '\r' || c == '\n' || c == LAC_TO_LKC0(LYK_SUBMIT)) &&
		 peek_mouse_link() == -1)) {
a199 14
#ifdef TEXT_SUBMIT_CONFIRM_WANTED
		if (!immediate_submit && (c == '\r' || c == '\n') &&
		    !HTConfirmDefault(NO_SUBMIT_BUTTON_QUERY), YES) {
		    /* User was prompted and declined; if canceled with ^G
		     * let mainloop stay on this field, otherwise move on to
		     * the next field or link. - kw
		     */
		    if (HTLastConfirmCancelled())
			c = DO_NOTHING;
		    else
			c = LAC_TO_LKC(LYK_NEXT_LINK);
		    break;
		}
#endif
a207 6
		} else if (!immediate_submit &&
			   ((no_file_url &&
			     !strncasecomp(form->submit_action, "file:", 5)) ||
			    !strncasecomp(form->submit_action, "lynx", 4))) {
		    c = LAC_TO_LKC0(LYK_SUBMIT);
		    break;
d214 1
a214 2
		    newdoc_changed =
			HText_SubmitForm(form, newdoc, link_name, form->value);
d241 1
a241 2
	    newdoc_changed =
		HText_SubmitForm(form, newdoc, link_name, link_value);
a252 12
    if (newdoc_changed) {
	c = LKC_DONE;
    } else {
	/*
	 *  These flags may have been set in mainloop, anticipating that
	 *  a request will be submitted.  But if we haven't filled in
	 *  newdoc, that won't actually be the case, so unset them. - kw
	 */
	LYforce_no_cache = FALSE;
	reloading = FALSE;
    }
    FREE(my_data);
d256 2
a257 26
PUBLIC int change_form_link ARGS7(
	struct link *,	form_link,
	document *,	newdoc,
	BOOLEAN *,	refresh_screen,
	char *,		link_name,
	char *,		link_value,
	BOOLEAN,	use_last_tfpos,
	BOOLEAN,	immediate_submit)
{
    /*pass all our args and FALSE as last arg*/
    return change_form_link_ex(form_link,newdoc,refresh_screen,link_name,
	link_value,use_last_tfpos,immediate_submit, FALSE /*redraw_only*/ );
}

PRIVATE int LastTFPos = -1;	/* remember last text field position */

PRIVATE void LYSetLastTFPos ARGS1(
    int,	pos)
{
    LastTFPos = pos;
}

PRIVATE int form_getstr ARGS3(
	struct link *,	form_link,
	BOOLEAN,	use_last_tfpos,
	BOOLEAN,	redraw_only)
d266 1
a266 5
    int action, repeat;
    int last_xlkc = -1;
#ifdef SUPPORT_MULTIBYTE_EDIT
    BOOL refresh_mb = TRUE;
#endif
d299 23
a321 2
	    show_formlink_statusline(form, redraw_only? FOR_PANEL : FOR_INPUT);
	    LYmove(startline, startcol);
d330 1
a330 34
    MyEdit.hidden = (BOOL) (form->type == F_PASSWORD_TYPE);
    if (use_last_tfpos && LastTFPos >= 0 && LastTFPos < MyEdit.strlen) {
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
	if (redraw_only) {
	    if (!(MyEdit.strlen >= MyEdit.dspwdth &&
		  LastTFPos >= MyEdit.dspwdth - MyEdit.margin)) {
		MyEdit.pos = LastTFPos;
		if (MyEdit.strlen >= MyEdit.dspwdth)
		    textinput_redrawn = FALSE;
	    }
	} else
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
	    MyEdit.pos = LastTFPos;
#ifdef ENHANCED_LINEEDIT
	if (MyEdit.pos == 0)
	    MyEdit.mark = -1 - MyEdit.strlen;	/* Do not show the region. */
#endif
    }
    /* Try to prepare for setting position based on the last mouse event */
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
    if (!redraw_only) {
	if (peek_mouse_levent()) {
	    if (!use_last_tfpos && !textinput_redrawn) {
		MyEdit.pos = 0;
	    }
	}
	textinput_redrawn = FALSE;
    }
#else
    if (peek_mouse_levent()) {
	if (!use_last_tfpos)
	    MyEdit.pos = 0;
    }
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
a331 2
    if (redraw_only)
	return 0;		/*return value won't be analysed*/
d339 4
a342 1
	get_mouse_link();	/* Reset mouse_link. */
d344 1
a344 10
	ch = LYgetch_input();
#ifdef SUPPORT_MULTIBYTE_EDIT
	if (!refresh_mb
	 && (EditBinding(ch) != LYE_CHAR)
#ifndef WIN_EX
	 && (EditBinding(ch) != LYE_AIX)
#endif
	    )
	    goto again;
#endif /* SUPPORT_MULTIBYTE_EDIT */
d348 1
a348 1
	    ch = LYCharINTERRUPT2;
d351 1
a351 6

	action = 0;
#ifdef USE_MOUSE
#  if defined(NCURSES) || defined(PDCURSES)
	if (ch != -1 && (ch & LKC_ISLAC) && !(ch & LKC_ISLECLAC)) /* already lynxactioncode? */
	    break;	/* @@@@@@ maybe move these 2 lines outside ifdef -kw */
a352 14
#if defined(PDCURSES)
	    int curx, cury;

	    request_mouse_pos();
	    LYGetYX(cury, curx);
	    if (MOUSE_Y_POS == cury) {
		repeat = MOUSE_X_POS - curx;
		if (repeat < 0) {
		    action = LYE_BACK;
		    repeat = - repeat;
		} else
		    action = LYE_FORW;
	    }
#else
d361 1
a361 1
		    action = LYE_BACK;
d364 1
a364 26
		    action = LYE_FORW;
	    }
#endif /* PDCURSES */
	    else {
		/*  Mouse event passed to us as MOUSE_KEY, and apparently
		 *  not on this field's line?  Something is not as it
		 *  should be...
		 *  A call to statusline() may have happened, possibly from
		 *  within a mouse menu.  Let's at least make sure here
		 *  that the cursor position gets restored.  - kw
		 */
		MyEdit.dirty = TRUE;
	    }
	    last_xlkc = -1;
	} else
#  endif     /* NCURSES || PDCURSES */
#endif /* USE_MOUSE */

	{
	    if (!(ch & LKC_ISLECLAC))
		ch |= MyEdit.current_modifiers;
	    MyEdit.current_modifiers = 0;
	    if (last_xlkc != -1) {
		if (ch == last_xlkc)
		    ch |= LKC_MOD3;
		last_xlkc = -1;	/* consumed */
d367 1
a369 24

	if (!action)
	    action = EditBinding(ch);
	if ((action & LYE_DF) && !(action & LYE_FORM_LAC)) {
	    last_xlkc = ch;
	    action &= ~LYE_DF;
	} else {
	    last_xlkc = -1;
	}

	if (action == LYE_SETM1) {
	    /*
	     *  Set flag for modifier 1.
	     */
	    MyEdit.current_modifiers |= LKC_MOD1;
	    continue;
	}
	if (action == LYE_SETM2) {
	    /*
	     *  Set flag for modifier 2.
	     */
	    MyEdit.current_modifiers |= LKC_MOD2;
	    continue;
	}
d374 1
a378 4
	if (action & LYE_FORM_LAC) {
	    ch = (action & LAC_MASK) | LKC_ISLAC;
	    break;
	}
d385 1
a385 1
		ch = LYCharINTERRUPT2;
a389 59

#ifdef CAN_CUT_AND_PASTE	/* 1998/10/01 (Thu) 19:19:22 */
	if (action == LYE_PASTE) {
	    unsigned char *s = get_clip_grab(), *e;
	    char *buf = NULL;
	    int len;

	    if (!s)
		break;
	    len = strlen(s);
	    e = s + len;

	    if (len > 0) {
		unsigned char *e1 = s;

		while (e1 < e) {
		    if (*e1 < ' ') { /* Stop here? */
			if (e1 > s)
			    LYEditInsert(&MyEdit, s, e1 - s, -1, TRUE);
			s = e1;
			if (*e1 == '\t') { /* Replace by space */
			    LYEditInsert(&MyEdit, " ", 1, -1, TRUE);
			    s = ++e1;
			} else
			    break;
		    } else
			++e1;
		}
		if (e1 > s)
		    LYEditInsert(&MyEdit, s, e1 - s, -1, TRUE);
		while (e1 < e && *e1 == '\r')
		    e1++;
		if (e1 + 1 < e && *e1 == '\n')
		    StrAllocCopy(buf, e1 + 1);	/* Survive _release() */
		get_clip_release();
		if (MyEdit.strlen >= max_length) {
		    HaveMaxlength = TRUE;
		} else if (HaveMaxlength &&
			   MyEdit.strlen < max_length) {
		    HaveMaxlength = FALSE;
		    _statusline(ENTER_TEXT_ARROWS_OR_TAB);
		}
		if (strcmp(value, MyEdit.buffer) != 0) {
		    Edited = TRUE;
		}
		if (buf) {
		    put_clip(buf);
		    FREE(buf);
		    ch = '\n';		/* Sometimes moves to the next line */
		    break;
		}
		LYRefreshEdit(&MyEdit);
	    } else {
		HTInfoMsg("Clipboard empty or Not text data.");
		continue;
	    }
	}
#endif
#ifndef WIN_EX
a392 1
#endif
d400 1
a400 12
	if (action == LYE_STOP) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    textfields_need_activation = TRUE;
	    break;
#else
#ifdef ENHANCED_LINEEDIT
	    if (MyEdit.mark >= 0)
		MyEdit.mark = -1 - MyEdit.strlen;	/* Disable. */
#endif
#endif
	}
	if (action == LYE_NOP && LKC_TO_LAC(keymap,ch) == LYK_REFRESH)
a401 7
#ifdef SH_EX
/* ASATAKU emacskey hack 1997/08/26 (Tue) 09:19:23 */
	if (emacs_keys &&
	    (EditBinding(ch) == LYE_FORWW || EditBinding(ch) == LYE_BACKW))
	    goto breakfor;
/* ASATAKU emacskey hack */
#endif
d403 13
a415 2
	    default:
	    /*	[ 1999/04/14 (Wed) 15:01:33 ]
d419 2
a420 1
		if (action == LYE_BACK && MyEdit.pos == 0 && repeat == -1) {
d422 1
a422 3
		    if (textfield_prompt_at_left_edge) {
			c = HTConfirmDefault(PREV_DOC_QUERY, NO);
		    } else if (strcmp(MyEdit.buffer, value)) {
d434 5
a438 27
		if (form->disabled == YES) {
		    /*
		     *  Allow actions that don't modify the contents even
		     *  in disabled form fields, so the user can scroll
		     *  through the line for reading if necessary. - kw
		     */
		    switch(action) {
		    case LYE_BOL:
		    case LYE_EOL:
		    case LYE_FORW:
		    case LYE_FORW_RL:
		    case LYE_BACK:
		    case LYE_BACK_LL:
		    case LYE_FORWW:
		    case LYE_BACKW:
#ifdef EXP_KEYBOARD_LAYOUT
		    case LYE_SWMAP:
#endif
#ifdef ENHANCED_LINEEDIT
		    case LYE_SETMARK:
		    case LYE_XPMARK:
#endif
			break;
		    default:
			goto again;
		    }
		}
d444 2
a445 39
		while (repeat--) {
		    int rc = LYEdit1(&MyEdit, ch, action & ~LYE_DF, TRUE);

		    if (rc < 0) {
			ch = -rc;
			/* FORW_RL and BACK_LL may require special attention.
			   BACK_LL wanted to switch to the previous link on
			   the same line.  However, if there is no such link,
			   then we would either disactivate the form
			   (with -tna), or will reenter the form, thus we jump
			   to the end of the line; both are counterintuitive.
			   Unfortunately, we do not have access to curdoc.link,
			   so we deduce it ourselves.  We don't have the info
			   to do it inside LYLineEdit().
			   This should work for prompts too.  */
			if ( (action != LYE_BACK_LL && action != LYE_FORW_RL)
			     || ((form_link - links) >= 0
				&& (form_link - links) < nlinks
				&& (action==LYE_FORW_RL
				    ? (form_link - links) < nlinks - 1
				    : (form_link - links) > 0)
				&& form_link[action==LYE_FORW_RL ? 1 : -1].ly
				   == form_link->ly))
			    goto breakfor;
		    }
#ifdef SUPPORT_MULTIBYTE_EDIT
		    if (rc == 0) {
			if (HTCJK != NOCJK && (0x80 <= ch)
			&& (ch <= 0xfe) && refresh_mb)
			    refresh_mb = FALSE;
			else
			    refresh_mb = TRUE;
		    } else {
			if (!refresh_mb) {
			    LYEdit1(&MyEdit, 0, LYE_DELP, TRUE);
			}
		    }
#endif /* SUPPORT_MULTIBYTE_EDIT */
		}
a455 3
#ifdef SUPPORT_MULTIBYTE_EDIT
		if (refresh_mb)
#endif
a456 1
		LYSetLastTFPos(MyEdit.pos);
d459 3
a461 1
  breakfor:
a482 1
	/* 2.8.4pre.3 - most browsers appear to preserve trailing spaces -VH */
d491 4
a494 6
	if (LYtrimInputFields) {
	    p = &(form->value[strlen(form->value)]);
	    while ((p != form->value) && (p[-1] == ' '))
		p--;
	    *p = '\0';
	}
d512 7
a518 5
 *  Display statusline info tailored for the current form field.
 */
PUBLIC void show_formlink_statusline ARGS2(
    CONST FormInfo *,	form,
    int,		for_what)
d520 29
a548 11
    switch(form->type) {
    case F_PASSWORD_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_PASSWORD_UNM_MSG);
	else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (for_what == FOR_PANEL)
		statusline(FORM_LINK_PASSWORD_MESSAGE_INA);
	    else
#endif
	    statusline(FORM_LINK_PASSWORD_MESSAGE);
d550 4
a553 5
    case F_OPTION_LIST_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
	else
	    statusline(FORM_LINK_OPTION_LIST_MESSAGE);
d555 36
a590 24
    case F_CHECKBOX_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_CHECKBOX_UNM_MSG);
	else
	    statusline(FORM_LINK_CHECKBOX_MESSAGE);
	break;
    case F_RADIO_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_RADIO_UNM_MSG);
	else
	    statusline(FORM_LINK_RADIO_MESSAGE);
	break;
    case F_TEXT_SUBMIT_TYPE:
	if (form->disabled == YES) {
	    statusline(FORM_LINK_TEXT_SUBMIT_UNM_MSG);
	} else if (form->submit_method ==
		   URL_MAIL_METHOD) {
	    if (no_mail)
		statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_DIS_MSG);
	    else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    statusline(FORM_TEXT_SUBMIT_MAILTO_MSG_INA);
		else
d592 113
a704 8
		statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_MSG);
	} else if (form->no_cache) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (for_what == FOR_PANEL)
		statusline(FORM_TEXT_RESUBMIT_MESSAGE_INA);
	    else
#endif
	    statusline(FORM_LINK_TEXT_RESUBMIT_MESSAGE);
d706 8
a713 22
	    char *submit_str = NULL;
	    char *xkey_info = key_for_func_ext(LYK_NOCACHE, for_what);
	    if (xkey_info && *xkey_info) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    HTSprintf0(&submit_str, FORM_TEXT_SUBMIT_MESSAGE_INA_X,
			       xkey_info);
		else
#endif
		    HTSprintf0(&submit_str, FORM_LINK_TEXT_SUBMIT_MESSAGE_X,
			       xkey_info);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE_INA);
		else
#endif
		statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE);
	    }
	    FREE(xkey_info);
d715 6
a720 12
	break;
    case F_SUBMIT_TYPE:
    case F_IMAGE_SUBMIT_TYPE:
	if (form->disabled == YES) {
	    statusline(FORM_LINK_SUBMIT_DIS_MSG);
	} else if (form->submit_method ==
		   URL_MAIL_METHOD) {
	    if (no_mail) {
		statusline(FORM_LINK_SUBMIT_MAILTO_DIS_MSG);
	    } else {
		if(user_mode == ADVANCED_MODE) {
		    char *submit_str = NULL;
d722 9
a730 22
		    StrAllocCopy(submit_str, FORM_LINK_SUBMIT_MAILTO_PREFIX);
		    StrAllocCat(submit_str, form->submit_action);
		    statusline(submit_str);
		    FREE(submit_str);
		} else {
		    statusline(FORM_LINK_SUBMIT_MAILTO_MSG);
		}
	    }
	} else if (form->no_cache) {
	    if(user_mode == ADVANCED_MODE) {
		char *submit_str = NULL;

		StrAllocCopy(submit_str, FORM_LINK_RESUBMIT_PREFIX);
		StrAllocCat(submit_str, form->submit_action);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
		statusline(FORM_LINK_RESUBMIT_MESSAGE);
	    }
	} else {
	    if(user_mode == ADVANCED_MODE) {
		char *submit_str = NULL;
d732 18
a749 29
		StrAllocCopy(submit_str, FORM_LINK_SUBMIT_PREFIX);
		StrAllocCat(submit_str, form->submit_action);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
		statusline(FORM_LINK_SUBMIT_MESSAGE);
	    }
	}
	break;
    case F_RESET_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_RESET_DIS_MSG);
	else
	    statusline(FORM_LINK_RESET_MESSAGE);
	break;
    case F_FILE_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_FILE_UNM_MSG);
	else
	    statusline(FORM_LINK_FILE_MESSAGE);
	break;
    case F_TEXT_TYPE:
	if (form->disabled == YES)
	    statusline(FORM_LINK_TEXT_UNM_MSG);
	else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (for_what == FOR_PANEL)
		statusline(FORM_LINK_TEXT_MESSAGE_INA);
	    else
d751 3
a753 13
	    statusline(FORM_LINK_TEXT_MESSAGE);
	break;
    case F_TEXTAREA_TYPE:
	if (form->disabled == YES) {
	    statusline(FORM_LINK_TEXT_UNM_MSG);
	} else {
	    char *submit_str = NULL;
	    char *xkey_info = NULL;
	    if (!no_editor && editor && editor) {
		xkey_info = key_for_func_ext(LYK_EDIT_TEXTAREA, for_what);
#ifdef TEXTAREA_AUTOEXTEDIT
		if (!xkey_info)
		    xkey_info = key_for_func_ext(LYK_DWIMEDIT, for_what);
d755 127
a881 7
	    }
	    if (xkey_info && *xkey_info) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    HTSprintf0(&submit_str, FORM_LINK_TEXTAREA_MESSAGE_INA_E,
			       xkey_info);
		else
d883 649
a1531 8
		    HTSprintf0(&submit_str, FORM_LINK_TEXTAREA_MESSAGE_E,
			       xkey_info);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    statusline(FORM_LINK_TEXTAREA_MESSAGE_INA);
d1533 18
a1550 4
#endif
		    statusline(FORM_LINK_TEXTAREA_MESSAGE);
	    }
	    FREE(xkey_info);
d1552 1
a1552 1
	break;
d1554 8
@

