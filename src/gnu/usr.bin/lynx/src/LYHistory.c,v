head	1.4;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.5
	tg-mergefixes-1-branch:1.1.3.5.0.4
	tg-mergefixes-1-base:1.1.3.5
	MIROS_X:1.1.3.5.0.2
	MIROS_X_BASE:1.1.3.5
	MIRBSD_XP_MIRPPC:1.1.3.4.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.1.3.4
	MIRBSD_XP_SPARC:1.1.3.4.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2005.01.03.00.45.57;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.34;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.31;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.22;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.53;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.14;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.08.13.10.01;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.51;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.51.41;	author tg;	state Stab;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.20.10.10.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@soft merge
@
text
@#include <HTUtils.h>
#include <HTTP.h>
#include <GridText.h>
#include <HTAlert.h>
#include <HText.h>
#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <LYHistory.h>
#include <LYPrint.h>
#include <LYDownload.h>
#include <LYOptions.h>
#include <LYKeymap.h>
#include <LYList.h>
#include <LYShowInfo.h>
#include <LYStrings.h>
#include <LYCharUtils.h>
#include <LYCharSets.h>
#include <LYrcFile.h>
#ifdef DISP_PARTIAL
#include <LYMainLoop.h>
#endif

#ifdef DIRED_SUPPORT
#include <LYUpload.h>
#include <LYLocal.h>
#endif /* DIRED_SUPPORT */

#include <LYexit.h>
#include <LYLeaks.h>
#include <HTCJK.h>

static HTList *Visited_Links = NULL;	/* List of safe popped docs. */
int Visited_Links_As = VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE;
static VisitedLink *PrevVisitedLink = NULL;	/* NULL on auxillary */
static VisitedLink *PrevActiveVisitedLink = NULL;	/* Last non-auxillary */
static VisitedLink Latest_first;
static VisitedLink Latest_last;
static VisitedLink *Latest_tree;
static VisitedLink *First_tree;
static VisitedLink *Last_by_first;

int nhist_extra;

#ifdef LY_FIND_LEAKS
static int already_registered_free_messages_stack = 0;
static int already_registered_clean_all_history = 0;
#endif

#ifdef LY_FIND_LEAKS
/*
 * Utility for freeing the list of visited links.  - FM
 */
static void Visited_Links_free(void)
{
    VisitedLink *vl;
    HTList *cur = Visited_Links;

    PrevVisitedLink = NULL;
    PrevActiveVisitedLink = NULL;
    if (!cur)
	return;

    while (NULL != (vl = (VisitedLink *) HTList_nextObject(cur))) {
	FREE(vl->address);
	FREE(vl->title);
	FREE(vl);
    }
    HTList_delete(Visited_Links);
    Visited_Links = NULL;
    Latest_last.prev_latest = &Latest_first;
    Latest_first.next_latest = &Latest_last;
    Last_by_first = Latest_tree = First_tree = 0;
    return;
}
#endif /* LY_FIND_LEAKS */

#ifdef DEBUG
static void trace_history(const char *tag)
{
    if (TRACE) {
	CTRACE((tfp, "HISTORY %s %d/%d (%d extra)\n",
		tag, nhist, size_history, nhist_extra));
	CTRACE_FLUSH(tfp);
    }
}
#else
#define trace_history(tag)	/* nothing */
#endif /* DEBUG */

/*
 * Utility for listing visited links, making any repeated links the most
 * current in the list.  - FM
 */
void LYAddVisitedLink(DocInfo *doc)
{
    VisitedLink *tmp;
    HTList *cur;
    const char *title = (doc->title ? doc->title : NO_TITLE);

    if (isEmpty(doc->address)) {
	PrevVisitedLink = NULL;
	return;
    }

    /*
     * Exclude POST or HEAD replies, and bookmark, menu or list files.  - FM
     */
    if (doc->post_data || doc->isHEAD || doc->bookmark ||
	(			/* special url or a temp file */
	    (!strncmp(doc->address, "LYNX", 4) ||
	     !strncmp(doc->address, "file://localhost/", 17)))) {
	int related = 1;	/* First approximation only */

	if (LYIsUIPage(doc->address, UIP_HISTORY) ||
	    LYIsUIPage(doc->address, UIP_VLINKS) ||
	    LYIsUIPage(doc->address, UIP_SHOWINFO) ||
	    isLYNXMESSAGES(doc->address) ||
	    (related = 0) ||
#ifdef DIRED_SUPPORT
	    LYIsUIPage(doc->address, UIP_DIRED_MENU) ||
	    LYIsUIPage(doc->address, UIP_UPLOAD_OPTIONS) ||
	    LYIsUIPage(doc->address, UIP_PERMIT_OPTIONS) ||
#endif /* DIRED_SUPPORT */
	    LYIsUIPage(doc->address, UIP_PRINT_OPTIONS) ||
	    LYIsUIPage(doc->address, UIP_DOWNLOAD_OPTIONS) ||
	    LYIsUIPage(doc->address, UIP_OPTIONS_MENU) ||
	    isLYNXKEYMAP(doc->address) ||
	    LYIsUIPage(doc->address, UIP_LIST_PAGE) ||
#ifdef EXP_ADDRLIST_PAGE
	    LYIsUIPage(doc->address, UIP_ADDRLIST_PAGE) ||
#endif
	    LYIsUIPage(doc->address, UIP_CONFIG_DEF) ||
	    LYIsUIPage(doc->address, UIP_LYNXCFG) ||
	    isLYNXCOOKIE(doc->address) ||
	    LYIsUIPage(doc->address, UIP_TRACELOG)) {
	    if (!related)
		PrevVisitedLink = NULL;
	    return;
	}
    }

    if (!Visited_Links) {
	Visited_Links = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(Visited_Links_free);
#endif
	Latest_last.prev_latest = &Latest_first;
	Latest_first.next_latest = &Latest_last;
	Latest_last.next_latest = NULL;		/* Find bugs quick! */
	Latest_first.prev_latest = NULL;
	Last_by_first = Latest_tree = First_tree = NULL;
    }

    cur = Visited_Links;
    while (NULL != (tmp = (VisitedLink *) HTList_nextObject(cur))) {
	if (!strcmp(NonNull(tmp->address),
		    NonNull(doc->address))) {
	    PrevVisitedLink = PrevActiveVisitedLink = tmp;
	    /* Already visited.  Update the last-visited info. */
	    if (tmp->next_latest == &Latest_last)	/* optimization */
		return;

	    /* Remove from "latest" chain */
	    tmp->prev_latest->next_latest = tmp->next_latest;
	    tmp->next_latest->prev_latest = tmp->prev_latest;

	    /* Insert at the end of the "latest" chain */
	    Latest_last.prev_latest->next_latest = tmp;
	    tmp->prev_latest = Latest_last.prev_latest;
	    tmp->next_latest = &Latest_last;
	    Latest_last.prev_latest = tmp;
	    return;
	}
    }

    if ((tmp = typecalloc(VisitedLink)) == NULL)
	outofmem(__FILE__, "LYAddVisitedLink");
    StrAllocCopy(tmp->address, doc->address);
    LYformTitle(&(tmp->title), title);

    /* First-visited chain */
    HTList_appendObject(Visited_Links, tmp);	/* At end */
    tmp->prev_first = Last_by_first;
    Last_by_first = tmp;

    /* Tree structure */
    if (PrevVisitedLink) {
	VisitedLink *a = PrevVisitedLink;
	VisitedLink *b = a->next_tree;
	int l = PrevVisitedLink->level;

	/* Find last on the deeper levels */
	while (b && b->level > l)
	    a = b, b = b->next_tree;

	if (!b)			/* a == Latest_tree */
	    Latest_tree = tmp;
	tmp->next_tree = a->next_tree;
	a->next_tree = tmp;

	tmp->level = PrevVisitedLink->level + 1;
    } else {
	if (Latest_tree)
	    Latest_tree->next_tree = tmp;
	tmp->level = 0;
	tmp->next_tree = NULL;
	Latest_tree = tmp;
    }
    PrevVisitedLink = PrevActiveVisitedLink = tmp;
    if (!First_tree)
	First_tree = tmp;

    /* "latest" chain */
    Latest_last.prev_latest->next_latest = tmp;
    tmp->prev_latest = Latest_last.prev_latest;
    tmp->next_latest = &Latest_last;
    Latest_last.prev_latest = tmp;

    return;
}

/*
 * Returns true if this is a page that we would push onto the stack if not
 * forced.  If docurl is NULL, only the title is considered; otherwise also
 * check the URL whether it is (likely to be) a generated special page.
 */
BOOLEAN LYwouldPush(const char *title,
		    const char *docurl)
{
    BOOLEAN rc = FALSE;

    /*
     * All non-pushable generated pages have URLs that begin with
     * "file://localhost/" and end with HTML_SUFFIX.  - kw
     */
    if (docurl) {
	size_t ulen;

	if (strncmp(docurl, "file://localhost/", 17) != 0 ||
	    (ulen = strlen(docurl)) <= strlen(HTML_SUFFIX) ||
	    strcmp(docurl + ulen - strlen(HTML_SUFFIX), HTML_SUFFIX) != 0) {
	    /*
	     * If it is not a local HTML file, it may be a Web page that
	     * accidentally has the same title.  So return TRUE now.  - kw
	     */
	    return TRUE;
	}
    }

    if (docurl) {
	rc = (BOOLEAN)
	    !(LYIsUIPage(docurl, UIP_HISTORY)
	      || LYIsUIPage(docurl, UIP_PRINT_OPTIONS)
#ifdef DIRED_SUPPORT
	      || LYIsUIPage(docurl, UIP_DIRED_MENU)
	      || LYIsUIPage(docurl, UIP_UPLOAD_OPTIONS)
	      || LYIsUIPage(docurl, UIP_PERMIT_OPTIONS)
#endif /* DIRED_SUPPORT */
	    );
    } else {
	rc = (BOOLEAN)
	    !(!strcmp(title, HISTORY_PAGE_TITLE)
	      || !strcmp(title, PRINT_OPTIONS_TITLE)
#ifdef DIRED_SUPPORT
	      || !strcmp(title, DIRED_MENU_TITLE)
	      || !strcmp(title, UPLOAD_OPTIONS_TITLE)
	      || !strcmp(title, PERMIT_OPTIONS_TITLE)
#endif /* DIRED_SUPPORT */
	    );
    }
    return rc;
}

/*
 * Free post-data for 'DocInfo'
 */
void LYFreePostData(DocInfo *doc)
{
    BStrFree(doc->post_data);
    FREE(doc->post_content_type);
}

/*
 * Free strings associated with a 'DocInfo' struct.
 */
void LYFreeDocInfo(DocInfo *doc)
{
    FREE(doc->title);
    FREE(doc->address);
    FREE(doc->bookmark);
    LYFreePostData(doc);
}

/*
 * Free the information in the last history entry.
 */
static void clean_extra_history(void)
{
    trace_history("clean_extra_history");
    nhist += nhist_extra;
    while (nhist_extra > 0) {
	nhist--;
	LYFreeDocInfo(&HDOC(nhist));
	nhist_extra--;
    }
    trace_history("...clean_extra_history");
}

/*
 * Free the entire history stack, for auditing memory leaks.
 */
#ifdef LY_FIND_LEAKS
static void clean_all_history(void)
{
    trace_history("clean_all_history");
    clean_extra_history();
    while (nhist > 0) {
	nhist--;
	LYFreeDocInfo(&HDOC(nhist));
    }
    trace_history("...clean_all_history");
}
#endif

/* FIXME What is the relationship to are_different() from the mainloop?! */
static int are_identical(HistInfo * doc, DocInfo *doc1)
{
    return (STREQ(doc1->address, doc->hdoc.address)
	    && BINEQ(doc1->post_data, doc->hdoc.post_data)
	    && !strcmp(NonNull(doc1->bookmark),
		       NonNull(doc->hdoc.bookmark))
	    && doc1->isHEAD == doc->hdoc.isHEAD);
}

void LYAllocHistory(int entries)
{
    CTRACE((tfp, "LYAllocHistory %d vs %d\n", entries, size_history));
    if (entries + 1 >= size_history) {
	unsigned want;
	int save = size_history;

	size_history = (entries + 2) * 2;
	want = size_history * sizeof(*history);
	if (history == 0) {
	    history = (HistInfo *) malloc(want);
	} else {
	    history = (HistInfo *) realloc(history, want);
	}
	if (history == 0)
	    outofmem(__FILE__, "LYAllocHistory");
	while (save < size_history) {
	    CTRACE((tfp, "...LYAllocHistory clearing %d\n", save));
	    memset(&history[save++], 0, sizeof(history[0]));
	}
    }
    CTRACE((tfp, "...LYAllocHistory %d vs %d\n", entries, size_history));
}

/*
 * Push the current filename, link and line number onto the history list.
 */
int LYpush(DocInfo *doc, BOOLEAN force_push)
{
    /*
     * Don't push NULL file names.
     */
    if (*doc->address == '\0')
	return 0;

    /*
     * Check whether this is a document we don't push unless forced.  - FM
     */
    if (!force_push) {
	/*
	 * Don't push the history, printer, or download lists.
	 */
	if (!LYwouldPush(doc->title, doc->address)) {
	    if (!LYforce_no_cache)
		LYoverride_no_cache = TRUE;
	    return 0;
	}
    }

    /*
     * If file is identical to one before it, don't push it.
     */
    if (nhist > 1 && are_identical(&(history[nhist - 1]), doc)) {
	if (HDOC(nhist - 1).internal_link == doc->internal_link) {
	    /* But it is nice to have the last position remembered!
	       - kw */
	    HDOC(nhist - 1).link = doc->link;
	    HDOC(nhist - 1).line = doc->line;
	    return 0;
	}
    }

    /*
     * If file is identical to the current document, just move the pointer.
     */
    if (nhist_extra >= 1 && are_identical(&(history[nhist]), doc)) {
	HDOC(nhist).link = doc->link;
	HDOC(nhist).line = doc->line;
	nhist_extra--;
	LYAllocHistory(nhist);
	nhist++;
	trace_history("LYpush: just move the cursor");
	return 1;
    }

    clean_extra_history();
#ifdef LY_FIND_LEAKS
    if (!already_registered_clean_all_history) {
	already_registered_clean_all_history = 1;
	atexit(clean_all_history);
    }
#endif

    /*
     * OK, push it...
     */
    LYAllocHistory(nhist);
    HDOC(nhist).link = doc->link;
    HDOC(nhist).line = doc->line;

    HDOC(nhist).title = NULL;
    LYformTitle(&(HDOC(nhist).title), doc->title);

    HDOC(nhist).address = NULL;
    StrAllocCopy(HDOC(nhist).address, doc->address);

    HDOC(nhist).post_data = NULL;
    BStrCopy(HDOC(nhist).post_data, doc->post_data);

    HDOC(nhist).post_content_type = NULL;
    StrAllocCopy(HDOC(nhist).post_content_type, doc->post_content_type);

    HDOC(nhist).bookmark = NULL;
    StrAllocCopy(HDOC(nhist).bookmark, doc->bookmark);

    HDOC(nhist).isHEAD = doc->isHEAD;
    HDOC(nhist).safe = doc->safe;

    HDOC(nhist).internal_link = FALSE;	/* by default */
    history[nhist].intern_seq_start = -1;	/* by default */
    if (doc->internal_link) {
	/* Now some tricky stuff: if the caller thinks that the doc
	   to push was the result of following an internal
	   (fragment) link, we check whether we believe it.
	   It is only accepted as valid if the immediately preceding
	   item on the history stack is actually the same document
	   except for fragment and location info.  I.e. the Parent
	   Anchors are the same.
	   Also of course this requires that this is not the first
	   history item. - kw */
	if (nhist > 0) {
	    DocAddress WWWDoc;
	    HTParentAnchor *thisparent, *thatparent = NULL;

	    WWWDoc.address = doc->address;
	    WWWDoc.post_data = doc->post_data;
	    WWWDoc.post_content_type = doc->post_content_type;
	    WWWDoc.bookmark = doc->bookmark;
	    WWWDoc.isHEAD = doc->isHEAD;
	    WWWDoc.safe = doc->safe;
	    thisparent =
		HTAnchor_findAddress(&WWWDoc);
	    /* Now find the ParentAnchor for the previous history
	     * item - kw
	     */
	    if (thisparent) {
		/* If the last-pushed item is a LYNXIMGMAP but THIS one
		 * isn't, compare the physical URLs instead. - kw
		 */
		if (isLYNXIMGMAP(HDOC(nhist - 1).address) &&
		    !isLYNXIMGMAP(doc->address)) {
		    WWWDoc.address = HDOC(nhist - 1).address + LEN_LYNXIMGMAP;
		    /*
		     * If THIS item is a LYNXIMGMAP but the last-pushed one
		     * isn't, fake it by using THIS item's address for
		     * thatparent... - kw
		     */
		} else if (isLYNXIMGMAP(doc->address) &&
			   !isLYNXIMGMAP(HDOC(nhist - 1).address)) {
		    char *temp = NULL;

		    StrAllocCopy(temp, STR_LYNXIMGMAP);
		    StrAllocCat(temp, doc->address + LEN_LYNXIMGMAP);
		    WWWDoc.address = temp;
		    WWWDoc.post_content_type = HDOC(nhist - 1).post_content_type;
		    WWWDoc.bookmark = HDOC(nhist - 1).bookmark;
		    WWWDoc.isHEAD = HDOC(nhist - 1).isHEAD;
		    WWWDoc.safe = HDOC(nhist - 1).safe;
		    thatparent =
			HTAnchor_findAddress(&WWWDoc);
		    FREE(temp);
		} else {
		    WWWDoc.address = HDOC(nhist - 1).address;
		}
		if (!thatparent) {	/* if not yet done */
		    WWWDoc.post_data = HDOC(nhist - 1).post_data;
		    WWWDoc.post_content_type = HDOC(nhist - 1).post_content_type;
		    WWWDoc.bookmark = HDOC(nhist - 1).bookmark;
		    WWWDoc.isHEAD = HDOC(nhist - 1).isHEAD;
		    WWWDoc.safe = HDOC(nhist - 1).safe;
		    thatparent =
			HTAnchor_findAddress(&WWWDoc);
		}
		/* In addition to equality of the ParentAnchors, require
		 * that IF we have a HTMainText (i.e., it wasn't just
		 * HTuncache'd by mainloop), THEN it has to be consistent
		 * with what we are trying to push.
		 *
		 * This may be overkill...  - kw
		 */
		if (thatparent == thisparent &&
		    (!HTMainText || HTMainAnchor == thisparent)
		    ) {
		    HDOC(nhist).internal_link = TRUE;
		    history[nhist].intern_seq_start =
			history[nhist - 1].intern_seq_start >= 0 ?
			history[nhist - 1].intern_seq_start : nhist - 1;
		    CTRACE((tfp, "\nLYpush: pushed as internal link, OK\n"));
		}
	    }
	}
	if (!HDOC(nhist).internal_link) {
	    CTRACE((tfp, "\nLYpush: push as internal link requested, %s\n",
		    "but didn't check out!"));
	}
    }
    CTRACE((tfp, "\nLYpush[%d]: address:%s\n        title:%s\n",
	    nhist, doc->address, doc->title));
    nhist++;
    return 1;
}

/*
 * Pop the previous filename, link and line number from the history list.
 */
void LYpop(DocInfo *doc)
{
    if (nhist > 0) {
	clean_extra_history();
	nhist--;

	LYFreeDocInfo(doc);

	*doc = HDOC(nhist);

#ifdef DISP_PARTIAL
	/* assume we pop the 'doc' to show it soon... */
	LYSetNewline(doc->line);	/* reinitialize */
#endif /* DISP_PARTIAL */
	CTRACE((tfp, "LYpop[%d]: address:%s\n     title:%s\n",
		nhist, doc->address, doc->title));
    }
}

/*
 * Move to the previous filename, link and line number from the history list.
 */
void LYhist_prev(DocInfo *doc)
{
    trace_history("LYhist_prev");
    if (nhist > 0 && (nhist_extra || nhist < size_history)) {
	nhist--;
	nhist_extra++;
	LYpop_num(nhist, doc);
	trace_history("...LYhist_prev");
    }
}

/*
 * Called before calling LYhist_prev().
 */
void LYhist_prev_register(DocInfo *doc)
{
    trace_history("LYhist_prev_register");
    if (nhist > 1) {
	if (nhist_extra) {	/* Make something to return back */
	    /* Store the new position */
	    HDOC(nhist).link = doc->link;
	    HDOC(nhist).line = doc->line;
	} else if (LYpush(doc, 0)) {
	    nhist--;
	    nhist_extra++;
	}
	trace_history("...LYhist_prev_register");
    }
}

/*
 * Move to the next filename, link and line number from the history.
 */
int LYhist_next(DocInfo *doc, DocInfo *newdoc)
{
    if (nhist_extra <= 1)	/* == 1 when we are the last one */
	return 0;
    /* Store the new position */
    HDOC(nhist).link = doc->link;
    HDOC(nhist).line = doc->line;
    LYAllocHistory(nhist);
    nhist++;
    nhist_extra--;
    LYpop_num(nhist, newdoc);
    return 1;
}

/*
 * Pop the specified hist entry, link and line number from the history list but
 * don't actually remove the entry, just return it.
 * (This procedure is badly named :)
 */
void LYpop_num(int number,
	       DocInfo *doc)
{
    if (number >= 0 && nhist + nhist_extra > number) {
	doc->link = HDOC(number).link;
	doc->line = HDOC(number).line;
	StrAllocCopy(doc->title, HDOC(number).title);
	StrAllocCopy(doc->address, HDOC(number).address);
	BStrCopy(doc->post_data, HDOC(number).post_data);
	StrAllocCopy(doc->post_content_type, HDOC(number).post_content_type);
	StrAllocCopy(doc->bookmark, HDOC(number).bookmark);
	doc->isHEAD = HDOC(number).isHEAD;
	doc->safe = HDOC(number).safe;
	doc->internal_link = HDOC(number).internal_link;	/* ?? */
#ifdef DISP_PARTIAL
	/* assume we pop the 'doc' to show it soon... */
	LYSetNewline(doc->line);	/* reinitialize */
#endif /* DISP_PARTIAL */
    }
}

/*
 * This procedure outputs the history buffer into a temporary file.
 */
int showhistory(char **newfile)
{
    static char tempfile[LY_MAXPATH] = "\0";
    char *Title = NULL;
    int x = 0;
    FILE *fp0;

    if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	return (-1);

    LYLocalFileToURL(newfile, tempfile);

    LYforce_HTML_mode = TRUE;	/* force this file to be HTML */
    LYforce_no_cache = TRUE;	/* force this file to be new */

    BeginInternalPage(fp0, HISTORY_PAGE_TITLE, HISTORY_PAGE_HELP);

    fprintf(fp0, "<p align=right> <a href=\"%s\">[%s]</a>\n",
	    STR_LYNXMESSAGES, STATUSLINES_TITLE);

    fprintf(fp0, "<pre>\n");

    fprintf(fp0, "<em>%s</em>\n", gettext("You selected:"));
    for (x = nhist + nhist_extra - 1; x >= 0; x--) {
	/*
	 * The number of the document in the hist stack, its title in a link,
	 * and its address.  - FM
	 */
	if (HDOC(x).title != NULL) {
	    StrAllocCopy(Title, HDOC(x).title);
	    LYEntify(&Title, TRUE);
	    LYTrimLeading(Title);
	    LYTrimTrailing(Title);
	    if (*Title == '\0')
		StrAllocCopy(Title, NO_TITLE);
	} else {
	    StrAllocCopy(Title, NO_TITLE);
	}
	fprintf(fp0,
		"%s<em>%d</em>. <tab id=t%d><a href=\"%s%d\">%s</a>\n",
		(x > 99 ? "" : x < 10 ? "  " : " "),
		x, x, STR_LYNXHIST, x, Title);
	if (HDOC(x).address != NULL) {
	    StrAllocCopy(Title, HDOC(x).address);
	    LYEntify(&Title, TRUE);
	} else {
	    StrAllocCopy(Title, gettext("(no address)"));
	}
	if (HDOC(x).internal_link) {
	    if (history[x].intern_seq_start == history[nhist - 1].intern_seq_start)
		StrAllocCat(Title, gettext(" (internal)"));
	    else
		StrAllocCat(Title, gettext(" (was internal)"));
	}
	fprintf(fp0, "<tab to=t%d>%s\n", x, Title);
    }
    fprintf(fp0, "</pre>\n");
    EndInternalPage(fp0);

    LYCloseTempFP(fp0);
    FREE(Title);
    return (0);
}

/*
 * This function makes the history page seem like any other type of file since
 * more info is needed than can be provided by the normal link structure.  We
 * saved out the history number to a special URL.
 *
 * The info looks like:  LYNXHIST:#
 */
BOOLEAN historytarget(DocInfo *newdoc)
{
    int number;
    DocAddress WWWDoc;
    HTParentAnchor *tmpanchor;
    HText *text;
    BOOLEAN treat_as_intern = FALSE;

    if ((!newdoc || !newdoc->address) ||
	strlen(newdoc->address) < 10 || !isdigit(UCH(*(newdoc->address + 9))))
	return (FALSE);

    if ((number = atoi(newdoc->address + 9)) > nhist + nhist_extra || number < 0)
	return (FALSE);

    /*
     * Optimization: assume we came from the History Page,
     * so never return back - always a new version next time.
     * But check first whether HTMainText is really the History
     * Page document - in some obscure situations this may not be
     * the case.  If HTMainText seems to be a History Page document,
     * also check that it really hasn't been pushed. - LP, kw
     */
    if (HTMainText && nhist > 0 &&
	!strcmp(HTLoadedDocumentTitle(), HISTORY_PAGE_TITLE) &&
	LYIsUIPage3(HTLoadedDocumentURL(), UIP_HISTORY, 0) &&
	strcmp(HTLoadedDocumentURL(), HDOC(nhist - 1).address)) {
	HTuncache_current_document();	/* don't waste the cache */
    }

    LYpop_num(number, newdoc);
    if (((newdoc->internal_link &&
	  history[number].intern_seq_start == history[nhist - 1].intern_seq_start)
	 || (number < nhist - 1 &&
	     HDOC(nhist - 1).internal_link &&
	     number == history[nhist - 1].intern_seq_start))
	&& !(LYforce_no_cache == TRUE && LYoverride_no_cache == FALSE)) {
#ifndef DONT_TRACK_INTERNAL_LINKS
	LYforce_no_cache = FALSE;
	LYinternal_flag = TRUE;
	newdoc->internal_link = TRUE;
	treat_as_intern = TRUE;
#endif
    } else {
	newdoc->internal_link = FALSE;
    }
    /*
     * If we have POST content, and have LYresubmit_posts set or have no_cache
     * set or do not still have the text cached, ask the user whether to
     * resubmit the form.  - FM
     */
    if (newdoc->post_data != NULL) {
	WWWDoc.address = newdoc->address;
	WWWDoc.post_data = newdoc->post_data;
	WWWDoc.post_content_type = newdoc->post_content_type;
	WWWDoc.bookmark = newdoc->bookmark;
	WWWDoc.isHEAD = newdoc->isHEAD;
	WWWDoc.safe = newdoc->safe;
	tmpanchor = HTAnchor_findAddress(&WWWDoc);
	text = (HText *) HTAnchor_document(tmpanchor);
	if (((((LYresubmit_posts == TRUE) ||
	       (LYforce_no_cache == TRUE &&
		LYoverride_no_cache == FALSE)) &&
	      !(treat_as_intern && !reloading)) ||
	     text == NULL) &&
	    (isLYNXIMGMAP(newdoc->address) ||
	     HTConfirm(CONFIRM_POST_RESUBMISSION) == TRUE)) {
	    LYforce_no_cache = TRUE;
	    LYoverride_no_cache = FALSE;
	} else if (text != NULL) {
	    LYforce_no_cache = FALSE;
	    LYoverride_no_cache = TRUE;
	} else {
	    HTInfoMsg(CANCELLED);
	    return (FALSE);
	}
    }

    if (number != 0)
	StrAllocCat(newdoc->title, gettext(" (From History)"));
    return (TRUE);
}

/*
 * This procedure outputs the Visited Links list into a temporary file.  - FM
 * Returns links's number to make active (1-based), or 0 if not required.
 */
int LYShowVisitedLinks(char **newfile)
{
    static char tempfile[LY_MAXPATH] = "\0";
    char *Title = NULL;
    char *Address = NULL;
    int x, tot;
    FILE *fp0;
    VisitedLink *vl;
    HTList *cur = Visited_Links;
    int offset;
    int ret = 0;
    const char *arrow, *post_arrow;

    if (!cur)
	return (-1);

    if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	return (-1);

    LYLocalFileToURL(newfile, tempfile);
    LYRegisterUIPage(*newfile, UIP_VLINKS);

    LYforce_HTML_mode = TRUE;	/* force this file to be HTML */
    LYforce_no_cache = TRUE;	/* force this file to be new */

    BeginInternalPage(fp0, VISITED_LINKS_TITLE, VISITED_LINKS_HELP);

#ifndef NO_OPTION_FORMS
    fprintf(fp0, "<form action=\"%s\" method=\"post\">\n", STR_LYNXOPTIONS);
    LYMenuVisitedLinks(fp0, FALSE);
    fprintf(fp0, "<input type=\"submit\" value=\"Accept Changes\">\n");
    fprintf(fp0, "</form>\n");
    fprintf(fp0, "<P>\n");
#endif

    fprintf(fp0, "<pre>\n");
    fprintf(fp0, "<em>%s</em>\n",
	    gettext("You visited (POSTs, bookmark, menu and list files excluded):"));
    if (Visited_Links_As & VISITED_LINKS_REVERSE)
	tot = x = HTList_count(Visited_Links);
    else
	tot = x = -1;

    if (Visited_Links_As & VISITED_LINKS_AS_TREE) {
	vl = First_tree;
    } else if (Visited_Links_As & VISITED_LINKS_AS_LATEST) {
	if (Visited_Links_As & VISITED_LINKS_REVERSE)
	    vl = Latest_last.prev_latest;
	else
	    vl = Latest_first.next_latest;
	if (vl == &Latest_last || vl == &Latest_first)
	    vl = NULL;
    } else {
	if (Visited_Links_As & VISITED_LINKS_REVERSE)
	    vl = Last_by_first;
	else
	    vl = (VisitedLink *) HTList_nextObject(cur);
    }
    while (NULL != vl) {
	/*
	 * The number of the document (most recent highest), its title in a
	 * link, and its address.  - FM
	 */
	post_arrow = arrow = "";
	if (Visited_Links_As & VISITED_LINKS_REVERSE)
	    x--;
	else
	    x++;
	if (vl == PrevActiveVisitedLink) {
	    if (Visited_Links_As & VISITED_LINKS_REVERSE)
		ret = tot - x + 2;
	    else
		ret = x + 3;
	}
	if (vl == PrevActiveVisitedLink) {
	    post_arrow = "<A NAME=current></A>";
	    /* Otherwise levels 0 and 1 look the same when with arrow: */
	    arrow = (vl->level && (Visited_Links_As & VISITED_LINKS_AS_TREE))
		? "==>" : "=>";
	    StrAllocCat(*newfile, "#current");
	}
	if (Visited_Links_As & VISITED_LINKS_AS_TREE) {
	    offset = 2 * vl->level;
	    if (offset > 24)
		offset = (offset + 24) / 2;
	    if (offset > LYcols * 3 / 4)
		offset = LYcols * 3 / 4;
	} else
	    offset = (x > 99 ? 0 : x < 10 ? 2 : 1);
	if (non_empty(vl->title)) {
	    StrAllocCopy(Title, vl->title);
	    LYEntify(&Title, TRUE);
	    LYTrimLeading(Title);
	    LYTrimTrailing(Title);
	    if (*Title == '\0')
		StrAllocCopy(Title, NO_TITLE);
	} else {
	    StrAllocCopy(Title, NO_TITLE);
	}
	if (non_empty(vl->address)) {
	    StrAllocCopy(Address, vl->address);
	    LYEntify(&Address, FALSE);
	    fprintf(fp0,
		    "%-*s%s<em>%d</em>. <tab id=t%d><a href=\"%s\">%s</a>\n",
		    offset, arrow, post_arrow,
		    x, x, Address, Title);
	} else {
	    fprintf(fp0,
		    "%-*s%s<em>%d</em>. <tab id=t%d><em>%s</em>\n",
		    offset, arrow, post_arrow,
		    x, x, Title);
	}
	if (Address != NULL) {
	    StrAllocCopy(Address, vl->address);
	    LYEntify(&Address, TRUE);
	}
	fprintf(fp0, "<tab to=t%d>%s\n", x,
		((Address != NULL) ? Address : gettext("(no address)")));
	if (Visited_Links_As & VISITED_LINKS_AS_TREE)
	    vl = vl->next_tree;
	else if (Visited_Links_As & VISITED_LINKS_AS_LATEST) {
	    if (Visited_Links_As & VISITED_LINKS_REVERSE)
		vl = vl->prev_latest;
	    else
		vl = vl->next_latest;
	    if (vl == &Latest_last || vl == &Latest_first)
		vl = NULL;
	} else {
	    if (Visited_Links_As & VISITED_LINKS_REVERSE)
		vl = vl->prev_first;
	    else
		vl = (VisitedLink *) HTList_nextObject(cur);
	}
    }
    fprintf(fp0, "</pre>\n");
    EndInternalPage(fp0);

    LYCloseTempFP(fp0);
    FREE(Title);
    FREE(Address);
    return (ret);
}

/*
 * Keep cycled buffer for statusline messages.
 */
#define STATUSBUFSIZE   40
static char *buffstack[STATUSBUFSIZE];
static int topOfStack = 0;

#ifdef LY_FIND_LEAKS
static void free_messages_stack(void)
{
    topOfStack = STATUSBUFSIZE;

    while (--topOfStack >= 0) {
	FREE(buffstack[topOfStack]);
    }
}
#endif

static void to_stack(char *str)
{
    /*
     * Cycle buffer:
     */
    if (topOfStack >= STATUSBUFSIZE) {
	topOfStack = 0;
    }

    /*
     * Register string.
     */
    FREE(buffstack[topOfStack]);
    buffstack[topOfStack] = str;
    topOfStack++;
#ifdef LY_FIND_LEAKS
    if (!already_registered_free_messages_stack) {
	already_registered_free_messages_stack = 1;
	atexit(free_messages_stack);
    }
#endif
    if (topOfStack >= STATUSBUFSIZE) {
	topOfStack = 0;
    }
}

/*
 * Dump statusline messages into the buffer.
 * Called from mainloop() when exit immediately with an error:
 * can not access startfile (first_file) so a couple of alert messages
 * will be very useful on exit.
 * (Don't expect everyone will look a trace log in case of difficulties:))
 */
void LYstatusline_messages_on_exit(char **buf)
{
    int i;

    StrAllocCat(*buf, "\n");
    /* print messages in chronological order:
     * probably a single message but let's do it.
     */
    i = topOfStack - 1;
    while (++i < STATUSBUFSIZE) {
	if (buffstack[i] != NULL) {
	    StrAllocCat(*buf, buffstack[i]);
	    StrAllocCat(*buf, "\n");
	}
    }
    i = -1;
    while (++i < topOfStack) {
	if (buffstack[i] != NULL) {
	    StrAllocCat(*buf, buffstack[i]);
	    StrAllocCat(*buf, "\n");
	}
    }
}

void LYstore_message2(const char *message,
		      const char *argument)
{

    if (message != NULL) {
	char *temp = NULL;

	HTSprintf0(&temp, message, NonNull(argument));
	to_stack(temp);
    }
}

void LYstore_message(const char *message)
{
    if (message != NULL) {
	char *temp = NULL;

	StrAllocCopy(temp, message);
	to_stack(temp);
    }
}

/*     LYLoadMESSAGES
 *     --------------
 *     Create a text/html stream with a list of recent statusline messages.
 *     LYNXMESSAGES:/ internal page.
 *     [implementation based on LYLoadKeymap()].
 */

struct _HTStream {
    HTStreamClass *isa;
};

static int LYLoadMESSAGES(const char *arg GCC_UNUSED,
			  HTParentAnchor *anAnchor,
			  HTFormat format_out,
			  HTStream *sink)
{
    HTFormat format_in = WWW_HTML;
    HTStream *target = NULL;
    char *buf = NULL;
    int nummsg = 0;

    int i;
    char *temp = NULL;

    i = STATUSBUFSIZE;
    while (--i >= 0) {
	if (buffstack[i] != NULL)
	    nummsg++;
    }

    /*
     * Set up the stream.  - FM
     */
    target = HTStreamStack(format_in, format_out, sink, anAnchor);

    if (!target || target == NULL) {
	HTSprintf0(&buf, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	HTAlert(buf);
	FREE(buf);
	return (HT_NOT_LOADED);
    }
    anAnchor->no_cache = TRUE;

#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

    HTSprintf0(&buf, "<html>\n<head>\n");
    PUTS(buf);
    /*
     * This page is a list of messages in display character set.
     */
    HTSprintf0(&buf, "<META %s content=\"text/html;charset=%s\">\n",
	       "http-equiv=\"content-type\"",
	       LYCharSet_UC[current_char_set].MIMEname);
    PUTS(buf);
    HTSprintf0(&buf, "<title>%s</title>\n</head>\n<body>\n",
	       STATUSLINES_TITLE);
    PUTS(buf);

    if (nummsg != 0) {
	HTSprintf0(&buf, "<ol>\n");
	PUTS(buf);
	/* print messages in reverse order: */
	i = topOfStack;
	while (--i >= 0) {
	    if (buffstack[i] != NULL) {
		StrAllocCopy(temp, buffstack[i]);
		LYEntify(&temp, TRUE);
		HTSprintf0(&buf, "<li value=%d> <em>%s</em>\n", nummsg, temp);
		nummsg--;
		PUTS(buf);
	    }
	}
	i = STATUSBUFSIZE;
	while (--i >= topOfStack) {
	    if (buffstack[i] != NULL) {
		StrAllocCopy(temp, buffstack[i]);
		LYEntify(&temp, TRUE);
		HTSprintf0(&buf, "<li value=%d> <em>%s</em>\n", nummsg, temp);
		nummsg--;
		PUTS(buf);
	    }
	}
	FREE(temp);
	HTSprintf0(&buf, "</ol>\n</body>\n</html>\n");
    } else {
	HTSprintf0(&buf, "<p>%s\n</body>\n</html>\n",
		   gettext("(No messages yet)"));
    }
    PUTS(buf);

    (*target->isa->_free) (target);
    FREE(buf);
    return (HT_LOADED);
}

#ifdef GLOBALDEF_IS_MACRO
#define _LYMESSAGES_C_GLOBALDEF_1_INIT { "LYNXMESSAGES", LYLoadMESSAGES, 0}
GLOBALDEF(HTProtocol, LYLynxStatusMessages, _LYMESSAGES_C_GLOBALDEF_1_INIT);
#else
GLOBALDEF HTProtocol LYLynxStatusMessages =
{"LYNXMESSAGES", LYLoadMESSAGES, 0};
#endif /* GLOBALDEF_IS_MACRO */
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d18 1
d32 9
a40 9
PUBLIC HTList * Visited_Links = NULL;	/* List of safe popped docs. */
PUBLIC int Visited_Links_As = VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE;
PRIVATE VisitedLink *PrevVisitedLink = NULL;	    /* NULL on auxillary */
PRIVATE VisitedLink *PrevActiveVisitedLink = NULL;  /* Last non-auxillary */
PRIVATE VisitedLink Latest_first;
PRIVATE VisitedLink Latest_last;
PRIVATE VisitedLink *Latest_tree;
PRIVATE VisitedLink *First_tree;
PRIVATE VisitedLink *Last_by_first;
d45 2
a46 2
PRIVATE int already_registered_free_messages_stack = 0;
PRIVATE int already_registered_clean_all_history = 0;
d51 1
a51 1
 *  Utility for freeing the list of visited links. - FM
d53 1
a53 1
PRIVATE void Visited_Links_free NOARGS
d63 1
a63 1
    while (NULL != (vl = (VisitedLink *)HTList_nextObject(cur))) {
d78 1
a78 2
PRIVATE void trace_history ARGS1(
	CONST char *,	tag)
d82 1
a82 1
		     tag, nhist, MAXHIST, nhist_extra));
d87 1
a87 1
#define trace_history(tag) /* nothing */
d91 2
a92 2
 *  Utility for listing visited links, making any repeated
 *  links the most current in the list. - FM
d94 1
a94 2
PUBLIC void LYAddVisitedLink ARGS1(
	DocInfo *,	doc)
d96 1
a96 1
    VisitedLink *new;
d98 1
a98 1
    char *title = (doc->title ? doc->title : NO_TITLE);
d100 1
a100 1
    if (!(doc->address && *doc->address)) {
d106 1
a106 2
     *	Exclude POST or HEAD replies, and bookmark, menu
     *	or list files. - FM
d109 3
a111 3
	(/* special url or a temp file */
	 (!strncmp(doc->address, "LYNX", 4) ||
	  !strncmp(doc->address, "file://localhost/", 17)))) {
d114 5
a118 5
	if (	LYIsUIPage(doc->address, UIP_HISTORY) ||
		LYIsUIPage(doc->address, UIP_VLINKS) ||
		LYIsUIPage(doc->address, UIP_SHOWINFO) ||
		isLYNXMESSAGES(doc->address) ||
			(related = 0)	||
d120 3
a122 3
		LYIsUIPage(doc->address, UIP_DIRED_MENU) ||
		LYIsUIPage(doc->address, UIP_UPLOAD_OPTIONS) ||
		LYIsUIPage(doc->address, UIP_PERMIT_OPTIONS) ||
d124 5
a128 5
		LYIsUIPage(doc->address, UIP_PRINT_OPTIONS) ||
		LYIsUIPage(doc->address, UIP_DOWNLOAD_OPTIONS) ||
		LYIsUIPage(doc->address, UIP_OPTIONS_MENU) ||
		isLYNXKEYMAP(doc->address) ||
		LYIsUIPage(doc->address, UIP_LIST_PAGE) ||
d130 1
a130 1
		LYIsUIPage(doc->address, UIP_ADDRLIST_PAGE) ||
d132 4
a135 4
		LYIsUIPage(doc->address, UIP_CONFIG_DEF) ||
		LYIsUIPage(doc->address, UIP_LYNXCFG) ||
		isLYNXCOOKIE(doc->address) ||
		LYIsUIPage(doc->address, UIP_TRACELOG)	) {
d155 2
a156 2
    while (NULL != (new = (VisitedLink *)HTList_nextObject(cur))) {
	if (!strcmp(NonNull(new->address),
d158 1
a158 1
	    PrevVisitedLink = PrevActiveVisitedLink = new;
d160 1
a160 1
	    if (new->next_latest == &Latest_last)	/* optimization */
d164 2
a165 2
	    new->prev_latest->next_latest = new->next_latest;
	    new->next_latest->prev_latest = new->prev_latest;
d168 4
a171 4
	    Latest_last.prev_latest->next_latest = new;
	    new->prev_latest = Latest_last.prev_latest;
	    new->next_latest = &Latest_last;
	    Latest_last.prev_latest = new;
d176 1
a176 1
    if ((new = typecalloc(VisitedLink)) == NULL)
d178 2
a179 2
    StrAllocCopy(new->address, doc->address);
    LYformTitle(&(new->title), title);
d182 3
a184 3
    HTList_appendObject(Visited_Links, new);	/* At end */
    new->prev_first = Last_by_first;
    Last_by_first = new;
d197 3
a199 3
	    Latest_tree = new;
	new->next_tree = a->next_tree;
	a->next_tree = new;
d201 1
a201 1
	new->level = PrevVisitedLink->level + 1;
d204 4
a207 4
	    Latest_tree->next_tree = new;
	new->level = 0;
	new->next_tree = NULL;
	Latest_tree = new;
d209 1
a209 1
    PrevVisitedLink = PrevActiveVisitedLink = new;
d211 1
a211 1
	First_tree = new;
d214 4
a217 4
    Latest_last.prev_latest->next_latest = new;
    new->prev_latest = Latest_last.prev_latest;
    new->next_latest = &Latest_last;
    Latest_last.prev_latest = new;
d223 3
a225 4
 *  Returns true if this is a page that we would push onto the stack if not
 *  forced.  If docurl is NULL, only the title is considered; otherwise
 *  also check the URL whether it is (likely to be) a generated special
 *  page.
d227 2
a228 3
PUBLIC BOOLEAN LYwouldPush ARGS2(
	CONST char *,	title,
	CONST char *,	docurl)
d233 2
a234 2
     *  All non-pushable generated pages have URLs that begin with
     *  "file://localhost/" and end with HTML_SUFFIX. - kw
d238 1
d243 2
a244 2
	     *  If it is not a local HTML file, it may be a Web page that
	     *  accidentally has the same title.  So return TRUE now. - kw
d252 2
a253 2
		! (LYIsUIPage(docurl, UIP_HISTORY)
		|| LYIsUIPage(docurl, UIP_PRINT_OPTIONS)
d255 3
a257 3
		|| LYIsUIPage(docurl, UIP_DIRED_MENU)
		|| LYIsUIPage(docurl, UIP_UPLOAD_OPTIONS)
		|| LYIsUIPage(docurl, UIP_PERMIT_OPTIONS)
d262 2
a263 2
		! (!strcmp(title, HISTORY_PAGE_TITLE)
		|| !strcmp(title, PRINT_OPTIONS_TITLE)
d265 3
a267 3
		|| !strcmp(title, DIRED_MENU_TITLE)
		|| !strcmp(title, UPLOAD_OPTIONS_TITLE)
		|| !strcmp(title, PERMIT_OPTIONS_TITLE)
d277 1
a277 2
PUBLIC void LYFreePostData ARGS1(
    DocInfo *,		doc)
d286 1
a286 2
PUBLIC void LYFreeDocInfo ARGS1(
    DocInfo *,		doc)
d295 1
a295 1
 *  Free the information in the last history entry.
d297 1
a297 1
PRIVATE void clean_extra_history NOARGS
d313 1
a313 1
PRIVATE void clean_all_history NOARGS
d326 31
a356 9
PRIVATE int are_identical ARGS2(
	HistInfo *,	doc,
	DocInfo *,	doc1)
{
     return (	STREQ(doc1->address, doc->hdoc.address)
		&& BINEQ(doc1->post_data, doc->hdoc.post_data)
		&& !strcmp(NonNull(doc1->bookmark),
			   NonNull(doc->hdoc.bookmark))
		&& doc1->isHEAD == doc->hdoc.isHEAD );
d360 1
a360 1
 *  Push the current filename, link and line number onto the history list.
d362 1
a362 3
PUBLIC int LYpush ARGS2(
	DocInfo *,	doc,
	BOOLEAN,	force_push)
d365 1
a365 1
     *	Don't push NULL file names.
d371 1
a371 2
     *	Check whether this is a document we
     *	don't push unless forced. - FM
d375 1
a375 1
	 *  Don't push the history, printer, or download lists.
d385 1
a385 1
     *	If file is identical to one before it, don't push it.
d387 2
a388 2
    if ( nhist > 1 && are_identical(&(history[nhist-1]), doc)) {
	if (HDOC(nhist-1).internal_link == doc->internal_link) {
d391 2
a392 2
	    HDOC(nhist-1).link = doc->link;
	    HDOC(nhist-1).line = doc->line;
d398 1
a398 1
     *	If file is identical to the current document, just move the pointer.
d400 1
a400 1
    if ( nhist_extra >= 1 && are_identical(&(history[nhist]), doc)) {
d404 1
d419 1
a419 1
     *	OK, push it if we have stack space.
d421 3
a423 3
    if (nhist < MAXHIST)  {
	HDOC(nhist).link = doc->link;
	HDOC(nhist).line = doc->line;
d425 2
a426 2
	HDOC(nhist).title = NULL;
	LYformTitle(&(HDOC(nhist).title), doc->title);
d428 2
a429 2
	HDOC(nhist).address = NULL;
	StrAllocCopy(HDOC(nhist).address, doc->address);
d431 2
a432 2
	HDOC(nhist).post_data = NULL;
	BStrCopy(HDOC(nhist).post_data, doc->post_data);
d434 43
a476 42
	HDOC(nhist).post_content_type = NULL;
	StrAllocCopy(HDOC(nhist).post_content_type, doc->post_content_type);

	HDOC(nhist).bookmark = NULL;
	StrAllocCopy(HDOC(nhist).bookmark, doc->bookmark);

	HDOC(nhist).isHEAD = doc->isHEAD;
	HDOC(nhist).safe = doc->safe;

	HDOC(nhist).internal_link = FALSE; /* by default */
	history[nhist].intern_seq_start = -1; /* by default */
	if (doc->internal_link) {
	    /* Now some tricky stuff: if the caller thinks that the doc
	       to push was the result of following an internal
	       (fragment) link, we check whether we believe it.
	       It is only accepted as valid if the immediately preceding
	       item on the history stack is actually the same document
	       except for fragment and location info.  I.e. the Parent
	       Anchors are the same.
	       Also of course this requires that this is not the first
	       history item. - kw */
	    if (nhist > 0) {
		DocAddress WWWDoc;
		HTParentAnchor *thisparent, *thatparent = NULL;
		WWWDoc.address = doc->address;
		WWWDoc.post_data = doc->post_data;
		WWWDoc.post_content_type = doc->post_content_type;
		WWWDoc.bookmark = doc->bookmark;
		WWWDoc.isHEAD = doc->isHEAD;
		WWWDoc.safe = doc->safe;
		thisparent =
		    HTAnchor_findAddress(&WWWDoc);
		/* Now find the ParentAnchor for the previous history
		** item - kw
		*/
		if (thisparent) {
		    /* If the last-pushed item is a LYNXIMGMAP but THIS one
		    ** isn't, compare the physical URLs instead. - kw
		    */
		    if (isLYNXIMGMAP(HDOC(nhist-1).address) &&
			!isLYNXIMGMAP(doc->address)) {
			WWWDoc.address = HDOC(nhist-1).address + LEN_LYNXIMGMAP;
d478 45
a522 44
		    ** If THIS item is a LYNXIMGMAP but the last-pushed one
		    ** isn't, fake it by using THIS item's address for
		    ** thatparent... - kw
		    */
		    } else if (isLYNXIMGMAP(doc->address) &&
		       !isLYNXIMGMAP(HDOC(nhist-1).address)) {
			char *temp = NULL;
			StrAllocCopy(temp, STR_LYNXIMGMAP);
			StrAllocCat(temp, doc->address + LEN_LYNXIMGMAP);
			WWWDoc.address = temp;
			WWWDoc.post_content_type = HDOC(nhist-1).post_content_type;
			WWWDoc.bookmark = HDOC(nhist-1).bookmark;
			WWWDoc.isHEAD = HDOC(nhist-1).isHEAD;
			WWWDoc.safe = HDOC(nhist-1).safe;
			thatparent =
			    HTAnchor_findAddress(&WWWDoc);
			FREE(temp);
		    } else {
			WWWDoc.address = HDOC(nhist-1).address;
		    }
		    if (!thatparent) { /* if not yet done */
			WWWDoc.post_data = HDOC(nhist-1).post_data;
			WWWDoc.post_content_type = HDOC(nhist-1).post_content_type;
			WWWDoc.bookmark = HDOC(nhist-1).bookmark;
			WWWDoc.isHEAD = HDOC(nhist-1).isHEAD;
			WWWDoc.safe = HDOC(nhist-1).safe;
			thatparent =
			    HTAnchor_findAddress(&WWWDoc);
		    }
		    /* In addition to equality of the ParentAnchors, require
		    ** that IF we have a HTMainText (i.e., it wasn't just
		    ** HTuncache'd by mainloop), THEN it has to be consistent
		    ** with what we are trying to push.
		    **   This may be overkill... - kw
		    */
		    if (thatparent == thisparent &&
			(!HTMainText || HTMainAnchor == thisparent)
			) {
			HDOC(nhist).internal_link = TRUE;
			history[nhist].intern_seq_start =
			    history[nhist-1].intern_seq_start >= 0 ?
			    history[nhist-1].intern_seq_start : nhist-1;
			CTRACE((tfp, "\nLYpush: pushed as internal link, OK\n"));
		    }
a524 4
	    if (!HDOC(nhist).internal_link) {
		CTRACE((tfp, "\nLYpush: push as internal link requested, %s\n",
			    "but didn't check out!"));
	    }
d526 3
a528 6
	CTRACE((tfp, "\nLYpush[%d]: address:%s\n        title:%s\n",
		    nhist, doc->address, doc->title));
	nhist++;
    } else {
	if (LYCursesON) {
	    HTAlert(MAXHIST_REACHED);
a529 2
	CTRACE((tfp, "\nLYpush: MAXHIST reached for:\n        address:%s\n        title:%s\n",
		    doc->address, doc->title));
d531 3
d538 1
a538 1
 *  Pop the previous filename, link and line number from the history list.
d540 1
a540 2
PUBLIC void LYpop ARGS1(
	DocInfo *,	doc)
d555 1
a555 1
		    nhist, doc->address, doc->title));
d560 1
a560 1
 *  Move to the previous filename, link and line number from the history list.
d562 1
a562 2
PUBLIC void LYhist_prev ARGS1(
	DocInfo *,	doc)
d565 1
a565 1
    if (nhist > 0 && (nhist_extra || nhist < MAXHIST)) {
d574 1
a574 1
 *  Called before calling LYhist_prev().
d576 1
a576 2
PUBLIC void LYhist_prev_register ARGS1(
	DocInfo *,	doc)
d584 3
a586 5
	} else if (nhist < MAXHIST) { /* push will fail */
	    if (LYpush(doc, 0)) {
		nhist--;
		nhist_extra++;
	    }
d593 1
a593 1
 *  Move to the next filename, link and line number from the history.
d595 1
a595 3
PUBLIC int LYhist_next ARGS2(
	DocInfo *,	doc,
	DocInfo *,	newdoc)
d602 1
d610 3
a612 3
 *  Pop the specified hist entry, link and line number from the history
 *  list but don't actually remove the entry, just return it.
 *  (This procedure is badly named :)
d614 2
a615 3
PUBLIC void LYpop_num ARGS2(
	int,		number,
	DocInfo *,	doc)
d627 1
a627 1
	doc->internal_link = HDOC(number).internal_link; /* ?? */
d636 1
a636 1
 *  This procedure outputs the history buffer into a temporary file.
d638 1
a638 2
PUBLIC int showhistory ARGS1(
	char **,	newfile)
d646 1
a646 1
	return(-1);
d656 1
a656 1
		 STR_LYNXMESSAGES, STATUSLINES_TITLE);
d663 2
a664 2
	 *  The number of the document in the hist stack,
	 *  its title in a link, and its address. - FM
d672 1
a672 1
		StrAllocCopy(Title , NO_TITLE);
d687 1
a687 1
	    if (history[x].intern_seq_start == history[nhist-1].intern_seq_start)
d694 1
a694 1
    fprintf(fp0,"</pre>\n");
d699 1
a699 1
    return(0);
d703 5
a707 4
 *  This function makes the history page seem like any other type of
 *  file since more info is needed than can be provided by the normal
 *  link structure.  We saved out the history number to a special URL.
 *  The info looks like:  LYNXHIST:#
d709 1
a709 2
PUBLIC BOOLEAN historytarget ARGS1(
	DocInfo *,	newdoc)
d718 2
a719 2
	strlen(newdoc->address) < 10 || !isdigit(UCH(*(newdoc->address+9))))
	return(FALSE);
d721 2
a722 2
    if ((number = atoi(newdoc->address+9)) > nhist + nhist_extra || number < 0)
	return(FALSE);
d735 2
a736 2
	strcmp(HTLoadedDocumentURL(), HDOC(nhist-1).address)) {
	HTuncache_current_document();  /* don't waste the cache */
d741 4
a744 4
	  history[number].intern_seq_start == history[nhist-1].intern_seq_start) ||
	 (number < nhist-1 &&
	  HDOC(nhist-1).internal_link &&
	  number == history[nhist-1].intern_seq_start))
d756 3
a758 3
     *	If we have POST content, and have LYresubmit_posts set
     *	or have no_cache set or do not still have the text cached,
     *	ask the user whether to resubmit the form. - FM
d768 1
a768 1
	text = (HText *)HTAnchor_document(tmpanchor);
d783 1
a783 1
	    return(FALSE);
d789 1
a789 1
    return(TRUE);
d793 2
a794 2
 *  This procedure outputs the Visited Links list into a temporary file. - FM
 *  Returns links's number to make active (1-based), or 0 if not required.
d796 1
a796 2
PUBLIC int LYShowVisitedLinks ARGS1(
	char **,	newfile)
d807 1
a807 1
    char *arrow, *post_arrow;
d810 1
a810 1
	return(-1);
d813 1
a813 1
	return(-1);
d823 1
d825 1
a825 13
    fprintf(fp0, "<select name=\"visited_pages_type\">\n");
    fprintf(fp0, " <option value=\"first_visited\" %s>Sort By First Visited\n",
		 (Visited_Links_As == VISITED_LINKS_AS_FIRST_V ? "selected" : ""));
    fprintf(fp0, " <option value=\"first_visited_reversed\" %s>Reverse Sort By First Visited\n",
		 (Visited_Links_As == (VISITED_LINKS_AS_FIRST_V|VISITED_LINKS_REVERSE) ? "selected" : ""));
    fprintf(fp0, " <option value=\"visit_tree\" %s>View As Visit Tree\n",
		 (Visited_Links_As == VISITED_LINKS_AS_TREE ? "selected" : ""));
    fprintf(fp0, " <option value=\"last_visited\" %s>Sort By Last Visited\n",
		 (Visited_Links_As == VISITED_LINKS_AS_LATEST ? "selected" : ""));
    fprintf(fp0, " <option value=\"last_visited_reversed\" %s>Reverse Sort By Last Visited\n",
		 (Visited_Links_As == (VISITED_LINKS_AS_LATEST|VISITED_LINKS_REVERSE)
		   ? "selected" : ""));
    fprintf(fp0, "</select>\n");
d829 1
d852 1
a852 1
	    vl = (VisitedLink *)HTList_nextObject(cur);
d856 2
a857 2
	 *  The number of the document (most recent highest),
	 *  its title in a link, and its address. - FM
d874 1
a874 1
			 ? "==>" : "=>";
d880 3
a882 3
		offset = (offset + 24)/2;
	    if (offset > LYcols * 3/4)
		offset = LYcols * 3/4;
d885 1
a885 1
	if (vl->title != NULL && *vl->title != '\0') {
d891 1
a891 1
		StrAllocCopy(Title , NO_TITLE);
d893 1
a893 1
	    StrAllocCopy(Title , NO_TITLE);
d895 1
a895 1
	if (vl->address != NULL && *vl->address != '\0') {
d913 1
a913 1
		     ((Address != NULL) ? Address : gettext("(no address)")));
d927 1
a927 1
		vl = (VisitedLink *)HTList_nextObject(cur);
d930 1
a930 1
    fprintf(fp0,"</pre>\n");
d936 1
a936 1
    return(ret);
a938 1

d940 1
a940 1
 *  Keep cycled buffer for statusline messages.
d943 2
a944 2
PRIVATE char * buffstack[STATUSBUFSIZE];
PRIVATE int topOfStack = 0;
d947 1
a947 1
PRIVATE void free_messages_stack NOARGS
d957 1
a957 1
PRIVATE void to_stack ARGS1(char *, str)
d960 1
a960 1
     *  Cycle buffer:
d967 1
a967 1
     *  Register string.
d973 1
a973 1
    if(!already_registered_free_messages_stack) {
a982 1

d990 1
a990 2
PUBLIC void LYstatusline_messages_on_exit ARGS1(
	char **,	buf)
d1014 2
a1015 4

PUBLIC void LYstore_message2 ARGS2(
	CONST char *,	message,
	CONST char *,	argument)
d1020 1
d1026 1
a1026 2
PUBLIC void LYstore_message ARGS1(
	CONST char *,	message)
d1030 1
d1037 5
a1041 5
**     --------------
**     Create a text/html stream with a list of recent statusline messages.
**     LYNXMESSAGES:/ internal page.
**     [implementation based on LYLoadKeymap()].
*/
d1043 2
a1044 3
struct _HTStream
{
    HTStreamClass * isa;
d1047 4
a1050 5
PRIVATE int LYLoadMESSAGES ARGS4 (
	CONST char *,		arg GCC_UNUSED,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d1067 1
a1067 1
     *  Set up the stream. - FM
d1073 1
a1073 1
			 HTAtom_name(format_in), HTAtom_name(format_out));
d1076 1
a1076 1
	return(HT_NOT_LOADED);
d1084 3
a1086 3
	/*
	 *  This page is a list of messages in display character set.
	 */
d1127 1
a1127 1
    (*target->isa->_free)(target);
d1129 1
a1129 1
    return(HT_LOADED);
d1134 1
a1134 1
GLOBALDEF (HTProtocol,LYLynxStatusMessages,_LYMESSAGES_C_GLOBALDEF_1_INIT);
d1136 2
a1137 1
GLOBALDEF PUBLIC HTProtocol LYLynxStatusMessages = {"LYNXMESSAGES", LYLoadMESSAGES, 0};
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d17 4
a20 1
#include <LYGetFile.h>
d29 1
d32 15
d57 2
d69 3
d76 14
d95 1
a95 1
	document *,	doc)
a97 1
    VisitedLink *old;
d99 1
d101 2
a102 1
    if (!(doc->address && *doc->address))
d104 1
d113 8
a120 6
	  !strncmp(doc->address, "file://localhost/", 17))
	 && (
	!strcmp((doc->title ? doc->title : ""), HISTORY_PAGE_TITLE) ||
	!strcmp((doc->title ? doc->title : ""), PRINT_OPTIONS_TITLE) ||
	!strcmp((doc->title ? doc->title : ""), DOWNLOAD_OPTIONS_TITLE) ||
	!strcmp((doc->title ? doc->title : ""), OPTIONS_TITLE) ||
d122 3
a124 3
	!strcmp((doc->title ? doc->title : ""), DIRED_MENU_TITLE) ||
	!strcmp((doc->title ? doc->title : ""), UPLOAD_OPTIONS_TITLE) ||
	!strcmp((doc->title ? doc->title : ""), PERMIT_OPTIONS_TITLE) ||
d126 5
a130 2
	!strcmp((doc->title ? doc->title : ""), CURRENT_KEYMAP_TITLE) ||
	!strcmp((doc->title ? doc->title : ""), LIST_PAGE_TITLE) ||
d132 1
a132 1
	!strcmp((doc->title ? doc->title : ""), ADDRLIST_PAGE_TITLE) ||
d134 8
a141 8
	!strcmp((doc->title ? doc->title : ""), SHOWINFO_TITLE) ||
	!strcmp((doc->title ? doc->title : ""), STATUSLINES_TITLE) ||
	!strcmp((doc->title ? doc->title : ""), CONFIG_DEF_TITLE) ||
	!strcmp((doc->title ? doc->title : ""), LYNXCFG_TITLE) ||
	!strcmp((doc->title ? doc->title : ""), COOKIE_JAR_TITLE) ||
	!strcmp((doc->title ? doc->title : ""), VISITED_LINKS_TITLE) ||
	!strcmp((doc->title ? doc->title : ""), LYNX_TRACELOG_TITLE)))) {
	return;
a143 5
    if ((new = (VisitedLink *)calloc(1, sizeof(*new))) == NULL)
	outofmem(__FILE__, "LYAddVisitedLink");
    StrAllocCopy(new->address, doc->address);
    StrAllocCopy(new->title, (doc->title ? doc->title : NO_TITLE));

d149 5
a153 2
	HTList_addObject(Visited_Links, new);
	return;
d157 18
a174 10
    while (NULL != (old = (VisitedLink *)HTList_nextObject(cur))) {
	if (!strcmp((old->address ? old->address : ""),
		    (new->address ? new->address : "")) &&
	    !strcmp((old->title ? new->title : ""),
		    (new->title ? new->title : ""))) {
	    FREE(old->address);
	    FREE(old->title);
	    HTList_removeObject(Visited_Links, old);
	    FREE(old);
	    break;
d177 43
a219 1
    HTList_addObject(Visited_Links, new);
d226 3
a228 1
 *  forced.
d230 3
a232 2
PUBLIC BOOLEAN LYwouldPush ARGS1(
	char *,	title)
d234 23
a256 3
    return (!strcmp(title, HISTORY_PAGE_TITLE)
	 || !strcmp(title, PRINT_OPTIONS_TITLE)
	 || !strcmp(title, DOWNLOAD_OPTIONS_TITLE)
d258 3
a260 3
	 || !strcmp(title, DIRED_MENU_TITLE)
	 || !strcmp(title, UPLOAD_OPTIONS_TITLE)
	 || !strcmp(title, PERMIT_OPTIONS_TITLE)
d262 78
a339 3
	 )
	 ? FALSE
	 : TRUE;
d345 2
a346 2
PUBLIC void LYpush ARGS2(
	document *,	doc,
d353 1
a353 1
	return;
d363 1
a363 1
	if (!LYwouldPush(doc->title)) {
d366 1
a366 1
	    return;
d373 2
a374 12
    if (nhist> 1 &&
	STREQ(history[nhist-1].address, doc->address) &&
	!strcmp(history[nhist-1].post_data ?
		history[nhist-1].post_data : "",
		doc->post_data ?
		doc->post_data : "") &&
	!strcmp(history[nhist-1].bookmark ?
		history[nhist-1].bookmark : "",
		doc->bookmark ?
		doc->bookmark : "") &&
	history[nhist-1].isHEAD == doc->isHEAD) {
	if (history[nhist-1].internal_link == doc->internal_link) {
d377 3
a379 3
	    history[nhist-1].link = doc->link;
	    history[nhist-1].line = doc->line;
	    return;
d382 21
d407 8
a414 14
	history[nhist].link = doc->link;
	history[nhist].line = doc->line;
	history[nhist].title = NULL;
	StrAllocCopy(history[nhist].title, doc->title);
	history[nhist].address = NULL;
	StrAllocCopy(history[nhist].address, doc->address);
	history[nhist].post_data = NULL;
	StrAllocCopy(history[nhist].post_data, doc->post_data);
	history[nhist].post_content_type = NULL;
	StrAllocCopy(history[nhist].post_content_type, doc->post_content_type);
	history[nhist].bookmark = NULL;
	StrAllocCopy(history[nhist].bookmark, doc->bookmark);
	history[nhist].isHEAD = doc->isHEAD;
	history[nhist].safe = doc->safe;
d416 13
a428 1
	history[nhist].internal_link = FALSE; /* by default */
d450 1
a450 1
		    HTAnchor_parent(HTAnchor_findAddress(&WWWDoc));
d458 3
a460 3
		    if (0==strncmp(history[nhist-1].address,"LYNXIMGMAP:",11) &&
			0!=strncmp(doc->address,"LYNXIMGMAP:",11)) {
			WWWDoc.address = history[nhist-1].address + 11;
d466 2
a467 2
		    } else if ((0==strncmp(doc->address,"LYNXIMGMAP:",11) &&
		       0!=strncmp(history[nhist-1].address,"LYNXIMGMAP:",11))) {
d469 2
a470 2
			StrAllocCopy(temp, "LYNXIMGMAP:");
			StrAllocCat(temp, doc->address+11);
d472 4
a475 4
			WWWDoc.post_content_type = history[nhist-1].post_content_type;
			WWWDoc.bookmark = history[nhist-1].bookmark;
			WWWDoc.isHEAD = history[nhist-1].isHEAD;
			WWWDoc.safe = history[nhist-1].safe;
d477 1
a477 1
			    HTAnchor_parent(HTAnchor_findAddress(&WWWDoc));
d480 1
a480 1
			WWWDoc.address = history[nhist-1].address;
d483 5
a487 5
			WWWDoc.post_data = history[nhist-1].post_data;
			WWWDoc.post_content_type = history[nhist-1].post_content_type;
			WWWDoc.bookmark = history[nhist-1].bookmark;
			WWWDoc.isHEAD = history[nhist-1].isHEAD;
			WWWDoc.safe = history[nhist-1].safe;
d489 1
a489 1
			    HTAnchor_parent(HTAnchor_findAddress(&WWWDoc));
d491 6
a496 6
		/* In addition to equality of the ParentAnchors, require
		** that IF we have a HTMainText (i.e., it wasn't just
		** HTuncache'd by mainloop), THEN it has to be consistent
		** with what we are trying to push.
		**   This may be overkill... - kw
		*/
d500 1
a500 1
			history[nhist].internal_link = TRUE;
d504 1
a504 1
			CTRACE(tfp, "\nLYpush: pushed as internal link, OK\n");
d508 3
a510 3
	    if (!history[nhist].internal_link) {
		CTRACE(tfp, "\nLYpush: push as internal link requested, %s\n",
			    "but didn't check out!");
d513 2
a514 2
	CTRACE(tfp, "\nLYpush[%d]: address:%s\n        title:%s\n",
		    nhist, doc->address, doc->title);
d520 2
a521 2
	CTRACE(tfp, "\nLYpush: MAXHIST reached for:\n        address:%s\n        title:%s\n",
		    doc->address, doc->title);
d523 1
d530 1
a530 1
	document *,	doc)
d533 1
d535 5
a539 15
	doc->link = history[nhist].link;
	doc->line = history[nhist].line;
	FREE(doc->title);
	doc->title = history[nhist].title;	 /* will be freed later */
	FREE(doc->address);
	doc->address = history[nhist].address;	 /* will be freed later */
	FREE(doc->post_data);
	doc->post_data = history[nhist].post_data;
	FREE(doc->post_content_type);
	doc->post_content_type = history[nhist].post_content_type;
	FREE(doc->bookmark);
	doc->bookmark = history[nhist].bookmark; /* will be freed later */
	doc->isHEAD = history[nhist].isHEAD;
	doc->safe = history[nhist].safe;
	doc->internal_link = history[nhist].internal_link;
d542 1
a542 1
	Newline_partial = doc->line;	/* reinitialize */
d544 17
a560 2
	CTRACE(tfp, "LYpop[%d]: address:%s\n     title:%s\n",
		    nhist, doc->address, doc->title);
d565 40
d611 1
a611 1
	document *,	doc)
d613 11
a623 11
    if (number >= 0 && nhist > number) {
	doc->link = history[number].link;
	doc->line = history[number].line;
	StrAllocCopy(doc->title, history[number].title);
	StrAllocCopy(doc->address, history[number].address);
	StrAllocCopy(doc->post_data, history[number].post_data);
	StrAllocCopy(doc->post_content_type, history[number].post_content_type);
	StrAllocCopy(doc->bookmark, history[number].bookmark);
	doc->isHEAD = history[number].isHEAD;
	doc->safe = history[number].safe;
	doc->internal_link = history[number].internal_link; /* ?? */
d626 1
a626 1
	Newline_partial = doc->line;	/* reinitialize */
d637 1
a637 1
    static char tempfile[LY_MAXPATH];
d642 1
a642 3
    LYRemoveTemp(tempfile);
    if ((fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w")) == NULL) {
	HTAlert(CANNOT_OPEN_TEMP);
a643 1
    }
d652 2
a653 2
    fprintf(fp0, "<tr align=right> <a href=\"LYNXMESSAGES:\">[%s]</a> </tr>\n",
		 STATUSLINES_TITLE);
d658 1
a658 1
    for (x = nhist-1; x >= 0; x--) {
d663 2
a664 2
	if (history[x].title != NULL) {
	    StrAllocCopy(Title, history[x].title);
d674 1
a674 1
		"%s<em>%d</em>. <tab id=t%d><a href=\"LYNXHIST:%d\">%s</a>\n",
d676 3
a678 3
		x, x, x, Title);
	if (history[x].address != NULL) {
	    StrAllocCopy(Title, history[x].address);
d683 1
a683 1
	if (history[x].internal_link) {
d706 1
a706 1
	document *,	newdoc)
d715 1
a715 1
	strlen(newdoc->address) < 10 || !isdigit(*(newdoc->address+9)))
d718 1
a718 1
    if ((number = atoi(newdoc->address+9)) > nhist || number < 0)
d724 4
d729 6
a734 1
    HTuncache_current_document();  /* don't waste the cache */
d740 1
a740 1
	  history[nhist-1].internal_link &&
d764 1
a764 1
	tmpanchor = HTAnchor_parent(HTAnchor_findAddress(&WWWDoc));
d771 1
a771 1
	    (!strncmp(newdoc->address, "LYNXIMGMAP:", 11) ||
d790 2
a791 2
 *  This procedure outputs the Visited Links
 *  list into a temporary file. - FM
d796 1
a796 1
    static char tempfile[LY_MAXPATH];
d799 1
a799 1
    int x;
d803 3
d810 1
a810 3
    LYRemoveTemp(tempfile);
    if ((fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w")) == NULL) {
	HTAlert(CANNOT_OPEN_TEMP);
a811 1
    }
d814 1
d821 18
d842 21
a862 2
    x = HTList_count(Visited_Links);
    while (NULL != (vl = (VisitedLink *)HTList_nextObject(cur))) {
d867 26
a892 1
	x--;
d907 2
a908 2
		    "%s<em>%d</em>. <tab id=t%d><a href=\"%s\">%s</a>\n",
		    (x > 99 ? "" : x < 10 ? "  " : " "),
d912 2
a913 2
		    "%s<em>%d</em>. <tab id=t%d><em>%s</em>\n",
		    (x > 99 ? "" : x < 10 ? "  " : " "),
d922 15
d944 1
a944 1
    return(0);
a953 3
#ifdef LY_FIND_LEAKS
PRIVATE int already_registered_free_messages_stack = 0;
#endif
d971 1
a971 1
    if (topOfStack == STATUSBUFSIZE) {
d987 3
a993 58
 *  Status line messages list, LYNXMESSAGES:/ internal page,
 *  called from getfile() cyrcle.
 */
PUBLIC int LYshow_statusline_messages ARGS1(
    document *,			      newdoc)
{
    static char tempfile[LY_MAXPATH];
    static char *info_url;
    DocAddress WWWDoc;  /* need on exit */
    FILE *fp0;
    int i;

    LYRemoveTemp(tempfile);
    if ((fp0 = LYOpenTemp (tempfile, HTML_SUFFIX, "w")) == 0) {
	HTAlert(CANNOT_OPEN_TEMP);
	return(NOT_FOUND);
    }
    LYLocalFileToURL(&info_url, tempfile);

    LYforce_no_cache = TRUE;  /* don't cache this doc */

    BeginInternalPage (fp0, STATUSLINES_TITLE, NULL);
    fprintf(fp0, "<pre>\n");
    fprintf(fp0, "<ol>\n");

    /* print messages in reverse order: */
    i = topOfStack;
    while (--i >= 0) {
	if (buffstack[i] != NULL)
	    fprintf(fp0,  "<li> <em>%s</em>\n",  buffstack[i]);
    }
    i = STATUSBUFSIZE;
    while (--i >= topOfStack) {
	if (buffstack[i] != NULL)
	fprintf(fp0,  "<li> <em>%s</em>\n",  buffstack[i]);
    }

    fprintf(fp0, "</ol>\n");
    fprintf(fp0, "</pre>\n");
    EndInternalPage(fp0);
    LYCloseTempFP(fp0);


    /* exit to getfile() cyrcle */
    StrAllocCopy(newdoc->address, info_url);
    WWWDoc.address = newdoc->address;
    WWWDoc.post_data = newdoc->post_data;
    WWWDoc.post_content_type = newdoc->post_content_type;
    WWWDoc.bookmark = newdoc->bookmark;
    WWWDoc.isHEAD = newdoc->isHEAD;
    WWWDoc.safe = newdoc->safe;

    if (!HTLoadAbsolute(&WWWDoc))
	return(NOT_FOUND);
    return(NORMAL);
}

/*
d1010 1
a1010 1
    while (++i <= STATUSBUFSIZE) {
d1033 1
a1033 1
	HTSprintf(&temp, message, (argument == 0) ? "" : argument);
d1047 105
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d17 1
a17 5
#include <LYCharSets.h>
#include <LYrcFile.h>
#ifdef DISP_PARTIAL
#include <LYMainLoop.h>
#endif
a25 11
#include <HTCJK.h>

static HTList *Visited_Links = NULL;	/* List of safe popped docs. */
int Visited_Links_As = VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE;
static VisitedLink *PrevVisitedLink = NULL;	/* NULL on auxillary */
static VisitedLink *PrevActiveVisitedLink = NULL;	/* Last non-auxillary */
static VisitedLink Latest_first;
static VisitedLink Latest_last;
static VisitedLink *Latest_tree;
static VisitedLink *First_tree;
static VisitedLink *Last_by_first;
d27 1
a27 6
int nhist_extra;

#ifdef LY_FIND_LEAKS
static int already_registered_free_messages_stack = 0;
static int already_registered_clean_all_history = 0;
#endif
d31 1
a31 1
 * Utility for freeing the list of visited links.  - FM
d33 1
a33 1
static void Visited_Links_free(void)
a37 2
    PrevVisitedLink = NULL;
    PrevActiveVisitedLink = NULL;
d41 1
a41 1
    while (NULL != (vl = (VisitedLink *) HTList_nextObject(cur))) {
a47 3
    Latest_last.prev_latest = &Latest_first;
    Latest_first.next_latest = &Latest_last;
    Last_by_first = Latest_tree = First_tree = 0;
a51 13
#ifdef DEBUG
static void trace_history(const char *tag)
{
    if (TRACE) {
	CTRACE((tfp, "HISTORY %s %d/%d (%d extra)\n",
		tag, nhist, size_history, nhist_extra));
	CTRACE_FLUSH(tfp);
    }
}
#else
#define trace_history(tag)	/* nothing */
#endif /* DEBUG */

d53 2
a54 2
 * Utility for listing visited links, making any repeated links the most
 * current in the list.  - FM
d56 2
a57 1
void LYAddVisitedLink(DocInfo *doc)
d59 2
a60 1
    VisitedLink *tmp;
a61 1
    const char *title = (doc->title ? doc->title : NO_TITLE);
d63 1
a63 2
    if (isEmpty(doc->address)) {
	PrevVisitedLink = NULL;
a64 1
    }
d67 2
a68 1
     * Exclude POST or HEAD replies, and bookmark, menu or list files.  - FM
d71 8
a78 10
	(			/* special url or a temp file */
	    (!strncmp(doc->address, "LYNX", 4) ||
	     !strncmp(doc->address, "file://localhost/", 17)))) {
	int related = 1;	/* First approximation only */

	if (LYIsUIPage(doc->address, UIP_HISTORY) ||
	    LYIsUIPage(doc->address, UIP_VLINKS) ||
	    LYIsUIPage(doc->address, UIP_SHOWINFO) ||
	    isLYNXMESSAGES(doc->address) ||
	    (related = 0) ||
d80 3
a82 3
	    LYIsUIPage(doc->address, UIP_DIRED_MENU) ||
	    LYIsUIPage(doc->address, UIP_UPLOAD_OPTIONS) ||
	    LYIsUIPage(doc->address, UIP_PERMIT_OPTIONS) ||
d84 2
a85 5
	    LYIsUIPage(doc->address, UIP_PRINT_OPTIONS) ||
	    LYIsUIPage(doc->address, UIP_DOWNLOAD_OPTIONS) ||
	    LYIsUIPage(doc->address, UIP_OPTIONS_MENU) ||
	    isLYNXKEYMAP(doc->address) ||
	    LYIsUIPage(doc->address, UIP_LIST_PAGE) ||
d87 1
a87 1
	    LYIsUIPage(doc->address, UIP_ADDRLIST_PAGE) ||
d89 8
a96 8
	    LYIsUIPage(doc->address, UIP_CONFIG_DEF) ||
	    LYIsUIPage(doc->address, UIP_LYNXCFG) ||
	    isLYNXCOOKIE(doc->address) ||
	    LYIsUIPage(doc->address, UIP_TRACELOG)) {
	    if (!related)
		PrevVisitedLink = NULL;
	    return;
	}
d99 5
d109 2
a110 5
	Latest_last.prev_latest = &Latest_first;
	Latest_first.next_latest = &Latest_last;
	Latest_last.next_latest = NULL;		/* Find bugs quick! */
	Latest_first.prev_latest = NULL;
	Last_by_first = Latest_tree = First_tree = NULL;
d114 10
a123 18
    while (NULL != (tmp = (VisitedLink *) HTList_nextObject(cur))) {
	if (!strcmp(NonNull(tmp->address),
		    NonNull(doc->address))) {
	    PrevVisitedLink = PrevActiveVisitedLink = tmp;
	    /* Already visited.  Update the last-visited info. */
	    if (tmp->next_latest == &Latest_last)	/* optimization */
		return;

	    /* Remove from "latest" chain */
	    tmp->prev_latest->next_latest = tmp->next_latest;
	    tmp->next_latest->prev_latest = tmp->prev_latest;

	    /* Insert at the end of the "latest" chain */
	    Latest_last.prev_latest->next_latest = tmp;
	    tmp->prev_latest = Latest_last.prev_latest;
	    tmp->next_latest = &Latest_last;
	    Latest_last.prev_latest = tmp;
	    return;
d126 1
a126 43

    if ((tmp = typecalloc(VisitedLink)) == NULL)
	outofmem(__FILE__, "LYAddVisitedLink");
    StrAllocCopy(tmp->address, doc->address);
    LYformTitle(&(tmp->title), title);

    /* First-visited chain */
    HTList_appendObject(Visited_Links, tmp);	/* At end */
    tmp->prev_first = Last_by_first;
    Last_by_first = tmp;

    /* Tree structure */
    if (PrevVisitedLink) {
	VisitedLink *a = PrevVisitedLink;
	VisitedLink *b = a->next_tree;
	int l = PrevVisitedLink->level;

	/* Find last on the deeper levels */
	while (b && b->level > l)
	    a = b, b = b->next_tree;

	if (!b)			/* a == Latest_tree */
	    Latest_tree = tmp;
	tmp->next_tree = a->next_tree;
	a->next_tree = tmp;

	tmp->level = PrevVisitedLink->level + 1;
    } else {
	if (Latest_tree)
	    Latest_tree->next_tree = tmp;
	tmp->level = 0;
	tmp->next_tree = NULL;
	Latest_tree = tmp;
    }
    PrevVisitedLink = PrevActiveVisitedLink = tmp;
    if (!First_tree)
	First_tree = tmp;

    /* "latest" chain */
    Latest_last.prev_latest->next_latest = tmp;
    tmp->prev_latest = Latest_last.prev_latest;
    tmp->next_latest = &Latest_last;
    Latest_last.prev_latest = tmp;
d132 2
a133 3
 * Returns true if this is a page that we would push onto the stack if not
 * forced.  If docurl is NULL, only the title is considered; otherwise also
 * check the URL whether it is (likely to be) a generated special page.
d135 2
a136 2
BOOLEAN LYwouldPush(const char *title,
		    const char *docurl)
d138 3
a140 24
    BOOLEAN rc = FALSE;

    /*
     * All non-pushable generated pages have URLs that begin with
     * "file://localhost/" and end with HTML_SUFFIX.  - kw
     */
    if (docurl) {
	size_t ulen;

	if (strncmp(docurl, "file://localhost/", 17) != 0 ||
	    (ulen = strlen(docurl)) <= strlen(HTML_SUFFIX) ||
	    strcmp(docurl + ulen - strlen(HTML_SUFFIX), HTML_SUFFIX) != 0) {
	    /*
	     * If it is not a local HTML file, it may be a Web page that
	     * accidentally has the same title.  So return TRUE now.  - kw
	     */
	    return TRUE;
	}
    }

    if (docurl) {
	rc = (BOOLEAN)
	    !(LYIsUIPage(docurl, UIP_HISTORY)
	      || LYIsUIPage(docurl, UIP_PRINT_OPTIONS)
d142 3
a144 3
	      || LYIsUIPage(docurl, UIP_DIRED_MENU)
	      || LYIsUIPage(docurl, UIP_UPLOAD_OPTIONS)
	      || LYIsUIPage(docurl, UIP_PERMIT_OPTIONS)
d146 3
a148 33
	    );
    } else {
	rc = (BOOLEAN)
	    !(!strcmp(title, HISTORY_PAGE_TITLE)
	      || !strcmp(title, PRINT_OPTIONS_TITLE)
#ifdef DIRED_SUPPORT
	      || !strcmp(title, DIRED_MENU_TITLE)
	      || !strcmp(title, UPLOAD_OPTIONS_TITLE)
	      || !strcmp(title, PERMIT_OPTIONS_TITLE)
#endif /* DIRED_SUPPORT */
	    );
    }
    return rc;
}

/*
 * Free post-data for 'DocInfo'
 */
void LYFreePostData(DocInfo *doc)
{
    BStrFree(doc->post_data);
    FREE(doc->post_content_type);
}

/*
 * Free strings associated with a 'DocInfo' struct.
 */
void LYFreeDocInfo(DocInfo *doc)
{
    FREE(doc->title);
    FREE(doc->address);
    FREE(doc->bookmark);
    LYFreePostData(doc);
d152 1
a152 1
 * Free the information in the last history entry.
d154 3
a156 66
static void clean_extra_history(void)
{
    trace_history("clean_extra_history");
    nhist += nhist_extra;
    while (nhist_extra > 0) {
	nhist--;
	LYFreeDocInfo(&HDOC(nhist));
	nhist_extra--;
    }
    trace_history("...clean_extra_history");
}

/*
 * Free the entire history stack, for auditing memory leaks.
 */
#ifdef LY_FIND_LEAKS
static void clean_all_history(void)
{
    trace_history("clean_all_history");
    clean_extra_history();
    while (nhist > 0) {
	nhist--;
	LYFreeDocInfo(&HDOC(nhist));
    }
    trace_history("...clean_all_history");
}
#endif

/* FIXME What is the relationship to are_different() from the mainloop?! */
static int are_identical(HistInfo * doc, DocInfo *doc1)
{
    return (STREQ(doc1->address, doc->hdoc.address)
	    && BINEQ(doc1->post_data, doc->hdoc.post_data)
	    && !strcmp(NonNull(doc1->bookmark),
		       NonNull(doc->hdoc.bookmark))
	    && doc1->isHEAD == doc->hdoc.isHEAD);
}

void LYAllocHistory(int entries)
{
    CTRACE((tfp, "LYAllocHistory %d vs %d\n", entries, size_history));
    if (entries + 1 >= size_history) {
	unsigned want;
	int save = size_history;

	size_history = (entries + 2) * 2;
	want = size_history * sizeof(*history);
	if (history == 0) {
	    history = (HistInfo *) malloc(want);
	} else {
	    history = (HistInfo *) realloc(history, want);
	}
	if (history == 0)
	    outofmem(__FILE__, "LYAllocHistory");
	while (save < size_history) {
	    CTRACE((tfp, "...LYAllocHistory clearing %d\n", save));
	    memset(&history[save++], 0, sizeof(history[0]));
	}
    }
    CTRACE((tfp, "...LYAllocHistory %d vs %d\n", entries, size_history));
}

/*
 * Push the current filename, link and line number onto the history list.
 */
int LYpush(DocInfo *doc, BOOLEAN force_push)
d159 1
a159 1
     * Don't push NULL file names.
d162 1
a162 1
	return 0;
d165 2
a166 1
     * Check whether this is a document we don't push unless forced.  - FM
d170 1
a170 1
	 * Don't push the history, printer, or download lists.
d172 1
a172 1
	if (!LYwouldPush(doc->title, doc->address)) {
d175 1
a175 1
	    return 0;
d180 1
a180 1
     * If file is identical to one before it, don't push it.
d182 12
a193 2
    if (nhist > 1 && are_identical(&(history[nhist - 1]), doc)) {
	if (HDOC(nhist - 1).internal_link == doc->internal_link) {
d196 3
a198 3
	    HDOC(nhist - 1).link = doc->link;
	    HDOC(nhist - 1).line = doc->line;
	    return 0;
a200 22

    /*
     * If file is identical to the current document, just move the pointer.
     */
    if (nhist_extra >= 1 && are_identical(&(history[nhist]), doc)) {
	HDOC(nhist).link = doc->link;
	HDOC(nhist).line = doc->line;
	nhist_extra--;
	LYAllocHistory(nhist);
	nhist++;
	trace_history("LYpush: just move the cursor");
	return 1;
    }

    clean_extra_history();
#ifdef LY_FIND_LEAKS
    if (!already_registered_clean_all_history) {
	already_registered_clean_all_history = 1;
	atexit(clean_all_history);
    }
#endif

d202 1
a202 1
     * OK, push it...
d204 49
a252 56
    LYAllocHistory(nhist);
    HDOC(nhist).link = doc->link;
    HDOC(nhist).line = doc->line;

    HDOC(nhist).title = NULL;
    LYformTitle(&(HDOC(nhist).title), doc->title);

    HDOC(nhist).address = NULL;
    StrAllocCopy(HDOC(nhist).address, doc->address);

    HDOC(nhist).post_data = NULL;
    BStrCopy(HDOC(nhist).post_data, doc->post_data);

    HDOC(nhist).post_content_type = NULL;
    StrAllocCopy(HDOC(nhist).post_content_type, doc->post_content_type);

    HDOC(nhist).bookmark = NULL;
    StrAllocCopy(HDOC(nhist).bookmark, doc->bookmark);

    HDOC(nhist).isHEAD = doc->isHEAD;
    HDOC(nhist).safe = doc->safe;

    HDOC(nhist).internal_link = FALSE;	/* by default */
    history[nhist].intern_seq_start = -1;	/* by default */
    if (doc->internal_link) {
	/* Now some tricky stuff: if the caller thinks that the doc
	   to push was the result of following an internal
	   (fragment) link, we check whether we believe it.
	   It is only accepted as valid if the immediately preceding
	   item on the history stack is actually the same document
	   except for fragment and location info.  I.e. the Parent
	   Anchors are the same.
	   Also of course this requires that this is not the first
	   history item. - kw */
	if (nhist > 0) {
	    DocAddress WWWDoc;
	    HTParentAnchor *thisparent, *thatparent = NULL;

	    WWWDoc.address = doc->address;
	    WWWDoc.post_data = doc->post_data;
	    WWWDoc.post_content_type = doc->post_content_type;
	    WWWDoc.bookmark = doc->bookmark;
	    WWWDoc.isHEAD = doc->isHEAD;
	    WWWDoc.safe = doc->safe;
	    thisparent =
		HTAnchor_findAddress(&WWWDoc);
	    /* Now find the ParentAnchor for the previous history
	     * item - kw
	     */
	    if (thisparent) {
		/* If the last-pushed item is a LYNXIMGMAP but THIS one
		 * isn't, compare the physical URLs instead. - kw
		 */
		if (isLYNXIMGMAP(HDOC(nhist - 1).address) &&
		    !isLYNXIMGMAP(doc->address)) {
		    WWWDoc.address = HDOC(nhist - 1).address + LEN_LYNXIMGMAP;
d254 29
a282 30
		     * If THIS item is a LYNXIMGMAP but the last-pushed one
		     * isn't, fake it by using THIS item's address for
		     * thatparent... - kw
		     */
		} else if (isLYNXIMGMAP(doc->address) &&
			   !isLYNXIMGMAP(HDOC(nhist - 1).address)) {
		    char *temp = NULL;

		    StrAllocCopy(temp, STR_LYNXIMGMAP);
		    StrAllocCat(temp, doc->address + LEN_LYNXIMGMAP);
		    WWWDoc.address = temp;
		    WWWDoc.post_content_type = HDOC(nhist - 1).post_content_type;
		    WWWDoc.bookmark = HDOC(nhist - 1).bookmark;
		    WWWDoc.isHEAD = HDOC(nhist - 1).isHEAD;
		    WWWDoc.safe = HDOC(nhist - 1).safe;
		    thatparent =
			HTAnchor_findAddress(&WWWDoc);
		    FREE(temp);
		} else {
		    WWWDoc.address = HDOC(nhist - 1).address;
		}
		if (!thatparent) {	/* if not yet done */
		    WWWDoc.post_data = HDOC(nhist - 1).post_data;
		    WWWDoc.post_content_type = HDOC(nhist - 1).post_content_type;
		    WWWDoc.bookmark = HDOC(nhist - 1).bookmark;
		    WWWDoc.isHEAD = HDOC(nhist - 1).isHEAD;
		    WWWDoc.safe = HDOC(nhist - 1).safe;
		    thatparent =
			HTAnchor_findAddress(&WWWDoc);
		}
d284 14
a297 14
		 * that IF we have a HTMainText (i.e., it wasn't just
		 * HTuncache'd by mainloop), THEN it has to be consistent
		 * with what we are trying to push.
		 *
		 * This may be overkill...  - kw
		 */
		if (thatparent == thisparent &&
		    (!HTMainText || HTMainAnchor == thisparent)
		    ) {
		    HDOC(nhist).internal_link = TRUE;
		    history[nhist].intern_seq_start =
			history[nhist - 1].intern_seq_start >= 0 ?
			history[nhist - 1].intern_seq_start : nhist - 1;
		    CTRACE((tfp, "\nLYpush: pushed as internal link, OK\n"));
d300 4
d305 6
a310 3
	if (!HDOC(nhist).internal_link) {
	    CTRACE((tfp, "\nLYpush: push as internal link requested, %s\n",
		    "but didn't check out!"));
d312 2
a314 4
    CTRACE((tfp, "\nLYpush[%d]: address:%s\n        title:%s\n",
	    nhist, doc->address, doc->title));
    nhist++;
    return 1;
d318 1
a318 1
 * Pop the previous filename, link and line number from the history list.
d320 2
a321 1
void LYpop(DocInfo *doc)
a323 1
	clean_extra_history();
d325 15
a339 5

	LYFreeDocInfo(doc);

	*doc = HDOC(nhist);

d342 1
a342 1
	LYSetNewline(doc->line);	/* reinitialize */
d344 2
a345 35
	CTRACE((tfp, "LYpop[%d]: address:%s\n     title:%s\n",
		nhist, doc->address, doc->title));
    }
}

/*
 * Move to the previous filename, link and line number from the history list.
 */
void LYhist_prev(DocInfo *doc)
{
    trace_history("LYhist_prev");
    if (nhist > 0 && (nhist_extra || nhist < size_history)) {
	nhist--;
	nhist_extra++;
	LYpop_num(nhist, doc);
	trace_history("...LYhist_prev");
    }
}

/*
 * Called before calling LYhist_prev().
 */
void LYhist_prev_register(DocInfo *doc)
{
    trace_history("LYhist_prev_register");
    if (nhist > 1) {
	if (nhist_extra) {	/* Make something to return back */
	    /* Store the new position */
	    HDOC(nhist).link = doc->link;
	    HDOC(nhist).line = doc->line;
	} else if (LYpush(doc, 0)) {
	    nhist--;
	    nhist_extra++;
	}
	trace_history("...LYhist_prev_register");
d350 19
a368 35
 * Move to the next filename, link and line number from the history.
 */
int LYhist_next(DocInfo *doc, DocInfo *newdoc)
{
    if (nhist_extra <= 1)	/* == 1 when we are the last one */
	return 0;
    /* Store the new position */
    HDOC(nhist).link = doc->link;
    HDOC(nhist).line = doc->line;
    LYAllocHistory(nhist);
    nhist++;
    nhist_extra--;
    LYpop_num(nhist, newdoc);
    return 1;
}

/*
 * Pop the specified hist entry, link and line number from the history list but
 * don't actually remove the entry, just return it.
 * (This procedure is badly named :)
 */
void LYpop_num(int number,
	       DocInfo *doc)
{
    if (number >= 0 && nhist + nhist_extra > number) {
	doc->link = HDOC(number).link;
	doc->line = HDOC(number).line;
	StrAllocCopy(doc->title, HDOC(number).title);
	StrAllocCopy(doc->address, HDOC(number).address);
	BStrCopy(doc->post_data, HDOC(number).post_data);
	StrAllocCopy(doc->post_content_type, HDOC(number).post_content_type);
	StrAllocCopy(doc->bookmark, HDOC(number).bookmark);
	doc->isHEAD = HDOC(number).isHEAD;
	doc->safe = HDOC(number).safe;
	doc->internal_link = HDOC(number).internal_link;	/* ?? */
d371 1
a371 1
	LYSetNewline(doc->line);	/* reinitialize */
d377 1
a377 1
 * This procedure outputs the history buffer into a temporary file.
d379 2
a380 1
int showhistory(char **newfile)
d382 1
a382 1
    static char tempfile[LY_MAXPATH] = "\0";
d387 5
a391 2
    if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	return (-1);
d400 2
a401 2
    fprintf(fp0, "<p align=right> <a href=\"%s\">[%s]</a>\n",
	    STR_LYNXMESSAGES, STATUSLINES_TITLE);
d406 1
a406 1
    for (x = nhist + nhist_extra - 1; x >= 0; x--) {
d408 2
a409 2
	 * The number of the document in the hist stack, its title in a link,
	 * and its address.  - FM
d411 2
a412 2
	if (HDOC(x).title != NULL) {
	    StrAllocCopy(Title, HDOC(x).title);
d417 1
a417 1
		StrAllocCopy(Title, NO_TITLE);
d422 1
a422 1
		"%s<em>%d</em>. <tab id=t%d><a href=\"%s%d\">%s</a>\n",
d424 3
a426 3
		x, x, STR_LYNXHIST, x, Title);
	if (HDOC(x).address != NULL) {
	    StrAllocCopy(Title, HDOC(x).address);
d431 2
a432 2
	if (HDOC(x).internal_link) {
	    if (history[x].intern_seq_start == history[nhist - 1].intern_seq_start)
d439 1
a439 1
    fprintf(fp0, "</pre>\n");
d444 1
a444 1
    return (0);
d448 4
a451 5
 * This function makes the history page seem like any other type of file since
 * more info is needed than can be provided by the normal link structure.  We
 * saved out the history number to a special URL.
 *
 * The info looks like:  LYNXHIST:#
d453 2
a454 1
BOOLEAN historytarget(DocInfo *newdoc)
d463 2
a464 2
	strlen(newdoc->address) < 10 || !isdigit(UCH(*(newdoc->address + 9))))
	return (FALSE);
d466 2
a467 2
    if ((number = atoi(newdoc->address + 9)) > nhist + nhist_extra || number < 0)
	return (FALSE);
a471 4
     * But check first whether HTMainText is really the History
     * Page document - in some obscure situations this may not be
     * the case.  If HTMainText seems to be a History Page document,
     * also check that it really hasn't been pushed. - LP, kw
d473 1
a473 6
    if (HTMainText && nhist > 0 &&
	!strcmp(HTLoadedDocumentTitle(), HISTORY_PAGE_TITLE) &&
	LYIsUIPage3(HTLoadedDocumentURL(), UIP_HISTORY, 0) &&
	strcmp(HTLoadedDocumentURL(), HDOC(nhist - 1).address)) {
	HTuncache_current_document();	/* don't waste the cache */
    }
d477 4
a480 4
	  history[number].intern_seq_start == history[nhist - 1].intern_seq_start)
	 || (number < nhist - 1 &&
	     HDOC(nhist - 1).internal_link &&
	     number == history[nhist - 1].intern_seq_start))
d492 3
a494 3
     * If we have POST content, and have LYresubmit_posts set or have no_cache
     * set or do not still have the text cached, ask the user whether to
     * resubmit the form.  - FM
d503 2
a504 2
	tmpanchor = HTAnchor_findAddress(&WWWDoc);
	text = (HText *) HTAnchor_document(tmpanchor);
d510 1
a510 1
	    (isLYNXIMGMAP(newdoc->address) ||
d519 1
a519 1
	    return (FALSE);
d525 1
a525 1
    return (TRUE);
d529 2
a530 2
 * This procedure outputs the Visited Links list into a temporary file.  - FM
 * Returns links's number to make active (1-based), or 0 if not required.
d532 2
a533 1
int LYShowVisitedLinks(char **newfile)
d535 1
a535 1
    static char tempfile[LY_MAXPATH] = "\0";
d538 1
a538 1
    int x, tot;
a541 3
    int offset;
    int ret = 0;
    const char *arrow, *post_arrow;
d544 1
a544 1
	return (-1);
d546 5
a550 2
    if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	return (-1);
a552 1
    LYRegisterUIPage(*newfile, UIP_VLINKS);
a558 8
#ifndef NO_OPTION_FORMS
    fprintf(fp0, "<form action=\"%s\" method=\"post\">\n", STR_LYNXOPTIONS);
    LYMenuVisitedLinks(fp0, FALSE);
    fprintf(fp0, "<input type=\"submit\" value=\"Accept Changes\">\n");
    fprintf(fp0, "</form>\n");
    fprintf(fp0, "<P>\n");
#endif

d562 2
a563 21
    if (Visited_Links_As & VISITED_LINKS_REVERSE)
	tot = x = HTList_count(Visited_Links);
    else
	tot = x = -1;

    if (Visited_Links_As & VISITED_LINKS_AS_TREE) {
	vl = First_tree;
    } else if (Visited_Links_As & VISITED_LINKS_AS_LATEST) {
	if (Visited_Links_As & VISITED_LINKS_REVERSE)
	    vl = Latest_last.prev_latest;
	else
	    vl = Latest_first.next_latest;
	if (vl == &Latest_last || vl == &Latest_first)
	    vl = NULL;
    } else {
	if (Visited_Links_As & VISITED_LINKS_REVERSE)
	    vl = Last_by_first;
	else
	    vl = (VisitedLink *) HTList_nextObject(cur);
    }
    while (NULL != vl) {
d565 2
a566 2
	 * The number of the document (most recent highest), its title in a
	 * link, and its address.  - FM
d568 2
a569 27
	post_arrow = arrow = "";
	if (Visited_Links_As & VISITED_LINKS_REVERSE)
	    x--;
	else
	    x++;
	if (vl == PrevActiveVisitedLink) {
	    if (Visited_Links_As & VISITED_LINKS_REVERSE)
		ret = tot - x + 2;
	    else
		ret = x + 3;
	}
	if (vl == PrevActiveVisitedLink) {
	    post_arrow = "<A NAME=current></A>";
	    /* Otherwise levels 0 and 1 look the same when with arrow: */
	    arrow = (vl->level && (Visited_Links_As & VISITED_LINKS_AS_TREE))
		? "==>" : "=>";
	    StrAllocCat(*newfile, "#current");
	}
	if (Visited_Links_As & VISITED_LINKS_AS_TREE) {
	    offset = 2 * vl->level;
	    if (offset > 24)
		offset = (offset + 24) / 2;
	    if (offset > LYcols * 3 / 4)
		offset = LYcols * 3 / 4;
	} else
	    offset = (x > 99 ? 0 : x < 10 ? 2 : 1);
	if (non_empty(vl->title)) {
d575 1
a575 1
		StrAllocCopy(Title, NO_TITLE);
d577 1
a577 1
	    StrAllocCopy(Title, NO_TITLE);
d579 1
a579 1
	if (non_empty(vl->address)) {
d583 2
a584 2
		    "%-*s%s<em>%d</em>. <tab id=t%d><a href=\"%s\">%s</a>\n",
		    offset, arrow, post_arrow,
d588 2
a589 2
		    "%-*s%s<em>%d</em>. <tab id=t%d><em>%s</em>\n",
		    offset, arrow, post_arrow,
d597 1
a597 16
		((Address != NULL) ? Address : gettext("(no address)")));
	if (Visited_Links_As & VISITED_LINKS_AS_TREE)
	    vl = vl->next_tree;
	else if (Visited_Links_As & VISITED_LINKS_AS_LATEST) {
	    if (Visited_Links_As & VISITED_LINKS_REVERSE)
		vl = vl->prev_latest;
	    else
		vl = vl->next_latest;
	    if (vl == &Latest_last || vl == &Latest_first)
		vl = NULL;
	} else {
	    if (Visited_Links_As & VISITED_LINKS_REVERSE)
		vl = vl->prev_first;
	    else
		vl = (VisitedLink *) HTList_nextObject(cur);
	}
d599 1
a599 1
    fprintf(fp0, "</pre>\n");
d605 1
a605 1
    return (ret);
d608 1
d610 1
a610 1
 * Keep cycled buffer for statusline messages.
d613 5
a617 2
static char *buffstack[STATUSBUFSIZE];
static int topOfStack = 0;
d620 1
a620 1
static void free_messages_stack(void)
d630 1
a630 1
static void to_stack(char *str)
d633 1
a633 1
     * Cycle buffer:
d635 1
a635 1
    if (topOfStack >= STATUSBUFSIZE) {
d640 1
a640 1
     * Register string.
d646 1
a646 1
    if (!already_registered_free_messages_stack) {
d651 39
a689 2
    if (topOfStack >= STATUSBUFSIZE) {
	topOfStack = 0;
d691 19
d719 2
a720 1
void LYstatusline_messages_on_exit(char **buf)
d729 1
a729 1
    while (++i < STATUSBUFSIZE) {
d744 4
a747 2
void LYstore_message2(const char *message,
		      const char *argument)
d752 1
a752 2

	HTSprintf0(&temp, message, NonNull(argument));
d757 2
a758 1
void LYstore_message(const char *message)
a761 1

a765 104

/*     LYLoadMESSAGES
 *     --------------
 *     Create a text/html stream with a list of recent statusline messages.
 *     LYNXMESSAGES:/ internal page.
 *     [implementation based on LYLoadKeymap()].
 */

struct _HTStream {
    HTStreamClass *isa;
};

static int LYLoadMESSAGES(const char *arg GCC_UNUSED,
			  HTParentAnchor *anAnchor,
			  HTFormat format_out,
			  HTStream *sink)
{
    HTFormat format_in = WWW_HTML;
    HTStream *target = NULL;
    char *buf = NULL;
    int nummsg = 0;

    int i;
    char *temp = NULL;

    i = STATUSBUFSIZE;
    while (--i >= 0) {
	if (buffstack[i] != NULL)
	    nummsg++;
    }

    /*
     * Set up the stream.  - FM
     */
    target = HTStreamStack(format_in, format_out, sink, anAnchor);

    if (!target || target == NULL) {
	HTSprintf0(&buf, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	HTAlert(buf);
	FREE(buf);
	return (HT_NOT_LOADED);
    }
    anAnchor->no_cache = TRUE;

#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

    HTSprintf0(&buf, "<html>\n<head>\n");
    PUTS(buf);
    /*
     * This page is a list of messages in display character set.
     */
    HTSprintf0(&buf, "<META %s content=\"text/html;charset=%s\">\n",
	       "http-equiv=\"content-type\"",
	       LYCharSet_UC[current_char_set].MIMEname);
    PUTS(buf);
    HTSprintf0(&buf, "<title>%s</title>\n</head>\n<body>\n",
	       STATUSLINES_TITLE);
    PUTS(buf);

    if (nummsg != 0) {
	HTSprintf0(&buf, "<ol>\n");
	PUTS(buf);
	/* print messages in reverse order: */
	i = topOfStack;
	while (--i >= 0) {
	    if (buffstack[i] != NULL) {
		StrAllocCopy(temp, buffstack[i]);
		LYEntify(&temp, TRUE);
		HTSprintf0(&buf, "<li value=%d> <em>%s</em>\n", nummsg, temp);
		nummsg--;
		PUTS(buf);
	    }
	}
	i = STATUSBUFSIZE;
	while (--i >= topOfStack) {
	    if (buffstack[i] != NULL) {
		StrAllocCopy(temp, buffstack[i]);
		LYEntify(&temp, TRUE);
		HTSprintf0(&buf, "<li value=%d> <em>%s</em>\n", nummsg, temp);
		nummsg--;
		PUTS(buf);
	    }
	}
	FREE(temp);
	HTSprintf0(&buf, "</ol>\n</body>\n</html>\n");
    } else {
	HTSprintf0(&buf, "<p>%s\n</body>\n</html>\n",
		   gettext("(No messages yet)"));
    }
    PUTS(buf);

    (*target->isa->_free) (target);
    FREE(buf);
    return (HT_LOADED);
}

#ifdef GLOBALDEF_IS_MACRO
#define _LYMESSAGES_C_GLOBALDEF_1_INIT { "LYNXMESSAGES", LYLoadMESSAGES, 0}
GLOBALDEF(HTProtocol, LYLynxStatusMessages, _LYMESSAGES_C_GLOBALDEF_1_INIT);
#else
GLOBALDEF HTProtocol LYLynxStatusMessages =
{"LYNXMESSAGES", LYLoadMESSAGES, 0};
#endif /* GLOBALDEF_IS_MACRO */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d17 1
a17 4
#include <LYCharSets.h>
#ifdef DISP_PARTIAL
#include <LYMainLoop.h>
#endif
a25 1
#include <HTCJK.h>
a27 15
PUBLIC int Visited_Links_As = VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE;
PRIVATE VisitedLink *PrevVisitedLink = NULL;	    /* NULL on auxillary */
PRIVATE VisitedLink *PrevActiveVisitedLink = NULL;  /* Last non-auxillary */
PRIVATE VisitedLink Latest_first;
PRIVATE VisitedLink Latest_last;
PRIVATE VisitedLink *Latest_tree;
PRIVATE VisitedLink *First_tree;
PRIVATE VisitedLink *Last_by_first;

int nhist_extra;

#ifdef LY_FIND_LEAKS
PRIVATE int already_registered_free_messages_stack = 0;
PRIVATE int already_registered_clean_all_history = 0;
#endif
a37 2
    PrevVisitedLink = NULL;
    PrevActiveVisitedLink = NULL;
a47 3
    Latest_last.prev_latest = &Latest_first;
    Latest_first.next_latest = &Latest_last;
    Last_by_first = Latest_tree = First_tree = 0;
a51 14
#ifdef DEBUG
PRIVATE void trace_history ARGS1(
	CONST char *,	tag)
{
    if (TRACE) {
	CTRACE((tfp, "HISTORY %s %d/%d (%d extra)\n",
		     tag, nhist, MAXHIST, nhist_extra));
	CTRACE_FLUSH(tfp);
    }
}
#else
#define trace_history(tag) /* nothing */
#endif /* DEBUG */

d57 1
a57 1
	DocInfo *,	doc)
d60 1
a61 1
    char *title = (doc->title ? doc->title : NO_TITLE);
d63 1
a63 2
    if (!(doc->address && *doc->address)) {
	PrevVisitedLink = NULL;
a64 1
    }
d73 6
a78 8
	  !strncmp(doc->address, "file://localhost/", 17)))) {
	int related = 1;	/* First approximation only */

	if (	LYIsUIPage(doc->address, UIP_HISTORY) ||
		LYIsUIPage(doc->address, UIP_VLINKS) ||
		LYIsUIPage(doc->address, UIP_SHOWINFO) ||
		isLYNXMESSAGES(doc->address) ||
			(related = 0)	||
d80 3
a82 3
		LYIsUIPage(doc->address, UIP_DIRED_MENU) ||
		LYIsUIPage(doc->address, UIP_UPLOAD_OPTIONS) ||
		LYIsUIPage(doc->address, UIP_PERMIT_OPTIONS) ||
d84 2
a85 5
		LYIsUIPage(doc->address, UIP_PRINT_OPTIONS) ||
		LYIsUIPage(doc->address, UIP_DOWNLOAD_OPTIONS) ||
		LYIsUIPage(doc->address, UIP_OPTIONS_MENU) ||
		isLYNXKEYMAP(doc->address) ||
		LYIsUIPage(doc->address, UIP_LIST_PAGE) ||
d87 1
a87 1
		LYIsUIPage(doc->address, UIP_ADDRLIST_PAGE) ||
d89 8
a96 8
		LYIsUIPage(doc->address, UIP_CONFIG_DEF) ||
		LYIsUIPage(doc->address, UIP_LYNXCFG) ||
		isLYNXCOOKIE(doc->address) ||
		LYIsUIPage(doc->address, UIP_TRACELOG)	) {
	    if (!related)
		PrevVisitedLink = NULL;
	    return;
	}
d99 5
d109 2
a110 5
	Latest_last.prev_latest = &Latest_first;
	Latest_first.next_latest = &Latest_last;
	Latest_last.next_latest = NULL;		/* Find bugs quick! */
	Latest_first.prev_latest = NULL;
	Last_by_first = Latest_tree = First_tree = NULL;
d114 10
a123 18
    while (NULL != (new = (VisitedLink *)HTList_nextObject(cur))) {
	if (!strcmp(NonNull(new->address),
		    NonNull(doc->address))) {
	    PrevVisitedLink = PrevActiveVisitedLink = new;
	    /* Already visited.  Update the last-visited info. */
	    if (new->next_latest == &Latest_last)	/* optimization */
		return;

	    /* Remove from "latest" chain */
	    new->prev_latest->next_latest = new->next_latest;
	    new->next_latest->prev_latest = new->prev_latest;

	    /* Insert at the end of the "latest" chain */
	    Latest_last.prev_latest->next_latest = new;
	    new->prev_latest = Latest_last.prev_latest;
	    new->next_latest = &Latest_last;
	    Latest_last.prev_latest = new;
	    return;
d126 1
a126 43

    if ((new = typecalloc(VisitedLink)) == NULL)
	outofmem(__FILE__, "LYAddVisitedLink");
    StrAllocCopy(new->address, doc->address);
    LYformTitle(&(new->title), title);

    /* First-visited chain */
    HTList_appendObject(Visited_Links, new);	/* At end */
    new->prev_first = Last_by_first;
    Last_by_first = new;

    /* Tree structure */
    if (PrevVisitedLink) {
	VisitedLink *a = PrevVisitedLink;
	VisitedLink *b = a->next_tree;
	int l = PrevVisitedLink->level;

	/* Find last on the deeper levels */
	while (b && b->level > l)
	    a = b, b = b->next_tree;

	if (!b)			/* a == Latest_tree */
	    Latest_tree = new;
	new->next_tree = a->next_tree;
	a->next_tree = new;

	new->level = PrevVisitedLink->level + 1;
    } else {
	if (Latest_tree)
	    Latest_tree->next_tree = new;
	new->level = 0;
	new->next_tree = NULL;
	Latest_tree = new;
    }
    PrevVisitedLink = PrevActiveVisitedLink = new;
    if (!First_tree)
	First_tree = new;

    /* "latest" chain */
    Latest_last.prev_latest->next_latest = new;
    new->prev_latest = Latest_last.prev_latest;
    new->next_latest = &Latest_last;
    Latest_last.prev_latest = new;
d133 1
a133 3
 *  forced.  If docurl is NULL, only the title is considered; otherwise
 *  also check the URL whether it is (likely to be) a generated special
 *  page.
d135 2
a136 3
PUBLIC BOOLEAN LYwouldPush ARGS2(
	CONST char *,	title,
	CONST char *,	docurl)
d138 3
a140 23
    BOOLEAN rc = FALSE;

    /*
     *  All non-pushable generated pages have URLs that begin with
     *  "file://localhost/" and end with HTML_SUFFIX. - kw
     */
    if (docurl) {
	size_t ulen;
	if (strncmp(docurl, "file://localhost/", 17) != 0 ||
	    (ulen = strlen(docurl)) <= strlen(HTML_SUFFIX) ||
	    strcmp(docurl + ulen - strlen(HTML_SUFFIX), HTML_SUFFIX) != 0) {
	    /*
	     *  If it is not a local HTML file, it may be a Web page that
	     *  accidentally has the same title.  So return TRUE now. - kw
	     */
	    return TRUE;
	}
    }

    if (docurl) {
	rc = (BOOLEAN)
		! (LYIsUIPage(docurl, UIP_HISTORY)
		|| LYIsUIPage(docurl, UIP_PRINT_OPTIONS)
d142 3
a144 3
		|| LYIsUIPage(docurl, UIP_DIRED_MENU)
		|| LYIsUIPage(docurl, UIP_UPLOAD_OPTIONS)
		|| LYIsUIPage(docurl, UIP_PERMIT_OPTIONS)
d146 3
a148 78
	    );
    } else {
	rc = (BOOLEAN)
		! (!strcmp(title, HISTORY_PAGE_TITLE)
		|| !strcmp(title, PRINT_OPTIONS_TITLE)
#ifdef DIRED_SUPPORT
		|| !strcmp(title, DIRED_MENU_TITLE)
		|| !strcmp(title, UPLOAD_OPTIONS_TITLE)
		|| !strcmp(title, PERMIT_OPTIONS_TITLE)
#endif /* DIRED_SUPPORT */
	    );
    }
    return rc;
}

/*
 * Free post-data for 'DocInfo'
 */
PUBLIC void LYFreePostData ARGS1(
    DocInfo *,		doc)
{
    BStrFree(doc->post_data);
    FREE(doc->post_content_type);
}

/*
 * Free strings associated with a 'DocInfo' struct.
 */
PUBLIC void LYFreeDocInfo ARGS1(
    DocInfo *,		doc)
{
    FREE(doc->title);
    FREE(doc->address);
    FREE(doc->bookmark);
    LYFreePostData(doc);
}

/*
 *  Free the information in the last history entry.
 */
PRIVATE void clean_extra_history NOARGS
{
    trace_history("clean_extra_history");
    nhist += nhist_extra;
    while (nhist_extra > 0) {
	nhist--;
	LYFreeDocInfo(&HDOC(nhist));
	nhist_extra--;
    }
    trace_history("...clean_extra_history");
}

/*
 * Free the entire history stack, for auditing memory leaks.
 */
#ifdef LY_FIND_LEAKS
PRIVATE void clean_all_history NOARGS
{
    trace_history("clean_all_history");
    clean_extra_history();
    while (nhist > 0) {
	nhist--;
	LYFreeDocInfo(&HDOC(nhist));
    }
    trace_history("...clean_all_history");
}
#endif

/* FIXME What is the relationship to are_different() from the mainloop?! */
PRIVATE int are_identical ARGS2(
	HistInfo *,	doc,
	DocInfo *,	doc1)
{
     return (	STREQ(doc1->address, doc->hdoc.address)
		&& BINEQ(doc1->post_data, doc->hdoc.post_data)
		&& !strcmp(NonNull(doc1->bookmark),
			   NonNull(doc->hdoc.bookmark))
		&& doc1->isHEAD == doc->hdoc.isHEAD );
d154 2
a155 2
PUBLIC int LYpush ARGS2(
	DocInfo *,	doc,
d162 1
a162 1
	return 0;
d172 1
a172 1
	if (!LYwouldPush(doc->title, doc->address)) {
d175 1
a175 1
	    return 0;
d182 12
a193 2
    if ( nhist > 1 && are_identical(&(history[nhist-1]), doc)) {
	if (HDOC(nhist-1).internal_link == doc->internal_link) {
d196 3
a198 3
	    HDOC(nhist-1).link = doc->link;
	    HDOC(nhist-1).line = doc->line;
	    return 0;
a200 21

    /*
     *	If file is identical to the current document, just move the pointer.
     */
    if ( nhist_extra >= 1 && are_identical(&(history[nhist]), doc)) {
	HDOC(nhist).link = doc->link;
	HDOC(nhist).line = doc->line;
	nhist_extra--;
	nhist++;
	trace_history("LYpush: just move the cursor");
	return 1;
    }

    clean_extra_history();
#ifdef LY_FIND_LEAKS
    if (!already_registered_clean_all_history) {
	already_registered_clean_all_history = 1;
	atexit(clean_all_history);
    }
#endif

d205 14
a218 8
	HDOC(nhist).link = doc->link;
	HDOC(nhist).line = doc->line;

	HDOC(nhist).title = NULL;
	LYformTitle(&(HDOC(nhist).title), doc->title);

	HDOC(nhist).address = NULL;
	StrAllocCopy(HDOC(nhist).address, doc->address);
d220 1
a220 13
	HDOC(nhist).post_data = NULL;
	BStrCopy(HDOC(nhist).post_data, doc->post_data);

	HDOC(nhist).post_content_type = NULL;
	StrAllocCopy(HDOC(nhist).post_content_type, doc->post_content_type);

	HDOC(nhist).bookmark = NULL;
	StrAllocCopy(HDOC(nhist).bookmark, doc->bookmark);

	HDOC(nhist).isHEAD = doc->isHEAD;
	HDOC(nhist).safe = doc->safe;

	HDOC(nhist).internal_link = FALSE; /* by default */
d242 1
a242 1
		    HTAnchor_findAddress(&WWWDoc);
d250 3
a252 3
		    if (isLYNXIMGMAP(HDOC(nhist-1).address) &&
			!isLYNXIMGMAP(doc->address)) {
			WWWDoc.address = HDOC(nhist-1).address + LEN_LYNXIMGMAP;
d258 2
a259 2
		    } else if (isLYNXIMGMAP(doc->address) &&
		       !isLYNXIMGMAP(HDOC(nhist-1).address)) {
d261 2
a262 2
			StrAllocCopy(temp, STR_LYNXIMGMAP);
			StrAllocCat(temp, doc->address + LEN_LYNXIMGMAP);
d264 4
a267 4
			WWWDoc.post_content_type = HDOC(nhist-1).post_content_type;
			WWWDoc.bookmark = HDOC(nhist-1).bookmark;
			WWWDoc.isHEAD = HDOC(nhist-1).isHEAD;
			WWWDoc.safe = HDOC(nhist-1).safe;
d269 1
a269 1
			    HTAnchor_findAddress(&WWWDoc);
d272 1
a272 1
			WWWDoc.address = HDOC(nhist-1).address;
d275 5
a279 5
			WWWDoc.post_data = HDOC(nhist-1).post_data;
			WWWDoc.post_content_type = HDOC(nhist-1).post_content_type;
			WWWDoc.bookmark = HDOC(nhist-1).bookmark;
			WWWDoc.isHEAD = HDOC(nhist-1).isHEAD;
			WWWDoc.safe = HDOC(nhist-1).safe;
d281 1
a281 1
			    HTAnchor_findAddress(&WWWDoc);
d283 6
a288 6
		    /* In addition to equality of the ParentAnchors, require
		    ** that IF we have a HTMainText (i.e., it wasn't just
		    ** HTuncache'd by mainloop), THEN it has to be consistent
		    ** with what we are trying to push.
		    **   This may be overkill... - kw
		    */
d292 1
a292 1
			HDOC(nhist).internal_link = TRUE;
d296 1
a296 1
			CTRACE((tfp, "\nLYpush: pushed as internal link, OK\n"));
d300 3
a302 3
	    if (!HDOC(nhist).internal_link) {
		CTRACE((tfp, "\nLYpush: push as internal link requested, %s\n",
			    "but didn't check out!"));
d305 2
a306 2
	CTRACE((tfp, "\nLYpush[%d]: address:%s\n        title:%s\n",
		    nhist, doc->address, doc->title));
d312 2
a313 2
	CTRACE((tfp, "\nLYpush: MAXHIST reached for:\n        address:%s\n        title:%s\n",
		    doc->address, doc->title));
a314 1
    return 1;
d321 1
a321 1
	DocInfo *,	doc)
a323 1
	clean_extra_history();
d325 15
a339 5

	LYFreeDocInfo(doc);

	*doc = HDOC(nhist);

d342 1
a342 1
	LYSetNewline(doc->line);	/* reinitialize */
d344 2
a345 17
	CTRACE((tfp, "LYpop[%d]: address:%s\n     title:%s\n",
		    nhist, doc->address, doc->title));
    }
}

/*
 *  Move to the previous filename, link and line number from the history list.
 */
PUBLIC void LYhist_prev ARGS1(
	DocInfo *,	doc)
{
    trace_history("LYhist_prev");
    if (nhist > 0 && (nhist_extra || nhist < MAXHIST)) {
	nhist--;
	nhist_extra++;
	LYpop_num(nhist, doc);
	trace_history("...LYhist_prev");
a349 40
 *  Called before calling LYhist_prev().
 */
PUBLIC void LYhist_prev_register ARGS1(
	DocInfo *,	doc)
{
    trace_history("LYhist_prev_register");
    if (nhist > 1) {
	if (nhist_extra) {	/* Make something to return back */
	    /* Store the new position */
	    HDOC(nhist).link = doc->link;
	    HDOC(nhist).line = doc->line;
	} else if (nhist < MAXHIST) { /* push will fail */
	    if (LYpush(doc, 0)) {
		nhist--;
		nhist_extra++;
	    }
	}
	trace_history("...LYhist_prev_register");
    }
}

/*
 *  Move to the next filename, link and line number from the history.
 */
PUBLIC int LYhist_next ARGS2(
	DocInfo *,	doc,
	DocInfo *,	newdoc)
{
    if (nhist_extra <= 1)	/* == 1 when we are the last one */
	return 0;
    /* Store the new position */
    HDOC(nhist).link = doc->link;
    HDOC(nhist).line = doc->line;
    nhist++;
    nhist_extra--;
    LYpop_num(nhist, newdoc);
    return 1;
}

/*
d356 1
a356 1
	DocInfo *,	doc)
d358 11
a368 11
    if (number >= 0 && nhist + nhist_extra > number) {
	doc->link = HDOC(number).link;
	doc->line = HDOC(number).line;
	StrAllocCopy(doc->title, HDOC(number).title);
	StrAllocCopy(doc->address, HDOC(number).address);
	BStrCopy(doc->post_data, HDOC(number).post_data);
	StrAllocCopy(doc->post_content_type, HDOC(number).post_content_type);
	StrAllocCopy(doc->bookmark, HDOC(number).bookmark);
	doc->isHEAD = HDOC(number).isHEAD;
	doc->safe = HDOC(number).safe;
	doc->internal_link = HDOC(number).internal_link; /* ?? */
d371 1
a371 1
	LYSetNewline(doc->line);	/* reinitialize */
d382 1
a382 1
    static char tempfile[LY_MAXPATH] = "\0";
d387 3
a389 1
    if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
d391 1
d400 2
a401 2
    fprintf(fp0, "<p align=right> <a href=\"%s\">[%s]</a>\n",
		 STR_LYNXMESSAGES, STATUSLINES_TITLE);
d406 1
a406 1
    for (x = nhist + nhist_extra - 1; x >= 0; x--) {
d411 2
a412 2
	if (HDOC(x).title != NULL) {
	    StrAllocCopy(Title, HDOC(x).title);
d422 1
a422 1
		"%s<em>%d</em>. <tab id=t%d><a href=\"%s%d\">%s</a>\n",
d424 3
a426 3
		x, x, STR_LYNXHIST, x, Title);
	if (HDOC(x).address != NULL) {
	    StrAllocCopy(Title, HDOC(x).address);
d431 1
a431 1
	if (HDOC(x).internal_link) {
d454 1
a454 1
	DocInfo *,	newdoc)
d463 1
a463 1
	strlen(newdoc->address) < 10 || !isdigit(UCH(*(newdoc->address+9))))
d466 1
a466 1
    if ((number = atoi(newdoc->address+9)) > nhist + nhist_extra || number < 0)
a471 4
     * But check first whether HTMainText is really the History
     * Page document - in some obscure situations this may not be
     * the case.  If HTMainText seems to be a History Page document,
     * also check that it really hasn't been pushed. - LP, kw
d473 1
a473 6
    if (HTMainText && nhist > 0 &&
	!strcmp(HTLoadedDocumentTitle(), HISTORY_PAGE_TITLE) &&
	LYIsUIPage3(HTLoadedDocumentURL(), UIP_HISTORY, 0) &&
	strcmp(HTLoadedDocumentURL(), HDOC(nhist-1).address)) {
	HTuncache_current_document();  /* don't waste the cache */
    }
d479 1
a479 1
	  HDOC(nhist-1).internal_link &&
d503 1
a503 1
	tmpanchor = HTAnchor_findAddress(&WWWDoc);
d510 1
a510 1
	    (isLYNXIMGMAP(newdoc->address) ||
d529 2
a530 2
 *  This procedure outputs the Visited Links list into a temporary file. - FM
 *  Returns links's number to make active (1-based), or 0 if not required.
d535 1
a535 1
    static char tempfile[LY_MAXPATH] = "\0";
d538 1
a538 1
    int x, tot;
a541 3
    int offset;
    int ret = 0;
    char *arrow, *post_arrow;
d546 3
a548 1
    if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
d550 1
a552 1
    LYRegisterUIPage(*newfile, UIP_VLINKS);
a558 18
    fprintf(fp0, "<form action=\"%s\" method=\"post\">\n", STR_LYNXOPTIONS);
    fprintf(fp0, "<select name=\"visited_pages_type\">\n");
    fprintf(fp0, " <option value=\"first_visited\" %s>Sort By First Visited\n",
		 (Visited_Links_As == VISITED_LINKS_AS_FIRST_V ? "selected" : ""));
    fprintf(fp0, " <option value=\"first_visited_reversed\" %s>Reverse Sort By First Visited\n",
		 (Visited_Links_As == (VISITED_LINKS_AS_FIRST_V|VISITED_LINKS_REVERSE) ? "selected" : ""));
    fprintf(fp0, " <option value=\"visit_tree\" %s>View As Visit Tree\n",
		 (Visited_Links_As == VISITED_LINKS_AS_TREE ? "selected" : ""));
    fprintf(fp0, " <option value=\"last_visited\" %s>Sort By Last Visited\n",
		 (Visited_Links_As == VISITED_LINKS_AS_LATEST ? "selected" : ""));
    fprintf(fp0, " <option value=\"last_visited_reversed\" %s>Reverse Sort By Last Visited\n",
		 (Visited_Links_As == (VISITED_LINKS_AS_LATEST|VISITED_LINKS_REVERSE)
		   ? "selected" : ""));
    fprintf(fp0, "</select>\n");
    fprintf(fp0, "<input type=\"submit\" value=\"Accept Changes\">\n");
    fprintf(fp0, "</form>\n");
    fprintf(fp0, "<P>\n");

d562 2
a563 21
    if (Visited_Links_As & VISITED_LINKS_REVERSE)
	tot = x = HTList_count(Visited_Links);
    else
	tot = x = -1;

    if (Visited_Links_As & VISITED_LINKS_AS_TREE) {
	vl = First_tree;
    } else if (Visited_Links_As & VISITED_LINKS_AS_LATEST) {
	if (Visited_Links_As & VISITED_LINKS_REVERSE)
	    vl = Latest_last.prev_latest;
	else
	    vl = Latest_first.next_latest;
	if (vl == &Latest_last || vl == &Latest_first)
	    vl = NULL;
    } else {
	if (Visited_Links_As & VISITED_LINKS_REVERSE)
	    vl = Last_by_first;
	else
	    vl = (VisitedLink *)HTList_nextObject(cur);
    }
    while (NULL != vl) {
d568 1
a568 26
	post_arrow = arrow = "";
	if (Visited_Links_As & VISITED_LINKS_REVERSE)
	    x--;
	else
	    x++;
	if (vl == PrevActiveVisitedLink) {
	    if (Visited_Links_As & VISITED_LINKS_REVERSE)
		ret = tot - x + 2;
	    else
		ret = x + 3;
	}
	if (vl == PrevActiveVisitedLink) {
	    post_arrow = "<A NAME=current></A>";
	    /* Otherwise levels 0 and 1 look the same when with arrow: */
	    arrow = (vl->level && (Visited_Links_As & VISITED_LINKS_AS_TREE))
			 ? "==>" : "=>";
	    StrAllocCat(*newfile, "#current");
	}
	if (Visited_Links_As & VISITED_LINKS_AS_TREE) {
	    offset = 2 * vl->level;
	    if (offset > 24)
		offset = (offset + 24)/2;
	    if (offset > LYcols * 3/4)
		offset = LYcols * 3/4;
	} else
	    offset = (x > 99 ? 0 : x < 10 ? 2 : 1);
d583 2
a584 2
		    "%-*s%s<em>%d</em>. <tab id=t%d><a href=\"%s\">%s</a>\n",
		    offset, arrow, post_arrow,
d588 2
a589 2
		    "%-*s%s<em>%d</em>. <tab id=t%d><em>%s</em>\n",
		    offset, arrow, post_arrow,
a597 15
	if (Visited_Links_As & VISITED_LINKS_AS_TREE)
	    vl = vl->next_tree;
	else if (Visited_Links_As & VISITED_LINKS_AS_LATEST) {
	    if (Visited_Links_As & VISITED_LINKS_REVERSE)
		vl = vl->prev_latest;
	    else
		vl = vl->next_latest;
	    if (vl == &Latest_last || vl == &Latest_first)
		vl = NULL;
	} else {
	    if (Visited_Links_As & VISITED_LINKS_REVERSE)
		vl = vl->prev_first;
	    else
		vl = (VisitedLink *)HTList_nextObject(cur);
	}
d605 1
a605 1
    return(ret);
d615 3
d635 1
a635 1
    if (topOfStack >= STATUSBUFSIZE) {
d651 39
a689 2
    if (topOfStack >= STATUSBUFSIZE) {
	topOfStack = 0;
d691 19
a711 1

d729 1
a729 1
    while (++i < STATUSBUFSIZE) {
d752 1
a752 1
	HTSprintf0(&temp, message, NonNull(argument));
a765 105

/*     LYLoadMESSAGES
**     --------------
**     Create a text/html stream with a list of recent statusline messages.
**     LYNXMESSAGES:/ internal page.
**     [implementation based on LYLoadKeymap()].
*/

struct _HTStream
{
    HTStreamClass * isa;
};

PRIVATE int LYLoadMESSAGES ARGS4 (
	CONST char *,		arg GCC_UNUSED,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
{
    HTFormat format_in = WWW_HTML;
    HTStream *target = NULL;
    char *buf = NULL;
    int nummsg = 0;

    int i;
    char *temp = NULL;

    i = STATUSBUFSIZE;
    while (--i >= 0) {
	if (buffstack[i] != NULL)
	    nummsg++;
    }

    /*
     *  Set up the stream. - FM
     */
    target = HTStreamStack(format_in, format_out, sink, anAnchor);

    if (!target || target == NULL) {
	HTSprintf0(&buf, CANNOT_CONVERT_I_TO_O,
			 HTAtom_name(format_in), HTAtom_name(format_out));
	HTAlert(buf);
	FREE(buf);
	return(HT_NOT_LOADED);
    }
    anAnchor->no_cache = TRUE;

#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

    HTSprintf0(&buf, "<html>\n<head>\n");
    PUTS(buf);
	/*
	 *  This page is a list of messages in display character set.
	 */
    HTSprintf0(&buf, "<META %s content=\"text/html;charset=%s\">\n",
	       "http-equiv=\"content-type\"",
	       LYCharSet_UC[current_char_set].MIMEname);
    PUTS(buf);
    HTSprintf0(&buf, "<title>%s</title>\n</head>\n<body>\n",
	       STATUSLINES_TITLE);
    PUTS(buf);

    if (nummsg != 0) {
	HTSprintf0(&buf, "<ol>\n");
	PUTS(buf);
	/* print messages in reverse order: */
	i = topOfStack;
	while (--i >= 0) {
	    if (buffstack[i] != NULL) {
		StrAllocCopy(temp, buffstack[i]);
		LYEntify(&temp, TRUE);
		HTSprintf0(&buf, "<li value=%d> <em>%s</em>\n", nummsg, temp);
		nummsg--;
		PUTS(buf);
	    }
	}
	i = STATUSBUFSIZE;
	while (--i >= topOfStack) {
	    if (buffstack[i] != NULL) {
		StrAllocCopy(temp, buffstack[i]);
		LYEntify(&temp, TRUE);
		HTSprintf0(&buf, "<li value=%d> <em>%s</em>\n", nummsg, temp);
		nummsg--;
		PUTS(buf);
	    }
	}
	FREE(temp);
	HTSprintf0(&buf, "</ol>\n</body>\n</html>\n");
    } else {
	HTSprintf0(&buf, "<p>%s\n</body>\n</html>\n",
		   gettext("(No messages yet)"));
    }
    PUTS(buf);

    (*target->isa->_free)(target);
    FREE(buf);
    return(HT_LOADED);
}

#ifdef GLOBALDEF_IS_MACRO
#define _LYMESSAGES_C_GLOBALDEF_1_INIT { "LYNXMESSAGES", LYLoadMESSAGES, 0}
GLOBALDEF (HTProtocol,LYLynxStatusMessages,_LYMESSAGES_C_GLOBALDEF_1_INIT);
#else
GLOBALDEF PUBLIC HTProtocol LYLynxStatusMessages = {"LYNXMESSAGES", LYLoadMESSAGES, 0};
#endif /* GLOBALDEF_IS_MACRO */
@


1.1.3.2
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@a17 1
#include <LYrcFile.h>
a820 1
#ifndef NO_OPTION_FORMS
d822 13
a834 1
    LYMenuVisitedLinks (fp0, FALSE);
a837 1
#endif
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d32 9
a40 9
HTList * Visited_Links = NULL;	/* List of safe popped docs. */
int Visited_Links_As = VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE;
static VisitedLink *PrevVisitedLink = NULL;	    /* NULL on auxillary */
static VisitedLink *PrevActiveVisitedLink = NULL;  /* Last non-auxillary */
static VisitedLink Latest_first;
static VisitedLink Latest_last;
static VisitedLink *Latest_tree;
static VisitedLink *First_tree;
static VisitedLink *Last_by_first;
d45 2
a46 2
static int already_registered_free_messages_stack = 0;
static int already_registered_clean_all_history = 0;
d53 1
a53 1
static void Visited_Links_free (void)
d78 2
a79 2
static void trace_history (
	const char *	tag)
d95 2
a96 2
void LYAddVisitedLink (
	DocInfo *	doc)
d231 3
a233 3
BOOLEAN LYwouldPush (
	const char *	title,
	const char *	docurl)
d281 2
a282 2
void LYFreePostData (
    DocInfo *		doc)
d291 2
a292 2
void LYFreeDocInfo (
    DocInfo *		doc)
d303 1
a303 1
static void clean_extra_history (void)
d319 1
a319 1
static void clean_all_history (void)
d332 3
a334 3
static int are_identical (
	HistInfo *	doc,
	DocInfo *	doc1)
d346 3
a348 3
int LYpush (
	DocInfo *	doc,
	BOOLEAN	force_push)
d530 2
a531 2
void LYpop (
	DocInfo *	doc)
d553 2
a554 2
void LYhist_prev (
	DocInfo *	doc)
d568 2
a569 2
void LYhist_prev_register (
	DocInfo *	doc)
d590 3
a592 3
int LYhist_next (
	DocInfo *	doc,
	DocInfo *	newdoc)
d610 3
a612 3
void LYpop_num (
	int		number,
	DocInfo *	doc)
d635 2
a636 2
int showhistory (
	char **	newfile)
d706 2
a707 2
BOOLEAN historytarget (
	DocInfo *	newdoc)
d794 2
a795 2
int LYShowVisitedLinks (
	char **	newfile)
d943 2
a944 2
static char * buffstack[STATUSBUFSIZE];
static int topOfStack = 0;
d947 1
a947 1
static void free_messages_stack (void)
d957 1
a957 1
static void to_stack (char * str)
d991 2
a992 2
void LYstatusline_messages_on_exit (
	char **	buf)
d1017 3
a1019 3
void LYstore_message2 (
	const char *	message,
	const char *	argument)
d1029 2
a1030 2
void LYstore_message (
	const char *	message)
d1051 5
a1055 5
static int LYLoadMESSAGES (
	const char *		arg GCC_UNUSED,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d1141 1
a1141 1
GLOBALDEF HTProtocol LYLynxStatusMessages = {"LYNXMESSAGES", LYLoadMESSAGES, 0};
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d32 1
a32 1
HTList *Visited_Links = NULL;	/* List of safe popped docs. */
d34 2
a35 2
static VisitedLink *PrevVisitedLink = NULL;	/* NULL on auxillary */
static VisitedLink *PrevActiveVisitedLink = NULL;	/* Last non-auxillary */
d51 1
a51 1
 * Utility for freeing the list of visited links.  - FM
d53 1
a53 1
static void Visited_Links_free(void)
d63 1
a63 1
    while (NULL != (vl = (VisitedLink *) HTList_nextObject(cur))) {
d78 2
a79 1
static void trace_history(const char *tag)
d83 1
a83 1
		tag, nhist, MAXHIST, nhist_extra));
d88 1
a88 1
#define trace_history(tag)	/* nothing */
d92 2
a93 2
 * Utility for listing visited links, making any repeated links the most
 * current in the list.  - FM
d95 2
a96 1
void LYAddVisitedLink(DocInfo *doc)
d108 2
a109 1
     * Exclude POST or HEAD replies, and bookmark, menu or list files.  - FM
d112 3
a114 3
	(			/* special url or a temp file */
	    (!strncmp(doc->address, "LYNX", 4) ||
	     !strncmp(doc->address, "file://localhost/", 17)))) {
d117 5
a121 5
	if (LYIsUIPage(doc->address, UIP_HISTORY) ||
	    LYIsUIPage(doc->address, UIP_VLINKS) ||
	    LYIsUIPage(doc->address, UIP_SHOWINFO) ||
	    isLYNXMESSAGES(doc->address) ||
	    (related = 0) ||
d123 3
a125 3
	    LYIsUIPage(doc->address, UIP_DIRED_MENU) ||
	    LYIsUIPage(doc->address, UIP_UPLOAD_OPTIONS) ||
	    LYIsUIPage(doc->address, UIP_PERMIT_OPTIONS) ||
d127 5
a131 5
	    LYIsUIPage(doc->address, UIP_PRINT_OPTIONS) ||
	    LYIsUIPage(doc->address, UIP_DOWNLOAD_OPTIONS) ||
	    LYIsUIPage(doc->address, UIP_OPTIONS_MENU) ||
	    isLYNXKEYMAP(doc->address) ||
	    LYIsUIPage(doc->address, UIP_LIST_PAGE) ||
d133 1
a133 1
	    LYIsUIPage(doc->address, UIP_ADDRLIST_PAGE) ||
d135 4
a138 4
	    LYIsUIPage(doc->address, UIP_CONFIG_DEF) ||
	    LYIsUIPage(doc->address, UIP_LYNXCFG) ||
	    isLYNXCOOKIE(doc->address) ||
	    LYIsUIPage(doc->address, UIP_TRACELOG)) {
d158 1
a158 1
    while (NULL != (new = (VisitedLink *) HTList_nextObject(cur))) {
d226 4
a229 3
 * Returns true if this is a page that we would push onto the stack if not
 * forced.  If docurl is NULL, only the title is considered; otherwise also
 * check the URL whether it is (likely to be) a generated special page.
d231 3
a233 2
BOOLEAN LYwouldPush(const char *title,
		    const char *docurl)
d238 2
a239 2
     * All non-pushable generated pages have URLs that begin with
     * "file://localhost/" and end with HTML_SUFFIX.  - kw
a242 1

d247 2
a248 2
	     * If it is not a local HTML file, it may be a Web page that
	     * accidentally has the same title.  So return TRUE now.  - kw
d256 2
a257 2
	    !(LYIsUIPage(docurl, UIP_HISTORY)
	      || LYIsUIPage(docurl, UIP_PRINT_OPTIONS)
d259 3
a261 3
	      || LYIsUIPage(docurl, UIP_DIRED_MENU)
	      || LYIsUIPage(docurl, UIP_UPLOAD_OPTIONS)
	      || LYIsUIPage(docurl, UIP_PERMIT_OPTIONS)
d266 2
a267 2
	    !(!strcmp(title, HISTORY_PAGE_TITLE)
	      || !strcmp(title, PRINT_OPTIONS_TITLE)
d269 3
a271 3
	      || !strcmp(title, DIRED_MENU_TITLE)
	      || !strcmp(title, UPLOAD_OPTIONS_TITLE)
	      || !strcmp(title, PERMIT_OPTIONS_TITLE)
d281 2
a282 1
void LYFreePostData(DocInfo *doc)
d291 2
a292 1
void LYFreeDocInfo(DocInfo *doc)
d301 1
a301 1
 * Free the information in the last history entry.
d303 1
a303 1
static void clean_extra_history(void)
d319 1
a319 1
static void clean_all_history(void)
d332 9
a340 7
static int are_identical(HistInfo * doc, DocInfo *doc1)
{
    return (STREQ(doc1->address, doc->hdoc.address)
	    && BINEQ(doc1->post_data, doc->hdoc.post_data)
	    && !strcmp(NonNull(doc1->bookmark),
		       NonNull(doc->hdoc.bookmark))
	    && doc1->isHEAD == doc->hdoc.isHEAD);
d344 1
a344 1
 * Push the current filename, link and line number onto the history list.
d346 3
a348 1
int LYpush(DocInfo *doc, BOOLEAN force_push)
d351 1
a351 1
     * Don't push NULL file names.
d357 2
a358 1
     * Check whether this is a document we don't push unless forced.  - FM
d362 1
a362 1
	 * Don't push the history, printer, or download lists.
d372 1
a372 1
     * If file is identical to one before it, don't push it.
d374 2
a375 2
    if (nhist > 1 && are_identical(&(history[nhist - 1]), doc)) {
	if (HDOC(nhist - 1).internal_link == doc->internal_link) {
d378 2
a379 2
	    HDOC(nhist - 1).link = doc->link;
	    HDOC(nhist - 1).line = doc->line;
d385 1
a385 1
     * If file is identical to the current document, just move the pointer.
d387 1
a387 1
    if (nhist_extra >= 1 && are_identical(&(history[nhist]), doc)) {
d405 1
a405 1
     * OK, push it if we have stack space.
d407 1
a407 1
    if (nhist < MAXHIST) {
d429 2
a430 2
	HDOC(nhist).internal_link = FALSE;	/* by default */
	history[nhist].intern_seq_start = -1;	/* by default */
a443 1

d453 2
a454 2
		 * item - kw
		 */
d457 3
a459 3
		     * isn't, compare the physical URLs instead. - kw
		     */
		    if (isLYNXIMGMAP(HDOC(nhist - 1).address) &&
d461 6
a466 6
			WWWDoc.address = HDOC(nhist - 1).address + LEN_LYNXIMGMAP;
			/*
			 * If THIS item is a LYNXIMGMAP but the last-pushed one
			 * isn't, fake it by using THIS item's address for
			 * thatparent... - kw
			 */
d468 1
a468 1
			       !isLYNXIMGMAP(HDOC(nhist - 1).address)) {
a469 1

d473 4
a476 4
			WWWDoc.post_content_type = HDOC(nhist - 1).post_content_type;
			WWWDoc.bookmark = HDOC(nhist - 1).bookmark;
			WWWDoc.isHEAD = HDOC(nhist - 1).isHEAD;
			WWWDoc.safe = HDOC(nhist - 1).safe;
d481 1
a481 1
			WWWDoc.address = HDOC(nhist - 1).address;
d483 6
a488 6
		    if (!thatparent) {	/* if not yet done */
			WWWDoc.post_data = HDOC(nhist - 1).post_data;
			WWWDoc.post_content_type = HDOC(nhist - 1).post_content_type;
			WWWDoc.bookmark = HDOC(nhist - 1).bookmark;
			WWWDoc.isHEAD = HDOC(nhist - 1).isHEAD;
			WWWDoc.safe = HDOC(nhist - 1).safe;
d493 5
a497 6
		     * that IF we have a HTMainText (i.e., it wasn't just
		     * HTuncache'd by mainloop), THEN it has to be consistent
		     * with what we are trying to push.
		     *
		     * This may be overkill...  - kw
		     */
d503 2
a504 2
			    history[nhist - 1].intern_seq_start >= 0 ?
			    history[nhist - 1].intern_seq_start : nhist - 1;
d511 1
a511 1
			"but didn't check out!"));
d515 1
a515 1
		nhist, doc->address, doc->title));
d521 2
a522 3
	CTRACE((tfp,
		"\nLYpush: MAXHIST reached for:\n        address:%s\n        title:%s\n",
		doc->address, doc->title));
d528 1
a528 1
 * Pop the previous filename, link and line number from the history list.
d530 2
a531 1
void LYpop(DocInfo *doc)
d546 1
a546 1
		nhist, doc->address, doc->title));
d551 1
a551 1
 * Move to the previous filename, link and line number from the history list.
d553 2
a554 1
void LYhist_prev(DocInfo *doc)
d566 1
a566 1
 * Called before calling LYhist_prev().
d568 2
a569 1
void LYhist_prev_register(DocInfo *doc)
d577 1
a577 1
	} else if (nhist < MAXHIST) {	/* push will fail */
d588 1
a588 1
 * Move to the next filename, link and line number from the history.
d590 3
a592 1
int LYhist_next(DocInfo *doc, DocInfo *newdoc)
d606 3
a608 3
 * Pop the specified hist entry, link and line number from the history list but
 * don't actually remove the entry, just return it.
 * (This procedure is badly named :)
d610 3
a612 2
void LYpop_num(int number,
	       DocInfo *doc)
d624 1
a624 1
	doc->internal_link = HDOC(number).internal_link;	/* ?? */
d633 1
a633 1
 * This procedure outputs the history buffer into a temporary file.
d635 2
a636 1
int showhistory(char **newfile)
d644 1
a644 1
	return (-1);
d654 1
a654 1
	    STR_LYNXMESSAGES, STATUSLINES_TITLE);
d661 2
a662 2
	 * The number of the document in the hist stack, its title in a link,
	 * and its address.  - FM
d670 1
a670 1
		StrAllocCopy(Title, NO_TITLE);
d685 1
a685 1
	    if (history[x].intern_seq_start == history[nhist - 1].intern_seq_start)
d692 1
a692 1
    fprintf(fp0, "</pre>\n");
d697 1
a697 1
    return (0);
d701 4
a704 5
 * This function makes the history page seem like any other type of file since
 * more info is needed than can be provided by the normal link structure.  We
 * saved out the history number to a special URL.
 *
 * The info looks like:  LYNXHIST:#
d706 2
a707 1
BOOLEAN historytarget(DocInfo *newdoc)
d716 2
a717 2
	strlen(newdoc->address) < 10 || !isdigit(UCH(*(newdoc->address + 9))))
	return (FALSE);
d719 2
a720 2
    if ((number = atoi(newdoc->address + 9)) > nhist + nhist_extra || number < 0)
	return (FALSE);
d733 2
a734 2
	strcmp(HTLoadedDocumentURL(), HDOC(nhist - 1).address)) {
	HTuncache_current_document();	/* don't waste the cache */
d739 4
a742 4
	  history[number].intern_seq_start == history[nhist - 1].intern_seq_start)
	 || (number < nhist - 1 &&
	     HDOC(nhist - 1).internal_link &&
	     number == history[nhist - 1].intern_seq_start))
d754 3
a756 3
     * If we have POST content, and have LYresubmit_posts set or have no_cache
     * set or do not still have the text cached, ask the user whether to
     * resubmit the form.  - FM
d766 1
a766 1
	text = (HText *) HTAnchor_document(tmpanchor);
d781 1
a781 1
	    return (FALSE);
d787 1
a787 1
    return (TRUE);
d791 2
a792 2
 * This procedure outputs the Visited Links list into a temporary file.  - FM
 * Returns links's number to make active (1-based), or 0 if not required.
d794 2
a795 1
int LYShowVisitedLinks(char **newfile)
d809 1
a809 1
	return (-1);
d812 1
a812 1
	return (-1);
d824 1
a824 1
    LYMenuVisitedLinks(fp0, FALSE);
d851 1
a851 1
	    vl = (VisitedLink *) HTList_nextObject(cur);
d855 2
a856 2
	 * The number of the document (most recent highest), its title in a
	 * link, and its address.  - FM
d873 1
a873 1
		? "==>" : "=>";
d879 3
a881 3
		offset = (offset + 24) / 2;
	    if (offset > LYcols * 3 / 4)
		offset = LYcols * 3 / 4;
d890 1
a890 1
		StrAllocCopy(Title, NO_TITLE);
d892 1
a892 1
	    StrAllocCopy(Title, NO_TITLE);
d912 1
a912 1
		((Address != NULL) ? Address : gettext("(no address)")));
d926 1
a926 1
		vl = (VisitedLink *) HTList_nextObject(cur);
d929 1
a929 1
    fprintf(fp0, "</pre>\n");
d935 1
a935 1
    return (ret);
d938 1
d940 1
a940 1
 * Keep cycled buffer for statusline messages.
d943 1
a943 1
static char *buffstack[STATUSBUFSIZE];
d947 1
a947 1
static void free_messages_stack(void)
d957 1
a957 1
static void to_stack(char *str)
d960 1
a960 1
     * Cycle buffer:
d967 1
a967 1
     * Register string.
d973 1
a973 1
    if (!already_registered_free_messages_stack) {
d983 1
d991 2
a992 1
void LYstatusline_messages_on_exit(char **buf)
d1016 4
a1019 2
void LYstore_message2(const char *message,
		      const char *argument)
a1023 1

d1029 2
a1030 1
void LYstore_message(const char *message)
a1033 1

d1040 5
a1044 5
 *     --------------
 *     Create a text/html stream with a list of recent statusline messages.
 *     LYNXMESSAGES:/ internal page.
 *     [implementation based on LYLoadKeymap()].
 */
d1046 3
a1048 2
struct _HTStream {
    HTStreamClass *isa;
d1051 5
a1055 4
static int LYLoadMESSAGES(const char *arg GCC_UNUSED,
			  HTParentAnchor *anAnchor,
			  HTFormat format_out,
			  HTStream *sink)
d1072 1
a1072 1
     * Set up the stream.  - FM
d1078 1
a1078 1
		   HTAtom_name(format_in), HTAtom_name(format_out));
d1081 1
a1081 1
	return (HT_NOT_LOADED);
d1089 3
a1091 3
    /*
     * This page is a list of messages in display character set.
     */
d1132 1
a1132 1
    (*target->isa->_free) (target);
d1134 1
a1134 1
    return (HT_LOADED);
d1139 1
a1139 1
GLOBALDEF(HTProtocol, LYLynxStatusMessages, _LYMESSAGES_C_GLOBALDEF_1_INIT);
d1141 1
a1141 2
GLOBALDEF HTProtocol LYLynxStatusMessages =
{"LYNXMESSAGES", LYLoadMESSAGES, 0};
@


1.1.3.5
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d100 1
a100 1
    if (isEmpty(doc->address)) {
d869 1
a869 1
	if (non_empty(vl->title)) {
d879 1
a879 1
	if (non_empty(vl->address)) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d17 1
a17 4
#include <LYCharSets.h>
#ifdef DISP_PARTIAL
#include <LYMainLoop.h>
#endif
a25 1
#include <HTCJK.h>
a27 10
PUBLIC int Visited_Links_As = VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE;
PRIVATE VisitedLink *PrevVisitedLink = NULL;	    /* NULL on auxillary */
PRIVATE VisitedLink *PrevActiveVisitedLink = NULL;  /* Last non-auxillary */
PRIVATE VisitedLink Latest_first;
PRIVATE VisitedLink Latest_last;
PRIVATE VisitedLink *Latest_tree;
PRIVATE VisitedLink *First_tree;
PRIVATE VisitedLink *Last_by_first;

int nhist_extra;
a37 2
    PrevVisitedLink = NULL;
    PrevActiveVisitedLink = NULL;
a47 3
    Latest_last.prev_latest = &Latest_first;
    Latest_first.next_latest = &Latest_last;
    Last_by_first = Latest_tree = First_tree = 0;
a51 14
#ifdef DEBUG
PRIVATE void trace_history ARGS1(
	CONST char *,	tag)
{
    if (TRACE) {
	CTRACE((tfp, "HISTORY %s %d/%d (%d extra)\n",
		     tag, nhist, MAXHIST, nhist_extra));
	CTRACE_FLUSH(tfp);
    }
}
#else
#define trace_history(tag) /* nothing */
#endif /* DEBUG */

d60 1
a61 1
    char *title = (doc->title ? doc->title : NO_TITLE);
d63 1
a63 2
    if (!(doc->address && *doc->address)) {
	PrevVisitedLink = NULL;
a64 1
    }
d73 6
a78 8
	  !strncmp(doc->address, "file://localhost/", 17)))) {
	int related = 1;	/* First approximation only */

	if (	LYIsUIPage(doc->address, UIP_HISTORY) ||
		LYIsUIPage(doc->address, UIP_VLINKS) ||
		LYIsUIPage(doc->address, UIP_SHOWINFO) ||
		!strncmp(doc->address, "LYNXMESSAGES:", 13) ||
			(related = 0)	||
d80 3
a82 3
		LYIsUIPage(doc->address, UIP_DIRED_MENU) ||
		LYIsUIPage(doc->address, UIP_UPLOAD_OPTIONS) ||
		LYIsUIPage(doc->address, UIP_PERMIT_OPTIONS) ||
d84 2
a85 5
		LYIsUIPage(doc->address, UIP_PRINT_OPTIONS) ||
		LYIsUIPage(doc->address, UIP_DOWNLOAD_OPTIONS) ||
		LYIsUIPage(doc->address, UIP_OPTIONS_MENU) ||
		!strncmp(doc->address, "LYNXKEYMAP:", 11) ||
		LYIsUIPage(doc->address, UIP_LIST_PAGE) ||
d87 1
a87 1
		LYIsUIPage(doc->address, UIP_ADDRLIST_PAGE) ||
d89 8
a96 8
		LYIsUIPage(doc->address, UIP_CONFIG_DEF) ||
		LYIsUIPage(doc->address, UIP_LYNXCFG) ||
		!strncmp(doc->address, "LYNXCOOKIE:", 11) ||
		LYIsUIPage(doc->address, UIP_TRACELOG)	) {
	    if (!related)
		PrevVisitedLink = NULL;
	    return;
	}
d99 5
d109 2
a110 5
	Latest_last.prev_latest = &Latest_first;
	Latest_first.next_latest = &Latest_last;
	Latest_last.next_latest = NULL;		/* Find bugs quick! */
	Latest_first.prev_latest = NULL;
	Last_by_first = Latest_tree = First_tree = NULL;
d114 10
a123 18
    while (NULL != (new = (VisitedLink *)HTList_nextObject(cur))) {
	if (!strcmp((new->address ? new->address : ""),
		    (doc->address ? doc->address : ""))) {
	    PrevVisitedLink = PrevActiveVisitedLink = new;
	    /* Already visited.  Update the last-visited info. */
	    if (new->next_latest == &Latest_last)	/* optimization */
		return;

	    /* Remove from "latest" chain */
	    new->prev_latest->next_latest = new->next_latest;
	    new->next_latest->prev_latest = new->prev_latest;

	    /* Insert at the end of the "latest" chain */
	    Latest_last.prev_latest->next_latest = new;
	    new->prev_latest = Latest_last.prev_latest;
	    new->next_latest = &Latest_last;
	    Latest_last.prev_latest = new;
	    return;
d126 1
a126 43

    if ((new = typecalloc(VisitedLink)) == NULL)
	outofmem(__FILE__, "LYAddVisitedLink");
    StrAllocCopy(new->address, doc->address);
    LYformTitle(&(new->title), title);

    /* First-visited chain */
    HTList_appendObject(Visited_Links, new);	/* At end */
    new->prev_first = Last_by_first;
    Last_by_first = new;

    /* Tree structure */
    if (PrevVisitedLink) {
	VisitedLink *a = PrevVisitedLink;
	VisitedLink *b = a->next_tree;
	int l = PrevVisitedLink->level;

	/* Find last on the deeper levels */
	while (b && b->level > l)
	    a = b, b = b->next_tree;

	if (!b)			/* a == Latest_tree */
	    Latest_tree = new;
	new->next_tree = a->next_tree;
	a->next_tree = new;

	new->level = PrevVisitedLink->level + 1;
    } else {
	if (Latest_tree)
	    Latest_tree->next_tree = new;
	new->level = 0;
	new->next_tree = NULL;
	Latest_tree = new;
    }
    PrevVisitedLink = PrevActiveVisitedLink = new;
    if (!First_tree)
	First_tree = new;

    /* "latest" chain */
    Latest_last.prev_latest->next_latest = new;
    new->prev_latest = Latest_last.prev_latest;
    new->next_latest = &Latest_last;
    Latest_last.prev_latest = new;
d133 1
a133 3
 *  forced.  If docurl is NULL, only the title is considered; otherwise
 *  also check the URL whether it is (likely to be) a generated special
 *  page.
d135 2
a136 3
PUBLIC BOOLEAN LYwouldPush ARGS2(
	CONST char *,	title,
	CONST char *,	docurl)
d138 3
a140 35
    BOOLEAN rc = FALSE;

    /*
     *  All non-pushable generated pages have URLs that begin with
     *  "file://localhost/" and end with HTML_SUFFIX. - kw
     */
    if (docurl) {
	size_t ulen;
	if (strncmp(docurl, "file://localhost/", 17) != 0 ||
	    (ulen = strlen(docurl)) <= strlen(HTML_SUFFIX) ||
	    strcmp(docurl + ulen - strlen(HTML_SUFFIX), HTML_SUFFIX) != 0) {
	    /*
	     *  If it is not a local HTML file, it may be a Web page that
	     *  accidentally has the same title.  So return TRUE now. - kw
	     */
	    return TRUE;
	}
    }

    if (docurl) {
	rc = (BOOLEAN)
		! (LYIsUIPage(docurl, UIP_HISTORY)
		|| LYIsUIPage(docurl, UIP_PRINT_OPTIONS)
		|| LYIsUIPage(docurl, UIP_DOWNLOAD_OPTIONS)
#ifdef DIRED_SUPPORT
		|| LYIsUIPage(docurl, UIP_DIRED_MENU)
		|| LYIsUIPage(docurl, UIP_UPLOAD_OPTIONS)
		|| LYIsUIPage(docurl, UIP_PERMIT_OPTIONS)
#endif /* DIRED_SUPPORT */
	    );
    } else {
	rc = (BOOLEAN)
		! (!strcmp(title, HISTORY_PAGE_TITLE)
		|| !strcmp(title, PRINT_OPTIONS_TITLE)
		|| !strcmp(title, DOWNLOAD_OPTIONS_TITLE)
d142 3
a144 3
		|| !strcmp(title, DIRED_MENU_TITLE)
		|| !strcmp(title, UPLOAD_OPTIONS_TITLE)
		|| !strcmp(title, PERMIT_OPTIONS_TITLE)
d146 3
a148 35
	    );
    }
    return rc;
}

/*
 *  Free the information in the last history entry.
 */
PRIVATE void clean_extra NOARGS
{
    trace_history("clean_extra");
    nhist += nhist_extra;
    while (nhist_extra > 0) {
	nhist--;
	FREE(history[nhist].title);
	FREE(history[nhist].address);
	FREE(history[nhist].post_data);
	FREE(history[nhist].post_content_type);
	FREE(history[nhist].bookmark);
	nhist_extra--;
    }
    trace_history("...clean_extra");
}

/* What is the relationship to are_different() from the mainloop?! */
PRIVATE int are_identical ARGS2(
	histstruct *,	doc,
	document *,	doc1)
{
     return (	STREQ(doc1->address, doc->address)
		&& !strcmp(doc1->post_data ? doc1->post_data : "",
			   doc->post_data ?  doc->post_data : "")
		&& !strcmp(doc1->bookmark ? doc1->bookmark : "",
			   doc->bookmark ?  doc->bookmark : "")
		&& doc1->isHEAD == doc->isHEAD );
d154 1
a154 1
PUBLIC int LYpush ARGS2(
d162 1
a162 1
	return 0;
d172 1
a172 1
	if (!LYwouldPush(doc->title, doc->address)) {
d175 1
a175 1
	    return 0;
d182 11
a192 1
    if ( nhist > 1 && are_identical(&(history[nhist-1]), doc)) {
d198 1
a198 1
	    return 0;
a200 15

    /*
     *	If file is identical to the current document, just move the pointer.
     */
    if ( nhist_extra >= 1 && are_identical(&(history[nhist]), doc)) {
	history[nhist].link = doc->link;
	history[nhist].line = doc->line;
	nhist_extra--;
	nhist++;
	trace_history("LYpush: just move the cursor");
	return 1;
    }

    clean_extra();

a206 1

d208 1
a208 2
	LYformTitle(&(history[nhist].title), doc->title);

a210 1

a212 1

a214 1

a216 1

d296 1
a296 1
			CTRACE((tfp, "\nLYpush: pushed as internal link, OK\n"));
d301 2
a302 2
		CTRACE((tfp, "\nLYpush: push as internal link requested, %s\n",
			    "but didn't check out!"));
d305 2
a306 2
	CTRACE((tfp, "\nLYpush[%d]: address:%s\n        title:%s\n",
		    nhist, doc->address, doc->title));
d312 2
a313 2
	CTRACE((tfp, "\nLYpush: MAXHIST reached for:\n        address:%s\n        title:%s\n",
		    doc->address, doc->title));
a314 1
    return 1;
a323 1
	clean_extra();
d342 1
a342 1
	LYSetNewline(doc->line);	/* reinitialize */
d344 2
a345 39
	CTRACE((tfp, "LYpop[%d]: address:%s\n     title:%s\n",
		    nhist, doc->address, doc->title));
    }
}

/*
 *  Move to the previous filename, link and line number from the history list.
 */
PUBLIC void LYhist_prev ARGS1(
	document *,	doc)
{
    trace_history("LYhist_prev");
    if (nhist > 0 && (nhist_extra || nhist < MAXHIST)) {
	nhist--;
	nhist_extra++;
	LYpop_num(nhist, doc);
	trace_history("...LYhist_prev");
    }
}

/*
 *  Called before calling LYhist_prev().
 */
PUBLIC void LYhist_prev_register ARGS1(
	document *,	doc)
{
    trace_history("LYhist_prev_register");
    if (nhist > 1) {
	if (nhist_extra) {	/* Make something to return back */
	    /* Store the new position */
	    history[nhist].link = doc->link;
	    history[nhist].line = doc->line;
	} else if (nhist < MAXHIST) { /* push will fail */
	    if (LYpush(doc, 0)) {
		nhist--;
		nhist_extra++;
	    }
	}
	trace_history("...LYhist_prev_register");
a349 18
 *  Move to the next filename, link and line number from the history list.
 */
PUBLIC int LYhist_next ARGS2(
	document *,	doc,
	document *,	newdoc)
{
    if (nhist_extra <= 1)	/* == 1 when we are the last one */
	return 0;
    /* Store the new position */
    history[nhist].link = doc->link;
    history[nhist].line = doc->line;
    nhist++;
    nhist_extra--;
    LYpop_num(nhist, newdoc);
    return 1;
}

/*
d358 1
a358 1
    if (number >= 0 && nhist + nhist_extra > number) {
d371 1
a371 1
	LYSetNewline(doc->line);	/* reinitialize */
d382 1
a382 1
    static char tempfile[LY_MAXPATH] = "\0";
d387 2
a388 7
    if (LYReuseTempfiles) {
	fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
    } else {
	LYRemoveTemp(tempfile);
	fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
    }
    if (fp0 == NULL) {
d400 1
a400 1
    fprintf(fp0, "<p align=right> <a href=\"LYNXMESSAGES:\">[%s]</a>\n",
d406 1
a406 1
    for (x = nhist + nhist_extra - 1; x >= 0; x--) {
d463 1
a463 1
	strlen(newdoc->address) < 10 || !isdigit(UCH(*(newdoc->address+9))))
d466 1
a466 1
    if ((number = atoi(newdoc->address+9)) > nhist + nhist_extra || number < 0)
a471 4
     * But check first whether HTMainText is really the History
     * Page document - in some obscure situations this may not be
     * the case.  If HTMainText seems to be a History Page document,
     * also check that it really hasn't been pushed. - LP, kw
d473 1
a473 6
    if (HTMainText && nhist > 0 &&
	!strcmp(HTLoadedDocumentTitle(), HISTORY_PAGE_TITLE) &&
	LYIsUIPage3(HTLoadedDocumentURL(), UIP_HISTORY, 0) &&
	strcmp(HTLoadedDocumentURL(), history[nhist-1].address)) {
	HTuncache_current_document();  /* don't waste the cache */
    }
d529 2
a530 2
 *  This procedure outputs the Visited Links list into a temporary file. - FM
 *  Returns links's number to make active (1-based), or 0 if not required.
d535 1
a535 1
    static char tempfile[LY_MAXPATH] = "\0";
d538 1
a538 1
    int x, tot;
a541 3
    int offset;
    int ret = 0;
    char *arrow, *post_arrow;
d546 2
a547 7
    if (LYReuseTempfiles) {
	fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
    } else {
	LYRemoveTemp(tempfile);
	fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
    }
    if (fp0 == NULL) {
a552 1
    LYRegisterUIPage(*newfile, UIP_VLINKS);
a558 18
    fprintf(fp0, "<form action=\"LYNXOPTIONS:\" method=\"post\">\n");
    fprintf(fp0, "<select name=\"visited_pages_type\">\n");
    fprintf(fp0, " <option value=\"first_visited\" %s>Sort By First Visited\n",
		 (Visited_Links_As == VISITED_LINKS_AS_FIRST_V ? "selected" : ""));
    fprintf(fp0, " <option value=\"first_visited_reversed\" %s>Reverse Sort By First Visited\n",
		 (Visited_Links_As == (VISITED_LINKS_AS_FIRST_V|VISITED_LINKS_REVERSE) ? "selected" : ""));
    fprintf(fp0, " <option value=\"visit_tree\" %s>View As Visit Tree\n",
		 (Visited_Links_As == VISITED_LINKS_AS_TREE ? "selected" : ""));
    fprintf(fp0, " <option value=\"last_visited\" %s>Sort By Last Visited\n",
		 (Visited_Links_As == VISITED_LINKS_AS_LATEST ? "selected" : ""));
    fprintf(fp0, " <option value=\"last_visited_reversed\" %s>Reverse Sort By Last Visited\n",
		 (Visited_Links_As == (VISITED_LINKS_AS_LATEST|VISITED_LINKS_REVERSE)
		   ? "selected" : ""));
    fprintf(fp0, "</select>\n");
    fprintf(fp0, "<input type=\"submit\" value=\"Accept Changes\">\n");
    fprintf(fp0, "</form>\n");
    fprintf(fp0, "<P>\n");

d562 2
a563 21
    if (Visited_Links_As & VISITED_LINKS_REVERSE)
	tot = x = HTList_count(Visited_Links);
    else
	tot = x = -1;

    if (Visited_Links_As & VISITED_LINKS_AS_TREE) {
	vl = First_tree;
    } else if (Visited_Links_As & VISITED_LINKS_AS_LATEST) {
	if (Visited_Links_As & VISITED_LINKS_REVERSE)
	    vl = Latest_last.prev_latest;
	else
	    vl = Latest_first.next_latest;
	if (vl == &Latest_last || vl == &Latest_first)
	    vl = NULL;
    } else {
	if (Visited_Links_As & VISITED_LINKS_REVERSE)
	    vl = Last_by_first;
	else
	    vl = (VisitedLink *)HTList_nextObject(cur);
    }
    while (NULL != vl) {
d568 1
a568 26
	post_arrow = arrow = "";
	if (Visited_Links_As & VISITED_LINKS_REVERSE)
	    x--;
	else
	    x++;
	if (vl == PrevActiveVisitedLink) {
	    if (Visited_Links_As & VISITED_LINKS_REVERSE)
		ret = tot - x + 2;
	    else
		ret = x + 3;
	}
	if (vl == PrevActiveVisitedLink) {
	    post_arrow = "<A NAME=current></A>";
	    /* Otherwise levels 0 and 1 look the same when with arrow: */
	    arrow = (vl->level && (Visited_Links_As & VISITED_LINKS_AS_TREE))
			 ? "==>" : "=>";
	    StrAllocCat(*newfile, "#current");
	}
	if (Visited_Links_As & VISITED_LINKS_AS_TREE) {
	    offset = 2 * vl->level;
	    if (offset > 24)
		offset = (offset + 24)/2;
	    if (offset > LYcols * 3/4)
		offset = LYcols * 3/4;
	} else
	    offset = (x > 99 ? 0 : x < 10 ? 2 : 1);
d583 2
a584 2
		    "%-*s%s<em>%d</em>. <tab id=t%d><a href=\"%s\">%s</a>\n",
		    offset, arrow, post_arrow,
d588 2
a589 2
		    "%-*s%s<em>%d</em>. <tab id=t%d><em>%s</em>\n",
		    offset, arrow, post_arrow,
a597 15
	if (Visited_Links_As & VISITED_LINKS_AS_TREE)
	    vl = vl->next_tree;
	else if (Visited_Links_As & VISITED_LINKS_AS_LATEST) {
	    if (Visited_Links_As & VISITED_LINKS_REVERSE)
		vl = vl->prev_latest;
	    else
		vl = vl->next_latest;
	    if (vl == &Latest_last || vl == &Latest_first)
		vl = NULL;
	} else {
	    if (Visited_Links_As & VISITED_LINKS_REVERSE)
		vl = vl->prev_first;
	    else
		vl = (VisitedLink *)HTList_nextObject(cur);
	}
d605 1
a605 1
    return(ret);
d635 1
a635 1
    if (topOfStack >= STATUSBUFSIZE) {
d651 39
a689 2
    if (topOfStack >= STATUSBUFSIZE) {
	topOfStack = 0;
d691 19
a711 1

d729 1
a729 1
    while (++i < STATUSBUFSIZE) {
d752 1
a752 1
	HTSprintf0(&temp, message, (argument == 0) ? "" : argument);
a765 105

/*     LYLoadMESSAGES
**     --------------
**     Create a text/html stream with a list of recent statusline messages.
**     LYNXMESSAGES:/ internal page.
**     [implementation based on LYLoadKeymap()].
*/

struct _HTStream
{
    HTStreamClass * isa;
};

PRIVATE int LYLoadMESSAGES ARGS4 (
	CONST char *,		arg GCC_UNUSED,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
{
    HTFormat format_in = WWW_HTML;
    HTStream *target = NULL;
    char *buf = NULL;
    int nummsg = 0;

    int i;
    char *temp = NULL;

    i = STATUSBUFSIZE;
    while (--i >= 0) {
	if (buffstack[i] != NULL)
	    nummsg++;
    }

    /*
     *  Set up the stream. - FM
     */
    target = HTStreamStack(format_in, format_out, sink, anAnchor);

    if (!target || target == NULL) {
	HTSprintf0(&buf, CANNOT_CONVERT_I_TO_O,
			 HTAtom_name(format_in), HTAtom_name(format_out));
	HTAlert(buf);
	FREE(buf);
	return(HT_NOT_LOADED);
    }
    anAnchor->no_cache = TRUE;

#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

    HTSprintf0(&buf, "<html>\n<head>\n");
    PUTS(buf);
	/*
	 *  This page is a list of messages in display character set.
	 */
    HTSprintf0(&buf, "<META %s content=\"text/html;charset=%s\">\n",
	       "http-equiv=\"content-type\"",
	       LYCharSet_UC[current_char_set].MIMEname);
    PUTS(buf);
    HTSprintf0(&buf, "<title>%s</title>\n</head>\n<body>\n",
	       STATUSLINES_TITLE);
    PUTS(buf);

    if (nummsg != 0) {
	HTSprintf0(&buf, "<ol>\n");
	PUTS(buf);
	/* print messages in reverse order: */
	i = topOfStack;
	while (--i >= 0) {
	    if (buffstack[i] != NULL) {
		StrAllocCopy(temp, buffstack[i]);
		LYEntify(&temp, TRUE);
		HTSprintf0(&buf, "<li value=%d> <em>%s</em>\n", nummsg, temp);
		nummsg--;
		PUTS(buf);
	    }
	}
	i = STATUSBUFSIZE;
	while (--i >= topOfStack) {
	    if (buffstack[i] != NULL) {
		StrAllocCopy(temp, buffstack[i]);
		LYEntify(&temp, TRUE);
		HTSprintf0(&buf, "<li value=%d> <em>%s</em>\n", nummsg, temp);
		nummsg--;
		PUTS(buf);
	    }
	}
	FREE(temp);
	HTSprintf0(&buf, "</ol>\n</body>\n</html>\n");
    } else {
	HTSprintf0(&buf, "<p>%s\n</body>\n</html>\n",
		   gettext("(No messages yet)"));
    }
    PUTS(buf);

    (*target->isa->_free)(target);
    FREE(buf);
    return(HT_LOADED);
}

#ifdef GLOBALDEF_IS_MACRO
#define _LYMESSAGES_C_GLOBALDEF_1_INIT { "LYNXMESSAGES", LYLoadMESSAGES, 0}
GLOBALDEF (HTProtocol,LYLynxStatusMessages,_LYMESSAGES_C_GLOBALDEF_1_INIT);
#else
GLOBALDEF PUBLIC HTProtocol LYLynxStatusMessages = {"LYNXMESSAGES", LYLoadMESSAGES, 0};
#endif /* GLOBALDEF_IS_MACRO */
@

