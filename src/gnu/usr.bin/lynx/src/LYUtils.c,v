head	1.8;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.8
	tg-mergefixes-1-branch:1.1.3.8.0.4
	tg-mergefixes-1-base:1.1.3.8
	MIROS_X:1.1.3.8.0.2
	MIROS_X_BASE:1.1.3.8
	MIRBSD_XP_MIRPPC:1.1.3.6.0.4
	lynx-2_8_6dev_7b:1.1.3.8
	lynx-2_8_6dev_6:1.1.3.7
	MIRBSD_XP_SPARC_BASE:1.1.3.6
	MIRBSD_XP_SPARC:1.1.3.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.6
	lynx-2_8_6dev_5:1.1.3.6
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.6
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.5
	lynx-2_8_5:1.1.3.4
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.3
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.6.0.6
	MIRBSD_7:1.6.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.6
	MIRBSD_7_DEV:1.6.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2005.01.03.00.46.05;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.18.16.56.29;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.27.13.45.09;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.27.13.12.48;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.07.20.00.29;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.39;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.35;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.28;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.43;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.25;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.46.18;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.01.18.15.34.44;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.02.08.13.11.54;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.04.30.16.16.09;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.07.15.15.54.30;	author tg;	state Stab;
branches;
next	1.1.3.7;

1.1.3.7
date	2004.10.11.20.16.26;	author tg;	state Exp;
branches;
next	1.1.3.8;

1.1.3.8
date	2004.10.20.10.10.45;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@soft merge
@
text
@#include <HTUtils.h>
#include <HTTCP.h>
#include <HTParse.h>
#include <HTAccess.h>
#include <HTCJK.h>
#include <HTAlert.h>

#ifdef __MINGW32__
int kbhit(void);

#ifdef UNIX
#undef UNIX
#endif /* UNIX */
#endif /* __MINGW32__ */

#include <LYCurses.h>
#include <LYHistory.h>
#include <LYStrings.h>
#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <LYSignal.h>
#include <GridText.h>
#include <LYClean.h>
#include <LYCharSets.h>
#include <LYCharUtils.h>

#include <LYMainLoop.h>
#include <LYKeymap.h>

#ifdef __DJGPP__
#include <go32.h>
#include <sys/exceptn.h>
#endif /* __DJGPP__ */

#ifndef NO_GROUPS
#include <HTFile.h>
#endif

#ifdef _WINDOWS			/* 1998/04/30 (Thu) 19:04:25 */
#define GETPID()	(getpid() & 0xffff)
#else
#define GETPID()	getpid()
#endif /* _WINDOWS */

#ifdef DJGPP_KEYHANDLER
#include <bios.h>
#endif /* DJGPP_KEYHANDLER */

#ifdef __EMX__
#  define BOOLEAN OS2_BOOLEAN	/* Conflicts, but is used */
#  undef HT_ERROR		/* Conflicts too */
#  define INCL_PM		/* I want some PM functions.. */
#  define INCL_DOSPROCESS	/* TIB PIB. */
#  include <os2.h>
#  undef BOOLEAN
#endif

#ifdef VMS
#include <descrip.h>
#include <libclidef.h>
#include <lib$routines.h>
#endif /* VMS */

#ifdef HAVE_UTMP
#include <pwd.h>
#ifdef UTMPX_FOR_UTMP
#include <utmpx.h>
#define utmp utmpx
#ifdef UTMPX_FILE
#ifdef UTMP_FILE
#undef UTMP_FILE
#endif /* UTMP_FILE */
#define UTMP_FILE UTMPX_FILE
#else
#ifdef __UTMPX_FILE
#define UTMP_FILE __UTMPX_FILE	/* at least in OS/390  S/390 -- gil -- 2100 */
#else
#define UTMP_FILE "/var/adm/utmpx"	/* Digital Unix 4.0 */
#endif
#endif /* UTMPX_FILE */
#else
#include <utmp.h>
#endif /* UTMPX_FOR_UTMP */
#endif /* HAVE_UTMP */

#ifdef NEED_PTEM_H
/* they neglected to define struct winsize in termios.h -- it's only in
 * termio.h and ptem.h (the former conflicts with other definitions).
 */
#include	<sys/stream.h>
#include	<sys/ptem.h>
#endif

#include <LYLeaks.h>

#ifdef USE_COLOR_STYLE
#include <AttrList.h>
#include <LYHash.h>
#include <LYStyle.h>
#endif

#ifdef SVR4_BSDSELECT
extern int BSDselect(int nfds, fd_set * readfds, fd_set * writefds,
		     fd_set * exceptfds, struct timeval *timeout);

#ifdef select
#undef select
#endif /* select */
#define select BSDselect
#ifdef SOCKS
#ifdef Rselect
#undef Rselect
#endif /* Rselect */
#define Rselect BSDselect
#endif /* SOCKS */
#endif /* SVR4_BSDSELECT */

#ifdef __DJGPP__
#undef select			/* defined to select_s in www_tcp.h */
#endif

#ifndef UTMP_FILE
#if defined(__FreeBSD__) || defined(__bsdi__)
#define UTMP_FILE _PATH_UTMP
#else
#define UTMP_FILE "/etc/utmp"
#endif /* __FreeBSD__ || __bsdi__ */
#endif /* !UTMP_FILE */

/*
 * experimental - make temporary filenames random to make the scheme less
 * obvious.  However, as noted by KW, there are instances (such as the
 * 'O'ption page, for which Lynx will store a temporary filename even when
 * it no longer applies, since it will reuse that filename at a later time.
 */
#ifdef EXP_RAND_TEMPNAME
#if defined(LYNX_RAND_MAX)
#define USE_RAND_TEMPNAME 1
#define MAX_TEMPNAME 10000
#ifndef BITS_PER_CHAR
#define BITS_PER_CHAR 8
#endif
#endif
#endif

#define COPY_COMMAND "%s %s %s"

static HTList *localhost_aliases = NULL;	/* Hosts to treat as local */
static char *HomeDir = NULL;	/* HOME directory */

HTList *sug_filenames = NULL;	/* Suggested filenames   */

/*
 * Maintain a list of all of the temp-files we create so that we can remove
 * them during the cleanup.
 */
typedef struct _LYTemp {
    struct _LYTemp *next;
    char *name;
    BOOLEAN outs;
    FILE *file;
} LY_TEMP;

static LY_TEMP *ly_temp;

static LY_TEMP *FindTempfileByName(const char *name)
{
    LY_TEMP *p;

    for (p = ly_temp; p != 0; p = p->next) {
	if (!strcmp(p->name, name)) {
	    break;
	}
    }
    return p;
}

static LY_TEMP *FindTempfileByFP(FILE *fp)
{
    LY_TEMP *p;

    for (p = ly_temp; p != 0; p = p->next) {
	if (p->file == fp) {
	    break;
	}
    }
    return p;
}

/*
 * Get an environment variable, rejecting empty strings
 */
char *LYGetEnv(const char *name)
{
    char *result = getenv(name);

    return non_empty(result) ? result : 0;
}

/*
 * ascii versions of locale sensitive functions needed because in
 * Turkish locales tolower("I") is not "i". That's fatal for case
 * sensitive operations with charset names, HTML tags etc.
 */
#ifdef EXP_ASCII_CTYPES
int ascii_tolower(int i)
{
    if (91 > i && i > 64)
	return (i + 32);
    else
	return i;
}

int ascii_toupper(int i)
{
    if (123 > i && i > 96)
	return (i - 32);
    else
	return i;
}

int ascii_isupper(int i)
{
    if (91 > i && i > 64)
	return 1;
    else
	return 0;
}
#endif /* EXP_ASCII_CTYPES */

/*
 * Check for UTF-8 data, returning the length past the first character.
 * Return zero if we found an ordinary character rather than UTF-8.
 */
size_t utf8_length(BOOL utf_flag,
		   const char *data)
{
    size_t utf_extra = 0;

    if (utf_flag && is8bits(*data)) {
	if ((*data & 0xe0) == 0xc0) {
	    utf_extra = 1;
	} else if ((*data & 0xf0) == 0xe0) {
	    utf_extra = 2;
	} else if ((*data & 0xf8) == 0xf0) {
	    utf_extra = 3;
	} else if ((*data & 0xfc) == 0xf8) {
	    utf_extra = 4;
	} else if ((*data & 0xfe) == 0xfc) {
	    utf_extra = 5;
	} else {
	    /*
	     * Garbage.
	     */
	    utf_extra = 0;
	}
	if (strlen(data + 1) < utf_extra) {
	    /*
	     * Shouldn't happen.
	     */
	    utf_extra = 0;
	}
    }
    return utf_extra;
}

/*
 * Free storage used for the link-highlighting.
 */
void LYFreeHilites(int first, int last)
{
    int i;

    for (i = first; i < last; i++) {
	LYSetHilite(i, NULL);
	FREE(links[i].lname);
    }
}

/*
 * Set the initial highlight information for a given link.
 */
void LYSetHilite(int cur,
		 const char *text)
{
    links[cur].list.hl_base.hl_text = (char *) text;
    links[cur].list.hl_len = (text != NULL) ? 1 : 0;
    FREE(links[cur].list.hl_info);
}

/*
 * Add highlight information for the next line of a link.
 */
void LYAddHilite(int cur,
		 char *text,
		 int x)
{
    HiliteList *list = &(links[cur].list);
    HiliteInfo *have = list->hl_info;
    unsigned need = (list->hl_len - 1);
    unsigned want = (list->hl_len += 1);

    if (have != NULL) {
	have = typeRealloc(HiliteInfo, have, want);
    } else {
	have = typeMallocn(HiliteInfo, want);
    }
    list->hl_info = have;
    have[need].hl_text = text;
    have[need].hl_x = x;
}

/*
 * Get the highlight text, counting from zero.
 */
const char *LYGetHiliteStr(int cur,
			   int count)
{
    const char *result;

    if (count >= links[cur].list.hl_len)
	result = NULL;
    else if (count > 0)
	result = links[cur].list.hl_info[count - 1].hl_text;
    else
	result = links[cur].list.hl_base.hl_text;
    return result;
}

/*
 * Get the X-ordinate at which to draw the corresponding highlight-text
 */
int LYGetHilitePos(int cur,
		   int count)
{
    int result;

    if (count >= links[cur].list.hl_len)
	result = -1;
    else if (count > 0)
	result = links[cur].list.hl_info[count - 1].hl_x;
    else
	result = links[cur].lx;
    return result;
}

#define LXP (links[cur].lx)
#define LYP (links[cur].ly)

#ifdef SHOW_WHEREIS_TARGETS

#define SKIP_GLYPHS(theFlag, theData, theOffset) \
	(theFlag \
	    ? LYmbcs_skip_glyphs(theData, (theOffset), theFlag) \
	    : (theData + (theOffset)))

/*
 * If we have an emphasized WHEREIS hit in the highlighted text, restore the
 * emphasis.  Note that we never emphasize the first and last characters of the
 * highlighted text when we are making the link current, so the link attributes
 * for the current link will persist at the beginning and end, providing an
 * indication to the user that it has been made current.  Also note that we use
 * HText_getFirstTargetInLine() to determine if there's a hit in the HText
 * structure line containing the link, and if so, get back a copy of the line
 * starting at that first hit (which might be before or after our link), and
 * with all IsSpecial characters stripped, so we don't need to deal with them
 * here.  -FM
 */
static BOOL show_whereis_targets(int flag,
				 int cur,
				 int count,
				 const char *target,
				 BOOL TargetEmphasisON,
				 BOOL utf_flag)
{
    const char *Data = NULL;
    const char *cp;
    char *theData = NULL;
    char buffer[MAX_LINE];
    char tmp[7];
    int HitOffset;
    int LenNeeded;
    int Offset;
    int tLen;

    tmp[0] = tmp[1] = tmp[2] = '\0';

    if (non_empty(target)
	&& (links[cur].type & WWW_LINK_TYPE)
	&& non_empty(LYGetHiliteStr(cur, count))
	&& links[cur].ly + count < display_lines
	&& HText_getFirstTargetInLine(HTMainText,
				      links[cur].anchor_line_num + count,
				      utf_flag,
				      &Offset,
				      &tLen,
				      &theData,
				      target)) {
	int itmp, written, len, y, offset;
	const char *data;
	int tlen = strlen(target);
	int hlen, hLen;
	int hLine = links[cur].ly + count;
	int hoffset = LYGetHilitePos(cur, count);
	size_t utf_extra = 0;

	/*
	 * Copy into the buffer only what will fit up to the right border of
	 * the screen.  -FM
	 */
	LYmbcsstrncpy(buffer,
		      NonNull(LYGetHiliteStr(cur, count)),
		      (sizeof(buffer) - 1),
		      (LYcolLimit - LYGetHilitePos(cur, count)),
		      utf_flag);
	hlen = strlen(buffer);
	hLen = ((HTCJK != NOCJK || utf_flag) ?
		LYmbcsstrlen(buffer, utf_flag, YES) : hlen);

	/*
	 * Break out if the first hit in the line starts after this link.  -FM
	 */
	if (Offset < (hoffset + hLen)) {
	    /*
	     * Recursively skip hits that end before this link, and break out
	     * if there is no hit beyond those.  -FM
	     */
	    Data = theData;
	    while ((Offset < hoffset) &&
		   ((Offset + tLen) <= hoffset)) {
		data = (Data + tlen);
		offset = (Offset + tLen);
		if (((cp = LYno_attr_mb_strstr(data,
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL)
		    && (offset + LenNeeded) < LYcols) {
		    Data = cp;
		    Offset = (offset + HitOffset);
		} else {
		    goto highlight_search_done;
		}
	    }
	    data = buffer;
	    offset = hoffset;

	    /*
	     * If the hit starts before the hightext, and ends in or beyond the
	     * hightext, restore the emphasis, skipping the first and last
	     * characters of the hightext if we're making the link current.
	     * -FM
	     */
	    if ((Offset < offset) &&
		((Offset + tLen) > offset)) {
		itmp = 0;
		written = 0;
		len = (tlen - (offset - Offset));

		/*
		 * Go to the start of the hightext and handle its first
		 * character.  -FM
		 */
		LYmove(hLine, offset);
		tmp[0] = data[itmp];
		utf_extra = utf8_length(utf_flag, data + itmp);
		if (utf_extra) {
		    LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
		    itmp += utf_extra;
		    /*
		     * Start emphasis immediately if we are making the link
		     * non-current.  -FM
		     */
		    if (flag != ON) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
		    }
		    tmp[1] = '\0';
		    written += (utf_extra + 1);
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && is8bits(tmp[0])) {
		    /*
		     * For CJK strings, by Masanobu Kimura.
		     */
		    tmp[1] = data[++itmp];
		    /*
		     * Start emphasis immediately if we are making the link
		     * non-current.  -FM
		     */
		    if (flag != ON) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
		    }
		    tmp[1] = '\0';
		    written += 2;
		} else {
		    /*
		     * Start emphasis immediately if we are making the link
		     * non-current.  -FM
		     */
		    if (flag != ON) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
		    }
		    written++;
		}
		itmp++;
		/*
		 * Start emphasis after the first character if we are making
		 * the link current and this is not the last character.  -FM
		 */
		if (!TargetEmphasisON &&
		    data[itmp] != '\0') {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		}

		/*
		 * Handle the remaining characters.  -FM
		 */
		for (;
		     written < len && (tmp[0] = data[itmp]) != '\0';
		     itmp++) {
		    /*
		     * Print all the other target chars, except the last
		     * character if it is also the last character of hightext
		     * and we are making the link current.  -FM
		     */
		    utf_extra = utf8_length(utf_flag, data + itmp);
		    if (utf_extra) {
			LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
			itmp += utf_extra;
			/*
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
			 */
			if (flag == ON && data[(itmp + 1)] == '\0') {
			    LYstopTargetEmphasis();
			    TargetEmphasisON = FALSE;
			    LYGetYX(y, offset);
			    LYmove(hLine, (offset + 1));
			} else {
			    LYaddstr(tmp);
			}
			tmp[1] = '\0';
			written += (utf_extra + 1);
			utf_extra = 0;
		    } else if (HTCJK != NOCJK && is8bits(tmp[0])) {
			/*
			 * For CJK strings, by Masanobu Kimura.
			 */
			tmp[1] = data[++itmp];
			/*
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
			 */
			if (flag == ON && data[(itmp + 1)] == '\0') {
			    LYstopTargetEmphasis();
			    TargetEmphasisON = FALSE;
			    LYGetYX(y, offset);
			    LYmove(hLine, (offset + 1));
			} else {
			    LYaddstr(tmp);
			}
			tmp[1] = '\0';
			written += 2;
		    } else {
			/*
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
			 */
			if (flag == ON && data[(itmp + 1)] == '\0') {
			    LYstopTargetEmphasis();
			    TargetEmphasisON = FALSE;
			    LYGetYX(y, offset);
			    LYmove(hLine, (offset + 1));
			} else {
			    LYaddstr(tmp);
			}
			written++;
		    }
		}

		/*
		 * Stop the emphasis if we haven't already, then reset the
		 * offset to our current position in the line, and if that is
		 * beyond the link, or or we are making the link current and it
		 * is the last character of the hightext, we are done.  -FM
		 */
		if (TargetEmphasisON) {
		    LYstopTargetEmphasis();
		    TargetEmphasisON = FALSE;
		}
		LYGetYX(y, offset);
		if (offset < (hoffset + (flag == ON ? (hLen - 1) : hLen))
		/*
		 * See if we have another hit that starts within the
		 * hightext.  -FM
		 */
		    && ((cp =
			 LYno_attr_mb_strstr(data = SKIP_GLYPHS(utf_flag,
								Data,
								offset - Offset),
					     target,
					     utf_flag, YES,
					     &HitOffset,
					     &LenNeeded)) != NULL)
		    && (offset + LenNeeded) < LYcols
		/*
		 * If the hit starts after the end of the hightext, or we
		 * are making the link current and the hit starts at its
		 * last character, we are done.  -FM
		 */
		    && (HitOffset + offset) <
		    (hoffset +
		     (flag == ON ? (hLen - 1) : hLen))) {
		    /*
		     * Set up the data and offset for the hit, and let the code
		     * for within hightext hits handle it.  -FM
		     */
		    Data = cp;
		    Offset = (offset + HitOffset);
		    data = buffer;
		    offset = hoffset;
		    goto highlight_hit_within_hightext;
		}
		goto highlight_search_done;
	    }

	  highlight_hit_within_hightext:
	    /*
	     * If we get to here, the hit starts within the hightext.  If we
	     * are making the link current and it's the last character in the
	     * hightext, we are done.  Otherwise, move there and start
	     * restoring the emphasis.  -FM
	     */
	    if ((Offset - offset) <= (flag == ON ? (hLen - 1) : hLen)) {
		data = SKIP_GLYPHS(utf_flag, data, Offset - offset);
		if (utf_flag) {
		    LYrefresh();
		}
		offset = Offset;
		itmp = 0;
		written = 0;
		len = tlen;

		/*
		 * Go to the start of the hit and handle its first character.
		 * -FM
		 */
		LYmove(hLine, offset);
		tmp[0] = data[itmp];
		utf_extra = utf8_length(utf_flag, data + itmp);
		if (utf_extra) {
		    LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
		    itmp += utf_extra;
		    /*
		     * Start emphasis immediately if we are making the link
		     * non-current, or we are making it current but this is not
		     * the first or last character of the hightext.  -FM
		     */
		    if (flag != ON ||
			(offset > hoffset && data[itmp + 1] != '\0')) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
		    }
		    tmp[1] = '\0';
		    written += (utf_extra + 1);
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && is8bits(tmp[0])) {
		    /*
		     * For CJK strings, by Masanobu Kimura.
		     */
		    tmp[1] = data[++itmp];
		    /*
		     * Start emphasis immediately if we are making the link
		     * non-current, or we are making it current but this is not
		     * the first or last character of the hightext.  -FM
		     */
		    if (flag != ON ||
			(offset > hoffset && data[itmp + 1] != '\0')) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 2));
		    }
		    tmp[1] = '\0';
		    written += 2;
		} else {
		    /*
		     * Start emphasis immediately if we are making the link
		     * non-current, or we are making it current but this is not
		     * the first or last character of the hightext.  -FM
		     */
		    if (flag != ON ||
			(offset > hoffset && data[itmp + 1] != '\0')) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
		    }
		    written++;
		}
		itmp++;
		/*
		 * Start emphasis after the first character if we are making
		 * the link current and this is not the last character.  -FM
		 */
		if (!TargetEmphasisON &&
		    data[itmp] != '\0') {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		}

		for (;
		     written < len && (tmp[0] = data[itmp]) != '\0';
		     itmp++) {
		    /*
		     * Print all the other target chars, except the last
		     * character if it is also the last character of hightext
		     * and we are making the link current.  -FM
		     */
		    utf_extra = utf8_length(utf_flag, data + itmp);
		    if (utf_extra) {
			LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
			itmp += utf_extra;
			/*
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
			 */
			if (flag == ON && data[(itmp + 1)] == '\0') {
			    LYstopTargetEmphasis();
			    TargetEmphasisON = FALSE;
			    LYGetYX(y, offset);
			    LYmove(hLine, (offset + 1));
			} else {
			    LYaddstr(tmp);
			}
			tmp[1] = '\0';
			written += (utf_extra + 1);
			utf_extra = 0;
		    } else if (HTCJK != NOCJK && is8bits(tmp[0])) {
			/*
			 * For CJK strings, by Masanobu Kimura.
			 */
			tmp[1] = data[++itmp];
			/*
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
			 */
			if (flag == ON && data[(itmp + 1)] == '\0') {
			    LYstopTargetEmphasis();
			    TargetEmphasisON = FALSE;
			    LYGetYX(y, offset);
			    LYmove(hLine, (offset + 1));
			} else {
			    LYaddstr(tmp);
			}
			tmp[1] = '\0';
			written += 2;
		    } else {
			/*
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
			 */
			if (flag == ON && data[(itmp + 1)] == '\0') {
			    LYstopTargetEmphasis();
			    TargetEmphasisON = FALSE;
			    LYGetYX(y, offset);
			    LYmove(hLine, (offset + 1));
			} else {
			    LYaddstr(tmp);
			}
			written++;
		    }
		}

		/*
		 * Stop the emphasis if we haven't already, then reset the
		 * offset to our current position in the line, and if that is
		 * beyond the link, or we are making the link current and it is
		 * the last character in the hightext, we are done.  -FM
		 */
		if (TargetEmphasisON) {
		    LYstopTargetEmphasis();
		    TargetEmphasisON = FALSE;
		}
		LYGetYX(y, offset);
		if (offset < (hoffset + (flag == ON ? (hLen - 1) : hLen))
		/*
		 * See if we have another hit that starts within the
		 * hightext.  -FM
		 */
		    && ((cp =
			 LYno_attr_mb_strstr(data = SKIP_GLYPHS(utf_flag,
								Data,
								offset - Offset),
					     target,
					     utf_flag, YES,
					     &HitOffset,
					     &LenNeeded)) != NULL)
		    && (offset + LenNeeded) < LYcols
		/*
		 * If the hit starts after the end of the hightext, or we
		 * are making the link current and the hit starts at its
		 * last character, we are done.  -FM
		 */
		    && (HitOffset + offset) <
		    (hoffset + (flag == ON ? (hLen - 1) : hLen))) {
		    /*
		     * If the target extends beyond our buffer, emphasize
		     * everything in the hightext starting at this hit.
		     * Otherwise, set up the data and offsets, and loop back.
		     * -FM
		     */
		    if ((HitOffset + (offset + tLen)) >= (hoffset + hLen)) {
			offset = (HitOffset + offset);
			data = SKIP_GLYPHS(utf_flag, Data, offset - hoffset);
			if (utf_flag) {
			    LYrefresh();
			}
			LYmove(hLine, offset);
			itmp = 0;
			written = 0;
			len = strlen(data);

			/*
			 * Turn the emphasis back on.  -FM
			 */
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			for (;
			     written < len && (tmp[0] = data[itmp]) != '\0';
			     itmp++) {
			    /*
			     * Print all the other target chars, except the
			     * last character if it is also the last character
			     * of hightext and we are making the link current.
			     * -FM
			     */
			    utf_extra = utf8_length(utf_flag, data + itmp);
			    if (utf_extra) {
				LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
				itmp += utf_extra;
				/*
				 * Make sure we don't restore emphasis to the
				 * last character of hightext if we are making
				 * the link current.  -FM
				 */
				if (flag == ON && data[(itmp + 1)] == '\0') {
				    LYstopTargetEmphasis();
				    TargetEmphasisON = FALSE;
				    LYGetYX(y, offset);
				    LYmove(hLine, (offset + 1));
				} else {
				    LYaddstr(tmp);
				}
				tmp[1] = '\0';
				written += (utf_extra + 1);
				utf_extra = 0;
			    } else if (HTCJK != NOCJK && is8bits(tmp[0])) {
				/*
				 * For CJK strings, by Masanobu Kimura.
				 */
				tmp[1] = data[++itmp];
				/*
				 * Make sure we don't restore emphasis to the
				 * last character of hightext if we are making
				 * the link current.  -FM
				 */
				if (flag == ON && data[(itmp + 1)] == '\0') {
				    LYstopTargetEmphasis();
				    TargetEmphasisON = FALSE;
				} else {
				    LYaddstr(tmp);
				}
				tmp[1] = '\0';
				written += 2;
			    } else {
				/*
				 * Make sure we don't restore emphasis to the
				 * last character of hightext if we are making
				 * the link current.  -FM
				 */
				if (flag == ON && data[(itmp + 1)] == '\0') {
				    LYstopTargetEmphasis();
				    TargetEmphasisON = FALSE;
				} else {
				    LYaddstr(tmp);
				}
				written++;
			    }
			}
			/*
			 * Turn off the emphasis if we haven't already, and
			 * then we're done.  -FM
			 */
			if (TargetEmphasisON) {
			    LYstopTargetEmphasis();
			}
		    } else {
			Data = cp;
			Offset = (offset + HitOffset);
			data = buffer;
			offset = hoffset;
			goto highlight_hit_within_hightext;
		    }
		}
	    }
	}
    }
  highlight_search_done:
    FREE(theData);
    return TargetEmphasisON;
}
#endif /* SHOW_WHEREIS_TARGETS */

#ifdef USE_COLOR_STYLE
static int find_cached_style(int cur,
			     int flag)
{
    int s = s_alink;

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
    if (textfields_need_activation
	&& links[cur].type == WWW_FORM_LINK_TYPE
	&& F_TEXTLIKE(links[cur].l_form->type))
	s = s_curedit;
#endif

    if (flag != ON) {
	int x;

	/*
	 * This is where we try to restore the original style when a link is
	 * unhighlighted.  The purpose of cached_styles[][] is to save the
	 * original style just for this case.  If it doesn't have a color
	 * change saved at just the right position, we look at preceding
	 * positions in the same line until we find one.
	 */
	if (LYP >= 0 && LYP < CACHEH && LXP >= 0 && LXP < CACHEW) {
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.off: cached style @@(%d,%d): ",
		     LYP, LXP));
	    s = cached_styles[LYP][LXP];
	    if (s == 0) {
		for (x = LXP - 1; x >= 0; x--) {
		    if (cached_styles[LYP][x]) {
			if (cached_styles[LYP][x] > 0) {
			    s = cached_styles[LYP][x];
			    cached_styles[LYP][LXP] = s;
			}
			CTRACE((tfp, "found %d, x_offset=%d.\n",
				cached_styles[LYP][x], (int) x - LXP));
			break;
		    }
		}
		if (s == 0) {
		    CTRACE((tfp, "not found, assume <a>.\n"));
		    s = s_a;
		}
	    } else {
		CTRACE((tfp, "found %d.\n", s));
	    }
	} else {
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.off: can't use cache.\n"));
	    s = s_a;
	}
    } else {
	CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.on: @@(%d,%d).\n", LYP, LXP));
    }
    return s;
}
#endif /* USE_COLOR_STYLE */

/*
 * Highlight (or unhighlight) a given link.
 */
void LYhighlight(int flag,
		 int cur,
		 const char *target)
{
    char buffer[MAX_LINE];
    int i;
    int hi_count;
    int hi_offset;
    char tmp[7];
    const char *hi_string;

#ifdef SHOW_WHEREIS_TARGETS
    BOOL TargetEmphasisON = FALSE;
    BOOL target1_drawn = NO;
#endif
    BOOL utf_flag = (BOOL) (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8);
    BOOL hl1_drawn = NO;

#ifdef USE_COLOR_STYLE
    BOOL hl2_drawn = FALSE;	/* whether links[cur].l_hightext2 is already drawn

				   properly */
#endif
    tmp[0] = tmp[1] = tmp[2] = '\0';

    /*
     * Bugs in the history code might cause -1 to be sent for cur, which yields
     * a crash when LYstrncpy() is called with a nonsense pointer.  As far as I
     * know, such bugs have been squashed, but if they should reappear, this
     * works around them.  -FM
     */
    if (cur < 0)
	cur = 0;
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
    if (flag == OFF)
	textinput_redrawn = FALSE;
#endif

    if (nlinks > 0) {
#ifdef USE_COLOR_STYLE
	if (flag == ON || links[cur].type == WWW_FORM_LINK_TYPE) {
	    LYmove(LYP, LXP);
	    LynxChangeStyle(find_cached_style(cur, flag), STACK_ON);
	}
#else
	if (links[cur].type == WWW_FORM_LINK_TYPE
	    || LYGetHiliteStr(cur, 0) == NULL) {
	    LYMoveToLink(cur, target, NULL,
			 flag, links[cur].inUnderline, utf_flag);
	    lynx_start_link_color(flag == ON, links[cur].inUnderline);
	} else {
	    LYMoveToLink(cur, target, LYGetHiliteStr(cur, 0),
			 flag, links[cur].inUnderline, utf_flag);
	    hl1_drawn = YES;
#ifdef SHOW_WHEREIS_TARGETS
	    target1_drawn = YES;
#endif
	}
#endif

	if (links[cur].type == WWW_FORM_LINK_TYPE) {
	    int len;
	    int avail_space = (LYcolLimit - links[cur].lx);
	    const char *text = LYGetHiliteStr(cur, 0);

	    if (avail_space > links[cur].l_form->size)
		avail_space = links[cur].l_form->size;
	    if (avail_space > (int) sizeof(buffer) - 1)
		avail_space = (int) sizeof(buffer) - 1;

	    LYstrncpy(buffer, NonNull(text), avail_space);
	    LYaddstr(buffer);

	    len = strlen(buffer);
	    for (; len < links[cur].l_form->size && len < avail_space; len++)
		LYaddch('_');

#ifdef USE_COLOR_STYLE
	} else if (flag == OFF) {
	    hl2_drawn = TRUE;
	    redraw_lines_of_link(cur);
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.off: NOFIX branch @@(%d,%d).\n",
		     LYP, LXP));
#endif
	} else if (!hl1_drawn) {
	    /*
	     * Copy into the buffer only what will fit within the width of the
	     * screen.
	     */
	    LYmbcsstrncpy(buffer,
			  NonNull(LYGetHiliteStr(cur, 0)),
			  (sizeof(buffer) - 1),
			  (LYcolLimit - links[cur].lx),
			  utf_flag);
	    LYaddstr(buffer);
	}

	/*
	 * Display a second line as well.
	 */
#ifdef USE_COLOR_STYLE
	if (hl2_drawn == FALSE)
#endif
	{
	    for (hi_count = 1;
		 (hi_string = LYGetHiliteStr(cur, hi_count)) != NULL
		 && links[cur].ly + hi_count <= display_lines;
		 ++hi_count) {

		hi_offset = LYGetHilitePos(cur, hi_count);
		lynx_stop_link_color(flag == ON, links[cur].inUnderline);
		LYmove(links[cur].ly + hi_count, hi_offset);

#ifdef USE_COLOR_STYLE
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.highlight.line2: @@(%d,%d), style=%d.\n",
			 links[cur].ly + hi_count, hi_offset,
			 flag == ON ? s_alink : s_a));
		LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_ON);
#else
		lynx_start_link_color(flag == ON, links[cur].inUnderline);
#endif

		for (i = 0; (tmp[0] = hi_string[i]) != '\0'
		     && (i + hi_offset) < LYcols; i++) {
		    if (!IsSpecialAttrChar(hi_string[i])) {
			/*
			 * For CJK strings, by Masanobu Kimura.
			 */
			if (HTCJK != NOCJK && is8bits(tmp[0])) {
			    tmp[1] = hi_string[++i];
			    LYaddstr(tmp);
			    tmp[1] = '\0';
			} else {
			    LYaddstr(tmp);
			}
		    }
		}
	    }
	    lynx_stop_link_color(flag == ON, links[cur].inUnderline);
	}
#ifdef SHOW_WHEREIS_TARGETS
	for (hi_count = target1_drawn ? 1 : 0;
	     LYGetHiliteStr(cur, hi_count) != NULL;
	     hi_count++) {
	    TargetEmphasisON = show_whereis_targets(flag,
						    cur,
						    hi_count,
						    target,
						    TargetEmphasisON,
						    utf_flag);
	}

	if (!LYShowCursor)
	    /*
	     * Get cursor out of the way.
	     */
	    LYHideCursor();
	else
#endif /* SHOW_WHEREIS_TARGETS */
	    /*
	     * Never hide the cursor if there's no FANCY CURSES or SLANG.
	     */
	    LYmove(links[cur].ly,
		   ((links[cur].lx > 0) ? (links[cur].lx - 1) : 0));

	if (flag)
	    LYrefresh();
    }
    return;
}

/*
 * free_and_clear will free a pointer if it is non-zero and then set it to
 * zero.
 */
void free_and_clear(char **pointer)
{
    if (*pointer) {
	FREE(*pointer);
	*pointer = 0;
    }
    return;
}

/*
 * Convert single or serial newlines to single spaces throughout a string
 * (ignore newlines if the preceding character is a space) and convert tabs to
 * single spaces.  Don't ignore any explicit tabs or spaces if the condense
 * argument is FALSE, otherwise, condense any serial spaces or tabs to one
 * space.  - FM
 */
void convert_to_spaces(char *string,
		       BOOL condense)
{
    char *s = string;
    char *ns;
    BOOL last_is_space = FALSE;

    if (!s)
	return;

    for (; (*s && !isspace(*s)); s++) ;
    ns = s;

    while (*s) {
	switch (*s) {
	case ' ':
	case '\t':
	    if (!(condense && last_is_space))
		*(ns++) = ' ';
	    last_is_space = TRUE;
	    break;

	case '\r':
	case '\n':
	    if (!last_is_space) {
		*(ns++) = ' ';
		last_is_space = TRUE;
	    }
	    break;

	default:
	    *(ns++) = *s;
	    last_is_space = FALSE;
	    break;
	}
	s++;
    }
    *ns = '\0';
    return;
}

/*
 * Strip trailing slashes from directory paths.
 */
char *strip_trailing_slash(char *dirname)
{
    int i;

    i = strlen(dirname) - 1;
    while (i >= 0 && dirname[i] == '/')
	dirname[i--] = '\0';
    return (dirname);
}

/*
 * Display (or hide) the status line.
 */
BOOLEAN mustshow = FALSE;

void statusline(const char *text)
{
    char buffer[MAX_LINE];
    unsigned char *temp = NULL;
    int max_length, len, i, j;
    unsigned char k;
    char *p;
    char text_buff[MAX_LINE];

    if (text == NULL)
	return;

    /*
     * Don't print statusline messages if dumping to stdout.
     */
    if (dump_output_immediately)
	return;

    /*
     * Don't print statusline message if turned off.
     */
    if (mustshow != TRUE) {
	if (no_statusline == TRUE) {
	    return;
	}
    }
    mustshow = FALSE;

    /* "LYNXDOWNLOAD://Method=-1/File=%s/SugFile=%s%s\">Save to disk</a>\n" */
    LYstrncpy(text_buff, text, sizeof(text_buff) - 1);
    p = strchr(text_buff, '\n');
    if (p)
	p = '\0';

    /*
     * Deal with any CJK escape sequences and Kanji if we have a CJK character
     * set selected, otherwise, strip any escapes.  Also, make sure text is not
     * longer than the statusline window.  - FM
     */
    max_length = (((LYcolLimit - 1) < (int) sizeof(buffer))
		  ? (LYcolLimit - 1)
		  : (int) sizeof(buffer) - 1);
    if ((text_buff[0] != '\0') &&
	(LYHaveCJKCharacterSet)) {
	/*
	 * Translate or filter any escape sequences.  - FM
	 */
	if ((temp = typecallocn(unsigned char, strlen(text_buff) + 1)) == NULL)
	      outofmem(__FILE__, "statusline");

	if (kanji_code == EUC) {
	    TO_EUC((const unsigned char *) text_buff, temp);
	} else if (kanji_code == SJIS) {
#ifdef KANJI_CODE_OVERRIDE
	    if (!LYRawMode || last_kcode == SJIS)
		strcpy(temp, text_buff);
	    else
		TO_SJIS((const unsigned char *) text_buff, temp);
#else
	    strcpy((char *) temp, text_buff);
#endif
	} else {
	    for (i = 0, j = 0; text_buff[i]; i++) {
		if (text_buff[i] != CH_ESC) {	/* S/390 -- gil -- 2119 */
		    temp[j++] = text_buff[i];
		}
	    }
	    temp[j] = '\0';
	}

	/*
	 * Deal with any newlines or tabs in the string.  - FM
	 */
	LYReduceBlanks((char *) temp);

	/*
	 * Handle the Kanji, making sure the text is not longer than the
	 * statusline window.  - FM
	 */
	for (i = 0, j = 0, len = 0, k = '\0';
	     temp[i] != '\0' && len < max_length; i++) {
	    if (k != '\0') {
		buffer[j++] = k;
		buffer[j++] = temp[i];
		k = '\0';
		len += 2;
	    } else if ((temp[i] & 0200) != 0) {
		k = temp[i];
	    } else {
		buffer[j++] = temp[i];
		len++;
	    }
	}
	buffer[j] = '\0';
	FREE(temp);
    } else {
	/*
	 * Strip any escapes, and shorten text if necessary.  Note that we
	 * don't deal with the possibility of UTF-8 characters in the string. 
	 * This is unlikely, but if strings with such characters are used in
	 * LYMessages_en.h, a compilation symbol of HAVE_UTF8_STATUSLINES could
	 * be added there, and code added here for determining the displayed
	 * string length, as we do above for CJK.  - FM
	 */
	for (i = 0, len = 0; text_buff[i] != '\0' && len < max_length; i++) {
	    if (text_buff[i] != CH_ESC) {	/* S/390 -- gil -- 2119 */
		buffer[len++] = text_buff[i];
	    }
	}
	buffer[len] = '\0';
	/*
	 * Deal with any newlines or tabs in the string.  - FM
	 */
	LYReduceBlanks(buffer);
    }

    /*
     * Move to the desired statusline window and output the text highlighted. 
     * - FM
     */
    if (LYStatusLine >= 0) {
	if (LYStatusLine < LYlines - 1) {
	    LYmove(LYStatusLine, 0);
	} else {
	    LYmove(LYlines - 1, 0);
	}
    } else if (user_mode == NOVICE_MODE) {
	LYmove(LYlines - 3, 0);
    } else {
	LYmove(LYlines - 1, 0);
    }
    LYclrtoeol();

    if (text != NULL && text[0] != '\0') {
	BOOLEAN has_CJK = FALSE;

	if (HTCJK != NOCJK) {
	    for (i = 0; buffer[i] != '\0'; i++) {
		if (buffer[i] & 0x80) {
		    has_CJK = TRUE;
		    break;
		}
	    }
	}

	if (has_CJK
#ifdef HAVE_UTF8_STATUSLINES
	    || (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8)
#endif
	    ) {
	    LYrefresh();
	}
#ifndef USE_COLOR_STYLE
	lynx_start_status_color();
	LYaddstr(buffer);
	lynx_stop_status_color();
#else
	/* draw the status bar in the STATUS style */
	{
	    int a = (strncmp(buffer, ALERT_FORMAT, ALERT_PREFIX_LEN)
		     || !hashStyles[s_alert].name)
	    ? s_status
	    : s_alert;

	    LynxChangeStyle(a, STACK_ON);
	    LYaddstr(buffer);
	    wbkgdset(LYwin,
		     ((lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
		      ? hashStyles[a].color
		      : A_NORMAL) | ' ');
	    LYclrtoeol();
	    if (!(lynx_has_color && LYShowColor >= SHOW_COLOR_ON))
		wbkgdset(LYwin, A_NORMAL | ' ');
	    else if (s_normal != NOSTYLE)
		wbkgdset(LYwin, hashStyles[s_normal].color | ' ');
	    else
		wbkgdset(LYwin, displayStyles[DSTYLE_NORMAL].color | ' ');
	    LynxChangeStyle(a, STACK_OFF);
	}
#endif
    }
    LYrefresh();

    return;
}

static const char *novice_lines(int lineno)
{
    switch (lineno) {
    case 0:
	return NOVICE_LINE_TWO_A;
    case 1:
	return NOVICE_LINE_TWO_B;
    case 2:
	return NOVICE_LINE_TWO_C;
    default:
	return "";
    }
}

static int lineno = 0;

void toggle_novice_line(void)
{
    lineno++;
    if (*novice_lines(lineno) == '\0')
	lineno = 0;
    return;
}

void noviceline(int more_flag GCC_UNUSED)
{
    if (dump_output_immediately)
	return;

    LYmove(LYlines - 2, 0);
    /* lynx_stop_reverse(); */
    LYclrtoeol();
    LYaddstr(NOVICE_LINE_ONE);
    LYclrtoeol();
#if defined(DIRED_SUPPORT ) && defined(OK_OVERRIDE)
    if (lynx_edit_mode && !no_dired_support)
	LYaddstr(DIRED_NOVICELINE);
    else
#endif /* DIRED_SUPPORT && OK_OVERRIDE */

    if (LYUseNoviceLineTwo)
	LYaddstr(NOVICE_LINE_TWO);
    else
	LYaddstr(novice_lines(lineno));

    LYrefresh();
    return;
}

#if defined(NSL_FORK) || defined(MISC_EXP)
/*
 * Returns the file descriptor from which keyboard input is expected, or INVSOC
 * (-1) if not available.  If need_selectable is true, returns non-INVSOC fd
 * only if select() is possible - actually, currently only checks if fd is
 * connected to a tty.  - kw
 */
int LYConsoleInputFD(BOOLEAN need_selectable)
{
    int fd = INVSOC;

#ifdef USE_SLANG
    if (!LYCursesON)
	fd = fileno(stdin);
#if ((SLANG_VERSION >= 9919) && defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__))
    /* SLang_TT_Read_FD introduced in slang 0.99.19, from its changelog: 
     * SLang_TT_Read_FD variable is now available for unix.  This is the file
     * descriptor used by SLang_getkey.  */
    else
	fd = SLang_TT_Read_FD;
#endif /* SLANG_VERSION >= 9919 */
#else /* !USE_SLANG */
    fd = fileno(stdin);
#endif /* !USE_SLANG */

    if (need_selectable && fd != INVSOC) {
	if (isatty(fd)) {
	    return fd;
	} else {
	    return INVSOC;
	}
    }
    return fd;
}
#endif /* NSL_FORK || MISC_EXP */

static int fake_zap = 0;

void LYFakeZap(BOOL set)
{
    if (set && fake_zap < 1) {
	CTRACE((tfp, "\r *** Set simulated 'Z'"));
	if (fake_zap)
	    CTRACE((tfp, ", %d pending", fake_zap));
	CTRACE((tfp, " ***\n"));
	fake_zap++;
    } else if (!set && fake_zap) {
	CTRACE((tfp, "\r *** Unset simulated 'Z'"));
	CTRACE((tfp, ", %d pending", fake_zap));
	CTRACE((tfp, " ***\n"));
	fake_zap = 0;
    }

}

static int DontCheck(void)
{
    static long last;
    long next;

    /** Curses or slang setup was not invoked **/
    if (dump_output_immediately)
	return (TRUE);

    if (LYHaveCmdScript())	/* we may be running from a script */
	return (TRUE);

#ifdef MISC_EXP
    if (LYNoZapKey)
	return (TRUE);
#endif
    /*
     * Avoid checking interrupts more than one per second, since it is a slow
     * and expensive operation - TD
     */
#ifdef HAVE_GETTIMEOFDAY
#undef timezone			/* U/Win defines a conflicting macro */
    {
	struct timeval tv;

	gettimeofday(&tv, (struct timezone *) 0);
	next = tv.tv_usec / 100000L;	/* 0.1 seconds is a compromise */
    }
#else
    next = time((time_t *) 0);
#endif
    if (next == last)
	return (TRUE);

    last = next;
    return FALSE;
}

int HTCheckForInterrupt(void)
{
    int c;
    int cmd;

#ifndef VMS			/* UNIX stuff: */
#if !defined(USE_SLANG)
    struct timeval socket_timeout;
    int ret = 0;
    fd_set readfds;
#endif /* !USE_SLANG */

    if (fake_zap > 0) {
	fake_zap--;
	CTRACE((tfp, "\r *** Got simulated 'Z' ***\n"));
	CTRACE_FLUSH(tfp);
	CTRACE_SLEEP(AlertSecs);
	return ((int) TRUE);
    }

    /** Curses or slang setup was not invoked **/
    if (DontCheck())
	return ((int) FALSE);

#if !defined(_WINDOWS) || defined(__MINGW32__)
#ifdef USE_SLANG
    /** No keystroke was entered
	Note that this isn't taking possible SOCKSification
	and the socks_flag into account, and may fail on the
	slang library's select() when SOCKSified. - FM **/
#ifdef DJGPP_KEYHANDLER
    if (0 == _bios_keybrd(_NKEYBRD_READY))
#else
    if (0 == SLang_input_pending(0))
#endif /* DJGPP_KEYHANDLER */
	return (FALSE);

#else /* Unix curses: */

    socket_timeout.tv_sec = 0;
    socket_timeout.tv_usec = 0;
    FD_ZERO(&readfds);
    FD_SET(0, &readfds);
#ifdef SOCKS
    if (socks_flag)
	ret = Rselect(1, &readfds, NULL, NULL, &socket_timeout);
    else
#endif /* SOCKS */
	ret = select(1, &readfds, NULL, NULL, &socket_timeout);

    /** Suspended? **/
    if ((ret == -1) && (SOCKET_ERRNO == EINTR))
	return ((int) FALSE);

    /** No keystroke was entered? **/
    if (!FD_ISSET(0, &readfds))
	return ((int) FALSE);
#endif /* USE_SLANG */
#endif /* !_WINDOWS */

#if defined(PDCURSES)
    nodelay(LYwin, TRUE);
#endif /* PDCURSES */
    /*
     * 'c' contains whatever character we're able to read from keyboard
     */
    c = LYgetch();
#if defined(PDCURSES)
    nodelay(LYwin, FALSE);
#endif /* PDCURSES */

#else /* VMS: */
    extern int typeahead(void);

    if (fake_zap > 0) {
	fake_zap--;
	CTRACE((tfp, "\r *** Got simulated 'Z' ***\n"));
	CTRACE_FLUSH(tfp);
	CTRACE_SLEEP(AlertSecs);
	return ((int) TRUE);
    }

    /** Curses or slang setup was not invoked **/
    if (DontCheck())
	return ((int) FALSE);

    /** Control-C or Control-Y and a 'N'o reply to exit query **/
    if (HadVMSInterrupt) {
	HadVMSInterrupt = FALSE;
	return ((int) TRUE);
    }

    /*
     * 'c' contains whatever character we're able to read from keyboard
     */
    c = typeahead();

#endif /* !VMS */

    /*
     * 'c' contains whatever character we're able to read from keyboard
     */

	/** Keyboard 'Z' or 'z', or Control-G or Control-C **/
    if (LYCharIsINTERRUPT(c))
	return ((int) TRUE);

    /* There is a subset of mainloop() actions available at this stage:  no new
     * getfile() cycle is possible until the previous finished.  Currently we
     * have scrolling in partial mode, toggling of trace log, and pasting. 
     * User search now in progress...
     */
    cmd = (LKC_TO_LAC(keymap, c));
    switch (cmd) {
    case LYK_TRACE_TOGGLE:	/*  Toggle TRACE mode. */
	handle_LYK_TRACE_TOGGLE();
	break;
#ifdef CAN_CUT_AND_PASTE
    case LYK_TO_CLIPBOARD:{	/* ^S */
	    const char *s = LYDownLoadAddress();

	    if (!s || !*s || put_clip(s))
		HTInfoMsg(gettext("Copy to clipboard failed."));
	    else
		HTInfoMsg(gettext("Download document URL put to clipboard."));
	    break;
	}
#endif /* defined CAN_CUT_AND_PASTE */
    default:
#ifdef DISP_PARTIAL
	/* OK, we got several lines from new document and want to scroll... */
	if (display_partial && (NumOfLines_partial > 2)) {
	    BOOLEAN do_refresh;
	    int res;
	    int Newline_partial = LYGetNewline();

	    switch (cmd) {
	    case LYK_WHEREIS:	/* search within the document */
	    case LYK_NEXT:	/* search for the next occurrence in the document */
	    case LYK_PREV:	/* search for the previous occurrence in the document */
		handle_LYK_WHEREIS(cmd, &do_refresh);
		if (www_search_result != -1) {
		    Newline_partial = www_search_result;
		    www_search_result = -1;	/* reset */
		}
		break;

	    case LYK_FASTBACKW_LINK:
		if (Newline_partial <= (display_lines) + 1) {
		    Newline_partial -= display_lines;
		} else if ((res =
			    HTGetLinkOrFieldStart(-1,
						  &Newline_partial, NULL,
						  -1, TRUE)) == LINK_LINE_FOUND) {
		    Newline_partial++;
		} else if (res == LINK_DO_ARROWUP) {
		    Newline_partial -= display_lines;
		}
		break;
	    case LYK_FASTFORW_LINK:
		if (HText_canScrollDown()) {
		    /* This is not an exact science... - kw */
		    if ((res =
			 HTGetLinkOrFieldStart(HText_LinksInLines(HTMainText,
								  Newline_partial,
								  display_lines)
					       - 1,
					       &Newline_partial, NULL,
					       1, TRUE)) == LINK_LINE_FOUND) {
			Newline_partial++;
		    }
		}
		break;
	    case LYK_PREV_PAGE:
		if (Newline_partial > 1)
		    Newline_partial -= display_lines;
		break;
	    case LYK_NEXT_PAGE:
		if (HText_canScrollDown())
		    Newline_partial += display_lines;
		break;
	    case LYK_UP_HALF:
		if (Newline_partial > 1)
		    Newline_partial -= (display_lines / 2);
		break;
	    case LYK_DOWN_HALF:
		if (HText_canScrollDown())
		    Newline_partial += (display_lines / 2);
		break;
	    case LYK_UP_TWO:
		if (Newline_partial > 1)
		    Newline_partial -= 2;
		break;
	    case LYK_DOWN_TWO:
		if (HText_canScrollDown())
		    Newline_partial += 2;
		break;
	    case LYK_HOME:
		if (Newline_partial > 1)
		    Newline_partial = 1;
		break;
	    case LYK_END:
		if (HText_canScrollDown())
		    Newline_partial = HText_getNumOfLines() - display_lines + 1;
		/* calculate for "current" bottom value */
		break;
	    case LYK_REFRESH:
		break;
	    default:
		/** Other or no keystrokes **/
		return ((int) FALSE);
	    }			/* end switch */
	    if (Newline_partial < 1)
		Newline_partial = 1;
	    if (LYMainLoop_pageDisplay(Newline_partial))
		NumOfLines_partial = HText_getNumOfLines();
	}
#endif /* DISP_PARTIAL */
	break;
    }				/* end switch */
    /** Other or no keystrokes **/
    return ((int) FALSE);
}

/*
 * Check if the given filename looks like it's an absolute pathname, i.e.,
 * references a directory.
 */
BOOLEAN LYisAbsPath(const char *path)
{
    BOOLEAN result = FALSE;

    if (non_empty(path)) {
#ifdef VMS
	result = TRUE;
#else
#if defined(USE_DOS_DRIVES)
	result = (BOOL) (LYIsPathSep(path[0])
			 || (LYIsDosDrive(path)
			     && LYIsPathSep(path[2])));
#else
	result = (LYIsPathSep(path[0]));
#endif /* USE_DOS_DRIVES */
#endif
    }
    return result;
}

/*
 * Check if the given filename is the root path, e.g., "/" on Unix.
 */
BOOLEAN LYisRootPath(const char *path)
{
#if defined(USE_DOS_DRIVES)
    if (strlen(path) == 3
	&& LYIsDosDrive(path)
	&& LYIsPathSep(path[2]))
	return TRUE;
#endif
    return (BOOL) ((strlen(path) == 1) && LYIsPathSep(path[0]));
}

/*
 * A file URL for a remote host is an obsolete ftp URL.
 * Return YES only if we're certain it's a local file.  - FM
 */
BOOLEAN LYisLocalFile(const char *filename)
{
    char *host = NULL;
    char *acc_method = NULL;
    char *cp;

    if (!filename)
	return NO;
    if (!(host = HTParse(filename, "", PARSE_HOST)))
	return NO;
    if (!*host) {
	FREE(host);
	return NO;
    }

    if ((cp = strchr(host, ':')) != NULL)
	*cp = '\0';

    if ((acc_method = HTParse(filename, "", PARSE_ACCESS))) {
	if (0 == strcmp("file", acc_method) &&
	    (0 == strcmp(host, "localhost") ||
	     LYSameFilename(host, HTHostName()))) {
	    FREE(host);
	    FREE(acc_method);
	    return YES;
	}
    }

    FREE(host);
    FREE(acc_method);
    return NO;
}

/*
 * Utility for checking URLs with a host field.  Return YES only if we're
 * certain it's the local host.  - FM
 */
BOOLEAN LYisLocalHost(const char *filename)
{
    char *host = NULL;
    char *cp;

    if (!filename)
	return NO;
    if (!(host = HTParse(filename, "", PARSE_HOST)))
	return NO;
    if (!*host) {
	FREE(host);
	return NO;
    }

    if ((cp = strchr(host, ':')) != NULL)
	*cp = '\0';

    if ((LYSameFilename(host, "localhost") ||
	 LYSameFilename(host, LYHostName) ||
	 LYSameFilename(host, HTHostName()))) {
	FREE(host);
	return YES;
    }

    FREE(host);
    return NO;
}

/*
 * Free an HTList that contains strings.
 */
void LYFreeStringList(HTList *list)
{
    if (list != NULL) {
	char *argument;
	HTList *cur = list;

	while (NULL != (argument = (char *) HTList_nextObject(cur))) {
	    FREE(argument);
	}
	HTList_delete(list);
    }
}

/*
 * Utility for freeing the list of local host aliases.  - FM
 */
void LYLocalhostAliases_free(void)
{
    LYFreeStringList(localhost_aliases);
    localhost_aliases = NULL;
}

/*
 * Utility for listing hosts to be treated as local aliases.  - FM
 */
void LYAddLocalhostAlias(char *alias)
{
    char *LocalAlias = NULL;

    if (!non_empty(alias))
	return;

    if (!localhost_aliases) {
	localhost_aliases = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(LYLocalhostAliases_free);
#endif
    }

    StrAllocCopy(LocalAlias, alias);
    HTList_addObject(localhost_aliases, LocalAlias);

    return;
}

/*
 * Utility for checking URLs with a host field.  Return YES only if we've
 * listed the host as a local alias.  - FM
 */
BOOLEAN LYisLocalAlias(const char *filename)
{
    char *host = NULL;
    char *alias;
    char *cp;
    HTList *cur = localhost_aliases;

    if (!cur || !filename)
	return NO;
    if (!(host = HTParse(filename, "", PARSE_HOST)))
	return NO;
    if (!(*host)) {
	FREE(host);
	return NO;
    }

    if ((cp = strchr(host, ':')) != NULL)
	*cp = '\0';

    while (NULL != (alias = (char *) HTList_nextObject(cur))) {
	if (LYSameFilename(host, alias)) {
	    FREE(host);
	    return YES;
	}
    }

    FREE(host);
    return NO;
}

/*
 *  This function checks for a URL with an unknown scheme,
 *  but for which proxying has been set up, and if so,
 *  returns PROXY_URL_TYPE. - FM
 *
 *  If a colon is present but the string segment which
 *  precedes it is not being proxied, and we can be sure
 *  that what follows the colon is not a port field,
 *  it returns UNKNOWN_URL_TYPE.  Otherwise, it returns
 *  0 (not a URL). - FM
 */
UrlTypes LYCheckForProxyURL(char *filename)
{
    char *cp = filename;
    char *cp1;
    char *cp2 = NULL;

    /*
     * Don't crash on an empty argument.
     */
    if (isEmpty(cp))
	return (NOT_A_URL_TYPE);

    /* kill beginning spaces */
    cp = LYSkipBlanks(cp);

    /*
     * Check for a colon, and if present,
     * see if we have proxying set up.
     */
    if ((cp1 = strchr((cp + 1), ':')) != NULL) {
	if ((cp2 = strchr((cp + 1), '/')) != NULL && cp2 < cp1)
	    return (NOT_A_URL_TYPE);
	*cp1 = '\0';
	cp2 = NULL;
	StrAllocCopy(cp2, cp);
	*cp1 = ':';
	StrAllocCat(cp2, "_proxy");
	if (LYGetEnv(cp2) != NULL) {
	    FREE(cp2);
	    return (PROXY_URL_TYPE);
	}
	FREE(cp2);
#if defined (USE_DOS_DRIVES)
	if (LYIsDosDrive(cp))
	    return (NOT_A_URL_TYPE);
#endif
	cp1++;
	if (!*cp) {
	    return (NOT_A_URL_TYPE);
	} else if (isdigit(UCH(*cp1))) {
	    while (*cp1 && isdigit(UCH(*cp1)))
		cp1++;
	    if (*cp1 && !LYIsHtmlSep(*cp1))
		return (UNKNOWN_URL_TYPE);
	} else {
	    return (UNKNOWN_URL_TYPE);
	}
    }

    return (NOT_A_URL_TYPE);
}

/*
 * Compare a "type:" string, replacing it by the comparison-string if it
 * matches (and return true in that case).
 */
static BOOLEAN compare_type(char *tst,
			    const char *cmp,
			    size_t len)
{
    if (!strncasecomp(tst, cmp, len)) {
	if (strncmp(tst, cmp, len)) {
	    size_t i;

	    for (i = 0; i < len; i++)
		tst[i] = cmp[i];
	}
	return TRUE;
    }
    return FALSE;
}

#define DoubleHtmlSep(s) (LYIsHtmlSep((s)[0]) && LYIsHtmlSep((s)[1]))
#define compare_two(tst,cmp,len,limit) \
	((len + 2) <= limit \
	&& DoubleHtmlSep(tst + len) \
	&& compare_type(tst, cmp, len))

/*
 *  Must recognize a URL and return the type.
 *  If recognized, based on a case-insensitive
 *  analysis of the scheme field, ensures that
 *  the scheme field has the expected case.
 *
 *  Returns 0 (not a URL) for a NULL argument,
 *  one which lacks a colon.
 *
 *  Chains to LYCheckForProxyURL() if a colon
 *  is present but the type is not recognized.
 */
UrlTypes is_url(char *filename)
{
    char *cp = filename;
    char *cp1;
    UrlTypes result = NOT_A_URL_TYPE;
    int len;
    int limit;

    /*
     * Don't crash on an empty argument.
     */
    if (isEmpty(cp))
	return (result);

    /*
     * Can't be a URL if it lacks a colon.
     */
    if (NULL == strchr(cp, ':'))
	return (result);

    /*
     * Kill beginning spaces.
     */
    cp = LYSkipBlanks(cp);

    /*
     * Can't be a URL if it starts with a slash.  So return immediately for
     * this common case, also to avoid false positives if there was a colon
     * later in the string.  Also can't be a URL if it starts with a colon.  -
     * KW
     */
    if (*cp == ':' || LYIsHtmlSep(*cp)) {
	result = NOT_A_URL_TYPE;

    } else {
	limit = strlen(cp);
	switch (*cp) {
	case 'L':
	case 'l':
	    /*
	     * Lynx internal pages ("LYNXfoo:" or "lynxfoo:") start with 'l' or
	     * 'L', other URLs aren't.
	     */
	    if (compare_type(cp, STR_LYNXEXEC, LEN_LYNXEXEC)) {
		/*
		 * Special External Lynx type to handle execution of commands
		 * or scripts which require a pause to read the screen upon
		 * completion.
		 */
		result = LYNXEXEC_URL_TYPE;

	    } else if (compare_type(cp, STR_LYNXPROG, LEN_LYNXPROG)) {
		/*
		 * Special External Lynx type to handle execution of commands,
		 * scripts or programs with do not require a pause to read
		 * screen upon completion.
		 */
		result = LYNXPROG_URL_TYPE;

	    } else if (compare_type(cp, STR_LYNXCGI, LEN_LYNXCGI)) {
		/*
		 * Special External Lynx type to handle cgi scripts.
		 */
		result = LYNXCGI_URL_TYPE;

	    } else if (compare_type(cp, STR_LYNXPRINT, LEN_LYNXPRINT)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXPRINT_URL_TYPE;

	    } else if (compare_type(cp, STR_LYNXOPTIONS, LEN_LYNXOPTIONS)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXOPTIONS_URL_TYPE;

	    } else if (compare_type(cp, STR_LYNXCFG, LEN_LYNXCFG)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXCFG_URL_TYPE;

	    } else if (compare_type(cp, STR_LYNXMESSAGES, LEN_LYNXMESSAGES)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXMESSAGES_URL_TYPE;

	    } else if (compare_type(cp, STR_LYNXCFLAGS, LEN_LYNXCFLAGS)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXCOMPILE_OPTS_URL_TYPE;

	    } else if (compare_type(cp, STR_LYNXDOWNLOAD, LEN_LYNXDOWNLOAD)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXDOWNLOAD_URL_TYPE;

	    } else if (compare_type(cp, STR_LYNXDIRED, LEN_LYNXDIRED)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXDIRED_URL_TYPE;

	    } else if (compare_type(cp, STR_LYNXHIST, LEN_LYNXHIST)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXHIST_URL_TYPE;

	    } else if (compare_type(cp, STR_LYNXKEYMAP, LEN_LYNXKEYMAP)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXKEYMAP_URL_TYPE;

	    } else if (compare_type(cp, STR_LYNXIMGMAP, LEN_LYNXIMGMAP)) {
		/*
		 * Special Internal Lynx type.
		 */
		/* force lower/uppercase of next part */
		(void) is_url(&cp[LEN_LYNXIMGMAP]);
		result = LYNXIMGMAP_URL_TYPE;

	    } else if (compare_type(cp, STR_LYNXCOOKIE, LEN_LYNXCOOKIE)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXCOOKIE_URL_TYPE;
	    }
	    break;
#ifndef DISABLE_NEWS
	    /*
	     * NEWSfoo:  schemes -
	     */
	case 'N':
	case 'n':
	    if (compare_type(cp, STR_NEWS_URL, LEN_NEWS_URL)) {
		result = NEWS_URL_TYPE;

	    } else if (compare_type(cp, STR_NNTP_URL, LEN_NNTP_URL)) {
		result = NNTP_URL_TYPE;

	    } else if (compare_type(cp, "newspost:", 9)) {
		/*
		 * Special Lynx type to handle news posts.
		 */
		result = NEWSPOST_URL_TYPE;

	    } else if (compare_type(cp, "newsreply:", 10)) {
		/*
		 * Special Lynx type to handle news replies (followups).
		 */
		result = NEWSREPLY_URL_TYPE;
	    }
	    break;

	    /*
	     * SNEWSfoo:  schemes -
	     */
	case 'S':
	case 's':
	    if (compare_type(cp, STR_SNEWS_URL, LEN_SNEWS_URL)) {
		result = SNEWS_URL_TYPE;

	    } else if (compare_type(cp, "snewspost:", 10)) {
		/*
		 * Special Lynx type to handle snews posts.
		 */
		result = NEWSPOST_URL_TYPE;

	    } else if (compare_type(cp, "snewsreply:", 11)) {
		/*
		 * Special Lynx type to handle snews replies (followups).
		 */
		result = NEWSREPLY_URL_TYPE;
	    }
	    break;
#endif
	case 'M':
	case 'm':
	    if (compare_type(cp, STR_MAILTO_URL, LEN_MAILTO_URL)) {
		result = MAILTO_URL_TYPE;
	    }
	    break;

	case 'F':
	case 'f':
	    if (compare_type(cp, STR_FILE_URL, len = LEN_FILE_URL)) {
		if (LYisLocalFile(cp)) {
		    result = FILE_URL_TYPE;
		} else if (DoubleHtmlSep(cp + len)) {
		    result = FTP_URL_TYPE;
		}
	    }
#ifndef DISABLE_FTP
	    else if (compare_two(cp, STR_FTP_URL, LEN_FTP_URL, limit)) {
		result = FTP_URL_TYPE;
	    }
#endif
#ifndef DISABLE_FINGER
	    else if (compare_two(cp, STR_FINGER_URL, LEN_FINGER_URL, limit)) {
		result = FINGER_URL_TYPE;
	    }
#endif
	    break;

	case 'B':
	case 'b':
#ifndef DISABLE_BIBP
	    if (compare_type(cp, STR_BIBP_URL, LEN_BIBP_URL)) {
		result = BIBP_URL_TYPE;
	    }
#endif
	    break;

	case 'D':
	case 'd':
	    if (compare_type(cp, "data:", 5)) {
		result = DATA_URL_TYPE;
	    }
	    break;

	default:
	    if (limit >= 3
		&& ((cp1 = strchr(cp + 3, ':')) == NULL
		    || !DoubleHtmlSep(cp1 + 1))) {
		/*
		 * If it doesn't contain "://", and it's not one of the the
		 * above, it can't be a URL with a scheme we know, so check if
		 * it's an unknown scheme for which proxying has been set up.
		 * - FM
		 */
		if (cp1 != NULL
		    && (cp1 - cp) > 1	/* exclude DOS-style device:/path */
		    && LYisAbsPath(cp1 + 1)) {
		    result = NCFTP_URL_TYPE;
		}

	    } else {
		switch (*cp) {
		case 'H':
		case 'h':
		    if (compare_type(cp, STR_HTTP_URL, LEN_HTTP_URL)) {
			result = HTTP_URL_TYPE;

		    } else if (compare_type(cp, STR_HTTPS_URL, LEN_HTTPS_URL)) {
			result = HTTPS_URL_TYPE;
		    }
		    break;

#ifndef DISABLE_GOPHER
		case 'G':
		case 'g':
		    if (compare_type(cp, STR_GOPHER_URL, LEN_GOPHER_URL)) {
			if (strlen(cp) >= 11
			    && (cp1 = strchr(cp + 11, '/')) != NULL) {

			    if (TOUPPER(*(cp1 + 1)) == 'H' || *(cp1 + 1) == 'w')
				/* if this is a gopher html type */
				result = HTML_GOPHER_URL_TYPE;
			    else if (*(cp1 + 1) == 'T' || *(cp1 + 1) == '8')
				result = TELNET_GOPHER_URL_TYPE;
			    else if (*(cp1 + 1) == '7')
				result = INDEX_GOPHER_URL_TYPE;
			    else
				result = GOPHER_URL_TYPE;
			} else {
			    result = GOPHER_URL_TYPE;
			}
		    }
		    break;
#endif
		case 'W':
		case 'w':
		    if (compare_type(cp, STR_WAIS_URL, LEN_WAIS_URL)) {
			result = WAIS_URL_TYPE;
		    }
		    break;

		case 'T':
		case 't':
		    if (compare_type(cp, STR_TELNET_URL, LEN_TELNET_URL)) {
			result = TELNET_URL_TYPE;

		    } else if (compare_type(cp, STR_TN3270_URL, LEN_TN3270_URL)) {
			result = TN3270_URL_TYPE;
		    }
		    break;

		case 'R':
		case 'r':
		    if (compare_type(cp, STR_RLOGIN_URL, LEN_RLOGIN_URL)) {
			result = RLOGIN_URL_TYPE;
		    }
		    break;

		case 'C':
		case 'c':
		    if (compare_type(cp, STR_CSO_URL, LEN_CSO_URL)) {
			result = CSO_URL_TYPE;
		    }
		    break;

		case 'A':
		case 'a':
		    if (compare_type(cp, "afs:", 4)) {
			result = AFS_URL_TYPE;
		    }
		    break;

		case 'P':
		case 'p':
		    if (compare_type(cp, "prospero:", 9)) {
			result = PROSPERO_URL_TYPE;
		    }
		    break;
		}
	    }
	}
	/*
	 * Check if it is an unknown scheme for which proxying has been set up.
	 */
	if (result == NOT_A_URL_TYPE)
	    result = LYCheckForProxyURL(filename);
    }
    return result;
}

/*
 * Sometimes it is just expected that curses is on when an alert or other
 * statusline message needs to be shown and we are not just dumping
 * immediately.  Calling this will 'fix' it, but may not always be appropriate. 
 * - kw
 */
void LYFixCursesOn(const char *reason)
{
    if (dump_output_immediately || LYCursesON)
	return;
    if (reason) {
	CTRACE((tfp, "Forcing curses on to %s\n", reason));
    }
    start_curses();
}

/*
 * Most protocol modules called through HTLoad* expect that curses is on unless
 * dump_output_immediately is set, so that statusline messages can be shown. 
 * Some protocols expect the opposite, namely telnet and friends.  This
 * function should be called after the 'physical' URL for accessing addr has
 * been established.  It does the right thing to the degree that curses is
 * turned on for known problem cases.  In any normal circumstances this should
 * never apply, but proxying or rule substitution is not prevented for
 * telnet-like URLs, and this 'fix' avoids some crashes that can otherwise
 * occur.  - kw
 */
BOOLEAN LYFixCursesOnForAccess(const char *addr,
			       const char *physical)
{
    /*
     * If curses is off when maybe it shouldn't...
     */
    if (!dump_output_immediately && !LYCursesON && physical) {
	char *cp1;

	/*
	 * If requested resource wants to be accessed with curses off, and
	 * getfile() would indeed have turned curses off for it...
	 */
	if (strstr(addr, "://") != NULL &&
	    (isTELNET_URL(addr) ||
	     isRLOGIN_URL(addr) ||
	     isTN3270_URL(addr) ||
	     (!isGOPHER_URL(addr) &&
	      (cp1 = strchr(addr + 11, '/')) != NULL &&
	      (*(cp1 + 1) == 'T' || *(cp1 + 1) == '8')))) {
	    /*
	     * If actual access that will be done is ok with curses off, then
	     * do nothing special, else force curses on.  - kw
	     */
	    if (!isTELNET_URL(physical) &&
		!isRLOGIN_URL(physical) &&
		!isTN3270_URL(physical)) {
		start_curses();
		HTAlert(gettext("Unexpected access protocol for this URL scheme."));
		return TRUE;
	    }
	}
    }
    return FALSE;
}

/*
 * Determine whether we allow HEAD and related flags for a URL.  - kw
 */
BOOLEAN LYCanDoHEAD(const char *address)
{
    char *temp0 = NULL;
    int isurl;

    if (!non_empty(address))
	return FALSE;
    if (!strncmp(address, "http", 4))
	return TRUE;
    /* Make copy for is_url() since caller may not care for case changes */
    StrAllocCopy(temp0, address);
    isurl = is_url(temp0);
    if (!isurl) {
	FREE(temp0);
	return FALSE;
    }
    if (isurl == LYNXCGI_URL_TYPE) {
	FREE(temp0);
#if defined(LYNXCGI_LINKS) && !defined(VMS)
	return TRUE;
#else
	return FALSE;
#endif
    }
    /*
     * The idea of the following is to allow HEAD for news URLs that identify
     * single articles, not those that identify ranges of articles or groups or
     * a list of groups.  - kw
     */
    if (isurl == NEWS_URL_TYPE || isurl == NNTP_URL_TYPE) {
	char *temp = HTParse(address, "", PARSE_PATH);
	char *cp = strrchr(temp, '/');

	if (strchr((cp ? cp : temp), '@@') != NULL) {
	    FREE(temp0);
	    FREE(temp);
	    return TRUE;
	}
	if (cp && isdigit(UCH(cp[1])) && strchr(cp, '-') == NULL) {
	    FREE(temp0);
	    FREE(temp);
	    return TRUE;
	}
	FREE(temp);
    }
#define ALLOW_PROXY_HEAD
/* If defined, also allow head requests for URLs proxied through the "http" or
 * "lynxcgi" protocols, which understand HEAD.  Only the proxy environment
 * variables are checked, not the HTRules system.  - kw
 */
#ifdef ALLOW_PROXY_HEAD
    if (isurl != FILE_URL_TYPE) {
	char *acc_method = HTParse(temp0, "", PARSE_ACCESS);

	if (non_empty(acc_method)) {
	    char *proxy;

	    StrAllocCat(acc_method, "_proxy");
	    proxy = LYGetEnv(acc_method);
	    if (proxy && (isHTTP_URL(proxy) ||
			  isLYNXCGI(proxy)) &&
		!override_proxy(temp0)) {
		FREE(temp0);
		FREE(acc_method);
		return TRUE;
	    }
	}
	FREE(acc_method);
    }
#endif /* ALLOW_PROXY_HEAD */

    FREE(temp0);
    return FALSE;
}

/*
 * Close an input file.
 */
BOOLEAN LYCloseInput(FILE *fp)
{
    if (fp != 0) {
	int err = ferror(fp);

	fclose(fp);
	if (!err) {
	    return TRUE;
	}
    }
    return FALSE;
}

/*
 * Close an output file, reporting any problems with writing to it.
 */
BOOLEAN LYCloseOutput(FILE *fp)
{
    if (fp != 0) {
	int err = ferror(fp);

	fclose(fp);
	if (!err) {
	    return TRUE;
	}
    }
    HTAlert(CANNOT_WRITE_TO_FILE);
    return FALSE;
}

/*
 * Test if we'll be able to write a file.  If not, warn the user.
 */
BOOLEAN LYCanWriteFile(const char *filename)
{
    if (LYCloseOutput(fopen(filename, "w"))) {
	remove(filename);
	return TRUE;
    } else {
	_statusline(NEW_FILENAME_PROMPT);
	return FALSE;
    }
}

/*
 * Test if we'll be able to read a file.
 */
BOOLEAN LYCanReadFile(const char *filename)
{
    FILE *fp;

    if ((fp = fopen(filename, "r")) != 0) {
	return LYCloseInput(fp);
    }
    return FALSE;
}

/*
 * Remove backslashes from any string.
 */
void remove_backslashes(char *buf)
{
    char *cp;

    for (cp = buf; *cp != '\0'; cp++) {

	if (*cp != '\\') {	/* don't print slashes */
	    *buf = *cp;
	    buf++;
	} else if (*cp == '\\' &&	/* print one slash if there */
		   *(cp + 1) == '\\') {		/* are two in a row         */
	    *buf = *cp;
	    buf++;
	}
    }
    *buf = '\0';
    return;
}

/*
 * Checks to see if the current process is attached via a terminal in the local
 * domain.
 */
BOOLEAN inlocaldomain(void)
{
#ifdef HAVE_UTMP
    int n;
    FILE *fp;
    struct utmp me;
    char *cp, *mytty = NULL;

    if ((cp = ttyname(0)))
	mytty = strrchr(cp, '/');

    if (mytty && (fp = fopen(UTMP_FILE, "r")) != NULL) {
	mytty++;
	do {
	    n = fread((char *) &me, sizeof(struct utmp), 1, fp);
	} while (n > 0 && !STREQ(me.ut_line, mytty));
	(void) LYCloseInput(fp);

	if (n > 0 &&
	    strlen(me.ut_host) > strlen(LYLocalDomain) &&
	    STREQ(LYLocalDomain,
		  me.ut_host + strlen(me.ut_host) - strlen(LYLocalDomain)))
	    return (TRUE);
#ifdef LINUX
/* Linux fix to check for local user. J.Cullen 11Jul94		*/
	if ((n > 0) && (strlen(me.ut_host) == 0))
	    return (TRUE);
#endif /* LINUX */

    } else {
	CTRACE((tfp,
		"Could not get ttyname (returned %s) or open UTMP file %s\n",
		NONNULL(cp), UTMP_FILE));
    }

    return (FALSE);
#else
    CTRACE((tfp, "LYUtils: inlocaldomain() not support.\n"));
    return (TRUE);
#endif /* HAVE_UTMP */
}

#ifdef HAVE_SIGACTION
/*
 * An extended alternative for calling signal(), sets some flags for signal
 * handler as we want them if that functionality is available.  (We don't
 * return anything from this function since the return value would currently be
 * ignored anyway.) - kw
 */
void LYExtSignal(int sig,
		 LYSigHandlerFunc_t * handler)
{
#ifdef SIGWINCH
    /* add more cases to if(condition) if required... */
    if (sig == SIGWINCH && LYNonRestartingSIGWINCH) {
	struct sigaction act;

	act.sa_handler = handler;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
#ifdef SA_RESTART
	if (sig != SIGWINCH)
	    act.sa_flags |= SA_RESTART;
#endif /* SA_RESTART */
	sigaction(sig, &act, NULL);
    } else
#endif /* defined(SIGWINCH) */
	signal(sig, handler);
}
#endif /* HAVE_SIGACTION */

#if defined(SIGTSTP) && !defined(USE_SLANG)
#ifdef HAVE_SIGACTION
/*
 * For switching a signal's handling between SIG_DFL and something (possibly)
 * different that may have been set up by lynx code or e.g. by curses library. 
 * Uses sigaction to preserve / restore as much state as possible.
 *
 * Second arg is where to save or restore from.
 *
 * Third arg to_dfl specifies what to do:
 *	1	Save current state in where, set handling to SIG_DFL
 *	0	Restore current state to previously saved one in where
 *
 * Currently only used for SIGTSTP without SLANG, to prevent (n)curses signal
 * handler from running while lynx is waiting in system() for an interactive
 * command like an editor.  - kw
 */
static BOOLEAN LYToggleSigDfl(int sig,
			      struct sigaction *where,
			      int to_dfl)
{
    int rv = -1;
    struct sigaction oact;

    if (to_dfl == 1) {
	rv = sigaction(sig, NULL, &oact);
	if (rv == 0) {
	    if (oact.sa_handler != SIG_DFL) {
		oact.sa_handler = SIG_DFL;
		rv = sigaction(sig, &oact, where);
	    } else if (where) {
		memcpy(where, &oact, sizeof(oact));
		rv = 0;
	    }
	}
    } else {
	rv = sigaction(sig, where, NULL);
    }
    if (rv != 0) {
	CTRACE((tfp, "Error in LYToggleSigDfl: %s\n", LYStrerror(errno)));
	return FALSE;
    } else
	return TRUE;
}
#endif /* HAVE_SIGACTION */
#endif /* SIGTSTP && !USE_SLANG */

/**************
 * This bit of code catches window size change signals
 */

#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif

/* For systems that have both, but both can't be included, duh (or neither) */
/* FIXME: this whole chunk may be redundant */
#ifdef TERMIO_AND_CURSES
# ifdef TERMIO_AND_TERMIOS
#  include <termio.h>
# else
#  ifdef HAVE_TERMIOS_H
#   include <termios.h>
#  else
#   ifdef HAVE_TERMIO_H
#    include <termio.h>
#   endif			/* HAVE_TERMIO_H */
#  endif			/* HAVE_TERMIOS_H */
# endif				/* TERMIO_AND_TERMIOS */
#endif /* TERMIO_AND_CURSES */

void size_change(int sig GCC_UNUSED)
{
    int old_lines = LYlines;
    int old_cols = LYcols;

#ifdef USE_SLANG
#if defined(VMS) || defined(UNIX)
    SLtt_get_screen_size();
#endif /* VMS || UNIX */
    LYlines = SLtt_Screen_Rows;
    LYcols = SLtt_Screen_Cols;
#ifdef SLANG_MBCS_HACK
    PHYSICAL_SLtt_Screen_Cols = LYcols;
#ifdef SLANG_NO_LIMIT		/* define this if slang has been fixed */
    SLtt_Screen_Cols = LYcolLimit * 6;
#else
    /* Needs to be limited: fixed buffer bugs in slang can cause crash,
       see slang's SLtt_smart_puts - kw */
    SLtt_Screen_Cols = HTMIN(LYcolLimit * 6, 255);
#endif
#endif /* SLANG_MBCS_HACK */
    if (sig == 0)
	/*
	 * Called from start_curses().
	 */
	return;
#else /* Curses: */
#ifdef HAVE_SIZECHANGE
#ifdef TIOCGSIZE
    struct ttysize win;

#else
#ifdef TIOCGWINSZ
    struct winsize win;
#endif /* TIOCGWINSZ */
#endif /* TIOCGSIZE */

#ifdef TIOCGSIZE
    if (ioctl(0, TIOCGSIZE, &win) == 0) {
	if (win.ts_lines != 0) {
	    LYlines = win.ts_lines;
	}
	if (win.ts_cols != 0) {
	    LYcols = win.ts_cols;
	}
    }
#else
#ifdef TIOCGWINSZ
    if (ioctl(0, TIOCGWINSZ, &win) == 0) {
	if (win.ws_row != 0) {
	    LYlines = win.ws_row;
	}
	if (win.ws_col != 0) {
	    LYcols = win.ws_col;
	}
    }
#endif /* TIOCGWINSZ */
#endif /* TIOCGSIZE */
#endif /* HAVE_SIZECHANGE */

#ifdef __EMX__
    {
	int scrsize[2];

	_scrsize(scrsize);
	LYcols = scrsize[0];
	LYlines = scrsize[1];
    }
#endif

    if (LYlines <= 0)
	LYlines = DFT_ROWS;
    if (LYcols <= 0)
	LYcols = DFT_COLS;
#endif /* USE_SLANG */

    /*
     * Check if the screen size has actually changed.  - AJL
     */
    if (LYlines != old_lines || LYcols != old_cols) {
	recent_sizechange = TRUE;
	CTRACE((tfp, "Window size changed from (%d,%d) to (%d,%d)\n",
		old_lines, old_cols, LYlines, LYcols));
#if defined(CAN_SWITCH_DISPLAY_CHARSET) && defined(CAN_AUTODETECT_DISPLAY_CHARSET)
	/* May need to reload the font due to different char-box size */
	if (current_char_set != auto_display_charset)
	    Switch_Display_Charset(current_char_set, SWITCH_DISPLAY_CHARSET_RESIZE);
#endif
    }
#ifdef SIGWINCH
    LYExtSignal(SIGWINCH, size_change);
#endif /* SIGWINCH */

    return;
}

/*
 * Utility for freeing the list of previous suggested filenames.  - FM
 */
void HTSugFilenames_free(void)
{
    LYFreeStringList(sug_filenames);
    sug_filenames = NULL;
}

/*
 * Utility for listing suggested filenames, making any repeated filenames the
 * most current in the list.  - FM
 */
void HTAddSugFilename(char *fname)
{
    char *tmp = NULL;
    char *old;
    HTList *cur;

    if (!non_empty(fname))
	return;

    StrAllocCopy(tmp, fname);

    if (!sug_filenames) {
	sug_filenames = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(HTSugFilenames_free);
#endif
	HTList_addObject(sug_filenames, tmp);
	return;
    }

    cur = sug_filenames;
    while (NULL != (old = (char *) HTList_nextObject(cur))) {
	if (!strcmp(old, tmp)) {
	    HTList_removeObject(sug_filenames, old);
	    FREE(old);
	    break;
	}
    }
    HTList_addObject(sug_filenames, tmp);

    return;
}

/*
 * CHANGE_SUG_FILENAME -- Foteos Macrides 29-Dec-1993 Upgraded for use with
 * Lynx2.2 - FM 17-Jan-1994
 */
void change_sug_filename(char *fname)
{
    const char *cp2;
    char *temp = 0, *cp, *cp1, *end;

#ifdef VMS
    char *dot;
    int j, k;
#endif /* VMS */

    /*
     * Establish the current end of fname.
     */
    end = fname + strlen(fname);

    /*
     * Unescape fname.
     */
    HTUnEscape(fname);

    /*
     * Rename any temporary files.
     */
    cp2 = wwwName(lynx_temp_space);
#ifdef FNAMES_8_3
    if (LYIsHtmlSep(*cp2)) {
	HTSprintf0(&temp, "file://localhost%s%04x", cp2, GETPID());
    } else {
	HTSprintf0(&temp, "file://localhost/%s%04x", cp2, GETPID());
    }
#else
    if (LYIsHtmlSep(*cp2)) {
	HTSprintf0(&temp, "file://localhost%s%d", cp2, (int) getpid());
    } else {
	HTSprintf0(&temp, "file://localhost/%s%d", cp2, (int) getpid());
    }
#endif
    if (!strncmp(fname, temp, strlen(temp))) {
	cp = strrchr(fname, '.');
	if (strlen(cp) > (strlen(temp) - 4))
	    cp = NULL;
	StrAllocCopy(temp, NonNull(cp));
	sprintf(fname, "temp%.*s", LY_MAXPATH - 10, temp);
    }
    FREE(temp);

    if (fname[strlen(fname) - 1] == '/')
	/*
	 * Hmm...  we have a directory name.  It is annoying to see a
	 * scheme+host+path name as a suggested one, let's remove the
	 * last_slash and go ahead like we have a file name.  - LP
	 */
	fname[strlen(fname) - 1] = '\0';

    /*
     * Remove everything up the the last_slash if there is one.
     */
    if ((cp = strrchr(fname, '/')) != NULL && strlen(cp) > 1) {
	cp1 = fname;
	/*
	 * Go past the slash.
	 */
	cp++;
	for (; *cp != '\0'; cp++, cp1++) {
	    *cp1 = *cp;
	}
	*cp1 = '\0';
    }
#ifdef _WINDOWS			/* 1998/05/05 (Tue) 10:08:05 */
    if ((cp = strrchr(fname, '=')) != NULL && strlen(cp) > 1) {
	cp1 = fname;
	/*
	 * Go past the '='.
	 */
	cp++;
	for (; *cp != '\0'; cp++, cp1++) {
	    *cp1 = *cp;
	}
	*cp1 = '\0';
    }
#endif

    /*
     * Trim off date-size suffix, if present.
     */
    if ((*(end - 1) == ']') && ((cp = strrchr(fname, '[')) != NULL) &&
	(cp > fname) && *(--cp) == ' ') {
	while (*cp == ' ') {
	    *(cp--) = '\0';
	}
    }

    /*
     * Trim off VMS device and/or directory specs, if present.
     */
    if ((cp = strchr(fname, '[')) != NULL &&
	(cp1 = strrchr(cp, ']')) != NULL && strlen(cp1) > 1) {
	cp1++;
	for (cp = fname; *cp1 != '\0'; cp1++) {
	    *(cp++) = *cp1;
	}
	*cp = '\0';
    }
#ifdef VMS
    /*
     * Replace illegal or problem characters.
     */
    dot = fname + strlen(fname);
    for (cp = fname; cp < dot; cp++) {
	/*
	 * Replace with underscores.
	 */
	if (*cp == ' ' || *cp == '/' || *cp == ':' ||
	    *cp == '[' || *cp == ']' || *cp == '&') {
	    *cp = '_';
	    /*
	     * Replace with dashes.
	     */
	} else if (*cp == '!' || *cp == '?' || *cp == '\'' ||
		   *cp == ',' || *cp == ':' || *cp == '"' ||
		   *cp == '+' || *cp == '@@' || *cp == '\\' ||
		   *cp == '(' || *cp == ')' || *cp == '=' ||
		   *cp == '<' || *cp == '>' || *cp == '#' ||
		   *cp == '%' || *cp == '*' || *cp == '`' ||
		   *cp == '~' || *cp == '^' || *cp == '|' ||
		   *cp < ' ' || (UCH(*cp)) > 126) {
	    *cp = '-';
	}
    }

    /*
     * Collapse any serial underscores.
     */
    cp = fname + 1;
    j = 0;
    while (cp < dot) {
	if (fname[j] == '_' && *cp == '_') {
	    cp++;
	} else {
	    fname[++j] = *cp++;
	}
    }
    fname[++j] = '\0';

    /*
     * Collapse any serial dashes.
     */
    dot = fname + (strlen(fname));
    cp = fname + 1;
    j = 0;
    while (cp < dot) {
	if (fname[j] == '-' && *cp == '-') {
	    cp++;
	} else {
	    fname[++j] = *cp++;
	}
    }
    fname[++j] = '\0';

    /*
     * Trim any trailing or leading underscores or dashes.
     */
    cp = fname + (strlen(fname)) - 1;
    while (*cp == '_' || *cp == '-') {
	*cp-- = '\0';
    }
    if (fname[0] == '_' || fname[0] == '-') {
	dot = fname + (strlen(fname));
	cp = fname;
	while ((*cp == '_' || *cp == '-') && cp < dot) {
	    cp++;
	}
	j = 0;
	while (cp < dot) {
	    fname[j++] = *cp++;
	}
	fname[j] = '\0';
    }

    /*
     * Replace all but the last period with _'s, or second to last if last is
     * followed by a terminal Z or z, or GZ or gz,
     * e.g., convert foo.tar.Z to foo.tar_Z
     * or, convert foo.tar.gz to foo.tar-gz
     */
    j = strlen(fname) - 1;
    if ((dot = strrchr(fname, '.')) != NULL) {
	if (TOUPPER(fname[j]) == 'Z') {
	    if ((fname[j - 1] == '.') &&
		(((cp = strchr(fname, '.')) != NULL) && cp < dot)) {
		*dot = '_';
		dot = strrchr(fname, '.');
	    } else if (((TOUPPER(fname[j - 1]) == 'G') &&
			fname[j - 2] == '.') &&
		       (((cp = strchr(fname, '.')) != NULL) && cp < dot)) {
		*dot = '-';
		dot = strrchr(fname, '.');
	    }
	}
	cp = fname;
	while ((cp = strchr(cp, '.')) != NULL && cp < dot) {
	    *cp = '_';
	}

	/*
	 * But if the root is > 39 characters, move the period appropriately to
	 * the left.
	 */
	while (dot - fname > 39) {
	    *dot = '\0';
	    if ((cp = strrchr(fname, '_')) != NULL) {
		*cp = '.';
		*dot = '_';
	    } else if ((cp = strrchr(fname, '-')) != NULL) {
		*cp = '.';
		*dot = '_';
	    } else if (*(dot + 1) == '\0') {
		j = strlen(fname);
		while (j > 39) {
		    fname[j] = fname[j - 1];
		    j--;
		}
		fname[j] = '.';
	    } else {
		*dot = '.';
		j = 39;
		k = 0;
		while (dot[k] != '\0') {
		    fname[j++] = dot[k++];
		}
		fname[j] = '\0';
	    }
	    dot = strrchr(fname, '.');
	}

	/*
	 * Make sure the extension is < 40 characters.
	 */
	if ((fname + strlen(fname) - dot) > 39) {
	    *(dot + 40) = '\0';
	}

	/*
	 * Trim trailing dashes or underscores.
	 */
	j = (strlen(fname) - 1);
	while (fname[j] == '_' || fname[j] == '-') {
	    fname[j--] = '\0';
	}
    } else {
	/*
	 * No period, so put one on the end, or after the 39th character,
	 * trimming trailing dashes or underscores.
	 */
	if (strlen(fname) > 39) {
	    fname[39] = '\0';
	}
	j = (strlen(fname) - 1);
	while ((fname[j] == '_') || (fname[j] == '-')) {
	    j--;
	}
	fname[++j] = '.';
	fname[++j] = '\0';
    }

#else /* Not VMS (UNIX): */

    /*
     * Replace problem characters.
     */
    for (cp = fname; *cp != '\0'; cp++) {
	switch (*cp) {
	case '\'':
	case '"':
	case '/':
	case ' ':
	    *cp = '-';
	}
    }
#endif /* VMS (UNIX) */

    /*
     * Make sure the rest of the original string in nulled.
     */
    cp = fname + strlen(fname);
    while (cp < end) {
	*cp++ = '\0';
    }

    return;
}

/*
 * Construct a temporary-filename.  Assumes result is LY_MAXPATH chars long.
 */
static int fmt_tempname(char *result,
			const char *prefix,
			const char *suffix)
{
    int code;

#ifdef USE_RAND_TEMPNAME
#define SIZE_TEMPNAME ((MAX_TEMPNAME / BITS_PER_CHAR) + 1)
    static BOOL first = TRUE;
    static int names_used = 0;
    static unsigned char used_tempname[SIZE_TEMPNAME];
    unsigned offset, mask;
#endif
    static unsigned counter;
    char leaf[LY_MAXPATH];

    if (prefix == 0)
	prefix = "";
    if (suffix == 0)
	suffix = "";
    /*
     * Prefer a random value rather than a counter.
     */
#ifdef USE_RAND_TEMPNAME
    if (first) {
	lynx_srand((unsigned) ((long) time((time_t *) 0) + (long) result));
	first = FALSE;
    }

    /* We don't really need all of the bits from rand().  The high-order bits
     * are the more-random portion in any case, but limiting the width of the
     * generated name is done partly to avoid problems on systems that may not
     * support long filenames.
     */
    counter = MAX_TEMPNAME;
    while (names_used < MAX_TEMPNAME) {
	counter = (unsigned) (((float) MAX_TEMPNAME * lynx_rand()) /
			      LYNX_RAND_MAX + 1);
	counter %= SIZE_TEMPNAME;	/* just in case... */
	/*
	 * Avoid reusing a temporary name, since there are places in the code
	 * which can refer to a temporary filename even after it has been
	 * closed and removed from the filesystem.
	 */
	offset = counter / BITS_PER_CHAR;
	mask = 1 << (counter % BITS_PER_CHAR);
	if ((used_tempname[offset] & mask) == 0) {
	    names_used++;
	    used_tempname[offset] |= mask;
	    break;
	}
    }
    if (names_used >= MAX_TEMPNAME)
	HTAlert(gettext("Too many tempfiles"));
#else
    counter++;
#endif

#ifdef FNAMES_8_3
    /*
     * The 'lynx_temp_space' string ends with a '/' or '\\', so we only have to
     * limit the length of the leaf.  As received (e.g., from HTCompressed),
     * the suffix may contain more than a ".htm", e.g., "-txt.gz", so we trim
     * off from the filename portion to make room.
     */
#ifdef _WINDOWS
    sprintf(leaf, "%04x%04x", counter, (unsigned) GETPID());
#else
    sprintf(leaf, "%u%u", counter, (unsigned) getpid());
#endif
    if (strlen(leaf) > 8)
	leaf[8] = 0;
    if (strlen(suffix) > 4 || *suffix != '.') {
	const char *tail = strchr(suffix, '.');

	if (tail == 0)
	    tail = suffix + strlen(suffix);
	if (8 - (tail - suffix) >= 0)
	    leaf[8 - (tail - suffix)] = 0;
    }
    strcat(leaf, suffix);
#else
    sprintf(leaf, "L%u-%uTMP%s", (unsigned) getpid(), counter, suffix);
#endif
    /*
     * Someone could have configured the temporary pathname to be too long.
     */
    if ((strlen(prefix) + strlen(leaf)) < LY_MAXPATH) {
	sprintf(result, "%s%s", prefix, leaf);
	code = TRUE;
    } else {
	sprintf(result, "%.*s", LY_MAXPATH - 1, leaf);
	code = FALSE;
    }
    CTRACE((tfp, "-> '%s'\n", result));
    return (code);
}

/*
 * Convert 4, 6, 2, 8 to left, right, down, up, etc.
 */
int number2arrows(int number)
{
    switch (number) {
    case '1':
	number = END_KEY;
	break;
    case '2':
	number = DNARROW;
	break;
    case '3':
	number = PGDOWN;
	break;
    case '4':
	number = LTARROW;
	break;
    case '5':
	number = DO_NOTHING;
	break;
    case '6':
	number = RTARROW;
	break;
    case '7':
	number = HOME;
	break;
    case '8':
	number = UPARROW;
	break;
    case '9':
	number = PGUP;
	break;
    }

    return (number);
}

/*
 * parse_restrictions takes a string of comma-separated restrictions and sets
 * the corresponding flags to restrict the facilities available.
 */
/* The first two are special:  we want to record whether "default" or "all"
 * restrictions were applied, in addition to the detailed effects of those
 * options.  - kw
 */
/* skip the special flags when processing "all" and "default": */
#define N_SPECIAL_RESTRICT_OPTIONS 2
/* *INDENT-OFF* */
static const struct {
    const char *name;
    BOOLEAN *flag;
    BOOLEAN can;
} restrictions[] = {
    { "default",	&had_restrictions_default, TRUE },
    { "all",		&had_restrictions_all,	TRUE },
    { "inside_telnet",	&no_inside_telnet,	CAN_ANONYMOUS_INSIDE_DOMAIN_TELNET },
    { "outside_telnet",	&no_outside_telnet,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_TELNET },
    { "telnet_port",	&no_telnet_port,	CAN_ANONYMOUS_GOTO_TELNET_PORT },
    { "inside_ftp",	&no_inside_ftp,		CAN_ANONYMOUS_INSIDE_DOMAIN_FTP },
    { "outside_ftp",	&no_outside_ftp,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_FTP },
    { "inside_rlogin",	&no_inside_rlogin,	CAN_ANONYMOUS_INSIDE_DOMAIN_RLOGIN },
    { "outside_rlogin",	&no_outside_rlogin,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_RLOGIN },
    { "suspend",	&no_suspend,		FALSE },
    { "editor",		&no_editor,		FALSE },
    { "shell",		&no_shell,		FALSE },
    { "bookmark",	&no_bookmark,		FALSE },
    { "multibook",	&no_multibook,		FALSE },
    { "bookmark_exec",	&no_bookmark_exec,	FALSE },
    { "option_save",	&no_option_save,	FALSE },
    { "print",		&no_print,		CAN_ANONYMOUS_PRINT },
    { "download",	&no_download,		FALSE },
    { "disk_save",	&no_disk_save,		FALSE },
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
    { "exec",		&no_exec,		LOCAL_EXECUTION_LINKS_ALWAYS_OFF_FOR_ANONYMOUS },
#endif
    { "lynxcgi",	&no_lynxcgi,		FALSE },
    { "exec_frozen",	&exec_frozen,		FALSE },
    { "goto",		&no_goto,		CAN_ANONYMOUS_GOTO },
    { "jump",		&no_jump,		CAN_ANONYMOUS_JUMP },
    { "file_url",	&no_file_url,		FALSE },
#ifndef DISABLE_NEWS
    { "news_post",	&no_newspost,		FALSE },
    { "inside_news",	&no_inside_news,	CAN_ANONYMOUS_INSIDE_DOMAIN_READ_NEWS },
    { "outside_news",	&no_outside_news,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_READ_NEWS },
#endif
    { "mail",		&no_mail,		CAN_ANONYMOUS_MAIL },
    { "dotfiles",	&no_dotfiles,		FALSE },
    { "useragent",	&no_useragent,		FALSE },
#ifdef SUPPORT_CHDIR
    { "chdir",		&no_chdir,		FALSE },
#endif
#ifdef DIRED_SUPPORT
    { "dired_support",	&no_dired_support,	FALSE },
#ifdef OK_PERMIT
    { "change_exec_perms", &no_change_exec_perms, FALSE },
#endif /* OK_PERMIT */
#endif /* DIRED_SUPPORT */
#ifdef USE_EXTERNALS
    { "externals",	&no_externals,		FALSE },
#endif
    { "lynxcfg_info",	&no_lynxcfg_info,	CAN_ANONYMOUS_VIEW_LYNXCFG_INFO },
#ifndef NO_CONFIG_INFO
    { "lynxcfg_xinfo",	&no_lynxcfg_xinfo,	CAN_ANONYMOUS_VIEW_LYNXCFG_EXTENDED_INFO },
#ifdef HAVE_CONFIG_H
    { "compileopts_info", &no_compileopts_info,	CAN_ANONYMOUS_VIEW_COMPILEOPTS_INFO },
#endif
#endif
    /* put "goto" restrictions on the end, since they are a refinement */
#ifndef DISABLE_BIBP
    { "goto_bibp",	&no_goto_bibp,		CAN_ANONYMOUS_GOTO_BIBP	},
#endif
#ifdef HAVE_CONFIG_H
#ifndef NO_CONFIG_INFO
    { "goto_configinfo", &no_goto_configinfo,	CAN_ANONYMOUS_GOTO_CONFIGINFO },
#endif
#endif
    { "goto_cso",	&no_goto_cso,		CAN_ANONYMOUS_GOTO_CSO },
    { "goto_file",	&no_goto_file,		CAN_ANONYMOUS_GOTO_FILE },
#ifndef DISABLE_FINGER
    { "goto_finger",	&no_goto_finger,	CAN_ANONYMOUS_GOTO_FINGER },
#endif
    { "goto_ftp",	&no_goto_ftp,		CAN_ANONYMOUS_GOTO_FTP },
#ifndef DISABLE_GOPHER
    { "goto_gopher",	&no_goto_gopher,	CAN_ANONYMOUS_GOTO_GOPHER },
#endif
    { "goto_http",	&no_goto_http,		CAN_ANONYMOUS_GOTO_HTTP },
    { "goto_https",	&no_goto_https,		CAN_ANONYMOUS_GOTO_HTTPS },
    { "goto_lynxcgi",	&no_goto_lynxcgi,	CAN_ANONYMOUS_GOTO_LYNXCGI },
    { "goto_lynxexec",	&no_goto_lynxexec,	CAN_ANONYMOUS_GOTO_LYNXEXEC },
    { "goto_lynxprog",	&no_goto_lynxprog,	CAN_ANONYMOUS_GOTO_LYNXPROG },
    { "goto_mailto",	&no_goto_mailto,	CAN_ANONYMOUS_GOTO_MAILTO },
#ifndef DISABLE_NEWS
    { "goto_news",	&no_goto_news,		CAN_ANONYMOUS_GOTO_NEWS },
    { "goto_nntp",	&no_goto_nntp,		CAN_ANONYMOUS_GOTO_NNTP },
#endif
    { "goto_rlogin",	&no_goto_rlogin,	CAN_ANONYMOUS_GOTO_RLOGIN },
#ifndef DISABLE_NEWS
    { "goto_snews",	&no_goto_snews,		CAN_ANONYMOUS_GOTO_SNEWS },
#endif
    { "goto_telnet",	&no_goto_telnet,	CAN_ANONYMOUS_GOTO_TELNET },
    { "goto_tn3270",	&no_goto_tn3270,	CAN_ANONYMOUS_GOTO_TN3270 },
    { "goto_wais",	&no_goto_wais,		CAN_ANONYMOUS_GOTO_WAIS },
};
/* *INDENT-ON* */

/* This will make no difference between '-' and '_'.  It does only in/equality
 * compare.  It assumes that p2 can't contain dashes, but p1 can.  This
 * function is also used (if macro OPTNAME_ALLOW_DASHES doesn't have value of
 * zero) for compare of commandline options -VH
 */
BOOL strn_dash_equ(const char *p1,
		   const char *p2,
		   int len)
{
    while (len--) {
	if (!*p2)
	    return 0;		/* canonical name is shorter */
	switch (*p1) {
	case 0:
	    return 0;
	case '-':
	case '_':
	    if (*p2 != '_')
		return 0;
	    else
		break;
	default:
	    if (*p1 != *p2)
		return 0;
	}
	++p1;
	++p2;
    }
    return 1;
}

/* Uncomment following lines to allow only exact string matching */
/* #define RESTRICT_NM_ALLOW_DASHES 0 */

#ifndef RESTRICT_NM_ALLOW_DASHES
# define RESTRICT_NM_ALLOW_DASHES 1
#endif

#if RESTRICT_NM_ALLOW_DASHES
#	define RESTRICT_NM_EQU(a,b,len) strn_dash_equ(a,b,len)
#else
#	define RESTRICT_NM_EQU(a,b,len) STRNEQ(a,b,len)
#endif

/*
 * Returns the inx'th name from the restrictions table, or null if inx is
 * out of range.
 */
const char *index_to_restriction(int inx)
{
    if (inx >= 0 && inx < (int) TABLESIZE(restrictions))
	return restrictions[inx].name;
    return NULL;
}

/*
 * Returns the value TRUE/FALSE of a given restriction, or -1 if it is not
 * one that we recognize.
 */
int find_restriction(const char *name,
		     int len)
{
    unsigned i;

    if (len < 0)
	len = strlen(name);
    for (i = 0; i < TABLESIZE(restrictions); i++) {
	if (RESTRICT_NM_EQU(name, restrictions[i].name, len)) {
	    return (*restrictions[i].flag);
	}
    }
    return -1;
}

void parse_restrictions(const char *s)
{
    const char *p;
    const char *word;
    unsigned i;
    BOOLEAN found;

    p = s;
    while (*p) {
	p = LYSkipCBlanks(p);
	if (*p == '\0')
	    break;
	word = p;
	while (*p != ',' && *p != '\0')
	    p++;

	found = FALSE;
	if (RESTRICT_NM_EQU(word, "all", p - word)) {
	    found = TRUE;
	    for (i = N_SPECIAL_RESTRICT_OPTIONS;
		 i < TABLESIZE(restrictions);
		 i++)
		*(restrictions[i].flag) = TRUE;
	} else if (RESTRICT_NM_EQU(word, "default", p - word)) {
	    found = TRUE;
	    for (i = N_SPECIAL_RESTRICT_OPTIONS;
		 i < TABLESIZE(restrictions);
		 i++)
		*(restrictions[i].flag) = !restrictions[i].can;
	} else {
	    for (i = 0; i < TABLESIZE(restrictions); i++) {
		if (RESTRICT_NM_EQU(word, restrictions[i].name, p - word)) {
		    *(restrictions[i].flag) = TRUE;
		    found = TRUE;
		    break;
		}
	    }
	}
	if (!found) {
	    printf("%s: %.*s\n", gettext("unknown restriction"), p - word, word);
	    exit_immediately(EXIT_FAILURE);
	}
	if (*p)
	    p++;
    }

    /*
     * If shell is restricted, set restrictions on related topics.
     */
    if (no_shell) {
	no_goto_lynxexec = TRUE;
	no_goto_lynxprog = TRUE;
	no_goto_lynxcgi = TRUE;
#ifdef EXEC_LINKS
	local_exec_on_local_files = TRUE;
#endif
    }
}

void print_restrictions_to_fd(FILE *fp)
{
    unsigned i, count = 0;

    for (i = 0; i < TABLESIZE(restrictions); i++) {
	if (*(restrictions[i].flag) == TRUE) {
	    count++;
	}
    }
    if (!count) {
	fprintf(fp, gettext("No restrictions set.\n"));
	return;
    }
    fprintf(fp, gettext("Restrictions set:\n"));
    for (i = 0; i < TABLESIZE(restrictions); i++) {
	if (*(restrictions[i].flag) == TRUE) {
	    /* if "goto" is restricted, don't bother tell about its
	     * refinements
	     */
	    if (strncmp(restrictions[i].name, "goto_", 5)
		|| !no_goto)
		fprintf(fp, "   %s\n", restrictions[i].name);
	}
    }
}

#ifdef VMS
#include <jpidef.h>
#include <maildef.h>
#include <starlet.h>

typedef struct _VMSMailItemList {
    short buffer_length;
    short item_code;
    void *buffer_address;
    long *return_length_address;
} VMSMailItemList;

void LYCheckMail(void)
{
    static BOOL firsttime = TRUE, failure = FALSE;
    static char user[13], dir[252];
    static long userlen = 0, dirlen;
    static time_t lastcheck = 0;
    time_t now;
    static short new, lastcount;
    long ucontext = 0, status;
    short flags = MAIL$M_NEWMSG;
    /* *INDENT-OFF* */
    VMSMailItemList
      null_list[] = {{0,0,0,0}},
      jpi_list[]  = {{sizeof(user) - 1,JPI$_USERNAME,(void *)user,&userlen},
		     {0,0,0,0}},
      uilist[]	  = {{0,MAIL$_USER_USERNAME,0,0},
		     {0,0,0,0}},
      uolist[]	  = {{sizeof(new),MAIL$_USER_NEW_MESSAGES,&new,0},
		     {sizeof(dir),MAIL$_USER_FULL_DIRECTORY,dir,&dirlen},
		     {0,0,0,0}};
    /* *INDENT-ON* */

    extern long mail$user_begin();
    extern long mail$user_get_info();
    extern long mail$user_end();

    if (failure)
	return;

    if (firsttime) {
	firsttime = FALSE;
	/* Get the username. */
	status = sys$getjpiw(0, 0, 0, jpi_list, 0, 0, 0);
	if (!(status & 1)) {
	    failure = TRUE;
	    return;
	}
	user[userlen] = '\0';
	LYTrimTrailing(user);
    }

    /* Minimum report interval is 60 sec. */
    time(&now);
    if (now - lastcheck < 60)
	return;
    lastcheck = now;

    /* Get the current newmail count. */
    status = mail$user_begin(&ucontext, null_list, null_list);
    if (!(status & 1)) {
	failure = TRUE;
	return;
    }
    uilist[0].buffer_length = strlen(user);
    uilist[0].buffer_address = user;
    status = mail$user_get_info(&ucontext, uilist, uolist);
    if (!(status & 1)) {
	failure = TRUE;
	return;
    }

    /* Should we report anything to the user? */
    if (new > 0) {
	if (lastcount == 0)
	    /* Have newmail at startup of Lynx. */
	    HTUserMsg(HAVE_UNREAD_MAIL_MSG);
	else if (new > lastcount)
	    /* Have additional mail since last report. */
	    HTUserMsg(HAVE_NEW_MAIL_MSG);
	lastcount = new;
	return;
    }
    lastcount = new;

    /* Clear the context */
    mail$user_end((long *) &ucontext, null_list, null_list);
    return;
}
#else
void LYCheckMail(void)
{
    static BOOL firsttime = TRUE;
    static char *mf;
    static time_t lastcheck;
    static time_t lasttime;
    static long lastsize;
    time_t now;
    struct stat st;

    if (firsttime) {
	mf = LYGetEnv("MAIL");
	firsttime = FALSE;
	time(&lasttime);
    }

    if (mf == NULL)
	return;

    time(&now);
    if (now - lastcheck < 60)
	return;
    lastcheck = now;

    if ((stat(mf, &st) < 0)
	|| !S_ISREG(st.st_mode)) {
	mf = NULL;
	return;
    }

    if (st.st_size > 0) {
	if (((lasttime != st.st_mtime) && (st.st_mtime > st.st_atime))
	    || ((lastsize != 0) && (st.st_size > lastsize)))
	    HTUserMsg(HAVE_NEW_MAIL_MSG);
	else if (lastsize == 0)
	    HTUserMsg(HAVE_MAIL_MSG);
    }
    lastsize = st.st_size;
    lasttime = st.st_mtime;
    return;
}
#endif /* VMS */

/*
 *  This function ensures that an href will be
 *  converted to a fully resolved, absolute URL,
 *  with guessing of the host or expansions of
 *  lead tildes via LYConvertToURL() if needed,
 *  and tweaking/simplifying via HTParse().  It
 *  is used for LynxHome, startfile, homepage,
 *  and 'g'oto entries, after they have been
 *  passed to LYFillLocalFileURL(). - FM
 *  Such URLs have no `base' reference to which they
 *  could be resolved.  LYLegitimizeHREF could not be used.
 */
void LYEnsureAbsoluteURL(char **href,
			 const char *name,
			 int fixit)
{
    char *temp = NULL;

    if (isEmpty(*href))
	return;

    /*
     * Check whether to fill in localhost.  - FM
     */
    LYFillLocalFileURL(href, "file://localhost");

    /*
     * If it is not a URL then make it one.
     */
    if (!strcasecomp(*href, STR_NEWS_URL)) {
	StrAllocCat(*href, "*");
    } else if (!strcasecomp(*href, STR_SNEWS_URL)) {
	StrAllocCat(*href, "/*");
    }

    if (!is_url(*href)) {
	CTRACE((tfp, "%s%s'%s' is not a URL\n",
		NonNull(name), (name ? " " : ""), *href));
	LYConvertToURL(href, fixit);
    }

    temp = HTParse(*href, "", PARSE_ALL);
    if (non_empty(temp))
	StrAllocCopy(*href, temp);
    FREE(temp);
}

/*
 * Rewrite and reallocate a previously allocated string as a file URL if the
 * string resolves to a file or directory on the local system, otherwise as an
 * http URL.  - FM
 */
void LYConvertToURL(char **AllocatedString,
		    int fixit)
{
    char *old_string = *AllocatedString;
    char *temp = NULL;
    char *cp = NULL;

#ifndef VMS
    struct stat st;
#endif /* !VMS */

    if (!old_string || *old_string == '\0')
	return;

#if defined(USE_DOS_DRIVES)
    {
	char *cp_url = *AllocatedString;

	for (; *cp_url != '\0'; cp_url++)
	    if (*cp_url == '\\')
		*cp_url = '/';
	cp_url--;
	if (LYIsDosDrive(*AllocatedString) && *cp_url == ':')
	    LYAddPathSep(AllocatedString);
    }
#endif /* USE_DOS_DRIVES */

    *AllocatedString = NULL;	/* so StrAllocCopy doesn't free it */
    StrAllocCopy(*AllocatedString, "file://localhost");

    if (*old_string != '/') {
	char *fragment = NULL;

#if defined(USE_DOS_DRIVES)
	StrAllocCat(*AllocatedString, "/");
#endif /* USE_DOS_DRIVES */
#ifdef VMS
	/*
	 * Not a SHELL pathspec.  Get the full VMS spec and convert it.
	 */
	char *cur_dir = NULL;
	static char url_file[LY_MAXPATH], file_name[LY_MAXPATH], dir_name[LY_MAXPATH];
	unsigned long context = 0;

	$DESCRIPTOR(url_file_dsc, url_file);
	$DESCRIPTOR(file_name_dsc, file_name);
	if (*old_string == '~') {
	    /*
	     * On VMS, we'll accept '~' on the command line as Home_Dir(), and
	     * assume the rest of the path, if any, has SHELL syntax.
	     */
	    StrAllocCat(*AllocatedString, HTVMS_wwwName(Home_Dir()));
	    if ((cp = strchr(old_string, '/')) != NULL) {
		/*
		 * Append rest of path, if present, skipping "user" if "~user"
		 * was entered, simplifying, and eliminating any residual
		 * relative elements.  - FM
		 */
		StrAllocCopy(temp, cp);
		LYTrimRelFromAbsPath(temp);
		StrAllocCat(*AllocatedString, temp);
		FREE(temp);
	    }
	    goto have_VMS_URL;
	} else {
	    fragment = trimPoundSelector(old_string);
	    LYstrncpy(url_file, old_string, sizeof(url_file) - 1);
	}
	url_file_dsc.dsc$w_length = (short) strlen(url_file);
	if (1 & lib$find_file(&url_file_dsc, &file_name_dsc, &context,
			      0, 0, 0, 0)) {
	    /*
	     * We found the file.  Convert to a URL pathspec.
	     */
	    if ((cp = strchr(file_name, ';')) != NULL) {
		*cp = '\0';
	    }
	    LYLowerCase(file_name);
	    StrAllocCat(*AllocatedString, HTVMS_wwwName(file_name));
	    if ((cp = strchr(old_string, ';')) != NULL) {
		StrAllocCat(*AllocatedString, cp);
	    }
	    if (fragment != NULL) {
		restorePoundSelector(fragment);
		StrAllocCat(*AllocatedString, fragment);
		fragment = NULL;
	    }
	} else if ((NULL != getcwd(dir_name, sizeof(dir_name) - 1, 0)) &&
		   0 == chdir(old_string)) {
	    /*
	     * Probably a directory.  Try converting that.
	     */
	    StrAllocCopy(cur_dir, dir_name);
	    restorePoundSelector(fragment);
	    if (NULL != getcwd(dir_name, sizeof(dir_name) - 1, 0)) {
		/*
		 * Yup, we got it!
		 */
		LYLowerCase(dir_name);
		StrAllocCat(*AllocatedString, dir_name);
		if (fragment != NULL) {
		    StrAllocCat(*AllocatedString, fragment);
		    fragment = NULL;
		}
	    } else {
		/*
		 * Nope.  Assume it's an http URL with the "http://" defaulted,
		 * if we can't rule out a bad VMS path.
		 */
		fragment = NULL;
		if (strchr(old_string, '[') ||
		    ((cp = strchr(old_string, ':')) != NULL &&
		     !isdigit(UCH(cp[1]))) ||
		    !LYExpandHostForURL(&old_string,
					URLDomainPrefixes,
					URLDomainSuffixes)) {
		    /*
		     * Probably a bad VMS path (but can't be sure).  Use
		     * original pathspec for the error message that will
		     * result.
		     */
		    sprintf(url_file, "/%.*s", sizeof(url_file) - 2, old_string);
		    CTRACE((tfp,
			    "Can't find '%s'  Will assume it's a bad path.\n",
			    old_string));
		    StrAllocCat(*AllocatedString, url_file);
		} else {
		    /*
		     * Assume a URL is wanted, so guess the scheme with
		     * "http://" as the default.  - FM
		     */
		    if (!LYAddSchemeForURL(&old_string, "http://")) {
			StrAllocCopy(*AllocatedString, "http://");
			StrAllocCat(*AllocatedString, old_string);
		    } else {
			StrAllocCopy(*AllocatedString, old_string);
		    }
		}
	    }
	} else {
	    /*
	     * Nothing found.  Assume it's an http URL with the "http://"
	     * defaulted, if we can't rule out a bad VMS path.
	     */
	    restorePoundSelector(fragment);
	    fragment = NULL;

	    if (strchr(old_string, '[') ||
		((cp = strchr(old_string, ':')) != NULL &&
		 !isdigit(UCH(cp[1]))) ||
		!LYExpandHostForURL(&old_string,
				    URLDomainPrefixes,
				    URLDomainSuffixes)) {
		/*
		 * Probably a bad VMS path (but can't be sure).  Use original
		 * pathspec for the error message that will result.
		 */
		sprintf(url_file, "/%.*s", sizeof(url_file) - 2, old_string);
		CTRACE((tfp, "Can't find '%s'  Will assume it's a bad path.\n",
			old_string));
		StrAllocCat(*AllocatedString, url_file);
	    } else {
		/*
		 * Assume a URL is wanted, so guess the scheme with "http://"
		 * as the default.  - FM
		 */
		if (!LYAddSchemeForURL(&old_string, "http://")) {
		    StrAllocCopy(*AllocatedString, "http://");
		    StrAllocCat(*AllocatedString, old_string);
		} else {
		    StrAllocCopy(*AllocatedString, old_string);
		}
	    }
	}
	lib$find_file_end(&context);
	FREE(cur_dir);
      have_VMS_URL:
	CTRACE((tfp, "Trying: '%s'\n", *AllocatedString));
#else /* not VMS: */
#if defined(USE_DOS_DRIVES)
#ifdef _WINDOWS
	if (*old_string == '.') {
	    char fullpath[MAX_PATH + 1];
	    char *filepart = NULL;
	    DWORD chk;

	    chk = GetFullPathNameA(old_string, MAX_PATH + 1,
				   fullpath, &filepart);
	    if (chk != 0) {
		StrAllocCopy(temp, wwwName(fullpath));
		StrAllocCat(*AllocatedString, temp);
		FREE(temp);
		CTRACE((tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString));
	    } else {
		StrAllocCat(*AllocatedString, old_string);
	    }
	}
#else
	if (strlen(old_string) == 1 && *old_string == '.') {
	    /*
	     * They want .
	     */
	    char curdir[LY_MAXPATH];

	    StrAllocCopy(temp, wwwName(Current_Dir(curdir)));
	    StrAllocCat(*AllocatedString, temp);
	    FREE(temp);
	    CTRACE((tfp, "Converted '%s' to '%s'\n",
		    old_string, *AllocatedString));
	}
#endif
	else
#endif /* USE_DOS_DRIVES */
	if (*old_string == '~') {
	    /*
	     * On Unix, convert '~' to Home_Dir().
	     */
	    StrAllocCat(*AllocatedString, wwwName(Home_Dir()));
	    if ((cp = strchr(old_string, '/')) != NULL) {
		/*
		 * Append rest of path, if present, skipping "user" if "~user"
		 * was entered, simplifying, and eliminating any residual
		 * relative elements.  - FM
		 */
		StrAllocCopy(temp, cp);
		LYTrimRelFromAbsPath(temp);
		StrAllocCat(*AllocatedString, temp);
		FREE(temp);
	    }
	    CTRACE((tfp, "Converted '%s' to '%s'\n",
		    old_string, *AllocatedString));
	} else {
	    /*
	     * Create a full path to the current default directory.
	     */
	    char curdir[LY_MAXPATH];
	    char *temp2 = NULL;
	    BOOL is_local = FALSE;

	    Current_Dir(curdir);
	    /*
	     * Concatenate and simplify, trimming any residual relative
	     * elements.  - FM
	     */
#if defined (USE_DOS_DRIVES)
	    if (old_string[1] != ':' && old_string[1] != '|') {
		StrAllocCopy(temp, wwwName(curdir));
		LYAddHtmlSep(&temp);
		LYstrncpy(curdir, temp, (sizeof(curdir) - 1));
		StrAllocCat(temp, old_string);
	    } else {
		curdir[0] = '\0';
		/* 1998/01/13 (Tue) 12:24:33 */
		if (old_string[1] == '|')
		    old_string[1] = ':';
		StrAllocCopy(temp, old_string);

		if (strlen(temp) == 2 && LYIsDosDrive(temp))
		    LYAddPathSep(&temp);
	    }
#else
	    StrAllocCopy(temp, curdir);
	    StrAllocCat(temp, "/");
	    StrAllocCat(temp, old_string);
#endif /* USE_DOS_DRIVES */
	    LYTrimRelFromAbsPath(temp);
	    CTRACE((tfp, "Converted '%s' to '%s'\n", old_string, temp));
	    if ((stat(temp, &st) > -1) ||
		LYCanReadFile(temp)) {
		/*
		 * It is a subdirectory or file on the local system.
		 */
#if defined (USE_DOS_DRIVES)
		/* Don't want to see DOS local paths like c: escaped  */
		/* especially when we really have file://localhost/   */
		/* at the beginning.  To avoid any confusion we allow */
		/* escaping the path if URL specials % or # present.  */
		if (strchr(temp, '#') == NULL && strchr(temp, '%') == NULL)
		    StrAllocCopy(cp, temp);
		else
		    cp = HTEscape(temp, URL_PATH);
#else
		cp = HTEscape(temp, URL_PATH);
#endif /* USE_DOS_DRIVES */
		StrAllocCat(*AllocatedString, cp);
		FREE(cp);
		CTRACE((tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString));
		is_local = TRUE;
	    } else {
		char *cp2 = NULL;

		StrAllocCopy(temp2, curdir);
		LYAddPathSep(&temp2);
		StrAllocCopy(cp, old_string);
		fragment = trimPoundSelector(cp);
		HTUnEscape(cp);	/* unescape given path without fragment */
		StrAllocCat(temp2, cp);		/* append to current dir  */
		StrAllocCopy(cp2, temp2);	/* keep a copy in cp2     */
		LYTrimRelFromAbsPath(temp2);
#ifdef WIN_EX			/* 1998/07/31 (Fri) 09:09:03 */
		HTUnEscape(temp2);	/* for LFN */
#endif

		if (strcmp(temp2, temp) != 0 &&
		    ((stat(temp2, &st) > -1) ||
		     LYCanReadFile(temp2))) {
		    /*
		     * It is a subdirectory or file on the local system with
		     * escaped characters and/or a fragment to be appended to
		     * the URL.  - FM
		     */

		    FREE(temp);
		    if (strcmp(cp2, temp2) == 0) {
			/*
			 * LYTrimRelFromAbsPath did nothing, use old_string as
			 * given.  - kw
			 */
			temp = HTEscape(curdir, URL_PATH);
			LYAddHtmlSep(&temp);
			StrAllocCat(temp, old_string);
		    } else {
			temp = HTEscape(temp2, URL_PATH);
			if (fragment != NULL) {
			    restorePoundSelector(fragment);
			    StrAllocCat(temp, fragment);
			}
		    }
		    StrAllocCat(*AllocatedString, temp);
		    CTRACE((tfp, "Converted '%s' to '%s'\n",
			    old_string, *AllocatedString));
		    is_local = TRUE;

		} else if (strchr(curdir, '#') != NULL ||
			   strchr(curdir, '%') != NULL) {
		    /*
		     * If PWD has some unusual characters, construct a filename
		     * in temp where those are escaped.  This is mostly to
		     * prevent this function from returning with some weird URL
		     * if the LYExpandHostForURL tests further down fail.  - kw
		     */
		    FREE(temp);
		    if (strcmp(cp2, temp2) == 0) {
			/*
			 * LYTrimRelFromAbsPath did nothing, use old_string as
			 * given.  - kw
			 */
			temp = HTEscape(curdir, URL_PATH);
			LYAddHtmlSep(&temp);
			StrAllocCat(temp, old_string);
		    } else {
			temp = HTEscape(temp2, URL_PATH);
			if (fragment != NULL) {
			    restorePoundSelector(fragment);
			    StrAllocCat(temp, fragment);
			}
		    }
		}
		FREE(cp);
		FREE(cp2);
	    }
	    if (is_local == FALSE) {
		/*
		 * It's not an accessible subdirectory or file on the local
		 * system, so assume it's a URL request and guess the scheme
		 * with "http://" as the default.
		 */
		CTRACE((tfp, "Can't stat() or fopen() '%s'\n",
			temp2 ? temp2 : temp));
#ifdef WIN_EX			/* 1998/01/13 (Tue) 09:07:37 */
		{
		    const char *p, *q;
		    char buff[LY_MAXPATH + 128];

		    p = Home_Dir();
		    q = temp2 ? temp2 : temp;

		    if (strlen(q) == 3 && LYIsDosDrive(q)) {
			sprintf(buff,
				"'%s' not exist, Goto LynxHome '%s'.", q, p);
			_statusline(buff);
			LYSleepAlert();
			FREE(temp);
			StrAllocCat(*AllocatedString, p);
			goto Retry;
		    }
		}
#endif
		if (LYExpandHostForURL(&old_string,
				       URLDomainPrefixes,
				       URLDomainSuffixes)) {
		    if (!LYAddSchemeForURL(&old_string, "http://")) {
			StrAllocCopy(*AllocatedString, "http://");
			StrAllocCat(*AllocatedString, old_string);
		    } else {
			StrAllocCopy(*AllocatedString, old_string);
		    }
		} else if (fixit) {
		    /* RW 1998Mar16  Restore AllocatedString to 'old_string' */
		    StrAllocCopy(*AllocatedString, old_string);
		} else {
		    /* Return file URL for the file that does not exist */
		    StrAllocCat(*AllocatedString, temp);
		}
#ifdef WIN_EX
	      Retry:
#endif
		CTRACE((tfp, "Trying: '%s'\n", *AllocatedString));
	    }
	    FREE(temp);
	    FREE(temp2);
	}
#endif /* VMS */
    } else {
	/*
	 * Path begins with a slash.  Simplify and use it.
	 */
	if (old_string[1] == '\0') {
	    /*
	     * Request for root.  Respect it on Unix, but on VMS we treat that
	     * as a listing of the login directory.  - FM
	     */
#ifdef VMS
	    StrAllocCat(*AllocatedString, HTVMS_wwwName(Home_Dir()));
#else
	    StrAllocCat(*AllocatedString, "/");
	} else if ((stat(old_string, &st) > -1) ||
		   LYCanReadFile(old_string)) {
	    /*
	     * It is an absolute directory or file on the local system.  - KW
	     */
	    StrAllocCopy(temp, old_string);
	    LYTrimRelFromAbsPath(temp);
	    CTRACE((tfp, "Converted '%s' to '%s'\n", old_string, temp));
	    cp = HTEscape(temp, URL_PATH);
	    StrAllocCat(*AllocatedString, cp);
	    FREE(cp);
	    FREE(temp);
	    CTRACE((tfp, "Converted '%s' to '%s'\n",
		    old_string, *AllocatedString));
#endif /* VMS */
	} else if (old_string[1] == '~') {
	    /*
	     * Has a Home_Dir() reference.  Handle it as if there weren't a
	     * lead slash.  - FM
	     */
	    StrAllocCat(*AllocatedString, wwwName(Home_Dir()));
	    if ((cp = strchr((old_string + 1), '/')) != NULL) {
		/*
		 * Append rest of path, if present, skipping "user" if "~user"
		 * was entered, simplifying, and eliminating any residual
		 * relative elements.  - FM
		 */
		StrAllocCopy(temp, cp);
		LYTrimRelFromAbsPath(temp);
		StrAllocCat(*AllocatedString, temp);
		FREE(temp);
	    }
	} else {
	    /*
	     * Normal absolute path.  Simplify, trim any residual relative
	     * elements, and append it.  - FM
	     */
	    StrAllocCopy(temp, old_string);
	    LYTrimRelFromAbsPath(temp);
	    StrAllocCat(*AllocatedString, temp);
	    FREE(temp);
	}
	CTRACE((tfp, "Converted '%s' to '%s'\n",
		old_string, *AllocatedString));
    }
    FREE(old_string);
    /* Pause so we can read the messages before invoking curses */
    CTRACE_SLEEP(AlertSecs);
}

#if defined(_WINDOWS)		/* 1998/06/23 (Tue) 16:45:20 */

int win32_check_interrupt(void)
{
    int c;

    if (kbhit()) {
	c = LYgetch();
	/** Keyboard 'Z' or 'z', or Control-G or Control-C **/
	if (LYCharIsINTERRUPT(c) || c == 0x1b) {
	    return TRUE;
	}
    }
    return FALSE;
}

void sleep(unsigned sec)
{
    unsigned int i, j;
    int c;

    for (j = 0; j < sec; j++) {
	for (i = 0; i < 10; i++) {
	    Sleep(100);
	    if (kbhit()) {
		c = LYgetch();
		return;
	    }
	}
    }
}
#endif

/*
 * This function rewrites and reallocates a previously allocated string so that
 * the first element is a confirmed Internet host, and returns TRUE, otherwise
 * it does not modify the string and returns FALSE.  It first tries the element
 * as is, then, if the element does not end with a dot, it adds prefixes from
 * the (comma separated) prefix list argument, and, if the element does not
 * begin with a dot, suffixes from the (comma separated) suffix list arguments
 * (e.g., www.host.com, then www.host,edu, then www.host.net, then
 * www.host.org).  The remaining path, if one is present, will be appended to
 * the expanded host.  It also takes into account whether a colon is in the
 * element or suffix, and includes that and what follows as a port field for
 * the expanded host field (e.g, wfbr:8002/dir/lynx should yield
 * www.wfbr.edu:8002/dir/lynx).  The calling function should prepend the scheme
 * field (e.g., http://), or pass the string to LYAddSchemeForURL(), if this
 * function returns TRUE.  - FM
 */
BOOLEAN LYExpandHostForURL(char **AllocatedString,
			   char *prefix_list,
			   char *suffix_list)
{
    char DomainPrefix[80];
    const char *StartP, *EndP;
    char DomainSuffix[80];
    const char *StartS, *EndS;
    char *Str = NULL, *StrColon = NULL, *MsgStr = NULL;
    char *Host = NULL, *HostColon = NULL, *host = NULL;
    char *Path = NULL;
    char *Fragment = NULL;
    BOOLEAN GotHost = FALSE;
    BOOLEAN Startup = (BOOL) (helpfilepath == NULL);

#ifdef INET6
    struct addrinfo hints, *res;
    int error;
#endif /* INET6 */

    /*
     * If it's a NULL or zero-length string, or if it begins with a slash or
     * hash, don't continue pointlessly.  - FM
     */
    if (!(*AllocatedString) || *AllocatedString[0] == '\0' ||
	*AllocatedString[0] == '/' || *AllocatedString[0] == '#') {
	return GotHost;
    }

    /*
     * If it's a partial or relative path, don't continue pointlessly.  - FM
     */
    if (!strncmp(*AllocatedString, "..", 2) ||
	!strncmp(*AllocatedString, "./", 2)) {
	return GotHost;
    }

    /*
     * Make a clean copy of the string, and trim off the path if one is
     * present, but save the information so we can restore the path after
     * filling in the Host[:port] field.  - FM
     */
    StrAllocCopy(Str, *AllocatedString);
    if ((Path = strchr(Str, '/')) != NULL) {
	/*
	 * Have a path.  Any fragment should already be included in Path.  - FM
	 */
	*Path = '\0';
    } else {
	/*
	 * No path, so check for a fragment and trim that, to be restored after
	 * filling in the Host[:port] field.  - FM
	 */
	Fragment = trimPoundSelector(Str);
    }

    /*
     * If the potential host string has a colon, assume it begins a port field,
     * and trim it off, but save the information so we can restore the port
     * field after filling in the host field.  - FM
     */
    if ((StrColon = strrchr(Str, ':')) != NULL &&
	isdigit(UCH(StrColon[1]))) {
	if (StrColon == Str) {
	    FREE(Str);
	    return GotHost;
	}
	*StrColon = '\0';
    }

    /*
     * Do a DNS test on the potential host field as presently trimmed.  - FM
     */
    StrAllocCopy(host, Str);
    HTUnEscape(host);
    if (LYCursesON) {
	StrAllocCopy(MsgStr, WWW_FIND_MESSAGE);
	StrAllocCat(MsgStr, host);
	StrAllocCat(MsgStr, FIRST_SEGMENT);
	HTProgress(MsgStr);
    } else if (Startup && !dump_output_immediately) {
	fprintf(stdout, "%s '%s'%s\r\n", WWW_FIND_MESSAGE, host, FIRST_SEGMENT);
    }
#ifdef INET6
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    error = getaddrinfo(host, "80", &hints, &res);

    if (!error && res)
#else
    if (LYGetHostByName(host) != NULL)
#endif /* INET6 */
    {
	/*
	 * Clear any residual interrupt.  - FM
	 */
	if (LYCursesON && HTCheckForInterrupt()) {
	    CTRACE((tfp,
		    "LYExpandHostForURL: Ignoring interrupt because '%s' resolved.\n",
		    host));
	}

	/*
	 * Return success.  - FM
	 */
	GotHost = TRUE;
	FREE(host);
	FREE(Str);
	FREE(MsgStr);
	return GotHost;
    } else if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED)) {
	/*
	 * Give the user chance to interrupt lookup cycles.  - KW & FM
	 */
	CTRACE((tfp,
		"LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
		host));

	/*
	 * Return failure.  - FM
	 */
	FREE(host);
	FREE(Str);
	FREE(MsgStr);
	return FALSE;
    }

    /*
     * Set the first prefix, making it a zero-length string if the list is NULL
     * or if the potential host field ends with a dot.  - FM
     */
    StartP = ((prefix_list && Str[strlen(Str) - 1] != '.')
	      ? prefix_list
	      : "");
    /*
     * If we have a prefix, but the allocated string is one of the common host
     * prefixes, make our prefix a zero-length string.  - FM
     */
    if (*StartP && *StartP != '.') {
	if (!strncasecomp(*AllocatedString, "www.", 4) ||
	    !strncasecomp(*AllocatedString, "ftp.", 4) ||
	    !strncasecomp(*AllocatedString, "gopher.", 7) ||
	    !strncasecomp(*AllocatedString, "wais.", 5) ||
	    !strncasecomp(*AllocatedString, "cso.", 4) ||
	    !strncasecomp(*AllocatedString, "ns.", 3) ||
	    !strncasecomp(*AllocatedString, "ph.", 3) ||
	    !strncasecomp(*AllocatedString, "finger.", 7) ||
	    !strncasecomp(*AllocatedString, "news.", 5) ||
	    !strncasecomp(*AllocatedString, "nntp.", 5)) {
	    StartP = "";
	}
    }
    while ((*StartP) && (WHITE(*StartP) || *StartP == ',')) {
	StartP++;		/* Skip whitespace and separators */
    }
    EndP = StartP;
    while (*EndP && !WHITE(*EndP) && *EndP != ',') {
	EndP++;			/* Find separator */
    }
    LYstrncpy(DomainPrefix, StartP, (EndP - StartP));

    /*
     * Test each prefix with each suffix.  - FM
     */
    do {
	/*
	 * Set the first suffix, making it a zero-length string if the list is
	 * NULL or if the potential host field begins with a dot.  - FM
	 */
	StartS = ((suffix_list && *Str != '.')
		  ? suffix_list
		  : "");
	while ((*StartS) && (WHITE(*StartS) || *StartS == ',')) {
	    StartS++;		/* Skip whitespace and separators */
	}
	EndS = StartS;
	while (*EndS && !WHITE(*EndS) && *EndS != ',') {
	    EndS++;		/* Find separator */
	}
	LYstrncpy(DomainSuffix, StartS, (EndS - StartS));

	/*
	 * Create domain names and do DNS tests.  - FM
	 */
	do {
	    StrAllocCopy(Host, DomainPrefix);
	    StrAllocCat(Host, ((*Str == '.') ? (Str + 1) : Str));
	    if (Host[strlen(Host) - 1] == '.') {
		Host[strlen(Host) - 1] = '\0';
	    }
	    StrAllocCat(Host, DomainSuffix);
	    if ((HostColon = strrchr(Host, ':')) != NULL &&
		isdigit(UCH(HostColon[1]))) {
		*HostColon = '\0';
	    }
	    StrAllocCopy(host, Host);
	    HTUnEscape(host);
	    if (LYCursesON) {
		StrAllocCopy(MsgStr, WWW_FIND_MESSAGE);
		StrAllocCat(MsgStr, host);
		StrAllocCat(MsgStr, GUESSING_SEGMENT);
		HTProgress(MsgStr);
	    } else if (Startup && !dump_output_immediately) {
		fprintf(stdout, "%s '%s'%s\n", WWW_FIND_MESSAGE, host, GUESSING_SEGMENT);
	    }
	    GotHost = (BOOL) (LYGetHostByName(host) != NULL);
	    if (HostColon != NULL) {
		*HostColon = ':';
	    }
	    if (GotHost == FALSE) {
		/*
		 * Give the user chance to interrupt lookup cycles.  - KW
		 */
		if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED)) {
		    CTRACE((tfp,
			    "LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
			    host));
		    FREE(Str);
		    FREE(MsgStr);
		    FREE(Host);
		    FREE(host);
		    return FALSE;	/* We didn't find a valid name. */
		}

		/*
		 * Advance to the next suffix, or end of suffix list.  - FM
		 */
		StartS = ((*EndS == '\0') ? EndS : (EndS + 1));
		while ((*StartS) && (WHITE(*StartS) || *StartS == ',')) {
		    StartS++;	/* Skip whitespace and separators */
		}
		EndS = StartS;
		while (*EndS && !WHITE(*EndS) && *EndS != ',') {
		    EndS++;	/* Find separator */
		}
		LYstrncpy(DomainSuffix, StartS, (EndS - StartS));
	    }
	} while ((GotHost == FALSE) && (*DomainSuffix != '\0'));

	if (GotHost == FALSE) {
	    /*
	     * Advance to the next prefix, or end of prefix list.  - FM
	     */
	    StartP = ((*EndP == '\0') ? EndP : (EndP + 1));
	    while ((*StartP) && (WHITE(*StartP) || *StartP == ',')) {
		StartP++;	/* Skip whitespace and separators */
	    }
	    EndP = StartP;
	    while (*EndP && !WHITE(*EndP) && *EndP != ',') {
		EndP++;		/* Find separator */
	    }
	    LYstrncpy(DomainPrefix, StartP, (EndP - StartP));
	}
    } while ((GotHost == FALSE) && (*DomainPrefix != '\0'));

    /*
     * If a test passed, restore the port field if we had one and there is no
     * colon in the expanded host, and the path if we had one, and reallocate
     * the original string with the expanded Host[:port] field included.  - FM
     */
    if (GotHost) {
	if (StrColon && strchr(Host, ':') == NULL) {
	    *StrColon = ':';
	    StrAllocCat(Host, StrColon);
	}
	if (Path) {
	    *Path = '/';
	    StrAllocCat(Host, Path);
	} else if (Fragment) {
	    StrAllocCat(Host, "/");
	    restorePoundSelector(Fragment);
	    StrAllocCat(Host, Fragment);
	}
	StrAllocCopy(*AllocatedString, Host);
    }

    /*
     * Clear any residual interrupt.  - FM
     */
    if (LYCursesON && HTCheckForInterrupt()) {
	CTRACE((tfp,
		"LYExpandHostForURL: Ignoring interrupt because '%s' %s.\n",
		host,
		(GotHost ? "resolved" : "timed out")));
    }

    /*
     * Clean up and return the last test result.  - FM
     */
    FREE(Str);
    FREE(MsgStr);
    FREE(Host);
    FREE(host);
    return GotHost;
}

/*
 * This function rewrites and reallocates a previously allocated string that
 * begins with an Internet host name so that the string begins with its guess
 * of the scheme based on the first field of the host name, or the default
 * scheme if no guess was made, and returns TRUE, otherwise it does not modify
 * the string and returns FALSE.  It also returns FALSE without modifying the
 * string if the default_scheme argument was NULL or zero-length and no guess
 * was made.  - FM
 */
BOOLEAN LYAddSchemeForURL(char **AllocatedString,
			  const char *default_scheme)
{
    char *Str = NULL;
    BOOLEAN GotScheme = FALSE;

    /*
     * If we were passed a NULL or zero-length string, don't continue
     * pointlessly.  - FM
     */
    if (!(*AllocatedString) || *AllocatedString[0] == '\0') {
	return GotScheme;
    }

    /*
     * Try to guess the appropriate scheme. - FM
     */
    if (0 == strncasecomp(*AllocatedString, "www", 3)) {
	/*
	 * This could be either http or https, so check the default and
	 * otherwise use "http".  - FM
	 */
	if (default_scheme != NULL &&
	    NULL != strstr(default_scheme, "http")) {
	    StrAllocCopy(Str, default_scheme);
	} else {
	    StrAllocCopy(Str, "http://");
	}
	GotScheme = TRUE;

    } else if (0 == strncasecomp(*AllocatedString, "ftp", 3)) {
	StrAllocCopy(Str, "ftp://");
	GotScheme = TRUE;

    } else if (0 == strncasecomp(*AllocatedString, "gopher", 6)) {
	StrAllocCopy(Str, "gopher://");
	GotScheme = TRUE;

    } else if (0 == strncasecomp(*AllocatedString, "wais", 4)) {
	StrAllocCopy(Str, "wais://");
	GotScheme = TRUE;

    } else if (0 == strncasecomp(*AllocatedString, "cso", 3) ||
	       0 == strncasecomp(*AllocatedString, "ns.", 3) ||
	       0 == strncasecomp(*AllocatedString, "ph.", 3)) {
	StrAllocCopy(Str, "cso://");
	GotScheme = TRUE;

    } else if (0 == strncasecomp(*AllocatedString, "finger", 6)) {
	StrAllocCopy(Str, "finger://");
	GotScheme = TRUE;

    } else if (0 == strncasecomp(*AllocatedString, "news", 4)) {
	/*
	 * This could be either news, snews, or nntp, so check the default, and
	 * otherwise use news.  - FM
	 */
	if ((default_scheme != NULL) &&
	    (NULL != strstr(default_scheme, "news") ||
	     NULL != strstr(default_scheme, "nntp"))) {
	    StrAllocCopy(Str, default_scheme);
	} else {
	    StrAllocCopy(Str, "news://");
	}
	GotScheme = TRUE;

    } else if (0 == strncasecomp(*AllocatedString, "nntp", 4)) {
	StrAllocCopy(Str, "nntp://");
	GotScheme = TRUE;

    }

    /*
     * If we've make a guess, use it.  Otherwise, if we were passed a default
     * scheme prefix, use that.  - FM
     */
    if (GotScheme == TRUE) {
	StrAllocCat(Str, *AllocatedString);
	StrAllocCopy(*AllocatedString, Str);
	FREE(Str);
	return GotScheme;

    } else if (non_empty(default_scheme)) {
	StrAllocCopy(Str, default_scheme);
	GotScheme = TRUE;
	StrAllocCat(Str, *AllocatedString);
	StrAllocCopy(*AllocatedString, Str);
	FREE(Str);
	return GotScheme;
    }

    return GotScheme;
}

/*
 * This function expects an absolute Unix or VMS SHELL path spec as an
 * allocated string, simplifies it, and trims out any residual relative
 * elements.  It also checks whether the path had a terminal slash, and if it
 * didn't, makes sure that the simplified path doesn't either.  If it's a
 * directory, our convention is to exclude "Up to parent" links when a terminal
 * slash is present.  - FM
 */
void LYTrimRelFromAbsPath(char *path)
{
    char *cp;
    int i;
    BOOL TerminalSlash;

    /*
     * Make sure we have a pointer to an absolute path.  - FM
     */
    if (path == NULL || !LYIsPathSep(*path))
	return;

    /*
     * Check whether the path has a terminal slash.  - FM
     */
    TerminalSlash = (BOOL) (LYIsPathSep(path[(strlen(path) - 1)]));

    /*
     * Simplify the path and then do any necessary trimming.  - FM
     */
    HTSimplify(path);
    cp = path;
    while (cp[1] == '.') {
	if (cp[2] == '\0') {
	    /*
	     * Eliminate trailing dot.  - FM
	     */
	    cp[1] = '\0';
	} else if (LYIsPathSep(cp[2])) {
	    /*
	     * Skip over the "/." of a "/./".  - FM
	     */
	    cp += 2;
	} else if (cp[2] == '.' && cp[3] == '\0') {
	    /*
	     * Eliminate trailing dotdot.  - FM
	     */
	    cp[1] = '\0';
	} else if (cp[2] == '.' && cp[3] == '/') {
	    /*
	     * Skip over the "/.." of a "/../".  - FM
	     */
	    cp += 3;
	} else {
	    /*
	     * Done trimming.  - FM
	     */
	    break;
	}
    }

    /*
     * Load any shifts into path, and eliminate any terminal slash created by
     * HTSimplify() or our walk, but not present originally.  - FM
     */
    if (cp > path) {
	for (i = 0; cp[i] != '\0'; i++)
	    path[i] = cp[i];
	path[i] = '\0';
    }
    if (TerminalSlash == FALSE) {
	LYTrimPathSep(path);
    }
}

/*
 * Example Client-Side Include interface.
 *
 * This is called from SGML.c and simply returns markup for reporting the URL
 * of the document being loaded if a comment begins with "<!--#lynxCSI".  The
 * markup will be included as if it were in the document.  Move this function
 * to a separate module for doing this kind of thing seriously, someday.  - FM
 */
void LYDoCSI(char *url,
	     const char *comment,
	     char **csi)
{
    const char *cp = comment;

    if (cp == NULL)
	return;

    if (strncmp(cp, "!--#", 4))
	return;

    cp += 4;
    if (!strncasecomp(cp, "lynxCSI", 7)) {
	StrAllocCat(*csi, "\n<p align=\"center\">URL: ");
	StrAllocCat(*csi, url);
	StrAllocCat(*csi, "</p>\n\n");
    }

    return;
}

#ifdef VMS
/*
 * Define_VMSLogical -- Fote Macrides 04-Apr-1995
 * Define VMS logicals in the process table.
 */
void Define_VMSLogical(char *LogicalName,
		       char *LogicalValue)
{
    $DESCRIPTOR(lname, "");
    $DESCRIPTOR(lvalue, "");
    $DESCRIPTOR(ltable, "LNM$PROCESS");

    if (!LogicalName || *LogicalName == '\0')
	return;

    lname.dsc$w_length = strlen(LogicalName);
    lname.dsc$a_pointer = LogicalName;

    if (!LogicalValue || *LogicalValue == '\0') {
	lib$delete_logical(&lname, &ltable);
	return;
    }

    lvalue.dsc$w_length = strlen(LogicalValue);
    lvalue.dsc$a_pointer = LogicalValue;
    lib$set_logical(&lname, &lvalue, &ltable, 0, 0);
    return;
}
#endif /* VMS */

#ifdef LY_FIND_LEAKS
static void LYHomeDir_free(void)
{
    FREE(HomeDir);
}
#endif /* LY_FIND_LEAKS */

char *Current_Dir(char *pathname)
{
    char *result;

#ifdef HAVE_GETCWD
    result = getcwd(pathname, LY_MAXPATH);
#else
    result = getwd(pathname);
#endif /* NO_GETCWD */
    if (result == 0)
	strcpy(pathname, ".");
    return pathname;
}

/*
 * Verify that the given path refers to an existing directory, returning the
 * string if the directory exists.  If not, return null.
 */
static char *CheckDir(char *path)
{
    struct stat stat_info;

    if (!LYisAbsPath(path)
	|| (HTStat(path, &stat_info) < 0
	    || !S_ISDIR(stat_info.st_mode))) {
	path = NULL;
    }
    return path;
}

/*
 * Lookup various possibilities for $HOME, and check that the directory exists.
 */
static char *HomeEnv(void)
{
    char *result = CheckDir(LYGetEnv("HOME"));

#if defined (USE_DOS_DRIVES)
    if (result == 0) {
	char *head;
	char *leaf;
	static char *temp = NULL;

	/* Windows 2000 */
	if ((result = LYGetEnv("USERPROFILE")) != 0) {
	    HTSprintf0(&temp, "%s%sMy Documents", result, PATHSEP_STR);
	    result = CheckDir(temp);
	}
	/* NT4 */
	if (result == 0) {
	    if ((head = LYGetEnv("HOMEDRIVE")) != 0) {
		if ((leaf = LYGetEnv("HOMEPATH")) != 0) {
		    HTSprintf0(&temp, "%s%s%s", head, PATHSEP_STR, leaf);
		    result = CheckDir(temp);
		}
	    }
	}
	/* General M$ */
	if (result == 0)
	    result = CheckDir(LYGetEnv("TEMP"));
	if (result == 0)
	    result = CheckDir(LYGetEnv("TMP"));
	if (result == 0) {
	    if ((head = LYGetEnv("SystemDrive")) != 0) {
		HTSprintf0(&temp, "%s%s", head, PATHSEP_STR);
		result = CheckDir(temp);
	    }
	}
	if (result == 0)
	    result = CheckDir("C:" PATHSEP_STR);
    }
#endif

    return result;
}

const char *Home_Dir(void)
{
    static const char *homedir = NULL;
    char *cp = NULL;

    if (homedir == NULL) {
	if ((cp = HomeEnv()) == NULL) {
#ifdef VMS
	    if ((cp = LYGetEnv("SYS$LOGIN")) == NULL
		&& (cp = LYGetEnv("SYS$SCRATCH")) == NULL) {
		cp = "sys$scratch:";
	    }
	    StrAllocCopy(HomeDir, cp);
#else
#ifdef UNIX
#ifdef HAVE_UTMP
	    /*
	     * One could use getlogin() and getpwnam() here instead.
	     */
	    struct passwd *pw = getpwuid(geteuid());

	    if (pw && pw->pw_dir) {
		StrAllocCopy(HomeDir, pw->pw_dir);
	    } else
#endif
	    {
		/*
		 * Use /tmp; it should be writable.
		 */
		StrAllocCopy(HomeDir, "/tmp");
	    }
#endif
#endif /* VMS */
	} else {
	    StrAllocCopy(HomeDir, cp);
	}
	homedir = (const char *) HomeDir;
#ifdef LY_FIND_LEAKS
	atexit(LYHomeDir_free);
#endif
    }
    if (homedir == NULL) {
	printf("%s\n", gettext("Cannot find HOME directory"));
	exit_immediately(EXIT_FAILURE);
    }
    return homedir;
}

/*
 * Return a pointer to the final leaf of the given pathname, If no pathname
 * separators are found, returns the original pathname.  The leaf may be
 * empty.
 */
char *LYPathLeaf(char *pathname)
{
    char *leaf;

#ifdef UNIX
    if ((leaf = strrchr(pathname, '/')) != 0) {
	leaf++;
    }
#else
#ifdef VMS
    if ((leaf = strrchr(pathname, ']')) == 0)
	leaf = strrchr(pathname, ':');
    if (leaf != 0)
	leaf++;
#else
    int n;

    for (leaf = 0, n = strlen(pathname) - 1; n >= 0; n--) {
	if (strchr("\\/:", pathname[n]) != 0) {
	    leaf = pathname + n + 1;
	    break;
	}
    }
#endif
#endif
    return (leaf != 0) ? leaf : pathname;
}

/*
 * This function checks the acceptability of file paths that are intended to be
 * off the home directory.  The file path should be passed in fbuffer, together
 * with the size of the buffer.  The function simplifies the file path, and if
 * it is acceptable, loads it into fbuffer and returns TRUE.  Otherwise, it
 * does not modify fbuffer and returns FALSE.  If a subdirectory is present and
 * the path does not begin with "./", that is prefixed to make the situation
 * clear.  - FM
 */
BOOLEAN LYPathOffHomeOK(char *fbuffer,
			size_t fbuffer_size)
{
    char *file = NULL;
    char *cp, *cp1;

    /*
     * Make sure we have an fbuffer and a string in it.  - FM
     */
    if (!fbuffer || fbuffer_size < 2 || fbuffer[0] == '\0') {
	return (FALSE);
    }
    StrAllocCopy(file, fbuffer);
    cp = file;

    /*
     * Check for an inappropriate reference to the home directory, and correct
     * it if we can.  - FM
     */
#ifdef VMS
    if (!strncasecomp(cp, "sys$login", 9)) {
	if (*(cp + 9) == '\0') {
	    /*
	     * Reject "sys$login".  - FM
	     */
	    FREE(file);
	    return (FALSE);
	}
	if (*(cp + 9) == ':') {
	    cp += 10;
	    if (*cp == '\0') {
		/*
		 * Reject "sys$login:".  Otherwise, we have converted
		 * "sys$login:file" to "file", or have left a strange path for
		 * VMS as it was originally.  - FM
		 */
		FREE(file);
		return (FALSE);
	    }
	}
    }
#endif /* VMS */
    if (*cp == '~') {
	if (*(cp + 1) == '/') {
	    if (*(cp + 2) != '\0') {
		if ((cp1 = strchr((cp + 2), '/')) != NULL) {
		    /*
		     * Convert "~/subdir(s)/file" to "./subdir(s)/file".  - FM
		     */
		    *cp = '.';
		} else {
		    /*
		     * Convert "~/file" to "file".  - FM
		     */
		    cp += 2;
		}
	    } else {
		/*
		 * Reject "~/".  - FM
		 */
		FREE(file);
		return (FALSE);
	    }
	} else if ((*(cp + 1) != '\0') &&
		   (cp1 = strchr((cp + 1), '/')) != NULL) {
	    cp = (cp1 - 1);
	    if (*(cp + 2) != '\0') {
		if ((cp1 = strchr((cp + 2), '/')) != NULL) {
		    /*
		     * Convert "~user/subdir(s)/file" to "./subdir(s)/file". 
		     * If user is someone else, we covered a spoof.  Otherwise,
		     * we simplified.  - FM
		     */
		    *cp = '.';
		} else {
		    /*
		     * Convert "~user/file" to "file".  - FM
		     */
		    cp += 2;
		}
	    } else {
		/*
		 * Reject "~user/".  - FM
		 */
		FREE(file);
		return (FALSE);
	    }
	} else {
	    /*
	     * Reject "~user".  - FM
	     */
	    FREE(file);
	    return (FALSE);
	}
    }
#ifdef VMS
    /*
     * Check for VMS path specs, and reject if still present.  - FM
     */
    if (strchr(cp, ':') != NULL || strchr(cp, ']') != NULL) {
	FREE(file);
	return (FALSE);
    }
#endif /* VMS */

    /*
     * Check for a URL or absolute path, and reject if present.  - FM
     */
    if (is_url(cp) || LYIsPathSep(*cp)) {
	FREE(file);
	return (FALSE);
    }

    /*
     * Simplify it.  - FM
     */
    HTSimplify(cp);

    /*
     * Check if it has a pointless "./".  - FM
     */
    if (!strncmp(cp, "./", 2)) {
	if ((cp1 = strchr((cp + 2), '/')) == NULL) {
	    cp += 2;
	}
    }

    /*
     * Check for spoofing.  - FM
     */
    if (*cp == '\0'
	|| LYIsPathSep(*cp)
	|| LYIsPathSep(cp[(strlen(cp) - 1)])
	|| strstr(cp, "..") != NULL
	|| !strcmp(cp, ".")) {
	FREE(file);
	return (FALSE);
    }

    /*
     * Load what we have at this point into fbuffer, trimming if too long, and
     * claim it's OK.  - FM
     */
    if (fbuffer_size > 3 && strncmp(cp, "./", 2) && strchr(cp, '/')) {
	/*
	 * We have a subdirectory and no lead "./", so prefix it to make the
	 * situation clear.  - FM
	 */
	strcpy(fbuffer, "./");
	if (strlen(cp) > (fbuffer_size - 3))
	    cp[(fbuffer_size - 3)] = '\0';
	strcat(fbuffer, cp);
    } else {
	if (strlen(cp) > (fbuffer_size - 1))
	    cp[(fbuffer_size - 1)] = '\0';
	strcpy(fbuffer, cp);
    }
    FREE(file);
    return (TRUE);
}

/*
 * This function appends fname to the home path and returns the full path and
 * filename.  The fname string can be just a filename (e.g.,
 * "lynx_bookmarks.html"), or include a subdirectory off the home directory, in
 * which case fname should begin with "./" (e.g., ./BM/lynx_bookmarks.html) Use
 * LYPathOffHomeOK() to check and/or fix up fname before calling this function. 
 * On VMS, the resultant full path and filename are converted to VMS syntax.  -
 * FM
 */
void LYAddPathToHome(char *fbuffer,
		     size_t fbuffer_size,
		     const char *fname)
{
    char *home = NULL;
    const char *file = fname;
    int len;

    /*
     * Make sure we have a buffer.  - FM
     */
    if (!fbuffer)
	return;
    if (fbuffer_size < 2) {
	fbuffer[0] = '\0';
	return;
    }
    fbuffer[(fbuffer_size - 1)] = '\0';

    /*
     * Make sure we have a file name.  - FM
     */
    if (!file)
	file = "";

    /*
     * Set up home string and length.  - FM
     */
    StrAllocCopy(home, Home_Dir());

#ifdef VMS
#define NO_HOMEPATH "Error:"
#else
#define NO_HOMEPATH "/error"
#endif /* VMS */
    if (!non_empty(home))
	/*
	 * Home_Dir() has a bug if this ever happens.  - FM
	 */
	StrAllocCopy(home, NO_HOMEPATH);

    len = fbuffer_size - (strlen(home) + 1);
    if (len <= 0) {
	/*
	 * Buffer is smaller than or only big enough for the home path.  Load
	 * what fits of the home path and return.  This will fail, but we need
	 * something in the buffer.  - FM
	 */
	LYstrncpy(fbuffer, home, (fbuffer_size - 1));
	FREE(home);
	return;
    }
#ifdef VMS
    /*
     * Check whether we have a subdirectory path or just a filename.  - FM
     */
    if (!strncmp(file, "./", 2)) {
	/*
	 * We have a subdirectory path.  - FM
	 */
	if (home[strlen(home) - 1] == ']') {
	    /*
	     * We got the home directory, so convert it to SHELL syntax and
	     * append subdirectory path, then convert that to VMS syntax.  - FM
	     */
	    char *temp = NULL;

	    HTSprintf0(&temp, "%s%s", HTVMS_wwwName(home), (file + 1));
	    sprintf(fbuffer, "%.*s",
		    (fbuffer_size - 1), HTVMS_name("", temp));
	    FREE(temp);
	} else {
	    /*
	     * This will fail, but we need something in the buffer.  - FM
	     */
	    sprintf(fbuffer, "%s%.*s", home, len, file);
	}
    } else {
	/*
	 * We have a file in the home directory.  - FM
	 */
	sprintf(fbuffer, "%s%.*s", home, len, file);
    }
#else
    /*
     * Check whether we have a subdirectory path or just a filename.  - FM
     */
    sprintf(fbuffer, "%s/%.*s", home, len,
	    (strncmp(file, "./", 2) ? file : (file + 2)));
#endif /* VMS */
    FREE(home);
}

/*
 * Given a filename, concatenate it to the save-space pathname, unless it is
 * an absolute pathname.  If there is no save-space defined, use the home
 * directory. Return a new string with the result.
 */
char *LYAddPathToSave(char *fname)
{
    char *result = NULL;

    if (LYisAbsPath(fname)) {
	StrAllocCopy(result, fname);
    } else {
	if (lynx_save_space != NULL) {
	    StrAllocCopy(result, lynx_save_space);
	} else {
	    char temp[LY_MAXPATH];

	    LYAddPathToHome(temp, sizeof(temp), fname);
	    StrAllocCopy(result, temp);
	}
    }
    return result;
}

/*
 * This function takes a string in the format
 *	"Mon, 01-Jan-96 13:45:35 GMT" or
 *	"Mon,  1 Jan 1996 13:45:35 GMT"" or
 *	"dd-mm-yyyy"
 * as an argument, and returns its conversion to clock format (seconds since
 * 00:00:00 Jan 1 1970), or 0 if the string doesn't match the expected pattern. 
 * It also returns 0 if the time is in the past and the "absolute" argument is
 * FALSE.  It is intended for handling 'expires' strings in Version 0 cookies
 * homologously to 'max-age' strings in Version 1 cookies, for which 0 is the
 * minimum, and greater values are handled as '[max-age seconds] + time(NULL)'. 
 * If "absolute" if TRUE, we return the clock format value itself, but if
 * anything goes wrong when parsing the expected patterns, we still return 0. 
 * - FM
 */
time_t LYmktime(char *string,
		BOOL absolute)
{
    char *s;
    time_t now, clock2;
    int day, month, year, hour, minutes, seconds;
    char *start;
    char temp[8];

    /*
     * Make sure we have a string to parse.  - FM
     */
    if (!non_empty(string))
	return (0);
    s = string;
    CTRACE((tfp, "LYmktime: Parsing '%s'\n", s));

    /*
     * Skip any lead alphabetic "Day, " field and seek a numeric day field.  -
     * FM
     */
    while (*s != '\0' && !isdigit(UCH(*s)))
	s++;
    if (*s == '\0')
	return (0);

    /*
     * Get the numeric day and convert to an integer.  - FM
     */
    start = s;
    while (*s != '\0' && isdigit(UCH(*s)))
	s++;
    if (*s == '\0' || (s - start) > 2)
	return (0);
    LYstrncpy(temp, start, (int) (s - start));
    day = atoi(temp);
    if (day < 1 || day > 31)
	return (0);

    /*
     * Get the month string and convert to an integer.  - FM
     */
    while (*s != '\0' && !isalnum(UCH(*s)))
	s++;
    if (*s == '\0')
	return (0);
    start = s;
    while (*s != '\0' && isalnum(UCH(*s)))
	s++;
    if ((*s == '\0') ||
	(s - start) < (isdigit(UCH(*(s - 1))) ? 2 : 3) ||
	(s - start) > (isdigit(UCH(*(s - 1))) ? 2 : 9))
	return (0);
    LYstrncpy(temp, start, (isdigit(UCH(*(s - 1))) ? 2 : 3));
    switch (TOUPPER(temp[0])) {
    case '0':
    case '1':
	month = atoi(temp);
	if (month < 1 || month > 12) {
	    return (0);
	}
	break;
    case 'A':
	if (!strcasecomp(temp, "Apr")) {
	    month = 4;
	} else if (!strcasecomp(temp, "Aug")) {
	    month = 8;
	} else {
	    return (0);
	}
	break;
    case 'D':
	if (!strcasecomp(temp, "Dec")) {
	    month = 12;
	} else {
	    return (0);
	}
	break;
    case 'F':
	if (!strcasecomp(temp, "Feb")) {
	    month = 2;
	} else {
	    return (0);
	}
	break;
    case 'J':
	if (!strcasecomp(temp, "Jan")) {
	    month = 1;
	} else if (!strcasecomp(temp, "Jun")) {
	    month = 6;
	} else if (!strcasecomp(temp, "Jul")) {
	    month = 7;
	} else {
	    return (0);
	}
	break;
    case 'M':
	if (!strcasecomp(temp, "Mar")) {
	    month = 3;
	} else if (!strcasecomp(temp, "May")) {
	    month = 5;
	} else {
	    return (0);
	}
	break;
    case 'N':
	if (!strcasecomp(temp, "Nov")) {
	    month = 11;
	} else {
	    return (0);
	}
	break;
    case 'O':
	if (!strcasecomp(temp, "Oct")) {
	    month = 10;
	} else {
	    return (0);
	}
	break;
    case 'S':
	if (!strcasecomp(temp, "Sep")) {
	    month = 9;
	} else {
	    return (0);
	}
	break;
    default:
	return (0);
    }

    /*
     * Get the numeric year string and convert to an integer.  - FM
     */
    while (*s != '\0' && !isdigit(UCH(*s)))
	s++;
    if (*s == '\0')
	return (0);
    start = s;
    while (*s != '\0' && isdigit(UCH(*s)))
	s++;
    if ((s - start) == 4) {
	LYstrncpy(temp, start, 4);
    } else if ((s - start) == 2) {
	now = time(NULL);
	/*
	 * Assume that received 2-digit dates >= 70 are 19xx; others
	 * are 20xx.  Only matters when dealing with broken software
	 * (HTTP server or web page) which is not Y2K compliant.  The
	 * line is drawn on a best-guess basis; it is impossible for
	 * this to be completely accurate because it depends on what
	 * the broken sender software intends.  (This totally breaks
	 * in 2100 -- setting up the next crisis...) - BL
	 */
	if (atoi(start) >= 70)
	    LYstrncpy(temp, "19", 2);
	else
	    LYstrncpy(temp, "20", 2);
	strncat(temp, start, 2);
	temp[4] = '\0';
    } else {
	return (0);
    }
    year = atoi(temp);

    /*
     * Get the numeric hour string and convert to an integer.  - FM
     */
    while (*s != '\0' && !isdigit(UCH(*s)))
	s++;
    if (*s == '\0') {
	hour = 0;
	minutes = 0;
	seconds = 0;
    } else {
	start = s;
	while (*s != '\0' && isdigit(UCH(*s)))
	    s++;
	if (*s != ':' || (s - start) > 2)
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
	hour = atoi(temp);

	/*
	 * Get the numeric minutes string and convert to an integer.  - FM
	 */
	while (*s != '\0' && !isdigit(UCH(*s)))
	    s++;
	if (*s == '\0')
	    return (0);
	start = s;
	while (*s != '\0' && isdigit(UCH(*s)))
	    s++;
	if (*s != ':' || (s - start) > 2)
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
	minutes = atoi(temp);

	/*
	 * Get the numeric seconds string and convert to an integer.  - FM
	 */
	while (*s != '\0' && !isdigit(UCH(*s)))
	    s++;
	if (*s == '\0')
	    return (0);
	start = s;
	while (*s != '\0' && isdigit(UCH(*s)))
	    s++;
	if (*s == '\0' || (s - start) > 2)
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
	seconds = atoi(temp);
    }

    /*
     * Convert to clock format (seconds since 00:00:00 Jan 1 1970), but then
     * zero it if it's in the past and "absolute" is not TRUE.  - FM
     */
    month -= 3;
    if (month < 0) {
	month += 12;
	year--;
    }
    day += (year - 1968) * 1461 / 4;
    day += ((((month * 153) + 2) / 5) - 672);
    clock2 = (time_t) ((day * 60 * 60 * 24) +
		       (hour * 60 * 60) +
		       (minutes * 60) +
		       seconds);
    if (absolute == FALSE && (long) (time((time_t *) 0) - clock2) >= 0)
	clock2 = (time_t) 0;
    if (clock2 > 0)
	CTRACE((tfp, "LYmktime: clock=%ld, ctime=%s",
		(long) clock2,
		ctime(&clock2)));

    return (clock2);
}

#if !defined(HAVE_PUTENV) && !defined(_WINDOWS)
/*
 * No putenv on the NeXT so we use this code instead!
 */

/* Copyright (C) 1991 Free Software Foundation, Inc.
This file is part of the GNU C Library.

The GNU C Library is free software; you can  redistribute it and/or
modify it under the terms of the GNU Library General  Public License as
published by the Free Software Foundation; either  version 2 of the
License, or (at your option) any later version.

The GNU C Library is distributed in the hope that it  will be useful,
but WITHOUT ANY WARRANTY; without even the implied  warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library  General Public
License along with the GNU C Library; see the file  COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 675  Mass Ave,
Cambridge, MA 02139, USA.  */

#if defined(STDC_HEADERS) || defined(USG)
#include <string.h>
#else /* Not (STDC_HEADERS or USG): */
#include <strings.h>
#endif /* STDC_HEADERS or USG */

#ifndef NULL
#define NULL 0
#endif /* !NULL */

extern char **environ;

/*
 * Put STRING, which is of the form "NAME=VALUE", in the environment.
 */
int putenv(const char *string)
{
    char *name_end = strchr(string, '=');
    register size_t size;
    register char **ep;

    if (name_end == NULL) {
	/* Remove the variable from the environment.  */
	size = strlen(string);
	for (ep = environ; *ep != NULL; ++ep)
	    if (!strncmp(*ep, string, size) && (*ep)[size] == '=') {
		while (ep[1] != NULL) {
		    ep[0] = ep[1];
		    ++ep;
		}
		*ep = NULL;
		return 0;
	    }
    }

    size = 0;
    for (ep = environ; *ep != NULL; ++ep)
	if (!strncmp(*ep, string, name_end - string) &&
	    (*ep)[name_end - string] == '=')
	    break;
	else
	    ++size;

    if (*ep == NULL) {
	static char **last_environ = NULL;
	char **new_environ = (char **) malloc((size + 2) * sizeof(char *));

	if (new_environ == NULL)
	    return -1;
	(void) memcpy((char *) new_environ, (char *) environ, size * sizeof(char *));

	new_environ[size] = (char *) string;
	new_environ[size + 1] = NULL;
	if (last_environ != NULL)
	    FREE(last_environ);
	last_environ = new_environ;
	environ = new_environ;
    } else
	*ep = (char *) string;

    return 0;
}
#endif /* !HAVE_PUTENV */

#ifdef NEED_REMOVE
int remove(char *name)
{
    return unlink(name);
}
#endif

/*
 * Default, for single-user systems such as Cygwin and OS/2 EMX:
 */
#define IsOurFile(name) TRUE
#define OpenHiddenFile(name, mode) fopen(name, mode)

#if defined(MULTI_USER_UNIX)

#undef IsOurFile
#undef OpenHiddenFile

/*
 * Verify if this is really a file, not accessed by a link, except for the
 * special case of its directory being pointed to by a link from a directory
 * owned by root and not writable by other users.
 */
static BOOL IsOurFile(const char *name)
{
    struct stat data;

    if (lstat(name, &data) == 0
	&& S_ISREG(data.st_mode)
	&& data.st_nlink == 1
	&& data.st_uid == getuid()) {
	int linked = FALSE;

	/*
	 * ( If this is not a single-user system, the other user is presumed by
	 * some people busy trying to use a symlink attack on our files ;-)
	 */
#if defined(HAVE_LSTAT)
	char *path = 0;
	char *leaf;

	StrAllocCopy(path, name);
	do {
	    if ((leaf = LYPathLeaf(path)) != path)
		*--leaf = '\0';	/* write a null on the '/' */
	    if (lstat(*path ? path : "/", &data) != 0) {
		break;
	    }
	    /*
	     * If we find a symbolic link, it has to be in a directory that's
	     * protected.  Otherwise someone could have switched it to point
	     * to one of the real user's files.
	     */
	    if (S_ISLNK(data.st_mode)) {
		linked = TRUE;	/* could be link-to-link; doesn't matter */
	    } else if (S_ISDIR(data.st_mode)) {
		if (linked) {
		    linked = FALSE;
		    /*
		     * We assume that a properly-configured system has the
		     * unwritable directories owned by root.  This is not
		     * necessarily so (bin, news, etc., may), but the only
		     * uid we can count on is 0.  It would be nice to add a
		     * check for the gid also, but that wouldn't be
		     * portable.
		     */
		    if (data.st_uid != 0
			|| (data.st_mode & S_IWOTH) != 0) {
			linked = TRUE;	/* force an error-return */
			break;
		    }
		}
	    } else if (linked) {
		break;
	    }
	} while (leaf != path);
	FREE(path);
#endif
	return !linked;
    }
    return FALSE;
}

/*
 * Open a file that we don't want other users to see.
 */
static FILE *OpenHiddenFile(const char *name, const char *mode)
{
    FILE *fp = 0;
    struct stat data;
    BOOLEAN binary = strchr(mode, 'b') != 0;

#if defined(O_CREAT) && defined(O_EXCL)		/* we have fcntl.h or kindred? */
    /*
     * This is the preferred method for creating new files, since it ensures
     * that no one has an existing file or link that they happen to own.
     */
    if (*mode == 'w') {
	int fd = open(name, O_CREAT | O_EXCL | O_WRONLY, HIDE_CHMOD);

	if (fd < 0
	    && errno == EEXIST
	    && IsOurFile(name)) {
	    remove(name);
	    /* FIXME: there's a race at this point if directory is open */
	    fd = open(name, O_CREAT | O_EXCL | O_WRONLY, HIDE_CHMOD);
	}
	if (fd >= 0) {
#if defined(O_BINARY) && defined(__CYGWIN__)
	    if (binary)
		setmode(fd, O_BINARY);
#endif
	    fp = fdopen(fd, mode);
	}
    } else
#endif
    if (*mode == 'a') {
	if (IsOurFile(name)
	    && chmod(name, HIDE_CHMOD) == 0)
	    fp = fopen(name, mode);
	else if (lstat(name, &data) != 0)
	    fp = OpenHiddenFile(name, binary ? BIN_W : TXT_W);
	/*
	 * This is less stringent, but reasonably portable.  For new files, the
	 * umask will suffice; however if the file already exists we'll change
	 * permissions first, before opening it.  If the chmod fails because of
	 * some reason other than a non-existent file, there's no point in trying
	 * to open it.
	 *
	 * This won't work properly if the user is root, since the chmod succeeds.
	 */
    } else if (*mode != 'a') {
	mode_t save = umask(HIDE_UMASK);

	if (chmod(name, HIDE_CHMOD) == 0 || errno == ENOENT)
	    fp = fopen(name, mode);
	umask(save);
    }
    return fp;
}
#endif /* MULTI_USER_UNIX */

FILE *LYNewBinFile(const char *name)
{
#ifdef VMS
    FILE *fp = fopen(name, BIN_W, "mbc=32");

    chmod(name, HIDE_CHMOD);
#else
    FILE *fp = OpenHiddenFile(name, BIN_W);
#endif
    return fp;
}

FILE *LYNewTxtFile(const char *name)
{
    FILE *fp;

#ifdef VMS
    fp = fopen(name, TXT_W, "shr=get");
    chmod(name, HIDE_CHMOD);
#else
    SetDefaultMode(O_TEXT);

    fp = OpenHiddenFile(name, TXT_W);

    SetDefaultMode(O_BINARY);
#endif

    return fp;
}

FILE *LYAppendToTxtFile(const char *name)
{
    FILE *fp;

#ifdef VMS
    fp = fopen(name, TXT_A, "shr=get");
    chmod(name, HIDE_CHMOD);
#else
    SetDefaultMode(O_TEXT);

    fp = OpenHiddenFile(name, TXT_A);

    SetDefaultMode(O_BINARY);
#endif
    return fp;
}

#if defined(MULTI_USER_UNIX)
/*
 * Restore normal permissions to a copy of a file that we have created with
 * temp file restricted permissions.  The normal umask should apply for user
 * files.  - kw
 */
void LYRelaxFilePermissions(const char *name)
{
    mode_t mode;
    struct stat stat_buf;

    if (stat(name, &stat_buf) == 0 &&
	S_ISREG(stat_buf.st_mode) &&
	(mode = (stat_buf.st_mode & 0777)) == HIDE_CHMOD) {
	/*
	 * It looks plausible that this is a file we created with temp file
	 * paranoid permissions (and the umask wasn't even more restrictive
	 * when it was copied).  - kw
	 */
	mode_t save = umask(HIDE_UMASK);

	mode = ((mode & 0700) | 0066) & ~save;
	umask(save);
	chmod(name, mode);
    }
}
#endif

/*
 * Check if the given anchor has an associated file-cache.
 */
BOOLEAN LYCachedTemp(char *result,
		     char **cached)
{
    if (*cached) {
	LYstrncpy(result, *cached, LY_MAXPATH);
	FREE(*cached);
	if (LYCanReadFile(result)) {
	    remove(result);
	}
	return TRUE;
    }
    return FALSE;
}

#ifndef HAVE_MKDTEMP
#define mkdtemp(path) ((mktemp(path) != 0) && (mkdir(path, 0700) == 0))
#endif

/*
 * Open a temp-file, ensuring that it is unique, and not readable by other
 * users.
 *
 * The mode can be one of: "w", "a", "wb".
 */
FILE *LYOpenTemp(char *result,
		 const char *suffix,
		 const char *mode)
{
    FILE *fp = 0;
    BOOL txt = TRUE;
    char wrt = 'r';
    LY_TEMP *p;

    CTRACE((tfp, "LYOpenTemp(,%s,%s)\n", suffix, mode));
    if (result == 0)
	return 0;

    while (*mode != '\0') {
	switch (*mode++) {
	case 'w':
	    wrt = 'w';
	    break;
	case 'a':
	    wrt = 'a';
	    break;
	case 'b':
	    txt = FALSE;
	    break;
	default:
	    CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
	    return 0;
	}
    }

    /*
     * Verify if the given space looks secure enough.  Otherwise, make a
     * secure subdirectory of that.
     */
#if defined(MULTI_USER_UNIX) && (defined(HAVE_MKTEMP) || defined(HAVE_MKDTEMP))
    if (lynx_temp_subspace == 0) {
	BOOL make_it = FALSE;
	struct stat sb;

	if (lstat(lynx_temp_space, &sb) == 0
	    && S_ISDIR(sb.st_mode)) {
	    if (sb.st_uid != getuid()
		|| (sb.st_mode & (S_IWOTH | S_IWGRP)) != 0) {
		make_it = TRUE;
		CTRACE((tfp,
			"lynx_temp_space is not our directory %s owner %d mode %03o\n",
			lynx_temp_space, (int) sb.st_uid, (int) sb.st_mode & 0777));
	    }
	} else {
	    make_it = TRUE;
	    CTRACE((tfp, "lynx_temp_space is not a directory %s\n", lynx_temp_space));
	}
	if (make_it) {
	    int old_mask = umask(HIDE_UMASK);

	    StrAllocCat(lynx_temp_space, "lynxXXXXXXXXXX");
	    if (mkdtemp(lynx_temp_space) == 0) {
		printf("%s: %s\n", lynx_temp_space, LYStrerror(errno));
		exit_immediately(EXIT_FAILURE);
	    }
	    umask(old_mask);
	    lynx_temp_subspace = 1;
	    StrAllocCat(lynx_temp_space, "/");
	    CTRACE((tfp, "made subdirectory %s\n", lynx_temp_space));
	} else {
	    lynx_temp_subspace = -1;
	}
    }
#endif

    do {
	if (!fmt_tempname(result, lynx_temp_space, suffix))
	    return 0;
	if (txt) {
	    switch (wrt) {
	    case 'w':
		fp = LYNewTxtFile(result);
		break;
	    case 'a':
		fp = LYAppendToTxtFile(result);
		break;
	    }
	} else {
	    fp = LYNewBinFile(result);
	}
	/*
	 * If we get a failure to make a temporary file, don't bother to try a
	 * different name unless the failure was because the file already
	 * exists.
	 */
#ifdef EEXIST			/* FIXME (need a better test) in fcntl.h or unistd.h */
	if ((fp == 0) && (errno != EEXIST)) {
	    CTRACE((tfp, "... LYOpenTemp(%s) failed: %s\n",
		    result, LYStrerror(errno)));
	    return 0;
	}
#endif
    } while (fp == 0);

    if ((p = typecalloc(LY_TEMP)) != 0) {
	p->next = ly_temp;
	StrAllocCopy((p->name), result);
	p->file = fp;
	p->outs = (wrt != 'r');
	ly_temp = p;
    } else {
	outofmem(__FILE__, "LYOpenTemp");
    }

    CTRACE((tfp, "... LYOpenTemp(%s)\n", result));
    return fp;
}

/*
 * Reopen a temporary file
 */
FILE *LYReopenTemp(char *name)
{
    LY_TEMP *p;
    FILE *fp = 0;

    LYCloseTemp(name);
    if ((p = FindTempfileByName(name)) != 0) {
	fp = p->file = LYAppendToTxtFile(name);
    }
    return fp;
}

/*
 * Open a temp-file for writing, possibly re-using a previously used
 * name and file.
 * If a non-empty fname is given, it is reused if it indicates a file
 * previously registered as a temp file and, in case the file still
 * exists, if it looks like we can write to it safely.  Otherwise a
 * new temp file (with new name) will be generated and returned in fname.
 *
 * File permissions are set so that the file is not readable by unprivileged
 * other users.
 *
 * Suffix is only used if fname is not being reused.
 * The mode should be "w", others are possible (they may be passed on)
 * but probably don't make sense. - kw
 */
FILE *LYOpenTempRewrite(char *fname,
			const char *suffix,
			const char *mode)
{
    FILE *fp = 0;
    BOOL txt = TRUE;
    char wrt = 'r';
    BOOL registered = NO;
    BOOL writable_exists = NO;
    BOOL is_ours = NO;
    BOOL still_open = NO;
    LY_TEMP *p;
    struct stat stat_buf;

    CTRACE((tfp, "LYOpenTempRewrite(%s,%s,%s)\n", fname, suffix, mode));
    if (*fname == '\0')		/* first time, no filename yet */
	return (LYOpenTemp(fname, suffix, mode));

    if ((p = FindTempfileByName(fname)) != 0) {
	registered = YES;
	if (p->file != 0)
	    still_open = YES;
	CTRACE((tfp, "...used before%s\n", still_open ? ", still open!" : "."));
    }

    if (registered) {
#ifndef NO_GROUPS
	writable_exists = HTEditable(fname);	/* existing, can write */
#define CTRACE_EXISTS "exists and is writable, "
#else
	writable_exists = (BOOL) (stat(fname, &stat_buf) == 0);		/* existing, assume can write */
#define CTRACE_EXISTS "exists, "
#endif

	if (writable_exists) {
	    is_ours = IsOurFile(fname);
	}
	CTRACE((tfp, "...%s%s\n",
		writable_exists ? CTRACE_EXISTS : "",
		is_ours ? "is our file." : "is NOT our file."));
    }

    /*
     * Note that in cases where LYOpenTemp is called as fallback below, we
     * don't call LYRemoveTemp first.  That may be appropriate in some cases,
     * but not trying to remove a weird existing file seems safer and could
     * help diagnose an unusual situation.  (They may be removed anyway later.)
     */
    if (still_open) {
	/*
	 * This should probably not happen.  Make a new one.
	 */
	return (LYOpenTemp(fname, suffix, mode));
    } else if (!registered) {
	/*
	 * Not registered.  It should have been registered at one point though,
	 * otherwise we wouldn't be called like this.
	 */
	return (LYOpenTemp(fname, suffix, mode));
    } else if (writable_exists && !is_ours) {
	/*
	 * File exists, writable if we checked, but something is wrong with it.
	 */
	return (LYOpenTemp(fname, suffix, mode));
#ifndef NO_GROUPS
    } else if (!is_ours && (lstat(fname, &stat_buf) == 0)) {
	/*
	 * Exists but not writable, and something is wrong with it.
	 */
	return (LYOpenTemp(fname, suffix, mode));
#endif
    }

    while (*mode != '\0') {
	switch (*mode++) {
	case 'w':
	    wrt = 'w';
	    break;
	case 'a':
	    wrt = 'a';
	    break;
	case 'b':
	    txt = FALSE;
	    break;
	default:
	    CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
	    return fp;
	}
    }

    if (is_ours) {
	/*
	 * Yes, it exists, is writable if we checked, and everything looks ok
	 * so far.  This should be the most regular case.  - kw
	 */
#ifdef HAVE_TRUNCATE
	if (txt == TRUE) {	/* limitation of LYReopenTemp.  shrug */
	    /*
	     * We truncate and then append, this avoids having a small window
	     * in which the file doesn't exist.  - kw
	     */
	    if (truncate(fname, 0) != 0) {
		CTRACE((tfp, "... truncate(%s,0) failed: %s\n",
			fname, LYStrerror(errno)));
		return (LYOpenTemp(fname, suffix, mode));
	    } else {
		return (LYReopenTemp(fname));
	    }
	}
#endif
	remove(fname);

    }

    /* We come here in two cases:  either the file existed and was ours and we
     * just got rid of it.  Or the file did and does not exist, but is
     * registered as a temp file.  It must have been removed by some means
     * other than LYRemoveTemp.  In both cases, reuse the name!  - kw
     */

    if (txt) {
	switch (wrt) {
	case 'w':
	    fp = LYNewTxtFile(fname);
	    break;
	case 'a':
	    fp = LYAppendToTxtFile(fname);
	    break;
	}
    } else {
	fp = LYNewBinFile(fname);
    }
    p->file = fp;

    CTRACE((tfp, "... LYOpenTempRewrite(%s), %s\n", fname,
	    (fp) ? "ok" : "failed"));
    /*
     * We could fall back to trying LYOpenTemp() here in case of failure. 
     * After all the checks already done above a filure here should be pretty
     * unusual though, so maybe it's better to let the user notice that
     * something went wrong, and not try to fix it up.  - kw
     */
    return fp;
}

/*
 * Special case of LYOpenTemp, used for manipulating bookmark file, i.e., with
 * renaming.
 */
FILE *LYOpenScratch(char *result,
		    const char *prefix)
{
    FILE *fp;
    LY_TEMP *p;

    if (!fmt_tempname(result, prefix, HTML_SUFFIX))
	return 0;

    if ((fp = LYNewTxtFile(result)) != 0) {
	if ((p = typecalloc(LY_TEMP)) != 0) {
	    p->next = ly_temp;
	    StrAllocCopy((p->name), result);
	    p->file = fp;
	    ly_temp = p;
	} else {
	    outofmem(__FILE__, "LYOpenScratch");
	}
    }
    CTRACE((tfp, "LYOpenScratch(%s)\n", result));
    return fp;
}

static void LY_close_temp(LY_TEMP * p)
{
    if (p->file != 0) {
	if (p->outs) {
	    LYCloseOutput(p->file);
	} else {
	    LYCloseInput(p->file);
	}
	p->file = 0;
    }
}

/*
 * Close a temp-file, given its name
 */
void LYCloseTemp(char *name)
{
    LY_TEMP *p;

    CTRACE((tfp, "LYCloseTemp(%s)\n", name));
    if ((p = FindTempfileByName(name)) != 0) {
	CTRACE((tfp, "...LYCloseTemp(%s)%s\n", name,
		(p->file != 0) ? ", closed" : ""));
	LY_close_temp(p);
    }
}

/*
 * Close a temp-file, given its file-pointer
 */
void LYCloseTempFP(FILE *fp)
{
    LY_TEMP *p;

    CTRACE((tfp, "LYCloseTempFP\n"));
    if ((p = FindTempfileByFP(fp)) != 0) {
	LY_close_temp(p);
	CTRACE((tfp, "...LYCloseTempFP(%s)\n", p->name));
    }
}

/*
 * Close a temp-file, removing it.
 */
int LYRemoveTemp(char *name)
{
    LY_TEMP *p, *q;
    int code = -1;

    if (non_empty(name)) {
	CTRACE((tfp, "LYRemoveTemp(%s)\n", name));
	for (p = ly_temp, q = 0; p != 0; q = p, p = p->next) {
	    if (!strcmp(name, p->name)) {
		if (q != 0) {
		    q->next = p->next;
		} else {
		    ly_temp = p->next;
		}
		LY_close_temp(p);
		code = HTSYS_remove(name);
		CTRACE((tfp, "...LYRemoveTemp done(%d)%s\n", code,
			(p->file != 0) ? ", closed" : ""));
		CTRACE_FLUSH(tfp);
		FREE(p->name);
		FREE(p);
		break;
	    }
	}
    }
    return code;
}

/*
 * Remove all of the temp-files.  Note that this assumes that they are closed,
 * since some systems will not allow us to remove a file which is open.
 */
void LYCleanupTemp(void)
{
    while (ly_temp != 0) {
	LYRemoveTemp(ly_temp->name);
    }
#if defined(MULTI_USER_UNIX)
    if (lynx_temp_subspace > 0) {
	char result[LY_MAXPATH];

	LYstrncpy(result, lynx_temp_space, sizeof(result) - 1);
	LYTrimPathSep(result);
	CTRACE((tfp, "LYCleanupTemp removing %s\n", result));
	rmdir(result);
	lynx_temp_subspace = -1;
    }
#endif
}

/*
 * We renamed a temporary file.  Keep track so we can remove it on exit.
 */
void LYRenamedTemp(char *oldname,
		   char *newname)
{
    LY_TEMP *p;

    CTRACE((tfp, "LYRenamedTemp(old=%s, new=%s)\n", oldname, newname));
    if ((p = FindTempfileByName(oldname)) != 0) {
	StrAllocCopy((p->name), newname);
    }
}

#ifndef DISABLE_BIBP
/*
 * Check that bibhost defines the BibP icon.
 */
void LYCheckBibHost(void)
{
    DocAddress bibhostIcon;
    BOOLEAN saveFlag;

    bibhostIcon.address = NULL;
    StrAllocCopy(bibhostIcon.address, BibP_bibhost);
    StrAllocCat(bibhostIcon.address, "bibp1.0/bibpicon.jpg");
    bibhostIcon.post_data = NULL;
    bibhostIcon.post_content_type = NULL;
    bibhostIcon.bookmark = FALSE;
    bibhostIcon.isHEAD = FALSE;
    bibhostIcon.safe = FALSE;
    saveFlag = traversal;
    traversal = TRUE;		/* Hack to force error response. */
    BibP_bibhost_available = HTLoadAbsolute(&bibhostIcon) == YES;
    traversal = saveFlag;
    BibP_bibhost_checked = TRUE;
}
#endif /* !DISABLE_BIBP */

/*
 * Management of User Interface Pages.  - kw
 *
 * These are mostly temp files.  Pages which can be recognized by their special
 * URL (after having been loaded) need not be tracked here.
 *
 * First some private stuff:
 */
typedef struct uipage_entry {
    UIP_t type;
    unsigned flags;
    char *url;
    HTList *alturls;
    char *file;
} uip_entry;

#define UIP_F_MULTI	0x0001	/* flag: track multiple instances */
#define UIP_F_LIMIT	0x0002	/* flag: limit size of alturls list */
#define UIP_F_LMULTI   (UIP_F_MULTI | UIP_F_LIMIT)
/* *INDENT-OFF* */
static uip_entry ly_uip[] =
{
    { UIP_HISTORY		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_DOWNLOAD_OPTIONS	, 0	      , NULL, NULL, NULL }
  , { UIP_PRINT_OPTIONS		, 0	      , NULL, NULL, NULL }
  , { UIP_SHOWINFO		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_LIST_PAGE		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_VLINKS		, UIP_F_LMULTI, NULL, NULL, NULL }
#if !defined(NO_OPTION_FORMS)
  , { UIP_OPTIONS_MENU		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
#ifdef DIRED_SUPPORT
  , { UIP_DIRED_MENU		, 0	      , NULL, NULL, NULL }
  , { UIP_PERMIT_OPTIONS	, 0	      , NULL, NULL, NULL }
  , { UIP_UPLOAD_OPTIONS	, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
#ifdef EXP_ADDRLIST_PAGE
  , { UIP_ADDRLIST_PAGE		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
  , { UIP_LYNXCFG		, UIP_F_LMULTI, NULL, NULL, NULL }
#if !defined(NO_CONFIG_INFO)
  , { UIP_CONFIG_DEF		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
/* The following are not generated tempfiles: */
  , { UIP_TRACELOG		, 0	     , NULL, NULL, NULL }
#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
  , { UIP_INSTALL		, 0	     , NULL, NULL, NULL }
#endif

};
/* *INDENT-ON* */

/*  Public entry points for User Interface Page management: */

BOOL LYIsUIPage3(const char *url,
		 UIP_t type,
		 int flagparam)
{
    unsigned int i;
    size_t l;

    if (!url)
	return NO;
    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	if (ly_uip[i].type == type) {
	    if (!ly_uip[i].url) {
		return NO;
	    } else if ((flagparam & UIP_P_FRAG) ?
		       (!strncmp(ly_uip[i].url, url, (l = strlen(ly_uip[i].url)))
			&& (url[l] == '\0' || url[l] == '#')) :
		       !strcmp(ly_uip[i].url, url)) {
		return YES;
	    } else if (ly_uip[i].flags & UIP_F_MULTI) {
		char *p;
		HTList *l0 = ly_uip[i].alturls;

		while ((p = (char *) HTList_nextObject(l0)) != NULL) {
		    if ((flagparam & UIP_P_FRAG) ?
			(!strncmp(p, url, (l = strlen(p)))
			 && (url[l] == '\0' || url[l] == '#')) :
			!strcmp(p, url))
			return YES;
		}
	    }
	    return NO;
	}
    }
    return NO;
}

void LYRegisterUIPage(const char *url,
		      UIP_t type)
{
    unsigned int i;

    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	if (ly_uip[i].type == type) {
	    if (ly_uip[i].url && url &&
		!strcmp(ly_uip[i].url, url)) {

	    } else if (!ly_uip[i].url || !url ||
		       !(ly_uip[i].flags & UIP_F_MULTI)) {
		StrAllocCopy(ly_uip[i].url, url);

	    } else {
		char *p;
		int n = 0;
		HTList *l0 = ly_uip[i].alturls;

		while ((p = (char *) HTList_nextObject(l0)) != NULL) {
		    if (!strcmp(p, url))
			return;
		    if (!strcmp(p, ly_uip[i].url)) {
			StrAllocCopy(ly_uip[i].url, url);
			return;
		    }
		    n++;
		}
		if (!ly_uip[i].alturls)
		    ly_uip[i].alturls = HTList_new();

		if (n >= HTCacheSize && (ly_uip[i].flags & UIP_F_LIMIT))
		    HTList_removeFirstObject(ly_uip[i].alturls);
		HTList_addObject(ly_uip[i].alturls, ly_uip[i].url);
		ly_uip[i].url = NULL;
		StrAllocCopy(ly_uip[i].url, url);
	    }

	    return;
	}
    }
}

void LYUIPages_free(void)
{
    unsigned int i;

    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	FREE(ly_uip[i].url);
	FREE(ly_uip[i].file);
	LYFreeStringList(ly_uip[i].alturls);
	ly_uip[i].alturls = NULL;
    }
}

/*
 * Convert local pathname to www name
 * (do not bother about file://localhost prefix at this point).
 */
const char *wwwName(const char *pathname)
{
    const char *cp = NULL;

#if defined(USE_DOS_DRIVES)
    cp = HTDOS_wwwName(pathname);
#else
#ifdef VMS
    cp = HTVMS_wwwName(pathname);
#else
    cp = pathname;
#endif /* VMS */
#endif

    return cp;
}

/*
 * Given a user-specified filename, e.g., for download or print, validate and
 * expand it.  Expand home-directory expressions in the given string.  Only
 * allow pipes if the user can spawn shell commands.
 *
 * Both strings are fixed buffer sizes, LY_MAXPATH.
 */
BOOLEAN LYValidateFilename(char *result,
			   char *given)
{
    char *cp;
    const char *cp2;

    /*
     * Cancel if the user entered "/dev/null" on Unix, or an "nl:" path on VMS. 
     * - FM
     */
    if (LYIsNullDevice(given)) {
	/* just ignore it */
	return FALSE;
    }
#ifdef HAVE_POPEN
    if (LYIsPipeCommand(given)) {
	if (no_shell) {
	    HTUserMsg(SPAWNING_DISABLED);
	    return FALSE;
	}
	LYstrncpy(result, given, LY_MAXPATH);
	return TRUE;
    }
#endif
    if ((cp = strchr(given, '~')) != 0
	&& (cp2 = wwwName(Home_Dir())) != 0
	&& strlen(cp2) + strlen(given) < LY_MAXPATH) {
	*(cp++) = '\0';
	strcpy(result, given);
	LYTrimPathSep(result);
	strcat(result, cp2);
	strcat(result, cp);
	strcpy(given, result);
    }
#ifdef VMS
    if (strchr(given, '/') != NULL) {
	strcpy(result, HTVMS_name("", given));
	strcpy(given, result);
    }
    if (given[0] != '/'
	&& strchr(given, ':') == NULL
	&& strlen(given) < LY_MAXPATH - 13) {
	strcpy(result, "sys$disk:");
	if (strchr(given, ']') == NULL)
	    strcat(result, "[]");
	strcat(result, given);
    } else {
	strcpy(result, given);
    }
#else

#ifndef __EMX__
    if (!LYisAbsPath(given)) {
#if defined(__DJGPP__) || defined(_WINDOWS)
	if (strchr(result, ':') != NULL)
	    cp = NULL;
	else
#endif /*  __DJGPP__ || _WINDOWS */
	{
#ifdef SUPPORT_CHDIR
	    static char buf[LY_MAXPATH];

	    cp = Current_Dir(buf);
#else
	    cp = original_dir;
#endif
	}
    } else
#endif /* __EMX__ */
	cp = NULL;

    *result = 0;
    if (cp) {
	LYTrimPathSep(cp);
	if (strlen(cp) >= LY_MAXPATH - 2)
	    return FALSE;
	sprintf(result, "%s/", cp);
    }
    cp = HTSYS_name(given);
    if (strlen(result) + strlen(cp) >= LY_MAXPATH - 1)
	return FALSE;
    strcat(result, cp);
#endif /* VMS */
    return TRUE;
}

/*
 * Given a valid filename, check if it exists.  If so, we'll have to worry
 * about overwriting it.
 *
 * Returns:
 *	'Y' (yes/success)
 *	'N' (no/retry)
 *	3   (cancel)
 */
int LYValidateOutput(char *filename)
{
    int c;

    /*
     * Assume we can write to a pipe
     */
#ifdef HAVE_POPEN
    if (LYIsPipeCommand(filename))
	return 'Y';
#endif

    if (no_dotfiles || !show_dotfiles) {
	if (*LYPathLeaf(filename) == '.') {
	    HTAlert(FILENAME_CANNOT_BE_DOT);
	    return 'N';
	}
    }

    /*
     * See if it already exists.
     */
    if (LYCanReadFile(filename)) {
#ifdef VMS
	c = HTConfirm(FILE_EXISTS_HPROMPT);
#else
	c = HTConfirm(FILE_EXISTS_OPROMPT);
#endif /* VMS */
	if (HTLastConfirmCancelled()) {
	    HTInfoMsg(SAVE_REQUEST_CANCELLED);
	    return 3;
	} else if (c == NO) {
	    return 'N';
	}
    }
    return 'Y';
}

/*
 * Convert a local filename to a URL
 */
void LYLocalFileToURL(char **target,
		      const char *source)
{
    const char *leaf;

    StrAllocCopy(*target, "file://localhost");

    leaf = wwwName(source);

    if (!LYisAbsPath(source)) {
	char temp[LY_MAXPATH];

	Current_Dir(temp);
	if (!LYIsHtmlSep(*temp))
	    LYAddHtmlSep(target);
	StrAllocCat(*target, temp);
    }
    if (!LYIsHtmlSep(*leaf))
	LYAddHtmlSep(target);
    StrAllocCat(*target, leaf);
}

/*
 * Open a temporary file for internal-pages, optionally reusing an existing
 * filename.
 */
FILE *InternalPageFP(char *filename,
		     int reuse_flag)
{
    FILE *fp;

    if (LYReuseTempfiles && reuse_flag) {
	fp = LYOpenTempRewrite(filename, HTML_SUFFIX, BIN_W);
    } else {
	LYRemoveTemp(filename);
	fp = LYOpenTemp(filename, HTML_SUFFIX, BIN_W);
    }
    if (fp == NULL) {
	HTAlert(CANNOT_OPEN_TEMP);
    }
    return fp;
}

/*
 * This part is shared by all internal pages.
 */
void WriteInternalTitle(FILE *fp0, const char *Title)
{
    fprintf(fp0,
	    "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n");

    fprintf(fp0, "<html>\n<head>\n");
    LYAddMETAcharsetToFD(fp0, -1);
    if (LYIsListpageTitle(Title)) {
	if (strchr(HTLoadedDocumentURL(), '"') == NULL) {
	    char *Address = NULL;

	    /*
	     * Insert a BASE tag so there is some way to relate the List Page
	     * file to its underlying document after we are done.  It won't be
	     * actually used for resolving relative URLs.  - kw
	     */
	    StrAllocCopy(Address, HTLoadedDocumentURL());
	    LYEntify(&Address, FALSE);
	    fprintf(fp0, "<base href=\"%s\">\n", Address);
	    FREE(Address);
	}
    }
    fprintf(fp0, "<title>%s</title>\n</head>\n<body>\n", Title);
}

/*
 * This is used to start most internal pages, except for special cases where
 * the embedded HREF's in the title differ.
 */
void BeginInternalPage(FILE *fp0, const char *Title,
		       const char *HelpURL)
{
    WriteInternalTitle(fp0, Title);

    if ((user_mode == NOVICE_MODE)
	&& LYwouldPush(Title, NULL)
	&& (HelpURL != 0)) {
	fprintf(fp0, "<h1>%s (%s%s%s), <a href=\"%s%s\">help</a></h1>\n",
		Title, LYNX_NAME, VERSION_SEGMENT, LYNX_VERSION,
		helpfilepath, HelpURL);
    } else {
	fprintf(fp0, "<h1>%s (%s%s%s)</h1>\n",
		Title, LYNX_NAME, VERSION_SEGMENT, LYNX_VERSION);
    }
}

void EndInternalPage(FILE *fp0)
{
    fprintf(fp0, "</body>\n</html>");
}

char *trimPoundSelector(char *address)
{
    char *pound = findPoundSelector(address);

    if (pound != 0)
	*pound = '\0';
    return pound;
}

/*
 * Trim a trailing path-separator to avoid confusing other programs when we concatenate
 * to it.  This only applies to local filesystems.
 */
void LYTrimPathSep(char *path)
{
    size_t len;

    if (path != 0
	&& (len = strlen(path)) != 0
	&& LYIsPathSep(path[len - 1]))
	path[len - 1] = 0;
}

/*
 * Add a trailing path-separator to avoid confusing other programs when we concatenate
 * to it.  This only applies to local filesystems.
 */
void LYAddPathSep(char **path)
{
    size_t len;
    char *temp;

    if ((path != 0)
	&& ((temp = *path) != 0)
	&& (len = strlen(temp)) != 0
	&& !LYIsPathSep(temp[len - 1])) {
	StrAllocCat(*path, PATHSEP_STR);
    }
}

/*
 * Add a trailing path-separator to avoid confusing other programs when we concatenate
 * to it.  This only applies to local filesystems.
 */
void LYAddPathSep0(char *path)
{
    size_t len;

    if ((path != 0)
	&& (len = strlen(path)) != 0
	&& (len < LY_MAXPATH - 2)
	&& !LYIsPathSep(path[len - 1])) {
	strcat(path, PATHSEP_STR);
    }
}

/*
 * Check if a given string contains a path separator
 */
char *LYLastPathSep(const char *path)
{
    char *result;

#if defined(USE_DOS_DRIVES)
    if ((result = strrchr(path, '\\')) == 0)
	result = strrchr(path, '/');
#else
    result = strrchr(path, '/');
#endif
    return result;
}

/*
 * Trim a trailing path-separator to avoid confusing other programs when we concatenate
 * to it.  This only applies to HTML paths.
 */
void LYTrimHtmlSep(char *path)
{
    size_t len;

    if (path != 0
	&& (len = strlen(path)) != 0
	&& LYIsHtmlSep(path[len - 1]))
	path[len - 1] = 0;
}

/*
 * Add a trailing path-separator to avoid confusing other programs when we concatenate
 * to it.  This only applies to HTML paths.
 */
void LYAddHtmlSep(char **path)
{
    size_t len;
    char *temp;

    if ((path != 0)
	&& ((temp = *path) != 0)
	&& (len = strlen(temp)) != 0
	&& !LYIsHtmlSep(temp[len - 1])) {
	StrAllocCat(*path, "/");
    }
}

/*
 * Add a trailing path-separator to avoid confusing other programs when we concatenate
 * to it.  This only applies to HTML paths.
 */
void LYAddHtmlSep0(char *path)
{
    size_t len;

    if ((path != 0)
	&& (len = strlen(path)) != 0
	&& (len < LY_MAXPATH - 2)
	&& !LYIsHtmlSep(path[len - 1])) {
	strcat(path, "/");
    }
}

/*
 * Copy a file
 */
int LYCopyFile(char *src,
	       char *dst)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppCOPY)) != NULL) {
	char *the_command = 0;

	HTAddParam(&the_command, COPY_COMMAND, 1, program);
	HTAddParam(&the_command, COPY_COMMAND, 2, src);
	HTAddParam(&the_command, COPY_COMMAND, 3, dst);
	HTEndParam(&the_command, COPY_COMMAND, 3);

	CTRACE((tfp, "command: %s\n", the_command));
	stop_curses();
	code = LYSystem(the_command);
	start_curses();

	FREE(the_command);
    } else {
	FILE *fin, *fout;
	unsigned char buff[BUFSIZ];
	int len;

	code = EOF;
	if ((fin = fopen(src, BIN_R)) != 0) {
	    if ((fout = fopen(dst, BIN_W)) != 0) {
		code = 0;
		while ((len = fread(buff, 1, sizeof(buff), fin)) > 0) {
		    fwrite(buff, 1, len, fout);
		    if (ferror(fout)) {
			code = EOF;
			break;
		    }
		}
		LYCloseOutput(fout);
	    }
	    LYCloseInput(fin);
	}
    }

    if (code) {
	HTAlert(CANNOT_WRITE_TO_FILE);
    }
    return code;
}

#ifdef __DJGPP__
static char *escape_backslashes(char *source)
{
    char *result = 0;
    int count = 0;
    int n;

    for (n = 0; source[n] != '\0'; ++n) {
	if (source[n] == '\\')
	    ++count;
    }
    if (count != 0) {
	result = malloc(count + n + 1);
	if (result != 0) {
	    int ch;
	    char *target = result;

	    while ((ch = *source++) != '\0') {
		if (ch == '\\')
		    *target++ = ch;
		*target++ = ch;
	    }
	    *target = '\0';
	}
    }
    return result;
}
#endif /* __DJGPP__ */
/*
 * Invoke a shell command, return nonzero on error.
 */
int LYSystem(char *command)
{
    int code;
    int do_free = 0;

#if defined(HAVE_SIGACTION) && defined(SIGTSTP) && !defined(USE_SLANG)
    struct sigaction saved_sigtstp_act;
    BOOLEAN sigtstp_saved = FALSE;
#endif
    int saved_errno = 0;

#ifdef __EMX__
    int scrsize[4];
#endif

    fflush(stdout);
    fflush(stderr);
    CTRACE((tfp, "LYSystem(%s)\n", command));
    CTRACE_FLUSH(tfp);

#ifdef __DJGPP__
    __djgpp_set_ctrl_c(0);
    _go32_want_ctrl_break(1);
#endif /* __DJGPP__ */

#ifdef VMS
    code = DCLsystem(command);
#else
#  ifdef __EMX__		/* FIXME: Should be LY_CONVERT_SLASH? */
    /* Configure writes commands which contain direct slashes.
       Native command-(non)-shell will not tolerate this. */
    {
	char *space = command, *slash = command;

	_scrsize(scrsize);
	while (*space && *space != ' ' && *space != '\t')
	    space++;
	while (slash < space && *slash != '/')
	    slash++;
	if (slash != space) {
	    char *old = command;

	    command = NULL;
	    StrAllocCopy(command, old);
	    do_free = 1;
	    slash = (slash - old) + command - 1;
	    space = (space - old) + command;
	    while (++slash < space)
		if (*slash == '/')
		    *slash = '\\';
	}
    }
#  endif

    /*
     * This chunk of code does not work, for two reasons:
     * a) the Cygwin system() function edits out the backslashes
     * b) it does not account for more than one parameter, e.g., +number
     */
#if defined(__CYGWIN__) && defined(DOSPATH)	/* 1999/02/26 (Fri) */
    {
	char cmd[LY_MAXPATH];
	char win32_name[LY_MAXPATH];
	char new_cmd[LY_MAXPATH];
	char new_command[LY_MAXPATH * 2 + 10];
	char *p, *q;

	p = command;
	q = cmd;
	while (*p) {
	    if (*p == ' ')
		break;
	    else
		*q = *p;
	    p++;
	    q++;
	}
	*q = '\0';

	if (cmd[0] == '/')
	    cygwin_conv_to_full_posix_path(cmd, new_cmd);
	else
	    strcpy(new_cmd, cmd);

	while (*p == ' ')
	    p++;

	if (strchr(p, '\\') == NULL) {
	    /* for Windows Application */
	    cygwin_conv_to_full_win32_path(p, win32_name);
	    sprintf(new_command, "%.*s \"%.*s\"",
		    LY_MAXPATH, new_cmd, LY_MAXPATH, win32_name);
	} else {
	    /* for DOS like editor */
	    q = win32_name;
	    while (*p) {
		if (*p == '\\') {
		    if (*(p + 1) == '\\')
			p++;
		}
		*q = *p;
		q++, p++;
	    }
	    *q = '\0';
	    sprintf(new_command, "%.*s %.*s", LY_MAXPATH, new_cmd, LY_MAXPATH, win32_name);
	}
	command = new_command;
    }
#endif

#ifdef __DJGPP__
    if (dj_is_bash) {
	char *new_command = escape_backslashes(command);

	if (new_command != 0) {
	    if (do_free)
		free(command);
	    command = new_command;
	}
    }
#endif /* __DJGPP__ */

#ifdef _WIN_CC
    code = exec_command(command, TRUE);		/* Wait exec */
#else /* !_WIN_CC */
#ifdef SIGPIPE
    if (restore_sigpipe_for_children)
	signal(SIGPIPE, SIG_DFL);	/* Some commands expect the default */
#endif
#if defined(HAVE_SIGACTION) && defined(SIGTSTP) && !defined(USE_SLANG)
    if (!dump_output_immediately && !LYCursesON && !no_suspend)
	sigtstp_saved = LYToggleSigDfl(SIGTSTP, &saved_sigtstp_act, 1);
#endif
    code = system(command);
    saved_errno = errno;
#if defined(HAVE_SIGACTION) && defined(SIGTSTP) && !defined(USE_SLANG)
    if (sigtstp_saved)
	LYToggleSigDfl(SIGTSTP, &saved_sigtstp_act, 0);
#endif
#ifdef SIGPIPE
    if (restore_sigpipe_for_children)
	signal(SIGPIPE, SIG_IGN);	/* Ignore it again - kw */
#endif
#endif
#endif

#ifdef __DJGPP__
    __djgpp_set_ctrl_c(1);
    _go32_want_ctrl_break(0);
#endif /* __DJGPP__ */

    fflush(stdout);
    fflush(stderr);

    if (do_free)
	FREE(command);
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ?? */
    set_errno(saved_errno);	/* may have been clobbered */
#endif
#ifdef __EMX__			/* Check whether the screen size changed */
    size_change(0);
#endif
    return code;
}

/*
 * Return a string which can be used in LYSystem() for spawning a subshell
 */
#if defined(__CYGWIN__)		/* 1999/02/26 (Fri) */
int Cygwin_Shell(void)
{
    char *shell;
    int code;
    STARTUPINFO startUpInfo;
    PROCESS_INFORMATION procInfo;
    SECURITY_ATTRIBUTES sa;

    /* Set up security attributes to allow inheritance of the file handle */

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = 0;
    sa.bInheritHandle = TRUE;

    /* Init a startup structure */
    GetStartupInfo(&startUpInfo);

    shell = LYGetEnv("COMSPEC");

    /* Create the child process, specifying
       inherited handles. Pass the value of the
       handle as a command line parameter */
    code = 0;
    if (shell) {
	code = CreateProcess(0, shell, 0, 0,
			     TRUE, 0,
			     0, 0, &startUpInfo, &procInfo);

	if (!code) {
	    printf("shell = [%s], code = %ld\n", shell, GetLastError());
	}

	/* wait for the child to return (this is not a requirement
	   since the child is its own independent process) */
	WaitForSingleObject(procInfo.hProcess, INFINITE);
    }

    return code;
}
#endif

const char *LYSysShell(void)
{
    const char *shell = 0;

#ifdef DOSPATH
#ifdef WIN_EX
    shell = LYGetEnv("SHELL");
    if (shell) {
	if (access(shell, 0) != 0)
	    shell = LYGetEnv("COMSPEC");
    }
    if (shell == NULL) {
	if (system_is_NT)
	    shell = "cmd.exe";
	else
	    shell = "command.com";
    }
#else
    shell = LYGetEnv("SHELL");
    if (shell == NULL) {
	shell = LYGetEnv("COMSPEC");
    }
    if (shell == NULL) {
	shell = "command.com";
    }
#endif /* WIN_EX */
#else
#ifdef __EMX__
    if (LYGetEnv("SHELL") != NULL) {
	shell = LYGetEnv("SHELL");
    } else {
	shell = (LYGetEnv("COMSPEC") == NULL) ? "cmd.exe" : LYGetEnv("COMSPEC");
    }
#else
#ifdef VMS
    shell = "";
#else
    shell = "exec $SHELL";
#endif /* __EMX__ */
#endif /* VMS */
#endif /* DOSPATH */
    return shell;
}

#ifdef VMS
#define DISPLAY "DECW$DISPLAY"
#else
#define DISPLAY "DISPLAY"
#endif /* VMS */

/*
 * Return the X-Window $DISPLAY string if it is nonnull/nonempty
 */
char *LYgetXDisplay(void)
{
    return LYGetEnv(DISPLAY);
}

/*
 * Set the value of the X-Window $DISPLAY variable (yes it leaks memory, but
 * that is putenv's fault).
 */
void LYsetXDisplay(char *new_display)
{
    if (new_display != 0) {
#ifdef VMS
	LYUpperCase(new_display);
	Define_VMSLogical(DISPLAY, new_display);
#else
	static char *display_putenv_command;

	HTSprintf0(&display_putenv_command, "DISPLAY=%s", new_display);
	putenv(display_putenv_command);
#endif /* VMS */
	if ((new_display = LYgetXDisplay()) != 0) {
	    StrAllocCopy(x_display, new_display);
	}
    }
}

#ifdef CAN_CUT_AND_PASTE
#ifdef __EMX__

static int proc_type = -1;
static PPIB pib;
static HAB hab;
static HMQ hmq;

static void morph_PM(void)
{
    PTIB tib;
    int first = 0;

    if (proc_type == -1) {
	DosGetInfoBlocks(&tib, &pib);
	proc_type = pib->pib_ultype;
	first = 1;
    }
    if (pib->pib_ultype != 3)	/* 2 is VIO */
	pib->pib_ultype = 3;	/* 3 is PM */
    if (first)
	hab = WinInitialize(0);
    /* 64 messages if before OS/2 3.0, ignored otherwise */
    hmq = WinCreateMsgQueue(hab, 64);
    WinCancelShutdown(hmq, 1);	/* Do not inform us on shutdown */
}

static void unmorph_PM(void)
{
    WinDestroyMsgQueue(hmq);
    pib->pib_ultype = proc_type;
}

int size_clip(void)
{
    return 8192;
}

/* Code partially stolen from FED editor. */

int put_clip(const char *s)
{
    int sz = strlen(s) + 1;
    int ret = EOF, nl = 0;
    char *pByte = 0, *s1 = s, c, *t;

    while ((c = *s1++)) {
	if (c == '\r' && *s1 == '\n')
	    s1++;
	else if (c == '\n')
	    nl++;
    }
    if (DosAllocSharedMem((PPVOID) & pByte, 0, sz + nl,
			  PAG_WRITE | PAG_COMMIT | OBJ_GIVEABLE | OBJ_GETTABLE))
	return ret;

    if (!nl)
	memcpy(pByte, s, sz);
    else {
	t = pByte;
	while ((c = *t++ = *s++))
	    if (c == '\n' && (t == pByte + 1 || t[-2] != '\r'))
		t[-1] = '\r', *t++ = '\n';
    }

    morph_PM();
    if (!hab)
	goto fail;

    WinOpenClipbrd(hab);
    WinEmptyClipbrd(hab);
    if (WinSetClipbrdData(hab, (ULONG) pByte, CF_TEXT, CFI_POINTER))
	ret = 0;
    WinCloseClipbrd(hab);
    unmorph_PM();
    if (ret == 0)
	return 0;
  fail:
    DosFreeMem((PPVOID) & pByte);
    return EOF;
}

static int clip_open;

/* get_clip_grab() returns a pointer to the string in the system area.
   get_clip_release() should be called ASAP after this. */

char *get_clip_grab(void)
{
    char *ClipData;
    ULONG ulFormat;
    int sz;

    morph_PM();
    if (!hab)
	return 0;
    if (clip_open)
	get_clip_release();

    WinQueryClipbrdFmtInfo(hab, CF_TEXT, &ulFormat);
    if (ulFormat != CFI_POINTER) {
	unmorph_PM();
	return 0;
    }
    WinOpenClipbrd(hab);
    clip_open = 1;
    ClipData = (char *) WinQueryClipbrdData(hab, CF_TEXT);
    sz = strlen(ClipData);
    if (!ClipData || !sz) {
	get_clip_release();
	return 0;
    }
    return ClipData;
}

void get_clip_release(void)
{
    if (!clip_open)
	return;
    WinCloseClipbrd(hab);
    clip_open = 0;
    unmorph_PM();
}

#else /* !( defined __EMX__ ) */

#  if !defined(WIN_EX) && defined(HAVE_POPEN)

static FILE *paste_handle = 0;
static char *paste_buf = NULL;

void get_clip_release(void)
{
    if (paste_handle != 0)
	pclose(paste_handle);
    if (paste_buf)
	FREE(paste_buf);
}

static int clip_grab(void)
{
    char *cmd = LYGetEnv("RL_PASTE_CMD");

    if (paste_handle)
	pclose(paste_handle);
    if (!cmd)
	return 0;

    paste_handle = popen(cmd, "rt");
    if (!paste_handle)
	return 0;
    return 1;
}

#define PASTE_BUFFER 1008
#define CF_TEXT 0		/* Not used */

char *get_clip_grab(void)
{
    int len;
    int size = PASTE_BUFFER;
    int off = 0;

    if (!clip_grab())
	return NULL;
    if (!paste_handle)
	return NULL;
    if (paste_buf)
	FREE(paste_buf);
    paste_buf = (char *) malloc(PASTE_BUFFER);
    while (1) {
	len = fread(paste_buf + off, 1, PASTE_BUFFER - 1, paste_handle);
	paste_buf[off + len] = '\0';
	if (len < PASTE_BUFFER - 1)
	    break;
	if (strchr(paste_buf + off, '\r')
	    || strchr(paste_buf + off, '\n'))
	    break;
	paste_buf = typeRealloc(char, paste_buf, size += PASTE_BUFFER - 1);

	off += len;
    }
    return paste_buf;
}

int put_clip(const char *s)
{
    char *cmd = LYGetEnv("RL_CLCOPY_CMD");
    FILE *fh;
    int l = strlen(s), res;

    if (!cmd)
	return -1;

    fh = popen(cmd, "wt");
    if (!fh)
	return -1;
    res = fwrite(s, 1, l, fh);
    if (pclose(fh) != 0 || res != l)
	return -1;
    return 0;
}

#  endif			/* !defined(WIN_EX) && defined(HAVE_POPEN) */

#endif /* __EMX__ */

/*
 * Sleep for a number of milli-sec.
 */
void LYmsec_delay(unsigned msec)
{
#if defined(_WINDOWS)
    Sleep(msec);

#elif defined(HAVE_NAPMS)
    napms(msec);

#elif defined(DJGPP) || defined(HAVE_USLEEP)
    usleep(1000 * msec);

#else
    struct timeval tv;
    unsigned long usec = 1000UL * msec;

    tv.tv_sec = usec / 1000000UL;
    tv.tv_usec = usec % 1000000UL;
    select(0, NULL, NULL, NULL, &tv);
#endif
}

#if defined(WIN_EX)		/* 1997/10/16 (Thu) 20:13:28 */

int put_clip(const char *szBuffer)
{
    HANDLE hWnd;
    HANDLE m_hLogData;
    LPTSTR pLogData;
    HANDLE hClip;
    int len;

    if (szBuffer == NULL)
	return EOF;

    len = strlen(szBuffer);
    if (len == 0)
	return EOF;
    else
	len++;

    m_hLogData = GlobalAlloc(GHND, len);
    if (m_hLogData == NULL) {
	return EOF;
    }

    hWnd = NULL;
    if (!OpenClipboard(hWnd)) {
	return EOF;
    }
    /* Remove the current Clipboard contents */
    if (!EmptyClipboard()) {
	GlobalFree(m_hLogData);
	return EOF;
    }

    /* Lock the global memory while we write to it. */
    pLogData = (LPTSTR) GlobalLock(m_hLogData);

    lstrcpy((LPTSTR) pLogData, szBuffer);
    GlobalUnlock(m_hLogData);

    /* If there were any lines at all then copy them to clipboard. */
    hClip = SetClipboardData(CF_TEXT, m_hLogData);
    if (!hClip) {
	/* If we couldn't clip the data then free the global handle. */
	GlobalFree(m_hLogData);
    }

    CloseClipboard();
    return 0;
}

static HANDLE m_hLogData;
static int m_locked;

/* get_clip_grab() returns a pointer to the string in the system area.
   get_clip_release() should be called ASAP after this. */

char *get_clip_grab()
{
    HANDLE hWnd;
    LPTSTR pLogData;

    hWnd = NULL;
    if (!OpenClipboard(hWnd)) {
	return 0;
    }

    m_hLogData = GetClipboardData(CF_TEXT);

    if (m_hLogData == NULL) {
	CloseClipboard();
	m_locked = 0;
	return 0;
    }
    pLogData = (LPTSTR) GlobalLock(m_hLogData);

    m_locked = 1;
    return pLogData;
}

void get_clip_release()
{
    if (!m_locked)
	return;
    GlobalUnlock(m_hLogData);
    CloseClipboard();
    m_locked = 0;
}
#endif /* WIN_EX */
#endif /* CAN_CUT_AND_PASTE */

#if defined(WIN_EX)

#ifndef WSABASEERR
#define WSABASEERR 10000
#endif

#ifdef ENABLE_IPV6
#define WSOCK_NAME  "ws2_32"
#else
#define WSOCK_NAME  "wsock32"
#endif

/*
 * Description: the windows32 version of perror()
 *
 * Returns:  a pointer to a static error
 *
 * Notes/Dependencies:  I got this from
 *	comp.os.ms-windows.programmer.win32
 */
char *w32_strerror(DWORD ercode)
{
/*  __declspec(thread) necessary if you will use multiple threads */
#ifdef __CYGWIN__
    static char msg_buff[256];

#else
    __declspec(thread) static char msg_buff[256];
#endif
    HMODULE hModule;
    int i, msg_type;
    unsigned char *p, *q, tmp_buff[256];
    DWORD rc;

    hModule = NULL;
    msg_type = FORMAT_MESSAGE_FROM_SYSTEM;
    /* Fill message buffer with a default message in
     * case FormatMessage fails
     */
    wsprintf(msg_buff, "Error %ld", ercode);

    /*
     * Special code for winsock error handling.
     */
    if (ercode > WSABASEERR) {
	hModule = GetModuleHandle(WSOCK_NAME);
	if (hModule)
	    msg_type = FORMAT_MESSAGE_FROM_HMODULE;
    }
    /*
     * message handling. If not found in module, retry from system.
     */
    rc = FormatMessage(msg_type, hModule, ercode, LANG_NEUTRAL,
		       msg_buff, sizeof(msg_buff), NULL);

    if (rc == 0 && msg_type == FORMAT_MESSAGE_FROM_HMODULE) {
	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, ercode,
		      LANG_NEUTRAL, msg_buff, sizeof(msg_buff), NULL);
    }

    strcpy(tmp_buff, msg_buff);
    p = q = tmp_buff;
    i = 0;
    while (*p) {
	if (!(*p == '\n' || *p == '\r'))
	    msg_buff[i++] = *p;
	p++;
    }
    msg_buff[i] = '\0';

    return msg_buff;
}

#endif

#if defined(SYSLOG_REQUESTED_URLS)
/*
 * syslog() interface
 */
void LYOpenlog(const char *banner)
{
    if (syslog_requested_urls) {
	CTRACE((tfp, "LYOpenlog(%s)\n", NONNULL(banner)));
#if defined(DJGPP)
	openlog("lynx", LOG_PID | LOG_NDELAY, LOG_LOCAL5);
#else
	openlog("lynx", LOG_PID, LOG_LOCAL5);
#endif

	if (banner) {
	    syslog(LOG_INFO, "Session start:%s", banner);
	} else {
	    syslog(LOG_INFO, "Session start");
	}
    }
}

static BOOLEAN looks_like_password(char *first,
				   char *last)
{
    BOOLEAN result = FALSE;

    while (first <= last) {
	if (*first == '/'
	    || *first == ':') {
	    result = FALSE;
	    break;
	}
	result = TRUE;
	first++;
    }
    return result;
}

void LYSyslog(char *arg)
{
    char *colon1;
    char *colon2;
    char *atsign;

    if (syslog_requested_urls) {

	CTRACE((tfp, "LYSyslog %s\n", arg));

	if (is_url(arg)) {	/* proto://user:password@@host/path:port */
	    /*      ^this colon                 */
	    if ((colon1 = strchr(arg, ':')) != 0
		&& !strncmp(colon1, "://", 3)
		&& (colon2 = strchr(colon1 + 3, ':')) != 0
		&& (atsign = strchr(colon1, '@@')) != 0
		&& (colon2 < atsign)
		&& looks_like_password(colon2 + 1, atsign - 1)) {
		char *buf = NULL;

		StrAllocCopy(buf, arg);
		buf[colon2 - arg + 1] = 0;
		StrAllocCat(buf, "******");
		StrAllocCat(buf, atsign);
		syslog(LOG_INFO | LOG_LOCAL5, "%s", buf);
		CTRACE((tfp, "...alter %s\n", buf));
		FREE(buf);
		return;
	    }
	}
	syslog(LOG_INFO | LOG_LOCAL5, "%s", NONNULL(arg));
    }
}

void LYCloselog(void)
{
    if (syslog_requested_urls) {
	syslog(LOG_INFO, "Session over");
	closelog();
    }
}

#endif /* SYSLOG_REQUESTED_URLS */
@


1.7
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d7 9
d39 1
a39 5
#ifdef _WIN_CC
extern int exec_command(char * cmd, int wait_flag); /* xsystem.c */
#endif

#ifdef _WINDOWS	/* 1998/04/30 (Thu) 19:04:25 */
d50 4
a53 4
#  define BOOLEAN OS2_BOOLEAN		/* Conflicts, but is used */
#  undef HT_ERROR			/* Conflicts too */
#  define INCL_PM			/* I want some PM functions.. */
#  define INCL_DOSPROCESS		/* TIB PIB. */
d76 1
a76 1
#define UTMP_FILE __UTMPX_FILE  /* at least in OS/390  S/390 -- gil -- 2100 */
d78 1
a78 1
#define UTMP_FILE "/var/adm/utmpx" /* Digital Unix 4.0 */
d103 3
a105 2
extern int BSDselect PARAMS((int nfds, fd_set * readfds, fd_set * writefds,
			     fd_set * exceptfds, struct timeval * timeout));
d148 2
a149 2
PRIVATE HTList * localhost_aliases = NULL;	/* Hosts to treat as local */
PRIVATE char *HomeDir = NULL;			/* HOME directory */
d151 1
a151 1
PUBLIC	HTList * sug_filenames = NULL;		/* Suggested filenames	 */
d164 1
a164 1
PRIVATE LY_TEMP *ly_temp;
d166 1
a166 1
PRIVATE LY_TEMP *FindTempfileByName ARGS1(CONST char *, name)
d178 1
a178 1
PRIVATE LY_TEMP *FindTempfileByFP ARGS1(FILE *, fp)
d193 1
a193 1
PUBLIC char *LYGetEnv ARGS1(CONST char *, name)
d196 1
d206 1
a206 1
PUBLIC int ascii_tolower ARGS1(int, i)
d208 2
a209 2
    if ( 91 > i && i > 64 )
	return (i+32);
d214 1
a214 1
PUBLIC int ascii_toupper ARGS1(int, i)
d216 2
a217 2
    if ( 123 > i && i > 96 )
	return (i-32);
d222 1
a222 1
PUBLIC int ascii_isupper ARGS1(int, i)
d224 1
a224 1
    if ( 91 > i && i > 64 )
d235 2
a236 3
PUBLIC size_t utf8_length ARGS2(
	BOOL,		utf_flag,
	CONST char *,	data)
d253 1
a253 1
	     *  Garbage.
d257 1
a257 1
	if (strlen(data+1) < utf_extra) {
d259 1
a259 1
	     *  Shouldn't happen.
d268 13
d283 2
a284 3
PUBLIC void LYSetHilite ARGS2(
	int,		cur,
	char *,		text)
d286 1
a286 1
    links[cur].list.hl_base.hl_text = text;
d294 3
a296 4
PUBLIC void LYAddHilite ARGS3(
	int,		cur,
	char *,		text,
	int,		x)
d301 1
a301 1
    unsigned want = (list->hl_len += 1) * sizeof(HiliteInfo);
d304 1
a304 1
	have = realloc(have, want);
d306 1
a306 1
	have = malloc(want);
d316 2
a317 3
PUBLIC char *LYGetHiliteStr ARGS2(
	int,		cur,
	int,		count)
d319 1
a319 1
    char *result;
d333 2
a334 3
PUBLIC int LYGetHilitePos ARGS2(
	int,		cur,
	int,		count)
d369 6
a374 7
PRIVATE BOOL show_whereis_targets ARGS6(
	int,	flag,
	int,	cur,
	int,	count,
	char *,	target,
	BOOL,	TargetEmphasisON,
	BOOL,	utf_flag)
d376 2
a377 2
    char *Data = NULL;
    char *cp;
d389 10
a398 10
     && (links[cur].type & WWW_LINK_TYPE)
     && non_empty(LYGetHiliteStr(cur, count))
     && links[cur].ly + count < display_lines
     && HText_getFirstTargetInLine(HTMainText,
				   links[cur].anchor_line_num + count,
				   utf_flag,
				   &Offset,
				   &tLen,
				   &theData,
				   target)) {
d400 1
a400 1
	char *data;
d412 1
a412 2
		      (LYGetHiliteStr(cur, count) ?
		       LYGetHiliteStr(cur, count) : ""),
d414 1
a414 1
		      ((LYcols - 1) - LYGetHilitePos(cur, count)),
d418 1
a418 1
	      LYmbcsstrlen(buffer, utf_flag, YES) : hlen);
d438 1
a438 1
		 && (offset + LenNeeded) < LYcols) {
d468 1
a468 1
		    LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
d532 1
a532 1
		     itmp++)  {
d540 1
a540 1
			LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
d608 21
a628 18
		    /*
		     * See if we have another hit that starts within the
		     * hightext.  -FM
		     */
		 && ((cp = LYno_attr_mb_strstr(data = SKIP_GLYPHS(utf_flag, Data, offset - Offset),
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL)
		 && (offset + LenNeeded) < LYcols
		    /*
		     * If the hit starts after the end of the hightext, or we
		     * are making the link current and the hit starts at its
		     * last character, we are done.  -FM
		     */
		 && (HitOffset + offset) <
		     (hoffset +
		      (flag == ON ? (hLen - 1) : hLen)))  {
d642 1
a642 1
highlight_hit_within_hightext:
d649 1
a649 1
	    if ((Offset - offset) <= (flag == ON ? (hLen - 1) : hLen))  {
d667 1
a667 1
		    LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
d675 1
a675 1
			(offset > hoffset && data[itmp+1] != '\0')) {
d696 1
a696 1
			(offset > hoffset && data[itmp+1] != '\0')) {
d712 1
a712 1
			(offset > hoffset && data[itmp+1] != '\0')) {
d734 1
a734 1
		     itmp++)  {
d742 1
a742 1
			LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
d810 20
a829 16
		    /*
		     * See if we have another hit that starts within the
		     * hightext.  -FM
		     */
		 && ((cp = LYno_attr_mb_strstr(data = SKIP_GLYPHS(utf_flag, Data, offset - Offset),
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL)
		 && (offset + LenNeeded) < LYcols
		    /*
		     * If the hit starts after the end of the hightext, or we
		     * are making the link current and the hit starts at its
		     * last character, we are done.  -FM
		     */
		 && (HitOffset + offset) < (hoffset + (flag == ON ? (hLen - 1) : hLen))) {
d854 1
a854 1
			     itmp++)  {
d863 1
a863 1
				LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
d932 1
a932 1
highlight_search_done:
d939 2
a940 3
PRIVATE int find_cached_style ARGS2(
	int,	cur,
	int,	flag)
d945 3
a947 3
    if ( textfields_need_activation
     && links[cur].type == WWW_FORM_LINK_TYPE
     && F_TEXTLIKE(links[cur].l_form->type) )
d953 1
d964 1
a964 1
			  LYP, LXP));
d967 1
a967 1
		for (x = LXP-1; x >= 0; x--) {
d974 1
a974 1
				cached_styles[LYP][x], (int)x-LXP));
d986 2
a987 1
	    CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.off: can't use cache.\n"));
d998 1
a998 1
 *  Highlight (or unhighlight) a given link.
d1000 3
a1002 4
PUBLIC void LYhighlight ARGS3(
	int,		flag,
	int,		cur,
	char *,		target)
d1009 2
a1010 1
    char *hi_string;
d1015 1
a1015 1
    BOOL utf_flag = (BOOL)(LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8);
d1017 1
d1020 1
d1046 1
a1046 1
	 || LYGetHiliteStr(cur, 0) == NULL) {
d1049 1
a1049 1
	    lynx_start_link_color (flag == ON, links[cur].inUnderline);
d1062 2
a1063 2
	    int avail_space = (LYcols - links[cur].lx) - 1;
	    char *text = LYGetHiliteStr(cur, 0);
d1081 3
a1083 1
	    CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.off: NOFIX branch @@(%d,%d).\n", LYP, LXP));
d1091 1
a1091 2
			  (LYGetHiliteStr(cur, 0) ?
			   LYGetHiliteStr(cur, 0) : ""),
d1093 1
a1093 1
			  ((LYcols - 1) - links[cur].lx),
d1099 1
a1099 1
	 *  Display a second line as well.
d1106 3
a1108 3
		    (hi_string = LYGetHiliteStr(cur, hi_count)) != NULL
		    && links[cur].ly + hi_count <= display_lines;
			++hi_count) {
d1111 1
a1111 1
		lynx_stop_link_color (flag == ON, links[cur].inUnderline);
d1117 2
a1118 2
			      links[cur].ly + hi_count, hi_offset,
			      flag == ON ? s_alink : s_a));
d1121 1
a1121 1
		lynx_start_link_color (flag == ON, links[cur].inUnderline);
d1125 1
a1125 1
			   && (i + hi_offset) < LYcols; i++) {
d1137 1
a1137 1
		     }
d1140 1
a1140 1
	    lynx_stop_link_color (flag == ON, links[cur].inUnderline);
a1141 1

d1144 2
a1145 2
		LYGetHiliteStr(cur, hi_count) != NULL;
			hi_count++) {
d1156 1
a1156 1
	     *	Get cursor out of the way.
d1162 1
a1162 1
	     *	Never hide the cursor if there's no FANCY CURSES or SLANG.
d1165 1
a1165 1
		 ((links[cur].lx > 0) ? (links[cur].lx - 1) : 0));
d1174 2
a1175 2
 *  free_and_clear will free a pointer if it
 *  is non-zero and then set it to zero.
d1177 1
a1177 2
PUBLIC void free_and_clear ARGS1(
	char **,	pointer)
d1187 8
a1194 9
 *  Convert single or serial newlines to single spaces throughout a string
 *  (ignore newlines if the preceding character is a space) and convert
 *  tabs to single spaces.  Don't ignore any explicit tabs or spaces if
 *  the condense argument is FALSE, otherwise, condense any serial spaces
 *  or tabs to one space. - FM
 */
PUBLIC void convert_to_spaces ARGS2(
	char *,		string,
	BOOL,		condense)
d1203 1
a1203 2
    for ( ; (*s && !isspace(*s)); s++)
	;
d1208 11
a1218 4
	    case ' ':
	    case '\t':
		if (!(condense && last_is_space))
		    *(ns++) = ' ';
d1220 2
a1221 1
		break;
d1223 4
a1226 12
	    case '\r':
	    case '\n':
		if (!last_is_space) {
		    *(ns++) = ' ';
		    last_is_space = TRUE;
		}
		break;

	    default:
		*(ns++) = *s;
		last_is_space = FALSE;
		break;
d1235 1
a1235 1
 *  Strip trailing slashes from directory paths.
d1237 1
a1237 2
PUBLIC char * strip_trailing_slash ARGS1(
	char *,		dirname)
d1244 1
a1244 1
    return(dirname);
d1248 1
a1248 1
 *  Display (or hide) the status line.
d1252 1
a1252 2
PUBLIC void statusline ARGS1(
	CONST char *,	text)
d1265 1
a1265 1
     *	Don't print statusline messages if dumping to stdout.
d1271 1
a1271 1
     *	Don't print statusline message if turned off.
d1281 1
a1281 1
    LYstrncpy(text_buff, text, sizeof(text_buff)-1);
d1284 1
a1284 1
	p= '\0';
d1287 3
a1289 3
     *	Deal with any CJK escape sequences and Kanji if we have a CJK
     *	character set selected, otherwise, strip any escapes.  Also,
     *	make sure text is not longer than the statusline window. - FM
d1291 3
a1293 2
    max_length = ((LYcols - 2) < (int)sizeof(buffer))
		? (LYcols - 2) : (int)sizeof(buffer)-1;
d1297 1
a1297 1
	 *  Translate or filter any escape sequences. - FM
d1300 2
a1301 1
	    outofmem(__FILE__, "statusline");
d1303 1
a1303 1
	    TO_EUC((CONST unsigned char *)text_buff, temp);
d1309 1
a1309 1
		TO_SJIS((CONST unsigned char *)text_buff, temp);
d1315 1
a1315 1
		if (text_buff[i] != CH_ESC) {  /* S/390 -- gil -- 2119 */
d1323 1
a1323 1
	 *  Deal with any newlines or tabs in the string. - FM
d1325 1
a1325 1
	convert_to_spaces((char *)temp, FALSE);
d1328 2
a1329 2
	 *  Handle the Kanji, making sure the text is not
	 *  longer than the statusline window. - FM
d1349 6
a1354 7
	 *  Strip any escapes, and shorten text if necessary.  Note
	 *  that we don't deal with the possibility of UTF-8 characters
	 *  in the string.  This is unlikely, but if strings with such
	 *  characters are used in LYMessages_en.h, a compilation
	 *  symbol of HAVE_UTF8_STATUSLINES could be added there, and
	 *  code added here for determining the displayed string length,
	 *  as we do above for CJK. - FM
d1357 1
a1357 1
	    if (text_buff[i] != CH_ESC) {  /* S/390 -- gil -- 2119 */
d1363 1
a1363 1
	 *  Deal with any newlines or tabs in the string. - FM
d1365 1
a1365 1
	convert_to_spaces(buffer, FALSE);
d1369 2
a1370 2
     *	Move to the desired statusline window and
     *	output the text highlighted. - FM
d1373 1
a1373 1
	if (LYStatusLine < LYlines-1) {
d1376 1
a1376 1
	    LYmove(LYlines-1, 0);
d1379 1
a1379 1
	LYmove(LYlines-3, 0);
d1381 1
a1381 1
	LYmove(LYlines-1, 0);
a1403 1

d1405 3
a1407 3
	lynx_start_status_color ();
	LYaddstr (buffer);
	lynx_stop_status_color ();
d1411 19
a1429 18
		int a = (strncmp(buffer, ALERT_FORMAT, ALERT_PREFIX_LEN)
			|| !hashStyles[s_alert].name)
			? s_status
			: s_alert;
		LynxChangeStyle (a, STACK_ON);
		LYaddstr(buffer);
		wbkgdset(LYwin,
			 ((lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
			  ? hashStyles[a].color
			  :A_NORMAL) | ' ');
		LYclrtoeol();
		if (!(lynx_has_color && LYShowColor >= SHOW_COLOR_ON))
		    wbkgdset(LYwin, A_NORMAL | ' ');
		else if (s_normal != NOSTYLE)
		    wbkgdset(LYwin, hashStyles[s_normal].color | ' ');
		else
		    wbkgdset(LYwin, displayStyles[DSTYLE_NORMAL].color | ' ');
		LynxChangeStyle (a, STACK_OFF);
d1438 1
a1438 2
PRIVATE char *novice_lines ARGS1(
	int,		lineno)
d1454 1
a1454 1
PUBLIC void toggle_novice_line NOARGS
d1456 4
a1459 4
	lineno++;
	if (*novice_lines(lineno) == '\0')
		lineno = 0;
	return;
d1462 1
a1462 2
PUBLIC void noviceline ARGS1(
	int,		more_flag GCC_UNUSED)
a1463 1

d1467 2
a1468 2
    LYmove(LYlines-2,0);
    /* stop_reverse(); */
d1481 1
a1481 1
	LYaddstr((char *)novice_lines(lineno));
d1489 4
a1492 5
 *  Returns the file descriptor from which keyboard input is expected,
 *  or INVSOC (-1) if not available.
 *  If need_selectable is true, returns non-INVSOC fd only if select()
 *  is possible - actually, currently only checks if fd is connected
 *  to a tty. - kw
d1494 1
a1494 2
PUBLIC int LYConsoleInputFD ARGS1(
    BOOLEAN,		need_selectable)
d1497 1
d1502 3
a1504 3
    /* SLang_TT_Read_FD introduced in slang 0.99.19, from its changelog:
     *   SLang_TT_Read_FD variable is now available for unix.  This is the file
     *   descriptor used by SLang_getkey. */
d1508 1
a1508 1
#else  /* !USE_SLANG */
d1523 1
a1523 1
PRIVATE int fake_zap = 0;
d1525 1
a1525 2
PUBLIC void LYFakeZap ARGS1(
    BOOL,	set)
d1542 1
a1542 1
PRIVATE int DontCheck NOARGS
d1549 1
a1549 1
	return(TRUE);
d1551 2
a1552 2
    if (LYHaveCmdScript()) /* we may be running from a script */
	return(TRUE);
d1556 1
a1556 1
	return(TRUE);
d1566 2
a1567 1
	gettimeofday(&tv, (struct timezone *)0);
d1571 1
a1571 1
    next = time((time_t*)0);
d1580 1
a1580 1
PUBLIC int HTCheckForInterrupt NOARGS
d1584 2
a1585 1
#ifndef VMS /* UNIX stuff: */
d1597 1
a1597 1
	return((int)TRUE);
d1602 1
a1602 1
	return((int)FALSE);
d1615 1
a1615 1
	return(FALSE);
d1625 1
a1625 2
	ret = Rselect(1, (void *)&readfds, NULL, NULL,
		      &socket_timeout);
d1628 1
a1628 2
	ret = select(1, (void *)&readfds, NULL, NULL,
		     &socket_timeout);
d1632 1
a1632 1
	 return((int)FALSE);
d1635 2
a1636 2
    if (!FD_ISSET(0,&readfds))
	 return((int)FALSE);
d1641 1
a1641 1
    nodelay(LYwin,TRUE);
d1648 1
a1648 1
    nodelay(LYwin,FALSE);
d1652 1
a1652 1
    extern int typeahead();
d1659 1
a1659 1
	return((int)TRUE);
d1664 1
a1664 1
	return((int)FALSE);
d1669 1
a1669 1
	return((int)TRUE);
d1685 1
a1685 1
	return((int)TRUE);
d1687 6
a1692 6
	/* There is a subset of mainloop() actions available at this stage:
	** no new getfile() cycle is possible until the previous finished.
	** Currently we have scrolling in partial mode, toggling of trace
	** log, and pasting. User search now in progress...
	*/
    cmd = (LKC_TO_LAC(keymap,c));
d1694 1
a1694 1
    case LYK_TRACE_TOGGLE :	/*  Toggle TRACE mode. */
d1698 2
a1699 2
    case LYK_TO_CLIPBOARD: {	/* ^S */
	char *s = LYDownLoadAddress();
d1701 8
a1708 8
	if (!s || !*s || put_clip(s))
	    HTInfoMsg(gettext("Copy to clipboard failed."));
	else
	    HTInfoMsg(gettext("Download document URL put to clipboard."));
	break;
    }
#endif	/* defined CAN_CUT_AND_PASTE */
    default :
d1727 3
a1729 3
	    case LYK_FASTBACKW_LINK :
		if (Newline_partial <= (display_lines)+1) {
		    Newline_partial -= display_lines ;
d1736 1
a1736 1
		    Newline_partial -= display_lines ;
d1739 1
a1739 1
	    case LYK_FASTFORW_LINK :
d1743 6
a1748 6
			HTGetLinkOrFieldStart(HText_LinksInLines(HTMainText,
								 Newline_partial,
								 display_lines)
					      - 1,
					      &Newline_partial, NULL,
					      1, TRUE)) == LINK_LINE_FOUND) {
d1753 1
a1753 1
	    case LYK_PREV_PAGE :
d1755 3
a1757 3
		    Newline_partial -= display_lines ;
		break ;
	    case LYK_NEXT_PAGE :
d1759 3
a1761 3
		    Newline_partial += display_lines ;
		break ;
	    case LYK_UP_HALF :
d1763 3
a1765 3
		    Newline_partial -= (display_lines/2) ;
		break ;
	    case LYK_DOWN_HALF :
d1767 3
a1769 3
		    Newline_partial += (display_lines/2) ;
		break ;
	    case LYK_UP_TWO :
d1771 3
a1773 3
		    Newline_partial -= 2 ;
		break ;
	    case LYK_DOWN_TWO :
d1775 2
a1776 2
		    Newline_partial += 2 ;
		break ;
d1784 1
a1784 1
		    /* calculate for "current" bottom value */
d1786 3
a1788 3
	    case LYK_REFRESH :
		break ;
	    default :
d1790 2
a1791 2
		return ((int)FALSE) ;
	    } /* end switch */
d1799 1
a1799 1
    } /* end switch */
d1801 1
a1801 1
    return((int)FALSE);
d1808 1
a1808 2
PUBLIC BOOLEAN LYisAbsPath ARGS1(
	CONST char *,	path)
d1811 1
d1818 2
a1819 2
	 || (LYIsDosDrive(path)
	   && LYIsPathSep(path[2])));
d1831 1
a1831 2
PUBLIC BOOLEAN LYisRootPath ARGS1(
	CONST char *,		path)
d1835 2
a1836 2
     && LYIsDosDrive(path)
     && LYIsPathSep(path[2]))
d1843 2
a1844 2
 *  A file URL for a remote host is an obsolete ftp URL.
 *  Return YES only if we're certain it's a local file. - FM
d1846 1
a1846 2
PUBLIC BOOLEAN LYisLocalFile ARGS1(
	CONST char *,		filename)
d1865 2
a1866 2
	if (0==strcmp("file", acc_method) &&
	    (0==strcmp(host, "localhost") ||
d1880 2
a1881 2
 *  Utility for checking URLs with a host field.
 *  Return YES only if we're certain it's the local host. - FM
d1883 1
a1883 2
PUBLIC BOOLEAN LYisLocalHost ARGS1(
	CONST char *,		filename)
d1912 1
a1912 1
 *  Utility for freeing the list of local host aliases. - FM
d1914 1
a1914 1
PUBLIC void LYLocalhostAliases_free NOARGS
d1916 3
a1918 2
    char *alias;
    HTList *cur = localhost_aliases;
d1920 6
a1925 2
    if (!cur)
	return;
d1927 6
a1932 4
    while (NULL != (alias = (char *)HTList_nextObject(cur))) {
	FREE(alias);
    }
    HTList_delete(localhost_aliases);
a1933 1
    return;
d1937 1
a1937 1
 *  Utility for listing hosts to be treated as local aliases. - FM
d1939 1
a1939 2
PUBLIC void LYAddLocalhostAlias ARGS1(
	char *,		alias)
d1960 2
a1961 2
 *  Utility for checking URLs with a host field.
 *  Return YES only if we've listed the host as a local alias. - FM
d1963 1
a1963 2
PUBLIC BOOLEAN LYisLocalAlias ARGS1(
	CONST char *,		filename)
d1982 1
a1982 1
    while (NULL != (alias = (char *)HTList_nextObject(cur))) {
d1994 11
a2004 12
**  This function checks for a URL with an unknown scheme,
**  but for which proxying has been set up, and if so,
**  returns PROXY_URL_TYPE. - FM
**
**  If a colon is present but the string segment which
**  precedes it is not being proxied, and we can be sure
**  that what follows the colon is not a port field,
**  it returns UNKNOWN_URL_TYPE.  Otherwise, it returns
**  0 (not a URL). - FM
*/
PUBLIC int LYCheckForProxyURL ARGS1(
	char *,		filename)
d2011 1
a2011 1
     *	Don't crash on an empty argument.
d2014 1
a2014 1
	return(NOT_A_URL_TYPE);
d2023 3
a2025 1
    if ((cp1 = strchr((cp+1), ':')) != NULL) {
d2027 1
d2033 1
a2033 1
	    return(PROXY_URL_TYPE);
d2038 1
a2038 1
	    return(NOT_A_URL_TYPE);
d2042 1
a2042 1
	    return(NOT_A_URL_TYPE);
d2047 1
a2047 1
		return(UNKNOWN_URL_TYPE);
d2049 1
a2049 1
	    return(UNKNOWN_URL_TYPE);
d2053 1
a2053 1
    return(NOT_A_URL_TYPE);
d2060 3
a2062 4
static BOOLEAN compare_type ARGS3(
	char *,		tst,
	CONST char *,	cmp,
	size_t,		len)
d2067 1
d2083 12
a2094 13
**  Must recognize a URL and return the type.
**  If recognized, based on a case-insensitive
**  analysis of the scheme field, ensures that
**  the scheme field has the expected case.
**
**  Returns 0 (not a URL) for a NULL argument,
**  one which lacks a colon.
**
**  Chains to LYCheckForProxyURL() if a colon
**  is present but the type is not recognized.
*/
PUBLIC int is_url ARGS1(
	char *,		filename)
d2098 1
a2098 1
    int result = NOT_A_URL_TYPE;
d2103 1
a2103 1
     *	Don't crash on an empty argument.
d2106 1
a2106 1
	return(result);
d2109 1
a2109 1
     *	Can't be a URL if it lacks a colon.
d2112 1
a2112 1
	return(result);
d2115 1
a2115 1
     *	Kill beginning spaces.
d2120 4
a2123 5
     *	Can't be a URL if it starts with a slash.
     *	So return immediately for this common case,
     *	also to avoid false positives if there was
     *	a colon later in the string.  Also can't be
     *  a URL if it starts with a colon. - KW
d2134 2
a2135 2
	     *  Lynx internal pages ("LYNXfoo:" or "lynxfoo:")
	     *  start with 'l' or 'L', other URLs aren't.
d2139 3
a2141 3
		 *  Special External Lynx type to handle execution
		 *  of commands or scripts which require a pause to
		 *  read the screen upon completion.
d2147 3
a2149 3
		 *  Special External Lynx type to handle execution
		 *  of commands, scripts or programs with do not
		 *  require a pause to read screen upon completion.
d2155 1
a2155 1
		 *  Special External Lynx type to handle cgi scripts.
d2161 1
a2161 1
		 *  Special Internal Lynx type.
d2167 1
a2167 1
		 *  Special Internal Lynx type.
d2173 1
a2173 1
		 *  Special Internal Lynx type.
d2179 1
a2179 1
		 *  Special Internal Lynx type.
d2185 1
a2185 1
		 *  Special Internal Lynx type.
d2191 1
a2191 1
		 *  Special Internal Lynx type.
d2197 1
a2197 1
		 *  Special Internal Lynx type.
d2203 1
a2203 1
		 *  Special Internal Lynx type.
d2209 1
a2209 1
		 *  Special Internal Lynx type.
d2215 1
a2215 1
		 *  Special Internal Lynx type.
d2218 1
a2218 1
		(void)is_url(&cp[LEN_LYNXIMGMAP]);
d2223 1
a2223 1
		 *  Special Internal Lynx type.
d2230 1
a2230 1
	     *  NEWSfoo: schemes -
d2242 1
a2242 1
		 *  Special Lynx type to handle news posts.
d2248 1
a2248 1
		 *  Special Lynx type to handle news replies (followups).
d2255 1
a2255 1
	     *  SNEWSfoo: schemes -
d2264 1
a2264 1
		 *  Special Lynx type to handle snews posts.
d2270 1
a2270 1
		 *  Special Lynx type to handle snews replies (followups).
d2322 2
a2323 2
	    && ((cp1 = strchr(cp + 3, ':')) == NULL
	     || !DoubleHtmlSep(cp1 + 1))) {
d2331 2
a2332 2
		 && (cp1 - cp) > 1	/* exclude DOS-style device:/path */
		 && LYisAbsPath(cp1+1)) {
d2353 1
a2353 1
			 && (cp1 = strchr(cp+11,'/')) != NULL) {
d2355 1
a2355 1
			    if (TOUPPER(*(cp1+1)) == 'H' || *(cp1+1) == 'w')
d2358 1
a2358 1
			    else if (*(cp1+1) == 'T' || *(cp1+1) == '8')
d2360 1
a2360 1
			    else if (*(cp1+1) == '7')
d2427 4
a2430 4
 *  Sometimes it is just expected that curses is on when an alert or
 *  other statusline message needs to be shown and we are not just
 *  dumping immediately.  Calling this will 'fix' it, but may not
 *  always be appropriate. - kw
d2432 1
a2432 2
PUBLIC void LYFixCursesOn ARGS1(
    CONST char *,	reason)
d2443 12
a2454 13
 *  Most protocol modules called through HTLoad* expect that curses is on
 *  unless dump_output_immediately is set, so that statusline messages
 *  can be shown.  Some protocols expect the opposite, namely telnet and
 *  friends.  This function should be called after the 'physical' URL
 *  for accessing addr has been established.  It does the right thing
 *  to the degree that curses is turned on for known problem cases.
 *  In any normal circumstances this should never apply, but proxying
 *  or rule substitution is not prevented for telnet-like URLs, and
 *  this 'fix' avoids some crashes that can otherwise occur. - kw
 */
PUBLIC BOOLEAN LYFixCursesOnForAccess ARGS2(
    CONST char *,	addr,
    CONST char *,	physical)
d2457 1
a2457 1
     *  If curses is off when maybe it shouldn't...
d2461 1
d2463 2
a2464 2
	 *  If requested resource wants to be accessed with curses off, and
	 *  getfile() would indeed have turned curses off for it...
d2471 2
a2472 2
	      (cp1 = strchr(addr+11,'/')) != NULL &&
	      (*(cp1+1) == 'T' || *(cp1+1) == '8')))) {
d2474 2
a2475 2
	     *  If actual access that will be done is ok with curses off,
	     *  then do nothing special, else force curses on. - kw
d2481 1
a2481 2
		HTAlert(
		    gettext("Unexpected access protocol for this URL scheme."));
d2486 1
a2486 1
	return FALSE;
d2490 1
a2490 1
 *  Determine whether we allow HEAD and related flags for a URL. - kw
d2492 1
a2492 2
PUBLIC BOOLEAN LYCanDoHEAD ARGS1(
    CONST char *,	address)
d2496 1
d2517 3
a2519 3
     *  The idea of the following is to allow HEAD for news URLs that
     *  identify single articles, not those that identify ranges of
     *  articles or groups or a list of groups. - kw
d2524 1
a2536 1

d2538 3
a2540 3
/*  If defined, also allow head requests for URLs proxied through the
 *  "http" or "lynxcgi" protocols, which understand HEAD.  Only the
 *  proxy environment variables are checked, not the HTRules system. - kw
d2545 1
d2548 1
d2570 1
a2570 2
PUBLIC BOOLEAN LYCloseInput ARGS1(
	FILE *,		fp)
d2574 1
d2586 1
a2586 2
PUBLIC BOOLEAN LYCloseOutput ARGS1(
	FILE *,		fp)
d2590 1
d2603 1
a2603 2
PUBLIC BOOLEAN LYCanWriteFile ARGS1(
	CONST char*,	filename)
d2617 1
a2617 2
PUBLIC BOOLEAN LYCanReadFile ARGS1(
	CONST char*,	filename)
d2628 1
a2628 1
 *  Remove backslashes from any string.
d2630 1
a2630 2
PUBLIC void remove_backslashes ARGS1(
	char *,		buf)
d2634 1
a2634 1
    for (cp = buf; *cp != '\0' ; cp++) {
d2636 1
a2636 1
	if (*cp != '\\') { /* don't print slashes */
d2640 1
a2640 1
		   *(cp+1) == '\\') {	/* are two in a row	    */
d2650 2
a2651 3
 *  Checks to see if the current process is attached
 *  via a terminal in the local domain.
 *
d2653 1
a2653 1
PUBLIC BOOLEAN inlocaldomain NOARGS
d2674 2
a2675 2
		  me.ut_host + strlen(me.ut_host) - strlen(LYLocalDomain)) )
	    return(TRUE);
d2679 1
a2679 1
	    return(TRUE);
d2683 3
a2685 2
	CTRACE((tfp, "Could not get ttyname (returned %s) or open UTMP file %s\n",
		      (cp != 0) ? cp : "<null>", UTMP_FILE));
d2688 1
a2688 1
    return(FALSE);
d2691 1
a2691 1
    return(TRUE);
d2697 4
a2700 5
 *  An extended alternative for calling signal(), sets some flags for
 *  signal handler as we want them if that functionality is available.
 *  (We don't return anything from this function since the return
 *  value would currently be ignored anyway.) - kw
 *
d2702 2
a2703 3
PUBLIC void LYExtSignal ARGS2(
    int,			sig,
    LYSigHandlerFunc_t *,	handler)
d2709 1
d2727 7
a2733 6
 *  For switching a signal's handling between SIG_DFL and something
 *  (possibly) different that may have been set up by lynx code or
 *  e.g. by curses library.  Uses sigaction to preserve / restore as
 *  much state as possible.
 *  Second arg is where to save or restore from.
 *  Third arg to_dfl specifies what to do:
d2737 7
a2743 8
 *  Currently only used for SIGTSTP without SLANG, to prevent (n)curses
 *  signal handler from running while lynx is waiting in system() for
 *  an interactive command like an editor. - kw
 */
PRIVATE BOOLEAN LYToggleSigDfl ARGS3(
    int,			sig,
    struct sigaction *,		where,
    int,			to_dfl)
d2772 2
a2773 2
** This bit of code catches window size change signals
**/
d2790 3
a2792 3
#   endif /* HAVE_TERMIO_H */
#  endif /* HAVE_TERMIOS_H */
# endif	/* TERMIO_AND_TERMIOS */
d2795 1
a2795 2
PUBLIC void size_change ARGS1(
	int,		sig GCC_UNUSED)
d2805 1
a2805 1
    LYcols  = SLtt_Screen_Cols;
d2809 1
a2809 1
    SLtt_Screen_Cols = (LYcols-1) * 6;
d2813 1
a2813 1
    SLtt_Screen_Cols = HTMIN((LYcols-1) * 6, 255);
d2818 1
a2818 1
	 *  Called from start_curses().
d2825 1
d2872 1
a2872 1
     *	Check if the screen size has actually changed. - AJL
d2885 1
a2885 1
    LYExtSignal (SIGWINCH, size_change);
d2892 1
a2892 1
 *  Utility for freeing the list of previous suggested filenames. - FM
d2894 1
a2894 1
PUBLIC void HTSugFilenames_free NOARGS
d2896 1
a2896 10
    char *fname;
    HTList *cur = sug_filenames;

    if (!cur)
	return;

    while (NULL != (fname = (char *)HTList_nextObject(cur))) {
	FREE(fname);
    }
    HTList_delete(sug_filenames);
a2897 1
    return;
d2901 2
a2902 2
 *  Utility for listing suggested filenames, making any
 *  repeated filenames the most current in the list. - FM
d2904 1
a2904 2
PUBLIC void HTAddSugFilename ARGS1(
	char *,		fname)
d2906 1
a2906 1
    char *new = NULL;
d2913 1
a2913 1
    StrAllocCopy(new, fname);
d2920 1
a2920 1
	HTList_addObject(sug_filenames, new);
d2925 2
a2926 2
    while (NULL != (old = (char *)HTList_nextObject(cur))) {
	if (!strcmp(old, new)) {
d2932 1
a2932 1
    HTList_addObject(sug_filenames, new);
d2938 2
a2939 2
 *  CHANGE_SUG_FILENAME -- Foteos Macrides 29-Dec-1993
 *	Upgraded for use with Lynx2.2 - FM 17-Jan-1994
d2941 1
a2941 2
PUBLIC void change_sug_filename ARGS1(
	char *,		fname)
d2943 1
a2943 1
    CONST char *cp2;
d2945 1
d2952 1
a2952 1
     *	Establish the current end of fname.
d2957 1
a2957 1
     *	Unescape fname.
d2962 1
a2962 1
     *	Rename any temporary files.
d2973 1
a2973 1
	HTSprintf0(&temp, "file://localhost%s%d", cp2, (int)getpid());
d2975 1
a2975 1
	HTSprintf0(&temp, "file://localhost/%s%d", cp2, (int)getpid());
d2989 3
a2991 3
	 *  Hmm... we have a directory name.
	 *  It is annoying to see a scheme+host+path name as a suggested one,
	 *  let's remove the last_slash and go ahead like we have a file name. - LP
d2996 1
a2996 1
     *	Remove everything up the the last_slash if there is one.
d2998 1
a2998 1
    if ((cp = strrchr(fname,'/')) != NULL && strlen(cp) > 1) {
d3001 1
a3001 1
	 *  Go past the slash.
d3009 2
a3010 2
#ifdef _WINDOWS	/* 1998/05/05 (Tue) 10:08:05 */
    if ((cp = strrchr(fname,'=')) != NULL && strlen(cp) > 1) {
d3013 1
a3013 1
	 *  Go past the '='.
d3024 1
a3024 1
     *	Trim off date-size suffix, if present.
d3034 1
a3034 1
     *	Trim off VMS device and/or directory specs, if present.
d3036 2
a3037 2
    if ((cp = strchr(fname,'[')) != NULL &&
	(cp1 = strrchr(cp,']')) != NULL && strlen(cp1) > 1) {
d3039 1
a3039 1
	for (cp=fname; *cp1 != '\0'; cp1++) {
a3043 1

d3046 1
a3046 1
     *	Replace illegal or problem characters.
d3051 1
a3051 1
	 *  Replace with underscores.
d3056 3
a3058 3
	/*
	 *  Replace with dashes.
	 */
d3060 1
a3060 1
		   *cp == ',' || *cp == ':' || *cp == '\"' ||
d3066 1
a3066 1
		   *cp <  ' ' || (UCH(*cp)) > 126) {
d3072 1
a3072 1
     *	Collapse any serial underscores.
d3086 1
a3086 1
     *	Collapse any serial dashes.
d3094 1
a3094 1
	}  else {
d3101 1
a3101 2
     *	Trim any trailing or leading
     *	underscores or dashes.
d3121 4
a3124 7
     *	Replace all but the last period with _'s, or second
     *	to last if last is followed by a terminal Z or z,
     *	or GZ or gz,
     *	e.g., convert foo.tar.Z to
     *		      foo.tar_Z
     *	  or, convert foo.tar.gz to
     *		      foo.tar-gz
d3129 1
a3129 1
	    if ((fname[j-1] == '.') &&
d3133 2
a3134 2
	    } else if (((TOUPPER(fname[j-1]) == 'G') &&
			fname[j-2] == '.') &&
d3146 2
a3147 2
	 *  But if the root is > 39 characters, move
	 *  the period appropriately to the left.
d3152 1
a3152 1
		*cp  = '.';
d3155 1
a3155 1
		*cp  = '.';
d3160 1
a3160 1
		    fname[j] = fname[j-1];
d3177 1
a3177 1
	 *  Make sure the extension is < 40 characters.
d3184 1
a3184 1
	 *  Trim trailing dashes or underscores.
d3192 2
a3193 3
	 *  No period, so put one on the end, or after
	 *  the 39th character, trimming trailing dashes
	 *  or underscores.
d3209 1
a3209 1
     *	Replace problem characters.
d3213 5
a3217 5
	    case '\'':
	    case '\"':
	    case '/':
	    case ' ':
		*cp = '-';
d3223 1
a3223 1
     *	Make sure the rest of the original string in nulled.
d3236 3
a3238 4
PRIVATE int fmt_tempname ARGS3(
	char *,		result,
	CONST char *,	prefix,
	CONST char *,	suffix)
d3241 1
d3261 1
a3261 1
	lynx_srand((unsigned)((long)time((time_t *)0) + (long)result));
d3272 2
a3273 1
	counter = (unsigned)(( (float)MAX_TEMPNAME * lynx_rand() ) / LYNX_RAND_MAX + 1);
d3302 1
a3302 1
    sprintf(leaf, "%04x%04x", counter, (unsigned)GETPID());
d3304 1
a3304 1
    sprintf(leaf, "%u%u", counter, (unsigned)getpid());
d3309 2
a3310 1
	CONST char *tail = strchr(suffix, '.');
d3318 1
a3318 1
    sprintf(leaf, "L%u-%uTMP%s", (unsigned)getpid(), counter, suffix);
d3327 1
a3327 1
	sprintf(result, "%.*s", LY_MAXPATH-1, leaf);
d3335 1
a3335 1
 *  Convert 4, 6, 2, 8 to left, right, down, up, etc.
d3337 1
a3337 2
PUBLIC int number2arrows ARGS1(
	int,		number)
d3339 28
a3366 28
    switch(number) {
	case '1':
	    number=END_KEY;
	    break;
	case '2':
	    number=DNARROW;
	    break;
	case '3':
	    number=PGDOWN;
	    break;
	case '4':
	    number=LTARROW;
	    break;
	case '5':
	    number=DO_NOTHING;
	    break;
	case '6':
	    number=RTARROW;
	    break;
	case '7':
	    number=HOME;
	    break;
	case '8':
	    number=UPARROW;
	    break;
	case '9':
	    number=PGUP;
	    break;
d3369 1
a3369 1
    return(number);
d3373 2
a3374 2
 *  parse_restrictions takes a string of comma-separated restrictions
 *  and sets the corresponding flags to restrict the facilities available.
d3376 3
a3378 3
/* The first two are special: we want to record whether "default" or
 * "all" restrictions were applied, in addition to the detailed effects
 * of those options. - kw
d3382 3
a3384 3

PRIVATE CONST struct {
    CONST char *name;
d3478 1
d3480 8
a3487 9
/*  This will make no difference between '-' and '_'. It does only in/equality
    compare. It assumes that p2 can't contain dashes, but p1 can.
    This function is also used (if macro OPTNAME_ALLOW_DASHES doesn't have
    value of zero) for compare of commandline options -VH
 */
PUBLIC BOOL strn_dash_equ ARGS3(
	CONST char*,	p1,
	CONST char*,	p2,
	int,		len)
d3491 1
a3491 1
	    return 0;/* canonical name is shorter */
d3493 10
a3502 1
	    case 0:
a3503 9
	    case '-':
	    case '_':
		if (*p2!='_')
		    return 0;
		else
		    break;
	    default:
		if (*p1!=*p2)
		    return 0;
d3505 2
a3506 1
	++p1; ++p2;
d3528 1
a3528 2
PUBLIC CONST char *index_to_restriction ARGS1(
    int,	inx)
d3539 2
a3540 3
PUBLIC int find_restriction ARGS2(
    CONST char *,	name,
    int,		len)
d3543 1
d3546 1
a3546 1
    for (i=0; i < TABLESIZE(restrictions); i++) {
d3554 1
a3554 2
PUBLIC void parse_restrictions ARGS1(
    CONST char *,	s)
d3556 2
a3557 2
    CONST char *p;
    CONST char *word;
d3571 1
a3571 1
	if (RESTRICT_NM_EQU(word, "all", p-word)) {
d3573 3
a3575 1
	    for (i = N_SPECIAL_RESTRICT_OPTIONS; i < TABLESIZE(restrictions); i++)
d3577 1
a3577 1
	} else if (RESTRICT_NM_EQU(word, "default", p-word)) {
d3579 3
a3581 1
	    for (i = N_SPECIAL_RESTRICT_OPTIONS; i < TABLESIZE(restrictions); i++)
d3584 2
a3585 2
	    for (i=0; i < TABLESIZE(restrictions); i++) {
		if (RESTRICT_NM_EQU(word, restrictions[i].name, p-word)) {
d3593 2
a3594 2
	    printf("%s: %.*s\n", gettext("unknown restriction"), p-word, word);
	    exit(EXIT_FAILURE);
d3613 1
a3613 2
PUBLIC void print_restrictions_to_fd ARGS1(
    FILE *,	fp)
d3617 1
a3617 1
    for (i=0; i < TABLESIZE(restrictions); i++) {
d3627 1
a3627 1
    for (i=0; i < TABLESIZE(restrictions); i++) {
d3633 1
a3633 1
	     || !no_goto)
d3644 5
a3648 6
typedef struct _VMSMailItemList
{
  short buffer_length;
  short item_code;
  void *buffer_address;
  long *return_length_address;
d3651 1
a3651 1
PUBLIC void LYCheckMail NOARGS
d3661 1
d3671 2
d3683 1
a3683 1
	status = sys$getjpiw(0,0,0,jpi_list,0,0,0);
d3699 1
a3699 1
    status = mail$user_begin(&ucontext,null_list,null_list);
d3706 1
a3706 1
    status = mail$user_get_info(&ucontext,uilist,uolist);
d3726 1
a3726 1
    mail$user_end((long *)&ucontext,null_list,null_list);
d3730 1
a3730 1
PUBLIC void LYCheckMail NOARGS
d3754 2
a3755 2
    if ((stat(mf,&st) < 0)
     || !S_ISREG(st.st_mode)) {
d3762 1
a3762 1
	 || ((lastsize != 0) && (st.st_size > lastsize)))
d3774 14
a3787 15
**  This function ensures that an href will be
**  converted to a fully resolved, absolute URL,
**  with guessing of the host or expansions of
**  lead tildes via LYConvertToURL() if needed,
**  and tweaking/simplifying via HTParse().  It
**  is used for LynxHome, startfile, homepage,
**  and 'g'oto entries, after they have been
**  passed to LYFillLocalFileURL(). - FM
**  Such URLs have no `base' reference to which they
**  could be resolved.  LYLegitimizeHREF could not be used.
*/
PUBLIC void LYEnsureAbsoluteURL ARGS3(
	char **,	href,
	CONST char *,	name,
	int,		fixit)
d3794 3
a3796 3
   /*
    *  Check whether to fill in localhost. - FM
    */
d3800 1
a3800 1
     *	If it is not a URL then make it one.
d3810 1
a3810 1
		    NonNull(name), (name ? " " : ""), *href));
d3821 6
a3826 8
 *  Rewrite and reallocate a previously allocated string
 *  as a file URL if the string resolves to a file or
 *  directory on the local system, otherwise as an
 *  http URL. - FM
 */
PUBLIC void LYConvertToURL ARGS2(
	char **,	AllocatedString,
	int,		fixit)
d3831 1
d3842 2
a3843 1
	for(; *cp_url != '\0'; cp_url++)
d3852 1
a3852 1
    *AllocatedString = NULL;  /* so StrAllocCopy doesn't free it */
d3857 1
d3859 1
a3859 1
	StrAllocCat(*AllocatedString,"/");
d3863 1
a3863 1
	 *  Not a SHELL pathspec.  Get the full VMS spec and convert it.
d3868 1
d3873 2
a3874 3
	     *	On VMS, we'll accept '~' on the command line as
	     *	Home_Dir(), and assume the rest of the path, if
	     *	any, has SHELL syntax.
d3879 3
a3881 3
		 *  Append rest of path, if present, skipping "user" if
		 *  "~user" was entered, simplifying, and eliminating
		 *  any residual relative elements. - FM
d3891 1
a3891 1
	    LYstrncpy(url_file, old_string, sizeof(url_file)-1);
d3894 2
a3895 2
	if (1&lib$find_file(&url_file_dsc, &file_name_dsc, &context,
			    0, 0, 0, 0)) {
d3897 1
a3897 1
	     *	We found the file.  Convert to a URL pathspec.
d3912 1
a3912 1
	} else if ((NULL != getcwd(dir_name, sizeof(dir_name)-1, 0)) &&
d3919 1
a3919 1
	    if (NULL != getcwd(dir_name, sizeof(dir_name)-1, 0)) {
d3931 2
a3932 3
		 *  Nope.  Assume it's an http URL with
		 *  the "http://" defaulted, if we can't
		 *  rule out a bad VMS path.
d3938 1
a3938 1
		    !LYExpandHostForURL((char **)&old_string,
d3942 3
a3944 3
		     *	Probably a bad VMS path (but can't be
		     *	sure).	Use original pathspec for the
		     *	error message that will result.
d3946 4
a3949 3
		    sprintf(url_file, "/%.*s", sizeof(url_file)-2, old_string);
		    CTRACE((tfp, "Can't find '%s'  Will assume it's a bad path.\n",
				old_string));
d3953 2
a3954 2
		     *	Assume a URL is wanted, so guess the
		     *	scheme with "http://" as the default. - FM
d3956 1
a3956 1
		    if (!LYAddSchemeForURL((char **)&old_string, "http://")) {
d3966 2
a3967 3
	     *	Nothing found.	Assume it's an http URL
	     *	with the "http://" defaulted, if we can't
	     *	rule out a bad VMS path.
d3975 1
a3975 1
		!LYExpandHostForURL((char **)&old_string,
d3979 2
a3980 3
		 *  Probably a bad VMS path (but can't be
		 *  sure).  Use original pathspec for the
		 *  error message that will result.
d3982 1
a3982 1
		sprintf(url_file, "/%.*s", sizeof(url_file)-2, old_string);
d3984 1
a3984 1
			    old_string));
d3988 2
a3989 2
		 *  Assume a URL is wanted, so guess the
		 *  scheme with "http://" as the default. - FM
d3991 1
a3991 1
		if (!LYAddSchemeForURL((char **)&old_string, "http://")) {
d4001 1
a4001 1
have_VMS_URL:
d4012 1
a4012 1
			fullpath, &filepart);
d4018 1
a4018 1
				old_string, *AllocatedString));
d4026 1
a4026 1
	     *	They want .
d4029 1
d4034 1
a4034 1
			old_string, *AllocatedString));
d4041 1
a4041 1
	     *	On Unix, convert '~' to Home_Dir().
d4046 3
a4048 3
		 *  Append rest of path, if present, skipping "user" if
		 *  "~user" was entered, simplifying, and eliminating
		 *  any residual relative elements. - FM
d4056 1
a4056 1
			old_string, *AllocatedString));
d4059 1
a4059 1
	     *	Create a full path to the current default directory.
d4064 2
a4065 1
	    Current_Dir (curdir);
d4067 2
a4068 2
	     *	Concatenate and simplify, trimming any
	     *	residual relative elements. - FM
d4096 1
a4096 1
		 *  It is a subdirectory or file on the local system.
d4113 1
a4113 1
			    old_string, *AllocatedString));
d4117 1
d4122 1
a4122 1
		HTUnEscape(cp);   /* unescape given path without fragment */
d4124 1
a4124 1
		StrAllocCopy(cp2, temp2);	/* keep a copy in cp2	  */
d4126 1
a4126 1
#ifdef WIN_EX	/* 1998/07/31 (Fri) 09:09:03 */
d4134 3
a4136 3
		     *	It is a subdirectory or file on the local system
		     *	with escaped characters and/or a fragment to be
		     *	appended to the URL. - FM
d4142 2
a4143 2
			 *  LYTrimRelFromAbsPath did nothing, use
			 *  old_string as given. - kw
d4157 1
a4157 1
				old_string, *AllocatedString));
d4163 4
a4166 5
		     *	If PWD has some unusual characters, construct a
		     *	filename in temp where those are escaped.  This
		     *	is mostly to prevent this function from returning
		     *	with some weird URL if the LYExpandHostForURL tests
		     *	further down fail. - kw
d4171 2
a4172 2
			 *  LYTrimRelFromAbsPath did nothing, use
			 *  old_string as given. - kw
d4190 3
a4192 3
		 *  It's not an accessible subdirectory or file on the
		 *  local system, so assume it's a URL request and guess
		 *  the scheme with "http://" as the default.
d4195 2
a4196 2
			    temp2 ? temp2 : temp));
#ifdef WIN_EX  /* 1998/01/13 (Tue) 09:07:37 */
d4198 1
a4198 1
		    CONST char *p, *q;
d4206 1
a4206 1
			    "'%s' not exist, Goto LynxHome '%s'.", q, p);
d4215 1
a4215 1
		if (LYExpandHostForURL((char **)&old_string,
d4217 2
a4218 3
				       URLDomainSuffixes))
		{
		    if (!LYAddSchemeForURL((char **)&old_string, "http://")) {
d4225 1
a4225 1
		  /* RW 1998Mar16  Restore AllocatedString to 'old_string' */
d4232 1
a4232 1
	Retry:
d4242 1
a4242 1
	 *  Path begins with a slash.  Simplify and use it.
d4246 2
a4247 3
	     *	Request for root.  Respect it on Unix, but
	     *	on VMS we treat that as a listing of the
	     *	login directory. - FM
d4256 1
a4256 2
	     *	It is an absolute directory or file
	     *	on the local system. - KW
d4266 1
a4266 1
			old_string, *AllocatedString));
d4270 2
a4271 2
	     *	Has a Home_Dir() reference.  Handle it
	     *	as if there weren't a lead slash. - FM
d4276 3
a4278 3
		 *  Append rest of path, if present, skipping "user" if
		 *  "~user" was entered, simplifying, and eliminating
		 *  any residual relative elements. - FM
d4287 2
a4288 2
	     *	Normal absolute path.  Simplify, trim any
	     *	residual relative elements, and append it. - FM
d4296 1
a4296 1
		    old_string, *AllocatedString));
d4303 1
a4303 1
#if defined(_WINDOWS) /* 1998/06/23 (Tue) 16:45:20 */
d4305 1
a4305 1
PUBLIC int win32_check_interrupt(void)
d4337 23
a4359 24
 *  This function rewrites and reallocates a previously allocated
 *  string so that the first element is a confirmed Internet host,
 *  and returns TRUE, otherwise it does not modify the string and
 *  returns FALSE.  It first tries the element as is, then, if the
 *  element does not end with a dot, it adds prefixes from the
 *  (comma separated) prefix list argument, and, if the element
 *  does not begin with a dot, suffixes from the (comma separated)
 *  suffix list arguments (e.g., www.host.com, then www.host,edu,
 *  then www.host.net, then www.host.org).  The remaining path, if
 *  one is present, will be appended to the expanded host.  It also
 *  takes into account whether a colon is in the element or suffix,
 *  and includes that and what follows as a port field for the
 *  expanded host field (e.g, wfbr:8002/dir/lynx should yield
 *  www.wfbr.edu:8002/dir/lynx).  The calling function should
 *  prepend the scheme field (e.g., http://), or pass the string
 *  to LYAddSchemeForURL(), if this function returns TRUE. - FM
 */
PUBLIC BOOLEAN LYExpandHostForURL ARGS3(
	char **,	AllocatedString,
	char *,		prefix_list,
	char *,		suffix_list)
{
    char DomainPrefix[80], *StartP, *EndP;
    char DomainSuffix[80], *StartS, *EndS;
d4366 1
d4373 2
a4374 3
     *	If it's a NULL or zero-length string,
     *	or if it begins with a slash or hash,
     *	don't continue pointlessly. - FM
d4382 1
a4382 2
     *	If it's a partial or relative path,
     *	don't continue pointlessly. - FM
d4390 3
a4392 4
     *	Make a clean copy of the string, and trim off the
     *	path if one is present, but save the information
     *	so we can restore the path after filling in the
     *	Host[:port] field. - FM
d4397 1
a4397 2
	 *  Have a path.  Any fragment should
	 *  already be included in Path. - FM
d4402 2
a4403 3
	 *  No path, so check for a fragment and
	 *  trim that, to be restored after filling
	 *  in the Host[:port] field. - FM
d4409 3
a4411 4
     *	If the potential host string has a colon, assume it
     *	begins a port field, and trim it off, but save the
     *	information so we can restore the port field after
     *	filling in the host field. - FM
d4423 1
a4423 2
     *	Do a DNS test on the potential host field
     *	as presently trimmed. - FM
a4434 1

d4447 1
a4447 1
	 *  Clear any residual interrupt. - FM
d4451 2
a4452 2
	    "LYExpandHostForURL: Ignoring interrupt because '%s' resolved.\n",
			host));
d4456 1
a4456 1
	 *  Return success. - FM
d4463 1
a4463 3
    }
    else if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED))
    {
d4465 1
a4465 1
	 *  Give the user chance to interrupt lookup cycles. - KW & FM
d4468 2
a4469 2
	"LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
		    host));
d4472 1
a4472 1
	 *  Return failure. - FM
d4481 9
a4489 10
     *	Set the first prefix, making it a zero-length string
     *	if the list is NULL or if the potential host field
     *	ends with a dot. - FM
     */
    StartP = ((prefix_list && Str[strlen(Str)-1] != '.') ?
					     prefix_list : "");
    /*
     *	If we have a prefix, but the allocated string is
     *	one of the common host prefixes, make our prefix
     *	a zero-length string. - FM
d4506 1
a4506 1
	StartP++;	/* Skip whitespace and separators */
d4510 1
a4510 1
	EndP++;		/* Find separator */
d4515 1
a4515 1
     *	Test each prefix with each suffix. - FM
d4519 2
a4520 3
	 *  Set the first suffix, making it a zero-length string
	 *  if the list is NULL or if the potential host field
	 *  begins with a dot. - FM
d4522 3
a4524 2
	StartS = ((suffix_list && *Str != '.') ?
				   suffix_list : "");
d4526 1
a4526 1
	    StartS++;	/* Skip whitespace and separators */
d4530 1
a4530 1
	    EndS++;	/* Find separator */
d4535 1
a4535 1
	 *  Create domain names and do DNS tests. - FM
d4540 2
a4541 2
	    if (Host[strlen(Host)-1] == '.') {
		Host[strlen(Host)-1] = '\0';
d4564 1
a4564 1
		 *  Give the user chance to interrupt lookup cycles. - KW
d4566 1
a4566 2
		if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED))
		{
d4568 2
a4569 2
	"LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
				host));
d4574 1
a4574 1
		    return FALSE; /* We didn't find a valid name. */
d4578 1
a4578 1
		 *  Advance to the next suffix, or end of suffix list. - FM
d4590 1
a4590 1
	}  while ((GotHost == FALSE) && (*DomainSuffix != '\0'));
d4593 12
a4604 12
	   /*
	    *  Advance to the next prefix, or end of prefix list. - FM
	    */
	   StartP = ((*EndP == '\0') ? EndP : (EndP + 1));
	   while ((*StartP) && (WHITE(*StartP) || *StartP == ',')) {
	       StartP++;	/* Skip whitespace and separators */
	   }
	   EndP = StartP;
	   while (*EndP && !WHITE(*EndP) && *EndP != ',') {
	       EndP++;		/* Find separator */
	   }
	   LYstrncpy(DomainPrefix, StartP, (EndP - StartP));
d4609 3
a4611 4
     *	If a test passed, restore the port field if we had one
     *	and there is no colon in the expanded host, and the path
     *	if we had one, and reallocate the original string with
     *	the expanded Host[:port] field included. - FM
d4630 1
a4630 1
     *	Clear any residual interrupt. - FM
d4633 4
a4636 3
	CTRACE((tfp, "LYExpandHostForURL: Ignoring interrupt because '%s' %s.\n",
		    host,
		    (GotHost ? "resolved" : "timed out")));
d4640 1
a4640 1
     *	Clean up and return the last test result. - FM
d4650 10
a4659 12
 *  This function rewrites and reallocates a previously allocated
 *  string that begins with an Internet host name so that the string
 *  begins with its guess of the scheme based on the first field of
 *  the host name, or the default scheme if no guess was made, and
 *  returns TRUE, otherwise it does not modify the string and returns
 *  FALSE.  It also returns FALSE without modifying the string if the
 *  default_scheme argument was NULL or zero-length and no guess was
 *  made. - FM
  */
PUBLIC BOOLEAN LYAddSchemeForURL ARGS2(
	char **,	AllocatedString,
	char *,		default_scheme)
d4665 2
a4666 2
     *	If we were passed a NULL or zero-length string,
     *	don't continue pointlessly. - FM
d4677 2
a4678 2
	 *  This could be either http or https, so check
	 *  the default and otherwise use "http". - FM
d4712 2
a4713 2
	 *  This could be either news, snews, or nntp, so
	 *  check the default, and otherwise use news. - FM
d4731 2
a4732 2
     *	If we've make a guess, use it.	Otherwise, if we
     *	were passed a default scheme prefix, use that. - FM
d4753 6
a4758 7
 *  This function expects an absolute Unix or VMS SHELL path
 *  spec as an allocated string, simplifies it, and trims out
 *  any residual relative elements.  It also checks whether
 *  the path had a terminal slash, and if it didn't, makes
 *  sure that the simplified path doesn't either.  If it's
 *  a directory, our convention is to exclude "Up to parent"
 *  links when a terminal slash is present. - FM
d4760 1
a4760 2
PUBLIC void LYTrimRelFromAbsPath ARGS1(
	char *,		path)
d4767 1
a4767 1
     *	Make sure we have a pointer to an absolute path. - FM
d4773 1
a4773 1
     *	Check whether the path has a terminal slash. - FM
d4778 1
a4778 1
     *	Simplify the path and then do any necessary trimming. - FM
d4785 1
a4785 1
	     *	Eliminate trailing dot. - FM
d4790 1
a4790 1
	     *	Skip over the "/." of a "/./". - FM
d4795 1
a4795 1
	     *	Eliminate trailing dotdot. - FM
d4800 1
a4800 1
	     *	Skip over the "/.." of a "/../". - FM
d4805 1
a4805 1
	     *	Done trimming. - FM
d4812 2
a4813 3
     *	Load any shifts into path, and eliminate any
     *	terminal slash created by HTSimplify() or our
     *	walk, but not present originally. - FM
d4826 1
a4826 1
 *  Example Client-Side Include interface.
d4828 8
a4835 10
 *  This is called from SGML.c and simply returns markup for reporting
 *  the URL of the document being loaded if a comment begins with
 *  "<!--#lynxCSI".  The markup will be included as if it were in the
 *  document.  Move this function to a separate module for doing this
 *  kind of thing seriously, someday. - FM
 */
PUBLIC void LYDoCSI ARGS3(
	char *,		url,
	CONST char *,	comment,
	char **,	csi)
d4837 1
a4837 1
    CONST char *cp = comment;
d4857 2
a4858 2
 *  Define_VMSLogical -- Fote Macrides 04-Apr-1995
 *	Define VMS logicals in the process table.
d4860 2
a4861 3
PUBLIC void Define_VMSLogical ARGS2(
	char *,		LogicalName,
	char *,		LogicalValue)
d4886 1
a4886 1
PRIVATE void LYHomeDir_free NOARGS
d4892 1
a4892 2
PUBLIC char * Current_Dir ARGS1(
	char *,	pathname)
d4895 1
d4897 1
a4897 1
    result = getcwd (pathname, LY_MAXPATH);
d4899 1
a4899 1
    result = getwd (pathname);
d4910 1
a4910 2
PRIVATE char * CheckDir ARGS1(
    char *,	path)
d4913 1
d4916 1
a4916 1
	 || !S_ISDIR(stat_info.st_mode))) {
d4925 1
a4925 1
PRIVATE char *HomeEnv NOARGS
d4968 1
a4968 1
PUBLIC CONST char * Home_Dir NOARGS
d4970 1
a4970 1
    static CONST char *homedir = NULL;
d4977 1
a4977 1
	     && (cp = LYGetEnv("SYS$SCRATCH")) == NULL) {
d4985 1
a4985 1
	     *	One could use getlogin() and getpwnam() here instead.
d4995 1
a4995 1
		 *  Use /tmp; it should be writable.
d5004 1
a5004 1
	homedir = (CONST char *)HomeDir;
d5011 1
a5011 1
	exit(EXIT_FAILURE);
d5021 1
a5021 1
PUBLIC char *LYPathLeaf ARGS1(char *, pathname)
d5024 1
d5037 2
a5038 1
    for (leaf = 0, n = strlen(pathname)-1; n >= 0; n--) {
d5050 10
a5059 12
 *  This function checks the acceptability of file paths that
 *  are intended to be off the home directory.	The file path
 *  should be passed in fbuffer, together with the size of the
 *  buffer.  The function simplifies the file path, and if it
 *  is acceptable, loads it into fbuffer and returns TRUE.
 *  Otherwise, it does not modify fbuffer and returns FALSE.
 *  If a subdirectory is present and the path does not begin
 *  with "./", that is prefixed to make the situation clear. - FM
 */
PUBLIC BOOLEAN LYPathOffHomeOK ARGS2(
	char *,		fbuffer,
	size_t,		fbuffer_size)
d5065 1
a5065 1
     *	Make sure we have an fbuffer and a string in it. - FM
d5068 1
a5068 1
	return(FALSE);
d5074 2
a5075 2
     *	Check for an inappropriate reference to the
     *	home directory, and correct it if we can. - FM
d5081 1
a5081 1
	     *	Reject "sys$login". - FM
d5084 1
a5084 1
	    return(FALSE);
d5090 3
a5092 4
		 *  Reject "sys$login:".  Otherwise, we have
		 *  converted "sys$login:file" to "file", or
		 *  have left a strange path for VMS as it
		 *  was originally. - FM
d5095 1
a5095 1
		return(FALSE);
d5105 1
a5105 2
		     *	Convert "~/subdir(s)/file"
		     *	to "./subdir(s)/file". - FM
d5110 1
a5110 1
		     *	Convert "~/file" to "file". - FM
d5116 1
a5116 1
		 *  Reject "~/". - FM
d5119 1
a5119 1
		return(FALSE);
d5123 1
a5123 1
	    cp = (cp1 - 1) ;
d5127 3
a5129 4
		     *	Convert "~user/subdir(s)/file" to
		     *	"./subdir(s)/file".  If user is someone
		     *	else, we covered a spoof.  Otherwise,
		     *	we simplified. - FM
d5134 1
a5134 1
		     *	Convert "~user/file" to "file". - FM
d5140 1
a5140 1
		 *  Reject "~user/". - FM
d5143 1
a5143 1
		return(FALSE);
d5147 1
a5147 1
	     *	Reject "~user". - FM
d5150 1
a5150 1
	    return(FALSE);
a5152 1

d5155 1
a5155 1
     *	Check for VMS path specs, and reject if still present. - FM
d5159 1
a5159 1
	return(FALSE);
d5164 1
a5164 1
     *	Check for a URL or absolute path, and reject if present. - FM
d5168 1
a5168 1
	return(FALSE);
d5172 1
a5172 1
     *	Simplify it. - FM
d5177 1
a5177 1
     *	Check if it has a pointless "./". - FM
d5186 1
a5186 1
     *	Check for spoofing. - FM
d5189 4
a5192 4
     || LYIsPathSep(*cp)
     || LYIsPathSep(cp[(strlen(cp) - 1)])
     || strstr(cp, "..") != NULL
     || !strcmp(cp, ".")) {
d5194 1
a5194 1
	return(FALSE);
d5198 2
a5199 2
     *	Load what we have at this point into fbuffer,
     *	trimming if too long, and claim it's OK. - FM
d5203 2
a5204 2
	 *  We have a subdirectory and no lead "./", so
	 *  prefix it to make the situation clear. - FM
d5216 1
a5216 1
    return(TRUE);
d5220 11
a5230 13
 *  This function appends fname to the home path and returns
 *  the full path and filename.  The fname string can be just
 *  a filename (e.g., "lynx_bookmarks.html"), or include a
 *  subdirectory off the home directory, in which case fname
 *  should begin with "./" (e.g., ./BM/lynx_bookmarks.html)
 *  Use LYPathOffHomeOK() to check and/or fix up fname before
 *  calling this function.  On VMS, the resultant full path
 *  and filename are converted to VMS syntax. - FM
 */
PUBLIC void LYAddPathToHome ARGS3(
	char *,		fbuffer,
	size_t,		fbuffer_size,
	char *,		fname)
d5233 1
a5233 1
    char *file = fname;
d5237 1
a5237 1
     *	Make sure we have a buffer. - FM
d5248 1
a5248 1
     *	Make sure we have a file name. - FM
d5254 1
a5254 1
     *	Set up home string and length. - FM
d5265 1
a5265 1
	 *  Home_Dir() has a bug if this ever happens. - FM
d5272 3
a5274 3
	 *  Buffer is smaller than or only big enough for the home path.
	 *  Load what fits of the home path and return.  This will fail,
	 *  but we need something in the buffer. - FM
a5279 1

d5282 1
a5282 1
     *	Check whether we have a subdirectory path or just a filename. - FM
d5286 1
a5286 1
	 *  We have a subdirectory path. - FM
d5288 1
a5288 1
	if (home[strlen(home)-1] == ']') {
d5290 2
a5291 3
	     *	We got the home directory, so convert it to
	     *	SHELL syntax and append subdirectory path,
	     *	then convert that to VMS syntax. - FM
d5294 1
d5301 1
a5301 1
	     *	This will fail, but we need something in the buffer. - FM
d5307 1
a5307 1
	 *  We have a file in the home directory. - FM
d5313 1
a5313 1
     *	Check whether we have a subdirectory path or just a filename. - FM
d5316 1
a5316 1
		     (strncmp(file, "./", 2) ? file : (file + 2)));
d5326 1
a5326 2
PUBLIC char * LYAddPathToSave ARGS1(
	char *,		fname)
d5337 1
d5346 1
a5346 1
 *  This function takes a string in the format
d5350 12
a5361 14
 *  as an argument, and returns its conversion to clock format
 *  (seconds since 00:00:00 Jan 1 1970), or 0 if the string
 *  doesn't match the expected pattern.  It also returns 0 if
 *  the time is in the past and the "absolute" argument is FALSE.
 *  It is intended for handling 'expires' strings in Version 0
 *  cookies homologously to 'max-age' strings in Version 1 cookies,
 *  for which 0 is the minimum, and greater values are handled as
 *  '[max-age seconds] + time(NULL)'.	If "absolute" if TRUE, we
 *  return the clock format value itself, but if anything goes wrong
 *  when parsing the expected patterns, we still return 0. - FM
 */
PUBLIC time_t LYmktime ARGS2(
	char *,		string,
	BOOL,		absolute)
d5370 1
a5370 1
     *	Make sure we have a string to parse. - FM
d5373 1
a5373 1
	return(0);
d5378 2
a5379 2
     *	Skip any lead alphabetic "Day, " field and
     *	seek a numeric day field. - FM
d5384 1
a5384 1
	return(0);
d5387 1
a5387 1
     *	Get the numeric day and convert to an integer. - FM
d5393 2
a5394 2
	return(0);
    LYstrncpy(temp, start, (int)(s - start));
d5397 1
a5397 1
	return(0);
d5400 1
a5400 1
     *	Get the month string and convert to an integer. - FM
d5405 1
a5405 1
	return(0);
d5412 1
a5412 1
	return(0);
d5415 73
a5487 73
	case '0':
	case '1':
	    month = atoi(temp);
	    if (month < 1 || month > 12) {
		return(0);
	    }
	    break;
	case 'A':
	    if (!strcasecomp(temp, "Apr")) {
		month = 4;
	    } else if (!strcasecomp(temp, "Aug")) {
		month = 8;
	    } else {
		return(0);
	    }
	    break;
	case 'D':
	    if (!strcasecomp(temp, "Dec")) {
		month = 12;
	    } else {
		return(0);
	    }
	    break;
	case 'F':
	    if (!strcasecomp(temp, "Feb")) {
		month = 2;
	    } else {
		return(0);
	    }
	    break;
	case 'J':
	    if (!strcasecomp(temp, "Jan")) {
		month = 1;
	    } else if (!strcasecomp(temp, "Jun")) {
		month = 6;
	    } else if (!strcasecomp(temp, "Jul")) {
		month = 7;
	    } else {
		return(0);
	    }
	    break;
	case 'M':
	    if (!strcasecomp(temp, "Mar")) {
		month = 3;
	    } else if (!strcasecomp(temp, "May")) {
		month = 5;
	    } else {
		return(0);
	    }
	    break;
	case 'N':
	    if (!strcasecomp(temp, "Nov")) {
		month = 11;
	    } else {
		return(0);
	    }
	    break;
	case 'O':
	    if (!strcasecomp(temp, "Oct")) {
		month = 10;
	    } else {
		return(0);
	    }
	    break;
	case 'S':
	    if (!strcasecomp(temp, "Sep")) {
		month = 9;
	    } else {
		return(0);
	    }
	    break;
	default:
	    return(0);
d5491 1
a5491 1
     *	Get the numeric year string and convert to an integer. - FM
d5496 1
a5496 1
	return(0);
d5510 1
a5510 1
	 * the broken sender software intends.	(This totally breaks
d5520 1
a5520 1
	return(0);
d5525 1
a5525 1
     *	Get the numeric hour string and convert to an integer. - FM
d5538 2
a5539 2
	    return(0);
	LYstrncpy(temp, start, (int)(s - start));
d5543 1
a5543 1
	 *  Get the numeric minutes string and convert to an integer. - FM
d5548 1
a5548 1
	    return(0);
d5553 2
a5554 2
	    return(0);
	LYstrncpy(temp, start, (int)(s - start));
d5558 1
a5558 1
	 *  Get the numeric seconds string and convert to an integer. - FM
d5563 1
a5563 1
	    return(0);
d5568 2
a5569 2
	    return(0);
	LYstrncpy(temp, start, (int)(s - start));
d5574 2
a5575 3
     *	Convert to clock format (seconds since 00:00:00 Jan 1 1970),
     *	but then zero it if it's in the past and "absolute" is not
     *	TRUE.  - FM
d5579 2
a5580 2
	 month += 12;
	 year--;
d5582 8
a5589 8
    day += (year - 1968)*1461/4;
    day += ((((month*153) + 2)/5) - 672);
    clock2 = (time_t)((day * 60 * 60 * 24) +
		     (hour * 60 * 60) +
		     (minutes * 60) +
		     seconds);
    if (absolute == FALSE && (long)(time((time_t *)0) - clock2) >= 0)
	clock2 = (time_t)0;
d5592 2
a5593 2
		    (long) clock2,
		    ctime(&clock2)));
d5595 1
a5595 1
    return(clock2);
d5600 1
a5600 1
 *  No putenv on the NeXT so we use this code instead!
d5634 1
a5634 1
 *  Put STRING, which is of the form "NAME=VALUE", in  the environment.
d5636 1
a5636 2
PUBLIC int putenv ARGS1(
	CONST char *,	string)
d5638 16
a5653 19
  char *name_end = strchr(string, '=');
  register size_t size;
  register char **ep;

  if (name_end == NULL)
    {
      /* Remove the variable from the environment.  */
      size = strlen (string);
      for (ep = environ; *ep != NULL; ++ep)
	if (!strncmp (*ep, string, size) && (*ep)[size]  == '=')
	  {
	    while (ep[1] != NULL)
	      {
		ep[0] = ep[1];
		++ep;
	      }
	    *ep = NULL;
	    return 0;
	  }
d5656 7
a5662 6
  size = 0;
  for (ep = environ; *ep != NULL; ++ep)
    if (!strncmp (*ep, string, name_end - string) && (*ep)[name_end - string] == '=')
      break;
    else
      ++size;
d5664 16
a5679 16
  if (*ep == NULL)
    {
      static char **last_environ = NULL;
      char **new_environ = (char **) malloc ((size + 2) * sizeof (char *));
      if (new_environ == NULL)
	return -1;
      (void) memcpy((char *)new_environ, (char *)environ, size * sizeof(char *));
      new_environ[size] = (char *) string;
      new_environ[size + 1] = NULL;
      if (last_environ != NULL)
	FREE (last_environ);
      last_environ = new_environ;
      environ = new_environ;
    }
  else
    *ep = (char *) string;
d5681 1
a5681 1
  return 0;
d5686 1
a5686 1
int remove ARGS1(char *, name)
d5708 1
a5708 1
PRIVATE BOOL IsOurFile ARGS1(char *, name)
d5713 3
a5715 3
    && S_ISREG(data.st_mode)
    && data.st_nlink == 1
    && data.st_uid == getuid()) {
d5717 1
d5752 1
a5752 1
		     || (data.st_mode & S_IWOTH) != 0) {
d5771 1
a5771 1
PRIVATE FILE *OpenHiddenFile ARGS2(char *, name, char *, mode)
d5777 1
a5777 1
#if defined(O_CREAT) && defined(O_EXCL) /* we have fcntl.h or kindred? */
d5783 2
a5784 1
	int fd = open(name, O_CREAT|O_EXCL|O_WRONLY, HIDE_CHMOD);
d5786 2
a5787 2
	 && errno == EEXIST
	 && IsOurFile(name)) {
d5790 1
a5790 1
	    fd = open(name, O_CREAT|O_EXCL|O_WRONLY, HIDE_CHMOD);
d5799 1
a5799 2
    }
    else
d5803 1
a5803 1
	 && chmod(name, HIDE_CHMOD) == 0)
d5807 9
a5815 9
    /*
     * This is less stringent, but reasonably portable.  For new files, the
     * umask will suffice; however if the file already exists we'll change
     * permissions first, before opening it.  If the chmod fails because of
     * some reason other than a non-existent file, there's no point in trying
     * to open it.
     *
     * This won't work properly if the user is root, since the chmod succeeds.
     */
d5818 1
d5827 1
a5827 1
PUBLIC FILE *LYNewBinFile ARGS1(char *, name)
d5830 2
a5831 1
    FILE *fp = fopen (name, BIN_W, "mbc=32");
d5839 1
a5839 1
PUBLIC FILE *LYNewTxtFile ARGS1(char *, name)
d5844 1
a5844 1
    fp = fopen (name, TXT_W, "shr=get");
d5857 1
a5857 1
PUBLIC FILE *LYAppendToTxtFile ARGS1(char *, name)
d5862 1
a5862 1
    fp = fopen (name, TXT_A, "shr=get");
d5876 3
a5878 3
 *  Restore normal permissions to a copy of a file that we have created
 *  with temp file restricted permissions.  The normal umask should
 *  apply for user files. - kw
d5880 1
a5880 1
PUBLIC void LYRelaxFilePermissions ARGS1(CONST char *, name)
d5884 1
d5889 3
a5891 3
	 *  It looks plausible that this is a file we created with
	 *  temp file paranoid permissions (and the umask wasn't even
	 *  more restrictive when it was copied). - kw
d5894 1
d5905 2
a5906 3
PUBLIC BOOLEAN LYCachedTemp ARGS2(
	char *,		result,
	char **,	cached)
d5929 3
a5931 4
PUBLIC FILE *LYOpenTemp ARGS3(
	char *,		result,
	CONST char *,	suffix,
	CONST char *,	mode)
d5944 9
a5952 3
	case 'w':	wrt = 'w';	break;
	case 'a':	wrt = 'a';	break;
	case 'b':	txt = FALSE;	break;
d5954 2
a5955 2
		CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
		return 0;
d5964 1
a5964 2
    if (lynx_temp_subspace == 0)
    {
d5969 1
a5969 1
	 && S_ISDIR(sb.st_mode)) {
d5971 1
a5971 1
	     || (sb.st_mode & (S_IWOTH | S_IWGRP)) != 0) {
d5973 3
a5975 2
		CTRACE((tfp, "lynx_temp_space is not our directory %s owner %d mode %03o\n",
			     lynx_temp_space, (int) sb.st_uid, (int) sb.st_mode & 0777));
d5983 2
a5984 1
	    StrAllocCat(lynx_temp_space, "XXXXXXXXXX");
d5987 1
a5987 1
		exit(EXIT_FAILURE);
d6005 1
a6005 1
		fp = LYNewTxtFile (result);
d6008 1
a6008 1
		fp = LYAppendToTxtFile (result);
d6012 1
a6012 1
	    fp = LYNewBinFile (result);
d6019 1
a6019 1
#ifdef EEXIST	/* FIXME (need a better test) in fcntl.h or unistd.h */
d6022 1
a6022 1
		   result, LYStrerror(errno)));
d6045 1
a6045 2
PUBLIC FILE *LYReopenTemp ARGS1(
	char *,		name)
d6052 1
a6052 1
	fp = p->file = LYAppendToTxtFile (name);
d6072 3
a6074 4
PUBLIC FILE *LYOpenTempRewrite ARGS3(
	char *,		fname,
	CONST char *,	suffix,
	CONST char *,	mode)
d6099 1
a6099 1
	writable_exists = HTEditable(fname); /* existing, can write */
d6102 1
a6102 1
	writable_exists = (BOOL) (stat(fname, &stat_buf) == 0); /* existing, assume can write */
d6110 2
a6111 2
	       writable_exists ? CTRACE_EXISTS : "",
	       is_ours ? "is our file." : "is NOT our file."));
d6115 4
a6118 5
     *  Note that in cases where LYOpenTemp is called as fallback below,
     *  we don't call LYRemoveTemp first.  That may be appropriate in some
     *  cases, but not trying to remove a weird existing file seems safer
     *  and could help diagnose an unusual situation.  (They may be removed
     *  anyway later.)
d6127 2
a6128 2
	 *  Not registered.  It should have been registered at one point
	 *  though, otherwise we wouldn't be called like this.
d6133 1
a6133 2
	 *  File exists, writable if we checked, but something is wrong
	 *  with it.
d6139 1
a6139 1
	 *  Exists but not writable, and something is wrong with it.
d6147 9
a6155 3
	case 'w':	wrt = 'w';	break;
	case 'a':	wrt = 'a';	break;
	case 'b':	txt = FALSE;	break;
d6157 2
a6158 2
		CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
		return fp;
d6164 2
a6165 2
	 *  Yes, it exists, is writable if we checked, and everything
	 *  looks ok so far.  This should be the most regular case. - kw
d6170 2
a6171 2
	     *  We truncate and then append, this avoids having a small
	     *  window in which the file doesn't exist. - kw
d6186 5
a6190 7
	/*  We come here in two cases: either the file existed and was
	 *  ours and we just got rid of it.
	 *  Or the file did and does not exist, but is registered as a
	 *  temp file.  It must have been removed by some means other than
	 *  LYRemoveTemp.
	 *  In both cases, reuse the name! - kw
	 */
d6195 1
a6195 1
	    fp = LYNewTxtFile (fname);
d6198 1
a6198 1
	    fp = LYAppendToTxtFile (fname);
d6202 1
a6202 1
	fp = LYNewBinFile (fname);
d6207 1
a6207 1
	   (fp) ? "ok" : "failed"));
d6209 4
a6212 4
     *  We could fall back to trying LYOpenTemp() here in case of failure.
     *  After all the checks already done above a filure here should be
     *  pretty unusual though, so maybe it's better to let the user notice
     *  that something went wrong, and not try to fix it up. - kw
d6221 2
a6222 3
PUBLIC FILE *LYOpenScratch ARGS2(
	char *,		result,
	CONST char *,	prefix)
d6230 1
a6230 1
    if ((fp = LYNewTxtFile (result)) != 0) {
d6244 1
a6244 2
PRIVATE void LY_close_temp ARGS1(
	LY_TEMP *,	p)
d6259 1
a6259 2
PUBLIC void LYCloseTemp ARGS1(
	char *, name)
d6266 1
a6266 1
	    (p->file != 0) ? ", closed" : ""));
d6274 1
a6274 2
PUBLIC void LYCloseTempFP ARGS1(
	FILE *, fp)
d6288 1
a6288 2
PUBLIC int LYRemoveTemp ARGS1(
	char *, name)
d6305 1
a6305 1
		       (p->file != 0) ? ", closed" : ""));
d6320 1
a6320 1
PUBLIC void LYCleanupTemp NOARGS
d6328 2
a6329 1
	LYstrncpy(result, lynx_temp_space, sizeof(result)-1);
d6341 2
a6342 3
PUBLIC void LYRenamedTemp ARGS2(
	char *,		oldname,
	char *,		newname)
d6354 1
a6354 1
 *  Check that bibhost defines the BibP icon.
d6356 1
a6356 1
PUBLIC void LYCheckBibHost NOARGS
d6370 1
a6370 1
    traversal = TRUE;  /* Hack to force error response. */
d6378 1
a6378 1
 *  Management of User Interface Pages. - kw
d6380 2
a6381 2
 *  These are mostly temp files.  Pages which can be recognized by their
 *  special URL (after having been loaded) need not be tracked here.
d6383 1
a6383 1
 *  First some private stuff:
d6386 5
a6390 5
    UIP_t	type;
    unsigned	flags;
    char *	url;
    HTList *	alturls;
    char *	file;
d6394 1
a6394 1
#define UIP_F_LIMIT	0x0002	/* flag: limit size of alturl list */
d6396 1
a6396 1

d6427 1
d6431 3
a6433 4
PUBLIC BOOL LYIsUIPage3 ARGS3(
    CONST char *,	url,
    UIP_t,		type,
    int,		flagparam)
d6437 1
d6445 1
a6445 1
		       (!strncmp(ly_uip[i].url, url, (l=strlen(ly_uip[i].url)))
d6453 1
a6453 1
		while ((p = HTList_nextObject(l0)) != NULL) {
d6455 2
a6456 2
		       (!strncmp(p, url, (l=strlen(p)))
			&& (url[l] == '\0' || url[l] == '#')) :
d6467 2
a6468 3
PUBLIC void LYRegisterUIPage ARGS2(
    CONST char *,	url,
    UIP_t,		type)
d6471 1
d6486 1
a6486 1
		while ((p = HTList_nextObject(l0)) != NULL) {
d6510 1
a6510 1
PUBLIC void LYUIPages_free NOARGS
d6513 1
a6513 2
    char *p;
    HTList *l0;
d6517 1
a6517 5
	l0 = ly_uip[i].alturls;
	while ((p = HTList_nextObject(l0)) != NULL) {
	    FREE(p);
	}
	HTList_delete(ly_uip[i].alturls);
d6523 2
a6524 2
 *  Convert local pathname to www name
 *  (do not bother about file://localhost prefix at this point).
d6526 1
a6526 2
PUBLIC  CONST char * wwwName ARGS1(
	CONST char *,	pathname)
d6528 1
a6528 1
    CONST char *cp = NULL;
d6550 2
a6551 3
PUBLIC BOOLEAN LYValidateFilename ARGS2(
	char *,		result,
	char *,		given)
d6554 1
a6554 1
    CONST char *cp2;
d6557 2
a6558 2
     *  Cancel if the user entered "/dev/null" on Unix,
     *  or an "nl:" path on VMS. - FM
d6560 1
a6560 2
    if (LYIsNullDevice(given))
    {
d6575 2
a6576 2
     && (cp2 = wwwName(Home_Dir())) != 0
     && strlen(cp2) + strlen(given) < LY_MAXPATH) {
d6590 2
a6591 2
     && strchr(given, ':') == NULL
     && strlen(given) < LY_MAXPATH - 13) {
d6604 3
a6606 3
    if (strchr(result, ':') != NULL)
	cp = NULL;
    else
d6611 1
d6617 2
a6618 3
    }
    else
#endif /* __EMX__*/
d6645 1
a6645 2
PUBLIC int LYValidateOutput ARGS1(
	char *,		filename)
d6665 1
a6665 1
     *  See if it already exists.
d6686 2
a6687 3
PUBLIC void LYLocalFileToURL ARGS2(
	char **,	target,
	CONST char *,	source)
d6689 1
a6689 1
    CONST char *leaf;
d6697 1
d6712 2
a6713 3
PUBLIC FILE *InternalPageFP ARGS2(
	char *, filename,
	int,	reuse_flag)
d6729 4
a6732 4
PUBLIC void BeginInternalPage ARGS3(
	FILE *, fp0,
	char*, Title,
	char*, HelpURL)
d6734 2
a6735 1
    fprintf(fp0, "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n");
d6742 1
d6754 11
a6764 2
    fprintf(fp0, "<title>%s</title>\n</head>\n<body>\n",
		 Title);
d6767 2
a6768 2
     && LYwouldPush(Title, NULL)
     && (HelpURL != 0)) {
d6778 1
a6778 2
PUBLIC void EndInternalPage ARGS1(
	FILE *, fp0)
d6783 1
a6783 2
PUBLIC char *trimPoundSelector ARGS1(
	char *,		address)
d6786 1
d6796 1
a6796 2
PUBLIC void LYTrimPathSep ARGS1(
	char *,	path)
d6801 3
a6803 3
     && (len = strlen(path)) != 0
     && LYIsPathSep(path[len-1]))
	path[len-1] = 0;
d6810 1
a6810 2
PUBLIC void LYAddPathSep ARGS1(
	char **,	path)
d6816 3
a6818 3
     && ((temp = *path) != 0)
     && (len = strlen(temp)) != 0
     && !LYIsPathSep(temp[len-1])) {
d6827 1
a6827 2
PUBLIC void LYAddPathSep0 ARGS1(
	char *,		path)
d6832 3
a6834 3
     && (len = strlen(path)) != 0
     && (len < LY_MAXPATH - 2)
     && !LYIsPathSep(path[len-1])) {
d6842 1
a6842 2
PUBLIC char * LYLastPathSep ARGS1(
	CONST char *,	path)
d6845 1
d6859 1
a6859 2
PUBLIC void LYTrimHtmlSep ARGS1(
	char *,	path)
d6864 3
a6866 3
     && (len = strlen(path)) != 0
     && LYIsHtmlSep(path[len-1]))
	path[len-1] = 0;
d6873 1
a6873 2
PUBLIC void LYAddHtmlSep ARGS1(
	char **,	path)
d6879 3
a6881 3
     && ((temp = *path) != 0)
     && (len = strlen(temp)) != 0
     && !LYIsHtmlSep(temp[len-1])) {
d6890 1
a6890 2
PUBLIC void LYAddHtmlSep0 ARGS1(
	char *,		path)
d6895 3
a6897 3
     && (len = strlen(path)) != 0
     && (len < LY_MAXPATH - 2)
     && !LYIsHtmlSep(path[len-1])) {
d6905 2
a6906 3
PUBLIC int LYCopyFile ARGS2(
	char *,		src,
	char *,		dst)
d6909 1
a6909 1
    CONST char *program;
d6954 1
a6954 1
PRIVATE char *escape_backslashes ARGS1(char *, source)
d6969 1
d6984 1
a6984 2
PUBLIC int LYSystem ARGS1(
	char *,	command)
d6988 1
d6994 1
d7012 1
a7012 1
#  ifdef __EMX__			/* FIXME: Should be LY_CONVERT_SLASH? */
d7074 2
a7075 1
	    sprintf(new_command, "%.*s \"%.*s\"", LY_MAXPATH, new_cmd, LY_MAXPATH, win32_name);
d7081 1
a7081 1
		    if (*(p+1) == '\\')
d7097 1
d7107 1
a7107 1
    code = exec_command(command, TRUE);	/* Wait exec */
d7111 1
a7111 1
	signal(SIGPIPE, SIG_DFL); /* Some commands expect the default */
d7125 1
a7125 1
	signal(SIGPIPE, SIG_IGN); /* Ignore it again - kw */
d7140 1
a7140 1
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ?? */
d7152 2
a7153 2
#if defined(__CYGWIN__)	/* 1999/02/26 (Fri) */
PUBLIC int Cygwin_Shell NOARGS
d7165 1
a7165 1
    sa.bInheritHandle=TRUE;
d7173 2
a7174 2
     inherited handles. Pass the value of the
     handle as a command line parameter */
d7178 2
a7179 2
			TRUE, 0,
			0, 0, &startUpInfo, &procInfo);
d7194 1
a7194 1
PUBLIC char *LYSysShell NOARGS
d7196 2
a7197 1
    char *shell = 0;
d7247 1
a7247 1
PUBLIC char *LYgetXDisplay NOARGS
d7256 1
a7256 2
PUBLIC void LYsetXDisplay ARGS1(
	char *,	new_display)
d7282 1
a7282 1
PRIVATE void morph_PM NOARGS
d7292 2
a7293 2
    if (pib->pib_ultype != 3)		/* 2 is VIO */
	pib->pib_ultype = 3;		/* 3 is PM */
d7301 1
a7301 1
PRIVATE void unmorph_PM NOARGS
d7307 1
a7307 1
PUBLIC int size_clip NOARGS
d7314 1
a7314 1
PUBLIC int put_clip ARGS1(char *, s)
d7326 1
a7326 1
    if (DosAllocSharedMem((PPVOID)&pByte, 0, sz + nl,
d7340 1
a7340 1
    if(!hab)
d7352 1
a7352 1
    DosFreeMem((PPVOID)&pByte);
d7361 1
a7361 1
PUBLIC char* get_clip_grab NOARGS
d7368 1
a7368 1
    if(!hab)
d7374 1
a7374 1
    if(ulFormat != CFI_POINTER) {
d7380 1
a7380 1
    ClipData = (char *)WinQueryClipbrdData(hab, CF_TEXT);
d7382 1
a7382 1
    if(!ClipData || !sz) {
d7389 1
a7389 1
PUBLIC void get_clip_release NOARGS
d7398 1
a7398 1
#else	/* !( defined __EMX__ ) */
d7402 1
a7402 1
static FILE* paste_handle = 0;
d7405 1
a7405 1
PUBLIC void get_clip_release NOARGS
d7410 1
a7410 1
	FREE (paste_buf);
d7413 1
a7413 1
PRIVATE int clip_grab NOARGS
d7429 1
a7429 1
#define CF_TEXT 0			/* Not used */
d7431 1
a7431 1
PUBLIC char* get_clip_grab NOARGS
d7442 2
a7443 2
	FREE (paste_buf);
    paste_buf = (char*)malloc (PASTE_BUFFER);
d7445 1
a7445 1
	len = fread (paste_buf + off, 1, PASTE_BUFFER - 1, paste_handle);
a7447 3
	break;
	if (strchr (paste_buf + off, '\r')
	 || strchr (paste_buf + off, '\n'))
d7449 5
a7453 1
	paste_buf = realloc (paste_buf, size += PASTE_BUFFER - 1);
d7459 1
a7459 2
PUBLIC int
put_clip ARGS1(char *, s)
d7468 1
a7468 1
    fh = popen (cmd, "wt");
d7471 2
a7472 2
    res = fwrite (s, 1, l, fh);
    if (pclose (fh) != 0 || res != l)
d7477 1
a7477 1
#  endif	/* !defined(WIN_EX) && defined(HAVE_POPEN) */
d7481 7
a7487 1
#if defined(WIN_EX)	/* 1997/10/16 (Thu) 20:13:28 */
d7489 19
a7507 1
PUBLIC int put_clip(char *szBuffer)
d7522 1
a7522 1
	len ++;
d7562 1
a7562 1
PUBLIC char* get_clip_grab()
d7585 1
a7585 1
PUBLIC void get_clip_release()
d7593 1
a7593 1
#endif	/* WIN_EX */
d7602 6
d7614 1
a7614 1
 *      comp.os.ms-windows.programmer.win32
d7616 1
a7616 1
PUBLIC char * w32_strerror(DWORD ercode)
d7621 1
d7628 1
d7638 1
a7638 1
     *  Special code for winsock error handling.
d7641 2
a7642 4
	hModule = GetModuleHandle("wsock32");
	if (hModule == NULL)
	    ercode = GetLastError();
	else
d7646 1
a7646 1
     *  message handling
d7648 7
a7654 7
    FormatMessage(msg_type,
		  hModule,
		  ercode,
		  LANG_NEUTRAL,
		  msg_buff,
		  sizeof(msg_buff),
		  NULL);
d7671 1
a7671 1
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
d7675 1
a7675 2
PUBLIC void LYOpenlog ARGS1(
	CONST char *, banner)
d7677 2
d7680 1
a7680 1
    openlog("lynx", LOG_PID|LOG_NDELAY, LOG_LOCAL5);
d7682 1
a7682 1
    openlog("lynx", LOG_PID, LOG_LOCAL5);
d7685 5
a7689 4
    if (banner) {
	syslog(LOG_INFO, "Session start:%s", banner);
    } else {
	syslog(LOG_INFO, "Session start");
d7693 2
a7694 3
PRIVATE BOOLEAN looks_like_password ARGS2(
	char *,		first,
	char *,		last)
d7700 1
a7700 1
	 || *first == ':') {
d7710 1
a7710 2
PUBLIC void LYSyslog ARGS1(
	char *,		arg)
d7716 3
a7718 1
    CTRACE((tfp, "LYSyslog %s\n", arg));
d7720 19
a7738 18
    if (is_url(arg)) {	/* proto://user:password@@host/path:port */
			/*	^this colon		    */
	if ((colon1 = strchr(arg, ':')) != 0
	 && !strncmp(colon1, "://", 3)
	 && (colon2 = strchr(colon1+3, ':')) != 0
	 && (atsign = strchr(colon1, '@@')) != 0
	 && (colon2 < atsign)
	 && looks_like_password(colon2 + 1, atsign - 1)) {
	    char *buf = NULL;

	    StrAllocCopy(buf, arg);
	    buf[colon2 - arg + 1] = 0;
	    StrAllocCat(buf, "******");
	    StrAllocCat(buf, atsign);
	    syslog (LOG_INFO|LOG_LOCAL5, "%s", buf);
	    CTRACE((tfp, "...alter %s\n", buf));
	    FREE(buf);
	    return;
d7740 1
a7741 1
    syslog (LOG_INFO|LOG_LOCAL5, "%s", NONNULL(arg));
d7744 1
a7744 1
PUBLIC void LYCloselog NOARGS
d7746 4
a7749 2
  syslog(LOG_INFO, "Session over");
  closelog();
d7752 1
a7752 1
#endif /* !VMS && SYSLOG_REQUESTED_URLS */
@


1.6
log
@Second round of lynx merger:
o "cvs admin" some files back to vendor branch where
  we nuked the differences with the upstream package
  (due to them incorporating changes from MirBSD)
o nuke mkdirs.sh, use $(GNUSYSTEM_AUX_DIR)/mkinstalldirs
o add comments about MirBSD SSL certs
o regenerate configure files
o clean up
@
text
@a0 20
/* $MirBSD: LYUtils.c,v 1.5 2003/09/27 13:12:48 tg Exp $
 *-
 * Copyright (c) 2002, 2003 Thorsten Glaser <x86@@ePost.de>
 *
 * Subject to these terms, everybody who obtained a copy of this work
 * is hereby permitted to deal in the work without restriction inclu-
 * ding without limitation the rights to use, distribute, sell, modi-
 * fy, publically perform, give away, merge or sublicense it provided
 * this notice is kept and the authors and contributors are given due
 * credit in derivates or accompanying documents.
 * This work is provided "as is" with no explicit or implicit warran-
 * ties whatsoever to the maximum extend permitted by applicable law;
 * in no event may an author or contributor be held liable for damage
 * that is, directly or indirectly, caused by the work, even if advi-
 * sed of the possibility of such damage.
 *-
 * These are patches to the Lynx web browser, which is licensed under
 * the GNU General Public License, Version 2.
 */

d194 31
d5353 24
a5990 1
#ifndef __OpenBSD__
a6024 1
#endif	/* ndef __OpenBSD__ */
d6991 27
d7129 11
d7449 1
a7449 1
    char *cmd = getenv ("RL_PASTE_CMD");
d7495 1
a7495 1
    char *cmd = getenv ("RL_CLCOPY_CMD");
@


1.5
log
@First step of lynx-2.8.5-dev16c merger
@
text
@d1 1
a1 1
/* $MirBSD: LYUtils.c,v 1.4 2003/07/07 20:00:29 tg Exp $
d5977 1
a5977 1
	    StrAllocCat(lynx_temp_space, "XXXXXX");
@


1.4
log
@improve temp file handlink, from openbsd:
- mkdtemp temp space directory (art)
@
text
@d1 1
a1 1
/* $MirBSD: licence.template,v 1.4 2003/07/07 19:03:08 tg Exp $
d1559 1
a1559 1
#if !defined(USE_SLANG) && (defined(UNIX) || defined(__DJGPP__))
d5957 1
a5957 1
#if defined(MULTI_USER_UNIX) && defined(HAVE_MKTEMP)
d6706 2
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d1 20
d5956 1
d5991 1
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a8 1
#include <LYUtils.h>
d11 1
d17 1
d21 19
d44 9
d59 1
a59 1
#if HAVE_UTMP
d64 1
a67 1
#ifdef    UTMPX_FILE
d70 1
d72 3
d112 3
a114 3
#ifndef FD_SETSIZE
#define FD_SETSIZE 256
#endif /* !FD_SETSIZE */
d124 16
a141 4
extern HTkcode kanji_code;
extern BOOLEAN LYHaveCJKCharacterSet;
extern HTCJKlang HTCJK;

d144 1
d148 2
a149 1
 *  Highlight (or unhighlight) a given link.
d151 6
a156 22
PUBLIC void highlight ARGS3(
	int,		flag,
	int,		cur,
	char *,		target)
{
    char buffer[200];
    int i;
    char tmp[7];
#if defined(FANCY_CURSES) || defined(USE_SLANG)
    char *cp;
    char *theData = NULL;
    char *Data = NULL;
    int Offset, HitOffset, tLen;
    int LenNeeded;
    BOOL TargetEmphasisON = FALSE;
#endif
    BOOL utf_flag = (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8);
#if defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
    BOOL hl2_drawn=FALSE;	/* whether links[cur].hightext2 is already drawn
				   properly */
#endif
    tmp[0] = tmp[1] = tmp[2] = '\0';
d158 1
a158 8
    /*
     *	Bugs in the history code might cause -1 to be sent for cur, which
     *	yields a crash when LYstrncpy() is called with a nonsense pointer.
     *	As far as I know, such bugs have been squashed, but if they should
     *	reappear, this works around them. - FM
     */
    if (cur < 0)
	cur = 0;
d160 3
a162 5
    if (nlinks > 0) {
#if  defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
	if (flag == ON || links[cur].type == WWW_FORM_LINK_TYPE)
#endif
	{
d164 3
a166 41
#ifdef USE_COLOR_STYLE
#define LXP (links[cur].lx)
#define LYP (links[cur].ly)
#endif
	move(links[cur].ly, links[cur].lx);
#ifndef USE_COLOR_STYLE
	lynx_start_link_color (flag == ON, links[cur].inUnderline);
#else
	if (flag == ON) {
	    LynxChangeStyle(s_alink, STACK_ON, 0);
	} else {
	    int s, x;
		/*
		 *  This is where we try to restore the original style when
		 *  a link is unhighlighted.  The purpose of cached_styles[][]
		 *  is to save the original style just for this case.
		 *  If it doesn't have a color change saved at just the right
		 *  position, we look at preceding positions in the same line
		 *  until we find one.
		 */
	    if (LYP >= 0 && LYP < CACHEH && LXP >= 0 && LXP < CACHEW) {
		s = cached_styles[LYP][LXP];
		if (s == 0) {
		    for (x = LXP-1; x >= 0; x--) {
			if (cached_styles[LYP][x]) {
			    if (cached_styles[LYP][x] > 0) {
				s = cached_styles[LYP][x];
				cached_styles[LYP][LXP] = s;
			    }
			    break;
			}
		    }
		    if (s == 0)
			s = s_a;
		}
	    } else {
		s = s_a;
	    }
	    LynxChangeStyle(s, STACK_ON, 0);
	}
#endif
d168 3
d172 3
d176 7
a182 3
	if (links[cur].type == WWW_FORM_LINK_TYPE) {
	    int len;
	    int avail_space = (LYcols - links[cur].lx) - 1;
d184 8
a191 6
	    LYstrncpy(buffer,
		      (links[cur].hightext ?
		       links[cur].hightext : ""),
		      (avail_space > links[cur].form->size ?
				      links[cur].form->size : avail_space));
	    addstr(buffer);
d193 9
a201 3
	    len = strlen(buffer);
	    for (; len < links[cur].form->size && len < avail_space; len++)
		addch('_');
d203 11
a214 7
#if defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
	    if (flag == OFF) {
		hl2_drawn = TRUE;
		redraw_lines_of_link(cur);
	    } else
#endif
	    {
d216 7
a222 2
	     *	Copy into the buffer only what will fit
	     *	within the width of the screen.
d224 1
a224 8
	    LYmbcsstrncpy(buffer,
			  (links[cur].hightext ?
			   links[cur].hightext : ""),
			  (sizeof(buffer) - 1),
			  ((LYcols - 1) - links[cur].lx),
			  utf_flag);
	    addstr(buffer);
	    }
d226 38
d265 38
a302 15
	/*
	 *  Display a second line as well.
	 */
	if ( links[cur].hightext2 && links[cur].ly < display_lines
#if defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
	  && hl2_drawn == FALSE
#endif
	) {
	    lynx_stop_link_color (flag == ON, links[cur].inUnderline);
	    move((links[cur].ly + 1), links[cur].hightext2_offset);
#ifndef USE_COLOR_STYLE
	    lynx_start_link_color (flag == ON, links[cur].inUnderline);
#else
	    LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_ON, 0);
#endif
d304 1
a304 20
	    for (i = 0; (tmp[0] = links[cur].hightext2[i]) != '\0' &&
			i+links[cur].hightext2_offset < LYcols; i++) {
		if (!IsSpecialAttrChar(links[cur].hightext2[i])) {
		    /*
		     *	For CJK strings, by Masanobu Kimura.
		     */
		    if (HTCJK != NOCJK && !isascii(tmp[0])) {
			tmp[1] = links[cur].hightext2[++i];
			addstr(tmp);
			tmp[1] = '\0';
		    } else {
			addstr(tmp);
		    }
		 }
	    }
	}
#if defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
	if ( hl2_drawn == FALSE )
#endif
	lynx_stop_link_color (flag == ON, links[cur].inUnderline);
d306 34
a339 30
#if defined(FANCY_CURSES) || defined(USE_SLANG)
	/*
	 *  If we have an emphasized WHEREIS hit in the highlighted
	 *  text, restore the emphasis.  Note that we never emphasize
	 *  the first and last characters of the highlighted text when
	 *  we are making the link current, so the link attributes for
	 *  the current link will persist at the beginning and end,
	 *  providing an indication to the user that it has been made
	 *  current.   Also note that we use HText_getFirstTargetInLine()
	 *  to determine if there's a hit in the HText structure line
	 *  containing the link, and if so, get back a copy of the line
	 *  starting at that first hit (which might be before or after
	 *  our link), and with all IsSpecial characters stripped, so we
	 *  don't need to deal with them here. - FM
	 */
	if (target && *target && (links[cur].type & WWW_LINK_TYPE) &&
	    links[cur].hightext && *links[cur].hightext &&
	    HText_getFirstTargetInLine(HTMainText,
				       links[cur].anchor_line_num,
				       utf_flag,
				       (int *)&Offset,
				       (int *)&tLen,
				       (char **)&theData,
				       target)) {
	    int itmp, written, len, y, offset;
	    char *data;
	    int tlen = strlen(target);
	    int hlen, hLen;
	    int hLine = links[cur].ly, hoffset = links[cur].lx;
	    size_t utf_extra = 0;
d341 1
a341 13
	    /*
	     *	Copy into the buffer only what will fit
	     *	up to the right border of the screen. - FM
	     */
	    LYmbcsstrncpy(buffer,
			  (links[cur].hightext ?
			   links[cur].hightext : ""),
			  (sizeof(buffer) - 1),
			  ((LYcols - 1) - links[cur].lx),
			  utf_flag);
	    hlen = strlen(buffer);
	    hLen = ((HTCJK != NOCJK || utf_flag) ?
		  LYmbcsstrlen(buffer, utf_flag) : hlen);
d343 32
a374 7
	    /*
	     *	Break out if the first hit in the line
	     *	starts after this link. - FM
	     */
	    if (Offset >= (hoffset + hLen)) {
		goto highlight_search_hightext2;
	    }
d376 4
d381 2
a382 2
	     *	Recursively skip hits that end before this link, and
	     *	break out if there is no hit beyond those. - FM
d389 6
a394 12
		if ((case_sensitive ?
		     (cp = LYno_attr_mbcs_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL :
		     (cp = LYno_attr_mbcs_case_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL) &&
		    (offset + LenNeeded) < LYcols) {
d398 1
a398 1
		    goto highlight_search_hightext2;
d405 4
a408 4
	     *	If the hit starts before the hightext, and ends
	     *	in or beyond the hightext, restore the emphasis,
	     *	skipping the first and last characters of the
	     *	hightext if we're making the link current. - FM
d417 2
a418 2
		 *  Go to the start of the hightext and
		 *  handle its first character. - FM
d420 1
a420 1
		move(hLine, offset);
d422 1
a422 24
		if (utf_flag && !isascii(tmp[0])) {
		    if ((*tmp & 0xe0) == 0xc0) {
			utf_extra = 1;
		    } else if ((*tmp & 0xf0) == 0xe0) {
			utf_extra = 2;
		    } else if ((*tmp & 0xf8) == 0xf0) {
			utf_extra = 3;
		    } else if ((*tmp & 0xfc) == 0xf8) {
			utf_extra = 4;
		    } else if ((*tmp & 0xfe) == 0xfc) {
			utf_extra = 5;
		    } else {
			/*
			 *  Garbage.
			 */
			utf_extra = 0;
		    }
		    if (strlen(&data[itmp+1]) < utf_extra) {
			/*
			 *  Shouldn't happen.
			 */
			utf_extra = 0;
		    }
		}
d427 2
a428 2
		     *	Start emphasis immediately if we are
		     *	making the link non-current. - FM
d433 1
a433 1
			addstr(tmp);
d435 1
a435 1
			move(hLine, (offset + 1));
d440 1
a440 1
		} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
d442 1
a442 1
		     *	For CJK strings, by Masanobu Kimura.
d446 2
a447 2
		     *	Start emphasis immediately if we are
		     *	making the link non-current. - FM
d452 1
a452 1
			addstr(tmp);
d454 1
a454 1
			move(hLine, (offset + 1));
d460 2
a461 2
		     *	Start emphasis immediately if we are making
		     *	the link non-current. - FM
d466 1
a466 1
			addstr(tmp);
d468 1
a468 1
			move(hLine, (offset + 1));
d474 2
a475 3
		 *  Start emphasis after the first character
		 *  if we are making the link current and this
		 *  is not the last character. - FM
d484 1
a484 1
		 *  Handle the remaining characters. - FM
d490 3
a492 4
		     *	Print all the other target chars, except
		     *	the last character if it is also the last
		     *	character of hightext and we are making
		     *	the link current. - FM
d494 1
a494 24
		    if (utf_flag && !isascii(tmp[0])) {
			if ((*tmp & 0xe0) == 0xc0) {
			    utf_extra = 1;
			} else if ((*tmp & 0xf0) == 0xe0) {
			    utf_extra = 2;
			} else if ((*tmp & 0xf8) == 0xf0) {
			    utf_extra = 3;
			} else if ((*tmp & 0xfc) == 0xf8) {
			    utf_extra = 4;
			} else if ((*tmp & 0xfe) == 0xfc) {
			    utf_extra = 5;
			} else {
			    /*
			     *	Garbage.
			     */
			    utf_extra = 0;
			}
			if (strlen(&data[itmp+1]) < utf_extra) {
			    /*
			     *	Shouldn't happen.
			     */
			    utf_extra = 0;
			}
		    }
d499 3
a501 3
			 *  Make sure we don't restore emphasis to
			 *  the last character of hightext if we
			 *  are making the link current. - FM
d507 1
a507 1
			    move(hLine, (offset + 1));
d509 1
a509 1
			    addstr(tmp);
d514 1
a514 1
		    } else if (HTCJK != NOCJK && !isascii(tmp[0])) {
d516 1
a516 1
			 *  For CJK strings, by Masanobu Kimura.
d520 3
a522 3
			 *  Make sure we don't restore emphasis to
			 *  the last character of hightext if we
			 *  are making the link current. - FM
d528 1
a528 1
			    move(hLine, (offset + 1));
d530 1
a530 1
			    addstr(tmp);
d536 3
a538 3
			 *  Make sure we don't restore emphasis to
			 *  the last character of hightext if we
			 *  are making the link current. - FM
d544 1
a544 1
			    move(hLine, (offset + 1));
d546 1
a546 1
			    addstr(tmp);
d553 4
a556 6
		 *  Stop the emphasis if we haven't already, then
		 *  reset the offset to our current position in
		 *  the line, and if that is beyond the link, or
		 *  or we are making the link current and it is
		 *  the last character of the hightext, we are
		 *  done. - FM
d563 11
a573 30
		if (offset >=
		    (hoffset +
		     (flag == ON ? (hLen - 1) : hLen)))  {
		    goto highlight_search_hightext2;
		}

		/*
		 *  See if we have another hit that starts
		 *  within the hightext. - FM
		 */
		data = (Data + (offset - Offset));
		if (!utf_flag) {
		    data = Data + (offset - Offset);
		} else {
		    data = LYmbcs_skip_glyphs(Data,
					      (offset - Offset),
					      utf_flag);
		}
		if ((case_sensitive ?
		     (cp = LYno_attr_mbcs_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL :
		     (cp = LYno_attr_mbcs_case_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL) &&
		    (offset + LenNeeded) < LYcols) {
d575 3
a577 3
		     *	If the hit starts after the end of the hightext,
		     *	or we are making the link current and the hit
		     *	starts at its last character, we are done. - FM
d579 3
a581 6
		    if ((HitOffset + offset) >=
			(hoffset +
			 (flag == ON ? (hLen - 1) : hLen)))  {
			goto highlight_search_hightext2;
		    }

d583 2
a584 2
		     *	Set up the data and offset for the hit, and let
		     *	the code for within hightext hits handle it. - FM
d592 1
a592 1
		goto highlight_search_hightext2;
d597 14
a610 22
	     *	If we get to here, the hit starts within the
	     *	hightext.  If we are making the link current
	     *	and it's the last character in the hightext,
	     *	we are done.  Otherwise, move there and start
	     *	restoring the emphasis. - FM
	     */
	    if ((Offset - offset) >
		(flag == ON ? (hLen - 1) : hLen))  {
		goto highlight_search_hightext2;
	    }
	    if (!utf_flag) {
		data += (Offset - offset);
	    } else {
		refresh();
		data = LYmbcs_skip_glyphs(data,
					  (Offset - offset),
					  utf_flag);
	    }
	    offset = Offset;
	    itmp = 0;
	    written = 0;
	    len = tlen;
d612 10
a621 18
	    /*
	     *	Go to the start of the hit and
	     *	handle its first character. - FM
	     */
	    move(hLine, offset);
	    tmp[0] = data[itmp];
	    if (utf_flag && !isascii(tmp[0])) {
		if ((*tmp & 0xe0) == 0xc0) {
		    utf_extra = 1;
		} else if ((*tmp & 0xf0) == 0xe0) {
		    utf_extra = 2;
		} else if ((*tmp & 0xf8) == 0xf0) {
		    utf_extra = 3;
		} else if ((*tmp & 0xfc) == 0xf8) {
		    utf_extra = 4;
		} else if ((*tmp & 0xfe) == 0xfc) {
		    utf_extra = 5;
		} else {
d623 3
a625 1
		     *	Garbage.
d627 10
d638 21
a658 2
		}
		if (strlen(&data[itmp+1]) < utf_extra) {
d660 3
a662 1
		     *	Shouldn't happen.
d664 9
a672 1
		    utf_extra = 0;
d674 4
a677 9
	    }
	    if (utf_extra) {
		LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
		itmp += utf_extra;
		/*
		 *  Start emphasis immediately if we are making
		 *  the link non-current, or we are making it
		 *  current but this is not the first or last
		 *  character of the hightext. - FM
d679 2
a680 2
		if (flag != ON ||
		    (offset > hoffset && data[itmp+1] != '\0')) {
a682 196
		    addstr(tmp);
		} else {
		    move(hLine, (offset + 1));
		}
		tmp[1] = '\0';
		written += (utf_extra + 1);
		utf_extra = 0;
	    } else if (HTCJK != NOCJK && !isascii(tmp[0])) {
		/*
		 *  For CJK strings, by Masanobu Kimura.
		 */
		tmp[1] = data[++itmp];
		/*
		 *  Start emphasis immediately if we are making
		 *  the link non-current, or we are making it
		 *  current but this is not the first or last
		 *  character of the hightext. - FM
		 */
		if (flag != ON ||
		    (offset > hoffset && data[itmp+1] != '\0')) {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    addstr(tmp);
		} else {
		    move(hLine, (offset + 1));
		}
		tmp[1] = '\0';
		written += 2;
	    } else {
		/*
		 *  Start emphasis immediately if we are making
		 *  the link non-current, or we are making it
		 *  current but this is not the first or last
		 *  character of the hightext. - FM
		 */
		if (flag != ON ||
		    (offset > hoffset && data[itmp+1] != '\0')) {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    addstr(tmp);
		} else {
		    move(hLine, (offset + 1));
		}
		written++;
	    }
	    itmp++;
	    /*
	     *	Start emphasis after the first character
	     *	if we are making the link current and this
	     *	is not the last character. - FM
	     */
	    if (!TargetEmphasisON &&
		data[itmp] != '\0') {
		LYstartTargetEmphasis();
		TargetEmphasisON = TRUE;
	    }

	    for (;
		 written < len && (tmp[0] = data[itmp]) != '\0';
		 itmp++)  {
		/*
		 *  Print all the other target chars, except
		 *  the last character if it is also the last
		 *  character of hightext and we are making
		 *  the link current. - FM
		 */
		if (utf_flag && !isascii(tmp[0])) {
		    if ((*tmp & 0xe0) == 0xc0) {
			utf_extra = 1;
		    } else if ((*tmp & 0xf0) == 0xe0) {
			utf_extra = 2;
		    } else if ((*tmp & 0xf8) == 0xf0) {
			utf_extra = 3;
		    } else if ((*tmp & 0xfc) == 0xf8) {
			utf_extra = 4;
		    } else if ((*tmp & 0xfe) == 0xfc) {
			utf_extra = 5;
		    } else {
			/*
			 *  Garbage.
			 */
			utf_extra = 0;
		    }
		    if (strlen(&data[itmp+1]) < utf_extra) {
			/*
			 *  Shouldn't happen.
			 */
			utf_extra = 0;
		    }
		}
		if (utf_extra) {
		    LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
		    itmp += utf_extra;
		    /*
		     *	Make sure we don't restore emphasis to
		     *	the last character of hightext if we
		     *	are making the link current. - FM
		     */
		    if (flag == ON && data[(itmp + 1)] == '\0') {
			LYstopTargetEmphasis();
			TargetEmphasisON = FALSE;
			LYGetYX(y, offset);
			move(hLine, (offset + 1));
		    } else {
			addstr(tmp);
		    }
		    tmp[1] = '\0';
		    written += (utf_extra + 1);
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
		    /*
		     *	For CJK strings, by Masanobu Kimura.
		     */
		    tmp[1] = data[++itmp];
		    /*
		     *	Make sure we don't restore emphasis to
		     *	the last character of hightext if we
		     *	are making the link current. - FM
		     */
		    if (flag == ON && data[(itmp + 1)] == '\0') {
			LYstopTargetEmphasis();
			TargetEmphasisON = FALSE;
			LYGetYX(y, offset);
			move(hLine, (offset + 1));
		    } else {
			addstr(tmp);
		    }
		    tmp[1] = '\0';
		    written += 2;
		} else {
		    /*
		     *	Make sure we don't restore emphasis to
		     *	the last character of hightext if we
		     *	are making the link current. - FM
		     */
		    if (flag == ON && data[(itmp + 1)] == '\0') {
			LYstopTargetEmphasis();
			TargetEmphasisON = FALSE;
			LYGetYX(y, offset);
			move(hLine, (offset + 1));
		    } else {
			addstr(tmp);
		    }
		    written++;
		}
	    }

	    /*
	     *	Stop the emphasis if we haven't already, then reset
	     *	the offset to our current position in the line, and
	     *	if that is beyond the link, or we are making the link
	     *	current and it is the last character in the hightext,
	     *	we are done. - FM
	     */
	    if (TargetEmphasisON) {
		LYstopTargetEmphasis();
		TargetEmphasisON = FALSE;
	    }
	    LYGetYX(y, offset);
	    if (offset >=
		(hoffset + (flag == ON ? (hLen - 1) : hLen))) {
		goto highlight_search_hightext2;
	    }

	    /*
	     *	See if we have another hit that starts
	     *	within the hightext. - FM
	     */
	    if (!utf_flag) {
		data = Data + (offset - Offset);
	    } else {
		data = LYmbcs_skip_glyphs(Data,
					  (offset - Offset),
					  utf_flag);
	    }
	    if ((case_sensitive ?
		 (cp = LYno_attr_mbcs_strstr(data,
					     target,
					     utf_flag,
					     &HitOffset,
					     &LenNeeded)) != NULL :
		 (cp = LYno_attr_mbcs_case_strstr(data,
					     target,
					     utf_flag,
					     &HitOffset,
					     &LenNeeded)) != NULL) &&
		(offset + LenNeeded) < LYcols) {
		/*
		 *  If the hit starts after the end of the hightext,
		 *  or we are making the link current and the hit
		 *  starts at its last character, we are done. - FM
		 */
		if ((HitOffset + offset) >=
		    (hoffset +
		     (flag == ON ? (hLen - 1) : hLen)))  {
		    goto highlight_search_hightext2;
a684 307
		/*
		 *  If the target extends beyond our buffer, emphasize
		 *  everything in the hightext starting at this hit.
		 *  Otherwise, set up the data and offsets, and loop
		 *  back. - FM
		 */
		if ((HitOffset + (offset + tLen)) >=
		    (hoffset + hLen)) {
		    offset = (HitOffset + offset);
		    if (!utf_flag) {
			data = buffer + (offset - hoffset);
		    } else {
			refresh();
			data = LYmbcs_skip_glyphs(buffer,
						  (offset - hoffset),
						  utf_flag);
		    }
		    move(hLine, offset);
		    itmp = 0;
		    written = 0;
		    len = strlen(data);

		    /*
		     *	Turn the emphasis back on. - FM
		     */
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    for (;
			 written < len && (tmp[0] = data[itmp]) != '\0';
			 itmp++)  {
			/*
			 *  Print all the other target chars, except
			 *  the last character if it is also the last
			 *  character of hightext and we are making
			 *  the link current. - FM
			 */
			if (utf_flag && !isascii(tmp[0])) {
			    if ((*tmp & 0xe0) == 0xc0) {
				utf_extra = 1;
			    } else if ((*tmp & 0xf0) == 0xe0) {
				utf_extra = 2;
			    } else if ((*tmp & 0xf8) == 0xf0) {
				utf_extra = 3;
			    } else if ((*tmp & 0xfc) == 0xf8) {
				utf_extra = 4;
			    } else if ((*tmp & 0xfe) == 0xfc) {
				utf_extra = 5;
			    } else {
				/*
				 *  Garbage.
				 */
				utf_extra = 0;
			    }
			    if (strlen(&data[itmp+1]) < utf_extra) {
				/*
				 *  Shouldn't happen.
				 */
				utf_extra = 0;
			    }
			}
			if (utf_extra) {
			    LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
			    itmp += utf_extra;
			    /*
			     *	Make sure we don't restore emphasis to
			     *	the last character of hightext if we
			     *	are making the link current. - FM
			     */
			    if (flag == ON && data[(itmp + 1)] == '\0') {
				LYstopTargetEmphasis();
				TargetEmphasisON = FALSE;
				LYGetYX(y, offset);
				move(hLine, (offset + 1));
			    } else {
				addstr(tmp);
			    }
			    tmp[1] = '\0';
			    written += (utf_extra + 1);
			    utf_extra = 0;
			} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
			    /*
			     *	For CJK strings, by Masanobu Kimura.
			     */
			    tmp[1] = data[++itmp];
			    /*
			     *	Make sure we don't restore emphasis to
			     *	the last character of hightext if we
			     *	are making the link current. - FM
			     */
			    if (flag == ON && data[(itmp + 1)] == '\0') {
				LYstopTargetEmphasis();
				TargetEmphasisON = FALSE;
			    } else {
				addstr(tmp);
			    }
			    tmp[1] = '\0';
			    written += 2;
			} else {
			    /*
			     *	Make sure we don't restore emphasis to
			     *	the last character of hightext if we
			     *	are making the link current. - FM
			     */
			    if (flag == ON && data[(itmp + 1)] == '\0') {
				LYstopTargetEmphasis();
				TargetEmphasisON = FALSE;
			    } else {
				addstr(tmp);
			    }
			    written++;
			}
		    }
		    /*
		     *	Turn off the emphasis if we haven't already,
		     *	and then we're done. - FM
		     */
		    if (TargetEmphasisON) {
			LYstopTargetEmphasis();
		    }
		    goto highlight_search_hightext2;
		} else {
		    Data = cp;
		    Offset = (offset + HitOffset);
		    data = buffer;
		    offset = hoffset;
		    goto highlight_hit_within_hightext;
		}
	    }
	    goto highlight_search_hightext2;
	}
highlight_search_hightext2:
	if (target && *target && (links[cur].type & WWW_LINK_TYPE) &&
	    links[cur].hightext2 && *links[cur].hightext2 &&
	    links[cur].ly < display_lines &&
	    HText_getFirstTargetInLine(HTMainText,
				       (links[cur].anchor_line_num + 1),
				       utf_flag,
				       (int *)&Offset,
				       (int *)&tLen,
				       (char **)&theData,
				       target)) {
	    int itmp, written, len, y, offset;
	    char *data;
	    int tlen = strlen(target);
	    int hlen, hLen;
	    int hLine = (links[cur].ly + 1);
	    int hoffset = links[cur].hightext2_offset;
	    size_t utf_extra = 0;

	    /*
	     *	Copy into the buffer only what will fit
	     *	up to the right border of the screen. - FM
	     */
	    LYmbcsstrncpy(buffer,
			  (links[cur].hightext2 ?
			   links[cur].hightext2 : ""),
			  (sizeof(buffer) - 1),
			  ((LYcols - 1) - links[cur].hightext2_offset),
			  utf_flag);
	    hlen = strlen(buffer);
	    hLen = ((HTCJK != NOCJK || utf_flag) ?
		  LYmbcsstrlen(buffer, utf_flag) : hlen);

	    /*
	     *	Break out if the first hit in the line
	     *	starts after this link. - FM
	     */
	    if (Offset >= (hoffset + hLen)) {
		goto highlight_search_done;
	    }

	    /*
	     *	Recursively skip hits that end before this link, and
	     *	break out if there is no hit beyond those. - FM
	     */
	    Data = theData;
	    while ((Offset < hoffset) &&
		   ((Offset + tLen) <= hoffset)) {
		data = (Data + tlen);
		offset = (Offset + tLen);
		if ((case_sensitive ?
		     (cp = LYno_attr_mbcs_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL :
		     (cp = LYno_attr_mbcs_case_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL) &&
		    (offset + LenNeeded) < LYcols) {
		    Data = cp;
		    Offset = (offset + HitOffset);
		} else {
		    goto highlight_search_done;
		}
	    }
	    data = buffer;
	    offset = hoffset;

	    /*
	     *	If the hit starts before the hightext2, and ends
	     *	in or beyond the hightext2, restore the emphasis,
	     *	skipping the first and last characters of the
	     *	hightext2 if we're making the link current. - FM
	     */
	    if ((Offset < offset) &&
		((Offset + tLen) > offset)) {
		itmp = 0;
		written = 0;
		len = (tlen - (offset - Offset));

		/*
		 *  Go to the start of the hightext2 and
		 *  handle its first character. - FM
		 */
		move(hLine, offset);
		tmp[0] = data[itmp];
		if (utf_flag && !isascii(tmp[0])) {
		    if ((*tmp & 0xe0) == 0xc0) {
			utf_extra = 1;
		    } else if ((*tmp & 0xf0) == 0xe0) {
			utf_extra = 2;
		    } else if ((*tmp & 0xf8) == 0xf0) {
			utf_extra = 3;
		    } else if ((*tmp & 0xfc) == 0xf8) {
			utf_extra = 4;
		    } else if ((*tmp & 0xfe) == 0xfc) {
			utf_extra = 5;
		    } else {
			/*
			 *  Garbage.
			 */
			utf_extra = 0;
		    }
		    if (strlen(&data[itmp+1]) < utf_extra) {
			/*
			 *  Shouldn't happen.
			 */
			utf_extra = 0;
		    }
		}
		if (utf_extra) {
		    LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
		    itmp += utf_extra;
		    /*
		     *	Start emphasis immediately if we are
		     *	making the link non-current. - FM
		     */
		    if (flag != ON) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			addstr(tmp);
		    } else {
			move(hLine, (offset + 1));
		    }
		    tmp[1] = '\0';
		    written += (utf_extra + 1);
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
		    /*
		     *	For CJK strings, by Masanobu Kimura.
		     */
		    tmp[1] = data[++itmp];
		    /*
		     *	Start emphasis immediately if we are
		     *	making the link non-current. - FM
		     */
		    if (flag != ON) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			addstr(tmp);
		    } else {
			move(hLine, (offset + 1));
		    }
		    tmp[1] = '\0';
		    written += 2;
		} else {
		    /*
		     *	Start emphasis immediately if we are making
		     *	the link non-current. - FM
		     */
		    if (flag != ON) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			addstr(tmp);
		    } else {
			move(hLine, (offset + 1));
		    }
		    written++;
		}
		itmp++;
		/*
		 *  Start emphasis after the first character
		 *  if we are making the link current and this
		 *  is not the last character. - FM
		 */
		if (!TargetEmphasisON &&
		    data[itmp] != '\0') {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		}

		/*
		 *  Handle the remaining characters. - FM
		 */
d689 3
a691 4
		     *	Print all the other target chars, except
		     *	the last character if it is also the last
		     *	character of hightext2 and we are making
		     *	the link current. - FM
d693 1
a693 24
		    if (utf_flag && !isascii(tmp[0])) {
			if ((*tmp & 0xe0) == 0xc0) {
			    utf_extra = 1;
			} else if ((*tmp & 0xf0) == 0xe0) {
			    utf_extra = 2;
			} else if ((*tmp & 0xf8) == 0xf0) {
			    utf_extra = 3;
			} else if ((*tmp & 0xfc) == 0xf8) {
			    utf_extra = 4;
			} else if ((*tmp & 0xfe) == 0xfc) {
			    utf_extra = 5;
			} else {
			    /*
			     *	Garbage.
			     */
			    utf_extra = 0;
			}
			if (strlen(&data[itmp+1]) < utf_extra) {
			    /*
			     *	Shouldn't happen.
			     */
			    utf_extra = 0;
			}
		    }
d698 3
a700 3
			 *  Make sure we don't restore emphasis to
			 *  the last character of hightext2 if we
			 *  are making the link current. - FM
d706 1
a706 1
			    move(hLine, (offset + 1));
d708 1
a708 1
			    addstr(tmp);
d713 1
a713 1
		    } else if (HTCJK != NOCJK && !isascii(tmp[0])) {
d715 1
a715 1
			 *  For CJK strings, by Masanobu Kimura.
d719 3
a721 3
			 *  Make sure we don't restore emphasis to
			 *  the last character of hightext2 if we
			 *  are making the link current. - FM
d727 1
a727 1
			    move(hLine, (offset + 1));
d729 1
a729 1
			    addstr(tmp);
d735 3
a737 3
			 *  Make sure we don't restore emphasis to
			 *  the last character of hightext2 if we
			 *  are making the link current. - FM
d743 1
a743 1
			    move(hLine, (offset + 1));
d745 1
a745 1
			    addstr(tmp);
d752 4
a755 6
		 *  Stop the emphasis if we haven't already, then
		 *  reset the offset to our current position in
		 *  the line, and if that is beyond the link, or
		 *  or we are making the link current and it is
		 *  the last character of the hightext2, we are
		 *  done. - FM
d762 1
a762 29
		if (offset >=
		    (hoffset +
		     (flag == ON ? (hLen - 1) : hLen)))  {
		    goto highlight_search_done;
		}

		/*
		 *  See if we have another hit that starts
		 *  within the hightext2. - FM
		 */
		if (!utf_flag) {
		    data = Data + (offset - Offset);
		} else {
		    data = LYmbcs_skip_glyphs(Data,
					      (offset - Offset),
					      utf_flag);
		}
		if ((case_sensitive ?
		     (cp = LYno_attr_mbcs_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL :
		     (cp = LYno_attr_mbcs_case_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL) &&
		    (offset + LenNeeded) < LYcols) {
d764 2
a765 3
		     *	If the hit starts after the end of the hightext2,
		     *	or we are making the link current and the hit
		     *	starts at its last character, we are done. - FM
d767 6
a772 6
		    if ((HitOffset + offset) >=
			(hoffset +
			 (flag == ON ? (hLen - 1) : hLen)))  {
			goto highlight_search_done;
		    }

d774 3
a776 2
		     *	Set up the data and offset for the hit, and let
		     *	the code for within hightext2 hits handle it. - FM
d778 1
a778 52
		    Data = cp;
		    Offset = (offset + HitOffset);
		    data = buffer;
		    offset = hoffset;
		    goto highlight_hit_within_hightext2;
		}
		goto highlight_search_done;
	    }

highlight_hit_within_hightext2:
	    /*
	     *	If we get to here, the hit starts within the
	     *	hightext2.  If we are making the link current
	     *	and it's the last character in the hightext2,
	     *	we are done.  Otherwise, move there and start
	     *	restoring the emphasis. - FM
	     */
	    if ((Offset - offset) >
		(flag == ON ? (hLen - 1) : hLen))  {
		goto highlight_search_done;
	    }
	    if (!utf_flag) {
		data += (Offset - offset);
	    } else {
		refresh();
		data = LYmbcs_skip_glyphs(data,
					  (Offset - offset),
					  utf_flag);
	    }
	    offset = Offset;
	    itmp = 0;
	    written = 0;
	    len = tlen;

	    /*
	     *	Go to the start of the hit and
	     *	handle its first character. - FM
	     */
	    move(hLine, offset);
	    tmp[0] = data[itmp];
	    if (utf_flag && !isascii(tmp[0])) {
		if ((*tmp & 0xe0) == 0xc0) {
		    utf_extra = 1;
		} else if ((*tmp & 0xf0) == 0xe0) {
		    utf_extra = 2;
		} else if ((*tmp & 0xf8) == 0xf0) {
		    utf_extra = 3;
		} else if ((*tmp & 0xfc) == 0xf8) {
		    utf_extra = 4;
		} else if ((*tmp & 0xfe) == 0xfc) {
		    utf_extra = 5;
		} else {
d780 4
a783 1
		     *	Garbage.
d785 11
a795 100
		    utf_extra = 0;
		}
		if (strlen(&data[itmp+1]) < utf_extra) {
		    /*
		     *	Shouldn't happen.
		     */
		    utf_extra = 0;
		}
	    }
	    if (utf_extra) {
		LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
		itmp += utf_extra;
		/*
		 *  Start emphasis immediately if we are making
		 *  the link non-current, or we are making it
		 *  current but this is not the first or last
		 *  character of the hightext2. - FM
		 */
		if (flag != ON ||
		    (offset > hoffset && data[itmp+1] != '\0')) {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    addstr(tmp);
		} else {
		    move(hLine, (offset + 1));
		}
		tmp[1] = '\0';
		written += (utf_extra + 1);
		utf_extra = 0;
	    } else if (HTCJK != NOCJK && !isascii(tmp[0])) {
		/*
		 *  For CJK strings, by Masanobu Kimura.
		 */
		tmp[1] = data[++itmp];
		/*
		 *  Start emphasis immediately if we are making
		 *  the link non-current, or we are making it
		 *  current but this is not the first or last
		 *  character of the hightext2. - FM
		 */
		if (flag != ON ||
		    (offset > hoffset && data[itmp+1] != '\0')) {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    addstr(tmp);
		} else {
		    move(hLine, (offset + 1));
		}
		tmp[1] = '\0';
		written += 2;
	    } else {
		/*
		 *  Start emphasis immediately if we are making
		 *  the link non-current, or we are making it
		 *  current but this is not the first or last
		 *  character of the hightext2. - FM
		 */
		if (flag != ON ||
		    (offset > hoffset && data[itmp+1] != '\0')) {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    addstr(tmp);
		} else {
		    move(hLine, (offset + 1));
		}
		written++;
	    }
	    itmp++;
	    /*
	     *	Start emphasis after the first character
	     *	if we are making the link current and this
	     *	is not the last character. - FM
	     */
	    if (!TargetEmphasisON &&
		data[itmp] != '\0') {
		LYstartTargetEmphasis();
		TargetEmphasisON = TRUE;
	    }

	    for (;
		 written < len && (tmp[0] = data[itmp]) != '\0';
		 itmp++)  {
		/*
		 *  Print all the other target chars, except
		 *  the last character if it is also the last
		 *  character of hightext2 and we are making
		 *  the link current. - FM
		 */
		if (utf_flag && !isascii(tmp[0])) {
		    if ((*tmp & 0xe0) == 0xc0) {
			utf_extra = 1;
		    } else if ((*tmp & 0xf0) == 0xe0) {
			utf_extra = 2;
		    } else if ((*tmp & 0xf8) == 0xf0) {
			utf_extra = 3;
		    } else if ((*tmp & 0xfc) == 0xf8) {
			utf_extra = 4;
		    } else if ((*tmp & 0xfe) == 0xfc) {
			utf_extra = 5;
		    } else {
d797 1
a797 1
			 *  Garbage.
d799 64
a862 3
			utf_extra = 0;
		    }
		    if (strlen(&data[itmp+1]) < utf_extra) {
d864 2
a865 1
			 *  Shouldn't happen.
d867 9
a875 1
			utf_extra = 0;
d878 47
a924 15
		if (utf_extra) {
		    LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
		    itmp += utf_extra;
		    /*
		     *	Make sure we don't restore emphasis to
		     *	the last character of hightext2 if we
		     *	are making the link current. - FM
		     */
		    if (flag == ON && data[(itmp + 1)] == '\0') {
			LYstopTargetEmphasis();
			TargetEmphasisON = FALSE;
			LYGetYX(y, offset);
			move(hLine, (offset + 1));
		    } else {
			addstr(tmp);
a925 38
		    tmp[1] = '\0';
		    written += (utf_extra + 1);
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
		    /*
		     *	For CJK strings, by Masanobu Kimura.
		     */
		    tmp[1] = data[++itmp];
		    /*
		     *	Make sure we don't restore emphasis to
		     *	the last character of hightext2 if we
		     *	are making the link current. - FM
		     */
		    if (flag == ON && data[(itmp + 1)] == '\0') {
			LYstopTargetEmphasis();
			TargetEmphasisON = FALSE;
			LYGetYX(y, offset);
			move(hLine, (offset + 1));
		    } else {
			addstr(tmp);
		    }
		    tmp[1] = '\0';
		    written += 2;
		} else {
		    /*
		     *	Make sure we don't restore emphasis to
		     *	the last character of hightext2 if we
		     *	are making the link current. - FM
		     */
		    if (flag == ON && data[(itmp + 1)] == '\0') {
			LYstopTargetEmphasis();
			TargetEmphasisON = FALSE;
			LYGetYX(y, offset);
			move(hLine, (offset + 1));
		    } else {
			addstr(tmp);
		    }
		    written++;
d927 6
d934 71
d1006 24
d1031 2
a1032 5
	     *	Stop the emphasis if we haven't already, then reset
	     *	the offset to our current position in the line, and
	     *	if that is beyond the link, or we are making the link
	     *	current and it is the last character in the hightext2,
	     *	we are done. - FM
d1034 8
a1041 9
	    if (TargetEmphasisON) {
		LYstopTargetEmphasis();
		TargetEmphasisON = FALSE;
	    }
	    LYGetYX(y, offset);
	    if (offset >=
		(hoffset + (flag == ON ? (hLen - 1) : hLen))) {
		goto highlight_search_done;
	    }
d1043 15
a1057 33
	    /*
	     *	See if we have another hit that starts
	     *	within the hightext2. - FM
	     */
	    if (!utf_flag) {
		data = (Data + (offset - Offset));
	    } else {
		data = LYmbcs_skip_glyphs(Data,
					  (offset - Offset),
					  utf_flag);
	    }
	    if ((case_sensitive ?
		 (cp = LYno_attr_mbcs_strstr(data,
					     target,
					     utf_flag,
					     &HitOffset,
					     &LenNeeded)) != NULL :
		 (cp = LYno_attr_mbcs_case_strstr(data,
					     target,
					     utf_flag,
					     &HitOffset,
					     &LenNeeded)) != NULL) &&
		(offset + LenNeeded) < LYcols) {
		/*
		 *  If the hit starts after the end of the hightext2,
		 *  or we are making the link current and the hit
		 *  starts at its last character, we are done. - FM
		 */
		if ((HitOffset + offset) >=
		    (hoffset +
		     (flag == ON ? (hLen - 1) : hLen)))  {
		    goto highlight_search_done;
		}
d1059 9
a1067 21
		/*
		 *  If the target extends beyond our buffer, emphasize
		 *  everything in the hightext2 starting at this hit.
		 *  Otherwise, set up the data and offsets, and loop
		 *  back. - FM
		 */
		if ((HitOffset + (offset + tLen)) >=
		    (hoffset + hLen)) {
		    offset = (HitOffset + offset);
		    if (!utf_flag) {
			data = buffer + (offset - hoffset);
		    } else {
			refresh();
			data = LYmbcs_skip_glyphs(buffer,
						  (offset - hoffset),
						  utf_flag);
		    }
		    move(hLine, offset);
		    itmp = 0;
		    written = 0;
		    len = strlen(data);
d1069 3
a1071 8
		    /*
		     *	Turn the emphasis back on. - FM
		     */
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    for (;
			 written < len && (tmp[0] = data[itmp]) != '\0';
			 itmp++)  {
d1073 1
a1073 4
			 *  Print all the other target chars, except
			 *  the last character if it is also the last
			 *  character of hightext2 and we are making
			 *  the link current. - FM
d1075 3
a1077 59
			if (utf_flag && !isascii(tmp[0])) {
			    if ((*tmp & 0xe0) == 0xc0) {
				utf_extra = 1;
			    } else if ((*tmp & 0xf0) == 0xe0) {
				utf_extra = 2;
			    } else if ((*tmp & 0xf8) == 0xf0) {
				utf_extra = 3;
			    } else if ((*tmp & 0xfc) == 0xf8) {
				utf_extra = 4;
			    } else if ((*tmp & 0xfe) == 0xfc) {
				utf_extra = 5;
			    } else {
				/*
				 *  Garbage.
				 */
				utf_extra = 0;
			    }
			    if (strlen(&data[itmp+1]) < utf_extra) {
				/*
				 *  Shouldn't happen.
				 */
				utf_extra = 0;
			    }
			}
			if (utf_extra) {
			    LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
			    itmp += utf_extra;
			    /*
			     *	Make sure we don't restore emphasis to
			     *	the last character of hightext2 if we
			     *	are making the link current. - FM
			     */
			    if (flag == ON && data[(itmp + 1)] == '\0') {
				LYstopTargetEmphasis();
				TargetEmphasisON = FALSE;
				LYGetYX(y, offset);
				move(hLine, (offset + 1));
			    } else {
				addstr(tmp);
			    }
			    tmp[1] = '\0';
			    written += (utf_extra + 1);
			    utf_extra = 0;
			} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
			    /*
			     *	For CJK strings, by Masanobu Kimura.
			     */
			    tmp[1] = data[++itmp];
			    /*
			     *	Make sure we don't restore emphasis to
			     *	the last character of hightext2 if we
			     *	are making the link current. - FM
			     */
			    if (flag == ON && data[(itmp + 1)] == '\0') {
				LYstopTargetEmphasis();
				TargetEmphasisON = FALSE;
			    } else {
				addstr(tmp);
			    }
a1078 1
			    written += 2;
d1080 1
a1080 12
			    /*
			     *	Make sure we don't restore emphasis to
			     *	the last character of hightext2 if we
			     *	are making the link current. - FM
			     */
			    if (flag == ON && data[(itmp + 1)] == '\0') {
				LYstopTargetEmphasis();
				TargetEmphasisON = FALSE;
			    } else {
				addstr(tmp);
			    }
			    written++;
d1082 1
a1082 15
		    }
		    /*
		     *	Turn off the emphasis if we haven't already,
		     *	and then we're done. - FM
		     */
		    if (TargetEmphasisON) {
			LYstopTargetEmphasis();
		    }
		    goto highlight_search_done;
		} else {
		    Data = cp;
		    Offset = (offset + HitOffset);
		    data = buffer;
		    offset = hoffset;
		    goto highlight_hit_within_hightext2;
d1085 13
a1097 1
	    goto highlight_search_done;
a1098 2
highlight_search_done:
	FREE(theData);
d1104 1
a1104 1
	    move((LYlines - 1), (LYcols - 1));
d1106 1
a1106 1
#endif /* FANCY CURSES || USE_SLANG */
d1110 1
a1110 1
	    move(links[cur].ly,
d1114 1
a1114 1
	    refresh();
d1145 1
a1145 1
    char *ns = string;
d1148 1
a1148 1
    if (!string)
d1151 4
d1205 1
a1205 1
    char buffer[256];
d1209 2
d1231 6
d1244 1
a1244 1
    if ((text[0] != '\0') &&
d1249 1
a1249 1
	if ((temp = (unsigned char *)calloc(1, strlen(text) + 1)) == NULL)
d1252 1
a1252 1
	    TO_EUC((CONST unsigned char *)text, temp);
d1254 8
a1261 1
	    TO_SJIS((CONST unsigned char *)text, temp);
d1263 3
a1265 3
	    for (i = 0, j = 0; text[i]; i++) {
		if (text[i] != CH_ESC) {  /* S/390 -- gil -- 2119 */
		    temp[j++] = text[i];
d1306 3
a1308 3
	for (i = 0, len = 0; text[i] != '\0' && len < max_length; i++) {
	    if (text[i] != CH_ESC) {  /* S/390 -- gil -- 2136 */
		buffer[len++] = text[i];
d1324 1
a1324 1
	    move(LYStatusLine, 0);
d1326 1
a1326 1
	    move(LYlines-1, 0);
d1329 1
a1329 1
	move(LYlines-3, 0);
d1331 1
a1331 1
	move(LYlines-1, 0);
d1333 2
a1334 1
    clrtoeol();
d1336 12
d1349 4
a1352 2
	if (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
	    refresh();
d1354 1
a1354 1
#endif /* HAVE_UTF8_STATUSLINES */
d1357 1
a1357 1
	addstr (buffer);
d1362 7
a1368 5
		int a=(strncmp(buffer, ALERT_FORMAT, ALERT_PREFIX_LEN) ||
		       !hashStyles[s_alert].name) ? s_status : s_alert;
		LynxChangeStyle (a, STACK_ON, 1);
		addstr(buffer);
		wbkgdset(stdscr,
d1372 1
a1372 1
		clrtoeol();
d1374 1
a1374 1
		    wbkgdset(stdscr, A_NORMAL | ' ');
d1376 1
a1376 1
		    wbkgdset(stdscr, hashStyles[s_normal].color | ' ');
d1378 2
a1379 2
		    wbkgdset(stdscr, displayStyles[DSTYLE_NORMAL].color | ' ');
		LynxChangeStyle (a, STACK_OFF, 0);
d1383 1
a1383 1
    refresh();
d1420 1
a1420 1
    move(LYlines-2,0);
d1422 3
a1424 4
    clrtoeol();
    addstr(NOVICE_LINE_ONE);
    clrtoeol();

d1427 1
a1427 1
       addstr(DIRED_NOVICELINE);
d1432 1
a1432 1
	addstr(NOVICE_LINE_TWO);
d1434 1
a1434 1
	addstr((char *)novice_lines(lineno));
d1436 1
a1436 1
    refresh();
d1440 1
a1440 1
#ifdef NSL_FORK
d1455 1
a1455 1
#if SLANG_VERSION >= 9919
d1475 1
a1475 1
#endif /* NSL_FORK */
d1483 1
a1483 1
	CTRACE(tfp, "\r *** Set simulated 'Z'");
d1485 2
a1486 2
	    CTRACE(tfp, ", %d pending", fake_zap);
	CTRACE(tfp, " ***\n");
d1489 3
a1491 3
	CTRACE(tfp, "\r *** Unset simulated 'Z'");
	CTRACE(tfp, ", %d pending", fake_zap);
	CTRACE(tfp, " ***\n");
d1506 7
d1517 2
a1518 1
#if HAVE_GETTIMEOFDAY
d1537 1
d1539 1
a1539 1
#ifndef USE_SLANG
d1547 1
a1547 1
	CTRACE(tfp, "\r *** Got simulated 'Z' ***\n");
d1557 1
d1573 1
a1573 1
    socket_timeout.tv_usec = 100;
d1586 1
a1586 1
    if ((ret == -1) && (errno == EINTR))
d1593 1
d1595 3
a1597 3
#if defined (DOSPATH) && defined (NCURSES)
    nodelay(stdscr,TRUE);
#endif /* DOSPATH */
d1602 3
a1604 3
#if defined (DOSPATH) && defined (NCURSES)
    nodelay(stdscr,FALSE);
#endif /* DOSPATH */
d1611 1
a1611 1
	CTRACE(tfp, "\r *** Got simulated 'Z' ***\n");
d1619 1
a1619 1
	  return((int)FALSE);
d1639 1
a1639 1
    if (TOUPPER(c) == 'Z' || c == 7 || c == 3)
d1643 3
a1645 2
	** no new getfile() cyrcle possible until the previous finished.
	** Currently we have scrolling in partial mode and toggling of trace log.
d1647 16
a1662 7
    switch (keymap[c+1])
    {
    case LYK_TRACE_TOGGLE :	       /*  Toggle TRACE mode. */
	WWW_TraceFlag = ! WWW_TraceFlag;
	if (LYOpenTraceLog())
	    HTUserMsg(WWW_TraceFlag ? TRACE_ON : TRACE_OFF);
	break ;
a1663 1

a1664 1
	if (display_partial && (NumOfLines_partial > 2))
d1666 2
a1667 1
	{
d1669 13
a1681 2
	    switch (keymap[c+1])
	    {
d1749 2
a1750 2
	    NumOfLines_partial = HText_getNumOfLines();
	    HText_pageDisplay(Newline_partial, "");
d1760 39
d1803 1
a1803 1
	char *,		filename)
d1818 1
a1818 1
    if ((cp=strchr(host, ':')) != NULL)
d1824 1
a1824 6
#ifdef VMS
	     0==strcasecomp(host, HTHostName())))
#else
	     0==strcmp(host, HTHostName())))
#endif /* VMS */
	{
d1841 1
a1841 1
	char *,		filename)
d1858 5
a1862 12
#ifdef VMS
    if ((0==strcasecomp(host, "localhost") ||
	 0==strcasecomp(host, LYHostName) ||
	 0==strcasecomp(host, HTHostName())))
#else
    if ((0==strcmp(host, "localhost") ||
	 0==strcmp(host, LYHostName) ||
	 0==strcmp(host, HTHostName())))
#endif /* VMS */
    {
	    FREE(host);
	    return YES;
d1894 1
a1894 1
    char *LocalAlias;
d1896 1
a1896 1
    if (!(alias && *alias))
d1906 1
a1906 3
    if ((LocalAlias = (char *)calloc(1, (strlen(alias) + 1))) == NULL)
	outofmem(__FILE__, "HTAddLocalhosAlias");
    strcpy(LocalAlias, alias);
d1917 1
a1917 1
	char *,		filename)
d1937 1
a1937 6
#ifdef VMS
	if (0==strcasecomp(host, alias))
#else
	if (0==strcmp(host, alias))
#endif /* VMS */
	{
d1968 1
a1968 1
    if (cp == NULL || *cp == '\0')
d1983 1
a1983 1
	if (getenv(cp2) != NULL) {
d1988 3
a1990 3
#if defined (DOSPATH)
	if (cp[1] == ':')
	    return(NOT_A_URL_TYPE);	/* could be drive letter? - kw */
d1995 2
a1996 2
	} else if (isdigit((unsigned char)*cp1)) {
	    while (*cp1 && isdigit((unsigned char)*cp1))
d2028 6
d2051 3
d2058 2
a2059 2
    if (cp == NULL || *cp == '\0')
	return(0);
d2065 1
a2065 1
	return(0);
d2079 2
a2080 2
    if (*cp == ':' || LYIsHtmlSep(*cp))
	return(0);
d2082 16
a2097 2
    if (compare_type(cp, "news:", 5)) {
	return(NEWS_URL_TYPE);
d2099 7
a2105 2
    } else if (compare_type(cp, "nntp:", 5)) {
	return(NNTP_URL_TYPE);
d2107 5
a2111 2
    } else if (compare_type(cp, "snews:", 6)) {
	return(SNEWS_URL_TYPE);
d2113 5
a2117 5
    } else if (compare_type(cp, "newspost:", 9)) {
	/*
	 *  Special Lynx type to handle news posts.
	 */
	return(NEWSPOST_URL_TYPE);
d2119 5
a2123 5
    } else if (compare_type(cp, "newsreply:", 10)) {
	/*
	 *  Special Lynx type to handle news replies (followups).
	 */
	return(NEWSREPLY_URL_TYPE);
d2125 5
a2129 5
    } else if (compare_type(cp, "snewspost:", 10)) {
	/*
	 *  Special Lynx type to handle snews posts.
	 */
	return(NEWSPOST_URL_TYPE);
d2131 5
a2135 5
    } else if (compare_type(cp, "snewsreply:", 11)) {
	/*
	 *  Special Lynx type to handle snews replies (followups).
	 */
	return(NEWSREPLY_URL_TYPE);
d2137 5
a2141 2
    } else if (compare_type(cp, "mailto:", 7)) {
	return(MAILTO_URL_TYPE);
d2143 5
a2147 8
    } else if (compare_type(cp, "file:", 5)) {
	if (LYisLocalFile(cp)) {
	    return(FILE_URL_TYPE);
	} else if (LYIsHtmlSep(cp[5]) && LYIsHtmlSep(cp[6])) {
	    return(FTP_URL_TYPE);
	} else {
	    return(0);
	}
d2149 5
a2153 2
    } else if (compare_type(cp, "data:", 5)) {
	return(DATA_URL_TYPE);
d2155 5
a2159 7
    } else if (compare_type(cp, "lynxexec:", 9)) {
	/*
	 *  Special External Lynx type to handle execution
	 *  of commands or scripts which require a pause to
	 *  read the screen upon completion.
	 */
	return(LYNXEXEC_URL_TYPE);
d2161 5
a2165 7
    } else if (compare_type(cp, "lynxprog:", 9)) {
	/*
	 *  Special External Lynx type to handle execution
	 *  of commands, scripts or programs with do not
	 *  require a pause to read screen upon completion.
	 */
	return(LYNXPROG_URL_TYPE);
d2167 7
a2173 5
    } else if (compare_type(cp, "lynxcgi:", 8)) {
	/*
	 *  Special External Lynx type to handle cgi scripts.
	 */
	return(LYNXCGI_URL_TYPE);
d2175 15
a2189 5
    } else if (compare_type(cp, "LYNXPRINT:", 10)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXPRINT_URL_TYPE);
d2191 2
a2192 5
    } else if (compare_type(cp, "LYNXOPTIONS:", 12)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXOPTIONS_URL_TYPE);
d2194 5
a2198 5
    } else if (compare_type(cp, "LYNXCFG:", 8)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXCFG_URL_TYPE);
d2200 7
a2206 5
    } else if (compare_type(cp, "LYNXMESSAGES:", 13)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXMESSAGES_URL_TYPE);
d2208 7
a2214 5
    } else if (compare_type(cp, "LYNXCOMPILEOPTS:", 16)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXCOMPILE_OPTS_URL_TYPE);
d2216 5
a2220 5
    } else if (compare_type(cp, "LYNXDOWNLOAD:", 13)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXDOWNLOAD_URL_TYPE);
d2222 14
a2235 5
    } else if (compare_type(cp, "LYNXDIRED:", 10)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXDIRED_URL_TYPE);
d2237 20
a2256 5
    } else if (compare_type(cp, "LYNXHIST:", 9)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXHIST_URL_TYPE);
d2258 8
a2265 5
    } else if (compare_type(cp, "LYNXKEYMAP:", 11)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXKEYMAP_URL_TYPE);
d2267 6
a2272 6
    } else if (compare_type(cp, "LYNXIMGMAP:", 11)) {
	/*
	 *  Special Internal Lynx type.
	 */
	(void)is_url(&cp[11]);
	return(LYNXIMGMAP_URL_TYPE);
d2274 15
a2288 5
    } else if (compare_type(cp, "LYNXCOOKIE:", 11)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXCOOKIE_URL_TYPE);
d2290 6
a2295 8
    } else if (strstr((cp+3), "://") == NULL) {
	/*
	 *  If it doesn't contain "://", and it's not one of the
	 *  the above, it can't be a URL with a scheme we know,
	 *  so check if it's an unknown scheme for which proxying
	 *  has been set up. - FM
	 */
	return(LYCheckForProxyURL(filename));
d2297 4
a2300 2
    } else if (compare_type(cp, "http:", 5)) {
	return(HTTP_URL_TYPE);
d2302 28
a2329 2
    } else if (compare_type(cp, "https:", 6)) {
	return(HTTPS_URL_TYPE);
d2331 4
a2334 2
    } else if (compare_type(cp, "gopher:", 7)) {
	if ((cp1 = strchr(cp+11,'/')) != NULL) {
d2336 4
a2339 12
	    if (TOUPPER(*(cp1+1)) == 'H' || *(cp1+1) == 'w')
		/* if this is a gopher html type */
		return(HTML_GOPHER_URL_TYPE);
	    else if (*(cp1+1) == 'T' || *(cp1+1) == '8')
		return(TELNET_GOPHER_URL_TYPE);
	    else if (*(cp1+1) == '7')
		return(INDEX_GOPHER_URL_TYPE);
	    else
		return(GOPHER_URL_TYPE);
	} else {
	    return(GOPHER_URL_TYPE);
	}
d2341 6
a2346 2
    } else if (compare_type(cp, "ftp:", 4)) {
	return(FTP_URL_TYPE);
d2348 6
a2353 2
    } else if (compare_type(cp, "wais:", 5)) {
	return(WAIS_URL_TYPE);
d2355 6
a2360 2
    } else if (compare_type(cp, "telnet:", 7)) {
	return(TELNET_URL_TYPE);
d2362 17
a2378 2
    } else if (compare_type(cp, "tn3270:", 7)) {
	return(TN3270_URL_TYPE);
d2380 16
a2395 2
    } else if (compare_type(cp, "rlogin:", 7)) {
	return(RLOGIN_URL_TYPE);
d2397 44
a2440 18
    } else if (compare_type(cp, "cso:", 4)) {
	return(CSO_URL_TYPE);

    } else if (compare_type(cp, "finger:", 7)) {
	return(FINGER_URL_TYPE);

    } else if (compare_type(cp, "afs:", 4)) {
	return(AFS_URL_TYPE);

    } else if (compare_type(cp, "prospero:", 9)) {
	return(PROSPERO_URL_TYPE);

    } else {
	/*
	 *  Check if it's an unknown scheme for which
	 *  proxying has been set up. - FM
	 */
	return(LYCheckForProxyURL(filename));
d2442 1
d2449 1
a2449 2
    CONST char *,	address
    )
d2453 1
a2453 1
    if (!(address && *address))
d2460 2
a2461 2
    FREE(temp0);
    if (!isurl)
d2463 1
d2465 1
d2472 5
d2481 1
d2485 2
a2486 1
	if (cp && isdigit(cp[1]) && strchr(cp, '-') == NULL) {
d2492 88
a2605 4
#if HAVE_UTMP
extern char *ttyname PARAMS((int fd));
#endif

d2613 1
a2613 3
#if ! HAVE_UTMP
    return(TRUE);
#else
d2619 1
a2619 1
    if ((cp=ttyname(0)))
d2622 12
a2633 12
    if (mytty && (fp=fopen(UTMP_FILE, "r")) != NULL) {
	    mytty++;
	    do {
		n = fread((char *) &me, sizeof(struct utmp), 1, fp);
	    } while (n>0 && !STREQ(me.ut_line,mytty));
	    (void) fclose(fp);

	    if (n > 0 &&
		strlen(me.ut_host) > strlen(LYLocalDomain) &&
		STREQ(LYLocalDomain,
		  me.ut_host+strlen(me.ut_host)-strlen(LYLocalDomain)) )
		return(TRUE);
d2636 2
a2637 2
	    if ((n > 0) && (strlen(me.ut_host) == 0))
		return(TRUE);
d2641 2
a2642 1
	CTRACE(tfp,"Could not get ttyname or open UTMP file %s\n", UTMP_FILE);
d2646 79
a2724 1
#endif /* !HAVE_UTMP */
d2726 2
d2767 7
a2773 1
    SLtt_Screen_Cols = (LYcols * 6);
d2781 1
a2781 1
#if HAVE_SIZECHANGE
d2813 10
d2824 1
a2824 1
	LYlines = 24;
d2826 1
a2826 1
	LYcols = 80;
d2834 7
a2840 2
	CTRACE(tfp, "Window size changed from (%d,%d) to (%d,%d)\n",
		old_lines, old_cols, LYlines, LYcols);
d2843 1
a2843 1
    (void)signal (SIGWINCH, size_change);
d2875 1
a2875 1
    char *new;
d2879 1
a2879 1
    if (!(fname && *fname))
d2882 1
a2882 3
    if ((new = (char *)calloc(1, (strlen(fname) + 1))) == NULL)
	outofmem(__FILE__, "HTAddSugFilename");
    strcpy(new, fname);
d2913 2
a2914 1
    char *temp, *cp, *cp1, *end;
d2933 10
a2942 6
    temp = (char *)calloc(1, (strlen(lynx_temp_space) + 60));
    if (temp == NULL)
	outofmem(__FILE__, "change_sug_filename");
    cp = wwwName(lynx_temp_space);
    if (LYIsHtmlSep(*cp)) {
	sprintf(temp, "file://localhost%s%d", cp, (int)getpid());
d2944 1
a2944 1
	sprintf(temp, "file://localhost/%s%d", cp, (int)getpid());
d2946 1
d2951 2
a2952 3
	strcpy(temp, (cp ? cp : ""));
	strcpy(fname, "temp");
	strcat(fname, temp);
d2957 6
a2962 6
    /*
     *  Hmm... we have a directory name.
     *  It is annoying to see a scheme+host+path name as a suggested one,
     *  let's remove the last_slash and go ahead like we have a file name. - LP
     */
    fname[strlen(fname) - 1] = '\0';
d2978 13
d3036 1
a3036 1
		   *cp <  ' ' || ((unsigned char)*cp) > 126) {
d3216 8
a3225 1
    int code;
d3231 34
d3266 2
d3275 3
d3279 1
d3286 2
a3287 1
	leaf[8 - (tail - suffix)] = 0;
d3303 1
a3303 1
    CTRACE(tfp, "-> '%s'\n", result);
d3350 39
a3388 24
PRIVATE CONST char *restrict_name[] = {
       "inside_telnet" ,
       "outside_telnet",
       "telnet_port"   ,
       "inside_ftp"    ,
       "outside_ftp"   ,
       "inside_rlogin" ,
       "outside_rlogin",
       "suspend"       ,
       "editor"        ,
       "shell"	       ,
       "bookmark"      ,
       "multibook"     ,
       "bookmark_exec" ,
       "option_save"   ,
       "print"	       ,
       "download"      ,
       "disk_save"     ,
       "exec"	       ,
       "lynxcgi"       ,
       "exec_frozen"   ,
       "goto"	       ,
       "jump"	       ,
       "file_url"      ,
d3390 10
a3399 7
       "news_post"     ,
       "inside_news"   ,
       "outside_news"  ,
#endif
       "mail"	       ,
       "dotfiles"      ,
       "useragent"     ,
d3401 1
a3401 1
       "dired_support" ,
d3403 1
a3403 1
       "change_exec_perms",
d3407 7
a3413 1
       "externals" ,
a3414 46
       (char *) 0     };

	/* restrict_name and restrict_flag structure order
	 * must be maintained exactly!
	 */

PRIVATE BOOLEAN *restrict_flag[] = {
       &no_inside_telnet,
       &no_outside_telnet,
       &no_telnet_port,
       &no_inside_ftp,
       &no_outside_ftp,
       &no_inside_rlogin,
       &no_outside_rlogin,
       &no_suspend  ,
       &no_editor   ,
       &no_shell    ,
       &no_bookmark ,
       &no_multibook ,
       &no_bookmark_exec,
       &no_option_save,
       &no_print    ,
       &no_download ,
       &no_disk_save,
       &no_exec     ,
       &no_lynxcgi  ,
       &exec_frozen ,
       &no_goto     ,
       &no_jump     ,
       &no_file_url ,
#ifndef DISABLE_NEWS
       &no_newspost ,
       &no_inside_news,
       &no_outside_news,
#endif
       &no_mail     ,
       &no_dotfiles ,
       &no_useragent ,
#ifdef DIRED_SUPPORT
       &no_dired_support,
#ifdef OK_PERMIT
       &no_change_exec_perms,
#endif /* OK_PERMIT */
#endif /* DIRED_SUPPORT */
#ifdef USE_EXTERNALS
       &no_externals ,
d3416 8
a3423 27
       (BOOLEAN *) 0  };

PUBLIC void parse_restrictions ARGS1(
	CONST char *,	s)
{
      CONST char *p;
      CONST char *word;
      int i;

      if (STREQ("all", s)) {
	   /* set all restrictions */
	  for (i=0; restrict_flag[i]; i++)
	      *restrict_flag[i] = TRUE;
	  return;
      }

      if (STREQ("default", s)) {
	   /* set all restrictions */
	  for (i=0; restrict_flag[i]; i++)
	      *restrict_flag[i] = TRUE;

	     /* reset these to defaults */
	     no_inside_telnet = !(CAN_ANONYMOUS_INSIDE_DOMAIN_TELNET);
	    no_outside_telnet = !(CAN_ANONYMOUS_OUTSIDE_DOMAIN_TELNET);
#ifndef DISABLE_NEWS
	       no_inside_news = !(CAN_ANONYMOUS_INSIDE_DOMAIN_READ_NEWS);
	      no_outside_news = !(CAN_ANONYMOUS_OUTSIDE_DOMAIN_READ_NEWS);
d3425 2
a3426 7
		no_inside_ftp = !(CAN_ANONYMOUS_INSIDE_DOMAIN_FTP);
	       no_outside_ftp = !(CAN_ANONYMOUS_OUTSIDE_DOMAIN_FTP);
	     no_inside_rlogin = !(CAN_ANONYMOUS_INSIDE_DOMAIN_RLOGIN);
	    no_outside_rlogin = !(CAN_ANONYMOUS_OUTSIDE_DOMAIN_RLOGIN);
		      no_goto = !(CAN_ANONYMOUS_GOTO);
		  no_goto_cso = !(CAN_ANONYMOUS_GOTO_CSO);
		 no_goto_file = !(CAN_ANONYMOUS_GOTO_FILE);
d3428 1
a3428 1
	       no_goto_finger = !(CAN_ANONYMOUS_GOTO_FINGER);
d3430 1
a3430 1
		  no_goto_ftp = !(CAN_ANONYMOUS_GOTO_FTP);
d3432 1
a3432 1
	       no_goto_gopher = !(CAN_ANONYMOUS_GOTO_GOPHER);
d3434 6
a3439 6
		 no_goto_http = !(CAN_ANONYMOUS_GOTO_HTTP);
		no_goto_https = !(CAN_ANONYMOUS_GOTO_HTTPS);
	      no_goto_lynxcgi = !(CAN_ANONYMOUS_GOTO_LYNXCGI);
	     no_goto_lynxexec = !(CAN_ANONYMOUS_GOTO_LYNXEXEC);
	     no_goto_lynxprog = !(CAN_ANONYMOUS_GOTO_LYNXPROG);
	       no_goto_mailto = !(CAN_ANONYMOUS_GOTO_MAILTO);
d3441 2
a3442 2
		 no_goto_news = !(CAN_ANONYMOUS_GOTO_NEWS);
		 no_goto_nntp = !(CAN_ANONYMOUS_GOTO_NNTP);
d3444 1
a3444 1
	       no_goto_rlogin = !(CAN_ANONYMOUS_GOTO_RLOGIN);
d3446 134
a3579 1
		no_goto_snews = !(CAN_ANONYMOUS_GOTO_SNEWS);
d3581 28
a3608 32
	       no_goto_telnet = !(CAN_ANONYMOUS_GOTO_TELNET);
	       no_goto_tn3270 = !(CAN_ANONYMOUS_GOTO_TN3270);
		 no_goto_wais = !(CAN_ANONYMOUS_GOTO_WAIS);
	       no_telnet_port = !(CAN_ANONYMOUS_GOTO_TELNET_PORT);
		      no_jump = !(CAN_ANONYMOUS_JUMP);
		      no_mail = !(CAN_ANONYMOUS_MAIL);
		     no_print = !(CAN_ANONYMOUS_PRINT);
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
		      no_exec = LOCAL_EXECUTION_LINKS_ALWAYS_OFF_FOR_ANONYMOUS;
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
	  return;
      }

      p = s;
      while (*p) {
	  p = LYSkipCBlanks(p);
	  if (*p == '\0')
	      break;
	  word = p;
	  while (*p != ',' && *p != '\0')
	      p++;

	  for (i=0; restrict_name[i]; i++) {
	     if (STRNEQ(word, restrict_name[i], p-word)) {
		 *restrict_flag[i] = TRUE;
		 break;
	     }
	  }
	  if (*p)
	      p++;
      }
      return;
d3711 1
a3711 1
	mf = getenv("MAIL");
d3750 1
a3750 1
**  an 'g'oto entries, after they have been
d3752 2
d3762 1
a3762 1
    if (!(*href && *(*href)))
d3765 5
d3773 1
a3773 1
    if (!strcasecomp(*href, "news:")) {
d3775 1
a3775 2
    } else if (!strcasecomp(*href, "nntp:") ||
	       !strcasecomp(*href, "snews:")) {
d3778 1
d3780 2
a3781 2
	CTRACE(tfp, "%s%s'%s' is not a URL\n",
		    (name ? name : ""), (name ? " " : ""), *href);
d3784 3
a3786 1
    if ((temp = HTParse(*href, "", PARSE_ALL)) != NULL && *temp != '\0')
a3805 1
    FILE *fptemp = NULL;
d3811 1
a3811 1
#if defined(DOSPATH) || defined(__EMX__)
d3813 7
a3819 6
	 char *cp_url = *AllocatedString;
	 for(; *cp_url != '\0'; cp_url++)
		if(*cp_url == '\\') *cp_url = '/';
	 cp_url--;
	 if(*cp_url == ':')
		 StrAllocCat(*AllocatedString,"/");
d3821 1
a3821 1
#endif /* DOSPATH */
d3824 1
a3824 1
    StrAllocCopy(*AllocatedString,"file://localhost");
d3828 1
a3828 1
#if defined(DOSPATH) || defined(__EMX__)
d3830 1
a3830 1
#endif /* DOSPATH */
d3846 1
a3846 1
	    StrAllocCat(*AllocatedString, HTVMS_wwwName((char *)Home_Dir()));
d3860 2
a3861 3
	    if ((fragment = strchr(old_string, '#')) != NULL)
		*fragment = '\0';
	    strcpy(url_file, old_string);
d3878 1
a3878 1
		*fragment = '#';
d3888 1
a3888 3
	    if (fragment != NULL) {
		*fragment = '#';
	    }
d3908 1
a3908 1
		     !isdigit((unsigned char)cp[1])) ||
d3917 3
a3919 4
		    strcpy(url_file, "/");
		    strcat(url_file, old_string);
		    CTRACE(tfp, "Can't find '%s'  Will assume it's a bad path.\n",
				old_string);
d3940 3
a3942 4
	    if (fragment != NULL) {
		*fragment = '#';
		fragment = NULL;
	    }
d3945 1
a3945 1
		 !isdigit((unsigned char)cp[1])) ||
d3954 3
a3956 4
		strcpy(url_file, "/");
		strcat(url_file, old_string);
		CTRACE(tfp, "Can't find '%s'  Will assume it's a bad path.\n",
			    old_string);
d3974 22
a3995 3
	CTRACE(tfp, "Trying: '%s'\n", *AllocatedString);
#else /* Unix: */
#ifdef DOSPATH
d4004 6
a4009 4
	    CTRACE(tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString);
	} else
#endif /* DOSPATH */
d4014 1
a4014 1
	    StrAllocCat(*AllocatedString, Home_Dir());
d4026 2
a4027 2
	    CTRACE(tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString);
d4040 1
a4040 1
#if defined (DOSPATH) || defined (__EMX__)
d4048 3
d4052 3
d4060 1
a4060 1
#endif /* DOSPATH */
d4062 1
a4062 1
	    CTRACE(tfp, "Converted '%s' to '%s'\n", old_string, temp);
d4064 1
a4064 1
		(fptemp = fopen(temp, "r")) != NULL) {
d4068 1
a4068 1
#if defined (DOSPATH) || defined (__EMX__)
d4073 2
a4074 3
		if (strchr(temp, '#') == NULL &&
			   strchr(temp, '%') == NULL)
		StrAllocCopy(cp, temp);
d4076 2
a4077 1
#endif /* DOSPATH */
d4079 1
d4082 2
a4083 2
		CTRACE(tfp, "Converted '%s' to '%s'\n",
			    old_string, *AllocatedString);
d4090 1
a4090 2
		if ((fragment = strchr(cp, '#')) != NULL)
		    *fragment = '\0';	/* keep as pointer into cp string */
d4095 3
d4101 1
a4101 1
		     (fptemp = fopen(temp2, "r")) != NULL)) {
d4120 1
a4120 1
			    *fragment = '#';
d4125 2
a4126 2
		    CTRACE(tfp, "Converted '%s' to '%s'\n",
				old_string, *AllocatedString);
d4150 1
a4150 1
			    *fragment = '#';
d4164 21
a4184 2
		CTRACE(tfp, "Can't stat() or fopen() '%s'\n",
			    temp2 ? temp2 : temp);
d4187 2
a4188 1
				       URLDomainSuffixes)) {
d4198 3
d4202 4
a4205 1
		CTRACE(tfp, "Trying: '%s'\n", *AllocatedString);
a4208 4
	    if (fptemp) {
		fclose(fptemp);
		fptemp = NULL;
	    }
d4222 1
a4222 1
	    StrAllocCat(*AllocatedString, HTVMS_wwwName((char *)Home_Dir()));
d4226 1
a4226 1
		   (fptemp = fopen(old_string, "r")) != NULL) {
d4233 1
a4233 1
	    CTRACE(tfp, "Converted '%s' to '%s'\n", old_string, temp);
d4238 2
a4239 6
	    if (fptemp) {
		fclose(fptemp);
		fptemp = NULL;
	    }
	    CTRACE(tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString);
d4246 1
a4246 5
#ifdef VMS
	    StrAllocCat(*AllocatedString, HTVMS_wwwName((char *)Home_Dir()));
#else
	    StrAllocCat(*AllocatedString, Home_Dir());
#endif /* VMS */
d4255 48
a4302 2
		StrAllocCat(*AllocatedString, temp);
		FREE(temp);
a4303 9
	} else {
	    /*
	     *	Normal absolute path.  Simplify, trim any
	     *	residual relative elements, and append it. - FM
	     */
	    StrAllocCopy(temp, old_string);
	    LYTrimRelFromAbsPath(temp);
	    StrAllocCat(*AllocatedString, temp);
	    FREE(temp);
a4304 2
	CTRACE(tfp, "Converted '%s' to '%s'\n",
		    old_string, *AllocatedString);
a4305 3
    FREE(old_string);
    /* Pause so we can read the messages before invoking curses */
    CTRACE_SLEEP(AlertSecs);
d4307 1
d4339 5
a4343 1
    BOOLEAN Startup = (helpfilepath == NULL);
d4377 1
a4377 1
    } else if ((Fragment = strchr(Str, '#')) != NULL) {
d4383 1
a4383 1
	*Fragment = '\0';
d4393 1
a4393 1
	isdigit((unsigned char)StrColon[1])) {
d4413 1
a4413 1
	fprintf(stdout, "%s '%s'%s\n", WWW_FIND_MESSAGE, host, FIRST_SEGMENT);
d4415 9
a4423 1
#ifndef DJGPP
d4425 1
a4425 3
#else
    if (resolve(host) != 0)
#endif /* DJGPP */
d4431 3
a4433 2
	    CTRACE(tfp, "LYExpandHostForURL: Ignoring interrupt because '%s' resolved.\n",
			host);
d4444 3
a4446 5
#ifndef DJGPP
    } else if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED)) {
#else /* DJGPP */
    } else if (LYCursesON && HTCheckForInterrupt()) {
#endif /* DJGPP */
d4450 3
a4452 2
	CTRACE(tfp, "LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
		    host);
d4529 1
a4529 1
		isdigit((unsigned char)HostColon[1])) {
d4542 1
a4542 5
#ifndef DJGPP
	    GotHost = (LYGetHostByName(host) != NULL);
#else
	    GotHost = (resolve(host) != 0);
#endif /* DJGPP */
a4549 1
#ifndef DJGPP
a4550 3
#else /* DJGPP */
		if (LYCursesON && HTCheckForInterrupt())
#endif /* DJGPP */
d4552 3
a4554 2
		    CTRACE(tfp, "LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
				host);
d4609 1
a4609 1
	    *Fragment = '#';
d4619 1
a4619 1
	CTRACE(tfp, "LYExpandHostForURL: Ignoring interrupt because '%s' %s.\n",
d4621 1
a4621 1
		    (GotHost ? "resolved" : "timed out"));
d4727 1
a4727 1
    } else if (default_scheme != NULL && *default_scheme != '\0') {
d4764 1
a4764 1
    TerminalSlash = LYIsPathSep(path[(strlen(path) - 1)]);
d4889 1
a4889 1
#if HAVE_GETCWD
d4899 62
d4967 1
a4967 16
	if ((cp = getenv("HOME")) == NULL || *cp == '\0'
#ifdef UNIX
	    || *cp != '/'
#endif /* UNIX */
	    ) {
#if defined (DOSPATH) || defined (__EMX__) /* BAD!	WSB */
	    if ((cp = getenv("TEMP")) == NULL || *cp == '\0') {
		if ((cp = getenv("TMP")) == NULL || *cp == '\0') {
		    StrAllocCopy(HomeDir, "C:\\");
		} else {
		    StrAllocCopy(HomeDir, cp);
		}
	    } else {
		StrAllocCopy(HomeDir, cp);
	    }
#else
d4969 3
a4971 8
	    if ((cp = getenv("SYS$LOGIN")) == NULL || *cp == '\0') {
		if ((cp = getenv("SYS$SCRATCH")) == NULL || *cp == '\0') {
		    StrAllocCopy(HomeDir, "sys$scratch:");
		} else {
		    StrAllocCopy(HomeDir, cp);
		}
	    } else {
		StrAllocCopy(HomeDir, cp);
d4973 1
d4975 2
a4976 1
#if HAVE_UTMP
a4991 3
#ifdef UNIX
	    if (cp && *cp)
		HTAlwaysAlert(NULL, gettext("Ignoring invalid HOME"));
a4993 1
#endif /* DOSPATH */
d5002 4
d5256 7
a5262 1
    if (!(home && *home))
d5266 2
a5267 5
#ifdef VMS
	StrAllocCopy(home, "Error:");
#else
	StrAllocCopy(home, "/error");
#endif /* VMS */
d5294 2
a5295 5
	    char *temp = (char *)calloc(1,
					(strlen(home) + strlen(file) + 10));
	    if (temp == NULL)
		outofmem(__FILE__, "LYAddPathToHome");
	    sprintf(temp, "%s%s", HTVMS_wwwName(home), (file + 1));
d5350 1
a5350 1
    if (!(string && *string))
d5353 1
a5353 1
    CTRACE(tfp, "LYmktime: Parsing '%s'\n", s);
d5359 1
a5359 1
    while (*s != '\0' && !isdigit((unsigned char)*s))
d5368 2
a5369 2
    while (*s != '\0' && isdigit((unsigned char)*s))
       s++;
d5380 1
a5380 1
    while (*s != '\0' && !isalnum((unsigned char)*s))
d5385 1
a5385 1
    while (*s != '\0' && isalnum((unsigned char)*s))
d5388 2
a5389 2
	(s - start) < (isdigit((unsigned char)*(s - 1)) ? 2 : 3) ||
	(s - start) > (isdigit((unsigned char)*(s - 1)) ? 2 : 9))
d5391 1
a5391 1
    LYstrncpy(temp, start, (isdigit((unsigned char)*(s - 1)) ? 2 : 3));
d5471 1
a5471 1
    while (*s != '\0' && !isdigit((unsigned char)*s))
d5476 1
a5476 1
    while (*s != '\0' && isdigit((unsigned char)*s))
d5505 1
a5505 1
    while (*s != '\0' && !isdigit((unsigned char)*s))
d5513 1
a5513 1
	while (*s != '\0' && isdigit((unsigned char)*s))
d5523 1
a5523 1
	while (*s != '\0' && !isdigit((unsigned char)*s))
d5528 1
a5528 1
	while (*s != '\0' && isdigit((unsigned char)*s))
d5538 1
a5538 1
	while (*s != '\0' && !isdigit((unsigned char)*s))
d5543 1
a5543 1
	while (*s != '\0' && isdigit((unsigned char)*s))
d5567 1
a5567 1
    if (absolute == FALSE && clock2 <= time(NULL))
d5570 1
a5570 1
	CTRACE(tfp, "LYmktime: clock=%ld, ctime=%s",
d5572 1
a5572 1
		    ctime(&clock2));
d5577 1
a5577 1
#if ! HAVE_PUTENV
d5579 1
a5579 1
 *  No putenv on the next so we use this code instead!
d5674 11
a5684 1
#ifdef UNIX
d5699 5
a5703 1
#if HAVE_LSTAT
d5733 1
a5733 1
		     || data.st_mode & S_IWOTH) {
d5756 1
d5773 4
d5787 1
a5787 1
	    fp = OpenHiddenFile(name, "w");
d5805 1
a5805 5
#else
# ifndef VMS
#  define OpenHiddenFile(name, mode) fopen(name, mode)
# endif
#endif
d5810 1
a5810 1
    FILE *fp = fopen (name, "wb", "mbc=32");
d5813 1
a5813 1
    FILE *fp = OpenHiddenFile(name, "wb");
d5823 1
a5823 1
    fp = fopen (name, "w", "shr=get");
d5828 1
a5828 1
    fp = OpenHiddenFile(name, "w");
d5841 1
a5841 1
    fp = fopen (name, "a+", "shr=get");
d5846 1
a5846 1
    fp = OpenHiddenFile(name, "a+");
d5853 1
a5853 1
#ifdef UNIX
a5885 2
    FILE *fp;

d5887 1
a5887 1
	strcpy(result, *cached);
d5889 1
a5889 2
	if ((fp = fopen(result, "r")) != NULL) {
	    fclose(fp);
d5897 3
a5899 11
/*
 * Maintain a list of all of the temp-files we create so that we can remove
 * them during the cleanup.
 */
typedef struct _LYTemp {
    struct _LYTemp *next;
    char *name;
    FILE *file;
} LY_TEMP;

static LY_TEMP *ly_temp;
d5914 1
a5914 1
    BOOL wrt = 'r';
d5917 1
a5917 1
    CTRACE(tfp, "LYOpenTemp(,%s,%s)\n", suffix, mode);
d5927 40
a5966 2
		CTRACE(tfp, "%s @@%d: BUG\n", __FILE__, __LINE__);
		return fp;
d5969 1
d5993 2
a5994 2
	    CTRACE(tfp, "... LYOpenTemp(%s) failed: %s\n",
		   result, LYStrerror(errno));
d6000 1
a6000 1
    if ((p = (LY_TEMP *)calloc(1, sizeof(LY_TEMP))) != 0) {
d6004 1
d6010 1
a6010 1
    CTRACE(tfp, "... LYOpenTemp(%s)\n", result);
d6024 147
a6170 3
    for (p = ly_temp; p != 0; p = p->next) {
	if (!strcmp(p->name, name)) {
	    fp = p->file = LYAppendToTxtFile (name);
d6173 2
d6176 10
d6204 1
a6204 1
	if ((p = (LY_TEMP *)calloc(1, sizeof(LY_TEMP))) != 0) {
d6213 1
a6213 1
    CTRACE(tfp, "LYOpenScratch(%s)\n", result);
d6217 13
d6238 5
a6242 11
    CTRACE(tfp, "LYCloseTemp(%s)\n", name);
    for (p = ly_temp; p != 0; p = p->next) {
	if (!strcmp(name, p->name)) {
	    CTRACE(tfp, "...LYCloseTemp(%s)%s\n", name,
		(p->file != 0) ? ", closed" : "");
	    if (p->file != 0) {
		fclose(p->file);
		p->file = 0;
	    }
	    break;
	}
d6254 4
a6257 8
    CTRACE(tfp, "LYCloseTempFP\n");
    for (p = ly_temp; p != 0; p = p->next) {
	if (p->file == fp) {
	    fclose(p->file);
	    p->file = 0;
	    CTRACE(tfp, "...LYCloseTempFP(%s)\n", p->name);
	    break;
	}
d6264 1
a6264 1
PUBLIC void LYRemoveTemp ARGS1(
d6268 1
a6268 1
    int code;
d6270 2
a6271 2
    if (name != 0 && *name != 0) {
	CTRACE(tfp, "LYRemoveTemp(%s)\n", name);
d6279 1
a6279 2
		if (p->file != 0)
		    fclose(p->file);
d6281 2
a6282 2
		CTRACE(tfp, "...LYRemoveTemp done(%d)%s\n", code,
		       (p->file != 0) ? ", closed" : "");
d6290 1
d6302 10
d6323 174
a6496 5
    CTRACE(tfp, "LYRenamedTemp(old=%s, new=%s)\n", oldname, newname);
    for (p = ly_temp; p != 0; p = p->next) {
	if (!strcmp(oldname, p->name)) {
	    StrAllocCopy((p->name), newname);
	    break;
d6498 2
d6507 1
a6507 1
PUBLIC  char * wwwName ARGS1(
d6510 1
a6510 1
    char *cp = NULL;
d6512 2
a6513 2
#ifdef DOSPATH
    cp = HTDOS_wwwName((char *)pathname);
d6516 1
a6516 1
    cp = HTVMS_wwwName((char *)pathname);
d6518 1
a6518 1
    cp = (char *)pathname;
d6520 1
a6520 1
#endif /* DOSPATH */
d6529 2
d6537 1
d6541 1
a6541 1
     *  or an "nl:" path (case-insensitive) on VMS. - FM
d6543 1
a6543 6
#ifdef VMS
    if (!strncasecomp(given, "nl:", 3) ||
	!strncasecomp(given, "/nl/", 4))
#else
    if (!strcmp(given, "/dev/null"))
#endif /* VMS */
d6548 1
a6548 1
#if HAVE_POPEN
d6554 1
a6554 1
	strcpy(result, given);
d6558 3
a6560 1
    if ((cp = strchr(given, '~'))) {
d6564 1
a6564 1
	strcat(result, wwwName(Home_Dir()));
d6573 3
a6575 1
    if (given[0] != '/' && strchr(given, ':') == NULL) {
d6586 1
a6586 1
    if (!LYIsPathSep(*given)) {
d6592 8
a6599 1
	cp = original_dir;
d6605 1
d6608 3
a6610 3
	sprintf(result, "%s/%s", cp, HTSYS_name(given));
    } else {
	strcpy(result, HTSYS_name(given));
d6612 4
a6631 1
    FILE *fp;
d6637 1
a6637 1
#if HAVE_POPEN
d6652 1
a6652 2
    if ((fp = fopen(filename, "r")) != NULL) {
	fclose(fp);
d6675 1
a6675 1
    char *leaf;
d6681 5
d6691 7
a6697 5
#ifdef NOTDEFINED
/* FIXME: this may be useful for pages that do not allow nested pages */
PUBLIC int LYOpenInternalPage ARGS2(
	FILE **,  fp0,
	char **, newfile)
d6699 1
a6699 1
    static char tempfile[LY_MAXPATH];
d6701 7
a6707 2
    LYRemoveTemp(tempfile);
    if ((*fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w")) == NULL) {
a6708 1
	return(-1);
d6710 1
a6710 5

    LYLocalFileToURL(newfile, tempfile);
    LYforce_no_cache = TRUE;  /* don't cache this doc */

    return(0);  /* OK */
a6711 1
#endif
d6718 2
d6740 1
a6740 1
     && LYwouldPush(Title)
d6757 9
a6780 6
#ifdef DOSPATH
#define PATHSEP_STR "\\"
#else
#define PATHSEP_STR "/"
#endif

d6804 1
a6804 1
	char *,	path)
d6810 1
d6817 16
d6876 1
d6890 4
a6893 1
    char *the_command = 0;
d6895 9
a6903 9
    HTAddParam(&the_command, COPY_COMMAND, 1, COPY_PATH);
    HTAddParam(&the_command, COPY_COMMAND, 2, src);
    HTAddParam(&the_command, COPY_COMMAND, 3, dst);
    HTEndParam(&the_command, COPY_COMMAND, 3);

    CTRACE(tfp, "command: %s\n", the_command);
    stop_curses();
    code = LYSystem(the_command);
    start_curses();
d6905 22
a6926 1
    FREE(the_command);
d6928 3
d6935 1
a6935 1
 * Invoke a shell command
d6942 8
d6953 1
a6953 1
    CTRACE(tfp, "LYSystem(%s)\n", command);
d6969 2
d6989 67
d7057 10
d7079 6
d7091 42
d7137 19
a7155 4
    if (getenv("SHELL") != NULL) {
	shell = getenv("SHELL");
    } else {
	shell = (getenv("COMSPEC") == NULL) ? "command.com" : getenv("COMSPEC");
d7157 1
d7160 2
a7161 2
    if (getenv("SHELL") != NULL) {
	shell = getenv("SHELL");
d7163 1
a7163 1
	shell = (getenv("COMSPEC") == NULL) ? "cmd.exe" : getenv("COMSPEC");
d7187 1
a7187 4
    char *cp;
    if ((cp = getenv(DISPLAY)) == NULL || *cp == '\0')
	cp = 0;
    return cp;
d7197 1
a7197 1
    if (new_display != 0 && *new_display != '\0') {
a7202 3
	display_putenv_command = malloc(strlen(new_display) + 12);
	if (!display_putenv_command)
	    outofmem(__FILE__, "LYsetXDisplay");
d7204 1
a7204 1
	sprintf(display_putenv_command, "DISPLAY=%s", new_display);
d7212 445
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a6 9

#ifdef __MINGW32__
int kbhit(void);

#ifdef UNIX
#undef UNIX
#endif /* UNIX */
#endif /* __MINGW32__ */

d9 1
a11 1
#include <LYUtils.h>
a16 1

a19 15
#ifdef __DJGPP__
#include <go32.h>
#include <sys/exceptn.h>
#endif /* __DJGPP__ */

#ifndef NO_GROUPS
#include <HTFile.h>
#endif

#ifdef _WINDOWS			/* 1998/04/30 (Thu) 19:04:25 */
#define GETPID()	(getpid() & 0xffff)
#else
#define GETPID()	getpid()
#endif /* _WINDOWS */

a23 9
#ifdef __EMX__
#  define BOOLEAN OS2_BOOLEAN	/* Conflicts, but is used */
#  undef HT_ERROR		/* Conflicts too */
#  define INCL_PM		/* I want some PM functions.. */
#  define INCL_DOSPROCESS	/* TIB PIB. */
#  include <os2.h>
#  undef BOOLEAN
#endif

d30 1
a30 1
#ifdef HAVE_UTMP
a34 1
#ifdef UTMPX_FILE
d38 1
d41 1
a41 5
#ifdef __UTMPX_FILE
#define UTMP_FILE __UTMPX_FILE	/* at least in OS/390  S/390 -- gil -- 2100 */
#else
#define UTMP_FILE "/var/adm/utmpx"	/* Digital Unix 4.0 */
#endif
d65 2
a66 3
extern int BSDselect(int nfds, fd_set * readfds, fd_set * writefds,
		     fd_set * exceptfds, struct timeval *timeout);

d79 3
a81 3
#ifdef __DJGPP__
#undef select			/* defined to select_s in www_tcp.h */
#endif
a90 16
/*
 * experimental - make temporary filenames random to make the scheme less
 * obvious.  However, as noted by KW, there are instances (such as the
 * 'O'ption page, for which Lynx will store a temporary filename even when
 * it no longer applies, since it will reuse that filename at a later time.
 */
#ifdef EXP_RAND_TEMPNAME
#if defined(LYNX_RAND_MAX)
#define USE_RAND_TEMPNAME 1
#define MAX_TEMPNAME 10000
#ifndef BITS_PER_CHAR
#define BITS_PER_CHAR 8
#endif
#endif
#endif

d93 3
a95 2
static HTList *localhost_aliases = NULL;	/* Hosts to treat as local */
static char *HomeDir = NULL;	/* HOME directory */
d97 3
a99 1
HTList *sug_filenames = NULL;	/* Suggested filenames   */
d102 1
a102 2
 * Maintain a list of all of the temp-files we create so that we can remove
 * them during the cleanup.
d104 22
a125 6
typedef struct _LYTemp {
    struct _LYTemp *next;
    char *name;
    BOOLEAN outs;
    FILE *file;
} LY_TEMP;
d127 8
a134 1
static LY_TEMP *ly_temp;
d136 5
a140 3
static LY_TEMP *FindTempfileByName(const char *name)
{
    LY_TEMP *p;
d142 39
a180 3
    for (p = ly_temp; p != 0; p = p->next) {
	if (!strcmp(p->name, name)) {
	    break;
d182 1
a182 11
    }
    return p;
}

static LY_TEMP *FindTempfileByFP(FILE *fp)
{
    LY_TEMP *p;

    for (p = ly_temp; p != 0; p = p->next) {
	if (p->file == fp) {
	    break;
a183 10
    }
    return p;
}

/*
 * Get an environment variable, rejecting empty strings
 */
char *LYGetEnv(const char *name)
{
    char *result = getenv(name);
a184 2
    return non_empty(result) ? result : 0;
}
d186 3
a188 13
/*
 * ascii versions of locale sensitive functions needed because in
 * Turkish locales tolower("I") is not "i". That's fatal for case
 * sensitive operations with charset names, HTML tags etc.
 */
#ifdef EXP_ASCII_CTYPES
int ascii_tolower(int i)
{
    if (91 > i && i > 64)
	return (i + 32);
    else
	return i;
}
d190 6
a195 7
int ascii_toupper(int i)
{
    if (123 > i && i > 96)
	return (i - 32);
    else
	return i;
}
d197 3
a199 8
int ascii_isupper(int i)
{
    if (91 > i && i > 64)
	return 1;
    else
	return 0;
}
#endif /* EXP_ASCII_CTYPES */
a200 20
/*
 * Check for UTF-8 data, returning the length past the first character.
 * Return zero if we found an ordinary character rather than UTF-8.
 */
size_t utf8_length(BOOL utf_flag,
		   const char *data)
{
    size_t utf_extra = 0;

    if (utf_flag && is8bits(*data)) {
	if ((*data & 0xe0) == 0xc0) {
	    utf_extra = 1;
	} else if ((*data & 0xf0) == 0xe0) {
	    utf_extra = 2;
	} else if ((*data & 0xf8) == 0xf0) {
	    utf_extra = 3;
	} else if ((*data & 0xfc) == 0xf8) {
	    utf_extra = 4;
	} else if ((*data & 0xfe) == 0xfc) {
	    utf_extra = 5;
d202 7
d210 2
a211 1
	     * Garbage.
d213 8
a220 7
	    utf_extra = 0;
	}
	if (strlen(data + 1) < utf_extra) {
	    /*
	     * Shouldn't happen.
	     */
	    utf_extra = 0;
a221 3
    }
    return utf_extra;
}
d223 15
a237 6
/*
 * Free storage used for the link-highlighting.
 */
void LYFreeHilites(int first, int last)
{
    int i;
d239 20
a258 5
    for (i = first; i < last; i++) {
	LYSetHilite(i, NULL);
	FREE(links[i].lname);
    }
}
d260 30
a289 10
/*
 * Set the initial highlight information for a given link.
 */
void LYSetHilite(int cur,
		 const char *text)
{
    links[cur].list.hl_base.hl_text = (char *) text;
    links[cur].list.hl_len = (text != NULL) ? 1 : 0;
    FREE(links[cur].list.hl_info);
}
d291 13
a303 11
/*
 * Add highlight information for the next line of a link.
 */
void LYAddHilite(int cur,
		 char *text,
		 int x)
{
    HiliteList *list = &(links[cur].list);
    HiliteInfo *have = list->hl_info;
    unsigned need = (list->hl_len - 1);
    unsigned want = (list->hl_len += 1);
d305 7
a311 9
    if (have != NULL) {
	have = typeRealloc(HiliteInfo, have, want);
    } else {
	have = typeMallocn(HiliteInfo, want);
    }
    list->hl_info = have;
    have[need].hl_text = text;
    have[need].hl_x = x;
}
a312 111
/*
 * Get the highlight text, counting from zero.
 */
const char *LYGetHiliteStr(int cur,
			   int count)
{
    const char *result;

    if (count >= links[cur].list.hl_len)
	result = NULL;
    else if (count > 0)
	result = links[cur].list.hl_info[count - 1].hl_text;
    else
	result = links[cur].list.hl_base.hl_text;
    return result;
}

/*
 * Get the X-ordinate at which to draw the corresponding highlight-text
 */
int LYGetHilitePos(int cur,
		   int count)
{
    int result;

    if (count >= links[cur].list.hl_len)
	result = -1;
    else if (count > 0)
	result = links[cur].list.hl_info[count - 1].hl_x;
    else
	result = links[cur].lx;
    return result;
}

#define LXP (links[cur].lx)
#define LYP (links[cur].ly)

#ifdef SHOW_WHEREIS_TARGETS

#define SKIP_GLYPHS(theFlag, theData, theOffset) \
	(theFlag \
	    ? LYmbcs_skip_glyphs(theData, (theOffset), theFlag) \
	    : (theData + (theOffset)))

/*
 * If we have an emphasized WHEREIS hit in the highlighted text, restore the
 * emphasis.  Note that we never emphasize the first and last characters of the
 * highlighted text when we are making the link current, so the link attributes
 * for the current link will persist at the beginning and end, providing an
 * indication to the user that it has been made current.  Also note that we use
 * HText_getFirstTargetInLine() to determine if there's a hit in the HText
 * structure line containing the link, and if so, get back a copy of the line
 * starting at that first hit (which might be before or after our link), and
 * with all IsSpecial characters stripped, so we don't need to deal with them
 * here.  -FM
 */
static BOOL show_whereis_targets(int flag,
				 int cur,
				 int count,
				 const char *target,
				 BOOL TargetEmphasisON,
				 BOOL utf_flag)
{
    const char *Data = NULL;
    const char *cp;
    char *theData = NULL;
    char buffer[MAX_LINE];
    char tmp[7];
    int HitOffset;
    int LenNeeded;
    int Offset;
    int tLen;

    tmp[0] = tmp[1] = tmp[2] = '\0';

    if (non_empty(target)
	&& (links[cur].type & WWW_LINK_TYPE)
	&& non_empty(LYGetHiliteStr(cur, count))
	&& links[cur].ly + count < display_lines
	&& HText_getFirstTargetInLine(HTMainText,
				      links[cur].anchor_line_num + count,
				      utf_flag,
				      &Offset,
				      &tLen,
				      &theData,
				      target)) {
	int itmp, written, len, y, offset;
	const char *data;
	int tlen = strlen(target);
	int hlen, hLen;
	int hLine = links[cur].ly + count;
	int hoffset = LYGetHilitePos(cur, count);
	size_t utf_extra = 0;

	/*
	 * Copy into the buffer only what will fit up to the right border of
	 * the screen.  -FM
	 */
	LYmbcsstrncpy(buffer,
		      NonNull(LYGetHiliteStr(cur, count)),
		      (sizeof(buffer) - 1),
		      (LYcolLimit - LYGetHilitePos(cur, count)),
		      utf_flag);
	hlen = strlen(buffer);
	hLen = ((HTCJK != NOCJK || utf_flag) ?
		LYmbcsstrlen(buffer, utf_flag, YES) : hlen);

	/*
	 * Break out if the first hit in the line starts after this link.  -FM
	 */
	if (Offset < (hoffset + hLen)) {
d314 2
a315 2
	     * Recursively skip hits that end before this link, and break out
	     * if there is no hit beyond those.  -FM
d322 12
a333 6
		if (((cp = LYno_attr_mb_strstr(data,
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL)
		    && (offset + LenNeeded) < LYcols) {
d337 1
a337 1
		    goto highlight_search_done;
d344 4
a347 4
	     * If the hit starts before the hightext, and ends in or beyond the
	     * hightext, restore the emphasis, skipping the first and last
	     * characters of the hightext if we're making the link current.
	     * -FM
d356 2
a357 2
		 * Go to the start of the hightext and handle its first
		 * character.  -FM
d359 1
a359 1
		LYmove(hLine, offset);
d361 24
a384 1
		utf_extra = utf8_length(utf_flag, data + itmp);
d386 1
a386 1
		    LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
d389 2
a390 2
		     * Start emphasis immediately if we are making the link
		     * non-current.  -FM
d395 1
a395 1
			LYaddstr(tmp);
d397 1
a397 1
			LYmove(hLine, (offset + 1));
d402 1
a402 1
		} else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d404 1
a404 1
		     * For CJK strings, by Masanobu Kimura.
d408 2
a409 2
		     * Start emphasis immediately if we are making the link
		     * non-current.  -FM
d414 1
a414 1
			LYaddstr(tmp);
d416 1
a416 1
			LYmove(hLine, (offset + 1));
d422 2
a423 2
		     * Start emphasis immediately if we are making the link
		     * non-current.  -FM
d428 1
a428 1
			LYaddstr(tmp);
d430 1
a430 1
			LYmove(hLine, (offset + 1));
d436 3
a438 2
		 * Start emphasis after the first character if we are making
		 * the link current and this is not the last character.  -FM
d447 1
a447 1
		 * Handle the remaining characters.  -FM
d451 1
a451 1
		     itmp++) {
d453 4
a456 3
		     * Print all the other target chars, except the last
		     * character if it is also the last character of hightext
		     * and we are making the link current.  -FM
d458 24
a481 1
		    utf_extra = utf8_length(utf_flag, data + itmp);
d483 1
a483 1
			LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
d486 3
a488 3
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
d494 1
a494 1
			    LYmove(hLine, (offset + 1));
d496 1
a496 1
			    LYaddstr(tmp);
d501 1
a501 1
		    } else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d503 1
a503 1
			 * For CJK strings, by Masanobu Kimura.
d507 3
a509 3
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
d515 1
a515 1
			    LYmove(hLine, (offset + 1));
d517 1
a517 1
			    LYaddstr(tmp);
d523 3
a525 3
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
d531 1
a531 1
			    LYmove(hLine, (offset + 1));
d533 1
a533 1
			    LYaddstr(tmp);
d540 6
a545 4
		 * Stop the emphasis if we haven't already, then reset the
		 * offset to our current position in the line, and if that is
		 * beyond the link, or or we are making the link current and it
		 * is the last character of the hightext, we are done.  -FM
d552 6
a557 1
		if (offset < (hoffset + (flag == ON ? (hLen - 1) : hLen))
d559 2
a560 2
		 * See if we have another hit that starts within the
		 * hightext.  -FM
d562 31
a592 17
		    && ((cp =
			 LYno_attr_mb_strstr(data = SKIP_GLYPHS(utf_flag,
								Data,
								offset - Offset),
					     target,
					     utf_flag, YES,
					     &HitOffset,
					     &LenNeeded)) != NULL)
		    && (offset + LenNeeded) < LYcols
		/*
		 * If the hit starts after the end of the hightext, or we
		 * are making the link current and the hit starts at its
		 * last character, we are done.  -FM
		 */
		    && (HitOffset + offset) <
		    (hoffset +
		     (flag == ON ? (hLen - 1) : hLen))) {
d594 2
a595 2
		     * Set up the data and offset for the hit, and let the code
		     * for within hightext hits handle it.  -FM
d603 1
a603 1
		goto highlight_search_done;
d606 1
a606 1
	  highlight_hit_within_hightext:
d608 22
a629 14
	     * If we get to here, the hit starts within the hightext.  If we
	     * are making the link current and it's the last character in the
	     * hightext, we are done.  Otherwise, move there and start
	     * restoring the emphasis.  -FM
	     */
	    if ((Offset - offset) <= (flag == ON ? (hLen - 1) : hLen)) {
		data = SKIP_GLYPHS(utf_flag, data, Offset - offset);
		if (utf_flag) {
		    LYrefresh();
		}
		offset = Offset;
		itmp = 0;
		written = 0;
		len = tlen;
d631 18
a648 10
		/*
		 * Go to the start of the hit and handle its first character.
		 * -FM
		 */
		LYmove(hLine, offset);
		tmp[0] = data[itmp];
		utf_extra = utf8_length(utf_flag, data + itmp);
		if (utf_extra) {
		    LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
		    itmp += utf_extra;
d650 1
a650 3
		     * Start emphasis immediately if we are making the link
		     * non-current, or we are making it current but this is not
		     * the first or last character of the hightext.  -FM
a651 10
		    if (flag != ON ||
			(offset > hoffset && data[itmp + 1] != '\0')) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
		    }
		    tmp[1] = '\0';
		    written += (utf_extra + 1);
d653 2
a654 1
		} else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d656 130
a785 1
		     * For CJK strings, by Masanobu Kimura.
d789 107
a895 3
		     * Start emphasis immediately if we are making the link
		     * non-current, or we are making it current but this is not
		     * the first or last character of the hightext.  -FM
d897 245
a1141 2
		    if (flag != ON ||
			(offset > hoffset && data[itmp + 1] != '\0')) {
d1144 1
a1144 1
			LYaddstr(tmp);
d1146 1
a1146 1
			LYmove(hLine, (offset + 2));
d1152 2
a1153 3
		     * Start emphasis immediately if we are making the link
		     * non-current, or we are making it current but this is not
		     * the first or last character of the hightext.  -FM
d1155 1
a1155 2
		    if (flag != ON ||
			(offset > hoffset && data[itmp + 1] != '\0')) {
d1158 1
a1158 1
			LYaddstr(tmp);
d1160 1
a1160 1
			LYmove(hLine, (offset + 1));
d1166 3
a1168 2
		 * Start emphasis after the first character if we are making
		 * the link current and this is not the last character.  -FM
d1176 3
d1181 1
a1181 1
		     itmp++) {
d1183 4
a1186 3
		     * Print all the other target chars, except the last
		     * character if it is also the last character of hightext
		     * and we are making the link current.  -FM
d1188 24
a1211 1
		    utf_extra = utf8_length(utf_flag, data + itmp);
d1213 1
a1213 1
			LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
d1216 3
a1218 3
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
d1224 1
a1224 1
			    LYmove(hLine, (offset + 1));
d1226 1
a1226 1
			    LYaddstr(tmp);
d1231 1
a1231 1
		    } else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d1233 1
a1233 1
			 * For CJK strings, by Masanobu Kimura.
d1237 3
a1239 3
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
d1245 1
a1245 1
			    LYmove(hLine, (offset + 1));
d1247 1
a1247 1
			    LYaddstr(tmp);
d1253 3
a1255 3
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
d1261 1
a1261 1
			    LYmove(hLine, (offset + 1));
d1263 1
a1263 1
			    LYaddstr(tmp);
d1270 6
a1275 4
		 * Stop the emphasis if we haven't already, then reset the
		 * offset to our current position in the line, and if that is
		 * beyond the link, or we are making the link current and it is
		 * the last character in the hightext, we are done.  -FM
d1282 6
a1287 1
		if (offset < (hoffset + (flag == ON ? (hLen - 1) : hLen))
d1289 2
a1290 2
		 * See if we have another hit that starts within the
		 * hightext.  -FM
d1292 30
a1321 16
		    && ((cp =
			 LYno_attr_mb_strstr(data = SKIP_GLYPHS(utf_flag,
								Data,
								offset - Offset),
					     target,
					     utf_flag, YES,
					     &HitOffset,
					     &LenNeeded)) != NULL)
		    && (offset + LenNeeded) < LYcols
		/*
		 * If the hit starts after the end of the hightext, or we
		 * are making the link current and the hit starts at its
		 * last character, we are done.  -FM
		 */
		    && (HitOffset + offset) <
		    (hoffset + (flag == ON ? (hLen - 1) : hLen))) {
d1323 2
a1324 4
		     * If the target extends beyond our buffer, emphasize
		     * everything in the hightext starting at this hit.
		     * Otherwise, set up the data and offsets, and loop back.
		     * -FM
d1326 33
a1358 10
		    if ((HitOffset + (offset + tLen)) >= (hoffset + hLen)) {
			offset = (HitOffset + offset);
			data = SKIP_GLYPHS(utf_flag, Data, offset - hoffset);
			if (utf_flag) {
			    LYrefresh();
			}
			LYmove(hLine, offset);
			itmp = 0;
			written = 0;
			len = strlen(data);
d1360 121
d1482 1
a1482 1
			 * Turn the emphasis back on.  -FM
d1484 3
a1486 64
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			for (;
			     written < len && (tmp[0] = data[itmp]) != '\0';
			     itmp++) {
			    /*
			     * Print all the other target chars, except the
			     * last character if it is also the last character
			     * of hightext and we are making the link current.
			     * -FM
			     */
			    utf_extra = utf8_length(utf_flag, data + itmp);
			    if (utf_extra) {
				LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
				itmp += utf_extra;
				/*
				 * Make sure we don't restore emphasis to the
				 * last character of hightext if we are making
				 * the link current.  -FM
				 */
				if (flag == ON && data[(itmp + 1)] == '\0') {
				    LYstopTargetEmphasis();
				    TargetEmphasisON = FALSE;
				    LYGetYX(y, offset);
				    LYmove(hLine, (offset + 1));
				} else {
				    LYaddstr(tmp);
				}
				tmp[1] = '\0';
				written += (utf_extra + 1);
				utf_extra = 0;
			    } else if (HTCJK != NOCJK && is8bits(tmp[0])) {
				/*
				 * For CJK strings, by Masanobu Kimura.
				 */
				tmp[1] = data[++itmp];
				/*
				 * Make sure we don't restore emphasis to the
				 * last character of hightext if we are making
				 * the link current.  -FM
				 */
				if (flag == ON && data[(itmp + 1)] == '\0') {
				    LYstopTargetEmphasis();
				    TargetEmphasisON = FALSE;
				} else {
				    LYaddstr(tmp);
				}
				tmp[1] = '\0';
				written += 2;
			    } else {
				/*
				 * Make sure we don't restore emphasis to the
				 * last character of hightext if we are making
				 * the link current.  -FM
				 */
				if (flag == ON && data[(itmp + 1)] == '\0') {
				    LYstopTargetEmphasis();
				    TargetEmphasisON = FALSE;
				} else {
				    LYaddstr(tmp);
				}
				written++;
			    }
			}
d1488 1
a1488 2
			 * Turn off the emphasis if we haven't already, and
			 * then we're done.  -FM
d1490 53
a1542 3
			if (TargetEmphasisON) {
			    LYstopTargetEmphasis();
			}
d1544 1
a1544 5
			Data = cp;
			Offset = (offset + HitOffset);
			data = buffer;
			offset = hoffset;
			goto highlight_hit_within_hightext;
d1546 1
a1548 7
	}
    }
  highlight_search_done:
    FREE(theData);
    return TargetEmphasisON;
}
#endif /* SHOW_WHEREIS_TARGETS */
d1550 15
a1564 46
#ifdef USE_COLOR_STYLE
static int find_cached_style(int cur,
			     int flag)
{
    int s = s_alink;

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
    if (textfields_need_activation
	&& links[cur].type == WWW_FORM_LINK_TYPE
	&& F_TEXTLIKE(links[cur].l_form->type))
	s = s_curedit;
#endif

    if (flag != ON) {
	int x;

	/*
	 * This is where we try to restore the original style when a link is
	 * unhighlighted.  The purpose of cached_styles[][] is to save the
	 * original style just for this case.  If it doesn't have a color
	 * change saved at just the right position, we look at preceding
	 * positions in the same line until we find one.
	 */
	if (LYP >= 0 && LYP < CACHEH && LXP >= 0 && LXP < CACHEW) {
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.off: cached style @@(%d,%d): ",
		     LYP, LXP));
	    s = cached_styles[LYP][LXP];
	    if (s == 0) {
		for (x = LXP - 1; x >= 0; x--) {
		    if (cached_styles[LYP][x]) {
			if (cached_styles[LYP][x] > 0) {
			    s = cached_styles[LYP][x];
			    cached_styles[LYP][LXP] = s;
			}
			CTRACE((tfp, "found %d, x_offset=%d.\n",
				cached_styles[LYP][x], (int) x - LXP));
			break;
		    }
		}
		if (s == 0) {
		    CTRACE((tfp, "not found, assume <a>.\n"));
		    s = s_a;
		}
	    } else {
		CTRACE((tfp, "found %d.\n", s));
a1565 39
	} else {
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.off: can't use cache.\n"));
	    s = s_a;
	}
    } else {
	CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.on: @@(%d,%d).\n", LYP, LXP));
    }
    return s;
}
#endif /* USE_COLOR_STYLE */

/*
 * Highlight (or unhighlight) a given link.
 */
void LYhighlight(int flag,
		 int cur,
		 const char *target)
{
    char buffer[MAX_LINE];
    int i;
    int hi_count;
    int hi_offset;
    char tmp[7];
    const char *hi_string;

#ifdef SHOW_WHEREIS_TARGETS
    BOOL TargetEmphasisON = FALSE;
    BOOL target1_drawn = NO;
#endif
    BOOL utf_flag = (BOOL) (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8);
    BOOL hl1_drawn = NO;

#ifdef USE_COLOR_STYLE
    BOOL hl2_drawn = FALSE;	/* whether links[cur].l_hightext2 is already drawn

				   properly */
#endif
    tmp[0] = tmp[1] = tmp[2] = '\0';
a1566 61
    /*
     * Bugs in the history code might cause -1 to be sent for cur, which yields
     * a crash when LYstrncpy() is called with a nonsense pointer.  As far as I
     * know, such bugs have been squashed, but if they should reappear, this
     * works around them.  -FM
     */
    if (cur < 0)
	cur = 0;
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
    if (flag == OFF)
	textinput_redrawn = FALSE;
#endif

    if (nlinks > 0) {
#ifdef USE_COLOR_STYLE
	if (flag == ON || links[cur].type == WWW_FORM_LINK_TYPE) {
	    LYmove(LYP, LXP);
	    LynxChangeStyle(find_cached_style(cur, flag), STACK_ON);
	}
#else
	if (links[cur].type == WWW_FORM_LINK_TYPE
	    || LYGetHiliteStr(cur, 0) == NULL) {
	    LYMoveToLink(cur, target, NULL,
			 flag, links[cur].inUnderline, utf_flag);
	    lynx_start_link_color(flag == ON, links[cur].inUnderline);
	} else {
	    LYMoveToLink(cur, target, LYGetHiliteStr(cur, 0),
			 flag, links[cur].inUnderline, utf_flag);
	    hl1_drawn = YES;
#ifdef SHOW_WHEREIS_TARGETS
	    target1_drawn = YES;
#endif
	}
#endif

	if (links[cur].type == WWW_FORM_LINK_TYPE) {
	    int len;
	    int avail_space = (LYcolLimit - links[cur].lx);
	    const char *text = LYGetHiliteStr(cur, 0);

	    if (avail_space > links[cur].l_form->size)
		avail_space = links[cur].l_form->size;
	    if (avail_space > (int) sizeof(buffer) - 1)
		avail_space = (int) sizeof(buffer) - 1;

	    LYstrncpy(buffer, NonNull(text), avail_space);
	    LYaddstr(buffer);

	    len = strlen(buffer);
	    for (; len < links[cur].l_form->size && len < avail_space; len++)
		LYaddch('_');

#ifdef USE_COLOR_STYLE
	} else if (flag == OFF) {
	    hl2_drawn = TRUE;
	    redraw_lines_of_link(cur);
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.off: NOFIX branch @@(%d,%d).\n",
		     LYP, LXP));
#endif
	} else if (!hl1_drawn) {
d1568 2
a1569 2
	     * Copy into the buffer only what will fit within the width of the
	     * screen.
d1571 29
a1599 7
	    LYmbcsstrncpy(buffer,
			  NonNull(LYGetHiliteStr(cur, 0)),
			  (sizeof(buffer) - 1),
			  (LYcolLimit - links[cur].lx),
			  utf_flag);
	    LYaddstr(buffer);
	}
d1601 21
a1621 15
	/*
	 * Display a second line as well.
	 */
#ifdef USE_COLOR_STYLE
	if (hl2_drawn == FALSE)
#endif
	{
	    for (hi_count = 1;
		 (hi_string = LYGetHiliteStr(cur, hi_count)) != NULL
		 && links[cur].ly + hi_count <= display_lines;
		 ++hi_count) {

		hi_offset = LYGetHilitePos(cur, hi_count);
		lynx_stop_link_color(flag == ON, links[cur].inUnderline);
		LYmove(links[cur].ly + hi_count, hi_offset);
d1623 8
a1630 13
#ifdef USE_COLOR_STYLE
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.highlight.line2: @@(%d,%d), style=%d.\n",
			 links[cur].ly + hi_count, hi_offset,
			 flag == ON ? s_alink : s_a));
		LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_ON);
#else
		lynx_start_link_color(flag == ON, links[cur].inUnderline);
#endif

		for (i = 0; (tmp[0] = hi_string[i]) != '\0'
		     && (i + hi_offset) < LYcols; i++) {
		    if (!IsSpecialAttrChar(hi_string[i])) {
d1632 4
a1635 1
			 * For CJK strings, by Masanobu Kimura.
d1637 59
a1695 3
			if (HTCJK != NOCJK && is8bits(tmp[0])) {
			    tmp[1] = hi_string[++i];
			    LYaddstr(tmp);
d1697 1
d1699 12
a1710 1
			    LYaddstr(tmp);
d1713 14
d1729 1
a1729 12
	    lynx_stop_link_color(flag == ON, links[cur].inUnderline);
	}
#ifdef SHOW_WHEREIS_TARGETS
	for (hi_count = target1_drawn ? 1 : 0;
	     LYGetHiliteStr(cur, hi_count) != NULL;
	     hi_count++) {
	    TargetEmphasisON = show_whereis_targets(flag,
						    cur,
						    hi_count,
						    target,
						    TargetEmphasisON,
						    utf_flag);
d1731 2
d1736 1
a1736 1
	     * Get cursor out of the way.
d1738 1
a1738 1
	    LYHideCursor();
d1740 1
a1740 1
#endif /* SHOW_WHEREIS_TARGETS */
d1742 1
a1742 1
	     * Never hide the cursor if there's no FANCY CURSES or SLANG.
d1744 2
a1745 2
	    LYmove(links[cur].ly,
		   ((links[cur].lx > 0) ? (links[cur].lx - 1) : 0));
d1748 1
a1748 1
	    LYrefresh();
d1754 2
a1755 2
 * free_and_clear will free a pointer if it is non-zero and then set it to
 * zero.
d1757 2
a1758 1
void free_and_clear(char **pointer)
d1768 9
a1776 8
 * Convert single or serial newlines to single spaces throughout a string
 * (ignore newlines if the preceding character is a space) and convert tabs to
 * single spaces.  Don't ignore any explicit tabs or spaces if the condense
 * argument is FALSE, otherwise, condense any serial spaces or tabs to one
 * space.  - FM
 */
void convert_to_spaces(char *string,
		       BOOL condense)
d1779 1
a1779 1
    char *ns;
d1782 1
a1782 1
    if (!s)
a1784 3
    for (; (*s && !isspace(*s)); s++) ;
    ns = s;

d1787 6
a1792 6
	case ' ':
	case '\t':
	    if (!(condense && last_is_space))
		*(ns++) = ' ';
	    last_is_space = TRUE;
	    break;
d1794 7
a1800 7
	case '\r':
	case '\n':
	    if (!last_is_space) {
		*(ns++) = ' ';
		last_is_space = TRUE;
	    }
	    break;
d1802 4
a1805 4
	default:
	    *(ns++) = *s;
	    last_is_space = FALSE;
	    break;
d1814 1
a1814 1
 * Strip trailing slashes from directory paths.
d1816 2
a1817 1
char *strip_trailing_slash(char *dirname)
d1824 1
a1824 1
    return (dirname);
d1828 1
a1828 1
 * Display (or hide) the status line.
d1832 2
a1833 1
void statusline(const char *text)
d1835 1
a1835 1
    char buffer[MAX_LINE];
a1838 2
    char *p;
    char text_buff[MAX_LINE];
d1844 1
a1844 1
     * Don't print statusline messages if dumping to stdout.
d1850 1
a1850 1
     * Don't print statusline message if turned off.
a1858 6
    /* "LYNXDOWNLOAD://Method=-1/File=%s/SugFile=%s%s\">Save to disk</a>\n" */
    LYstrncpy(text_buff, text, sizeof(text_buff) - 1);
    p = strchr(text_buff, '\n');
    if (p)
	p = '\0';

d1860 7
a1866 8
     * Deal with any CJK escape sequences and Kanji if we have a CJK character
     * set selected, otherwise, strip any escapes.  Also, make sure text is not
     * longer than the statusline window.  - FM
     */
    max_length = (((LYcolLimit - 1) < (int) sizeof(buffer))
		  ? (LYcolLimit - 1)
		  : (int) sizeof(buffer) - 1);
    if ((text_buff[0] != '\0') &&
d1869 1
a1869 1
	 * Translate or filter any escape sequences.  - FM
d1871 2
a1872 3
	if ((temp = typecallocn(unsigned char, strlen(text_buff) + 1)) == NULL)
	      outofmem(__FILE__, "statusline");

d1874 1
a1874 1
	    TO_EUC((const unsigned char *) text_buff, temp);
d1876 1
a1876 8
#ifdef KANJI_CODE_OVERRIDE
	    if (!LYRawMode || last_kcode == SJIS)
		strcpy(temp, text_buff);
	    else
		TO_SJIS((const unsigned char *) text_buff, temp);
#else
	    strcpy((char *) temp, text_buff);
#endif
d1878 3
a1880 3
	    for (i = 0, j = 0; text_buff[i]; i++) {
		if (text_buff[i] != CH_ESC) {	/* S/390 -- gil -- 2119 */
		    temp[j++] = text_buff[i];
d1887 1
a1887 1
	 * Deal with any newlines or tabs in the string.  - FM
d1889 1
a1889 1
	LYReduceBlanks((char *) temp);
d1892 2
a1893 2
	 * Handle the Kanji, making sure the text is not longer than the
	 * statusline window.  - FM
d1913 11
a1923 10
	 * Strip any escapes, and shorten text if necessary.  Note that we
	 * don't deal with the possibility of UTF-8 characters in the string. 
	 * This is unlikely, but if strings with such characters are used in
	 * LYMessages_en.h, a compilation symbol of HAVE_UTF8_STATUSLINES could
	 * be added there, and code added here for determining the displayed
	 * string length, as we do above for CJK.  - FM
	 */
	for (i = 0, len = 0; text_buff[i] != '\0' && len < max_length; i++) {
	    if (text_buff[i] != CH_ESC) {	/* S/390 -- gil -- 2119 */
		buffer[len++] = text_buff[i];
d1928 1
a1928 1
	 * Deal with any newlines or tabs in the string.  - FM
d1930 1
a1930 1
	LYReduceBlanks(buffer);
d1934 2
a1935 2
     * Move to the desired statusline window and output the text highlighted. 
     * - FM
d1938 2
a1939 2
	if (LYStatusLine < LYlines - 1) {
	    LYmove(LYStatusLine, 0);
d1941 1
a1941 1
	    LYmove(LYlines - 1, 0);
d1944 1
a1944 1
	LYmove(LYlines - 3, 0);
d1946 1
a1946 1
	LYmove(LYlines - 1, 0);
d1948 1
a1948 2
    LYclrtoeol();

a1949 12
	BOOLEAN has_CJK = FALSE;

	if (HTCJK != NOCJK) {
	    for (i = 0; buffer[i] != '\0'; i++) {
		if (buffer[i] & 0x80) {
		    has_CJK = TRUE;
		    break;
		}
	    }
	}

	if (has_CJK
d1951 2
a1952 4
	    || (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8)
#endif
	    ) {
	    LYrefresh();
d1954 1
d1956 3
a1958 3
	lynx_start_status_color();
	LYaddstr(buffer);
	lynx_stop_status_color();
d1962 16
a1977 19
	    int a = (strncmp(buffer, ALERT_FORMAT, ALERT_PREFIX_LEN)
		     || !hashStyles[s_alert].name)
	    ? s_status
	    : s_alert;

	    LynxChangeStyle(a, STACK_ON);
	    LYaddstr(buffer);
	    wbkgdset(LYwin,
		     ((lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
		      ? hashStyles[a].color
		      : A_NORMAL) | ' ');
	    LYclrtoeol();
	    if (!(lynx_has_color && LYShowColor >= SHOW_COLOR_ON))
		wbkgdset(LYwin, A_NORMAL | ' ');
	    else if (s_normal != NOSTYLE)
		wbkgdset(LYwin, hashStyles[s_normal].color | ' ');
	    else
		wbkgdset(LYwin, displayStyles[DSTYLE_NORMAL].color | ' ');
	    LynxChangeStyle(a, STACK_OFF);
d1981 1
a1981 1
    LYrefresh();
d1986 2
a1987 1
static const char *novice_lines(int lineno)
d2003 1
a2003 1
void toggle_novice_line(void)
d2005 4
a2008 4
    lineno++;
    if (*novice_lines(lineno) == '\0')
	lineno = 0;
    return;
d2011 2
a2012 1
void noviceline(int more_flag GCC_UNUSED)
d2014 1
d2018 6
a2023 5
    LYmove(LYlines - 2, 0);
    /* lynx_stop_reverse(); */
    LYclrtoeol();
    LYaddstr(NOVICE_LINE_ONE);
    LYclrtoeol();
d2026 1
a2026 1
	LYaddstr(DIRED_NOVICELINE);
d2031 1
a2031 1
	LYaddstr(NOVICE_LINE_TWO);
d2033 1
a2033 1
	LYaddstr(novice_lines(lineno));
d2035 1
a2035 1
    LYrefresh();
d2039 1
a2039 1
#if defined(NSL_FORK) || defined(MISC_EXP)
d2041 5
a2045 4
 * Returns the file descriptor from which keyboard input is expected, or INVSOC
 * (-1) if not available.  If need_selectable is true, returns non-INVSOC fd
 * only if select() is possible - actually, currently only checks if fd is
 * connected to a tty.  - kw
d2047 2
a2048 1
int LYConsoleInputFD(BOOLEAN need_selectable)
a2050 1

d2054 4
a2057 4
#if ((SLANG_VERSION >= 9919) && defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__))
    /* SLang_TT_Read_FD introduced in slang 0.99.19, from its changelog: 
     * SLang_TT_Read_FD variable is now available for unix.  This is the file
     * descriptor used by SLang_getkey.  */
d2061 1
a2061 1
#else /* !USE_SLANG */
d2074 1
a2074 1
#endif /* NSL_FORK || MISC_EXP */
d2076 1
a2076 1
static int fake_zap = 0;
d2078 2
a2079 1
void LYFakeZap(BOOL set)
d2082 1
a2082 1
	CTRACE((tfp, "\r *** Set simulated 'Z'"));
d2084 2
a2085 2
	    CTRACE((tfp, ", %d pending", fake_zap));
	CTRACE((tfp, " ***\n"));
d2088 3
a2090 3
	CTRACE((tfp, "\r *** Unset simulated 'Z'"));
	CTRACE((tfp, ", %d pending", fake_zap));
	CTRACE((tfp, " ***\n"));
d2096 1
a2096 1
static int DontCheck(void)
d2103 1
a2103 4
	return (TRUE);

    if (LYHaveCmdScript())	/* we may be running from a script */
	return (TRUE);
a2104 4
#ifdef MISC_EXP
    if (LYNoZapKey)
	return (TRUE);
#endif
d2109 1
a2109 2
#ifdef HAVE_GETTIMEOFDAY
#undef timezone			/* U/Win defines a conflicting macro */
d2112 1
a2112 2

	gettimeofday(&tv, (struct timezone *) 0);
d2116 1
a2116 1
    next = time((time_t *) 0);
d2125 1
a2125 1
int HTCheckForInterrupt(void)
d2128 2
a2129 4
    int cmd;

#ifndef VMS			/* UNIX stuff: */
#if !defined(USE_SLANG)
d2137 1
a2137 1
	CTRACE((tfp, "\r *** Got simulated 'Z' ***\n"));
d2140 1
a2140 1
	return ((int) TRUE);
d2145 1
a2145 1
	return ((int) FALSE);
a2146 1
#if !defined(_WINDOWS) || defined(__MINGW32__)
d2157 1
a2157 1
	return (FALSE);
d2162 1
a2162 1
    socket_timeout.tv_usec = 0;
d2167 2
a2168 1
	ret = Rselect(1, &readfds, NULL, NULL, &socket_timeout);
d2171 2
a2172 1
	ret = select(1, &readfds, NULL, NULL, &socket_timeout);
d2175 2
a2176 2
    if ((ret == -1) && (SOCKET_ERRNO == EINTR))
	return ((int) FALSE);
d2179 2
a2180 2
    if (!FD_ISSET(0, &readfds))
	return ((int) FALSE);
a2181 1
#endif /* !_WINDOWS */
d2183 3
a2185 3
#if defined(PDCURSES)
    nodelay(LYwin, TRUE);
#endif /* PDCURSES */
d2190 3
a2192 3
#if defined(PDCURSES)
    nodelay(LYwin, FALSE);
#endif /* PDCURSES */
d2195 1
a2195 1
    extern int typeahead(void);
d2199 1
a2199 1
	CTRACE((tfp, "\r *** Got simulated 'Z' ***\n"));
d2202 1
a2202 1
	return ((int) TRUE);
d2207 1
a2207 1
	return ((int) FALSE);
d2212 1
a2212 1
	return ((int) TRUE);
d2227 2
a2228 2
    if (LYCharIsINTERRUPT(c))
	return ((int) TRUE);
d2230 12
a2241 13
    /* There is a subset of mainloop() actions available at this stage:  no new
     * getfile() cycle is possible until the previous finished.  Currently we
     * have scrolling in partial mode, toggling of trace log, and pasting. 
     * User search now in progress...
     */
    cmd = (LKC_TO_LAC(keymap, c));
    switch (cmd) {
    case LYK_TRACE_TOGGLE:	/*  Toggle TRACE mode. */
	handle_LYK_TRACE_TOGGLE();
	break;
#ifdef CAN_CUT_AND_PASTE
    case LYK_TO_CLIPBOARD:{	/* ^S */
	    const char *s = LYDownLoadAddress();
a2242 8
	    if (!s || !*s || put_clip(s))
		HTInfoMsg(gettext("Copy to clipboard failed."));
	    else
		HTInfoMsg(gettext("Download document URL put to clipboard."));
	    break;
	}
#endif /* defined CAN_CUT_AND_PASTE */
    default:
d2244 1
d2246 1
a2246 2
	if (display_partial && (NumOfLines_partial > 2)) {
	    BOOLEAN do_refresh;
d2248 5
a2252 16
	    int Newline_partial = LYGetNewline();

	    switch (cmd) {
	    case LYK_WHEREIS:	/* search within the document */
	    case LYK_NEXT:	/* search for the next occurrence in the document */
	    case LYK_PREV:	/* search for the previous occurrence in the document */
		handle_LYK_WHEREIS(cmd, &do_refresh);
		if (www_search_result != -1) {
		    Newline_partial = www_search_result;
		    www_search_result = -1;	/* reset */
		}
		break;

	    case LYK_FASTBACKW_LINK:
		if (Newline_partial <= (display_lines) + 1) {
		    Newline_partial -= display_lines;
d2259 1
a2259 1
		    Newline_partial -= display_lines;
d2262 1
a2262 1
	    case LYK_FASTFORW_LINK:
d2266 6
a2271 6
			 HTGetLinkOrFieldStart(HText_LinksInLines(HTMainText,
								  Newline_partial,
								  display_lines)
					       - 1,
					       &Newline_partial, NULL,
					       1, TRUE)) == LINK_LINE_FOUND) {
d2276 1
a2276 1
	    case LYK_PREV_PAGE:
d2278 3
a2280 3
		    Newline_partial -= display_lines;
		break;
	    case LYK_NEXT_PAGE:
d2282 3
a2284 3
		    Newline_partial += display_lines;
		break;
	    case LYK_UP_HALF:
d2286 3
a2288 3
		    Newline_partial -= (display_lines / 2);
		break;
	    case LYK_DOWN_HALF:
d2290 3
a2292 3
		    Newline_partial += (display_lines / 2);
		break;
	    case LYK_UP_TWO:
d2294 3
a2296 3
		    Newline_partial -= 2;
		break;
	    case LYK_DOWN_TWO:
d2298 2
a2299 2
		    Newline_partial += 2;
		break;
d2307 1
a2307 3
		/* calculate for "current" bottom value */
		break;
	    case LYK_REFRESH:
d2309 3
a2311 1
	    default:
d2313 2
a2314 2
		return ((int) FALSE);
	    }			/* end switch */
d2317 2
a2318 2
	    if (LYMainLoop_pageDisplay(Newline_partial))
		NumOfLines_partial = HText_getNumOfLines();
d2322 1
a2322 1
    }				/* end switch */
d2324 1
a2324 39
    return ((int) FALSE);
}

/*
 * Check if the given filename looks like it's an absolute pathname, i.e.,
 * references a directory.
 */
BOOLEAN LYisAbsPath(const char *path)
{
    BOOLEAN result = FALSE;

    if (non_empty(path)) {
#ifdef VMS
	result = TRUE;
#else
#if defined(USE_DOS_DRIVES)
	result = (BOOL) (LYIsPathSep(path[0])
			 || (LYIsDosDrive(path)
			     && LYIsPathSep(path[2])));
#else
	result = (LYIsPathSep(path[0]));
#endif /* USE_DOS_DRIVES */
#endif
    }
    return result;
}

/*
 * Check if the given filename is the root path, e.g., "/" on Unix.
 */
BOOLEAN LYisRootPath(const char *path)
{
#if defined(USE_DOS_DRIVES)
    if (strlen(path) == 3
	&& LYIsDosDrive(path)
	&& LYIsPathSep(path[2]))
	return TRUE;
#endif
    return (BOOL) ((strlen(path) == 1) && LYIsPathSep(path[0]));
d2328 2
a2329 2
 * A file URL for a remote host is an obsolete ftp URL.
 * Return YES only if we're certain it's a local file.  - FM
d2331 2
a2332 1
BOOLEAN LYisLocalFile(const char *filename)
d2347 1
a2347 1
    if ((cp = strchr(host, ':')) != NULL)
d2351 8
a2358 3
	if (0 == strcmp("file", acc_method) &&
	    (0 == strcmp(host, "localhost") ||
	     LYSameFilename(host, HTHostName()))) {
d2371 2
a2372 2
 * Utility for checking URLs with a host field.  Return YES only if we're
 * certain it's the local host.  - FM
d2374 2
a2375 1
BOOLEAN LYisLocalHost(const char *filename)
d2392 12
a2403 5
    if ((LYSameFilename(host, "localhost") ||
	 LYSameFilename(host, LYHostName) ||
	 LYSameFilename(host, HTHostName()))) {
	FREE(host);
	return YES;
d2411 1
a2411 1
 * Free an HTList that contains strings.
d2413 1
a2413 1
void LYFreeStringList(HTList *list)
d2415 5
a2419 3
    if (list != NULL) {
	char *argument;
	HTList *cur = list;
d2421 2
a2422 4
	while (NULL != (argument = (char *) HTList_nextObject(cur))) {
	    FREE(argument);
	}
	HTList_delete(list);
d2424 1
a2424 8
}

/*
 * Utility for freeing the list of local host aliases.  - FM
 */
void LYLocalhostAliases_free(void)
{
    LYFreeStringList(localhost_aliases);
d2426 1
d2430 1
a2430 1
 * Utility for listing hosts to be treated as local aliases.  - FM
d2432 2
a2433 1
void LYAddLocalhostAlias(char *alias)
d2435 1
a2435 1
    char *LocalAlias = NULL;
d2437 1
a2437 1
    if (!non_empty(alias))
d2447 3
a2449 1
    StrAllocCopy(LocalAlias, alias);
d2456 2
a2457 2
 * Utility for checking URLs with a host field.  Return YES only if we've
 * listed the host as a local alias.  - FM
d2459 2
a2460 1
BOOLEAN LYisLocalAlias(const char *filename)
d2479 7
a2485 2
    while (NULL != (alias = (char *) HTList_nextObject(cur))) {
	if (LYSameFilename(host, alias)) {
d2496 12
a2507 11
 *  This function checks for a URL with an unknown scheme,
 *  but for which proxying has been set up, and if so,
 *  returns PROXY_URL_TYPE. - FM
 *
 *  If a colon is present but the string segment which
 *  precedes it is not being proxied, and we can be sure
 *  that what follows the colon is not a port field,
 *  it returns UNKNOWN_URL_TYPE.  Otherwise, it returns
 *  0 (not a URL). - FM
 */
UrlTypes LYCheckForProxyURL(char *filename)
d2514 1
a2514 1
     * Don't crash on an empty argument.
d2516 2
a2517 2
    if (isEmpty(cp))
	return (NOT_A_URL_TYPE);
d2526 1
a2526 3
    if ((cp1 = strchr((cp + 1), ':')) != NULL) {
	if ((cp2 = strchr((cp + 1), '/')) != NULL && cp2 < cp1)
	    return (NOT_A_URL_TYPE);
a2527 1
	cp2 = NULL;
d2531 1
a2531 1
	if (LYGetEnv(cp2) != NULL) {
d2533 1
a2533 1
	    return (PROXY_URL_TYPE);
d2536 3
a2538 3
#if defined (USE_DOS_DRIVES)
	if (LYIsDosDrive(cp))
	    return (NOT_A_URL_TYPE);
d2542 3
a2544 3
	    return (NOT_A_URL_TYPE);
	} else if (isdigit(UCH(*cp1))) {
	    while (*cp1 && isdigit(UCH(*cp1)))
d2547 1
a2547 1
		return (UNKNOWN_URL_TYPE);
d2549 1
a2549 1
	    return (UNKNOWN_URL_TYPE);
d2553 1
a2553 1
    return (NOT_A_URL_TYPE);
d2560 4
a2563 3
static BOOLEAN compare_type(char *tst,
			    const char *cmp,
			    size_t len)
a2567 1

a2575 6
#define DoubleHtmlSep(s) (LYIsHtmlSep((s)[0]) && LYIsHtmlSep((s)[1]))
#define compare_two(tst,cmp,len,limit) \
	((len + 2) <= limit \
	&& DoubleHtmlSep(tst + len) \
	&& compare_type(tst, cmp, len))

d2577 13
a2589 12
 *  Must recognize a URL and return the type.
 *  If recognized, based on a case-insensitive
 *  analysis of the scheme field, ensures that
 *  the scheme field has the expected case.
 *
 *  Returns 0 (not a URL) for a NULL argument,
 *  one which lacks a colon.
 *
 *  Chains to LYCheckForProxyURL() if a colon
 *  is present but the type is not recognized.
 */
UrlTypes is_url(char *filename)
a2592 3
    UrlTypes result = NOT_A_URL_TYPE;
    int len;
    int limit;
d2595 1
a2595 1
     * Don't crash on an empty argument.
d2597 2
a2598 2
    if (isEmpty(cp))
	return (result);
d2601 1
a2601 1
     * Can't be a URL if it lacks a colon.
d2604 1
a2604 1
	return (result);
d2607 1
a2607 1
     * Kill beginning spaces.
d2612 5
a2616 4
     * Can't be a URL if it starts with a slash.  So return immediately for
     * this common case, also to avoid false positives if there was a colon
     * later in the string.  Also can't be a URL if it starts with a colon.  -
     * KW
d2618 23
a2640 2
    if (*cp == ':' || LYIsHtmlSep(*cp)) {
	result = NOT_A_URL_TYPE;
d2642 11
a2652 16
    } else {
	limit = strlen(cp);
	switch (*cp) {
	case 'L':
	case 'l':
	    /*
	     * Lynx internal pages ("LYNXfoo:" or "lynxfoo:") start with 'l' or
	     * 'L', other URLs aren't.
	     */
	    if (compare_type(cp, STR_LYNXEXEC, LEN_LYNXEXEC)) {
		/*
		 * Special External Lynx type to handle execution of commands
		 * or scripts which require a pause to read the screen upon
		 * completion.
		 */
		result = LYNXEXEC_URL_TYPE;
d2654 2
a2655 7
	    } else if (compare_type(cp, STR_LYNXPROG, LEN_LYNXPROG)) {
		/*
		 * Special External Lynx type to handle execution of commands,
		 * scripts or programs with do not require a pause to read
		 * screen upon completion.
		 */
		result = LYNXPROG_URL_TYPE;
d2657 8
a2664 5
	    } else if (compare_type(cp, STR_LYNXCGI, LEN_LYNXCGI)) {
		/*
		 * Special External Lynx type to handle cgi scripts.
		 */
		result = LYNXCGI_URL_TYPE;
d2666 2
a2667 5
	    } else if (compare_type(cp, STR_LYNXPRINT, LEN_LYNXPRINT)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXPRINT_URL_TYPE;
d2669 7
a2675 5
	    } else if (compare_type(cp, STR_LYNXOPTIONS, LEN_LYNXOPTIONS)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXOPTIONS_URL_TYPE;
d2677 7
a2683 5
	    } else if (compare_type(cp, STR_LYNXCFG, LEN_LYNXCFG)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXCFG_URL_TYPE;
d2685 5
a2689 5
	    } else if (compare_type(cp, STR_LYNXMESSAGES, LEN_LYNXMESSAGES)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXMESSAGES_URL_TYPE;
d2691 5
a2695 5
	    } else if (compare_type(cp, STR_LYNXCFLAGS, LEN_LYNXCFLAGS)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXCOMPILE_OPTS_URL_TYPE;
d2697 5
a2701 5
	    } else if (compare_type(cp, STR_LYNXDOWNLOAD, LEN_LYNXDOWNLOAD)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXDOWNLOAD_URL_TYPE;
d2703 5
a2707 5
	    } else if (compare_type(cp, STR_LYNXDIRED, LEN_LYNXDIRED)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXDIRED_URL_TYPE;
d2709 5
a2713 5
	    } else if (compare_type(cp, STR_LYNXHIST, LEN_LYNXHIST)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXHIST_URL_TYPE;
d2715 5
a2719 5
	    } else if (compare_type(cp, STR_LYNXKEYMAP, LEN_LYNXKEYMAP)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXKEYMAP_URL_TYPE;
d2721 5
a2725 7
	    } else if (compare_type(cp, STR_LYNXIMGMAP, LEN_LYNXIMGMAP)) {
		/*
		 * Special Internal Lynx type.
		 */
		/* force lower/uppercase of next part */
		(void) is_url(&cp[LEN_LYNXIMGMAP]);
		result = LYNXIMGMAP_URL_TYPE;
d2727 5
a2731 15
	    } else if (compare_type(cp, STR_LYNXCOOKIE, LEN_LYNXCOOKIE)) {
		/*
		 * Special Internal Lynx type.
		 */
		result = LYNXCOOKIE_URL_TYPE;
	    }
	    break;
#ifndef DISABLE_NEWS
	    /*
	     * NEWSfoo:  schemes -
	     */
	case 'N':
	case 'n':
	    if (compare_type(cp, STR_NEWS_URL, LEN_NEWS_URL)) {
		result = NEWS_URL_TYPE;
d2733 5
a2737 2
	    } else if (compare_type(cp, STR_NNTP_URL, LEN_NNTP_URL)) {
		result = NNTP_URL_TYPE;
d2739 5
a2743 5
	    } else if (compare_type(cp, "newspost:", 9)) {
		/*
		 * Special Lynx type to handle news posts.
		 */
		result = NEWSPOST_URL_TYPE;
d2745 6
a2750 7
	    } else if (compare_type(cp, "newsreply:", 10)) {
		/*
		 * Special Lynx type to handle news replies (followups).
		 */
		result = NEWSREPLY_URL_TYPE;
	    }
	    break;
d2752 5
a2756 7
	    /*
	     * SNEWSfoo:  schemes -
	     */
	case 'S':
	case 's':
	    if (compare_type(cp, STR_SNEWS_URL, LEN_SNEWS_URL)) {
		result = SNEWS_URL_TYPE;
d2758 8
a2765 5
	    } else if (compare_type(cp, "snewspost:", 10)) {
		/*
		 * Special Lynx type to handle snews posts.
		 */
		result = NEWSPOST_URL_TYPE;
d2767 2
a2768 14
	    } else if (compare_type(cp, "snewsreply:", 11)) {
		/*
		 * Special Lynx type to handle snews replies (followups).
		 */
		result = NEWSREPLY_URL_TYPE;
	    }
	    break;
#endif
	case 'M':
	case 'm':
	    if (compare_type(cp, STR_MAILTO_URL, LEN_MAILTO_URL)) {
		result = MAILTO_URL_TYPE;
	    }
	    break;
d2770 2
a2771 20
	case 'F':
	case 'f':
	    if (compare_type(cp, STR_FILE_URL, len = LEN_FILE_URL)) {
		if (LYisLocalFile(cp)) {
		    result = FILE_URL_TYPE;
		} else if (DoubleHtmlSep(cp + len)) {
		    result = FTP_URL_TYPE;
		}
	    }
#ifndef DISABLE_FTP
	    else if (compare_two(cp, STR_FTP_URL, LEN_FTP_URL, limit)) {
		result = FTP_URL_TYPE;
	    }
#endif
#ifndef DISABLE_FINGER
	    else if (compare_two(cp, STR_FINGER_URL, LEN_FINGER_URL, limit)) {
		result = FINGER_URL_TYPE;
	    }
#endif
	    break;
d2773 2
a2774 8
	case 'B':
	case 'b':
#ifndef DISABLE_BIBP
	    if (compare_type(cp, STR_BIBP_URL, LEN_BIBP_URL)) {
		result = BIBP_URL_TYPE;
	    }
#endif
	    break;
d2776 12
a2787 6
	case 'D':
	case 'd':
	    if (compare_type(cp, "data:", 5)) {
		result = DATA_URL_TYPE;
	    }
	    break;
d2789 2
a2790 15
	default:
	    if (limit >= 3
		&& ((cp1 = strchr(cp + 3, ':')) == NULL
		    || !DoubleHtmlSep(cp1 + 1))) {
		/*
		 * If it doesn't contain "://", and it's not one of the the
		 * above, it can't be a URL with a scheme we know, so check if
		 * it's an unknown scheme for which proxying has been set up.
		 * - FM
		 */
		if (cp1 != NULL
		    && (cp1 - cp) > 1	/* exclude DOS-style device:/path */
		    && LYisAbsPath(cp1 + 1)) {
		    result = NCFTP_URL_TYPE;
		}
d2792 2
a2793 6
	    } else {
		switch (*cp) {
		case 'H':
		case 'h':
		    if (compare_type(cp, STR_HTTP_URL, LEN_HTTP_URL)) {
			result = HTTP_URL_TYPE;
d2795 2
a2796 4
		    } else if (compare_type(cp, STR_HTTPS_URL, LEN_HTTPS_URL)) {
			result = HTTPS_URL_TYPE;
		    }
		    break;
d2798 2
a2799 28
#ifndef DISABLE_GOPHER
		case 'G':
		case 'g':
		    if (compare_type(cp, STR_GOPHER_URL, LEN_GOPHER_URL)) {
			if (strlen(cp) >= 11
			    && (cp1 = strchr(cp + 11, '/')) != NULL) {

			    if (TOUPPER(*(cp1 + 1)) == 'H' || *(cp1 + 1) == 'w')
				/* if this is a gopher html type */
				result = HTML_GOPHER_URL_TYPE;
			    else if (*(cp1 + 1) == 'T' || *(cp1 + 1) == '8')
				result = TELNET_GOPHER_URL_TYPE;
			    else if (*(cp1 + 1) == '7')
				result = INDEX_GOPHER_URL_TYPE;
			    else
				result = GOPHER_URL_TYPE;
			} else {
			    result = GOPHER_URL_TYPE;
			}
		    }
		    break;
#endif
		case 'W':
		case 'w':
		    if (compare_type(cp, STR_WAIS_URL, LEN_WAIS_URL)) {
			result = WAIS_URL_TYPE;
		    }
		    break;
d2801 2
a2802 4
		case 'T':
		case 't':
		    if (compare_type(cp, STR_TELNET_URL, LEN_TELNET_URL)) {
			result = TELNET_URL_TYPE;
d2804 2
a2805 4
		    } else if (compare_type(cp, STR_TN3270_URL, LEN_TN3270_URL)) {
			result = TN3270_URL_TYPE;
		    }
		    break;
d2807 2
a2808 6
		case 'R':
		case 'r':
		    if (compare_type(cp, STR_RLOGIN_URL, LEN_RLOGIN_URL)) {
			result = RLOGIN_URL_TYPE;
		    }
		    break;
d2810 2
a2811 6
		case 'C':
		case 'c':
		    if (compare_type(cp, STR_CSO_URL, LEN_CSO_URL)) {
			result = CSO_URL_TYPE;
		    }
		    break;
d2813 2
a2814 6
		case 'A':
		case 'a':
		    if (compare_type(cp, "afs:", 4)) {
			result = AFS_URL_TYPE;
		    }
		    break;
d2816 1
a2816 9
		case 'P':
		case 'p':
		    if (compare_type(cp, "prospero:", 9)) {
			result = PROSPERO_URL_TYPE;
		    }
		    break;
		}
	    }
	}
d2818 2
a2819 1
	 * Check if it is an unknown scheme for which proxying has been set up.
d2821 1
a2821 65
	if (result == NOT_A_URL_TYPE)
	    result = LYCheckForProxyURL(filename);
    }
    return result;
}

/*
 * Sometimes it is just expected that curses is on when an alert or other
 * statusline message needs to be shown and we are not just dumping
 * immediately.  Calling this will 'fix' it, but may not always be appropriate. 
 * - kw
 */
void LYFixCursesOn(const char *reason)
{
    if (dump_output_immediately || LYCursesON)
	return;
    if (reason) {
	CTRACE((tfp, "Forcing curses on to %s\n", reason));
    }
    start_curses();
}

/*
 * Most protocol modules called through HTLoad* expect that curses is on unless
 * dump_output_immediately is set, so that statusline messages can be shown. 
 * Some protocols expect the opposite, namely telnet and friends.  This
 * function should be called after the 'physical' URL for accessing addr has
 * been established.  It does the right thing to the degree that curses is
 * turned on for known problem cases.  In any normal circumstances this should
 * never apply, but proxying or rule substitution is not prevented for
 * telnet-like URLs, and this 'fix' avoids some crashes that can otherwise
 * occur.  - kw
 */
BOOLEAN LYFixCursesOnForAccess(const char *addr,
			       const char *physical)
{
    /*
     * If curses is off when maybe it shouldn't...
     */
    if (!dump_output_immediately && !LYCursesON && physical) {
	char *cp1;

	/*
	 * If requested resource wants to be accessed with curses off, and
	 * getfile() would indeed have turned curses off for it...
	 */
	if (strstr(addr, "://") != NULL &&
	    (isTELNET_URL(addr) ||
	     isRLOGIN_URL(addr) ||
	     isTN3270_URL(addr) ||
	     (!isGOPHER_URL(addr) &&
	      (cp1 = strchr(addr + 11, '/')) != NULL &&
	      (*(cp1 + 1) == 'T' || *(cp1 + 1) == '8')))) {
	    /*
	     * If actual access that will be done is ok with curses off, then
	     * do nothing special, else force curses on.  - kw
	     */
	    if (!isTELNET_URL(physical) &&
		!isRLOGIN_URL(physical) &&
		!isTN3270_URL(physical)) {
		start_curses();
		HTAlert(gettext("Unexpected access protocol for this URL scheme."));
		return TRUE;
	    }
	}
a2822 1
    return FALSE;
d2826 1
a2826 1
 * Determine whether we allow HEAD and related flags for a URL.  - kw
d2828 3
a2830 1
BOOLEAN LYCanDoHEAD(const char *address)
d2834 1
a2834 2

    if (!non_empty(address))
d2841 2
a2842 2
    if (!isurl) {
	FREE(temp0);
a2843 1
    }
a2844 1
	FREE(temp0);
a2850 5
    /*
     * The idea of the following is to allow HEAD for news URLs that identify
     * single articles, not those that identify ranges of articles or groups or
     * a list of groups.  - kw
     */
a2853 1

a2854 1
	    FREE(temp0);
d2858 1
a2858 2
	if (cp && isdigit(UCH(cp[1])) && strchr(cp, '-') == NULL) {
	    FREE(temp0);
a2863 87
#define ALLOW_PROXY_HEAD
/* If defined, also allow head requests for URLs proxied through the "http" or
 * "lynxcgi" protocols, which understand HEAD.  Only the proxy environment
 * variables are checked, not the HTRules system.  - kw
 */
#ifdef ALLOW_PROXY_HEAD
    if (isurl != FILE_URL_TYPE) {
	char *acc_method = HTParse(temp0, "", PARSE_ACCESS);

	if (non_empty(acc_method)) {
	    char *proxy;

	    StrAllocCat(acc_method, "_proxy");
	    proxy = LYGetEnv(acc_method);
	    if (proxy && (isHTTP_URL(proxy) ||
			  isLYNXCGI(proxy)) &&
		!override_proxy(temp0)) {
		FREE(temp0);
		FREE(acc_method);
		return TRUE;
	    }
	}
	FREE(acc_method);
    }
#endif /* ALLOW_PROXY_HEAD */

    FREE(temp0);
    return FALSE;
}

/*
 * Close an input file.
 */
BOOLEAN LYCloseInput(FILE *fp)
{
    if (fp != 0) {
	int err = ferror(fp);

	fclose(fp);
	if (!err) {
	    return TRUE;
	}
    }
    return FALSE;
}

/*
 * Close an output file, reporting any problems with writing to it.
 */
BOOLEAN LYCloseOutput(FILE *fp)
{
    if (fp != 0) {
	int err = ferror(fp);

	fclose(fp);
	if (!err) {
	    return TRUE;
	}
    }
    HTAlert(CANNOT_WRITE_TO_FILE);
    return FALSE;
}

/*
 * Test if we'll be able to write a file.  If not, warn the user.
 */
BOOLEAN LYCanWriteFile(const char *filename)
{
    if (LYCloseOutput(fopen(filename, "w"))) {
	remove(filename);
	return TRUE;
    } else {
	_statusline(NEW_FILENAME_PROMPT);
	return FALSE;
    }
}

/*
 * Test if we'll be able to read a file.
 */
BOOLEAN LYCanReadFile(const char *filename)
{
    FILE *fp;

    if ((fp = fopen(filename, "r")) != 0) {
	return LYCloseInput(fp);
    }
d2868 1
a2868 1
 * Remove backslashes from any string.
d2870 2
a2871 1
void remove_backslashes(char *buf)
d2875 1
a2875 1
    for (cp = buf; *cp != '\0'; cp++) {
d2877 1
a2877 1
	if (*cp != '\\') {	/* don't print slashes */
d2881 1
a2881 1
		   *(cp + 1) == '\\') {		/* are two in a row         */
d2890 4
d2895 3
a2897 2
 * Checks to see if the current process is attached via a terminal in the local
 * domain.
d2899 1
a2899 1
BOOLEAN inlocaldomain(void)
d2901 3
a2903 1
#ifdef HAVE_UTMP
d2909 1
a2909 1
    if ((cp = ttyname(0)))
d2912 12
a2923 12
    if (mytty && (fp = fopen(UTMP_FILE, "r")) != NULL) {
	mytty++;
	do {
	    n = fread((char *) &me, sizeof(struct utmp), 1, fp);
	} while (n > 0 && !STREQ(me.ut_line, mytty));
	(void) LYCloseInput(fp);

	if (n > 0 &&
	    strlen(me.ut_host) > strlen(LYLocalDomain) &&
	    STREQ(LYLocalDomain,
		  me.ut_host + strlen(me.ut_host) - strlen(LYLocalDomain)))
	    return (TRUE);
d2926 2
a2927 2
	if ((n > 0) && (strlen(me.ut_host) == 0))
	    return (TRUE);
d2931 1
a2931 3
	CTRACE((tfp,
		"Could not get ttyname (returned %s) or open UTMP file %s\n",
		NONNULL(cp), UTMP_FILE));
d2934 2
a2935 79
    return (FALSE);
#else
    CTRACE((tfp, "LYUtils: inlocaldomain() not support.\n"));
    return (TRUE);
#endif /* HAVE_UTMP */
}

#ifdef HAVE_SIGACTION
/*
 * An extended alternative for calling signal(), sets some flags for signal
 * handler as we want them if that functionality is available.  (We don't
 * return anything from this function since the return value would currently be
 * ignored anyway.) - kw
 */
void LYExtSignal(int sig,
		 LYSigHandlerFunc_t * handler)
{
#ifdef SIGWINCH
    /* add more cases to if(condition) if required... */
    if (sig == SIGWINCH && LYNonRestartingSIGWINCH) {
	struct sigaction act;

	act.sa_handler = handler;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
#ifdef SA_RESTART
	if (sig != SIGWINCH)
	    act.sa_flags |= SA_RESTART;
#endif /* SA_RESTART */
	sigaction(sig, &act, NULL);
    } else
#endif /* defined(SIGWINCH) */
	signal(sig, handler);
}
#endif /* HAVE_SIGACTION */

#if defined(SIGTSTP) && !defined(USE_SLANG)
#ifdef HAVE_SIGACTION
/*
 * For switching a signal's handling between SIG_DFL and something (possibly)
 * different that may have been set up by lynx code or e.g. by curses library. 
 * Uses sigaction to preserve / restore as much state as possible.
 *
 * Second arg is where to save or restore from.
 *
 * Third arg to_dfl specifies what to do:
 *	1	Save current state in where, set handling to SIG_DFL
 *	0	Restore current state to previously saved one in where
 *
 * Currently only used for SIGTSTP without SLANG, to prevent (n)curses signal
 * handler from running while lynx is waiting in system() for an interactive
 * command like an editor.  - kw
 */
static BOOLEAN LYToggleSigDfl(int sig,
			      struct sigaction *where,
			      int to_dfl)
{
    int rv = -1;
    struct sigaction oact;

    if (to_dfl == 1) {
	rv = sigaction(sig, NULL, &oact);
	if (rv == 0) {
	    if (oact.sa_handler != SIG_DFL) {
		oact.sa_handler = SIG_DFL;
		rv = sigaction(sig, &oact, where);
	    } else if (where) {
		memcpy(where, &oact, sizeof(oact));
		rv = 0;
	    }
	}
    } else {
	rv = sigaction(sig, where, NULL);
    }
    if (rv != 0) {
	CTRACE((tfp, "Error in LYToggleSigDfl: %s\n", LYStrerror(errno)));
	return FALSE;
    } else
	return TRUE;
a2936 2
#endif /* HAVE_SIGACTION */
#endif /* SIGTSTP && !USE_SLANG */
d2939 2
a2940 2
 * This bit of code catches window size change signals
 */
d2957 3
a2959 3
#   endif			/* HAVE_TERMIO_H */
#  endif			/* HAVE_TERMIOS_H */
# endif				/* TERMIO_AND_TERMIOS */
d2962 2
a2963 1
void size_change(int sig GCC_UNUSED)
d2973 1
a2973 1
    LYcols = SLtt_Screen_Cols;
d2976 1
a2976 7
#ifdef SLANG_NO_LIMIT		/* define this if slang has been fixed */
    SLtt_Screen_Cols = LYcolLimit * 6;
#else
    /* Needs to be limited: fixed buffer bugs in slang can cause crash,
       see slang's SLtt_smart_puts - kw */
    SLtt_Screen_Cols = HTMIN(LYcolLimit * 6, 255);
#endif
d2980 1
a2980 1
	 * Called from start_curses().
d2984 1
a2984 1
#ifdef HAVE_SIZECHANGE
a2986 1

a3015 10
#ifdef __EMX__
    {
	int scrsize[2];

	_scrsize(scrsize);
	LYcols = scrsize[0];
	LYlines = scrsize[1];
    }
#endif

d3017 1
a3017 1
	LYlines = DFT_ROWS;
d3019 1
a3019 1
	LYcols = DFT_COLS;
d3023 1
a3023 1
     * Check if the screen size has actually changed.  - AJL
d3027 2
a3028 7
	CTRACE((tfp, "Window size changed from (%d,%d) to (%d,%d)\n",
		old_lines, old_cols, LYlines, LYcols));
#if defined(CAN_SWITCH_DISPLAY_CHARSET) && defined(CAN_AUTODETECT_DISPLAY_CHARSET)
	/* May need to reload the font due to different char-box size */
	if (current_char_set != auto_display_charset)
	    Switch_Display_Charset(current_char_set, SWITCH_DISPLAY_CHARSET_RESIZE);
#endif
d3031 1
a3031 1
    LYExtSignal(SIGWINCH, size_change);
d3038 1
a3038 1
 * Utility for freeing the list of previous suggested filenames.  - FM
d3040 1
a3040 1
void HTSugFilenames_free(void)
d3042 10
a3051 1
    LYFreeStringList(sug_filenames);
d3053 1
d3057 2
a3058 2
 * Utility for listing suggested filenames, making any repeated filenames the
 * most current in the list.  - FM
d3060 2
a3061 1
void HTAddSugFilename(char *fname)
d3063 1
a3063 1
    char *tmp = NULL;
d3067 1
a3067 1
    if (!non_empty(fname))
d3070 3
a3072 1
    StrAllocCopy(tmp, fname);
d3079 1
a3079 1
	HTList_addObject(sug_filenames, tmp);
d3084 2
a3085 2
    while (NULL != (old = (char *) HTList_nextObject(cur))) {
	if (!strcmp(old, tmp)) {
d3091 1
a3091 1
    HTList_addObject(sug_filenames, tmp);
d3097 2
a3098 2
 * CHANGE_SUG_FILENAME -- Foteos Macrides 29-Dec-1993 Upgraded for use with
 * Lynx2.2 - FM 17-Jan-1994
d3100 2
a3101 1
void change_sug_filename(char *fname)
d3103 1
a3103 3
    const char *cp2;
    char *temp = 0, *cp, *cp1, *end;

d3110 1
a3110 1
     * Establish the current end of fname.
d3115 1
a3115 1
     * Unescape fname.
d3120 1
a3120 1
     * Rename any temporary files.
d3122 6
a3127 10
    cp2 = wwwName(lynx_temp_space);
#ifdef FNAMES_8_3
    if (LYIsHtmlSep(*cp2)) {
	HTSprintf0(&temp, "file://localhost%s%04x", cp2, GETPID());
    } else {
	HTSprintf0(&temp, "file://localhost/%s%04x", cp2, GETPID());
    }
#else
    if (LYIsHtmlSep(*cp2)) {
	HTSprintf0(&temp, "file://localhost%s%d", cp2, (int) getpid());
d3129 1
a3129 1
	HTSprintf0(&temp, "file://localhost/%s%d", cp2, (int) getpid());
a3130 1
#endif
d3135 3
a3137 2
	StrAllocCopy(temp, NonNull(cp));
	sprintf(fname, "temp%.*s", LY_MAXPATH - 10, temp);
d3142 6
a3147 6
	/*
	 * Hmm...  we have a directory name.  It is annoying to see a
	 * scheme+host+path name as a suggested one, let's remove the
	 * last_slash and go ahead like we have a file name.  - LP
	 */
	fname[strlen(fname) - 1] = '\0';
d3150 1
a3150 1
     * Remove everything up the the last_slash if there is one.
d3152 1
a3152 13
    if ((cp = strrchr(fname, '/')) != NULL && strlen(cp) > 1) {
	cp1 = fname;
	/*
	 * Go past the slash.
	 */
	cp++;
	for (; *cp != '\0'; cp++, cp1++) {
	    *cp1 = *cp;
	}
	*cp1 = '\0';
    }
#ifdef _WINDOWS			/* 1998/05/05 (Tue) 10:08:05 */
    if ((cp = strrchr(fname, '=')) != NULL && strlen(cp) > 1) {
d3155 1
a3155 1
	 * Go past the '='.
a3162 1
#endif
d3165 1
a3165 1
     * Trim off date-size suffix, if present.
d3175 1
a3175 1
     * Trim off VMS device and/or directory specs, if present.
d3177 2
a3178 2
    if ((cp = strchr(fname, '[')) != NULL &&
	(cp1 = strrchr(cp, ']')) != NULL && strlen(cp1) > 1) {
d3180 1
a3180 1
	for (cp = fname; *cp1 != '\0'; cp1++) {
d3185 1
d3188 1
a3188 1
     * Replace illegal or problem characters.
d3193 1
a3193 1
	 * Replace with underscores.
d3198 3
a3200 3
	    /*
	     * Replace with dashes.
	     */
d3202 1
a3202 1
		   *cp == ',' || *cp == ':' || *cp == '"' ||
d3208 1
a3208 1
		   *cp < ' ' || (UCH(*cp)) > 126) {
d3214 1
a3214 1
     * Collapse any serial underscores.
d3228 1
a3228 1
     * Collapse any serial dashes.
d3236 1
a3236 1
	} else {
d3243 2
a3244 1
     * Trim any trailing or leading underscores or dashes.
d3264 7
a3270 4
     * Replace all but the last period with _'s, or second to last if last is
     * followed by a terminal Z or z, or GZ or gz,
     * e.g., convert foo.tar.Z to foo.tar_Z
     * or, convert foo.tar.gz to foo.tar-gz
d3275 1
a3275 1
	    if ((fname[j - 1] == '.') &&
d3279 2
a3280 2
	    } else if (((TOUPPER(fname[j - 1]) == 'G') &&
			fname[j - 2] == '.') &&
d3292 2
a3293 2
	 * But if the root is > 39 characters, move the period appropriately to
	 * the left.
d3298 1
a3298 1
		*cp = '.';
d3301 1
a3301 1
		*cp = '.';
d3306 1
a3306 1
		    fname[j] = fname[j - 1];
d3323 1
a3323 1
	 * Make sure the extension is < 40 characters.
d3330 1
a3330 1
	 * Trim trailing dashes or underscores.
d3338 3
a3340 2
	 * No period, so put one on the end, or after the 39th character,
	 * trimming trailing dashes or underscores.
d3356 1
a3356 1
     * Replace problem characters.
d3360 5
a3364 5
	case '\'':
	case '"':
	case '/':
	case ' ':
	    *cp = '-';
d3370 1
a3370 1
     * Make sure the rest of the original string in nulled.
d3383 4
a3386 3
static int fmt_tempname(char *result,
			const char *prefix,
			const char *suffix)
a3387 9
    int code;

#ifdef USE_RAND_TEMPNAME
#define SIZE_TEMPNAME ((MAX_TEMPNAME / BITS_PER_CHAR) + 1)
    static BOOL first = TRUE;
    static int names_used = 0;
    static unsigned char used_tempname[SIZE_TEMPNAME];
    unsigned offset, mask;
#endif
d3390 1
a3395 35
    /*
     * Prefer a random value rather than a counter.
     */
#ifdef USE_RAND_TEMPNAME
    if (first) {
	lynx_srand((unsigned) ((long) time((time_t *) 0) + (long) result));
	first = FALSE;
    }

    /* We don't really need all of the bits from rand().  The high-order bits
     * are the more-random portion in any case, but limiting the width of the
     * generated name is done partly to avoid problems on systems that may not
     * support long filenames.
     */
    counter = MAX_TEMPNAME;
    while (names_used < MAX_TEMPNAME) {
	counter = (unsigned) (((float) MAX_TEMPNAME * lynx_rand()) /
			      LYNX_RAND_MAX + 1);
	counter %= SIZE_TEMPNAME;	/* just in case... */
	/*
	 * Avoid reusing a temporary name, since there are places in the code
	 * which can refer to a temporary filename even after it has been
	 * closed and removed from the filesystem.
	 */
	offset = counter / BITS_PER_CHAR;
	mask = 1 << (counter % BITS_PER_CHAR);
	if ((used_tempname[offset] & mask) == 0) {
	    names_used++;
	    used_tempname[offset] |= mask;
	    break;
	}
    }
    if (names_used >= MAX_TEMPNAME)
	HTAlert(gettext("Too many tempfiles"));
#else
a3396 2
#endif

d3404 1
a3404 5
#ifdef _WINDOWS
    sprintf(leaf, "%04x%04x", counter, (unsigned) GETPID());
#else
    sprintf(leaf, "%u%u", counter, (unsigned) getpid());
#endif
d3408 1
a3408 2
	const char *tail = strchr(suffix, '.');

d3411 1
a3411 2
	if (8 - (tail - suffix) >= 0)
	    leaf[8 - (tail - suffix)] = 0;
d3415 1
a3415 1
    sprintf(leaf, "L%u-%uTMP%s", (unsigned) getpid(), counter, suffix);
d3424 1
a3424 1
	sprintf(result, "%.*s", LY_MAXPATH - 1, leaf);
d3427 1
a3427 1
    CTRACE((tfp, "-> '%s'\n", result));
d3432 1
a3432 1
 * Convert 4, 6, 2, 8 to left, right, down, up, etc.
d3434 2
a3435 1
int number2arrows(int number)
d3437 28
a3464 28
    switch (number) {
    case '1':
	number = END_KEY;
	break;
    case '2':
	number = DNARROW;
	break;
    case '3':
	number = PGDOWN;
	break;
    case '4':
	number = LTARROW;
	break;
    case '5':
	number = DO_NOTHING;
	break;
    case '6':
	number = RTARROW;
	break;
    case '7':
	number = HOME;
	break;
    case '8':
	number = UPARROW;
	break;
    case '9':
	number = PGUP;
	break;
d3467 1
a3467 1
    return (number);
d3471 2
a3472 2
 * parse_restrictions takes a string of comma-separated restrictions and sets
 * the corresponding flags to restrict the facilities available.
d3474 24
a3497 39
/* The first two are special:  we want to record whether "default" or "all"
 * restrictions were applied, in addition to the detailed effects of those
 * options.  - kw
 */
/* skip the special flags when processing "all" and "default": */
#define N_SPECIAL_RESTRICT_OPTIONS 2
/* *INDENT-OFF* */
static const struct {
    const char *name;
    BOOLEAN *flag;
    BOOLEAN can;
} restrictions[] = {
    { "default",	&had_restrictions_default, TRUE },
    { "all",		&had_restrictions_all,	TRUE },
    { "inside_telnet",	&no_inside_telnet,	CAN_ANONYMOUS_INSIDE_DOMAIN_TELNET },
    { "outside_telnet",	&no_outside_telnet,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_TELNET },
    { "telnet_port",	&no_telnet_port,	CAN_ANONYMOUS_GOTO_TELNET_PORT },
    { "inside_ftp",	&no_inside_ftp,		CAN_ANONYMOUS_INSIDE_DOMAIN_FTP },
    { "outside_ftp",	&no_outside_ftp,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_FTP },
    { "inside_rlogin",	&no_inside_rlogin,	CAN_ANONYMOUS_INSIDE_DOMAIN_RLOGIN },
    { "outside_rlogin",	&no_outside_rlogin,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_RLOGIN },
    { "suspend",	&no_suspend,		FALSE },
    { "editor",		&no_editor,		FALSE },
    { "shell",		&no_shell,		FALSE },
    { "bookmark",	&no_bookmark,		FALSE },
    { "multibook",	&no_multibook,		FALSE },
    { "bookmark_exec",	&no_bookmark_exec,	FALSE },
    { "option_save",	&no_option_save,	FALSE },
    { "print",		&no_print,		CAN_ANONYMOUS_PRINT },
    { "download",	&no_download,		FALSE },
    { "disk_save",	&no_disk_save,		FALSE },
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
    { "exec",		&no_exec,		LOCAL_EXECUTION_LINKS_ALWAYS_OFF_FOR_ANONYMOUS },
#endif
    { "lynxcgi",	&no_lynxcgi,		FALSE },
    { "exec_frozen",	&exec_frozen,		FALSE },
    { "goto",		&no_goto,		CAN_ANONYMOUS_GOTO },
    { "jump",		&no_jump,		CAN_ANONYMOUS_JUMP },
    { "file_url",	&no_file_url,		FALSE },
d3499 7
a3505 10
    { "news_post",	&no_newspost,		FALSE },
    { "inside_news",	&no_inside_news,	CAN_ANONYMOUS_INSIDE_DOMAIN_READ_NEWS },
    { "outside_news",	&no_outside_news,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_READ_NEWS },
#endif
    { "mail",		&no_mail,		CAN_ANONYMOUS_MAIL },
    { "dotfiles",	&no_dotfiles,		FALSE },
    { "useragent",	&no_useragent,		FALSE },
#ifdef SUPPORT_CHDIR
    { "chdir",		&no_chdir,		FALSE },
#endif
d3507 1
a3507 1
    { "dired_support",	&no_dired_support,	FALSE },
d3509 1
a3509 1
    { "change_exec_perms", &no_change_exec_perms, FALSE },
d3513 1
a3513 83
    { "externals",	&no_externals,		FALSE },
#endif
    { "lynxcfg_info",	&no_lynxcfg_info,	CAN_ANONYMOUS_VIEW_LYNXCFG_INFO },
#ifndef NO_CONFIG_INFO
    { "lynxcfg_xinfo",	&no_lynxcfg_xinfo,	CAN_ANONYMOUS_VIEW_LYNXCFG_EXTENDED_INFO },
#ifdef HAVE_CONFIG_H
    { "compileopts_info", &no_compileopts_info,	CAN_ANONYMOUS_VIEW_COMPILEOPTS_INFO },
#endif
#endif
    /* put "goto" restrictions on the end, since they are a refinement */
#ifndef DISABLE_BIBP
    { "goto_bibp",	&no_goto_bibp,		CAN_ANONYMOUS_GOTO_BIBP	},
#endif
#ifdef HAVE_CONFIG_H
#ifndef NO_CONFIG_INFO
    { "goto_configinfo", &no_goto_configinfo,	CAN_ANONYMOUS_GOTO_CONFIGINFO },
#endif
#endif
    { "goto_cso",	&no_goto_cso,		CAN_ANONYMOUS_GOTO_CSO },
    { "goto_file",	&no_goto_file,		CAN_ANONYMOUS_GOTO_FILE },
#ifndef DISABLE_FINGER
    { "goto_finger",	&no_goto_finger,	CAN_ANONYMOUS_GOTO_FINGER },
#endif
    { "goto_ftp",	&no_goto_ftp,		CAN_ANONYMOUS_GOTO_FTP },
#ifndef DISABLE_GOPHER
    { "goto_gopher",	&no_goto_gopher,	CAN_ANONYMOUS_GOTO_GOPHER },
#endif
    { "goto_http",	&no_goto_http,		CAN_ANONYMOUS_GOTO_HTTP },
    { "goto_https",	&no_goto_https,		CAN_ANONYMOUS_GOTO_HTTPS },
    { "goto_lynxcgi",	&no_goto_lynxcgi,	CAN_ANONYMOUS_GOTO_LYNXCGI },
    { "goto_lynxexec",	&no_goto_lynxexec,	CAN_ANONYMOUS_GOTO_LYNXEXEC },
    { "goto_lynxprog",	&no_goto_lynxprog,	CAN_ANONYMOUS_GOTO_LYNXPROG },
    { "goto_mailto",	&no_goto_mailto,	CAN_ANONYMOUS_GOTO_MAILTO },
#ifndef DISABLE_NEWS
    { "goto_news",	&no_goto_news,		CAN_ANONYMOUS_GOTO_NEWS },
    { "goto_nntp",	&no_goto_nntp,		CAN_ANONYMOUS_GOTO_NNTP },
#endif
    { "goto_rlogin",	&no_goto_rlogin,	CAN_ANONYMOUS_GOTO_RLOGIN },
#ifndef DISABLE_NEWS
    { "goto_snews",	&no_goto_snews,		CAN_ANONYMOUS_GOTO_SNEWS },
#endif
    { "goto_telnet",	&no_goto_telnet,	CAN_ANONYMOUS_GOTO_TELNET },
    { "goto_tn3270",	&no_goto_tn3270,	CAN_ANONYMOUS_GOTO_TN3270 },
    { "goto_wais",	&no_goto_wais,		CAN_ANONYMOUS_GOTO_WAIS },
};
/* *INDENT-ON* */

/* This will make no difference between '-' and '_'.  It does only in/equality
 * compare.  It assumes that p2 can't contain dashes, but p1 can.  This
 * function is also used (if macro OPTNAME_ALLOW_DASHES doesn't have value of
 * zero) for compare of commandline options -VH
 */
BOOL strn_dash_equ(const char *p1,
		   const char *p2,
		   int len)
{
    while (len--) {
	if (!*p2)
	    return 0;		/* canonical name is shorter */
	switch (*p1) {
	case 0:
	    return 0;
	case '-':
	case '_':
	    if (*p2 != '_')
		return 0;
	    else
		break;
	default:
	    if (*p1 != *p2)
		return 0;
	}
	++p1;
	++p2;
    }
    return 1;
}

/* Uncomment following lines to allow only exact string matching */
/* #define RESTRICT_NM_ALLOW_DASHES 0 */

#ifndef RESTRICT_NM_ALLOW_DASHES
# define RESTRICT_NM_ALLOW_DASHES 1
d3515 1
d3517 3
a3519 5
#if RESTRICT_NM_ALLOW_DASHES
#	define RESTRICT_NM_EQU(a,b,len) strn_dash_equ(a,b,len)
#else
#	define RESTRICT_NM_EQU(a,b,len) STRNEQ(a,b,len)
#endif
d3521 40
a3560 85
/*
 * Returns the inx'th name from the restrictions table, or null if inx is
 * out of range.
 */
const char *index_to_restriction(int inx)
{
    if (inx >= 0 && inx < (int) TABLESIZE(restrictions))
	return restrictions[inx].name;
    return NULL;
}

/*
 * Returns the value TRUE/FALSE of a given restriction, or -1 if it is not
 * one that we recognize.
 */
int find_restriction(const char *name,
		     int len)
{
    unsigned i;

    if (len < 0)
	len = strlen(name);
    for (i = 0; i < TABLESIZE(restrictions); i++) {
	if (RESTRICT_NM_EQU(name, restrictions[i].name, len)) {
	    return (*restrictions[i].flag);
	}
    }
    return -1;
}

void parse_restrictions(const char *s)
{
    const char *p;
    const char *word;
    unsigned i;
    BOOLEAN found;

    p = s;
    while (*p) {
	p = LYSkipCBlanks(p);
	if (*p == '\0')
	    break;
	word = p;
	while (*p != ',' && *p != '\0')
	    p++;

	found = FALSE;
	if (RESTRICT_NM_EQU(word, "all", p - word)) {
	    found = TRUE;
	    for (i = N_SPECIAL_RESTRICT_OPTIONS;
		 i < TABLESIZE(restrictions);
		 i++)
		*(restrictions[i].flag) = TRUE;
	} else if (RESTRICT_NM_EQU(word, "default", p - word)) {
	    found = TRUE;
	    for (i = N_SPECIAL_RESTRICT_OPTIONS;
		 i < TABLESIZE(restrictions);
		 i++)
		*(restrictions[i].flag) = !restrictions[i].can;
	} else {
	    for (i = 0; i < TABLESIZE(restrictions); i++) {
		if (RESTRICT_NM_EQU(word, restrictions[i].name, p - word)) {
		    *(restrictions[i].flag) = TRUE;
		    found = TRUE;
		    break;
		}
	    }
	}
	if (!found) {
	    printf("%s: %.*s\n", gettext("unknown restriction"), p - word, word);
	    exit_immediately(EXIT_FAILURE);
	}
	if (*p)
	    p++;
    }

    /*
     * If shell is restricted, set restrictions on related topics.
     */
    if (no_shell) {
	no_goto_lynxexec = TRUE;
	no_goto_lynxprog = TRUE;
	no_goto_lynxcgi = TRUE;
#ifdef EXEC_LINKS
	local_exec_on_local_files = TRUE;
d3562 1
a3562 2
    }
}
d3564 2
a3565 1
void print_restrictions_to_fd(FILE *fp)
d3567 83
a3649 22
    unsigned i, count = 0;

    for (i = 0; i < TABLESIZE(restrictions); i++) {
	if (*(restrictions[i].flag) == TRUE) {
	    count++;
	}
    }
    if (!count) {
	fprintf(fp, gettext("No restrictions set.\n"));
	return;
    }
    fprintf(fp, gettext("Restrictions set:\n"));
    for (i = 0; i < TABLESIZE(restrictions); i++) {
	if (*(restrictions[i].flag) == TRUE) {
	    /* if "goto" is restricted, don't bother tell about its
	     * refinements
	     */
	    if (strncmp(restrictions[i].name, "goto_", 5)
		|| !no_goto)
		fprintf(fp, "   %s\n", restrictions[i].name);
	}
    }
d3657 6
a3662 5
typedef struct _VMSMailItemList {
    short buffer_length;
    short item_code;
    void *buffer_address;
    long *return_length_address;
d3665 1
a3665 1
void LYCheckMail(void)
a3674 1
    /* *INDENT-OFF* */
a3683 2
    /* *INDENT-ON* */

d3694 1
a3694 1
	status = sys$getjpiw(0, 0, 0, jpi_list, 0, 0, 0);
d3710 1
a3710 1
    status = mail$user_begin(&ucontext, null_list, null_list);
d3717 1
a3717 1
    status = mail$user_get_info(&ucontext, uilist, uolist);
d3737 1
a3737 1
    mail$user_end((long *) &ucontext, null_list, null_list);
d3741 1
a3741 1
void LYCheckMail(void)
d3752 1
a3752 1
	mf = LYGetEnv("MAIL");
d3765 2
a3766 2
    if ((stat(mf, &st) < 0)
	|| !S_ISREG(st.st_mode)) {
d3773 1
a3773 1
	    || ((lastsize != 0) && (st.st_size > lastsize)))
d3785 13
a3797 14
 *  This function ensures that an href will be
 *  converted to a fully resolved, absolute URL,
 *  with guessing of the host or expansions of
 *  lead tildes via LYConvertToURL() if needed,
 *  and tweaking/simplifying via HTParse().  It
 *  is used for LynxHome, startfile, homepage,
 *  and 'g'oto entries, after they have been
 *  passed to LYFillLocalFileURL(). - FM
 *  Such URLs have no `base' reference to which they
 *  could be resolved.  LYLegitimizeHREF could not be used.
 */
void LYEnsureAbsoluteURL(char **href,
			 const char *name,
			 int fixit)
d3801 1
a3801 1
    if (isEmpty(*href))
d3805 1
a3805 6
     * Check whether to fill in localhost.  - FM
     */
    LYFillLocalFileURL(href, "file://localhost");

    /*
     * If it is not a URL then make it one.
d3807 1
a3807 1
    if (!strcasecomp(*href, STR_NEWS_URL)) {
d3809 2
a3810 1
    } else if (!strcasecomp(*href, STR_SNEWS_URL)) {
a3812 1

d3814 2
a3815 2
	CTRACE((tfp, "%s%s'%s' is not a URL\n",
		NonNull(name), (name ? " " : ""), *href));
d3818 1
a3818 3

    temp = HTParse(*href, "", PARSE_ALL);
    if (non_empty(temp))
d3824 8
a3831 6
 * Rewrite and reallocate a previously allocated string as a file URL if the
 * string resolves to a file or directory on the local system, otherwise as an
 * http URL.  - FM
 */
void LYConvertToURL(char **AllocatedString,
		    int fixit)
a3835 1

d3838 1
d3844 1
a3844 1
#if defined(USE_DOS_DRIVES)
d3846 6
a3851 8
	char *cp_url = *AllocatedString;

	for (; *cp_url != '\0'; cp_url++)
	    if (*cp_url == '\\')
		*cp_url = '/';
	cp_url--;
	if (LYIsDosDrive(*AllocatedString) && *cp_url == ':')
	    LYAddPathSep(AllocatedString);
d3853 1
a3853 1
#endif /* USE_DOS_DRIVES */
d3855 2
a3856 2
    *AllocatedString = NULL;	/* so StrAllocCopy doesn't free it */
    StrAllocCopy(*AllocatedString, "file://localhost");
d3860 3
a3862 4

#if defined(USE_DOS_DRIVES)
	StrAllocCat(*AllocatedString, "/");
#endif /* USE_DOS_DRIVES */
d3865 1
a3865 1
	 * Not a SHELL pathspec.  Get the full VMS spec and convert it.
a3869 1

d3874 3
a3876 2
	     * On VMS, we'll accept '~' on the command line as Home_Dir(), and
	     * assume the rest of the path, if any, has SHELL syntax.
d3878 1
a3878 1
	    StrAllocCat(*AllocatedString, HTVMS_wwwName(Home_Dir()));
d3881 3
a3883 3
		 * Append rest of path, if present, skipping "user" if "~user"
		 * was entered, simplifying, and eliminating any residual
		 * relative elements.  - FM
d3892 3
a3894 2
	    fragment = trimPoundSelector(old_string);
	    LYstrncpy(url_file, old_string, sizeof(url_file) - 1);
d3897 2
a3898 2
	if (1 & lib$find_file(&url_file_dsc, &file_name_dsc, &context,
			      0, 0, 0, 0)) {
d3900 1
a3900 1
	     * We found the file.  Convert to a URL pathspec.
d3911 1
a3911 1
		restorePoundSelector(fragment);
d3915 1
a3915 1
	} else if ((NULL != getcwd(dir_name, sizeof(dir_name) - 1, 0)) &&
d3921 4
a3924 2
	    restorePoundSelector(fragment);
	    if (NULL != getcwd(dir_name, sizeof(dir_name) - 1, 0)) {
d3936 3
a3938 2
		 * Nope.  Assume it's an http URL with the "http://" defaulted,
		 * if we can't rule out a bad VMS path.
d3943 2
a3944 2
		     !isdigit(UCH(cp[1]))) ||
		    !LYExpandHostForURL(&old_string,
d3948 3
a3950 3
		     * Probably a bad VMS path (but can't be sure).  Use
		     * original pathspec for the error message that will
		     * result.
d3952 4
a3955 4
		    sprintf(url_file, "/%.*s", sizeof(url_file) - 2, old_string);
		    CTRACE((tfp,
			    "Can't find '%s'  Will assume it's a bad path.\n",
			    old_string));
d3959 2
a3960 2
		     * Assume a URL is wanted, so guess the scheme with
		     * "http://" as the default.  - FM
d3962 1
a3962 1
		    if (!LYAddSchemeForURL(&old_string, "http://")) {
d3972 3
a3974 2
	     * Nothing found.  Assume it's an http URL with the "http://"
	     * defaulted, if we can't rule out a bad VMS path.
d3976 4
a3979 3
	    restorePoundSelector(fragment);
	    fragment = NULL;

d3982 2
a3983 2
		 !isdigit(UCH(cp[1]))) ||
		!LYExpandHostForURL(&old_string,
d3987 8
a3994 6
		 * Probably a bad VMS path (but can't be sure).  Use original
		 * pathspec for the error message that will result.
		 */
		sprintf(url_file, "/%.*s", sizeof(url_file) - 2, old_string);
		CTRACE((tfp, "Can't find '%s'  Will assume it's a bad path.\n",
			old_string));
d3998 2
a3999 2
		 * Assume a URL is wanted, so guess the scheme with "http://"
		 * as the default.  - FM
d4001 1
a4001 1
		if (!LYAddSchemeForURL(&old_string, "http://")) {
d4011 4
a4014 23
      have_VMS_URL:
	CTRACE((tfp, "Trying: '%s'\n", *AllocatedString));
#else /* not VMS: */
#if defined(USE_DOS_DRIVES)
#ifdef _WINDOWS
	if (*old_string == '.') {
	    char fullpath[MAX_PATH + 1];
	    char *filepart = NULL;
	    DWORD chk;

	    chk = GetFullPathNameA(old_string, MAX_PATH + 1,
				   fullpath, &filepart);
	    if (chk != 0) {
		StrAllocCopy(temp, wwwName(fullpath));
		StrAllocCat(*AllocatedString, temp);
		FREE(temp);
		CTRACE((tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString));
	    } else {
		StrAllocCat(*AllocatedString, old_string);
	    }
	}
#else
d4017 1
a4017 1
	     * They want .
a4019 1

d4023 4
a4026 6
	    CTRACE((tfp, "Converted '%s' to '%s'\n",
		    old_string, *AllocatedString));
	}
#endif
	else
#endif /* USE_DOS_DRIVES */
d4029 1
a4029 1
	     * On Unix, convert '~' to Home_Dir().
d4031 1
a4031 1
	    StrAllocCat(*AllocatedString, wwwName(Home_Dir()));
d4034 3
a4036 3
		 * Append rest of path, if present, skipping "user" if "~user"
		 * was entered, simplifying, and eliminating any residual
		 * relative elements.  - FM
d4043 2
a4044 2
	    CTRACE((tfp, "Converted '%s' to '%s'\n",
		    old_string, *AllocatedString));
d4047 1
a4047 1
	     * Create a full path to the current default directory.
d4052 1
a4052 2

	    Current_Dir(curdir);
d4054 2
a4055 2
	     * Concatenate and simplify, trimming any residual relative
	     * elements.  - FM
d4057 1
a4057 1
#if defined (USE_DOS_DRIVES)
a4064 3
		/* 1998/01/13 (Tue) 12:24:33 */
		if (old_string[1] == '|')
		    old_string[1] = ':';
a4065 3

		if (strlen(temp) == 2 && LYIsDosDrive(temp))
		    LYAddPathSep(&temp);
d4071 1
a4071 1
#endif /* USE_DOS_DRIVES */
d4073 1
a4073 1
	    CTRACE((tfp, "Converted '%s' to '%s'\n", old_string, temp));
d4075 1
a4075 1
		LYCanReadFile(temp)) {
d4077 1
a4077 1
		 * It is a subdirectory or file on the local system.
d4079 1
a4079 1
#if defined (USE_DOS_DRIVES)
d4084 3
a4086 2
		if (strchr(temp, '#') == NULL && strchr(temp, '%') == NULL)
		    StrAllocCopy(cp, temp);
d4088 1
a4088 2
		    cp = HTEscape(temp, URL_PATH);
#else
a4089 1
#endif /* USE_DOS_DRIVES */
d4092 2
a4093 2
		CTRACE((tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString));
a4096 1

d4100 3
a4102 2
		fragment = trimPoundSelector(cp);
		HTUnEscape(cp);	/* unescape given path without fragment */
d4104 1
a4104 1
		StrAllocCopy(cp2, temp2);	/* keep a copy in cp2     */
a4105 3
#ifdef WIN_EX			/* 1998/07/31 (Fri) 09:09:03 */
		HTUnEscape(temp2);	/* for LFN */
#endif
d4109 1
a4109 1
		     LYCanReadFile(temp2))) {
d4111 3
a4113 3
		     * It is a subdirectory or file on the local system with
		     * escaped characters and/or a fragment to be appended to
		     * the URL.  - FM
d4119 2
a4120 2
			 * LYTrimRelFromAbsPath did nothing, use old_string as
			 * given.  - kw
d4128 1
a4128 1
			    restorePoundSelector(fragment);
d4133 2
a4134 2
		    CTRACE((tfp, "Converted '%s' to '%s'\n",
			    old_string, *AllocatedString));
d4140 5
a4144 4
		     * If PWD has some unusual characters, construct a filename
		     * in temp where those are escaped.  This is mostly to
		     * prevent this function from returning with some weird URL
		     * if the LYExpandHostForURL tests further down fail.  - kw
d4149 2
a4150 2
			 * LYTrimRelFromAbsPath did nothing, use old_string as
			 * given.  - kw
d4158 1
a4158 1
			    restorePoundSelector(fragment);
d4168 7
a4174 26
		 * It's not an accessible subdirectory or file on the local
		 * system, so assume it's a URL request and guess the scheme
		 * with "http://" as the default.
		 */
		CTRACE((tfp, "Can't stat() or fopen() '%s'\n",
			temp2 ? temp2 : temp));
#ifdef WIN_EX			/* 1998/01/13 (Tue) 09:07:37 */
		{
		    const char *p, *q;
		    char buff[LY_MAXPATH + 128];

		    p = Home_Dir();
		    q = temp2 ? temp2 : temp;

		    if (strlen(q) == 3 && LYIsDosDrive(q)) {
			sprintf(buff,
				"'%s' not exist, Goto LynxHome '%s'.", q, p);
			_statusline(buff);
			LYSleepAlert();
			FREE(temp);
			StrAllocCat(*AllocatedString, p);
			goto Retry;
		    }
		}
#endif
		if (LYExpandHostForURL(&old_string,
d4177 1
a4177 1
		    if (!LYAddSchemeForURL(&old_string, "http://")) {
d4184 1
a4184 1
		    /* RW 1998Mar16  Restore AllocatedString to 'old_string' */
a4185 3
		} else {
		    /* Return file URL for the file that does not exist */
		    StrAllocCat(*AllocatedString, temp);
d4187 1
a4187 4
#ifdef WIN_EX
	      Retry:
#endif
		CTRACE((tfp, "Trying: '%s'\n", *AllocatedString));
d4191 4
d4199 1
a4199 1
	 * Path begins with a slash.  Simplify and use it.
d4203 3
a4205 2
	     * Request for root.  Respect it on Unix, but on VMS we treat that
	     * as a listing of the login directory.  - FM
d4208 1
a4208 1
	    StrAllocCat(*AllocatedString, HTVMS_wwwName(Home_Dir()));
d4212 1
a4212 1
		   LYCanReadFile(old_string)) {
d4214 2
a4215 1
	     * It is an absolute directory or file on the local system.  - KW
d4219 1
a4219 1
	    CTRACE((tfp, "Converted '%s' to '%s'\n", old_string, temp));
d4224 6
a4229 2
	    CTRACE((tfp, "Converted '%s' to '%s'\n",
		    old_string, *AllocatedString));
d4233 2
a4234 2
	     * Has a Home_Dir() reference.  Handle it as if there weren't a
	     * lead slash.  - FM
d4236 5
a4240 1
	    StrAllocCat(*AllocatedString, wwwName(Home_Dir()));
d4243 3
a4245 3
		 * Append rest of path, if present, skipping "user" if "~user"
		 * was entered, simplifying, and eliminating any residual
		 * relative elements.  - FM
d4254 2
a4255 2
	     * Normal absolute path.  Simplify, trim any residual relative
	     * elements, and append it.  - FM
d4262 2
a4263 2
	CTRACE((tfp, "Converted '%s' to '%s'\n",
		old_string, *AllocatedString));
d4270 22
a4291 17
#if defined(_WINDOWS)		/* 1998/06/23 (Tue) 16:45:20 */

int win32_check_interrupt(void)
{
    int c;

    if (kbhit()) {
	c = LYgetch();
	/** Keyboard 'Z' or 'z', or Control-G or Control-C **/
	if (LYCharIsINTERRUPT(c) || c == 0x1b) {
	    return TRUE;
	}
    }
    return FALSE;
}

void sleep(unsigned sec)
d4293 2
a4294 39
    unsigned int i, j;
    int c;

    for (j = 0; j < sec; j++) {
	for (i = 0; i < 10; i++) {
	    Sleep(100);
	    if (kbhit()) {
		c = LYgetch();
		return;
	    }
	}
    }
}
#endif

/*
 * This function rewrites and reallocates a previously allocated string so that
 * the first element is a confirmed Internet host, and returns TRUE, otherwise
 * it does not modify the string and returns FALSE.  It first tries the element
 * as is, then, if the element does not end with a dot, it adds prefixes from
 * the (comma separated) prefix list argument, and, if the element does not
 * begin with a dot, suffixes from the (comma separated) suffix list arguments
 * (e.g., www.host.com, then www.host,edu, then www.host.net, then
 * www.host.org).  The remaining path, if one is present, will be appended to
 * the expanded host.  It also takes into account whether a colon is in the
 * element or suffix, and includes that and what follows as a port field for
 * the expanded host field (e.g, wfbr:8002/dir/lynx should yield
 * www.wfbr.edu:8002/dir/lynx).  The calling function should prepend the scheme
 * field (e.g., http://), or pass the string to LYAddSchemeForURL(), if this
 * function returns TRUE.  - FM
 */
BOOLEAN LYExpandHostForURL(char **AllocatedString,
			   char *prefix_list,
			   char *suffix_list)
{
    char DomainPrefix[80];
    const char *StartP, *EndP;
    char DomainSuffix[80];
    const char *StartS, *EndS;
d4300 1
a4300 6
    BOOLEAN Startup = (BOOL) (helpfilepath == NULL);

#ifdef INET6
    struct addrinfo hints, *res;
    int error;
#endif /* INET6 */
d4303 3
a4305 2
     * If it's a NULL or zero-length string, or if it begins with a slash or
     * hash, don't continue pointlessly.  - FM
d4313 2
a4314 1
     * If it's a partial or relative path, don't continue pointlessly.  - FM
d4322 4
a4325 3
     * Make a clean copy of the string, and trim off the path if one is
     * present, but save the information so we can restore the path after
     * filling in the Host[:port] field.  - FM
d4330 2
a4331 1
	 * Have a path.  Any fragment should already be included in Path.  - FM
d4334 1
a4334 1
    } else {
d4336 3
a4338 2
	 * No path, so check for a fragment and trim that, to be restored after
	 * filling in the Host[:port] field.  - FM
d4340 1
a4340 1
	Fragment = trimPoundSelector(Str);
d4344 4
a4347 3
     * If the potential host string has a colon, assume it begins a port field,
     * and trim it off, but save the information so we can restore the port
     * field after filling in the host field.  - FM
d4350 1
a4350 1
	isdigit(UCH(StrColon[1]))) {
d4359 2
a4360 1
     * Do a DNS test on the potential host field as presently trimmed.  - FM
d4370 1
a4370 1
	fprintf(stdout, "%s '%s'%s\r\n", WWW_FIND_MESSAGE, host, FIRST_SEGMENT);
d4372 2
a4373 7
#ifdef INET6
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    error = getaddrinfo(host, "80", &hints, &res);

    if (!error && res)
d4375 2
a4376 2
    if (LYGetHostByName(host) != NULL)
#endif /* INET6 */
d4379 1
a4379 1
	 * Clear any residual interrupt.  - FM
d4382 2
a4383 3
	    CTRACE((tfp,
		    "LYExpandHostForURL: Ignoring interrupt because '%s' resolved.\n",
		    host));
d4387 1
a4387 1
	 * Return success.  - FM
d4394 1
d4396 3
d4400 1
a4400 1
	 * Give the user chance to interrupt lookup cycles.  - KW & FM
d4402 2
a4403 3
	CTRACE((tfp,
		"LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
		host));
d4406 1
a4406 1
	 * Return failure.  - FM
d4415 10
a4424 9
     * Set the first prefix, making it a zero-length string if the list is NULL
     * or if the potential host field ends with a dot.  - FM
     */
    StartP = ((prefix_list && Str[strlen(Str) - 1] != '.')
	      ? prefix_list
	      : "");
    /*
     * If we have a prefix, but the allocated string is one of the common host
     * prefixes, make our prefix a zero-length string.  - FM
d4441 1
a4441 1
	StartP++;		/* Skip whitespace and separators */
d4445 1
a4445 1
	EndP++;			/* Find separator */
d4450 1
a4450 1
     * Test each prefix with each suffix.  - FM
d4454 3
a4456 2
	 * Set the first suffix, making it a zero-length string if the list is
	 * NULL or if the potential host field begins with a dot.  - FM
d4458 2
a4459 3
	StartS = ((suffix_list && *Str != '.')
		  ? suffix_list
		  : "");
d4461 1
a4461 1
	    StartS++;		/* Skip whitespace and separators */
d4465 1
a4465 1
	    EndS++;		/* Find separator */
d4470 1
a4470 1
	 * Create domain names and do DNS tests.  - FM
d4475 2
a4476 2
	    if (Host[strlen(Host) - 1] == '.') {
		Host[strlen(Host) - 1] = '\0';
d4480 1
a4480 1
		isdigit(UCH(HostColon[1]))) {
d4493 5
a4497 1
	    GotHost = (BOOL) (LYGetHostByName(host) != NULL);
d4503 1
a4503 1
		 * Give the user chance to interrupt lookup cycles.  - KW
d4505 8
a4512 4
		if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED)) {
		    CTRACE((tfp,
			    "LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
			    host));
d4517 1
a4517 1
		    return FALSE;	/* We didn't find a valid name. */
d4521 1
a4521 1
		 * Advance to the next suffix, or end of suffix list.  - FM
d4533 1
a4533 1
	} while ((GotHost == FALSE) && (*DomainSuffix != '\0'));
d4536 12
a4547 12
	    /*
	     * Advance to the next prefix, or end of prefix list.  - FM
	     */
	    StartP = ((*EndP == '\0') ? EndP : (EndP + 1));
	    while ((*StartP) && (WHITE(*StartP) || *StartP == ',')) {
		StartP++;	/* Skip whitespace and separators */
	    }
	    EndP = StartP;
	    while (*EndP && !WHITE(*EndP) && *EndP != ',') {
		EndP++;		/* Find separator */
	    }
	    LYstrncpy(DomainPrefix, StartP, (EndP - StartP));
d4552 4
a4555 3
     * If a test passed, restore the port field if we had one and there is no
     * colon in the expanded host, and the path if we had one, and reallocate
     * the original string with the expanded Host[:port] field included.  - FM
d4567 1
a4567 1
	    restorePoundSelector(Fragment);
d4574 1
a4574 1
     * Clear any residual interrupt.  - FM
d4577 3
a4579 4
	CTRACE((tfp,
		"LYExpandHostForURL: Ignoring interrupt because '%s' %s.\n",
		host,
		(GotHost ? "resolved" : "timed out")));
d4583 1
a4583 1
     * Clean up and return the last test result.  - FM
d4593 12
a4604 10
 * This function rewrites and reallocates a previously allocated string that
 * begins with an Internet host name so that the string begins with its guess
 * of the scheme based on the first field of the host name, or the default
 * scheme if no guess was made, and returns TRUE, otherwise it does not modify
 * the string and returns FALSE.  It also returns FALSE without modifying the
 * string if the default_scheme argument was NULL or zero-length and no guess
 * was made.  - FM
 */
BOOLEAN LYAddSchemeForURL(char **AllocatedString,
			  const char *default_scheme)
d4610 2
a4611 2
     * If we were passed a NULL or zero-length string, don't continue
     * pointlessly.  - FM
d4622 2
a4623 2
	 * This could be either http or https, so check the default and
	 * otherwise use "http".  - FM
d4657 2
a4658 2
	 * This could be either news, snews, or nntp, so check the default, and
	 * otherwise use news.  - FM
d4676 2
a4677 2
     * If we've make a guess, use it.  Otherwise, if we were passed a default
     * scheme prefix, use that.  - FM
d4685 1
a4685 1
    } else if (non_empty(default_scheme)) {
d4698 7
a4704 6
 * This function expects an absolute Unix or VMS SHELL path spec as an
 * allocated string, simplifies it, and trims out any residual relative
 * elements.  It also checks whether the path had a terminal slash, and if it
 * didn't, makes sure that the simplified path doesn't either.  If it's a
 * directory, our convention is to exclude "Up to parent" links when a terminal
 * slash is present.  - FM
d4706 2
a4707 1
void LYTrimRelFromAbsPath(char *path)
d4714 1
a4714 1
     * Make sure we have a pointer to an absolute path.  - FM
d4720 1
a4720 1
     * Check whether the path has a terminal slash.  - FM
d4722 1
a4722 1
    TerminalSlash = (BOOL) (LYIsPathSep(path[(strlen(path) - 1)]));
d4725 1
a4725 1
     * Simplify the path and then do any necessary trimming.  - FM
d4732 1
a4732 1
	     * Eliminate trailing dot.  - FM
d4737 1
a4737 1
	     * Skip over the "/." of a "/./".  - FM
d4742 1
a4742 1
	     * Eliminate trailing dotdot.  - FM
d4747 1
a4747 1
	     * Skip over the "/.." of a "/../".  - FM
d4752 1
a4752 1
	     * Done trimming.  - FM
d4759 3
a4761 2
     * Load any shifts into path, and eliminate any terminal slash created by
     * HTSimplify() or our walk, but not present originally.  - FM
d4774 1
a4774 1
 * Example Client-Side Include interface.
d4776 10
a4785 8
 * This is called from SGML.c and simply returns markup for reporting the URL
 * of the document being loaded if a comment begins with "<!--#lynxCSI".  The
 * markup will be included as if it were in the document.  Move this function
 * to a separate module for doing this kind of thing seriously, someday.  - FM
 */
void LYDoCSI(char *url,
	     const char *comment,
	     char **csi)
d4787 1
a4787 1
    const char *cp = comment;
d4807 2
a4808 2
 * Define_VMSLogical -- Fote Macrides 04-Apr-1995
 * Define VMS logicals in the process table.
d4810 3
a4812 2
void Define_VMSLogical(char *LogicalName,
		       char *LogicalValue)
d4837 1
a4837 1
static void LYHomeDir_free(void)
d4843 2
a4844 1
char *Current_Dir(char *pathname)
d4847 2
a4848 3

#ifdef HAVE_GETCWD
    result = getcwd(pathname, LY_MAXPATH);
d4850 1
a4850 1
    result = getwd(pathname);
d4857 1
a4857 5
/*
 * Verify that the given path refers to an existing directory, returning the
 * string if the directory exists.  If not, return null.
 */
static char *CheckDir(char *path)
d4859 2
a4860 1
    struct stat stat_info;
d4862 12
a4873 32
    if (!LYisAbsPath(path)
	|| (HTStat(path, &stat_info) < 0
	    || !S_ISDIR(stat_info.st_mode))) {
	path = NULL;
    }
    return path;
}

/*
 * Lookup various possibilities for $HOME, and check that the directory exists.
 */
static char *HomeEnv(void)
{
    char *result = CheckDir(LYGetEnv("HOME"));

#if defined (USE_DOS_DRIVES)
    if (result == 0) {
	char *head;
	char *leaf;
	static char *temp = NULL;

	/* Windows 2000 */
	if ((result = LYGetEnv("USERPROFILE")) != 0) {
	    HTSprintf0(&temp, "%s%sMy Documents", result, PATHSEP_STR);
	    result = CheckDir(temp);
	}
	/* NT4 */
	if (result == 0) {
	    if ((head = LYGetEnv("HOMEDRIVE")) != 0) {
		if ((leaf = LYGetEnv("HOMEPATH")) != 0) {
		    HTSprintf0(&temp, "%s%s%s", head, PATHSEP_STR, leaf);
		    result = CheckDir(temp);
d4875 2
d4878 1
a4878 27
	}
	/* General M$ */
	if (result == 0)
	    result = CheckDir(LYGetEnv("TEMP"));
	if (result == 0)
	    result = CheckDir(LYGetEnv("TMP"));
	if (result == 0) {
	    if ((head = LYGetEnv("SystemDrive")) != 0) {
		HTSprintf0(&temp, "%s%s", head, PATHSEP_STR);
		result = CheckDir(temp);
	    }
	}
	if (result == 0)
	    result = CheckDir("C:" PATHSEP_STR);
    }
#endif

    return result;
}

const char *Home_Dir(void)
{
    static const char *homedir = NULL;
    char *cp = NULL;

    if (homedir == NULL) {
	if ((cp = HomeEnv()) == NULL) {
d4880 8
a4887 3
	    if ((cp = LYGetEnv("SYS$LOGIN")) == NULL
		&& (cp = LYGetEnv("SYS$SCRATCH")) == NULL) {
		cp = "sys$scratch:";
a4888 1
	    StrAllocCopy(HomeDir, cp);
d4890 1
a4890 2
#ifdef UNIX
#ifdef HAVE_UTMP
d4892 1
a4892 1
	     * One could use getlogin() and getpwnam() here instead.
d4902 1
a4902 1
		 * Use /tmp; it should be writable.
d4906 3
d4911 1
d4915 1
a4915 1
	homedir = (const char *) HomeDir;
a4919 4
    if (homedir == NULL) {
	printf("%s\n", gettext("Cannot find HOME directory"));
	exit_immediately(EXIT_FAILURE);
    }
d4928 1
a4928 1
char *LYPathLeaf(char *pathname)
a4930 1

d4943 1
a4943 2

    for (leaf = 0, n = strlen(pathname) - 1; n >= 0; n--) {
d4955 12
a4966 10
 * This function checks the acceptability of file paths that are intended to be
 * off the home directory.  The file path should be passed in fbuffer, together
 * with the size of the buffer.  The function simplifies the file path, and if
 * it is acceptable, loads it into fbuffer and returns TRUE.  Otherwise, it
 * does not modify fbuffer and returns FALSE.  If a subdirectory is present and
 * the path does not begin with "./", that is prefixed to make the situation
 * clear.  - FM
 */
BOOLEAN LYPathOffHomeOK(char *fbuffer,
			size_t fbuffer_size)
d4972 1
a4972 1
     * Make sure we have an fbuffer and a string in it.  - FM
d4975 1
a4975 1
	return (FALSE);
d4981 2
a4982 2
     * Check for an inappropriate reference to the home directory, and correct
     * it if we can.  - FM
d4988 1
a4988 1
	     * Reject "sys$login".  - FM
d4991 1
a4991 1
	    return (FALSE);
d4997 4
a5000 3
		 * Reject "sys$login:".  Otherwise, we have converted
		 * "sys$login:file" to "file", or have left a strange path for
		 * VMS as it was originally.  - FM
d5003 1
a5003 1
		return (FALSE);
d5013 2
a5014 1
		     * Convert "~/subdir(s)/file" to "./subdir(s)/file".  - FM
d5019 1
a5019 1
		     * Convert "~/file" to "file".  - FM
d5025 1
a5025 1
		 * Reject "~/".  - FM
d5028 1
a5028 1
		return (FALSE);
d5032 1
a5032 1
	    cp = (cp1 - 1);
d5036 4
a5039 3
		     * Convert "~user/subdir(s)/file" to "./subdir(s)/file". 
		     * If user is someone else, we covered a spoof.  Otherwise,
		     * we simplified.  - FM
d5044 1
a5044 1
		     * Convert "~user/file" to "file".  - FM
d5050 1
a5050 1
		 * Reject "~user/".  - FM
d5053 1
a5053 1
		return (FALSE);
d5057 1
a5057 1
	     * Reject "~user".  - FM
d5060 1
a5060 1
	    return (FALSE);
d5063 1
d5066 1
a5066 1
     * Check for VMS path specs, and reject if still present.  - FM
d5070 1
a5070 1
	return (FALSE);
d5075 1
a5075 1
     * Check for a URL or absolute path, and reject if present.  - FM
d5079 1
a5079 1
	return (FALSE);
d5083 1
a5083 1
     * Simplify it.  - FM
d5088 1
a5088 1
     * Check if it has a pointless "./".  - FM
d5097 1
a5097 1
     * Check for spoofing.  - FM
d5100 4
a5103 4
	|| LYIsPathSep(*cp)
	|| LYIsPathSep(cp[(strlen(cp) - 1)])
	|| strstr(cp, "..") != NULL
	|| !strcmp(cp, ".")) {
d5105 1
a5105 1
	return (FALSE);
d5109 2
a5110 2
     * Load what we have at this point into fbuffer, trimming if too long, and
     * claim it's OK.  - FM
d5114 2
a5115 2
	 * We have a subdirectory and no lead "./", so prefix it to make the
	 * situation clear.  - FM
d5127 1
a5127 1
    return (TRUE);
d5131 13
a5143 11
 * This function appends fname to the home path and returns the full path and
 * filename.  The fname string can be just a filename (e.g.,
 * "lynx_bookmarks.html"), or include a subdirectory off the home directory, in
 * which case fname should begin with "./" (e.g., ./BM/lynx_bookmarks.html) Use
 * LYPathOffHomeOK() to check and/or fix up fname before calling this function. 
 * On VMS, the resultant full path and filename are converted to VMS syntax.  -
 * FM
 */
void LYAddPathToHome(char *fbuffer,
		     size_t fbuffer_size,
		     const char *fname)
d5146 1
a5146 1
    const char *file = fname;
d5150 1
a5150 1
     * Make sure we have a buffer.  - FM
d5161 1
a5161 1
     * Make sure we have a file name.  - FM
d5167 1
a5167 1
     * Set up home string and length.  - FM
d5170 4
a5173 1

d5175 1
a5175 1
#define NO_HOMEPATH "Error:"
d5177 1
a5177 1
#define NO_HOMEPATH "/error"
a5178 6
    if (!non_empty(home))
	/*
	 * Home_Dir() has a bug if this ever happens.  - FM
	 */
	StrAllocCopy(home, NO_HOMEPATH);

d5182 3
a5184 3
	 * Buffer is smaller than or only big enough for the home path.  Load
	 * what fits of the home path and return.  This will fail, but we need
	 * something in the buffer.  - FM
d5190 1
d5193 1
a5193 1
     * Check whether we have a subdirectory path or just a filename.  - FM
d5197 1
a5197 1
	 * We have a subdirectory path.  - FM
d5199 1
a5199 1
	if (home[strlen(home) - 1] == ']') {
d5201 3
a5203 2
	     * We got the home directory, so convert it to SHELL syntax and
	     * append subdirectory path, then convert that to VMS syntax.  - FM
d5205 5
a5209 3
	    char *temp = NULL;

	    HTSprintf0(&temp, "%s%s", HTVMS_wwwName(home), (file + 1));
d5215 1
a5215 1
	     * This will fail, but we need something in the buffer.  - FM
d5221 1
a5221 1
	 * We have a file in the home directory.  - FM
d5227 1
a5227 1
     * Check whether we have a subdirectory path or just a filename.  - FM
d5230 1
a5230 1
	    (strncmp(file, "./", 2) ? file : (file + 2)));
d5236 1
a5236 25
 * Given a filename, concatenate it to the save-space pathname, unless it is
 * an absolute pathname.  If there is no save-space defined, use the home
 * directory. Return a new string with the result.
 */
char *LYAddPathToSave(char *fname)
{
    char *result = NULL;

    if (LYisAbsPath(fname)) {
	StrAllocCopy(result, fname);
    } else {
	if (lynx_save_space != NULL) {
	    StrAllocCopy(result, lynx_save_space);
	} else {
	    char temp[LY_MAXPATH];

	    LYAddPathToHome(temp, sizeof(temp), fname);
	    StrAllocCopy(result, temp);
	}
    }
    return result;
}

/*
 * This function takes a string in the format
d5240 14
a5253 12
 * as an argument, and returns its conversion to clock format (seconds since
 * 00:00:00 Jan 1 1970), or 0 if the string doesn't match the expected pattern. 
 * It also returns 0 if the time is in the past and the "absolute" argument is
 * FALSE.  It is intended for handling 'expires' strings in Version 0 cookies
 * homologously to 'max-age' strings in Version 1 cookies, for which 0 is the
 * minimum, and greater values are handled as '[max-age seconds] + time(NULL)'. 
 * If "absolute" if TRUE, we return the clock format value itself, but if
 * anything goes wrong when parsing the expected patterns, we still return 0. 
 * - FM
 */
time_t LYmktime(char *string,
		BOOL absolute)
d5262 1
a5262 1
     * Make sure we have a string to parse.  - FM
d5264 2
a5265 2
    if (!non_empty(string))
	return (0);
d5267 1
a5267 1
    CTRACE((tfp, "LYmktime: Parsing '%s'\n", s));
d5270 2
a5271 2
     * Skip any lead alphabetic "Day, " field and seek a numeric day field.  -
     * FM
d5273 1
a5273 1
    while (*s != '\0' && !isdigit(UCH(*s)))
d5276 1
a5276 1
	return (0);
d5279 1
a5279 1
     * Get the numeric day and convert to an integer.  - FM
d5282 2
a5283 2
    while (*s != '\0' && isdigit(UCH(*s)))
	s++;
d5285 2
a5286 2
	return (0);
    LYstrncpy(temp, start, (int) (s - start));
d5289 1
a5289 1
	return (0);
d5292 1
a5292 1
     * Get the month string and convert to an integer.  - FM
d5294 1
a5294 1
    while (*s != '\0' && !isalnum(UCH(*s)))
d5297 1
a5297 1
	return (0);
d5299 1
a5299 1
    while (*s != '\0' && isalnum(UCH(*s)))
d5302 4
a5305 4
	(s - start) < (isdigit(UCH(*(s - 1))) ? 2 : 3) ||
	(s - start) > (isdigit(UCH(*(s - 1))) ? 2 : 9))
	return (0);
    LYstrncpy(temp, start, (isdigit(UCH(*(s - 1))) ? 2 : 3));
d5307 73
a5379 73
    case '0':
    case '1':
	month = atoi(temp);
	if (month < 1 || month > 12) {
	    return (0);
	}
	break;
    case 'A':
	if (!strcasecomp(temp, "Apr")) {
	    month = 4;
	} else if (!strcasecomp(temp, "Aug")) {
	    month = 8;
	} else {
	    return (0);
	}
	break;
    case 'D':
	if (!strcasecomp(temp, "Dec")) {
	    month = 12;
	} else {
	    return (0);
	}
	break;
    case 'F':
	if (!strcasecomp(temp, "Feb")) {
	    month = 2;
	} else {
	    return (0);
	}
	break;
    case 'J':
	if (!strcasecomp(temp, "Jan")) {
	    month = 1;
	} else if (!strcasecomp(temp, "Jun")) {
	    month = 6;
	} else if (!strcasecomp(temp, "Jul")) {
	    month = 7;
	} else {
	    return (0);
	}
	break;
    case 'M':
	if (!strcasecomp(temp, "Mar")) {
	    month = 3;
	} else if (!strcasecomp(temp, "May")) {
	    month = 5;
	} else {
	    return (0);
	}
	break;
    case 'N':
	if (!strcasecomp(temp, "Nov")) {
	    month = 11;
	} else {
	    return (0);
	}
	break;
    case 'O':
	if (!strcasecomp(temp, "Oct")) {
	    month = 10;
	} else {
	    return (0);
	}
	break;
    case 'S':
	if (!strcasecomp(temp, "Sep")) {
	    month = 9;
	} else {
	    return (0);
	}
	break;
    default:
	return (0);
d5383 1
a5383 1
     * Get the numeric year string and convert to an integer.  - FM
d5385 1
a5385 1
    while (*s != '\0' && !isdigit(UCH(*s)))
d5388 1
a5388 1
	return (0);
d5390 1
a5390 1
    while (*s != '\0' && isdigit(UCH(*s)))
d5402 1
a5402 1
	 * the broken sender software intends.  (This totally breaks
d5412 1
a5412 1
	return (0);
d5417 1
a5417 1
     * Get the numeric hour string and convert to an integer.  - FM
d5419 1
a5419 1
    while (*s != '\0' && !isdigit(UCH(*s)))
d5427 1
a5427 1
	while (*s != '\0' && isdigit(UCH(*s)))
d5430 2
a5431 2
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
d5435 1
a5435 1
	 * Get the numeric minutes string and convert to an integer.  - FM
d5437 1
a5437 1
	while (*s != '\0' && !isdigit(UCH(*s)))
d5440 1
a5440 1
	    return (0);
d5442 1
a5442 1
	while (*s != '\0' && isdigit(UCH(*s)))
d5445 2
a5446 2
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
d5450 1
a5450 1
	 * Get the numeric seconds string and convert to an integer.  - FM
d5452 1
a5452 1
	while (*s != '\0' && !isdigit(UCH(*s)))
d5455 1
a5455 1
	    return (0);
d5457 1
a5457 1
	while (*s != '\0' && isdigit(UCH(*s)))
d5460 2
a5461 2
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
d5466 3
a5468 2
     * Convert to clock format (seconds since 00:00:00 Jan 1 1970), but then
     * zero it if it's in the past and "absolute" is not TRUE.  - FM
d5472 2
a5473 2
	month += 12;
	year--;
d5475 8
a5482 8
    day += (year - 1968) * 1461 / 4;
    day += ((((month * 153) + 2) / 5) - 672);
    clock2 = (time_t) ((day * 60 * 60 * 24) +
		       (hour * 60 * 60) +
		       (minutes * 60) +
		       seconds);
    if (absolute == FALSE && (long) (time((time_t *) 0) - clock2) >= 0)
	clock2 = (time_t) 0;
d5484 3
a5486 3
	CTRACE((tfp, "LYmktime: clock=%ld, ctime=%s",
		(long) clock2,
		ctime(&clock2)));
d5488 1
a5488 1
    return (clock2);
d5491 1
a5491 1
#if !defined(HAVE_PUTENV) && !defined(_WINDOWS)
d5493 1
a5493 1
 * No putenv on the NeXT so we use this code instead!
d5527 1
a5527 1
 * Put STRING, which is of the form "NAME=VALUE", in the environment.
d5529 2
a5530 1
int putenv(const char *string)
d5532 3
a5534 3
    char *name_end = strchr(string, '=');
    register size_t size;
    register char **ep;
d5536 15
a5550 12
    if (name_end == NULL) {
	/* Remove the variable from the environment.  */
	size = strlen(string);
	for (ep = environ; *ep != NULL; ++ep)
	    if (!strncmp(*ep, string, size) && (*ep)[size] == '=') {
		while (ep[1] != NULL) {
		    ep[0] = ep[1];
		    ++ep;
		}
		*ep = NULL;
		return 0;
	    }
d5553 6
a5558 7
    size = 0;
    for (ep = environ; *ep != NULL; ++ep)
	if (!strncmp(*ep, string, name_end - string) &&
	    (*ep)[name_end - string] == '=')
	    break;
	else
	    ++size;
d5560 16
a5575 16
    if (*ep == NULL) {
	static char **last_environ = NULL;
	char **new_environ = (char **) malloc((size + 2) * sizeof(char *));

	if (new_environ == NULL)
	    return -1;
	(void) memcpy((char *) new_environ, (char *) environ, size * sizeof(char *));

	new_environ[size] = (char *) string;
	new_environ[size + 1] = NULL;
	if (last_environ != NULL)
	    FREE(last_environ);
	last_environ = new_environ;
	environ = new_environ;
    } else
	*ep = (char *) string;
d5577 1
a5577 1
    return 0;
d5582 1
a5582 1
int remove(char *name)
d5588 1
a5588 11
/*
 * Default, for single-user systems such as Cygwin and OS/2 EMX:
 */
#define IsOurFile(name) TRUE
#define OpenHiddenFile(name, mode) fopen(name, mode)

#if defined(MULTI_USER_UNIX)

#undef IsOurFile
#undef OpenHiddenFile

d5594 1
a5594 1
static BOOL IsOurFile(const char *name)
d5599 3
a5601 3
	&& S_ISREG(data.st_mode)
	&& data.st_nlink == 1
	&& data.st_uid == getuid()) {
d5603 1
a5603 6

	/*
	 * ( If this is not a single-user system, the other user is presumed by
	 * some people busy trying to use a symlink attack on our files ;-)
	 */
#if defined(HAVE_LSTAT)
d5633 1
a5633 1
			|| (data.st_mode & S_IWOTH) != 0) {
d5652 1
a5652 1
static FILE *OpenHiddenFile(const char *name, const char *mode)
a5655 1
    BOOLEAN binary = strchr(mode, 'b') != 0;
d5657 1
a5657 1
#if defined(O_CREAT) && defined(O_EXCL)		/* we have fcntl.h or kindred? */
d5663 1
a5663 2
	int fd = open(name, O_CREAT | O_EXCL | O_WRONLY, HIDE_CHMOD);

d5665 2
a5666 2
	    && errno == EEXIST
	    && IsOurFile(name)) {
d5669 1
a5669 1
	    fd = open(name, O_CREAT | O_EXCL | O_WRONLY, HIDE_CHMOD);
a5671 4
#if defined(O_BINARY) && defined(__CYGWIN__)
	    if (binary)
		setmode(fd, O_BINARY);
#endif
d5674 2
a5675 1
    } else
d5679 1
a5679 1
	    && chmod(name, HIDE_CHMOD) == 0)
d5682 10
a5691 10
	    fp = OpenHiddenFile(name, binary ? BIN_W : TXT_W);
	/*
	 * This is less stringent, but reasonably portable.  For new files, the
	 * umask will suffice; however if the file already exists we'll change
	 * permissions first, before opening it.  If the chmod fails because of
	 * some reason other than a non-existent file, there's no point in trying
	 * to open it.
	 *
	 * This won't work properly if the user is root, since the chmod succeeds.
	 */
a5693 1

d5700 5
a5704 1
#endif /* MULTI_USER_UNIX */
d5706 1
a5706 1
FILE *LYNewBinFile(const char *name)
d5709 1
a5709 2
    FILE *fp = fopen(name, BIN_W, "mbc=32");

d5712 1
a5712 1
    FILE *fp = OpenHiddenFile(name, BIN_W);
d5717 1
a5717 1
FILE *LYNewTxtFile(const char *name)
d5722 1
a5722 1
    fp = fopen(name, TXT_W, "shr=get");
d5727 1
a5727 1
    fp = OpenHiddenFile(name, TXT_W);
d5735 1
a5735 1
FILE *LYAppendToTxtFile(const char *name)
d5740 1
a5740 1
    fp = fopen(name, TXT_A, "shr=get");
d5745 1
a5745 1
    fp = OpenHiddenFile(name, TXT_A);
d5752 1
a5752 1
#if defined(MULTI_USER_UNIX)
d5754 3
a5756 3
 * Restore normal permissions to a copy of a file that we have created with
 * temp file restricted permissions.  The normal umask should apply for user
 * files.  - kw
d5758 1
a5758 1
void LYRelaxFilePermissions(const char *name)
a5761 1

d5766 3
a5768 3
	 * It looks plausible that this is a file we created with temp file
	 * paranoid permissions (and the umask wasn't even more restrictive
	 * when it was copied).  - kw
a5770 1

d5781 3
a5783 2
BOOLEAN LYCachedTemp(char *result,
		     char **cached)
d5785 2
d5788 1
a5788 1
	LYstrncpy(result, *cached, LY_MAXPATH);
d5790 2
a5791 1
	if (LYCanReadFile(result)) {
d5799 11
a5809 3
#ifndef HAVE_MKDTEMP
#define mkdtemp(path) ((mktemp(path) != 0) && (mkdir(path, 0700) == 0))
#endif
d5817 4
a5820 3
FILE *LYOpenTemp(char *result,
		 const char *suffix,
		 const char *mode)
d5824 1
a5824 1
    char wrt = 'r';
d5827 1
a5827 1
    CTRACE((tfp, "LYOpenTemp(,%s,%s)\n", suffix, mode));
d5833 3
a5835 9
	case 'w':
	    wrt = 'w';
	    break;
	case 'a':
	    wrt = 'a';
	    break;
	case 'b':
	    txt = FALSE;
	    break;
d5837 2
a5838 41
	    CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
	    return 0;
	}
    }

    /*
     * Verify if the given space looks secure enough.  Otherwise, make a
     * secure subdirectory of that.
     */
#if defined(MULTI_USER_UNIX) && (defined(HAVE_MKTEMP) || defined(HAVE_MKDTEMP))
    if (lynx_temp_subspace == 0) {
	BOOL make_it = FALSE;
	struct stat sb;

	if (lstat(lynx_temp_space, &sb) == 0
	    && S_ISDIR(sb.st_mode)) {
	    if (sb.st_uid != getuid()
		|| (sb.st_mode & (S_IWOTH | S_IWGRP)) != 0) {
		make_it = TRUE;
		CTRACE((tfp,
			"lynx_temp_space is not our directory %s owner %d mode %03o\n",
			lynx_temp_space, (int) sb.st_uid, (int) sb.st_mode & 0777));
	    }
	} else {
	    make_it = TRUE;
	    CTRACE((tfp, "lynx_temp_space is not a directory %s\n", lynx_temp_space));
	}
	if (make_it) {
	    int old_mask = umask(HIDE_UMASK);

	    StrAllocCat(lynx_temp_space, "lynxXXXXXXXXXX");
	    if (mkdtemp(lynx_temp_space) == 0) {
		printf("%s: %s\n", lynx_temp_space, LYStrerror(errno));
		exit_immediately(EXIT_FAILURE);
	    }
	    umask(old_mask);
	    lynx_temp_subspace = 1;
	    StrAllocCat(lynx_temp_space, "/");
	    CTRACE((tfp, "made subdirectory %s\n", lynx_temp_space));
	} else {
	    lynx_temp_subspace = -1;
a5840 1
#endif
d5848 1
a5848 1
		fp = LYNewTxtFile(result);
d5851 1
a5851 1
		fp = LYAppendToTxtFile(result);
d5855 1
a5855 1
	    fp = LYNewBinFile(result);
d5862 1
a5862 1
#ifdef EEXIST			/* FIXME (need a better test) in fcntl.h or unistd.h */
d5864 2
a5865 2
	    CTRACE((tfp, "... LYOpenTemp(%s) failed: %s\n",
		    result, LYStrerror(errno)));
d5871 1
a5871 1
    if ((p = typecalloc(LY_TEMP)) != 0) {
a5874 1
	p->outs = (wrt != 'r');
d5880 1
a5880 1
    CTRACE((tfp, "... LYOpenTemp(%s)\n", result));
d5887 2
a5888 1
FILE *LYReopenTemp(char *name)
d5894 3
a5896 148
    if ((p = FindTempfileByName(name)) != 0) {
	fp = p->file = LYAppendToTxtFile(name);
    }
    return fp;
}

/*
 * Open a temp-file for writing, possibly re-using a previously used
 * name and file.
 * If a non-empty fname is given, it is reused if it indicates a file
 * previously registered as a temp file and, in case the file still
 * exists, if it looks like we can write to it safely.  Otherwise a
 * new temp file (with new name) will be generated and returned in fname.
 *
 * File permissions are set so that the file is not readable by unprivileged
 * other users.
 *
 * Suffix is only used if fname is not being reused.
 * The mode should be "w", others are possible (they may be passed on)
 * but probably don't make sense. - kw
 */
FILE *LYOpenTempRewrite(char *fname,
			const char *suffix,
			const char *mode)
{
    FILE *fp = 0;
    BOOL txt = TRUE;
    char wrt = 'r';
    BOOL registered = NO;
    BOOL writable_exists = NO;
    BOOL is_ours = NO;
    BOOL still_open = NO;
    LY_TEMP *p;
    struct stat stat_buf;

    CTRACE((tfp, "LYOpenTempRewrite(%s,%s,%s)\n", fname, suffix, mode));
    if (*fname == '\0')		/* first time, no filename yet */
	return (LYOpenTemp(fname, suffix, mode));

    if ((p = FindTempfileByName(fname)) != 0) {
	registered = YES;
	if (p->file != 0)
	    still_open = YES;
	CTRACE((tfp, "...used before%s\n", still_open ? ", still open!" : "."));
    }

    if (registered) {
#ifndef NO_GROUPS
	writable_exists = HTEditable(fname);	/* existing, can write */
#define CTRACE_EXISTS "exists and is writable, "
#else
	writable_exists = (BOOL) (stat(fname, &stat_buf) == 0);		/* existing, assume can write */
#define CTRACE_EXISTS "exists, "
#endif

	if (writable_exists) {
	    is_ours = IsOurFile(fname);
	}
	CTRACE((tfp, "...%s%s\n",
		writable_exists ? CTRACE_EXISTS : "",
		is_ours ? "is our file." : "is NOT our file."));
    }

    /*
     * Note that in cases where LYOpenTemp is called as fallback below, we
     * don't call LYRemoveTemp first.  That may be appropriate in some cases,
     * but not trying to remove a weird existing file seems safer and could
     * help diagnose an unusual situation.  (They may be removed anyway later.)
     */
    if (still_open) {
	/*
	 * This should probably not happen.  Make a new one.
	 */
	return (LYOpenTemp(fname, suffix, mode));
    } else if (!registered) {
	/*
	 * Not registered.  It should have been registered at one point though,
	 * otherwise we wouldn't be called like this.
	 */
	return (LYOpenTemp(fname, suffix, mode));
    } else if (writable_exists && !is_ours) {
	/*
	 * File exists, writable if we checked, but something is wrong with it.
	 */
	return (LYOpenTemp(fname, suffix, mode));
#ifndef NO_GROUPS
    } else if (!is_ours && (lstat(fname, &stat_buf) == 0)) {
	/*
	 * Exists but not writable, and something is wrong with it.
	 */
	return (LYOpenTemp(fname, suffix, mode));
#endif
    }

    while (*mode != '\0') {
	switch (*mode++) {
	case 'w':
	    wrt = 'w';
	    break;
	case 'a':
	    wrt = 'a';
	    break;
	case 'b':
	    txt = FALSE;
	    break;
	default:
	    CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
	    return fp;
	}
    }

    if (is_ours) {
	/*
	 * Yes, it exists, is writable if we checked, and everything looks ok
	 * so far.  This should be the most regular case.  - kw
	 */
#ifdef HAVE_TRUNCATE
	if (txt == TRUE) {	/* limitation of LYReopenTemp.  shrug */
	    /*
	     * We truncate and then append, this avoids having a small window
	     * in which the file doesn't exist.  - kw
	     */
	    if (truncate(fname, 0) != 0) {
		CTRACE((tfp, "... truncate(%s,0) failed: %s\n",
			fname, LYStrerror(errno)));
		return (LYOpenTemp(fname, suffix, mode));
	    } else {
		return (LYReopenTemp(fname));
	    }
	}
#endif
	remove(fname);

    }

    /* We come here in two cases:  either the file existed and was ours and we
     * just got rid of it.  Or the file did and does not exist, but is
     * registered as a temp file.  It must have been removed by some means
     * other than LYRemoveTemp.  In both cases, reuse the name!  - kw
     */

    if (txt) {
	switch (wrt) {
	case 'w':
	    fp = LYNewTxtFile(fname);
	    break;
	case 'a':
	    fp = LYAppendToTxtFile(fname);
a5898 2
    } else {
	fp = LYNewBinFile(fname);
a5899 10
    p->file = fp;

    CTRACE((tfp, "... LYOpenTempRewrite(%s), %s\n", fname,
	    (fp) ? "ok" : "failed"));
    /*
     * We could fall back to trying LYOpenTemp() here in case of failure. 
     * After all the checks already done above a filure here should be pretty
     * unusual though, so maybe it's better to let the user notice that
     * something went wrong, and not try to fix it up.  - kw
     */
d5907 3
a5909 2
FILE *LYOpenScratch(char *result,
		    const char *prefix)
d5917 2
a5918 2
    if ((fp = LYNewTxtFile(result)) != 0) {
	if ((p = typecalloc(LY_TEMP)) != 0) {
d5927 1
a5927 1
    CTRACE((tfp, "LYOpenScratch(%s)\n", result));
a5930 12
static void LY_close_temp(LY_TEMP * p)
{
    if (p->file != 0) {
	if (p->outs) {
	    LYCloseOutput(p->file);
	} else {
	    LYCloseInput(p->file);
	}
	p->file = 0;
    }
}

d5934 2
a5935 1
void LYCloseTemp(char *name)
d5939 11
a5949 5
    CTRACE((tfp, "LYCloseTemp(%s)\n", name));
    if ((p = FindTempfileByName(name)) != 0) {
	CTRACE((tfp, "...LYCloseTemp(%s)%s\n", name,
		(p->file != 0) ? ", closed" : ""));
	LY_close_temp(p);
d5956 2
a5957 1
void LYCloseTempFP(FILE *fp)
d5961 8
a5968 4
    CTRACE((tfp, "LYCloseTempFP\n"));
    if ((p = FindTempfileByFP(fp)) != 0) {
	LY_close_temp(p);
	CTRACE((tfp, "...LYCloseTempFP(%s)\n", p->name));
d5975 2
a5976 1
int LYRemoveTemp(char *name)
d5979 1
a5979 1
    int code = -1;
d5981 2
a5982 2
    if (non_empty(name)) {
	CTRACE((tfp, "LYRemoveTemp(%s)\n", name));
d5990 2
a5991 1
		LY_close_temp(p);
d5993 2
a5994 2
		CTRACE((tfp, "...LYRemoveTemp done(%d)%s\n", code,
			(p->file != 0) ? ", closed" : ""));
a6001 1
    return code;
d6008 1
a6008 1
void LYCleanupTemp(void)
a6012 11
#if defined(MULTI_USER_UNIX)
    if (lynx_temp_subspace > 0) {
	char result[LY_MAXPATH];

	LYstrncpy(result, lynx_temp_space, sizeof(result) - 1);
	LYTrimPathSep(result);
	CTRACE((tfp, "LYCleanupTemp removing %s\n", result));
	rmdir(result);
	lynx_temp_subspace = -1;
    }
#endif
d6018 3
a6020 2
void LYRenamedTemp(char *oldname,
		   char *newname)
d6024 5
a6028 160
    CTRACE((tfp, "LYRenamedTemp(old=%s, new=%s)\n", oldname, newname));
    if ((p = FindTempfileByName(oldname)) != 0) {
	StrAllocCopy((p->name), newname);
    }
}

#ifndef DISABLE_BIBP
/*
 * Check that bibhost defines the BibP icon.
 */
void LYCheckBibHost(void)
{
    DocAddress bibhostIcon;
    BOOLEAN saveFlag;

    bibhostIcon.address = NULL;
    StrAllocCopy(bibhostIcon.address, BibP_bibhost);
    StrAllocCat(bibhostIcon.address, "bibp1.0/bibpicon.jpg");
    bibhostIcon.post_data = NULL;
    bibhostIcon.post_content_type = NULL;
    bibhostIcon.bookmark = FALSE;
    bibhostIcon.isHEAD = FALSE;
    bibhostIcon.safe = FALSE;
    saveFlag = traversal;
    traversal = TRUE;		/* Hack to force error response. */
    BibP_bibhost_available = HTLoadAbsolute(&bibhostIcon) == YES;
    traversal = saveFlag;
    BibP_bibhost_checked = TRUE;
}
#endif /* !DISABLE_BIBP */

/*
 * Management of User Interface Pages.  - kw
 *
 * These are mostly temp files.  Pages which can be recognized by their special
 * URL (after having been loaded) need not be tracked here.
 *
 * First some private stuff:
 */
typedef struct uipage_entry {
    UIP_t type;
    unsigned flags;
    char *url;
    HTList *alturls;
    char *file;
} uip_entry;

#define UIP_F_MULTI	0x0001	/* flag: track multiple instances */
#define UIP_F_LIMIT	0x0002	/* flag: limit size of alturls list */
#define UIP_F_LMULTI   (UIP_F_MULTI | UIP_F_LIMIT)
/* *INDENT-OFF* */
static uip_entry ly_uip[] =
{
    { UIP_HISTORY		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_DOWNLOAD_OPTIONS	, 0	      , NULL, NULL, NULL }
  , { UIP_PRINT_OPTIONS		, 0	      , NULL, NULL, NULL }
  , { UIP_SHOWINFO		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_LIST_PAGE		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_VLINKS		, UIP_F_LMULTI, NULL, NULL, NULL }
#if !defined(NO_OPTION_FORMS)
  , { UIP_OPTIONS_MENU		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
#ifdef DIRED_SUPPORT
  , { UIP_DIRED_MENU		, 0	      , NULL, NULL, NULL }
  , { UIP_PERMIT_OPTIONS	, 0	      , NULL, NULL, NULL }
  , { UIP_UPLOAD_OPTIONS	, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
#ifdef EXP_ADDRLIST_PAGE
  , { UIP_ADDRLIST_PAGE		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
  , { UIP_LYNXCFG		, UIP_F_LMULTI, NULL, NULL, NULL }
#if !defined(NO_CONFIG_INFO)
  , { UIP_CONFIG_DEF		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
/* The following are not generated tempfiles: */
  , { UIP_TRACELOG		, 0	     , NULL, NULL, NULL }
#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
  , { UIP_INSTALL		, 0	     , NULL, NULL, NULL }
#endif

};
/* *INDENT-ON* */

/*  Public entry points for User Interface Page management: */

BOOL LYIsUIPage3(const char *url,
		 UIP_t type,
		 int flagparam)
{
    unsigned int i;
    size_t l;

    if (!url)
	return NO;
    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	if (ly_uip[i].type == type) {
	    if (!ly_uip[i].url) {
		return NO;
	    } else if ((flagparam & UIP_P_FRAG) ?
		       (!strncmp(ly_uip[i].url, url, (l = strlen(ly_uip[i].url)))
			&& (url[l] == '\0' || url[l] == '#')) :
		       !strcmp(ly_uip[i].url, url)) {
		return YES;
	    } else if (ly_uip[i].flags & UIP_F_MULTI) {
		char *p;
		HTList *l0 = ly_uip[i].alturls;

		while ((p = (char *) HTList_nextObject(l0)) != NULL) {
		    if ((flagparam & UIP_P_FRAG) ?
			(!strncmp(p, url, (l = strlen(p)))
			 && (url[l] == '\0' || url[l] == '#')) :
			!strcmp(p, url))
			return YES;
		}
	    }
	    return NO;
	}
    }
    return NO;
}

void LYRegisterUIPage(const char *url,
		      UIP_t type)
{
    unsigned int i;

    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	if (ly_uip[i].type == type) {
	    if (ly_uip[i].url && url &&
		!strcmp(ly_uip[i].url, url)) {

	    } else if (!ly_uip[i].url || !url ||
		       !(ly_uip[i].flags & UIP_F_MULTI)) {
		StrAllocCopy(ly_uip[i].url, url);

	    } else {
		char *p;
		int n = 0;
		HTList *l0 = ly_uip[i].alturls;

		while ((p = (char *) HTList_nextObject(l0)) != NULL) {
		    if (!strcmp(p, url))
			return;
		    if (!strcmp(p, ly_uip[i].url)) {
			StrAllocCopy(ly_uip[i].url, url);
			return;
		    }
		    n++;
		}
		if (!ly_uip[i].alturls)
		    ly_uip[i].alturls = HTList_new();

		if (n >= HTCacheSize && (ly_uip[i].flags & UIP_F_LIMIT))
		    HTList_removeFirstObject(ly_uip[i].alturls);
		HTList_addObject(ly_uip[i].alturls, ly_uip[i].url);
		ly_uip[i].url = NULL;
		StrAllocCopy(ly_uip[i].url, url);
	    }

	    return;
a6032 12
void LYUIPages_free(void)
{
    unsigned int i;

    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	FREE(ly_uip[i].url);
	FREE(ly_uip[i].file);
	LYFreeStringList(ly_uip[i].alturls);
	ly_uip[i].alturls = NULL;
    }
}

d6034 2
a6035 2
 * Convert local pathname to www name
 * (do not bother about file://localhost prefix at this point).
d6037 2
a6038 1
const char *wwwName(const char *pathname)
d6040 1
a6040 1
    const char *cp = NULL;
d6042 2
a6043 2
#if defined(USE_DOS_DRIVES)
    cp = HTDOS_wwwName(pathname);
d6046 1
a6046 1
    cp = HTVMS_wwwName(pathname);
d6048 1
a6048 1
    cp = pathname;
d6050 1
a6050 1
#endif
a6058 2
 *
 * Both strings are fixed buffer sizes, LY_MAXPATH.
d6060 3
a6062 2
BOOLEAN LYValidateFilename(char *result,
			   char *given)
a6064 1
    const char *cp2;
d6067 2
a6068 2
     * Cancel if the user entered "/dev/null" on Unix, or an "nl:" path on VMS. 
     * - FM
d6070 7
a6076 1
    if (LYIsNullDevice(given)) {
d6080 1
a6080 1
#ifdef HAVE_POPEN
d6086 1
a6086 1
	LYstrncpy(result, given, LY_MAXPATH);
d6090 1
a6090 3
    if ((cp = strchr(given, '~')) != 0
	&& (cp2 = wwwName(Home_Dir())) != 0
	&& strlen(cp2) + strlen(given) < LY_MAXPATH) {
d6094 1
a6094 1
	strcat(result, cp2);
d6103 1
a6103 3
    if (given[0] != '/'
	&& strchr(given, ':') == NULL
	&& strlen(given) < LY_MAXPATH - 13) {
d6114 1
a6114 1
    if (!LYisAbsPath(given)) {
d6116 3
a6118 3
	if (strchr(result, ':') != NULL)
	    cp = NULL;
	else
d6120 4
a6123 11
	{
#ifdef SUPPORT_CHDIR
	    static char buf[LY_MAXPATH];

	    cp = Current_Dir(buf);
#else
	    cp = original_dir;
#endif
	}
    } else
#endif /* __EMX__ */
a6125 1
    *result = 0;
d6128 3
a6130 3
	if (strlen(cp) >= LY_MAXPATH - 2)
	    return FALSE;
	sprintf(result, "%s/", cp);
a6131 4
    cp = HTSYS_name(given);
    if (strlen(result) + strlen(cp) >= LY_MAXPATH - 1)
	return FALSE;
    strcat(result, cp);
d6145 2
a6146 1
int LYValidateOutput(char *filename)
d6148 1
d6154 1
a6154 1
#ifdef HAVE_POPEN
d6167 1
a6167 1
     * See if it already exists.
d6169 2
a6170 1
    if (LYCanReadFile(filename)) {
d6189 3
a6191 2
void LYLocalFileToURL(char **target,
		      const char *source)
d6193 1
a6193 1
    const char *leaf;
a6198 8
    if (!LYisAbsPath(source)) {
	char temp[LY_MAXPATH];

	Current_Dir(temp);
	if (!LYIsHtmlSep(*temp))
	    LYAddHtmlSep(target);
	StrAllocCat(*target, temp);
    }
d6204 5
a6208 6
/*
 * Open a temporary file for internal-pages, optionally reusing an existing
 * filename.
 */
FILE *InternalPageFP(char *filename,
		     int reuse_flag)
d6210 1
a6210 1
    FILE *fp;
d6212 2
a6213 7
    if (LYReuseTempfiles && reuse_flag) {
	fp = LYOpenTempRewrite(filename, HTML_SUFFIX, BIN_W);
    } else {
	LYRemoveTemp(filename);
	fp = LYOpenTemp(filename, HTML_SUFFIX, BIN_W);
    }
    if (fp == NULL) {
d6215 1
d6217 5
a6221 1
    return fp;
d6223 1
d6225 4
a6228 4
/*
 * This part is shared by all internal pages.
 */
void WriteInternalTitle(FILE *fp0, const char *Title)
a6229 3
    fprintf(fp0,
	    "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n");

a6234 1

d6246 2
a6247 11
    fprintf(fp0, "<title>%s</title>\n</head>\n<body>\n", Title);
}

/*
 * This is used to start most internal pages, except for special cases where
 * the embedded HREF's in the title differ.
 */
void BeginInternalPage(FILE *fp0, const char *Title,
		       const char *HelpURL)
{
    WriteInternalTitle(fp0, Title);
d6250 2
a6251 2
	&& LYwouldPush(Title, NULL)
	&& (HelpURL != 0)) {
d6261 2
a6262 1
void EndInternalPage(FILE *fp0)
a6266 9
char *trimPoundSelector(char *address)
{
    char *pound = findPoundSelector(address);

    if (pound != 0)
	*pound = '\0';
    return pound;
}

d6271 2
a6272 1
void LYTrimPathSep(char *path)
d6277 3
a6279 3
	&& (len = strlen(path)) != 0
	&& LYIsPathSep(path[len - 1]))
	path[len - 1] = 0;
d6282 6
d6292 2
a6293 1
void LYAddPathSep(char **path)
d6299 3
a6301 3
	&& ((temp = *path) != 0)
	&& (len = strlen(temp)) != 0
	&& !LYIsPathSep(temp[len - 1])) {
d6310 2
a6311 1
void LYAddPathSep0(char *path)
d6316 2
a6317 3
	&& (len = strlen(path)) != 0
	&& (len < LY_MAXPATH - 2)
	&& !LYIsPathSep(path[len - 1])) {
a6322 16
 * Check if a given string contains a path separator
 */
char *LYLastPathSep(const char *path)
{
    char *result;

#if defined(USE_DOS_DRIVES)
    if ((result = strrchr(path, '\\')) == 0)
	result = strrchr(path, '/');
#else
    result = strrchr(path, '/');
#endif
    return result;
}

/*
d6326 2
a6327 1
void LYTrimHtmlSep(char *path)
d6332 3
a6334 3
	&& (len = strlen(path)) != 0
	&& LYIsHtmlSep(path[len - 1]))
	path[len - 1] = 0;
d6341 2
a6342 1
void LYAddHtmlSep(char **path)
d6348 3
a6350 3
	&& ((temp = *path) != 0)
	&& (len = strlen(temp)) != 0
	&& !LYIsHtmlSep(temp[len - 1])) {
d6359 2
a6360 1
void LYAddHtmlSep0(char *path)
d6365 2
a6366 3
	&& (len = strlen(path)) != 0
	&& (len < LY_MAXPATH - 2)
	&& !LYIsHtmlSep(path[len - 1])) {
d6374 3
a6376 2
int LYCopyFile(char *src,
	       char *dst)
d6379 1
a6379 1
    const char *program;
d6381 9
a6389 2
    if ((program = HTGetProgramPath(ppCOPY)) != NULL) {
	char *the_command = 0;
d6391 1
a6391 32
	HTAddParam(&the_command, COPY_COMMAND, 1, program);
	HTAddParam(&the_command, COPY_COMMAND, 2, src);
	HTAddParam(&the_command, COPY_COMMAND, 3, dst);
	HTEndParam(&the_command, COPY_COMMAND, 3);

	CTRACE((tfp, "command: %s\n", the_command));
	stop_curses();
	code = LYSystem(the_command);
	start_curses();

	FREE(the_command);
    } else {
	FILE *fin, *fout;
	unsigned char buff[BUFSIZ];
	int len;

	code = EOF;
	if ((fin = fopen(src, BIN_R)) != 0) {
	    if ((fout = fopen(dst, BIN_W)) != 0) {
		code = 0;
		while ((len = fread(buff, 1, sizeof(buff), fin)) > 0) {
		    fwrite(buff, 1, len, fout);
		    if (ferror(fout)) {
			code = EOF;
			break;
		    }
		}
		LYCloseOutput(fout);
	    }
	    LYCloseInput(fin);
	}
    }
a6392 3
    if (code) {
	HTAlert(CANNOT_WRITE_TO_FILE);
    }
a6395 28
#ifdef __DJGPP__
static char *escape_backslashes(char *source)
{
    char *result = 0;
    int count = 0;
    int n;

    for (n = 0; source[n] != '\0'; ++n) {
	if (source[n] == '\\')
	    ++count;
    }
    if (count != 0) {
	result = malloc(count + n + 1);
	if (result != 0) {
	    int ch;
	    char *target = result;

	    while ((ch = *source++) != '\0') {
		if (ch == '\\')
		    *target++ = ch;
		*target++ = ch;
	    }
	    *target = '\0';
	}
    }
    return result;
}
#endif /* __DJGPP__ */
d6397 1
a6397 1
 * Invoke a shell command, return nonzero on error.
d6399 2
a6400 1
int LYSystem(char *command)
a6404 10
#if defined(HAVE_SIGACTION) && defined(SIGTSTP) && !defined(USE_SLANG)
    struct sigaction saved_sigtstp_act;
    BOOLEAN sigtstp_saved = FALSE;
#endif
    int saved_errno = 0;

#ifdef __EMX__
    int scrsize[4];
#endif

d6407 1
a6407 1
    CTRACE((tfp, "LYSystem(%s)\n", command));
d6418 1
a6418 1
#  ifdef __EMX__		/* FIXME: Should be LY_CONVERT_SLASH? */
a6422 2

	_scrsize(scrsize);
a6440 80

    /*
     * This chunk of code does not work, for two reasons:
     * a) the Cygwin system() function edits out the backslashes
     * b) it does not account for more than one parameter, e.g., +number
     */
#if defined(__CYGWIN__) && defined(DOSPATH)	/* 1999/02/26 (Fri) */
    {
	char cmd[LY_MAXPATH];
	char win32_name[LY_MAXPATH];
	char new_cmd[LY_MAXPATH];
	char new_command[LY_MAXPATH * 2 + 10];
	char *p, *q;

	p = command;
	q = cmd;
	while (*p) {
	    if (*p == ' ')
		break;
	    else
		*q = *p;
	    p++;
	    q++;
	}
	*q = '\0';

	if (cmd[0] == '/')
	    cygwin_conv_to_full_posix_path(cmd, new_cmd);
	else
	    strcpy(new_cmd, cmd);

	while (*p == ' ')
	    p++;

	if (strchr(p, '\\') == NULL) {
	    /* for Windows Application */
	    cygwin_conv_to_full_win32_path(p, win32_name);
	    sprintf(new_command, "%.*s \"%.*s\"",
		    LY_MAXPATH, new_cmd, LY_MAXPATH, win32_name);
	} else {
	    /* for DOS like editor */
	    q = win32_name;
	    while (*p) {
		if (*p == '\\') {
		    if (*(p + 1) == '\\')
			p++;
		}
		*q = *p;
		q++, p++;
	    }
	    *q = '\0';
	    sprintf(new_command, "%.*s %.*s", LY_MAXPATH, new_cmd, LY_MAXPATH, win32_name);
	}
	command = new_command;
    }
#endif

#ifdef __DJGPP__
    if (dj_is_bash) {
	char *new_command = escape_backslashes(command);

	if (new_command != 0) {
	    if (do_free)
		free(command);
	    command = new_command;
	}
    }
#endif /* __DJGPP__ */

#ifdef _WIN_CC
    code = exec_command(command, TRUE);		/* Wait exec */
#else /* !_WIN_CC */
#ifdef SIGPIPE
    if (restore_sigpipe_for_children)
	signal(SIGPIPE, SIG_DFL);	/* Some commands expect the default */
#endif
#if defined(HAVE_SIGACTION) && defined(SIGTSTP) && !defined(USE_SLANG)
    if (!dump_output_immediately && !LYCursesON && !no_suspend)
	sigtstp_saved = LYToggleSigDfl(SIGTSTP, &saved_sigtstp_act, 1);
#endif
a6441 10
    saved_errno = errno;
#if defined(HAVE_SIGACTION) && defined(SIGTSTP) && !defined(USE_SLANG)
    if (sigtstp_saved)
	LYToggleSigDfl(SIGTSTP, &saved_sigtstp_act, 0);
#endif
#ifdef SIGPIPE
    if (restore_sigpipe_for_children)
	signal(SIGPIPE, SIG_IGN);	/* Ignore it again - kw */
#endif
#endif
a6453 6
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ?? */
    set_errno(saved_errno);	/* may have been clobbered */
#endif
#ifdef __EMX__			/* Check whether the screen size changed */
    size_change(0);
#endif
d6460 1
a6460 43
#if defined(__CYGWIN__)		/* 1999/02/26 (Fri) */
int Cygwin_Shell(void)
{
    char *shell;
    int code;
    STARTUPINFO startUpInfo;
    PROCESS_INFORMATION procInfo;
    SECURITY_ATTRIBUTES sa;

    /* Set up security attributes to allow inheritance of the file handle */

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = 0;
    sa.bInheritHandle = TRUE;

    /* Init a startup structure */
    GetStartupInfo(&startUpInfo);

    shell = LYGetEnv("COMSPEC");

    /* Create the child process, specifying
       inherited handles. Pass the value of the
       handle as a command line parameter */
    code = 0;
    if (shell) {
	code = CreateProcess(0, shell, 0, 0,
			     TRUE, 0,
			     0, 0, &startUpInfo, &procInfo);

	if (!code) {
	    printf("shell = [%s], code = %ld\n", shell, GetLastError());
	}

	/* wait for the child to return (this is not a requirement
	   since the child is its own independent process) */
	WaitForSingleObject(procInfo.hProcess, INFINITE);
    }

    return code;
}
#endif

const char *LYSysShell(void)
d6462 1
a6462 2
    const char *shell = 0;

d6464 4
a6467 16
#ifdef WIN_EX
    shell = LYGetEnv("SHELL");
    if (shell) {
	if (access(shell, 0) != 0)
	    shell = LYGetEnv("COMSPEC");
    }
    if (shell == NULL) {
	if (system_is_NT)
	    shell = "cmd.exe";
	else
	    shell = "command.com";
    }
#else
    shell = LYGetEnv("SHELL");
    if (shell == NULL) {
	shell = LYGetEnv("COMSPEC");
a6468 4
    if (shell == NULL) {
	shell = "command.com";
    }
#endif /* WIN_EX */
d6471 2
a6472 2
    if (LYGetEnv("SHELL") != NULL) {
	shell = LYGetEnv("SHELL");
d6474 1
a6474 1
	shell = (LYGetEnv("COMSPEC") == NULL) ? "cmd.exe" : LYGetEnv("COMSPEC");
d6496 1
a6496 1
char *LYgetXDisplay(void)
d6498 4
a6501 1
    return LYGetEnv(DISPLAY);
d6508 2
a6509 1
void LYsetXDisplay(char *new_display)
d6511 1
a6511 1
    if (new_display != 0) {
d6517 3
d6521 1
a6521 1
	HTSprintf0(&display_putenv_command, "DISPLAY=%s", new_display);
a6528 480

#ifdef CAN_CUT_AND_PASTE
#ifdef __EMX__

static int proc_type = -1;
static PPIB pib;
static HAB hab;
static HMQ hmq;

static void morph_PM(void)
{
    PTIB tib;
    int first = 0;

    if (proc_type == -1) {
	DosGetInfoBlocks(&tib, &pib);
	proc_type = pib->pib_ultype;
	first = 1;
    }
    if (pib->pib_ultype != 3)	/* 2 is VIO */
	pib->pib_ultype = 3;	/* 3 is PM */
    if (first)
	hab = WinInitialize(0);
    /* 64 messages if before OS/2 3.0, ignored otherwise */
    hmq = WinCreateMsgQueue(hab, 64);
    WinCancelShutdown(hmq, 1);	/* Do not inform us on shutdown */
}

static void unmorph_PM(void)
{
    WinDestroyMsgQueue(hmq);
    pib->pib_ultype = proc_type;
}

int size_clip(void)
{
    return 8192;
}

/* Code partially stolen from FED editor. */

int put_clip(const char *s)
{
    int sz = strlen(s) + 1;
    int ret = EOF, nl = 0;
    char *pByte = 0, *s1 = s, c, *t;

    while ((c = *s1++)) {
	if (c == '\r' && *s1 == '\n')
	    s1++;
	else if (c == '\n')
	    nl++;
    }
    if (DosAllocSharedMem((PPVOID) & pByte, 0, sz + nl,
			  PAG_WRITE | PAG_COMMIT | OBJ_GIVEABLE | OBJ_GETTABLE))
	return ret;

    if (!nl)
	memcpy(pByte, s, sz);
    else {
	t = pByte;
	while ((c = *t++ = *s++))
	    if (c == '\n' && (t == pByte + 1 || t[-2] != '\r'))
		t[-1] = '\r', *t++ = '\n';
    }

    morph_PM();
    if (!hab)
	goto fail;

    WinOpenClipbrd(hab);
    WinEmptyClipbrd(hab);
    if (WinSetClipbrdData(hab, (ULONG) pByte, CF_TEXT, CFI_POINTER))
	ret = 0;
    WinCloseClipbrd(hab);
    unmorph_PM();
    if (ret == 0)
	return 0;
  fail:
    DosFreeMem((PPVOID) & pByte);
    return EOF;
}

static int clip_open;

/* get_clip_grab() returns a pointer to the string in the system area.
   get_clip_release() should be called ASAP after this. */

char *get_clip_grab(void)
{
    char *ClipData;
    ULONG ulFormat;
    int sz;

    morph_PM();
    if (!hab)
	return 0;
    if (clip_open)
	get_clip_release();

    WinQueryClipbrdFmtInfo(hab, CF_TEXT, &ulFormat);
    if (ulFormat != CFI_POINTER) {
	unmorph_PM();
	return 0;
    }
    WinOpenClipbrd(hab);
    clip_open = 1;
    ClipData = (char *) WinQueryClipbrdData(hab, CF_TEXT);
    sz = strlen(ClipData);
    if (!ClipData || !sz) {
	get_clip_release();
	return 0;
    }
    return ClipData;
}

void get_clip_release(void)
{
    if (!clip_open)
	return;
    WinCloseClipbrd(hab);
    clip_open = 0;
    unmorph_PM();
}

#else /* !( defined __EMX__ ) */

#  if !defined(WIN_EX) && defined(HAVE_POPEN)

static FILE *paste_handle = 0;
static char *paste_buf = NULL;

void get_clip_release(void)
{
    if (paste_handle != 0)
	pclose(paste_handle);
    if (paste_buf)
	FREE(paste_buf);
}

static int clip_grab(void)
{
    char *cmd = LYGetEnv("RL_PASTE_CMD");

    if (paste_handle)
	pclose(paste_handle);
    if (!cmd)
	return 0;

    paste_handle = popen(cmd, "rt");
    if (!paste_handle)
	return 0;
    return 1;
}

#define PASTE_BUFFER 1008
#define CF_TEXT 0		/* Not used */

char *get_clip_grab(void)
{
    int len;
    int size = PASTE_BUFFER;
    int off = 0;

    if (!clip_grab())
	return NULL;
    if (!paste_handle)
	return NULL;
    if (paste_buf)
	FREE(paste_buf);
    paste_buf = (char *) malloc(PASTE_BUFFER);
    while (1) {
	len = fread(paste_buf + off, 1, PASTE_BUFFER - 1, paste_handle);
	paste_buf[off + len] = '\0';
	if (len < PASTE_BUFFER - 1)
	    break;
	if (strchr(paste_buf + off, '\r')
	    || strchr(paste_buf + off, '\n'))
	    break;
	paste_buf = typeRealloc(char, paste_buf, size += PASTE_BUFFER - 1);

	off += len;
    }
    return paste_buf;
}

int put_clip(const char *s)
{
    char *cmd = LYGetEnv("RL_CLCOPY_CMD");
    FILE *fh;
    int l = strlen(s), res;

    if (!cmd)
	return -1;

    fh = popen(cmd, "wt");
    if (!fh)
	return -1;
    res = fwrite(s, 1, l, fh);
    if (pclose(fh) != 0 || res != l)
	return -1;
    return 0;
}

#  endif			/* !defined(WIN_EX) && defined(HAVE_POPEN) */

#endif /* __EMX__ */

/*
 * Sleep for a number of milli-sec.
 */
void LYmsec_delay(unsigned msec)
{
#if defined(_WINDOWS)
    Sleep(msec);

#elif defined(HAVE_NAPMS)
    napms(msec);

#elif defined(DJGPP) || defined(HAVE_USLEEP)
    usleep(1000 * msec);

#else
    struct timeval tv;
    unsigned long usec = 1000UL * msec;

    tv.tv_sec = usec / 1000000UL;
    tv.tv_usec = usec % 1000000UL;
    select(0, NULL, NULL, NULL, &tv);
#endif
}

#if defined(WIN_EX)		/* 1997/10/16 (Thu) 20:13:28 */

int put_clip(const char *szBuffer)
{
    HANDLE hWnd;
    HANDLE m_hLogData;
    LPTSTR pLogData;
    HANDLE hClip;
    int len;

    if (szBuffer == NULL)
	return EOF;

    len = strlen(szBuffer);
    if (len == 0)
	return EOF;
    else
	len++;

    m_hLogData = GlobalAlloc(GHND, len);
    if (m_hLogData == NULL) {
	return EOF;
    }

    hWnd = NULL;
    if (!OpenClipboard(hWnd)) {
	return EOF;
    }
    /* Remove the current Clipboard contents */
    if (!EmptyClipboard()) {
	GlobalFree(m_hLogData);
	return EOF;
    }

    /* Lock the global memory while we write to it. */
    pLogData = (LPTSTR) GlobalLock(m_hLogData);

    lstrcpy((LPTSTR) pLogData, szBuffer);
    GlobalUnlock(m_hLogData);

    /* If there were any lines at all then copy them to clipboard. */
    hClip = SetClipboardData(CF_TEXT, m_hLogData);
    if (!hClip) {
	/* If we couldn't clip the data then free the global handle. */
	GlobalFree(m_hLogData);
    }

    CloseClipboard();
    return 0;
}

static HANDLE m_hLogData;
static int m_locked;

/* get_clip_grab() returns a pointer to the string in the system area.
   get_clip_release() should be called ASAP after this. */

char *get_clip_grab()
{
    HANDLE hWnd;
    LPTSTR pLogData;

    hWnd = NULL;
    if (!OpenClipboard(hWnd)) {
	return 0;
    }

    m_hLogData = GetClipboardData(CF_TEXT);

    if (m_hLogData == NULL) {
	CloseClipboard();
	m_locked = 0;
	return 0;
    }
    pLogData = (LPTSTR) GlobalLock(m_hLogData);

    m_locked = 1;
    return pLogData;
}

void get_clip_release()
{
    if (!m_locked)
	return;
    GlobalUnlock(m_hLogData);
    CloseClipboard();
    m_locked = 0;
}
#endif /* WIN_EX */
#endif /* CAN_CUT_AND_PASTE */

#if defined(WIN_EX)

#ifndef WSABASEERR
#define WSABASEERR 10000
#endif

#ifdef ENABLE_IPV6
#define WSOCK_NAME  "ws2_32"
#else
#define WSOCK_NAME  "wsock32"
#endif

/*
 * Description: the windows32 version of perror()
 *
 * Returns:  a pointer to a static error
 *
 * Notes/Dependencies:  I got this from
 *	comp.os.ms-windows.programmer.win32
 */
char *w32_strerror(DWORD ercode)
{
/*  __declspec(thread) necessary if you will use multiple threads */
#ifdef __CYGWIN__
    static char msg_buff[256];

#else
    __declspec(thread) static char msg_buff[256];
#endif
    HMODULE hModule;
    int i, msg_type;
    unsigned char *p, *q, tmp_buff[256];
    DWORD rc;

    hModule = NULL;
    msg_type = FORMAT_MESSAGE_FROM_SYSTEM;
    /* Fill message buffer with a default message in
     * case FormatMessage fails
     */
    wsprintf(msg_buff, "Error %ld", ercode);

    /*
     * Special code for winsock error handling.
     */
    if (ercode > WSABASEERR) {
	hModule = GetModuleHandle(WSOCK_NAME);
	if (hModule)
	    msg_type = FORMAT_MESSAGE_FROM_HMODULE;
    }
    /*
     * message handling. If not found in module, retry from system.
     */
    rc = FormatMessage(msg_type, hModule, ercode, LANG_NEUTRAL,
		       msg_buff, sizeof(msg_buff), NULL);

    if (rc == 0 && msg_type == FORMAT_MESSAGE_FROM_HMODULE) {
	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, ercode,
		      LANG_NEUTRAL, msg_buff, sizeof(msg_buff), NULL);
    }

    strcpy(tmp_buff, msg_buff);
    p = q = tmp_buff;
    i = 0;
    while (*p) {
	if (!(*p == '\n' || *p == '\r'))
	    msg_buff[i++] = *p;
	p++;
    }
    msg_buff[i] = '\0';

    return msg_buff;
}

#endif

#if defined(SYSLOG_REQUESTED_URLS)
/*
 * syslog() interface
 */
void LYOpenlog(const char *banner)
{
    if (syslog_requested_urls) {
	CTRACE((tfp, "LYOpenlog(%s)\n", NONNULL(banner)));
#if defined(DJGPP)
	openlog("lynx", LOG_PID | LOG_NDELAY, LOG_LOCAL5);
#else
	openlog("lynx", LOG_PID, LOG_LOCAL5);
#endif

	if (banner) {
	    syslog(LOG_INFO, "Session start:%s", banner);
	} else {
	    syslog(LOG_INFO, "Session start");
	}
    }
}

static BOOLEAN looks_like_password(char *first,
				   char *last)
{
    BOOLEAN result = FALSE;

    while (first <= last) {
	if (*first == '/'
	    || *first == ':') {
	    result = FALSE;
	    break;
	}
	result = TRUE;
	first++;
    }
    return result;
}

void LYSyslog(char *arg)
{
    char *colon1;
    char *colon2;
    char *atsign;

    if (syslog_requested_urls) {

	CTRACE((tfp, "LYSyslog %s\n", arg));

	if (is_url(arg)) {	/* proto://user:password@@host/path:port */
	    /*      ^this colon                 */
	    if ((colon1 = strchr(arg, ':')) != 0
		&& !strncmp(colon1, "://", 3)
		&& (colon2 = strchr(colon1 + 3, ':')) != 0
		&& (atsign = strchr(colon1, '@@')) != 0
		&& (colon2 < atsign)
		&& looks_like_password(colon2 + 1, atsign - 1)) {
		char *buf = NULL;

		StrAllocCopy(buf, arg);
		buf[colon2 - arg + 1] = 0;
		StrAllocCat(buf, "******");
		StrAllocCat(buf, atsign);
		syslog(LOG_INFO | LOG_LOCAL5, "%s", buf);
		CTRACE((tfp, "...alter %s\n", buf));
		FREE(buf);
		return;
	    }
	}
	syslog(LOG_INFO | LOG_LOCAL5, "%s", NONNULL(arg));
    }
}

void LYCloselog(void)
{
    if (syslog_requested_urls) {
	syslog(LOG_INFO, "Session over");
	closelog();
    }
}

#endif /* SYSLOG_REQUESTED_URLS */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d9 1
a11 1
#include <LYUtils.h>
a16 1

a19 19
#ifdef __DJGPP__
#include <go32.h>
#include <sys/exceptn.h>
#endif /* __DJGPP__ */

#ifndef NO_GROUPS
#include <HTFile.h>
#endif

#ifdef _WIN_CC
extern int exec_command(char * cmd, int wait_flag); /* xsystem.c */
#endif

#ifdef _WINDOWS	/* 1998/04/30 (Thu) 19:04:25 */
#define GETPID()	(getpid() & 0xffff)
#else
#define GETPID()	getpid()
#endif /* _WINDOWS */

a23 9
#ifdef __EMX__
#  define BOOLEAN OS2_BOOLEAN		/* Conflicts, but is used */
#  undef HT_ERROR			/* Conflicts too */
#  define INCL_PM			/* I want some PM functions.. */
#  define INCL_DOSPROCESS		/* TIB PIB. */
#  include <os2.h>
#  undef BOOLEAN
#endif

d30 1
a30 1
#ifdef HAVE_UTMP
a34 1
#ifdef UTMPX_FILE
d38 1
a40 1
#ifdef __UTMPX_FILE
a41 3
#else
#define UTMP_FILE "/var/adm/utmpx" /* Digital Unix 4.0 */
#endif
d79 3
a81 3
#ifdef __DJGPP__
#undef select			/* defined to select_s in www_tcp.h */
#endif
d91 1
a91 15
/*
 * experimental - make temporary filenames random to make the scheme less
 * obvious.  However, as noted by KW, there are instances (such as the
 * 'O'ption page, for which Lynx will store a temporary filename even when
 * it no longer applies, since it will reuse that filename at a later time.
 */
#ifdef EXP_RAND_TEMPNAME
#if defined(LYNX_RAND_MAX)
#define USE_RAND_TEMPNAME 1
#define MAX_TEMPNAME 10000
#ifndef BITS_PER_CHAR
#define BITS_PER_CHAR 8
#endif
#endif
#endif
d93 3
a95 1
#define COPY_COMMAND "%s %s %s"
a98 1

d102 1
a102 2
 * Maintain a list of all of the temp-files we create so that we can remove
 * them during the cleanup.
d104 22
a125 6
typedef struct _LYTemp {
    struct _LYTemp *next;
    char *name;
    BOOLEAN outs;
    FILE *file;
} LY_TEMP;
d127 8
a134 1
PRIVATE LY_TEMP *ly_temp;
d136 5
a140 3
PRIVATE LY_TEMP *FindTempfileByName ARGS1(CONST char *, name)
{
    LY_TEMP *p;
d142 41
a182 3
    for (p = ly_temp; p != 0; p = p->next) {
	if (!strcmp(p->name, name)) {
	    break;
a183 3
    }
    return p;
}
a184 3
PRIVATE LY_TEMP *FindTempfileByFP ARGS1(FILE *, fp)
{
    LY_TEMP *p;
d186 3
a188 7
    for (p = ly_temp; p != 0; p = p->next) {
	if (p->file == fp) {
	    break;
	}
    }
    return p;
}
d190 6
a195 8
/*
 * Get an environment variable, rejecting empty strings
 */
PUBLIC char *LYGetEnv ARGS1(CONST char *, name)
{
    char *result = getenv(name);
    return non_empty(result) ? result : 0;
}
d197 3
a199 9
/*
 * Check for UTF-8 data, returning the length past the first character.
 * Return zero if we found an ordinary character rather than UTF-8.
 */
PUBLIC size_t utf8_length ARGS2(
	BOOL,		utf_flag,
	CONST char *,	data)
{
    size_t utf_extra = 0;
a200 11
    if (utf_flag && is8bits(*data)) {
	if ((*data & 0xe0) == 0xc0) {
	    utf_extra = 1;
	} else if ((*data & 0xf0) == 0xe0) {
	    utf_extra = 2;
	} else if ((*data & 0xf8) == 0xf0) {
	    utf_extra = 3;
	} else if ((*data & 0xfc) == 0xf8) {
	    utf_extra = 4;
	} else if ((*data & 0xfe) == 0xfc) {
	    utf_extra = 5;
d202 7
d210 2
a211 1
	     *  Garbage.
d213 8
a220 1
	    utf_extra = 0;
a221 9
	if (strlen(data+1) < utf_extra) {
	    /*
	     *  Shouldn't happen.
	     */
	    utf_extra = 0;
	}
    }
    return utf_extra;
}
d223 15
a237 11
/*
 * Set the initial highlight information for a given link.
 */
PUBLIC void LYSetHilite ARGS2(
	int,		cur,
	char *,		text)
{
    links[cur].list.hl_base.hl_text = text;
    links[cur].list.hl_len = (text != NULL) ? 1 : 0;
    FREE(links[cur].list.hl_info);
}
d239 20
a258 12
/*
 * Add highlight information for the next line of a link.
 */
PUBLIC void LYAddHilite ARGS3(
	int,		cur,
	char *,		text,
	int,		x)
{
    HiliteList *list = &(links[cur].list);
    HiliteInfo *have = list->hl_info;
    unsigned need = (list->hl_len - 1);
    unsigned want = (list->hl_len += 1) * sizeof(HiliteInfo);
d260 30
a289 9
    if (have != NULL) {
	have = realloc(have, want);
    } else {
	have = malloc(want);
    }
    list->hl_info = have;
    have[need].hl_text = text;
    have[need].hl_x = x;
}
d291 13
a303 8
/*
 * Get the highlight text, counting from zero.
 */
PUBLIC char *LYGetHiliteStr ARGS2(
	int,		cur,
	int,		count)
{
    char *result;
d305 7
a311 101
    if (count >= links[cur].list.hl_len)
	result = NULL;
    else if (count > 0)
	result = links[cur].list.hl_info[count - 1].hl_text;
    else
	result = links[cur].list.hl_base.hl_text;
    return result;
}

/*
 * Get the X-ordinate at which to draw the corresponding highlight-text
 */
PUBLIC int LYGetHilitePos ARGS2(
	int,		cur,
	int,		count)
{
    int result;

    if (count >= links[cur].list.hl_len)
	result = -1;
    else if (count > 0)
	result = links[cur].list.hl_info[count - 1].hl_x;
    else
	result = links[cur].lx;
    return result;
}

#define LXP (links[cur].lx)
#define LYP (links[cur].ly)

#ifdef SHOW_WHEREIS_TARGETS

#define SKIP_GLYPHS(theFlag, theData, theOffset) \
	(theFlag \
	    ? LYmbcs_skip_glyphs(theData, (theOffset), theFlag) \
	    : (theData + (theOffset)))

/*
 * If we have an emphasized WHEREIS hit in the highlighted text, restore the
 * emphasis.  Note that we never emphasize the first and last characters of the
 * highlighted text when we are making the link current, so the link attributes
 * for the current link will persist at the beginning and end, providing an
 * indication to the user that it has been made current.  Also note that we use
 * HText_getFirstTargetInLine() to determine if there's a hit in the HText
 * structure line containing the link, and if so, get back a copy of the line
 * starting at that first hit (which might be before or after our link), and
 * with all IsSpecial characters stripped, so we don't need to deal with them
 * here.  -FM
 */
PRIVATE BOOL show_whereis_targets ARGS6(
	int,	flag,
	int,	cur,
	int,	count,
	char *,	target,
	BOOL,	TargetEmphasisON,
	BOOL,	utf_flag)
{
    char *Data = NULL;
    char *cp;
    char *theData = NULL;
    char buffer[MAX_LINE];
    char tmp[7];
    int HitOffset;
    int LenNeeded;
    int Offset;
    int tLen;

    tmp[0] = tmp[1] = tmp[2] = '\0';

    if (non_empty(target)
     && (links[cur].type & WWW_LINK_TYPE)
     && non_empty(LYGetHiliteStr(cur, count))
     && links[cur].ly + count < display_lines
     && HText_getFirstTargetInLine(HTMainText,
				   links[cur].anchor_line_num + count,
				   utf_flag,
				   &Offset,
				   &tLen,
				   &theData,
				   target)) {
	int itmp, written, len, y, offset;
	char *data;
	int tlen = strlen(target);
	int hlen, hLen;
	int hLine = links[cur].ly + count;
	int hoffset = LYGetHilitePos(cur, count);
	size_t utf_extra = 0;

	/*
	 * Copy into the buffer only what will fit up to the right border of
	 * the screen.  -FM
	 */
	LYmbcsstrncpy(buffer,
		      (LYGetHiliteStr(cur, count) ?
		       LYGetHiliteStr(cur, count) : ""),
		      (sizeof(buffer) - 1),
		      ((LYcols - 1) - LYGetHilitePos(cur, count)),
		      utf_flag);
	hlen = strlen(buffer);
	hLen = ((HTCJK != NOCJK || utf_flag) ?
	      LYmbcsstrlen(buffer, utf_flag, YES) : hlen);
a312 4
	/*
	 * Break out if the first hit in the line starts after this link.  -FM
	 */
	if (Offset < (hoffset + hLen)) {
d314 2
a315 2
	     * Recursively skip hits that end before this link, and break out
	     * if there is no hit beyond those.  -FM
d322 12
a333 6
		if (((cp = LYno_attr_mb_strstr(data,
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL)
		 && (offset + LenNeeded) < LYcols) {
d337 1
a337 1
		    goto highlight_search_done;
d344 4
a347 4
	     * If the hit starts before the hightext, and ends in or beyond the
	     * hightext, restore the emphasis, skipping the first and last
	     * characters of the hightext if we're making the link current.
	     * -FM
d356 2
a357 2
		 * Go to the start of the hightext and handle its first
		 * character.  -FM
d359 1
a359 1
		LYmove(hLine, offset);
d361 24
a384 1
		utf_extra = utf8_length(utf_flag, data + itmp);
d389 2
a390 2
		     * Start emphasis immediately if we are making the link
		     * non-current.  -FM
d395 1
a395 1
			LYaddstr(tmp);
d397 1
a397 1
			LYmove(hLine, (offset + 1));
d402 1
a402 1
		} else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d404 1
a404 1
		     * For CJK strings, by Masanobu Kimura.
d408 2
a409 2
		     * Start emphasis immediately if we are making the link
		     * non-current.  -FM
d414 1
a414 1
			LYaddstr(tmp);
d416 1
a416 1
			LYmove(hLine, (offset + 1));
d422 2
a423 2
		     * Start emphasis immediately if we are making the link
		     * non-current.  -FM
d428 1
a428 1
			LYaddstr(tmp);
d430 1
a430 1
			LYmove(hLine, (offset + 1));
d436 3
a438 2
		 * Start emphasis after the first character if we are making
		 * the link current and this is not the last character.  -FM
d447 1
a447 1
		 * Handle the remaining characters.  -FM
d453 4
a456 3
		     * Print all the other target chars, except the last
		     * character if it is also the last character of hightext
		     * and we are making the link current.  -FM
d458 24
a481 1
		    utf_extra = utf8_length(utf_flag, data + itmp);
d486 3
a488 3
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
d494 1
a494 1
			    LYmove(hLine, (offset + 1));
d496 1
a496 1
			    LYaddstr(tmp);
d501 1
a501 1
		    } else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d503 1
a503 1
			 * For CJK strings, by Masanobu Kimura.
d507 3
a509 3
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
d515 1
a515 1
			    LYmove(hLine, (offset + 1));
d517 1
a517 1
			    LYaddstr(tmp);
d523 3
a525 3
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
d531 1
a531 1
			    LYmove(hLine, (offset + 1));
d533 1
a533 1
			    LYaddstr(tmp);
d540 6
a545 4
		 * Stop the emphasis if we haven't already, then reset the
		 * offset to our current position in the line, and if that is
		 * beyond the link, or or we are making the link current and it
		 * is the last character of the hightext, we are done.  -FM
d552 30
a581 1
		if (offset < (hoffset + (flag == ON ? (hLen - 1) : hLen))
d583 3
a585 2
		     * See if we have another hit that starts within the
		     * hightext.  -FM
d587 6
a592 6
		 && ((cp = LYno_attr_mb_strstr(data = SKIP_GLYPHS(utf_flag, Data, offset - Offset),
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL)
		 && (offset + LenNeeded) < LYcols
d594 2
a595 10
		     * If the hit starts after the end of the hightext, or we
		     * are making the link current and the hit starts at its
		     * last character, we are done.  -FM
		     */
		 && (HitOffset + offset) <
		     (hoffset +
		      (flag == ON ? (hLen - 1) : hLen)))  {
		    /*
		     * Set up the data and offset for the hit, and let the code
		     * for within hightext hits handle it.  -FM
d603 1
a603 1
		goto highlight_search_done;
d608 22
a629 14
	     * If we get to here, the hit starts within the hightext.  If we
	     * are making the link current and it's the last character in the
	     * hightext, we are done.  Otherwise, move there and start
	     * restoring the emphasis.  -FM
	     */
	    if ((Offset - offset) <= (flag == ON ? (hLen - 1) : hLen))  {
		data = SKIP_GLYPHS(utf_flag, data, Offset - offset);
		if (utf_flag) {
		    LYrefresh();
		}
		offset = Offset;
		itmp = 0;
		written = 0;
		len = tlen;
d631 18
a648 10
		/*
		 * Go to the start of the hit and handle its first character.
		 * -FM
		 */
		LYmove(hLine, offset);
		tmp[0] = data[itmp];
		utf_extra = utf8_length(utf_flag, data + itmp);
		if (utf_extra) {
		    LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
		    itmp += utf_extra;
d650 1
a650 3
		     * Start emphasis immediately if we are making the link
		     * non-current, or we are making it current but this is not
		     * the first or last character of the hightext.  -FM
a651 10
		    if (flag != ON ||
			(offset > hoffset && data[itmp+1] != '\0')) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
		    }
		    tmp[1] = '\0';
		    written += (utf_extra + 1);
d653 2
a654 1
		} else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d656 1
a656 1
		     * For CJK strings, by Masanobu Kimura.
d658 17
a674 16
		    tmp[1] = data[++itmp];
		    /*
		     * Start emphasis immediately if we are making the link
		     * non-current, or we are making it current but this is not
		     * the first or last character of the hightext.  -FM
		     */
		    if (flag != ON ||
			(offset > hoffset && data[itmp+1] != '\0')) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 2));
		    }
		    tmp[1] = '\0';
		    written += 2;
d676 1
a676 14
		    /*
		     * Start emphasis immediately if we are making the link
		     * non-current, or we are making it current but this is not
		     * the first or last character of the hightext.  -FM
		     */
		    if (flag != ON ||
			(offset > hoffset && data[itmp+1] != '\0')) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
		    }
		    written++;
d678 4
a681 1
		itmp++;
d683 486
a1168 2
		 * Start emphasis after the first character if we are making
		 * the link current and this is not the last character.  -FM
d1176 3
d1183 4
a1186 3
		     * Print all the other target chars, except the last
		     * character if it is also the last character of hightext
		     * and we are making the link current.  -FM
d1188 24
a1211 1
		    utf_extra = utf8_length(utf_flag, data + itmp);
d1216 3
a1218 3
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
d1224 1
a1224 1
			    LYmove(hLine, (offset + 1));
d1226 1
a1226 1
			    LYaddstr(tmp);
d1231 1
a1231 1
		    } else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d1233 1
a1233 1
			 * For CJK strings, by Masanobu Kimura.
d1237 3
a1239 3
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
d1245 1
a1245 1
			    LYmove(hLine, (offset + 1));
d1247 1
a1247 1
			    LYaddstr(tmp);
d1253 3
a1255 3
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
d1261 1
a1261 1
			    LYmove(hLine, (offset + 1));
d1263 1
a1263 1
			    LYaddstr(tmp);
d1270 6
a1275 4
		 * Stop the emphasis if we haven't already, then reset the
		 * offset to our current position in the line, and if that is
		 * beyond the link, or we are making the link current and it is
		 * the last character in the hightext, we are done.  -FM
d1282 29
a1310 1
		if (offset < (hoffset + (flag == ON ? (hLen - 1) : hLen))
d1312 3
a1314 2
		     * See if we have another hit that starts within the
		     * hightext.  -FM
d1316 6
a1321 6
		 && ((cp = LYno_attr_mb_strstr(data = SKIP_GLYPHS(utf_flag, Data, offset - Offset),
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL)
		 && (offset + LenNeeded) < LYcols
d1323 2
a1324 3
		     * If the hit starts after the end of the hightext, or we
		     * are making the link current and the hit starts at its
		     * last character, we are done.  -FM
d1326 52
a1377 1
		 && (HitOffset + offset) < (hoffset + (flag == ON ? (hLen - 1) : hLen))) {
d1379 1
a1379 4
		     * If the target extends beyond our buffer, emphasize
		     * everything in the hightext starting at this hit.
		     * Otherwise, set up the data and offsets, and loop back.
		     * -FM
d1381 100
a1480 11
		    if ((HitOffset + (offset + tLen)) >= (hoffset + hLen)) {
			offset = (HitOffset + offset);
			data = SKIP_GLYPHS(utf_flag, Data, offset - hoffset);
			if (utf_flag) {
			    LYrefresh();
			}
			LYmove(hLine, offset);
			itmp = 0;
			written = 0;
			len = strlen(data);

d1482 1
a1482 1
			 * Turn the emphasis back on.  -FM
d1484 3
a1486 64
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			for (;
			     written < len && (tmp[0] = data[itmp]) != '\0';
			     itmp++)  {
			    /*
			     * Print all the other target chars, except the
			     * last character if it is also the last character
			     * of hightext and we are making the link current.
			     * -FM
			     */
			    utf_extra = utf8_length(utf_flag, data + itmp);
			    if (utf_extra) {
				LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
				itmp += utf_extra;
				/*
				 * Make sure we don't restore emphasis to the
				 * last character of hightext if we are making
				 * the link current.  -FM
				 */
				if (flag == ON && data[(itmp + 1)] == '\0') {
				    LYstopTargetEmphasis();
				    TargetEmphasisON = FALSE;
				    LYGetYX(y, offset);
				    LYmove(hLine, (offset + 1));
				} else {
				    LYaddstr(tmp);
				}
				tmp[1] = '\0';
				written += (utf_extra + 1);
				utf_extra = 0;
			    } else if (HTCJK != NOCJK && is8bits(tmp[0])) {
				/*
				 * For CJK strings, by Masanobu Kimura.
				 */
				tmp[1] = data[++itmp];
				/*
				 * Make sure we don't restore emphasis to the
				 * last character of hightext if we are making
				 * the link current.  -FM
				 */
				if (flag == ON && data[(itmp + 1)] == '\0') {
				    LYstopTargetEmphasis();
				    TargetEmphasisON = FALSE;
				} else {
				    LYaddstr(tmp);
				}
				tmp[1] = '\0';
				written += 2;
			    } else {
				/*
				 * Make sure we don't restore emphasis to the
				 * last character of hightext if we are making
				 * the link current.  -FM
				 */
				if (flag == ON && data[(itmp + 1)] == '\0') {
				    LYstopTargetEmphasis();
				    TargetEmphasisON = FALSE;
				} else {
				    LYaddstr(tmp);
				}
				written++;
			    }
			}
d1488 1
a1488 2
			 * Turn off the emphasis if we haven't already, and
			 * then we're done.  -FM
d1490 53
a1542 3
			if (TargetEmphasisON) {
			    LYstopTargetEmphasis();
			}
d1544 1
a1544 5
			Data = cp;
			Offset = (offset + HitOffset);
			data = buffer;
			offset = hoffset;
			goto highlight_hit_within_hightext;
d1546 1
a1548 7
	}
    }
highlight_search_done:
    FREE(theData);
    return TargetEmphasisON;
}
#endif /* SHOW_WHEREIS_TARGETS */
d1550 15
a1564 46
#ifdef USE_COLOR_STYLE
PRIVATE int find_cached_style ARGS2(
	int,	cur,
	int,	flag)
{
    int s = s_alink;

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
    if ( textfields_need_activation
     && links[cur].type == WWW_FORM_LINK_TYPE
     && F_TEXTLIKE(links[cur].l_form->type) )
	s = s_curedit;
#endif

    if (flag != ON) {
	int x;
	/*
	 * This is where we try to restore the original style when a link is
	 * unhighlighted.  The purpose of cached_styles[][] is to save the
	 * original style just for this case.  If it doesn't have a color
	 * change saved at just the right position, we look at preceding
	 * positions in the same line until we find one.
	 */
	if (LYP >= 0 && LYP < CACHEH && LXP >= 0 && LXP < CACHEW) {
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.off: cached style @@(%d,%d): ",
			  LYP, LXP));
	    s = cached_styles[LYP][LXP];
	    if (s == 0) {
		for (x = LXP-1; x >= 0; x--) {
		    if (cached_styles[LYP][x]) {
			if (cached_styles[LYP][x] > 0) {
			    s = cached_styles[LYP][x];
			    cached_styles[LYP][LXP] = s;
			}
			CTRACE((tfp, "found %d, x_offset=%d.\n",
				cached_styles[LYP][x], (int)x-LXP));
			break;
		    }
		}
		if (s == 0) {
		    CTRACE((tfp, "not found, assume <a>.\n"));
		    s = s_a;
		}
	    } else {
		CTRACE((tfp, "found %d.\n", s));
a1565 71
	} else {
	    CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.off: can't use cache.\n"));
	    s = s_a;
	}
    } else {
	CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.on: @@(%d,%d).\n", LYP, LXP));
    }
    return s;
}
#endif /* USE_COLOR_STYLE */

/*
 *  Highlight (or unhighlight) a given link.
 */
PUBLIC void LYhighlight ARGS3(
	int,		flag,
	int,		cur,
	char *,		target)
{
    char buffer[MAX_LINE];
    int i;
    int hi_count;
    int hi_offset;
    char tmp[7];
    char *hi_string;
#ifdef SHOW_WHEREIS_TARGETS
    BOOL TargetEmphasisON = FALSE;
    BOOL target1_drawn = NO;
#endif
    BOOL utf_flag = (BOOL)(LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8);
    BOOL hl1_drawn = NO;
#ifdef USE_COLOR_STYLE
    BOOL hl2_drawn = FALSE;	/* whether links[cur].l_hightext2 is already drawn
				   properly */
#endif
    tmp[0] = tmp[1] = tmp[2] = '\0';

    /*
     * Bugs in the history code might cause -1 to be sent for cur, which yields
     * a crash when LYstrncpy() is called with a nonsense pointer.  As far as I
     * know, such bugs have been squashed, but if they should reappear, this
     * works around them.  -FM
     */
    if (cur < 0)
	cur = 0;
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
    if (flag == OFF)
	textinput_redrawn = FALSE;
#endif

    if (nlinks > 0) {
#ifdef USE_COLOR_STYLE
	if (flag == ON || links[cur].type == WWW_FORM_LINK_TYPE) {
	    LYmove(LYP, LXP);
	    LynxChangeStyle(find_cached_style(cur, flag), STACK_ON);
	}
#else
	if (links[cur].type == WWW_FORM_LINK_TYPE
	 || LYGetHiliteStr(cur, 0) == NULL) {
	    LYMoveToLink(cur, target, NULL,
			 flag, links[cur].inUnderline, utf_flag);
	    lynx_start_link_color (flag == ON, links[cur].inUnderline);
	} else {
	    LYMoveToLink(cur, target, LYGetHiliteStr(cur, 0),
			 flag, links[cur].inUnderline, utf_flag);
	    hl1_drawn = YES;
#ifdef SHOW_WHEREIS_TARGETS
	    target1_drawn = YES;
#endif
	}
#endif
a1566 24
	if (links[cur].type == WWW_FORM_LINK_TYPE) {
	    int len;
	    int avail_space = (LYcols - links[cur].lx) - 1;
	    char *text = LYGetHiliteStr(cur, 0);

	    if (avail_space > links[cur].l_form->size)
		avail_space = links[cur].l_form->size;
	    if (avail_space > (int) sizeof(buffer) - 1)
		avail_space = (int) sizeof(buffer) - 1;

	    LYstrncpy(buffer, NonNull(text), avail_space);
	    LYaddstr(buffer);

	    len = strlen(buffer);
	    for (; len < links[cur].l_form->size && len < avail_space; len++)
		LYaddch('_');

#ifdef USE_COLOR_STYLE
	} else if (flag == OFF) {
	    hl2_drawn = TRUE;
	    redraw_lines_of_link(cur);
	    CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.off: NOFIX branch @@(%d,%d).\n", LYP, LXP));
#endif
	} else if (!hl1_drawn) {
d1568 2
a1569 2
	     * Copy into the buffer only what will fit within the width of the
	     * screen.
d1571 51
a1621 8
	    LYmbcsstrncpy(buffer,
			  (LYGetHiliteStr(cur, 0) ?
			   LYGetHiliteStr(cur, 0) : ""),
			  (sizeof(buffer) - 1),
			  ((LYcols - 1) - links[cur].lx),
			  utf_flag);
	    LYaddstr(buffer);
	}
d1623 73
a1695 35
	/*
	 *  Display a second line as well.
	 */
#ifdef USE_COLOR_STYLE
	if (hl2_drawn == FALSE)
#endif
	{
	    for (hi_count = 1;
		    (hi_string = LYGetHiliteStr(cur, hi_count)) != NULL
		    && links[cur].ly + hi_count <= display_lines;
			++hi_count) {

		hi_offset = LYGetHilitePos(cur, hi_count);
		lynx_stop_link_color (flag == ON, links[cur].inUnderline);
		LYmove(links[cur].ly + hi_count, hi_offset);

#ifdef USE_COLOR_STYLE
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.highlight.line2: @@(%d,%d), style=%d.\n",
			      links[cur].ly + hi_count, hi_offset,
			      flag == ON ? s_alink : s_a));
		LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_ON);
#else
		lynx_start_link_color (flag == ON, links[cur].inUnderline);
#endif

		for (i = 0; (tmp[0] = hi_string[i]) != '\0'
			   && (i + hi_offset) < LYcols; i++) {
		    if (!IsSpecialAttrChar(hi_string[i])) {
			/*
			 * For CJK strings, by Masanobu Kimura.
			 */
			if (HTCJK != NOCJK && is8bits(tmp[0])) {
			    tmp[1] = hi_string[++i];
			    LYaddstr(tmp);
d1697 1
d1699 12
a1710 1
			    LYaddstr(tmp);
d1712 15
a1726 1
		     }
d1729 1
a1729 13
	    lynx_stop_link_color (flag == ON, links[cur].inUnderline);
	}

#ifdef SHOW_WHEREIS_TARGETS
	for (hi_count = target1_drawn ? 1 : 0;
		LYGetHiliteStr(cur, hi_count) != NULL;
			hi_count++) {
	    TargetEmphasisON = show_whereis_targets(flag,
						    cur,
						    hi_count,
						    target,
						    TargetEmphasisON,
						    utf_flag);
d1731 2
d1738 1
a1738 1
	    LYHideCursor();
d1740 1
a1740 1
#endif /* SHOW_WHEREIS_TARGETS */
d1744 1
a1744 1
	    LYmove(links[cur].ly,
d1748 1
a1748 1
	    LYrefresh();
d1779 1
a1779 1
    char *ns;
d1782 1
a1782 1
    if (!s)
a1784 4
    for ( ; (*s && !isspace(*s)); s++)
	;
    ns = s;

d1835 1
a1835 1
    char buffer[MAX_LINE];
a1838 2
    char *p;
    char text_buff[MAX_LINE];
a1858 6
    /* "LYNXDOWNLOAD://Method=-1/File=%s/SugFile=%s%s\">Save to disk</a>\n" */
    LYstrncpy(text_buff, text, sizeof(text_buff)-1);
    p = strchr(text_buff, '\n');
    if (p)
	p= '\0';

d1866 1
a1866 1
    if ((text_buff[0] != '\0') &&
d1871 1
a1871 1
	if ((temp = typecallocn(unsigned char, strlen(text_buff) + 1)) == NULL)
d1874 1
a1874 1
	    TO_EUC((CONST unsigned char *)text_buff, temp);
d1876 1
a1876 8
#ifdef KANJI_CODE_OVERRIDE
	    if (!LYRawMode || last_kcode == SJIS)
		strcpy(temp, text_buff);
	    else
		TO_SJIS((CONST unsigned char *)text_buff, temp);
#else
	    strcpy((char *) temp, text_buff);
#endif
d1878 3
a1880 3
	    for (i = 0, j = 0; text_buff[i]; i++) {
		if (text_buff[i] != CH_ESC) {  /* S/390 -- gil -- 2119 */
		    temp[j++] = text_buff[i];
d1921 3
a1923 3
	for (i = 0, len = 0; text_buff[i] != '\0' && len < max_length; i++) {
	    if (text_buff[i] != CH_ESC) {  /* S/390 -- gil -- 2119 */
		buffer[len++] = text_buff[i];
d1939 1
a1939 1
	    LYmove(LYStatusLine, 0);
d1941 1
a1941 1
	    LYmove(LYlines-1, 0);
d1944 1
a1944 1
	LYmove(LYlines-3, 0);
d1946 1
a1946 1
	LYmove(LYlines-1, 0);
d1948 1
a1948 2
    LYclrtoeol();

a1949 12
	BOOLEAN has_CJK = FALSE;

	if (HTCJK != NOCJK) {
	    for (i = 0; buffer[i] != '\0'; i++) {
		if (buffer[i] & 0x80) {
		    has_CJK = TRUE;
		    break;
		}
	    }
	}

	if (has_CJK
d1951 2
a1952 4
	    || (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8)
#endif
	    ) {
	    LYrefresh();
d1954 1
a1954 1

d1957 1
a1957 1
	LYaddstr (buffer);
d1962 5
a1966 7
		int a = (strncmp(buffer, ALERT_FORMAT, ALERT_PREFIX_LEN)
			|| !hashStyles[s_alert].name)
			? s_status
			: s_alert;
		LynxChangeStyle (a, STACK_ON);
		LYaddstr(buffer);
		wbkgdset(LYwin,
d1970 1
a1970 1
		LYclrtoeol();
d1972 1
a1972 1
		    wbkgdset(LYwin, A_NORMAL | ' ');
d1974 1
a1974 1
		    wbkgdset(LYwin, hashStyles[s_normal].color | ' ');
d1976 2
a1977 2
		    wbkgdset(LYwin, displayStyles[DSTYLE_NORMAL].color | ' ');
		LynxChangeStyle (a, STACK_OFF);
d1981 1
a1981 1
    LYrefresh();
d2018 1
a2018 1
    LYmove(LYlines-2,0);
d2020 4
a2023 3
    LYclrtoeol();
    LYaddstr(NOVICE_LINE_ONE);
    LYclrtoeol();
d2026 1
a2026 1
	LYaddstr(DIRED_NOVICELINE);
d2031 1
a2031 1
	LYaddstr(NOVICE_LINE_TWO);
d2033 1
a2033 1
	LYaddstr((char *)novice_lines(lineno));
d2035 1
a2035 1
    LYrefresh();
d2039 1
a2039 1
#if defined(NSL_FORK) || defined(MISC_EXP)
d2054 1
a2054 1
#if ((SLANG_VERSION >= 9919) && defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__))
d2074 1
a2074 1
#endif /* NSL_FORK || MISC_EXP */
d2082 1
a2082 1
	CTRACE((tfp, "\r *** Set simulated 'Z'"));
d2084 2
a2085 2
	    CTRACE((tfp, ", %d pending", fake_zap));
	CTRACE((tfp, " ***\n"));
d2088 3
a2090 3
	CTRACE((tfp, "\r *** Unset simulated 'Z'"));
	CTRACE((tfp, ", %d pending", fake_zap));
	CTRACE((tfp, " ***\n"));
a2104 7
    if (LYHaveCmdScript()) /* we may be running from a script */
	return(TRUE);

#ifdef MISC_EXP
    if (LYNoZapKey)
	return(TRUE);
#endif
d2109 1
a2109 2
#ifdef HAVE_GETTIMEOFDAY
#undef timezone			/* U/Win defines a conflicting macro */
a2127 1
    int cmd;
d2129 1
a2129 1
#if !defined(USE_SLANG) && (defined(UNIX) || defined(__DJGPP__))
d2137 1
a2137 1
	CTRACE((tfp, "\r *** Got simulated 'Z' ***\n"));
a2146 1
#if !defined(_WINDOWS) || defined(__MINGW32__)
d2162 1
a2162 1
    socket_timeout.tv_usec = 0;
d2175 1
a2175 1
    if ((ret == -1) && (SOCKET_ERRNO == EINTR))
a2181 1
#endif /* !_WINDOWS */
d2183 3
a2185 3
#if defined(PDCURSES)
    nodelay(LYwin,TRUE);
#endif /* PDCURSES */
d2190 3
a2192 3
#if defined(PDCURSES)
    nodelay(LYwin,FALSE);
#endif /* PDCURSES */
d2199 1
a2199 1
	CTRACE((tfp, "\r *** Got simulated 'Z' ***\n"));
d2207 1
a2207 1
	return((int)FALSE);
d2227 1
a2227 1
    if (LYCharIsINTERRUPT(c))
d2231 2
a2232 3
	** no new getfile() cycle is possible until the previous finished.
	** Currently we have scrolling in partial mode, toggling of trace
	** log, and pasting. User search now in progress...
d2234 8
a2241 8
    cmd = (LKC_TO_LAC(keymap,c));
    switch (cmd) {
    case LYK_TRACE_TOGGLE :	/*  Toggle TRACE mode. */
	handle_LYK_TRACE_TOGGLE();
	break;
#ifdef CAN_CUT_AND_PASTE
    case LYK_TO_CLIPBOARD: {	/* ^S */
	char *s = LYDownLoadAddress();
a2242 8
	if (!s || !*s || put_clip(s))
	    HTInfoMsg(gettext("Copy to clipboard failed."));
	else
	    HTInfoMsg(gettext("Download document URL put to clipboard."));
	break;
    }
#endif	/* defined CAN_CUT_AND_PASTE */
    default :
d2244 1
d2246 1
a2246 2
	if (display_partial && (NumOfLines_partial > 2)) {
	    BOOLEAN do_refresh;
d2248 2
a2249 13
	    int Newline_partial = LYGetNewline();

	    switch (cmd) {
	    case LYK_WHEREIS:	/* search within the document */
	    case LYK_NEXT:	/* search for the next occurrence in the document */
	    case LYK_PREV:	/* search for the previous occurrence in the document */
		handle_LYK_WHEREIS(cmd, &do_refresh);
		if (www_search_result != -1) {
		    Newline_partial = www_search_result;
		    www_search_result = -1;	/* reset */
		}
		break;

d2317 2
a2318 2
	    if (LYMainLoop_pageDisplay(Newline_partial))
		NumOfLines_partial = HText_getNumOfLines();
a2327 39
 * Check if the given filename looks like it's an absolute pathname, i.e.,
 * references a directory.
 */
PUBLIC BOOLEAN LYisAbsPath ARGS1(
	CONST char *,	path)
{
    BOOLEAN result = FALSE;
    if (non_empty(path)) {
#ifdef VMS
	result = TRUE;
#else
#if defined(USE_DOS_DRIVES)
	result = (BOOL) (LYIsPathSep(path[0])
	 || (LYIsDosDrive(path)
	   && LYIsPathSep(path[2])));
#else
	result = (LYIsPathSep(path[0]));
#endif /* USE_DOS_DRIVES */
#endif
    }
    return result;
}

/*
 * Check if the given filename is the root path, e.g., "/" on Unix.
 */
PUBLIC BOOLEAN LYisRootPath ARGS1(
	CONST char *,		path)
{
#if defined(USE_DOS_DRIVES)
    if (strlen(path) == 3
     && LYIsDosDrive(path)
     && LYIsPathSep(path[2]))
	return TRUE;
#endif
    return (BOOL) ((strlen(path) == 1) && LYIsPathSep(path[0]));
}

/*
d2332 1
a2332 1
	CONST char *,		filename)
d2347 1
a2347 1
    if ((cp = strchr(host, ':')) != NULL)
d2353 6
a2358 1
	     LYSameFilename(host, HTHostName()))) {
d2375 1
a2375 1
	CONST char *,		filename)
d2392 12
a2403 5
    if ((LYSameFilename(host, "localhost") ||
	 LYSameFilename(host, LYHostName) ||
	 LYSameFilename(host, HTHostName()))) {
	FREE(host);
	return YES;
d2435 1
a2435 1
    char *LocalAlias = NULL;
d2437 1
a2437 1
    if (!non_empty(alias))
d2447 3
a2449 1
    StrAllocCopy(LocalAlias, alias);
d2460 1
a2460 1
	CONST char *,		filename)
d2480 6
a2485 1
	if (LYSameFilename(host, alias)) {
d2516 1
a2516 1
    if (isEmpty(cp))
d2531 1
a2531 1
	if (LYGetEnv(cp2) != NULL) {
d2536 3
a2538 3
#if defined (USE_DOS_DRIVES)
	if (LYIsDosDrive(cp))
	    return(NOT_A_URL_TYPE);
d2543 2
a2544 2
	} else if (isdigit(UCH(*cp1))) {
	    while (*cp1 && isdigit(UCH(*cp1)))
a2575 6
#define DoubleHtmlSep(s) (LYIsHtmlSep((s)[0]) && LYIsHtmlSep((s)[1]))
#define compare_two(tst,cmp,len,limit) \
	((len + 2) <= limit \
	&& DoubleHtmlSep(tst + len) \
	&& compare_type(tst, cmp, len))

a2592 3
    int result = NOT_A_URL_TYPE;
    int len;
    int limit;
d2597 2
a2598 2
    if (isEmpty(cp))
	return(result);
d2604 1
a2604 1
	return(result);
d2618 23
a2640 2
    if (*cp == ':' || LYIsHtmlSep(*cp)) {
	result = NOT_A_URL_TYPE;
d2642 11
a2652 16
    } else {
	limit = strlen(cp);
	switch (*cp) {
	case 'L':
	case 'l':
	    /*
	     *  Lynx internal pages ("LYNXfoo:" or "lynxfoo:")
	     *  start with 'l' or 'L', other URLs aren't.
	     */
	    if (compare_type(cp, STR_LYNXEXEC, LEN_LYNXEXEC)) {
		/*
		 *  Special External Lynx type to handle execution
		 *  of commands or scripts which require a pause to
		 *  read the screen upon completion.
		 */
		result = LYNXEXEC_URL_TYPE;
d2654 2
a2655 7
	    } else if (compare_type(cp, STR_LYNXPROG, LEN_LYNXPROG)) {
		/*
		 *  Special External Lynx type to handle execution
		 *  of commands, scripts or programs with do not
		 *  require a pause to read screen upon completion.
		 */
		result = LYNXPROG_URL_TYPE;
d2657 8
a2664 5
	    } else if (compare_type(cp, STR_LYNXCGI, LEN_LYNXCGI)) {
		/*
		 *  Special External Lynx type to handle cgi scripts.
		 */
		result = LYNXCGI_URL_TYPE;
d2666 2
a2667 5
	    } else if (compare_type(cp, STR_LYNXPRINT, LEN_LYNXPRINT)) {
		/*
		 *  Special Internal Lynx type.
		 */
		result = LYNXPRINT_URL_TYPE;
d2669 7
a2675 5
	    } else if (compare_type(cp, STR_LYNXOPTIONS, LEN_LYNXOPTIONS)) {
		/*
		 *  Special Internal Lynx type.
		 */
		result = LYNXOPTIONS_URL_TYPE;
d2677 7
a2683 5
	    } else if (compare_type(cp, STR_LYNXCFG, LEN_LYNXCFG)) {
		/*
		 *  Special Internal Lynx type.
		 */
		result = LYNXCFG_URL_TYPE;
d2685 5
a2689 5
	    } else if (compare_type(cp, STR_LYNXMESSAGES, LEN_LYNXMESSAGES)) {
		/*
		 *  Special Internal Lynx type.
		 */
		result = LYNXMESSAGES_URL_TYPE;
d2691 5
a2695 5
	    } else if (compare_type(cp, STR_LYNXCFLAGS, LEN_LYNXCFLAGS)) {
		/*
		 *  Special Internal Lynx type.
		 */
		result = LYNXCOMPILE_OPTS_URL_TYPE;
d2697 5
a2701 5
	    } else if (compare_type(cp, STR_LYNXDOWNLOAD, LEN_LYNXDOWNLOAD)) {
		/*
		 *  Special Internal Lynx type.
		 */
		result = LYNXDOWNLOAD_URL_TYPE;
d2703 5
a2707 5
	    } else if (compare_type(cp, STR_LYNXDIRED, LEN_LYNXDIRED)) {
		/*
		 *  Special Internal Lynx type.
		 */
		result = LYNXDIRED_URL_TYPE;
d2709 5
a2713 5
	    } else if (compare_type(cp, STR_LYNXHIST, LEN_LYNXHIST)) {
		/*
		 *  Special Internal Lynx type.
		 */
		result = LYNXHIST_URL_TYPE;
d2715 5
a2719 5
	    } else if (compare_type(cp, STR_LYNXKEYMAP, LEN_LYNXKEYMAP)) {
		/*
		 *  Special Internal Lynx type.
		 */
		result = LYNXKEYMAP_URL_TYPE;
d2721 5
a2725 7
	    } else if (compare_type(cp, STR_LYNXIMGMAP, LEN_LYNXIMGMAP)) {
		/*
		 *  Special Internal Lynx type.
		 */
		/* force lower/uppercase of next part */
		(void)is_url(&cp[LEN_LYNXIMGMAP]);
		result = LYNXIMGMAP_URL_TYPE;
d2727 5
a2731 15
	    } else if (compare_type(cp, STR_LYNXCOOKIE, LEN_LYNXCOOKIE)) {
		/*
		 *  Special Internal Lynx type.
		 */
		result = LYNXCOOKIE_URL_TYPE;
	    }
	    break;
#ifndef DISABLE_NEWS
	    /*
	     *  NEWSfoo: schemes -
	     */
	case 'N':
	case 'n':
	    if (compare_type(cp, STR_NEWS_URL, LEN_NEWS_URL)) {
		result = NEWS_URL_TYPE;
d2733 5
a2737 2
	    } else if (compare_type(cp, STR_NNTP_URL, LEN_NNTP_URL)) {
		result = NNTP_URL_TYPE;
d2739 5
a2743 5
	    } else if (compare_type(cp, "newspost:", 9)) {
		/*
		 *  Special Lynx type to handle news posts.
		 */
		result = NEWSPOST_URL_TYPE;
d2745 6
a2750 7
	    } else if (compare_type(cp, "newsreply:", 10)) {
		/*
		 *  Special Lynx type to handle news replies (followups).
		 */
		result = NEWSREPLY_URL_TYPE;
	    }
	    break;
d2752 5
a2756 7
	    /*
	     *  SNEWSfoo: schemes -
	     */
	case 'S':
	case 's':
	    if (compare_type(cp, STR_SNEWS_URL, LEN_SNEWS_URL)) {
		result = SNEWS_URL_TYPE;
d2758 8
a2765 5
	    } else if (compare_type(cp, "snewspost:", 10)) {
		/*
		 *  Special Lynx type to handle snews posts.
		 */
		result = NEWSPOST_URL_TYPE;
d2767 2
a2768 14
	    } else if (compare_type(cp, "snewsreply:", 11)) {
		/*
		 *  Special Lynx type to handle snews replies (followups).
		 */
		result = NEWSREPLY_URL_TYPE;
	    }
	    break;
#endif
	case 'M':
	case 'm':
	    if (compare_type(cp, STR_MAILTO_URL, LEN_MAILTO_URL)) {
		result = MAILTO_URL_TYPE;
	    }
	    break;
d2770 2
a2771 20
	case 'F':
	case 'f':
	    if (compare_type(cp, STR_FILE_URL, len = LEN_FILE_URL)) {
		if (LYisLocalFile(cp)) {
		    result = FILE_URL_TYPE;
		} else if (DoubleHtmlSep(cp + len)) {
		    result = FTP_URL_TYPE;
		}
	    }
#ifndef DISABLE_FTP
	    else if (compare_two(cp, STR_FTP_URL, LEN_FTP_URL, limit)) {
		result = FTP_URL_TYPE;
	    }
#endif
#ifndef DISABLE_FINGER
	    else if (compare_two(cp, STR_FINGER_URL, LEN_FINGER_URL, limit)) {
		result = FINGER_URL_TYPE;
	    }
#endif
	    break;
d2773 2
a2774 8
	case 'B':
	case 'b':
#ifndef DISABLE_BIBP
	    if (compare_type(cp, STR_BIBP_URL, LEN_BIBP_URL)) {
		result = BIBP_URL_TYPE;
	    }
#endif
	    break;
d2776 12
a2787 6
	case 'D':
	case 'd':
	    if (compare_type(cp, "data:", 5)) {
		result = DATA_URL_TYPE;
	    }
	    break;
d2789 2
a2790 15
	default:
	    if (limit >= 3
	    && ((cp1 = strchr(cp + 3, ':')) == NULL
	     || !DoubleHtmlSep(cp1 + 1))) {
		/*
		 * If it doesn't contain "://", and it's not one of the the
		 * above, it can't be a URL with a scheme we know, so check if
		 * it's an unknown scheme for which proxying has been set up.
		 * - FM
		 */
		if (cp1 != NULL
		 && (cp1 - cp) > 1	/* exclude DOS-style device:/path */
		 && LYisAbsPath(cp1+1)) {
		    result = NCFTP_URL_TYPE;
		}
d2792 2
a2793 6
	    } else {
		switch (*cp) {
		case 'H':
		case 'h':
		    if (compare_type(cp, STR_HTTP_URL, LEN_HTTP_URL)) {
			result = HTTP_URL_TYPE;
d2795 2
a2796 4
		    } else if (compare_type(cp, STR_HTTPS_URL, LEN_HTTPS_URL)) {
			result = HTTPS_URL_TYPE;
		    }
		    break;
d2798 2
a2799 28
#ifndef DISABLE_GOPHER
		case 'G':
		case 'g':
		    if (compare_type(cp, STR_GOPHER_URL, LEN_GOPHER_URL)) {
			if (strlen(cp) >= 11
			 && (cp1 = strchr(cp+11,'/')) != NULL) {

			    if (TOUPPER(*(cp1+1)) == 'H' || *(cp1+1) == 'w')
				/* if this is a gopher html type */
				result = HTML_GOPHER_URL_TYPE;
			    else if (*(cp1+1) == 'T' || *(cp1+1) == '8')
				result = TELNET_GOPHER_URL_TYPE;
			    else if (*(cp1+1) == '7')
				result = INDEX_GOPHER_URL_TYPE;
			    else
				result = GOPHER_URL_TYPE;
			} else {
			    result = GOPHER_URL_TYPE;
			}
		    }
		    break;
#endif
		case 'W':
		case 'w':
		    if (compare_type(cp, STR_WAIS_URL, LEN_WAIS_URL)) {
			result = WAIS_URL_TYPE;
		    }
		    break;
d2801 2
a2802 4
		case 'T':
		case 't':
		    if (compare_type(cp, STR_TELNET_URL, LEN_TELNET_URL)) {
			result = TELNET_URL_TYPE;
d2804 2
a2805 4
		    } else if (compare_type(cp, STR_TN3270_URL, LEN_TN3270_URL)) {
			result = TN3270_URL_TYPE;
		    }
		    break;
d2807 2
a2808 6
		case 'R':
		case 'r':
		    if (compare_type(cp, STR_RLOGIN_URL, LEN_RLOGIN_URL)) {
			result = RLOGIN_URL_TYPE;
		    }
		    break;
d2810 2
a2811 6
		case 'C':
		case 'c':
		    if (compare_type(cp, STR_CSO_URL, LEN_CSO_URL)) {
			result = CSO_URL_TYPE;
		    }
		    break;
d2813 2
a2814 6
		case 'A':
		case 'a':
		    if (compare_type(cp, "afs:", 4)) {
			result = AFS_URL_TYPE;
		    }
		    break;
d2816 1
a2816 9
		case 'P':
		case 'p':
		    if (compare_type(cp, "prospero:", 9)) {
			result = PROSPERO_URL_TYPE;
		    }
		    break;
		}
	    }
	}
d2818 2
a2819 1
	 * Check if it is an unknown scheme for which proxying has been set up.
d2821 1
a2821 67
	if (result == NOT_A_URL_TYPE)
	    result = LYCheckForProxyURL(filename);
    }
    return result;
}

/*
 *  Sometimes it is just expected that curses is on when an alert or
 *  other statusline message needs to be shown and we are not just
 *  dumping immediately.  Calling this will 'fix' it, but may not
 *  always be appropriate. - kw
 */
PUBLIC void LYFixCursesOn ARGS1(
    CONST char *,	reason)
{
    if (dump_output_immediately || LYCursesON)
	return;
    if (reason) {
	CTRACE((tfp, "Forcing curses on to %s\n", reason));
    }
    start_curses();
}

/*
 *  Most protocol modules called through HTLoad* expect that curses is on
 *  unless dump_output_immediately is set, so that statusline messages
 *  can be shown.  Some protocols expect the opposite, namely telnet and
 *  friends.  This function should be called after the 'physical' URL
 *  for accessing addr has been established.  It does the right thing
 *  to the degree that curses is turned on for known problem cases.
 *  In any normal circumstances this should never apply, but proxying
 *  or rule substitution is not prevented for telnet-like URLs, and
 *  this 'fix' avoids some crashes that can otherwise occur. - kw
 */
PUBLIC BOOLEAN LYFixCursesOnForAccess ARGS2(
    CONST char *,	addr,
    CONST char *,	physical)
{
    /*
     *  If curses is off when maybe it shouldn't...
     */
    if (!dump_output_immediately && !LYCursesON && physical) {
	char *cp1;
	/*
	 *  If requested resource wants to be accessed with curses off, and
	 *  getfile() would indeed have turned curses off for it...
	 */
	if (strstr(addr, "://") != NULL &&
	    (isTELNET_URL(addr) ||
	     isRLOGIN_URL(addr) ||
	     isTN3270_URL(addr) ||
	     (!isGOPHER_URL(addr) &&
	      (cp1 = strchr(addr+11,'/')) != NULL &&
	      (*(cp1+1) == 'T' || *(cp1+1) == '8')))) {
	    /*
	     *  If actual access that will be done is ok with curses off,
	     *  then do nothing special, else force curses on. - kw
	     */
	    if (!isTELNET_URL(physical) &&
		!isRLOGIN_URL(physical) &&
		!isTN3270_URL(physical)) {
		start_curses();
		HTAlert(
		    gettext("Unexpected access protocol for this URL scheme."));
		return TRUE;
	    }
	}
a2822 1
	return FALSE;
d2829 2
a2830 1
    CONST char *,	address)
d2834 1
a2834 1
    if (!non_empty(address))
d2841 2
a2842 2
    if (!isurl) {
	FREE(temp0);
a2843 1
    }
a2844 1
	FREE(temp0);
a2850 5
    /*
     *  The idea of the following is to allow HEAD for news URLs that
     *  identify single articles, not those that identify ranges of
     *  articles or groups or a list of groups. - kw
     */
a2854 1
	    FREE(temp0);
d2858 1
a2858 2
	if (cp && isdigit(UCH(cp[1])) && strchr(cp, '-') == NULL) {
	    FREE(temp0);
a2863 88

#define ALLOW_PROXY_HEAD
/*  If defined, also allow head requests for URLs proxied through the
 *  "http" or "lynxcgi" protocols, which understand HEAD.  Only the
 *  proxy environment variables are checked, not the HTRules system. - kw
 */
#ifdef ALLOW_PROXY_HEAD
    if (isurl != FILE_URL_TYPE) {
	char *acc_method = HTParse(temp0, "", PARSE_ACCESS);
	if (non_empty(acc_method)) {
	    char *proxy;
	    StrAllocCat(acc_method, "_proxy");
	    proxy = LYGetEnv(acc_method);
	    if (proxy && (isHTTP_URL(proxy) ||
			  isLYNXCGI(proxy)) &&
		!override_proxy(temp0)) {
		FREE(temp0);
		FREE(acc_method);
		return TRUE;
	    }
	}
	FREE(acc_method);
    }
#endif /* ALLOW_PROXY_HEAD */

    FREE(temp0);
    return FALSE;
}

/*
 * Close an input file.
 */
PUBLIC BOOLEAN LYCloseInput ARGS1(
	FILE *,		fp)
{
    if (fp != 0) {
	int err = ferror(fp);
	fclose(fp);
	if (!err) {
	    return TRUE;
	}
    }
    return FALSE;
}

/*
 * Close an output file, reporting any problems with writing to it.
 */
PUBLIC BOOLEAN LYCloseOutput ARGS1(
	FILE *,		fp)
{
    if (fp != 0) {
	int err = ferror(fp);
	fclose(fp);
	if (!err) {
	    return TRUE;
	}
    }
    HTAlert(CANNOT_WRITE_TO_FILE);
    return FALSE;
}

/*
 * Test if we'll be able to write a file.  If not, warn the user.
 */
PUBLIC BOOLEAN LYCanWriteFile ARGS1(
	CONST char*,	filename)
{
    if (LYCloseOutput(fopen(filename, "w"))) {
	remove(filename);
	return TRUE;
    } else {
	_statusline(NEW_FILENAME_PROMPT);
	return FALSE;
    }
}

/*
 * Test if we'll be able to read a file.
 */
PUBLIC BOOLEAN LYCanReadFile ARGS1(
	CONST char*,	filename)
{
    FILE *fp;

    if ((fp = fopen(filename, "r")) != 0) {
	return LYCloseInput(fp);
    }
d2890 4
d2901 3
a2903 1
#ifdef HAVE_UTMP
d2909 1
a2909 1
    if ((cp = ttyname(0)))
d2912 12
a2923 12
    if (mytty && (fp = fopen(UTMP_FILE, "r")) != NULL) {
	mytty++;
	do {
	    n = fread((char *) &me, sizeof(struct utmp), 1, fp);
	} while (n > 0 && !STREQ(me.ut_line, mytty));
	(void) LYCloseInput(fp);

	if (n > 0 &&
	    strlen(me.ut_host) > strlen(LYLocalDomain) &&
	    STREQ(LYLocalDomain,
		  me.ut_host + strlen(me.ut_host) - strlen(LYLocalDomain)) )
	    return(TRUE);
d2926 2
a2927 2
	if ((n > 0) && (strlen(me.ut_host) == 0))
	    return(TRUE);
d2931 1
a2931 2
	CTRACE((tfp, "Could not get ttyname (returned %s) or open UTMP file %s\n",
		      (cp != 0) ? cp : "<null>", UTMP_FILE));
d2935 1
a2935 79
#else
    CTRACE((tfp, "LYUtils: inlocaldomain() not support.\n"));
    return(TRUE);
#endif /* HAVE_UTMP */
}

#ifdef HAVE_SIGACTION
/*
 *  An extended alternative for calling signal(), sets some flags for
 *  signal handler as we want them if that functionality is available.
 *  (We don't return anything from this function since the return
 *  value would currently be ignored anyway.) - kw
 *
 */
PUBLIC void LYExtSignal ARGS2(
    int,			sig,
    LYSigHandlerFunc_t *,	handler)
{
#ifdef SIGWINCH
    /* add more cases to if(condition) if required... */
    if (sig == SIGWINCH && LYNonRestartingSIGWINCH) {
	struct sigaction act;
	act.sa_handler = handler;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
#ifdef SA_RESTART
	if (sig != SIGWINCH)
	    act.sa_flags |= SA_RESTART;
#endif /* SA_RESTART */
	sigaction(sig, &act, NULL);
    } else
#endif /* defined(SIGWINCH) */
	signal(sig, handler);
}
#endif /* HAVE_SIGACTION */

#if defined(SIGTSTP) && !defined(USE_SLANG)
#ifdef HAVE_SIGACTION
/*
 *  For switching a signal's handling between SIG_DFL and something
 *  (possibly) different that may have been set up by lynx code or
 *  e.g. by curses library.  Uses sigaction to preserve / restore as
 *  much state as possible.
 *  Second arg is where to save or restore from.
 *  Third arg to_dfl specifies what to do:
 *	1	Save current state in where, set handling to SIG_DFL
 *	0	Restore current state to previously saved one in where
 *
 *  Currently only used for SIGTSTP without SLANG, to prevent (n)curses
 *  signal handler from running while lynx is waiting in system() for
 *  an interactive command like an editor. - kw
 */
PRIVATE BOOLEAN LYToggleSigDfl ARGS3(
    int,			sig,
    struct sigaction *,		where,
    int,			to_dfl)
{
    int rv = -1;
    struct sigaction oact;

    if (to_dfl == 1) {
	rv = sigaction(sig, NULL, &oact);
	if (rv == 0) {
	    if (oact.sa_handler != SIG_DFL) {
		oact.sa_handler = SIG_DFL;
		rv = sigaction(sig, &oact, where);
	    } else if (where) {
		memcpy(where, &oact, sizeof(oact));
		rv = 0;
	    }
	}
    } else {
	rv = sigaction(sig, where, NULL);
    }
    if (rv != 0) {
	CTRACE((tfp, "Error in LYToggleSigDfl: %s\n", LYStrerror(errno)));
	return FALSE;
    } else
	return TRUE;
a2936 2
#endif /* HAVE_SIGACTION */
#endif /* SIGTSTP && !USE_SLANG */
d2976 1
a2976 7
#ifdef SLANG_NO_LIMIT		/* define this if slang has been fixed */
    SLtt_Screen_Cols = (LYcols-1) * 6;
#else
    /* Needs to be limited: fixed buffer bugs in slang can cause crash,
       see slang's SLtt_smart_puts - kw */
    SLtt_Screen_Cols = HTMIN((LYcols-1) * 6, 255);
#endif
d2984 1
a2984 1
#ifdef HAVE_SIZECHANGE
a3015 10
#ifdef __EMX__
    {
	int scrsize[2];

	_scrsize(scrsize);
	LYcols = scrsize[0];
	LYlines = scrsize[1];
    }
#endif

d3017 1
a3017 1
	LYlines = DFT_ROWS;
d3019 1
a3019 1
	LYcols = DFT_COLS;
d3027 2
a3028 7
	CTRACE((tfp, "Window size changed from (%d,%d) to (%d,%d)\n",
		old_lines, old_cols, LYlines, LYcols));
#if defined(CAN_SWITCH_DISPLAY_CHARSET) && defined(CAN_AUTODETECT_DISPLAY_CHARSET)
	/* May need to reload the font due to different char-box size */
	if (current_char_set != auto_display_charset)
	    Switch_Display_Charset(current_char_set, SWITCH_DISPLAY_CHARSET_RESIZE);
#endif
d3031 1
a3031 1
    LYExtSignal (SIGWINCH, size_change);
d3063 1
a3063 1
    char *new = NULL;
d3067 1
a3067 1
    if (!non_empty(fname))
d3070 3
a3072 1
    StrAllocCopy(new, fname);
d3103 1
a3103 2
    CONST char *cp2;
    char *temp = 0, *cp, *cp1, *end;
d3122 6
a3127 10
    cp2 = wwwName(lynx_temp_space);
#ifdef FNAMES_8_3
    if (LYIsHtmlSep(*cp2)) {
	HTSprintf0(&temp, "file://localhost%s%04x", cp2, GETPID());
    } else {
	HTSprintf0(&temp, "file://localhost/%s%04x", cp2, GETPID());
    }
#else
    if (LYIsHtmlSep(*cp2)) {
	HTSprintf0(&temp, "file://localhost%s%d", cp2, (int)getpid());
d3129 1
a3129 1
	HTSprintf0(&temp, "file://localhost/%s%d", cp2, (int)getpid());
a3130 1
#endif
d3135 3
a3137 2
	StrAllocCopy(temp, NonNull(cp));
	sprintf(fname, "temp%.*s", LY_MAXPATH - 10, temp);
d3142 6
a3147 6
	/*
	 *  Hmm... we have a directory name.
	 *  It is annoying to see a scheme+host+path name as a suggested one,
	 *  let's remove the last_slash and go ahead like we have a file name. - LP
	 */
	fname[strlen(fname) - 1] = '\0';
a3162 13
#ifdef _WINDOWS	/* 1998/05/05 (Tue) 10:08:05 */
    if ((cp = strrchr(fname,'=')) != NULL && strlen(cp) > 1) {
	cp1 = fname;
	/*
	 *  Go past the '='.
	 */
	cp++;
	for (; *cp != '\0'; cp++, cp1++) {
	    *cp1 = *cp;
	}
	*cp1 = '\0';
    }
#endif
d3208 1
a3208 1
		   *cp <  ' ' || (UCH(*cp)) > 126) {
a3387 8
    int code;
#ifdef USE_RAND_TEMPNAME
#define SIZE_TEMPNAME ((MAX_TEMPNAME / BITS_PER_CHAR) + 1)
    static BOOL first = TRUE;
    static int names_used = 0;
    static unsigned char used_tempname[SIZE_TEMPNAME];
    unsigned offset, mask;
#endif
d3390 1
a3395 34
    /*
     * Prefer a random value rather than a counter.
     */
#ifdef USE_RAND_TEMPNAME
    if (first) {
	lynx_srand((unsigned)((long)time((time_t *)0) + (long)result));
	first = FALSE;
    }

    /* We don't really need all of the bits from rand().  The high-order bits
     * are the more-random portion in any case, but limiting the width of the
     * generated name is done partly to avoid problems on systems that may not
     * support long filenames.
     */
    counter = MAX_TEMPNAME;
    while (names_used < MAX_TEMPNAME) {
	counter = (unsigned)(( (float)MAX_TEMPNAME * lynx_rand() ) / LYNX_RAND_MAX + 1);
	counter %= SIZE_TEMPNAME;	/* just in case... */
	/*
	 * Avoid reusing a temporary name, since there are places in the code
	 * which can refer to a temporary filename even after it has been
	 * closed and removed from the filesystem.
	 */
	offset = counter / BITS_PER_CHAR;
	mask = 1 << (counter % BITS_PER_CHAR);
	if ((used_tempname[offset] & mask) == 0) {
	    names_used++;
	    used_tempname[offset] |= mask;
	    break;
	}
    }
    if (names_used >= MAX_TEMPNAME)
	HTAlert(gettext("Too many tempfiles"));
#else
a3396 2
#endif

a3403 3
#ifdef _WINDOWS
    sprintf(leaf, "%04x%04x", counter, (unsigned)GETPID());
#else
a3404 1
#endif
d3411 1
a3411 2
	if (8 - (tail - suffix) >= 0)
	    leaf[8 - (tail - suffix)] = 0;
d3427 1
a3427 1
    CTRACE((tfp, "-> '%s'\n", result));
d3474 40
a3513 33
/* The first two are special: we want to record whether "default" or
 * "all" restrictions were applied, in addition to the detailed effects
 * of those options. - kw
 */
/* skip the special flags when processing "all" and "default": */
#define N_SPECIAL_RESTRICT_OPTIONS 2

PRIVATE CONST struct {
    CONST char *name;
    BOOLEAN *flag;
    BOOLEAN can;
} restrictions[] = {
    { "default",	&had_restrictions_default, TRUE },
    { "all",		&had_restrictions_all,	TRUE },
    { "inside_telnet",	&no_inside_telnet,	CAN_ANONYMOUS_INSIDE_DOMAIN_TELNET },
    { "outside_telnet",	&no_outside_telnet,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_TELNET },
    { "telnet_port",	&no_telnet_port,	CAN_ANONYMOUS_GOTO_TELNET_PORT },
    { "inside_ftp",	&no_inside_ftp,		CAN_ANONYMOUS_INSIDE_DOMAIN_FTP },
    { "outside_ftp",	&no_outside_ftp,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_FTP },
    { "inside_rlogin",	&no_inside_rlogin,	CAN_ANONYMOUS_INSIDE_DOMAIN_RLOGIN },
    { "outside_rlogin",	&no_outside_rlogin,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_RLOGIN },
    { "suspend",	&no_suspend,		FALSE },
    { "editor",		&no_editor,		FALSE },
    { "shell",		&no_shell,		FALSE },
    { "bookmark",	&no_bookmark,		FALSE },
    { "multibook",	&no_multibook,		FALSE },
    { "bookmark_exec",	&no_bookmark_exec,	FALSE },
    { "option_save",	&no_option_save,	FALSE },
    { "print",		&no_print,		CAN_ANONYMOUS_PRINT },
    { "download",	&no_download,		FALSE },
    { "disk_save",	&no_disk_save,		FALSE },
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
    { "exec",		&no_exec,		LOCAL_EXECUTION_LINKS_ALWAYS_OFF_FOR_ANONYMOUS },
d3515 30
a3544 5
    { "lynxcgi",	&no_lynxcgi,		FALSE },
    { "exec_frozen",	&exec_frozen,		FALSE },
    { "goto",		&no_goto,		CAN_ANONYMOUS_GOTO },
    { "jump",		&no_jump,		CAN_ANONYMOUS_JUMP },
    { "file_url",	&no_file_url,		FALSE },
d3546 7
a3552 10
    { "news_post",	&no_newspost,		FALSE },
    { "inside_news",	&no_inside_news,	CAN_ANONYMOUS_INSIDE_DOMAIN_READ_NEWS },
    { "outside_news",	&no_outside_news,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_READ_NEWS },
#endif
    { "mail",		&no_mail,		CAN_ANONYMOUS_MAIL },
    { "dotfiles",	&no_dotfiles,		FALSE },
    { "useragent",	&no_useragent,		FALSE },
#ifdef SUPPORT_CHDIR
    { "chdir",		&no_chdir,		FALSE },
#endif
d3554 1
a3554 1
    { "dired_support",	&no_dired_support,	FALSE },
d3556 1
a3556 1
    { "change_exec_perms", &no_change_exec_perms, FALSE },
d3560 1
a3560 7
    { "externals",	&no_externals,		FALSE },
#endif
    { "lynxcfg_info",	&no_lynxcfg_info,	CAN_ANONYMOUS_VIEW_LYNXCFG_INFO },
#ifndef NO_CONFIG_INFO
    { "lynxcfg_xinfo",	&no_lynxcfg_xinfo,	CAN_ANONYMOUS_VIEW_LYNXCFG_EXTENDED_INFO },
#ifdef HAVE_CONFIG_H
    { "compileopts_info", &no_compileopts_info,	CAN_ANONYMOUS_VIEW_COMPILEOPTS_INFO },
d3562 27
d3590 7
a3596 11
    /* put "goto" restrictions on the end, since they are a refinement */
#ifndef DISABLE_BIBP
    { "goto_bibp",	&no_goto_bibp,		CAN_ANONYMOUS_GOTO_BIBP	},
#endif
#ifdef HAVE_CONFIG_H
#ifndef NO_CONFIG_INFO
    { "goto_configinfo", &no_goto_configinfo,	CAN_ANONYMOUS_GOTO_CONFIGINFO },
#endif
#endif
    { "goto_cso",	&no_goto_cso,		CAN_ANONYMOUS_GOTO_CSO },
    { "goto_file",	&no_goto_file,		CAN_ANONYMOUS_GOTO_FILE },
d3598 1
a3598 1
    { "goto_finger",	&no_goto_finger,	CAN_ANONYMOUS_GOTO_FINGER },
d3600 1
a3600 1
    { "goto_ftp",	&no_goto_ftp,		CAN_ANONYMOUS_GOTO_FTP },
d3602 1
a3602 1
    { "goto_gopher",	&no_goto_gopher,	CAN_ANONYMOUS_GOTO_GOPHER },
d3604 6
a3609 6
    { "goto_http",	&no_goto_http,		CAN_ANONYMOUS_GOTO_HTTP },
    { "goto_https",	&no_goto_https,		CAN_ANONYMOUS_GOTO_HTTPS },
    { "goto_lynxcgi",	&no_goto_lynxcgi,	CAN_ANONYMOUS_GOTO_LYNXCGI },
    { "goto_lynxexec",	&no_goto_lynxexec,	CAN_ANONYMOUS_GOTO_LYNXEXEC },
    { "goto_lynxprog",	&no_goto_lynxprog,	CAN_ANONYMOUS_GOTO_LYNXPROG },
    { "goto_mailto",	&no_goto_mailto,	CAN_ANONYMOUS_GOTO_MAILTO },
d3611 2
a3612 2
    { "goto_news",	&no_goto_news,		CAN_ANONYMOUS_GOTO_NEWS },
    { "goto_nntp",	&no_goto_nntp,		CAN_ANONYMOUS_GOTO_NNTP },
d3614 1
a3614 1
    { "goto_rlogin",	&no_goto_rlogin,	CAN_ANONYMOUS_GOTO_RLOGIN },
d3616 1
a3616 1
    { "goto_snews",	&no_goto_snews,		CAN_ANONYMOUS_GOTO_SNEWS },
d3618 32
a3649 161
    { "goto_telnet",	&no_goto_telnet,	CAN_ANONYMOUS_GOTO_TELNET },
    { "goto_tn3270",	&no_goto_tn3270,	CAN_ANONYMOUS_GOTO_TN3270 },
    { "goto_wais",	&no_goto_wais,		CAN_ANONYMOUS_GOTO_WAIS },
};

/*  This will make no difference between '-' and '_'. It does only in/equality
    compare. It assumes that p2 can't contain dashes, but p1 can.
    This function is also used (if macro OPTNAME_ALLOW_DASHES doesn't have
    value of zero) for compare of commandline options -VH
 */
PUBLIC BOOL strn_dash_equ ARGS3(
	CONST char*,	p1,
	CONST char*,	p2,
	int,		len)
{
    while (len--) {
	if (!*p2)
	    return 0;/* canonical name is shorter */
	switch (*p1) {
	    case 0:
		return 0;
	    case '-':
	    case '_':
		if (*p2!='_')
		    return 0;
		else
		    break;
	    default:
		if (*p1!=*p2)
		    return 0;
	}
	++p1; ++p2;
    }
    return 1;
}

/* Uncomment following lines to allow only exact string matching */
/* #define RESTRICT_NM_ALLOW_DASHES 0 */

#ifndef RESTRICT_NM_ALLOW_DASHES
# define RESTRICT_NM_ALLOW_DASHES 1
#endif

#if RESTRICT_NM_ALLOW_DASHES
#	define RESTRICT_NM_EQU(a,b,len) strn_dash_equ(a,b,len)
#else
#	define RESTRICT_NM_EQU(a,b,len) STRNEQ(a,b,len)
#endif

/*
 * Returns the inx'th name from the restrictions table, or null if inx is
 * out of range.
 */
PUBLIC CONST char *index_to_restriction ARGS1(
    int,	inx)
{
    if (inx >= 0 && inx < (int) TABLESIZE(restrictions))
	return restrictions[inx].name;
    return NULL;
}

/*
 * Returns the value TRUE/FALSE of a given restriction, or -1 if it is not
 * one that we recognize.
 */
PUBLIC int find_restriction ARGS2(
    CONST char *,	name,
    int,		len)
{
    unsigned i;
    if (len < 0)
	len = strlen(name);
    for (i=0; i < TABLESIZE(restrictions); i++) {
	if (RESTRICT_NM_EQU(name, restrictions[i].name, len)) {
	    return (*restrictions[i].flag);
	}
    }
    return -1;
}

PUBLIC void parse_restrictions ARGS1(
    CONST char *,	s)
{
    CONST char *p;
    CONST char *word;
    unsigned i;
    BOOLEAN found;

    p = s;
    while (*p) {
	p = LYSkipCBlanks(p);
	if (*p == '\0')
	    break;
	word = p;
	while (*p != ',' && *p != '\0')
	    p++;

	found = FALSE;
	if (RESTRICT_NM_EQU(word, "all", p-word)) {
	    found = TRUE;
	    for (i = N_SPECIAL_RESTRICT_OPTIONS; i < TABLESIZE(restrictions); i++)
		*(restrictions[i].flag) = TRUE;
	} else if (RESTRICT_NM_EQU(word, "default", p-word)) {
	    found = TRUE;
	    for (i = N_SPECIAL_RESTRICT_OPTIONS; i < TABLESIZE(restrictions); i++)
		*(restrictions[i].flag) = !restrictions[i].can;
	} else {
	    for (i=0; i < TABLESIZE(restrictions); i++) {
		if (RESTRICT_NM_EQU(word, restrictions[i].name, p-word)) {
		    *(restrictions[i].flag) = TRUE;
		    found = TRUE;
		    break;
		}
	    }
	}
	if (!found) {
	    printf("%s: %.*s\n", gettext("unknown restriction"), p-word, word);
	    exit(EXIT_FAILURE);
	}
	if (*p)
	    p++;
    }

    /*
     * If shell is restricted, set restrictions on related topics.
     */
    if (no_shell) {
	no_goto_lynxexec = TRUE;
	no_goto_lynxprog = TRUE;
	no_goto_lynxcgi = TRUE;
#ifdef EXEC_LINKS
	local_exec_on_local_files = TRUE;
#endif
    }
}

PUBLIC void print_restrictions_to_fd ARGS1(
    FILE *,	fp)
{
    unsigned i, count = 0;

    for (i=0; i < TABLESIZE(restrictions); i++) {
	if (*(restrictions[i].flag) == TRUE) {
	    count++;
	}
    }
    if (!count) {
	fprintf(fp, gettext("No restrictions set.\n"));
	return;
    }
    fprintf(fp, gettext("Restrictions set:\n"));
    for (i=0; i < TABLESIZE(restrictions); i++) {
	if (*(restrictions[i].flag) == TRUE) {
	    /* if "goto" is restricted, don't bother tell about its
	     * refinements
	     */
	    if (strncmp(restrictions[i].name, "goto_", 5)
	     || !no_goto)
		fprintf(fp, "   %s\n", restrictions[i].name);
	}
    }
d3752 1
a3752 1
	mf = LYGetEnv("MAIL");
d3791 1
a3791 1
**  and 'g'oto entries, after they have been
a3792 2
**  Such URLs have no `base' reference to which they
**  could be resolved.  LYLegitimizeHREF could not be used.
d3801 1
a3801 1
    if (isEmpty(*href))
a3803 5
   /*
    *  Check whether to fill in localhost. - FM
    */
    LYFillLocalFileURL(href, "file://localhost");

d3807 1
a3807 1
    if (!strcasecomp(*href, STR_NEWS_URL)) {
d3809 2
a3810 1
    } else if (!strcasecomp(*href, STR_SNEWS_URL)) {
a3812 1

d3814 2
a3815 2
	CTRACE((tfp, "%s%s'%s' is not a URL\n",
		    NonNull(name), (name ? " " : ""), *href));
d3818 1
a3818 3

    temp = HTParse(*href, "", PARSE_ALL);
    if (non_empty(temp))
d3838 1
d3844 1
a3844 1
#if defined(USE_DOS_DRIVES)
d3846 6
a3851 7
	char *cp_url = *AllocatedString;
	for(; *cp_url != '\0'; cp_url++)
	    if (*cp_url == '\\')
		*cp_url = '/';
	cp_url--;
	if (LYIsDosDrive(*AllocatedString) && *cp_url == ':')
	    LYAddPathSep(AllocatedString);
d3853 1
a3853 1
#endif /* USE_DOS_DRIVES */
d3856 1
a3856 1
    StrAllocCopy(*AllocatedString, "file://localhost");
d3860 1
a3860 1
#if defined(USE_DOS_DRIVES)
d3862 1
a3862 1
#endif /* USE_DOS_DRIVES */
d3878 1
a3878 1
	    StrAllocCat(*AllocatedString, HTVMS_wwwName(Home_Dir()));
d3892 3
a3894 2
	    fragment = trimPoundSelector(old_string);
	    LYstrncpy(url_file, old_string, sizeof(url_file)-1);
d3911 1
a3911 1
		restorePoundSelector(fragment);
d3921 3
a3923 1
	    restorePoundSelector(fragment);
d3943 1
a3943 1
		     !isdigit(UCH(cp[1]))) ||
d3952 4
a3955 3
		    sprintf(url_file, "/%.*s", sizeof(url_file)-2, old_string);
		    CTRACE((tfp, "Can't find '%s'  Will assume it's a bad path.\n",
				old_string));
d3976 4
a3979 3
	    restorePoundSelector(fragment);
	    fragment = NULL;

d3982 1
a3982 1
		 !isdigit(UCH(cp[1]))) ||
d3991 4
a3994 3
		sprintf(url_file, "/%.*s", sizeof(url_file)-2, old_string);
		CTRACE((tfp, "Can't find '%s'  Will assume it's a bad path.\n",
			    old_string));
d4012 3
a4014 22
	CTRACE((tfp, "Trying: '%s'\n", *AllocatedString));
#else /* not VMS: */
#if defined(USE_DOS_DRIVES)
#ifdef _WINDOWS
	if (*old_string == '.') {
	    char fullpath[MAX_PATH + 1];
	    char *filepart = NULL;
	    DWORD chk;

	    chk = GetFullPathNameA(old_string, MAX_PATH + 1,
			fullpath, &filepart);
	    if (chk != 0) {
		StrAllocCopy(temp, wwwName(fullpath));
		StrAllocCat(*AllocatedString, temp);
		FREE(temp);
		CTRACE((tfp, "Converted '%s' to '%s'\n",
				old_string, *AllocatedString));
	    } else {
		StrAllocCat(*AllocatedString, old_string);
	    }
	}
#else
d4023 4
a4026 6
	    CTRACE((tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString));
	}
#endif
	else
#endif /* USE_DOS_DRIVES */
d4031 1
a4031 1
	    StrAllocCat(*AllocatedString, wwwName(Home_Dir()));
d4043 2
a4044 2
	    CTRACE((tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString));
d4057 1
a4057 1
#if defined (USE_DOS_DRIVES)
a4064 3
		/* 1998/01/13 (Tue) 12:24:33 */
		if (old_string[1] == '|')
		    old_string[1] = ':';
a4065 3

		if (strlen(temp) == 2 && LYIsDosDrive(temp))
		    LYAddPathSep(&temp);
d4071 1
a4071 1
#endif /* USE_DOS_DRIVES */
d4073 1
a4073 1
	    CTRACE((tfp, "Converted '%s' to '%s'\n", old_string, temp));
d4075 1
a4075 1
		LYCanReadFile(temp)) {
d4079 1
a4079 1
#if defined (USE_DOS_DRIVES)
d4084 3
a4086 2
		if (strchr(temp, '#') == NULL && strchr(temp, '%') == NULL)
		    StrAllocCopy(cp, temp);
d4088 1
a4088 2
		    cp = HTEscape(temp, URL_PATH);
#else
a4089 1
#endif /* USE_DOS_DRIVES */
d4092 2
a4093 2
		CTRACE((tfp, "Converted '%s' to '%s'\n",
			    old_string, *AllocatedString));
d4100 2
a4101 1
		fragment = trimPoundSelector(cp);
a4105 3
#ifdef WIN_EX	/* 1998/07/31 (Fri) 09:09:03 */
		HTUnEscape(temp2);	/* for LFN */
#endif
d4109 1
a4109 1
		     LYCanReadFile(temp2))) {
d4128 1
a4128 1
			    restorePoundSelector(fragment);
d4133 2
a4134 2
		    CTRACE((tfp, "Converted '%s' to '%s'\n",
				old_string, *AllocatedString));
d4158 1
a4158 1
			    restorePoundSelector(fragment);
d4172 2
a4173 21
		CTRACE((tfp, "Can't stat() or fopen() '%s'\n",
			    temp2 ? temp2 : temp));
#ifdef WIN_EX  /* 1998/01/13 (Tue) 09:07:37 */
		{
		    CONST char *p, *q;
		    char buff[LY_MAXPATH + 128];

		    p = Home_Dir();
		    q = temp2 ? temp2 : temp;

		    if (strlen(q) == 3 && LYIsDosDrive(q)) {
			sprintf(buff,
			    "'%s' not exist, Goto LynxHome '%s'.", q, p);
			_statusline(buff);
			LYSleepAlert();
			FREE(temp);
			StrAllocCat(*AllocatedString, p);
			goto Retry;
		    }
		}
#endif
d4176 1
a4176 2
				       URLDomainSuffixes))
		{
a4185 3
		} else {
		    /* Return file URL for the file that does not exist */
		    StrAllocCat(*AllocatedString, temp);
d4187 1
a4187 4
#ifdef WIN_EX
	Retry:
#endif
		CTRACE((tfp, "Trying: '%s'\n", *AllocatedString));
d4191 4
d4208 1
a4208 1
	    StrAllocCat(*AllocatedString, HTVMS_wwwName(Home_Dir()));
d4212 1
a4212 1
		   LYCanReadFile(old_string)) {
d4219 1
a4219 1
	    CTRACE((tfp, "Converted '%s' to '%s'\n", old_string, temp));
d4224 6
a4229 2
	    CTRACE((tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString));
d4236 5
a4240 1
	    StrAllocCat(*AllocatedString, wwwName(Home_Dir()));
d4252 9
a4260 46
	} else {
	    /*
	     *	Normal absolute path.  Simplify, trim any
	     *	residual relative elements, and append it. - FM
	     */
	    StrAllocCopy(temp, old_string);
	    LYTrimRelFromAbsPath(temp);
	    StrAllocCat(*AllocatedString, temp);
	    FREE(temp);
	}
	CTRACE((tfp, "Converted '%s' to '%s'\n",
		    old_string, *AllocatedString));
    }
    FREE(old_string);
    /* Pause so we can read the messages before invoking curses */
    CTRACE_SLEEP(AlertSecs);
}

#if defined(_WINDOWS) /* 1998/06/23 (Tue) 16:45:20 */

PUBLIC int win32_check_interrupt(void)
{
    int c;

    if (kbhit()) {
	c = LYgetch();
	/** Keyboard 'Z' or 'z', or Control-G or Control-C **/
	if (LYCharIsINTERRUPT(c) || c == 0x1b) {
	    return TRUE;
	}
    }
    return FALSE;
}

void sleep(unsigned sec)
{
    unsigned int i, j;
    int c;

    for (j = 0; j < sec; j++) {
	for (i = 0; i < 10; i++) {
	    Sleep(100);
	    if (kbhit()) {
		c = LYgetch();
		return;
	    }
d4262 2
d4265 3
a4268 1
#endif
d4300 1
a4300 5
    BOOLEAN Startup = (BOOL) (helpfilepath == NULL);
#ifdef INET6
    struct addrinfo hints, *res;
    int error;
#endif /* INET6 */
d4334 1
a4334 1
    } else {
d4340 1
a4340 1
	Fragment = trimPoundSelector(Str);
d4350 1
a4350 1
	isdigit(UCH(StrColon[1]))) {
d4370 1
a4370 1
	fprintf(stdout, "%s '%s'%s\r\n", WWW_FIND_MESSAGE, host, FIRST_SEGMENT);
d4372 2
a4373 8

#ifdef INET6
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    error = getaddrinfo(host, "80", &hints, &res);

    if (!error && res)
d4375 2
a4376 2
    if (LYGetHostByName(host) != NULL)
#endif /* INET6 */
d4382 2
a4383 3
	    CTRACE((tfp,
	    "LYExpandHostForURL: Ignoring interrupt because '%s' resolved.\n",
			host));
d4394 5
a4398 3
    }
    else if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED))
    {
d4402 2
a4403 3
	CTRACE((tfp,
	"LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
		    host));
d4480 1
a4480 1
		isdigit(UCH(HostColon[1]))) {
d4493 5
a4497 1
	    GotHost = (BOOL) (LYGetHostByName(host) != NULL);
d4505 1
d4507 3
d4511 2
a4512 3
		    CTRACE((tfp,
	"LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
				host));
d4567 1
a4567 1
	    restorePoundSelector(Fragment);
d4577 1
a4577 1
	CTRACE((tfp, "LYExpandHostForURL: Ignoring interrupt because '%s' %s.\n",
d4579 1
a4579 1
		    (GotHost ? "resolved" : "timed out")));
d4685 1
a4685 1
    } else if (non_empty(default_scheme)) {
d4722 1
a4722 1
    TerminalSlash = (BOOL) (LYIsPathSep(path[(strlen(path) - 1)]));
d4847 1
a4847 1
#ifdef HAVE_GETCWD
a4856 62
/*
 * Verify that the given path refers to an existing directory, returning the
 * string if the directory exists.  If not, return null.
 */
PRIVATE char * CheckDir ARGS1(
    char *,	path)
{
    struct stat stat_info;
    if (!LYisAbsPath(path)
	|| (HTStat(path, &stat_info) < 0
	 || !S_ISDIR(stat_info.st_mode))) {
	path = NULL;
    }
    return path;
}

/*
 * Lookup various possibilities for $HOME, and check that the directory exists.
 */
PRIVATE char *HomeEnv NOARGS
{
    char *result = CheckDir(LYGetEnv("HOME"));

#if defined (USE_DOS_DRIVES)
    if (result == 0) {
	char *head;
	char *leaf;
	static char *temp = NULL;

	/* Windows 2000 */
	if ((result = LYGetEnv("USERPROFILE")) != 0) {
	    HTSprintf0(&temp, "%s%sMy Documents", result, PATHSEP_STR);
	    result = CheckDir(temp);
	}
	/* NT4 */
	if (result == 0) {
	    if ((head = LYGetEnv("HOMEDRIVE")) != 0) {
		if ((leaf = LYGetEnv("HOMEPATH")) != 0) {
		    HTSprintf0(&temp, "%s%s%s", head, PATHSEP_STR, leaf);
		    result = CheckDir(temp);
		}
	    }
	}
	/* General M$ */
	if (result == 0)
	    result = CheckDir(LYGetEnv("TEMP"));
	if (result == 0)
	    result = CheckDir(LYGetEnv("TMP"));
	if (result == 0) {
	    if ((head = LYGetEnv("SystemDrive")) != 0) {
		HTSprintf0(&temp, "%s%s", head, PATHSEP_STR);
		result = CheckDir(temp);
	    }
	}
	if (result == 0)
	    result = CheckDir("C:" PATHSEP_STR);
    }
#endif

    return result;
}

d4863 16
a4878 1
	if ((cp = HomeEnv()) == NULL) {
d4880 8
a4887 3
	    if ((cp = LYGetEnv("SYS$LOGIN")) == NULL
	     && (cp = LYGetEnv("SYS$SCRATCH")) == NULL) {
		cp = "sys$scratch:";
a4888 1
	    StrAllocCopy(HomeDir, cp);
d4890 1
a4890 2
#ifdef UNIX
#ifdef HAVE_UTMP
d4906 3
d4911 1
a4919 4
    if (homedir == NULL) {
	printf("%s\n", gettext("Cannot find HOME directory"));
	exit(EXIT_FAILURE);
    }
d5170 4
a5173 1

d5175 1
a5175 1
#define NO_HOMEPATH "Error:"
d5177 1
a5177 1
#define NO_HOMEPATH "/error"
a5178 6
    if (!non_empty(home))
	/*
	 *  Home_Dir() has a bug if this ever happens. - FM
	 */
	StrAllocCopy(home, NO_HOMEPATH);

d5205 5
a5209 2
	    char *temp = NULL;
	    HTSprintf0(&temp, "%s%s", HTVMS_wwwName(home), (file + 1));
d5264 1
a5264 1
    if (!non_empty(string))
d5267 1
a5267 1
    CTRACE((tfp, "LYmktime: Parsing '%s'\n", s));
d5273 1
a5273 1
    while (*s != '\0' && !isdigit(UCH(*s)))
d5282 2
a5283 2
    while (*s != '\0' && isdigit(UCH(*s)))
	s++;
d5294 1
a5294 1
    while (*s != '\0' && !isalnum(UCH(*s)))
d5299 1
a5299 1
    while (*s != '\0' && isalnum(UCH(*s)))
d5302 2
a5303 2
	(s - start) < (isdigit(UCH(*(s - 1))) ? 2 : 3) ||
	(s - start) > (isdigit(UCH(*(s - 1))) ? 2 : 9))
d5305 1
a5305 1
    LYstrncpy(temp, start, (isdigit(UCH(*(s - 1))) ? 2 : 3));
d5385 1
a5385 1
    while (*s != '\0' && !isdigit(UCH(*s)))
d5390 1
a5390 1
    while (*s != '\0' && isdigit(UCH(*s)))
d5419 1
a5419 1
    while (*s != '\0' && !isdigit(UCH(*s)))
d5427 1
a5427 1
	while (*s != '\0' && isdigit(UCH(*s)))
d5437 1
a5437 1
	while (*s != '\0' && !isdigit(UCH(*s)))
d5442 1
a5442 1
	while (*s != '\0' && isdigit(UCH(*s)))
d5452 1
a5452 1
	while (*s != '\0' && !isdigit(UCH(*s)))
d5457 1
a5457 1
	while (*s != '\0' && isdigit(UCH(*s)))
d5481 1
a5481 1
    if (absolute == FALSE && (long)(time((time_t *)0) - clock2) >= 0)
d5484 1
a5484 1
	CTRACE((tfp, "LYmktime: clock=%ld, ctime=%s",
d5486 1
a5486 1
		    ctime(&clock2)));
d5491 1
a5491 1
#if !defined(HAVE_PUTENV) && !defined(_WINDOWS)
d5493 1
a5493 1
 *  No putenv on the NeXT so we use this code instead!
d5588 1
a5588 11
/*
 * Default, for single-user systems such as Cygwin and OS/2 EMX:
 */
#define IsOurFile(name) TRUE
#define OpenHiddenFile(name, mode) fopen(name, mode)

#if defined(MULTI_USER_UNIX)

#undef IsOurFile
#undef OpenHiddenFile

d5603 1
a5603 5
	/*
	 * ( If this is not a single-user system, the other user is presumed by
	 * some people busy trying to use a symlink attack on our files ;-)
	 */
#if defined(HAVE_LSTAT)
d5633 1
a5633 1
		     || (data.st_mode & S_IWOTH) != 0) {
a5655 1
    BOOLEAN binary = strchr(mode, 'b') != 0;
a5671 4
#if defined(O_BINARY) && defined(__CYGWIN__)
	    if (binary)
		setmode(fd, O_BINARY);
#endif
d5682 1
a5682 1
	    fp = OpenHiddenFile(name, binary ? BIN_W : TXT_W);
d5700 5
a5704 1
#endif /* MULTI_USER_UNIX */
d5709 1
a5709 1
    FILE *fp = fopen (name, BIN_W, "mbc=32");
d5712 1
a5712 1
    FILE *fp = OpenHiddenFile(name, BIN_W);
d5722 1
a5722 1
    fp = fopen (name, TXT_W, "shr=get");
d5727 1
a5727 1
    fp = OpenHiddenFile(name, TXT_W);
d5740 1
a5740 1
    fp = fopen (name, TXT_A, "shr=get");
d5745 1
a5745 1
    fp = OpenHiddenFile(name, TXT_A);
d5752 1
a5752 1
#if defined(MULTI_USER_UNIX)
d5785 2
d5788 1
a5788 1
	LYstrncpy(result, *cached, LY_MAXPATH);
d5790 2
a5791 1
	if (LYCanReadFile(result)) {
d5799 11
a5809 3
#ifndef HAVE_MKDTEMP
#define mkdtemp(path) ((mktemp(path) != 0) && (mkdir(path, 0700) == 0))
#endif
d5824 1
a5824 1
    char wrt = 'r';
d5827 1
a5827 1
    CTRACE((tfp, "LYOpenTemp(,%s,%s)\n", suffix, mode));
d5837 2
a5838 40
		CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
		return 0;
	}
    }

    /*
     * Verify if the given space looks secure enough.  Otherwise, make a
     * secure subdirectory of that.
     */
#if defined(MULTI_USER_UNIX) && defined(HAVE_MKTEMP)
    if (lynx_temp_subspace == 0)
    {
	BOOL make_it = FALSE;
	struct stat sb;

	if (lstat(lynx_temp_space, &sb) == 0
	 && S_ISDIR(sb.st_mode)) {
	    if (sb.st_uid != getuid()
	     || (sb.st_mode & (S_IWOTH | S_IWGRP)) != 0) {
		make_it = TRUE;
		CTRACE((tfp, "lynx_temp_space is not our directory %s owner %d mode %03o\n",
			     lynx_temp_space, (int) sb.st_uid, (int) sb.st_mode & 0777));
	    }
	} else {
	    make_it = TRUE;
	    CTRACE((tfp, "lynx_temp_space is not a directory %s\n", lynx_temp_space));
	}
	if (make_it) {
	    int old_mask = umask(HIDE_UMASK);
	    StrAllocCat(lynx_temp_space, "XXXXXX");
	    if (mkdtemp(lynx_temp_space) == 0) {
		printf("%s: %s\n", lynx_temp_space, LYStrerror(errno));
		exit(EXIT_FAILURE);
	    }
	    umask(old_mask);
	    lynx_temp_subspace = 1;
	    StrAllocCat(lynx_temp_space, "/");
	    CTRACE((tfp, "made subdirectory %s\n", lynx_temp_space));
	} else {
	    lynx_temp_subspace = -1;
a5840 1
#endif
d5864 2
a5865 2
	    CTRACE((tfp, "... LYOpenTemp(%s) failed: %s\n",
		   result, LYStrerror(errno)));
d5871 1
a5871 1
    if ((p = typecalloc(LY_TEMP)) != 0) {
a5874 1
	p->outs = (wrt != 'r');
d5880 1
a5880 1
    CTRACE((tfp, "... LYOpenTemp(%s)\n", result));
d5894 3
a5896 147
    if ((p = FindTempfileByName(name)) != 0) {
	fp = p->file = LYAppendToTxtFile (name);
    }
    return fp;
}

/*
 * Open a temp-file for writing, possibly re-using a previously used
 * name and file.
 * If a non-empty fname is given, it is reused if it indicates a file
 * previously registered as a temp file and, in case the file still
 * exists, if it looks like we can write to it safely.  Otherwise a
 * new temp file (with new name) will be generated and returned in fname.
 *
 * File permissions are set so that the file is not readable by unprivileged
 * other users.
 *
 * Suffix is only used if fname is not being reused.
 * The mode should be "w", others are possible (they may be passed on)
 * but probably don't make sense. - kw
 */
PUBLIC FILE *LYOpenTempRewrite ARGS3(
	char *,		fname,
	CONST char *,	suffix,
	CONST char *,	mode)
{
    FILE *fp = 0;
    BOOL txt = TRUE;
    char wrt = 'r';
    BOOL registered = NO;
    BOOL writable_exists = NO;
    BOOL is_ours = NO;
    BOOL still_open = NO;
    LY_TEMP *p;
    struct stat stat_buf;

    CTRACE((tfp, "LYOpenTempRewrite(%s,%s,%s)\n", fname, suffix, mode));
    if (*fname == '\0')		/* first time, no filename yet */
	return (LYOpenTemp(fname, suffix, mode));

    if ((p = FindTempfileByName(fname)) != 0) {
	registered = YES;
	if (p->file != 0)
	    still_open = YES;
	CTRACE((tfp, "...used before%s\n", still_open ? ", still open!" : "."));
    }

    if (registered) {
#ifndef NO_GROUPS
	writable_exists = HTEditable(fname); /* existing, can write */
#define CTRACE_EXISTS "exists and is writable, "
#else
	writable_exists = (BOOL) (stat(fname, &stat_buf) == 0); /* existing, assume can write */
#define CTRACE_EXISTS "exists, "
#endif

	if (writable_exists) {
	    is_ours = IsOurFile(fname);
	}
	CTRACE((tfp, "...%s%s\n",
	       writable_exists ? CTRACE_EXISTS : "",
	       is_ours ? "is our file." : "is NOT our file."));
    }

    /*
     *  Note that in cases where LYOpenTemp is called as fallback below,
     *  we don't call LYRemoveTemp first.  That may be appropriate in some
     *  cases, but not trying to remove a weird existing file seems safer
     *  and could help diagnose an unusual situation.  (They may be removed
     *  anyway later.)
     */
    if (still_open) {
	/*
	 * This should probably not happen.  Make a new one.
	 */
	return (LYOpenTemp(fname, suffix, mode));
    } else if (!registered) {
	/*
	 *  Not registered.  It should have been registered at one point
	 *  though, otherwise we wouldn't be called like this.
	 */
	return (LYOpenTemp(fname, suffix, mode));
    } else if (writable_exists && !is_ours) {
	/*
	 *  File exists, writable if we checked, but something is wrong
	 *  with it.
	 */
	return (LYOpenTemp(fname, suffix, mode));
#ifndef NO_GROUPS
    } else if (!is_ours && (lstat(fname, &stat_buf) == 0)) {
	/*
	 *  Exists but not writable, and something is wrong with it.
	 */
	return (LYOpenTemp(fname, suffix, mode));
#endif
    }

    while (*mode != '\0') {
	switch (*mode++) {
	case 'w':	wrt = 'w';	break;
	case 'a':	wrt = 'a';	break;
	case 'b':	txt = FALSE;	break;
	default:
		CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
		return fp;
	}
    }

    if (is_ours) {
	/*
	 *  Yes, it exists, is writable if we checked, and everything
	 *  looks ok so far.  This should be the most regular case. - kw
	 */
#ifdef HAVE_TRUNCATE
	if (txt == TRUE) {	/* limitation of LYReopenTemp.  shrug */
	    /*
	     *  We truncate and then append, this avoids having a small
	     *  window in which the file doesn't exist. - kw
	     */
	    if (truncate(fname, 0) != 0) {
		CTRACE((tfp, "... truncate(%s,0) failed: %s\n",
			fname, LYStrerror(errno)));
		return (LYOpenTemp(fname, suffix, mode));
	    } else {
		return (LYReopenTemp(fname));
	    }
	}
#endif
	remove(fname);

    }

	/*  We come here in two cases: either the file existed and was
	 *  ours and we just got rid of it.
	 *  Or the file did and does not exist, but is registered as a
	 *  temp file.  It must have been removed by some means other than
	 *  LYRemoveTemp.
	 *  In both cases, reuse the name! - kw
	 */

    if (txt) {
	switch (wrt) {
	case 'w':
	    fp = LYNewTxtFile (fname);
	    break;
	case 'a':
	    fp = LYAppendToTxtFile (fname);
a5898 2
    } else {
	fp = LYNewBinFile (fname);
a5899 10
    p->file = fp;

    CTRACE((tfp, "... LYOpenTempRewrite(%s), %s\n", fname,
	   (fp) ? "ok" : "failed"));
    /*
     *  We could fall back to trying LYOpenTemp() here in case of failure.
     *  After all the checks already done above a filure here should be
     *  pretty unusual though, so maybe it's better to let the user notice
     *  that something went wrong, and not try to fix it up. - kw
     */
d5918 1
a5918 1
	if ((p = typecalloc(LY_TEMP)) != 0) {
d5927 1
a5927 1
    CTRACE((tfp, "LYOpenScratch(%s)\n", result));
a5930 13
PRIVATE void LY_close_temp ARGS1(
	LY_TEMP *,	p)
{
    if (p->file != 0) {
	if (p->outs) {
	    LYCloseOutput(p->file);
	} else {
	    LYCloseInput(p->file);
	}
	p->file = 0;
    }
}

d5939 11
a5949 5
    CTRACE((tfp, "LYCloseTemp(%s)\n", name));
    if ((p = FindTempfileByName(name)) != 0) {
	CTRACE((tfp, "...LYCloseTemp(%s)%s\n", name,
	    (p->file != 0) ? ", closed" : ""));
	LY_close_temp(p);
d5961 8
a5968 4
    CTRACE((tfp, "LYCloseTempFP\n"));
    if ((p = FindTempfileByFP(fp)) != 0) {
	LY_close_temp(p);
	CTRACE((tfp, "...LYCloseTempFP(%s)\n", p->name));
d5975 1
a5975 1
PUBLIC int LYRemoveTemp ARGS1(
d5979 1
a5979 1
    int code = -1;
d5981 2
a5982 2
    if (non_empty(name)) {
	CTRACE((tfp, "LYRemoveTemp(%s)\n", name));
d5990 2
a5991 1
		LY_close_temp(p);
d5993 2
a5994 2
		CTRACE((tfp, "...LYRemoveTemp done(%d)%s\n", code,
		       (p->file != 0) ? ", closed" : ""));
a6001 1
    return code;
a6012 10
#if defined(MULTI_USER_UNIX)
    if (lynx_temp_subspace > 0) {
	char result[LY_MAXPATH];
	LYstrncpy(result, lynx_temp_space, sizeof(result)-1);
	LYTrimPathSep(result);
	CTRACE((tfp, "LYCleanupTemp removing %s\n", result));
	rmdir(result);
	lynx_temp_subspace = -1;
    }
#endif
d6024 5
a6028 115
    CTRACE((tfp, "LYRenamedTemp(old=%s, new=%s)\n", oldname, newname));
    if ((p = FindTempfileByName(oldname)) != 0) {
	StrAllocCopy((p->name), newname);
    }
}

#ifndef DISABLE_BIBP
/*
 *  Check that bibhost defines the BibP icon.
 */
PUBLIC void LYCheckBibHost NOARGS
{
    DocAddress bibhostIcon;
    BOOLEAN saveFlag;

    bibhostIcon.address = NULL;
    StrAllocCopy(bibhostIcon.address, BibP_bibhost);
    StrAllocCat(bibhostIcon.address, "bibp1.0/bibpicon.jpg");
    bibhostIcon.post_data = NULL;
    bibhostIcon.post_content_type = NULL;
    bibhostIcon.bookmark = FALSE;
    bibhostIcon.isHEAD = FALSE;
    bibhostIcon.safe = FALSE;
    saveFlag = traversal;
    traversal = TRUE;  /* Hack to force error response. */
    BibP_bibhost_available = HTLoadAbsolute(&bibhostIcon) == YES;
    traversal = saveFlag;
    BibP_bibhost_checked = TRUE;
}
#endif /* !DISABLE_BIBP */

/*
 *  Management of User Interface Pages. - kw
 *
 *  These are mostly temp files.  Pages which can be recognized by their
 *  special URL (after having been loaded) need not be tracked here.
 *
 *  First some private stuff:
 */
typedef struct uipage_entry {
    UIP_t	type;
    unsigned	flags;
    char *	url;
    HTList *	alturls;
    char *	file;
} uip_entry;

#define UIP_F_MULTI	0x0001	/* flag: track multiple instances */
#define UIP_F_LIMIT	0x0002	/* flag: limit size of alturl list */
#define UIP_F_LMULTI   (UIP_F_MULTI | UIP_F_LIMIT)

static uip_entry ly_uip[] =
{
    { UIP_HISTORY		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_DOWNLOAD_OPTIONS	, 0	      , NULL, NULL, NULL }
  , { UIP_PRINT_OPTIONS		, 0	      , NULL, NULL, NULL }
  , { UIP_SHOWINFO		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_LIST_PAGE		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_VLINKS		, UIP_F_LMULTI, NULL, NULL, NULL }
#if !defined(NO_OPTION_FORMS)
  , { UIP_OPTIONS_MENU		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
#ifdef DIRED_SUPPORT
  , { UIP_DIRED_MENU		, 0	      , NULL, NULL, NULL }
  , { UIP_PERMIT_OPTIONS	, 0	      , NULL, NULL, NULL }
  , { UIP_UPLOAD_OPTIONS	, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
#ifdef EXP_ADDRLIST_PAGE
  , { UIP_ADDRLIST_PAGE		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
  , { UIP_LYNXCFG		, UIP_F_LMULTI, NULL, NULL, NULL }
#if !defined(NO_CONFIG_INFO)
  , { UIP_CONFIG_DEF		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
/* The following are not generated tempfiles: */
  , { UIP_TRACELOG		, 0	     , NULL, NULL, NULL }
#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
  , { UIP_INSTALL		, 0	     , NULL, NULL, NULL }
#endif

};

/*  Public entry points for User Interface Page management: */

PUBLIC BOOL LYIsUIPage3 ARGS3(
    CONST char *,	url,
    UIP_t,		type,
    int,		flagparam)
{
    unsigned int i;
    size_t l;
    if (!url)
	return NO;
    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	if (ly_uip[i].type == type) {
	    if (!ly_uip[i].url) {
		return NO;
	    } else if ((flagparam & UIP_P_FRAG) ?
		       (!strncmp(ly_uip[i].url, url, (l=strlen(ly_uip[i].url)))
			&& (url[l] == '\0' || url[l] == '#')) :
		       !strcmp(ly_uip[i].url, url)) {
		return YES;
	    } else if (ly_uip[i].flags & UIP_F_MULTI) {
		char *p;
		HTList *l0 = ly_uip[i].alturls;

		while ((p = HTList_nextObject(l0)) != NULL) {
		    if ((flagparam & UIP_P_FRAG) ?
		       (!strncmp(p, url, (l=strlen(p)))
			&& (url[l] == '\0' || url[l] == '#')) :
			!strcmp(p, url))
			return YES;
		}
	    }
	    return NO;
a6030 61
    return NO;
}

PUBLIC void LYRegisterUIPage ARGS2(
    CONST char *,	url,
    UIP_t,		type)
{
    unsigned int i;
    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	if (ly_uip[i].type == type) {
	    if (ly_uip[i].url && url &&
		!strcmp(ly_uip[i].url, url)) {

	    } else if (!ly_uip[i].url || !url ||
		       !(ly_uip[i].flags & UIP_F_MULTI)) {
		StrAllocCopy(ly_uip[i].url, url);

	    } else {
		char *p;
		int n = 0;
		HTList *l0 = ly_uip[i].alturls;

		while ((p = HTList_nextObject(l0)) != NULL) {
		    if (!strcmp(p, url))
			return;
		    if (!strcmp(p, ly_uip[i].url)) {
			StrAllocCopy(ly_uip[i].url, url);
			return;
		    }
		    n++;
		}
		if (!ly_uip[i].alturls)
		    ly_uip[i].alturls = HTList_new();

		if (n >= HTCacheSize && (ly_uip[i].flags & UIP_F_LIMIT))
		    HTList_removeFirstObject(ly_uip[i].alturls);
		HTList_addObject(ly_uip[i].alturls, ly_uip[i].url);
		ly_uip[i].url = NULL;
		StrAllocCopy(ly_uip[i].url, url);
	    }

	    return;
	}
    }
}

PUBLIC void LYUIPages_free NOARGS
{
    unsigned int i;
    char *p;
    HTList *l0;
    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	FREE(ly_uip[i].url);
	FREE(ly_uip[i].file);
	l0 = ly_uip[i].alturls;
	while ((p = HTList_nextObject(l0)) != NULL) {
	    FREE(p);
	}
	HTList_delete(ly_uip[i].alturls);
	ly_uip[i].alturls = NULL;
    }
d6037 1
a6037 1
PUBLIC  CONST char * wwwName ARGS1(
d6040 1
a6040 1
    CONST char *cp = NULL;
d6042 2
a6043 2
#if defined(USE_DOS_DRIVES)
    cp = HTDOS_wwwName(pathname);
d6046 1
a6046 1
    cp = HTVMS_wwwName(pathname);
d6048 1
a6048 1
    cp = pathname;
d6050 1
a6050 1
#endif
a6058 2
 *
 * Both strings are fixed buffer sizes, LY_MAXPATH.
a6064 1
    CONST char *cp2;
d6068 1
a6068 1
     *  or an "nl:" path on VMS. - FM
d6070 6
a6075 1
    if (LYIsNullDevice(given))
d6080 1
a6080 1
#ifdef HAVE_POPEN
d6086 1
a6086 1
	LYstrncpy(result, given, LY_MAXPATH);
d6090 1
a6090 3
    if ((cp = strchr(given, '~')) != 0
     && (cp2 = wwwName(Home_Dir())) != 0
     && strlen(cp2) + strlen(given) < LY_MAXPATH) {
d6094 1
a6094 1
	strcat(result, cp2);
d6103 1
a6103 3
    if (given[0] != '/'
     && strchr(given, ':') == NULL
     && strlen(given) < LY_MAXPATH - 13) {
d6114 1
a6114 1
    if (!LYisAbsPath(given)) {
d6120 1
a6120 8
	{
#ifdef SUPPORT_CHDIR
	    static char buf[LY_MAXPATH];
	    cp = Current_Dir(buf);
#else
	    cp = original_dir;
#endif
	}
a6125 1
    *result = 0;
d6128 3
a6130 3
	if (strlen(cp) >= LY_MAXPATH - 2)
	    return FALSE;
	sprintf(result, "%s/", cp);
a6131 4
    cp = HTSYS_name(given);
    if (strlen(result) + strlen(cp) >= LY_MAXPATH - 1)
	return FALSE;
    strcat(result, cp);
d6148 1
d6154 1
a6154 1
#ifdef HAVE_POPEN
d6169 2
a6170 1
    if (LYCanReadFile(filename)) {
d6193 1
a6193 1
    CONST char *leaf;
a6198 5
    if (!LYisAbsPath(source)) {
	char temp[LY_MAXPATH];
	Current_Dir(temp);
	StrAllocCat(*target, temp);
    }
d6204 5
a6208 7
/*
 * Open a temporary file for internal-pages, optionally reusing an existing
 * filename.
 */
PUBLIC FILE *InternalPageFP ARGS2(
	char *, filename,
	int,	reuse_flag)
d6210 1
a6210 1
    FILE *fp;
d6212 2
a6213 7
    if (LYReuseTempfiles && reuse_flag) {
	fp = LYOpenTempRewrite(filename, HTML_SUFFIX, BIN_W);
    } else {
	LYRemoveTemp(filename);
	fp = LYOpenTemp(filename, HTML_SUFFIX, BIN_W);
    }
    if (fp == NULL) {
d6215 1
d6217 5
a6221 1
    return fp;
d6223 1
a6229 2
    fprintf(fp0, "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n");

d6250 1
a6250 1
     && LYwouldPush(Title, NULL)
a6266 9
PUBLIC char *trimPoundSelector ARGS1(
	char *,		address)
{
    char *pound = findPoundSelector(address);
    if (pound != 0)
	*pound = '\0';
    return pound;
}

d6282 6
d6311 1
a6311 1
	char *,		path)
a6316 1
     && (len < LY_MAXPATH - 2)
a6322 16
 * Check if a given string contains a path separator
 */
PUBLIC char * LYLastPathSep ARGS1(
	CONST char *,	path)
{
    char *result;
#if defined(USE_DOS_DRIVES)
    if ((result = strrchr(path, '\\')) == 0)
	result = strrchr(path, '/');
#else
    result = strrchr(path, '/');
#endif
    return result;
}

/*
a6365 1
     && (len < LY_MAXPATH - 2)
d6379 1
a6379 1
    CONST char *program;
d6381 9
a6389 2
    if ((program = HTGetProgramPath(ppCOPY)) != NULL) {
	char *the_command = 0;
d6391 1
a6391 32
	HTAddParam(&the_command, COPY_COMMAND, 1, program);
	HTAddParam(&the_command, COPY_COMMAND, 2, src);
	HTAddParam(&the_command, COPY_COMMAND, 3, dst);
	HTEndParam(&the_command, COPY_COMMAND, 3);

	CTRACE((tfp, "command: %s\n", the_command));
	stop_curses();
	code = LYSystem(the_command);
	start_curses();

	FREE(the_command);
    } else {
	FILE *fin, *fout;
	unsigned char buff[BUFSIZ];
	int len;

	code = EOF;
	if ((fin = fopen(src, BIN_R)) != 0) {
	    if ((fout = fopen(dst, BIN_W)) != 0) {
		code = 0;
		while ((len = fread(buff, 1, sizeof(buff), fin)) > 0) {
		    fwrite(buff, 1, len, fout);
		    if (ferror(fout)) {
			code = EOF;
			break;
		    }
		}
		LYCloseOutput(fout);
	    }
	    LYCloseInput(fin);
	}
    }
a6392 3
    if (code) {
	HTAlert(CANNOT_WRITE_TO_FILE);
    }
d6397 1
a6397 1
 * Invoke a shell command, return nonzero on error.
a6403 8
#if defined(HAVE_SIGACTION) && defined(SIGTSTP) && !defined(USE_SLANG)
    struct sigaction saved_sigtstp_act;
    BOOLEAN sigtstp_saved = FALSE;
#endif
    int saved_errno = 0;
#ifdef __EMX__
    int scrsize[4];
#endif
d6407 1
a6407 1
    CTRACE((tfp, "LYSystem(%s)\n", command));
a6422 2

	_scrsize(scrsize);
a6440 67

    /*
     * This chunk of code does not work, for two reasons:
     * a) the Cygwin system() function edits out the backslashes
     * b) it does not account for more than one parameter, e.g., +number
     */
#if defined(__CYGWIN__) && defined(DOSPATH)	/* 1999/02/26 (Fri) */
    {
	char cmd[LY_MAXPATH];
	char win32_name[LY_MAXPATH];
	char new_cmd[LY_MAXPATH];
	char new_command[LY_MAXPATH * 2 + 10];
	char *p, *q;

	p = command;
	q = cmd;
	while (*p) {
	    if (*p == ' ')
		break;
	    else
		*q = *p;
	    p++;
	    q++;
	}
	*q = '\0';

	if (cmd[0] == '/')
	    cygwin_conv_to_full_posix_path(cmd, new_cmd);
	else
	    strcpy(new_cmd, cmd);

	while (*p == ' ')
	    p++;

	if (strchr(p, '\\') == NULL) {
	    /* for Windows Application */
	    cygwin_conv_to_full_win32_path(p, win32_name);
	    sprintf(new_command, "%.*s \"%.*s\"", LY_MAXPATH, new_cmd, LY_MAXPATH, win32_name);
	} else {
	    /* for DOS like editor */
	    q = win32_name;
	    while (*p) {
		if (*p == '\\') {
		    if (*(p+1) == '\\')
			p++;
		}
		*q = *p;
		q++, p++;
	    }
	    *q = '\0';
	    sprintf(new_command, "%.*s %.*s", LY_MAXPATH, new_cmd, LY_MAXPATH, win32_name);
	}
	command = new_command;
    }
#endif

#ifdef _WIN_CC
    code = exec_command(command, TRUE);	/* Wait exec */
#else /* !_WIN_CC */
#ifdef SIGPIPE
    if (restore_sigpipe_for_children)
	signal(SIGPIPE, SIG_DFL); /* Some commands expect the default */
#endif
#if defined(HAVE_SIGACTION) && defined(SIGTSTP) && !defined(USE_SLANG)
    if (!dump_output_immediately && !LYCursesON && !no_suspend)
	sigtstp_saved = LYToggleSigDfl(SIGTSTP, &saved_sigtstp_act, 1);
#endif
a6441 10
    saved_errno = errno;
#if defined(HAVE_SIGACTION) && defined(SIGTSTP) && !defined(USE_SLANG)
    if (sigtstp_saved)
	LYToggleSigDfl(SIGTSTP, &saved_sigtstp_act, 0);
#endif
#ifdef SIGPIPE
    if (restore_sigpipe_for_children)
	signal(SIGPIPE, SIG_IGN); /* Ignore it again - kw */
#endif
#endif
a6453 6
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ?? */
    set_errno(saved_errno);	/* may have been clobbered */
#endif
#ifdef __EMX__			/* Check whether the screen size changed */
    size_change(0);
#endif
a6459 42
#if defined(__CYGWIN__)	/* 1999/02/26 (Fri) */
PUBLIC int Cygwin_Shell NOARGS
{
    char *shell;
    int code;
    STARTUPINFO startUpInfo;
    PROCESS_INFORMATION procInfo;
    SECURITY_ATTRIBUTES sa;

    /* Set up security attributes to allow inheritance of the file handle */

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = 0;
    sa.bInheritHandle=TRUE;

    /* Init a startup structure */
    GetStartupInfo(&startUpInfo);

    shell = LYGetEnv("COMSPEC");

    /* Create the child process, specifying
     inherited handles. Pass the value of the
     handle as a command line parameter */
    code = 0;
    if (shell) {
	code = CreateProcess(0, shell, 0, 0,
			TRUE, 0,
			0, 0, &startUpInfo, &procInfo);

	if (!code) {
	    printf("shell = [%s], code = %ld\n", shell, GetLastError());
	}

	/* wait for the child to return (this is not a requirement
	   since the child is its own independent process) */
	WaitForSingleObject(procInfo.hProcess, INFINITE);
    }

    return code;
}
#endif

d6464 4
a6467 19
#ifdef WIN_EX
    shell = LYGetEnv("SHELL");
    if (shell) {
	if (access(shell, 0) != 0)
	    shell = LYGetEnv("COMSPEC");
    }
    if (shell == NULL) {
	if (system_is_NT)
	    shell = "cmd.exe";
	else
	    shell = "command.com";
    }
#else
    shell = LYGetEnv("SHELL");
    if (shell == NULL) {
	shell = LYGetEnv("COMSPEC");
    }
    if (shell == NULL) {
	shell = "command.com";
a6468 1
#endif /* WIN_EX */
d6471 2
a6472 2
    if (LYGetEnv("SHELL") != NULL) {
	shell = LYGetEnv("SHELL");
d6474 1
a6474 1
	shell = (LYGetEnv("COMSPEC") == NULL) ? "cmd.exe" : LYGetEnv("COMSPEC");
d6498 4
a6501 1
    return LYGetEnv(DISPLAY);
d6511 1
a6511 1
    if (new_display != 0) {
d6517 3
d6521 1
a6521 1
	HTSprintf0(&display_putenv_command, "DISPLAY=%s", new_display);
a6528 445

#ifdef CAN_CUT_AND_PASTE
#ifdef __EMX__

static int proc_type = -1;
static PPIB pib;
static HAB hab;
static HMQ hmq;

PRIVATE void morph_PM NOARGS
{
    PTIB tib;
    int first = 0;

    if (proc_type == -1) {
	DosGetInfoBlocks(&tib, &pib);
	proc_type = pib->pib_ultype;
	first = 1;
    }
    if (pib->pib_ultype != 3)		/* 2 is VIO */
	pib->pib_ultype = 3;		/* 3 is PM */
    if (first)
	hab = WinInitialize(0);
    /* 64 messages if before OS/2 3.0, ignored otherwise */
    hmq = WinCreateMsgQueue(hab, 64);
    WinCancelShutdown(hmq, 1);	/* Do not inform us on shutdown */
}

PRIVATE void unmorph_PM NOARGS
{
    WinDestroyMsgQueue(hmq);
    pib->pib_ultype = proc_type;
}

PUBLIC int size_clip NOARGS
{
    return 8192;
}

/* Code partially stolen from FED editor. */

PUBLIC int put_clip ARGS1(char *, s)
{
    int sz = strlen(s) + 1;
    int ret = EOF, nl = 0;
    char *pByte = 0, *s1 = s, c, *t;

    while ((c = *s1++)) {
	if (c == '\r' && *s1 == '\n')
	    s1++;
	else if (c == '\n')
	    nl++;
    }
    if (DosAllocSharedMem((PPVOID)&pByte, 0, sz + nl,
			  PAG_WRITE | PAG_COMMIT | OBJ_GIVEABLE | OBJ_GETTABLE))
	return ret;

    if (!nl)
	memcpy(pByte, s, sz);
    else {
	t = pByte;
	while ((c = *t++ = *s++))
	    if (c == '\n' && (t == pByte + 1 || t[-2] != '\r'))
		t[-1] = '\r', *t++ = '\n';
    }

    morph_PM();
    if(!hab)
	goto fail;

    WinOpenClipbrd(hab);
    WinEmptyClipbrd(hab);
    if (WinSetClipbrdData(hab, (ULONG) pByte, CF_TEXT, CFI_POINTER))
	ret = 0;
    WinCloseClipbrd(hab);
    unmorph_PM();
    if (ret == 0)
	return 0;
  fail:
    DosFreeMem((PPVOID)&pByte);
    return EOF;
}

static int clip_open;

/* get_clip_grab() returns a pointer to the string in the system area.
   get_clip_release() should be called ASAP after this. */

PUBLIC char* get_clip_grab NOARGS
{
    char *ClipData;
    ULONG ulFormat;
    int sz;

    morph_PM();
    if(!hab)
	return 0;
    if (clip_open)
	get_clip_release();

    WinQueryClipbrdFmtInfo(hab, CF_TEXT, &ulFormat);
    if(ulFormat != CFI_POINTER) {
	unmorph_PM();
	return 0;
    }
    WinOpenClipbrd(hab);
    clip_open = 1;
    ClipData = (char *)WinQueryClipbrdData(hab, CF_TEXT);
    sz = strlen(ClipData);
    if(!ClipData || !sz) {
	get_clip_release();
	return 0;
    }
    return ClipData;
}

PUBLIC void get_clip_release NOARGS
{
    if (!clip_open)
	return;
    WinCloseClipbrd(hab);
    clip_open = 0;
    unmorph_PM();
}

#else	/* !( defined __EMX__ ) */

#  if !defined(WIN_EX) && defined(HAVE_POPEN)

static FILE* paste_handle = 0;
static char *paste_buf = NULL;

PUBLIC void get_clip_release NOARGS
{
    if (paste_handle != 0)
	pclose(paste_handle);
    if (paste_buf)
	FREE (paste_buf);
}

PRIVATE int clip_grab NOARGS
{
    char *cmd = getenv ("RL_PASTE_CMD");

    if (paste_handle)
	pclose(paste_handle);
    if (!cmd)
	return 0;

    paste_handle = popen(cmd, "rt");
    if (!paste_handle)
	return 0;
    return 1;
}

#define PASTE_BUFFER 1008
#define CF_TEXT 0			/* Not used */

PUBLIC char* get_clip_grab NOARGS
{
    int len;
    int size = PASTE_BUFFER;
    int off = 0;

    if (!clip_grab())
	return NULL;
    if (!paste_handle)
	return NULL;
    if (paste_buf)
	FREE (paste_buf);
    paste_buf = (char*)malloc (PASTE_BUFFER);
    while (1) {
	len = fread (paste_buf + off, 1, PASTE_BUFFER - 1, paste_handle);
	paste_buf[off + len] = '\0';
	if (len < PASTE_BUFFER - 1)
	break;
	if (strchr (paste_buf + off, '\r')
	 || strchr (paste_buf + off, '\n'))
	    break;
	paste_buf = realloc (paste_buf, size += PASTE_BUFFER - 1);
	off += len;
    }
    return paste_buf;
}

PUBLIC int
put_clip ARGS1(char *, s)
{
    char *cmd = getenv ("RL_CLCOPY_CMD");
    FILE *fh;
    int l = strlen(s), res;

    if (!cmd)
	return -1;

    fh = popen (cmd, "wt");
    if (!fh)
	return -1;
    res = fwrite (s, 1, l, fh);
    if (pclose (fh) != 0 || res != l)
	return -1;
    return 0;
}

#  endif	/* !defined(WIN_EX) && defined(HAVE_POPEN) */

#endif /* __EMX__ */

#if defined(WIN_EX)	/* 1997/10/16 (Thu) 20:13:28 */

PUBLIC int put_clip(char *szBuffer)
{
    HANDLE hWnd;
    HANDLE m_hLogData;
    LPTSTR pLogData;
    HANDLE hClip;
    int len;

    if (szBuffer == NULL)
	return EOF;

    len = strlen(szBuffer);
    if (len == 0)
	return EOF;
    else
	len ++;

    m_hLogData = GlobalAlloc(GHND, len);
    if (m_hLogData == NULL) {
	return EOF;
    }

    hWnd = NULL;
    if (!OpenClipboard(hWnd)) {
	return EOF;
    }
    /* Remove the current Clipboard contents */
    if (!EmptyClipboard()) {
	GlobalFree(m_hLogData);
	return EOF;
    }

    /* Lock the global memory while we write to it. */
    pLogData = (LPTSTR) GlobalLock(m_hLogData);

    lstrcpy((LPTSTR) pLogData, szBuffer);
    GlobalUnlock(m_hLogData);

    /* If there were any lines at all then copy them to clipboard. */
    hClip = SetClipboardData(CF_TEXT, m_hLogData);
    if (!hClip) {
	/* If we couldn't clip the data then free the global handle. */
	GlobalFree(m_hLogData);
    }

    CloseClipboard();
    return 0;
}

static HANDLE m_hLogData;
static int m_locked;

/* get_clip_grab() returns a pointer to the string in the system area.
   get_clip_release() should be called ASAP after this. */

PUBLIC char* get_clip_grab()
{
    HANDLE hWnd;
    LPTSTR pLogData;

    hWnd = NULL;
    if (!OpenClipboard(hWnd)) {
	return 0;
    }

    m_hLogData = GetClipboardData(CF_TEXT);

    if (m_hLogData == NULL) {
	CloseClipboard();
	m_locked = 0;
	return 0;
    }
    pLogData = (LPTSTR) GlobalLock(m_hLogData);

    m_locked = 1;
    return pLogData;
}

PUBLIC void get_clip_release()
{
    if (!m_locked)
	return;
    GlobalUnlock(m_hLogData);
    CloseClipboard();
    m_locked = 0;
}
#endif	/* WIN_EX */
#endif /* CAN_CUT_AND_PASTE */

#if defined(WIN_EX)

#ifndef WSABASEERR
#define WSABASEERR 10000
#endif

/*
 * Description: the windows32 version of perror()
 *
 * Returns:  a pointer to a static error
 *
 * Notes/Dependencies:  I got this from
 *      comp.os.ms-windows.programmer.win32
 */
PUBLIC char * w32_strerror(DWORD ercode)
{
/*  __declspec(thread) necessary if you will use multiple threads */
#ifdef __CYGWIN__
    static char msg_buff[256];
#else
    __declspec(thread) static char msg_buff[256];
#endif
    HMODULE hModule;
    int i, msg_type;
    unsigned char *p, *q, tmp_buff[256];

    hModule = NULL;
    msg_type = FORMAT_MESSAGE_FROM_SYSTEM;
    /* Fill message buffer with a default message in
     * case FormatMessage fails
     */
    wsprintf(msg_buff, "Error %ld", ercode);

    /*
     *  Special code for winsock error handling.
     */
    if (ercode > WSABASEERR) {
	hModule = GetModuleHandle("wsock32");
	if (hModule == NULL)
	    ercode = GetLastError();
	else
	    msg_type = FORMAT_MESSAGE_FROM_HMODULE;
    }
    /*
     *  message handling
     */
    FormatMessage(msg_type,
		  hModule,
		  ercode,
		  LANG_NEUTRAL,
		  msg_buff,
		  sizeof(msg_buff),
		  NULL);

    strcpy(tmp_buff, msg_buff);
    p = q = tmp_buff;
    i = 0;
    while (*p) {
	if (!(*p == '\n' || *p == '\r'))
	    msg_buff[i++] = *p;
	p++;
    }
    msg_buff[i] = '\0';

    return msg_buff;
}

#endif

#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
/*
 * syslog() interface
 */
PUBLIC void LYOpenlog ARGS1(
	CONST char *, banner)
{
#if defined(DJGPP)
    openlog("lynx", LOG_PID|LOG_NDELAY, LOG_LOCAL5);
#else
    openlog("lynx", LOG_PID, LOG_LOCAL5);
#endif

    if (banner) {
	syslog(LOG_INFO, "Session start:%s", banner);
    } else {
	syslog(LOG_INFO, "Session start");
    }
}

PRIVATE BOOLEAN looks_like_password ARGS2(
	char *,		first,
	char *,		last)
{
    BOOLEAN result = FALSE;

    while (first <= last) {
	if (*first == '/'
	 || *first == ':') {
	    result = FALSE;
	    break;
	}
	result = TRUE;
	first++;
    }
    return result;
}

PUBLIC void LYSyslog ARGS1(
	char *,		arg)
{
    char *colon1;
    char *colon2;
    char *atsign;

    CTRACE((tfp, "LYSyslog %s\n", arg));

    if (is_url(arg)) {	/* proto://user:password@@host/path:port */
			/*	^this colon		    */
	if ((colon1 = strchr(arg, ':')) != 0
	 && !strncmp(colon1, "://", 3)
	 && (colon2 = strchr(colon1+3, ':')) != 0
	 && (atsign = strchr(colon1, '@@')) != 0
	 && (colon2 < atsign)
	 && looks_like_password(colon2 + 1, atsign - 1)) {
	    char *buf = NULL;

	    StrAllocCopy(buf, arg);
	    buf[colon2 - arg + 1] = 0;
	    StrAllocCat(buf, "******");
	    StrAllocCat(buf, atsign);
	    syslog (LOG_INFO|LOG_LOCAL5, "%s", buf);
	    CTRACE((tfp, "...alter %s\n", buf));
	    FREE(buf);
	    return;
	}
    }
    syslog (LOG_INFO|LOG_LOCAL5, "%s", NONNULL(arg));
}

PUBLIC void LYCloselog NOARGS
{
  syslog(LOG_INFO, "Session over");
  closelog();
}

#endif /* !VMS && SYSLOG_REQUESTED_URLS */
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@d1539 1
a1539 1
#if !defined(USE_SLANG)
d5936 1
a5936 1
#if defined(MULTI_USER_UNIX) && (defined(HAVE_MKTEMP) || defined(HAVE_MKDTEMP))
a6683 2
	if (!LYIsHtmlSep(*temp))
	    LYAddHtmlSep(target);
@


1.1.3.3
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@a193 31
 * ascii versions of locale sensitive functions needed because in
 * Turkish locales tolower("I") is not "i". That's fatal for case
 * sensitive operations with charset names, HTML tags etc.
 */
#ifdef EXP_ASCII_CTYPES
PUBLIC int ascii_tolower ARGS1(int, i)
{
    if ( 91 > i && i > 64 )
	return (i+32);
    else
	return i;
}

PUBLIC int ascii_toupper ARGS1(int, i)
{
    if ( 123 > i && i > 96 )
	return (i-32);
    else
	return i;
}

PUBLIC int ascii_isupper ARGS1(int, i)
{
    if ( 91 > i && i > 64 )
	return 1;
    else
	return 0;
}
#endif /* EXP_ASCII_CTYPES */

/*
a5321 24
 * Given a filename, concatenate it to the save-space pathname, unless it is
 * an absolute pathname.  If there is no save-space defined, use the home
 * directory. Return a new string with the result.
 */
PUBLIC char * LYAddPathToSave ARGS1(
	char *,		fname)
{
    char *result = NULL;

    if (LYisAbsPath(fname)) {
	StrAllocCopy(result, fname);
    } else {
	if (lynx_save_space != NULL) {
	    StrAllocCopy(result, lynx_save_space);
	} else {
	    char temp[LY_MAXPATH];
	    LYAddPathToHome(temp, sizeof(temp), fname);
	    StrAllocCopy(result, temp);
	}
    }
    return result;
}

/*
a6935 27
#ifdef __DJGPP__
PRIVATE char *escape_backslashes ARGS1(char *, source)
{
    char *result = 0;
    int count = 0;
    int n;

    for (n = 0; source[n] != '\0'; ++n) {
	if (source[n] == '\\')
	    ++count;
    }
    if (count != 0) {
	result = malloc(count + n + 1);
	if (result != 0) {
	    int ch;
	    char *target = result;
	    while ((ch = *source++) != '\0') {
		if (ch == '\\')
		    *target++ = ch;
		*target++ = ch;
	    }
	    *target = '\0';
	}
    }
    return result;
}
#endif /* __DJGPP__ */
a7046 11
#ifdef __DJGPP__
    if (dj_is_bash) {
	char *new_command = escape_backslashes(command);
	if (new_command != 0) {
	    if (do_free)
		free(command);
	    command = new_command;
	}
    }
#endif /* __DJGPP__ */

d7356 1
a7356 1
    char *cmd = LYGetEnv("RL_PASTE_CMD");
d7402 1
a7402 1
    char *cmd = LYGetEnv("RL_CLCOPY_CMD");
@


1.1.3.4
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@a6 8

#ifdef __MINGW32__
int kbhit(void);
#ifdef UNIX
#undef UNIX
#endif /* UNIX */
#endif /* __MINGW32__ */

d1452 1
a1452 1
    /* lynx_stop_reverse(); */
d6011 1
a6011 1
	    StrAllocCat(lynx_temp_space, "XXXXXXXXXX");
@


1.1.3.5
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d106 2
a107 2
extern int BSDselect (int nfds, fd_set * readfds, fd_set * writefds,
			     fd_set * exceptfds, struct timeval * timeout);
d150 2
a151 2
static HTList * localhost_aliases = NULL;	/* Hosts to treat as local */
static char *HomeDir = NULL;			/* HOME directory */
d153 1
a153 1
HTList * sug_filenames = NULL;		/* Suggested filenames	 */
d166 1
a166 1
static LY_TEMP *ly_temp;
d168 1
a168 1
static LY_TEMP *FindTempfileByName (const char * name)
d180 1
a180 1
static LY_TEMP *FindTempfileByFP (FILE * fp)
d195 1
a195 1
char *LYGetEnv (const char * name)
d207 1
a207 1
int ascii_tolower (int i)
d215 1
a215 1
int ascii_toupper (int i)
d223 1
a223 1
int ascii_isupper (int i)
d236 3
a238 3
size_t utf8_length (
	BOOL		utf_flag,
	const char *	data)
d272 3
a274 3
void LYSetHilite (
	int		cur,
	char *		text)
d284 4
a287 4
void LYAddHilite (
	int		cur,
	char *		text,
	int		x)
d307 3
a309 3
char *LYGetHiliteStr (
	int		cur,
	int		count)
d325 3
a327 3
int LYGetHilitePos (
	int		cur,
	int		count)
d362 7
a368 7
static BOOL show_whereis_targets (
	int	flag,
	int	cur,
	int	count,
	char *	target,
	BOOL	TargetEmphasisON,
	BOOL	utf_flag)
d927 3
a929 3
static int find_cached_style (
	int	cur,
	int	flag)
d987 4
a990 4
void LYhighlight (
	int		flag,
	int		cur,
	char *		target)
d1162 2
a1163 2
void free_and_clear (
	char **	pointer)
d1179 3
a1181 3
void convert_to_spaces (
	char *		string,
	BOOL		condense)
d1225 2
a1226 2
char * strip_trailing_slash (
	char *		dirname)
d1241 2
a1242 2
void statusline (
	const char *	text)
d1291 1
a1291 1
	    TO_EUC((const unsigned char *)text_buff, temp);
d1297 1
a1297 1
		TO_SJIS((const unsigned char *)text_buff, temp);
d1427 2
a1428 2
static char *novice_lines (
	int		lineno)
d1444 1
a1444 1
void toggle_novice_line (void)
d1452 2
a1453 2
void noviceline (
	int		more_flag GCC_UNUSED)
d1487 2
a1488 2
int LYConsoleInputFD (
    BOOLEAN		need_selectable)
d1516 1
a1516 1
static int fake_zap = 0;
d1518 2
a1519 2
void LYFakeZap (
    BOOL	set)
d1536 1
a1536 1
static int DontCheck (void)
d1573 1
a1573 1
int HTCheckForInterrupt (void)
d1802 2
a1803 2
BOOLEAN LYisAbsPath (
	const char *	path)
d1825 2
a1826 2
BOOLEAN LYisRootPath (
	const char *		path)
d1841 2
a1842 2
BOOLEAN LYisLocalFile (
	const char *		filename)
d1879 2
a1880 2
BOOLEAN LYisLocalHost (
	const char *		filename)
d1911 1
a1911 1
void LYLocalhostAliases_free (void)
d1930 2
a1931 2
void LYAddLocalhostAlias (
	char *		alias)
d1955 2
a1956 2
BOOLEAN LYisLocalAlias (
	const char *		filename)
d1997 2
a1998 2
int LYCheckForProxyURL (
	char *		filename)
d2051 4
a2054 4
static BOOLEAN compare_type (
	char *		tst,
	const char *	cmp,
	size_t		len)
d2085 2
a2086 2
int is_url (
	char *		filename)
d2425 2
a2426 2
void LYFixCursesOn (
    const char *	reason)
d2447 3
a2449 3
BOOLEAN LYFixCursesOnForAccess (
    const char *	addr,
    const char *	physical)
d2487 2
a2488 2
BOOLEAN LYCanDoHEAD (
    const char *	address)
d2563 2
a2564 2
BOOLEAN LYCloseInput (
	FILE *		fp)
d2579 2
a2580 2
BOOLEAN LYCloseOutput (
	FILE *		fp)
d2596 2
a2597 2
BOOLEAN LYCanWriteFile (
	const char*	filename)
d2611 2
a2612 2
BOOLEAN LYCanReadFile (
	const char*	filename)
d2625 2
a2626 2
void remove_backslashes (
	char *		buf)
d2650 1
a2650 1
BOOLEAN inlocaldomain (void)
d2699 3
a2701 3
void LYExtSignal (
    int			sig,
    LYSigHandlerFunc_t *	handler)
d2737 4
a2740 4
static BOOLEAN LYToggleSigDfl (
    int			sig,
    struct sigaction *		where,
    int			to_dfl)
d2792 2
a2793 2
void size_change (
	int		sig GCC_UNUSED)
d2891 1
a2891 1
void HTSugFilenames_free (void)
d2911 2
a2912 2
void HTAddSugFilename (
	char *		fname)
d2949 2
a2950 2
void change_sug_filename (
	char *		fname)
d2952 1
a2952 1
    const char *cp2;
d3250 4
a3253 4
static int fmt_tempname (
	char *		result,
	const char *	prefix,
	const char *	suffix)
d3322 1
a3322 1
	const char *tail = strchr(suffix, '.');
d3349 2
a3350 2
int number2arrows (
	int		number)
d3396 2
a3397 2
static const struct {
    const char *name;
d3497 4
a3500 4
BOOL strn_dash_equ (
	const char*	p1,
	const char*	p2,
	int		len)
d3540 2
a3541 2
const char *index_to_restriction (
    int	inx)
d3552 3
a3554 3
int find_restriction (
    const char *	name,
    int		len)
d3567 2
a3568 2
void parse_restrictions (
    const char *	s)
d3570 2
a3571 2
    const char *p;
    const char *word;
d3623 2
a3624 2
void print_restrictions_to_fd (
    FILE *	fp)
d3663 1
a3663 1
void LYCheckMail (void)
d3739 1
a3739 1
void LYCheckMail (void)
d3794 4
a3797 4
void LYEnsureAbsoluteURL (
	char **	href,
	const char *	name,
	int		fixit)
d3836 3
a3838 3
void LYConvertToURL (
	char **	AllocatedString,
	int		fixit)
d4207 1
a4207 1
		    const char *p, *q;
d4317 1
a4317 1
int win32_check_interrupt(void)
d4366 4
a4369 4
BOOLEAN LYExpandHostForURL (
	char **	AllocatedString,
	char *		prefix_list,
	char *		suffix_list)
d4683 3
a4685 3
BOOLEAN LYAddSchemeForURL (
	char **	AllocatedString,
	char *		default_scheme)
d4787 2
a4788 2
void LYTrimRelFromAbsPath (
	char *		path)
d4863 4
a4866 4
void LYDoCSI (
	char *		url,
	const char *	comment,
	char **	csi)
d4868 1
a4868 1
    const char *cp = comment;
d4891 3
a4893 3
void Define_VMSLogical (
	char *		LogicalName,
	char *		LogicalValue)
d4918 1
a4918 1
static void LYHomeDir_free (void)
d4924 2
a4925 2
char * Current_Dir (
	char *	pathname)
d4942 2
a4943 2
static char * CheckDir (
    char *	path)
d4957 1
a4957 1
static char *HomeEnv (void)
d5000 1
a5000 1
const char * Home_Dir (void)
d5002 1
a5002 1
    static const char *homedir = NULL;
d5036 1
a5036 1
	homedir = (const char *)HomeDir;
d5053 1
a5053 1
char *LYPathLeaf (char * pathname)
d5089 3
a5091 3
BOOLEAN LYPathOffHomeOK (
	char *		fbuffer,
	size_t		fbuffer_size)
d5265 4
a5268 4
void LYAddPathToHome (
	char *		fbuffer,
	size_t		fbuffer_size,
	char *		fname)
d5365 2
a5366 2
char * LYAddPathToSave (
	char *		fname)
d5400 3
a5402 3
time_t LYmktime (
	char *		string,
	BOOL		absolute)
d5678 2
a5679 2
int putenv (
	const char *	string)
d5731 1
a5731 1
int remove (char * name)
d5753 1
a5753 1
static BOOL IsOurFile (char * name)
d5815 1
a5815 1
static FILE *OpenHiddenFile (char * name, char * mode)
d5870 1
a5870 1
FILE *LYNewBinFile (char * name)
d5881 1
a5881 1
FILE *LYNewTxtFile (char * name)
d5899 1
a5899 1
FILE *LYAppendToTxtFile (char * name)
d5922 1
a5922 1
void LYRelaxFilePermissions (const char * name)
d5945 3
a5947 3
BOOLEAN LYCachedTemp (
	char *		result,
	char **	cached)
d5970 4
a5973 4
FILE *LYOpenTemp (
	char *		result,
	const char *	suffix,
	const char *	mode)
d6080 2
a6081 2
FILE *LYReopenTemp (
	char *		name)
d6108 4
a6111 4
FILE *LYOpenTempRewrite (
	char *		fname,
	const char *	suffix,
	const char *	mode)
d6256 3
a6258 3
FILE *LYOpenScratch (
	char *		result,
	const char *	prefix)
d6280 2
a6281 2
static void LY_close_temp (
	LY_TEMP *	p)
d6296 2
a6297 2
void LYCloseTemp (
	char * name)
d6312 2
a6313 2
void LYCloseTempFP (
	FILE * fp)
d6327 2
a6328 2
int LYRemoveTemp (
	char * name)
d6360 1
a6360 1
void LYCleanupTemp (void)
d6380 3
a6382 3
void LYRenamedTemp (
	char *		oldname,
	char *		newname)
d6396 1
a6396 1
void LYCheckBibHost (void)
d6470 4
a6473 4
BOOL LYIsUIPage3 (
    const char *	url,
    UIP_t		type,
    int		flagparam)
d6506 3
a6508 3
void LYRegisterUIPage (
    const char *	url,
    UIP_t		type)
d6549 1
a6549 1
void LYUIPages_free (void)
d6570 2
a6571 2
const char * wwwName (
	const char *	pathname)
d6573 1
a6573 1
    const char *cp = NULL;
d6595 3
a6597 3
BOOLEAN LYValidateFilename (
	char *		result,
	char *		given)
d6600 1
a6600 1
    const char *cp2;
d6692 2
a6693 2
int LYValidateOutput (
	char *		filename)
d6734 3
a6736 3
void LYLocalFileToURL (
	char **	target,
	const char *	source)
d6738 1
a6738 1
    const char *leaf;
d6760 3
a6762 3
FILE *InternalPageFP (
	char * filename,
	int	reuse_flag)
d6778 4
a6781 4
void BeginInternalPage (
	FILE * fp0,
	char* Title,
	char* HelpURL)
d6816 2
a6817 2
void EndInternalPage (
	FILE * fp0)
d6822 2
a6823 2
char *trimPoundSelector (
	char *		address)
d6835 2
a6836 2
void LYTrimPathSep (
	char *	path)
d6850 2
a6851 2
void LYAddPathSep (
	char **	path)
d6868 2
a6869 2
void LYAddPathSep0 (
	char *		path)
d6884 2
a6885 2
char * LYLastPathSep (
	const char *	path)
d6901 2
a6902 2
void LYTrimHtmlSep (
	char *	path)
d6916 2
a6917 2
void LYAddHtmlSep (
	char **	path)
d6934 2
a6935 2
void LYAddHtmlSep0 (
	char *		path)
d6950 3
a6952 3
int LYCopyFile (
	char *		src,
	char *		dst)
d6955 1
a6955 1
    const char *program;
d7000 1
a7000 1
static char *escape_backslashes (char * source)
d7029 2
a7030 2
int LYSystem (
	char *	command)
d7195 1
a7195 1
int Cygwin_Shell (void)
d7236 1
a7236 1
char *LYSysShell (void)
d7288 1
a7288 1
char *LYgetXDisplay (void)
d7297 2
a7298 2
void LYsetXDisplay (
	char *	new_display)
d7324 1
a7324 1
static void morph_PM (void)
d7343 1
a7343 1
static void unmorph_PM (void)
d7349 1
a7349 1
int size_clip (void)
d7356 1
a7356 1
int put_clip (char * s)
d7403 1
a7403 1
char* get_clip_grab (void)
d7431 1
a7431 1
void get_clip_release (void)
d7447 1
a7447 1
void get_clip_release (void)
d7455 1
a7455 1
static int clip_grab (void)
d7473 1
a7473 1
char* get_clip_grab (void)
d7500 2
a7501 2
int
put_clip (char * s)
d7525 1
a7525 1
int put_clip(char *szBuffer)
d7580 1
a7580 1
char* get_clip_grab()
d7603 1
a7603 1
void get_clip_release()
d7628 1
a7628 1
char * w32_strerror(DWORD ercode)
d7687 2
a7688 2
void LYOpenlog (
	const char * banner)
d7703 3
a7705 3
static BOOLEAN looks_like_password (
	char *		first,
	char *		last)
d7721 2
a7722 2
void LYSyslog (
	char *		arg)
d7753 1
a7753 1
void LYCloselog (void)
@


1.1.3.6
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@a9 1

d38 5
a42 1
#ifdef _WINDOWS			/* 1998/04/30 (Thu) 19:04:25 */
d53 4
a56 4
#  define BOOLEAN OS2_BOOLEAN	/* Conflicts, but is used */
#  undef HT_ERROR		/* Conflicts too */
#  define INCL_PM		/* I want some PM functions.. */
#  define INCL_DOSPROCESS	/* TIB PIB. */
d79 1
a79 1
#define UTMP_FILE __UTMPX_FILE	/* at least in OS/390  S/390 -- gil -- 2100 */
d81 1
a81 1
#define UTMP_FILE "/var/adm/utmpx"	/* Digital Unix 4.0 */
d106 2
a107 3
extern int BSDselect(int nfds, fd_set * readfds, fd_set * writefds,
		     fd_set * exceptfds, struct timeval *timeout);

d150 2
a151 2
static HTList *localhost_aliases = NULL;	/* Hosts to treat as local */
static char *HomeDir = NULL;	/* HOME directory */
d153 1
a153 1
HTList *sug_filenames = NULL;	/* Suggested filenames   */
d168 1
a168 1
static LY_TEMP *FindTempfileByName(const char *name)
d180 1
a180 1
static LY_TEMP *FindTempfileByFP(FILE *fp)
d195 1
a195 1
char *LYGetEnv(const char *name)
a197 1

d207 1
a207 1
int ascii_tolower(int i)
d209 2
a210 2
    if (91 > i && i > 64)
	return (i + 32);
d215 1
a215 1
int ascii_toupper(int i)
d217 2
a218 2
    if (123 > i && i > 96)
	return (i - 32);
d223 1
a223 1
int ascii_isupper(int i)
d225 1
a225 1
    if (91 > i && i > 64)
d236 3
a238 2
size_t utf8_length(BOOL utf_flag,
		   const char *data)
d255 1
a255 1
	     * Garbage.
d259 1
a259 1
	if (strlen(data + 1) < utf_extra) {
d261 1
a261 1
	     * Shouldn't happen.
d272 3
a274 2
void LYSetHilite(int cur,
		 char *text)
d284 4
a287 3
void LYAddHilite(int cur,
		 char *text,
		 int x)
d307 3
a309 2
char *LYGetHiliteStr(int cur,
		     int count)
d325 3
a327 2
int LYGetHilitePos(int cur,
		   int count)
d362 7
a368 6
static BOOL show_whereis_targets(int flag,
				 int cur,
				 int count,
				 char *target,
				 BOOL TargetEmphasisON,
				 BOOL utf_flag)
d383 10
a392 10
	&& (links[cur].type & WWW_LINK_TYPE)
	&& non_empty(LYGetHiliteStr(cur, count))
	&& links[cur].ly + count < display_lines
	&& HText_getFirstTargetInLine(HTMainText,
				      links[cur].anchor_line_num + count,
				      utf_flag,
				      &Offset,
				      &tLen,
				      &theData,
				      target)) {
d413 1
a413 1
		LYmbcsstrlen(buffer, utf_flag, YES) : hlen);
d433 1
a433 1
		    && (offset + LenNeeded) < LYcols) {
d463 1
a463 1
		    LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
d527 1
a527 1
		     itmp++) {
d535 1
a535 1
			LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
d603 18
a620 21
		/*
		 * See if we have another hit that starts within the
		 * hightext.  -FM
		 */
		    && ((cp =
			 LYno_attr_mb_strstr(data = SKIP_GLYPHS(utf_flag,
								Data,
								offset - Offset),
					     target,
					     utf_flag, YES,
					     &HitOffset,
					     &LenNeeded)) != NULL)
		    && (offset + LenNeeded) < LYcols
		/*
		 * If the hit starts after the end of the hightext, or we
		 * are making the link current and the hit starts at its
		 * last character, we are done.  -FM
		 */
		    && (HitOffset + offset) <
		    (hoffset +
		     (flag == ON ? (hLen - 1) : hLen))) {
d634 1
a634 1
	  highlight_hit_within_hightext:
d641 1
a641 1
	    if ((Offset - offset) <= (flag == ON ? (hLen - 1) : hLen)) {
d659 1
a659 1
		    LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
d667 1
a667 1
			(offset > hoffset && data[itmp + 1] != '\0')) {
d688 1
a688 1
			(offset > hoffset && data[itmp + 1] != '\0')) {
d704 1
a704 1
			(offset > hoffset && data[itmp + 1] != '\0')) {
d726 1
a726 1
		     itmp++) {
d734 1
a734 1
			LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
d802 16
a817 20
		/*
		 * See if we have another hit that starts within the
		 * hightext.  -FM
		 */
		    && ((cp =
			 LYno_attr_mb_strstr(data = SKIP_GLYPHS(utf_flag,
								Data,
								offset - Offset),
					     target,
					     utf_flag, YES,
					     &HitOffset,
					     &LenNeeded)) != NULL)
		    && (offset + LenNeeded) < LYcols
		/*
		 * If the hit starts after the end of the hightext, or we
		 * are making the link current and the hit starts at its
		 * last character, we are done.  -FM
		 */
		    && (HitOffset + offset) <
		    (hoffset + (flag == ON ? (hLen - 1) : hLen))) {
d842 1
a842 1
			     itmp++) {
d851 1
a851 1
				LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
d920 1
a920 1
  highlight_search_done:
d927 3
a929 2
static int find_cached_style(int cur,
			     int flag)
d934 3
a936 3
    if (textfields_need_activation
	&& links[cur].type == WWW_FORM_LINK_TYPE
	&& F_TEXTLIKE(links[cur].l_form->type))
a941 1

d952 1
a952 1
		     LYP, LXP));
d955 1
a955 1
		for (x = LXP - 1; x >= 0; x--) {
d962 1
a962 1
				cached_styles[LYP][x], (int) x - LXP));
d974 1
a974 2
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.off: can't use cache.\n"));
d985 1
a985 1
 * Highlight (or unhighlight) a given link.
d987 4
a990 3
void LYhighlight(int flag,
		 int cur,
		 char *target)
a997 1

d1002 1
a1002 1
    BOOL utf_flag = (BOOL) (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8);
a1003 1

a1005 1

d1031 1
a1031 1
	    || LYGetHiliteStr(cur, 0) == NULL) {
d1034 1
a1034 1
	    lynx_start_link_color(flag == ON, links[cur].inUnderline);
d1066 1
a1066 3
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.off: NOFIX branch @@(%d,%d).\n",
		     LYP, LXP));
d1083 1
a1083 1
	 * Display a second line as well.
d1090 3
a1092 3
		 (hi_string = LYGetHiliteStr(cur, hi_count)) != NULL
		 && links[cur].ly + hi_count <= display_lines;
		 ++hi_count) {
d1095 1
a1095 1
		lynx_stop_link_color(flag == ON, links[cur].inUnderline);
d1101 2
a1102 2
			 links[cur].ly + hi_count, hi_offset,
			 flag == ON ? s_alink : s_a));
d1105 1
a1105 1
		lynx_start_link_color(flag == ON, links[cur].inUnderline);
d1109 1
a1109 1
		     && (i + hi_offset) < LYcols; i++) {
d1121 1
a1121 1
		    }
d1124 1
a1124 1
	    lynx_stop_link_color(flag == ON, links[cur].inUnderline);
d1126 1
d1129 2
a1130 2
	     LYGetHiliteStr(cur, hi_count) != NULL;
	     hi_count++) {
d1141 1
a1141 1
	     * Get cursor out of the way.
d1147 1
a1147 1
	     * Never hide the cursor if there's no FANCY CURSES or SLANG.
d1150 1
a1150 1
		   ((links[cur].lx > 0) ? (links[cur].lx - 1) : 0));
d1159 2
a1160 2
 * free_and_clear will free a pointer if it is non-zero and then set it to
 * zero.
d1162 2
a1163 1
void free_and_clear(char **pointer)
d1173 9
a1181 8
 * Convert single or serial newlines to single spaces throughout a string
 * (ignore newlines if the preceding character is a space) and convert tabs to
 * single spaces.  Don't ignore any explicit tabs or spaces if the condense
 * argument is FALSE, otherwise, condense any serial spaces or tabs to one
 * space.  - FM
 */
void convert_to_spaces(char *string,
		       BOOL condense)
d1190 2
a1191 1
    for (; (*s && !isspace(*s)); s++) ;
d1196 6
a1201 6
	case ' ':
	case '\t':
	    if (!(condense && last_is_space))
		*(ns++) = ' ';
	    last_is_space = TRUE;
	    break;
d1203 7
a1209 7
	case '\r':
	case '\n':
	    if (!last_is_space) {
		*(ns++) = ' ';
		last_is_space = TRUE;
	    }
	    break;
d1211 4
a1214 4
	default:
	    *(ns++) = *s;
	    last_is_space = FALSE;
	    break;
d1223 1
a1223 1
 * Strip trailing slashes from directory paths.
d1225 2
a1226 1
char *strip_trailing_slash(char *dirname)
d1233 1
a1233 1
    return (dirname);
d1237 1
a1237 1
 * Display (or hide) the status line.
d1241 2
a1242 1
void statusline(const char *text)
d1255 1
a1255 1
     * Don't print statusline messages if dumping to stdout.
d1261 1
a1261 1
     * Don't print statusline message if turned off.
d1271 1
a1271 1
    LYstrncpy(text_buff, text, sizeof(text_buff) - 1);
d1274 1
a1274 1
	p = '\0';
d1277 3
a1279 3
     * Deal with any CJK escape sequences and Kanji if we have a CJK character
     * set selected, otherwise, strip any escapes.  Also, make sure text is not
     * longer than the statusline window.  - FM
d1281 2
a1282 2
    max_length = ((LYcols - 2) < (int) sizeof(buffer))
	? (LYcols - 2) : (int) sizeof(buffer) - 1;
d1286 1
a1286 1
	 * Translate or filter any escape sequences.  - FM
d1289 1
a1289 2
	      outofmem(__FILE__, "statusline");

d1291 1
a1291 1
	    TO_EUC((const unsigned char *) text_buff, temp);
d1297 1
a1297 1
		TO_SJIS((const unsigned char *) text_buff, temp);
d1303 1
a1303 1
		if (text_buff[i] != CH_ESC) {	/* S/390 -- gil -- 2119 */
d1311 1
a1311 1
	 * Deal with any newlines or tabs in the string.  - FM
d1313 1
a1313 1
	convert_to_spaces((char *) temp, FALSE);
d1316 2
a1317 2
	 * Handle the Kanji, making sure the text is not longer than the
	 * statusline window.  - FM
d1337 7
a1343 6
	 * Strip any escapes, and shorten text if necessary.  Note that we
	 * don't deal with the possibility of UTF-8 characters in the string. 
	 * This is unlikely, but if strings with such characters are used in
	 * LYMessages_en.h, a compilation symbol of HAVE_UTF8_STATUSLINES could
	 * be added there, and code added here for determining the displayed
	 * string length, as we do above for CJK.  - FM
d1346 1
a1346 1
	    if (text_buff[i] != CH_ESC) {	/* S/390 -- gil -- 2119 */
d1352 1
a1352 1
	 * Deal with any newlines or tabs in the string.  - FM
d1358 2
a1359 2
     * Move to the desired statusline window and output the text highlighted. 
     * - FM
d1362 1
a1362 1
	if (LYStatusLine < LYlines - 1) {
d1365 1
a1365 1
	    LYmove(LYlines - 1, 0);
d1368 1
a1368 1
	LYmove(LYlines - 3, 0);
d1370 1
a1370 1
	LYmove(LYlines - 1, 0);
d1393 1
d1395 3
a1397 3
	lynx_start_status_color();
	LYaddstr(buffer);
	lynx_stop_status_color();
d1401 18
a1418 19
	    int a = (strncmp(buffer, ALERT_FORMAT, ALERT_PREFIX_LEN)
		     || !hashStyles[s_alert].name)
	    ? s_status
	    : s_alert;

	    LynxChangeStyle(a, STACK_ON);
	    LYaddstr(buffer);
	    wbkgdset(LYwin,
		     ((lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
		      ? hashStyles[a].color
		      : A_NORMAL) | ' ');
	    LYclrtoeol();
	    if (!(lynx_has_color && LYShowColor >= SHOW_COLOR_ON))
		wbkgdset(LYwin, A_NORMAL | ' ');
	    else if (s_normal != NOSTYLE)
		wbkgdset(LYwin, hashStyles[s_normal].color | ' ');
	    else
		wbkgdset(LYwin, displayStyles[DSTYLE_NORMAL].color | ' ');
	    LynxChangeStyle(a, STACK_OFF);
d1427 2
a1428 1
static char *novice_lines(int lineno)
d1444 1
a1444 1
void toggle_novice_line(void)
d1446 4
a1449 4
    lineno++;
    if (*novice_lines(lineno) == '\0')
	lineno = 0;
    return;
d1452 2
a1453 1
void noviceline(int more_flag GCC_UNUSED)
d1459 1
a1459 1
    LYmove(LYlines - 2, 0);
d1473 1
a1473 1
	LYaddstr((char *) novice_lines(lineno));
d1481 5
a1485 4
 * Returns the file descriptor from which keyboard input is expected, or INVSOC
 * (-1) if not available.  If need_selectable is true, returns non-INVSOC fd
 * only if select() is possible - actually, currently only checks if fd is
 * connected to a tty.  - kw
d1487 2
a1488 1
int LYConsoleInputFD(BOOLEAN need_selectable)
a1490 1

d1495 3
a1497 3
    /* SLang_TT_Read_FD introduced in slang 0.99.19, from its changelog: 
     * SLang_TT_Read_FD variable is now available for unix.  This is the file
     * descriptor used by SLang_getkey.  */
d1501 1
a1501 1
#else /* !USE_SLANG */
d1518 2
a1519 1
void LYFakeZap(BOOL set)
d1536 1
a1536 1
static int DontCheck(void)
d1543 1
a1543 1
	return (TRUE);
d1545 2
a1546 2
    if (LYHaveCmdScript())	/* we may be running from a script */
	return (TRUE);
d1550 1
a1550 1
	return (TRUE);
d1560 1
a1560 2

	gettimeofday(&tv, (struct timezone *) 0);
d1564 1
a1564 1
    next = time((time_t *) 0);
d1573 1
a1573 1
int HTCheckForInterrupt(void)
d1577 1
a1577 2

#ifndef VMS			/* UNIX stuff: */
d1589 1
a1589 1
	return ((int) TRUE);
d1594 1
a1594 1
	return ((int) FALSE);
d1607 1
a1607 1
	return (FALSE);
d1617 1
a1617 1
	ret = Rselect(1, (void *) &readfds, NULL, NULL,
d1621 1
a1621 1
	ret = select(1, (void *) &readfds, NULL, NULL,
d1626 1
a1626 1
	return ((int) FALSE);
d1629 2
a1630 2
    if (!FD_ISSET(0, &readfds))
	return ((int) FALSE);
d1635 1
a1635 1
    nodelay(LYwin, TRUE);
d1642 1
a1642 1
    nodelay(LYwin, FALSE);
d1653 1
a1653 1
	return ((int) TRUE);
d1658 1
a1658 1
	return ((int) FALSE);
d1663 1
a1663 1
	return ((int) TRUE);
d1679 1
a1679 1
	return ((int) TRUE);
d1681 6
a1686 6
    /* There is a subset of mainloop() actions available at this stage:  no new
     * getfile() cycle is possible until the previous finished.  Currently we
     * have scrolling in partial mode, toggling of trace log, and pasting. 
     * User search now in progress...
     */
    cmd = (LKC_TO_LAC(keymap, c));
d1688 1
a1688 1
    case LYK_TRACE_TOGGLE:	/*  Toggle TRACE mode. */
d1692 2
a1693 2
    case LYK_TO_CLIPBOARD:{	/* ^S */
	    char *s = LYDownLoadAddress();
d1695 8
a1702 8
	    if (!s || !*s || put_clip(s))
		HTInfoMsg(gettext("Copy to clipboard failed."));
	    else
		HTInfoMsg(gettext("Download document URL put to clipboard."));
	    break;
	}
#endif /* defined CAN_CUT_AND_PASTE */
    default:
d1721 3
a1723 3
	    case LYK_FASTBACKW_LINK:
		if (Newline_partial <= (display_lines) + 1) {
		    Newline_partial -= display_lines;
d1730 1
a1730 1
		    Newline_partial -= display_lines;
d1733 1
a1733 1
	    case LYK_FASTFORW_LINK:
d1737 6
a1742 6
			 HTGetLinkOrFieldStart(HText_LinksInLines(HTMainText,
								  Newline_partial,
								  display_lines)
					       - 1,
					       &Newline_partial, NULL,
					       1, TRUE)) == LINK_LINE_FOUND) {
d1747 1
a1747 1
	    case LYK_PREV_PAGE:
d1749 3
a1751 3
		    Newline_partial -= display_lines;
		break;
	    case LYK_NEXT_PAGE:
d1753 3
a1755 3
		    Newline_partial += display_lines;
		break;
	    case LYK_UP_HALF:
d1757 3
a1759 3
		    Newline_partial -= (display_lines / 2);
		break;
	    case LYK_DOWN_HALF:
d1761 3
a1763 3
		    Newline_partial += (display_lines / 2);
		break;
	    case LYK_UP_TWO:
d1765 3
a1767 3
		    Newline_partial -= 2;
		break;
	    case LYK_DOWN_TWO:
d1769 2
a1770 2
		    Newline_partial += 2;
		break;
d1778 1
a1778 3
		/* calculate for "current" bottom value */
		break;
	    case LYK_REFRESH:
d1780 3
a1782 1
	    default:
d1784 2
a1785 2
		return ((int) FALSE);
	    }			/* end switch */
d1793 1
a1793 1
    }				/* end switch */
d1795 1
a1795 1
    return ((int) FALSE);
d1802 2
a1803 1
BOOLEAN LYisAbsPath(const char *path)
a1805 1

d1812 2
a1813 2
			 || (LYIsDosDrive(path)
			     && LYIsPathSep(path[2])));
d1825 2
a1826 1
BOOLEAN LYisRootPath(const char *path)
d1830 2
a1831 2
	&& LYIsDosDrive(path)
	&& LYIsPathSep(path[2]))
d1838 2
a1839 2
 * A file URL for a remote host is an obsolete ftp URL.
 * Return YES only if we're certain it's a local file.  - FM
d1841 2
a1842 1
BOOLEAN LYisLocalFile(const char *filename)
d1861 2
a1862 2
	if (0 == strcmp("file", acc_method) &&
	    (0 == strcmp(host, "localhost") ||
d1876 2
a1877 2
 * Utility for checking URLs with a host field.  Return YES only if we're
 * certain it's the local host.  - FM
d1879 2
a1880 1
BOOLEAN LYisLocalHost(const char *filename)
d1909 1
a1909 1
 * Utility for freeing the list of local host aliases.  - FM
d1911 1
a1911 1
void LYLocalhostAliases_free(void)
d1919 1
a1919 1
    while (NULL != (alias = (char *) HTList_nextObject(cur))) {
d1928 1
a1928 1
 * Utility for listing hosts to be treated as local aliases.  - FM
d1930 2
a1931 1
void LYAddLocalhostAlias(char *alias)
d1952 2
a1953 2
 * Utility for checking URLs with a host field.  Return YES only if we've
 * listed the host as a local alias.  - FM
d1955 2
a1956 1
BOOLEAN LYisLocalAlias(const char *filename)
d1975 1
a1975 1
    while (NULL != (alias = (char *) HTList_nextObject(cur))) {
d1987 12
a1998 11
 *  This function checks for a URL with an unknown scheme,
 *  but for which proxying has been set up, and if so,
 *  returns PROXY_URL_TYPE. - FM
 *
 *  If a colon is present but the string segment which
 *  precedes it is not being proxied, and we can be sure
 *  that what follows the colon is not a port field,
 *  it returns UNKNOWN_URL_TYPE.  Otherwise, it returns
 *  0 (not a URL). - FM
 */
int LYCheckForProxyURL(char *filename)
d2005 1
a2005 1
     * Don't crash on an empty argument.
d2008 1
a2008 1
	return (NOT_A_URL_TYPE);
d2017 1
a2017 1
    if ((cp1 = strchr((cp + 1), ':')) != NULL) {
d2024 1
a2024 1
	    return (PROXY_URL_TYPE);
d2029 1
a2029 1
	    return (NOT_A_URL_TYPE);
d2033 1
a2033 1
	    return (NOT_A_URL_TYPE);
d2038 1
a2038 1
		return (UNKNOWN_URL_TYPE);
d2040 1
a2040 1
	    return (UNKNOWN_URL_TYPE);
d2044 1
a2044 1
    return (NOT_A_URL_TYPE);
d2051 4
a2054 3
static BOOLEAN compare_type(char *tst,
			    const char *cmp,
			    size_t len)
a2058 1

d2074 13
a2086 12
 *  Must recognize a URL and return the type.
 *  If recognized, based on a case-insensitive
 *  analysis of the scheme field, ensures that
 *  the scheme field has the expected case.
 *
 *  Returns 0 (not a URL) for a NULL argument,
 *  one which lacks a colon.
 *
 *  Chains to LYCheckForProxyURL() if a colon
 *  is present but the type is not recognized.
 */
int is_url(char *filename)
d2095 1
a2095 1
     * Don't crash on an empty argument.
d2098 1
a2098 1
	return (result);
d2101 1
a2101 1
     * Can't be a URL if it lacks a colon.
d2104 1
a2104 1
	return (result);
d2107 1
a2107 1
     * Kill beginning spaces.
d2112 5
a2116 4
     * Can't be a URL if it starts with a slash.  So return immediately for
     * this common case, also to avoid false positives if there was a colon
     * later in the string.  Also can't be a URL if it starts with a colon.  -
     * KW
d2127 2
a2128 2
	     * Lynx internal pages ("LYNXfoo:" or "lynxfoo:") start with 'l' or
	     * 'L', other URLs aren't.
d2132 3
a2134 3
		 * Special External Lynx type to handle execution of commands
		 * or scripts which require a pause to read the screen upon
		 * completion.
d2140 3
a2142 3
		 * Special External Lynx type to handle execution of commands,
		 * scripts or programs with do not require a pause to read
		 * screen upon completion.
d2148 1
a2148 1
		 * Special External Lynx type to handle cgi scripts.
d2154 1
a2154 1
		 * Special Internal Lynx type.
d2160 1
a2160 1
		 * Special Internal Lynx type.
d2166 1
a2166 1
		 * Special Internal Lynx type.
d2172 1
a2172 1
		 * Special Internal Lynx type.
d2178 1
a2178 1
		 * Special Internal Lynx type.
d2184 1
a2184 1
		 * Special Internal Lynx type.
d2190 1
a2190 1
		 * Special Internal Lynx type.
d2196 1
a2196 1
		 * Special Internal Lynx type.
d2202 1
a2202 1
		 * Special Internal Lynx type.
d2208 1
a2208 1
		 * Special Internal Lynx type.
d2211 1
a2211 1
		(void) is_url(&cp[LEN_LYNXIMGMAP]);
d2216 1
a2216 1
		 * Special Internal Lynx type.
d2223 1
a2223 1
	     * NEWSfoo:  schemes -
d2235 1
a2235 1
		 * Special Lynx type to handle news posts.
d2241 1
a2241 1
		 * Special Lynx type to handle news replies (followups).
d2248 1
a2248 1
	     * SNEWSfoo:  schemes -
d2257 1
a2257 1
		 * Special Lynx type to handle snews posts.
d2263 1
a2263 1
		 * Special Lynx type to handle snews replies (followups).
d2315 2
a2316 2
		&& ((cp1 = strchr(cp + 3, ':')) == NULL
		    || !DoubleHtmlSep(cp1 + 1))) {
d2324 2
a2325 2
		    && (cp1 - cp) > 1	/* exclude DOS-style device:/path */
		    && LYisAbsPath(cp1 + 1)) {
d2346 1
a2346 1
			    && (cp1 = strchr(cp + 11, '/')) != NULL) {
d2348 1
a2348 1
			    if (TOUPPER(*(cp1 + 1)) == 'H' || *(cp1 + 1) == 'w')
d2351 1
a2351 1
			    else if (*(cp1 + 1) == 'T' || *(cp1 + 1) == '8')
d2353 1
a2353 1
			    else if (*(cp1 + 1) == '7')
d2420 4
a2423 4
 * Sometimes it is just expected that curses is on when an alert or other
 * statusline message needs to be shown and we are not just dumping
 * immediately.  Calling this will 'fix' it, but may not always be appropriate. 
 * - kw
d2425 2
a2426 1
void LYFixCursesOn(const char *reason)
d2437 13
a2449 12
 * Most protocol modules called through HTLoad* expect that curses is on unless
 * dump_output_immediately is set, so that statusline messages can be shown. 
 * Some protocols expect the opposite, namely telnet and friends.  This
 * function should be called after the 'physical' URL for accessing addr has
 * been established.  It does the right thing to the degree that curses is
 * turned on for known problem cases.  In any normal circumstances this should
 * never apply, but proxying or rule substitution is not prevented for
 * telnet-like URLs, and this 'fix' avoids some crashes that can otherwise
 * occur.  - kw
 */
BOOLEAN LYFixCursesOnForAccess(const char *addr,
			       const char *physical)
d2452 1
a2452 1
     * If curses is off when maybe it shouldn't...
a2455 1

d2457 2
a2458 2
	 * If requested resource wants to be accessed with curses off, and
	 * getfile() would indeed have turned curses off for it...
d2465 2
a2466 2
	      (cp1 = strchr(addr + 11, '/')) != NULL &&
	      (*(cp1 + 1) == 'T' || *(cp1 + 1) == '8')))) {
d2468 2
a2469 2
	     * If actual access that will be done is ok with curses off, then
	     * do nothing special, else force curses on.  - kw
d2475 2
a2476 1
		HTAlert(gettext("Unexpected access protocol for this URL scheme."));
d2481 1
a2481 1
    return FALSE;
d2485 1
a2485 1
 * Determine whether we allow HEAD and related flags for a URL.  - kw
d2487 2
a2488 1
BOOLEAN LYCanDoHEAD(const char *address)
a2491 1

d2512 3
a2514 3
     * The idea of the following is to allow HEAD for news URLs that identify
     * single articles, not those that identify ranges of articles or groups or
     * a list of groups.  - kw
a2518 1

d2531 1
d2533 3
a2535 3
/* If defined, also allow head requests for URLs proxied through the "http" or
 * "lynxcgi" protocols, which understand HEAD.  Only the proxy environment
 * variables are checked, not the HTRules system.  - kw
a2539 1

a2541 1

d2563 2
a2564 1
BOOLEAN LYCloseInput(FILE *fp)
a2567 1

d2579 2
a2580 1
BOOLEAN LYCloseOutput(FILE *fp)
a2583 1

d2596 2
a2597 1
BOOLEAN LYCanWriteFile(const char *filename)
d2611 2
a2612 1
BOOLEAN LYCanReadFile(const char *filename)
d2623 1
a2623 1
 * Remove backslashes from any string.
d2625 2
a2626 1
void remove_backslashes(char *buf)
d2630 1
a2630 1
    for (cp = buf; *cp != '\0'; cp++) {
d2632 1
a2632 1
	if (*cp != '\\') {	/* don't print slashes */
d2636 1
a2636 1
		   *(cp + 1) == '\\') {		/* are two in a row         */
d2646 3
a2648 2
 * Checks to see if the current process is attached via a terminal in the local
 * domain.
d2650 1
a2650 1
BOOLEAN inlocaldomain(void)
d2671 2
a2672 2
		  me.ut_host + strlen(me.ut_host) - strlen(LYLocalDomain)))
	    return (TRUE);
d2676 1
a2676 1
	    return (TRUE);
d2680 2
a2681 3
	CTRACE((tfp,
		"Could not get ttyname (returned %s) or open UTMP file %s\n",
		((cp != 0) ? cp : "<null>"), UTMP_FILE));
d2684 1
a2684 1
    return (FALSE);
d2687 1
a2687 1
    return (TRUE);
d2693 5
a2697 4
 * An extended alternative for calling signal(), sets some flags for signal
 * handler as we want them if that functionality is available.  (We don't
 * return anything from this function since the return value would currently be
 * ignored anyway.) - kw
d2699 3
a2701 2
void LYExtSignal(int sig,
		 LYSigHandlerFunc_t * handler)
a2706 1

d2724 6
a2729 7
 * For switching a signal's handling between SIG_DFL and something (possibly)
 * different that may have been set up by lynx code or e.g. by curses library. 
 * Uses sigaction to preserve / restore as much state as possible.
 *
 * Second arg is where to save or restore from.
 *
 * Third arg to_dfl specifies what to do:
d2733 8
a2740 7
 * Currently only used for SIGTSTP without SLANG, to prevent (n)curses signal
 * handler from running while lynx is waiting in system() for an interactive
 * command like an editor.  - kw
 */
static BOOLEAN LYToggleSigDfl(int sig,
			      struct sigaction *where,
			      int to_dfl)
d2769 2
a2770 2
 * This bit of code catches window size change signals
 */
d2787 3
a2789 3
#   endif			/* HAVE_TERMIO_H */
#  endif			/* HAVE_TERMIOS_H */
# endif				/* TERMIO_AND_TERMIOS */
d2792 2
a2793 1
void size_change(int sig GCC_UNUSED)
d2803 1
a2803 1
    LYcols = SLtt_Screen_Cols;
d2807 1
a2807 1
    SLtt_Screen_Cols = (LYcols - 1) * 6;
d2811 1
a2811 1
    SLtt_Screen_Cols = HTMIN((LYcols - 1) * 6, 255);
d2816 1
a2816 1
	 * Called from start_curses().
a2822 1

d2869 1
a2869 1
     * Check if the screen size has actually changed.  - AJL
d2882 1
a2882 1
    LYExtSignal(SIGWINCH, size_change);
d2889 1
a2889 1
 * Utility for freeing the list of previous suggested filenames.  - FM
d2891 1
a2891 1
void HTSugFilenames_free(void)
d2899 1
a2899 1
    while (NULL != (fname = (char *) HTList_nextObject(cur))) {
d2908 2
a2909 2
 * Utility for listing suggested filenames, making any repeated filenames the
 * most current in the list.  - FM
d2911 2
a2912 1
void HTAddSugFilename(char *fname)
d2933 1
a2933 1
    while (NULL != (old = (char *) HTList_nextObject(cur))) {
d2946 2
a2947 2
 * CHANGE_SUG_FILENAME -- Foteos Macrides 29-Dec-1993 Upgraded for use with
 * Lynx2.2 - FM 17-Jan-1994
d2949 2
a2950 1
void change_sug_filename(char *fname)
a2953 1

d2960 1
a2960 1
     * Establish the current end of fname.
d2965 1
a2965 1
     * Unescape fname.
d2970 1
a2970 1
     * Rename any temporary files.
d2981 1
a2981 1
	HTSprintf0(&temp, "file://localhost%s%d", cp2, (int) getpid());
d2983 1
a2983 1
	HTSprintf0(&temp, "file://localhost/%s%d", cp2, (int) getpid());
d2997 3
a2999 3
	 * Hmm...  we have a directory name.  It is annoying to see a
	 * scheme+host+path name as a suggested one, let's remove the
	 * last_slash and go ahead like we have a file name.  - LP
d3004 1
a3004 1
     * Remove everything up the the last_slash if there is one.
d3006 1
a3006 1
    if ((cp = strrchr(fname, '/')) != NULL && strlen(cp) > 1) {
d3009 1
a3009 1
	 * Go past the slash.
d3017 2
a3018 2
#ifdef _WINDOWS			/* 1998/05/05 (Tue) 10:08:05 */
    if ((cp = strrchr(fname, '=')) != NULL && strlen(cp) > 1) {
d3021 1
a3021 1
	 * Go past the '='.
d3032 1
a3032 1
     * Trim off date-size suffix, if present.
d3042 1
a3042 1
     * Trim off VMS device and/or directory specs, if present.
d3044 2
a3045 2
    if ((cp = strchr(fname, '[')) != NULL &&
	(cp1 = strrchr(cp, ']')) != NULL && strlen(cp1) > 1) {
d3047 1
a3047 1
	for (cp = fname; *cp1 != '\0'; cp1++) {
d3052 1
d3055 1
a3055 1
     * Replace illegal or problem characters.
d3060 1
a3060 1
	 * Replace with underscores.
d3065 3
a3067 3
	    /*
	     * Replace with dashes.
	     */
d3075 1
a3075 1
		   *cp < ' ' || (UCH(*cp)) > 126) {
d3081 1
a3081 1
     * Collapse any serial underscores.
d3095 1
a3095 1
     * Collapse any serial dashes.
d3103 1
a3103 1
	} else {
d3110 2
a3111 1
     * Trim any trailing or leading underscores or dashes.
d3131 7
a3137 4
     * Replace all but the last period with _'s, or second to last if last is
     * followed by a terminal Z or z, or GZ or gz,
     * e.g., convert foo.tar.Z to foo.tar_Z
     * or, convert foo.tar.gz to foo.tar-gz
d3142 1
a3142 1
	    if ((fname[j - 1] == '.') &&
d3146 2
a3147 2
	    } else if (((TOUPPER(fname[j - 1]) == 'G') &&
			fname[j - 2] == '.') &&
d3159 2
a3160 2
	 * But if the root is > 39 characters, move the period appropriately to
	 * the left.
d3165 1
a3165 1
		*cp = '.';
d3168 1
a3168 1
		*cp = '.';
d3173 1
a3173 1
		    fname[j] = fname[j - 1];
d3190 1
a3190 1
	 * Make sure the extension is < 40 characters.
d3197 1
a3197 1
	 * Trim trailing dashes or underscores.
d3205 3
a3207 2
	 * No period, so put one on the end, or after the 39th character,
	 * trimming trailing dashes or underscores.
d3223 1
a3223 1
     * Replace problem characters.
d3227 5
a3231 5
	case '\'':
	case '\"':
	case '/':
	case ' ':
	    *cp = '-';
d3237 1
a3237 1
     * Make sure the rest of the original string in nulled.
d3250 4
a3253 3
static int fmt_tempname(char *result,
			const char *prefix,
			const char *suffix)
a3255 1

d3275 1
a3275 1
	lynx_srand((unsigned) ((long) time((time_t *) 0) + (long) result));
d3286 1
a3286 2
	counter = (unsigned) (((float) MAX_TEMPNAME * lynx_rand()) /
			      LYNX_RAND_MAX + 1);
d3315 1
a3315 1
    sprintf(leaf, "%04x%04x", counter, (unsigned) GETPID());
d3317 1
a3317 1
    sprintf(leaf, "%u%u", counter, (unsigned) getpid());
a3322 1

d3330 1
a3330 1
    sprintf(leaf, "L%u-%uTMP%s", (unsigned) getpid(), counter, suffix);
d3339 1
a3339 1
	sprintf(result, "%.*s", LY_MAXPATH - 1, leaf);
d3347 1
a3347 1
 * Convert 4, 6, 2, 8 to left, right, down, up, etc.
d3349 2
a3350 1
int number2arrows(int number)
d3352 28
a3379 28
    switch (number) {
    case '1':
	number = END_KEY;
	break;
    case '2':
	number = DNARROW;
	break;
    case '3':
	number = PGDOWN;
	break;
    case '4':
	number = LTARROW;
	break;
    case '5':
	number = DO_NOTHING;
	break;
    case '6':
	number = RTARROW;
	break;
    case '7':
	number = HOME;
	break;
    case '8':
	number = UPARROW;
	break;
    case '9':
	number = PGUP;
	break;
d3382 1
a3382 1
    return (number);
d3386 2
a3387 2
 * parse_restrictions takes a string of comma-separated restrictions and sets
 * the corresponding flags to restrict the facilities available.
d3389 3
a3391 3
/* The first two are special:  we want to record whether "default" or "all"
 * restrictions were applied, in addition to the detailed effects of those
 * options.  - kw
d3395 1
a3395 1
/* *INDENT-OFF* */
a3490 1
/* *INDENT-ON* */
d3492 9
a3500 8
/* This will make no difference between '-' and '_'.  It does only in/equality
 * compare.  It assumes that p2 can't contain dashes, but p1 can.  This
 * function is also used (if macro OPTNAME_ALLOW_DASHES doesn't have value of
 * zero) for compare of commandline options -VH
 */
BOOL strn_dash_equ(const char *p1,
		   const char *p2,
		   int len)
d3504 1
a3504 1
	    return 0;		/* canonical name is shorter */
d3506 1
a3506 10
	case 0:
	    return 0;
	case '-':
	case '_':
	    if (*p2 != '_')
		return 0;
	    else
		break;
	default:
	    if (*p1 != *p2)
d3508 9
d3518 1
a3518 2
	++p1;
	++p2;
d3540 2
a3541 1
const char *index_to_restriction(int inx)
d3552 3
a3554 2
int find_restriction(const char *name,
		     int len)
a3556 1

d3559 1
a3559 1
    for (i = 0; i < TABLESIZE(restrictions); i++) {
d3567 2
a3568 1
void parse_restrictions(const char *s)
d3585 1
a3585 1
	if (RESTRICT_NM_EQU(word, "all", p - word)) {
d3587 1
a3587 3
	    for (i = N_SPECIAL_RESTRICT_OPTIONS;
		 i < TABLESIZE(restrictions);
		 i++)
d3589 1
a3589 1
	} else if (RESTRICT_NM_EQU(word, "default", p - word)) {
d3591 1
a3591 3
	    for (i = N_SPECIAL_RESTRICT_OPTIONS;
		 i < TABLESIZE(restrictions);
		 i++)
d3594 2
a3595 2
	    for (i = 0; i < TABLESIZE(restrictions); i++) {
		if (RESTRICT_NM_EQU(word, restrictions[i].name, p - word)) {
d3603 1
a3603 1
	    printf("%s: %.*s\n", gettext("unknown restriction"), p - word, word);
d3623 2
a3624 1
void print_restrictions_to_fd(FILE *fp)
d3628 1
a3628 1
    for (i = 0; i < TABLESIZE(restrictions); i++) {
d3638 1
a3638 1
    for (i = 0; i < TABLESIZE(restrictions); i++) {
d3644 1
a3644 1
		|| !no_goto)
d3655 6
a3660 5
typedef struct _VMSMailItemList {
    short buffer_length;
    short item_code;
    void *buffer_address;
    long *return_length_address;
d3663 1
a3663 1
void LYCheckMail(void)
a3672 1
    /* *INDENT-OFF* */
a3681 2
    /* *INDENT-ON* */

d3692 1
a3692 1
	status = sys$getjpiw(0, 0, 0, jpi_list, 0, 0, 0);
d3708 1
a3708 1
    status = mail$user_begin(&ucontext, null_list, null_list);
d3715 1
a3715 1
    status = mail$user_get_info(&ucontext, uilist, uolist);
d3735 1
a3735 1
    mail$user_end((long *) &ucontext, null_list, null_list);
d3739 1
a3739 1
void LYCheckMail(void)
d3763 2
a3764 2
    if ((stat(mf, &st) < 0)
	|| !S_ISREG(st.st_mode)) {
d3771 1
a3771 1
	    || ((lastsize != 0) && (st.st_size > lastsize)))
d3783 15
a3797 14
 *  This function ensures that an href will be
 *  converted to a fully resolved, absolute URL,
 *  with guessing of the host or expansions of
 *  lead tildes via LYConvertToURL() if needed,
 *  and tweaking/simplifying via HTParse().  It
 *  is used for LynxHome, startfile, homepage,
 *  and 'g'oto entries, after they have been
 *  passed to LYFillLocalFileURL(). - FM
 *  Such URLs have no `base' reference to which they
 *  could be resolved.  LYLegitimizeHREF could not be used.
 */
void LYEnsureAbsoluteURL(char **href,
			 const char *name,
			 int fixit)
d3804 3
a3806 3
    /*
     * Check whether to fill in localhost.  - FM
     */
d3810 1
a3810 1
     * If it is not a URL then make it one.
d3820 1
a3820 1
		NonNull(name), (name ? " " : ""), *href));
d3831 8
a3838 6
 * Rewrite and reallocate a previously allocated string as a file URL if the
 * string resolves to a file or directory on the local system, otherwise as an
 * http URL.  - FM
 */
void LYConvertToURL(char **AllocatedString,
		    int fixit)
a3842 1

d3853 1
a3853 2

	for (; *cp_url != '\0'; cp_url++)
d3862 1
a3862 1
    *AllocatedString = NULL;	/* so StrAllocCopy doesn't free it */
a3866 1

d3868 1
a3868 1
	StrAllocCat(*AllocatedString, "/");
d3872 1
a3872 1
	 * Not a SHELL pathspec.  Get the full VMS spec and convert it.
a3876 1

d3881 3
a3883 2
	     * On VMS, we'll accept '~' on the command line as Home_Dir(), and
	     * assume the rest of the path, if any, has SHELL syntax.
d3888 3
a3890 3
		 * Append rest of path, if present, skipping "user" if "~user"
		 * was entered, simplifying, and eliminating any residual
		 * relative elements.  - FM
d3900 1
a3900 1
	    LYstrncpy(url_file, old_string, sizeof(url_file) - 1);
d3903 2
a3904 2
	if (1 & lib$find_file(&url_file_dsc, &file_name_dsc, &context,
			      0, 0, 0, 0)) {
d3906 1
a3906 1
	     * We found the file.  Convert to a URL pathspec.
d3921 1
a3921 1
	} else if ((NULL != getcwd(dir_name, sizeof(dir_name) - 1, 0)) &&
d3928 1
a3928 1
	    if (NULL != getcwd(dir_name, sizeof(dir_name) - 1, 0)) {
d3940 3
a3942 2
		 * Nope.  Assume it's an http URL with the "http://" defaulted,
		 * if we can't rule out a bad VMS path.
d3948 1
a3948 1
		    !LYExpandHostForURL(&old_string,
d3952 3
a3954 3
		     * Probably a bad VMS path (but can't be sure).  Use
		     * original pathspec for the error message that will
		     * result.
d3956 3
a3958 4
		    sprintf(url_file, "/%.*s", sizeof(url_file) - 2, old_string);
		    CTRACE((tfp,
			    "Can't find '%s'  Will assume it's a bad path.\n",
			    old_string));
d3962 2
a3963 2
		     * Assume a URL is wanted, so guess the scheme with
		     * "http://" as the default.  - FM
d3965 1
a3965 1
		    if (!LYAddSchemeForURL(&old_string, "http://")) {
d3975 3
a3977 2
	     * Nothing found.  Assume it's an http URL with the "http://"
	     * defaulted, if we can't rule out a bad VMS path.
d3985 1
a3985 1
		!LYExpandHostForURL(&old_string,
d3989 3
a3991 2
		 * Probably a bad VMS path (but can't be sure).  Use original
		 * pathspec for the error message that will result.
d3993 1
a3993 1
		sprintf(url_file, "/%.*s", sizeof(url_file) - 2, old_string);
d3995 1
a3995 1
			old_string));
d3999 2
a4000 2
		 * Assume a URL is wanted, so guess the scheme with "http://"
		 * as the default.  - FM
d4002 1
a4002 1
		if (!LYAddSchemeForURL(&old_string, "http://")) {
d4012 1
a4012 1
      have_VMS_URL:
d4023 1
a4023 1
				   fullpath, &filepart);
d4029 1
a4029 1
			old_string, *AllocatedString));
d4037 1
a4037 1
	     * They want .
a4039 1

d4044 1
a4044 1
		    old_string, *AllocatedString));
d4051 1
a4051 1
	     * On Unix, convert '~' to Home_Dir().
d4056 3
a4058 3
		 * Append rest of path, if present, skipping "user" if "~user"
		 * was entered, simplifying, and eliminating any residual
		 * relative elements.  - FM
d4066 1
a4066 1
		    old_string, *AllocatedString));
d4069 1
a4069 1
	     * Create a full path to the current default directory.
d4074 1
a4074 2

	    Current_Dir(curdir);
d4076 2
a4077 2
	     * Concatenate and simplify, trimming any residual relative
	     * elements.  - FM
d4105 1
a4105 1
		 * It is a subdirectory or file on the local system.
d4122 1
a4122 1
			old_string, *AllocatedString));
a4125 1

d4130 1
a4130 1
		HTUnEscape(cp);	/* unescape given path without fragment */
d4132 1
a4132 1
		StrAllocCopy(cp2, temp2);	/* keep a copy in cp2     */
d4134 1
a4134 1
#ifdef WIN_EX			/* 1998/07/31 (Fri) 09:09:03 */
d4142 3
a4144 3
		     * It is a subdirectory or file on the local system with
		     * escaped characters and/or a fragment to be appended to
		     * the URL.  - FM
d4150 2
a4151 2
			 * LYTrimRelFromAbsPath did nothing, use old_string as
			 * given.  - kw
d4165 1
a4165 1
			    old_string, *AllocatedString));
d4171 5
a4175 4
		     * If PWD has some unusual characters, construct a filename
		     * in temp where those are escaped.  This is mostly to
		     * prevent this function from returning with some weird URL
		     * if the LYExpandHostForURL tests further down fail.  - kw
d4180 2
a4181 2
			 * LYTrimRelFromAbsPath did nothing, use old_string as
			 * given.  - kw
d4199 3
a4201 3
		 * It's not an accessible subdirectory or file on the local
		 * system, so assume it's a URL request and guess the scheme
		 * with "http://" as the default.
d4204 2
a4205 2
			temp2 ? temp2 : temp));
#ifdef WIN_EX			/* 1998/01/13 (Tue) 09:07:37 */
d4215 1
a4215 1
				"'%s' not exist, Goto LynxHome '%s'.", q, p);
d4224 1
a4224 1
		if (LYExpandHostForURL(&old_string,
d4226 3
a4228 2
				       URLDomainSuffixes)) {
		    if (!LYAddSchemeForURL(&old_string, "http://")) {
d4235 1
a4235 1
		    /* RW 1998Mar16  Restore AllocatedString to 'old_string' */
d4242 1
a4242 1
	      Retry:
d4252 1
a4252 1
	 * Path begins with a slash.  Simplify and use it.
d4256 3
a4258 2
	     * Request for root.  Respect it on Unix, but on VMS we treat that
	     * as a listing of the login directory.  - FM
d4267 2
a4268 1
	     * It is an absolute directory or file on the local system.  - KW
d4278 1
a4278 1
		    old_string, *AllocatedString));
d4282 2
a4283 2
	     * Has a Home_Dir() reference.  Handle it as if there weren't a
	     * lead slash.  - FM
d4288 3
a4290 3
		 * Append rest of path, if present, skipping "user" if "~user"
		 * was entered, simplifying, and eliminating any residual
		 * relative elements.  - FM
d4299 2
a4300 2
	     * Normal absolute path.  Simplify, trim any residual relative
	     * elements, and append it.  - FM
d4308 1
a4308 1
		old_string, *AllocatedString));
d4315 1
a4315 1
#if defined(_WINDOWS)		/* 1998/06/23 (Tue) 16:45:20 */
d4349 21
a4369 18
 * This function rewrites and reallocates a previously allocated string so that
 * the first element is a confirmed Internet host, and returns TRUE, otherwise
 * it does not modify the string and returns FALSE.  It first tries the element
 * as is, then, if the element does not end with a dot, it adds prefixes from
 * the (comma separated) prefix list argument, and, if the element does not
 * begin with a dot, suffixes from the (comma separated) suffix list arguments
 * (e.g., www.host.com, then www.host,edu, then www.host.net, then
 * www.host.org).  The remaining path, if one is present, will be appended to
 * the expanded host.  It also takes into account whether a colon is in the
 * element or suffix, and includes that and what follows as a port field for
 * the expanded host field (e.g, wfbr:8002/dir/lynx should yield
 * www.wfbr.edu:8002/dir/lynx).  The calling function should prepend the scheme
 * field (e.g., http://), or pass the string to LYAddSchemeForURL(), if this
 * function returns TRUE.  - FM
 */
BOOLEAN LYExpandHostForURL(char **AllocatedString,
			   char *prefix_list,
			   char *suffix_list)
a4378 1

d4385 3
a4387 2
     * If it's a NULL or zero-length string, or if it begins with a slash or
     * hash, don't continue pointlessly.  - FM
d4395 2
a4396 1
     * If it's a partial or relative path, don't continue pointlessly.  - FM
d4404 4
a4407 3
     * Make a clean copy of the string, and trim off the path if one is
     * present, but save the information so we can restore the path after
     * filling in the Host[:port] field.  - FM
d4412 2
a4413 1
	 * Have a path.  Any fragment should already be included in Path.  - FM
d4418 3
a4420 2
	 * No path, so check for a fragment and trim that, to be restored after
	 * filling in the Host[:port] field.  - FM
d4426 4
a4429 3
     * If the potential host string has a colon, assume it begins a port field,
     * and trim it off, but save the information so we can restore the port
     * field after filling in the host field.  - FM
d4441 2
a4442 1
     * Do a DNS test on the potential host field as presently trimmed.  - FM
d4454 1
d4467 1
a4467 1
	 * Clear any residual interrupt.  - FM
d4471 2
a4472 2
		    "LYExpandHostForURL: Ignoring interrupt because '%s' resolved.\n",
		    host));
d4476 1
a4476 1
	 * Return success.  - FM
d4483 3
a4485 1
    } else if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED)) {
d4487 1
a4487 1
	 * Give the user chance to interrupt lookup cycles.  - KW & FM
d4490 2
a4491 2
		"LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
		host));
d4494 1
a4494 1
	 * Return failure.  - FM
d4503 10
a4512 8
     * Set the first prefix, making it a zero-length string if the list is NULL
     * or if the potential host field ends with a dot.  - FM
     */
    StartP = ((prefix_list && Str[strlen(Str) - 1] != '.') ?
	      prefix_list : "");
    /*
     * If we have a prefix, but the allocated string is one of the common host
     * prefixes, make our prefix a zero-length string.  - FM
d4529 1
a4529 1
	StartP++;		/* Skip whitespace and separators */
d4533 1
a4533 1
	EndP++;			/* Find separator */
d4538 1
a4538 1
     * Test each prefix with each suffix.  - FM
d4542 3
a4544 2
	 * Set the first suffix, making it a zero-length string if the list is
	 * NULL or if the potential host field begins with a dot.  - FM
d4547 1
a4547 1
		  suffix_list : "");
d4549 1
a4549 1
	    StartS++;		/* Skip whitespace and separators */
d4553 1
a4553 1
	    EndS++;		/* Find separator */
d4558 1
a4558 1
	 * Create domain names and do DNS tests.  - FM
d4563 2
a4564 2
	    if (Host[strlen(Host) - 1] == '.') {
		Host[strlen(Host) - 1] = '\0';
d4587 1
a4587 1
		 * Give the user chance to interrupt lookup cycles.  - KW
d4589 2
a4590 1
		if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED)) {
d4592 2
a4593 2
			    "LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
			    host));
d4598 1
a4598 1
		    return FALSE;	/* We didn't find a valid name. */
d4602 1
a4602 1
		 * Advance to the next suffix, or end of suffix list.  - FM
d4614 1
a4614 1
	} while ((GotHost == FALSE) && (*DomainSuffix != '\0'));
d4617 12
a4628 12
	    /*
	     * Advance to the next prefix, or end of prefix list.  - FM
	     */
	    StartP = ((*EndP == '\0') ? EndP : (EndP + 1));
	    while ((*StartP) && (WHITE(*StartP) || *StartP == ',')) {
		StartP++;	/* Skip whitespace and separators */
	    }
	    EndP = StartP;
	    while (*EndP && !WHITE(*EndP) && *EndP != ',') {
		EndP++;		/* Find separator */
	    }
	    LYstrncpy(DomainPrefix, StartP, (EndP - StartP));
d4633 4
a4636 3
     * If a test passed, restore the port field if we had one and there is no
     * colon in the expanded host, and the path if we had one, and reallocate
     * the original string with the expanded Host[:port] field included.  - FM
d4655 1
a4655 1
     * Clear any residual interrupt.  - FM
d4658 3
a4660 4
	CTRACE((tfp,
		"LYExpandHostForURL: Ignoring interrupt because '%s' %s.\n",
		host,
		(GotHost ? "resolved" : "timed out")));
d4664 1
a4664 1
     * Clean up and return the last test result.  - FM
d4674 12
a4685 10
 * This function rewrites and reallocates a previously allocated string that
 * begins with an Internet host name so that the string begins with its guess
 * of the scheme based on the first field of the host name, or the default
 * scheme if no guess was made, and returns TRUE, otherwise it does not modify
 * the string and returns FALSE.  It also returns FALSE without modifying the
 * string if the default_scheme argument was NULL or zero-length and no guess
 * was made.  - FM
 */
BOOLEAN LYAddSchemeForURL(char **AllocatedString,
			  char *default_scheme)
d4691 2
a4692 2
     * If we were passed a NULL or zero-length string, don't continue
     * pointlessly.  - FM
d4703 2
a4704 2
	 * This could be either http or https, so check the default and
	 * otherwise use "http".  - FM
d4738 2
a4739 2
	 * This could be either news, snews, or nntp, so check the default, and
	 * otherwise use news.  - FM
d4757 2
a4758 2
     * If we've make a guess, use it.  Otherwise, if we were passed a default
     * scheme prefix, use that.  - FM
d4779 7
a4785 6
 * This function expects an absolute Unix or VMS SHELL path spec as an
 * allocated string, simplifies it, and trims out any residual relative
 * elements.  It also checks whether the path had a terminal slash, and if it
 * didn't, makes sure that the simplified path doesn't either.  If it's a
 * directory, our convention is to exclude "Up to parent" links when a terminal
 * slash is present.  - FM
d4787 2
a4788 1
void LYTrimRelFromAbsPath(char *path)
d4795 1
a4795 1
     * Make sure we have a pointer to an absolute path.  - FM
d4801 1
a4801 1
     * Check whether the path has a terminal slash.  - FM
d4806 1
a4806 1
     * Simplify the path and then do any necessary trimming.  - FM
d4813 1
a4813 1
	     * Eliminate trailing dot.  - FM
d4818 1
a4818 1
	     * Skip over the "/." of a "/./".  - FM
d4823 1
a4823 1
	     * Eliminate trailing dotdot.  - FM
d4828 1
a4828 1
	     * Skip over the "/.." of a "/../".  - FM
d4833 1
a4833 1
	     * Done trimming.  - FM
d4840 3
a4842 2
     * Load any shifts into path, and eliminate any terminal slash created by
     * HTSimplify() or our walk, but not present originally.  - FM
d4855 1
a4855 1
 * Example Client-Side Include interface.
d4857 10
a4866 8
 * This is called from SGML.c and simply returns markup for reporting the URL
 * of the document being loaded if a comment begins with "<!--#lynxCSI".  The
 * markup will be included as if it were in the document.  Move this function
 * to a separate module for doing this kind of thing seriously, someday.  - FM
 */
void LYDoCSI(char *url,
	     const char *comment,
	     char **csi)
d4888 2
a4889 2
 * Define_VMSLogical -- Fote Macrides 04-Apr-1995
 * Define VMS logicals in the process table.
d4891 3
a4893 2
void Define_VMSLogical(char *LogicalName,
		       char *LogicalValue)
d4918 1
a4918 1
static void LYHomeDir_free(void)
d4924 2
a4925 1
char *Current_Dir(char *pathname)
a4927 1

d4929 1
a4929 1
    result = getcwd(pathname, LY_MAXPATH);
d4931 1
a4931 1
    result = getwd(pathname);
d4942 2
a4943 1
static char *CheckDir(char *path)
a4945 1

d4948 1
a4948 1
	    || !S_ISDIR(stat_info.st_mode))) {
d4957 1
a4957 1
static char *HomeEnv(void)
d5000 1
a5000 1
const char *Home_Dir(void)
d5009 1
a5009 1
		&& (cp = LYGetEnv("SYS$SCRATCH")) == NULL) {
d5017 1
a5017 1
	     * One could use getlogin() and getpwnam() here instead.
d5027 1
a5027 1
		 * Use /tmp; it should be writable.
d5036 1
a5036 1
	homedir = (const char *) HomeDir;
d5053 1
a5053 1
char *LYPathLeaf(char *pathname)
a5055 1

d5068 1
a5068 2

    for (leaf = 0, n = strlen(pathname) - 1; n >= 0; n--) {
d5080 12
a5091 10
 * This function checks the acceptability of file paths that are intended to be
 * off the home directory.  The file path should be passed in fbuffer, together
 * with the size of the buffer.  The function simplifies the file path, and if
 * it is acceptable, loads it into fbuffer and returns TRUE.  Otherwise, it
 * does not modify fbuffer and returns FALSE.  If a subdirectory is present and
 * the path does not begin with "./", that is prefixed to make the situation
 * clear.  - FM
 */
BOOLEAN LYPathOffHomeOK(char *fbuffer,
			size_t fbuffer_size)
d5097 1
a5097 1
     * Make sure we have an fbuffer and a string in it.  - FM
d5100 1
a5100 1
	return (FALSE);
d5106 2
a5107 2
     * Check for an inappropriate reference to the home directory, and correct
     * it if we can.  - FM
d5113 1
a5113 1
	     * Reject "sys$login".  - FM
d5116 1
a5116 1
	    return (FALSE);
d5122 4
a5125 3
		 * Reject "sys$login:".  Otherwise, we have converted
		 * "sys$login:file" to "file", or have left a strange path for
		 * VMS as it was originally.  - FM
d5128 1
a5128 1
		return (FALSE);
d5138 2
a5139 1
		     * Convert "~/subdir(s)/file" to "./subdir(s)/file".  - FM
d5144 1
a5144 1
		     * Convert "~/file" to "file".  - FM
d5150 1
a5150 1
		 * Reject "~/".  - FM
d5153 1
a5153 1
		return (FALSE);
d5157 1
a5157 1
	    cp = (cp1 - 1);
d5161 4
a5164 3
		     * Convert "~user/subdir(s)/file" to "./subdir(s)/file". 
		     * If user is someone else, we covered a spoof.  Otherwise,
		     * we simplified.  - FM
d5169 1
a5169 1
		     * Convert "~user/file" to "file".  - FM
d5175 1
a5175 1
		 * Reject "~user/".  - FM
d5178 1
a5178 1
		return (FALSE);
d5182 1
a5182 1
	     * Reject "~user".  - FM
d5185 1
a5185 1
	    return (FALSE);
d5188 1
d5191 1
a5191 1
     * Check for VMS path specs, and reject if still present.  - FM
d5195 1
a5195 1
	return (FALSE);
d5200 1
a5200 1
     * Check for a URL or absolute path, and reject if present.  - FM
d5204 1
a5204 1
	return (FALSE);
d5208 1
a5208 1
     * Simplify it.  - FM
d5213 1
a5213 1
     * Check if it has a pointless "./".  - FM
d5222 1
a5222 1
     * Check for spoofing.  - FM
d5225 4
a5228 4
	|| LYIsPathSep(*cp)
	|| LYIsPathSep(cp[(strlen(cp) - 1)])
	|| strstr(cp, "..") != NULL
	|| !strcmp(cp, ".")) {
d5230 1
a5230 1
	return (FALSE);
d5234 2
a5235 2
     * Load what we have at this point into fbuffer, trimming if too long, and
     * claim it's OK.  - FM
d5239 2
a5240 2
	 * We have a subdirectory and no lead "./", so prefix it to make the
	 * situation clear.  - FM
d5252 1
a5252 1
    return (TRUE);
d5256 13
a5268 11
 * This function appends fname to the home path and returns the full path and
 * filename.  The fname string can be just a filename (e.g.,
 * "lynx_bookmarks.html"), or include a subdirectory off the home directory, in
 * which case fname should begin with "./" (e.g., ./BM/lynx_bookmarks.html) Use
 * LYPathOffHomeOK() to check and/or fix up fname before calling this function. 
 * On VMS, the resultant full path and filename are converted to VMS syntax.  -
 * FM
 */
void LYAddPathToHome(char *fbuffer,
		     size_t fbuffer_size,
		     char *fname)
d5275 1
a5275 1
     * Make sure we have a buffer.  - FM
d5286 1
a5286 1
     * Make sure we have a file name.  - FM
d5292 1
a5292 1
     * Set up home string and length.  - FM
d5303 1
a5303 1
	 * Home_Dir() has a bug if this ever happens.  - FM
d5310 3
a5312 3
	 * Buffer is smaller than or only big enough for the home path.  Load
	 * what fits of the home path and return.  This will fail, but we need
	 * something in the buffer.  - FM
d5318 1
d5321 1
a5321 1
     * Check whether we have a subdirectory path or just a filename.  - FM
d5325 1
a5325 1
	 * We have a subdirectory path.  - FM
d5327 1
a5327 1
	if (home[strlen(home) - 1] == ']') {
d5329 3
a5331 2
	     * We got the home directory, so convert it to SHELL syntax and
	     * append subdirectory path, then convert that to VMS syntax.  - FM
a5333 1

d5340 1
a5340 1
	     * This will fail, but we need something in the buffer.  - FM
d5346 1
a5346 1
	 * We have a file in the home directory.  - FM
d5352 1
a5352 1
     * Check whether we have a subdirectory path or just a filename.  - FM
d5355 1
a5355 1
	    (strncmp(file, "./", 2) ? file : (file + 2)));
d5365 2
a5366 1
char *LYAddPathToSave(char *fname)
a5376 1

d5385 1
a5385 1
 * This function takes a string in the format
d5389 14
a5402 12
 * as an argument, and returns its conversion to clock format (seconds since
 * 00:00:00 Jan 1 1970), or 0 if the string doesn't match the expected pattern. 
 * It also returns 0 if the time is in the past and the "absolute" argument is
 * FALSE.  It is intended for handling 'expires' strings in Version 0 cookies
 * homologously to 'max-age' strings in Version 1 cookies, for which 0 is the
 * minimum, and greater values are handled as '[max-age seconds] + time(NULL)'. 
 * If "absolute" if TRUE, we return the clock format value itself, but if
 * anything goes wrong when parsing the expected patterns, we still return 0. 
 * - FM
 */
time_t LYmktime(char *string,
		BOOL absolute)
d5411 1
a5411 1
     * Make sure we have a string to parse.  - FM
d5414 1
a5414 1
	return (0);
d5419 2
a5420 2
     * Skip any lead alphabetic "Day, " field and seek a numeric day field.  -
     * FM
d5425 1
a5425 1
	return (0);
d5428 1
a5428 1
     * Get the numeric day and convert to an integer.  - FM
d5434 2
a5435 2
	return (0);
    LYstrncpy(temp, start, (int) (s - start));
d5438 1
a5438 1
	return (0);
d5441 1
a5441 1
     * Get the month string and convert to an integer.  - FM
d5446 1
a5446 1
	return (0);
d5453 1
a5453 1
	return (0);
d5456 73
a5528 73
    case '0':
    case '1':
	month = atoi(temp);
	if (month < 1 || month > 12) {
	    return (0);
	}
	break;
    case 'A':
	if (!strcasecomp(temp, "Apr")) {
	    month = 4;
	} else if (!strcasecomp(temp, "Aug")) {
	    month = 8;
	} else {
	    return (0);
	}
	break;
    case 'D':
	if (!strcasecomp(temp, "Dec")) {
	    month = 12;
	} else {
	    return (0);
	}
	break;
    case 'F':
	if (!strcasecomp(temp, "Feb")) {
	    month = 2;
	} else {
	    return (0);
	}
	break;
    case 'J':
	if (!strcasecomp(temp, "Jan")) {
	    month = 1;
	} else if (!strcasecomp(temp, "Jun")) {
	    month = 6;
	} else if (!strcasecomp(temp, "Jul")) {
	    month = 7;
	} else {
	    return (0);
	}
	break;
    case 'M':
	if (!strcasecomp(temp, "Mar")) {
	    month = 3;
	} else if (!strcasecomp(temp, "May")) {
	    month = 5;
	} else {
	    return (0);
	}
	break;
    case 'N':
	if (!strcasecomp(temp, "Nov")) {
	    month = 11;
	} else {
	    return (0);
	}
	break;
    case 'O':
	if (!strcasecomp(temp, "Oct")) {
	    month = 10;
	} else {
	    return (0);
	}
	break;
    case 'S':
	if (!strcasecomp(temp, "Sep")) {
	    month = 9;
	} else {
	    return (0);
	}
	break;
    default:
	return (0);
d5532 1
a5532 1
     * Get the numeric year string and convert to an integer.  - FM
d5537 1
a5537 1
	return (0);
d5551 1
a5551 1
	 * the broken sender software intends.  (This totally breaks
d5561 1
a5561 1
	return (0);
d5566 1
a5566 1
     * Get the numeric hour string and convert to an integer.  - FM
d5579 2
a5580 2
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
d5584 1
a5584 1
	 * Get the numeric minutes string and convert to an integer.  - FM
d5589 1
a5589 1
	    return (0);
d5594 2
a5595 2
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
d5599 1
a5599 1
	 * Get the numeric seconds string and convert to an integer.  - FM
d5604 1
a5604 1
	    return (0);
d5609 2
a5610 2
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
d5615 3
a5617 2
     * Convert to clock format (seconds since 00:00:00 Jan 1 1970), but then
     * zero it if it's in the past and "absolute" is not TRUE.  - FM
d5621 2
a5622 2
	month += 12;
	year--;
d5624 8
a5631 8
    day += (year - 1968) * 1461 / 4;
    day += ((((month * 153) + 2) / 5) - 672);
    clock2 = (time_t) ((day * 60 * 60 * 24) +
		       (hour * 60 * 60) +
		       (minutes * 60) +
		       seconds);
    if (absolute == FALSE && (long) (time((time_t *) 0) - clock2) >= 0)
	clock2 = (time_t) 0;
d5634 2
a5635 2
		(long) clock2,
		ctime(&clock2)));
d5637 1
a5637 1
    return (clock2);
d5642 1
a5642 1
 * No putenv on the NeXT so we use this code instead!
d5676 1
a5676 1
 * Put STRING, which is of the form "NAME=VALUE", in the environment.
d5678 2
a5679 1
int putenv(const char *string)
d5681 19
a5699 16
    char *name_end = strchr(string, '=');
    register size_t size;
    register char **ep;

    if (name_end == NULL) {
	/* Remove the variable from the environment.  */
	size = strlen(string);
	for (ep = environ; *ep != NULL; ++ep)
	    if (!strncmp(*ep, string, size) && (*ep)[size] == '=') {
		while (ep[1] != NULL) {
		    ep[0] = ep[1];
		    ++ep;
		}
		*ep = NULL;
		return 0;
	    }
d5702 6
a5707 7
    size = 0;
    for (ep = environ; *ep != NULL; ++ep)
	if (!strncmp(*ep, string, name_end - string) &&
	    (*ep)[name_end - string] == '=')
	    break;
	else
	    ++size;
d5709 16
a5724 16
    if (*ep == NULL) {
	static char **last_environ = NULL;
	char **new_environ = (char **) malloc((size + 2) * sizeof(char *));

	if (new_environ == NULL)
	    return -1;
	(void) memcpy((char *) new_environ, (char *) environ, size * sizeof(char *));

	new_environ[size] = (char *) string;
	new_environ[size + 1] = NULL;
	if (last_environ != NULL)
	    FREE(last_environ);
	last_environ = new_environ;
	environ = new_environ;
    } else
	*ep = (char *) string;
d5726 1
a5726 1
    return 0;
d5731 1
a5731 1
int remove(char *name)
d5753 1
a5753 1
static BOOL IsOurFile(char *name)
d5758 3
a5760 3
	&& S_ISREG(data.st_mode)
	&& data.st_nlink == 1
	&& data.st_uid == getuid()) {
a5761 1

d5796 1
a5796 1
			|| (data.st_mode & S_IWOTH) != 0) {
d5815 1
a5815 1
static FILE *OpenHiddenFile(char *name, char *mode)
d5821 1
a5821 1
#if defined(O_CREAT) && defined(O_EXCL)		/* we have fcntl.h or kindred? */
d5827 1
a5827 2
	int fd = open(name, O_CREAT | O_EXCL | O_WRONLY, HIDE_CHMOD);

d5829 2
a5830 2
	    && errno == EEXIST
	    && IsOurFile(name)) {
d5833 1
a5833 1
	    fd = open(name, O_CREAT | O_EXCL | O_WRONLY, HIDE_CHMOD);
d5842 2
a5843 1
    } else
d5847 1
a5847 1
	    && chmod(name, HIDE_CHMOD) == 0)
d5851 9
a5859 9
	/*
	 * This is less stringent, but reasonably portable.  For new files, the
	 * umask will suffice; however if the file already exists we'll change
	 * permissions first, before opening it.  If the chmod fails because of
	 * some reason other than a non-existent file, there's no point in trying
	 * to open it.
	 *
	 * This won't work properly if the user is root, since the chmod succeeds.
	 */
a5861 1

d5870 1
a5870 1
FILE *LYNewBinFile(char *name)
d5873 1
a5873 2
    FILE *fp = fopen(name, BIN_W, "mbc=32");

d5881 1
a5881 1
FILE *LYNewTxtFile(char *name)
d5886 1
a5886 1
    fp = fopen(name, TXT_W, "shr=get");
d5899 1
a5899 1
FILE *LYAppendToTxtFile(char *name)
d5904 1
a5904 1
    fp = fopen(name, TXT_A, "shr=get");
d5918 3
a5920 3
 * Restore normal permissions to a copy of a file that we have created with
 * temp file restricted permissions.  The normal umask should apply for user
 * files.  - kw
d5922 1
a5922 1
void LYRelaxFilePermissions(const char *name)
a5925 1

d5930 3
a5932 3
	 * It looks plausible that this is a file we created with temp file
	 * paranoid permissions (and the umask wasn't even more restrictive
	 * when it was copied).  - kw
a5934 1

d5945 3
a5947 2
BOOLEAN LYCachedTemp(char *result,
		     char **cached)
d5970 4
a5973 3
FILE *LYOpenTemp(char *result,
		 const char *suffix,
		 const char *mode)
d5986 3
a5988 9
	case 'w':
	    wrt = 'w';
	    break;
	case 'a':
	    wrt = 'a';
	    break;
	case 'b':
	    txt = FALSE;
	    break;
d5990 2
a5991 2
	    CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
	    return 0;
d6000 2
a6001 1
    if (lynx_temp_subspace == 0) {
d6006 1
a6006 1
	    && S_ISDIR(sb.st_mode)) {
d6008 1
a6008 1
		|| (sb.st_mode & (S_IWOTH | S_IWGRP)) != 0) {
d6010 2
a6011 3
		CTRACE((tfp,
			"lynx_temp_space is not our directory %s owner %d mode %03o\n",
			lynx_temp_space, (int) sb.st_uid, (int) sb.st_mode & 0777));
a6018 1

d6040 1
a6040 1
		fp = LYNewTxtFile(result);
d6043 1
a6043 1
		fp = LYAppendToTxtFile(result);
d6047 1
a6047 1
	    fp = LYNewBinFile(result);
d6054 1
a6054 1
#ifdef EEXIST			/* FIXME (need a better test) in fcntl.h or unistd.h */
d6057 1
a6057 1
		    result, LYStrerror(errno)));
d6080 2
a6081 1
FILE *LYReopenTemp(char *name)
d6088 1
a6088 1
	fp = p->file = LYAppendToTxtFile(name);
d6108 4
a6111 3
FILE *LYOpenTempRewrite(char *fname,
			const char *suffix,
			const char *mode)
d6136 1
a6136 1
	writable_exists = HTEditable(fname);	/* existing, can write */
d6139 1
a6139 1
	writable_exists = (BOOL) (stat(fname, &stat_buf) == 0);		/* existing, assume can write */
d6147 2
a6148 2
		writable_exists ? CTRACE_EXISTS : "",
		is_ours ? "is our file." : "is NOT our file."));
d6152 5
a6156 4
     * Note that in cases where LYOpenTemp is called as fallback below, we
     * don't call LYRemoveTemp first.  That may be appropriate in some cases,
     * but not trying to remove a weird existing file seems safer and could
     * help diagnose an unusual situation.  (They may be removed anyway later.)
d6165 2
a6166 2
	 * Not registered.  It should have been registered at one point though,
	 * otherwise we wouldn't be called like this.
d6171 2
a6172 1
	 * File exists, writable if we checked, but something is wrong with it.
d6178 1
a6178 1
	 * Exists but not writable, and something is wrong with it.
d6186 3
a6188 9
	case 'w':
	    wrt = 'w';
	    break;
	case 'a':
	    wrt = 'a';
	    break;
	case 'b':
	    txt = FALSE;
	    break;
d6190 2
a6191 2
	    CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
	    return fp;
d6197 2
a6198 2
	 * Yes, it exists, is writable if we checked, and everything looks ok
	 * so far.  This should be the most regular case.  - kw
d6203 2
a6204 2
	     * We truncate and then append, this avoids having a small window
	     * in which the file doesn't exist.  - kw
d6219 7
a6225 5
    /* We come here in two cases:  either the file existed and was ours and we
     * just got rid of it.  Or the file did and does not exist, but is
     * registered as a temp file.  It must have been removed by some means
     * other than LYRemoveTemp.  In both cases, reuse the name!  - kw
     */
d6230 1
a6230 1
	    fp = LYNewTxtFile(fname);
d6233 1
a6233 1
	    fp = LYAppendToTxtFile(fname);
d6237 1
a6237 1
	fp = LYNewBinFile(fname);
d6242 1
a6242 1
	    (fp) ? "ok" : "failed"));
d6244 4
a6247 4
     * We could fall back to trying LYOpenTemp() here in case of failure. 
     * After all the checks already done above a filure here should be pretty
     * unusual though, so maybe it's better to let the user notice that
     * something went wrong, and not try to fix it up.  - kw
d6256 3
a6258 2
FILE *LYOpenScratch(char *result,
		    const char *prefix)
d6266 1
a6266 1
    if ((fp = LYNewTxtFile(result)) != 0) {
d6280 2
a6281 1
static void LY_close_temp(LY_TEMP * p)
d6296 2
a6297 1
void LYCloseTemp(char *name)
d6304 1
a6304 1
		(p->file != 0) ? ", closed" : ""));
d6312 2
a6313 1
void LYCloseTempFP(FILE *fp)
d6327 2
a6328 1
int LYRemoveTemp(char *name)
d6345 1
a6345 1
			(p->file != 0) ? ", closed" : ""));
d6360 1
a6360 1
void LYCleanupTemp(void)
d6368 1
a6368 2

	LYstrncpy(result, lynx_temp_space, sizeof(result) - 1);
d6380 3
a6382 2
void LYRenamedTemp(char *oldname,
		   char *newname)
d6394 1
a6394 1
 * Check that bibhost defines the BibP icon.
d6396 1
a6396 1
void LYCheckBibHost(void)
d6410 1
a6410 1
    traversal = TRUE;		/* Hack to force error response. */
d6418 1
a6418 1
 * Management of User Interface Pages.  - kw
d6420 2
a6421 2
 * These are mostly temp files.  Pages which can be recognized by their special
 * URL (after having been loaded) need not be tracked here.
d6423 1
a6423 1
 * First some private stuff:
d6426 5
a6430 5
    UIP_t type;
    unsigned flags;
    char *url;
    HTList *alturls;
    char *file;
d6434 1
a6434 1
#define UIP_F_LIMIT	0x0002	/* flag: limit size of alturls list */
d6436 1
a6436 1
/* *INDENT-OFF* */
a6466 1
/* *INDENT-ON* */
d6470 4
a6473 3
BOOL LYIsUIPage3(const char *url,
		 UIP_t type,
		 int flagparam)
a6476 1

d6484 1
a6484 1
		       (!strncmp(ly_uip[i].url, url, (l = strlen(ly_uip[i].url)))
d6494 2
a6495 2
			(!strncmp(p, url, (l = strlen(p)))
			 && (url[l] == '\0' || url[l] == '#')) :
d6506 3
a6508 2
void LYRegisterUIPage(const char *url,
		      UIP_t type)
a6510 1

d6549 1
a6549 1
void LYUIPages_free(void)
a6553 1

d6567 2
a6568 2
 * Convert local pathname to www name
 * (do not bother about file://localhost prefix at this point).
d6570 2
a6571 1
const char *wwwName(const char *pathname)
d6595 3
a6597 2
BOOLEAN LYValidateFilename(char *result,
			   char *given)
d6603 2
a6604 2
     * Cancel if the user entered "/dev/null" on Unix, or an "nl:" path on VMS. 
     * - FM
d6606 2
a6607 1
    if (LYIsNullDevice(given)) {
d6622 2
a6623 2
	&& (cp2 = wwwName(Home_Dir())) != 0
	&& strlen(cp2) + strlen(given) < LY_MAXPATH) {
d6637 2
a6638 2
	&& strchr(given, ':') == NULL
	&& strlen(given) < LY_MAXPATH - 13) {
d6651 3
a6653 3
	if (strchr(result, ':') != NULL)
	    cp = NULL;
	else
a6657 1

d6663 3
a6665 2
    } else
#endif /* __EMX__ */
d6692 2
a6693 1
int LYValidateOutput(char *filename)
d6713 1
a6713 1
     * See if it already exists.
d6734 3
a6736 2
void LYLocalFileToURL(char **target,
		      const char *source)
a6745 1

d6760 3
a6762 2
FILE *InternalPageFP(char *filename,
		     int reuse_flag)
d6778 4
a6781 2
void BeginInternalPage(FILE *fp0, char *Title,
		       char *HelpURL)
d6783 1
a6783 2
    fprintf(fp0,
	    "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n");
a6789 1

d6802 1
a6802 1
	    Title);
d6805 2
a6806 2
	&& LYwouldPush(Title, NULL)
	&& (HelpURL != 0)) {
d6816 2
a6817 1
void EndInternalPage(FILE *fp0)
d6822 2
a6823 1
char *trimPoundSelector(char *address)
a6825 1

d6835 2
a6836 1
void LYTrimPathSep(char *path)
d6841 3
a6843 3
	&& (len = strlen(path)) != 0
	&& LYIsPathSep(path[len - 1]))
	path[len - 1] = 0;
d6850 2
a6851 1
void LYAddPathSep(char **path)
d6857 3
a6859 3
	&& ((temp = *path) != 0)
	&& (len = strlen(temp)) != 0
	&& !LYIsPathSep(temp[len - 1])) {
d6868 2
a6869 1
void LYAddPathSep0(char *path)
d6874 3
a6876 3
	&& (len = strlen(path)) != 0
	&& (len < LY_MAXPATH - 2)
	&& !LYIsPathSep(path[len - 1])) {
d6884 2
a6885 1
char *LYLastPathSep(const char *path)
a6887 1

d6901 2
a6902 1
void LYTrimHtmlSep(char *path)
d6907 3
a6909 3
	&& (len = strlen(path)) != 0
	&& LYIsHtmlSep(path[len - 1]))
	path[len - 1] = 0;
d6916 2
a6917 1
void LYAddHtmlSep(char **path)
d6923 3
a6925 3
	&& ((temp = *path) != 0)
	&& (len = strlen(temp)) != 0
	&& !LYIsHtmlSep(temp[len - 1])) {
d6934 2
a6935 1
void LYAddHtmlSep0(char *path)
d6940 3
a6942 3
	&& (len = strlen(path)) != 0
	&& (len < LY_MAXPATH - 2)
	&& !LYIsHtmlSep(path[len - 1])) {
d6950 3
a6952 2
int LYCopyFile(char *src,
	       char *dst)
d7000 1
a7000 1
static char *escape_backslashes(char *source)
a7014 1

d7029 2
a7030 1
int LYSystem(char *command)
a7033 1

a7038 1

d7056 1
a7056 1
#  ifdef __EMX__		/* FIXME: Should be LY_CONVERT_SLASH? */
d7118 1
a7118 2
	    sprintf(new_command, "%.*s \"%.*s\"",
		    LY_MAXPATH, new_cmd, LY_MAXPATH, win32_name);
d7124 1
a7124 1
		    if (*(p + 1) == '\\')
a7139 1

d7149 1
a7149 1
    code = exec_command(command, TRUE);		/* Wait exec */
d7153 1
a7153 1
	signal(SIGPIPE, SIG_DFL);	/* Some commands expect the default */
d7167 1
a7167 1
	signal(SIGPIPE, SIG_IGN);	/* Ignore it again - kw */
d7182 1
a7182 1
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ?? */
d7194 2
a7195 2
#if defined(__CYGWIN__)		/* 1999/02/26 (Fri) */
int Cygwin_Shell(void)
d7207 1
a7207 1
    sa.bInheritHandle = TRUE;
d7215 2
a7216 2
       inherited handles. Pass the value of the
       handle as a command line parameter */
d7220 2
a7221 2
			     TRUE, 0,
			     0, 0, &startUpInfo, &procInfo);
d7236 1
a7236 1
char *LYSysShell(void)
a7238 1

d7288 1
a7288 1
char *LYgetXDisplay(void)
d7297 2
a7298 1
void LYsetXDisplay(char *new_display)
d7324 1
a7324 1
static void morph_PM(void)
d7334 2
a7335 2
    if (pib->pib_ultype != 3)	/* 2 is VIO */
	pib->pib_ultype = 3;	/* 3 is PM */
d7343 1
a7343 1
static void unmorph_PM(void)
d7349 1
a7349 1
int size_clip(void)
d7356 1
a7356 1
int put_clip(char *s)
d7368 1
a7368 1
    if (DosAllocSharedMem((PPVOID) & pByte, 0, sz + nl,
d7382 1
a7382 1
    if (!hab)
d7394 1
a7394 1
    DosFreeMem((PPVOID) & pByte);
d7403 1
a7403 1
char *get_clip_grab(void)
d7410 1
a7410 1
    if (!hab)
d7416 1
a7416 1
    if (ulFormat != CFI_POINTER) {
d7422 1
a7422 1
    ClipData = (char *) WinQueryClipbrdData(hab, CF_TEXT);
d7424 1
a7424 1
    if (!ClipData || !sz) {
d7431 1
a7431 1
void get_clip_release(void)
d7440 1
a7440 1
#else /* !( defined __EMX__ ) */
d7444 1
a7444 1
static FILE *paste_handle = 0;
d7447 1
a7447 1
void get_clip_release(void)
d7452 1
a7452 1
	FREE(paste_buf);
d7455 1
a7455 1
static int clip_grab(void)
d7471 1
a7471 1
#define CF_TEXT 0		/* Not used */
d7473 1
a7473 1
char *get_clip_grab(void)
d7484 2
a7485 2
	FREE(paste_buf);
    paste_buf = (char *) malloc(PASTE_BUFFER);
d7487 1
a7487 1
	len = fread(paste_buf + off, 1, PASTE_BUFFER - 1, paste_handle);
d7490 3
d7494 1
a7494 4
	if (strchr(paste_buf + off, '\r')
	    || strchr(paste_buf + off, '\n'))
	    break;
	paste_buf = realloc(paste_buf, size += PASTE_BUFFER - 1);
d7500 2
a7501 1
int put_clip(char *s)
d7510 1
a7510 1
    fh = popen(cmd, "wt");
d7513 2
a7514 2
    res = fwrite(s, 1, l, fh);
    if (pclose(fh) != 0 || res != l)
d7519 1
a7519 1
#  endif			/* !defined(WIN_EX) && defined(HAVE_POPEN) */
d7523 1
a7523 1
#if defined(WIN_EX)		/* 1997/10/16 (Thu) 20:13:28 */
d7540 1
a7540 1
	len++;
d7580 1
a7580 1
char *get_clip_grab()
d7611 1
a7611 1
#endif /* WIN_EX */
a7619 6
#ifdef ENABLE_IPV6
#define WSOCK_NAME  "ws2_32"
#else
#define WSOCK_NAME  "wsock32"
#endif

d7626 1
a7626 1
 *	comp.os.ms-windows.programmer.win32
d7628 1
a7628 1
char *w32_strerror(DWORD ercode)
a7632 1

a7638 1
    DWORD rc;
d7648 1
a7648 1
     * Special code for winsock error handling.
d7651 4
a7654 2
	hModule = GetModuleHandle(WSOCK_NAME);
	if (hModule)
d7658 1
a7658 1
     * message handling. If not found in module, retry from system.
d7660 7
a7666 7
    rc = FormatMessage(msg_type, hModule, ercode, LANG_NEUTRAL,
		       msg_buff, sizeof(msg_buff), NULL);

    if (rc == 0 && msg_type == FORMAT_MESSAGE_FROM_HMODULE) {
	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, ercode,
		      LANG_NEUTRAL, msg_buff, sizeof(msg_buff), NULL);
    }
d7687 2
a7688 1
void LYOpenlog(const char *banner)
d7691 1
a7691 1
    openlog("lynx", LOG_PID | LOG_NDELAY, LOG_LOCAL5);
d7703 3
a7705 2
static BOOLEAN looks_like_password(char *first,
				   char *last)
d7711 1
a7711 1
	    || *first == ':') {
d7721 2
a7722 1
void LYSyslog(char *arg)
d7730 2
a7731 2
    if (is_url(arg)) {		/* proto://user:password@@host/path:port */
	/*      ^this colon                 */
d7733 5
a7737 5
	    && !strncmp(colon1, "://", 3)
	    && (colon2 = strchr(colon1 + 3, ':')) != 0
	    && (atsign = strchr(colon1, '@@')) != 0
	    && (colon2 < atsign)
	    && looks_like_password(colon2 + 1, atsign - 1)) {
d7744 1
a7744 1
	    syslog(LOG_INFO | LOG_LOCAL5, "%s", buf);
d7750 1
a7750 1
    syslog(LOG_INFO | LOG_LOCAL5, "%s", NONNULL(arg));
d7753 1
a7753 1
void LYCloselog(void)
d7755 2
a7756 2
    syslog(LOG_INFO, "Session over");
    closelog();
@


1.1.3.7
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d402 1
a402 1
		      (LYcolLimit - LYGetHilitePos(cur, count)),
d1050 1
a1050 1
	    int avail_space = (LYcolLimit - links[cur].lx);
d1082 1
a1082 1
			  (LYcolLimit - links[cur].lx),
d1280 2
a1281 3
    max_length = (((LYcolLimit - 1) < (int) sizeof(buffer))
		  ? (LYcolLimit - 1)
		  : (int) sizeof(buffer) - 1);
d2791 1
a2791 1
    SLtt_Screen_Cols = LYcolLimit * 6;
d2795 1
a2795 1
    SLtt_Screen_Cols = HTMIN(LYcolLimit * 6, 255);
d3052 1
a3052 1
		   *cp == ',' || *cp == ':' || *cp == '"' ||
d3206 1
a3206 1
	case '"':
d5972 1
a5972 1
	    StrAllocCat(lynx_temp_space, "lynxXXXXXXXXXX");
d6723 2
a6724 4
/*
 * This part is shared by all internal pages.
 */
void WriteInternalTitle(FILE *fp0, char *Title)
d6746 2
a6747 11
    fprintf(fp0, "<title>%s</title>\n</head>\n<body>\n", Title);
}

/*
 * This is used to start most internal pages, except for special cases where
 * the embedded HREF's in the title differ.
 */
void BeginInternalPage(FILE *fp0, char *Title,
		       char *HelpURL)
{
    WriteInternalTitle(fp0, Title);
a7461 24

/*
 * Sleep for a number of milli-sec.
 */
void LYmsec_delay(unsigned msec)
{
#if defined(_WINDOWS)
    Sleep(msec);

#elif defined(HAVE_NAPMS)
    napms(msec);

#elif defined(DJGPP) || defined(HAVE_USLEEP)
    usleep(1000 * msec);

#else
    struct timeval tv;
    unsigned long usec = 1000UL * msec;

    tv.tv_sec  = usec / 1000000UL;
    tv.tv_usec = usec % 1000000UL;
    select (0, NULL, NULL, NULL, &tv);
#endif
}
@


1.1.3.8
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d2668 1
a2668 1
		NONNULL(cp), UTMP_FILE));
d7493 1
a7493 1
    tv.tv_sec = usec / 1000000UL;
d7495 1
a7495 1
    select(0, NULL, NULL, NULL, &tv);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d9 1
a11 1
#include <LYUtils.h>
a16 1

a19 19
#ifdef __DJGPP__
#include <go32.h>
#include <sys/exceptn.h>
#endif /* __DJGPP__ */

#ifndef NO_GROUPS
#include <HTFile.h>
#endif

#if _WIN_CC
extern int exec_command(char * cmd, int wait_flag); /* xsystem.c */
#endif

#ifdef _WINDOWS	/* 1998/04/30 (Thu) 19:04:25 */
#define GETPID()	(getpid() & 0xffff)
#else
#define GETPID()	getpid()
#endif /* _WINDOWS */

a23 9
#ifdef __EMX__
#  define BOOLEAN OS2_BOOLEAN		/* Conflicts, but is used */
#  undef HT_ERROR			/* Conflicts too */
#  define INCL_PM			/* I want some PM functions.. */
#  define INCL_DOSPROCESS		/* TIB PIB. */
#  include <os2.h>
#  undef BOOLEAN
#endif

a34 1
#ifdef UTMPX_FILE
d38 1
a40 1
#ifdef __UTMPX_FILE
a41 3
#else
#define UTMP_FILE "/var/adm/utmpx" /* Digital Unix 4.0 */
#endif
a90 16
/*
 * experimental - make temporary filenames random to make the scheme less
 * obvious.  However, as noted by KW, there are instances (such as the
 * 'O'ption page, for which Lynx will store a temporary filename even when
 * it no longer applies, since it will reuse that filename at a later time.
 */
#ifdef EXP_RAND_TEMPNAME
#if defined(LYNX_RAND_MAX)
#define USE_RAND_TEMPNAME 1
#define MAX_TEMPNAME 10000
#ifndef BITS_PER_CHAR
#define BITS_PER_CHAR 8
#endif
#endif
#endif

d93 1
d95 1
a101 46
 * Maintain a list of all of the temp-files we create so that we can remove
 * them during the cleanup.
 */
typedef struct _LYTemp {
    struct _LYTemp *next;
    char *name;
    BOOLEAN outs;
    FILE *file;
} LY_TEMP;

PRIVATE LY_TEMP *ly_temp;

PRIVATE LY_TEMP *FindTempfileByName ARGS1(CONST char *, name)
{
    LY_TEMP *p;

    for (p = ly_temp; p != 0; p = p->next) {
	if (!strcmp(p->name, name)) {
	    break;
	}
    }
    return p;
}

PRIVATE LY_TEMP *FindTempfileByFP ARGS1(FILE *, fp)
{
    LY_TEMP *p;

    for (p = ly_temp; p != 0; p = p->next) {
	if (p->file == fp) {
	    break;
	}
    }
    return p;
}

/*
 * Get an environment variable, rejecting empty strings
 */
PRIVATE char *getenv_text ARGS1(char *, name)
{
    char *result = getenv(name);
    return (result != 0 && *result != 0) ? result : 0;
}

/*
d112 1
a112 1
#ifdef SHOW_WHEREIS_TARGETS
a118 1
    BOOL target1_drawn = NO;
d120 1
a120 2
    BOOL utf_flag = (BOOL)(LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8);
    BOOL hl1_drawn = NO;
a134 4
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
    if (flag == OFF)
	textinput_redrawn = FALSE;
#endif
d141 6
d148 4
a151 5
	if (links[cur].type == WWW_FORM_LINK_TYPE ||
	    !links[cur].hightext) {
	    LYMoveToLink(cur, target, NULL,
			 flag, links[cur].inUnderline, utf_flag);
	    lynx_start_link_color (flag == ON, links[cur].inUnderline);
d153 1
a153 22
	    LYMoveToLink(cur, target, links[cur].hightext,
			 flag, links[cur].inUnderline, utf_flag);
	    hl1_drawn = YES;
#ifdef SHOW_WHEREIS_TARGETS
	    target1_drawn = YES;
#endif
	}
#else	/* here USE_COLOR_STYLE defined */
	int s = s_alink;

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	if ( textfields_need_activation &&
	     links[cur].type == WWW_FORM_LINK_TYPE &&
	     F_TEXTLIKE(links[cur].form->type) )
	    s = s_curedit;
#endif


#  define LXP (links[cur].lx)
#  define LYP (links[cur].ly)
	if (flag != ON) {
	    int x;
a162 3
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.highlight.off: cached style @@(%d,%d): ",
			      LYP, LXP));
a170 2
			    CTRACE((tfp, "found %d, x_offset=%d.\n",
				    cached_styles[LYP][x], (int)x-LXP));
d174 1
a174 2
		    if (s == 0) {
			CTRACE((tfp, "not found, assume <a>.\n"));
a175 3
		    }
		} else {
		    CTRACE((tfp, "found %d.\n", s));
a177 1
		CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.off: can't use cache.\n"));
d180 1
a180 2
	} else {
	    CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.on: @@(%d,%d).\n", LYP, LXP));
a181 2
	LYmove(LYP, LXP);
	LynxChangeStyle(s, STACK_ON);
d195 1
a195 1
	    LYaddstr(buffer);
d199 1
a199 1
		LYaddch('_');
a205 1
		CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.off: NOFIX branch @@(%d,%d).\n", LYP, LXP));
d208 1
a208 1
	    if (!hl1_drawn) {
d213 7
a219 7
		LYmbcsstrncpy(buffer,
			      (links[cur].hightext ?
			       links[cur].hightext : ""),
			      (sizeof(buffer) - 1),
			      ((LYcols - 1) - links[cur].lx),
			      utf_flag);
		LYaddstr(buffer);
d232 1
a232 1
	    LYmove((links[cur].ly + 1), links[cur].hightext2_offset);
d236 1
a236 5
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.line2: @@(%d,%d), style=%d.\n",
			  links[cur].ly + 1, links[cur].hightext2_offset,
			  flag == ON ? s_alink : s_a));
	    LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_ON);
d247 1
a247 1
			LYaddstr(tmp);
d250 1
a250 1
			LYaddstr(tmp);
d260 1
a260 2
#ifdef SHOW_WHEREIS_TARGETS
	if (!target1_drawn)
d303 1
a303 1
		  LYmbcsstrlen(buffer, utf_flag, YES) : hlen);
d322 11
a332 5
		if (((cp = LYno_attr_mb_strstr(data,
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL) &&
d359 1
a359 1
		LYmove(hLine, offset);
d395 1
a395 1
			LYaddstr(tmp);
d397 1
a397 1
			LYmove(hLine, (offset + 1));
d414 1
a414 1
			LYaddstr(tmp);
d416 1
a416 1
			LYmove(hLine, (offset + 1));
d428 1
a428 1
			LYaddstr(tmp);
d430 1
a430 1
			LYmove(hLine, (offset + 1));
d494 1
a494 1
			    LYmove(hLine, (offset + 1));
d496 1
a496 1
			    LYaddstr(tmp);
d515 1
a515 1
			    LYmove(hLine, (offset + 1));
d517 1
a517 1
			    LYaddstr(tmp);
d531 1
a531 1
			    LYmove(hLine, (offset + 1));
d533 1
a533 1
			    LYaddstr(tmp);
d570 11
a580 5
		if (((cp = LYno_attr_mb_strstr(data,
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL) &&
d621 1
a621 1
		LYrefresh();
d635 1
a635 1
	    LYmove(hLine, offset);
d674 1
a674 1
		    LYaddstr(tmp);
d676 1
a676 1
		    LYmove(hLine, (offset + 1));
d696 1
a696 1
		    LYaddstr(tmp);
d698 1
a698 1
		    LYmove(hLine, (offset + 1));
d713 1
a713 1
		    LYaddstr(tmp);
d715 1
a715 1
		    LYmove(hLine, (offset + 1));
d776 1
a776 1
			LYmove(hLine, (offset + 1));
d778 1
a778 1
			LYaddstr(tmp);
d797 1
a797 1
			LYmove(hLine, (offset + 1));
d799 1
a799 1
			LYaddstr(tmp);
d813 1
a813 1
			LYmove(hLine, (offset + 1));
d815 1
a815 1
			LYaddstr(tmp);
d849 11
a859 5
	    if (((cp = LYno_attr_mb_strstr(data,
					   target,
					   utf_flag, YES,
					   &HitOffset,
					   &LenNeeded)) != NULL) &&
d884 1
a884 1
			LYrefresh();
d889 1
a889 1
		    LYmove(hLine, offset);
d944 1
a944 1
				LYmove(hLine, (offset + 1));
d946 1
a946 1
				LYaddstr(tmp);
d965 1
a965 1
				LYaddstr(tmp);
d979 1
a979 1
				LYaddstr(tmp);
d1033 1
a1033 1
		  LYmbcsstrlen(buffer, utf_flag, YES) : hlen);
d1052 11
a1062 5
		if (((cp = LYno_attr_mb_strstr(data,
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL) &&
d1089 1
a1089 1
		LYmove(hLine, offset);
d1125 1
a1125 1
			LYaddstr(tmp);
d1127 1
a1127 1
			LYmove(hLine, (offset + 1));
d1144 1
a1144 1
			LYaddstr(tmp);
d1146 1
a1146 1
			LYmove(hLine, (offset + 1));
d1158 1
a1158 1
			LYaddstr(tmp);
d1160 1
a1160 1
			LYmove(hLine, (offset + 1));
d1224 1
a1224 1
			    LYmove(hLine, (offset + 1));
d1226 1
a1226 1
			    LYaddstr(tmp);
d1245 1
a1245 1
			    LYmove(hLine, (offset + 1));
d1247 1
a1247 1
			    LYaddstr(tmp);
d1261 1
a1261 1
			    LYmove(hLine, (offset + 1));
d1263 1
a1263 1
			    LYaddstr(tmp);
d1299 11
a1309 5
		if (((cp = LYno_attr_mb_strstr(data,
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL) &&
d1350 1
a1350 1
		LYrefresh();
d1364 1
a1364 1
	    LYmove(hLine, offset);
d1403 1
a1403 1
		    LYaddstr(tmp);
d1405 1
a1405 1
		    LYmove(hLine, (offset + 1));
d1425 1
a1425 1
		    LYaddstr(tmp);
d1427 1
a1427 1
		    LYmove(hLine, (offset + 1));
d1442 1
a1442 1
		    LYaddstr(tmp);
d1444 1
a1444 1
		    LYmove(hLine, (offset + 1));
d1505 1
a1505 1
			LYmove(hLine, (offset + 1));
d1507 1
a1507 1
			LYaddstr(tmp);
d1526 1
a1526 1
			LYmove(hLine, (offset + 1));
d1528 1
a1528 1
			LYaddstr(tmp);
d1542 1
a1542 1
			LYmove(hLine, (offset + 1));
d1544 1
a1544 1
			LYaddstr(tmp);
d1578 11
a1588 5
	    if (((cp = LYno_attr_mb_strstr(data,
					   target,
					   utf_flag, YES,
					   &HitOffset,
					   &LenNeeded)) != NULL) &&
d1613 1
a1613 1
			LYrefresh();
d1618 1
a1618 1
		    LYmove(hLine, offset);
d1673 1
a1673 1
				LYmove(hLine, (offset + 1));
d1675 1
a1675 1
				LYaddstr(tmp);
d1694 1
a1694 1
				LYaddstr(tmp);
d1708 1
a1708 1
				LYaddstr(tmp);
d1738 1
a1738 1
	    LYHideCursor();
d1740 1
a1740 1
#endif /* SHOW_WHEREIS_TARGETS */
d1744 1
a1744 1
	    LYmove(links[cur].ly,
d1748 1
a1748 1
	    LYrefresh();
d1835 1
a1835 1
    char buffer[MAX_LINE];
a1838 2
    char *p;
    char text_buff[MAX_LINE];
a1858 6
    /* "LYNXDOWNLOAD://Method=-1/File=%s/SugFile=%s%s\">Save to disk</a>\n" */
    LYstrncpy(text_buff, text, sizeof(text_buff)-1);
    p = strchr(text_buff, '\n');
    if (p)
	p= '\0';

d1866 1
a1866 1
    if ((text_buff[0] != '\0') &&
d1871 1
a1871 1
	if ((temp = typecallocn(unsigned char, strlen(text_buff) + 1)) == NULL)
d1874 1
a1874 1
	    TO_EUC((CONST unsigned char *)text_buff, temp);
d1876 1
a1876 8
#ifdef KANJI_CODE_OVERRIDE
	    if (!LYRawMode || last_kcode == SJIS)
		strcpy(temp, text_buff);
	    else
		TO_SJIS((CONST unsigned char *)text_buff, temp);
#else
	    strcpy((char *) temp, text_buff);
#endif
d1878 3
a1880 3
	    for (i = 0, j = 0; text_buff[i]; i++) {
		if (text_buff[i] != CH_ESC) {  /* S/390 -- gil -- 2119 */
		    temp[j++] = text_buff[i];
d1921 3
a1923 3
	for (i = 0, len = 0; text_buff[i] != '\0' && len < max_length; i++) {
	    if (text_buff[i] != CH_ESC) {  /* S/390 -- gil -- 2119 */
		buffer[len++] = text_buff[i];
d1939 1
a1939 1
	    LYmove(LYStatusLine, 0);
d1941 1
a1941 1
	    LYmove(LYlines-1, 0);
d1944 1
a1944 1
	LYmove(LYlines-3, 0);
d1946 1
a1946 1
	LYmove(LYlines-1, 0);
d1948 1
a1948 2
    LYclrtoeol();

a1949 12
	BOOLEAN has_CJK = FALSE;

	if (HTCJK != NOCJK) {
	    for (i = 0; buffer[i] != '\0'; i++) {
		if (buffer[i] & 0x80) {
		    has_CJK = TRUE;
		    break;
		}
	    }
	}

	if (has_CJK
d1951 2
a1952 4
	    || (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8)
#endif
	    ) {
	    LYrefresh();
d1954 1
a1954 1

d1957 1
a1957 1
	LYaddstr (buffer);
d1964 3
a1966 3
		LynxChangeStyle (a, STACK_ON);
		LYaddstr(buffer);
		wbkgdset(LYwin,
d1970 1
a1970 1
		LYclrtoeol();
d1972 1
a1972 1
		    wbkgdset(LYwin, A_NORMAL | ' ');
d1974 1
a1974 1
		    wbkgdset(LYwin, hashStyles[s_normal].color | ' ');
d1976 2
a1977 2
		    wbkgdset(LYwin, displayStyles[DSTYLE_NORMAL].color | ' ');
		LynxChangeStyle (a, STACK_OFF);
d1981 1
a1981 1
    LYrefresh();
d2018 1
a2018 1
    LYmove(LYlines-2,0);
d2020 4
a2023 3
    LYclrtoeol();
    LYaddstr(NOVICE_LINE_ONE);
    LYclrtoeol();
d2026 1
a2026 1
	LYaddstr(DIRED_NOVICELINE);
d2031 1
a2031 1
	LYaddstr(NOVICE_LINE_TWO);
d2033 1
a2033 1
	LYaddstr((char *)novice_lines(lineno));
d2035 1
a2035 1
    LYrefresh();
d2039 1
a2039 1
#if defined(NSL_FORK) || defined(MISC_EXP)
d2054 1
a2054 1
#if ((SLANG_VERSION >= 9919) && defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__))
d2074 1
a2074 1
#endif /* NSL_FORK || MISC_EXP */
d2082 1
a2082 1
	CTRACE((tfp, "\r *** Set simulated 'Z'"));
d2084 2
a2085 2
	    CTRACE((tfp, ", %d pending", fake_zap));
	CTRACE((tfp, " ***\n"));
d2088 3
a2090 3
	CTRACE((tfp, "\r *** Unset simulated 'Z'"));
	CTRACE((tfp, ", %d pending", fake_zap));
	CTRACE((tfp, " ***\n"));
a2104 7
    if (LYHaveCmdScript()) /* we may be running from a script */
	return(TRUE);

#ifdef MISC_EXP
    if (LYNoZapKey)
	return(TRUE);
#endif
a2109 1
#undef timezone			/* U/Win defines a conflicting macro */
a2127 1
    int cmd;
d2129 1
a2129 1
#if !defined(USE_SLANG) && (defined(UNIX) || defined(__DJGPP__))
d2137 1
a2137 1
	CTRACE((tfp, "\r *** Got simulated 'Z' ***\n"));
a2146 1
#if !defined(_WINDOWS) || defined(__MINGW32__)
d2175 1
a2175 1
    if ((ret == -1) && (SOCKET_ERRNO == EINTR))
a2181 1
#endif /* !_WINDOWS */
d2183 2
a2184 2
#if defined(PDCURSES)
    nodelay(LYwin,TRUE);
d2190 2
a2191 2
#if defined(PDCURSES)
    nodelay(LYwin,FALSE);
d2199 1
a2199 1
	CTRACE((tfp, "\r *** Got simulated 'Z' ***\n"));
d2227 1
a2227 1
    if (LYCharIsINTERRUPT(c))
d2231 2
a2232 3
	** no new getfile() cycle is possible until the previous finished.
	** Currently we have scrolling in partial mode and toggling of trace
	** log. User search now in progress...
d2234 1
a2234 2
    cmd = (LKC_TO_LAC(keymap,c));
    switch (cmd)
d2236 5
a2240 3
    case LYK_TRACE_TOGGLE :	/*  Toggle TRACE mode. */
	   handle_LYK_TRACE_TOGGLE();
	   break;
a2246 1
	    BOOLEAN do_refresh;
d2248 1
a2248 3
	    int Newline_partial = LYGetNewline();

	    switch (cmd)
a2249 10
	    case LYK_WHEREIS:	/* search within the document */
	    case LYK_NEXT:	/* search for the next occurrence in the document */
	    case LYK_PREV:	/* search for the previous occurrence in the document */
		handle_LYK_WHEREIS(cmd, &do_refresh);
		if (www_search_result != -1) {
		    Newline_partial = www_search_result;
		    www_search_result = -1;	/* reset */
		}
		break;

d2318 1
a2318 1
	    LYMainLoop_pageDisplay(Newline_partial);
a2327 39
 * Check if the given filename looks like it's an absolute pathname, i.e.,
 * references a directory.
 */
PUBLIC BOOLEAN LYisAbsPath ARGS1(
	CONST char *,	path)
{
#ifdef VMS
    return TRUE;
#else
    BOOLEAN result;
#if defined(DOSPATH) || defined(__EMX__)
    result = (BOOL) (LYIsPathSep(path[0])
     || (isalpha(UCH(path[0]))
      && (path[1] == ':')
       && LYIsPathSep(path[2])));
#else
    result = (LYIsPathSep(path[0]));
#endif /* DOSPATH */
    return result;
#endif
}

/*
 * Check if the given filename is the root path, e.g., "/" on Unix.
 */
PUBLIC BOOLEAN LYisRootPath ARGS1(
	char *,		path)
{
#if defined(DOSPATH) || defined(__EMX__)
    if (strlen(path) == 3
     && isalpha(UCH(path[0]))
     && path[1] == ':'
     && LYIsPathSep(path[2]))
	return TRUE;
#endif
    return (BOOL) ((strlen(path) == 1) && LYIsPathSep(path[0]));
}

/*
d2354 1
a2354 1
	     0==strcasecomp(host, HTHostName())
d2356 1
a2356 1
	     0==strcmp(host, HTHostName())
a2357 1
	    ))
d2435 1
a2435 1
    char *LocalAlias = NULL;
d2447 3
a2449 1
    StrAllocCopy(LocalAlias, alias);
d2543 2
a2544 2
	} else if (isdigit(UCH(*cp1))) {
	    while (*cp1 && isdigit(UCH(*cp1)))
a2656 5
#ifndef DISABLE_BIBP
    } else if (compare_type(cp, "bibp:", 5)) {
	return(BIBP_URL_TYPE);
#endif

d2749 1
a2749 1
	(void)is_url(&cp[11]);	/* forces lower/uppercase of next part */
a2825 65
 *  Sometimes it is just expected that curses is on when an alert or
 *  other statusline message needs to be shown and we are not just
 *  dumping immediately.  Calling this will 'fix' it, but may not
 *  always be appropriate. - kw
 */
PUBLIC void LYFixCursesOn ARGS1(
    CONST char *,	reason)
{
    if (dump_output_immediately || LYCursesON)
	return;
    if (reason) {
	CTRACE((tfp, "Forcing curses on to %s\n", reason));
    }
    start_curses();
}

/*
 *  Most protocol modules called through HTLoad* expect that curses is on
 *  unless dump_output_immediately is set, so that statusline messages
 *  can be shown.  Some protocols expect the opposite, namely telnet and
 *  friends.  This function should be called after the 'physical' URL
 *  for accessing addr has been established.  It does the right thing
 *  to the degree that curses is turned on for known problem cases.
 *  In any normal circumstances this should never apply, but proxying
 *  or rule substitution is not prevented for telnet-like URLs, and
 *  this 'fix' avoids some crashes that can otherwise occur. - kw
 */
PUBLIC BOOLEAN LYFixCursesOnForAccess ARGS2(
    CONST char *,	addr,
    CONST char *,	physical)
{
    /*
     *  If curses is off when maybe it shouldn't...
     */
    if (!dump_output_immediately && !LYCursesON && physical) {
	char *cp1;
	/*
	 *  If requested resource wants to be accessed with curses off, and
	 *  getfile() would indeed have turned curses off for it...
	 */
	if (strstr(addr, "://") != NULL &&
	    (!strncmp(addr, "telnet:", 7) ||
	     !strncmp(addr, "rlogin:", 7) ||
	     !strncmp(addr, "tn3270:", 7) ||
	     (strncmp(addr, "gopher:", 7) &&
	      (cp1 = strchr(addr+11,'/')) != NULL &&
	      (*(cp1+1) == 'T' || *(cp1+1) == '8')))) {
	    /*
	     *  If actual access that will be done is ok with curses off,
	     *  then do nothing special, else force curses on. - kw
	     */
	    if (strncmp(physical, "telnet:", 7) &&
		strncmp(physical, "rlogin:", 7) &&
		strncmp(physical, "tn3270:", 7)) {
		start_curses();
		HTAlert(
		    gettext("Unexpected access protocol for this URL scheme."));
		return TRUE;
	    }
	}
    }
	return FALSE;
}

/*
d2841 2
a2842 2
    if (!isurl) {
	FREE(temp0);
a2843 1
    }
a2844 1
	FREE(temp0);
a2850 5
    /*
     *  The idea of the following is to allow HEAD for news URLs that
     *  identify single articles, not those that identify ranges of
     *  articles or groups or a list of groups. - kw
     */
a2854 1
	    FREE(temp0);
d2858 1
a2858 2
	if (cp && isdigit(UCH(cp[1])) && strchr(cp, '-') == NULL) {
	    FREE(temp0);
a2863 88

#define ALLOW_PROXY_HEAD
/*  If defined, also allow head requests for URLs proxied through the
 *  "http" or "lynxcgi" protocols, which understand HEAD.  Only the
 *  proxy environment variables are checked, not the HTRules system. - kw
 */
#ifdef ALLOW_PROXY_HEAD
    if (isurl != FILE_URL_TYPE) {
	char *acc_method = HTParse(temp0, "", PARSE_ACCESS);
	if (acc_method && *acc_method) {
	    char *proxy;
	    StrAllocCat(acc_method, "_proxy");
	    proxy = getenv(acc_method);
	    if (proxy && (!strncmp(proxy, "http:", 5) ||
			  !strncmp(proxy, "lynxcgi:", 8)) &&
		!override_proxy(temp0)) {
		FREE(temp0);
		FREE(acc_method);
		return TRUE;
	    }
	}
	FREE(acc_method);
    }
#endif /* ALLOW_PROXY_HEAD */

    FREE(temp0);
    return FALSE;
}

/*
 * Close an input file.
 */
PUBLIC BOOLEAN LYCloseInput ARGS1(
	FILE *,		fp)
{
    if (fp != 0) {
	int err = ferror(fp);
	fclose(fp);
	if (!err) {
	    return TRUE;
	}
    }
    return FALSE;
}

/*
 * Close an output file, reporting any problems with writing to it.
 */
PUBLIC BOOLEAN LYCloseOutput ARGS1(
	FILE *,		fp)
{
    if (fp != 0) {
	int err = ferror(fp);
	fclose(fp);
	if (!err) {
	    return TRUE;
	}
    }
    HTAlert(CANNOT_WRITE_TO_FILE);
    return FALSE;
}

/*
 * Test if we'll be able to write a file.  If not, warn the user.
 */
PUBLIC BOOLEAN LYCanWriteFile ARGS1(
	CONST char*,	filename)
{
    if (LYCloseOutput(fopen(filename, "w"))) {
	remove(filename);
	return TRUE;
    } else {
	_statusline(NEW_FILENAME_PROMPT);
	return FALSE;
    }
}

/*
 * Test if we'll be able to read a file.
 */
PUBLIC BOOLEAN LYCanReadFile ARGS1(
	CONST char*,	filename)
{
    FILE *fp;

    if ((fp = fopen(filename, "r")) != 0) {
	return LYCloseInput(fp);
    }
d2890 4
d2901 3
a2903 1
#if HAVE_UTMP
d2909 1
a2909 1
    if ((cp = ttyname(0)))
d2912 12
a2923 12
    if (mytty && (fp = fopen(UTMP_FILE, "r")) != NULL) {
	mytty++;
	do {
	    n = fread((char *) &me, sizeof(struct utmp), 1, fp);
	} while (n > 0 && !STREQ(me.ut_line, mytty));
	(void) LYCloseInput(fp);

	if (n > 0 &&
	    strlen(me.ut_host) > strlen(LYLocalDomain) &&
	    STREQ(LYLocalDomain,
		  me.ut_host + strlen(me.ut_host) - strlen(LYLocalDomain)) )
	    return(TRUE);
d2926 2
a2927 2
	if ((n > 0) && (strlen(me.ut_host) == 0))
	    return(TRUE);
d2931 1
a2931 1
	CTRACE((tfp, "Could not get ttyname or open UTMP file %s\n", UTMP_FILE));
d2935 1
a2935 79
#else
    CTRACE((tfp, "LYUtils: inlocaldomain() not support.\n"));
    return(TRUE);
#endif /* HAVE_UTMP */
}

#if HAVE_SIGACTION
/*
 *  An extended alternative for calling signal(), sets some flags for
 *  signal handler as we want them if that functionality is available.
 *  (We don't return anything from this function since the return
 *  value would currently be ignored anyway.) - kw
 *
 */
PUBLIC void LYExtSignal ARGS2(
    int,			sig,
    LYSigHandlerFunc_t *,	handler)
{
#ifdef SIGWINCH
    /* add more cases to if(condition) if required... */
    if (sig == SIGWINCH && LYNonRestartingSIGWINCH) {
	struct sigaction act;
	act.sa_handler = handler;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
#ifdef SA_RESTART
	if (sig != SIGWINCH)
	    act.sa_flags |= SA_RESTART;
#endif /* SA_RESTART */
	sigaction(sig, &act, NULL);
    } else
#endif /* defined(SIGWINCH) */
	signal(sig, handler);
}
#endif /* HAVE_SIGACTION */

#if defined(SIGTSTP) && !defined(USE_SLANG)
#if HAVE_SIGACTION
/*
 *  For switching a signal's handling between SIG_DFL and something
 *  (possibly) different that may have been set up by lynx code or
 *  e.g. by curses library.  Uses sigaction to preserve / restore as
 *  much state as possible.
 *  Second arg is where to save or restore from.
 *  Third arg to_dfl specifies what to do:
 *	1	Save current state in where, set handling to SIG_DFL
 *	0	Restore current state to previously saved one in where
 *
 *  Currently only used for SIGTSTP without SLANG, to prevent (n)curses
 *  signal handler from running while lynx is waiting in system() for
 *  an interactive command like an editor. - kw
 */
PRIVATE BOOLEAN LYToggleSigDfl ARGS3(
    int,			sig,
    struct sigaction *,		where,
    int,			to_dfl)
{
    int rv = -1;
    struct sigaction oact;

    if (to_dfl == 1) {
	rv = sigaction(sig, NULL, &oact);
	if (rv == 0) {
	    if (oact.sa_handler != SIG_DFL) {
		oact.sa_handler = SIG_DFL;
		rv = sigaction(sig, &oact, where);
	    } else if (where) {
		memcpy(where, &oact, sizeof(oact));
		rv = 0;
	    }
	}
    } else {
	rv = sigaction(sig, where, NULL);
    }
    if (rv != 0) {
	CTRACE((tfp, "Error in LYToggleSigDfl: %s\n", LYStrerror(errno)));
	return FALSE;
    } else
	return TRUE;
a2936 2
#endif /* HAVE_SIGACTION */
#endif /* SIGTSTP && !USE_SLANG */
d2976 1
a2976 7
#ifdef SLANG_NO_LIMIT		/* define this if slang has been fixed */
    SLtt_Screen_Cols = (LYcols-1) * 6;
#else
    /* Needs to be limited: fixed buffer bugs in slang can cause crash,
       see slang's SLtt_smart_puts - kw */
    SLtt_Screen_Cols = HTMIN((LYcols-1) * 6, 255);
#endif
a3015 10
#ifdef __EMX__
    {
	int scrsize[2];

	_scrsize(scrsize);
	LYcols = scrsize[0];
	LYlines = scrsize[1];
    }
#endif

d3017 1
a3017 1
	LYlines = DFT_ROWS;
d3019 1
a3019 1
	LYcols = DFT_COLS;
d3027 2
a3028 7
	CTRACE((tfp, "Window size changed from (%d,%d) to (%d,%d)\n",
		old_lines, old_cols, LYlines, LYcols));
#if defined(CAN_SWITCH_DISPLAY_CHARSET) && defined(CAN_AUTODETECT_DISPLAY_CHARSET)
	/* May need to reload the font due to different char-box size */
	if (current_char_set != auto_display_charset)
	    Switch_Display_Charset(current_char_set, SWITCH_DISPLAY_CHARSET_SIZECHANGE);
#endif
d3031 1
a3031 1
    LYExtSignal (SIGWINCH, size_change);
d3063 1
a3063 1
    char *new = NULL;
d3070 3
a3072 1
    StrAllocCopy(new, fname);
d3103 1
a3103 1
    char *temp = 0, *cp, *cp1, *end;
d3122 3
a3125 7
#ifdef FNAMES_8_3
    if (LYIsHtmlSep(*cp)) {
	HTSprintf0(&temp, "file://localhost%s%04x", cp, GETPID());
    } else {
	HTSprintf0(&temp, "file://localhost/%s%04x", cp, GETPID());
    }
#else
d3127 1
a3127 1
	HTSprintf0(&temp, "file://localhost%s%d", cp, (int)getpid());
d3129 1
a3129 1
	HTSprintf0(&temp, "file://localhost/%s%d", cp, (int)getpid());
a3130 1
#endif
d3135 3
a3137 2
	StrAllocCopy(temp, (cp ? cp : ""));
	sprintf(fname, "temp%.*s", LY_MAXPATH - 10, temp);
a3162 13
#ifdef _WINDOWS	/* 1998/05/05 (Tue) 10:08:05 */
    if ((cp = strrchr(fname,'=')) != NULL && strlen(cp) > 1) {
	cp1 = fname;
	/*
	 *  Go past the '='.
	 */
	cp++;
	for (; *cp != '\0'; cp++, cp1++) {
	    *cp1 = *cp;
	}
	*cp1 = '\0';
    }
#endif
d3208 1
a3208 1
		   *cp <  ' ' || (UCH(*cp)) > 126) {
a3387 23
    int code;
#if defined(USE_MKSTEMP) && defined(HAVE_MKSTEMP)
    int fd;
    char interim[LY_MAXPATH];
    sprintf(interim, "%.*sXXXXXX", LY_MAXPATH - 8, prefix);
    if (strlen(interim) + strlen(suffix) < LY_MAXPATH - 2
    && (fd = mkstemp(interim)) >= 0) {
	sprintf(result, "%s%s", interim, suffix);
	rename(interim, result);
	chmod(result, HIDE_CHMOD); /* (yes, some mkstemps are broken ;-) */
	close(fd);
	code = TRUE;
    } else {
	code = FALSE;
    }
#else
#ifdef USE_RAND_TEMPNAME
#define SIZE_TEMPNAME ((MAX_TEMPNAME / BITS_PER_CHAR) + 1)
    static BOOL first = TRUE;
    static int names_used = 0;
    static unsigned char used_tempname[SIZE_TEMPNAME];
    unsigned offset, mask;
#endif
d3390 1
a3395 34
    /*
     * Prefer a random value rather than a counter.
     */
#ifdef USE_RAND_TEMPNAME
    if (first) {
	lynx_srand((unsigned)((long)time((time_t *)0) + (long)result));
	first = FALSE;
    }

    /* We don't really need all of the bits from rand().  The high-order bits
     * are the more-random portion in any case, but limiting the width of the
     * generated name is done partly to avoid problems on systems that may not
     * support long filenames.
     */
    counter = MAX_TEMPNAME;
    while (names_used < MAX_TEMPNAME) {
	counter = (unsigned)(( (float)MAX_TEMPNAME * lynx_rand() ) / LYNX_RAND_MAX + 1);
	counter %= SIZE_TEMPNAME;	/* just in case... */
	/*
	 * Avoid reusing a temporary name, since there are places in the code
	 * which can refer to a temporary filename even after it has been
	 * closed and removed from the filesystem.
	 */
	offset = counter / BITS_PER_CHAR;
	mask = 1 << (counter % BITS_PER_CHAR);
	if ((used_tempname[offset] & mask) == 0) {
	    names_used++;
	    used_tempname[offset] |= mask;
	    break;
	}
    }
    if (names_used >= MAX_TEMPNAME)
	HTAlert(gettext("Too many tempfiles"));
#else
a3396 2
#endif

a3403 3
#ifdef _WINDOWS
    sprintf(leaf, "%04x%04x", counter, (unsigned)GETPID());
#else
a3404 1
#endif
d3411 1
a3411 2
	if (8 - (tail - suffix) >= 0)
	    leaf[8 - (tail - suffix)] = 0;
d3427 1
a3427 2
#endif
    CTRACE((tfp, "-> '%s'\n", result));
d3474 40
a3513 33
/* The first two are special: we want to record whether "default" or
 * "all" restrictions were applied, in addition to the detailed effects
 * of those options. - kw
 */
/* skip the special flags when processing "all" and "default": */
#define N_SPECIAL_RESTRICT_OPTIONS 2

PRIVATE CONST struct {
    CONST char *name;
    BOOLEAN *flag;
    BOOLEAN can;
} restrictions[] = {
    { "default",	&had_restrictions_default, TRUE },
    { "all",		&had_restrictions_all,	TRUE },
    { "inside_telnet",	&no_inside_telnet,	CAN_ANONYMOUS_INSIDE_DOMAIN_TELNET },
    { "outside_telnet",	&no_outside_telnet,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_TELNET },
    { "telnet_port",	&no_telnet_port,	CAN_ANONYMOUS_GOTO_TELNET_PORT },
    { "inside_ftp",	&no_inside_ftp,		CAN_ANONYMOUS_INSIDE_DOMAIN_FTP },
    { "outside_ftp",	&no_outside_ftp,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_FTP },
    { "inside_rlogin",	&no_inside_rlogin,	CAN_ANONYMOUS_INSIDE_DOMAIN_RLOGIN },
    { "outside_rlogin",	&no_outside_rlogin,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_RLOGIN },
    { "suspend",	&no_suspend,		FALSE },
    { "editor",		&no_editor,		FALSE },
    { "shell",		&no_shell,		FALSE },
    { "bookmark",	&no_bookmark,		FALSE },
    { "multibook",	&no_multibook,		FALSE },
    { "bookmark_exec",	&no_bookmark_exec,	FALSE },
    { "option_save",	&no_option_save,	FALSE },
    { "print",		&no_print,		CAN_ANONYMOUS_PRINT },
    { "download",	&no_download,		FALSE },
    { "disk_save",	&no_disk_save,		FALSE },
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
    { "exec",		&no_exec,		LOCAL_EXECUTION_LINKS_ALWAYS_OFF_FOR_ANONYMOUS },
d3515 30
a3544 5
    { "lynxcgi",	&no_lynxcgi,		FALSE },
    { "exec_frozen",	&exec_frozen,		FALSE },
    { "goto",		&no_goto,		CAN_ANONYMOUS_GOTO },
    { "jump",		&no_jump,		CAN_ANONYMOUS_JUMP },
    { "file_url",	&no_file_url,		FALSE },
d3546 7
a3552 10
    { "news_post",	&no_newspost,		FALSE },
    { "inside_news",	&no_inside_news,	CAN_ANONYMOUS_INSIDE_DOMAIN_READ_NEWS },
    { "outside_news",	&no_outside_news,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_READ_NEWS },
#endif
    { "mail",		&no_mail,		CAN_ANONYMOUS_MAIL },
    { "dotfiles",	&no_dotfiles,		FALSE },
    { "useragent",	&no_useragent,		FALSE },
#ifdef SUPPORT_CHDIR
    { "chdir",		&no_chdir,		FALSE },
#endif
d3554 1
a3554 1
    { "dired_support",	&no_dired_support,	FALSE },
d3556 1
a3556 1
    { "change_exec_perms", &no_change_exec_perms, FALSE },
d3560 1
a3560 7
    { "externals",	&no_externals,		FALSE },
#endif
    { "lynxcfg_info",	&no_lynxcfg_info,	CAN_ANONYMOUS_VIEW_LYNXCFG_INFO },
#ifndef NO_CONFIG_INFO
    { "lynxcfg_xinfo",	&no_lynxcfg_xinfo,	CAN_ANONYMOUS_VIEW_LYNXCFG_EXTENDED_INFO },
#ifdef HAVE_CONFIG_H
    { "compileopts_info", &no_compileopts_info,	CAN_ANONYMOUS_VIEW_COMPILEOPTS_INFO },
d3562 27
d3590 7
a3596 11
    /* put "goto" restrictions on the end, since they are a refinement */
#ifndef DISABLE_BIBP
    { "goto_bibp",	&no_goto_bibp,		CAN_ANONYMOUS_GOTO_BIBP	},
#endif
#ifdef HAVE_CONFIG_H
#ifndef NO_CONFIG_INFO
    { "goto_configinfo", &no_goto_configinfo,	CAN_ANONYMOUS_GOTO_CONFIGINFO },
#endif
#endif
    { "goto_cso",	&no_goto_cso,		CAN_ANONYMOUS_GOTO_CSO },
    { "goto_file",	&no_goto_file,		CAN_ANONYMOUS_GOTO_FILE },
d3598 1
a3598 1
    { "goto_finger",	&no_goto_finger,	CAN_ANONYMOUS_GOTO_FINGER },
d3600 1
a3600 1
    { "goto_ftp",	&no_goto_ftp,		CAN_ANONYMOUS_GOTO_FTP },
d3602 1
a3602 1
    { "goto_gopher",	&no_goto_gopher,	CAN_ANONYMOUS_GOTO_GOPHER },
d3604 6
a3609 6
    { "goto_http",	&no_goto_http,		CAN_ANONYMOUS_GOTO_HTTP },
    { "goto_https",	&no_goto_https,		CAN_ANONYMOUS_GOTO_HTTPS },
    { "goto_lynxcgi",	&no_goto_lynxcgi,	CAN_ANONYMOUS_GOTO_LYNXCGI },
    { "goto_lynxexec",	&no_goto_lynxexec,	CAN_ANONYMOUS_GOTO_LYNXEXEC },
    { "goto_lynxprog",	&no_goto_lynxprog,	CAN_ANONYMOUS_GOTO_LYNXPROG },
    { "goto_mailto",	&no_goto_mailto,	CAN_ANONYMOUS_GOTO_MAILTO },
d3611 2
a3612 2
    { "goto_news",	&no_goto_news,		CAN_ANONYMOUS_GOTO_NEWS },
    { "goto_nntp",	&no_goto_nntp,		CAN_ANONYMOUS_GOTO_NNTP },
d3614 1
a3614 1
    { "goto_rlogin",	&no_goto_rlogin,	CAN_ANONYMOUS_GOTO_RLOGIN },
d3616 1
a3616 1
    { "goto_snews",	&no_goto_snews,		CAN_ANONYMOUS_GOTO_SNEWS },
d3618 32
a3649 161
    { "goto_telnet",	&no_goto_telnet,	CAN_ANONYMOUS_GOTO_TELNET },
    { "goto_tn3270",	&no_goto_tn3270,	CAN_ANONYMOUS_GOTO_TN3270 },
    { "goto_wais",	&no_goto_wais,		CAN_ANONYMOUS_GOTO_WAIS },
};

/*  This will make no difference between '-' and '_'. It does only in/equality
    compare. It assumes that p2 can't contain dashes, but p1 can.
    This function is also used (if macro OPTNAME_ALLOW_DASHES doesn't have
    value of zero) for compare of commandline options -VH
 */
PUBLIC BOOL strn_dash_equ ARGS3(
	CONST char*,	p1,
	CONST char*,	p2,
	int,		len)
{
    while (len--) {
	if (!*p2)
	    return 0;/* canonical name is shorter */
	switch (*p1) {
	    case 0:
		return 0;
	    case '-':
	    case '_':
		if (*p2!='_')
		    return 0;
		else
		    break;
	    default:
		if (*p1!=*p2)
		    return 0;
	}
	++p1; ++p2;
    }
    return 1;
}

/* Uncomment following lines to allow only exact string matching */
/* #define RESTRICT_NM_ALLOW_DASHES 0 */

#ifndef RESTRICT_NM_ALLOW_DASHES
# define RESTRICT_NM_ALLOW_DASHES 1
#endif

#if RESTRICT_NM_ALLOW_DASHES
#	define RESTRICT_NM_EQU(a,b,len) strn_dash_equ(a,b,len)
#else
#	define RESTRICT_NM_EQU(a,b,len) STRNEQ(a,b,len)
#endif

/*
 * Returns the inx'th name from the restrictions table, or null if inx is
 * out of range.
 */
PUBLIC CONST char *index_to_restriction ARGS1(
    int,	inx)
{
    if (inx >= 0 && inx < (int) TABLESIZE(restrictions))
	return restrictions[inx].name;
    return NULL;
}

/*
 * Returns the value TRUE/FALSE of a given restriction, or -1 if it is not
 * one that we recognize.
 */
PUBLIC int find_restriction ARGS2(
    CONST char *,	name,
    int,		len)
{
    unsigned i;
    if (len < 0)
	len = strlen(name);
    for (i=0; i < TABLESIZE(restrictions); i++) {
	if (RESTRICT_NM_EQU(name, restrictions[i].name, len)) {
	    return (*restrictions[i].flag);
	}
    }
    return -1;
}

PUBLIC void parse_restrictions ARGS1(
    CONST char *,	s)
{
    CONST char *p;
    CONST char *word;
    unsigned i;
    BOOLEAN found;

    p = s;
    while (*p) {
	p = LYSkipCBlanks(p);
	if (*p == '\0')
	    break;
	word = p;
	while (*p != ',' && *p != '\0')
	    p++;

	found = FALSE;
	if (RESTRICT_NM_EQU(word, "all", p-word)) {
	    found = TRUE;
	    for (i = N_SPECIAL_RESTRICT_OPTIONS; i < TABLESIZE(restrictions); i++)
		*(restrictions[i].flag) = TRUE;
	} else if (RESTRICT_NM_EQU(word, "default", p-word)) {
	    found = TRUE;
	    for (i = N_SPECIAL_RESTRICT_OPTIONS; i < TABLESIZE(restrictions); i++)
		*(restrictions[i].flag) = !restrictions[i].can;
	} else {
	    for (i=0; i < TABLESIZE(restrictions); i++) {
		if (RESTRICT_NM_EQU(word, restrictions[i].name, p-word)) {
		    *(restrictions[i].flag) = TRUE;
		    found = TRUE;
		    break;
		}
	    }
	}
	if (!found) {
	    printf("%s: %.*s", gettext("unknown restriction"), p-word, word);
	    exit(EXIT_FAILURE);
	}
	if (*p)
	    p++;
    }

    /*
     * If shell is restricted, set restrictions on related topics.
     */
    if (no_shell) {
	no_goto_lynxexec = TRUE;
	no_goto_lynxprog = TRUE;
	no_goto_lynxcgi = TRUE;
#ifdef EXEC_LINKS
	local_exec_on_local_files = TRUE;
#endif
    }
}

PUBLIC void print_restrictions_to_fd ARGS1(
    FILE *,	fp)
{
    unsigned i, count = 0;

    for (i=0; i < TABLESIZE(restrictions); i++) {
	if (*(restrictions[i].flag) == TRUE) {
	    count++;
	}
    }
    if (!count) {
	fprintf(fp, gettext("No restrictions set.\n"));
	return;
    }
    fprintf(fp, gettext("Restrictions set:\n"));
    for (i=0; i < TABLESIZE(restrictions); i++) {
	if (*(restrictions[i].flag) == TRUE) {
	    /* if "goto" is restricted, don't bother tell about its
	     * refinements
	     */
	    if (strncmp(restrictions[i].name, "goto_", 5)
	     || !no_goto)
		fprintf(fp, "   %s\n", restrictions[i].name);
	}
    }
d3814 2
a3815 2
	CTRACE((tfp, "%s%s'%s' is not a URL\n",
		    (name ? name : ""), (name ? " " : ""), *href));
d3838 1
d3856 1
a3856 1
    StrAllocCopy(*AllocatedString, "file://localhost");
d3878 1
a3878 1
	    StrAllocCat(*AllocatedString, HTVMS_wwwName(Home_Dir()));
d3894 1
a3894 1
	    LYstrncpy(url_file, old_string, sizeof(url_file)-1);
d3943 1
a3943 1
		     !isdigit(UCH(cp[1]))) ||
d3952 4
a3955 3
		    sprintf(url_file, "/%.*s", sizeof(url_file)-2, old_string);
		    CTRACE((tfp, "Can't find '%s'  Will assume it's a bad path.\n",
				old_string));
d3982 1
a3982 1
		 !isdigit(UCH(cp[1]))) ||
d3991 4
a3994 3
		sprintf(url_file, "/%.*s", sizeof(url_file)-2, old_string);
		CTRACE((tfp, "Can't find '%s'  Will assume it's a bad path.\n",
			    old_string));
d4012 3
a4014 22
	CTRACE((tfp, "Trying: '%s'\n", *AllocatedString));
#else /* not VMS: */
#if defined(DOSPATH)
#ifdef _WINDOWS
	if (*old_string == '.') {
	    char fullpath[MAX_PATH + 1];
	    char *filepart = NULL;
	    DWORD chk;

	    chk = GetFullPathNameA(old_string, MAX_PATH + 1,
			fullpath, &filepart);
	    if (chk != 0) {
		StrAllocCopy(temp, wwwName(fullpath));
		StrAllocCat(*AllocatedString, temp);
		FREE(temp);
		CTRACE((tfp, "Converted '%s' to '%s'\n",
				old_string, *AllocatedString));
	    } else {
		StrAllocCat(*AllocatedString, old_string);
	    }
	}
#else
d4023 3
a4025 5
	    CTRACE((tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString));
	}
#endif
	else
d4031 1
a4031 1
	    StrAllocCat(*AllocatedString, wwwName(Home_Dir()));
d4043 2
a4044 2
	    CTRACE((tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString));
d4057 1
a4057 1
#if defined (DOSPATH) || defined (__EMX__) || defined (WIN_EX)
a4064 3
		/* 1998/01/13 (Tue) 12:24:33 */
		if (old_string[1] == '|')
		    old_string[1] = ':';
a4065 3

		if (strlen(temp) == 2 && temp[1] == ':')
		    StrAllocCat(temp, "/");
d4073 1
a4073 1
	    CTRACE((tfp, "Converted '%s' to '%s'\n", old_string, temp));
d4075 1
a4075 1
		LYCanReadFile(temp)) {
d4084 3
a4086 2
		if (strchr(temp, '#') == NULL && strchr(temp, '%') == NULL)
		    StrAllocCopy(cp, temp);
d4088 1
a4088 2
		    cp = HTEscape(temp, URL_PATH);
#else
a4089 1
#endif /* DOSPATH */
d4092 2
a4093 2
		CTRACE((tfp, "Converted '%s' to '%s'\n",
			    old_string, *AllocatedString));
a4105 3
#ifdef WIN_EX	/* 1998/07/31 (Fri) 09:09:03 */
		HTUnEscape(temp2);	/* for LFN */
#endif
d4109 1
a4109 1
		     LYCanReadFile(temp2))) {
d4133 2
a4134 2
		    CTRACE((tfp, "Converted '%s' to '%s'\n",
				old_string, *AllocatedString));
d4172 2
a4173 20
		CTRACE((tfp, "Can't stat() or fopen() '%s'\n",
			    temp2 ? temp2 : temp));
#ifdef WIN_EX  /* 1998/01/13 (Tue) 09:07:37 */
		{
		    char *p, *q, buff[LY_MAXPATH + 128];

		    p = (char *)Home_Dir();
		    q = temp2 ? temp2 : temp;

		    if (strlen(q) == 3 && isalpha(UCH(q[0])) && q[1] == ':') {
			sprintf(buff,
			    "'%s' not exist, Goto LynxHome '%s'.", q, p);
			_statusline(buff);
			LYSleepAlert();
			FREE(temp);
			StrAllocCat(*AllocatedString, p);
			goto Retry;
		    }
		}
#endif
d4176 1
a4176 2
				       URLDomainSuffixes))
		{
a4185 3
		} else {
		    /* Return file URL for the file that does not exist */
		    StrAllocCat(*AllocatedString, temp);
d4187 1
a4187 4
#ifdef WIN_EX
	Retry:
#endif
		CTRACE((tfp, "Trying: '%s'\n", *AllocatedString));
d4191 4
d4208 1
a4208 1
	    StrAllocCat(*AllocatedString, HTVMS_wwwName(Home_Dir()));
d4212 1
a4212 1
		   LYCanReadFile(old_string)) {
d4219 1
a4219 1
	    CTRACE((tfp, "Converted '%s' to '%s'\n", old_string, temp));
d4224 6
a4229 2
	    CTRACE((tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString));
d4236 5
a4240 1
	    StrAllocCat(*AllocatedString, wwwName(Home_Dir()));
d4262 2
a4263 2
	CTRACE((tfp, "Converted '%s' to '%s'\n",
		    old_string, *AllocatedString));
a4269 33
#if defined(_WINDOWS) /* 1998/06/23 (Tue) 16:45:20 */

PUBLIC int win32_check_interrupt(void)
{
    int c;

    if (kbhit()) {
	c = wgetch(LYwin);
	/** Keyboard 'Z' or 'z', or Control-G or Control-C **/
	if (LYCharIsINTERRUPT(c) || c == 0x1b) {
	    return TRUE;
	}
    }
    return FALSE;
}

void sleep(unsigned sec)
{
    unsigned int i, j;
    int c;

    for (j = 0; j < sec; j++) {
	for (i = 0; i < 10; i++) {
	    Sleep(100);
	    if (kbhit()) {
		c = wgetch(LYwin);
		return;
	    }
	}
    }
}
#endif

d4300 1
a4300 10
    BOOLEAN Startup = (BOOL) (helpfilepath == NULL);
#ifdef INET6
    struct addrinfo hints, *res;
    int error;
#endif /* INET6 */

#ifdef _WINDOWS
    int hoststat;
    struct hostent  *phost;	/* Pointer to host - See netdb.h */
#endif
d4350 1
a4350 1
	isdigit(UCH(StrColon[1]))) {
d4370 1
a4370 1
	fprintf(stdout, "%s '%s'%s\r\n", WWW_FIND_MESSAGE, host, FIRST_SEGMENT);
d4372 2
a4373 8

#ifdef INET6
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    error = getaddrinfo(host, "80", &hints, &res);

    if (!error && res)
d4375 2
a4376 2
    if (LYGetHostByName(host) != NULL)
#endif /* INET6 */
d4382 2
a4383 3
	    CTRACE((tfp,
	    "LYExpandHostForURL: Ignoring interrupt because '%s' resolved.\n",
			host));
d4394 5
a4398 9
    }
    else if (LYCursesON &&
#if defined(__DJGPP__) && !defined(WATT32)
	HTCheckForInterrupt()
#else /* normal systems */
	(lynx_nsl_status == HT_INTERRUPTED)
#endif
	)
    {
d4402 2
a4403 3
	CTRACE((tfp,
	"LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
		    host));
d4480 1
a4480 1
		isdigit(UCH(HostColon[1]))) {
d4493 5
a4497 1
	    GotHost = (BOOL) (LYGetHostByName(host) != NULL);
d4505 3
a4507 1
#if defined(__DJGPP__) && !defined(WATT32)
d4509 1
a4509 3
#else /* normal systems */
		if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED))
#endif
d4511 2
a4512 3
		    CTRACE((tfp,
	"LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
				host));
d4577 1
a4577 1
	CTRACE((tfp, "LYExpandHostForURL: Ignoring interrupt because '%s' %s.\n",
d4579 1
a4579 1
		    (GotHost ? "resolved" : "timed out")));
d4722 1
a4722 1
    TerminalSlash = (BOOL) (LYIsPathSep(path[(strlen(path) - 1)]));
d4863 5
a4867 2
	if ((cp = getenv_text("HOME")) == NULL
	 || !LYisAbsPath(cp)) {
d4869 8
a4876 3
	    if ((cp = getenv_text("TEMP")) == NULL
	     && (cp = getenv_text("TMP")) == NULL) {
		cp = "C:\\";
a4877 1
	    StrAllocCopy(HomeDir, cp);
d4880 8
a4887 3
	    if ((cp = getenv_text("SYS$LOGIN")) == NULL
	     && (cp = getenv_text("SYS$SCRATCH")) == NULL) {
		cp = "sys$scratch:";
a4888 1
	    StrAllocCopy(HomeDir, cp);
a4912 8
#if defined(_WINDOWS) || defined(DOSPATH)
	    char *hp = getenv_text("HOMEDRIVE");
	    if (hp != 0
	     && (LYIsPathSep(*cp) || !LYisAbsPath(cp))) {
		StrAllocCopy(HomeDir, hp);
		StrAllocCat(HomeDir, cp);
	    } else
#endif
a5169 6

#ifdef VMS
#define NO_HOMEPATH "Error:"
#else
#define NO_HOMEPATH "/error"
#endif /* VMS */
d5174 5
a5178 2
	StrAllocCopy(home, NO_HOMEPATH);

d5205 5
a5209 2
	    char *temp = NULL;
	    HTSprintf0(&temp, "%s%s", HTVMS_wwwName(home), (file + 1));
d5267 1
a5267 1
    CTRACE((tfp, "LYmktime: Parsing '%s'\n", s));
d5273 1
a5273 1
    while (*s != '\0' && !isdigit(UCH(*s)))
d5282 2
a5283 2
    while (*s != '\0' && isdigit(UCH(*s)))
	s++;
d5294 1
a5294 1
    while (*s != '\0' && !isalnum(UCH(*s)))
d5299 1
a5299 1
    while (*s != '\0' && isalnum(UCH(*s)))
d5302 2
a5303 2
	(s - start) < (isdigit(UCH(*(s - 1))) ? 2 : 3) ||
	(s - start) > (isdigit(UCH(*(s - 1))) ? 2 : 9))
d5305 1
a5305 1
    LYstrncpy(temp, start, (isdigit(UCH(*(s - 1))) ? 2 : 3));
d5385 1
a5385 1
    while (*s != '\0' && !isdigit(UCH(*s)))
d5390 1
a5390 1
    while (*s != '\0' && isdigit(UCH(*s)))
d5419 1
a5419 1
    while (*s != '\0' && !isdigit(UCH(*s)))
d5427 1
a5427 1
	while (*s != '\0' && isdigit(UCH(*s)))
d5437 1
a5437 1
	while (*s != '\0' && !isdigit(UCH(*s)))
d5442 1
a5442 1
	while (*s != '\0' && isdigit(UCH(*s)))
d5452 1
a5452 1
	while (*s != '\0' && !isdigit(UCH(*s)))
d5457 1
a5457 1
	while (*s != '\0' && isdigit(UCH(*s)))
d5481 1
a5481 1
    if (absolute == FALSE && (long)(time((time_t *)0) - clock2) >= 0)
d5484 1
a5484 1
	CTRACE((tfp, "LYmktime: clock=%ld, ctime=%s",
d5486 1
a5486 1
		    ctime(&clock2)));
d5491 1
a5491 1
#if !defined(HAVE_PUTENV) && !defined(_WINDOWS)
d5588 1
a5588 1
#if defined(UNIX)
d5603 1
a5603 5
	/*
	 * ( If this is not a single-user system, the other user is presumed by
	 * some people busy trying to use a symlink attack on our files ;-)
	 */
#if defined(HAVE_LSTAT) && !(defined(DOSPATH) || defined(__EMX__))
d5633 1
a5633 1
		     || (data.st_mode & S_IWOTH) != 0) {
a5655 1
    BOOLEAN binary = strchr(mode, 'b') != 0;
a5671 4
#if defined(O_BINARY) && defined(__CYGWIN__)
	    if (binary)
		setmode(fd, O_BINARY);
#endif
d5682 1
a5682 1
	    fp = OpenHiddenFile(name, binary ? BIN_W : TXT_W);
d5700 1
a5700 1
#else	/* !UNIX */
d5709 1
a5709 1
    FILE *fp = fopen (name, BIN_W, "mbc=32");
d5712 1
a5712 1
    FILE *fp = OpenHiddenFile(name, BIN_W);
d5722 1
a5722 1
    fp = fopen (name, TXT_W, "shr=get");
d5727 1
a5727 1
    fp = OpenHiddenFile(name, TXT_W);
d5740 1
a5740 1
    fp = fopen (name, TXT_A, "shr=get");
d5745 1
a5745 1
    fp = OpenHiddenFile(name, TXT_A);
d5785 2
d5788 1
a5788 1
	LYstrncpy(result, *cached, LY_MAXPATH);
d5790 2
a5791 1
	if (LYCanReadFile(result)) {
d5800 12
d5824 1
a5824 1
    char wrt = 'r';
d5827 1
a5827 1
    CTRACE((tfp, "LYOpenTemp(,%s,%s)\n", suffix, mode));
d5837 2
a5838 42
		CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
		return 0;
	}
    }

    /*
     * Verify if the given space looks secure enough.  Otherwise, make a
     * secure subdirectory of that.
     */
#if 0
#if defined(UNIX) && defined(HAVE_MKTEMP)
    if (lynx_temp_subspace == 0)
    {
	BOOL make_it = FALSE;
	struct stat sb;

	if (lstat(lynx_temp_space, &sb) == 0
	 && S_ISDIR(sb.st_mode)) {
	    if (sb.st_uid != getuid()
	     || (sb.st_mode & (S_IWOTH | S_IWGRP)) != 0) {
		make_it = TRUE;
		CTRACE((tfp, "lynx_temp_space is not our directory %s owner %d mode %03o\n",
			     lynx_temp_space, (int) sb.st_uid, (int) sb.st_mode & 0777));
	    }
	} else {
	    make_it = TRUE;
	    CTRACE((tfp, "lynx_temp_space is not a directory %s\n", lynx_temp_space));
	}
	if (make_it) {
	    int old_mask = umask(HIDE_UMASK);
	    StrAllocCat(lynx_temp_space, "XXXXXX");
	    if (mktemp(lynx_temp_space) == 0
	     || mkdir(lynx_temp_space, 0700) < 0) {
		printf("%s: %s\n", lynx_temp_space, LYStrerror(errno));
		exit(EXIT_FAILURE);
	    }
	    umask(old_mask);
	    lynx_temp_subspace = 1;
	    StrAllocCat(lynx_temp_space, "/");
	    CTRACE((tfp, "made subdirectory %s\n", lynx_temp_space));
	} else {
	    lynx_temp_subspace = -1;
a5840 2
#endif
#endif
d5864 2
a5865 2
	    CTRACE((tfp, "... LYOpenTemp(%s) failed: %s\n",
		   result, LYStrerror(errno)));
d5871 1
a5871 1
    if ((p = typecalloc(LY_TEMP)) != 0) {
a5874 1
	p->outs = (wrt != 'r');
d5880 1
a5880 1
    CTRACE((tfp, "... LYOpenTemp(%s)\n", result));
d5894 3
a5896 151
    if ((p = FindTempfileByName(name)) != 0) {
	fp = p->file = LYAppendToTxtFile (name);
    }
    return fp;
}

/*
 * Open a temp-file for writing, possibly re-using a previously used
 * name and file.
 * If a non-empty fname is given, it is reused if it indicates a file
 * previously registered as a temp file and, in case the file still
 * exists, if it looks like we can write to it safely.  Otherwise a
 * new temp file (with new name) will be generated and returned in fname.
 *
 * File permissions are set so that the file is not readable by unprivileged
 * other users.
 *
 * Suffix is only used if fname is not being reused.
 * The mode should be "w", others are possible (they may be passed on)
 * but probably don't make sense. - kw
 */
PUBLIC FILE *LYOpenTempRewrite ARGS3(
	char *,		fname,
	CONST char *,	suffix,
	CONST char *,	mode)
{
    FILE *fp = 0;
    BOOL txt = TRUE;
    char wrt = 'r';
    BOOL registered = NO;
    BOOL writable_exists = NO;
    BOOL is_ours = NO;
    BOOL still_open = NO;
    LY_TEMP *p;
    struct stat stat_buf;

    CTRACE((tfp, "LYOpenTempRewrite(%s,%s,%s)\n", fname, suffix, mode));
    if (*fname == '\0')		/* first time, no filename yet */
	return (LYOpenTemp(fname, suffix, mode));

    if ((p = FindTempfileByName(fname)) != 0) {
	registered = YES;
	if (p->file != 0)
	    still_open = YES;
	CTRACE((tfp, "...used before%s\n", still_open ? ", still open!" : "."));
    }

    if (registered) {
#ifndef NO_GROUPS
	writable_exists = HTEditable(fname); /* existing, can write */
#define CTRACE_EXISTS "exists and is writable, "
#else
	writable_exists = (BOOL) (stat(fname, &stat_buf) == 0); /* existing, assume can write */
#define CTRACE_EXISTS "exists, "
#endif

	if (writable_exists) {
#ifdef UNIX
	    is_ours = IsOurFile(fname);
#else
	    is_ours = TRUE;	/* assume ok, if we get to here */
#endif
	}
	CTRACE((tfp, "...%s%s\n",
	       writable_exists ? CTRACE_EXISTS : "",
	       is_ours ? "is our file." : "is NOT our file."));
    }

    /*
     *  Note that in cases where LYOpenTemp is called as fallback below,
     *  we don't call LYRemoveTemp first.  That may be appropriate in some
     *  cases, but not trying to remove a weird existing file seems safer
     *  and could help diagnose an unusual situation.  (They may be removed
     *  anyway later.)
     */
    if (still_open) {
	/*
	 * This should probably not happen.  Make a new one.
	 */
	return (LYOpenTemp(fname, suffix, mode));
    } else if (!registered) {
	/*
	 *  Not registered.  It should have been registered at one point
	 *  though, otherwise we wouldn't be called like this.
	 */
	return (LYOpenTemp(fname, suffix, mode));
    } else if (writable_exists && !is_ours) {
	/*
	 *  File exists, writable if we checked, but something is wrong
	 *  with it.
	 */
	return (LYOpenTemp(fname, suffix, mode));
#ifndef NO_GROUPS
    } else if (!is_ours && (lstat(fname, &stat_buf) == 0)) {
	/*
	 *  Exists but not writable, and something is wrong with it.
	 */
	return (LYOpenTemp(fname, suffix, mode));
#endif
    }

    while (*mode != '\0') {
	switch (*mode++) {
	case 'w':	wrt = 'w';	break;
	case 'a':	wrt = 'a';	break;
	case 'b':	txt = FALSE;	break;
	default:
		CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
		return fp;
	}
    }

    if (is_ours) {
	/*
	 *  Yes, it exists, is writable if we checked, and everything
	 *  looks ok so far.  This should be the most regular case. - kw
	 */
#if HAVE_TRUNCATE
	if (txt == TRUE) {	/* limitation of LYReopenTemp.  shrug */
	    /*
	     *  We truncate and then append, this avoids having a small
	     *  window in which the file doesn't exist. - kw
	     */
	    if (truncate(fname, 0) != 0) {
		CTRACE((tfp, "... truncate(%s,0) failed: %s\n",
			fname, LYStrerror(errno)));
		return (LYOpenTemp(fname, suffix, mode));
	    } else {
		return (LYReopenTemp(fname));
	    }
	}
#endif
	remove(fname);

    }

	/*  We come here in two cases: either the file existed and was
	 *  ours and we just got rid of it.
	 *  Or the file did and does not exist, but is registered as a
	 *  temp file.  It must have been removed by some means other than
	 *  LYRemoveTemp.
	 *  In both cases, reuse the name! - kw
	 */

    if (txt) {
	switch (wrt) {
	case 'w':
	    fp = LYNewTxtFile (fname);
	    break;
	case 'a':
	    fp = LYAppendToTxtFile (fname);
a5898 2
    } else {
	fp = LYNewBinFile (fname);
a5899 10
    p->file = fp;

    CTRACE((tfp, "... LYOpenTempRewrite(%s), %s\n", fname,
	   (fp) ? "ok" : "failed"));
    /*
     *  We could fall back to trying LYOpenTemp() here in case of failure.
     *  After all the checks already done above a filure here should be
     *  pretty unusual though, so maybe it's better to let the user notice
     *  that something went wrong, and not try to fix it up. - kw
     */
d5918 1
a5918 1
	if ((p = typecalloc(LY_TEMP)) != 0) {
d5927 1
a5927 1
    CTRACE((tfp, "LYOpenScratch(%s)\n", result));
a5930 13
PRIVATE void LY_close_temp ARGS1(
	LY_TEMP *,	p)
{
    if (p->file != 0) {
	if (p->outs) {
	    LYCloseOutput(p->file);
	} else {
	    LYCloseInput(p->file);
	}
	p->file = 0;
    }
}

d5939 11
a5949 5
    CTRACE((tfp, "LYCloseTemp(%s)\n", name));
    if ((p = FindTempfileByName(name)) != 0) {
	CTRACE((tfp, "...LYCloseTemp(%s)%s\n", name,
	    (p->file != 0) ? ", closed" : ""));
	LY_close_temp(p);
d5961 8
a5968 4
    CTRACE((tfp, "LYCloseTempFP\n"));
    if ((p = FindTempfileByFP(fp)) != 0) {
	LY_close_temp(p);
	CTRACE((tfp, "...LYCloseTempFP(%s)\n", p->name));
d5975 1
a5975 1
PUBLIC int LYRemoveTemp ARGS1(
d5979 1
a5979 1
    int code = -1;
d5982 1
a5982 1
	CTRACE((tfp, "LYRemoveTemp(%s)\n", name));
d5990 2
a5991 1
		LY_close_temp(p);
d5993 2
a5994 2
		CTRACE((tfp, "...LYRemoveTemp done(%d)%s\n", code,
		       (p->file != 0) ? ", closed" : ""));
a6001 1
    return code;
a6012 10
#ifdef UNIX
    if (lynx_temp_subspace > 0) {
	char result[LY_MAXPATH];
	LYstrncpy(result, lynx_temp_space, sizeof(result)-1);
	LYTrimPathSep(result);
	CTRACE((tfp, "LYCleanupTemp removing %s\n", result));
	rmdir(result);
	lynx_temp_subspace = -1;
    }
#endif
d6024 5
a6028 174
    CTRACE((tfp, "LYRenamedTemp(old=%s, new=%s)\n", oldname, newname));
    if ((p = FindTempfileByName(oldname)) != 0) {
	StrAllocCopy((p->name), newname);
    }
}

#ifndef DISABLE_BIBP
/*
 *  Check that bibhost defines the BibP icon.
 */
PUBLIC void LYCheckBibHost NOARGS
{
    DocAddress bibhostIcon;
    BOOLEAN saveFlag;

    bibhostIcon.address = NULL;
    StrAllocCopy(bibhostIcon.address, BibP_bibhost);
    StrAllocCat(bibhostIcon.address, "bibp1.0/bibpicon.jpg");
    bibhostIcon.post_data = NULL;
    bibhostIcon.post_content_type = NULL;
    bibhostIcon.bookmark = FALSE;
    bibhostIcon.isHEAD = FALSE;
    bibhostIcon.safe = FALSE;
    saveFlag = traversal;
    traversal = TRUE;  /* Hack to force error response. */
    BibP_bibhost_available = HTLoadAbsolute(&bibhostIcon) == YES;
    traversal = saveFlag;
    BibP_bibhost_checked = TRUE;
}
#endif /* !DISABLE_BIBP */

/*
 *  Management of User Interface Pages. - kw
 *
 *  These are mostly temp files.  Pages which can be recognized by their
 *  special URL (after having been loaded) need not be tracked here.
 *
 *  First some private stuff:
 */
typedef struct uipage_entry {
    UIP_t	type;
    unsigned	flags;
    char *	url;
    HTList *	alturls;
    char *	file;
} uip_entry;

#define UIP_F_MULTI	0x0001	/* flag: track multiple instances */
#define UIP_F_LIMIT	0x0002	/* flag: limit size of alturl list */
#define UIP_F_LMULTI   (UIP_F_MULTI | UIP_F_LIMIT)

static uip_entry ly_uip[] =
{
    { UIP_HISTORY		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_DOWNLOAD_OPTIONS	, 0	      , NULL, NULL, NULL }
  , { UIP_PRINT_OPTIONS		, 0	      , NULL, NULL, NULL }
  , { UIP_SHOWINFO		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_LIST_PAGE		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_VLINKS		, UIP_F_LMULTI, NULL, NULL, NULL }
#if !defined(NO_OPTION_FORMS)
  , { UIP_OPTIONS_MENU		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
#ifdef DIRED_SUPPORT
  , { UIP_DIRED_MENU		, 0	      , NULL, NULL, NULL }
  , { UIP_PERMIT_OPTIONS	, 0	      , NULL, NULL, NULL }
  , { UIP_UPLOAD_OPTIONS	, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
#ifdef EXP_ADDRLIST_PAGE
  , { UIP_ADDRLIST_PAGE		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
  , { UIP_LYNXCFG		, UIP_F_LMULTI, NULL, NULL, NULL }
#if !defined(NO_CONFIG_INFO)
  , { UIP_CONFIG_DEF		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
/* The following are not generated tempfiles: */
  , { UIP_TRACELOG		, 0	     , NULL, NULL, NULL }
#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
  , { UIP_INSTALL		, 0	     , NULL, NULL, NULL }
#endif

};

/*  Public entry points for User Interface Page management: */

PUBLIC BOOL LYIsUIPage3 ARGS3(
    CONST char *,	url,
    UIP_t,		type,
    int,		flagparam)
{
    unsigned int i;
    size_t l;
    if (!url)
	return NO;
    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	if (ly_uip[i].type == type) {
	    if (!ly_uip[i].url) {
		return NO;
	    } else if ((flagparam & UIP_P_FRAG) ?
		       (!strncmp(ly_uip[i].url, url, (l=strlen(ly_uip[i].url)))
			&& (url[l] == '\0' || url[l] == '#')) :
		       !strcmp(ly_uip[i].url, url)) {
		return YES;
	    } else if (ly_uip[i].flags & UIP_F_MULTI) {
		char *p;
		HTList *l0 = ly_uip[i].alturls;

		while ((p = HTList_nextObject(l0)) != NULL) {
		    if ((flagparam & UIP_P_FRAG) ?
		       (!strncmp(p, url, (l=strlen(p)))
			&& (url[l] == '\0' || url[l] == '#')) :
			!strcmp(p, url))
			return YES;
		}
	    }
	    return NO;
	}
    }
    return NO;
}

PUBLIC void LYRegisterUIPage ARGS2(
    CONST char *,	url,
    UIP_t,		type)
{
    unsigned int i;
    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	if (ly_uip[i].type == type) {
	    if (ly_uip[i].url && url &&
		!strcmp(ly_uip[i].url, url)) {

	    } else if (!ly_uip[i].url || !url ||
		       !(ly_uip[i].flags & UIP_F_MULTI)) {
		StrAllocCopy(ly_uip[i].url, url);

	    } else {
		char *p;
		int n = 0;
		HTList *l0 = ly_uip[i].alturls;

		while ((p = HTList_nextObject(l0)) != NULL) {
		    if (!strcmp(p, url))
			return;
		    if (!strcmp(p, ly_uip[i].url)) {
			StrAllocCopy(ly_uip[i].url, url);
			return;
		    }
		    n++;
		}
		if (!ly_uip[i].alturls)
		    ly_uip[i].alturls = HTList_new();

		if (n >= HTCacheSize && (ly_uip[i].flags & UIP_F_LIMIT))
		    HTList_removeFirstObject(ly_uip[i].alturls);
		HTList_addObject(ly_uip[i].alturls, ly_uip[i].url);
		ly_uip[i].url = NULL;
		StrAllocCopy(ly_uip[i].url, url);
	    }

	    return;
	}
    }
}

PUBLIC void LYUIPages_free NOARGS
{
    unsigned int i;
    char *p;
    HTList *l0;
    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	FREE(ly_uip[i].url);
	FREE(ly_uip[i].file);
	l0 = ly_uip[i].alturls;
	while ((p = HTList_nextObject(l0)) != NULL) {
	    FREE(p);
a6029 2
	HTList_delete(ly_uip[i].alturls);
	ly_uip[i].alturls = NULL;
d6043 1
a6043 1
    cp = HTDOS_wwwName(pathname);
d6046 1
a6046 1
    cp = HTVMS_wwwName(pathname);
a6058 2
 *
 * Both strings are fixed buffer sizes, LY_MAXPATH.
d6064 1
a6064 1
    char *cp, *cp2;
d6086 1
a6086 1
	LYstrncpy(result, given, LY_MAXPATH);
d6090 1
a6090 3
    if ((cp = strchr(given, '~')) != 0
     && (cp2 = wwwName(Home_Dir())) != 0
     && strlen(cp2) + strlen(given) < LY_MAXPATH) {
d6094 1
a6094 1
	strcat(result, cp2);
d6103 1
a6103 3
    if (given[0] != '/'
     && strchr(given, ':') == NULL
     && strlen(given) < LY_MAXPATH - 13) {
d6114 1
a6114 1
    if (!LYisAbsPath(given)) {
d6120 1
a6120 8
	{
#ifdef SUPPORT_CHDIR
	    static char buf[LY_MAXPATH];
	    cp = Current_Dir(buf);
#else
	    cp = original_dir;
#endif
	}
a6125 1
    *result = 0;
d6128 3
a6130 3
	if (strlen(cp) >= LY_MAXPATH - 2)
	    return FALSE;
	sprintf(result, "%s/", cp);
a6131 4
    cp = HTSYS_name(given);
    if (strlen(result) + strlen(cp) >= LY_MAXPATH - 1)
	return FALSE;
    strcat(result, cp);
d6148 1
d6169 2
a6170 1
    if (LYCanReadFile(filename)) {
a6198 5
    if (!LYisAbsPath(source)) {
	char temp[LY_MAXPATH];
	Current_Dir(temp);
	StrAllocCat(*target, temp);
    }
d6204 21
d6250 1
a6250 1
     && LYwouldPush(Title, NULL)
d6289 1
a6289 1
 * Add a trailing path-separator to avoid confusing other programs when we concateate
d6311 1
a6311 1
	char *,		path)
a6316 1
     && (len < LY_MAXPATH - 2)
a6322 16
 * Check if a given string contains a path separator
 */
PUBLIC char * LYLastPathSep ARGS1(
	CONST char *,	path)
{
    char *result;
#ifdef DOSPATH
    if ((result = strrchr(path, '\\')) == 0)
	result = strrchr(path, '/');
#else
    result = strrchr(path, '/');
#endif
    return result;
}

/*
a6365 1
     && (len < LY_MAXPATH - 2)
a6378 25

#if defined(DOSPATH) || defined(__CYGWIN__) /* thanks to Hiroyuki Senshu */

#define BUF_SIZE	1024

    FILE *fin, *fout;
    unsigned char buff[BUF_SIZE];
    int len;

    code = EOF;
    if ((fin = fopen(src, BIN_R)) != 0) {
	if ((fout = fopen(dst, BIN_W)) != 0) {
	    code = 0;
	    while ((len = fread(buff, 1, BUF_SIZE, fin)) > 0) {
		fwrite(buff, 1, len, fout);
		if (ferror(fout)) {
		    code = EOF;
		    break;
		}
	    }
	    LYCloseOutput(fout);
	}
	LYCloseInput(fin);
    }
#else
d6386 1
a6386 1
    CTRACE((tfp, "command: %s\n", the_command));
a6391 1
#endif
a6392 3
    if (code) {
	HTAlert(CANNOT_WRITE_TO_FILE);
    }
d6397 1
a6397 1
 * Invoke a shell command, return nonzero on error.
a6403 8
#if HAVE_SIGACTION && defined(SIGTSTP) && !defined(USE_SLANG)
    struct sigaction saved_sigtstp_act;
    BOOLEAN sigtstp_saved = FALSE;
#endif
    int saved_errno = 0;
#ifdef __EMX__
    int scrsize[4];
#endif
d6407 1
a6407 1
    CTRACE((tfp, "LYSystem(%s)\n", command));
a6422 2

	_scrsize(scrsize);
a6440 60

#if defined(__CYGWIN__) && defined(DOSPATH)	/* 1999/02/26 (Fri) */
    {
	char cmd[LY_MAXPATH];
	char win32_name[LY_MAXPATH];
	char new_cmd[LY_MAXPATH];
	char new_command[LY_MAXPATH * 2 + 10];
	char *p, *q;

	p = command;
	q = cmd;
	while (*p) {
	    if (*p == ' ')
		break;
	    else
		*q = *p;
	    p++;
	    q++;
	}
	*q = '\0';

	if (cmd[0] == '/')
	    cygwin_conv_to_full_posix_path(cmd, new_cmd);
	else
	    strcpy(new_cmd, cmd);

	while (*p == ' ')
	    p++;

	if (strchr(p, '\\') == NULL) {
	    /* for Windows Application */
	    cygwin_conv_to_full_win32_path(p, win32_name);
	    sprintf(new_command, "%.*s \"%.*s\"", LY_MAXPATH, new_cmd, LY_MAXPATH, win32_name);
	} else {
	    /* for DOS like editor */
	    q = win32_name;
	    while (*p) {
		if (*p == '\\') {
		    if (*(p+1) == '\\')
			p++;
		}
		*q = *p;
		q++, p++;
	    }
	    *q = '\0';
	    sprintf(new_command, "%.*s %.*s", LY_MAXPATH, new_cmd, LY_MAXPATH, win32_name);
	}
	command = new_command;
    }
#endif

#if _WIN_CC
    code = exec_command(command, TRUE);	/* Wait exec */
#else
    if (restore_sigpipe_for_children)
	signal(SIGPIPE, SIG_DFL); /* Some commands expect the default */
#if HAVE_SIGACTION && defined(SIGTSTP) && !defined(USE_SLANG)
    if (!dump_output_immediately && !LYCursesON && !no_suspend)
	sigtstp_saved = LYToggleSigDfl(SIGTSTP, &saved_sigtstp_act, 1);
#endif
a6441 8
    saved_errno = errno;
#if HAVE_SIGACTION && defined(SIGTSTP) && !defined(USE_SLANG)
    if (sigtstp_saved)
	LYToggleSigDfl(SIGTSTP, &saved_sigtstp_act, 0);
#endif
    if (restore_sigpipe_for_children)
	signal(SIGPIPE, SIG_IGN); /* Ignore it again - kw */
#endif
a6453 6
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ?? */
    set_errno(saved_errno);	/* may have been clobbered */
#endif
#ifdef __EMX__			/* Check whether the screen size changed */
    size_change(0);
#endif
a6459 42
#if defined(__CYGWIN__)	/* 1999/02/26 (Fri) */
PUBLIC int Cygwin_Shell NOARGS
{
    char *shell;
    int code;
    STARTUPINFO startUpInfo;
    PROCESS_INFORMATION procInfo;
    SECURITY_ATTRIBUTES sa;

    /* Set up security attributes to allow inheritance of the file handle */

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = 0;
    sa.bInheritHandle=TRUE;

    /* Init a startup structure */
    GetStartupInfo(&startUpInfo);

    shell = getenv_text("COMSPEC");

    /* Create the child process, specifying
     inherited handles. Pass the value of the
     handle as a command line parameter */
    code = 0;
    if (shell) {
	code = CreateProcess(0, shell, 0, 0,
			TRUE, 0,
			0, 0, &startUpInfo, &procInfo);

	if (!code) {
	    printf("shell = [%s], code = %d\n", shell, GetLastError());
	}

	/* wait for the child to return (this is not a requirement
	   since the child is its own independent process) */
	WaitForSingleObject(procInfo.hProcess, INFINITE);
    }

    return code;
}
#endif

d6464 4
a6467 19
#ifdef WIN_EX
    shell = getenv_text("SHELL");
    if (shell) {
	if (access(shell, 0) != 0)
	    shell = getenv_text("COMSPEC");
    }
    if (shell == NULL) {
	if (system_is_NT)
	    shell = "cmd.exe";
	else
	    shell = "command.com";
    }
#else
    shell = getenv_text("SHELL");
    if (shell == NULL) {
	shell = getenv_text("COMSPEC");
    }
    if (shell == NULL) {
	shell = "command.com";
a6468 1
#endif /* WIN_EX */
d6471 2
a6472 2
    if (getenv_text("SHELL") != NULL) {
	shell = getenv_text("SHELL");
d6474 1
a6474 1
	shell = (getenv_text("COMSPEC") == NULL) ? "cmd.exe" : getenv_text("COMSPEC");
d6499 1
a6499 1
    if ((cp = getenv_text(DISPLAY)) == NULL)
d6511 1
a6511 1
    if (new_display != 0) {
d6517 3
d6521 1
a6521 1
	HTSprintf0(&display_putenv_command, "DISPLAY=%s", new_display);
a6528 387

#ifdef __EMX__

static int proc_type = -1;
static PPIB pib;
HAB hab;
HMQ hmq;

PRIVATE void morph_PM NOARGS
{
    PTIB tib;
    int first = 0;

    if (proc_type == -1) {
	DosGetInfoBlocks(&tib, &pib);
	proc_type = pib->pib_ultype;
	first = 1;
    }
    if (pib->pib_ultype != 3)		/* 2 is VIO */
	pib->pib_ultype = 3;		/* 3 is PM */
    if (first)
	hab = WinInitialize(0);
    /* 64 messages if before OS/2 3.0, ignored otherwise */
    hmq = WinCreateMsgQueue(hab, 64);
    WinCancelShutdown(hmq, 1);	/* Do not inform us on shutdown */
}

PRIVATE void unmorph_PM NOARGS
{
    WinDestroyMsgQueue(hmq);
    pib->pib_ultype = proc_type;
}

PUBLIC int size_clip NOARGS
{
    return 8192;
}

/* Code partialy stolen from FED editor. */

PUBLIC int put_clip ARGS1(char *, s)
{
    int sz = strlen(s) + 1;
    int ret = EOF, nl = 0;
    char *pByte = 0, *s1 = s, c, *t;

    while ((c = *s1++)) {
	if (c == '\r' && *s1 == '\n')
	    s1++;
	else if (c == '\n')
	    nl++;
    }
    if (DosAllocSharedMem((PPVOID)&pByte, 0, sz + nl,
			  PAG_WRITE | PAG_COMMIT | OBJ_GIVEABLE | OBJ_GETTABLE))
	return ret;

    if (!nl)
	memcpy(pByte, s, sz);
    else {
	t = pByte;
	while ((c = *t++ = *s++))
	    if (c == '\n' && (t == pByte + 1 || t[-2] != '\r'))
		t[-1] = '\r', *t++ = '\n';
    }

    morph_PM();
    if(!hab)
	goto fail;

    WinOpenClipbrd(hab);
    WinEmptyClipbrd(hab);
    if (WinSetClipbrdData(hab, (ULONG) pByte, CF_TEXT, CFI_POINTER))
	ret = 0;
    WinCloseClipbrd(hab);
    unmorph_PM();
    if (ret == 0)
	return 0;
  fail:
    DosFreeMem((PPVOID)&pByte);
    return EOF;
}

static int clip_open;

/* get_clip_grab() returns a pointer to the string in the system area.
   get_clip_release() should be called ASAP after this. */

PUBLIC char* get_clip_grab NOARGS
{
    char *ClipData;
    ULONG ulFormat;
    int sz;

    morph_PM();
    if(!hab)
	return 0;
    if (clip_open)
	get_clip_release();

    WinQueryClipbrdFmtInfo(hab, CF_TEXT, &ulFormat);
    if(ulFormat != CFI_POINTER) {
	unmorph_PM();
	return 0;
    }
    WinOpenClipbrd(hab);
    clip_open = 1;
    ClipData = (char *)WinQueryClipbrdData(hab, CF_TEXT);
    sz = strlen(ClipData);
    if(!ClipData || !sz) {
	get_clip_release();
	return 0;
    }
    return ClipData;
}

PUBLIC void get_clip_release NOARGS
{
    if (!clip_open)
	return;
    WinCloseClipbrd(hab);
    clip_open = 0;
    unmorph_PM();
}

#endif

#if defined(WIN_EX)	/* 1997/10/16 (Thu) 20:13:28 */

#define	MAX_DOS_PATH	128	/* exactly 80 */

PUBLIC int put_clip(char *szBuffer)
{
    HANDLE hWnd;
    HANDLE m_hLogData;
    LPTSTR pLogData;
    HANDLE hClip;
    int len;

    if (szBuffer == NULL)
	return EOF;

    len = strlen(szBuffer);
    if (len == 0)
	return EOF;
    else
	len ++;

    m_hLogData = GlobalAlloc(GHND, len);
    if (m_hLogData == NULL) {
	return EOF;
    }

    hWnd = NULL;
    if (!OpenClipboard(hWnd)) {
	return EOF;
    }
    /* Remove the current Clipboard contents */
    if (!EmptyClipboard()) {
	GlobalFree(m_hLogData);
	return EOF;
    }

    /* Lock the global memory while we write to it. */
    pLogData = (LPTSTR) GlobalLock(m_hLogData);

    lstrcpy((LPTSTR) pLogData, szBuffer);
    GlobalUnlock(m_hLogData);

    /* If there were any lines at all then copy them to clipboard. */
    hClip = SetClipboardData(CF_TEXT, m_hLogData);
    if (!hClip) {
	/* If we couldn't clip the data then free the global handle. */
	GlobalFree(m_hLogData);
    }

    CloseClipboard();
    return 0;
}

static HANDLE m_hLogData;
static int m_locked;

/* get_clip_grab() returns a pointer to the string in the system area.
   get_clip_release() should be called ASAP after this. */

PUBLIC char* get_clip_grab()
{
    HANDLE hWnd;
    LPTSTR pLogData;

    hWnd = NULL;
    if (!OpenClipboard(hWnd)) {
	return 0;
    }

    m_hLogData = GetClipboardData(CF_TEXT);

    if (m_hLogData == NULL) {
	CloseClipboard();
	m_locked = 0;
	return 0;
    }
    pLogData = (LPTSTR) GlobalLock(m_hLogData);

    m_locked = 1;
    return pLogData;
}

PUBLIC void get_clip_release()
{
    if (!m_locked)
	return;
    GlobalUnlock(m_hLogData);
    CloseClipboard();
    m_locked = 0;
}


PUBLIC char *HTDOS_short_name(char *path)
{
    static char sbuf[MAX_DOS_PATH];
    char *ret;
    DWORD r;

    r = GetShortPathName(path, sbuf, sizeof sbuf);
    if (r >= sizeof sbuf) {
#if 0	/* DEBUG */
	fprintf(stderr, "bug: recompile with MAX_DOS_PATH > %d\n", r);
#endif
	ret = path;
    }
    if (r == 0) {
	ret = path;
    } else {
	ret = sbuf;
    }
    return ret;
}
#endif

#if defined(WIN_EX)

#ifndef WSABASEERR
#define WSABASEERR 10000
#endif

/*
 * Description: the windows32 version of perror()
 *
 * Returns:  a pointer to a static error
 *
 * Notes/Dependencies:  I got this from
 *      comp.os.ms-windows.programmer.win32
 */
PUBLIC char * w32_strerror(DWORD ercode)
{
/*  __declspec(thread) necessary if you will use multiple threads */
#ifdef __CYGWIN__
    static char msg_buff[256];
#else
    __declspec(thread) static char msg_buff[256];
#endif
    HMODULE hModule;
    int i, msg_type;
    unsigned char *p, *q, tmp_buff[256];

    hModule = NULL;
    msg_type = FORMAT_MESSAGE_FROM_SYSTEM;
    /* Fill message buffer with a default message in
     * case FormatMessage fails
     */
    wsprintf(msg_buff, "Error %ld", ercode);

    /*
     *  Special code for winsock error handling.
     */
    if (ercode > WSABASEERR) {
	hModule = GetModuleHandle("wsock32");
	if (hModule == NULL)
	    ercode = GetLastError();
	else
	    msg_type = FORMAT_MESSAGE_FROM_HMODULE;
    }
    /*
     *  message handling
     */
    FormatMessage(msg_type,
		  hModule,
		  ercode,
		  LANG_NEUTRAL,
		  msg_buff,
		  sizeof(msg_buff),
		  NULL);

    strcpy(tmp_buff, msg_buff);
    p = q = tmp_buff;
    i = 0;
    while (*p) {
	if (!(*p == '\n' || *p == '\r'))
	    msg_buff[i++] = *p;
	p++;
    }
    msg_buff[i] = '\0';

    return msg_buff;
}

#endif

#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
/*
 * syslog() interface
 */
PUBLIC void LYOpenlog ARGS1(
	CONST char *, banner)
{
#if defined(WATT32)
    openlog("lynx", LOG_PID|LOG_NDELAY, LOG_LOCAL5);
#else
    openlog("lynx", LOG_PID, LOG_LOCAL5);
#endif

    if (banner) {
	syslog(LOG_INFO, "Session start:%s", banner);
    } else {
	syslog(LOG_INFO, "Session start");
    }
}

PRIVATE BOOLEAN looks_like_password ARGS2(
	char *,		first,
	char *,		last)
{
    BOOLEAN result = FALSE;

    while (first <= last) {
	if (*first == '/'
	 || *first == ':') {
	    result = FALSE;
	    break;
	}
	result = TRUE;
	first++;
    }
    return result;
}

PUBLIC void LYSyslog ARGS1(
	char *,		arg)
{
    char *colon1;
    char *colon2;
    char *atsign;

    CTRACE((tfp, "LYSyslog %s\n", arg));

    if (is_url(arg)) {	/* proto://user:password@@host/path:port */
			/*	^this colon		    */
	if ((colon1 = strchr(arg, ':')) != 0
	 && !strncmp(colon1, "://", 3)
	 && (colon2 = strchr(colon1+3, ':')) != 0
	 && (atsign = strchr(colon1, '@@')) != 0
	 && (colon2 < atsign)
	 && looks_like_password(colon2 + 1, atsign - 1)) {
	    char *buf = NULL;

	    StrAllocCopy(buf, arg);
	    buf[colon2 - arg + 1] = 0;
	    StrAllocCat(buf, "******");
	    StrAllocCat(buf, atsign);
	    syslog (LOG_INFO|LOG_LOCAL5, buf);
	    CTRACE((tfp, "...alter %s\n", buf));
	    FREE(buf);
	    return;
	}
    }
    syslog (LOG_INFO|LOG_LOCAL5, "%s", NONNULL(arg));
}

PUBLIC void LYCloselog NOARGS
{
  syslog(LOG_INFO, "Session over");
  closelog();
}

#endif /* !VMS && SYSLOG_REQUESTED_URLS */

@

