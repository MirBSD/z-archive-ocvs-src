head	1.10;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.9
	tg-mergefixes-1-branch:1.9.0.4
	tg-mergefixes-1-base:1.9
	MIROS_X:1.9.0.2
	MIROS_X_BASE:1.9
	MIRBSD_XP_MIRPPC:1.7.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.7
	MIRBSD_XP_SPARC:1.7.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.4
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.4.0.6
	MIRBSD_7:1.4.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.4
	MIRBSD_7_DEV:1.4.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2005.01.03.00.46.04;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.20.10.26.31;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.11.20.30.42;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.15.18.17.03;	author tg;	state Stab;
branches;
next	1.6;

1.6
date	2004.04.30.16.32.36;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.18.17.40.13;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.07.20.49.01;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.38;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.34;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.20;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.20;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.27;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.28;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.16;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.55;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.52.02;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.10.11.20.16.26;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.20.10.10.45;	author tg;	state Exp;
branches;
next	;


desc
@@


1.10
log
@soft merge
@
text
@#include <HTUtils.h>
#include <HTFile.h>
#include <HTParse.h>
#include <HTAlert.h>
#include <HTTP.h>
#include <LYCurses.h>
#include <LYUtils.h>
#include <LYStructs.h>
#include <LYGlobalDefs.h>
#include <LYShowInfo.h>
#include <LYCharUtils.h>
#include <GridText.h>
#include <LYReadCFG.h>
#include <LYCharSets.h>
#include <LYStrings.h>

#include <LYLeaks.h>

#ifdef DIRED_SUPPORT
#include <HTAAProt.h>
#include <time.h>
#include <LYLocal.h>
#endif /* DIRED_SUPPORT */

#define ADVANCED_INFO 1		/* to get more info in advanced mode */

#define BEGIN_DL(text) fprintf(fp0, "<h2>%s</h2>\n<dl compact>", text)
#define END_DL()       fprintf(fp0, "\n</dl>\n")

#define ADD_SS(label,value)       dt_String(fp0, label, value)
#define ADD_NN(label,value,units) dt_Number(fp0, label, value, units)

static int label_columns;

/*
 * LYNX_VERSION and LYNX_DATE are automatically generated by PRCS, the tool
 * which we use to archive versions of Lynx.  We use a convention for naming
 * the successive versions:
 *	{release}{status}{patch}
 * where
 *	{release} is the release that we are working on, e.g., 2.8.4
 *	{status} is one of "dev", "pre" or "rel", and
 *	{patch} is a number assigned by PRCS.
 */
BOOL LYVersionIsRelease(void)
{
    return (BOOL) (strstr(LYNX_VERSION, "rel") != 0);
}

const char *LYVersionStatus(void)
{
    if (LYVersionIsRelease())
	return REL_VERSION;
    else if (strstr(LYNX_VERSION, "pre") != 0)
	return PRE_VERSION;
    return DEV_VERSION;
}

const char *LYVersionDate(void)
{
    static char temp[LYNX_DATE_LEN + 1];

    LYstrncpy(temp, &LYNX_DATE[LYNX_DATE_OFF], LYNX_DATE_LEN);
    return temp;
}

static void dt_String(FILE *fp,
		      const char *label,
		      const char *value)
{
    int have;
    int need;
    char *the_label = 0;
    char *the_value = 0;

    StrAllocCopy(the_label, label);
    StrAllocCopy(the_value, value);

    have = strlen(the_label);
    need = LYstrExtent(the_label, have, label_columns);

    LYEntify(&the_label, TRUE);
    LYEntify(&the_value, TRUE);

    fprintf(fp, "<dt>");
    while (need++ < label_columns)
	fprintf(fp, "&nbsp;");
    fprintf(fp, "<em>%s</em> %s\n", the_label, the_value);

    FREE(the_label);
    FREE(the_value);
}

static void dt_Number(FILE *fp0,
		      const char *label,
		      long number,
		      const char *units)
{
    char *value = NULL;

    HTSprintf(&value, "%ld %s", number, units);
    ADD_SS(label, value);
    FREE(value);
}

/*
 * LYShowInfo prints a page of info about the current file and the link that
 * the cursor is on.
 */
int LYShowInfo(DocInfo *doc,
	       DocInfo *newdoc,
	       char *owner_address)
{
    static char tempfile[LY_MAXPATH] = "\0";
    int url_type;
    FILE *fp0;
    char *Title = NULL;
    const char *name;
    const char *cp;
    char *temp = 0;

#ifdef ADVANCED_INFO
    BOOLEAN LYInfoAdvanced = (BOOL) (user_mode == ADVANCED_MODE);
#endif
#ifdef DIRED_SUPPORT
    struct stat dir_info;
#endif /* DIRED_SUPPORT */

    if (LYReuseTempfiles) {
	fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
    } else {
	LYRemoveTemp(tempfile);
	fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
    }
    if (fp0 == NULL) {
	HTAlert(CANNOT_OPEN_TEMP);
	return (-1);
    }

    /*
     * Point the address pointer at this Url
     */
    LYLocalFileToURL(&newdoc->address, tempfile);

    if (nlinks > 0 && links[doc->link].lname != NULL &&
	(url_type = is_url(links[doc->link].lname)) != 0 &&
	(url_type == LYNXEXEC_URL_TYPE ||
	 url_type == LYNXPROG_URL_TYPE)) {
	char *last_slash = strrchr(links[doc->link].lname, '/');
	int next_to_last = strlen(links[doc->link].lname) - 1;

	if ((last_slash - links[doc->link].lname) == next_to_last) {
	    links[doc->link].lname[next_to_last] = '\0';
	}
    }

    label_columns = 9;

    WriteInternalTitle(fp0, SHOWINFO_TITLE);

    fprintf(fp0, "<h1>%s %s (%s) (<a href=\"%s\">%s</a>)",
	    LYNX_NAME, LYNX_VERSION,
	    LYVersionDate(),
	    (LYVersionIsRelease()? LYNX_WWW_HOME : LYNX_WWW_DIST),
	    LYVersionStatus());

    fprintf(fp0, "</h1>\n");	/* don't forget to close <h1> */

#ifdef DIRED_SUPPORT
    if (lynx_edit_mode && nlinks > 0) {

	BEGIN_DL(gettext("Directory that you are currently viewing"));

	temp = HTfullURL_toFile(doc->address);
	ADD_SS(gettext("Name:"), temp);
	FREE(temp);

	ADD_SS(gettext("URL:"), doc->address);

	END_DL();

	temp = HTfullURL_toFile(links[doc->link].lname);

	if (lstat(temp, &dir_info) == -1) {
	    CTRACE((tfp, "lstat(%s) failed, errno=%d\n", temp, errno));
	    HTAlert(CURRENT_LINK_STATUS_FAILED);
	} else {
	    char modes[80];

	    label_columns = 16;
	    if (S_ISDIR(dir_info.st_mode)) {
		BEGIN_DL(gettext("Directory that you have currently selected"));
	    } else if (S_ISREG(dir_info.st_mode)) {
		BEGIN_DL(gettext("File that you have currently selected"));
#ifdef S_IFLNK
	    } else if (S_ISLNK(dir_info.st_mode)) {
		BEGIN_DL(gettext("Symbolic link that you have currently selected"));
#endif
	    } else {
		BEGIN_DL(gettext("Item that you have currently selected"));
	    }
	    ADD_SS(gettext("Full name:"), temp);
#ifdef S_IFLNK
	    if (S_ISLNK(dir_info.st_mode)) {
		char buf[1025];
		int buf_size;

		if ((buf_size = readlink(temp, buf, sizeof(buf) - 1)) != -1) {
		    buf[buf_size] = '\0';
		} else {
		    snprintf(buf, 1025, "%.1024s", gettext("Unable to follow link"));
		}
		ADD_SS(gettext("Points to file:"), buf);
	    }
#endif
	    name = HTAA_UidToName(dir_info.st_uid);
	    if (*name)
		ADD_SS(gettext("Name of owner:"), name);
	    name = HTAA_GidToName(dir_info.st_gid);
	    if (*name)
		ADD_SS(gettext("Group name:"), name);
	    if (S_ISREG(dir_info.st_mode)) {
		ADD_NN(gettext("File size:"),
		       (long) dir_info.st_size,
		       gettext("(bytes)"));
	    }
	    /*
	     * Include date and time information.
	     */
	    ADD_SS(gettext("Creation date:"),
		   ctime(&dir_info.st_ctime));

	    ADD_SS(gettext("Last modified:"),
		   ctime(&dir_info.st_mtime));

	    ADD_SS(gettext("Last accessed:"),
		   ctime(&dir_info.st_atime));

	    END_DL();

	    label_columns = 9;
	    BEGIN_DL(gettext("Access Permissions"));
	    modes[0] = '\0';
	    modes[1] = '\0';	/* In case there are no permissions */
	    modes[2] = '\0';
	    if ((dir_info.st_mode & S_IRUSR))
		strlcat(modes, ", read", 80);
	    if ((dir_info.st_mode & S_IWUSR))
		strlcat(modes, ", write", 80);
	    if ((dir_info.st_mode & S_IXUSR)) {
		if (S_ISDIR(dir_info.st_mode))
		    strlcat(modes, ", search", 80);
		else {
		    strlcat(modes, ", execute", 80);
		    if ((dir_info.st_mode & S_ISUID))
			strlcat(modes, ", setuid", 80);
		}
	    }
	    ADD_SS(gettext("Owner:"), &modes[2]);

	    modes[0] = '\0';
	    modes[1] = '\0';	/* In case there are no permissions */
	    modes[2] = '\0';
	    if ((dir_info.st_mode & S_IRGRP))
		strlcat(modes, ", read", 80);
	    if ((dir_info.st_mode & S_IWGRP))
		strlcat(modes, ", write", 80);
	    if ((dir_info.st_mode & S_IXGRP)) {
		if (S_ISDIR(dir_info.st_mode))
		    strlcat(modes, ", search", 80);
		else {
		    strlcat(modes, ", execute", 80);
		    if ((dir_info.st_mode & S_ISGID))
			strlcat(modes, ", setgid", 80);
		}
	    }
	    ADD_SS(gettext("Group:"), &modes[2]);

	    modes[0] = '\0';
	    modes[1] = '\0';	/* In case there are no permissions */
	    modes[2] = '\0';
	    if ((dir_info.st_mode & S_IROTH))
		strlcat(modes, ", read", 80);
	    if ((dir_info.st_mode & S_IWOTH))
		strlcat(modes, ", write", 80);
	    if ((dir_info.st_mode & S_IXOTH)) {
		if (S_ISDIR(dir_info.st_mode))
		    strlcat(modes, ", search", 80);
		else {
		    strlcat(modes, ", execute", 80);
#ifdef S_ISVTX
		    if ((dir_info.st_mode & S_ISVTX))
			strlcat(modes, ", sticky", 80);
#endif
		}
	    }
	    ADD_SS(gettext("World:"), &modes[2]);
	    END_DL();
	}
	FREE(temp);
    } else {
#endif /* DIRED_SUPPORT */

	BEGIN_DL(gettext("File that you are currently viewing"));

	LYformTitle(&Title, doc->title);
	HTSprintf(&temp, "%s%s",
		  Title,
		  ((doc->isHEAD &&
		    !strstr(Title, " (HEAD)") &&
		    !strstr(Title, " - HEAD")) ? " (HEAD)" : ""));
	ADD_SS(gettext("Linkname:"), temp);
	FREE(temp);

	ADD_SS("URL:", doc->address);

	if (HTLoadedDocumentCharset()) {
	    ADD_SS(gettext("Charset:"),
		   HTLoadedDocumentCharset());
	} else {
	    LYUCcharset *p_in = HTAnchor_getUCInfoStage(HTMainAnchor,
							UCT_STAGE_PARSER);

	    if (!p_in || isEmpty(p_in->MIMEname) ||
		HTAnchor_getUCLYhndl(HTMainAnchor, UCT_STAGE_PARSER) < 0) {
		p_in = HTAnchor_getUCInfoStage(HTMainAnchor, UCT_STAGE_MIME);
	    }
	    if (p_in && non_empty(p_in->MIMEname) &&
		HTAnchor_getUCLYhndl(HTMainAnchor, UCT_STAGE_MIME) >= 0) {
		HTSprintf(&temp, "%s %s",
			  p_in->MIMEname,
			  gettext("(assumed)"));
		ADD_SS(gettext("Charset:"), p_in->MIMEname);
		FREE(temp);
	    }
	}

	if ((cp = HText_getServer()) != NULL && *cp != '\0')
	    ADD_SS(gettext("Server:"), cp);

	if ((cp = HText_getDate()) != NULL && *cp != '\0')
	    ADD_SS(gettext("Date:"), cp);

	if ((cp = HText_getLastModified()) != NULL && *cp != '\0')
	    ADD_SS(gettext("Last Mod:"), cp);

#ifdef ADVANCED_INFO
	if (LYInfoAdvanced) {
	    if (HTMainAnchor && HTMainAnchor->expires) {
		ADD_SS(gettext("Expires:"), HTMainAnchor->expires);
	    }
	    if (HTMainAnchor && HTMainAnchor->cache_control) {
		ADD_SS(gettext("Cache-Control:"), HTMainAnchor->cache_control);
	    }
	    if (HTMainAnchor && HTMainAnchor->content_length > 0) {
		ADD_NN(gettext("Content-Length:"),
		       HTMainAnchor->content_length,
		       gettext("bytes"));
	    } else {
		ADD_NN(gettext("Length:"),
		       HText_getNumOfBytes(),
		       gettext("bytes"));
	    }
	    if (HTMainAnchor && HTMainAnchor->content_language) {
		ADD_SS(gettext("Language:"), HTMainAnchor->content_language);
	    }
	}
#endif /* ADVANCED_INFO */

	if (doc->post_data) {
	    fprintf(fp0, "<dt><em>%s</em> <xmp>%.*s</xmp>\n",
		    gettext("Post Data:"),
		    BStrLen(doc->post_data),
		    BStrData(doc->post_data));
	    ADD_SS(gettext("Post Content Type:"), doc->post_content_type);
	}

	ADD_SS(gettext("Owner(s):"),
	       (owner_address
		? owner_address
		: NO_NOTHING));

	ADD_NN(gettext("size:"),
	       HText_getNumOfLines(),
	       gettext("lines"));

	StrAllocCopy(temp,
		     ((lynx_mode == FORMS_LYNX_MODE)
		      ? gettext("forms mode")
		      : (HTisDocumentSource()
			 ? gettext("source")
			 : gettext("normal"))));
	if (doc->safe)
	    StrAllocCat(temp, gettext(", safe"));
	if (doc->internal_link)
	    StrAllocCat(temp, gettext(", via internal link"));

#ifdef ADVANCED_INFO
	if (LYInfoAdvanced) {
	    if (HText_hasNoCacheSet(HTMainText))
		StrAllocCat(temp, gettext(", no-cache"));
	    if (HTAnchor_isISMAPScript((HTAnchor *) HTMainAnchor))
		StrAllocCat(temp, gettext(", ISMAP script"));
	    if (doc->bookmark)
		StrAllocCat(temp, gettext(", bookmark file"));
	}
#endif /* ADVANCED_INFO */

	ADD_SS(gettext("mode:"), temp);
	FREE(temp);

	END_DL();

	if (nlinks > 0) {
	    BEGIN_DL(gettext("Link that you currently have selected"));
	    ADD_SS(gettext("Linkname:"),
		   LYGetHiliteStr(doc->link, 0));
	    if (lynx_mode == FORMS_LYNX_MODE &&
		links[doc->link].type == WWW_FORM_LINK_TYPE) {
		if (links[doc->link].l_form->submit_method) {
		    int method = links[doc->link].l_form->submit_method;
		    char *enctype = links[doc->link].l_form->submit_enctype;

		    ADD_SS(gettext("Method:"),
			   ((method == URL_POST_METHOD) ? "POST" :
			    ((method == URL_MAIL_METHOD) ? "(email)" :
			     "GET")));
		    ADD_SS(gettext("Enctype:"),
			   (non_empty(enctype)
			    ? enctype
			    : "application/x-www-form-urlencoded"));
		}
		if (links[doc->link].l_form->submit_action) {
		    ADD_SS(gettext("Action:"),
			   links[doc->link].l_form->submit_action);
		}
		if (!(links[doc->link].l_form->submit_method &&
		      links[doc->link].l_form->submit_action)) {
		    fprintf(fp0, "<dt>&nbsp;%s\n", gettext("(Form field)"));
		}
	    } else {
		ADD_SS("URL:",
		       NonNull(links[doc->link].lname));
	    }
	    END_DL();

	} else {
	    fprintf(fp0, "<h2>%s</h2>", gettext("No Links on the current page"));
	}

#ifdef EXP_HTTP_HEADERS
	if ((cp = HText_getHttpHeaders()) != 0) {
	    fprintf(fp0, "<h2>%s</h2>", gettext("Server Headers:"));
	    fprintf(fp0, "<pre>%s</pre>", cp);
	}
#endif

#ifdef DIRED_SUPPORT
    }
#endif /* DIRED_SUPPORT */
    EndInternalPage(fp0);

    LYrefresh();

    LYCloseTemp(tempfile);
    FREE(Title);

    return (0);
}
@


1.9
log
@automatic merge
@
text
@d50 1
a50 1
char *LYVersionStatus(void)
d59 1
a59 1
char *LYVersionDate(void)
a110 1
	       int size_of_file,
d118 1
a118 1
    char *name;
d359 4
d384 1
a384 1
	       size_of_file,
d443 1
a443 3
		       (links[doc->link].lname
			? links[doc->link].lname
			: ""));
@


1.8
log
@automatic merge; regen configure
@
text
@d329 1
a329 1
	    if (p_in && p_in->MIMEname && *(p_in->MIMEname) &&
@


1.7
log
@automatic merge of lynx-current
@
text
@d27 8
d67 39
d118 1
a118 1
    char *Address = NULL, *Title = NULL;
d121 1
d158 3
a160 4
    fprintf(fp0, "<html>\n<head>\n");
    LYAddMETAcharsetToFD(fp0, -1);
    fprintf(fp0, "<title>%s</title>\n</head>\n<body>\n",
	    SHOWINFO_TITLE);
a171 1
	char *temp;
d173 1
a173 3
	fprintf(fp0, "<pre>\n");
	fprintf(fp0, "\n%s\n\n",
		gettext("Directory that you are currently viewing"));
d176 1
a176 1
	fprintf(fp0, "   <em>%4s</em>  %s\n", gettext("Name:"), temp);
d179 3
a181 1
	fprintf(fp0, "   <em>%4s</em>  %s\n", gettext("URL:"), doc->address);
d191 1
d193 1
a193 2
		fprintf(fp0, "\n%s\n\n",
			gettext("Directory that you have currently selected"));
d195 1
a195 2
		fprintf(fp0, "\n%s\n\n",
			gettext("File that you have currently selected"));
d198 1
a198 2
		fprintf(fp0, "\n%s\n\n",
			gettext("Symbolic link that you have currently selected"));
d201 1
a201 2
		fprintf(fp0, "\n%s\n\n",
			gettext("Item that you have currently selected"));
d203 1
a203 1
	    fprintf(fp0, "       <em>%s</em>  %s\n", gettext("Full name:"), temp);
d214 1
a214 2
		fprintf(fp0, "  <em>%s</em>  %s\n",
			gettext("Points to file:"), buf);
d219 1
a219 2
		fprintf(fp0, "   <em>%s</em>  %s\n",
			gettext("Name of owner:"), name);
d222 1
a222 2
		fprintf(fp0, "      <em>%s</em>  %s\n",
			gettext("Group name:"), name);
d224 3
a226 2
		fprintf(fp0, "       <em>%s</em>  %ld (bytes)\n",
			gettext("File size:"), (long) dir_info.st_size);
d231 2
a232 2
	    cp = ctime(&dir_info.st_ctime);
	    fprintf(fp0, "   <em>%s</em>  %s", gettext("Creation date:"), cp);
d234 2
a235 2
	    cp = ctime(&dir_info.st_mtime);
	    fprintf(fp0, "   <em>%s</em>  %s", gettext("Last modified:"), cp);
d237 2
a238 2
	    cp = ctime(&dir_info.st_atime);
	    fprintf(fp0, "   <em>%s</em>  %s\n", gettext("Last accessed:"), cp);
d240 4
a243 2
	    fprintf(fp0, "   %s\n", gettext("Access Permissions"));
	    fprintf(fp0, "      <em>%s</em>  ", gettext("Owner:"));
d260 1
a260 1
	    fprintf(fp0, "%s\n", (char *) &modes[2]);	/* Skip leading ', ' */
a261 1
	    fprintf(fp0, "      <em>Group:</em>  ");
d278 1
a278 1
	    fprintf(fp0, "%s\n", (char *) &modes[2]);	/* Skip leading ', ' */
a279 1
	    fprintf(fp0, "      <em>World:</em>  ");
d298 2
a299 1
	    fprintf(fp0, "%s\n", (char *) &modes[2]);	/* Skip leading ', ' */
a301 1
	fprintf(fp0, "</pre>\n");
d305 1
a305 2
	fprintf(fp0, "<h2>%s</h2>\n<dl compact>",
		gettext("File that you are currently viewing"));
d308 9
a316 12
	LYEntify(&Title, TRUE);
	fprintf(fp0, "<dt><em>%s</em> %s%s\n",
		gettext("Linkname:"),
		Title,
		((doc->isHEAD &&
		  !strstr(Title, " (HEAD)") &&
		  !strstr(Title, " - HEAD")) ? " (HEAD)" : ""));

	StrAllocCopy(Address, doc->address);
	LYEntify(&Address, TRUE);
	fprintf(fp0,
		"<dt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>URL:</em> %s\n", Address);
d319 2
a320 3
	    fprintf(fp0, "<dt><em>&nbsp;%s</em> %s\n",
		    gettext("Charset:"),
		    HTLoadedDocumentCharset());
d331 5
a335 3
		fprintf(fp0, "<dt><em>&nbsp;%s</em> %s (assumed)\n",
			gettext("Charset:"),
			p_in->MIMEname);
d340 1
a340 2
	    fprintf(fp0, "<dt><em>&nbsp;&nbsp;%s</em> %s\n",
		    gettext("Server:"), cp);
d343 1
a343 2
	    fprintf(fp0, "<dt><em>&nbsp;&nbsp;&nbsp;&nbsp;%s</em> %s\n",
		    gettext("Date:"), cp);
d346 1
a346 1
	    fprintf(fp0, "<dt><em>%s</em> %s\n", gettext("Last Mod:"), cp);
d351 1
a351 2
		fprintf(fp0, "<dt><em>%s</em> %s\n",
			gettext("&nbsp;Expires:"), HTMainAnchor->expires);
d354 1
a354 2
		fprintf(fp0, "<dt><em>%s</em> %s\n",
			gettext("Cache-Control:"), HTMainAnchor->cache_control);
d357 3
a359 3
		fprintf(fp0, "<dt><em>%s</em> %d %s\n",
			gettext("Content-Length:"),
			HTMainAnchor->content_length, gettext("bytes"));
d362 1
a362 2
		fprintf(fp0, "<dt><em>%s</em> %s\n",
			gettext("Language:"), HTMainAnchor->content_language);
d372 1
a372 9
	    fprintf(fp0, "<dt><em>%s</em> %s\n",
		    gettext("Post Content Type:"), doc->post_content_type);
	}

	if (owner_address) {
	    StrAllocCopy(Address, owner_address);
	    LYEntify(&Address, TRUE);
	} else {
	    StrAllocCopy(Address, NO_NOTHING);
a373 1
	fprintf(fp0, "<dt><em>%s</em> %s\n", gettext("Owner(s):"), Address);
d375 19
a393 2
	fprintf(fp0, "<dt>&nbsp;&nbsp;&nbsp;&nbsp;<em>%s</em> %d %s\n",
		gettext("size:"), size_of_file, gettext("lines"));
a394 10
	fprintf(fp0, "<dt>&nbsp;&nbsp;&nbsp;&nbsp;<em>%s</em> %s%s%s",
		gettext("mode:"),
		((lynx_mode == FORMS_LYNX_MODE)
		 ? gettext("forms mode")
		 : (HTisDocumentSource()
		    ? gettext("source")
		    : gettext("normal"))),
		(doc->safe ? gettext(", safe") : ""),
		(doc->internal_link ? gettext(", via internal link") : "")
	    );
d397 6
a402 8
	    fprintf(fp0, "%s%s%s\n",
		    (HText_hasNoCacheSet(HTMainText) ?
		     gettext(", no-cache") : ""),
		    (HTAnchor_isISMAPScript((HTAnchor *) HTMainAnchor) ?
		     gettext(", ISMAP script") : ""),
		    (doc->bookmark ?
		     gettext(", bookmark file") : "")
		);
d406 4
a409 1
	fprintf(fp0, "\n</dl>\n");	/* end of list */
d412 3
a414 7
	    fprintf(fp0, "<h2>%s</h2>\n<dl compact>",
		    gettext("Link that you currently have selected"));
	    StrAllocCopy(Title, LYGetHiliteStr(doc->link, 0));
	    LYEntify(&Title, TRUE);
	    fprintf(fp0, "<dt><em>%s</em> %s\n",
		    gettext("Linkname:"),
		    Title);
d421 8
a428 10
		    fprintf(fp0, "<dt>&nbsp;&nbsp;<em>%s</em> %s\n",
			    gettext("Method:"),
			    ((method == URL_POST_METHOD) ? "POST" :
			     ((method == URL_MAIL_METHOD) ? "(email)" :
			      "GET")));
		    fprintf(fp0, "<dt>&nbsp;<em>%s</em> %s\n",
			    gettext("Enctype:"),
			    (enctype &&
			     *enctype ?
			     enctype : "application/x-www-form-urlencoded"));
d431 2
a432 3
		    StrAllocCopy(Address, links[doc->link].l_form->submit_action);
		    LYEntify(&Address, TRUE);
		    fprintf(fp0, "<dt>&nbsp;&nbsp;<em>Action:</em> %s\n", Address);
d439 4
a442 8
		if (links[doc->link].lname) {
		    StrAllocCopy(Title, links[doc->link].lname);
		    LYEntify(&Title, TRUE);
		} else {
		    StrAllocCopy(Title, "");
		}
		fprintf(fp0,
			"<dt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>URL:</em> %s\n", Title);
d444 1
a444 1
	    fprintf(fp0, "</dl>\n");	/* end of list */
d446 1
a446 1
	} else
d448 1
a464 1
    FREE(Address);
@


1.6
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d37 1
a37 1
BOOL LYVersionIsRelease (void)
d39 1
a39 1
    return (BOOL)(strstr(LYNX_VERSION, "rel") != 0);
d42 1
a42 1
char *LYVersionStatus (void)
d51 1
a51 1
char *LYVersionDate (void)
d53 2
a54 1
    static char temp[LYNX_DATE_LEN+1];
d60 2
a61 2
 *  LYShowInfo prints a page of info about the current file and the link
 *  that the cursor is on.
d63 4
a66 6

int LYShowInfo (
	DocInfo *	doc,
	int		size_of_file,
	DocInfo *	newdoc,
	char * 	owner_address)
d74 1
d90 1
a90 1
	return(-1);
d94 1
a94 1
     *	Point the address pointer at this Url
d102 1
a102 1
	char *last_slash = strrchr(links[doc->link].lname,'/');
d113 1
a113 1
		 SHOWINFO_TITLE);
d116 4
a119 6
		 LYNX_NAME, LYNX_VERSION,
		 LYVersionDate(),
		 (LYVersionIsRelease() ? LYNX_WWW_HOME     : LYNX_WWW_DIST),
		 LYVersionStatus());

    fprintf(fp0, "</h1>\n");  /* don't forget to close <h1> */
d121 1
d128 2
a129 1
	fprintf(fp0, "\n%s\n\n", gettext("Directory that you are currently viewing"));
d144 1
d166 1
a166 1
		if ((buf_size = readlink(temp, buf, sizeof(buf)-1)) != -1) {
d171 2
a172 1
		fprintf(fp0, "  <em>%s</em>  %s\n", gettext("Points to file:"), buf);
d177 3
a179 2
		fprintf(fp0, "   <em>%s</em>  %s\n", gettext("Name of owner:"), name);
	    name = HTAA_GidToName (dir_info.st_gid);
d181 2
a182 1
		fprintf(fp0, "      <em>%s</em>  %s\n", gettext("Group name:"), name);
d185 1
a185 1
			gettext("File size:"), (long)dir_info.st_size);
d188 1
a188 1
	     *	Include date and time information.
d202 1
a202 1
	    modes[1] = '\0';   /* In case there are no permissions */
d217 1
a217 1
	    fprintf(fp0, "%s\n", (char *)&modes[2]); /* Skip leading ', ' */
d221 1
a221 1
	    modes[1] = '\0';   /* In case there are no permissions */
d236 1
a236 1
	    fprintf(fp0, "%s\n", (char *)&modes[2]);  /* Skip leading ', ' */
d240 1
a240 1
	    modes[1] = '\0';   /* In case there are no permissions */
d257 1
a257 1
	    fprintf(fp0, "%s\n", (char *)&modes[2]);  /* Skip leading ', ' */
d260 1
a260 1
	fprintf(fp0,"</pre>\n");
d264 2
a265 2
    fprintf(fp0, "<h2>%s</h2>\n<dl compact>",
	    gettext("File that you are currently viewing"));
d267 8
a274 32
    LYformTitle(&Title, doc->title);
    LYEntify(&Title, TRUE);
    fprintf(fp0, "<dt><em>%s</em> %s%s\n",
		 gettext("Linkname:"),
		 Title,
		 ((doc->isHEAD &&
		   !strstr(Title, " (HEAD)") &&
		   !strstr(Title, " - HEAD")) ? " (HEAD)" : ""));

    StrAllocCopy(Address, doc->address);
    LYEntify(&Address, TRUE);
    fprintf(fp0,
	    "<dt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>URL:</em> %s\n", Address);

    if (HTLoadedDocumentCharset()) {
	fprintf(fp0, "<dt><em>&nbsp;%s</em> %s\n",
		     gettext("Charset:"),
		     HTLoadedDocumentCharset());
    } else {
      LYUCcharset * p_in = HTAnchor_getUCInfoStage(HTMainAnchor,
							     UCT_STAGE_PARSER);
      if (!p_in || isEmpty(p_in->MIMEname) ||
	   HTAnchor_getUCLYhndl(HTMainAnchor, UCT_STAGE_PARSER) < 0) {
	   p_in = HTAnchor_getUCInfoStage(HTMainAnchor, UCT_STAGE_MIME);
      }
      if (p_in && p_in->MIMEname && *(p_in->MIMEname) &&
	  HTAnchor_getUCLYhndl(HTMainAnchor, UCT_STAGE_MIME) >= 0) {
	fprintf(fp0, "<dt><em>&nbsp;%s</em> %s (assumed)\n",
		     gettext("Charset:"),
		     p_in->MIMEname);
      }
    }
d276 4
a279 2
    if ((cp = HText_getServer()) != NULL && *cp != '\0')
	fprintf(fp0, "<dt><em>&nbsp;&nbsp;%s</em> %s\n", gettext("Server:"), cp);
d281 7
a287 2
    if ((cp = HText_getDate()) != NULL && *cp != '\0')
	fprintf(fp0, "<dt><em>&nbsp;&nbsp;&nbsp;&nbsp;%s</em> %s\n", gettext("Date:"), cp);
d289 22
a310 2
    if ((cp = HText_getLastModified()) != NULL && *cp != '\0')
	fprintf(fp0, "<dt><em>%s</em> %s\n", gettext("Last Mod:"), cp);
d313 18
a330 4
    if (LYInfoAdvanced) {
	if (HTMainAnchor && HTMainAnchor->expires) {
	    fprintf(fp0, "<dt><em>%s</em> %s\n",
		    gettext("&nbsp;Expires:"), HTMainAnchor->expires);
d332 7
a338 1
	if (HTMainAnchor && HTMainAnchor->cache_control) {
d340 1
a340 1
		    gettext("Cache-Control:"), HTMainAnchor->cache_control);
d342 6
a347 8
	if (HTMainAnchor && HTMainAnchor->content_length > 0) {
	    fprintf(fp0, "<dt><em>%s</em> %d %s\n",
		    gettext("Content-Length:"),
		    HTMainAnchor->content_length, gettext("bytes"));
	}
	if (HTMainAnchor && HTMainAnchor->content_language) {
	    fprintf(fp0, "<dt><em>%s</em> %s\n",
		    gettext("Language:"), HTMainAnchor->content_language);
d349 1
a349 19
    }
#endif /* ADVANCED_INFO */

    if (doc->post_data) {
	fprintf(fp0, "<dt><em>%s</em> <xmp>%.*s</xmp>\n",
		gettext("Post Data:"),
		BStrLen(doc->post_data),
		BStrData(doc->post_data));
	fprintf(fp0, "<dt><em>%s</em> %s\n",
		gettext("Post Content Type:"), doc->post_content_type);
    }

    if (owner_address) {
	StrAllocCopy(Address, owner_address);
	LYEntify(&Address, TRUE);
    } else {
	StrAllocCopy(Address, NO_NOTHING);
    }
    fprintf(fp0, "<dt><em>%s</em> %s\n", gettext("Owner(s):"), Address);
d351 2
a352 2
    fprintf(fp0, "<dt>&nbsp;&nbsp;&nbsp;&nbsp;<em>%s</em> %d %s\n",
	    gettext("size:"), size_of_file, gettext("lines"));
d354 9
a362 8
    fprintf(fp0, "<dt>&nbsp;&nbsp;&nbsp;&nbsp;<em>%s</em> %s%s%s",
		 gettext("mode:"),
		 (lynx_mode == FORMS_LYNX_MODE ?
				  gettext("forms mode") :
		  HTisDocumentSource() ?
				  gettext("source") : gettext("normal")),
		 (doc->safe ? gettext(", safe") : ""),
		 (doc->internal_link ? gettext(", via internal link") : "")
d365 10
a374 10
    if (LYInfoAdvanced) {
	fprintf(fp0, "%s%s%s\n",
		(HText_hasNoCacheSet(HTMainText) ?
				  gettext(", no-cache") : ""),
		(HTAnchor_isISMAPScript((HTAnchor *)HTMainAnchor) ?
				  gettext(", ISMAP script") : ""),
		(doc->bookmark ?
				  gettext(", bookmark file") : "")
	    );
    }
d377 1
a377 1
    fprintf(fp0, "\n</dl>\n");  /* end of list */
d379 34
a412 38
    if (nlinks > 0) {
	fprintf(fp0, "<h2>%s</h2>\n<dl compact>",
		gettext("Link that you currently have selected"));
	StrAllocCopy(Title, LYGetHiliteStr(doc->link, 0));
	LYEntify(&Title, TRUE);
	fprintf(fp0, "<dt><em>%s</em> %s\n",
		gettext("Linkname:"),
		Title);
	if (lynx_mode == FORMS_LYNX_MODE &&
	    links[doc->link].type == WWW_FORM_LINK_TYPE) {
	    if (links[doc->link].l_form->submit_method) {
		int method = links[doc->link].l_form->submit_method;
		char *enctype = links[doc->link].l_form->submit_enctype;

		fprintf(fp0, "<dt>&nbsp;&nbsp;<em>%s</em> %s\n",
			     gettext("Method:"),
			     (method == URL_POST_METHOD) ? "POST" :
			     (method == URL_MAIL_METHOD) ? "(email)" :
							   "GET");
		fprintf(fp0, "<dt>&nbsp;<em>%s</em> %s\n",
			     gettext("Enctype:"),
			     (enctype &&
			      *enctype ?
			       enctype : "application/x-www-form-urlencoded"));
	    }
	    if (links[doc->link].l_form->submit_action) {
		StrAllocCopy(Address, links[doc->link].l_form->submit_action);
		LYEntify(&Address, TRUE);
		fprintf(fp0, "<dt>&nbsp;&nbsp;<em>Action:</em> %s\n", Address);
	    }
	    if (!(links[doc->link].l_form->submit_method &&
		  links[doc->link].l_form->submit_action)) {
		fprintf(fp0, "<dt>&nbsp;%s\n", gettext("(Form field)"));
	    }
	} else {
	    if (links[doc->link].lname) {
		StrAllocCopy(Title, links[doc->link].lname);
		LYEntify(&Title, TRUE);
d414 8
a421 1
		StrAllocCopy(Title, "");
d423 9
a431 2
	    fprintf(fp0,
	       "<dt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>URL:</em> %s\n", Title);
d433 1
a433 4
	fprintf(fp0, "</dl>\n");  /* end of list */

    } else
	fprintf(fp0, "<h2>%s</h2>", gettext("No Links on the current page"));
d446 1
a446 1
    return(0);
@


1.5
log
@some more string fixes, but I'll stop here...
I just noticed how much abuse is done with these
@
text
@d37 1
a37 1
PUBLIC BOOL LYVersionIsRelease NOARGS
d42 1
a42 1
PUBLIC char *LYVersionStatus NOARGS
d51 1
a51 1
PUBLIC char *LYVersionDate NOARGS
d63 5
a67 5
PUBLIC int LYShowInfo ARGS4(
	DocInfo *,	doc,
	int,		size_of_file,
	DocInfo *,	newdoc,
	char *, 	owner_address)
d74 1
a74 1
    CONST char *cp;
@


1.4
log
@kill sprintf (myself)
@
text
@d201 1
a201 1
		strcat(modes, ", read");
d203 1
a203 1
		strcat(modes, ", write");
d206 1
a206 1
		    strcat(modes, ", search");
d208 1
a208 1
		    strcat(modes, ", execute");
d210 1
a210 1
			strcat(modes, ", setuid");
d220 1
a220 1
		strcat(modes, ", read");
d222 1
a222 1
		strcat(modes, ", write");
d225 1
a225 1
		    strcat(modes, ", search");
d227 1
a227 1
		    strcat(modes, ", execute");
d229 1
a229 1
			strcat(modes, ", setgid");
d239 1
a239 1
		strcat(modes, ", read");
d241 1
a241 1
		strcat(modes, ", write");
d244 1
a244 1
		    strcat(modes, ", search");
d246 1
a246 1
		    strcat(modes, ", execute");
d249 1
a249 1
			strcat(modes, ", sticky");
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d168 1
a168 1
		    sprintf(buf, "%.1024s", gettext("Unable to follow link"));
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d14 2
d28 32
a59 1
 *  Showinfo prints a page of info about the current file and the link
d63 2
a64 2
PUBLIC int showinfo ARGS4(
	document *,	doc,
d66 1
a66 1
	document *,	newdoc,
d69 1
a69 1
    static char tempfile[LY_MAXPATH];
d76 1
a76 1
    BOOLEAN LYInfoAdvanced = (user_mode == ADVANCED_MODE);
a77 1

a78 1
    char temp[LY_MAXPATH];
d82 7
a88 2
    LYRemoveTemp(tempfile);
    if ((fp0 = LYOpenTemp (tempfile, HTML_SUFFIX, "w")) == 0) {
d115 1
a115 1
    fprintf(fp0, "<h1>%s %s (%.*s) (<a href=\"%s\">%s</a>)",
d117 4
a120 14
		 LYNX_DATE_LEN,
		 (LYNX_RELEASE ? LYNX_RELEASE_DATE : &LYNX_DATE[LYNX_DATE_OFF]),
		 (LYNX_RELEASE ? LYNX_WWW_HOME     : LYNX_WWW_DIST),
		 (LYNX_RELEASE ? REL_VERSION       : DEV_VERSION) );

    if (!LYRestricted) {
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
	fprintf(fp0, " - <a href=\"LYNXCOMPILEOPTS:\">%s</a>\n",
		COMPILE_OPT_SEGMENT);
#else
	fprintf(fp0, " - <a href=\"LYNXCFG:\">%s lynx.cfg</a>\n",
		YOUR_SEGMENT);
#endif
    }
d126 1
a126 1
	char *s;
d131 3
a133 3
	s = HTfullURL_toFile(doc->address);
	strcpy(temp, s);
	FREE(s);
a134 1
	fprintf(fp0, "   <em>%4s</em>  %s\n", gettext("Name:"), temp);
d137 1
a137 3
	s = HTfullURL_toFile(links[doc->link].lname);
	strcpy(temp, s);
	FREE(s);
d140 1
a140 1
	    CTRACE(tfp, "lstat(%s) failed, errno=%d\n", temp, errno);
d168 1
a168 1
		    strcpy(buf, gettext("Unable to follow link"));
d175 1
a175 1
		fprintf(fp0, "   <em>%s</em>  %s\n", gettext("Name of owner"), name);
d187 1
a187 1
	    fprintf(fp0, "   <em>%s</em>  %s", cp, gettext("Creation date:"));
d190 1
a190 1
	    fprintf(fp0, "   <em>%s</em>  %s", cp, gettext("Last modified:"));
d193 1
a193 1
	    fprintf(fp0, "   <em>%s</em>  %s\n", cp, gettext("Last accessed:"));
d255 1
d263 1
a263 1
    StrAllocCopy(Title, doc->title);
d267 4
a270 1
		 Title, (doc->isHEAD ? " (HEAD)" : ""));
d284 1
a284 1
      if (!p_in || !(p_in->MIMEname) || !*(p_in->MIMEname) ||
d328 4
a331 2
	fprintf(fp0, "<dt><em>%s</em> <xmp>%s</xmp>\n",
		gettext("Post Data:"), doc->post_data);
d354 1
a354 1
		 (doc->internal_link ? gettext(", internal link") : "")
d374 1
a374 1
	StrAllocCopy(Title, links[doc->link].hightext);
d381 3
a383 3
	    if (links[doc->link].form->submit_method) {
		int method = links[doc->link].form->submit_method;
		char *enctype = links[doc->link].form->submit_enctype;
d396 2
a397 2
	    if (links[doc->link].form->submit_action) {
		StrAllocCopy(Address, links[doc->link].form->submit_action);
d401 2
a402 2
	    if (!(links[doc->link].form->submit_method &&
		  links[doc->link].form->submit_action)) {
d425 1
a425 1
    refresh();
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a13 2
#include <LYCharSets.h>
#include <LYStrings.h>
a24 8
#define BEGIN_DL(text) fprintf(fp0, "<h2>%s</h2>\n<dl compact>", text)
#define END_DL()       fprintf(fp0, "\n</dl>\n")

#define ADD_SS(label,value)       dt_String(fp0, label, value)
#define ADD_NN(label,value,units) dt_Number(fp0, label, value, units)

static int label_columns;

d26 2
a27 8
 * LYNX_VERSION and LYNX_DATE are automatically generated by PRCS, the tool
 * which we use to archive versions of Lynx.  We use a convention for naming
 * the successive versions:
 *	{release}{status}{patch}
 * where
 *	{release} is the release that we are working on, e.g., 2.8.4
 *	{status} is one of "dev", "pre" or "rel", and
 *	{patch} is a number assigned by PRCS.
a28 17
BOOL LYVersionIsRelease(void)
{
    return (BOOL) (strstr(LYNX_VERSION, "rel") != 0);
}

const char *LYVersionStatus(void)
{
    if (LYVersionIsRelease())
	return REL_VERSION;
    else if (strstr(LYNX_VERSION, "pre") != 0)
	return PRE_VERSION;
    return DEV_VERSION;
}

const char *LYVersionDate(void)
{
    static char temp[LYNX_DATE_LEN + 1];
d30 5
a34 7
    LYstrncpy(temp, &LYNX_DATE[LYNX_DATE_OFF], LYNX_DATE_LEN);
    return temp;
}

static void dt_String(FILE *fp,
		      const char *label,
		      const char *value)
d36 1
a36 44
    int have;
    int need;
    char *the_label = 0;
    char *the_value = 0;

    StrAllocCopy(the_label, label);
    StrAllocCopy(the_value, value);

    have = strlen(the_label);
    need = LYstrExtent(the_label, have, label_columns);

    LYEntify(&the_label, TRUE);
    LYEntify(&the_value, TRUE);

    fprintf(fp, "<dt>");
    while (need++ < label_columns)
	fprintf(fp, "&nbsp;");
    fprintf(fp, "<em>%s</em> %s\n", the_label, the_value);

    FREE(the_label);
    FREE(the_value);
}

static void dt_Number(FILE *fp0,
		      const char *label,
		      long number,
		      const char *units)
{
    char *value = NULL;

    HTSprintf(&value, "%ld %s", number, units);
    ADD_SS(label, value);
    FREE(value);
}

/*
 * LYShowInfo prints a page of info about the current file and the link that
 * the cursor is on.
 */
int LYShowInfo(DocInfo *doc,
	       DocInfo *newdoc,
	       char *owner_address)
{
    static char tempfile[LY_MAXPATH] = "\0";
d39 3
a41 5
    char *Title = NULL;
    const char *name;
    const char *cp;
    char *temp = 0;

d43 1
a43 1
    BOOLEAN LYInfoAdvanced = (BOOL) (user_mode == ADVANCED_MODE);
d45 1
d47 1
d51 2
a52 7
    if (LYReuseTempfiles) {
	fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
    } else {
	LYRemoveTemp(tempfile);
	fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
    }
    if (fp0 == NULL) {
d54 1
a54 1
	return (-1);
d58 1
a58 1
     * Point the address pointer at this Url
d66 1
a66 1
	char *last_slash = strrchr(links[doc->link].lname, '/');
d74 22
a95 9
    label_columns = 9;

    WriteInternalTitle(fp0, SHOWINFO_TITLE);

    fprintf(fp0, "<h1>%s %s (%s) (<a href=\"%s\">%s</a>)",
	    LYNX_NAME, LYNX_VERSION,
	    LYVersionDate(),
	    (LYVersionIsRelease()? LYNX_WWW_HOME : LYNX_WWW_DIST),
	    LYVersionStatus());
a96 1
    fprintf(fp0, "</h1>\n");	/* don't forget to close <h1> */
d100 1
d102 2
a103 1
	BEGIN_DL(gettext("Directory that you are currently viewing"));
d105 3
a107 3
	temp = HTfullURL_toFile(doc->address);
	ADD_SS(gettext("Name:"), temp);
	FREE(temp);
d109 2
a110 1
	ADD_SS(gettext("URL:"), doc->address);
d112 3
a114 3
	END_DL();

	temp = HTfullURL_toFile(links[doc->link].lname);
d117 1
a117 1
	    CTRACE((tfp, "lstat(%s) failed, errno=%d\n", temp, errno));
a120 2

	    label_columns = 16;
d122 2
a123 1
		BEGIN_DL(gettext("Directory that you have currently selected"));
d125 2
a126 1
		BEGIN_DL(gettext("File that you have currently selected"));
d129 2
a130 1
		BEGIN_DL(gettext("Symbolic link that you have currently selected"));
d133 2
a134 1
		BEGIN_DL(gettext("Item that you have currently selected"));
d136 1
a136 1
	    ADD_SS(gettext("Full name:"), temp);
d142 1
a142 1
		if ((buf_size = readlink(temp, buf, sizeof(buf) - 1)) != -1) {
d145 1
a145 1
		    sprintf(buf, "%.1024s", gettext("Unable to follow link"));
d147 1
a147 1
		ADD_SS(gettext("Points to file:"), buf);
d152 2
a153 2
		ADD_SS(gettext("Name of owner:"), name);
	    name = HTAA_GidToName(dir_info.st_gid);
d155 1
a155 1
		ADD_SS(gettext("Group name:"), name);
d157 2
a158 3
		ADD_NN(gettext("File size:"),
		       (long) dir_info.st_size,
		       gettext("(bytes)"));
d161 1
a161 1
	     * Include date and time information.
d163 2
a164 2
	    ADD_SS(gettext("Creation date:"),
		   ctime(&dir_info.st_ctime));
d166 2
a167 2
	    ADD_SS(gettext("Last modified:"),
		   ctime(&dir_info.st_mtime));
d169 2
a170 2
	    ADD_SS(gettext("Last accessed:"),
		   ctime(&dir_info.st_atime));
d172 2
a173 4
	    END_DL();

	    label_columns = 9;
	    BEGIN_DL(gettext("Access Permissions"));
d175 1
a175 1
	    modes[1] = '\0';	/* In case there are no permissions */
d190 1
a190 1
	    ADD_SS(gettext("Owner:"), &modes[2]);
d192 1
d194 1
a194 1
	    modes[1] = '\0';	/* In case there are no permissions */
d209 1
a209 1
	    ADD_SS(gettext("Group:"), &modes[2]);
d211 1
d213 1
a213 1
	    modes[1] = '\0';	/* In case there are no permissions */
d230 1
a230 2
	    ADD_SS(gettext("World:"), &modes[2]);
	    END_DL();
d232 1
a232 1
	FREE(temp);
d236 2
a237 1
	BEGIN_DL(gettext("File that you are currently viewing"));
d239 29
a267 31
	LYformTitle(&Title, doc->title);
	HTSprintf(&temp, "%s%s",
		  Title,
		  ((doc->isHEAD &&
		    !strstr(Title, " (HEAD)") &&
		    !strstr(Title, " - HEAD")) ? " (HEAD)" : ""));
	ADD_SS(gettext("Linkname:"), temp);
	FREE(temp);

	ADD_SS("URL:", doc->address);

	if (HTLoadedDocumentCharset()) {
	    ADD_SS(gettext("Charset:"),
		   HTLoadedDocumentCharset());
	} else {
	    LYUCcharset *p_in = HTAnchor_getUCInfoStage(HTMainAnchor,
							UCT_STAGE_PARSER);

	    if (!p_in || isEmpty(p_in->MIMEname) ||
		HTAnchor_getUCLYhndl(HTMainAnchor, UCT_STAGE_PARSER) < 0) {
		p_in = HTAnchor_getUCInfoStage(HTMainAnchor, UCT_STAGE_MIME);
	    }
	    if (p_in && non_empty(p_in->MIMEname) &&
		HTAnchor_getUCLYhndl(HTMainAnchor, UCT_STAGE_MIME) >= 0) {
		HTSprintf(&temp, "%s %s",
			  p_in->MIMEname,
			  gettext("(assumed)"));
		ADD_SS(gettext("Charset:"), p_in->MIMEname);
		FREE(temp);
	    }
	}
d269 2
a270 2
	if ((cp = HText_getServer()) != NULL && *cp != '\0')
	    ADD_SS(gettext("Server:"), cp);
d272 2
a273 2
	if ((cp = HText_getDate()) != NULL && *cp != '\0')
	    ADD_SS(gettext("Date:"), cp);
d275 2
a276 2
	if ((cp = HText_getLastModified()) != NULL && *cp != '\0')
	    ADD_SS(gettext("Last Mod:"), cp);
d279 17
a295 19
	if (LYInfoAdvanced) {
	    if (HTMainAnchor && HTMainAnchor->expires) {
		ADD_SS(gettext("Expires:"), HTMainAnchor->expires);
	    }
	    if (HTMainAnchor && HTMainAnchor->cache_control) {
		ADD_SS(gettext("Cache-Control:"), HTMainAnchor->cache_control);
	    }
	    if (HTMainAnchor && HTMainAnchor->content_length > 0) {
		ADD_NN(gettext("Content-Length:"),
		       HTMainAnchor->content_length,
		       gettext("bytes"));
	    } else {
		ADD_NN(gettext("Length:"),
		       HText_getNumOfBytes(),
		       gettext("bytes"));
	    }
	    if (HTMainAnchor && HTMainAnchor->content_language) {
		ADD_SS(gettext("Language:"), HTMainAnchor->content_language);
	    }
d297 1
d300 14
a313 7
	if (doc->post_data) {
	    fprintf(fp0, "<dt><em>%s</em> <xmp>%.*s</xmp>\n",
		    gettext("Post Data:"),
		    BStrLen(doc->post_data),
		    BStrData(doc->post_data));
	    ADD_SS(gettext("Post Content Type:"), doc->post_content_type);
	}
d315 2
a316 19
	ADD_SS(gettext("Owner(s):"),
	       (owner_address
		? owner_address
		: NO_NOTHING));

	ADD_NN(gettext("size:"),
	       HText_getNumOfLines(),
	       gettext("lines"));

	StrAllocCopy(temp,
		     ((lynx_mode == FORMS_LYNX_MODE)
		      ? gettext("forms mode")
		      : (HTisDocumentSource()
			 ? gettext("source")
			 : gettext("normal"))));
	if (doc->safe)
	    StrAllocCat(temp, gettext(", safe"));
	if (doc->internal_link)
	    StrAllocCat(temp, gettext(", via internal link"));
d318 9
d328 10
a337 8
	if (LYInfoAdvanced) {
	    if (HText_hasNoCacheSet(HTMainText))
		StrAllocCat(temp, gettext(", no-cache"));
	    if (HTAnchor_isISMAPScript((HTAnchor *) HTMainAnchor))
		StrAllocCat(temp, gettext(", ISMAP script"));
	    if (doc->bookmark)
		StrAllocCat(temp, gettext(", bookmark file"));
	}
d340 1
a340 2
	ADD_SS(gettext("mode:"), temp);
	FREE(temp);
d342 38
a379 29
	END_DL();

	if (nlinks > 0) {
	    BEGIN_DL(gettext("Link that you currently have selected"));
	    ADD_SS(gettext("Linkname:"),
		   LYGetHiliteStr(doc->link, 0));
	    if (lynx_mode == FORMS_LYNX_MODE &&
		links[doc->link].type == WWW_FORM_LINK_TYPE) {
		if (links[doc->link].l_form->submit_method) {
		    int method = links[doc->link].l_form->submit_method;
		    char *enctype = links[doc->link].l_form->submit_enctype;

		    ADD_SS(gettext("Method:"),
			   ((method == URL_POST_METHOD) ? "POST" :
			    ((method == URL_MAIL_METHOD) ? "(email)" :
			     "GET")));
		    ADD_SS(gettext("Enctype:"),
			   (non_empty(enctype)
			    ? enctype
			    : "application/x-www-form-urlencoded"));
		}
		if (links[doc->link].l_form->submit_action) {
		    ADD_SS(gettext("Action:"),
			   links[doc->link].l_form->submit_action);
		}
		if (!(links[doc->link].l_form->submit_method &&
		      links[doc->link].l_form->submit_action)) {
		    fprintf(fp0, "<dt>&nbsp;%s\n", gettext("(Form field)"));
		}
d381 1
a381 2
		ADD_SS("URL:",
		       NonNull(links[doc->link].lname));
d383 2
a384 4
	    END_DL();

	} else {
	    fprintf(fp0, "<h2>%s</h2>", gettext("No Links on the current page"));
d386 1
d388 2
a389 6
#ifdef EXP_HTTP_HEADERS
	if ((cp = HText_getHttpHeaders()) != 0) {
	    fprintf(fp0, "<h2>%s</h2>", gettext("Server Headers:"));
	    fprintf(fp0, "<pre>%s</pre>", cp);
	}
#endif
d396 1
a396 1
    LYrefresh();
d399 1
d402 1
a402 1
    return (0);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a13 2
#include <LYCharSets.h>
#include <LYStrings.h>
d26 1
a26 32
 * LYNX_VERSION and LYNX_DATE are automatically generated by PRCS, the tool
 * which we use to archive versions of Lynx.  We use a convention for naming
 * the successive versions:
 *	{release}{status}{patch}
 * where
 *	{release} is the release that we are working on, e.g., 2.8.4
 *	{status} is one of "dev", "pre" or "rel", and
 *	{patch} is a number assigned by PRCS.
 */
PUBLIC BOOL LYVersionIsRelease NOARGS
{
    return (BOOL)(strstr(LYNX_VERSION, "rel") != 0);
}

PUBLIC char *LYVersionStatus NOARGS
{
    if (LYVersionIsRelease())
	return REL_VERSION;
    else if (strstr(LYNX_VERSION, "pre") != 0)
	return PRE_VERSION;
    return DEV_VERSION;
}

PUBLIC char *LYVersionDate NOARGS
{
    static char temp[LYNX_DATE_LEN+1];
    LYstrncpy(temp, &LYNX_DATE[LYNX_DATE_OFF], LYNX_DATE_LEN);
    return temp;
}

/*
 *  LYShowInfo prints a page of info about the current file and the link
d30 2
a31 2
PUBLIC int LYShowInfo ARGS4(
	DocInfo *,	doc,
d33 1
a33 1
	DocInfo *,	newdoc,
d36 1
a36 1
    static char tempfile[LY_MAXPATH] = "\0";
d43 1
a43 1
    BOOLEAN LYInfoAdvanced = (BOOL) (user_mode == ADVANCED_MODE);
d45 1
d47 1
d51 2
a52 7
    if (LYReuseTempfiles) {
	fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
    } else {
	LYRemoveTemp(tempfile);
	fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
    }
    if (fp0 == NULL) {
d79 1
a79 1
    fprintf(fp0, "<h1>%s %s (%s) (<a href=\"%s\">%s</a>)",
d81 14
a94 4
		 LYVersionDate(),
		 (LYVersionIsRelease() ? LYNX_WWW_HOME     : LYNX_WWW_DIST),
		 LYVersionStatus());

d100 1
a100 1
	char *temp;
d105 4
a108 1
	temp = HTfullURL_toFile(doc->address);
a109 2
	FREE(temp);

d112 3
a114 1
	temp = HTfullURL_toFile(links[doc->link].lname);
d117 1
a117 1
	    CTRACE((tfp, "lstat(%s) failed, errno=%d\n", temp, errno));
d145 1
a145 1
		    sprintf(buf, "%.1024s", gettext("Unable to follow link"));
d152 1
a152 1
		fprintf(fp0, "   <em>%s</em>  %s\n", gettext("Name of owner:"), name);
d164 1
a164 1
	    fprintf(fp0, "   <em>%s</em>  %s", gettext("Creation date:"), cp);
d167 1
a167 1
	    fprintf(fp0, "   <em>%s</em>  %s", gettext("Last modified:"), cp);
d170 1
a170 1
	    fprintf(fp0, "   <em>%s</em>  %s\n", gettext("Last accessed:"), cp);
a231 1
	FREE(temp);
d239 1
a239 1
    LYformTitle(&Title, doc->title);
d243 1
a243 4
		 Title,
		 ((doc->isHEAD &&
		   !strstr(Title, " (HEAD)") &&
		   !strstr(Title, " - HEAD")) ? " (HEAD)" : ""));
d257 1
a257 1
      if (!p_in || isEmpty(p_in->MIMEname) ||
d301 2
a302 4
	fprintf(fp0, "<dt><em>%s</em> <xmp>%.*s</xmp>\n",
		gettext("Post Data:"),
		BStrLen(doc->post_data),
		BStrData(doc->post_data));
d325 1
a325 1
		 (doc->internal_link ? gettext(", via internal link") : "")
d345 1
a345 1
	StrAllocCopy(Title, LYGetHiliteStr(doc->link, 0));
d352 3
a354 3
	    if (links[doc->link].l_form->submit_method) {
		int method = links[doc->link].l_form->submit_method;
		char *enctype = links[doc->link].l_form->submit_enctype;
d367 2
a368 2
	    if (links[doc->link].l_form->submit_action) {
		StrAllocCopy(Address, links[doc->link].l_form->submit_action);
d372 2
a373 2
	    if (!(links[doc->link].l_form->submit_method &&
		  links[doc->link].l_form->submit_action)) {
d396 1
a396 1
    LYrefresh();
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d37 1
a37 1
BOOL LYVersionIsRelease (void)
d42 1
a42 1
char *LYVersionStatus (void)
d51 1
a51 1
char *LYVersionDate (void)
d63 5
a67 5
int LYShowInfo (
	DocInfo *	doc,
	int		size_of_file,
	DocInfo *	newdoc,
	char * 	owner_address)
d74 1
a74 1
    const char *cp;
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d37 1
a37 1
BOOL LYVersionIsRelease(void)
d39 1
a39 1
    return (BOOL) (strstr(LYNX_VERSION, "rel") != 0);
d42 1
a42 1
char *LYVersionStatus(void)
d51 1
a51 1
char *LYVersionDate(void)
d53 1
a53 2
    static char temp[LYNX_DATE_LEN + 1];

d59 2
a60 2
 * LYShowInfo prints a page of info about the current file and the link that
 * the cursor is on.
d62 6
a67 4
int LYShowInfo(DocInfo *doc,
	       int size_of_file,
	       DocInfo *newdoc,
	       char *owner_address)
a74 1

d90 1
a90 1
	return (-1);
d94 1
a94 1
     * Point the address pointer at this Url
d102 1
a102 1
	char *last_slash = strrchr(links[doc->link].lname, '/');
d113 1
a113 1
	    SHOWINFO_TITLE);
d116 6
a121 4
	    LYNX_NAME, LYNX_VERSION,
	    LYVersionDate(),
	    (LYVersionIsRelease()? LYNX_WWW_HOME : LYNX_WWW_DIST),
	    LYVersionStatus());
a122 1
    fprintf(fp0, "</h1>\n");	/* don't forget to close <h1> */
d129 1
a129 2
	fprintf(fp0, "\n%s\n\n",
		gettext("Directory that you are currently viewing"));
a143 1

d165 1
a165 1
		if ((buf_size = readlink(temp, buf, sizeof(buf) - 1)) != -1) {
d170 1
a170 2
		fprintf(fp0, "  <em>%s</em>  %s\n",
			gettext("Points to file:"), buf);
d175 2
a176 3
		fprintf(fp0, "   <em>%s</em>  %s\n",
			gettext("Name of owner:"), name);
	    name = HTAA_GidToName(dir_info.st_gid);
d178 1
a178 2
		fprintf(fp0, "      <em>%s</em>  %s\n",
			gettext("Group name:"), name);
d181 1
a181 1
			gettext("File size:"), (long) dir_info.st_size);
d184 1
a184 1
	     * Include date and time information.
d198 1
a198 1
	    modes[1] = '\0';	/* In case there are no permissions */
d213 1
a213 1
	    fprintf(fp0, "%s\n", (char *) &modes[2]);	/* Skip leading ', ' */
d217 1
a217 1
	    modes[1] = '\0';	/* In case there are no permissions */
d232 1
a232 1
	    fprintf(fp0, "%s\n", (char *) &modes[2]);	/* Skip leading ', ' */
d236 1
a236 1
	    modes[1] = '\0';	/* In case there are no permissions */
d253 1
a253 1
	    fprintf(fp0, "%s\n", (char *) &modes[2]);	/* Skip leading ', ' */
d256 1
a256 1
	fprintf(fp0, "</pre>\n");
d260 2
a261 2
	fprintf(fp0, "<h2>%s</h2>\n<dl compact>",
		gettext("File that you are currently viewing"));
d263 32
a294 8
	LYformTitle(&Title, doc->title);
	LYEntify(&Title, TRUE);
	fprintf(fp0, "<dt><em>%s</em> %s%s\n",
		gettext("Linkname:"),
		Title,
		((doc->isHEAD &&
		  !strstr(Title, " (HEAD)") &&
		  !strstr(Title, " - HEAD")) ? " (HEAD)" : ""));
d296 2
a297 4
	StrAllocCopy(Address, doc->address);
	LYEntify(&Address, TRUE);
	fprintf(fp0,
		"<dt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>URL:</em> %s\n", Address);
d299 2
a300 7
	if (HTLoadedDocumentCharset()) {
	    fprintf(fp0, "<dt><em>&nbsp;%s</em> %s\n",
		    gettext("Charset:"),
		    HTLoadedDocumentCharset());
	} else {
	    LYUCcharset *p_in = HTAnchor_getUCInfoStage(HTMainAnchor,
							UCT_STAGE_PARSER);
d302 2
a303 22
	    if (!p_in || isEmpty(p_in->MIMEname) ||
		HTAnchor_getUCLYhndl(HTMainAnchor, UCT_STAGE_PARSER) < 0) {
		p_in = HTAnchor_getUCInfoStage(HTMainAnchor, UCT_STAGE_MIME);
	    }
	    if (p_in && p_in->MIMEname && *(p_in->MIMEname) &&
		HTAnchor_getUCLYhndl(HTMainAnchor, UCT_STAGE_MIME) >= 0) {
		fprintf(fp0, "<dt><em>&nbsp;%s</em> %s (assumed)\n",
			gettext("Charset:"),
			p_in->MIMEname);
	    }
	}

	if ((cp = HText_getServer()) != NULL && *cp != '\0')
	    fprintf(fp0, "<dt><em>&nbsp;&nbsp;%s</em> %s\n",
		    gettext("Server:"), cp);

	if ((cp = HText_getDate()) != NULL && *cp != '\0')
	    fprintf(fp0, "<dt><em>&nbsp;&nbsp;&nbsp;&nbsp;%s</em> %s\n",
		    gettext("Date:"), cp);

	if ((cp = HText_getLastModified()) != NULL && *cp != '\0')
	    fprintf(fp0, "<dt><em>%s</em> %s\n", gettext("Last Mod:"), cp);
d306 17
a322 18
	if (LYInfoAdvanced) {
	    if (HTMainAnchor && HTMainAnchor->expires) {
		fprintf(fp0, "<dt><em>%s</em> %s\n",
			gettext("&nbsp;Expires:"), HTMainAnchor->expires);
	    }
	    if (HTMainAnchor && HTMainAnchor->cache_control) {
		fprintf(fp0, "<dt><em>%s</em> %s\n",
			gettext("Cache-Control:"), HTMainAnchor->cache_control);
	    }
	    if (HTMainAnchor && HTMainAnchor->content_length > 0) {
		fprintf(fp0, "<dt><em>%s</em> %d %s\n",
			gettext("Content-Length:"),
			HTMainAnchor->content_length, gettext("bytes"));
	    }
	    if (HTMainAnchor && HTMainAnchor->content_language) {
		fprintf(fp0, "<dt><em>%s</em> %s\n",
			gettext("Language:"), HTMainAnchor->content_language);
	    }
d324 1
d327 8
a334 8
	if (doc->post_data) {
	    fprintf(fp0, "<dt><em>%s</em> <xmp>%.*s</xmp>\n",
		    gettext("Post Data:"),
		    BStrLen(doc->post_data),
		    BStrData(doc->post_data));
	    fprintf(fp0, "<dt><em>%s</em> %s\n",
		    gettext("Post Content Type:"), doc->post_content_type);
	}
d336 7
a342 7
	if (owner_address) {
	    StrAllocCopy(Address, owner_address);
	    LYEntify(&Address, TRUE);
	} else {
	    StrAllocCopy(Address, NO_NOTHING);
	}
	fprintf(fp0, "<dt><em>%s</em> %s\n", gettext("Owner(s):"), Address);
d344 2
a345 2
	fprintf(fp0, "<dt>&nbsp;&nbsp;&nbsp;&nbsp;<em>%s</em> %d %s\n",
		gettext("size:"), size_of_file, gettext("lines"));
d347 8
a354 9
	fprintf(fp0, "<dt>&nbsp;&nbsp;&nbsp;&nbsp;<em>%s</em> %s%s%s",
		gettext("mode:"),
		((lynx_mode == FORMS_LYNX_MODE)
		 ? gettext("forms mode")
		 : (HTisDocumentSource()
		    ? gettext("source")
		    : gettext("normal"))),
		(doc->safe ? gettext(", safe") : ""),
		(doc->internal_link ? gettext(", via internal link") : "")
d357 10
a366 10
	if (LYInfoAdvanced) {
	    fprintf(fp0, "%s%s%s\n",
		    (HText_hasNoCacheSet(HTMainText) ?
		     gettext(", no-cache") : ""),
		    (HTAnchor_isISMAPScript((HTAnchor *) HTMainAnchor) ?
		     gettext(", ISMAP script") : ""),
		    (doc->bookmark ?
		     gettext(", bookmark file") : "")
		);
	}
d369 1
a369 1
	fprintf(fp0, "\n</dl>\n");	/* end of list */
d371 38
a408 34
	if (nlinks > 0) {
	    fprintf(fp0, "<h2>%s</h2>\n<dl compact>",
		    gettext("Link that you currently have selected"));
	    StrAllocCopy(Title, LYGetHiliteStr(doc->link, 0));
	    LYEntify(&Title, TRUE);
	    fprintf(fp0, "<dt><em>%s</em> %s\n",
		    gettext("Linkname:"),
		    Title);
	    if (lynx_mode == FORMS_LYNX_MODE &&
		links[doc->link].type == WWW_FORM_LINK_TYPE) {
		if (links[doc->link].l_form->submit_method) {
		    int method = links[doc->link].l_form->submit_method;
		    char *enctype = links[doc->link].l_form->submit_enctype;

		    fprintf(fp0, "<dt>&nbsp;&nbsp;<em>%s</em> %s\n",
			    gettext("Method:"),
			    ((method == URL_POST_METHOD) ? "POST" :
			     ((method == URL_MAIL_METHOD) ? "(email)" :
			      "GET")));
		    fprintf(fp0, "<dt>&nbsp;<em>%s</em> %s\n",
			    gettext("Enctype:"),
			    (enctype &&
			     *enctype ?
			     enctype : "application/x-www-form-urlencoded"));
		}
		if (links[doc->link].l_form->submit_action) {
		    StrAllocCopy(Address, links[doc->link].l_form->submit_action);
		    LYEntify(&Address, TRUE);
		    fprintf(fp0, "<dt>&nbsp;&nbsp;<em>Action:</em> %s\n", Address);
		}
		if (!(links[doc->link].l_form->submit_method &&
		      links[doc->link].l_form->submit_action)) {
		    fprintf(fp0, "<dt>&nbsp;%s\n", gettext("(Form field)"));
		}
d410 1
a410 8
		if (links[doc->link].lname) {
		    StrAllocCopy(Title, links[doc->link].lname);
		    LYEntify(&Title, TRUE);
		} else {
		    StrAllocCopy(Title, "");
		}
		fprintf(fp0,
			"<dt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>URL:</em> %s\n", Title);
d412 4
a415 1
	    fprintf(fp0, "</dl>\n");	/* end of list */
d417 2
a418 9
	} else
	    fprintf(fp0, "<h2>%s</h2>", gettext("No Links on the current page"));

#ifdef EXP_HTTP_HEADERS
	if ((cp = HText_getHttpHeaders()) != 0) {
	    fprintf(fp0, "<h2>%s</h2>", gettext("Server Headers:"));
	    fprintf(fp0, "<pre>%s</pre>", cp);
	}
#endif
d431 1
a431 1
    return (0);
@


1.1.3.4
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@a26 8
#define BEGIN_DL(text) fprintf(fp0, "<h2>%s</h2>\n<dl compact>", text)
#define END_DL()       fprintf(fp0, "\n</dl>\n")

#define ADD_SS(label,value)       dt_String(fp0, label, value)
#define ADD_NN(label,value,units) dt_Number(fp0, label, value, units)

static int label_columns;

a58 39
static void dt_String(FILE *fp,
		      const char *label,
		      const char *value)
{
    int have;
    int need;
    char *the_label = 0;
    char *the_value = 0;

    StrAllocCopy(the_label, label);
    StrAllocCopy(the_value, value);

    have = strlen(the_label);
    need = LYstrExtent(the_label, have, label_columns);

    LYEntify(&the_label, TRUE);
    LYEntify(&the_value, TRUE);

    fprintf(fp, "<dt>");
    while (need++ < label_columns)
	fprintf(fp, "&nbsp;");
    fprintf(fp, "<em>%s</em> %s\n", the_label, the_value);

    FREE(the_label);
    FREE(the_value);
}

static void dt_Number(FILE *fp0,
		      const char *label,
		      long number,
		      const char *units)
{
    char *value = NULL;

    HTSprintf(&value, "%ld %s", number, units);
    ADD_SS(label, value);
    FREE(value);
}

d71 1
a71 1
    char *Title = NULL;
a73 1
    char *temp = 0;
d110 4
a113 3
    label_columns = 9;

    WriteInternalTitle(fp0, SHOWINFO_TITLE);
d125 1
d127 3
a129 1
	BEGIN_DL(gettext("Directory that you are currently viewing"));
d132 1
a132 1
	ADD_SS(gettext("Name:"), temp);
d135 1
a135 3
	ADD_SS(gettext("URL:"), doc->address);

	END_DL();
a144 1
	    label_columns = 16;
d146 2
a147 1
		BEGIN_DL(gettext("Directory that you have currently selected"));
d149 2
a150 1
		BEGIN_DL(gettext("File that you have currently selected"));
d153 2
a154 1
		BEGIN_DL(gettext("Symbolic link that you have currently selected"));
d157 2
a158 1
		BEGIN_DL(gettext("Item that you have currently selected"));
d160 1
a160 1
	    ADD_SS(gettext("Full name:"), temp);
d171 2
a172 1
		ADD_SS(gettext("Points to file:"), buf);
d177 2
a178 1
		ADD_SS(gettext("Name of owner:"), name);
d181 2
a182 1
		ADD_SS(gettext("Group name:"), name);
d184 2
a185 3
		ADD_NN(gettext("File size:"),
		       (long) dir_info.st_size,
		       gettext("(bytes)"));
d190 2
a191 2
	    ADD_SS(gettext("Creation date:"),
		   ctime(&dir_info.st_ctime));
d193 2
a194 2
	    ADD_SS(gettext("Last modified:"),
		   ctime(&dir_info.st_mtime));
d196 2
a197 2
	    ADD_SS(gettext("Last accessed:"),
		   ctime(&dir_info.st_atime));
d199 2
a200 4
	    END_DL();

	    label_columns = 9;
	    BEGIN_DL(gettext("Access Permissions"));
d217 1
a217 1
	    ADD_SS(gettext("Owner:"), &modes[2]);
d219 1
d236 1
a236 1
	    ADD_SS(gettext("Group:"), &modes[2]);
d238 1
d257 1
a257 2
	    ADD_SS(gettext("World:"), &modes[2]);
	    END_DL();
d260 1
d264 2
a265 1
	BEGIN_DL(gettext("File that you are currently viewing"));
d268 12
a279 9
	HTSprintf(&temp, "%s%s",
		  Title,
		  ((doc->isHEAD &&
		    !strstr(Title, " (HEAD)") &&
		    !strstr(Title, " - HEAD")) ? " (HEAD)" : ""));
	ADD_SS(gettext("Linkname:"), temp);
	FREE(temp);

	ADD_SS("URL:", doc->address);
d282 3
a284 2
	    ADD_SS(gettext("Charset:"),
		   HTLoadedDocumentCharset());
d295 3
a297 5
		HTSprintf(&temp, "%s %s",
			  p_in->MIMEname,
			  gettext("(assumed)"));
		ADD_SS(gettext("Charset:"), p_in->MIMEname);
		FREE(temp);
d302 2
a303 1
	    ADD_SS(gettext("Server:"), cp);
d306 2
a307 1
	    ADD_SS(gettext("Date:"), cp);
d310 1
a310 1
	    ADD_SS(gettext("Last Mod:"), cp);
d315 2
a316 1
		ADD_SS(gettext("Expires:"), HTMainAnchor->expires);
d319 2
a320 1
		ADD_SS(gettext("Cache-Control:"), HTMainAnchor->cache_control);
d323 3
a325 3
		ADD_NN(gettext("Content-Length:"),
		       HTMainAnchor->content_length,
		       gettext("bytes"));
d328 2
a329 1
		ADD_SS(gettext("Language:"), HTMainAnchor->content_language);
d339 9
a347 1
	    ADD_SS(gettext("Post Content Type:"), doc->post_content_type);
d349 1
d351 2
a352 19
	ADD_SS(gettext("Owner(s):"),
	       (owner_address
		? owner_address
		: NO_NOTHING));

	ADD_NN(gettext("size:"),
	       size_of_file,
	       gettext("lines"));

	StrAllocCopy(temp,
		     ((lynx_mode == FORMS_LYNX_MODE)
		      ? gettext("forms mode")
		      : (HTisDocumentSource()
			 ? gettext("source")
			 : gettext("normal"))));
	if (doc->safe)
	    StrAllocCat(temp, gettext(", safe"));
	if (doc->internal_link)
	    StrAllocCat(temp, gettext(", via internal link"));
d354 10
d366 8
a373 6
	    if (HText_hasNoCacheSet(HTMainText))
		StrAllocCat(temp, gettext(", no-cache"));
	    if (HTAnchor_isISMAPScript((HTAnchor *) HTMainAnchor))
		StrAllocCat(temp, gettext(", ISMAP script"));
	    if (doc->bookmark)
		StrAllocCat(temp, gettext(", bookmark file"));
d377 1
a377 4
	ADD_SS(gettext("mode:"), temp);
	FREE(temp);

	END_DL();
d380 7
a386 3
	    BEGIN_DL(gettext("Link that you currently have selected"));
	    ADD_SS(gettext("Linkname:"),
		   LYGetHiliteStr(doc->link, 0));
d393 10
a402 8
		    ADD_SS(gettext("Method:"),
			   ((method == URL_POST_METHOD) ? "POST" :
			    ((method == URL_MAIL_METHOD) ? "(email)" :
			     "GET")));
		    ADD_SS(gettext("Enctype:"),
			   (non_empty(enctype)
			    ? enctype
			    : "application/x-www-form-urlencoded"));
d405 3
a407 2
		    ADD_SS(gettext("Action:"),
			   links[doc->link].l_form->submit_action);
d414 8
a421 4
		ADD_SS("URL:",
		       (links[doc->link].lname
			? links[doc->link].lname
			: ""));
d423 1
a423 1
	    END_DL();
d425 1
a425 1
	} else {
a426 1
	}
d443 1
@


1.1.3.5
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d329 1
a329 1
	    if (p_in && non_empty(p_in->MIMEname) &&
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a13 2
#include <LYCharSets.h>
#include <LYStrings.h>
d26 1
a26 32
 * LYNX_VERSION and LYNX_DATE are automatically generated by PRCS, the tool
 * which we use to archive versions of Lynx.  We use a convention for naming
 * the successive versions:
 *	{release}{status}{patch}
 * where
 *	{release} is the release that we are working on, e.g., 2.8.4
 *	{status} is one of "dev", "pre" or "rel", and
 *	{patch} is a number assigned by PRCS.
 */
PUBLIC BOOL LYVersionIsRelease NOARGS
{
    return (BOOL)(strstr(LYNX_VERSION, "rel") != 0);
}

PUBLIC char *LYVersionStatus NOARGS
{
    if (LYVersionIsRelease())
	return REL_VERSION;
    else if (strstr(LYNX_VERSION, "pre") != 0)
	return PRE_VERSION;
    return DEV_VERSION;
}

PUBLIC char *LYVersionDate NOARGS
{
    static char temp[LYNX_DATE_LEN+1];
    LYstrncpy(temp, &LYNX_DATE[LYNX_DATE_OFF], LYNX_DATE_LEN);
    return temp;
}

/*
 *  LYShowInfo prints a page of info about the current file and the link
d30 1
a30 1
PUBLIC int LYShowInfo ARGS4(
d36 1
a36 1
    static char tempfile[LY_MAXPATH] = "\0";
d43 1
a43 1
    BOOLEAN LYInfoAdvanced = (BOOL) (user_mode == ADVANCED_MODE);
d45 1
d47 1
d51 2
a52 7
    if (LYReuseTempfiles) {
	fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
    } else {
	LYRemoveTemp(tempfile);
	fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
    }
    if (fp0 == NULL) {
d79 1
a79 1
    fprintf(fp0, "<h1>%s %s (%s) (<a href=\"%s\">%s</a>)",
d81 14
a94 4
		 LYVersionDate(),
		 (LYVersionIsRelease() ? LYNX_WWW_HOME     : LYNX_WWW_DIST),
		 LYVersionStatus());

d100 1
a100 1
	char *temp;
d105 4
a108 1
	temp = HTfullURL_toFile(doc->address);
a109 2
	FREE(temp);

d112 3
a114 1
	temp = HTfullURL_toFile(links[doc->link].lname);
d117 1
a117 1
	    CTRACE((tfp, "lstat(%s) failed, errno=%d\n", temp, errno));
d145 1
a145 1
		    sprintf(buf, "%.1024s", gettext("Unable to follow link"));
d152 1
a152 1
		fprintf(fp0, "   <em>%s</em>  %s\n", gettext("Name of owner:"), name);
d164 1
a164 1
	    fprintf(fp0, "   <em>%s</em>  %s", gettext("Creation date:"), cp);
d167 1
a167 1
	    fprintf(fp0, "   <em>%s</em>  %s", gettext("Last modified:"), cp);
d170 1
a170 1
	    fprintf(fp0, "   <em>%s</em>  %s\n", gettext("Last accessed:"), cp);
a231 1
	FREE(temp);
d239 1
a239 1
    LYformTitle(&Title, doc->title);
d243 1
a243 4
		 Title,
		 ((doc->isHEAD &&
		   !strstr(Title, " (HEAD)") &&
		   !strstr(Title, " - HEAD")) ? " (HEAD)" : ""));
d325 1
a325 1
		 (doc->internal_link ? gettext(", via internal link") : "")
d396 1
a396 1
    LYrefresh();
@

