head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.7
	tg-mergefixes-1-branch:1.1.3.7.0.4
	tg-mergefixes-1-base:1.1.3.7
	MIROS_X:1.1.3.7.0.2
	MIROS_X_BASE:1.1.3.7
	MIRBSD_XP_MIRPPC:1.1.3.5.0.4
	lynx-2_8_6dev_7b:1.1.3.7
	lynx-2_8_6dev_6:1.1.3.6
	MIRBSD_XP_SPARC_BASE:1.1.3.5
	MIRBSD_XP_SPARC:1.1.3.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2005.01.03.00.45.58;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.56.15;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.35;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.32;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.24;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.01;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.19;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.41;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.02.08.13.11.00;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.16.00;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.52.42;	author tg;	state Stab;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.11.20.16.25;	author tg;	state Exp;
branches;
next	1.1.3.7;

1.1.3.7
date	2004.10.20.10.10.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@soft merge
@
text
@/*
 *  Routines to manipulate the local filesystem.
 *  Written by: Rick Mallett, Carleton University
 *  Report problems to rmallett@@ccs.carleton.ca
 *  Modified 18-Dec-95 David Trueman (david@@cs.dal.ca):
 *	Added OK_PERMIT compilation option.
 *	Support replacement of compiled-in f)ull menu configuration via
 *	  DIRED_MENU definitions in lynx.cfg, so that more than one menu
 *	  can be driven by the same executable.
 *  Modified Oct-96 Klaus Weide (kweide@@tezcat.com):
 *	Changed to use the library's HTList_* functions and macros for
 *	  managing the list of tagged file URLs.
 *	Keep track of proper level of URL escaping, so that unusual filenames
 *	  which contain #% etc. are handled properly (some HTUnEscapeSome()'s
 *	  left in to be conservative, and to document where superfluous
 *	  unescaping took place before).
 *	Dynamic memory instead of fixed length buffers in a few cases.
 *	Other minor changes to make things work as intended.
 *  Modified Jun-97 Klaus Weide (kweide@@tezcat.com) & FM:
 *	Modified the code handling DIRED_MENU to do more careful
 *	  checking of the selected file.  In addition to "TAG", "FILE", and
 *	  "DIR", DIRED_MENU definitions in lynx.cfg now also recognize LINK as
 *	  a type.  DIRED_MENU definitions with a type field of "LINK" are only
 *	  used if the current selection is a symbolic link ("FILE" and "DIR"
 *	  definitions are not used in that case).  The default menu
 *	  definitions have been updated to reflect this change, and to avoid
 *	  the showing of menu items whose action would always fail - KW
 *	Cast all code into the Lynx programming style. - FM
 */

#include <HTUtils.h>
#include <HTAAProt.h>
#include <HTFile.h>
#include <HTAlert.h>
#include <HTParse.h>
#include <LYCurses.h>
#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <LYStrings.h>
#include <LYCharUtils.h>
#include <LYStructs.h>
#include <LYHistory.h>
#include <LYUpload.h>
#include <LYLocal.h>
#include <LYClean.h>
#include <www_wait.h>

#ifdef SUPPORT_CHDIR
#include <LYMainLoop.h>
#endif

#include <LYLeaks.h>

#undef USE_COMPRESS

#ifdef __DJGPP__
#define EXT_TAR_GZ ".tgz"
#define EXT_TAR_Z  ".taz"
#define EXT_Z      ".z"
#else
#define EXT_TAR_GZ ".tar.gz"
#define EXT_TAR_Z  ".tar.Z"
#define EXT_Z      ".Z"
#endif

#ifndef DIRED_MAXBUF
#define DIRED_MAXBUF 512
#endif

#ifdef DIRED_SUPPORT

#ifdef OK_INSTALL
#ifdef FNAMES_8_3
#define INSTALLDIRS_FILE "instdirs.htm"
#else
#define INSTALLDIRS_FILE ".installdirs.html"
#endif /* FNAMES_8_3 */
#endif /* OK_INSTALL */

static char *get_filename(const char *prompt,
			  char *buf,
			  size_t bufsize);

#ifdef OK_PERMIT
static int permit_location(char *destpath,
			   char *srcpath,
			   char **newpath);
#endif /* OK_PERMIT */
/* *INDENT-OFF* */
static char *render_item ( const char *	s,
	const char *	path,
	const char *	dir,
	char *		buf,
	int		bufsize,
	BOOLEAN		url_syntax);

struct dired_menu {
    int cond;
#define DE_TAG     1
#define DE_DIR     2
#define DE_FILE    3
#define DE_SYMLINK 4
    char *sfx;
    char *link;
    char *rest;
    char *href;
    struct dired_menu *next;
};

static struct dired_menu *menu_head = NULL;
static struct dired_menu defmenu[] = {

/*
 * The following initializations determine the contents of the f)ull menu
 * selection when in dired mode.  If any menu entries are defined in the
 * configuration file via DIRED_MENU lines, then these default entries are
 * discarded entirely.
 */
#ifdef SUPPORT_CHDIR
{ 0,		      "", "Change directory",
		      "", "LYNXDIRED://CHDIR",			NULL },
#endif
{ 0,		      "", "New File",
"(in current directory)", "LYNXDIRED://NEW_FILE%d",		NULL },

{ 0,		      "", "New Directory",
"(in current directory)", "LYNXDIRED://NEW_FOLDER%d",		NULL },

#ifdef OK_INSTALL
{ DE_FILE,	      "", "Install",
"selected file to new location", "LYNXDIRED://INSTALL_SRC%p",	NULL },
/* The following (installing a directory) doesn't work for me, at least
   with the "install" from GNU fileutils 4.0.  I leave it in anyway, in
   case one compiles with INSTALL_PATH / INSTALL_ARGS defined to some
   other command for which it works (like a script, or maybe "cp -a"). - kw
*/
{ DE_DIR,	      "", "Install",
"selected directory to new location", "LYNXDIRED://INSTALL_SRC%p",	NULL },
#endif /* OK_INSTALL */

{ DE_FILE,	      "", "Modify File Name",
"(of current selection)", "LYNXDIRED://MODIFY_NAME%p",		NULL },
{ DE_DIR,	      "", "Modify Directory Name",
"(of current selection)", "LYNXDIRED://MODIFY_NAME%p",		NULL },
#ifdef S_IFLNK
{ DE_SYMLINK,	      "", "Modify Name",
"(of selected symbolic link)", "LYNXDIRED://MODIFY_NAME%p",	NULL },
#endif  /* S_IFLNK */

#ifdef OK_PERMIT
{ DE_FILE,	      "", "Modify File Permissions",
"(of current selection)", "LYNXDIRED://PERMIT_SRC%p",		NULL },
{ DE_DIR,	      "", "Modify Directory Permissions",
"(of current selection)", "LYNXDIRED://PERMIT_SRC%p",		NULL },
#endif /* OK_PERMIT */

{ DE_FILE,	      "", "Change Location",
"(of selected file)"	, "LYNXDIRED://MODIFY_LOCATION%p",	NULL },
{ DE_DIR,	      "", "Change Location",
"(of selected directory)", "LYNXDIRED://MODIFY_LOCATION%p",	NULL },
#ifdef S_IFLNK
{ DE_SYMLINK,	      "", "Change Location",
"(of selected symbolic link)", "LYNXDIRED://MODIFY_LOCATION%p", NULL },
#endif /* S_IFLNK */

{ DE_FILE,	      "", "Remove File",
   "(current selection)", "LYNXDIRED://REMOVE_SINGLE%p",	NULL },
{ DE_DIR,	      "", "Remove Directory",
   "(current selection)", "LYNXDIRED://REMOVE_SINGLE%p",	NULL },
#ifdef S_IFLNK
{ DE_SYMLINK,	      "", "Remove Symbolic Link",
   "(current selection)", "LYNXDIRED://REMOVE_SINGLE%p",	NULL },
#endif /* S_IFLNK */

#if defined(OK_UUDECODE) && !defined(ARCHIVE_ONLY)
{ DE_FILE,	      "", "UUDecode",
   "(current selection)", "LYNXDIRED://UUDECODE%p",		NULL },
#endif /* OK_UUDECODE && !ARCHIVE_ONLY */

#if defined(OK_TAR) && !defined(ARCHIVE_ONLY)
{ DE_FILE,	EXT_TAR_Z, "Expand",
   "(current selection)", "LYNXDIRED://UNTAR_Z%p",		NULL },
#endif /* OK_TAR && !ARCHIVE_ONLY */

#if defined(OK_TAR) && defined(OK_GZIP) && !defined(ARCHIVE_ONLY)
{ DE_FILE,     ".tar.gz", "Expand",
   "(current selection)", "LYNXDIRED://UNTAR_GZ%p",		NULL },

{ DE_FILE,	  ".tgz", "Expand",
   "(current selection)", "LYNXDIRED://UNTAR_GZ%p",		NULL },
#endif /* OK_TAR && OK_GZIP && !ARCHIVE_ONLY */

#ifndef ARCHIVE_ONLY
{ DE_FILE,	   EXT_Z, "Uncompress",
   "(current selection)", "LYNXDIRED://DECOMPRESS%p",		NULL },
#endif /* ARCHIVE_ONLY */

#if defined(OK_GZIP) && !defined(ARCHIVE_ONLY)
{ DE_FILE,	   ".gz", "Uncompress",
   "(current selection)", "LYNXDIRED://UNGZIP%p",		NULL },
#endif /* OK_GZIP && !ARCHIVE_ONLY */

#if defined(OK_ZIP) && !defined(ARCHIVE_ONLY)
{ DE_FILE,	  ".zip", "Uncompress",
   "(current selection)", "LYNXDIRED://UNZIP%p",		NULL },
#endif /* OK_ZIP && !ARCHIVE_ONLY */

#if defined(OK_TAR) && !defined(ARCHIVE_ONLY)
{ DE_FILE,	  ".tar", "UnTar",
   "(current selection)", "LYNXDIRED://UNTAR%p",		NULL },
#endif /* OK_TAR && !ARCHIVE_ONLY */

#ifdef OK_TAR
{ DE_DIR,	      "", "Tar",
   "(current selection)", "LYNXDIRED://TAR%p",			NULL },
#endif /* OK_TAR */

#if defined(OK_TAR) && defined(OK_GZIP)
{ DE_DIR,	      "", "Tar and compress",
      "(using GNU gzip)", "LYNXDIRED://TAR_GZ%p",		NULL },
#endif /* OK_TAR && OK_GZIP */

#if defined(OK_TAR) && defined(USE_COMPRESS)
{ DE_DIR,	      "", "Tar and compress",
      "(using compress)", "LYNXDIRED://TAR_Z%p",		NULL },
#endif /* OK_TAR && USE_COMPRESS */

#ifdef OK_ZIP
{ DE_DIR,	      "", "Package and compress",
	   "(using zip)", "LYNXDIRED://ZIP%p",			NULL },
#endif /* OK_ZIP */

{ DE_FILE,	      "", "Compress",
 "(using Unix compress)", "LYNXDIRED://COMPRESS%p",		NULL },

#ifdef OK_GZIP
{ DE_FILE,	      "", "Compress",
	  "(using gzip)", "LYNXDIRED://GZIP%p",			NULL },
#endif /* OK_GZIP */

#ifdef OK_ZIP
{ DE_FILE,	      "", "Compress",
	   "(using zip)", "LYNXDIRED://ZIP%p",			NULL },
#endif /* OK_ZIP */

{ DE_TAG,	      "", "Move all tagged items to another location.",
		      "", "LYNXDIRED://MOVE_TAGGED%d",		NULL },

#ifdef OK_INSTALL
{ DE_TAG,	      "", "Install tagged files into another directory.",
		      "", "LYNXDIRED://INSTALL_SRC%00",		NULL },
#endif

{ DE_TAG,	      "", "Remove all tagged files and directories.",
		      "", "LYNXDIRED://REMOVE_TAGGED",		NULL },

{ DE_TAG,	      "", "Untag all tagged files and directories.",
		      "", "LYNXDIRED://CLEAR_TAGGED",		NULL },

{ 0,		    NULL, NULL,
		    NULL, NULL,					NULL }
};
/* *INDENT-ON* */

static BOOLEAN cannot_stat(const char *name)
{
    char *tmpbuf = 0;

    HTSprintf0(&tmpbuf, gettext("Unable to get status of '%s'."), name);
    HTAlert(tmpbuf);
    FREE(tmpbuf);
    return FALSE;
}

#define OK_STAT(name, sb) (stat(name, sb) == 0)

static BOOLEAN ok_stat(const char *name, struct stat *sb)
{
    CTRACE((tfp, "testing ok_stat(%s)\n", name));
    if (!OK_STAT(name, sb)) {
	return cannot_stat(name);
    }
    return TRUE;
}

#ifdef HAVE_LSTAT
static BOOLEAN ok_lstat(char *name, struct stat *sb)
{
    CTRACE((tfp, "testing ok_lstat(%s)\n", name));
    if (lstat(name, sb) < 0) {
	return cannot_stat(name);
    }
    return TRUE;
}
#else
#define ok_lstat(name,sb) ok_stat(name,sb)
#endif

static BOOLEAN ok_file_or_dir(struct stat *sb)
{
    if (!S_ISDIR(sb->st_mode)
	&& !S_ISREG(sb->st_mode)) {
	HTAlert(gettext("The selected item is not a file or a directory!  Request ignored."));
	return FALSE;
    }
    return TRUE;
}

#ifdef OK_INSTALL		/* currently only used in local_install */
static BOOLEAN ok_localname(char *dst, const char *src)
{
    struct stat dir_info;

    if (!ok_stat(src, &dir_info)
	|| !ok_file_or_dir(&dir_info)) {
	return FALSE;
    }
    if (strlen(src) >= DIRED_MAXBUF) {
	CTRACE((tfp, "filename too long in ok_localname!\n"));
	return FALSE;
    }
    strcpy(dst, src);
    return TRUE;
}
#endif /* OK_INSTALL */

/*
 * Execute DIRED command, return -1 or 0 on failure, 1 success.
 */
static int LYExecv(const char *path,
		   char **argv,
		   char *msg)
{
    int rc = 0;

#if defined(VMS) || defined(_WINDOWS)
    CTRACE((tfp, "LYExecv:  Called inappropriately! (path=%s)\n", path));
#else
    int n;
    char *tmpbuf = 0;

#ifdef __DJGPP__
    stop_curses();
    HTSprintf0(&tmpbuf, "%s", path);
    for (n = 1; argv[n] != 0; n++)
	HTSprintf(&tmpbuf, " %s", argv[n]);
    HTSprintf(&tmpbuf, "\n");
    rc = LYSystem(tmpbuf) ? 0 : 1;
#else
    int pid;

#ifdef HAVE_TYPE_UNIONWAIT
    union wait wstatus;

#else
    int wstatus;
#endif

    if (TRACE) {
	CTRACE((tfp, "LYExecv path='%s'\n", path));
	for (n = 0; argv[n] != 0; n++)
	    CTRACE((tfp, "argv[%d] = '%s'\n", n, argv[n]));
    }

    rc = 1;			/* It will work */
    stop_curses();
    pid = fork();		/* fork and execute command */

    switch (pid) {
    case -1:
	HTSprintf0(&tmpbuf, gettext("Unable to %s due to system error!"), msg);
	rc = 0;
	break;			/* don't fall thru! - KW */

    case 0:			/* child */
#ifdef USE_EXECVP
	execvp(path, argv);	/* this uses our $PATH */
#else
	execv(path, argv);
#endif
	exit(EXIT_FAILURE);	/* execv failed, give wait() something to look at */
	/*NOTREACHED */

    default:			/* parent */
#if !HAVE_WAITPID
	while (wait(&wstatus) != pid) ;		/* do nothing */
#else
	while (-1 == waitpid(pid, &wstatus, 0)) {	/* wait for child */
#ifdef EINTR
	    if (errno == EINTR)
		continue;
#endif /* EINTR */
#ifdef ERESTARTSYS
	    if (errno == ERESTARTSYS)
		continue;
#endif /* ERESTARTSYS */
	    break;
	}
#endif /* !HAVE_WAITPID */
	if ((WIFEXITED(wstatus)
	     && (WEXITSTATUS(wstatus) != 0))
	    || (WIFSIGNALED(wstatus)
		&& (WTERMSIG(wstatus) > 0))) {	/* error return */
	    HTSprintf0(&tmpbuf,
		       gettext("Probable failure to %s due to system error!"),
		       msg);
	    rc = 0;
	}
    }
#endif /* __DJGPP__ */

    if (rc == 0) {
	/*
	 * Screen may have message from the failed execv'd command.  Give user
	 * time to look at it before screen refresh.
	 */
	LYSleepAlert();
    }
    start_curses();
    if (tmpbuf != 0) {
	if (rc == 0)
	    HTAlert(tmpbuf);
	FREE(tmpbuf);
    }
#endif /* VMS || _WINDOWS */
    return (rc);
}

static int make_directory(char *path)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppMKDIR)) != NULL) {
	char *args[5];
	char *msg = 0;

	HTSprintf0(&msg, "make directory %s", path);
	args[0] = "mkdir";
	args[1] = path;
	args[2] = (char *) 0;
	code = (LYExecv(program, args, msg) <= 0) ? -1 : 1;
	FREE(msg);
    } else {
#ifdef _WINDOWS
	code = mkdir(path) ? -1 : 1;
#else
	code = mkdir(path, 0777) ? -1 : 1;
#endif
    }
    return (code);
}

static int remove_file(char *path)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppRM)) != NULL) {
	char *args[5];
	char *tmpbuf = NULL;

	args[0] = "rm";
	args[1] = "-f";
	args[2] = path;
	args[3] = (char *) 0;
	HTSprintf0(&tmpbuf, gettext("remove %s"), path);
	code = LYExecv(program, args, tmpbuf);
	FREE(tmpbuf);
    } else {
	code = remove(path) ? -1 : 1;
    }
    return (code);
}

static int remove_directory(char *path)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppRMDIR)) != NULL) {
	char *args[5];
	char *tmpbuf = NULL;

	args[0] = "rmdir";
	args[1] = path;
	args[2] = (char *) 0;
	HTSprintf0(&tmpbuf, gettext("remove %s"), path);
	code = LYExecv(program, args, tmpbuf);
	FREE(tmpbuf);
    } else {
	code = rmdir(path) ? -1 : 1;
    }
    return (code);
}

static int touch_file(char *path)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppTOUCH)) != NULL) {
	char *args[5];
	char *msg = NULL;

	HTSprintf0(&msg, gettext("touch %s"), path);
	args[0] = "touch";
	args[1] = path;
	args[2] = (char *) 0;
	code = (LYExecv(program, args, msg) <= 0) ? -1 : 1;
	FREE(msg);
    } else {
	FILE *fp;

	if ((fp = fopen(path, "w")) != 0) {
	    fclose(fp);
	    code = 1;
	} else {
	    code = -1;
	}
    }
    return (code);
}

static int move_file(char *source, char *target)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppMV)) != NULL) {
	char *msg = 0;
	char *args[5];

	HTSprintf0(&msg, gettext("move %s to %s"), source, target);
	args[0] = "mv";
	args[1] = source;
	args[2] = target;
	args[3] = (char *) 0;
	code = (LYExecv(program, args, msg) <= 0) ? -1 : 1;
	FREE(msg);
    } else {
	struct stat sb;
	char *actual = 0;

	/* the caller sets up a target directory; we need a file path */
	if (stat(target, &sb) == 0
	    && S_ISDIR(sb.st_mode)) {
	    HTSprintf0(&actual, "%s/%s", target, LYPathLeaf(source));
	    CTRACE((tfp, "move_file source=%s, target=%s\n", source, target));
	    target = actual;
	}
	if ((code = rename(source, target)) != 0)
	    if ((code = LYCopyFile(source, target)) >= 0)
		code = remove(source);
	if (code == 0)
	    code = 1;
	if (actual != target) {
	    FREE(actual);
	}
    }
    return code;
}

static BOOLEAN not_already_exists(char *name)
{
    struct stat dir_info;

    if (!OK_STAT(name, &dir_info)) {
	if (errno != ENOENT) {
	    cannot_stat(name);
	} else {
	    return TRUE;
	}
    } else if (S_ISDIR(dir_info.st_mode)) {
	HTAlert(gettext("There is already a directory with that name!  Request ignored."));
    } else if (S_ISREG(dir_info.st_mode)) {
	HTAlert(gettext("There is already a file with that name!  Request ignored."));
    } else {
	HTAlert(gettext("The specified name is already in use!  Request ignored."));
    }
    return FALSE;
}

static BOOLEAN dir_has_same_owner(struct stat *info, int owner)
{
    if (S_ISDIR(info->st_mode)) {
	if ((int) info->st_uid == owner) {
	    return TRUE;
	} else {
	    HTAlert(gettext("Destination has different owner!  Request denied."));
	}
    } else {
	HTAlert(gettext("Destination is not a valid directory!  Request denied."));
    }
    return FALSE;
}

/*
 * Remove all tagged files and directories.
 */
static int remove_tagged(void)
{
    int ans;
    BOOL will_clear = TRUE;
    char *cp;
    char *tmpbuf = NULL;
    char *testpath = NULL;
    struct stat dir_info;
    int count;
    HTList *tag;

    if (HTList_isEmpty(tagged))	/* should never happen */
	return 0;

    ans = HTConfirm(gettext("Remove all tagged files and directories?"));

    count = 0;
    tag = tagged;
    while (ans == YES && (cp = (char *) HTList_nextObject(tag)) != NULL) {
	if (is_url(cp) == FILE_URL_TYPE) {	/* unnecessary check */
	    testpath = HTfullURL_toFile(cp);
	    LYTrimPathSep(testpath);
	    will_clear = TRUE;

	    /*
	     * Check the current status of the path to be deleted.
	     */
	    if (!ok_stat(testpath, &dir_info)) {
		will_clear = FALSE;
		break;
	    } else {
		if (remove_file(testpath) <= 0) {
		    if (count == 0)
			count = -1;
		    will_clear = FALSE;
		    break;
		}
		++count;
		FREE(testpath);
	    }
	}
    }
    FREE(testpath);
    FREE(tmpbuf);
    if (will_clear)
	clear_tags();
    return count;
}

/*
 * Move all tagged files and directories to a new location.  Input is current
 * directory.  The tests in this function can, at best, prevent some user
 * mistakes - anybody who relies on them for security is seriously misguided. 
 * If a user has enough permissions to move a file somewhere, the same uid with
 * Lynx & dired can do the same thing.
 */
static int modify_tagged(char *testpath)
{
    char *cp;
    dev_t dev;
    ino_t inode;
    int owner;
    char tmpbuf[1024];
    char *savepath;
    char *srcpath = NULL;
    struct stat dir_info;
    int count = 0;
    HTList *tag;

    if (HTList_isEmpty(tagged))	/* should never happen */
	return 0;

    _statusline(gettext("Enter new location for tagged items: "));

    tmpbuf[0] = '\0';
    LYgetstr(tmpbuf, VISIBLE, sizeof(tmpbuf), NORECALL);
    if (strlen(tmpbuf)) {
	/*
	 * Determine the ownership of the current location.
	 */
	/*
	 * This test used to always fail from the dired menu...  changed to
	 * something that hopefully makes more sense - KW
	 */
	if (non_empty(testpath) && 0 != strcmp(testpath, "/")) {
	    /*
	     * testpath passed in and is not empty and not a single "/" (which
	     * would probably be bogus) - use it.
	     */
	    cp = testpath;
	} else {
	    /*
	     * Prepare to get directory path from one of the tagged files.
	     */
	    cp = (char *) HTList_lastObject(tagged);
	    testpath = NULL;	/* Won't be needed any more in this function,
				   set to NULL as a flag. */
	}

	if (testpath == NULL) {
	    /*
	     * Get the directory containing the file or subdir.
	     */
	    if (cp) {
		cp = strip_trailing_slash(cp);
		cp = HTParse(".", cp, PARSE_PATH + PARSE_PUNCTUATION);
		savepath = HTURLPath_toFile(cp, TRUE, FALSE);
		FREE(cp);
	    } else {		/* Last resort, should never happen. */
		savepath = HTURLPath_toFile(".", TRUE, FALSE);
	    }
	} else {
	    if (!strncmp(cp, "file://localhost", 16)) {
		cp += 16;
	    } else if (isFILE_URL(cp)) {
		cp += LEN_FILE_URL;
	    }
	    savepath = HTURLPath_toFile(cp, TRUE, FALSE);
	}

	if (!ok_stat(savepath, &dir_info)) {
	    FREE(savepath);
	    return 0;
	}

	/*
	 * Save the owner of the current location for later use.  Also save the
	 * device and inode for location checking/
	 */
	dev = dir_info.st_dev;
	inode = dir_info.st_ino;
	owner = dir_info.st_uid;

	/*
	 * Replace ~/ references to the home directory.
	 */
	if (!strncmp(tmpbuf, "~/", 2)) {
	    char *cp1 = NULL;

	    StrAllocCopy(cp1, Home_Dir());
	    StrAllocCat(cp1, (tmpbuf + 1));
	    if (strlen(cp1) > (sizeof(tmpbuf) - 1)) {
		HTAlert(gettext("Path too long"));
		FREE(savepath);
		FREE(cp1);
		return 0;
	    }
	    LYstrncpy(tmpbuf, cp1, sizeof(tmpbuf) - 1);
	    FREE(cp1);
	}

	/*
	 * If path is relative, prefix it with current location.
	 */
	if (!LYIsPathSep(tmpbuf[0])) {
	    LYAddPathSep(&savepath);
	    StrAllocCat(savepath, tmpbuf);
	} else {
	    StrAllocCopy(savepath, tmpbuf);
	}

	/*
	 * stat() the target location to determine type and ownership.
	 */
	if (!ok_stat(savepath, &dir_info)) {
	    FREE(savepath);
	    return 0;
	}

	/*
	 * Make sure the source and target locations are not the same place.
	 */
	if (dev == dir_info.st_dev && inode == dir_info.st_ino) {
	    HTAlert(gettext("Source and destination are the same location - request ignored!"));
	    FREE(savepath);
	    return 0;
	}

	/*
	 * Make sure the target location is a directory which is owned by the
	 * same uid as the owner of the current location.
	 */
	if (dir_has_same_owner(&dir_info, owner)) {
	    count = 0;
	    tag = tagged;

	    /*
	     * Move all tagged items to the target location.
	     */
	    while ((cp = (char *) HTList_nextObject(tag)) != NULL) {
		srcpath = HTfullURL_toFile(cp);

		if (move_file(srcpath, savepath) < 0) {
		    if (count == 0)
			count = -1;
		    break;
		}
		FREE(srcpath);
		++count;
	    }
	    clear_tags();
	    FREE(srcpath);
	}
	FREE(savepath);
	return count;
    }
    return 0;
}

/*
 * Modify the name of the specified item.
 */
static int modify_name(char *testpath)
{
    const char *cp;
    char tmpbuf[DIRED_MAXBUF];
    char *newpath = NULL;
    struct stat dir_info;
    int code = 0;

    /*
     * Determine the status of the selected item.
     */
    testpath = strip_trailing_slash(testpath);

    if (ok_stat(testpath, &dir_info)) {
	/*
	 * Change the name of the file or directory.
	 */
	if (S_ISDIR(dir_info.st_mode)) {
	    cp = gettext("Enter new name for directory: ");
	} else if (S_ISREG(dir_info.st_mode)) {
	    cp = gettext("Enter new name for file: ");
	} else {
	    return ok_file_or_dir(&dir_info);
	}
	LYstrncpy(tmpbuf, LYPathLeaf(testpath), sizeof(tmpbuf) - 1);
	if (get_filename(cp, tmpbuf, sizeof(tmpbuf)) == NULL)
	    return 0;

	/*
	 * Do not allow the user to also change the location at this time.
	 */
	if (LYLastPathSep(tmpbuf) != 0) {
	    HTAlert(gettext("Illegal character (path-separator) found! Request ignored."));
	} else if (strlen(tmpbuf)) {
	    if ((cp = LYLastPathSep(testpath)) != NULL)
		HTSprintf0(&newpath, "%.*s%s",
			   (cp - testpath + 1), testpath, tmpbuf);
	    else
		StrAllocCopy(newpath, tmpbuf);

	    /*
	     * Make sure the destination does not already exist.
	     */
	    if (not_already_exists(newpath)) {
		code = move_file(testpath, newpath);
	    }
	    FREE(newpath);

	}
    }
    return code;
}

/*
 * Change the location of a file or directory.
 */
static int modify_location(char *testpath)
{
    const char *cp;
    char *sp;
    dev_t dev;
    ino_t inode;
    int owner;
    char tmpbuf[1024];
    char *newpath = NULL;
    char *savepath = NULL;
    struct stat dir_info;
    int code = 0;

    /*
     * Determine the status of the selected item.
     */
    testpath = strip_trailing_slash(testpath);
    if (!ok_stat(testpath, &dir_info)) {
	return 0;
    }

    /*
     * Change the location of the file or directory.
     */
    if (S_ISDIR(dir_info.st_mode)) {
	if (HTGetProgramPath(ppMV) != NULL) {
	    cp = gettext("Enter new location for directory: ");
	} else {
	    HTAlert(COULD_NOT_ACCESS_DIR);
	    return 0;
	}
    } else if (S_ISREG(dir_info.st_mode)) {
	cp = gettext("Enter new location for file: ");
    } else {
	return ok_file_or_dir(&dir_info);
    }
    LYstrncpy(tmpbuf, testpath, sizeof(tmpbuf) - 1);
    *LYPathLeaf(tmpbuf) = '\0';
    if (get_filename(cp, tmpbuf, sizeof(tmpbuf)) == NULL)
	return 0;
    if (strlen(tmpbuf)) {
	StrAllocCopy(savepath, testpath);
	StrAllocCopy(newpath, testpath);

	/*
	 * Allow ~/ references to the home directory.
	 */
	if (!strncmp(tmpbuf, "~/", 2)
	    || !strcmp(tmpbuf, "~")) {
	    StrAllocCopy(newpath, Home_Dir());
	    StrAllocCat(newpath, (tmpbuf + 1));
	    LYstrncpy(tmpbuf, newpath, sizeof(tmpbuf) - 1);
	}
	if (LYisAbsPath(tmpbuf)) {
	    StrAllocCopy(newpath, tmpbuf);
	} else if ((sp = LYLastPathSep(newpath)) != NULL) {
	    *++sp = '\0';
	    StrAllocCat(newpath, tmpbuf);
	} else {
	    HTAlert(gettext("Unexpected failure - unable to find trailing path separator"));
	    FREE(newpath);
	    FREE(savepath);
	    return 0;
	}

	/*
	 * Make sure the source and target have the same owner (uid).
	 */
	dev = dir_info.st_dev;
	inode = dir_info.st_ino;
	owner = dir_info.st_uid;
	if (!ok_stat(newpath, &dir_info)) {
	    code = 0;
	}
#ifdef UNIX
	/*
	 * Make sure the source and target are not the same location.
	 */
	else if (dev == dir_info.st_dev && inode == dir_info.st_ino) {
	    HTAlert(gettext("Source and destination are the same location!  Request ignored!"));
	    code = 0;
	}
#endif
	else if (dir_has_same_owner(&dir_info, owner)) {
	    code = move_file(savepath, newpath);
	}
	FREE(newpath);
	FREE(savepath);
    }
    return code;
}

/*
 * Modify name or location of a file or directory on localhost.
 */
int local_modify(DocInfo *doc, char **newpath)
{
    int ans;
    char *cp;
    char testpath[DIRED_MAXBUF];	/* a bit ridiculous */
    int count;

    if (!HTList_isEmpty(tagged)) {
	cp = HTpartURL_toFile(doc->address);

	count = modify_tagged(cp);
	FREE(cp);

	if (doc->link > (nlinks - count - 1))
	    doc->link = (nlinks - count - 1);
	doc->link = (doc->link < 0) ?
	    0 : doc->link;

	return count;
    } else if (doc->link < 0 || doc->link > nlinks) {
	/*
	 * Added protection.
	 */
	return 0;
    }

    /*
     * Do not allow simultaneous change of name and location as in Unix.  This
     * reduces functionality but reduces difficulty for the novice.
     */
#ifdef OK_PERMIT
    _statusline(gettext("Modify name, location, or permission (n, l, or p): "));
#else
    _statusline(gettext("Modify name or location (n or l): "));
#endif /* OK_PERMIT */
    ans = LYgetch_single();

    if (strchr("NLP", ans) != NULL) {
	cp = HTfullURL_toFile(links[doc->link].lname);
	if (strlen(cp) >= DIRED_MAXBUF) {
	    FREE(cp);
	    return 0;
	}
	LYstrncpy(testpath, cp, sizeof(testpath) - 1);
	FREE(cp);

	if (ans == 'N') {
	    return (modify_name(testpath));
	} else if (ans == 'L') {
	    if (modify_location(testpath)) {
		if (doc->link == (nlinks - 1))
		    --doc->link;
		return 1;
	    }
#ifdef OK_PERMIT
	} else if (ans == 'P') {
	    return (permit_location(NULL, testpath, newpath));
#endif /* OK_PERMIT */
	} else {
	    /*
	     * Code for changing ownership needed here.
	     */
	    HTAlert(gettext("This feature not yet implemented!"));
	}
    }
    return 0;
}

/*
 * Create a new empty file in the current directory.
 */
static int create_file(char *current_location)
{
    int code = FALSE;
    char tmpbuf[DIRED_MAXBUF];
    char *testpath = NULL;
    const char *bad_chars = ".~/";

    tmpbuf[0] = '\0';
    if (get_filename(gettext("Enter name of file to create: "),
		     tmpbuf, sizeof(tmpbuf)) != NULL) {

	if (!no_dotfiles && show_dotfiles) {
	    bad_chars = "~/";
	}

	if (strstr(tmpbuf, "//") != NULL) {
	    HTAlert(gettext("Illegal redirection \"//\" found! Request ignored."));
	} else if (strlen(tmpbuf) && strchr(bad_chars, tmpbuf[0]) == NULL) {
	    StrAllocCopy(testpath, current_location);
	    LYAddPathSep(&testpath);

	    /*
	     * Append the target filename to the current location.
	     */
	    StrAllocCat(testpath, tmpbuf);

	    /*
	     * Make sure the target does not already exist
	     */
	    if (not_already_exists(testpath)) {
		code = touch_file(testpath);
	    }
	    FREE(testpath);
	}
    }
    return code;
}

/*
 * Create a new directory in the current directory.
 */
static int create_directory(char *current_location)
{
    int code = FALSE;
    char tmpbuf[DIRED_MAXBUF];
    char *testpath = NULL;
    const char *bad_chars = ".~/";

    tmpbuf[0] = '\0';
    if (get_filename(gettext("Enter name for new directory: "),
		     tmpbuf, sizeof(tmpbuf)) != NULL) {

	if (!no_dotfiles && show_dotfiles) {
	    bad_chars = "~/";
	}

	if (strstr(tmpbuf, "//") != NULL) {
	    HTAlert(gettext("Illegal redirection \"//\" found! Request ignored."));
	} else if (strlen(tmpbuf) && strchr(bad_chars, tmpbuf[0]) == NULL) {
	    StrAllocCopy(testpath, current_location);
	    LYAddPathSep(&testpath);

	    StrAllocCat(testpath, tmpbuf);

	    /*
	     * Make sure the target does not already exist.
	     */
	    if (not_already_exists(testpath)) {
		code = make_directory(testpath);
	    }
	    FREE(testpath);
	}
    }
    return code;
}

/*
 * Create a file or a directory at the current location.
 */
int local_create(DocInfo *doc)
{
    int ans;
    char *cp;
    char testpath[DIRED_MAXBUF];

    cp = HTfullURL_toFile(doc->address);
    if (strlen(cp) >= DIRED_MAXBUF) {
	FREE(cp);
	return 0;
    }
    strcpy(testpath, cp);
    FREE(cp);

    _statusline(gettext("Create file or directory (f or d): "));
    ans = LYgetch_single();

    if (ans == 'F') {
	return (create_file(testpath));
    } else if (ans == 'D') {
	return (create_directory(testpath));
    } else {
	return 0;
    }
}

/*
 * Remove a single file or directory.
 */
static int remove_single(char *testpath)
{
    int code = 0;
    char *cp;
    char *tmpbuf = 0;
    struct stat dir_info;
    BOOL is_directory = FALSE;

    if (!ok_lstat(testpath, &dir_info)) {
	return 0;
    }

    /*
     * Locate the filename portion of the path.
     */
    if ((cp = LYLastPathSep(testpath)) != NULL) {
	++cp;
    } else {
	cp = testpath;
    }
    if (S_ISDIR(dir_info.st_mode)) {
	/*
	 * This strlen stuff will probably screw up intl translations.  Course,
	 * it's probably broken for screen sizes other 80, too -jes
	 */
	if (strlen(cp) < 37) {
	    HTSprintf0(&tmpbuf,
		       gettext("Remove directory '%s'?"), cp);
	} else {
	    HTSprintf0(&tmpbuf,
		       gettext("Remove directory?"));
	}
	is_directory = TRUE;
    } else if (S_ISREG(dir_info.st_mode)) {
	if (strlen(cp) < 60) {
	    HTSprintf0(&tmpbuf, gettext("Remove file '%s'?"), cp);
	} else {
	    HTSprintf0(&tmpbuf, gettext("Remove file?"));
	}
#ifdef S_IFLNK
    } else if (S_ISLNK(dir_info.st_mode)) {
	if (strlen(cp) < 50) {
	    HTSprintf0(&tmpbuf, gettext("Remove symbolic link '%s'?"), cp);
	} else {
	    HTSprintf0(&tmpbuf, gettext("Remove symbolic link?"));
	}
#endif
    } else {
	cannot_stat(testpath);
	FREE(tmpbuf);
	return 0;
    }

    if (HTConfirm(tmpbuf) == YES) {
	code = is_directory
	    ? remove_directory(testpath)
	    : remove_file(testpath);
    }
    FREE(tmpbuf);
    return code;
}

/*
 * Remove a file or a directory.
 */
int local_remove(DocInfo *doc)
{
    char *cp, *tp;
    char testpath[DIRED_MAXBUF];
    int count, i;

    if (!HTList_isEmpty(tagged)) {
	count = remove_tagged();
	if (doc->link > (nlinks - count - 1))
	    doc->link = (nlinks - count - 1);
	doc->link = (doc->link < 0) ?
	    0 : doc->link;
	return count;
    } else if (doc->link < 0 || doc->link > nlinks) {
	return 0;
    }
    cp = links[doc->link].lname;
    if (is_url(cp) == FILE_URL_TYPE) {
	tp = HTfullURL_toFile(cp);
	if (strlen(tp) >= DIRED_MAXBUF) {
	    FREE(tp);
	    return 0;
	}
	strcpy(testpath, tp);
	FREE(tp);

	if ((i = strlen(testpath)) && testpath[i - 1] == '/')
	    testpath[(i - 1)] = '\0';

	if (remove_single(testpath)) {
	    if (doc->link == (nlinks - 1))
		--doc->link;
	    return 1;
	}
    }
    return 0;
}

#ifdef OK_PERMIT

static char LYValidPermitFile[LY_MAXPATH] = "\0";

static long permit_bits(char *string_mode)
{
    if (!strcmp(string_mode, "IRUSR"))
	return S_IRUSR;
    if (!strcmp(string_mode, "IWUSR"))
	return S_IWUSR;
    if (!strcmp(string_mode, "IXUSR"))
	return S_IXUSR;
    if (!strcmp(string_mode, "IRGRP"))
	return S_IRGRP;
    if (!strcmp(string_mode, "IWGRP"))
	return S_IWGRP;
    if (!strcmp(string_mode, "IXGRP"))
	return S_IXGRP;
    if (!strcmp(string_mode, "IROTH"))
	return S_IROTH;
    if (!strcmp(string_mode, "IWOTH"))
	return S_IWOTH;
    if (!strcmp(string_mode, "IXOTH"))
	return S_IXOTH;
    /* Don't include setuid and friends; use shell access for that. */
    return 0;
}

/*
 * Handle DIRED permissions.
 */
static int permit_location(char *destpath,
			   char *srcpath,
			   char **newpath)
{
#ifndef UNIX
    HTAlert(gettext("Sorry, don't know how to permit non-UNIX files yet."));
    return (0);
#else
    static char tempfile[LY_MAXPATH] = "\0";
    char *cp;
    char tmpdst[LY_MAXPATH];
    struct stat dir_info;
    const char *program;

    if (srcpath) {
	/*
	 * Create form.
	 */
	FILE *fp0;
	char *user_filename;
	const char *group_name;

	srcpath = strip_trailing_slash(srcpath);

	/*
	 * A couple of sanity tests.
	 */
	if (!ok_lstat(srcpath, &dir_info)
	    || !ok_file_or_dir(&dir_info))
	    return 0;

	user_filename = LYPathLeaf(srcpath);

	LYRemoveTemp(tempfile);
	if ((fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w")) == NULL) {
	    HTAlert(gettext("Unable to open permit options file"));
	    return (0);
	}

	/*
	 * Make the tempfile a URL.
	 */
	LYLocalFileToURL(newpath, tempfile);
	LYRegisterUIPage(*newpath, UIP_PERMIT_OPTIONS);

	group_name = HTAA_GidToName(dir_info.st_gid);
	LYstrncpy(LYValidPermitFile,
		  srcpath,
		  (sizeof(LYValidPermitFile) - 1));

	fprintf(fp0, "<Html><Head>\n<Title>%s</Title>\n</Head>\n<Body>\n",
		PERMIT_OPTIONS_TITLE);
	fprintf(fp0, "<H1>%s%s</H1>\n", PERMISSIONS_SEGMENT, user_filename);
	{
	    /*
	     * Prevent filenames which include '#' or '?' from messing it up.
	     */
	    char *srcpath_url = HTEscape(srcpath, URL_PATH);

	    fprintf(fp0, "<Form Action=\"%s//PERMIT_LOCATION%s\">\n",
		    STR_LYNXDIRED, srcpath_url);
	    FREE(srcpath_url);
	}

	fprintf(fp0, "<Ol><Li>%s<Br><Br>\n",
		gettext("Specify permissions below:"));
	fprintf(fp0, "%s:<Br>\n", gettext("Owner:"));
	fprintf(fp0,
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRUSR\" %s> Read<Br>\n",
		(dir_info.st_mode & S_IRUSR) ? "checked" : "");
	fprintf(fp0,
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWUSR\" %s> Write<Br>\n",
		(dir_info.st_mode & S_IWUSR) ? "checked" : "");
	/*
	 * If restricted, only change eXecute permissions on directories.
	 */
	if (!no_change_exec_perms || S_ISDIR(dir_info.st_mode))
	    fprintf(fp0,
		    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXUSR\" %s> %s<Br>\n",
		    (dir_info.st_mode & S_IXUSR) ? "checked" : "",
		    S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");

	fprintf(fp0, "%s %s:<Br>\n", gettext("Group"), group_name);
	fprintf(fp0,
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRGRP\" %s> Read<Br>\n",
		(dir_info.st_mode & S_IRGRP) ? "checked" : "");
	fprintf(fp0,
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWGRP\" %s> Write<Br>\n",
		(dir_info.st_mode & S_IWGRP) ? "checked" : "");
	/*
	 * If restricted, only change eXecute permissions on directories.
	 */
	if (!no_change_exec_perms || S_ISDIR(dir_info.st_mode))
	    fprintf(fp0,
		    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXGRP\" %s> %s<Br>\n",
		    (dir_info.st_mode & S_IXGRP) ? "checked" : "",
		    S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");

	fprintf(fp0, "%s<Br>\n", gettext("Others:"));
	fprintf(fp0,
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IROTH\" %s> Read<Br>\n",
		(dir_info.st_mode & S_IROTH) ? "checked" : "");
	fprintf(fp0,
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWOTH\" %s> Write<Br>\n",
		(dir_info.st_mode & S_IWOTH) ? "checked" : "");
	/*
	 * If restricted, only change eXecute permissions on directories.
	 */
	if (!no_change_exec_perms || S_ISDIR(dir_info.st_mode))
	    fprintf(fp0,
		    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXOTH\" %s> %s<Br>\n",
		    (dir_info.st_mode & S_IXOTH) ? "checked" : "",
		    S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");

	fprintf(fp0,
		"<Br>\n<Li><Input Type=\"submit\" Value=\"Submit\">  %s %s %s.\n</Ol>\n</Form>\n",
		gettext("form to permit"),
		S_ISDIR(dir_info.st_mode) ? "directory" : "file",
		user_filename);
	fprintf(fp0, "</Body></Html>");
	LYCloseTempFP(fp0);

	LYforce_no_cache = TRUE;
	return (PERMIT_FORM_RESULT);	/* Special flag for LYMainLoop */

    } else {			/* The form being activated. */
	mode_t new_mode = 0;

	/*
	 * Make sure we have a valid set-permission file comparison string
	 * loaded via a previous call with srcpath != NULL.  - KW
	 */
	if (LYValidPermitFile[0] == '\0') {
	    if (LYCursesON)
		HTAlert(INVALID_PERMIT_URL);
	    else
		fprintf(stderr, "%s\n", INVALID_PERMIT_URL);
	    CTRACE((tfp, "permit_location: called for <%s>.\n",
		    (destpath ?
		     destpath : "NULL URL pointer")));
	    return 0;
	}
	cp = destpath;
	while (*cp != '\0' && *cp != '?') {	/* Find filename */
	    cp++;
	}
	if (*cp == '\0') {
	    return (0);		/* Nothing to permit. */
	}
	*cp++ = '\0';		/* Null terminate file name and
				   start working on the masks. */

	/* Will now operate only on filename part. */
	if ((destpath = HTURLPath_toFile(destpath, TRUE, FALSE)) == 0)
	    return (0);
	if (strlen(destpath) >= LY_MAXPATH) {
	    FREE(destpath);
	    return (0);
	}
	strcpy(tmpdst, destpath);
	FREE(destpath);
	destpath = tmpdst;

	/*
	 * Make sure that the file string is the one from the last displayed
	 * File Permissions menu.  - KW
	 */
	if (strcmp(destpath, LYValidPermitFile)) {
	    if (LYCursesON)
		HTAlert(INVALID_PERMIT_URL);
	    else
		fprintf(stderr, "%s\n", INVALID_PERMIT_URL);
	    CTRACE((tfp, "permit_location: called for file '%s'.\n",
		    destpath));
	    return 0;
	}

	/*
	 * A couple of sanity tests.
	 */
	destpath = strip_trailing_slash(destpath);
	if (!ok_stat(destpath, &dir_info)
	    || !ok_file_or_dir(&dir_info)) {
	    return 0;
	}

	/*
	 * Cycle over permission strings.
	 */
	while (*cp != '\0') {
	    char *cr = cp;

	    while (*cr != '\0' && *cr != '&') {		/* GET data split by '&'. */
		cr++;
	    }
	    if (*cr != '\0') {
		*cr++ = '\0';
	    }
	    if (strncmp(cp, "mode=", 5) == 0) {		/* Magic string. */
		long mask = permit_bits(cp + 5);

		if (mask != 0) {
		    /*
		     * If restricted, only change eXecute permissions on
		     * directories.
		     */
		    if (!no_change_exec_perms
			|| strchr(cp + 5, 'X') == NULL
			|| S_ISDIR(dir_info.st_mode))
			new_mode |= mask;
		} else {
		    HTAlert(gettext("Invalid mode format."));
		    return 0;
		}
	    } else {
		HTAlert(gettext("Invalid syntax format."));
		return 0;
	    }

	    cp = cr;
	}

	/*
	 * Call chmod().
	 */
	if ((program = HTGetProgramPath(ppCHMOD)) != NULL) {
	    char *args[5];
	    char amode[10];
	    char *tmpbuf = NULL;

	    HTSprintf0(&tmpbuf, "chmod %.4o %s", (unsigned int) new_mode, destpath);
	    sprintf(amode, "%.4o", (unsigned int) new_mode);
	    args[0] = "chmod";
	    args[1] = amode;
	    args[2] = destpath;
	    args[3] = (char *) 0;
	    if (LYExecv(program, args, tmpbuf) <= 0) {
		FREE(tmpbuf);
		return (-1);
	    }
	    FREE(tmpbuf);
	} else {
	    if (chmod(destpath, new_mode) < 0)
		return (-1);
	}
	LYforce_no_cache = TRUE;	/* Force update of dired listing. */
	return 1;
    }
#endif /* !UNIX */
}
#endif /* OK_PERMIT */

/*
 * Display or remove a tag from a given link.
 */
void tagflag(int flag,
	     int cur)
{
    if (nlinks > 0) {
	LYmove(links[cur].ly, 2);
	lynx_stop_reverse();
	if (flag == ON) {
	    LYaddch('+');
	} else {
	    LYaddch(' ');
	}

#if defined(FANCY_CURSES) || defined(USE_SLANG)
	if (!LYShowCursor)
	    LYHideCursor();	/* get cursor out of the way */
	else
#endif /* FANCY CURSES || USE_SLANG */
	    /*
	     * Never hide the cursor if there's no FANCY CURSES.
	     */
	    LYmove(links[cur].ly, links[cur].lx);

	LYrefresh();
    }
}

/*
 * Handle DIRED tags.
 */
void showtags(HTList *t)
{
    int i;
    HTList *s;
    char *name;

    for (i = 0; i < nlinks; i++) {
	s = t;
	while ((name = (char *) HTList_nextObject(s)) != NULL) {
	    if (!strcmp(links[i].lname, name)) {
		tagflag(ON, i);
		break;
	    }
	}
    }
}

static char *DirectoryOf(char *pathname)
{
    char *result = 0;
    char *leaf;

    StrAllocCopy(result, pathname);
    leaf = LYPathLeaf(result);

    if (leaf != result) {
	const char *result1 = 0;

	*leaf = '\0';
	if (!LYisRootPath(result))
	    LYTrimPathSep(result);
	result1 = wwwName(result);
	StrAllocCopy(result, result1);
    }
    return result;
}

#ifdef __DJGPP__
/*
 * Convert filenames to acceptable 8+3 names when necessary.  Make a copy of
 * the parameter if we must modify it.
 */
static char *LYonedot(char *line)
{
    char *dot;
    static char line1[LY_MAXPATH];

    if (pathconf(line, _PC_NAME_MAX) <= 12) {
	LYstrncpy(line1, line, sizeof(line1) - 1);
	for (;;) {
	    if ((dot = strrchr(line1, '.')) == 0
		|| LYLastPathSep(dot) != 0) {
		break;
	    } else if (strlen(dot) == 1) {
		*dot = 0;
	    } else {
		*dot = '_';
	    }
	}
	return (line1);
    }
    return (line);
}
#else
#define LYonedot(path) path
#endif /*  __DJGPP__ */

static char *match_op(const char *prefix,
		      char *data)
{
    int len = strlen(prefix);

    if (!strncmp("LYNXDIRED://", data, 12)
	&& !strncmp(prefix, data + 12, (unsigned) len)) {
	len += 12;
#if defined(USE_DOS_DRIVES)
	if (data[len] == '/') {	/* this is normal */
	    len++;
	}
#endif
	return data + len;
    }
    return 0;
}

/*
 * Construct the appropriate system command taking care to escape all path
 * references to avoid spoofing the shell.
 */
static char *build_command(char *line,
			   char *dirname,
			   char *arg)
{
    char *buffer = NULL;
    const char *program;
    const char *tar_path = HTGetProgramPath(ppTAR);

    if ((arg = match_op("DECOMPRESS", line)) != 0) {
#define FMT_UNCOMPRESS "%s %s"
	if ((program = HTGetProgramPath(ppUNCOMPRESS)) != NULL) {
	    HTAddParam(&buffer, FMT_UNCOMPRESS, 1, program);
	    HTAddParam(&buffer, FMT_UNCOMPRESS, 2, arg);
	    HTEndParam(&buffer, FMT_UNCOMPRESS, 2);
	}
	return buffer;
    }
#if defined(OK_UUDECODE) && !defined(ARCHIVE_ONLY)
    if ((arg = match_op("UUDECODE", line)) != 0) {
#define FMT_UUDECODE "%s %s"
	if ((program = HTGetProgramPath(ppUUDECODE)) != NULL) {
	    HTAddParam(&buffer, FMT_UUDECODE, 1, program);
	    HTAddParam(&buffer, FMT_UUDECODE, 2, arg);
	    HTEndParam(&buffer, FMT_UUDECODE, 2);
	    HTAlert(gettext("Warning!  UUDecoded file will exist in the directory you started Lynx."));
	}
	return buffer;
    }
#endif /* OK_UUDECODE && !ARCHIVE_ONLY */

#ifdef OK_TAR
    if (tar_path != NULL) {
# ifndef ARCHIVE_ONLY
#  ifdef OK_GZIP
	if ((arg = match_op("UNTAR_GZ", line)) != 0) {
#define FMT_UNTAR_GZ "cd %s; %s -qdc %s |  %s %s %s"
	    if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 1, dirname);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 2, program);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 3, arg);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 4, tar_path);
		HTAddToCmd(&buffer, FMT_UNTAR_GZ, 5, TAR_DOWN_OPTIONS);
		HTAddToCmd(&buffer, FMT_UNTAR_GZ, 6, TAR_PIPE_OPTIONS);
		HTEndParam(&buffer, FMT_UNTAR_GZ, 6);
	    }
	    return buffer;
	}
#  endif			/* OK_GZIP */
	if ((arg = match_op("UNTAR_Z", line)) != 0) {
#define FMT_UNTAR_Z "cd %s; %s %s |  %s %s %s"
	    if ((program = HTGetProgramPath(ppZCAT)) != NULL) {
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_UNTAR_Z, 1, dirname);
		HTAddParam(&buffer, FMT_UNTAR_Z, 2, program);
		HTAddParam(&buffer, FMT_UNTAR_Z, 3, arg);
		HTAddParam(&buffer, FMT_UNTAR_Z, 4, tar_path);
		HTAddToCmd(&buffer, FMT_UNTAR_Z, 5, TAR_DOWN_OPTIONS);
		HTAddToCmd(&buffer, FMT_UNTAR_Z, 6, TAR_PIPE_OPTIONS);
		HTEndParam(&buffer, FMT_UNTAR_Z, 6);
	    }
	    return buffer;
	}
	if ((arg = match_op("UNTAR", line)) != 0) {
#define FMT_UNTAR "cd %s; %s %s %s"
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_UNTAR, 1, dirname);
	    HTAddParam(&buffer, FMT_UNTAR, 2, tar_path);
	    HTAddToCmd(&buffer, FMT_UNTAR, 3, TAR_DOWN_OPTIONS);
	    HTAddParam(&buffer, FMT_UNTAR, 4, arg);
	    HTEndParam(&buffer, FMT_UNTAR, 4);
	    return buffer;
	}
# endif				/* !ARCHIVE_ONLY */

# ifdef OK_GZIP
	if ((arg = match_op("TAR_GZ", line)) != 0) {
#define FMT_TAR_GZ "cd %s; %s %s %s %s | %s -qc >%s%s"
	    if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_TAR_GZ, 1, dirname);
		HTAddParam(&buffer, FMT_TAR_GZ, 2, tar_path);
		HTAddToCmd(&buffer, FMT_TAR_GZ, 3, TAR_UP_OPTIONS);
		HTAddToCmd(&buffer, FMT_TAR_GZ, 4, TAR_PIPE_OPTIONS);
		HTAddParam(&buffer, FMT_TAR_GZ, 5, LYPathLeaf(arg));
		HTAddParam(&buffer, FMT_TAR_GZ, 6, program);
		HTAddParam(&buffer, FMT_TAR_GZ, 7, LYonedot(LYPathLeaf(arg)));
		HTAddParam(&buffer, FMT_TAR_GZ, 8, EXT_TAR_GZ);
		HTEndParam(&buffer, FMT_TAR_GZ, 8);
	    }
	    return buffer;
	}
# endif				/* OK_GZIP */

	if ((arg = match_op("TAR_Z", line)) != 0) {
#define FMT_TAR_Z "cd %s; %s %s %s %s | %s >%s%s"
	    if ((program = HTGetProgramPath(ppCOMPRESS)) != NULL) {
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_TAR_Z, 1, dirname);
		HTAddParam(&buffer, FMT_TAR_Z, 2, tar_path);
		HTAddToCmd(&buffer, FMT_TAR_Z, 3, TAR_UP_OPTIONS);
		HTAddToCmd(&buffer, FMT_TAR_Z, 4, TAR_PIPE_OPTIONS);
		HTAddParam(&buffer, FMT_TAR_Z, 5, LYPathLeaf(arg));
		HTAddParam(&buffer, FMT_TAR_Z, 6, program);
		HTAddParam(&buffer, FMT_TAR_Z, 7, LYonedot(LYPathLeaf(arg)));
		HTAddParam(&buffer, FMT_TAR_Z, 8, EXT_TAR_Z);
		HTEndParam(&buffer, FMT_TAR_Z, 8);
	    }
	    return buffer;
	}

	if ((arg = match_op("TAR", line)) != 0) {
#define FMT_TAR "cd %s; %s %s %s %s.tar %s"
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_TAR, 1, dirname);
	    HTAddParam(&buffer, FMT_TAR, 2, tar_path);
	    HTAddToCmd(&buffer, FMT_TAR, 3, TAR_UP_OPTIONS);
	    HTAddToCmd(&buffer, FMT_TAR, 4, TAR_FILE_OPTIONS);
	    HTAddParam(&buffer, FMT_TAR, 5, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_TAR, 6, LYPathLeaf(arg));
	    HTEndParam(&buffer, FMT_TAR, 6);
	    return buffer;
	}
    }
#endif /* OK_TAR */

#ifdef OK_GZIP
    if ((arg = match_op("GZIP", line)) != 0) {
#define FMT_GZIP "%s -q %s"
	if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
	    HTAddParam(&buffer, FMT_GZIP, 1, program);
	    HTAddParam(&buffer, FMT_GZIP, 2, arg);
	    HTEndParam(&buffer, FMT_GZIP, 2);
	}
	return buffer;
    }
#ifndef ARCHIVE_ONLY
    if ((arg = match_op("UNGZIP", line)) != 0) {
#define FMT_UNGZIP "%s -d %s"
	if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
	    HTAddParam(&buffer, FMT_UNGZIP, 1, program);
	    HTAddParam(&buffer, FMT_UNGZIP, 2, arg);
	    HTEndParam(&buffer, FMT_UNGZIP, 2);
	}
	return buffer;
    }
#endif /* !ARCHIVE_ONLY */
#endif /* OK_GZIP */

#ifdef OK_ZIP
    if ((arg = match_op("ZIP", line)) != 0) {
#define FMT_ZIP "cd %s; %s -rq %s.zip %s"
	if ((program = HTGetProgramPath(ppZIP)) != NULL) {
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_ZIP, 1, dirname);
	    HTAddParam(&buffer, FMT_ZIP, 2, program);
	    HTAddParam(&buffer, FMT_ZIP, 3, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_ZIP, 4, LYPathLeaf(arg));
	    HTEndParam(&buffer, FMT_ZIP, 4);
	}
	return buffer;
    }
#if !defined(ARCHIVE_ONLY)
    if ((arg = match_op("UNZIP", line)) != 0) {
#define FMT_UNZIP "cd %s; %s -q %s"
	if ((program = HTGetProgramPath(ppUNZIP)) != NULL) {
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_UNZIP, 1, dirname);
	    HTAddParam(&buffer, FMT_UNZIP, 2, program);
	    HTAddParam(&buffer, FMT_UNZIP, 3, arg);
	    HTEndParam(&buffer, FMT_UNZIP, 3);
	}
	return buffer;
    }
# endif				/* !ARCHIVE_ONLY */
#endif /* OK_ZIP */

    if ((arg = match_op("COMPRESS", line)) != 0) {
#define FMT_COMPRESS "%s %s"
	if ((program = HTGetProgramPath(ppCOMPRESS)) != NULL) {
	    HTAddParam(&buffer, FMT_COMPRESS, 1, program);
	    HTAddParam(&buffer, FMT_COMPRESS, 2, arg);
	    HTEndParam(&buffer, FMT_COMPRESS, 2);
	}
	return buffer;
    }

    return NULL;
}

/*
 * Perform file management operations for LYNXDIRED URL's.  Attempt to be
 * consistent.  These are (pseudo) URLs - i.e., they should be in URL syntax: 
 * some bytes will be URL-escaped with '%'.  This is necessary because these
 * (pseudo) URLs will go through some of the same kinds of interpretations and
 * mutilations as real ones:  HTParse, stripping off #fragments etc.  (Some
 * access schemes currently have special rules about not escaping parsing '#'
 * "the URL way" built into HTParse, but that doesn't look like a clean way.)
 */
int local_dired(DocInfo *doc)
{
    char *line_url;		/* will point to doc's address, which is a URL */
    char *line = NULL;		/* same as line_url, but HTUnEscaped, will be alloced */
    char *arg = NULL;		/* ...will point into line[] */
    char *tp = NULL;
    char *tmpbuf = NULL;
    char *buffer = NULL;
    char *dirname = NULL;
    BOOL do_pop_doc = TRUE;

    line_url = doc->address;
    CTRACE((tfp, "local_dired: called for <%s>.\n",
	    (line_url
	     ? line_url
	     : gettext("NULL URL pointer"))));
    HTUnEscapeSome(line_url, "/");	/* don't mess too much with *doc */

    StrAllocCopy(line, line_url);
    HTUnEscape(line);		/* _file_ (not URL) syntax, for those functions
				   that need it.  Don't forget to FREE it. */
    if ((arg = match_op("CHDIR", line)) != 0) {
#ifdef SUPPORT_CHDIR
	handle_LYK_CHDIR();
	do_pop_doc = FALSE;
#endif
	arg = "blah";		/* do something to avoid cc's complaints */
    } else if ((arg = match_op("NEW_FILE", line)) != 0) {
	if (create_file(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("NEW_FOLDER", line)) != 0) {
	if (create_directory(arg) > 0)
	    LYforce_no_cache = TRUE;
#ifdef OK_INSTALL
    } else if ((arg = match_op("INSTALL_SRC", line)) != 0) {
	local_install(NULL, arg, &tp);
	if (tp) {
	    FREE(doc->address);
	    doc->address = tp;
	}
	FREE(line);
	return 0;
    } else if ((arg = match_op("INSTALL_DEST", line)) != 0) {
	local_install(arg, NULL, &tp);
	LYpop(doc);
#endif /* OK_INSTALL */
    } else if ((arg = match_op("MODIFY_NAME", line)) != 0) {
	if (modify_name(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("MODIFY_LOCATION", line)) != 0) {
	if (modify_location(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("MOVE_TAGGED", line_url)) != 0) {
	if (modify_tagged(arg) > 0)
	    LYforce_no_cache = TRUE;
#ifdef OK_PERMIT
    } else if ((arg = match_op("PERMIT_SRC", line)) != 0) {
	permit_location(NULL, arg, &tp);
	if (tp) {
	    /*
	     * One of the checks may have failed.
	     */
	    FREE(doc->address);
	    doc->address = tp;
	}
	FREE(line);
	return 0;
    } else if ((arg = match_op("PERMIT_LOCATION", line_url)) != 0) {
	permit_location(arg, NULL, &tp);
#endif /* OK_PERMIT */
    } else if ((arg = match_op("REMOVE_SINGLE", line)) != 0) {
	if (remove_single(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("REMOVE_TAGGED", line)) != 0) {
	if (remove_tagged())
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("CLEAR_TAGGED", line)) != 0) {
	clear_tags();
    } else if ((arg = match_op("UPLOAD", line)) != 0) {
	/*
	 * They're written by LYUpload_options() HTUnEscaped; don't want to
	 * change that for now...  so pass through without more unescaping. 
	 * Directory names containing '#' will probably fail.
	 */
	if (LYUpload(line_url))
	    LYforce_no_cache = TRUE;
    } else {
	LYTrimPathSep(line);
	if (LYLastPathSep(line) == NULL) {
	    FREE(line);
	    return 0;
	}

	buffer = build_command(line, dirname, arg);

	if (buffer != 0) {
	    if ((int) strlen(buffer) < LYcolLimit - 14) {
		HTSprintf0(&tmpbuf, gettext("Executing %s "), buffer);
	    } else {
		HTSprintf0(&tmpbuf,
			   gettext("Executing system command. This might take a while."));
	    }
	    _statusline(tmpbuf);
	    stop_curses();
	    printf("%s\r\n", tmpbuf);
	    LYSystem(buffer);
#ifdef VMS
	    HadVMSInterrupt = FALSE;
#endif /* VMS */
	    start_curses();
	    LYforce_no_cache = TRUE;
	}
    }

    FREE(dirname);
    FREE(tmpbuf);
    FREE(buffer);
    FREE(line);
    FREE(tp);
    if (do_pop_doc)
	LYpop(doc);
    return 0;
}

/*
 * Provide a menu of file management options.
 */
int dired_options(DocInfo *doc, char **newfile)
{
    static char tempfile[LY_MAXPATH];
    char *path;
    char *dir;
    lynx_list_item_type *nxt;
    struct stat dir_info;
    FILE *fp0;
    char *dir_url;
    char *path_url;
    BOOLEAN nothing_tagged;
    int count;
    struct dired_menu *mp;
    char buf[2048];

    if ((fp0 = InternalPageFP(tempfile, FALSE)) == 0)
	return (0);

    /*
     * Make the tempfile a URL.
     */
    LYLocalFileToURL(newfile, tempfile);
    LYRegisterUIPage(*newfile, UIP_DIRED_MENU);

    if (doc->link > -1 && doc->link < (nlinks + 1)) {
	path = HTfullURL_toFile(links[doc->link].lname);
	LYTrimPathSep(path);

	if (!ok_lstat(path, &dir_info)) {
	    LYCloseTempFP(fp0);
	    FREE(path);
	    return 0;
	}

    } else {
	StrAllocCopy(path, "");
    }

    dir = HTfullURL_toFile(doc->address);
    LYTrimPathSep(dir);

    nothing_tagged = (BOOL) (HTList_isEmpty(tagged));

    BeginInternalPage(fp0, DIRED_MENU_TITLE, DIRED_MENU_HELP);

    fprintf(fp0, "<em>%s</em> %s<br>\n", gettext("Current directory:"), dir);

    if (nothing_tagged) {
	fprintf(fp0, "<em>%s</em> ", gettext("Current selection:"));
	if (strlen(path)) {
	    fprintf(fp0, "%s<p>\n", path);
	} else {
	    fprintf(fp0, "%s.<p>\n", gettext("Nothing currently selected."));
	}
    } else {
	/*
	 * Write out number of tagged items, and names of first few of them
	 * relative to current (in the DIRED sense) directory.
	 */
	int n = HTList_count(tagged);
	char *cp1 = NULL;
	char *cd = NULL;
	int i, m;

#define NUM_TAGS_TO_WRITE 10
	fprintf(fp0, "<em>%s</em> %d %s",
		gettext("Current selection:"),
		n, ((n == 1)
		    ? gettext("tagged item:")
		    : gettext("tagged items:")));
	StrAllocCopy(cd, doc->address);
	HTUnEscapeSome(cd, "/");
	LYAddHtmlSep(&cd);
	m = (n < NUM_TAGS_TO_WRITE) ? n : NUM_TAGS_TO_WRITE;
	for (i = 1; i <= m; i++) {
	    cp1 = HTRelative((char *) HTList_objectAt(tagged, i - 1),
			     (*cd ? cd : "file://localhost"));
	    HTUnEscape(cp1);
	    LYEntify(&cp1, TRUE);	/* _should_ do this everywhere... */
	    fprintf(fp0, "%s<br>\n&nbsp;&nbsp;&nbsp;%s",
		    (i == 1 ? "" : " ,"), cp1);
	    FREE(cp1);
	}
	if (n > m) {
	    fprintf(fp0, " , ...");
	}
	fprintf(fp0, "<p>\n");
	FREE(cd);
    }

    /*
     * If menu_head is NULL then use defaults and link them together now.
     */
    if (menu_head == NULL) {
	for (mp = defmenu; mp->href != NULL; mp++)
	    mp->next = (mp + 1);
	(--mp)->next = NULL;
	menu_head = defmenu;
    }

    for (mp = menu_head; mp != NULL; mp = mp->next) {
	if (mp->cond != DE_TAG && !nothing_tagged)
	    continue;
	if (mp->cond == DE_TAG && nothing_tagged)
	    continue;
	if (mp->cond == DE_DIR &&
	    (!*path || !S_ISDIR(dir_info.st_mode)))
	    continue;
	if (mp->cond == DE_FILE &&
	    (!*path || !S_ISREG(dir_info.st_mode)))
	    continue;
#ifdef S_IFLNK
	if (mp->cond == DE_SYMLINK &&
	    (!*path || !S_ISLNK(dir_info.st_mode)))
	    continue;
#endif
	if (*mp->sfx &&
	    (strlen(path) < strlen(mp->sfx) ||
	     strcmp(mp->sfx, &path[(strlen(path) - strlen(mp->sfx))]) != 0))
	    continue;
	dir_url = HTEscape(dir, URL_PATH);
	path_url = HTEscape(path, URL_PATH);
	fprintf(fp0, "<a href=\"%s",
		render_item(mp->href, path_url, dir_url, buf, sizeof(buf), YES));
	fprintf(fp0, "\">%s</a> ",
		render_item(mp->link, path, dir, buf, sizeof(buf), NO));
	fprintf(fp0, "%s<br>\n",
		render_item(mp->rest, path, dir, buf, sizeof(buf), NO));
	FREE(dir_url);
	FREE(path_url);
    }
    FREE(path);

    if (uploaders != NULL) {
	fprintf(fp0, "<p>Upload to current directory:<p>\n");
	for (count = 0, nxt = uploaders;
	     nxt != NULL;
	     nxt = nxt->next, count++) {
	    fprintf(fp0,
		    "<a href=\"LYNXDIRED://UPLOAD=%d/TO=%s\"> %s </a><br>\n",
		    count, dir, nxt->name);
	}
    }
    FREE(dir);

    EndInternalPage(fp0);
    LYCloseTempFP(fp0);

    LYforce_no_cache = TRUE;

    return (0);
}

/*
 * Check DIRED filename.
 */
static char *get_filename(const char *prompt,
			  char *buf,
			  size_t bufsize)
{
    char *cp;

    _statusline(prompt);

    LYgetstr(buf, VISIBLE, bufsize, NORECALL);
    if (strstr(buf, "../") != NULL) {
	HTAlert(gettext("Illegal filename; request ignored."));
	return NULL;
    }

    if (no_dotfiles || !show_dotfiles) {
	cp = LYLastPathSep(buf);	/* find last slash */
	if (cp)
	    cp += 1;
	else
	    cp = buf;
	if (*cp == '.') {
	    HTAlert(gettext("Illegal filename; request ignored."));
	    return NULL;
	}
    }
    return buf;
}

#ifdef OK_INSTALL

#define LYEXECV_MAX_ARGC 15
/* these are quasi-constant once they have been allocated: */
static char **install_argp = NULL;	/* args for execv install */
static char *install_path = NULL;	/* auxiliary */

#ifdef LY_FIND_LEAKS
static void clear_install_path(void)
{
    FREE(install_argp);
    FREE(install_path);
}
#endif /* LY_FIND_LEAKS */

/*
 * Fill in args array for execv (or execvp etc.) call, after first allocating
 * it if necessary.  No fancy parsing, cmd_args is just split at spaces.  Leave
 * room for reserve additional args to be added by caller.
 *
 * On success *argvp points to new args vector, *pathp is auxiliary.  On
 * success returns index of next argument, else -1.  This is generic enough
 * that it could be used for other calls than install, except the atexit call. 
 * Go through this trouble for install because INSTALL_ARGS may be significant,
 * and someone may configure it with more than one significant flags.  - kw
 */
static int fill_argv_for_execv(char ***argvp,
			       char **pathp,
			       char *cmd_path,
			       const char *cmd_args,
			       int reserve)
{
    int n = 0;

    char **args;
    char *cp;

    if (*argvp == NULL) {
	*argvp = typecallocn(char *, LYEXECV_MAX_ARGC + 1);

	if (!*argvp)
	    return (-1);
#ifdef LY_FIND_LEAKS
	atexit(clear_install_path);
#endif
    }
    args = *argvp;
    args[n++] = cmd_path;
    if (cmd_args) {
	StrAllocCopy(*pathp, cmd_args);
	cp = strtok(*pathp, " ");
	if (cp) {
	    while (cp && (n < LYEXECV_MAX_ARGC - reserve)) {
		args[n++] = cp;
		cp = strtok(NULL, " ");
	    }
	    if (cp && (n >= LYEXECV_MAX_ARGC - reserve)) {
		CTRACE((tfp, "Too many args for '%s' in '%s'!\n",
			NONNULL(cmd_path), cmd_args));
		return (-1);
	    }
	} else {
	    args[n++] = *pathp;
	}
    }
    args[n] = (char *) 0;
    return (n);
}

/*
 * Install the specified file or directory.
 */
BOOLEAN local_install(char *destpath,
		      char *srcpath,
		      char **newpath)
{
    char *tmpbuf = NULL;
    static char savepath[DIRED_MAXBUF];		/* This will be the link that

						   is to be installed. */
    struct stat dir_info;
    char **args;
    HTList *tag;
    char *cp = NULL;
    char *tmpdest = NULL;
    int count = 0;
    int n = 0;			/* indices into 'args[]' */
    static int src = -1;
    const char *program;

    if ((program = HTGetProgramPath(ppINSTALL)) == NULL) {
	HTAlert(gettext("Install in the selected directory not permitted."));
	return 0;
    }

    /*
     * Determine the status of the selected item.
     */
    if (srcpath) {
	srcpath = strip_trailing_slash(srcpath);
	if (is_url(srcpath)) {
	    char *local_src = HTfullURL_toFile(srcpath);

	    if (!ok_localname(savepath, local_src)) {
		FREE(local_src);
		return 0;
	    }
	    FREE(local_src);
	} else if (!HTList_isEmpty(tagged) &&
		   srcpath[0] == '\0') {
	    savepath[0] = '\0';	/* will always use tagged list - kw */
	} else if (!ok_localname(savepath, srcpath)) {
	    return 0;
	}
	LYforce_no_cache = TRUE;
	LYLocalFileToURL(newpath, Home_Dir());
	LYAddHtmlSep(newpath);
	StrAllocCat(*newpath, INSTALLDIRS_FILE);
	LYRegisterUIPage(*newpath, UIP_INSTALL);
	return 0;
    }

    /* deal with ~/ or /~/ at the beginning - kw */
    if (destpath[0] == '~' &&
	(destpath[1] == '/' || destpath[1] == '\0')) {
	cp = &destpath[1];
    } else if (destpath[0] == '/' && destpath[1] == '~' &&
	       (destpath[2] == '/' || destpath[2] == '\0')) {
	cp = &destpath[2];
    }
    if (cp) {
	/* If found, allocate new string, make destpath point to it - kw */
	StrAllocCopy(tmpdest, Home_Dir());
	if (cp[0] && cp[1]) {
	    LYAddPathSep(&tmpdest);
	    StrAllocCat(tmpdest, cp + 1);
	}
	destpath = tmpdest;
    }

    destpath = strip_trailing_slash(destpath);

    if (!ok_stat(destpath, &dir_info)) {
	FREE(tmpdest);
	return 0;
    } else if (!S_ISDIR(dir_info.st_mode)) {
	HTAlert(gettext("The selected item is not a directory!  Request ignored."));
	FREE(tmpdest);
	return 0;
    } else if (0 /*directory not writable */ ) {
	HTAlert(gettext("Install in the selected directory not permitted."));
	FREE(tmpdest);
	return 0;
    }

    statusline(gettext("Just a moment, ..."));

    /* fill in the fixed args, if not already done - kw */
    if (src > 0 && install_argp) {
	n = src;
	n++;
    } else {
	n = fill_argv_for_execv(&install_argp, &install_path,
				"install",
#ifdef INSTALL_ARGS
				INSTALL_ARGS,
#else
				NULL,
#endif /* INSTALL_ARGS */
				2);
	if (n <= 0) {
	    src = 0;
	    HTAlert(gettext("Error building install args"));
	    FREE(tmpdest);
	    return 0;
	}
	src = n++;
    }
    args = install_argp;

    args[n++] = destpath;
    args[n] = (char *) 0;
    tag = tagged;

    if (HTList_isEmpty(tagged)) {
	/* simplistic detection of identical src and dest - kw */
	if (!strcmp(savepath, destpath)) {
	    HTUserMsg2(gettext("Source and target are the same: %s"),
		       savepath);
	    FREE(tmpdest);
	    return (-1);	/* don't do it */
	} else if (!strncmp(savepath, destpath, strlen(destpath)) &&
		   LYIsPathSep(savepath[strlen(destpath)]) &&
		   LYLastPathSep(savepath + strlen(destpath) + 1) == 0) {
	    HTUserMsg2(gettext("Already in target directory: %s"),
		       savepath);
	    FREE(tmpdest);
	    return 0;		/* don't do it */
	}
	args[src] = savepath;
	HTSprintf0(&tmpbuf, "install %s in %s", savepath, destpath);
	if (LYExecv(program, args, tmpbuf) <= 0) {
	    FREE(tmpbuf);
	    FREE(tmpdest);
	    return (-1);
	}
	count++;
    } else {
	char *name;

	HTSprintf0(&tmpbuf, "install in %s", destpath);
	while ((name = (char *) HTList_nextObject(tag))) {
	    int err;

	    args[src] = HTfullURL_toFile(name);

	    /* simplistic detection of identical src and dest - kw */
	    if (!strcmp(args[src], destpath)) {
		HTUserMsg2(gettext("Source and target are the same: %s"),
			   args[src]);
		FREE(args[src]);
		continue;	/* skip this source file */
	    } else if (!strncmp(args[src], destpath, strlen(destpath)) &&
		       LYIsPathSep(args[src][strlen(destpath)]) &&
		       LYLastPathSep(args[src] + strlen(destpath) + 1) == 0) {
		HTUserMsg2(gettext("Already in target directory: %s"),
			   args[src]);
		FREE(args[src]);
		continue;	/* skip this source file */
	    }
	    err = (LYExecv(program, args, tmpbuf) <= 0);
	    FREE(args[src]);
	    if (err) {
		FREE(tmpbuf);
		FREE(tmpdest);
		return ((count == 0) ? -1 : count);
	    }
	    count++;
	}
	clear_tags();
    }
    FREE(tmpbuf);
    FREE(tmpdest);
    HTInfoMsg(gettext("Installation complete"));
    return count;
}
#endif /* OK_INSTALL */

/*
 * Clear DIRED tags.
 */
void clear_tags(void)
{
    char *cp = NULL;

    while ((cp = (char *) HTList_removeLastObject(tagged)) != NULL) {
	FREE(cp);
    }
    if (HTList_isEmpty(tagged))
	FREE(tagged);
}

/*
 * Handle DIRED menu item.
 */
void add_menu_item(char *str)
{
    struct dired_menu *tmp, *mp;
    char *cp;

    /*
     * First custom menu definition causes entire default menu to be discarded.
     */
    if (menu_head == defmenu)
	menu_head = NULL;

    tmp = typecalloc(struct dired_menu);

    if (tmp == NULL)
	outofmem(__FILE__, "add_menu_item");

    /*
     * Conditional on tagged != NULL ?
     */
    cp = strchr(str, ':');
    *cp++ = '\0';
    if (strcasecomp(str, "tag") == 0) {
	tmp->cond = DE_TAG;
    } else if (strcasecomp(str, "dir") == 0) {
	tmp->cond = DE_DIR;
    } else if (strcasecomp(str, "file") == 0) {
	tmp->cond = DE_FILE;
#ifdef S_IFLNK
    } else if (strcasecomp(str, "link") == 0) {
	tmp->cond = DE_SYMLINK;
#endif /* S_IFLNK */
    }

    /*
     * Conditional on matching suffix.
     */
    str = cp;
    cp = strchr(str, ':');
    *cp++ = '\0';
    StrAllocCopy(tmp->sfx, str);

    str = cp;
    cp = strchr(str, ':');
    *cp++ = '\0';
    StrAllocCopy(tmp->link, str);

    str = cp;
    cp = strchr(str, ':');
    *cp++ = '\0';
    StrAllocCopy(tmp->rest, str);

    StrAllocCopy(tmp->href, cp);

    if (menu_head) {
	for (mp = menu_head; mp && mp->next != NULL; mp = mp->next) ;
	mp->next = tmp;
    } else
	menu_head = tmp;
}

void reset_dired_menu(void)
{
    if (menu_head != defmenu) {
	struct dired_menu *mp, *mp_next = NULL;

	for (mp = menu_head; mp != NULL; mp = mp_next) {
	    FREE(mp->sfx);
	    FREE(mp->link);
	    FREE(mp->rest);
	    FREE(mp->href);
	    mp_next = mp_next;
	    FREE(mp);
	}
	menu_head = NULL;
    }
}

/*
 * Create URL for DIRED HREF value.
 */
static char *render_item(const char *s,
			 const char *path,
			 const char *dir,
			 char *buf,
			 int bufsize,
			 BOOLEAN url_syntax)
{
    const char *cp;
    char *bp;
    char overrun = '\0';
    char *taglist = NULL;

#define BP_INC (bp>buf+bufsize-2 ?  &overrun : bp++)
    /* Buffer overrun could happen for very long
       tag list, if %l or %t are used */
    bp = buf;
    while (*s && !overrun) {
	if (*s == '%') {
	    s++;
	    switch (*s) {
	    case '%':
		*BP_INC = '%';
		break;
	    case 'p':
		cp = path;
		if (!LYIsHtmlSep(*cp))
		    *BP_INC = '/';
		while (*cp)
		    *BP_INC = *cp++;
		break;
	    case 'd':
		cp = dir;
		if (!LYIsHtmlSep(*cp))
		    *BP_INC = '/';
		while (*cp)
		    *BP_INC = *cp++;
		break;
	    case 'f':
		cp = LYLastPathSep(path);
		if (cp)
		    cp++;
		else
		    cp = path;
		while (*cp)
		    *BP_INC = *cp++;
		break;
	    case 'l':
	    case 't':
		if (!HTList_isEmpty(tagged)) {
		    HTList *cur = tagged;
		    char *name;

		    while (!overrun &&
			   (name = (char *) HTList_nextObject(cur)) != NULL) {
			if (*s == 'l' && (cp = strrchr(name, '/')))
			    cp++;
			else
			    cp = name;
			StrAllocCat(taglist, cp);
			StrAllocCat(taglist, " ");	/* should this be %20? */
		    }
		}
		if (taglist) {
		    /* could HTUnescape here... */
		    cp = taglist;
		    while (*cp)
			*BP_INC = *cp++;
		    FREE(taglist);
		}
		break;
	    default:
		*BP_INC = '%';
		*BP_INC = *s;
		break;
	    }
	} else {
	    /*
	     * Other chars come from the lynx.cfg or the default.  Let's assume
	     * there isn't anything weird there that needs escaping.
	     */
	    *BP_INC = *s;
	}
	s++;
    }
    if (overrun & url_syntax) {
	HTAlert(gettext("Temporary URL or list would be too long."));
	bp = buf;		/* set to start, will return empty string as URL */
    }
    *bp = '\0';
    return buf;
}

#endif /* DIRED_SUPPORT */
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d2 28
a29 28
**  Routines to manipulate the local filesystem.
**  Written by: Rick Mallett, Carleton University
**  Report problems to rmallett@@ccs.carleton.ca
**  Modified 18-Dec-95 David Trueman (david@@cs.dal.ca):
**	Added OK_PERMIT compilation option.
**	Support replacement of compiled-in f)ull menu configuration via
**	  DIRED_MENU definitions in lynx.cfg, so that more than one menu
**	  can be driven by the same executable.
**  Modified Oct-96 Klaus Weide (kweide@@tezcat.com):
**	Changed to use the library's HTList_* functions and macros for
**	  managing the list of tagged file URLs.
**	Keep track of proper level of URL escaping, so that unusual filenames
**	  which contain #% etc. are handled properly (some HTUnEscapeSome()'s
**	  left in to be conservative, and to document where superfluous
**	  unescaping took place before).
**	Dynamic memory instead of fixed length buffers in a few cases.
**	Other minor changes to make things work as intended.
**  Modified Jun-97 Klaus Weide (kweide@@tezcat.com) & FM:
**	Modified the code handling DIRED_MENU to do more careful
**	  checking of the selected file.  In addition to "TAG", "FILE", and
**	  "DIR", DIRED_MENU definitions in lynx.cfg now also recognize LINK as
**	  a type.  DIRED_MENU definitions with a type field of "LINK" are only
**	  used if the current selection is a symbolic link ("FILE" and "DIR"
**	  definitions are not used in that case).  The default menu
**	  definitions have been updated to reflect this change, and to avoid
**	  the showing of menu items whose action would always fail - KW
**	Cast all code into the Lynx programming style. - FM
*/
d80 3
a82 4
PRIVATE char *get_filename PARAMS((
	char *		prompt,
	char *		buf,
	size_t		bufsize));
d85 3
a87 4
PRIVATE int permit_location PARAMS((
	char *		destpath,
	char *		srcpath,
	char **		newpath));
d89 4
a92 5

PRIVATE char *render_item PARAMS((
	CONST char *	s,
	CONST char *	path,
	CONST char *	dir,
d95 1
a95 1
	BOOLEAN		url_syntax));
a96 1
PRIVATE struct dired_menu *menu_head = NULL;
d108 5
a112 1
} defmenu[] = {
d114 4
a117 4
 *  The following initializations determine the contents of the f)ull menu
 *  selection when in dired mode.  If any menu entries are defined in the
 *  configuration file via DIRED_MENU lines, then these default entries
 *  are discarded entirely.
d263 1
d265 1
a265 1
PRIVATE BOOLEAN cannot_stat ARGS1(CONST char *, name)
d268 1
d277 1
a277 1
PRIVATE BOOLEAN ok_stat ARGS2(CONST char *, name, struct stat*, sb)
d287 1
a287 1
PRIVATE BOOLEAN ok_lstat ARGS2(char *, name, struct stat*, sb)
d299 1
a299 1
PRIVATE BOOLEAN ok_file_or_dir ARGS1(struct stat*, sb)
d302 1
a302 1
     && !S_ISREG(sb->st_mode)) {
d310 1
a310 1
PRIVATE BOOLEAN ok_localname ARGS2(char*, dst, CONST char*, src)
d315 1
a315 1
     || !ok_file_or_dir(&dir_info)) {
d328 1
a328 1
 *  Execute DIRED command, return -1 or 0 on failure, 1 success.
d330 3
a332 4
PRIVATE int LYExecv ARGS3(
	CONST char *,	path,
	char **,	argv,
	char *,		msg)
d335 1
d341 1
d351 1
d354 1
d365 1
a365 1
    rc = 1;		/* It will work */
d367 1
a367 1
    pid = fork();	/* fork and execute command */
d370 4
a373 4
	case -1:
	    HTSprintf0(&tmpbuf, gettext("Unable to %s due to system error!"), msg);
	    rc = 0;
	    break;	/* don't fall thru! - KW */
d375 1
a375 1
	case 0:  /* child */
d377 1
a377 1
	    execvp(path, argv);	/* this uses our $PATH */
d379 1
a379 1
	    execv(path, argv);
d381 2
a382 2
	    exit(EXIT_FAILURE);	/* execv failed, give wait() something to look at */
	    /*NOTREACHED*/
d384 1
a384 1
	default:  /* parent */
d386 1
a386 2
	    while (wait(&wstatus) != pid)
		; /* do nothing */
d388 1
a388 1
	    while (-1 == waitpid(pid, &wstatus, 0)) { /* wait for child */
d390 2
a391 2
		if (errno == EINTR)
		    continue;
d394 2
a395 2
		if (errno == ERESTARTSYS)
		    continue;
d397 2
a398 2
		break;
	    }
d400 9
a408 8
	    if ((WIFEXITED(wstatus)
	      && (WEXITSTATUS(wstatus) != 0))
	     || (WIFSIGNALED(wstatus)
	      && (WTERMSIG(wstatus) > 0)))	{ /* error return */
		HTSprintf0(&tmpbuf, gettext("Probable failure to %s due to system error!"),
				   msg);
		rc = 0;
	    }
d414 2
a415 2
	 *  Screen may have message from the failed execv'd command.
	 *  Give user time to look at it before screen refresh.
a424 1

d426 1
a426 1
    return(rc);
d429 1
a429 1
PRIVATE int make_directory ARGS1(char *, path)
d432 1
a432 1
    CONST char *program;
d438 1
a438 1
	HTSprintf0(&msg,"make directory %s", path);
d454 1
a454 1
PRIVATE int remove_file ARGS1(char *, path)
d457 1
a457 1
    CONST char *program;
d476 1
a476 1
PRIVATE int remove_directory ARGS1(char *, path)
d479 1
a479 1
    CONST char *program;
d497 1
a497 1
PRIVATE int touch_file ARGS1(char *, path)
d500 1
a500 1
    CONST char *program;
d514 1
d525 1
a525 1
PRIVATE int move_file ARGS2(char *, source, char *, target)
d528 1
a528 1
    CONST char *program;
d544 1
d547 1
a547 1
	 && S_ISDIR(sb.st_mode)) {
d564 1
a564 1
PRIVATE BOOLEAN not_already_exists ARGS1(char *, name)
d584 1
a584 1
PRIVATE BOOLEAN dir_has_same_owner ARGS2(struct stat *, info, int, owner)
d599 1
a599 1
 *  Remove all tagged files and directories.
d601 1
a601 1
PRIVATE int remove_tagged NOARGS
d612 1
a612 1
    if (HTList_isEmpty(tagged))  /* should never happen */
d619 2
a620 2
    while (ans == YES && (cp = (char *)HTList_nextObject(tag)) != NULL) {
	if (is_url(cp) == FILE_URL_TYPE) { /* unnecessary check */
d626 1
a626 1
	     *	Check the current status of the path to be deleted.
d633 2
a634 1
		    if (count == 0) count = -1;
d651 5
a655 6
 *  Move all tagged files and directories to a new location.
 *  Input is current directory.
 *  The tests in this function can, at best, prevent some user mistakes -
 *   anybody who relies on them for security is seriously misguided.
 *  If a user has enough permissions to move a file somewhere, the same
 *   uid with Lynx & dired can do the same thing.
d657 1
a657 2
PRIVATE int modify_tagged ARGS1(
	char *,		testpath)
d670 1
a670 1
    if (HTList_isEmpty(tagged))  /* should never happen */
a677 3
    /*
     *	Determine the ownership of the current location.
     */
d679 5
a683 2
	 *  This test used to always fail from the dired menu...
	 *  changed to something that hopefully makes more sense - KW
d685 1
a685 1
	if (testpath && *testpath && 0!=strcmp(testpath,"/")) {
d687 2
a688 2
	     *	testpath passed in and is not empty and not a single "/"
	     *	(which would probably be bogus) - use it.
d693 1
a693 1
	     *	Prepare to get directory path from one of the tagged files.
d695 1
a695 1
	    cp = HTList_lastObject(tagged);
d702 1
a702 1
	     *	Get the directory containing the file or subdir.
d706 1
a706 1
		cp = HTParse(".", cp, PARSE_PATH+PARSE_PUNCTUATION);
d709 1
a709 1
	    } else {	/* Last resort, should never happen. */
d727 2
a728 2
	 *  Save the owner of the current location for later use.
	 *  Also save the device and inode for location checking/
d735 1
a735 1
	 *  Replace ~/ references to the home directory.
d739 1
d748 1
a748 1
	    LYstrncpy(tmpbuf, cp1, sizeof(tmpbuf)-1);
d753 1
a753 1
	 *  If path is relative, prefix it with current location.
d757 1
a757 1
	    StrAllocCat(savepath,tmpbuf);
d759 1
a759 1
	    StrAllocCopy(savepath,tmpbuf);
d763 1
a763 1
	 *  stat() the target location to determine type and ownership.
d771 1
a771 1
	 *  Make sure the source and target locations are not the same place.
d780 2
a781 2
	 *  Make sure the target location is a directory which is owned
	 *  by the same uid as the owner of the current location.
d788 1
a788 1
	     *  Move all tagged items to the target location.
d790 1
a790 1
	    while ((cp = (char *)HTList_nextObject(tag)) != NULL) {
d811 1
a811 1
 *  Modify the name of the specified item.
d813 1
a813 2
PRIVATE int modify_name ARGS1(
	char *,		testpath)
d815 1
a815 1
    char *cp;
d822 1
a822 1
     *	Determine the status of the selected item.
d828 1
a828 1
	 *  Change the name of the file or directory.
d831 1
a831 1
	     cp = gettext("Enter new name for directory: ");
d833 1
a833 1
	     cp = gettext("Enter new name for file: ");
d835 1
a835 1
	     return ok_file_or_dir(&dir_info);
d837 1
a837 1
	LYstrncpy(tmpbuf, LYPathLeaf(testpath), sizeof(tmpbuf)-1);
d842 1
a842 1
	 *  Do not allow the user to also change the location at this time.
d848 2
a849 1
		HTSprintf0(&newpath, "%.*s%s", (cp - testpath + 1), testpath, tmpbuf);
d854 1
a854 1
	     *	Make sure the destination does not already exist.
d867 1
a867 1
 *  Change the location of a file or directory.
d869 1
a869 2
PRIVATE int modify_location ARGS1(
	char *,		testpath)
d871 2
a872 1
    char *cp;
d883 1
a883 1
     *	Determine the status of the selected item.
d891 1
a891 1
     *	Change the location of the file or directory.
d905 1
a905 1
    LYstrncpy(tmpbuf, testpath, sizeof(tmpbuf)-1);
d914 1
a914 1
	 *  Allow ~/ references to the home directory.
d917 1
a917 1
	 || !strcmp(tmpbuf,"~")) {
d920 1
a920 1
	    LYstrncpy(tmpbuf, newpath, sizeof(tmpbuf)-1);
d924 2
a925 2
	} else if ((cp = LYLastPathSep(newpath)) != NULL) {
	    *++cp = '\0';
d935 1
a935 1
	 *  Make sure the source and target have the same owner (uid).
d945 1
a945 1
	 *  Make sure the source and target are not the same location.
d953 1
a953 1
	    code = move_file(savepath,newpath);
d962 1
a962 1
 *  Modify name or location of a file or directory on localhost.
d964 1
a964 3
PUBLIC int local_modify ARGS2(
	DocInfo *,	doc,
	char **,	newpath)
d968 1
a968 1
    char testpath[DIRED_MAXBUF]; /* a bit ridiculous */
d977 2
a978 2
	if (doc->link > (nlinks-count - 1))
	    doc->link = (nlinks-count - 1);
d980 1
a980 1
				  0 : doc->link;
d985 1
a985 1
	 *  Added protection.
d991 2
a992 2
     *	Do not allow simultaneous change of name and location as in Unix.
     *	This reduces functionality but reduces difficulty for the novice.
d1007 1
a1007 1
	LYstrncpy(testpath, cp, sizeof(testpath)-1);
d1011 1
a1011 1
	    return(modify_name(testpath));
d1014 1
a1014 1
		if (doc->link == (nlinks-1))
d1020 1
a1020 1
	    return(permit_location(NULL, testpath, newpath));
d1024 1
a1024 1
	     *	Code for changing ownership needed here.
d1033 1
a1033 1
 *  Create a new empty file in the current directory.
d1035 1
a1035 2
PRIVATE int create_file ARGS1(
	char *,		current_location)
d1040 1
a1040 1
    char *bad_chars = ".~/";
d1057 1
a1057 1
	     *  Append the target filename to the current location.
d1062 1
a1062 1
	     *  Make sure the target does not already exist
d1074 1
a1074 1
 *  Create a new directory in the current directory.
d1076 1
a1076 2
PRIVATE int create_directory ARGS1(
	char *,		current_location)
d1081 1
a1081 1
    char *bad_chars = ".~/";
d1100 1
a1100 1
	     *  Make sure the target does not already exist.
d1112 1
a1112 1
 *  Create a file or a directory at the current location.
d1114 1
a1114 2
PUBLIC int local_create ARGS1(
	DocInfo *,	doc)
d1125 1
a1125 1
    strcpy(testpath,cp);
d1132 1
a1132 1
	return(create_file(testpath));
d1134 1
a1134 1
	return(create_directory(testpath));
d1141 1
a1141 1
 *  Remove a single file or directory.
d1143 1
a1143 2
PRIVATE int remove_single ARGS1(
	char *,		testpath)
d1156 1
a1156 1
     *	Locate the filename portion of the path.
d1164 4
a1167 2
	/*** This strlen stuff will probably screw up intl translations /jes ***/
	/*** Course, it's probably broken for screen sizes other 80, too     ***/
d1170 1
a1170 1
		       gettext("Remove '%s' and all of its contents?"), cp);
d1173 1
a1173 1
		       gettext("Remove directory and all of its contents?"));
d1198 2
a1199 2
	     ? remove_directory(testpath)
	     : remove_file(testpath);
d1206 1
a1206 1
 *  Remove a file or a directory.
d1208 1
a1208 2
PUBLIC int local_remove ARGS1(
	DocInfo *,	doc)
d1216 2
a1217 2
	if (doc->link > (nlinks-count - 1))
	    doc->link = (nlinks-count - 1);
d1219 1
a1219 1
				  0 : doc->link;
d1248 1
a1248 1
PRIVATE char LYValidPermitFile[LY_MAXPATH] = "\0";
d1250 1
a1250 1
PRIVATE long permit_bits ARGS1(char *, string_mode)
d1252 18
a1269 9
    if (!strcmp(string_mode, "IRUSR")) return S_IRUSR;
    if (!strcmp(string_mode, "IWUSR")) return S_IWUSR;
    if (!strcmp(string_mode, "IXUSR")) return S_IXUSR;
    if (!strcmp(string_mode, "IRGRP")) return S_IRGRP;
    if (!strcmp(string_mode, "IWGRP")) return S_IWGRP;
    if (!strcmp(string_mode, "IXGRP")) return S_IXGRP;
    if (!strcmp(string_mode, "IROTH")) return S_IROTH;
    if (!strcmp(string_mode, "IWOTH")) return S_IWOTH;
    if (!strcmp(string_mode, "IXOTH")) return S_IXOTH;
d1275 1
a1275 1
 *  Handle DIRED permissions.
d1277 3
a1279 4
PRIVATE int permit_location ARGS3(
	char *,		destpath,
	char *,		srcpath,
	char **,	newpath)
d1283 1
a1283 1
    return(0);
d1289 1
a1289 1
    CONST char *program;
d1293 1
a1293 1
	 *  Create form.
d1296 2
a1297 2
	char * user_filename;
	char * group_name;
d1302 1
a1302 1
	 *  A couple of sanity tests.
d1305 1
a1305 1
	 || !ok_file_or_dir(&dir_info))
d1313 1
a1313 1
	    return(0);
d1322 1
a1322 1
	group_name = HTAA_GidToName (dir_info.st_gid);
d1329 4
a1332 3
      fprintf(fp0,"<H1>%s%s</H1>\n", PERMISSIONS_SEGMENT, user_filename);
	{   /*
	     *	Prevent filenames which include '#' or '?' from messing it up.
d1334 2
a1335 1
	    char * srcpath_url = HTEscape(srcpath, URL_PATH);
d1341 2
a1342 1
	fprintf(fp0, "<Ol><Li>%s<Br><Br>\n", gettext("Specify permissions below:"));
d1345 1
a1345 1
     "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRUSR\" %s> Read<Br>\n",
d1348 1
a1348 1
    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWUSR\" %s> Write<Br>\n",
d1351 1
a1351 1
	 *  If restricted, only change eXecute permissions on directories.
d1355 3
a1357 3
       "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXUSR\" %s> %s<Br>\n",
		(dir_info.st_mode & S_IXUSR) ? "checked" : "",
		S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");
d1361 1
a1361 1
     "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRGRP\" %s> Read<Br>\n",
d1364 1
a1364 1
    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWGRP\" %s> Write<Br>\n",
d1367 1
a1367 1
	 *  If restricted, only change eXecute permissions on directories.
d1371 3
a1373 3
       "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXGRP\" %s> %s<Br>\n",
		(dir_info.st_mode & S_IXGRP) ? "checked" : "",
		S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");
d1377 1
a1377 1
     "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IROTH\" %s> Read<Br>\n",
d1380 1
a1380 1
    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWOTH\" %s> Write<Br>\n",
d1383 1
a1383 1
	 *  If restricted, only change eXecute permissions on directories.
d1387 3
a1389 3
       "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXOTH\" %s> %s<Br>\n",
		(dir_info.st_mode & S_IXOTH) ? "checked" : "",
		S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");
d1391 2
a1392 2
      fprintf(fp0,
"<Br>\n<Li><Input Type=\"submit\" Value=\"Submit\">  %s %s %s.\n</Ol>\n</Form>\n",
d1400 1
a1400 1
	return(PERMIT_FORM_RESULT);	 /* Special flag for LYMainLoop */
d1402 1
a1402 1
    } else {				 /* The form being activated. */
d1406 2
a1407 3
	 *  Make sure we have a valid set-permission
	 *  file comparison string loaded via a previous
	 *  call with srcpath != NULL. - KW
d1415 2
a1416 2
			(destpath ?
			 destpath : "NULL URL pointer")));
d1420 1
a1420 1
	while (*cp != '\0' && *cp != '?') { /* Find filename */
d1424 1
a1424 1
	    return(0);	/* Nothing to permit. */
d1426 2
a1427 2
	*cp++ = '\0';	/* Null terminate file name and
			   start working on the masks. */
d1431 1
a1431 1
		return(0);
d1434 1
a1434 1
	    return(0);
d1441 2
a1442 2
	 *  Make sure that the file string is the one from
	 *  the last displayed File Permissions menu. - KW
d1450 1
a1450 1
			destpath));
d1455 1
a1455 1
	 *  A couple of sanity tests.
d1459 1
a1459 1
	 || !ok_file_or_dir(&dir_info)) {
d1464 1
a1464 1
	 *  Cycle over permission strings.
d1466 1
a1466 1
	while(*cp != '\0') {
d1469 1
a1469 1
	    while(*cr != '\0' && *cr != '&') { /* GET data split by '&'. */
d1475 1
a1475 1
	    if (strncmp(cp, "mode=", 5) == 0) { /* Magic string. */
d1480 2
a1481 2
		     *  If restricted, only change eXecute
		     *  permissions on directories.
d1484 2
a1485 2
		     || strchr(cp+5, 'X') == NULL
		     || S_ISDIR(dir_info.st_mode))
d1500 1
a1500 1
	 *  Call chmod().
d1507 2
a1508 2
	    HTSprintf0(&tmpbuf, "chmod %.4o %s", (unsigned int)new_mode, destpath);
	    sprintf(amode, "%.4o", (unsigned int)new_mode);
d1530 1
a1530 1
 *  Display or remove a tag from a given link.
d1532 2
a1533 3
PUBLIC void tagflag ARGS2(
	int,		flag,
	int,		cur)
d1537 1
a1537 1
	stop_reverse();
d1546 1
a1546 1
	    LYHideCursor(); /* get cursor out of the way */
d1550 1
a1550 1
	     *	Never hide the cursor if there's no FANCY CURSES.
d1559 1
a1559 1
 *  Handle DIRED tags.
d1561 1
a1561 2
PUBLIC void showtags ARGS1(
	HTList *,	t)
d1569 1
a1569 1
	while ((name = HTList_nextObject(s)) != NULL) {
d1578 1
a1578 2
PRIVATE char * DirectoryOf ARGS1(
	char *,		pathname)
d1587 1
a1587 1
	CONST char *result1 = 0;
d1593 1
a1593 1
	StrAllocCopy (result, result1);
d1603 1
a1603 2
PRIVATE char * LYonedot ARGS1(
	char *,		line)
d1608 2
a1609 2
    if (pathconf (line, _PC_NAME_MAX) <= 12) {
	LYstrncpy(line1, line, sizeof(line1)-1);
d1612 1
a1612 1
	     || LYLastPathSep(dot) != 0) {
d1620 1
a1620 1
	return(line1);
d1622 1
a1622 1
    return(line);
d1628 2
a1629 3
PRIVATE char * match_op ARGS2(
	CONST char *,	prefix,
	char *,		data)
d1634 1
a1634 1
     && !strncmp(prefix, data + 12, (unsigned)len)) {
d1647 2
a1648 2
 *  Construct the appropriate system command taking care to
 *  escape all path references to avoid spoofing the shell.
d1650 3
a1652 4
PRIVATE char *build_command ARGS3(
	char *,		line,
	char *,		dirname,
	char *,		arg)
d1655 2
a1656 2
    CONST char *program;
    CONST char *tar_path = HTGetProgramPath(ppTAR);
a1666 1

d1685 1
a1685 1
#define FMT_UNTAR_GZ "cd %s; %s -qdc %s |  %s -xf -"
d1692 3
a1694 1
		HTEndParam(&buffer, FMT_UNTAR_GZ, 4);
d1698 1
a1698 1
#  endif /* OK_GZIP */
d1700 1
a1700 1
#define FMT_UNTAR_Z "cd %s; %s %s |  %s -xf -"
d1707 3
a1709 1
		HTEndParam(&buffer, FMT_UNTAR_Z, 4);
d1714 1
a1714 1
#define FMT_UNTAR "cd %s; %s -xf %s"
d1718 3
a1720 2
	    HTAddParam(&buffer, FMT_UNTAR, 3, arg);
	    HTEndParam(&buffer, FMT_UNTAR, 3);
d1723 1
a1723 1
# endif /* !ARCHIVE_ONLY */
d1727 1
a1727 1
#define FMT_TAR_GZ "cd %s; %s -cf - %s | %s -qc >%s%s"
d1732 7
a1738 5
		HTAddParam(&buffer, FMT_TAR_GZ, 3, LYPathLeaf(arg));
		HTAddParam(&buffer, FMT_TAR_GZ, 4, program);
		HTAddParam(&buffer, FMT_TAR_GZ, 5, LYonedot(LYPathLeaf(arg)));
		HTAddParam(&buffer, FMT_TAR_GZ, 6, EXT_TAR_GZ);
		HTEndParam(&buffer, FMT_TAR_GZ, 6);
d1742 1
a1742 1
# endif /* OK_GZIP */
d1745 1
a1745 1
#define FMT_TAR_Z "cd %s; %s -cf - %s | %s >%s%s"
d1750 7
a1756 5
		HTAddParam(&buffer, FMT_TAR_Z, 3, LYPathLeaf(arg));
		HTAddParam(&buffer, FMT_TAR_Z, 4, program);
		HTAddParam(&buffer, FMT_TAR_Z, 5, LYonedot(LYPathLeaf(arg)));
		HTAddParam(&buffer, FMT_TAR_Z, 6, EXT_TAR_Z);
		HTEndParam(&buffer, FMT_TAR_Z, 6);
d1762 1
a1762 1
#define FMT_TAR "cd %s; %s -cf %s.tar %s"
d1766 5
a1770 3
	    HTAddParam(&buffer, FMT_TAR, 3, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_TAR, 4, LYPathLeaf(arg));
	    HTEndParam(&buffer, FMT_TAR, 4);
d1824 1
a1824 1
# endif /* !ARCHIVE_ONLY */
d1841 13
a1853 15
 *  Perform file management operations for LYNXDIRED URL's.
 *  Attempt to be consistent.  These are (pseudo) URLs - i.e., they should
 *  be in URL syntax: some bytes will be URL-escaped with '%'.	This is
 *  necessary because these (pseudo) URLs will go through some of the same
 *  kinds of interpretations and mutilations as real ones: HTParse, stripping
 *  off #fragments etc.  (Some access schemes currently have special rules
 *  about not escaping parsing '#' "the URL way" built into HTParse, but that
 *  doesn't look like a clean way.)
 */
PUBLIC int local_dired ARGS1(
	DocInfo *,	doc)
{
    char *line_url;    /* will point to doc's address, which is a URL */
    char *line = NULL; /* same as line_url, but HTUnEscaped, will be alloced */
    char *arg = NULL; /* ...will point into line[] */
d1862 3
a1864 2
		(line_url ?
		 line_url : gettext("NULL URL pointer"))));
d1868 2
a1869 2
    HTUnEscape(line);	/* _file_ (not URL) syntax, for those functions
			   that need it.  Don't forget to FREE it. */
d1875 1
a1875 1
	arg = "blah";	/* do something to avoid cc's complaints */
d1909 1
a1909 1
	     *	One of the checks may have failed.
d1929 3
a1931 4
	 *  They're written by LYUpload_options() HTUnEscaped;
	 *  don't want to change that for now... so pass through
	 *  without more unescaping.  Directory names containing
	 *  '#' will probably fail.
d1945 1
a1945 1
	    if ((int) strlen(buffer) < LYcols - 15) {
d1974 1
a1974 1
 *  Provide a menu of file management options.
d1976 1
a1976 3
PUBLIC int dired_options ARGS2(
	DocInfo *,	doc,
	char **,	newfile)
d1992 1
a1992 1
	return(0);
d1995 1
a1995 1
     *  Make the tempfile a URL.
d2000 1
a2000 1
    if (doc->link > -1 && doc->link < (nlinks+1)) {
d2032 2
a2033 3
	 *  Write out number of tagged items, and names of first
	 *  few of them relative to current (in the DIRED sense)
	 *  directory.
d2039 1
d2043 3
a2045 1
		n, ((n == 1) ? gettext("tagged item:") : gettext("tagged items:")));
d2051 1
a2051 1
	    cp1 = HTRelative(HTList_objectAt(tagged, i-1),
d2054 1
a2054 1
	    LYEntify(&cp1, TRUE); /* _should_ do this everywhere... */
d2056 1
a2056 1
			 (i == 1 ? "" : " ,"), cp1);
d2060 1
a2060 1
	    fprintf(fp0," , ...");
d2067 1
a2067 1
     *	If menu_head is NULL then use defaults and link them together now.
d2096 1
a2096 1
	dir_url  = HTEscape(dir, URL_PATH);
d2099 1
a2099 1
		render_item(mp->href, path_url, dir_url, buf,sizeof(buf), YES));
d2101 1
a2101 1
		render_item(mp->link, path, dir, buf,sizeof(buf), NO));
d2103 1
a2103 1
		render_item(mp->rest, path, dir, buf,sizeof(buf), NO));
d2115 1
a2115 1
		"<a href=\"LYNXDIRED://UPLOAD=%d/TO=%s\"> %s </a><br>\n",
d2126 1
a2126 1
    return(0);
d2130 1
a2130 1
 *  Check DIRED filename.
d2132 3
a2134 4
PRIVATE char *get_filename ARGS3(
	char *,		prompt,
	char *,		buf,
	size_t,		bufsize)
d2147 1
a2147 1
	cp = LYLastPathSep(buf); /* find last slash */
d2164 3
a2166 2
static char ** install_argp = NULL;	/* args for execv install */
static char * install_path = NULL;	/* auxiliary */
d2168 1
a2168 1
PRIVATE void clear_install_path NOARGS
d2176 15
a2190 17
 *  Fill in args array for execv (or execvp etc.) call, after first
 *  allocating it if necessary.  No fancy parsing, cmd_args is just
 *  split at spaces.  Leave room for reserve additional args to be
 *  added by caller.
 *  On success *argvp points to new args vector, *pathp is auxiliary.
 *  On success returns index of next argument, else -1.
 *  This is generic enough that it could be used for other calls than
 *  install, except the atexit call.  Go through this trouble for install
 *  because INSTALL_ARGS may be significant, and someone may configure it
 *  with more than one significant flags. - kw
 */
PRIVATE int fill_argv_for_execv ARGS5(
    char ***,		argvp,
    char **,		pathp,
    char *,		cmd_path,
    CONST char *,	cmd_args,
    int,		reserve)
d2196 1
d2198 2
a2199 1
	*argvp = typecallocn(char *, LYEXECV_MAX_ARGC+1);
d2201 1
a2201 1
	    return(-1);
d2218 2
a2219 2
		       NONNULL(cmd_path), cmd_args));
		return(-1);
d2225 2
a2226 2
    args[n] = (char *)0;
    return(n);
d2230 1
a2230 1
 *  Install the specified file or directory.
d2232 3
a2234 4
PUBLIC BOOLEAN local_install ARGS3(
	char *,		destpath,
	char *,		srcpath,
	char **,	newpath)
d2237 3
a2239 2
    static char savepath[DIRED_MAXBUF]; /* This will be the link that
					   is to be installed. */
d2246 1
a2246 1
    int n = 0;		/* indices into 'args[]' */
d2248 1
a2248 1
    CONST char *program;
d2256 1
a2256 1
     *	Determine the status of the selected item.
d2262 1
d2309 1
a2309 1
    } else if (0 /*directory not writable*/) {
d2332 1
a2332 1
	    HTAlert(gettext("Error buiding install args"));
d2341 1
a2341 1
    args[n] = (char *)0;
d2350 1
a2350 1
	    return(-1);		/* don't do it */
d2369 1
d2371 1
a2371 1
	while ((name = (char *)HTList_nextObject(tag))) {
d2373 1
d2409 1
a2409 1
 *  Clear DIRED tags.
d2411 1
a2411 1
PUBLIC void clear_tags NOARGS
d2415 1
a2415 1
    while ((cp = HTList_removeLastObject(tagged)) != NULL) {
d2423 1
a2423 1
 *  Handle DIRED menu item.
d2425 1
a2425 2
PUBLIC void add_menu_item ARGS1(
	char *,		str)
d2427 1
a2427 1
    struct dired_menu *new, *mp;
d2431 1
a2431 2
     *	First custom menu definition causes entire default menu to be
     *	discarded.
d2436 3
a2438 2
    new = typecalloc(struct dired_menu);
    if (new == NULL)
d2442 1
a2442 1
     *	Conditional on tagged != NULL ?
d2447 1
a2447 1
	new->cond = DE_TAG;
d2449 1
a2449 1
	new->cond = DE_DIR;
d2451 1
a2451 1
	new->cond = DE_FILE;
d2454 1
a2454 1
	new->cond = DE_SYMLINK;
d2459 1
a2459 1
     *	Conditional on matching suffix.
d2464 1
a2464 1
    StrAllocCopy(new->sfx, str);
d2469 1
a2469 1
    StrAllocCopy(new->link, str);
d2474 1
a2474 1
    StrAllocCopy(new->rest, str);
d2476 1
a2476 1
    StrAllocCopy(new->href, cp);
d2479 2
a2480 3
	for (mp = menu_head; mp && mp->next != NULL; mp = mp->next)
	    ;
	mp->next = new;
d2482 1
a2482 1
	menu_head = new;
d2485 1
a2485 1
PUBLIC void reset_dired_menu NOARGS
d2489 1
d2503 1
a2503 1
 *  Create URL for DIRED HREF value.
d2505 6
a2510 7
PRIVATE char * render_item ARGS6(
	CONST char *,	s,
	CONST char *,	path,
	CONST char *,	dir,
	char *,		buf,
	int,		bufsize,
	BOOLEAN,	url_syntax)
d2512 1
a2512 1
    CONST char *cp;
d2516 1
d2518 2
a2519 2
				/* Buffer overrun could happen for very long
				   tag list, if %l or %t are used */
d2525 22
a2546 4
		case '%':
		    *BP_INC = '%';
		    break;
		case 'p':
d2548 22
a2569 2
		    if (!LYIsHtmlSep(*cp))
			*BP_INC = '/';
d2572 7
a2578 45
		    break;
		case 'd':
		    cp = dir;
		    if (!LYIsHtmlSep(*cp))
			*BP_INC = '/';
		    while (*cp)
			*BP_INC = *cp++;
		    break;
		case 'f':
		    cp = LYLastPathSep(path);
		    if (cp)
			cp++;
		    else
			cp = path;
		    while (*cp)
			*BP_INC = *cp++;
		    break;
		case 'l':
		case 't':
		    if (!HTList_isEmpty(tagged)) {
			HTList *cur = tagged;
			char *name;

			while (!overrun &&
			       (name = (char *)HTList_nextObject(cur))!=NULL) {
			    if (*s == 'l' && (cp = strrchr(name, '/')))
				cp++;
			    else
				cp = name;
			    StrAllocCat(taglist, cp);
			    StrAllocCat(taglist, " "); /* should this be %20?*/
			}
		    }
		    if (taglist) {
			/* could HTUnescape here... */
			cp = taglist;
			while (*cp)
			    *BP_INC = *cp++;
			FREE(taglist);
		    }
		    break;
		default:
		    *BP_INC = '%';
		    *BP_INC = *s;
		    break;
d2582 2
a2583 3
	     *	Other chars come from the lynx.cfg or
	     *	the default.  Let's assume there isn't
	     *	anything weird there that needs escaping.
d2585 1
a2585 1
	    *BP_INC =*s;
d2591 1
a2591 1
	bp = buf;	/* set to start, will return empty string as URL */
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d460 1
a460 1
	args[1] = "-rf";
d472 21
d1149 1
d1173 1
d1195 3
a1197 1
	code = remove_file(testpath);
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d46 1
d48 2
a49 4
#ifndef VMS
#ifndef _WINDOWS
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
a50 2
#endif /*_WINDOWS */
#endif /* VMS */
d52 12
a63 6
#ifndef WEXITSTATUS
# ifdef HAVE_TYPE_UNIONWAIT
#  define	WEXITSTATUS(status)	(status.w_retcode)
# else
#  define	WEXITSTATUS(status)	(((status) & 0xff00) >> 8)
# endif
d66 2
a67 6
#ifndef WTERMSIG
# ifdef HAVE_TYPE_UNIONWAIT
#  define	WTERMSIG(status)	(status.w_termsig)
# else
#  define	WTERMSIG(status)	((status) & 0x7f)
# endif
d70 1
a70 1
#include <LYLeaks.h>
d72 7
a78 8
PRIVATE int LYExecv PARAMS((
	char *		path,
	char ** 	argv,
	char *		msg));

#ifdef DIRED_SUPPORT
PUBLIC char LYPermitFileURL[LY_MAXPATH] = "\0";
PUBLIC char LYDiredFileURL[LY_MAXPATH] = "\0";
d86 1
a86 1
PRIVATE BOOLEAN permit_location PARAMS((
d89 1
a89 1
	char ** 	newpath));
d94 2
a95 2
	char *		path,
	char *		dir,
d98 1
a98 1
	BOOLEAN 	url_syntax));
d119 4
d129 1
d131 6
a136 1
"(of current selection)", "LYNXDIRED://INSTALL_SRC%p",		NULL },
d138 2
a139 1
"(of current selection)", "LYNXDIRED://INSTALL_SRC%p",		NULL },
d145 1
d148 1
d161 1
d164 1
d170 1
d173 1
d181 1
a181 1
{ DE_FILE,	".tar.Z", "Expand",
d194 1
a194 1
{ DE_FILE,	    ".Z", "Uncompress",
d223 5
d238 1
a238 1
	  "(using gzip)", "LYNXDIRED://GZIP%p", 		NULL },
d249 5
d261 1
a261 1
		    NULL, NULL, 				NULL }
d264 1
a264 1
PRIVATE BOOLEAN cannot_stat ARGS1(char *, name)
d267 1
a267 1
    HTSprintf(&tmpbuf, gettext("Unable to get status of '%s'."), name);
d273 3
a275 1
PRIVATE BOOLEAN ok_stat ARGS2(char *, name, struct stat*, sb)
d277 2
a278 2
    CTRACE(tfp, "testing ok_stat(%s)\n", name);
    if (stat(name, sb) < 0) {
d287 1
a287 1
    CTRACE(tfp, "testing ok_lstat(%s)\n", name);
d307 2
a308 1
PRIVATE BOOLEAN ok_localname ARGS2(char*, dst, char*, src)
a309 1
    char *s = HTfullURL_toFile(strip_trailing_slash(src));
d312 1
a312 1
    if (!ok_stat(s, &dir_info)
a313 1
	FREE(s);
d316 5
a320 2
    strcpy(dst, s);
    FREE(s);
d323 175
d502 5
a506 2
    char *msg = 0;
    char *args[5];
d508 26
a533 7
    HTSprintf(&msg, gettext("move %s to %s"), source, target);
    args[0] = "mv";
    args[1] = source;
    args[2] = target;
    args[3] = (char *) 0;
    code = (LYExecv(MV_PATH, args, msg) <= 0) ? -1 : 1;
    FREE(msg);
d541 1
a541 1
    if (stat(name, &dir_info) == -1) {
d557 1
a557 1
PRIVATE BOOLEAN dir_has_same_owner ARGS2(struct stat *, info, uid_t, owner)
d560 1
a560 1
	if (info->st_uid == owner) {
d574 1
a574 1
PRIVATE BOOLEAN remove_tagged NOARGS
a583 1
    char *args[5];
d588 1
a588 1
    ans = HTConfirm(gettext("Remove all tagged files and directories "));
d605 1
a605 6
		args[0] = "rm";
		args[1] = "-rf";
		args[2] = testpath;
		args[3] = (char *) 0;
		HTSprintf0(&tmpbuf, gettext("remove %s"), testpath);
		if (LYExecv(RM_PATH, args, tmpbuf) <= 0) {
d611 1
d630 2
a631 2
PRIVATE BOOLEAN modify_tagged ARGS1(
	char *, 	testpath)
d636 1
a636 1
    uid_t owner;
d638 1
a638 1
    char *savepath = NULL;
a671 2
	    if (!cp)	/* Last resort, should never happen. */
		cp = "/";
d678 8
a685 2
	    cp = HTfullURL_toFile(strip_trailing_slash(cp));
	    savepath = HTParse(".", cp, PARSE_PATH+PARSE_PUNCTUATION);
d687 6
a692 2
	    cp = HTfullURL_toFile(cp);
	    StrAllocCopy(savepath, cp);
a693 1
	FREE(cp);
d721 1
a721 1
	    strcpy(tmpbuf, cp1);
d754 1
a754 1
	 * by the same uid as the owner of the current location.
d764 1
a764 2
		cp = HTfullURL_toFile(cp);
		StrAllocCopy(srcpath, cp);
a766 1
		    FREE(cp);
d771 1
a771 1
		FREE(cp);
d786 2
a787 2
PRIVATE BOOLEAN modify_name ARGS1(
	char *, 	testpath)
d790 2
a791 3
    char tmpbuf[512];
    char newpath[512];
    char savepath[512];
d793 1
d811 1
d818 7
a824 8
	if (strchr(tmpbuf, '/') != NULL) {
	    HTAlert(gettext("Illegal character \"/\" found! Request ignored."));
	} else if (strlen(tmpbuf) &&
		   (cp = strrchr(testpath, '/')) != NULL) {
	    strcpy(savepath,testpath);
	    *(++cp) = '\0';
	    strcpy(newpath,testpath);
	    strcat(newpath,tmpbuf);
d830 1
a830 1
		return move_file(savepath, newpath);
d832 2
d836 1
a836 1
    return 0;
d842 2
a843 2
PRIVATE BOOLEAN modify_location ARGS1(
	char *, 	testpath)
d848 1
a848 1
    uid_t owner;
d850 2
a851 2
    char newpath[512];
    char savepath[512];
d853 1
a858 1

d867 6
a872 1
	cp = gettext("Enter new location for directory: ");
d878 2
d883 2
a884 2
	strcpy(savepath, testpath);
	strcpy(newpath, testpath);
d891 9
a899 12
	    strcpy(newpath, Home_Dir());
	    strcat(newpath, (tmpbuf + 1));
	    strcpy(tmpbuf, newpath);
	}
	if (!LYIsPathSep(tmpbuf[0])) {
	    if ((cp = strrchr(newpath,'/')) != NULL) {
		*++cp = '\0';
		strcat(newpath,tmpbuf);
	    } else {
		HTAlert(gettext("Unexpected failure - unable to find trailing \"/\""));
		return 0;
	    }
d901 4
a904 1
	    strcpy(newpath,tmpbuf);
d914 1
a914 1
	    return 0;
d916 1
a916 1

d920 1
a920 1
	if (dev == dir_info.st_dev && inode == dir_info.st_ino) {
d922 1
a922 1
	    return 0;
d924 3
a926 2
	if (dir_has_same_owner(&dir_info, owner)) {
	    return move_file(savepath,newpath);
d928 2
d931 1
a931 1
    return 0;
d937 2
a938 2
PUBLIC BOOLEAN local_modify ARGS2(
	document *,	doc,
d941 1
a941 1
    int c, ans;
d943 1
a943 1
    char testpath[512]; /* a bit ridiculous */
d948 2
a949 1
	strcpy(testpath, cp);
a951 2
	count = modify_tagged(testpath);

d972 1
a972 1
    _statusline(gettext("Modify name, or location (n or l): "));
d974 1
a974 2
    c = LYgetch();
    ans = TOUPPER(c);
d978 5
a982 1
	strcpy(testpath, cp);
d1010 2
a1011 2
PRIVATE BOOLEAN create_file ARGS1(
	char *, 	current_location)
d1014 2
a1015 3
    char tmpbuf[512];
    char testpath[512];
    char *args[5];
d1018 1
d1020 1
a1020 3
		     tmpbuf, sizeof(tmpbuf)) == NULL) {
	return code;
    }
d1022 3
a1024 3
    if (!no_dotfiles && show_dotfiles) {
	bad_chars = "~/";
    }
d1026 5
a1030 5
    if (strstr(tmpbuf, "//") != NULL) {
	HTAlert(gettext("Illegal redirection \"//\" found! Request ignored."));
    } else if (strlen(tmpbuf) && strchr(bad_chars, tmpbuf[0]) == NULL) {
	strcpy(testpath,current_location);
	LYAddPathSep0(testpath);
d1032 4
a1035 4
	/*
	 *  Append the target filename to the current location.
	 */
	strcat(testpath, tmpbuf);
d1037 7
a1043 11
	/*
	 *  Make sure the target does not already exist
	 */
	if (not_already_exists(testpath)) {
	    char *msg = 0;
	    HTSprintf(&msg,gettext("create %s"),testpath);
	    args[0] = "touch";
	    args[1] = testpath;
	    args[2] = (char *) 0;
	    code = (LYExecv(TOUCH_PATH, args, msg) <= 0) ? -1 : 1;
	    FREE(msg);
d1052 2
a1053 2
PRIVATE BOOLEAN create_directory ARGS1(
	char *, 	current_location)
d1056 2
a1057 3
    char tmpbuf[512];
    char testpath[512];
    char *args[5];
d1060 1
d1062 1
a1062 3
		     tmpbuf, sizeof(tmpbuf)) == NULL) {
	return code;
    }
d1064 3
a1066 3
    if (!no_dotfiles && show_dotfiles) {
	bad_chars = "~/";
    }
d1068 5
a1072 5
    if (strstr(tmpbuf, "//") != NULL) {
	HTAlert(gettext("Illegal redirection \"//\" found! Request ignored."));
    } else if (strlen(tmpbuf) && strchr(bad_chars, tmpbuf[0]) == NULL) {
	strcpy(testpath,current_location);
	LYAddPathSep0(testpath);
d1074 1
a1074 1
	strcat(testpath, tmpbuf);
d1076 7
a1082 11
	/*
	 *  Make sure the target does not already exist.
	 */
	if (not_already_exists(testpath)) {
	    char *msg = 0;
	    HTSprintf(&msg,"make directory %s",testpath);
	    args[0] = "mkdir";
	    args[1] = testpath;
	    args[2] = (char *) 0;
	    code = (LYExecv(MKDIR_PATH, args, msg) <= 0) ? -1 : 1;
	    FREE(msg);
d1091 2
a1092 2
PUBLIC BOOLEAN local_create ARGS1(
	document *,	doc)
d1094 1
a1094 1
    int c, ans;
d1096 1
a1096 5
    char testpath[512];

    _statusline(gettext("Create file or directory (f or d): "));
    c = LYgetch();
    ans = TOUPPER(c);
d1099 4
d1106 3
d1121 2
a1122 2
PRIVATE BOOLEAN remove_single ARGS1(
	char *, 	testpath)
a1127 1
    char *args[5];
d1136 1
a1136 1
    if ((cp = strrchr(testpath, '/')) != NULL) {
d1146 1
a1146 1
		       gettext("Remove '%s' and all of its contents: "), cp);
d1149 1
a1149 1
		       gettext("Remove directory and all of its contents: "));
d1153 1
a1153 1
	    HTSprintf0(&tmpbuf, gettext("Remove file '%s': "), cp);
d1155 1
a1155 1
	    HTSprintf0(&tmpbuf, gettext("Remove file: "));
d1160 1
a1160 1
	    HTSprintf0(&tmpbuf, gettext("Remove symbolic link '%s': "), cp);
d1162 1
a1162 1
	    HTSprintf0(&tmpbuf, gettext("Remove symbolic link: "));
d1172 1
a1172 6
	HTSprintf0(&tmpbuf,"remove %s",testpath);
	args[0] = "rm";
	args[1] = "-rf";
	args[2] = testpath;
	args[3] = (char *) 0;
	code = (LYExecv(RM_PATH, args, tmpbuf) <= 0) ? -1 : 1;
d1181 2
a1182 2
PUBLIC BOOLEAN local_remove ARGS1(
	document *,	doc)
d1185 1
a1185 1
    char testpath[512];
d1201 4
a1220 20
/*
 *  Table of permission strings and chmod values.
 *  Makes the code a bit cleaner.
 */
static struct {
    CONST char *string_mode;	/* Key for  value below */
    long permit_bits;		/* Value for chmod/whatever */
} permissions[] = {
    {"IRUSR", S_IRUSR},
    {"IWUSR", S_IWUSR},
    {"IXUSR", S_IXUSR},
    {"IRGRP", S_IRGRP},
    {"IWGRP", S_IWGRP},
    {"IXGRP", S_IXGRP},
    {"IROTH", S_IROTH},
    {"IWOTH", S_IWOTH},
    {"IXOTH", S_IXOTH},
    {NULL, 0}			/* Don't include setuid and friends;
				   use shell access for that. */
};
d1224 15
d1242 3
a1244 3
PRIVATE BOOLEAN permit_location ARGS3(
	char *, 	destpath,
	char *, 	srcpath,
a1252 1
    char *tmpbuf = NULL;
d1255 1
a1261 1
	char local_src[LY_MAXPATH];
d1265 1
a1265 3
	cp = HTfullURL_toFile(strip_trailing_slash(srcpath));
	strcpy(local_src, cp);
	FREE(cp);
d1270 1
a1270 1
	if (!ok_lstat(local_src, &dir_info)
d1274 1
a1274 1
	user_filename = LYPathLeaf(local_src);
d1286 1
a1286 1
	strcpy(LYPermitFileURL, *newpath);
d1290 1
a1290 1
		  local_src,
d1300 2
a1301 2
	    fprintf(fp0, "<Form Action=\"LYNXDIRED://PERMIT_LOCATION%s\">\n",
		    srcpath_url);
a1366 2
	char *args[5];
	char amode[10];
d1378 1
a1378 1
	    CTRACE(tfp, "permit_location: called for <%s>.\n",
d1380 1
a1380 1
			 destpath : "NULL URL pointer"));
d1393 2
a1394 1
	if ((destpath = HTfullURL_toFile(destpath)) == 0)
d1396 5
a1400 2

	strcpy(tmpdst, destpath);	/* operate only on filename */
d1413 2
a1414 2
	    CTRACE(tfp, "permit_location: called for file '%s'.\n",
			destpath);
d1440 1
a1440 1
		int i;
d1442 10
a1451 14
		for(i = 0; permissions[i].string_mode != NULL; i++) {
		    if (strcmp(permissions[i].string_mode, cp+5) == 0) {
			/*
			 *  If restricted, only change eXecute
			 *  permissions on directories.
			 */
			if (!no_change_exec_perms ||
			    strchr(cp+5,'X') == NULL ||
			    S_ISDIR(dir_info.st_mode))
			    new_mode |= permissions[i].permit_bits;
			break;
		    }
		}
		if (permissions[i].string_mode == NULL) {
a1462 1
#ifdef UNIX
d1466 15
a1480 7
	HTSprintf(&tmpbuf, "chmod %.4o %s", (unsigned int)new_mode, destpath);
	sprintf(amode, "%.4o", (unsigned int)new_mode);
	args[0] = "chmod";
	args[1] = amode;
	args[2] = destpath;
	args[3] = (char *) 0;
	if (LYExecv(CHMOD_PATH, args, tmpbuf) <= 0) {
d1482 3
a1484 1
	    return (-1);
a1485 2
	FREE(tmpbuf);
#endif /* UNIX */
d1501 1
a1501 1
	move(links[cur].ly, 2);
d1504 1
a1504 1
	    addch('+');
d1506 1
a1506 1
	    addch(' ');
d1511 1
a1511 1
	    move((LYlines - 1), (LYcols - 1)); /* get cursor out of the way */
d1517 1
a1517 1
	    move(links[cur].ly, links[cur].lx);
d1519 1
a1519 1
	refresh();
d1552 1
d1554 2
d1557 4
a1560 1
	LYTrimPathSep(result);
d1565 1
d1567 2
a1568 8
 *  Perform file management operations for LYNXDIRED URL's.
 *  Attempt to be consistent.  These are (pseudo) URLs - i.e., they should
 *  be in URL syntax: some bytes will be URL-escaped with '%'.	This is
 *  necessary because these (pseudo) URLs will go through some of the same
 *  kinds of interpretations and mutilations as real ones: HTParse, stripping
 *  off #fragments etc.  (Some access schemes currently have special rules
 *  about not escaping parsing '#' "the URL way" built into HTParse, but that
 *  doesn't look like a clean way.)
d1570 2
a1571 2
PUBLIC int local_dired ARGS1(
	document *,	doc)
d1573 22
a1594 6
    char *line_url;    /* will point to doc's address, which is a URL */
    char *line = NULL; /* same as line_url, but HTUnEscaped, will be alloced */
    char *tp = NULL;
    char *tmpbuf = NULL;
    char *buffer = NULL;
    char *dirname = NULL;
d1596 18
a1613 5
    line_url = doc->address;
    CTRACE(tfp, "local_dired: called for <%s>.\n",
		(line_url ?
		 line_url : gettext("NULL URL pointer")));
    HTUnEscapeSome(line_url, "/");	/* don't mess too much with *doc */
d1615 12
a1626 65
    StrAllocCopy(line, line_url);
    HTUnEscape(line);	/* _file_ (not URL) syntax, for those functions
			   that need it.  Don't forget to FREE it. */

    if (!strncmp(line, "LYNXDIRED://NEW_FILE", 20)) {
	if (create_file(&line[20]) > 0)
	    LYforce_no_cache = TRUE;
    } else if (!strncmp(line, "LYNXDIRED://NEW_FOLDER", 22)) {
	if (create_directory(&line[22]) > 0)
	    LYforce_no_cache = TRUE;
    } else if (!strncmp(line, "LYNXDIRED://INSTALL_SRC", 23)) {
	local_install(NULL, &line[23], &tp);
	StrAllocCopy(doc->address, tp);
	FREE(tp);
	FREE(line);
	return 0;
    } else if (!strncmp(line, "LYNXDIRED://INSTALL_DEST", 24)) {
	local_install(&line[24], NULL, &tp);
	LYpop(doc);
    } else if (!strncmp(line, "LYNXDIRED://MODIFY_NAME", 23)) {
	if (modify_name(&line[23]) > 0)
	LYforce_no_cache = TRUE;
    } else if (!strncmp(line, "LYNXDIRED://MODIFY_LOCATION", 27)) {
	if (modify_location(&line[27]) > 0)
	    LYforce_no_cache = TRUE;
    } else if (!strncmp(line, "LYNXDIRED://MOVE_TAGGED", 23)) {
	if (modify_tagged(&line_url[23]) > 0)
	    LYforce_no_cache = TRUE;
#ifdef OK_PERMIT
    } else if (!strncmp(line, "LYNXDIRED://PERMIT_SRC", 22)) {
	permit_location(NULL, &line[22], &tp);
	if (tp)
	    /*
	     *	One of the checks may have failed.
	     */
	    StrAllocCopy(doc->address, tp);
	FREE(line);
	FREE(tp);
	return 0;
    } else if (!strncmp(line, "LYNXDIRED://PERMIT_LOCATION", 27)) {
	permit_location(&line_url[27], NULL, &tp);
#endif /* OK_PERMIT */
    } else if (!strncmp(line, "LYNXDIRED://REMOVE_SINGLE", 25)) {
	if (remove_single(&line[25]) > 0)
	    LYforce_no_cache = TRUE;
    } else if (!strncmp(line, "LYNXDIRED://REMOVE_TAGGED", 25)) {
	if (remove_tagged())
	    LYforce_no_cache = TRUE;
    } else if (!strncmp(line, "LYNXDIRED://CLEAR_TAGGED", 24)) {
	clear_tags();
    } else if (!strncmp(line, "LYNXDIRED://UPLOAD", 18)) {
	/*
	 *  They're written by LYUpload_options() HTUnEscaped;
	 *  don't want to change that for now... so pass through
	 *  without more unescaping.  Directory names containing
	 *  '#' will probably fail.
	 */
	if (LYUpload(line_url))
	    LYforce_no_cache = TRUE;
    } else {
	LYTrimPathSep(line);
	if (strrchr(line, '/') == NULL) {
	    FREE(line);
	    return 0;
	}
d1628 1
a1628 5
	/*
	 *  Construct the appropriate system command taking care to
	 *  escape all path references to avoid spoofing the shell.
	 */
	if (!strncmp(line, "LYNXDIRED://DECOMPRESS", 22)) {
d1630 3
a1632 2
	    HTAddParam(&buffer, FMT_UNCOMPRESS, 1, UNCOMPRESS_PATH);
	    HTAddParam(&buffer, FMT_UNCOMPRESS, 2, line+22);
d1634 3
d1639 1
a1639 1
	} else if (!strncmp(line, "LYNXDIRED://UUDECODE", 20)) {
d1641 3
a1643 2
	    HTAddParam(&buffer, FMT_UUDECODE, 1, UUDECODE_PATH);
	    HTAddParam(&buffer, FMT_UUDECODE, 2, line+20);
d1646 3
d1652 1
d1655 12
a1666 8
	} else if (!strncmp(line, "LYNXDIRED://UNTAR_GZ", 20)) {
#define FMT_UNTAR_GZ "%s -qdc %s | (cd %s; %s -xf -)"
	    dirname = DirectoryOf(line+20);
	    HTAddParam(&buffer, FMT_UNTAR_GZ, 1, GZIP_PATH);
	    HTAddParam(&buffer, FMT_UNTAR_GZ, 2, line+20);
	    HTAddParam(&buffer, FMT_UNTAR_GZ, 3, dirname);
	    HTAddParam(&buffer, FMT_UNTAR_GZ, 4, TAR_PATH);
	    HTEndParam(&buffer, FMT_UNTAR_GZ, 4);
d1668 13
a1680 11

	} else if (!strncmp(line, "LYNXDIRED://UNTAR_Z", 19)) {
#define FMT_UNTAR_Z "%s %s | (cd %s; %s -xf -)"
	    dirname = DirectoryOf(line+19);
	    HTAddParam(&buffer, FMT_UNTAR_Z, 1, ZCAT_PATH);
	    HTAddParam(&buffer, FMT_UNTAR_Z, 2, line+19);
	    HTAddParam(&buffer, FMT_UNTAR_Z, 3, dirname);
	    HTAddParam(&buffer, FMT_UNTAR_Z, 4, TAR_PATH);
	    HTEndParam(&buffer, FMT_UNTAR_Z, 4);

	} else if (!strncmp(line, "LYNXDIRED://UNTAR", 17)) {
d1682 1
a1682 1
	    dirname = DirectoryOf(line+17);
d1684 2
a1685 2
	    HTAddParam(&buffer, FMT_UNTAR, 2, TAR_PATH);
	    HTAddParam(&buffer, FMT_UNTAR, 3, line+17);
d1687 2
d1692 14
a1705 10
	} else if (!strncmp(line, "LYNXDIRED://TAR_GZ", 18)) {
#define FMT_TAR_GZ "(cd %s; %s -cf - %s) | %s -qc >%s/%s.tar.gz"
	    dirname = DirectoryOf(line+18);
	    HTAddParam(&buffer, FMT_TAR_GZ, 1, dirname);
	    HTAddParam(&buffer, FMT_TAR_GZ, 2, TAR_PATH);
	    HTAddParam(&buffer, FMT_TAR_GZ, 3, LYPathLeaf(line+18));
	    HTAddParam(&buffer, FMT_TAR_GZ, 4, GZIP_PATH);
	    HTAddParam(&buffer, FMT_TAR_GZ, 5, dirname);
	    HTAddParam(&buffer, FMT_TAR_GZ, 6, LYPathLeaf(line+18));
	    HTEndParam(&buffer, FMT_TAR_GZ, 6);
d1708 18
a1725 14
	} else if (!strncmp(line, "LYNXDIRED://TAR_Z", 17)) {
#define FMT_TAR_Z "(cd %s; %s -cf - %s) | %s >%s/%s.tar.Z"
	    dirname = DirectoryOf(line+17);
	    HTAddParam(&buffer, FMT_TAR_Z, 1, dirname);
	    HTAddParam(&buffer, FMT_TAR_Z, 2, TAR_PATH);
	    HTAddParam(&buffer, FMT_TAR_Z, 3, LYPathLeaf(line+17));
	    HTAddParam(&buffer, FMT_TAR_Z, 4, COMPRESS_PATH);
	    HTAddParam(&buffer, FMT_TAR_Z, 5, dirname);
	    HTAddParam(&buffer, FMT_TAR_Z, 6, LYPathLeaf(line+17));
	    HTEndParam(&buffer, FMT_TAR_Z, 6);

	} else if (!strncmp(line, "LYNXDIRED://TAR", 15)) {
#define FMT_TAR "(cd %s; %s -cf %s.tar %s)"
	    dirname = DirectoryOf(line+15);
d1727 3
a1729 3
	    HTAddParam(&buffer, FMT_TAR, 2, TAR_PATH);
	    HTAddParam(&buffer, FMT_TAR, 3, LYPathLeaf(line+15));
	    HTAddParam(&buffer, FMT_TAR, 4, LYPathLeaf(line+15));
d1731 3
d1737 1
a1737 1
	} else if (!strncmp(line, "LYNXDIRED://GZIP", 16)) {
d1739 3
a1741 2
	    HTAddParam(&buffer, FMT_GZIP, 1, GZIP_PATH);
	    HTAddParam(&buffer, FMT_GZIP, 2, line+16);
d1743 3
d1747 1
a1747 1
	} else if (!strncmp(line, "LYNXDIRED://UNGZIP", 18)) {
d1749 3
a1751 2
	    HTAddParam(&buffer, FMT_UNGZIP, 1, GZIP_PATH);
	    HTAddParam(&buffer, FMT_UNGZIP, 2, line+18);
d1753 3
d1760 1
a1760 1
	} else if (!strncmp(line, "LYNXDIRED://ZIP", 15)) {
d1762 2
a1763 1
	    dirname = DirectoryOf(line+15);
d1765 3
a1767 3
	    HTAddParam(&buffer, FMT_ZIP, 2, ZIP_PATH);
	    HTAddParam(&buffer, FMT_ZIP, 3, line+15);
	    HTAddParam(&buffer, FMT_ZIP, 4, LYPathLeaf(line+15));
d1769 5
a1773 2
#ifndef ARCHIVE_ONLY
	} else if (!strncmp(line, "LYNXDIRED://UNZIP", 17)) {
d1775 2
a1776 1
	    dirname = DirectoryOf(line+17);
d1778 2
a1779 2
	    HTAddParam(&buffer, FMT_UNZIP, 2, UNZIP_PATH);
	    HTAddParam(&buffer, FMT_UNZIP, 3, line+17);
d1781 3
d1787 1
a1787 1
	} else if (!strncmp(line, "LYNXDIRED://COMPRESS", 20)) {
d1789 3
a1791 2
	    HTAddParam(&buffer, FMT_COMPRESS, 1, COMPRESS_PATH);
	    HTAddParam(&buffer, FMT_COMPRESS, 2, line+20);
d1794 111
d1907 1
a1907 1
	    if (strlen(buffer) < 60) {
d1915 1
a1915 1
	    printf("%s\n", tmpbuf);
d1930 2
a1931 1
    LYpop(doc);
d1939 1
a1939 1
	document *,	doc,
d1943 3
a1945 2
    char path[512], dir[512]; /* much too large */
    lynx_html_item_type *nxt;
a1947 1
    char *cp = NULL;
d1955 1
a1955 3
    LYRemoveTemp(tempfile);
    if ((fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w")) == NULL) {
	HTAlert(gettext("Unable to open file management menu file."));
a1956 1
    }
d1962 1
a1962 6
    strcpy(LYDiredFileURL, *newfile);

    cp = HTpartURL_toFile(doc->address);
    strcpy(dir, cp);
    LYTrimPathSep(dir);
    FREE(cp);
d1965 1
a1965 2
	cp = HTfullURL_toFile(links[doc->link].lname);
	strcpy(path, cp);
a1966 1
	FREE(cp);
d1970 1
d1975 1
a1975 1
	path[0] = '\0';
d1978 4
a1981 1
    nothing_tagged = (HTList_isEmpty(tagged));
d2069 1
d2081 1
d2095 3
a2097 3
	char *, 	prompt,
	char *, 	buf,
	size_t, 	bufsize)
a2102 1
    *buf = '\0';
d2110 1
a2110 1
	cp = strrchr(buf, '/'); /* find last slash */
d2123 68
d2195 2
a2196 2
	char *, 	destpath,
	char *, 	srcpath,
d2200 2
a2201 1
    char savepath[512]; /* This will be the link that is to be installed. */
d2203 1
a2203 1
    char *args[6];
d2205 2
d2208 8
a2215 1
    int n = 0, src;	/* indices into 'args[]' */
d2221 12
a2232 1
	if (!ok_localname(savepath, srcpath))
d2234 1
a2234 1

d2237 3
a2239 1
	StrAllocCat(*newpath, "/.installdirs.html");
d2243 18
d2264 1
d2268 1
d2272 1
d2277 8
a2284 1
    args[n++] = "install";
d2286 3
a2288 1
    args[n++] = INSTALL_ARGS;
d2290 11
a2300 1
    src = n++;
a2302 1
    HTSprintf(&tmpbuf, "install %s", destpath);
d2306 14
d2321 4
a2324 1
	if (LYExecv(INSTALL_PATH, args, tmpbuf) <= 0)
d2326 1
d2330 1
d2334 16
a2349 1
	    err = (LYExecv(INSTALL_PATH, args, tmpbuf) <= 0);
d2351 3
a2353 1
	    if (err)
d2355 1
d2361 1
d2365 1
d2385 1
a2385 1
	char *, 	str)
d2397 1
a2397 1
    new = (struct dired_menu *)calloc(1, sizeof(*new));
d2412 1
d2415 1
d2446 16
d2466 4
a2469 4
	CONST char *, 	s,
	char *, 	path,
	char *, 	dir,
	char *, 	buf,
d2473 1
a2473 1
    char *cp;
d2503 1
a2503 1
		    cp = strrchr(path, '/');
d2537 1
a2537 1
		    *BP_INC =*s;
d2551 1
a2551 2
	strcpy(buf,gettext("Temporary URL or list would be too long."));
	HTAlert(buf);
d2557 1
a2558 85

/*
 *  Execute DIRED command.
 */
PRIVATE int LYExecv ARGS3(
	char *, 	path,
	char **,	argv,
	char *, 	msg)
{
#if defined(VMS) || defined(_WINDOWS)
    CTRACE(tfp, "LYExecv:  Called inappropriately!\n");
    return(0);
#else
    int rc;
    char *tmpbuf = 0;
    pid_t pid;
#ifdef HAVE_TYPE_UNIONWAIT
    union wait wstatus;
#else
    int wstatus;
#endif

    if (TRACE) {
	int n;
	CTRACE(tfp, "LYExecv path='%s'\n", path);
	for (n = 0; argv[n] != 0; n++)
	    CTRACE(tfp, "argv[%d] = '%s'\n", n, argv[n]);
    }

    rc = 1;		/* It will work */
    stop_curses();
    pid = fork();	/* fork and execute rm */
    switch (pid) {
	case -1:
	    HTSprintf(&tmpbuf, gettext("Unable to %s due to system error!"), msg);
	    rc = 0;
	    break;	/* don't fall thru! - KW */
	case 0:  /* child */
#ifdef USE_EXECVP
	    execvp(path, argv);	/* this uses our $PATH */
#else
	    execv(path, argv);
#endif
	    exit(-1);	/* execv failed, give wait() something to look at */
	default:  /* parent */
#if !HAVE_WAITPID
	    while (wait(&wstatus) != pid)
		; /* do nothing */
#else
	    while (-1 == waitpid(pid, &wstatus, 0)) { /* wait for child */
#ifdef EINTR
		if (errno == EINTR)
		    continue;
#endif /* EINTR */
#ifdef ERESTARTSYS
		if (errno == ERESTARTSYS)
		    continue;
#endif /* ERESTARTSYS */
		break;
	    }
#endif /* !HAVE_WAITPID */
	    if (WEXITSTATUS(wstatus) != 0 ||
		WTERMSIG(wstatus) > 0)	{ /* error return */
		HTSprintf(&tmpbuf, gettext("Probable failure to %s due to system error!"),
				   msg);
		rc = 0;
	    }
    }

    if (rc == 0) {
	/*
	 *  Screen may have message from the failed execv'd command.
	 *  Give user time to look at it before screen refresh.
	 */
	sleep(AlertSecs);
    }
    start_curses();
    if (tmpbuf != 0) {
	HTAlert(tmpbuf);
	FREE(tmpbuf);
    }

    return(rc);
#endif /* VMS */
}
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 28
a29 28
 *  Routines to manipulate the local filesystem.
 *  Written by: Rick Mallett, Carleton University
 *  Report problems to rmallett@@ccs.carleton.ca
 *  Modified 18-Dec-95 David Trueman (david@@cs.dal.ca):
 *	Added OK_PERMIT compilation option.
 *	Support replacement of compiled-in f)ull menu configuration via
 *	  DIRED_MENU definitions in lynx.cfg, so that more than one menu
 *	  can be driven by the same executable.
 *  Modified Oct-96 Klaus Weide (kweide@@tezcat.com):
 *	Changed to use the library's HTList_* functions and macros for
 *	  managing the list of tagged file URLs.
 *	Keep track of proper level of URL escaping, so that unusual filenames
 *	  which contain #% etc. are handled properly (some HTUnEscapeSome()'s
 *	  left in to be conservative, and to document where superfluous
 *	  unescaping took place before).
 *	Dynamic memory instead of fixed length buffers in a few cases.
 *	Other minor changes to make things work as intended.
 *  Modified Jun-97 Klaus Weide (kweide@@tezcat.com) & FM:
 *	Modified the code handling DIRED_MENU to do more careful
 *	  checking of the selected file.  In addition to "TAG", "FILE", and
 *	  "DIR", DIRED_MENU definitions in lynx.cfg now also recognize LINK as
 *	  a type.  DIRED_MENU definitions with a type field of "LINK" are only
 *	  used if the current selection is a symbolic link ("FILE" and "DIR"
 *	  definitions are not used in that case).  The default menu
 *	  definitions have been updated to reflect this change, and to avoid
 *	  the showing of menu items whose action would always fail - KW
 *	Cast all code into the Lynx programming style. - FM
 */
a45 1
#include <www_wait.h>
d47 4
a50 2
#ifdef SUPPORT_CHDIR
#include <LYMainLoop.h>
d52 2
d55 7
a61 1
#include <LYLeaks.h>
d63 7
a69 1
#undef USE_COMPRESS
d71 1
a71 9
#ifdef __DJGPP__
#define EXT_TAR_GZ ".tgz"
#define EXT_TAR_Z  ".taz"
#define EXT_Z      ".z"
#else
#define EXT_TAR_GZ ".tar.gz"
#define EXT_TAR_Z  ".tar.Z"
#define EXT_Z      ".Z"
#endif
d73 4
a76 3
#ifndef DIRED_MAXBUF
#define DIRED_MAXBUF 512
#endif
d79 2
d82 4
a85 11
#ifdef OK_INSTALL
#ifdef FNAMES_8_3
#define INSTALLDIRS_FILE "instdirs.htm"
#else
#define INSTALLDIRS_FILE ".installdirs.html"
#endif /* FNAMES_8_3 */
#endif /* OK_INSTALL */

static char *get_filename(const char *prompt,
			  char *buf,
			  size_t bufsize);
d88 4
a91 3
static int permit_location(char *destpath,
			   char *srcpath,
			   char **newpath);
d93 5
a97 4
/* *INDENT-OFF* */
static char *render_item ( const char *	s,
	const char *	path,
	const char *	dir,
d100 1
a100 1
	BOOLEAN		url_syntax);
d102 1
d114 1
a114 5
};

static struct dired_menu *menu_head = NULL;
static struct dired_menu defmenu[] = {

d116 5
a120 9
 * The following initializations determine the contents of the f)ull menu
 * selection when in dired mode.  If any menu entries are defined in the
 * configuration file via DIRED_MENU lines, then these default entries are
 * discarded entirely.
 */
#ifdef SUPPORT_CHDIR
{ 0,		      "", "Change directory",
		      "", "LYNXDIRED://CHDIR",			NULL },
#endif
a126 1
#ifdef OK_INSTALL
d128 1
a128 6
"selected file to new location", "LYNXDIRED://INSTALL_SRC%p",	NULL },
/* The following (installing a directory) doesn't work for me, at least
   with the "install" from GNU fileutils 4.0.  I leave it in anyway, in
   case one compiles with INSTALL_PATH / INSTALL_ARGS defined to some
   other command for which it works (like a script, or maybe "cp -a"). - kw
*/
d130 1
a130 2
"selected directory to new location", "LYNXDIRED://INSTALL_SRC%p",	NULL },
#endif /* OK_INSTALL */
a135 1
#ifdef S_IFLNK
a137 1
#endif  /* S_IFLNK */
a149 1
#ifdef S_IFLNK
a151 1
#endif /* S_IFLNK */
a156 1
#ifdef S_IFLNK
a158 1
#endif /* S_IFLNK */
d166 1
a166 1
{ DE_FILE,	EXT_TAR_Z, "Expand",
d179 1
a179 1
{ DE_FILE,	   EXT_Z, "Uncompress",
a207 5
#if defined(OK_TAR) && defined(USE_COMPRESS)
{ DE_DIR,	      "", "Tar and compress",
      "(using compress)", "LYNXDIRED://TAR_Z%p",		NULL },
#endif /* OK_TAR && USE_COMPRESS */

d218 1
a218 1
	  "(using gzip)", "LYNXDIRED://GZIP%p",			NULL },
a228 5
#ifdef OK_INSTALL
{ DE_TAG,	      "", "Install tagged files into another directory.",
		      "", "LYNXDIRED://INSTALL_SRC%00",		NULL },
#endif

d236 1
a236 1
		    NULL, NULL,					NULL }
a237 1
/* *INDENT-ON* */
d239 1
a239 1
static BOOLEAN cannot_stat(const char *name)
d242 1
a242 2

    HTSprintf0(&tmpbuf, gettext("Unable to get status of '%s'."), name);
d248 1
a248 3
#define OK_STAT(name, sb) (stat(name, sb) == 0)

static BOOLEAN ok_stat(const char *name, struct stat *sb)
d250 2
a251 2
    CTRACE((tfp, "testing ok_stat(%s)\n", name));
    if (!OK_STAT(name, sb)) {
d258 1
a258 1
static BOOLEAN ok_lstat(char *name, struct stat *sb)
d260 1
a260 1
    CTRACE((tfp, "testing ok_lstat(%s)\n", name));
d270 1
a270 1
static BOOLEAN ok_file_or_dir(struct stat *sb)
d273 1
a273 1
	&& !S_ISREG(sb->st_mode)) {
d280 1
a280 2
#ifdef OK_INSTALL		/* currently only used in local_install */
static BOOLEAN ok_localname(char *dst, const char *src)
d282 1
d285 3
a287 2
    if (!ok_stat(src, &dir_info)
	|| !ok_file_or_dir(&dir_info)) {
d290 2
a291 5
    if (strlen(src) >= DIRED_MAXBUF) {
	CTRACE((tfp, "filename too long in ok_localname!\n"));
	return FALSE;
    }
    strcpy(dst, src);
a293 199
#endif /* OK_INSTALL */

/*
 * Execute DIRED command, return -1 or 0 on failure, 1 success.
 */
static int LYExecv(const char *path,
		   char **argv,
		   char *msg)
{
    int rc = 0;

#if defined(VMS) || defined(_WINDOWS)
    CTRACE((tfp, "LYExecv:  Called inappropriately! (path=%s)\n", path));
#else
    int n;
    char *tmpbuf = 0;

#ifdef __DJGPP__
    stop_curses();
    HTSprintf0(&tmpbuf, "%s", path);
    for (n = 1; argv[n] != 0; n++)
	HTSprintf(&tmpbuf, " %s", argv[n]);
    HTSprintf(&tmpbuf, "\n");
    rc = LYSystem(tmpbuf) ? 0 : 1;
#else
    int pid;

#ifdef HAVE_TYPE_UNIONWAIT
    union wait wstatus;

#else
    int wstatus;
#endif

    if (TRACE) {
	CTRACE((tfp, "LYExecv path='%s'\n", path));
	for (n = 0; argv[n] != 0; n++)
	    CTRACE((tfp, "argv[%d] = '%s'\n", n, argv[n]));
    }

    rc = 1;			/* It will work */
    stop_curses();
    pid = fork();		/* fork and execute command */

    switch (pid) {
    case -1:
	HTSprintf0(&tmpbuf, gettext("Unable to %s due to system error!"), msg);
	rc = 0;
	break;			/* don't fall thru! - KW */

    case 0:			/* child */
#ifdef USE_EXECVP
	execvp(path, argv);	/* this uses our $PATH */
#else
	execv(path, argv);
#endif
	exit(EXIT_FAILURE);	/* execv failed, give wait() something to look at */
	/*NOTREACHED */

    default:			/* parent */
#if !HAVE_WAITPID
	while (wait(&wstatus) != pid) ;		/* do nothing */
#else
	while (-1 == waitpid(pid, &wstatus, 0)) {	/* wait for child */
#ifdef EINTR
	    if (errno == EINTR)
		continue;
#endif /* EINTR */
#ifdef ERESTARTSYS
	    if (errno == ERESTARTSYS)
		continue;
#endif /* ERESTARTSYS */
	    break;
	}
#endif /* !HAVE_WAITPID */
	if ((WIFEXITED(wstatus)
	     && (WEXITSTATUS(wstatus) != 0))
	    || (WIFSIGNALED(wstatus)
		&& (WTERMSIG(wstatus) > 0))) {	/* error return */
	    HTSprintf0(&tmpbuf,
		       gettext("Probable failure to %s due to system error!"),
		       msg);
	    rc = 0;
	}
    }
#endif /* __DJGPP__ */

    if (rc == 0) {
	/*
	 * Screen may have message from the failed execv'd command.  Give user
	 * time to look at it before screen refresh.
	 */
	LYSleepAlert();
    }
    start_curses();
    if (tmpbuf != 0) {
	if (rc == 0)
	    HTAlert(tmpbuf);
	FREE(tmpbuf);
    }
#endif /* VMS || _WINDOWS */
    return (rc);
}

static int make_directory(char *path)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppMKDIR)) != NULL) {
	char *args[5];
	char *msg = 0;

	HTSprintf0(&msg, "make directory %s", path);
	args[0] = "mkdir";
	args[1] = path;
	args[2] = (char *) 0;
	code = (LYExecv(program, args, msg) <= 0) ? -1 : 1;
	FREE(msg);
    } else {
#ifdef _WINDOWS
	code = mkdir(path) ? -1 : 1;
#else
	code = mkdir(path, 0777) ? -1 : 1;
#endif
    }
    return (code);
}

static int remove_file(char *path)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppRM)) != NULL) {
	char *args[5];
	char *tmpbuf = NULL;

	args[0] = "rm";
	args[1] = "-f";
	args[2] = path;
	args[3] = (char *) 0;
	HTSprintf0(&tmpbuf, gettext("remove %s"), path);
	code = LYExecv(program, args, tmpbuf);
	FREE(tmpbuf);
    } else {
	code = remove(path) ? -1 : 1;
    }
    return (code);
}

static int remove_directory(char *path)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppRMDIR)) != NULL) {
	char *args[5];
	char *tmpbuf = NULL;

	args[0] = "rmdir";
	args[1] = path;
	args[2] = (char *) 0;
	HTSprintf0(&tmpbuf, gettext("remove %s"), path);
	code = LYExecv(program, args, tmpbuf);
	FREE(tmpbuf);
    } else {
	code = rmdir(path) ? -1 : 1;
    }
    return (code);
}

static int touch_file(char *path)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppTOUCH)) != NULL) {
	char *args[5];
	char *msg = NULL;

	HTSprintf0(&msg, gettext("touch %s"), path);
	args[0] = "touch";
	args[1] = path;
	args[2] = (char *) 0;
	code = (LYExecv(program, args, msg) <= 0) ? -1 : 1;
	FREE(msg);
    } else {
	FILE *fp;

	if ((fp = fopen(path, "w")) != 0) {
	    fclose(fp);
	    code = 1;
	} else {
	    code = -1;
	}
    }
    return (code);
}
d295 1
a295 1
static int move_file(char *source, char *target)
d298 2
a299 1
    const char *program;
d301 7
a307 31
    if ((program = HTGetProgramPath(ppMV)) != NULL) {
	char *msg = 0;
	char *args[5];

	HTSprintf0(&msg, gettext("move %s to %s"), source, target);
	args[0] = "mv";
	args[1] = source;
	args[2] = target;
	args[3] = (char *) 0;
	code = (LYExecv(program, args, msg) <= 0) ? -1 : 1;
	FREE(msg);
    } else {
	struct stat sb;
	char *actual = 0;

	/* the caller sets up a target directory; we need a file path */
	if (stat(target, &sb) == 0
	    && S_ISDIR(sb.st_mode)) {
	    HTSprintf0(&actual, "%s/%s", target, LYPathLeaf(source));
	    CTRACE((tfp, "move_file source=%s, target=%s\n", source, target));
	    target = actual;
	}
	if ((code = rename(source, target)) != 0)
	    if ((code = LYCopyFile(source, target)) >= 0)
		code = remove(source);
	if (code == 0)
	    code = 1;
	if (actual != target) {
	    FREE(actual);
	}
    }
d311 1
a311 1
static BOOLEAN not_already_exists(char *name)
d315 1
a315 1
    if (!OK_STAT(name, &dir_info)) {
d331 1
a331 1
static BOOLEAN dir_has_same_owner(struct stat *info, int owner)
d334 1
a334 1
	if ((int) info->st_uid == owner) {
d346 1
a346 1
 * Remove all tagged files and directories.
d348 1
a348 1
static int remove_tagged(void)
d358 1
d360 1
a360 1
    if (HTList_isEmpty(tagged))	/* should never happen */
d363 1
a363 1
    ans = HTConfirm(gettext("Remove all tagged files and directories?"));
d367 2
a368 2
    while (ans == YES && (cp = (char *) HTList_nextObject(tag)) != NULL) {
	if (is_url(cp) == FILE_URL_TYPE) {	/* unnecessary check */
d374 1
a374 1
	     * Check the current status of the path to be deleted.
d380 7
a386 3
		if (remove_file(testpath) <= 0) {
		    if (count == 0)
			count = -1;
a390 1
		FREE(testpath);
d402 6
a407 5
 * Move all tagged files and directories to a new location.  Input is current
 * directory.  The tests in this function can, at best, prevent some user
 * mistakes - anybody who relies on them for security is seriously misguided. 
 * If a user has enough permissions to move a file somewhere, the same uid with
 * Lynx & dired can do the same thing.
d409 2
a410 1
static int modify_tagged(char *testpath)
d415 1
a415 1
    int owner;
d417 1
a417 1
    char *savepath;
d423 1
a423 1
    if (HTList_isEmpty(tagged))	/* should never happen */
d431 3
d435 2
a436 1
	 * Determine the ownership of the current location.
d438 1
a438 5
	/*
	 * This test used to always fail from the dired menu...  changed to
	 * something that hopefully makes more sense - KW
	 */
	if (non_empty(testpath) && 0 != strcmp(testpath, "/")) {
d440 2
a441 2
	     * testpath passed in and is not empty and not a single "/" (which
	     * would probably be bogus) - use it.
d446 1
a446 1
	     * Prepare to get directory path from one of the tagged files.
d448 1
a448 1
	    cp = (char *) HTList_lastObject(tagged);
d451 2
d457 1
a457 1
	     * Get the directory containing the file or subdir.
d459 2
a460 8
	    if (cp) {
		cp = strip_trailing_slash(cp);
		cp = HTParse(".", cp, PARSE_PATH + PARSE_PUNCTUATION);
		savepath = HTURLPath_toFile(cp, TRUE, FALSE);
		FREE(cp);
	    } else {		/* Last resort, should never happen. */
		savepath = HTURLPath_toFile(".", TRUE, FALSE);
	    }
d462 2
a463 6
	    if (!strncmp(cp, "file://localhost", 16)) {
		cp += 16;
	    } else if (isFILE_URL(cp)) {
		cp += LEN_FILE_URL;
	    }
	    savepath = HTURLPath_toFile(cp, TRUE, FALSE);
d465 1
d473 2
a474 2
	 * Save the owner of the current location for later use.  Also save the
	 * device and inode for location checking/
d481 1
a481 1
	 * Replace ~/ references to the home directory.
a484 1

d493 1
a493 1
	    LYstrncpy(tmpbuf, cp1, sizeof(tmpbuf) - 1);
d498 1
a498 1
	 * If path is relative, prefix it with current location.
d502 1
a502 1
	    StrAllocCat(savepath, tmpbuf);
d504 1
a504 1
	    StrAllocCopy(savepath, tmpbuf);
d508 1
a508 1
	 * stat() the target location to determine type and ownership.
d516 1
a516 1
	 * Make sure the source and target locations are not the same place.
d525 2
a526 2
	 * Make sure the target location is a directory which is owned by the
	 * same uid as the owner of the current location.
d533 1
a533 1
	     * Move all tagged items to the target location.
d535 3
a537 2
	    while ((cp = (char *) HTList_nextObject(tag)) != NULL) {
		srcpath = HTfullURL_toFile(cp);
d540 1
d545 1
a545 1
		FREE(srcpath);
d558 1
a558 1
 * Modify the name of the specified item.
d560 2
a561 1
static int modify_name(char *testpath)
d563 4
a566 3
    const char *cp;
    char tmpbuf[DIRED_MAXBUF];
    char *newpath = NULL;
a567 1
    int code = 0;
d570 1
a570 1
     * Determine the status of the selected item.
d576 1
a576 1
	 * Change the name of the file or directory.
d579 1
a579 1
	    cp = gettext("Enter new name for directory: ");
d581 1
a581 1
	    cp = gettext("Enter new name for file: ");
d583 1
a583 1
	    return ok_file_or_dir(&dir_info);
a584 1
	LYstrncpy(tmpbuf, LYPathLeaf(testpath), sizeof(tmpbuf) - 1);
d589 1
a589 1
	 * Do not allow the user to also change the location at this time.
d591 8
a598 8
	if (LYLastPathSep(tmpbuf) != 0) {
	    HTAlert(gettext("Illegal character (path-separator) found! Request ignored."));
	} else if (strlen(tmpbuf)) {
	    if ((cp = LYLastPathSep(testpath)) != NULL)
		HTSprintf0(&newpath, "%.*s%s",
			   (cp - testpath + 1), testpath, tmpbuf);
	    else
		StrAllocCopy(newpath, tmpbuf);
d601 1
a601 1
	     * Make sure the destination does not already exist.
d604 1
a604 1
		code = move_file(testpath, newpath);
a605 2
	    FREE(newpath);

d608 1
a608 1
    return code;
d612 1
a612 1
 * Change the location of a file or directory.
d614 2
a615 1
static int modify_location(char *testpath)
d617 1
a617 2
    const char *cp;
    char *sp;
d620 1
a620 1
    int owner;
d622 2
a623 2
    char *newpath = NULL;
    char *savepath = NULL;
a624 1
    int code = 0;
d627 1
a627 1
     * Determine the status of the selected item.
d630 1
d636 1
a636 1
     * Change the location of the file or directory.
d639 1
a639 6
	if (HTGetProgramPath(ppMV) != NULL) {
	    cp = gettext("Enter new location for directory: ");
	} else {
	    HTAlert(COULD_NOT_ACCESS_DIR);
	    return 0;
	}
a644 2
    LYstrncpy(tmpbuf, testpath, sizeof(tmpbuf) - 1);
    *LYPathLeaf(tmpbuf) = '\0';
d648 2
a649 2
	StrAllocCopy(savepath, testpath);
	StrAllocCopy(newpath, testpath);
d652 1
a652 1
	 * Allow ~/ references to the home directory.
d655 13
a667 10
	    || !strcmp(tmpbuf, "~")) {
	    StrAllocCopy(newpath, Home_Dir());
	    StrAllocCat(newpath, (tmpbuf + 1));
	    LYstrncpy(tmpbuf, newpath, sizeof(tmpbuf) - 1);
	}
	if (LYisAbsPath(tmpbuf)) {
	    StrAllocCopy(newpath, tmpbuf);
	} else if ((sp = LYLastPathSep(newpath)) != NULL) {
	    *++sp = '\0';
	    StrAllocCat(newpath, tmpbuf);
d669 1
a669 4
	    HTAlert(gettext("Unexpected failure - unable to find trailing path separator"));
	    FREE(newpath);
	    FREE(savepath);
	    return 0;
d673 1
a673 1
	 * Make sure the source and target have the same owner (uid).
d679 1
a679 1
	    code = 0;
d681 1
a681 1
#ifdef UNIX
d683 1
a683 1
	 * Make sure the source and target are not the same location.
d685 1
a685 1
	else if (dev == dir_info.st_dev && inode == dir_info.st_ino) {
d687 1
a687 1
	    code = 0;
d689 2
a690 3
#endif
	else if (dir_has_same_owner(&dir_info, owner)) {
	    code = move_file(savepath, newpath);
a691 2
	FREE(newpath);
	FREE(savepath);
d693 1
a693 1
    return code;
d697 1
a697 1
 * Modify name or location of a file or directory on localhost.
d699 3
a701 1
int local_modify(DocInfo *doc, char **newpath)
d703 1
a703 1
    int ans;
d705 1
a705 1
    char testpath[DIRED_MAXBUF];	/* a bit ridiculous */
d710 2
d713 1
a713 2
	count = modify_tagged(cp);
	FREE(cp);
d715 2
a716 2
	if (doc->link > (nlinks - count - 1))
	    doc->link = (nlinks - count - 1);
d718 1
a718 1
	    0 : doc->link;
d723 1
a723 1
	 * Added protection.
d729 2
a730 2
     * Do not allow simultaneous change of name and location as in Unix.  This
     * reduces functionality but reduces difficulty for the novice.
d735 1
a735 1
    _statusline(gettext("Modify name or location (n or l): "));
d737 2
a738 1
    ans = LYgetch_single();
d742 1
a742 5
	if (strlen(cp) >= DIRED_MAXBUF) {
	    FREE(cp);
	    return 0;
	}
	LYstrncpy(testpath, cp, sizeof(testpath) - 1);
d746 1
a746 1
	    return (modify_name(testpath));
d749 1
a749 1
		if (doc->link == (nlinks - 1))
d755 1
a755 1
	    return (permit_location(NULL, testpath, newpath));
d759 1
a759 1
	     * Code for changing ownership needed here.
d768 1
a768 1
 * Create a new empty file in the current directory.
d770 2
a771 1
static int create_file(char *current_location)
d774 4
a777 3
    char tmpbuf[DIRED_MAXBUF];
    char *testpath = NULL;
    const char *bad_chars = ".~/";
a778 1
    tmpbuf[0] = '\0';
d780 3
a782 1
		     tmpbuf, sizeof(tmpbuf)) != NULL) {
d784 3
a786 3
	if (!no_dotfiles && show_dotfiles) {
	    bad_chars = "~/";
	}
d788 5
a792 5
	if (strstr(tmpbuf, "//") != NULL) {
	    HTAlert(gettext("Illegal redirection \"//\" found! Request ignored."));
	} else if (strlen(tmpbuf) && strchr(bad_chars, tmpbuf[0]) == NULL) {
	    StrAllocCopy(testpath, current_location);
	    LYAddPathSep(&testpath);
d794 4
a797 4
	    /*
	     * Append the target filename to the current location.
	     */
	    StrAllocCat(testpath, tmpbuf);
d799 11
a809 7
	    /*
	     * Make sure the target does not already exist
	     */
	    if (not_already_exists(testpath)) {
		code = touch_file(testpath);
	    }
	    FREE(testpath);
d816 1
a816 1
 * Create a new directory in the current directory.
d818 2
a819 1
static int create_directory(char *current_location)
d822 4
a825 3
    char tmpbuf[DIRED_MAXBUF];
    char *testpath = NULL;
    const char *bad_chars = ".~/";
a826 1
    tmpbuf[0] = '\0';
d828 3
a830 1
		     tmpbuf, sizeof(tmpbuf)) != NULL) {
d832 3
a834 3
	if (!no_dotfiles && show_dotfiles) {
	    bad_chars = "~/";
	}
d836 5
a840 5
	if (strstr(tmpbuf, "//") != NULL) {
	    HTAlert(gettext("Illegal redirection \"//\" found! Request ignored."));
	} else if (strlen(tmpbuf) && strchr(bad_chars, tmpbuf[0]) == NULL) {
	    StrAllocCopy(testpath, current_location);
	    LYAddPathSep(&testpath);
d842 1
a842 1
	    StrAllocCat(testpath, tmpbuf);
d844 11
a854 7
	    /*
	     * Make sure the target does not already exist.
	     */
	    if (not_already_exists(testpath)) {
		code = make_directory(testpath);
	    }
	    FREE(testpath);
d861 1
a861 1
 * Create a file or a directory at the current location.
d863 2
a864 1
int local_create(DocInfo *doc)
d866 1
a866 1
    int ans;
d868 5
a872 1
    char testpath[DIRED_MAXBUF];
d875 1
a875 5
    if (strlen(cp) >= DIRED_MAXBUF) {
	FREE(cp);
	return 0;
    }
    strcpy(testpath, cp);
a877 3
    _statusline(gettext("Create file or directory (f or d): "));
    ans = LYgetch_single();

d879 1
a879 1
	return (create_file(testpath));
d881 1
a881 1
	return (create_directory(testpath));
d888 1
a888 1
 * Remove a single file or directory.
d890 2
a891 1
static int remove_single(char *testpath)
d897 1
a897 1
    BOOL is_directory = FALSE;
d904 1
a904 1
     * Locate the filename portion of the path.
d906 1
a906 1
    if ((cp = LYLastPathSep(testpath)) != NULL) {
d912 2
a913 4
	/*
	 * This strlen stuff will probably screw up intl translations.  Course,
	 * it's probably broken for screen sizes other 80, too -jes
	 */
d916 1
a916 1
		       gettext("Remove directory '%s'?"), cp);
d919 1
a919 1
		       gettext("Remove directory?"));
a920 1
	is_directory = TRUE;
d923 1
a923 1
	    HTSprintf0(&tmpbuf, gettext("Remove file '%s'?"), cp);
d925 1
a925 1
	    HTSprintf0(&tmpbuf, gettext("Remove file?"));
d930 1
a930 1
	    HTSprintf0(&tmpbuf, gettext("Remove symbolic link '%s'?"), cp);
d932 1
a932 1
	    HTSprintf0(&tmpbuf, gettext("Remove symbolic link?"));
d942 6
a947 3
	code = is_directory
	    ? remove_directory(testpath)
	    : remove_file(testpath);
d954 1
a954 1
 * Remove a file or a directory.
d956 2
a957 1
int local_remove(DocInfo *doc)
d960 1
a960 1
    char testpath[DIRED_MAXBUF];
d965 2
a966 2
	if (doc->link > (nlinks - count - 1))
	    doc->link = (nlinks - count - 1);
d968 1
a968 1
	    0 : doc->link;
a975 4
	if (strlen(tp) >= DIRED_MAXBUF) {
	    FREE(tp);
	    return 0;
	}
d992 20
d1013 1
a1013 25
static char LYValidPermitFile[LY_MAXPATH] = "\0";

static long permit_bits(char *string_mode)
{
    if (!strcmp(string_mode, "IRUSR"))
	return S_IRUSR;
    if (!strcmp(string_mode, "IWUSR"))
	return S_IWUSR;
    if (!strcmp(string_mode, "IXUSR"))
	return S_IXUSR;
    if (!strcmp(string_mode, "IRGRP"))
	return S_IRGRP;
    if (!strcmp(string_mode, "IWGRP"))
	return S_IWGRP;
    if (!strcmp(string_mode, "IXGRP"))
	return S_IXGRP;
    if (!strcmp(string_mode, "IROTH"))
	return S_IROTH;
    if (!strcmp(string_mode, "IWOTH"))
	return S_IWOTH;
    if (!strcmp(string_mode, "IXOTH"))
	return S_IXOTH;
    /* Don't include setuid and friends; use shell access for that. */
    return 0;
}
d1016 1
a1016 1
 * Handle DIRED permissions.
d1018 4
a1021 3
static int permit_location(char *destpath,
			   char *srcpath,
			   char **newpath)
d1025 1
a1025 1
    return (0);
d1029 1
a1031 1
    const char *program;
d1035 1
a1035 1
	 * Create form.
d1038 3
a1040 2
	char *user_filename;
	const char *group_name;
d1042 3
a1044 1
	srcpath = strip_trailing_slash(srcpath);
d1047 1
a1047 1
	 * A couple of sanity tests.
d1049 2
a1050 2
	if (!ok_lstat(srcpath, &dir_info)
	    || !ok_file_or_dir(&dir_info))
d1053 1
a1053 1
	user_filename = LYPathLeaf(srcpath);
d1058 1
a1058 1
	    return (0);
d1065 1
a1065 1
	LYRegisterUIPage(*newpath, UIP_PERMIT_OPTIONS);
d1067 1
a1067 1
	group_name = HTAA_GidToName(dir_info.st_gid);
d1069 1
a1069 1
		  srcpath,
d1074 3
a1076 4
	fprintf(fp0, "<H1>%s%s</H1>\n", PERMISSIONS_SEGMENT, user_filename);
	{
	    /*
	     * Prevent filenames which include '#' or '?' from messing it up.
d1078 3
a1080 4
	    char *srcpath_url = HTEscape(srcpath, URL_PATH);

	    fprintf(fp0, "<Form Action=\"%s//PERMIT_LOCATION%s\">\n",
		    STR_LYNXDIRED, srcpath_url);
d1084 1
a1084 2
	fprintf(fp0, "<Ol><Li>%s<Br><Br>\n",
		gettext("Specify permissions below:"));
d1087 1
a1087 1
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRUSR\" %s> Read<Br>\n",
d1090 1
a1090 1
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWUSR\" %s> Write<Br>\n",
d1093 1
a1093 1
	 * If restricted, only change eXecute permissions on directories.
d1097 3
a1099 3
		    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXUSR\" %s> %s<Br>\n",
		    (dir_info.st_mode & S_IXUSR) ? "checked" : "",
		    S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");
d1103 1
a1103 1
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRGRP\" %s> Read<Br>\n",
d1106 1
a1106 1
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWGRP\" %s> Write<Br>\n",
d1109 1
a1109 1
	 * If restricted, only change eXecute permissions on directories.
d1113 3
a1115 3
		    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXGRP\" %s> %s<Br>\n",
		    (dir_info.st_mode & S_IXGRP) ? "checked" : "",
		    S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");
d1119 1
a1119 1
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IROTH\" %s> Read<Br>\n",
d1122 1
a1122 1
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWOTH\" %s> Write<Br>\n",
d1125 1
a1125 1
	 * If restricted, only change eXecute permissions on directories.
d1129 3
a1131 3
		    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXOTH\" %s> %s<Br>\n",
		    (dir_info.st_mode & S_IXOTH) ? "checked" : "",
		    S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");
d1133 2
a1134 2
	fprintf(fp0,
		"<Br>\n<Li><Input Type=\"submit\" Value=\"Submit\">  %s %s %s.\n</Ol>\n</Form>\n",
d1142 1
a1142 1
	return (PERMIT_FORM_RESULT);	/* Special flag for LYMainLoop */
d1144 1
a1144 1
    } else {			/* The form being activated. */
d1146 2
d1150 3
a1152 2
	 * Make sure we have a valid set-permission file comparison string
	 * loaded via a previous call with srcpath != NULL.  - KW
d1159 3
a1161 3
	    CTRACE((tfp, "permit_location: called for <%s>.\n",
		    (destpath ?
		     destpath : "NULL URL pointer")));
d1165 1
a1165 1
	while (*cp != '\0' && *cp != '?') {	/* Find filename */
d1169 1
a1169 1
	    return (0);		/* Nothing to permit. */
d1171 2
a1172 2
	*cp++ = '\0';		/* Null terminate file name and
				   start working on the masks. */
d1174 4
a1177 8
	/* Will now operate only on filename part. */
	if ((destpath = HTURLPath_toFile(destpath, TRUE, FALSE)) == 0)
	    return (0);
	if (strlen(destpath) >= LY_MAXPATH) {
	    FREE(destpath);
	    return (0);
	}
	strcpy(tmpdst, destpath);
d1182 2
a1183 2
	 * Make sure that the file string is the one from the last displayed
	 * File Permissions menu.  - KW
d1190 2
a1191 2
	    CTRACE((tfp, "permit_location: called for file '%s'.\n",
		    destpath));
d1196 1
a1196 1
	 * A couple of sanity tests.
d1200 1
a1200 1
	    || !ok_file_or_dir(&dir_info)) {
d1205 1
a1205 1
	 * Cycle over permission strings.
d1207 1
a1207 1
	while (*cp != '\0') {
d1210 1
a1210 1
	    while (*cr != '\0' && *cr != '&') {		/* GET data split by '&'. */
d1216 2
a1217 2
	    if (strncmp(cp, "mode=", 5) == 0) {		/* Magic string. */
		long mask = permit_bits(cp + 5);
d1219 14
a1232 10
		if (mask != 0) {
		    /*
		     * If restricted, only change eXecute permissions on
		     * directories.
		     */
		    if (!no_change_exec_perms
			|| strchr(cp + 5, 'X') == NULL
			|| S_ISDIR(dir_info.st_mode))
			new_mode |= mask;
		} else {
d1244 1
d1246 1
a1246 1
	 * Call chmod().
d1248 7
a1254 15
	if ((program = HTGetProgramPath(ppCHMOD)) != NULL) {
	    char *args[5];
	    char amode[10];
	    char *tmpbuf = NULL;

	    HTSprintf0(&tmpbuf, "chmod %.4o %s", (unsigned int) new_mode, destpath);
	    sprintf(amode, "%.4o", (unsigned int) new_mode);
	    args[0] = "chmod";
	    args[1] = amode;
	    args[2] = destpath;
	    args[3] = (char *) 0;
	    if (LYExecv(program, args, tmpbuf) <= 0) {
		FREE(tmpbuf);
		return (-1);
	    }
d1256 1
a1256 3
	} else {
	    if (chmod(destpath, new_mode) < 0)
		return (-1);
d1258 2
d1268 1
a1268 1
 * Display or remove a tag from a given link.
d1270 3
a1272 2
void tagflag(int flag,
	     int cur)
d1275 2
a1276 2
	LYmove(links[cur].ly, 2);
	lynx_stop_reverse();
d1278 1
a1278 1
	    LYaddch('+');
d1280 1
a1280 1
	    LYaddch(' ');
d1285 1
a1285 1
	    LYHideCursor();	/* get cursor out of the way */
d1289 1
a1289 1
	     * Never hide the cursor if there's no FANCY CURSES.
d1291 1
a1291 1
	    LYmove(links[cur].ly, links[cur].lx);
d1293 1
a1293 1
	LYrefresh();
d1298 1
a1298 1
 * Handle DIRED tags.
d1300 2
a1301 1
void showtags(HTList *t)
d1309 1
a1309 1
	while ((name = (char *) HTList_nextObject(s)) != NULL) {
d1318 2
a1319 1
static char *DirectoryOf(char *pathname)
a1325 1

a1326 2
	const char *result1 = 0;

d1328 1
a1328 4
	if (!LYisRootPath(result))
	    LYTrimPathSep(result);
	result1 = wwwName(result);
	StrAllocCopy(result, result1);
a1332 1
#ifdef __DJGPP__
d1334 8
a1341 2
 * Convert filenames to acceptable 8+3 names when necessary.  Make a copy of
 * the parameter if we must modify it.
d1343 2
a1344 1
static char *LYonedot(char *line)
d1346 16
a1361 2
    char *dot;
    static char line1[LY_MAXPATH];
d1363 60
a1422 31
    if (pathconf(line, _PC_NAME_MAX) <= 12) {
	LYstrncpy(line1, line, sizeof(line1) - 1);
	for (;;) {
	    if ((dot = strrchr(line1, '.')) == 0
		|| LYLastPathSep(dot) != 0) {
		break;
	    } else if (strlen(dot) == 1) {
		*dot = 0;
	    } else {
		*dot = '_';
	    }
	}
	return (line1);
    }
    return (line);
}
#else
#define LYonedot(path) path
#endif /*  __DJGPP__ */

static char *match_op(const char *prefix,
		      char *data)
{
    int len = strlen(prefix);

    if (!strncmp("LYNXDIRED://", data, 12)
	&& !strncmp(prefix, data + 12, (unsigned) len)) {
	len += 12;
#if defined(USE_DOS_DRIVES)
	if (data[len] == '/') {	/* this is normal */
	    len++;
a1423 5
#endif
	return data + len;
    }
    return 0;
}
d1425 5
a1429 13
/*
 * Construct the appropriate system command taking care to escape all path
 * references to avoid spoofing the shell.
 */
static char *build_command(char *line,
			   char *dirname,
			   char *arg)
{
    char *buffer = NULL;
    const char *program;
    const char *tar_path = HTGetProgramPath(ppTAR);

    if ((arg = match_op("DECOMPRESS", line)) != 0) {
d1431 2
a1432 3
	if ((program = HTGetProgramPath(ppUNCOMPRESS)) != NULL) {
	    HTAddParam(&buffer, FMT_UNCOMPRESS, 1, program);
	    HTAddParam(&buffer, FMT_UNCOMPRESS, 2, arg);
d1434 1
a1434 3
	}
	return buffer;
    }
d1436 1
a1436 1
    if ((arg = match_op("UUDECODE", line)) != 0) {
d1438 2
a1439 3
	if ((program = HTGetProgramPath(ppUUDECODE)) != NULL) {
	    HTAddParam(&buffer, FMT_UUDECODE, 1, program);
	    HTAddParam(&buffer, FMT_UUDECODE, 2, arg);
a1441 3
	}
	return buffer;
    }
a1444 1
    if (tar_path != NULL) {
d1447 22
a1468 32
	if ((arg = match_op("UNTAR_GZ", line)) != 0) {
#define FMT_UNTAR_GZ "cd %s; %s -qdc %s |  %s %s %s"
	    if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 1, dirname);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 2, program);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 3, arg);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 4, tar_path);
		HTAddToCmd(&buffer, FMT_UNTAR_GZ, 5, TAR_DOWN_OPTIONS);
		HTAddToCmd(&buffer, FMT_UNTAR_GZ, 6, TAR_PIPE_OPTIONS);
		HTEndParam(&buffer, FMT_UNTAR_GZ, 6);
	    }
	    return buffer;
	}
#  endif			/* OK_GZIP */
	if ((arg = match_op("UNTAR_Z", line)) != 0) {
#define FMT_UNTAR_Z "cd %s; %s %s |  %s %s %s"
	    if ((program = HTGetProgramPath(ppZCAT)) != NULL) {
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_UNTAR_Z, 1, dirname);
		HTAddParam(&buffer, FMT_UNTAR_Z, 2, program);
		HTAddParam(&buffer, FMT_UNTAR_Z, 3, arg);
		HTAddParam(&buffer, FMT_UNTAR_Z, 4, tar_path);
		HTAddToCmd(&buffer, FMT_UNTAR_Z, 5, TAR_DOWN_OPTIONS);
		HTAddToCmd(&buffer, FMT_UNTAR_Z, 6, TAR_PIPE_OPTIONS);
		HTEndParam(&buffer, FMT_UNTAR_Z, 6);
	    }
	    return buffer;
	}
	if ((arg = match_op("UNTAR", line)) != 0) {
#define FMT_UNTAR "cd %s; %s %s %s"
	    dirname = DirectoryOf(arg);
d1470 4
a1473 7
	    HTAddParam(&buffer, FMT_UNTAR, 2, tar_path);
	    HTAddToCmd(&buffer, FMT_UNTAR, 3, TAR_DOWN_OPTIONS);
	    HTAddParam(&buffer, FMT_UNTAR, 4, arg);
	    HTEndParam(&buffer, FMT_UNTAR, 4);
	    return buffer;
	}
# endif				/* !ARCHIVE_ONLY */
d1476 26
a1501 38
	if ((arg = match_op("TAR_GZ", line)) != 0) {
#define FMT_TAR_GZ "cd %s; %s %s %s %s | %s -qc >%s%s"
	    if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_TAR_GZ, 1, dirname);
		HTAddParam(&buffer, FMT_TAR_GZ, 2, tar_path);
		HTAddToCmd(&buffer, FMT_TAR_GZ, 3, TAR_UP_OPTIONS);
		HTAddToCmd(&buffer, FMT_TAR_GZ, 4, TAR_PIPE_OPTIONS);
		HTAddParam(&buffer, FMT_TAR_GZ, 5, LYPathLeaf(arg));
		HTAddParam(&buffer, FMT_TAR_GZ, 6, program);
		HTAddParam(&buffer, FMT_TAR_GZ, 7, LYonedot(LYPathLeaf(arg)));
		HTAddParam(&buffer, FMT_TAR_GZ, 8, EXT_TAR_GZ);
		HTEndParam(&buffer, FMT_TAR_GZ, 8);
	    }
	    return buffer;
	}
# endif				/* OK_GZIP */

	if ((arg = match_op("TAR_Z", line)) != 0) {
#define FMT_TAR_Z "cd %s; %s %s %s %s | %s >%s%s"
	    if ((program = HTGetProgramPath(ppCOMPRESS)) != NULL) {
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_TAR_Z, 1, dirname);
		HTAddParam(&buffer, FMT_TAR_Z, 2, tar_path);
		HTAddToCmd(&buffer, FMT_TAR_Z, 3, TAR_UP_OPTIONS);
		HTAddToCmd(&buffer, FMT_TAR_Z, 4, TAR_PIPE_OPTIONS);
		HTAddParam(&buffer, FMT_TAR_Z, 5, LYPathLeaf(arg));
		HTAddParam(&buffer, FMT_TAR_Z, 6, program);
		HTAddParam(&buffer, FMT_TAR_Z, 7, LYonedot(LYPathLeaf(arg)));
		HTAddParam(&buffer, FMT_TAR_Z, 8, EXT_TAR_Z);
		HTEndParam(&buffer, FMT_TAR_Z, 8);
	    }
	    return buffer;
	}

	if ((arg = match_op("TAR", line)) != 0) {
#define FMT_TAR "cd %s; %s %s %s %s.tar %s"
	    dirname = DirectoryOf(arg);
d1503 4
a1506 9
	    HTAddParam(&buffer, FMT_TAR, 2, tar_path);
	    HTAddToCmd(&buffer, FMT_TAR, 3, TAR_UP_OPTIONS);
	    HTAddToCmd(&buffer, FMT_TAR, 4, TAR_FILE_OPTIONS);
	    HTAddParam(&buffer, FMT_TAR, 5, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_TAR, 6, LYPathLeaf(arg));
	    HTEndParam(&buffer, FMT_TAR, 6);
	    return buffer;
	}
    }
d1510 1
a1510 1
    if ((arg = match_op("GZIP", line)) != 0) {
d1512 2
a1513 3
	if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
	    HTAddParam(&buffer, FMT_GZIP, 1, program);
	    HTAddParam(&buffer, FMT_GZIP, 2, arg);
a1514 3
	}
	return buffer;
    }
d1516 1
a1516 1
    if ((arg = match_op("UNGZIP", line)) != 0) {
d1518 2
a1519 3
	if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
	    HTAddParam(&buffer, FMT_UNGZIP, 1, program);
	    HTAddParam(&buffer, FMT_UNGZIP, 2, arg);
a1520 3
	}
	return buffer;
    }
d1525 1
a1525 1
    if ((arg = match_op("ZIP", line)) != 0) {
d1527 1
a1527 2
	if ((program = HTGetProgramPath(ppZIP)) != NULL) {
	    dirname = DirectoryOf(arg);
d1529 3
a1531 3
	    HTAddParam(&buffer, FMT_ZIP, 2, program);
	    HTAddParam(&buffer, FMT_ZIP, 3, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_ZIP, 4, LYPathLeaf(arg));
d1533 2
a1534 5
	}
	return buffer;
    }
#if !defined(ARCHIVE_ONLY)
    if ((arg = match_op("UNZIP", line)) != 0) {
d1536 1
a1536 2
	if ((program = HTGetProgramPath(ppUNZIP)) != NULL) {
	    dirname = DirectoryOf(arg);
d1538 2
a1539 2
	    HTAddParam(&buffer, FMT_UNZIP, 2, program);
	    HTAddParam(&buffer, FMT_UNZIP, 3, arg);
d1541 1
a1541 4
	}
	return buffer;
    }
# endif				/* !ARCHIVE_ONLY */
d1544 1
a1544 1
    if ((arg = match_op("COMPRESS", line)) != 0) {
d1546 2
a1547 3
	if ((program = HTGetProgramPath(ppCOMPRESS)) != NULL) {
	    HTAddParam(&buffer, FMT_COMPRESS, 1, program);
	    HTAddParam(&buffer, FMT_COMPRESS, 2, arg);
a1549 109
	return buffer;
    }

    return NULL;
}

/*
 * Perform file management operations for LYNXDIRED URL's.  Attempt to be
 * consistent.  These are (pseudo) URLs - i.e., they should be in URL syntax: 
 * some bytes will be URL-escaped with '%'.  This is necessary because these
 * (pseudo) URLs will go through some of the same kinds of interpretations and
 * mutilations as real ones:  HTParse, stripping off #fragments etc.  (Some
 * access schemes currently have special rules about not escaping parsing '#'
 * "the URL way" built into HTParse, but that doesn't look like a clean way.)
 */
int local_dired(DocInfo *doc)
{
    char *line_url;		/* will point to doc's address, which is a URL */
    char *line = NULL;		/* same as line_url, but HTUnEscaped, will be alloced */
    char *arg = NULL;		/* ...will point into line[] */
    char *tp = NULL;
    char *tmpbuf = NULL;
    char *buffer = NULL;
    char *dirname = NULL;
    BOOL do_pop_doc = TRUE;

    line_url = doc->address;
    CTRACE((tfp, "local_dired: called for <%s>.\n",
	    (line_url
	     ? line_url
	     : gettext("NULL URL pointer"))));
    HTUnEscapeSome(line_url, "/");	/* don't mess too much with *doc */

    StrAllocCopy(line, line_url);
    HTUnEscape(line);		/* _file_ (not URL) syntax, for those functions
				   that need it.  Don't forget to FREE it. */
    if ((arg = match_op("CHDIR", line)) != 0) {
#ifdef SUPPORT_CHDIR
	handle_LYK_CHDIR();
	do_pop_doc = FALSE;
#endif
	arg = "blah";		/* do something to avoid cc's complaints */
    } else if ((arg = match_op("NEW_FILE", line)) != 0) {
	if (create_file(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("NEW_FOLDER", line)) != 0) {
	if (create_directory(arg) > 0)
	    LYforce_no_cache = TRUE;
#ifdef OK_INSTALL
    } else if ((arg = match_op("INSTALL_SRC", line)) != 0) {
	local_install(NULL, arg, &tp);
	if (tp) {
	    FREE(doc->address);
	    doc->address = tp;
	}
	FREE(line);
	return 0;
    } else if ((arg = match_op("INSTALL_DEST", line)) != 0) {
	local_install(arg, NULL, &tp);
	LYpop(doc);
#endif /* OK_INSTALL */
    } else if ((arg = match_op("MODIFY_NAME", line)) != 0) {
	if (modify_name(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("MODIFY_LOCATION", line)) != 0) {
	if (modify_location(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("MOVE_TAGGED", line_url)) != 0) {
	if (modify_tagged(arg) > 0)
	    LYforce_no_cache = TRUE;
#ifdef OK_PERMIT
    } else if ((arg = match_op("PERMIT_SRC", line)) != 0) {
	permit_location(NULL, arg, &tp);
	if (tp) {
	    /*
	     * One of the checks may have failed.
	     */
	    FREE(doc->address);
	    doc->address = tp;
	}
	FREE(line);
	return 0;
    } else if ((arg = match_op("PERMIT_LOCATION", line_url)) != 0) {
	permit_location(arg, NULL, &tp);
#endif /* OK_PERMIT */
    } else if ((arg = match_op("REMOVE_SINGLE", line)) != 0) {
	if (remove_single(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("REMOVE_TAGGED", line)) != 0) {
	if (remove_tagged())
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("CLEAR_TAGGED", line)) != 0) {
	clear_tags();
    } else if ((arg = match_op("UPLOAD", line)) != 0) {
	/*
	 * They're written by LYUpload_options() HTUnEscaped; don't want to
	 * change that for now...  so pass through without more unescaping. 
	 * Directory names containing '#' will probably fail.
	 */
	if (LYUpload(line_url))
	    LYforce_no_cache = TRUE;
    } else {
	LYTrimPathSep(line);
	if (LYLastPathSep(line) == NULL) {
	    FREE(line);
	    return 0;
	}

	buffer = build_command(line, dirname, arg);
d1552 1
a1552 1
	    if ((int) strlen(buffer) < LYcolLimit - 14) {
d1560 1
a1560 1
	    printf("%s\r\n", tmpbuf);
d1575 1
a1575 2
    if (do_pop_doc)
	LYpop(doc);
d1580 1
a1580 1
 * Provide a menu of file management options.
d1582 3
a1584 1
int dired_options(DocInfo *doc, char **newfile)
d1587 2
a1588 3
    char *path;
    char *dir;
    lynx_list_item_type *nxt;
d1591 1
d1599 5
a1603 2
    if ((fp0 = InternalPageFP(tempfile, FALSE)) == 0)
	return (0);
d1606 1
a1606 1
     * Make the tempfile a URL.
d1609 6
a1614 1
    LYRegisterUIPage(*newfile, UIP_DIRED_MENU);
d1616 3
a1618 2
    if (doc->link > -1 && doc->link < (nlinks + 1)) {
	path = HTfullURL_toFile(links[doc->link].lname);
d1620 1
a1623 1
	    FREE(path);
d1628 1
a1628 1
	StrAllocCopy(path, "");
d1631 1
a1631 4
    dir = HTfullURL_toFile(doc->address);
    LYTrimPathSep(dir);

    nothing_tagged = (BOOL) (HTList_isEmpty(tagged));
d1646 3
a1648 2
	 * Write out number of tagged items, and names of first few of them
	 * relative to current (in the DIRED sense) directory.
a1653 1

d1657 1
a1657 3
		n, ((n == 1)
		    ? gettext("tagged item:")
		    : gettext("tagged items:")));
d1663 1
a1663 1
	    cp1 = HTRelative((char *) HTList_objectAt(tagged, i - 1),
d1666 1
a1666 1
	    LYEntify(&cp1, TRUE);	/* _should_ do this everywhere... */
d1668 1
a1668 1
		    (i == 1 ? "" : " ,"), cp1);
d1672 1
a1672 1
	    fprintf(fp0, " , ...");
d1679 1
a1679 1
     * If menu_head is NULL then use defaults and link them together now.
d1708 1
a1708 1
	dir_url = HTEscape(dir, URL_PATH);
d1711 1
a1711 1
		render_item(mp->href, path_url, dir_url, buf, sizeof(buf), YES));
d1713 1
a1713 1
		render_item(mp->link, path, dir, buf, sizeof(buf), NO));
d1715 1
a1715 1
		render_item(mp->rest, path, dir, buf, sizeof(buf), NO));
a1718 1
    FREE(path);
d1726 1
a1726 1
		    "<a href=\"LYNXDIRED://UPLOAD=%d/TO=%s\"> %s </a><br>\n",
a1729 1
    FREE(dir);
d1736 1
a1736 1
    return (0);
d1740 1
a1740 1
 * Check DIRED filename.
d1742 4
a1745 3
static char *get_filename(const char *prompt,
			  char *buf,
			  size_t bufsize)
d1751 1
d1759 1
a1759 1
	cp = LYLastPathSep(buf);	/* find last slash */
a1771 15
#ifdef OK_INSTALL

#define LYEXECV_MAX_ARGC 15
/* these are quasi-constant once they have been allocated: */
static char **install_argp = NULL;	/* args for execv install */
static char *install_path = NULL;	/* auxiliary */

#ifdef LY_FIND_LEAKS
static void clear_install_path(void)
{
    FREE(install_argp);
    FREE(install_path);
}
#endif /* LY_FIND_LEAKS */

d1773 1
a1773 9
 * Fill in args array for execv (or execvp etc.) call, after first allocating
 * it if necessary.  No fancy parsing, cmd_args is just split at spaces.  Leave
 * room for reserve additional args to be added by caller.
 *
 * On success *argvp points to new args vector, *pathp is auxiliary.  On
 * success returns index of next argument, else -1.  This is generic enough
 * that it could be used for other calls than install, except the atexit call. 
 * Go through this trouble for install because INSTALL_ARGS may be significant,
 * and someone may configure it with more than one significant flags.  - kw
d1775 4
a1778 49
static int fill_argv_for_execv(char ***argvp,
			       char **pathp,
			       char *cmd_path,
			       const char *cmd_args,
			       int reserve)
{
    int n = 0;

    char **args;
    char *cp;

    if (*argvp == NULL) {
	*argvp = typecallocn(char *, LYEXECV_MAX_ARGC + 1);

	if (!*argvp)
	    return (-1);
#ifdef LY_FIND_LEAKS
	atexit(clear_install_path);
#endif
    }
    args = *argvp;
    args[n++] = cmd_path;
    if (cmd_args) {
	StrAllocCopy(*pathp, cmd_args);
	cp = strtok(*pathp, " ");
	if (cp) {
	    while (cp && (n < LYEXECV_MAX_ARGC - reserve)) {
		args[n++] = cp;
		cp = strtok(NULL, " ");
	    }
	    if (cp && (n >= LYEXECV_MAX_ARGC - reserve)) {
		CTRACE((tfp, "Too many args for '%s' in '%s'!\n",
			NONNULL(cmd_path), cmd_args));
		return (-1);
	    }
	} else {
	    args[n++] = *pathp;
	}
    }
    args[n] = (char *) 0;
    return (n);
}

/*
 * Install the specified file or directory.
 */
BOOLEAN local_install(char *destpath,
		      char *srcpath,
		      char **newpath)
d1781 1
a1781 3
    static char savepath[DIRED_MAXBUF];		/* This will be the link that

						   is to be installed. */
d1783 1
a1783 1
    char **args;
a1784 2
    char *cp = NULL;
    char *tmpdest = NULL;
d1786 1
a1786 8
    int n = 0;			/* indices into 'args[]' */
    static int src = -1;
    const char *program;

    if ((program = HTGetProgramPath(ppINSTALL)) == NULL) {
	HTAlert(gettext("Install in the selected directory not permitted."));
	return 0;
    }
d1789 1
a1789 1
     * Determine the status of the selected item.
d1792 2
a1793 3
	srcpath = strip_trailing_slash(srcpath);
	if (is_url(srcpath)) {
	    char *local_src = HTfullURL_toFile(srcpath);
a1794 11
	    if (!ok_localname(savepath, local_src)) {
		FREE(local_src);
		return 0;
	    }
	    FREE(local_src);
	} else if (!HTList_isEmpty(tagged) &&
		   srcpath[0] == '\0') {
	    savepath[0] = '\0';	/* will always use tagged list - kw */
	} else if (!ok_localname(savepath, srcpath)) {
	    return 0;
	}
d1797 1
a1797 3
	LYAddHtmlSep(newpath);
	StrAllocCat(*newpath, INSTALLDIRS_FILE);
	LYRegisterUIPage(*newpath, UIP_INSTALL);
a1800 18
    /* deal with ~/ or /~/ at the beginning - kw */
    if (destpath[0] == '~' &&
	(destpath[1] == '/' || destpath[1] == '\0')) {
	cp = &destpath[1];
    } else if (destpath[0] == '/' && destpath[1] == '~' &&
	       (destpath[2] == '/' || destpath[2] == '\0')) {
	cp = &destpath[2];
    }
    if (cp) {
	/* If found, allocate new string, make destpath point to it - kw */
	StrAllocCopy(tmpdest, Home_Dir());
	if (cp[0] && cp[1]) {
	    LYAddPathSep(&tmpdest);
	    StrAllocCat(tmpdest, cp + 1);
	}
	destpath = tmpdest;
    }

a1803 1
	FREE(tmpdest);
a1806 1
	FREE(tmpdest);
d1808 1
a1808 1
    } else if (0 /*directory not writable */ ) {
a1809 1
	FREE(tmpdest);
d1814 1
a1814 8

    /* fill in the fixed args, if not already done - kw */
    if (src > 0 && install_argp) {
	n = src;
	n++;
    } else {
	n = fill_argv_for_execv(&install_argp, &install_path,
				"install",
d1816 1
a1816 3
				INSTALL_ARGS,
#else
				NULL,
d1818 1
a1818 11
				2);
	if (n <= 0) {
	    src = 0;
	    HTAlert(gettext("Error building install args"));
	    FREE(tmpdest);
	    return 0;
	}
	src = n++;
    }
    args = install_argp;

d1820 2
a1821 1
    args[n] = (char *) 0;
a1824 14
	/* simplistic detection of identical src and dest - kw */
	if (!strcmp(savepath, destpath)) {
	    HTUserMsg2(gettext("Source and target are the same: %s"),
		       savepath);
	    FREE(tmpdest);
	    return (-1);	/* don't do it */
	} else if (!strncmp(savepath, destpath, strlen(destpath)) &&
		   LYIsPathSep(savepath[strlen(destpath)]) &&
		   LYLastPathSep(savepath + strlen(destpath) + 1) == 0) {
	    HTUserMsg2(gettext("Already in target directory: %s"),
		       savepath);
	    FREE(tmpdest);
	    return 0;		/* don't do it */
	}
d1826 1
a1826 4
	HTSprintf0(&tmpbuf, "install %s in %s", savepath, destpath);
	if (LYExecv(program, args, tmpbuf) <= 0) {
	    FREE(tmpbuf);
	    FREE(tmpdest);
a1827 1
	}
d1831 1
a1831 3

	HTSprintf0(&tmpbuf, "install in %s", destpath);
	while ((name = (char *) HTList_nextObject(tag))) {
a1832 1

d1834 1
a1834 16

	    /* simplistic detection of identical src and dest - kw */
	    if (!strcmp(args[src], destpath)) {
		HTUserMsg2(gettext("Source and target are the same: %s"),
			   args[src]);
		FREE(args[src]);
		continue;	/* skip this source file */
	    } else if (!strncmp(args[src], destpath, strlen(destpath)) &&
		       LYIsPathSep(args[src][strlen(destpath)]) &&
		       LYLastPathSep(args[src] + strlen(destpath) + 1) == 0) {
		HTUserMsg2(gettext("Already in target directory: %s"),
			   args[src]);
		FREE(args[src]);
		continue;	/* skip this source file */
	    }
	    err = (LYExecv(program, args, tmpbuf) <= 0);
d1836 1
a1836 3
	    if (err) {
		FREE(tmpbuf);
		FREE(tmpdest);
a1837 1
	    }
a1842 1
    FREE(tmpdest);
a1845 1
#endif /* OK_INSTALL */
d1848 1
a1848 1
 * Clear DIRED tags.
d1850 1
a1850 1
void clear_tags(void)
d1854 1
a1854 1
    while ((cp = (char *) HTList_removeLastObject(tagged)) != NULL) {
d1862 1
a1862 1
 * Handle DIRED menu item.
d1864 2
a1865 1
void add_menu_item(char *str)
d1867 1
a1867 1
    struct dired_menu *tmp, *mp;
d1871 2
a1872 1
     * First custom menu definition causes entire default menu to be discarded.
d1877 2
a1878 3
    tmp = typecalloc(struct dired_menu);

    if (tmp == NULL)
d1882 1
a1882 1
     * Conditional on tagged != NULL ?
d1887 1
a1887 1
	tmp->cond = DE_TAG;
d1889 1
a1889 1
	tmp->cond = DE_DIR;
d1891 1
a1891 2
	tmp->cond = DE_FILE;
#ifdef S_IFLNK
d1893 1
a1893 2
	tmp->cond = DE_SYMLINK;
#endif /* S_IFLNK */
d1897 1
a1897 1
     * Conditional on matching suffix.
d1902 1
a1902 1
    StrAllocCopy(tmp->sfx, str);
d1907 1
a1907 1
    StrAllocCopy(tmp->link, str);
d1912 1
a1912 1
    StrAllocCopy(tmp->rest, str);
d1914 1
a1914 1
    StrAllocCopy(tmp->href, cp);
d1917 3
a1919 2
	for (mp = menu_head; mp && mp->next != NULL; mp = mp->next) ;
	mp->next = tmp;
d1921 1
a1921 18
	menu_head = tmp;
}

void reset_dired_menu(void)
{
    if (menu_head != defmenu) {
	struct dired_menu *mp, *mp_next = NULL;

	for (mp = menu_head; mp != NULL; mp = mp_next) {
	    FREE(mp->sfx);
	    FREE(mp->link);
	    FREE(mp->rest);
	    FREE(mp->href);
	    mp_next = mp_next;
	    FREE(mp);
	}
	menu_head = NULL;
    }
d1925 1
a1925 1
 * Create URL for DIRED HREF value.
d1927 7
a1933 6
static char *render_item(const char *s,
			 const char *path,
			 const char *dir,
			 char *buf,
			 int bufsize,
			 BOOLEAN url_syntax)
d1935 1
a1935 1
    const char *cp;
a1938 1

d1940 2
a1941 2
    /* Buffer overrun could happen for very long
       tag list, if %l or %t are used */
d1947 4
a1950 22
	    case '%':
		*BP_INC = '%';
		break;
	    case 'p':
		cp = path;
		if (!LYIsHtmlSep(*cp))
		    *BP_INC = '/';
		while (*cp)
		    *BP_INC = *cp++;
		break;
	    case 'd':
		cp = dir;
		if (!LYIsHtmlSep(*cp))
		    *BP_INC = '/';
		while (*cp)
		    *BP_INC = *cp++;
		break;
	    case 'f':
		cp = LYLastPathSep(path);
		if (cp)
		    cp++;
		else
d1952 18
a1969 22
		while (*cp)
		    *BP_INC = *cp++;
		break;
	    case 'l':
	    case 't':
		if (!HTList_isEmpty(tagged)) {
		    HTList *cur = tagged;
		    char *name;

		    while (!overrun &&
			   (name = (char *) HTList_nextObject(cur)) != NULL) {
			if (*s == 'l' && (cp = strrchr(name, '/')))
			    cp++;
			else
			    cp = name;
			StrAllocCat(taglist, cp);
			StrAllocCat(taglist, " ");	/* should this be %20? */
		    }
		}
		if (taglist) {
		    /* could HTUnescape here... */
		    cp = taglist;
d1972 29
a2000 7
		    FREE(taglist);
		}
		break;
	    default:
		*BP_INC = '%';
		*BP_INC = *s;
		break;
d2004 3
a2006 2
	     * Other chars come from the lynx.cfg or the default.  Let's assume
	     * there isn't anything weird there that needs escaping.
d2008 1
a2008 1
	    *BP_INC = *s;
d2013 3
a2015 2
	HTAlert(gettext("Temporary URL or list would be too long."));
	bp = buf;		/* set to start, will return empty string as URL */
d2020 22
d2043 63
a2105 1
#endif /* DIRED_SUPPORT */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a45 1
#include <www_wait.h>
d47 4
a50 2
#ifdef SUPPORT_CHDIR
#include <LYMainLoop.h>
d52 2
d55 7
a61 1
#include <LYLeaks.h>
d63 7
a69 1
#undef USE_COMPRESS
d71 1
a71 9
#ifdef __DJGPP__
#define EXT_TAR_GZ ".tgz"
#define EXT_TAR_Z  ".taz"
#define EXT_Z      ".z"
#else
#define EXT_TAR_GZ ".tar.gz"
#define EXT_TAR_Z  ".tar.Z"
#define EXT_Z      ".Z"
#endif
d73 4
a76 3
#ifndef DIRED_MAXBUF
#define DIRED_MAXBUF 512
#endif
d79 2
a80 8

#ifdef OK_INSTALL
#ifdef FNAMES_8_3
#define INSTALLDIRS_FILE "instdirs.htm"
#else
#define INSTALLDIRS_FILE ".installdirs.html"
#endif /* FNAMES_8_3 */
#endif /* OK_INSTALL */
d88 1
a88 1
PRIVATE int permit_location PARAMS((
d91 1
a91 1
	char **		newpath));
d96 2
a97 2
	CONST char *	path,
	CONST char *	dir,
d100 1
a100 1
	BOOLEAN		url_syntax));
a120 4
#ifdef SUPPORT_CHDIR
{ 0,		      "", "Change directory",
		      "", "LYNXDIRED://CHDIR",			NULL },
#endif
a126 1
#ifdef OK_INSTALL
d128 1
a128 6
"selected file to new location", "LYNXDIRED://INSTALL_SRC%p",	NULL },
/* The following (installing a directory) doesn't work for me, at least
   with the "install" from GNU fileutils 4.0.  I leave it in anyway, in
   case one compiles with INSTALL_PATH / INSTALL_ARGS defined to some
   other command for which it works (like a script, or maybe "cp -a"). - kw
*/
d130 1
a130 2
"selected directory to new location", "LYNXDIRED://INSTALL_SRC%p",	NULL },
#endif /* OK_INSTALL */
a135 1
#ifdef S_IFLNK
a137 1
#endif  /* S_IFLNK */
a149 1
#ifdef S_IFLNK
a151 1
#endif /* S_IFLNK */
a156 1
#ifdef S_IFLNK
a158 1
#endif /* S_IFLNK */
d166 1
a166 1
{ DE_FILE,	EXT_TAR_Z, "Expand",
d179 1
a179 1
{ DE_FILE,	   EXT_Z, "Uncompress",
a207 5
#if defined(OK_TAR) && defined(USE_COMPRESS)
{ DE_DIR,	      "", "Tar and compress",
      "(using compress)", "LYNXDIRED://TAR_Z%p",		NULL },
#endif /* OK_TAR && USE_COMPRESS */

d218 1
a218 1
	  "(using gzip)", "LYNXDIRED://GZIP%p",			NULL },
a228 5
#ifdef OK_INSTALL
{ DE_TAG,	      "", "Install tagged files into another directory.",
		      "", "LYNXDIRED://INSTALL_SRC%00",		NULL },
#endif

d236 1
a236 1
		    NULL, NULL,					NULL }
d239 1
a239 1
PRIVATE BOOLEAN cannot_stat ARGS1(CONST char *, name)
d242 1
a242 1
    HTSprintf0(&tmpbuf, gettext("Unable to get status of '%s'."), name);
d248 1
a248 3
#define OK_STAT(name, sb) (stat(name, sb) == 0)

PRIVATE BOOLEAN ok_stat ARGS2(CONST char *, name, struct stat*, sb)
d250 2
a251 2
    CTRACE((tfp, "testing ok_stat(%s)\n", name));
    if (!OK_STAT(name, sb)) {
d260 1
a260 1
    CTRACE((tfp, "testing ok_lstat(%s)\n", name));
d280 1
a280 2
#ifdef OK_INSTALL		/* currently only used in local_install */
PRIVATE BOOLEAN ok_localname ARGS2(char*, dst, CONST char*, src)
d282 1
d285 1
a285 1
    if (!ok_stat(src, &dir_info)
d287 1
d290 2
a291 5
    if (strlen(src) >= DIRED_MAXBUF) {
	CTRACE((tfp, "filename too long in ok_localname!\n"));
	return FALSE;
    }
    strcpy(dst, src);
a293 175
#endif /* OK_INSTALL */

/*
 *  Execute DIRED command, return -1 or 0 on failure, 1 success.
 */
PRIVATE int LYExecv ARGS3(
	CONST char *,	path,
	char **,	argv,
	char *,		msg)
{
    int rc = 0;
#if defined(VMS) || defined(_WINDOWS)
    CTRACE((tfp, "LYExecv:  Called inappropriately! (path=%s)\n", path));
#else
    int n;
    char *tmpbuf = 0;
#ifdef __DJGPP__
    stop_curses();
    HTSprintf0(&tmpbuf, "%s", path);
    for (n = 1; argv[n] != 0; n++)
	HTSprintf(&tmpbuf, " %s", argv[n]);
    HTSprintf(&tmpbuf, "\n");
    rc = LYSystem(tmpbuf) ? 0 : 1;
#else
    int pid;
#ifdef HAVE_TYPE_UNIONWAIT
    union wait wstatus;
#else
    int wstatus;
#endif

    if (TRACE) {
	CTRACE((tfp, "LYExecv path='%s'\n", path));
	for (n = 0; argv[n] != 0; n++)
	    CTRACE((tfp, "argv[%d] = '%s'\n", n, argv[n]));
    }

    rc = 1;		/* It will work */
    stop_curses();
    pid = fork();	/* fork and execute command */

    switch (pid) {
	case -1:
	    HTSprintf0(&tmpbuf, gettext("Unable to %s due to system error!"), msg);
	    rc = 0;
	    break;	/* don't fall thru! - KW */

	case 0:  /* child */
#ifdef USE_EXECVP
	    execvp(path, argv);	/* this uses our $PATH */
#else
	    execv(path, argv);
#endif
	    exit(EXIT_FAILURE);	/* execv failed, give wait() something to look at */
	    /*NOTREACHED*/

	default:  /* parent */
#if !HAVE_WAITPID
	    while (wait(&wstatus) != pid)
		; /* do nothing */
#else
	    while (-1 == waitpid(pid, &wstatus, 0)) { /* wait for child */
#ifdef EINTR
		if (errno == EINTR)
		    continue;
#endif /* EINTR */
#ifdef ERESTARTSYS
		if (errno == ERESTARTSYS)
		    continue;
#endif /* ERESTARTSYS */
		break;
	    }
#endif /* !HAVE_WAITPID */
	    if ((WIFEXITED(wstatus)
	      && (WEXITSTATUS(wstatus) != 0))
	     || (WIFSIGNALED(wstatus)
	      && (WTERMSIG(wstatus) > 0)))	{ /* error return */
		HTSprintf0(&tmpbuf, gettext("Probable failure to %s due to system error!"),
				   msg);
		rc = 0;
	    }
    }
#endif /* __DJGPP__ */

    if (rc == 0) {
	/*
	 *  Screen may have message from the failed execv'd command.
	 *  Give user time to look at it before screen refresh.
	 */
	LYSleepAlert();
    }
    start_curses();
    if (tmpbuf != 0) {
	if (rc == 0)
	    HTAlert(tmpbuf);
	FREE(tmpbuf);
    }

#endif /* VMS || _WINDOWS */
    return(rc);
}

PRIVATE int make_directory ARGS1(char *, path)
{
    int code;
    CONST char *program;

    if ((program = HTGetProgramPath(ppMKDIR)) != NULL) {
	char *args[5];
	char *msg = 0;

	HTSprintf0(&msg,"make directory %s", path);
	args[0] = "mkdir";
	args[1] = path;
	args[2] = (char *) 0;
	code = (LYExecv(program, args, msg) <= 0) ? -1 : 1;
	FREE(msg);
    } else {
#ifdef _WINDOWS
	code = mkdir(path) ? -1 : 1;
#else
	code = mkdir(path, 0777) ? -1 : 1;
#endif
    }
    return (code);
}

PRIVATE int remove_file ARGS1(char *, path)
{
    int code;
    CONST char *program;

    if ((program = HTGetProgramPath(ppRM)) != NULL) {
	char *args[5];
	char *tmpbuf = NULL;

	args[0] = "rm";
	args[1] = "-rf";
	args[2] = path;
	args[3] = (char *) 0;
	HTSprintf0(&tmpbuf, gettext("remove %s"), path);
	code = LYExecv(program, args, tmpbuf);
	FREE(tmpbuf);
    } else {
	code = remove(path) ? -1 : 1;
    }
    return (code);
}

PRIVATE int touch_file ARGS1(char *, path)
{
    int code;
    CONST char *program;

    if ((program = HTGetProgramPath(ppTOUCH)) != NULL) {
	char *args[5];
	char *msg = NULL;

	HTSprintf0(&msg, gettext("touch %s"), path);
	args[0] = "touch";
	args[1] = path;
	args[2] = (char *) 0;
	code = (LYExecv(program, args, msg) <= 0) ? -1 : 1;
	FREE(msg);
    } else {
	FILE *fp;
	if ((fp = fopen(path, "w")) != 0) {
	    fclose(fp);
	    code = 1;
	} else {
	    code = -1;
	}
    }
    return (code);
}
d298 2
a299 5
    CONST char *program;

    if ((program = HTGetProgramPath(ppMV)) != NULL) {
	char *msg = 0;
	char *args[5];
d301 7
a307 26
	HTSprintf0(&msg, gettext("move %s to %s"), source, target);
	args[0] = "mv";
	args[1] = source;
	args[2] = target;
	args[3] = (char *) 0;
	code = (LYExecv(program, args, msg) <= 0) ? -1 : 1;
	FREE(msg);
    } else {
	struct stat sb;
	char *actual = 0;
	/* the caller sets up a target directory; we need a file path */
	if (stat(target, &sb) == 0
	 && S_ISDIR(sb.st_mode)) {
	    HTSprintf0(&actual, "%s/%s", target, LYPathLeaf(source));
	    CTRACE((tfp, "move_file source=%s, target=%s\n", source, target));
	    target = actual;
	}
	if ((code = rename(source, target)) != 0)
	    if ((code = LYCopyFile(source, target)) >= 0)
		code = remove(source);
	if (code == 0)
	    code = 1;
	if (actual != target) {
	    FREE(actual);
	}
    }
d315 1
a315 1
    if (!OK_STAT(name, &dir_info)) {
d331 1
a331 1
PRIVATE BOOLEAN dir_has_same_owner ARGS2(struct stat *, info, int, owner)
d334 1
a334 1
	if ((int) info->st_uid == owner) {
d348 1
a348 1
PRIVATE int remove_tagged NOARGS
d358 1
d363 1
a363 1
    ans = HTConfirm(gettext("Remove all tagged files and directories?"));
d380 6
a385 1
		if (remove_file(testpath) <= 0) {
a390 1
		FREE(testpath);
d409 2
a410 2
PRIVATE int modify_tagged ARGS1(
	char *,		testpath)
d415 1
a415 1
    int owner;
d417 1
a417 1
    char *savepath;
d451 2
d459 2
a460 8
	    if (cp) {
		cp = strip_trailing_slash(cp);
		cp = HTParse(".", cp, PARSE_PATH+PARSE_PUNCTUATION);
		savepath = HTURLPath_toFile(cp, TRUE, FALSE);
		FREE(cp);
	    } else {	/* Last resort, should never happen. */
		savepath = HTURLPath_toFile(".", TRUE, FALSE);
	    }
d462 2
a463 6
	    if (!strncmp(cp, "file://localhost", 16)) {
		cp += 16;
	    } else if (isFILE_URL(cp)) {
		cp += LEN_FILE_URL;
	    }
	    savepath = HTURLPath_toFile(cp, TRUE, FALSE);
d465 1
d493 1
a493 1
	    LYstrncpy(tmpbuf, cp1, sizeof(tmpbuf)-1);
d526 1
a526 1
	 *  by the same uid as the owner of the current location.
d536 2
a537 1
		srcpath = HTfullURL_toFile(cp);
d540 1
d545 1
a545 1
		FREE(srcpath);
d560 2
a561 2
PRIVATE int modify_name ARGS1(
	char *,		testpath)
d564 3
a566 2
    char tmpbuf[DIRED_MAXBUF];
    char *newpath = NULL;
a567 1
    int code = 0;
a584 1
	LYstrncpy(tmpbuf, LYPathLeaf(testpath), sizeof(tmpbuf)-1);
d591 8
a598 7
	if (LYLastPathSep(tmpbuf) != 0) {
	    HTAlert(gettext("Illegal character (path-separator) found! Request ignored."));
	} else if (strlen(tmpbuf)) {
	    if ((cp = LYLastPathSep(testpath)) != NULL)
		HTSprintf0(&newpath, "%.*s%s", (cp - testpath + 1), testpath, tmpbuf);
	    else
		StrAllocCopy(newpath, tmpbuf);
d604 1
a604 1
		code = move_file(testpath, newpath);
a605 2
	    FREE(newpath);

d608 1
a608 1
    return code;
d614 2
a615 2
PRIVATE int modify_location ARGS1(
	char *,		testpath)
d620 1
a620 1
    int owner;
d622 2
a623 2
    char *newpath = NULL;
    char *savepath = NULL;
a624 1
    int code = 0;
d630 1
d639 1
a639 6
	if (HTGetProgramPath(ppMV) != NULL) {
	    cp = gettext("Enter new location for directory: ");
	} else {
	    HTAlert(COULD_NOT_ACCESS_DIR);
	    return 0;
	}
a644 2
    LYstrncpy(tmpbuf, testpath, sizeof(tmpbuf)-1);
    *LYPathLeaf(tmpbuf) = '\0';
d648 2
a649 2
	StrAllocCopy(savepath, testpath);
	StrAllocCopy(newpath, testpath);
d656 12
a667 9
	    StrAllocCopy(newpath, Home_Dir());
	    StrAllocCat(newpath, (tmpbuf + 1));
	    LYstrncpy(tmpbuf, newpath, sizeof(tmpbuf)-1);
	}
	if (LYisAbsPath(tmpbuf)) {
	    StrAllocCopy(newpath, tmpbuf);
	} else if ((cp = LYLastPathSep(newpath)) != NULL) {
	    *++cp = '\0';
	    StrAllocCat(newpath, tmpbuf);
d669 1
a669 4
	    HTAlert(gettext("Unexpected failure - unable to find trailing path separator"));
	    FREE(newpath);
	    FREE(savepath);
	    return 0;
d679 1
a679 1
	    code = 0;
d681 1
a681 1
#ifdef UNIX
d685 1
a685 1
	else if (dev == dir_info.st_dev && inode == dir_info.st_ino) {
d687 1
a687 1
	    code = 0;
d689 2
a690 3
#endif
	else if (dir_has_same_owner(&dir_info, owner)) {
	    code = move_file(savepath,newpath);
a691 2
	FREE(newpath);
	FREE(savepath);
d693 1
a693 1
    return code;
d699 2
a700 2
PUBLIC int local_modify ARGS2(
	DocInfo *,	doc,
d703 1
a703 1
    int ans;
d705 1
a705 1
    char testpath[DIRED_MAXBUF]; /* a bit ridiculous */
d710 2
d713 1
a713 2
	count = modify_tagged(cp);
	FREE(cp);
d735 1
a735 1
    _statusline(gettext("Modify name or location (n or l): "));
d737 2
a738 1
    ans = LYgetch_single();
d742 1
a742 5
	if (strlen(cp) >= DIRED_MAXBUF) {
	    FREE(cp);
	    return 0;
	}
	LYstrncpy(testpath, cp, sizeof(testpath)-1);
d770 2
a771 2
PRIVATE int create_file ARGS1(
	char *,		current_location)
d774 3
a776 2
    char tmpbuf[DIRED_MAXBUF];
    char *testpath = NULL;
a778 1
    tmpbuf[0] = '\0';
d780 3
a782 1
		     tmpbuf, sizeof(tmpbuf)) != NULL) {
d784 3
a786 3
	if (!no_dotfiles && show_dotfiles) {
	    bad_chars = "~/";
	}
d788 5
a792 5
	if (strstr(tmpbuf, "//") != NULL) {
	    HTAlert(gettext("Illegal redirection \"//\" found! Request ignored."));
	} else if (strlen(tmpbuf) && strchr(bad_chars, tmpbuf[0]) == NULL) {
	    StrAllocCopy(testpath, current_location);
	    LYAddPathSep(&testpath);
d794 4
a797 4
	    /*
	     *  Append the target filename to the current location.
	     */
	    StrAllocCat(testpath, tmpbuf);
d799 11
a809 7
	    /*
	     *  Make sure the target does not already exist
	     */
	    if (not_already_exists(testpath)) {
		code = touch_file(testpath);
	    }
	    FREE(testpath);
d818 2
a819 2
PRIVATE int create_directory ARGS1(
	char *,		current_location)
d822 3
a824 2
    char tmpbuf[DIRED_MAXBUF];
    char *testpath = NULL;
a826 1
    tmpbuf[0] = '\0';
d828 3
a830 1
		     tmpbuf, sizeof(tmpbuf)) != NULL) {
d832 3
a834 3
	if (!no_dotfiles && show_dotfiles) {
	    bad_chars = "~/";
	}
d836 5
a840 5
	if (strstr(tmpbuf, "//") != NULL) {
	    HTAlert(gettext("Illegal redirection \"//\" found! Request ignored."));
	} else if (strlen(tmpbuf) && strchr(bad_chars, tmpbuf[0]) == NULL) {
	    StrAllocCopy(testpath, current_location);
	    LYAddPathSep(&testpath);
d842 1
a842 1
	    StrAllocCat(testpath, tmpbuf);
d844 11
a854 7
	    /*
	     *  Make sure the target does not already exist.
	     */
	    if (not_already_exists(testpath)) {
		code = make_directory(testpath);
	    }
	    FREE(testpath);
d863 2
a864 2
PUBLIC int local_create ARGS1(
	DocInfo *,	doc)
d866 1
a866 1
    int ans;
d868 5
a872 1
    char testpath[DIRED_MAXBUF];
a874 4
    if (strlen(cp) >= DIRED_MAXBUF) {
	FREE(cp);
	return 0;
    }
a877 3
    _statusline(gettext("Create file or directory (f or d): "));
    ans = LYgetch_single();

d890 2
a891 2
PRIVATE int remove_single ARGS1(
	char *,		testpath)
d897 1
d906 1
a906 1
    if ((cp = LYLastPathSep(testpath)) != NULL) {
d916 1
a916 1
		       gettext("Remove '%s' and all of its contents?"), cp);
d919 1
a919 1
		       gettext("Remove directory and all of its contents?"));
d923 1
a923 1
	    HTSprintf0(&tmpbuf, gettext("Remove file '%s'?"), cp);
d925 1
a925 1
	    HTSprintf0(&tmpbuf, gettext("Remove file?"));
d930 1
a930 1
	    HTSprintf0(&tmpbuf, gettext("Remove symbolic link '%s'?"), cp);
d932 1
a932 1
	    HTSprintf0(&tmpbuf, gettext("Remove symbolic link?"));
d942 6
a947 1
	code = remove_file(testpath);
d956 2
a957 2
PUBLIC int local_remove ARGS1(
	DocInfo *,	doc)
d960 1
a960 1
    char testpath[DIRED_MAXBUF];
a975 4
	if (strlen(tp) >= DIRED_MAXBUF) {
	    FREE(tp);
	    return 0;
	}
d992 20
a1014 15
PRIVATE long permit_bits ARGS1(char *, string_mode)
{
    if (!strcmp(string_mode, "IRUSR")) return S_IRUSR;
    if (!strcmp(string_mode, "IWUSR")) return S_IWUSR;
    if (!strcmp(string_mode, "IXUSR")) return S_IXUSR;
    if (!strcmp(string_mode, "IRGRP")) return S_IRGRP;
    if (!strcmp(string_mode, "IWGRP")) return S_IWGRP;
    if (!strcmp(string_mode, "IXGRP")) return S_IXGRP;
    if (!strcmp(string_mode, "IROTH")) return S_IROTH;
    if (!strcmp(string_mode, "IWOTH")) return S_IWOTH;
    if (!strcmp(string_mode, "IXOTH")) return S_IXOTH;
    /* Don't include setuid and friends; use shell access for that. */
    return 0;
}

d1018 3
a1020 3
PRIVATE int permit_location ARGS3(
	char *,		destpath,
	char *,		srcpath,
d1029 1
a1031 1
    CONST char *program;
d1038 1
d1042 3
a1044 1
	srcpath = strip_trailing_slash(srcpath);
d1049 1
a1049 1
	if (!ok_lstat(srcpath, &dir_info)
d1053 1
a1053 1
	user_filename = LYPathLeaf(srcpath);
d1065 1
a1065 1
	LYRegisterUIPage(*newpath, UIP_PERMIT_OPTIONS);
d1069 1
a1069 1
		  srcpath,
d1079 2
a1080 2
	    fprintf(fp0, "<Form Action=\"%s//PERMIT_LOCATION%s\">\n",
		    STR_LYNXDIRED, srcpath_url);
d1146 2
d1159 1
a1159 1
	    CTRACE((tfp, "permit_location: called for <%s>.\n",
d1161 1
a1161 1
			 destpath : "NULL URL pointer")));
d1174 1
a1174 2
	/* Will now operate only on filename part. */
	if ((destpath = HTURLPath_toFile(destpath, TRUE, FALSE)) == 0)
d1176 2
a1177 5
	if (strlen(destpath) >= LY_MAXPATH) {
	    FREE(destpath);
	    return(0);
	}
	strcpy(tmpdst, destpath);
d1190 2
a1191 2
	    CTRACE((tfp, "permit_location: called for file '%s'.\n",
			destpath));
d1217 1
a1217 1
		long mask = permit_bits(cp + 5);
d1219 14
a1232 10
		if (mask != 0) {
		    /*
		     *  If restricted, only change eXecute
		     *  permissions on directories.
		     */
		    if (!no_change_exec_perms
		     || strchr(cp+5, 'X') == NULL
		     || S_ISDIR(dir_info.st_mode))
			new_mode |= mask;
		} else {
d1244 1
d1248 7
a1254 15
	if ((program = HTGetProgramPath(ppCHMOD)) != NULL) {
	    char *args[5];
	    char amode[10];
	    char *tmpbuf = NULL;

	    HTSprintf0(&tmpbuf, "chmod %.4o %s", (unsigned int)new_mode, destpath);
	    sprintf(amode, "%.4o", (unsigned int)new_mode);
	    args[0] = "chmod";
	    args[1] = amode;
	    args[2] = destpath;
	    args[3] = (char *) 0;
	    if (LYExecv(program, args, tmpbuf) <= 0) {
		FREE(tmpbuf);
		return (-1);
	    }
d1256 1
a1256 3
	} else {
	    if (chmod(destpath, new_mode) < 0)
		return (-1);
d1258 2
d1275 1
a1275 1
	LYmove(links[cur].ly, 2);
d1278 1
a1278 1
	    LYaddch('+');
d1280 1
a1280 1
	    LYaddch(' ');
d1285 1
a1285 1
	    LYHideCursor(); /* get cursor out of the way */
d1291 1
a1291 1
	    LYmove(links[cur].ly, links[cur].lx);
d1293 1
a1293 1
	LYrefresh();
a1325 1

a1326 2
	CONST char *result1 = 0;

d1328 1
a1328 4
	if (!LYisRootPath(result))
	    LYTrimPathSep(result);
	result1 = wwwName(result);
	StrAllocCopy (result, result1);
a1332 1
#ifdef __DJGPP__
d1334 8
a1341 2
 * Convert filenames to acceptable 8+3 names when necessary.  Make a copy of
 * the parameter if we must modify it.
d1343 2
a1344 2
PRIVATE char * LYonedot ARGS1(
	char *,		line)
d1346 6
a1351 22
    char *dot;
    static char line1[LY_MAXPATH];

    if (pathconf (line, _PC_NAME_MAX) <= 12) {
	LYstrncpy(line1, line, sizeof(line1)-1);
	for (;;) {
	    if ((dot = strrchr(line1, '.')) == 0
	     || LYLastPathSep(dot) != 0) {
		break;
	    } else if (strlen(dot) == 1) {
		*dot = 0;
	    } else {
		*dot = '_';
	    }
	}
	return(line1);
    }
    return(line);
}
#else
#define LYonedot(path) path
#endif /*  __DJGPP__ */
d1353 70
a1422 12
PRIVATE char * match_op ARGS2(
	CONST char *,	prefix,
	char *,		data)
{
    int len = strlen(prefix);

    if (!strncmp("LYNXDIRED://", data, 12)
     && !strncmp(prefix, data + 12, (unsigned)len)) {
	len += 12;
#if defined(USE_DOS_DRIVES)
	if (data[len] == '/') {	/* this is normal */
	    len++;
a1423 5
#endif
	return data + len;
    }
    return 0;
}
d1425 5
a1429 14
/*
 *  Construct the appropriate system command taking care to
 *  escape all path references to avoid spoofing the shell.
 */
PRIVATE char *build_command ARGS3(
	char *,		line,
	char *,		dirname,
	char *,		arg)
{
    char *buffer = NULL;
    CONST char *program;
    CONST char *tar_path = HTGetProgramPath(ppTAR);

    if ((arg = match_op("DECOMPRESS", line)) != 0) {
d1431 2
a1432 3
	if ((program = HTGetProgramPath(ppUNCOMPRESS)) != NULL) {
	    HTAddParam(&buffer, FMT_UNCOMPRESS, 1, program);
	    HTAddParam(&buffer, FMT_UNCOMPRESS, 2, arg);
a1433 3
	}
	return buffer;
    }
d1436 1
a1436 1
    if ((arg = match_op("UUDECODE", line)) != 0) {
d1438 2
a1439 3
	if ((program = HTGetProgramPath(ppUUDECODE)) != NULL) {
	    HTAddParam(&buffer, FMT_UUDECODE, 1, program);
	    HTAddParam(&buffer, FMT_UUDECODE, 2, arg);
a1441 3
	}
	return buffer;
    }
a1444 1
    if (tar_path != NULL) {
d1447 8
a1454 12
	if ((arg = match_op("UNTAR_GZ", line)) != 0) {
#define FMT_UNTAR_GZ "cd %s; %s -qdc %s |  %s -xf -"
	    if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 1, dirname);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 2, program);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 3, arg);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 4, tar_path);
		HTEndParam(&buffer, FMT_UNTAR_GZ, 4);
	    }
	    return buffer;
	}
d1456 11
a1466 13
	if ((arg = match_op("UNTAR_Z", line)) != 0) {
#define FMT_UNTAR_Z "cd %s; %s %s |  %s -xf -"
	    if ((program = HTGetProgramPath(ppZCAT)) != NULL) {
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_UNTAR_Z, 1, dirname);
		HTAddParam(&buffer, FMT_UNTAR_Z, 2, program);
		HTAddParam(&buffer, FMT_UNTAR_Z, 3, arg);
		HTAddParam(&buffer, FMT_UNTAR_Z, 4, tar_path);
		HTEndParam(&buffer, FMT_UNTAR_Z, 4);
	    }
	    return buffer;
	}
	if ((arg = match_op("UNTAR", line)) != 0) {
d1468 1
a1468 1
	    dirname = DirectoryOf(arg);
d1470 2
a1471 2
	    HTAddParam(&buffer, FMT_UNTAR, 2, tar_path);
	    HTAddParam(&buffer, FMT_UNTAR, 3, arg);
a1472 2
	    return buffer;
	}
d1476 10
a1485 14
	if ((arg = match_op("TAR_GZ", line)) != 0) {
#define FMT_TAR_GZ "cd %s; %s -cf - %s | %s -qc >%s%s"
	    if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_TAR_GZ, 1, dirname);
		HTAddParam(&buffer, FMT_TAR_GZ, 2, tar_path);
		HTAddParam(&buffer, FMT_TAR_GZ, 3, LYPathLeaf(arg));
		HTAddParam(&buffer, FMT_TAR_GZ, 4, program);
		HTAddParam(&buffer, FMT_TAR_GZ, 5, LYonedot(LYPathLeaf(arg)));
		HTAddParam(&buffer, FMT_TAR_GZ, 6, EXT_TAR_GZ);
		HTEndParam(&buffer, FMT_TAR_GZ, 6);
	    }
	    return buffer;
	}
d1488 14
a1501 18
	if ((arg = match_op("TAR_Z", line)) != 0) {
#define FMT_TAR_Z "cd %s; %s -cf - %s | %s >%s%s"
	    if ((program = HTGetProgramPath(ppCOMPRESS)) != NULL) {
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_TAR_Z, 1, dirname);
		HTAddParam(&buffer, FMT_TAR_Z, 2, tar_path);
		HTAddParam(&buffer, FMT_TAR_Z, 3, LYPathLeaf(arg));
		HTAddParam(&buffer, FMT_TAR_Z, 4, program);
		HTAddParam(&buffer, FMT_TAR_Z, 5, LYonedot(LYPathLeaf(arg)));
		HTAddParam(&buffer, FMT_TAR_Z, 6, EXT_TAR_Z);
		HTEndParam(&buffer, FMT_TAR_Z, 6);
	    }
	    return buffer;
	}

	if ((arg = match_op("TAR", line)) != 0) {
#define FMT_TAR "cd %s; %s -cf %s.tar %s"
	    dirname = DirectoryOf(arg);
d1503 3
a1505 3
	    HTAddParam(&buffer, FMT_TAR, 2, tar_path);
	    HTAddParam(&buffer, FMT_TAR, 3, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_TAR, 4, LYPathLeaf(arg));
a1506 3
	    return buffer;
	}
    }
d1510 1
a1510 1
    if ((arg = match_op("GZIP", line)) != 0) {
d1512 2
a1513 3
	if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
	    HTAddParam(&buffer, FMT_GZIP, 1, program);
	    HTAddParam(&buffer, FMT_GZIP, 2, arg);
a1514 3
	}
	return buffer;
    }
d1516 1
a1516 1
    if ((arg = match_op("UNGZIP", line)) != 0) {
d1518 2
a1519 3
	if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
	    HTAddParam(&buffer, FMT_UNGZIP, 1, program);
	    HTAddParam(&buffer, FMT_UNGZIP, 2, arg);
a1520 3
	}
	return buffer;
    }
d1525 1
a1525 1
    if ((arg = match_op("ZIP", line)) != 0) {
d1527 1
a1527 2
	if ((program = HTGetProgramPath(ppZIP)) != NULL) {
	    dirname = DirectoryOf(arg);
d1529 3
a1531 3
	    HTAddParam(&buffer, FMT_ZIP, 2, program);
	    HTAddParam(&buffer, FMT_ZIP, 3, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_ZIP, 4, LYPathLeaf(arg));
d1533 2
a1534 5
	}
	return buffer;
    }
#if !defined(ARCHIVE_ONLY)
    if ((arg = match_op("UNZIP", line)) != 0) {
d1536 1
a1536 2
	if ((program = HTGetProgramPath(ppUNZIP)) != NULL) {
	    dirname = DirectoryOf(arg);
d1538 2
a1539 2
	    HTAddParam(&buffer, FMT_UNZIP, 2, program);
	    HTAddParam(&buffer, FMT_UNZIP, 3, arg);
a1540 3
	}
	return buffer;
    }
d1544 1
a1544 1
    if ((arg = match_op("COMPRESS", line)) != 0) {
d1546 2
a1547 3
	if ((program = HTGetProgramPath(ppCOMPRESS)) != NULL) {
	    HTAddParam(&buffer, FMT_COMPRESS, 1, program);
	    HTAddParam(&buffer, FMT_COMPRESS, 2, arg);
a1549 111
	return buffer;
    }

    return NULL;
}

/*
 *  Perform file management operations for LYNXDIRED URL's.
 *  Attempt to be consistent.  These are (pseudo) URLs - i.e., they should
 *  be in URL syntax: some bytes will be URL-escaped with '%'.	This is
 *  necessary because these (pseudo) URLs will go through some of the same
 *  kinds of interpretations and mutilations as real ones: HTParse, stripping
 *  off #fragments etc.  (Some access schemes currently have special rules
 *  about not escaping parsing '#' "the URL way" built into HTParse, but that
 *  doesn't look like a clean way.)
 */
PUBLIC int local_dired ARGS1(
	DocInfo *,	doc)
{
    char *line_url;    /* will point to doc's address, which is a URL */
    char *line = NULL; /* same as line_url, but HTUnEscaped, will be alloced */
    char *arg = NULL; /* ...will point into line[] */
    char *tp = NULL;
    char *tmpbuf = NULL;
    char *buffer = NULL;
    char *dirname = NULL;
    BOOL do_pop_doc = TRUE;

    line_url = doc->address;
    CTRACE((tfp, "local_dired: called for <%s>.\n",
		(line_url ?
		 line_url : gettext("NULL URL pointer"))));
    HTUnEscapeSome(line_url, "/");	/* don't mess too much with *doc */

    StrAllocCopy(line, line_url);
    HTUnEscape(line);	/* _file_ (not URL) syntax, for those functions
			   that need it.  Don't forget to FREE it. */
    if ((arg = match_op("CHDIR", line)) != 0) {
#ifdef SUPPORT_CHDIR
	handle_LYK_CHDIR();
	do_pop_doc = FALSE;
#endif
	arg = "blah";	/* do something to avoid cc's complaints */
    } else if ((arg = match_op("NEW_FILE", line)) != 0) {
	if (create_file(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("NEW_FOLDER", line)) != 0) {
	if (create_directory(arg) > 0)
	    LYforce_no_cache = TRUE;
#ifdef OK_INSTALL
    } else if ((arg = match_op("INSTALL_SRC", line)) != 0) {
	local_install(NULL, arg, &tp);
	if (tp) {
	    FREE(doc->address);
	    doc->address = tp;
	}
	FREE(line);
	return 0;
    } else if ((arg = match_op("INSTALL_DEST", line)) != 0) {
	local_install(arg, NULL, &tp);
	LYpop(doc);
#endif /* OK_INSTALL */
    } else if ((arg = match_op("MODIFY_NAME", line)) != 0) {
	if (modify_name(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("MODIFY_LOCATION", line)) != 0) {
	if (modify_location(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("MOVE_TAGGED", line_url)) != 0) {
	if (modify_tagged(arg) > 0)
	    LYforce_no_cache = TRUE;
#ifdef OK_PERMIT
    } else if ((arg = match_op("PERMIT_SRC", line)) != 0) {
	permit_location(NULL, arg, &tp);
	if (tp) {
	    /*
	     *	One of the checks may have failed.
	     */
	    FREE(doc->address);
	    doc->address = tp;
	}
	FREE(line);
	return 0;
    } else if ((arg = match_op("PERMIT_LOCATION", line_url)) != 0) {
	permit_location(arg, NULL, &tp);
#endif /* OK_PERMIT */
    } else if ((arg = match_op("REMOVE_SINGLE", line)) != 0) {
	if (remove_single(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("REMOVE_TAGGED", line)) != 0) {
	if (remove_tagged())
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("CLEAR_TAGGED", line)) != 0) {
	clear_tags();
    } else if ((arg = match_op("UPLOAD", line)) != 0) {
	/*
	 *  They're written by LYUpload_options() HTUnEscaped;
	 *  don't want to change that for now... so pass through
	 *  without more unescaping.  Directory names containing
	 *  '#' will probably fail.
	 */
	if (LYUpload(line_url))
	    LYforce_no_cache = TRUE;
    } else {
	LYTrimPathSep(line);
	if (LYLastPathSep(line) == NULL) {
	    FREE(line);
	    return 0;
	}

	buffer = build_command(line, dirname, arg);
d1552 1
a1552 1
	    if ((int) strlen(buffer) < LYcols - 15) {
d1560 1
a1560 1
	    printf("%s\r\n", tmpbuf);
d1575 1
a1575 2
    if (do_pop_doc)
	LYpop(doc);
d1583 1
a1583 1
	DocInfo *,	doc,
d1587 2
a1588 3
    char *path;
    char *dir;
    lynx_list_item_type *nxt;
d1591 1
d1599 3
a1601 1
    if ((fp0 = InternalPageFP(tempfile, FALSE)) == 0)
d1603 1
d1609 6
a1614 1
    LYRegisterUIPage(*newfile, UIP_DIRED_MENU);
d1617 2
a1618 1
	path = HTfullURL_toFile(links[doc->link].lname);
d1620 1
a1623 1
	    FREE(path);
d1628 1
a1628 1
	StrAllocCopy(path, "");
d1631 1
a1631 4
    dir = HTfullURL_toFile(doc->address);
    LYTrimPathSep(dir);

    nothing_tagged = (BOOL) (HTList_isEmpty(tagged));
a1718 1
    FREE(path);
a1729 1
    FREE(dir);
d1743 3
a1745 3
	char *,		prompt,
	char *,		buf,
	size_t,		bufsize)
d1751 1
d1759 1
a1759 1
	cp = LYLastPathSep(buf); /* find last slash */
a1771 68
#ifdef OK_INSTALL

#define LYEXECV_MAX_ARGC 15
/* these are quasi-constant once they have been allocated: */
static char ** install_argp = NULL;	/* args for execv install */
static char * install_path = NULL;	/* auxiliary */
#ifdef LY_FIND_LEAKS
PRIVATE void clear_install_path NOARGS
{
    FREE(install_argp);
    FREE(install_path);
}
#endif /* LY_FIND_LEAKS */

/*
 *  Fill in args array for execv (or execvp etc.) call, after first
 *  allocating it if necessary.  No fancy parsing, cmd_args is just
 *  split at spaces.  Leave room for reserve additional args to be
 *  added by caller.
 *  On success *argvp points to new args vector, *pathp is auxiliary.
 *  On success returns index of next argument, else -1.
 *  This is generic enough that it could be used for other calls than
 *  install, except the atexit call.  Go through this trouble for install
 *  because INSTALL_ARGS may be significant, and someone may configure it
 *  with more than one significant flags. - kw
 */
PRIVATE int fill_argv_for_execv ARGS5(
    char ***,		argvp,
    char **,		pathp,
    char *,		cmd_path,
    CONST char *,	cmd_args,
    int,		reserve)
{
    int n = 0;

    char **args;
    char *cp;
    if (*argvp == NULL) {
	*argvp = typecallocn(char *, LYEXECV_MAX_ARGC+1);
	if (!*argvp)
	    return(-1);
#ifdef LY_FIND_LEAKS
	atexit(clear_install_path);
#endif
    }
    args = *argvp;
    args[n++] = cmd_path;
    if (cmd_args) {
	StrAllocCopy(*pathp, cmd_args);
	cp = strtok(*pathp, " ");
	if (cp) {
	    while (cp && (n < LYEXECV_MAX_ARGC - reserve)) {
		args[n++] = cp;
		cp = strtok(NULL, " ");
	    }
	    if (cp && (n >= LYEXECV_MAX_ARGC - reserve)) {
		CTRACE((tfp, "Too many args for '%s' in '%s'!\n",
		       NONNULL(cmd_path), cmd_args));
		return(-1);
	    }
	} else {
	    args[n++] = *pathp;
	}
    }
    args[n] = (char *)0;
    return(n);
}

d1776 2
a1777 2
	char *,		destpath,
	char *,		srcpath,
d1781 1
a1781 2
    static char savepath[DIRED_MAXBUF]; /* This will be the link that
					   is to be installed. */
d1783 1
a1783 1
    char **args;
a1784 2
    char *cp = NULL;
    char *tmpdest = NULL;
d1786 1
a1786 8
    int n = 0;		/* indices into 'args[]' */
    static int src = -1;
    CONST char *program;

    if ((program = HTGetProgramPath(ppINSTALL)) == NULL) {
	HTAlert(gettext("Install in the selected directory not permitted."));
	return 0;
    }
d1792 1
a1792 12
	srcpath = strip_trailing_slash(srcpath);
	if (is_url(srcpath)) {
	    char *local_src = HTfullURL_toFile(srcpath);
	    if (!ok_localname(savepath, local_src)) {
		FREE(local_src);
		return 0;
	    }
	    FREE(local_src);
	} else if (!HTList_isEmpty(tagged) &&
		   srcpath[0] == '\0') {
	    savepath[0] = '\0';	/* will always use tagged list - kw */
	} else if (!ok_localname(savepath, srcpath)) {
d1794 1
a1794 1
	}
d1797 1
a1797 3
	LYAddHtmlSep(newpath);
	StrAllocCat(*newpath, INSTALLDIRS_FILE);
	LYRegisterUIPage(*newpath, UIP_INSTALL);
a1800 18
    /* deal with ~/ or /~/ at the beginning - kw */
    if (destpath[0] == '~' &&
	(destpath[1] == '/' || destpath[1] == '\0')) {
	cp = &destpath[1];
    } else if (destpath[0] == '/' && destpath[1] == '~' &&
	       (destpath[2] == '/' || destpath[2] == '\0')) {
	cp = &destpath[2];
    }
    if (cp) {
	/* If found, allocate new string, make destpath point to it - kw */
	StrAllocCopy(tmpdest, Home_Dir());
	if (cp[0] && cp[1]) {
	    LYAddPathSep(&tmpdest);
	    StrAllocCat(tmpdest, cp + 1);
	}
	destpath = tmpdest;
    }

a1803 1
	FREE(tmpdest);
a1806 1
	FREE(tmpdest);
a1809 1
	FREE(tmpdest);
d1814 1
a1814 8

    /* fill in the fixed args, if not already done - kw */
    if (src > 0 && install_argp) {
	n = src;
	n++;
    } else {
	n = fill_argv_for_execv(&install_argp, &install_path,
				"install",
d1816 1
a1816 3
				INSTALL_ARGS,
#else
				NULL,
d1818 1
a1818 11
				2);
	if (n <= 0) {
	    src = 0;
	    HTAlert(gettext("Error buiding install args"));
	    FREE(tmpdest);
	    return 0;
	}
	src = n++;
    }
    args = install_argp;

d1821 1
a1824 14
	/* simplistic detection of identical src and dest - kw */
	if (!strcmp(savepath, destpath)) {
	    HTUserMsg2(gettext("Source and target are the same: %s"),
		       savepath);
	    FREE(tmpdest);
	    return(-1);		/* don't do it */
	} else if (!strncmp(savepath, destpath, strlen(destpath)) &&
		   LYIsPathSep(savepath[strlen(destpath)]) &&
		   LYLastPathSep(savepath + strlen(destpath) + 1) == 0) {
	    HTUserMsg2(gettext("Already in target directory: %s"),
		       savepath);
	    FREE(tmpdest);
	    return 0;		/* don't do it */
	}
d1826 1
a1826 4
	HTSprintf0(&tmpbuf, "install %s in %s", savepath, destpath);
	if (LYExecv(program, args, tmpbuf) <= 0) {
	    FREE(tmpbuf);
	    FREE(tmpdest);
a1827 1
	}
a1830 1
	HTSprintf0(&tmpbuf, "install in %s", destpath);
d1834 1
a1834 16

	    /* simplistic detection of identical src and dest - kw */
	    if (!strcmp(args[src], destpath)) {
		HTUserMsg2(gettext("Source and target are the same: %s"),
			   args[src]);
		FREE(args[src]);
		continue;	/* skip this source file */
	    } else if (!strncmp(args[src], destpath, strlen(destpath)) &&
		       LYIsPathSep(args[src][strlen(destpath)]) &&
		       LYLastPathSep(args[src] + strlen(destpath) + 1) == 0) {
		HTUserMsg2(gettext("Already in target directory: %s"),
			   args[src]);
		FREE(args[src]);
		continue;	/* skip this source file */
	    }
	    err = (LYExecv(program, args, tmpbuf) <= 0);
d1836 1
a1836 3
	    if (err) {
		FREE(tmpbuf);
		FREE(tmpdest);
a1837 1
	    }
a1842 1
    FREE(tmpdest);
a1845 1
#endif /* OK_INSTALL */
d1865 1
a1865 1
	char *,		str)
d1877 1
a1877 1
    new = typecalloc(struct dired_menu);
a1891 1
#ifdef S_IFLNK
a1893 1
#endif /* S_IFLNK */
a1923 16
PUBLIC void reset_dired_menu NOARGS
{
    if (menu_head != defmenu) {
	struct dired_menu *mp, *mp_next = NULL;
	for (mp = menu_head; mp != NULL; mp = mp_next) {
	    FREE(mp->sfx);
	    FREE(mp->link);
	    FREE(mp->rest);
	    FREE(mp->href);
	    mp_next = mp_next;
	    FREE(mp);
	}
	menu_head = NULL;
    }
}

d1928 4
a1931 4
	CONST char *,	s,
	CONST char *,	path,
	CONST char *,	dir,
	char *,		buf,
d1935 1
a1935 1
    CONST char *cp;
d1965 1
a1965 1
		    cp = LYLastPathSep(path);
d1999 1
a1999 1
		    *BP_INC = *s;
d2013 2
a2014 1
	HTAlert(gettext("Temporary URL or list would be too long."));
d2020 29
d2050 56
a2105 1
#endif /* DIRED_SUPPORT */
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d460 1
a460 1
	args[1] = "-f";
a471 21
PRIVATE int remove_directory ARGS1(char *, path)
{
    int code;
    CONST char *program;

    if ((program = HTGetProgramPath(ppRMDIR)) != NULL) {
	char *args[5];
	char *tmpbuf = NULL;

	args[0] = "rmdir";
	args[1] = path;
	args[2] = (char *) 0;
	HTSprintf0(&tmpbuf, gettext("remove %s"), path);
	code = LYExecv(program, args, tmpbuf);
	FREE(tmpbuf);
    } else {
	code = rmdir(path) ? -1 : 1;
    }
    return (code);
}

a1127 1
    BOOL is_directory = FALSE;
a1150 1
	is_directory = TRUE;
d1172 1
a1172 3
	code = is_directory
	     ? remove_directory(testpath)
	     : remove_file(testpath);
@


1.1.3.3
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@a112 1

d1168 1
a1168 1
		       gettext("Remove directory '%s'?"), cp);
d1171 1
a1171 1
		       gettext("Remove directory?"));
d1527 1
a1527 1
	lynx_stop_reverse();
d1681 1
a1681 1
#define FMT_UNTAR_GZ "cd %s; %s -qdc %s |  %s %s %s"
d1688 1
a1688 3
		HTAddToCmd(&buffer, FMT_UNTAR_GZ, 5, TAR_DOWN_OPTIONS);
		HTAddToCmd(&buffer, FMT_UNTAR_GZ, 6, TAR_PIPE_OPTIONS);
		HTEndParam(&buffer, FMT_UNTAR_GZ, 6);
d1694 1
a1694 1
#define FMT_UNTAR_Z "cd %s; %s %s |  %s %s %s"
d1701 1
a1701 3
		HTAddToCmd(&buffer, FMT_UNTAR_Z, 5, TAR_DOWN_OPTIONS);
		HTAddToCmd(&buffer, FMT_UNTAR_Z, 6, TAR_PIPE_OPTIONS);
		HTEndParam(&buffer, FMT_UNTAR_Z, 6);
d1706 1
a1706 1
#define FMT_UNTAR "cd %s; %s %s %s"
d1710 2
a1711 3
	    HTAddToCmd(&buffer, FMT_UNTAR, 3, TAR_DOWN_OPTIONS);
	    HTAddParam(&buffer, FMT_UNTAR, 4, arg);
	    HTEndParam(&buffer, FMT_UNTAR, 4);
d1718 1
a1718 1
#define FMT_TAR_GZ "cd %s; %s %s %s %s | %s -qc >%s%s"
d1723 5
a1727 7
		HTAddToCmd(&buffer, FMT_TAR_GZ, 3, TAR_UP_OPTIONS);
		HTAddToCmd(&buffer, FMT_TAR_GZ, 4, TAR_PIPE_OPTIONS);
		HTAddParam(&buffer, FMT_TAR_GZ, 5, LYPathLeaf(arg));
		HTAddParam(&buffer, FMT_TAR_GZ, 6, program);
		HTAddParam(&buffer, FMT_TAR_GZ, 7, LYonedot(LYPathLeaf(arg)));
		HTAddParam(&buffer, FMT_TAR_GZ, 8, EXT_TAR_GZ);
		HTEndParam(&buffer, FMT_TAR_GZ, 8);
d1734 1
a1734 1
#define FMT_TAR_Z "cd %s; %s %s %s %s | %s >%s%s"
d1739 5
a1743 7
		HTAddToCmd(&buffer, FMT_TAR_Z, 3, TAR_UP_OPTIONS);
		HTAddToCmd(&buffer, FMT_TAR_Z, 4, TAR_PIPE_OPTIONS);
		HTAddParam(&buffer, FMT_TAR_Z, 5, LYPathLeaf(arg));
		HTAddParam(&buffer, FMT_TAR_Z, 6, program);
		HTAddParam(&buffer, FMT_TAR_Z, 7, LYonedot(LYPathLeaf(arg)));
		HTAddParam(&buffer, FMT_TAR_Z, 8, EXT_TAR_Z);
		HTEndParam(&buffer, FMT_TAR_Z, 8);
d1749 1
a1749 1
#define FMT_TAR "cd %s; %s %s %s %s.tar %s"
d1753 3
a1755 5
	    HTAddToCmd(&buffer, FMT_TAR, 3, TAR_UP_OPTIONS);
	    HTAddToCmd(&buffer, FMT_TAR, 4, TAR_FILE_OPTIONS);
	    HTAddParam(&buffer, FMT_TAR, 5, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_TAR, 6, LYPathLeaf(arg));
	    HTEndParam(&buffer, FMT_TAR, 6);
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d80 1
a80 1
static char *get_filename (
d83 1
a83 1
	size_t		bufsize);
d86 1
a86 1
static int permit_location (
d89 1
a89 1
	char **		newpath);
d92 4
a95 4
static char *render_item (
	const char *	s,
	const char *	path,
	const char *	dir,
d98 1
a98 1
	BOOLEAN		url_syntax);
d100 1
a100 1
static struct dired_menu *menu_head = NULL;
d265 1
a265 1
static BOOLEAN cannot_stat (const char * name)
d276 1
a276 1
static BOOLEAN ok_stat (const char * name, struct stat* sb)
d286 1
a286 1
static BOOLEAN ok_lstat (char * name, struct stat* sb)
d298 1
a298 1
static BOOLEAN ok_file_or_dir (struct stat* sb)
d309 1
a309 1
static BOOLEAN ok_localname (char* dst, const char* src)
d329 4
a332 4
static int LYExecv (
	const char *	path,
	char **	argv,
	char *		msg)
d426 1
a426 1
static int make_directory (char * path)
d429 1
a429 1
    const char *program;
d451 1
a451 1
static int remove_file (char * path)
d454 1
a454 1
    const char *program;
d473 1
a473 1
static int remove_directory (char * path)
d476 1
a476 1
    const char *program;
d494 1
a494 1
static int touch_file (char * path)
d497 1
a497 1
    const char *program;
d521 1
a521 1
static int move_file (char * source, char * target)
d524 1
a524 1
    const char *program;
d559 1
a559 1
static BOOLEAN not_already_exists (char * name)
d579 1
a579 1
static BOOLEAN dir_has_same_owner (struct stat * info, int owner)
d596 1
a596 1
static int remove_tagged (void)
d652 2
a653 2
static int modify_tagged (
	char *		testpath)
d808 2
a809 2
static int modify_name (
	char *		testpath)
d864 2
a865 2
static int modify_location (
	char *		testpath)
d959 3
a961 3
int local_modify (
	DocInfo *	doc,
	char **	newpath)
d1032 2
a1033 2
static int create_file (
	char *		current_location)
d1074 2
a1075 2
static int create_directory (
	char *		current_location)
d1113 2
a1114 2
int local_create (
	DocInfo *	doc)
d1143 2
a1144 2
static int remove_single (
	char *		testpath)
d1207 2
a1208 2
int local_remove (
	DocInfo *	doc)
d1248 1
a1248 1
static char LYValidPermitFile[LY_MAXPATH] = "\0";
d1250 1
a1250 1
static long permit_bits (char * string_mode)
d1268 4
a1271 4
static int permit_location (
	char *		destpath,
	char *		srcpath,
	char **	newpath)
d1281 1
a1281 1
    const char *program;
d1522 3
a1524 3
void tagflag (
	int		flag,
	int		cur)
d1552 2
a1553 2
void showtags (
	HTList *	t)
d1570 2
a1571 2
static char * DirectoryOf (
	char *		pathname)
d1580 1
a1580 1
	const char *result1 = 0;
d1596 2
a1597 2
static char * LYonedot (
	char *		line)
d1622 3
a1624 3
static char * match_op (
	const char *	prefix,
	char *		data)
d1645 4
a1648 4
static char *build_command (
	char *		line,
	char *		dirname,
	char *		arg)
d1651 2
a1652 2
    const char *program;
    const char *tar_path = HTGetProgramPath(ppTAR);
d1847 2
a1848 2
int local_dired (
	DocInfo *	doc)
d1975 3
a1977 3
int dired_options (
	DocInfo *	doc,
	char **	newfile)
d2131 4
a2134 4
static char *get_filename (
	char *		prompt,
	char *		buf,
	size_t		bufsize)
d2167 1
a2167 1
static void clear_install_path (void)
d2186 6
a2191 6
static int fill_argv_for_execv (
    char ***		argvp,
    char **		pathp,
    char *		cmd_path,
    const char *	cmd_args,
    int		reserve)
d2231 4
a2234 4
BOOLEAN local_install (
	char *		destpath,
	char *		srcpath,
	char **	newpath)
d2247 1
a2247 1
    const char *program;
d2407 1
a2407 1
void clear_tags (void)
d2421 2
a2422 2
void add_menu_item (
	char *		str)
d2483 1
a2483 1
void reset_dired_menu (void)
d2502 7
a2508 7
static char * render_item (
	const char *	s,
	const char *	path,
	const char *	dir,
	char *		buf,
	int		bufsize,
	BOOLEAN	url_syntax)
d2510 1
a2510 1
    const char *cp;
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 28
a29 28
 *  Routines to manipulate the local filesystem.
 *  Written by: Rick Mallett, Carleton University
 *  Report problems to rmallett@@ccs.carleton.ca
 *  Modified 18-Dec-95 David Trueman (david@@cs.dal.ca):
 *	Added OK_PERMIT compilation option.
 *	Support replacement of compiled-in f)ull menu configuration via
 *	  DIRED_MENU definitions in lynx.cfg, so that more than one menu
 *	  can be driven by the same executable.
 *  Modified Oct-96 Klaus Weide (kweide@@tezcat.com):
 *	Changed to use the library's HTList_* functions and macros for
 *	  managing the list of tagged file URLs.
 *	Keep track of proper level of URL escaping, so that unusual filenames
 *	  which contain #% etc. are handled properly (some HTUnEscapeSome()'s
 *	  left in to be conservative, and to document where superfluous
 *	  unescaping took place before).
 *	Dynamic memory instead of fixed length buffers in a few cases.
 *	Other minor changes to make things work as intended.
 *  Modified Jun-97 Klaus Weide (kweide@@tezcat.com) & FM:
 *	Modified the code handling DIRED_MENU to do more careful
 *	  checking of the selected file.  In addition to "TAG", "FILE", and
 *	  "DIR", DIRED_MENU definitions in lynx.cfg now also recognize LINK as
 *	  a type.  DIRED_MENU definitions with a type field of "LINK" are only
 *	  used if the current selection is a symbolic link ("FILE" and "DIR"
 *	  definitions are not used in that case).  The default menu
 *	  definitions have been updated to reflect this change, and to avoid
 *	  the showing of menu items whose action would always fail - KW
 *	Cast all code into the Lynx programming style. - FM
 */
d80 4
a83 3
static char *get_filename(char *prompt,
			  char *buf,
			  size_t bufsize);
d86 4
a89 3
static int permit_location(char *destpath,
			   char *srcpath,
			   char **newpath);
d91 3
a93 2
/* *INDENT-OFF* */
static char *render_item ( const char *	s,
d115 4
a118 4
 * The following initializations determine the contents of the f)ull menu
 * selection when in dired mode.  If any menu entries are defined in the
 * configuration file via DIRED_MENU lines, then these default entries are
 * discarded entirely.
a263 1
/* *INDENT-ON* */
d265 1
a265 1
static BOOLEAN cannot_stat(const char *name)
a267 1

d276 1
a276 1
static BOOLEAN ok_stat(const char *name, struct stat *sb)
d286 1
a286 1
static BOOLEAN ok_lstat(char *name, struct stat *sb)
d298 1
a298 1
static BOOLEAN ok_file_or_dir(struct stat *sb)
d301 1
a301 1
	&& !S_ISREG(sb->st_mode)) {
d309 1
a309 1
static BOOLEAN ok_localname(char *dst, const char *src)
d314 1
a314 1
	|| !ok_file_or_dir(&dir_info)) {
d327 1
a327 1
 * Execute DIRED command, return -1 or 0 on failure, 1 success.
d329 4
a332 3
static int LYExecv(const char *path,
		   char **argv,
		   char *msg)
a334 1

a339 1

a348 1

a350 1

d361 1
a361 1
    rc = 1;			/* It will work */
d363 1
a363 1
    pid = fork();		/* fork and execute command */
d366 4
a369 4
    case -1:
	HTSprintf0(&tmpbuf, gettext("Unable to %s due to system error!"), msg);
	rc = 0;
	break;			/* don't fall thru! - KW */
d371 1
a371 1
    case 0:			/* child */
d373 1
a373 1
	execvp(path, argv);	/* this uses our $PATH */
d375 1
a375 1
	execv(path, argv);
d377 2
a378 2
	exit(EXIT_FAILURE);	/* execv failed, give wait() something to look at */
	/*NOTREACHED */
d380 1
a380 1
    default:			/* parent */
d382 2
a383 1
	while (wait(&wstatus) != pid) ;		/* do nothing */
d385 1
a385 1
	while (-1 == waitpid(pid, &wstatus, 0)) {	/* wait for child */
d387 2
a388 2
	    if (errno == EINTR)
		continue;
d391 2
a392 2
	    if (errno == ERESTARTSYS)
		continue;
d394 2
a395 2
	    break;
	}
d397 8
a404 9
	if ((WIFEXITED(wstatus)
	     && (WEXITSTATUS(wstatus) != 0))
	    || (WIFSIGNALED(wstatus)
		&& (WTERMSIG(wstatus) > 0))) {	/* error return */
	    HTSprintf0(&tmpbuf,
		       gettext("Probable failure to %s due to system error!"),
		       msg);
	    rc = 0;
	}
d410 2
a411 2
	 * Screen may have message from the failed execv'd command.  Give user
	 * time to look at it before screen refresh.
d421 1
d423 1
a423 1
    return (rc);
d426 1
a426 1
static int make_directory(char *path)
d435 1
a435 1
	HTSprintf0(&msg, "make directory %s", path);
d451 1
a451 1
static int remove_file(char *path)
d473 1
a473 1
static int remove_directory(char *path)
d494 1
a494 1
static int touch_file(char *path)
a510 1

d521 1
a521 1
static int move_file(char *source, char *target)
a539 1

d542 1
a542 1
	    && S_ISDIR(sb.st_mode)) {
d559 1
a559 1
static BOOLEAN not_already_exists(char *name)
d579 1
a579 1
static BOOLEAN dir_has_same_owner(struct stat *info, int owner)
d594 1
a594 1
 * Remove all tagged files and directories.
d596 1
a596 1
static int remove_tagged(void)
d607 1
a607 1
    if (HTList_isEmpty(tagged))	/* should never happen */
d614 2
a615 2
    while (ans == YES && (cp = (char *) HTList_nextObject(tag)) != NULL) {
	if (is_url(cp) == FILE_URL_TYPE) {	/* unnecessary check */
d621 1
a621 1
	     * Check the current status of the path to be deleted.
d628 1
a628 2
		    if (count == 0)
			count = -1;
d645 6
a650 5
 * Move all tagged files and directories to a new location.  Input is current
 * directory.  The tests in this function can, at best, prevent some user
 * mistakes - anybody who relies on them for security is seriously misguided. 
 * If a user has enough permissions to move a file somewhere, the same uid with
 * Lynx & dired can do the same thing.
d652 2
a653 1
static int modify_tagged(char *testpath)
d666 1
a666 1
    if (HTList_isEmpty(tagged))	/* should never happen */
d674 3
d678 2
a679 5
	 * Determine the ownership of the current location.
	 */
	/*
	 * This test used to always fail from the dired menu...  changed to
	 * something that hopefully makes more sense - KW
d681 1
a681 1
	if (testpath && *testpath && 0 != strcmp(testpath, "/")) {
d683 2
a684 2
	     * testpath passed in and is not empty and not a single "/" (which
	     * would probably be bogus) - use it.
d689 1
a689 1
	     * Prepare to get directory path from one of the tagged files.
d698 1
a698 1
	     * Get the directory containing the file or subdir.
d702 1
a702 1
		cp = HTParse(".", cp, PARSE_PATH + PARSE_PUNCTUATION);
d705 1
a705 1
	    } else {		/* Last resort, should never happen. */
d723 2
a724 2
	 * Save the owner of the current location for later use.  Also save the
	 * device and inode for location checking/
d731 1
a731 1
	 * Replace ~/ references to the home directory.
a734 1

d743 1
a743 1
	    LYstrncpy(tmpbuf, cp1, sizeof(tmpbuf) - 1);
d748 1
a748 1
	 * If path is relative, prefix it with current location.
d752 1
a752 1
	    StrAllocCat(savepath, tmpbuf);
d754 1
a754 1
	    StrAllocCopy(savepath, tmpbuf);
d758 1
a758 1
	 * stat() the target location to determine type and ownership.
d766 1
a766 1
	 * Make sure the source and target locations are not the same place.
d775 2
a776 2
	 * Make sure the target location is a directory which is owned by the
	 * same uid as the owner of the current location.
d783 1
a783 1
	     * Move all tagged items to the target location.
d785 1
a785 1
	    while ((cp = (char *) HTList_nextObject(tag)) != NULL) {
d806 1
a806 1
 * Modify the name of the specified item.
d808 2
a809 1
static int modify_name(char *testpath)
d818 1
a818 1
     * Determine the status of the selected item.
d824 1
a824 1
	 * Change the name of the file or directory.
d827 1
a827 1
	    cp = gettext("Enter new name for directory: ");
d829 1
a829 1
	    cp = gettext("Enter new name for file: ");
d831 1
a831 1
	    return ok_file_or_dir(&dir_info);
d833 1
a833 1
	LYstrncpy(tmpbuf, LYPathLeaf(testpath), sizeof(tmpbuf) - 1);
d838 1
a838 1
	 * Do not allow the user to also change the location at this time.
d844 1
a844 2
		HTSprintf0(&newpath, "%.*s%s",
			   (cp - testpath + 1), testpath, tmpbuf);
d849 1
a849 1
	     * Make sure the destination does not already exist.
d862 1
a862 1
 * Change the location of a file or directory.
d864 2
a865 1
static int modify_location(char *testpath)
d878 1
a878 1
     * Determine the status of the selected item.
d886 1
a886 1
     * Change the location of the file or directory.
d900 1
a900 1
    LYstrncpy(tmpbuf, testpath, sizeof(tmpbuf) - 1);
d909 1
a909 1
	 * Allow ~/ references to the home directory.
d912 1
a912 1
	    || !strcmp(tmpbuf, "~")) {
d915 1
a915 1
	    LYstrncpy(tmpbuf, newpath, sizeof(tmpbuf) - 1);
d930 1
a930 1
	 * Make sure the source and target have the same owner (uid).
d940 1
a940 1
	 * Make sure the source and target are not the same location.
d948 1
a948 1
	    code = move_file(savepath, newpath);
d957 1
a957 1
 * Modify name or location of a file or directory on localhost.
d959 3
a961 1
int local_modify(DocInfo *doc, char **newpath)
d965 1
a965 1
    char testpath[DIRED_MAXBUF];	/* a bit ridiculous */
d974 2
a975 2
	if (doc->link > (nlinks - count - 1))
	    doc->link = (nlinks - count - 1);
d977 1
a977 1
	    0 : doc->link;
d982 1
a982 1
	 * Added protection.
d988 2
a989 2
     * Do not allow simultaneous change of name and location as in Unix.  This
     * reduces functionality but reduces difficulty for the novice.
d1004 1
a1004 1
	LYstrncpy(testpath, cp, sizeof(testpath) - 1);
d1008 1
a1008 1
	    return (modify_name(testpath));
d1011 1
a1011 1
		if (doc->link == (nlinks - 1))
d1017 1
a1017 1
	    return (permit_location(NULL, testpath, newpath));
d1021 1
a1021 1
	     * Code for changing ownership needed here.
d1030 1
a1030 1
 * Create a new empty file in the current directory.
d1032 2
a1033 1
static int create_file(char *current_location)
d1055 1
a1055 1
	     * Append the target filename to the current location.
d1060 1
a1060 1
	     * Make sure the target does not already exist
d1072 1
a1072 1
 * Create a new directory in the current directory.
d1074 2
a1075 1
static int create_directory(char *current_location)
d1099 1
a1099 1
	     * Make sure the target does not already exist.
d1111 1
a1111 1
 * Create a file or a directory at the current location.
d1113 2
a1114 1
int local_create(DocInfo *doc)
d1125 1
a1125 1
    strcpy(testpath, cp);
d1132 1
a1132 1
	return (create_file(testpath));
d1134 1
a1134 1
	return (create_directory(testpath));
d1141 1
a1141 1
 * Remove a single file or directory.
d1143 2
a1144 1
static int remove_single(char *testpath)
d1157 1
a1157 1
     * Locate the filename portion of the path.
d1165 2
a1166 4
	/*
	 * This strlen stuff will probably screw up intl translations.  Course,
	 * it's probably broken for screen sizes other 80, too -jes
	 */
d1197 2
a1198 2
	    ? remove_directory(testpath)
	    : remove_file(testpath);
d1205 1
a1205 1
 * Remove a file or a directory.
d1207 2
a1208 1
int local_remove(DocInfo *doc)
d1216 2
a1217 2
	if (doc->link > (nlinks - count - 1))
	    doc->link = (nlinks - count - 1);
d1219 1
a1219 1
	    0 : doc->link;
d1250 1
a1250 1
static long permit_bits(char *string_mode)
d1252 9
a1260 18
    if (!strcmp(string_mode, "IRUSR"))
	return S_IRUSR;
    if (!strcmp(string_mode, "IWUSR"))
	return S_IWUSR;
    if (!strcmp(string_mode, "IXUSR"))
	return S_IXUSR;
    if (!strcmp(string_mode, "IRGRP"))
	return S_IRGRP;
    if (!strcmp(string_mode, "IWGRP"))
	return S_IWGRP;
    if (!strcmp(string_mode, "IXGRP"))
	return S_IXGRP;
    if (!strcmp(string_mode, "IROTH"))
	return S_IROTH;
    if (!strcmp(string_mode, "IWOTH"))
	return S_IWOTH;
    if (!strcmp(string_mode, "IXOTH"))
	return S_IXOTH;
d1266 1
a1266 1
 * Handle DIRED permissions.
d1268 4
a1271 3
static int permit_location(char *destpath,
			   char *srcpath,
			   char **newpath)
d1275 1
a1275 1
    return (0);
d1285 1
a1285 1
	 * Create form.
d1288 2
a1289 2
	char *user_filename;
	char *group_name;
d1294 1
a1294 1
	 * A couple of sanity tests.
d1297 1
a1297 1
	    || !ok_file_or_dir(&dir_info))
d1305 1
a1305 1
	    return (0);
d1314 1
a1314 1
	group_name = HTAA_GidToName(dir_info.st_gid);
d1321 3
a1323 4
	fprintf(fp0, "<H1>%s%s</H1>\n", PERMISSIONS_SEGMENT, user_filename);
	{
	    /*
	     * Prevent filenames which include '#' or '?' from messing it up.
d1325 1
a1325 2
	    char *srcpath_url = HTEscape(srcpath, URL_PATH);

d1331 1
a1331 2
	fprintf(fp0, "<Ol><Li>%s<Br><Br>\n",
		gettext("Specify permissions below:"));
d1334 1
a1334 1
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRUSR\" %s> Read<Br>\n",
d1337 1
a1337 1
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWUSR\" %s> Write<Br>\n",
d1340 1
a1340 1
	 * If restricted, only change eXecute permissions on directories.
d1344 3
a1346 3
		    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXUSR\" %s> %s<Br>\n",
		    (dir_info.st_mode & S_IXUSR) ? "checked" : "",
		    S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");
d1350 1
a1350 1
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRGRP\" %s> Read<Br>\n",
d1353 1
a1353 1
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWGRP\" %s> Write<Br>\n",
d1356 1
a1356 1
	 * If restricted, only change eXecute permissions on directories.
d1360 3
a1362 3
		    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXGRP\" %s> %s<Br>\n",
		    (dir_info.st_mode & S_IXGRP) ? "checked" : "",
		    S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");
d1366 1
a1366 1
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IROTH\" %s> Read<Br>\n",
d1369 1
a1369 1
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWOTH\" %s> Write<Br>\n",
d1372 1
a1372 1
	 * If restricted, only change eXecute permissions on directories.
d1376 3
a1378 3
		    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXOTH\" %s> %s<Br>\n",
		    (dir_info.st_mode & S_IXOTH) ? "checked" : "",
		    S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");
d1380 2
a1381 2
	fprintf(fp0,
		"<Br>\n<Li><Input Type=\"submit\" Value=\"Submit\">  %s %s %s.\n</Ol>\n</Form>\n",
d1389 1
a1389 1
	return (PERMIT_FORM_RESULT);	/* Special flag for LYMainLoop */
d1391 1
a1391 1
    } else {			/* The form being activated. */
d1395 3
a1397 2
	 * Make sure we have a valid set-permission file comparison string
	 * loaded via a previous call with srcpath != NULL.  - KW
d1405 2
a1406 2
		    (destpath ?
		     destpath : "NULL URL pointer")));
d1410 1
a1410 1
	while (*cp != '\0' && *cp != '?') {	/* Find filename */
d1414 1
a1414 1
	    return (0);		/* Nothing to permit. */
d1416 2
a1417 2
	*cp++ = '\0';		/* Null terminate file name and
				   start working on the masks. */
d1421 1
a1421 1
	    return (0);
d1424 1
a1424 1
	    return (0);
d1431 2
a1432 2
	 * Make sure that the file string is the one from the last displayed
	 * File Permissions menu.  - KW
d1440 1
a1440 1
		    destpath));
d1445 1
a1445 1
	 * A couple of sanity tests.
d1449 1
a1449 1
	    || !ok_file_or_dir(&dir_info)) {
d1454 1
a1454 1
	 * Cycle over permission strings.
d1456 1
a1456 1
	while (*cp != '\0') {
d1459 1
a1459 1
	    while (*cr != '\0' && *cr != '&') {		/* GET data split by '&'. */
d1465 1
a1465 1
	    if (strncmp(cp, "mode=", 5) == 0) {		/* Magic string. */
d1470 2
a1471 2
		     * If restricted, only change eXecute permissions on
		     * directories.
d1474 2
a1475 2
			|| strchr(cp + 5, 'X') == NULL
			|| S_ISDIR(dir_info.st_mode))
d1490 1
a1490 1
	 * Call chmod().
d1497 2
a1498 2
	    HTSprintf0(&tmpbuf, "chmod %.4o %s", (unsigned int) new_mode, destpath);
	    sprintf(amode, "%.4o", (unsigned int) new_mode);
d1520 1
a1520 1
 * Display or remove a tag from a given link.
d1522 3
a1524 2
void tagflag(int flag,
	     int cur)
d1537 1
a1537 1
	    LYHideCursor();	/* get cursor out of the way */
d1541 1
a1541 1
	     * Never hide the cursor if there's no FANCY CURSES.
d1550 1
a1550 1
 * Handle DIRED tags.
d1552 2
a1553 1
void showtags(HTList *t)
d1570 2
a1571 1
static char *DirectoryOf(char *pathname)
d1586 1
a1586 1
	StrAllocCopy(result, result1);
d1596 2
a1597 1
static char *LYonedot(char *line)
d1602 2
a1603 2
    if (pathconf(line, _PC_NAME_MAX) <= 12) {
	LYstrncpy(line1, line, sizeof(line1) - 1);
d1606 1
a1606 1
		|| LYLastPathSep(dot) != 0) {
d1614 1
a1614 1
	return (line1);
d1616 1
a1616 1
    return (line);
d1622 3
a1624 2
static char *match_op(const char *prefix,
		      char *data)
d1629 1
a1629 1
	&& !strncmp(prefix, data + 12, (unsigned) len)) {
d1642 2
a1643 2
 * Construct the appropriate system command taking care to escape all path
 * references to avoid spoofing the shell.
d1645 4
a1648 3
static char *build_command(char *line,
			   char *dirname,
			   char *arg)
d1663 1
d1695 1
a1695 1
#  endif			/* OK_GZIP */
d1720 1
a1720 1
# endif				/* !ARCHIVE_ONLY */
d1739 1
a1739 1
# endif				/* OK_GZIP */
d1821 1
a1821 1
# endif				/* !ARCHIVE_ONLY */
d1838 15
a1852 13
 * Perform file management operations for LYNXDIRED URL's.  Attempt to be
 * consistent.  These are (pseudo) URLs - i.e., they should be in URL syntax: 
 * some bytes will be URL-escaped with '%'.  This is necessary because these
 * (pseudo) URLs will go through some of the same kinds of interpretations and
 * mutilations as real ones:  HTParse, stripping off #fragments etc.  (Some
 * access schemes currently have special rules about not escaping parsing '#'
 * "the URL way" built into HTParse, but that doesn't look like a clean way.)
 */
int local_dired(DocInfo *doc)
{
    char *line_url;		/* will point to doc's address, which is a URL */
    char *line = NULL;		/* same as line_url, but HTUnEscaped, will be alloced */
    char *arg = NULL;		/* ...will point into line[] */
d1861 2
a1862 3
	    (line_url
	     ? line_url
	     : gettext("NULL URL pointer"))));
d1866 2
a1867 2
    HTUnEscape(line);		/* _file_ (not URL) syntax, for those functions
				   that need it.  Don't forget to FREE it. */
d1873 1
a1873 1
	arg = "blah";		/* do something to avoid cc's complaints */
d1907 1
a1907 1
	     * One of the checks may have failed.
d1927 4
a1930 3
	 * They're written by LYUpload_options() HTUnEscaped; don't want to
	 * change that for now...  so pass through without more unescaping. 
	 * Directory names containing '#' will probably fail.
d1973 1
a1973 1
 * Provide a menu of file management options.
d1975 3
a1977 1
int dired_options(DocInfo *doc, char **newfile)
d1993 1
a1993 1
	return (0);
d1996 1
a1996 1
     * Make the tempfile a URL.
d2001 1
a2001 1
    if (doc->link > -1 && doc->link < (nlinks + 1)) {
d2033 3
a2035 2
	 * Write out number of tagged items, and names of first few of them
	 * relative to current (in the DIRED sense) directory.
a2040 1

d2044 1
a2044 3
		n, ((n == 1)
		    ? gettext("tagged item:")
		    : gettext("tagged items:")));
d2050 1
a2050 1
	    cp1 = HTRelative(HTList_objectAt(tagged, i - 1),
d2053 1
a2053 1
	    LYEntify(&cp1, TRUE);	/* _should_ do this everywhere... */
d2055 1
a2055 1
		    (i == 1 ? "" : " ,"), cp1);
d2059 1
a2059 1
	    fprintf(fp0, " , ...");
d2066 1
a2066 1
     * If menu_head is NULL then use defaults and link them together now.
d2095 1
a2095 1
	dir_url = HTEscape(dir, URL_PATH);
d2098 1
a2098 1
		render_item(mp->href, path_url, dir_url, buf, sizeof(buf), YES));
d2100 1
a2100 1
		render_item(mp->link, path, dir, buf, sizeof(buf), NO));
d2102 1
a2102 1
		render_item(mp->rest, path, dir, buf, sizeof(buf), NO));
d2114 1
a2114 1
		    "<a href=\"LYNXDIRED://UPLOAD=%d/TO=%s\"> %s </a><br>\n",
d2125 1
a2125 1
    return (0);
d2129 1
a2129 1
 * Check DIRED filename.
d2131 4
a2134 3
static char *get_filename(char *prompt,
			  char *buf,
			  size_t bufsize)
d2147 1
a2147 1
	cp = LYLastPathSep(buf);	/* find last slash */
d2164 2
a2165 3
static char **install_argp = NULL;	/* args for execv install */
static char *install_path = NULL;	/* auxiliary */

d2167 1
a2167 1
static void clear_install_path(void)
d2175 17
a2191 15
 * Fill in args array for execv (or execvp etc.) call, after first allocating
 * it if necessary.  No fancy parsing, cmd_args is just split at spaces.  Leave
 * room for reserve additional args to be added by caller.
 *
 * On success *argvp points to new args vector, *pathp is auxiliary.  On
 * success returns index of next argument, else -1.  This is generic enough
 * that it could be used for other calls than install, except the atexit call. 
 * Go through this trouble for install because INSTALL_ARGS may be significant,
 * and someone may configure it with more than one significant flags.  - kw
 */
static int fill_argv_for_execv(char ***argvp,
			       char **pathp,
			       char *cmd_path,
			       const char *cmd_args,
			       int reserve)
a2196 1

d2198 1
a2198 2
	*argvp = typecallocn(char *, LYEXECV_MAX_ARGC + 1);

d2200 1
a2200 1
	    return (-1);
d2217 2
a2218 2
			NONNULL(cmd_path), cmd_args));
		return (-1);
d2224 2
a2225 2
    args[n] = (char *) 0;
    return (n);
d2229 1
a2229 1
 * Install the specified file or directory.
d2231 4
a2234 3
BOOLEAN local_install(char *destpath,
		      char *srcpath,
		      char **newpath)
d2237 2
a2238 3
    static char savepath[DIRED_MAXBUF];		/* This will be the link that

						   is to be installed. */
d2245 1
a2245 1
    int n = 0;			/* indices into 'args[]' */
d2255 1
a2255 1
     * Determine the status of the selected item.
a2260 1

d2307 1
a2307 1
    } else if (0 /*directory not writable */ ) {
d2339 1
a2339 1
    args[n] = (char *) 0;
d2348 1
a2348 1
	    return (-1);	/* don't do it */
a2366 1

d2368 1
a2368 1
	while ((name = (char *) HTList_nextObject(tag))) {
a2369 1

d2405 1
a2405 1
 * Clear DIRED tags.
d2407 1
a2407 1
void clear_tags(void)
d2419 1
a2419 1
 * Handle DIRED menu item.
d2421 2
a2422 1
void add_menu_item(char *str)
d2428 2
a2429 1
     * First custom menu definition causes entire default menu to be discarded.
a2434 1

d2439 1
a2439 1
     * Conditional on tagged != NULL ?
d2456 1
a2456 1
     * Conditional on matching suffix.
d2476 2
a2477 1
	for (mp = menu_head; mp && mp->next != NULL; mp = mp->next) ;
d2483 1
a2483 1
void reset_dired_menu(void)
a2486 1

d2500 1
a2500 1
 * Create URL for DIRED HREF value.
d2502 7
a2508 6
static char *render_item(const char *s,
			 const char *path,
			 const char *dir,
			 char *buf,
			 int bufsize,
			 BOOLEAN url_syntax)
a2513 1

d2515 2
a2516 2
    /* Buffer overrun could happen for very long
       tag list, if %l or %t are used */
d2522 4
a2525 22
	    case '%':
		*BP_INC = '%';
		break;
	    case 'p':
		cp = path;
		if (!LYIsHtmlSep(*cp))
		    *BP_INC = '/';
		while (*cp)
		    *BP_INC = *cp++;
		break;
	    case 'd':
		cp = dir;
		if (!LYIsHtmlSep(*cp))
		    *BP_INC = '/';
		while (*cp)
		    *BP_INC = *cp++;
		break;
	    case 'f':
		cp = LYLastPathSep(path);
		if (cp)
		    cp++;
		else
d2527 18
a2544 22
		while (*cp)
		    *BP_INC = *cp++;
		break;
	    case 'l':
	    case 't':
		if (!HTList_isEmpty(tagged)) {
		    HTList *cur = tagged;
		    char *name;

		    while (!overrun &&
			   (name = (char *) HTList_nextObject(cur)) != NULL) {
			if (*s == 'l' && (cp = strrchr(name, '/')))
			    cp++;
			else
			    cp = name;
			StrAllocCat(taglist, cp);
			StrAllocCat(taglist, " ");	/* should this be %20? */
		    }
		}
		if (taglist) {
		    /* could HTUnescape here... */
		    cp = taglist;
d2547 29
a2575 7
		    FREE(taglist);
		}
		break;
	    default:
		*BP_INC = '%';
		*BP_INC = *s;
		break;
d2579 3
a2581 2
	     * Other chars come from the lynx.cfg or the default.  Let's assume
	     * there isn't anything weird there that needs escaping.
d2583 1
a2583 1
	    *BP_INC = *s;
d2589 1
a2589 1
	bp = buf;		/* set to start, will return empty string as URL */
@


1.1.3.6
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d1942 1
a1942 1
	    if ((int) strlen(buffer) < LYcolLimit - 14) {
d2329 1
a2329 1
	    HTAlert(gettext("Error building install args"));
@


1.1.3.7
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d683 1
a683 1
	if (non_empty(testpath) && 0 != strcmp(testpath, "/")) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a45 1
#include <www_wait.h>
d47 4
a50 2
#ifdef SUPPORT_CHDIR
#include <LYMainLoop.h>
d52 2
d55 7
a61 1
#include <LYLeaks.h>
d63 7
a69 1
#undef USE_COMPRESS
d71 1
a71 9
#ifdef __DJGPP__
#define EXT_TAR_GZ ".tgz"
#define EXT_TAR_Z  ".taz"
#define EXT_Z      ".z"
#else
#define EXT_TAR_GZ ".tar.gz"
#define EXT_TAR_Z  ".tar.Z"
#define EXT_Z      ".Z"
#endif
d73 4
a76 3
#ifndef DIRED_MAXBUF
#define DIRED_MAXBUF 512
#endif
d79 2
a80 8

#ifdef OK_INSTALL
#ifdef FNAMES_8_3
#define INSTALLDIRS_FILE "instdirs.htm"
#else
#define INSTALLDIRS_FILE ".installdirs.html"
#endif /* FNAMES_8_3 */
#endif /* OK_INSTALL */
d88 1
a88 1
PRIVATE int permit_location PARAMS((
d91 1
a91 1
	char **		newpath));
d96 2
a97 2
	CONST char *	path,
	CONST char *	dir,
d100 1
a100 1
	BOOLEAN		url_syntax));
a120 4
#ifdef SUPPORT_CHDIR
{ 0,		      "", "Change directory",
		      "", "LYNXDIRED://CHDIR",			NULL },
#endif
a126 1
#ifdef OK_INSTALL
d128 1
a128 6
"selected file to new location", "LYNXDIRED://INSTALL_SRC%p",	NULL },
/* The following (installing a directory) doesn't work for me, at least
   with the "install" from GNU fileutils 4.0.  I leave it in anyway, in
   case one compiles with INSTALL_PATH / INSTALL_ARGS defined to some
   other command for which it works (like a script, or maybe "cp -a"). - kw
*/
d130 1
a130 2
"selected directory to new location", "LYNXDIRED://INSTALL_SRC%p",	NULL },
#endif /* OK_INSTALL */
a135 1
#ifdef S_IFLNK
a137 1
#endif  /* S_IFLNK */
a149 1
#ifdef S_IFLNK
a151 1
#endif /* S_IFLNK */
a156 1
#ifdef S_IFLNK
a158 1
#endif /* S_IFLNK */
d166 1
a166 1
{ DE_FILE,	EXT_TAR_Z, "Expand",
d179 1
a179 1
{ DE_FILE,	   EXT_Z, "Uncompress",
a207 5
#if defined(OK_TAR) && defined(USE_COMPRESS)
{ DE_DIR,	      "", "Tar and compress",
      "(using compress)", "LYNXDIRED://TAR_Z%p",		NULL },
#endif /* OK_TAR && USE_COMPRESS */

d218 1
a218 1
	  "(using gzip)", "LYNXDIRED://GZIP%p",			NULL },
a228 5
#ifdef OK_INSTALL
{ DE_TAG,	      "", "Install tagged files into another directory.",
		      "", "LYNXDIRED://INSTALL_SRC%00",		NULL },
#endif

d236 1
a236 1
		    NULL, NULL,					NULL }
d239 1
a239 1
PRIVATE BOOLEAN cannot_stat ARGS1(CONST char *, name)
d242 1
a242 1
    HTSprintf0(&tmpbuf, gettext("Unable to get status of '%s'."), name);
d248 1
a248 3
#define OK_STAT(name, sb) (stat(name, sb) == 0)

PRIVATE BOOLEAN ok_stat ARGS2(CONST char *, name, struct stat*, sb)
d250 2
a251 2
    CTRACE((tfp, "testing ok_stat(%s)\n", name));
    if (!OK_STAT(name, sb)) {
d260 1
a260 1
    CTRACE((tfp, "testing ok_lstat(%s)\n", name));
d280 1
a280 2
#ifdef OK_INSTALL		/* currently only used in local_install */
PRIVATE BOOLEAN ok_localname ARGS2(char*, dst, CONST char*, src)
d282 1
d285 1
a285 1
    if (!ok_stat(src, &dir_info)
d287 1
d290 2
a291 5
    if (strlen(src) >= DIRED_MAXBUF) {
	CTRACE((tfp, "filename too long in ok_localname!\n"));
	return FALSE;
    }
    strcpy(dst, src);
a293 98
#endif /* OK_INSTALL */

/*
 *  Execute DIRED command, return -1 or 0 on failure, 1 success.
 */
PRIVATE int LYExecv ARGS3(
	char *,		path,
	char **,	argv,
	char *,		msg)
{
    int rc = 0;
#if defined(VMS)
    CTRACE((tfp, "LYExecv:  Called inappropriately!\n"));
#else
#if defined(_WINDOWS)
    if (!strcmp(path, TOUCH_PATH)) {
#if defined(__BORLANDC__) || defined(__MINGW32__)
	int fd = _creat(argv[1], S_IREAD | S_IWRITE);
#else /* Visual C++ */
	int fd = _creat(argv[1], _S_IREAD | _S_IWRITE);
#endif
	if (fd >= 0) {
	    close(fd);
	    return(1);
	}
    } else if (!strcmp(path, RM_PATH)) {
	rc = remove(argv[2]);
    } else {
	CTRACE((tfp, "LYExecv:  Called inappropriately! (path=%s)\n", path));
    }
#else
    int n;
    char *tmpbuf = 0;
#ifdef __DJGPP__
    stop_curses();
    HTSprintf0(&tmpbuf, "%s", path);
    for (n = 1; argv[n] != 0; n++)
	HTSprintf(&tmpbuf, " %s", argv[n]);
    HTSprintf(&tmpbuf, "\n");
    rc = LYSystem(tmpbuf) ? 0 : 1;
#else
    pid_t pid;
#ifdef HAVE_TYPE_UNIONWAIT
    union wait wstatus;
#else
    int wstatus;
#endif

    if (TRACE) {
	CTRACE((tfp, "LYExecv path='%s'\n", path));
	for (n = 0; argv[n] != 0; n++)
	    CTRACE((tfp, "argv[%d] = '%s'\n", n, argv[n]));
    }

    rc = 1;		/* It will work */
    stop_curses();
    pid = fork();	/* fork and execute command */

    switch (pid) {
	case -1:
	    HTSprintf0(&tmpbuf, gettext("Unable to %s due to system error!"), msg);
	    rc = 0;
	    break;	/* don't fall thru! - KW */

	case 0:  /* child */
#ifdef USE_EXECVP
	    execvp(path, argv);	/* this uses our $PATH */
#else
	    execv(path, argv);
#endif
	    exit(EXIT_FAILURE);	/* execv failed, give wait() something to look at */
	    /*NOTREACHED*/

	default:  /* parent */
#if !HAVE_WAITPID
	    while (wait(&wstatus) != pid)
		; /* do nothing */
#else
	    while (-1 == waitpid(pid, &wstatus, 0)) { /* wait for child */
#ifdef EINTR
		if (errno == EINTR)
		    continue;
#endif /* EINTR */
#ifdef ERESTARTSYS
		if (errno == ERESTARTSYS)
		    continue;
#endif /* ERESTARTSYS */
		break;
	    }
#endif /* !HAVE_WAITPID */
	    if (WEXITSTATUS(wstatus) != 0 ||
		WTERMSIG(wstatus) > 0)	{ /* error return */
		HTSprintf0(&tmpbuf, gettext("Probable failure to %s due to system error!"),
				   msg);
		rc = 0;
	    }
    }
#endif /* __DJGPP__ */
a294 18
    if (rc == 0) {
	/*
	 *  Screen may have message from the failed execv'd command.
	 *  Give user time to look at it before screen refresh.
	 */
	LYSleepAlert();
    }
    start_curses();
    if (tmpbuf != 0) {
	if (rc == 0)
	    HTAlert(tmpbuf);
	FREE(tmpbuf);
    }

#endif /* _WINDOWS */
#endif /* VMS */
    return(rc);
}
a297 7
#ifdef WIN_EX	/* 1999/01/02 (Sat) 23:24:20 */
    if ((code = rename(source, target)) != 0)
	if ((code = LYCopyFile(source, target)) >= 0)
	    code = remove(source);
    if (code == 0)
	code = 1;
#else
d301 1
a301 1
    HTSprintf0(&msg, gettext("move %s to %s"), source, target);
a307 1
#endif
d315 1
a315 1
    if (!OK_STAT(name, &dir_info)) {
d331 1
a331 1
PRIVATE BOOLEAN dir_has_same_owner ARGS2(struct stat *, info, int, owner)
d334 1
a334 1
	if ((int) info->st_uid == owner) {
d348 1
a348 1
PRIVATE int remove_tagged NOARGS
d363 1
a363 1
    ans = HTConfirm(gettext("Remove all tagged files and directories?"));
a390 1
		FREE(testpath);
d409 2
a410 2
PRIVATE int modify_tagged ARGS1(
	char *,		testpath)
d415 1
a415 1
    int owner;
d417 1
a417 1
    char *savepath;
d451 2
d459 2
a460 8
	    if (cp) {
		cp = strip_trailing_slash(cp);
		cp = HTParse(".", cp, PARSE_PATH+PARSE_PUNCTUATION);
		savepath = HTURLPath_toFile(cp, TRUE);
		FREE(cp);
	    } else {	/* Last resort, should never happen. */
		savepath = HTURLPath_toFile(".", TRUE);
	    }
d462 2
a463 6
	    if (!strncmp(cp, "file://localhost", 16)) {
		cp += 16;
	    } else if (!strncmp(cp, "file:", 5)) {
		cp += 5;
	    }
	    savepath = HTURLPath_toFile(cp, TRUE);
d465 1
d493 1
a493 1
	    LYstrncpy(tmpbuf, cp1, sizeof(tmpbuf)-1);
d536 2
a537 1
		srcpath = HTfullURL_toFile(cp);
d540 1
d545 1
a545 1
		FREE(srcpath);
d560 2
a561 2
PRIVATE int modify_name ARGS1(
	char *,		testpath)
d564 3
a566 2
    char tmpbuf[DIRED_MAXBUF];
    char *newpath = NULL;
a567 1
    int code = 0;
d591 8
a598 7
	if (LYLastPathSep(tmpbuf) != 0) {
	    HTAlert(gettext("Illegal character (path-separator) found! Request ignored."));
	} else if (strlen(tmpbuf)) {
	    if ((cp = LYLastPathSep(testpath)) != NULL)
		HTSprintf0(&newpath, "%.*s%s", (cp - testpath + 1), testpath, tmpbuf);
	    else
		StrAllocCopy(newpath, tmpbuf);
d604 1
a604 1
		code = move_file(testpath, newpath);
a605 2
	    FREE(newpath);

d608 1
a608 1
    return code;
d614 2
a615 2
PRIVATE int modify_location ARGS1(
	char *,		testpath)
d620 1
a620 1
    int owner;
d622 2
a623 2
    char *newpath = NULL;
    char *savepath = NULL;
a624 1
    int code = 0;
d648 2
a649 2
	StrAllocCopy(savepath, testpath);
	StrAllocCopy(newpath, testpath);
d656 12
a667 9
	    StrAllocCopy(newpath, Home_Dir());
	    StrAllocCat(newpath, (tmpbuf + 1));
	    LYstrncpy(tmpbuf, newpath, sizeof(tmpbuf)-1);
	}
	if (LYisAbsPath(tmpbuf)) {
	    StrAllocCopy(newpath, tmpbuf);
	} else if ((cp = LYLastPathSep(newpath)) != NULL) {
	    *++cp = '\0';
	    StrAllocCat(newpath, tmpbuf);
d669 1
a669 4
	    HTAlert(gettext("Unexpected failure - unable to find trailing path separator"));
	    FREE(newpath);
	    FREE(savepath);
	    return 0;
d679 1
a679 1
	    code = 0;
d685 1
a685 1
	else if (dev == dir_info.st_dev && inode == dir_info.st_ino) {
d687 4
a690 3
	    code = 0;
	} else if (dir_has_same_owner(&dir_info, owner)) {
	    code = move_file(savepath,newpath);
a691 2
	FREE(newpath);
	FREE(savepath);
d693 1
a693 1
    return code;
d699 1
a699 1
PUBLIC int local_modify ARGS2(
d703 1
a703 1
    int ans;
d705 1
a705 1
    char testpath[DIRED_MAXBUF]; /* a bit ridiculous */
d710 2
d713 1
a713 2
	count = modify_tagged(cp);
	FREE(cp);
d735 1
a735 1
    _statusline(gettext("Modify name or location (n or l): "));
d737 2
a738 1
    ans = LYgetch_single();
d742 1
a742 5
	if (strlen(cp) >= DIRED_MAXBUF) {
	    FREE(cp);
	    return 0;
	}
	LYstrncpy(testpath, cp, sizeof(testpath)-1);
d770 2
a771 2
PRIVATE int create_file ARGS1(
	char *,		current_location)
d774 2
a775 2
    char tmpbuf[DIRED_MAXBUF];
    char *testpath = NULL;
d780 3
a782 1
		     tmpbuf, sizeof(tmpbuf)) != NULL) {
d784 3
a786 3
	if (!no_dotfiles && show_dotfiles) {
	    bad_chars = "~/";
	}
d788 5
a792 5
	if (strstr(tmpbuf, "//") != NULL) {
	    HTAlert(gettext("Illegal redirection \"//\" found! Request ignored."));
	} else if (strlen(tmpbuf) && strchr(bad_chars, tmpbuf[0]) == NULL) {
	    StrAllocCopy(testpath, current_location);
	    LYAddPathSep(&testpath);
d794 4
a797 4
	    /*
	     *  Append the target filename to the current location.
	     */
	    StrAllocCat(testpath, tmpbuf);
d799 11
a809 13
	    /*
	     *  Make sure the target does not already exist
	     */
	    if (not_already_exists(testpath)) {
		char *msg = 0;
		HTSprintf0(&msg,gettext("create %s"),testpath);
		args[0] = "touch";
		args[1] = testpath;
		args[2] = (char *) 0;
		code = (LYExecv(TOUCH_PATH, args, msg) <= 0) ? -1 : 1;
		FREE(msg);
	    }
	    FREE(testpath);
d818 2
a819 2
PRIVATE int create_directory ARGS1(
	char *,		current_location)
d822 2
a823 2
    char tmpbuf[DIRED_MAXBUF];
    char *testpath = NULL;
d828 3
a830 1
		     tmpbuf, sizeof(tmpbuf)) != NULL) {
d832 3
a834 3
	if (!no_dotfiles && show_dotfiles) {
	    bad_chars = "~/";
	}
d836 5
a840 5
	if (strstr(tmpbuf, "//") != NULL) {
	    HTAlert(gettext("Illegal redirection \"//\" found! Request ignored."));
	} else if (strlen(tmpbuf) && strchr(bad_chars, tmpbuf[0]) == NULL) {
	    StrAllocCopy(testpath, current_location);
	    LYAddPathSep(&testpath);
d842 1
a842 1
	    StrAllocCat(testpath, tmpbuf);
d844 11
a854 13
	    /*
	     *  Make sure the target does not already exist.
	     */
	    if (not_already_exists(testpath)) {
		char *msg = 0;
		HTSprintf0(&msg,"make directory %s",testpath);
		args[0] = "mkdir";
		args[1] = testpath;
		args[2] = (char *) 0;
		code = (LYExecv(MKDIR_PATH, args, msg) <= 0) ? -1 : 1;
		FREE(msg);
	    }
	    FREE(testpath);
d863 1
a863 1
PUBLIC int local_create ARGS1(
d866 1
a866 1
    int ans;
d868 5
a872 1
    char testpath[DIRED_MAXBUF];
a874 4
    if (strlen(cp) >= DIRED_MAXBUF) {
	FREE(cp);
	return 0;
    }
a877 3
    _statusline(gettext("Create file or directory (f or d): "));
    ans = LYgetch_single();

d890 2
a891 2
PRIVATE int remove_single ARGS1(
	char *,		testpath)
d906 1
a906 1
    if ((cp = LYLastPathSep(testpath)) != NULL) {
d916 1
a916 1
		       gettext("Remove '%s' and all of its contents?"), cp);
d919 1
a919 1
		       gettext("Remove directory and all of its contents?"));
d923 1
a923 1
	    HTSprintf0(&tmpbuf, gettext("Remove file '%s'?"), cp);
d925 1
a925 1
	    HTSprintf0(&tmpbuf, gettext("Remove file?"));
d930 1
a930 1
	    HTSprintf0(&tmpbuf, gettext("Remove symbolic link '%s'?"), cp);
d932 1
a932 1
	    HTSprintf0(&tmpbuf, gettext("Remove symbolic link?"));
d956 1
a956 1
PUBLIC int local_remove ARGS1(
d960 1
a960 1
    char testpath[DIRED_MAXBUF];
a975 4
	if (strlen(tp) >= DIRED_MAXBUF) {
	    FREE(tp);
	    return 0;
	}
d992 20
a1014 15
PRIVATE long permit_bits ARGS1(char *, string_mode)
{
    if (!strcmp(string_mode, "IRUSR")) return S_IRUSR;
    if (!strcmp(string_mode, "IWUSR")) return S_IWUSR;
    if (!strcmp(string_mode, "IXUSR")) return S_IXUSR;
    if (!strcmp(string_mode, "IRGRP")) return S_IRGRP;
    if (!strcmp(string_mode, "IWGRP")) return S_IWGRP;
    if (!strcmp(string_mode, "IXGRP")) return S_IXGRP;
    if (!strcmp(string_mode, "IROTH")) return S_IROTH;
    if (!strcmp(string_mode, "IWOTH")) return S_IWOTH;
    if (!strcmp(string_mode, "IXOTH")) return S_IXOTH;
    /* Don't include setuid and friends; use shell access for that. */
    return 0;
}

d1018 3
a1020 3
PRIVATE int permit_location ARGS3(
	char *,		destpath,
	char *,		srcpath,
d1038 1
d1042 3
a1044 1
	srcpath = strip_trailing_slash(srcpath);
d1049 1
a1049 1
	if (!ok_lstat(srcpath, &dir_info)
d1053 1
a1053 1
	user_filename = LYPathLeaf(srcpath);
d1065 1
a1065 1
	LYRegisterUIPage(*newpath, UIP_PERMIT_OPTIONS);
d1069 1
a1069 1
		  srcpath,
d1159 1
a1159 1
	    CTRACE((tfp, "permit_location: called for <%s>.\n",
d1161 1
a1161 1
			 destpath : "NULL URL pointer")));
d1174 1
a1174 2
	/* Will now operate only on filename part. */
	if ((destpath = HTURLPath_toFile(destpath, TRUE)) == 0)
d1176 2
a1177 5
	if (strlen(destpath) >= LY_MAXPATH) {
	    FREE(destpath);
	    return(0);
	}
	strcpy(tmpdst, destpath);
d1190 2
a1191 2
	    CTRACE((tfp, "permit_location: called for file '%s'.\n",
			destpath));
d1217 1
a1217 1
		long mask = permit_bits(cp + 5);
d1219 14
a1232 10
		if (mask != 0) {
		    /*
		     *  If restricted, only change eXecute
		     *  permissions on directories.
		     */
		    if (!no_change_exec_perms
		     || strchr(cp+5, 'X') == NULL
		     || S_ISDIR(dir_info.st_mode))
			new_mode |= mask;
		} else {
d1248 1
a1248 1
	HTSprintf0(&tmpbuf, "chmod %.4o %s", (unsigned int)new_mode, destpath);
d1275 1
a1275 1
	LYmove(links[cur].ly, 2);
d1278 1
a1278 1
	    LYaddch('+');
d1280 1
a1280 1
	    LYaddch(' ');
d1285 1
a1285 1
	    LYHideCursor(); /* get cursor out of the way */
d1291 1
a1291 1
	    LYmove(links[cur].ly, links[cur].lx);
d1293 1
a1293 1
	LYrefresh();
a1321 1
    char *result1 = 0;
d1328 1
a1328 4
	if (!LYisRootPath(result))
	    LYTrimPathSep(result);
	result1 = wwwName(result);
	StrAllocCopy (result, result1);
a1332 50
#ifdef __DJGPP__
/*
 * Convert filenames to acceptable 8+3 names when necessary.  Make a copy of
 * the parameter if we must modify it.
 */
PRIVATE char * LYonedot ARGS1(
	char *,		line)
{
    char *dot;
    static char line1[LY_MAXPATH];

    if (pathconf (line, _PC_NAME_MAX) <= 12) {
	LYstrncpy(line1, line, sizeof(line1)-1);
	for (;;) {
	    if ((dot = strrchr(line1, '.')) == 0
	     || LYLastPathSep(dot) != 0) {
		break;
	    } else if (strlen(dot) == 1) {
		*dot = 0;
	    } else {
		*dot = '_';
	    }
	}
	return(line1);
    }
    return(line);
}
#else
#define LYonedot(path) path
#endif /*  __DJGPP__ */

PRIVATE char * match_op ARGS2(
	CONST char *,	prefix,
	char *,		data)
{
    int len = strlen(prefix);

    if (!strncmp("LYNXDIRED://", data, 12)
     && !strncmp(prefix, data + 12, (unsigned)len)) {
	len += 12;
#if defined(DOSPATH) || defined(__EMX__)
	if (data[len] == '/') {	/* this is normal */
	    len++;
	}
#endif
	return data + len;
    }
    return 0;
}

a1347 1
    char *arg = NULL; /* ...will point into line[] */
a1351 1
    BOOL do_pop_doc = TRUE;
d1354 1
a1354 1
    CTRACE((tfp, "local_dired: called for <%s>.\n",
d1356 1
a1356 1
		 line_url : gettext("NULL URL pointer"))));
d1362 3
a1364 8
    if ((arg = match_op("CHDIR", line)) != 0) {
#ifdef SUPPORT_CHDIR
	handle_LYK_CHDIR();
	do_pop_doc = FALSE;
#endif
	arg = "blah";	/* do something to avoid cc's complaints */
    } else if ((arg = match_op("NEW_FILE", line)) != 0) {
	if (create_file(arg) > 0)
d1366 2
a1367 2
    } else if ((arg = match_op("NEW_FOLDER", line)) != 0) {
	if (create_directory(arg) > 0)
d1369 4
a1372 7
#ifdef OK_INSTALL
    } else if ((arg = match_op("INSTALL_SRC", line)) != 0) {
	local_install(NULL, arg, &tp);
	if (tp) {
	    FREE(doc->address);
	    doc->address = tp;
	}
d1375 2
a1376 2
    } else if ((arg = match_op("INSTALL_DEST", line)) != 0) {
	local_install(arg, NULL, &tp);
d1378 5
a1382 6
#endif /* OK_INSTALL */
    } else if ((arg = match_op("MODIFY_NAME", line)) != 0) {
	if (modify_name(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("MODIFY_LOCATION", line)) != 0) {
	if (modify_location(arg) > 0)
d1384 2
a1385 2
    } else if ((arg = match_op("MOVE_TAGGED", line_url)) != 0) {
	if (modify_tagged(arg) > 0)
d1388 3
a1390 3
    } else if ((arg = match_op("PERMIT_SRC", line)) != 0) {
	permit_location(NULL, arg, &tp);
	if (tp) {
d1394 1
a1394 3
	    FREE(doc->address);
	    doc->address = tp;
	}
d1396 1
d1398 2
a1399 2
    } else if ((arg = match_op("PERMIT_LOCATION", line_url)) != 0) {
	permit_location(arg, NULL, &tp);
d1401 2
a1402 2
    } else if ((arg = match_op("REMOVE_SINGLE", line)) != 0) {
	if (remove_single(arg) > 0)
d1404 1
a1404 1
    } else if ((arg = match_op("REMOVE_TAGGED", line)) != 0) {
d1407 1
a1407 1
    } else if ((arg = match_op("CLEAR_TAGGED", line)) != 0) {
d1409 1
a1409 1
    } else if ((arg = match_op("UPLOAD", line)) != 0) {
d1420 1
a1420 1
	if (LYLastPathSep(line) == NULL) {
d1429 1
a1429 1
	if ((arg = match_op("DECOMPRESS", line)) != 0) {
d1432 1
a1432 1
	    HTAddParam(&buffer, FMT_UNCOMPRESS, 2, arg);
d1436 1
a1436 1
	} else if ((arg = match_op("UUDECODE", line)) != 0) {
d1439 1
a1439 1
	    HTAddParam(&buffer, FMT_UUDECODE, 2, arg);
d1447 6
a1452 6
	} else if ((arg = match_op("UNTAR_GZ", line)) != 0) {
#define FMT_UNTAR_GZ "cd %s; %s -qdc %s |  %s -xf -"
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_UNTAR_GZ, 1, dirname);
	    HTAddParam(&buffer, FMT_UNTAR_GZ, 2, GZIP_PATH);
	    HTAddParam(&buffer, FMT_UNTAR_GZ, 3, arg);
d1457 6
a1462 6
	} else if ((arg = match_op("UNTAR_Z", line)) != 0) {
#define FMT_UNTAR_Z "cd %s; %s %s |  %s -xf -"
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_UNTAR_Z, 1, dirname);
	    HTAddParam(&buffer, FMT_UNTAR_Z, 2, ZCAT_PATH);
	    HTAddParam(&buffer, FMT_UNTAR_Z, 3, arg);
d1466 1
a1466 1
	} else if ((arg = match_op("UNTAR", line)) != 0) {
d1468 1
a1468 1
	    dirname = DirectoryOf(arg);
d1471 1
a1471 1
	    HTAddParam(&buffer, FMT_UNTAR, 3, arg);
d1476 3
a1478 3
	} else if ((arg = match_op("TAR_GZ", line)) != 0) {
#define FMT_TAR_GZ "cd %s; %s -cf - %s | %s -qc >%s%s"
	    dirname = DirectoryOf(arg);
d1481 1
a1481 1
	    HTAddParam(&buffer, FMT_TAR_GZ, 3, LYPathLeaf(arg));
d1483 2
a1484 2
	    HTAddParam(&buffer, FMT_TAR_GZ, 5, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_TAR_GZ, 6, EXT_TAR_GZ);
d1488 3
a1490 3
	} else if ((arg = match_op("TAR_Z", line)) != 0) {
#define FMT_TAR_Z "cd %s; %s -cf - %s | %s >%s%s"
	    dirname = DirectoryOf(arg);
d1493 1
a1493 1
	    HTAddParam(&buffer, FMT_TAR_Z, 3, LYPathLeaf(arg));
d1495 2
a1496 2
	    HTAddParam(&buffer, FMT_TAR_Z, 5, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_TAR_Z, 6, EXT_TAR_Z);
d1499 3
a1501 3
	} else if ((arg = match_op("TAR", line)) != 0) {
#define FMT_TAR "cd %s; %s -cf %s.tar %s"
	    dirname = DirectoryOf(arg);
d1504 2
a1505 2
	    HTAddParam(&buffer, FMT_TAR, 3, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_TAR, 4, LYPathLeaf(arg));
d1510 1
a1510 1
	} else if ((arg = match_op("GZIP", line)) != 0) {
d1513 1
a1513 1
	    HTAddParam(&buffer, FMT_GZIP, 2, arg);
d1516 1
a1516 1
	} else if ((arg = match_op("UNGZIP", line)) != 0) {
d1519 1
a1519 1
	    HTAddParam(&buffer, FMT_UNGZIP, 2, arg);
d1525 1
a1525 1
	} else if ((arg = match_op("ZIP", line)) != 0) {
d1527 1
a1527 1
	    dirname = DirectoryOf(arg);
d1530 2
a1531 2
	    HTAddParam(&buffer, FMT_ZIP, 3, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_ZIP, 4, LYPathLeaf(arg));
d1534 1
a1534 1
	} else if ((arg = match_op("UNZIP", line)) != 0) {
d1536 1
a1536 1
	    dirname = DirectoryOf(arg);
d1539 1
a1539 1
	    HTAddParam(&buffer, FMT_UNZIP, 3, arg);
d1544 1
a1544 1
	} else if ((arg = match_op("COMPRESS", line)) != 0) {
d1547 1
a1547 1
	    HTAddParam(&buffer, FMT_COMPRESS, 2, arg);
d1552 1
a1552 1
	    if ((int) strlen(buffer) < LYcols - 15) {
d1560 1
a1560 1
	    printf("%s\r\n", tmpbuf);
d1575 1
a1575 2
    if (do_pop_doc)
	LYpop(doc);
d1587 2
a1588 3
    char *path;
    char *dir;
    lynx_list_item_type *nxt;
d1591 1
d1609 6
a1614 1
    LYRegisterUIPage(*newfile, UIP_DIRED_MENU);
d1617 2
a1618 1
	path = HTfullURL_toFile(links[doc->link].lname);
d1620 1
a1623 1
	    FREE(path);
d1628 1
a1628 1
	StrAllocCopy(path, "");
d1631 1
a1631 4
    dir = HTfullURL_toFile(doc->address);
    LYTrimPathSep(dir);

    nothing_tagged = (BOOL) (HTList_isEmpty(tagged));
a1718 1
    FREE(path);
a1729 1
    FREE(dir);
d1743 3
a1745 3
	char *,		prompt,
	char *,		buf,
	size_t,		bufsize)
d1759 1
a1759 1
	cp = LYLastPathSep(buf); /* find last slash */
a1771 66
#ifdef OK_INSTALL

#define LYEXECV_MAX_ARGC 15
/* these are quasi-constant once they have been allocated: */
static char ** install_argp = NULL;	/* args for execv install */
static char * install_path = NULL;	/* auxiliary */
#ifdef LY_FIND_LEAKS
PRIVATE void clear_install_path NOARGS
{
    FREE(install_argp);
    FREE(install_path);
}
#endif /* LY_FIND_LEAKS */
/*
 *  Fill in args array for execv (or execvp etc.) call, after first
 *  allocating it if necessary.  No fancy parsing, cmd_args is just
 *  split at spaces.  Leave room for reserve additional args to be
 *  added by caller.
 *  On success *argvp points to new args vector, *pathp is auxiliary.
 *  On success returns index of next argument, else -1.
 *  This is generic enough that it could be used for other calls than
 *  install, except the atexit call.  Go through this trouble for install
 *  because INSTALL_ARGS may be significant, and someone may configure it
 *  with more than one significant flags. - kw
 */
PRIVATE int fill_argv_for_execv ARGS5(
    char ***,		argvp,
    char **,		pathp,
    char *,		cmd_path,
    CONST char *,	cmd_args,
    int,		reserve)
{
    int n = 0;

    char **args;
    char *cp;
    if (*argvp == NULL) {
	*argvp = typecallocn(char *, LYEXECV_MAX_ARGC+1);
	if (!*argvp)
	    return(-1);
#ifdef LY_FIND_LEAKS
	atexit(clear_install_path);
#endif
    }
    args = *argvp;
    args[n++] = cmd_path;
    if (cmd_args) {
	StrAllocCopy(*pathp, cmd_args);
	cp = strtok(*pathp, " ");
	if (cp) {
	    while (cp && (n < LYEXECV_MAX_ARGC - reserve)) {
		args[n++] = cp;
		cp = strtok(NULL, " ");
	    }
	    if (cp && (n >= LYEXECV_MAX_ARGC - reserve)) {
		CTRACE((tfp, "Too many args for '%s' in '%s'!\n",
		       NONNULL(cmd_path), cmd_args));
		return(-1);
	    }
	} else {
	    args[n++] = *pathp;
	}
    }
    args[n] = (char *)0;
    return(n);
}
d1776 2
a1777 2
	char *,		destpath,
	char *,		srcpath,
d1781 1
a1781 2
    static char savepath[DIRED_MAXBUF]; /* This will be the link that
					   is to be installed. */
d1783 1
a1783 1
    char **args;
a1784 2
    char *cp = NULL;
    char *tmpdest = NULL;
d1786 1
a1786 2
    int n = 0;		/* indices into 'args[]' */
    static int src = -1;
d1792 1
a1792 12
	srcpath = strip_trailing_slash(srcpath);
	if (is_url(srcpath)) {
	    char *local_src = HTfullURL_toFile(srcpath);
	    if (!ok_localname(savepath, local_src)) {
		FREE(local_src);
		return 0;
	    }
	    FREE(local_src);
	} else if (!HTList_isEmpty(tagged) &&
		   srcpath[0] == '\0') {
	    savepath[0] = '\0';	/* will always use tagged list - kw */
	} else if (!ok_localname(savepath, srcpath)) {
d1794 1
a1794 1
	}
d1797 1
a1797 3
	LYAddHtmlSep(newpath);
	StrAllocCat(*newpath, INSTALLDIRS_FILE);
	LYRegisterUIPage(*newpath, UIP_INSTALL);
a1800 18
    /* deal with ~/ or /~/ at the beginning - kw */
    if (destpath[0] == '~' &&
	(destpath[1] == '/' || destpath[1] == '\0')) {
	cp = &destpath[1];
    } else if (destpath[0] == '/' && destpath[1] == '~' &&
	       (destpath[2] == '/' || destpath[2] == '\0')) {
	cp = &destpath[2];
    }
    if (cp) {
	/* If found, allocate new string, make destpath point to it - kw */
	StrAllocCopy(tmpdest, Home_Dir());
	if (cp[0] && cp[1]) {
	    LYAddPathSep(&tmpdest);
	    StrAllocCat(tmpdest, cp + 1);
	}
	destpath = tmpdest;
    }

a1803 1
	FREE(tmpdest);
a1806 1
	FREE(tmpdest);
a1809 1
	FREE(tmpdest);
d1814 1
a1814 8

    /* fill in the fixed args, if not already done - kw */
    if (src > 0 && install_argp) {
	n = src;
	n++;
    } else {
	n = fill_argv_for_execv(&install_argp, &install_path,
				"install",
d1816 1
a1816 3
				INSTALL_ARGS,
#else
				NULL,
d1818 1
a1818 11
				2);
	if (n <= 0) {
	    src = 0;
	    HTAlert(gettext("Error buiding install args"));
	    FREE(tmpdest);
	    return 0;
	}
	src = n++;
    }
    args = install_argp;

d1821 1
a1824 17
	/* simplistic detection of identical src and dest - kw */
	if (!strcmp(savepath, destpath)) {
	    HTUserMsg2(gettext("Source and target are the same: %s"),
		       savepath);
	    FREE(tmpdest);
	    return(-1);		/* don't do it */
	} else if (!strncmp(savepath, destpath, strlen(destpath)) &&
		   LYIsPathSep(savepath[strlen(destpath)]) &&
#ifdef DOSPATH
		   !strchr(savepath + strlen(destpath) + 1, '\\') &&
#endif
		   !strchr(savepath + strlen(destpath) + 1, '/')) {
	    HTUserMsg2(gettext("Already in target directory: %s"),
		       savepath);
	    FREE(tmpdest);
	    return 0;		/* don't do it */
	}
d1826 1
a1826 4
	HTSprintf0(&tmpbuf, "install %s in %s", savepath, destpath);
	if (LYExecv(INSTALL_PATH, args, tmpbuf) <= 0) {
	    FREE(tmpbuf);
	    FREE(tmpdest);
a1827 1
	}
a1830 1
	HTSprintf0(&tmpbuf, "install in %s", destpath);
a1833 18

	    /* simplistic detection of identical src and dest - kw */
	    if (!strcmp(args[src], destpath)) {
		HTUserMsg2(gettext("Source and target are the same: %s"),
			   args[src]);
		FREE(args[src]);
		continue;	/* skip this source file */
	    } else if (!strncmp(args[src], destpath, strlen(destpath)) &&
		       LYIsPathSep(args[src][strlen(destpath)]) &&
#ifdef DOSPATH
		       !strchr(args[src] + strlen(destpath) + 1, '\\') &&
#endif
		       !strchr(args[src] + strlen(destpath) + 1, '/')) {
		HTUserMsg2(gettext("Already in target directory: %s"),
			   args[src]);
		FREE(args[src]);
		continue;	/* skip this source file */
	    }
d1836 1
a1836 3
	    if (err) {
		FREE(tmpbuf);
		FREE(tmpdest);
a1837 1
	    }
a1842 1
    FREE(tmpdest);
a1845 1
#endif /* OK_INSTALL */
d1865 1
a1865 1
	char *,		str)
d1877 1
a1877 1
    new = typecalloc(struct dired_menu);
a1891 1
#ifdef S_IFLNK
a1893 1
#endif /* S_IFLNK */
a1923 16
PUBLIC void reset_dired_menu NOARGS
{
    if (menu_head != defmenu) {
	struct dired_menu *mp, *mp_next = NULL;
	for (mp = menu_head; mp != NULL; mp = mp_next) {
	    FREE(mp->sfx);
	    FREE(mp->link);
	    FREE(mp->rest);
	    FREE(mp->href);
	    mp_next = mp_next;
	    FREE(mp);
	}
	menu_head = NULL;
    }
}

d1928 4
a1931 4
	CONST char *,	s,
	CONST char *,	path,
	CONST char *,	dir,
	char *,		buf,
d1935 1
a1935 1
    CONST char *cp;
d1965 1
a1965 1
		    cp = LYLastPathSep(path);
d1999 1
a1999 1
		    *BP_INC = *s;
d2013 2
a2014 1
	HTAlert(gettext("Temporary URL or list would be too long."));
d2020 82
d2103 3
a2105 1
#endif /* DIRED_SUPPORT */
@

