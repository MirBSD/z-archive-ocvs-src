head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.2
	tg-mergefixes-1-branch:1.1.1.2.0.8
	tg-mergefixes-1-base:1.1.1.2
	MIROS_X:1.1.1.2.0.6
	MIROS_X_BASE:1.1.1.2
	tg-mergetmp-3:1.1.1.2
	MIRBSD_XP_MIRPPC:1.1.1.2.0.4
	cvs-200410231830:1.1.1.2
	MIRBSD_XP_SPARC_BASE:1.1.1.2
	MIRBSD_XP_SPARC:1.1.1.2.0.2
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.1.1.1
	cvs-200405160640:1.1.1.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	cvs-200312222040:1.1.1.2
	cvs-200312031730:1.1.1.2
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2003.03.22.17.43.14;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.43.14;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.17.55.42;	author tg;	state Stab;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl -w

print "1..51\n";

BEGIN {
    if( $ENV{PERL_CORE} ) {
        chdir 't' if -d 't';
        @@INC = '../lib';
    }
}

# use warnings;
use strict;
use ExtUtils::MakeMaker;
use ExtUtils::Constant qw (constant_types C_constant XS_constant autoload);
use Config;
use File::Spec::Functions qw(catfile rel2abs);
# Because were are going to be changing directory before running Makefile.PL
my $perl;
$perl = rel2abs( $^X ) unless $] < 5.006; # Hack. Until 5.00503 has rel2abs
# ExtUtils::Constant::C_constant uses $^X inside a comment, and we want to
# compare output to ensure that it is the same. We were probably run as ./perl
# whereas we will run the child with the full path in $perl. So make $^X for
# us the same as our child will see.
$^X = $perl;

print "# perl=$perl\n";
my $runperl = "$perl \"-I../../lib\"";

$| = 1;

my $dir = "ext-$$";
my @@files;

print "# $dir being created...\n";
mkdir $dir, 0777 or die "mkdir: $!\n";

my $output = "output";

# For debugging set this to 1.
my $keep_files = 0;

END {
    use File::Path;
    print "# $dir being removed...\n";
    rmtree($dir) unless $keep_files;
}

my $package = "ExtTest";

# Test the code that generates 1 and 2 letter name comparisons.
my %compass = (
N => 0, 'NE' => 45, E => 90, SE => 135, S => 180, SW => 225, W => 270, NW => 315
);

my $parent_rfc1149 =
  'A Standard for the Transmission of IP Datagrams on Avian Carriers';
# Check that 8 bit and unicode names don't cause problems.
my $pound; 
if (ord('A') == 193) {  # EBCDIC platform
    $pound = chr 177; # A pound sign. (Currency)
} else { # ASCII platform
    $pound = chr 163; # A pound sign. (Currency)
}
my $inf = chr 0x221E;
# Check that we can distiguish the pathological case of a string, and the
# utf8 representation of that string.
my $pound_bytes = my $pound_utf8 = $pound . '1';
utf8::encode ($pound_bytes);

my @@names = ("FIVE", {name=>"OK6", type=>"PV",},
             {name=>"OK7", type=>"PVN",
              value=>['"not ok 7\\n\\0ok 7\\n"', 15]},
             {name => "FARTHING", type=>"NV"},
             {name => "NOT_ZERO", type=>"UV", value=>"~(UV)0"},
             {name => "OPEN", type=>"PV", value=>'"/*"', macro=>1},
             {name => "CLOSE", type=>"PV", value=>'"*/"',
              macro=>["#if 1\n", "#endif\n"]},
             {name => "ANSWER", default=>["UV", 42]}, "NOTDEF",
             {name => "Yes", type=>"YES"},
             {name => "No", type=>"NO"},
             {name => "Undef", type=>"UNDEF"},
# OK. It wasn't really designed to allow the creation of dual valued constants.
# It was more for INADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE
             {name=>"RFC1149", type=>"SV", value=>"sv_2mortal(temp_sv)",
              pre=>"SV *temp_sv = newSVpv(RFC1149, 0); "
              	   . "(void) SvUPGRADE(temp_sv,SVt_PVIV); SvIOK_on(temp_sv); "
                   . "SvIVX(temp_sv) = 1149;"},
             {name=>"perl", type=>"PV",},
);

push @@names, $_ foreach keys %compass;

# Automatically compile the list of all the macro names, and make them
# exported constants.
my @@names_only = map {(ref $_) ? $_->{name} : $_} @@names;

# Exporter::Heavy (currently) isn't able to export these names:
push @@names, ({name=>"*/", type=>"PV", value=>'"CLOSE"', macro=>1},
              {name=>"/*", type=>"PV", value=>'"OPEN"', macro=>1},
              {name=>$pound, type=>"PV", value=>'"Sterling"', macro=>1},
              {name=>$inf, type=>"PV", value=>'"Infinity"', macro=>1},
              {name=>$pound_utf8, type=>"PV", value=>'"1 Pound"', macro=>1},
              {name=>$pound_bytes, type=>"PV", value=>'"1 Pound (as bytes)"',
               macro=>1},
             );

=pod

The above set of names seems to produce a suitably bad set of compile
problems on a Unicode naive version of ExtUtils::Constant (ie 0.11):

nick@@thinking-cap 15439-32-utf$ PERL_CORE=1 ./perl lib/ExtUtils/t/Constant.t
1..33
# perl=/stuff/perl5/15439-32-utf/perl
# ext-30370 being created...
Wide character in print at lib/ExtUtils/t/Constant.t line 140.
ok 1
ok 2
# make = 'make'
ExtTest.xs: In function `constant_1':
ExtTest.xs:80: warning: multi-character character constant
ExtTest.xs:80: warning: case value out of range
ok 3

=cut

my $types = {};
my $constant_types = constant_types(); # macro defs
my $C_constant = join "\n",
  C_constant ($package, undef, "IV", $types, undef, undef, @@names);
my $XS_constant = XS_constant ($package, $types); # XS for ExtTest::constant

################ Header
my $header = catfile($dir, "test.h");
push @@files, "test.h";
open FH, ">$header" or die "open >$header: $!\n";
print FH <<"EOT";
#define FIVE 5
#define OK6 "ok 6\\n"
#define OK7 1
#define FARTHING 0.25
#define NOT_ZERO 1
#define Yes 0
#define No 1
#define Undef 1
#define RFC1149 "$parent_rfc1149"
#undef NOTDEF
#define perl "rules"
EOT

while (my ($point, $bearing) = each %compass) {
  print FH "#define $point $bearing\n"
}
close FH or die "close $header: $!\n";

################ XS
my $xs = catfile($dir, "$package.xs");
push @@files, "$package.xs";
open FH, ">$xs" or die "open >$xs: $!\n";

print FH <<'EOT';
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
EOT

print FH "#include \"test.h\"\n\n";
print FH $constant_types;
print FH $C_constant, "\n";
print FH "MODULE = $package		PACKAGE = $package\n";
print FH "PROTOTYPES: ENABLE\n";
print FH $XS_constant;
close FH or die "close $xs: $!\n";

################ PM
my $pm = catfile($dir, "$package.pm");
push @@files, "$package.pm";
open FH, ">$pm" or die "open >$pm: $!\n";
print FH "package $package;\n";
print FH "use $];\n";

print FH <<'EOT';

use strict;
EOT
printf FH "use warnings;\n" unless $] < 5.006;
print FH <<'EOT';
use Carp;

require Exporter;
require DynaLoader;
use vars qw ($VERSION @@ISA @@EXPORT_OK $AUTOLOAD);

$VERSION = '0.01';
@@ISA = qw(Exporter DynaLoader);
@@EXPORT_OK = qw(
EOT

# Print the names of all our autoloaded constants
print FH "\t$_\n" foreach (@@names_only);
print FH ");\n";
# Print the AUTOLOAD subroutine ExtUtils::Constant generated for us
print FH autoload ($package, $]);
print FH "bootstrap $package \$VERSION;\n1;\n__END__\n";
close FH or die "close $pm: $!\n";

################ test.pl
my $testpl = catfile($dir, "test.pl");
push @@files, "test.pl";
open FH, ">$testpl" or die "open >$testpl: $!\n";

print FH "use strict;\n";
print FH "use $package qw(@@names_only);\n";
print FH <<"EOT";

use utf8;

print "1..1\n";
if (open OUTPUT, ">$output") {
  print "ok 1\n";
  select OUTPUT;
} else {
  print "not ok 1 # Failed to open '$output': $!\n";
  exit 1;
}
EOT

print FH << 'EOT';

# What follows goes to the temporary file.
# IV
my $five = FIVE;
if ($five == 5) {
  print "ok 5\n";
} else {
  print "not ok 5 # $five\n";
}

# PV
print OK6;

# PVN containing embedded \0s
$_ = OK7;
s/.*\0//s;
print;

# NV
my $farthing = FARTHING;
if ($farthing == 0.25) {
  print "ok 8\n";
} else {
  print "not ok 8 # $farthing\n";
}

# UV
my $not_zero = NOT_ZERO;
if ($not_zero > 0 && $not_zero == ~0) {
  print "ok 9\n";
} else {
  print "not ok 9 # \$not_zero=$not_zero ~0=" . (~0) . "\n";
}

# Value includes a "*/" in an attempt to bust out of a C comment.
# Also tests custom cpp #if clauses
my $close = CLOSE;
if ($close eq '*/') {
  print "ok 10\n";
} else {
  print "not ok 10 # \$close='$close'\n";
}

# Default values if macro not defined.
my $answer = ANSWER;
if ($answer == 42) {
  print "ok 11\n";
} else {
  print "not ok 11 # What do you get if you multiply six by nine? '$answer'\n";
}

# not defined macro
my $notdef = eval { NOTDEF; };
if (defined $notdef) {
  print "not ok 12 # \$notdef='$notdef'\n";
} elsif ($@@ !~ /Your vendor has not defined ExtTest macro NOTDEF/) {
  print "not ok 12 # \$@@='$@@'\n";
} else {
  print "ok 12\n";
}

# not a macro
my $notthere = eval { &ExtTest::NOTTHERE; };
if (defined $notthere) {
  print "not ok 13 # \$notthere='$notthere'\n";
} elsif ($@@ !~ /NOTTHERE is not a valid ExtTest macro/) {
  chomp $@@;
  print "not ok 13 # \$@@='$@@'\n";
} else {
  print "ok 13\n";
}

# Truth
my $yes = Yes;
if ($yes) {
  print "ok 14\n";
} else {
  print "not ok 14 # $yes='\$yes'\n";
}

# Falsehood
my $no = No;
if (defined $no and !$no) {
  print "ok 15\n";
} else {
  print "not ok 15 # \$no=" . defined ($no) ? "'$no'\n" : "undef\n";
}

# Undef
my $undef = Undef;
unless (defined $undef) {
  print "ok 16\n";
} else {
  print "not ok 16 # \$undef='$undef'\n";
}


# invalid macro (chosen to look like a mix up between No and SW)
$notdef = eval { &ExtTest::So };
if (defined $notdef) {
  print "not ok 17 # \$notdef='$notdef'\n";
} elsif ($@@ !~ /^So is not a valid ExtTest macro/) {
  print "not ok 17 # \$@@='$@@'\n";
} else {
  print "ok 17\n";
}

# invalid defined macro
$notdef = eval { &ExtTest::EW };
if (defined $notdef) {
  print "not ok 18 # \$notdef='$notdef'\n";
} elsif ($@@ !~ /^EW is not a valid ExtTest macro/) {
  print "not ok 18 # \$@@='$@@'\n";
} else {
  print "ok 18\n";
}

my %compass = (
EOT

while (my ($point, $bearing) = each %compass) {
  print FH "'$point' => $bearing, "
}

print FH <<'EOT';

);

my $fail;
while (my ($point, $bearing) = each %compass) {
  my $val = eval $point;
  if ($@@) {
    print "# $point: \$@@='$@@'\n";
    $fail = 1;
  } elsif (!defined $bearing) {
    print "# $point: \$val=undef\n";
    $fail = 1;
  } elsif ($val != $bearing) {
    print "# $point: \$val=$val, not $bearing\n";
    $fail = 1;
  }
}
if ($fail) {
  print "not ok 19\n";
} else {
  print "ok 19\n";
}

EOT

print FH <<"EOT";
my \$rfc1149 = RFC1149;
if (\$rfc1149 ne "$parent_rfc1149") {
  print "not ok 20 # '\$rfc1149' ne '$parent_rfc1149'\n";
} else {
  print "ok 20\n";
}

if (\$rfc1149 != 1149) {
  printf "not ok 21 # %d != 1149\n", \$rfc1149;
} else {
  print "ok 21\n";
}

EOT

print FH <<'EOT';
# test macro=>1
my $open = OPEN;
if ($open eq '/*') {
  print "ok 22\n";
} else {
  print "not ok 22 # \$open='$open'\n";
}
EOT

# Do this in 7 bit in case someone is testing with some settings that cause
# 8 bit files incapable of storing this character.
my @@values
 = map {"'" . join (",", unpack "U*", $_) . "'"}
 ($pound, $inf, $pound_bytes, $pound_utf8);
# Values is a list of strings, such as ('194,163,49', '163,49')

print FH <<'EOT';

# I can see that this child test program might be about to use parts of
# Test::Builder

my $test = 23;
my ($pound, $inf, $pound_bytes, $pound_utf8) = map {eval "pack 'U*', $_"}
EOT

print FH join ",", @@values;

print FH << 'EOT';
;

foreach (["perl", "rules", "rules"],
	 ["/*", "OPEN", "OPEN"],
	 ["*/", "CLOSE", "CLOSE"],
	 [$pound, 'Sterling', []],
         [$inf, 'Infinity', []],
	 [$pound_utf8, '1 Pound', '1 Pound (as bytes)'],
	 [$pound_bytes, '1 Pound (as bytes)', []],
        ) {
  # Flag an expected error with a reference for the expect string.
  my ($string, $expect, $expect_bytes) = @@$_;
  (my $name = $string) =~ s/([^ -~])/sprintf '\x{%X}', ord $1/ges;
  print "# \"$name\" => \'$expect\'\n";
  # Try to force this to be bytes if possible.
  utf8::downgrade ($string, 1);
EOT

print FH  "my (\$error, \$got) = ${package}::constant (\$string);\n";

print FH <<'EOT';
  if ($error or $got ne $expect) {
    print "not ok $test # error '$error', got '$got'\n";
  } else {
    print "ok $test\n";
  }
  $test++;
  print "# Now upgrade '$name' to utf8\n";
  utf8::upgrade ($string);
EOT

print FH  "my (\$error, \$got) = ${package}::constant (\$string);\n";

print FH <<'EOT';
  if ($error or $got ne $expect) {
    print "not ok $test # error '$error', got '$got'\n";
  } else {
    print "ok $test\n";
  }
  $test++;
  if (defined $expect_bytes) {
    print "# And now with the utf8 byte sequence for name\n";
    # Try the encoded bytes.
    utf8::encode ($string);
EOT

print FH "my (\$error, \$got) = ${package}::constant (\$string);\n";

print FH <<'EOT';
    if (ref $expect_bytes) {
      # Error expected.
      if ($error) {
        print "ok $test # error='$error' (as expected)\n";
      } else {
        print "not ok $test # expected error, got no error and '$got'\n";
      }
    } elsif ($got ne $expect_bytes) {
      print "not ok $test # error '$error', expect '$expect_bytes', got '$got'\n";
    } else {
      print "ok $test\n";
    }
    $test++;
  }
}
EOT

close FH or die "close $testpl: $!\n";

# This is where the test numbers carry on after the test number above are
# relayed
my $test = 44;

################ Makefile.PL
# We really need a Makefile.PL because make test for a no dynamic linking perl
# will run Makefile.PL again as part of the "make perl" target.
my $makefilePL = catfile($dir, "Makefile.PL");
push @@files, "Makefile.PL";
open FH, ">$makefilePL" or die "open >$makefilePL: $!\n";
print FH <<"EOT";
#!$perl -w
use ExtUtils::MakeMaker;
WriteMakefile(
              'NAME'		=> "$package",
              'VERSION_FROM'	=> "$package.pm", # finds \$VERSION
              (\$] >= 5.005 ?
               (#ABSTRACT_FROM => "$package.pm", # XXX add this
                AUTHOR     => "$0") : ())
             );
EOT

close FH or die "close $makefilePL: $!\n";

################ MANIFEST
# We really need a MANIFEST because make distclean checks it.
my $manifest = catfile($dir, "MANIFEST");
push @@files, "MANIFEST";
open FH, ">$manifest" or die "open >$manifest: $!\n";
print FH "$_\n" foreach @@files;
close FH or die "close $manifest: $!\n";

chdir $dir or die $!; push @@INC,  '../../lib';
END {chdir ".." or warn $!};

my @@perlout = `$runperl Makefile.PL PERL_CORE=1`;
if ($?) {
  print "not ok 1 # $runperl Makefile.PL failed: $?\n";
  print "# $_" foreach @@perlout;
  exit($?);
} else {
  print "ok 1\n";
}


my $makefile = ($^O eq 'VMS' ? 'descrip' : 'Makefile');
my $makefile_ext = ($^O eq 'VMS' ? '.mms' : '');
if (-f "$makefile$makefile_ext") {
  print "ok 2\n";
} else {
  print "not ok 2\n";
}

# Renamed by make clean
my $makefile_rename = $makefile . ($^O eq 'VMS' ? '.mms' : '.old');

my $make = $Config{make};

$make = $ENV{MAKE} if exists $ENV{MAKE};

if ($^O eq 'MSWin32' && $make eq 'nmake') { $make .= " -nologo"; }

my @@makeout;

if ($^O eq 'VMS') { $make .= ' all'; }
print "# make = '$make'\n";
@@makeout = `$make`;
if ($?) {
  print "not ok 3 # $make failed: $?\n";
  print "# $_" foreach @@makeout;
  exit($?);
} else {
  print "ok 3\n";
}

if ($^O eq 'VMS') { $make =~ s{ all}{}; }

if ($Config{usedl}) {
  print "ok 4\n";
} else {
  my $makeperl = "$make perl";
  print "# make = '$makeperl'\n";
  @@makeout = `$makeperl`;
  if ($?) {
    print "not ok 4 # $makeperl failed: $?\n";
  print "# $_" foreach @@makeout;
    exit($?);
  } else {
    print "ok 4\n";
  }
}

my $maketest = "$make test";
print "# make = '$maketest'\n";

@@makeout = `$maketest`;

if (open OUTPUT, "<$output") {
  print while <OUTPUT>;
  close OUTPUT or print "# Close $output failed: $!\n";
} else {
  # Harness will report missing test results at this point.
  print "# Open <$output failed: $!\n";
}

if ($?) {
  print "not ok $test # $maketest failed: $?\n";
  print "# $_" foreach @@makeout;
} else {
  print "ok $test - maketest\n";
}
$test++;


# -x is busted on Win32 < 5.6.1, so we emulate it.
my $regen;
if( $^O eq 'MSWin32' && $] <= 5.006001 ) {
    open(REGENTMP, ">regentmp") or die $!;
    open(XS, "$package.xs")     or die $!;
    my $saw_shebang;
    while(<XS>) {
        $saw_shebang++ if /^#!.*/i ;
        print REGENTMP $_ if $saw_shebang;
    }
    close XS;  close REGENTMP;
    $regen = `$runperl regentmp`;
    unlink 'regentmp';
}
else {
    $regen = `$runperl -x $package.xs`;
}
if ($?) {
  print "not ok $test # $runperl -x $package.xs failed: $?\n";
} else {
  print "ok $test - regen\n";
}
$test++;

my $expect = $constant_types . $C_constant .
  "\n#### XS Section:\n" . $XS_constant;

if ($expect eq $regen) {
  print "ok $test - regen worked\n";
} else {
  print "not ok $test - regen worked\n";
  # open FOO, ">expect"; print FOO $expect;
  # open FOO, ">regen"; print FOO $regen; close FOO;
}
$test++;

my $makeclean = "$make clean";
print "# make = '$makeclean'\n";
@@makeout = `$makeclean`;
if ($?) {
  print "not ok $test # $make failed: $?\n";
  print "# $_" foreach @@makeout;
} else {
  print "ok $test\n";
}
$test++;

sub check_for_bonus_files {
  my $dir = shift;
  my %expect = map {($^O eq 'VMS' ? lc($_) : $_), 1} @@_;

  my $fail;
  opendir DIR, $dir or die "opendir '$dir': $!";
  while (defined (my $entry = readdir DIR)) {
    $entry =~ s/\.$// if $^O eq 'VMS';  # delete trailing dot that indicates no extension
    next if $expect{$entry};
    print "# Extra file '$entry'\n";
    $fail = 1;
  }

  closedir DIR or warn "closedir '.': $!";
  if ($fail) {
    print "not ok $test\n";
  } else {
    print "ok $test\n";
  }
  $test++;
}

check_for_bonus_files ('.', @@files, $output, $makefile_rename, '.', '..');

rename $makefile_rename, $makefile
 or die "Can't rename '$makefile_rename' to '$makefile': $!";

unlink $output or warn "Can't unlink '$output': $!";

# Need to make distclean to remove ../../lib/ExtTest.pm
my $makedistclean = "$make distclean";
print "# make = '$makedistclean'\n";
@@makeout = `$makedistclean`;
if ($?) {
  print "not ok $test # $make failed: $?\n";
  print "# $_" foreach @@makeout;
} else {
  print "ok $test\n";
}
$test++;

check_for_bonus_files ('.', @@files, '.', '..');

unless ($keep_files) {
  foreach (@@files) {
    unlink $_ or warn "unlink $_: $!";
  }
}

check_for_bonus_files ('.', '.', '..');
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import selected parts of the OpenBSD base system:
 * vnd change - you'll have to re-run MAKEDEV after booting a new kernel
 * misc. changes in /etc, mostly user related
 * Perl 5.8.2 (diff to MirPorts will be committed RSN)
 * some changes to binutils
 * Updates in bc and dc
@
text
@d3 2
a9 5
    use Config;
    unless ($Config{usedl}) {
	print "1..0 # no usedl, skipping\n";
	exit 0;
    }
d16 2
a17 9
use File::Spec;
use Cwd;

my $do_utf_tests = $] > 5.006;
my $better_than_56 = $] > 5.007;
# For debugging set this to 1.
my $keep_files = 0;
$| = 1;

d19 2
a20 6
my $perl = $^X;
# 5.005 doesn't have new enough File::Spec to have rel2abs. But actually we
# only need it when $^X isn't absolute, which is going to be 5.8.0 or later
# (where ExtUtils::Constant is in the core, and tests against the uninstalled
# perl)
$perl = File::Spec->rel2abs ($perl) unless $] < 5.006;
d26 1
a26 2
my $lib = $ENV{PERL_CORE} ? '../../../lib' : '../../blib/lib';
my $runperl = "$perl \"-I$lib\"";
d28 1
d30 1
a30 8
my $make = $Config{make};
$make = $ENV{MAKE} if exists $ENV{MAKE};
if ($^O eq 'MSWin32' && $make eq 'nmake') { $make .= " -nologo"; }

# Renamed by make clean
my $makefile = ($^O eq 'VMS' ? 'descrip' : 'Makefile');
my $makefile_ext = ($^O eq 'VMS' ? '.mms' : '');
my $makefile_rename = $makefile . ($^O eq 'VMS' ? '.mms' : '.old');
a31 2
my $output = "output";
my $package = "ExtTest";
d33 1
a33 7
my $subdir = 0;
# The real test counter.
my $realtest = 1;

my $orig_cwd = cwd;
my $updir = File::Spec->updir;
die "Can't get current directory: $!" unless defined $orig_cwd;
d38 5
a43 2
  if (defined $orig_cwd and length $orig_cwd) {
    chdir $orig_cwd or die "Can't chdir back to '$orig_cwd': $!";
a46 4
  } else {
    # Can't get here.
    die "cwd at start was empty, but directory '$dir' was created" if $dir;
  }
d49 1
a49 2
chdir $dir or die $!;
push @@INC, '../../lib', '../../../lib';
d51 4
a54 3
sub check_for_bonus_files {
  my $dir = shift;
  my %expect = map {($^O eq 'VMS' ? lc($_) : $_), 1} @@_;
d56 8
a63 16
  my $fail;
  opendir DIR, $dir or die "opendir '$dir': $!";
  while (defined (my $entry = readdir DIR)) {
    $entry =~ s/\.$// if $^O eq 'VMS';  # delete trailing dot that indicates no extension
    next if $expect{$entry};
    print "# Extra file '$entry'\n";
    $fail = 1;
  }

  closedir DIR or warn "closedir '.': $!";
  if ($fail) {
    print "not ok $realtest\n";
  } else {
    print "ok $realtest\n";
  }
  $realtest++;
d65 26
d92 1
a92 12
sub build_and_run {
  my ($tests, $expect, $files) = @@_;
  my $core = $ENV{PERL_CORE} ? ' PERL_CORE=1' : '';
  my @@perlout = `$runperl Makefile.PL $core`;
  if ($?) {
    print "not ok $realtest # $runperl Makefile.PL failed: $?\n";
    print "# $_" foreach @@perlout;
    exit($?);
  } else {
    print "ok $realtest\n";
  }
  $realtest++;
d94 13
a106 6
  if (-f "$makefile$makefile_ext") {
    print "ok $realtest\n";
  } else {
    print "not ok $realtest\n";
  }
  $realtest++;
d108 1
a108 1
  my @@makeout;
d110 2
a111 1
  if ($^O eq 'VMS') { $make .= ' all'; }
d113 12
a124 10
  print "# make = '$make'\n";
  @@makeout = `$make`;
  if ($?) {
    print "not ok $realtest # $make failed: $?\n";
    print "# $_" foreach @@makeout;
    exit($?);
  } else {
    print "ok $realtest\n";
  }
  $realtest++;
d126 1
a126 1
  if ($^O eq 'VMS') { $make =~ s{ all}{}; }
d128 22
a149 130
  if ($Config{usedl}) {
    print "ok $realtest # This is dynamic linking, so no need to make perl\n";
  } else {
    my $makeperl = "$make perl";
    print "# make = '$makeperl'\n";
    @@makeout = `$makeperl`;
    if ($?) {
      print "not ok $realtest # $makeperl failed: $?\n";
      print "# $_" foreach @@makeout;
      exit($?);
    } else {
      print "ok $realtest\n";
    }
  }
  $realtest++;

  my $maketest = "$make test";
  print "# make = '$maketest'\n";

  @@makeout = `$maketest`;

  if (open OUTPUT, "<$output") {
    local $/; # Slurp it - faster.
    print <OUTPUT>;
    close OUTPUT or print "# Close $output failed: $!\n";
  } else {
    # Harness will report missing test results at this point.
    print "# Open <$output failed: $!\n";
  }

  $realtest += $tests;
  if ($?) {
    print "not ok $realtest # $maketest failed: $?\n";
    print "# $_" foreach @@makeout;
  } else {
    print "ok $realtest - maketest\n";
  }
  $realtest++;

  # -x is busted on Win32 < 5.6.1, so we emulate it.
  my $regen;
  if( $^O eq 'MSWin32' && $] <= 5.006001 ) {
    open(REGENTMP, ">regentmp") or die $!;
    open(XS, "$package.xs")     or die $!;
    my $saw_shebang;
    while(<XS>) {
      $saw_shebang++ if /^#!.*/i ;
        print REGENTMP $_ if $saw_shebang;
    }
    close XS;  close REGENTMP;
    $regen = `$runperl regentmp`;
    unlink 'regentmp';
  }
  else {
    $regen = `$runperl -x $package.xs`;
  }
  if ($?) {
    print "not ok $realtest # $runperl -x $package.xs failed: $?\n";
  } else {
    print "ok $realtest - regen\n";
  }
  $realtest++;

  if ($expect eq $regen) {
    print "ok $realtest - regen worked\n";
  } else {
    print "not ok $realtest - regen worked\n";
    # open FOO, ">expect"; print FOO $expect;
    # open FOO, ">regen"; print FOO $regen; close FOO;
  }
  $realtest++;

  my $makeclean = "$make clean";
  print "# make = '$makeclean'\n";
  @@makeout = `$makeclean`;
  if ($?) {
    print "not ok $realtest # $make failed: $?\n";
    print "# $_" foreach @@makeout;
  } else {
    print "ok $realtest\n";
  }
  $realtest++;

  check_for_bonus_files ('.', @@$files, $output, $makefile_rename, '.', '..');

  rename $makefile_rename, $makefile
    or die "Can't rename '$makefile_rename' to '$makefile': $!";

  unlink $output or warn "Can't unlink '$output': $!";

  # Need to make distclean to remove ../../lib/ExtTest.pm
  my $makedistclean = "$make distclean";
  print "# make = '$makedistclean'\n";
  @@makeout = `$makedistclean`;
  if ($?) {
    print "not ok $realtest # $make failed: $?\n";
    print "# $_" foreach @@makeout;
  } else {
    print "ok $realtest\n";
  }
  $realtest++;

  check_for_bonus_files ('.', @@$files, '.', '..');

  unless ($keep_files) {
    foreach (@@$files) {
      unlink $_ or warn "unlink $_: $!";
    }
  }

  check_for_bonus_files ('.', '.', '..');
}

sub Makefile_PL {
  my $package = shift;
  ################ Makefile.PL
  # We really need a Makefile.PL because make test for a no dynamic linking perl
  # will run Makefile.PL again as part of the "make perl" target.
  my $makefilePL = "Makefile.PL";
  open FH, ">$makefilePL" or die "open >$makefilePL: $!\n";
  print FH <<"EOT";
#!$perl -w
use ExtUtils::MakeMaker;
WriteMakefile(
              'NAME'		=> "$package",
              'VERSION_FROM'	=> "$package.pm", # finds \$VERSION
              (\$] >= 5.005 ?
               (#ABSTRACT_FROM => "$package.pm", # XXX add this
                AUTHOR     => "$0") : ())
             );
d152 2
a153 2
  close FH or die "close $makefilePL: $!\n";
  return $makefilePL;
d155 1
d157 4
a160 41
sub MANIFEST {
  my (@@files) = @@_;
  ################ MANIFEST
  # We really need a MANIFEST because make distclean checks it.
  my $manifest = "MANIFEST";
  push @@files, $manifest;
  open FH, ">$manifest" or die "open >$manifest: $!\n";
  print FH "$_\n" foreach @@files;
  close FH or die "close $manifest: $!\n";
  return @@files;
}

sub write_and_run_extension {
  my ($name, $items, $export_names, $package, $header, $testfile, $num_tests)
    = @@_;
  my $types = {};
  my $constant_types = constant_types(); # macro defs
  my $C_constant = join "\n",
    C_constant ($package, undef, "IV", $types, undef, undef, @@$items);
  my $XS_constant = XS_constant ($package, $types); # XS for ExtTest::constant

  my $expect = $constant_types . $C_constant .
    "\n#### XS Section:\n" . $XS_constant;

  print "# $name\n# $dir/$subdir being created...\n";
  mkdir $subdir, 0777 or die "mkdir: $!\n";
  chdir $subdir or die $!;

  my @@files;

  ################ Header
  my $header_name = "test.h";
  push @@files, $header_name;
  open FH, ">$header_name" or die "open >$header_name: $!\n";
  print FH $header or die $!;
  close FH or die "close $header_name: $!\n";

  ################ XS
  my $xs = "$package.xs";
  push @@files, $xs;
  open FH, ">$xs" or die "open >$xs: $!\n";
d162 1
a162 1
  print FH <<'EOT';
d168 14
a181 15
  # XXX Here doc these:
  print FH "#include \"$header_name\"\n\n";
  print FH $constant_types;
  print FH $C_constant, "\n";
  print FH "MODULE = $package		PACKAGE = $package\n";
  print FH "PROTOTYPES: ENABLE\n";
  print FH $XS_constant;
  close FH or die "close $xs: $!\n";

  ################ PM
  my $pm = "$package.pm";
  push @@files, $pm;
  open FH, ">$pm" or die "open >$pm: $!\n";
  print FH "package $package;\n";
  print FH "use $];\n";
d183 1
a183 1
  print FH <<'EOT';
d187 2
a188 2
  printf FH "use warnings;\n" unless $] < 5.006;
  print FH <<'EOT';
d197 1
a198 20
  # Having this qw( in the here doc confuses cperl mode far too much to be
  # helpful. And I'm using cperl mode to edit this, even if you're not :-)
  print FH "\@@EXPORT_OK = qw(\n";

  # Print the names of all our autoloaded constants
  print FH "\t$_\n" foreach (@@$export_names);
  print FH ");\n";
  # Print the AUTOLOAD subroutine ExtUtils::Constant generated for us
  print FH autoload ($package, $]);
  print FH "bootstrap $package \$VERSION;\n1;\n__END__\n";
  close FH or die "close $pm: $!\n";

  ################ test.pl
  my $testpl = "test.pl";
  push @@files, $testpl;
  open FH, ">$testpl" or die "open >$testpl: $!\n";
  # Standard test header (need an option to suppress this?)
  print FH <<"EOT" or die $!;
use strict;
use $package qw(@@$export_names);
d200 20
a219 1
print "1..2\n";
d224 1
a224 1
  print "not ok 1 # Failed to open '$output': \$!\n";
a227 13
  print FH $testfile or die $!;
  print FH <<"EOT" or die $!;
select STDOUT;
if (close OUTPUT) {
  print "ok 2\n";
} else {
  print "not ok 2 # Failed to close '$output': \$!\n";
}
EOT
  close FH or die "close $testpl: $!\n";

  push @@files, Makefile_PL($package);
  @@files = MANIFEST (@@files);
d229 1
a229 23
  build_and_run ($num_tests, $expect, \@@files);

  chdir $updir or die "chdir '$updir': $!";
  ++$subdir;
}
# Tests are arrayrefs of the form
# $name, [items], [export_names], $package, $header, $testfile, $num_tests
my @@tests;
my $before_tests = 4; # Number of "ok"s emitted to build extension
my $after_tests = 8; # Number of "ok"s emitted after make test run
my $dummytest = 1;

my $here;
sub start_tests {
  $dummytest += $before_tests;
  $here = $dummytest;
}
sub end_tests {
  my ($name, $items, $export_names, $header, $testfile) = @@_;
  push @@tests, [$name, $items, $export_names, $package, $header, $testfile,
               $dummytest - $here];
  $dummytest += $after_tests;
}
a230 74
my $pound;
if (ord('A') == 193) {  # EBCDIC platform
  $pound = chr 177; # A pound sign. (Currency)
} else { # ASCII platform
  $pound = chr 163; # A pound sign. (Currency)
}
my @@common_items = (
                    {name=>"perl", type=>"PV",},
                    {name=>"*/", type=>"PV", value=>'"CLOSE"', macro=>1},
                    {name=>"/*", type=>"PV", value=>'"OPEN"', macro=>1},
                    {name=>$pound, type=>"PV", value=>'"Sterling"', macro=>1},
                   );

{
  # Simple tests
  start_tests();
  my $parent_rfc1149 =
    'A Standard for the Transmission of IP Datagrams on Avian Carriers';
  # Test the code that generates 1 and 2 letter name comparisons.
  my %compass = (
                 N => 0, 'NE' => 45, E => 90, SE => 135,
                 S => 180, SW => 225, W => 270, NW => 315
                );

  my $header = << "EOT";
#define FIVE 5
#define OK6 "ok 6\\n"
#define OK7 1
#define FARTHING 0.25
#define NOT_ZERO 1
#define Yes 0
#define No 1
#define Undef 1
#define RFC1149 "$parent_rfc1149"
#undef NOTDEF
#define perl "rules"
EOT

  while (my ($point, $bearing) = each %compass) {
    $header .= "#define $point $bearing\n"
  }

  my @@items = ("FIVE", {name=>"OK6", type=>"PV",},
               {name=>"OK7", type=>"PVN",
                value=>['"not ok 7\\n\\0ok 7\\n"', 15]},
               {name => "FARTHING", type=>"NV"},
               {name => "NOT_ZERO", type=>"UV", value=>"~(UV)0"},
               {name => "OPEN", type=>"PV", value=>'"/*"', macro=>1},
               {name => "CLOSE", type=>"PV", value=>'"*/"',
                macro=>["#if 1\n", "#endif\n"]},
               {name => "ANSWER", default=>["UV", 42]}, "NOTDEF",
               {name => "Yes", type=>"YES"},
               {name => "No", type=>"NO"},
               {name => "Undef", type=>"UNDEF"},
  # OK. It wasn't really designed to allow the creation of dual valued
  # constants.
  # It was more for INADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE
               {name=>"RFC1149", type=>"SV", value=>"sv_2mortal(temp_sv)",
                pre=>"SV *temp_sv = newSVpv(RFC1149, 0); "
                . "(void) SvUPGRADE(temp_sv,SVt_PVIV); SvIOK_on(temp_sv); "
                . "SvIVX(temp_sv) = 1149;"},
              );

  push @@items, $_ foreach keys %compass;

  # Automatically compile the list of all the macro names, and make them
  # exported constants.
  my @@export_names = map {(ref $_) ? $_->{name} : $_} @@items;

  # Exporter::Heavy (currently) isn't able to export the last 3 of these:
  push @@items, @@common_items;

  # XXX there are hardwired still.
  my $test_body = <<'EOT';
d237 1
a237 1
  print "not ok 5 # \$five\n";
d326 1
d351 1
a351 1
  $test_body .= "'$point' => $bearing, "
d354 1
a354 1
$test_body .= <<'EOT';
d380 1
a380 1
$test_body .= <<"EOT";
d396 1
a396 1
$test_body .= <<'EOT';
a404 59
$dummytest+=18;

  end_tests("Simple tests", \@@items, \@@export_names, $header, $test_body);
}

if ($do_utf_tests) {
  # utf8 tests
  start_tests();
  my ($inf, $pound_bytes, $pound_utf8);

  $inf = chr 0x221E;
  # Check that we can distiguish the pathological case of a string, and the
  # utf8 representation of that string.
  $pound_utf8 = $pound . '1';
  if ($better_than_56) {
    $pound_bytes = $pound_utf8;
    utf8::encode ($pound_bytes);
  } else {
    # Must have that "U*" to generate a zero length UTF string that forces
    # top bit set chars (such as the pound sign) into UTF8, so that the
    # unpack 'C*' then gets the byte form of the UTF8.
    $pound_bytes =  pack 'C*', unpack 'C*', $pound_utf8 . pack "U*";
  }

  my @@items = (@@common_items,
               {name=>$inf, type=>"PV", value=>'"Infinity"', macro=>1},
               {name=>$pound_utf8, type=>"PV", value=>'"1 Pound"', macro=>1},
               {name=>$pound_bytes, type=>"PV", value=>'"1 Pound (as bytes)"',
                macro=>1},
              );

=pod

The above set of names seems to produce a suitably bad set of compile
problems on a Unicode naive version of ExtUtils::Constant (ie 0.11):

nick@@thinking-cap 15439-32-utf$ PERL_CORE=1 ./perl lib/ExtUtils/t/Constant.t
1..33
# perl=/stuff/perl5/15439-32-utf/perl
# ext-30370 being created...
Wide character in print at lib/ExtUtils/t/Constant.t line 140.
ok 1
ok 2
# make = 'make'
ExtTest.xs: In function `constant_1':
ExtTest.xs:80: warning: multi-character character constant
ExtTest.xs:80: warning: case value out of range
ok 3

=cut

# Grr `

  # Do this in 7 bit in case someone is testing with some settings that cause
  # 8 bit files incapable of storing this character.
  my @@values
    = map {"'" . join (",", unpack "U*", $_ . pack "U*") . "'"}
      ($pound, $inf, $pound_bytes, $pound_utf8);
  # Values is a list of strings, such as ('194,163,49', '163,49')
d406 6
a411 2
  my $test_body .= "my \$test = $dummytest;\n";
  $dummytest += 7 * 3; # 3 tests for each of the 7 things:
d413 1
a413 1
  $test_body .= << 'EOT';
d415 2
a416 2
use utf8;
my $better_than_56 = $] > 5.007;
d418 1
d422 1
a422 1
  $test_body .= join ",", @@values;
d424 1
a424 1
  $test_body .= << 'EOT';
d440 1
a440 8
  if ($better_than_56) {
    utf8::downgrade ($string, 1);
  } else {
    if ($string =~ tr/0-\377// == length $string) {
      # No chars outside range 0-255
      $string = pack 'C*', unpack 'U*', ($string . pack 'U*');
    }
  }
d443 1
a443 1
  $test_body .=  "my (\$error, \$got) = ${package}::constant (\$string);\n";
d445 1
a445 1
  $test_body .= <<'EOT';
d453 1
a453 5
  if ($better_than_56) {
    utf8::upgrade ($string);
  } else {
    $string = pack ('U*') . $string;
  }
d456 1
a456 1
  $test_body .=  "my (\$error, \$got) = ${package}::constant (\$string);\n";
d458 1
a458 1
  $test_body .= <<'EOT';
d468 1
a468 5
    if ($better_than_56) {
      utf8::encode ($string);
    } else {
      $string = pack 'C*', unpack 'C*', $string . pack "U*";
    }
d471 1
a471 1
    $test_body .= "my (\$error, \$got) = ${package}::constant (\$string);\n";
d473 1
a473 1
    $test_body .= <<'EOT';
d491 53
a543 1
  end_tests("utf8 tests", \@@items, [], "#define perl \"rules\"\n", $test_body);
d546 34
a579 14
# XXX I think that I should merge this into the utf8 test above.
sub explict_call_constant {
  my ($string, $expect) = @@_;
  # This does assume simple strings suitable for ''
  my $test_body = <<"EOT";
{
  my (\$error, \$got) = ${package}::constant ('$string');\n;
EOT

  if (defined $expect) {
    # No error expected
    $test_body .= <<"EOT";
  if (\$error or \$got ne "$expect") {
    print "not ok $dummytest # error '\$error', expect '$expect', got '\$got'\n";
d581 35
a615 1
    print "ok $dummytest\n";
d617 48
d666 4
a669 1
EOT
d671 1
a671 6
    # Error expected.
    $test_body .= <<"EOT";
  if (\$error) {
    print "ok $dummytest # error='\$error' (as expected)\n";
  } else {
    print "not ok $dummytest # expected error, got no error and '\$got'\n";
d673 1
a673 4
EOT
  }
  $dummytest++;
  return $test_body . <<'EOT';
d675 17
a691 1
EOT
d693 3
d697 3
a699 27
# Simple tests to verify bits of the switch generation system work.
sub simple {
  start_tests();
  # Deliberately leave $name in @@_, so that it is indexed from 1.
  my ($name, @@items) = @@_;
  my $test_header;
  my $test_body = "my \$value;\n";
  foreach my $counter (1 .. $#_) {
    my $thisname = $_[$counter];
    $test_header .= "#define $thisname $counter\n";
    $test_body .= <<"EOT";
\$value = $thisname;
if (\$value == $counter) {
  print "ok $dummytest\n";
} else {
  print "not ok $dummytest # $thisname gave \$value\n";
}
EOT
    ++$dummytest;
    # Yes, the last time round the loop appends a z to the string.
    for my $i (0 .. length $thisname) {
      my $copyname = $thisname;
      substr ($copyname, $i, 1) = 'z';
      $test_body .= explict_call_constant ($copyname,
                                           $copyname eq $thisname
                                             ? $thisname : undef);
    }
d701 1
a701 28
  # Ho. This seems to be buggy in 5.005_03:
  # # Now remove $name from @@_:
  # shift @@_;
  end_tests($name, \@@items, \@@items, $test_header, $test_body);
}

# Check that the memeq clauses work correctly when there isn't a switch
# statement to bump off a character
simple ("Singletons", "A", "AB", "ABC", "ABCD", "ABCDE");
# Check the three code.
simple ("Three start", qw(Bea kea Lea lea nea pea rea sea tea Wea yea Zea));
# There were 162 2 letter words in /usr/share/dict/words on FreeBSD 4.6, which
# I felt was rather too many. So I used words with 2 vowels.
simple ("Twos and three middle", qw(aa ae ai ea eu ie io oe era eta));
# Given the choice go for the end, else the earliest point
simple ("Three end and four symetry", qw(ean ear eat barb marm tart));


# Need this if the single test below is rolled into @@tests :
# --$dummytest;
print "1..$dummytest\n";

write_and_run_extension @@$_ foreach @@tests;

# This was causing an assertion failure (a C<confess>ion)
# Any single byte > 128 should do it.
C_constant ($package, undef, undef, undef, undef, undef, chr 255);
print "ok $realtest\n"; $realtest++;
d703 1
a703 2
print STDERR "# You were running with \$keep_files set to $keep_files\n"
  if $keep_files;
@

