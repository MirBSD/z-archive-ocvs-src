head	1.6;
access;
symbols
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.4
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.2
	MIROS_X_BASE:1.6
	tg-mergetmp-3:1.6
	cvs-200411231430:1.1.1.14
	MIRBSD_XP_MIRPPC:1.4.0.4
	cvs-200410222040:1.1.1.13
	tg-mergetmp-1:1.1.1.12
	MIRBSD_XP_SPARC_BASE:1.4
	MIRBSD_XP_SPARC:1.4.0.2
	MIRBSD_7quater:1.1.1.10
	cvs-200405160640:1.1.1.12
	cvs-200401271800:1.1.1.11
	cvs-200401261630:1.1.1.11
	cvs-200401021645:1.1.1.11
	MIRBSD_7_ALPHA:1.1.1.10.0.6
	MIRBSD_7:1.1.1.10.0.4
	cvs-200312222040:1.1.1.11
	MIRBSD_7ter:1.1.1.10
	MIRBSD_7_DEV:1.1.1.10.0.2
	cvs-200310020700:1.1.1.10
	cvs-200309271030:1.1.1.10
	cvs-200309251530:1.1.1.9
	cvs-200308302005:1.1.1.8
	cvs-200308171200:1.1.1.7
	ctm-3496:1.1.1.7
	ctm-3449:1.1.1.6
	ctm-3437:1.1.1.6
	cvs-200307191805:1.1.1.6
	ctm-3425:1.1.1.6
	cvs-200307091500:1.1.1.6
	cvs-200307072125:1.1.1.6
	ctm-3389:1.1.1.6
	cvs-200306291430:1.1.1.6
	ctm-3341:1.1.1.6
	MIRBSD_5:1.1.1.5
	cvs-200306082100:1.1.1.5
	ctm-3316:1.1.1.5
	ctm-3272:1.1.1.5
	ctm-3264:1.1.1.4
	cvs-200305071630:1.1.1.4
	MIRBSD_4:1.1.1.4
	ctm-3203:1.1.1.4
	cvs-20030410-1130:1.1.1.3
	ctm-3155:1.1.1.2
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.23.14.38.00;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.22.21.53.42;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.20.02.56.44;	author tg;	state Stab;
branches;
next	1.3;

1.3
date	2004.05.23.16.09.52;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.10.04.56.53;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.48.04;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.48.04;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.03.29.19.40.55;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.04.10.14.43.21;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.04.15.17.35.48;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.21.19.01.40;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.06.19.12.41.26;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.08.11.18.27.43;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.08.30.22.55.01;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.09.25.16.31.28;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.09.27.11.16.28;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2003.12.22.21.09.33;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2004.05.16.08.17.10;	author tg;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2004.10.22.20.49.12;	author tg;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2004.11.23.14.37.02;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@merge
@
text
@/**	$MirBSD: src/libexec/spamd/spamd.c,v 1.5 2004/10/22 21:53:42 tg Exp $ */
/*	$OpenBSD: spamd.c,v 1.74 2004/11/17 15:29:38 beck Exp $	*/

/*
 * Copyright (c) 2002 Theo de Raadt.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/file.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/resource.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <getopt.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include <netdb.h>

#include "sdl.h"
#include "grey.h"

__RCSID("$MirBSD: src/libexec/spamd/spamd.c,v 1.5 2004/10/22 21:53:42 tg Exp $");

struct con {
	int fd;
	int state;
	int laststate;
	int af;
	struct sockaddr_storage ss;
	void *ia;
	char addr[32];
	char mail[MAX_MAIL], rcpt[MAX_MAIL];
	struct sdlist **blacklists;

	/*
	 * we will do stuttering by changing these to time_t's of
	 * now + n, and only advancing when the time is in the past/now
	 */
	time_t r;
	time_t w;
	time_t s;

	char ibuf[8192];
	char *ip;
	int il;
	char rend[5];	/* any chars in here causes input termination */

	char *obuf;
	char *lists;
	size_t osize;
	char *op;
	int ol;
	int data_lines;
	int data_body;
	int stutter;
	int sr;
} *con;

void     usage(void);
char    *grow_obuf(struct con *, int);
int      parse_configline(char *);
void     parse_configs(void);
void     do_config(void);
int      append_error_string (struct con *, size_t, char *, int, void *);
void     build_reply(struct  con *);
void     doreply(struct con *);
void     setlog(char *, size_t, char *);
void     initcon(struct con *, int, struct sockaddr *);
void     closecon(struct con *);
int      match(const char *, const char *);
void     nextstate(struct con *);
void     handler(struct con *);
void     handlew(struct con *, int one);

char hostname[MAXHOSTNAMELEN];
struct syslog_data sdata = SYSLOG_DATA_INIT;
char *reply = NULL;
char *nreply = "450";
char *spamd = "spamd IP-based SPAM blocker";
int greypipe[2];
FILE *grey;
time_t passtime = PASSTIME;
time_t greyexp = GREYEXP;
time_t whiteexp = WHITEEXP;
struct passwd *pw;
pid_t jail_pid = -1;

extern struct sdlist *blacklists;

int conffd = -1;
char *cb;
size_t cbs, cbu;

time_t t;

#define MAXCON 800
int maxcon = MAXCON;
int maxblack = MAXCON;
int blackcount;
int clients;
int debug;
int greylist;
int verbose;
int stutter = 1;
int window;
#define MAXTIME 400

void
usage(void)
{
	fprintf(stderr,
	    "usage: spamd [-45dgv] [-B maxblack] [-b address] [-c maxcon]\n");
	fprintf(stderr,
	    "             [-G mins:hours:hours] [-n name] [-p port]\n");
	fprintf(stderr,
	    "             [-r reply] [-s secs] [-w window]\n");
	exit(1);
}

char *
grow_obuf(struct con *cp, int off)
{
	char *tmp;

	tmp = realloc(cp->obuf, cp->osize + 8192);
	if (tmp == NULL) {
		free(cp->obuf);
		cp->obuf = NULL;
		cp->osize = 0;
		return (NULL);
	} else {
		cp->osize += 8192;
		cp->obuf = tmp;
		return (cp->obuf + off);
	}
}

int
parse_configline(char *line)
{
	char *cp, prev, *name, *msg;
	static char **av = NULL;
	static size_t ac = 0;
	size_t au = 0;
	int mdone = 0;

	if (debug > 0)
		printf("read config line %40s ...\n", line);

	name = line;

	for (cp = name; *cp && *cp != ';'; cp++)
		;
	if (*cp != ';')
		goto parse_error;
	*cp++ = '\0';
	msg = cp;
	if (*cp++ != '"')
		goto parse_error;
	prev = '\0';
	for (; !mdone; cp++) {
		switch (*cp) {
		case '\\':
			if (!prev)
				prev = *cp;
			else
				prev = '\0';
			break;
		case '"':
			if (prev != '\\') {
				cp++;
				if (*cp == ';') {
					mdone = 1;
					*cp = '\0';
				} else
					goto parse_error;
			}
			break;
		case '\0':
			goto parse_error;
		default:
			prev = '\0';
			break;
		}
	}

	do {
		if (ac == au) {
			char **tmp;

			tmp = realloc(av, (ac + 2048) * sizeof(char *));
			if (tmp == NULL) {
				free(av);
				av = NULL;
				ac = 0;
				return (-1);
			}
			av = tmp;
			ac += 2048;
		}
	} while ((av[au++] = strsep(&cp, ";")) != NULL);

	if (au < 2)
		goto parse_error;
	else
		sdl_add(name, msg, av, au - 1);
	return (0);

parse_error:
	if (debug > 0)
		printf("bogus config line - need 'tag;message;a/m;a/m;a/m...'\n");
	return (-1);
}

void
parse_configs(void)
{
	char *start, *end;
	int i;

	if (cbu == cbs) {
		char *tmp;

		tmp = realloc(cb, cbs + 8192);
		if (tmp == NULL) {
			if (debug > 0)
				perror("malloc()");
			free(cb);
			cb = NULL;
			cbs = cbu = 0;
			return;
		}
		cbs += 8192;
		cb = tmp;
	}
	cb[cbu++] = '\0';

	start = cb;
	end = start;
	for (i = 0; i < cbu; i++) {
		if (*end == '\n') {
			*end = '\0';
			if (end > start + 1)
				parse_configline(start);
			start = ++end;
		} else
			++end;
	}
	if (end > start + 1)
		parse_configline(start);
}

void
do_config(void)
{
	int n;

	if (debug > 0)
		printf("got configuration connection\n");

	if (cbu == cbs) {
		char *tmp;

		tmp = realloc(cb, cbs + 8192);
		if (tmp == NULL) {
			if (debug > 0)
				perror("malloc()");
			free(cb);
			cb = NULL;
			cbs = 0;
			goto configdone;
		}
		cbs += 8192;
		cb = tmp;
	}

	n = read(conffd, cb + cbu, cbs - cbu);
	if (debug > 0)
		printf("read %d config bytes\n", n);
	if (n == 0) {
		parse_configs();
		goto configdone;
	} else if (n == -1) {
		if (debug > 0)
			perror("read()");
		goto configdone;
	} else
		cbu += n;
	return;

configdone:
	cbu = 0;
	close(conffd);
	conffd = -1;
}

int
append_error_string(struct con *cp, size_t off, char *fmt, int af, void *ia)
{
	char sav = '\0';
	static int lastcont = 0;
	char *c = cp->obuf + off;
	char *s = fmt;
	size_t len = cp->osize - off;
	int i = 0;

	if (off == 0)
		lastcont = 0;

	if (lastcont != 0)
		cp->obuf[lastcont] = '-';
	snprintf(c, len, "%s ", nreply);
	i += strlen(c);
	lastcont = off + i - 1;
	if (*s == '"')
		s++;
	while (*s) {
		/*
		 * Make sure we at minimum, have room to add a
		 * format code (4 bytes), and a v6 address(39 bytes)
		 * and a byte saved in sav.
		 */
		if (i >= len - 46) {
			c = grow_obuf(cp, off);
			if (c == NULL)
				return (-1);
			len = cp->osize - (off + i);
		}

		if (c[i-1] == '\n') {
			if (lastcont != 0)
				cp->obuf[lastcont] = '-';
			snprintf(c + i, len, "%s ", nreply);
			i += strlen(c);
			lastcont = off + i - 1;
		}

		switch (*s) {
		case '\\':
		case '%':
			if (!sav)
				sav = *s;
			else {
				c[i++] = sav;
				sav = '\0';
				c[i] = '\0';
			}
			break;
		case '"':
		case 'A':
		case 'n':
			if (*(s+1) == '\0') {
				break;
			}
			if (sav == '\\' && *s == 'n') {
				c[i++] = '\n';
				sav = '\0';
				c[i] = '\0';
				break;
			} else if (sav == '\\' && *s == '"') {
				c[i++] = '"';
				sav = '\0';
				c[i] = '\0';
				break;
			} else if (sav == '%' && *s == 'A') {
				inet_ntop(af, ia, c + i, (len - i));
				i += strlen(c + i);
				sav = '\0';
				break;
			}
			/* fallthrough */
		default:
			if (sav)
			c[i++] = sav;
			c[i++] = *s;
			sav = '\0';
			c[i] = '\0';
			break;
		}
		s++;
	}
	return (i);
}

char *
loglists(struct con *cp)
{
	static char matchlists[80];
	struct sdlist **matches;
	int s = sizeof(matchlists) - 4;

	matchlists[0] = '\0';
	matches = cp->blacklists;
	if (matches == NULL)
		return(NULL);
	for (; *matches; matches++) {

		/* don't report an insane amount of lists in the logs.
		 * just truncate and indicate with ...
		 */
		if (strlen(matchlists) + strlen(matches[0]->tag) + 1
		    >= s)
			strlcat(matchlists, " ...", sizeof(matchlists));
		else {
			strlcat(matchlists, " ", s);
			strlcat(matchlists, matches[0]->tag, s);
		}
	}
	return matchlists;
}

void
build_reply(struct con *cp)
{
	struct sdlist **matches;
	int off = 0;

	matches = cp->blacklists;
	if (matches == NULL)
		goto nomatch;
	for (; *matches; matches++) {
		int used = 0;
		char *c = cp->obuf + off;
		int left = cp->osize - off;

		used = append_error_string(cp, off, matches[0]->string,
		    cp->af, cp->ia);
		if (used == -1)
			goto bad;
		off += used;
		left -= used;
		if (cp->obuf[off - 1] != '\n') {
			if (left < 1) {
				c = grow_obuf(cp, off);
				if (c == NULL)
					goto bad;
			}
			cp->obuf[off++] = '\n';
			cp->obuf[off] = '\0';
		}
	}
	return;
nomatch:
	/* No match. give generic reply */
	free(cp->obuf);
	cp->obuf = NULL;
	cp->osize = 0;
	if (cp->blacklists != NULL)
		asprintf(&cp->obuf,
		    "%s-Sorry %s\n"
		    "%s-You are trying to send mail from an address "
		    "listed by one\n"
		    "%s or more IP-based registries as being a SPAM source.\n",
		    nreply, cp->addr, nreply, nreply);
	else
		asprintf(&cp->obuf,
		    "451 Temporary failure, please try again later.\r\n");
	if (cp->obuf != NULL)
		cp->osize = strlen(cp->obuf) + 1;
	else
		cp->osize = 0;
	return;
bad:
	if (cp->obuf != NULL) {
		free(cp->obuf);
		cp->obuf = NULL;
		cp->osize = 0;
	}
}

void
doreply(struct con *cp)
{
	if (reply)
		snprintf(cp->obuf, cp->osize, "%s %s\n", nreply, reply);
	build_reply(cp);
}

void
setlog(char *p, size_t len, char *f)
{
	char *s;

	s = strsep(&f, ":");
	if (!f)
		return;
	while (*f == ' ' || *f == '\t')
		f++;
	s = strsep(&f, " \t");
	if (s == NULL)
		return;
	strlcpy(p, s, len);
	s = strsep(&p, " \t\n\r");
	if (s == NULL)
		return;
	s = strsep(&p, " \t\n\r");
	if (s)
		*s = '\0';
}

void
initcon(struct con *cp, int fd, struct sockaddr *sa)
{
	time_t t;
	char *tmp;
	int error;

	time(&t);
	free(cp->obuf);
	cp->obuf = NULL;
	cp->osize = 0;
	free(cp->blacklists);
	cp->blacklists = NULL;
	free(cp->lists);
	cp->lists = NULL;
	memset(cp, 0, sizeof(struct con));
	if (grow_obuf(cp, 0) == NULL)
		err(1, "malloc");
	cp->fd = fd;
	if (sa->sa_len > sizeof(cp->ss))
		errx(1, "sockaddr size");
	if (sa->sa_family != AF_INET)
		errx(1, "not supported yet");
	memcpy(&cp->ss, sa, sa->sa_len);
	cp->af = sa->sa_family;
	cp->ia = &((struct sockaddr_in *)sa)->sin_addr;
	cp->blacklists = sdl_lookup(blacklists, cp->af, cp->ia);
	cp->stutter = (greylist && cp->blacklists == NULL) ? 0 : stutter;
	error = getnameinfo(sa, sa->sa_len, cp->addr, sizeof(cp->addr), NULL, 0,
	    NI_NUMERICHOST);
	if (error)
		errx(1, "%s", gai_strerror(error));
	tmp = strdup(ctime(&t));
	if (tmp == NULL)
		err(1, "malloc");
	tmp[strlen(tmp) - 1] = '\0'; /* nuke newline */
	snprintf(cp->obuf, cp->osize,
		 "220 %s ESMTP %s; %s\r\n",
		 hostname, spamd, tmp);
	free(tmp);
	cp->op = cp->obuf;
	cp->ol = strlen(cp->op);
	cp->w = t + cp->stutter;
	cp->s = t;
	strlcpy(cp->rend, "\n", sizeof cp->rend);
	clients++;
	if (cp->blacklists != NULL) {
		blackcount++;
		if (greylist && blackcount > maxblack) {
			closecon(cp); /* close and free */
			return;
		}
		cp->lists = strdup(loglists(cp));
	}
	else
		cp->lists = NULL;
}

void
closecon(struct con *cp)
{
	time_t t;

	time(&t);
	syslog_r(LOG_INFO, &sdata, "%s: disconnected after %ld seconds.%s%s",
	    cp->addr, (long)(t - cp->s),
	    ((cp->lists == NULL) ? "" : " lists:"),
	    ((cp->lists == NULL) ? "": cp->lists));
	if (debug > 0)
		printf("%s connected for %ld seconds.\n", cp->addr,
		    (long)(t - cp->s));
	if (cp->lists != NULL) {
		free(cp->lists);
		cp->lists = NULL;
	}
	if (cp->blacklists != NULL) {
		blackcount--;
		free(cp->blacklists);
		cp->blacklists = NULL;
	}
	if (cp->obuf != NULL) {
		free(cp->obuf);
		cp->obuf = NULL;
		cp->osize = 0;
	}
	close(cp->fd);
	clients--;
	cp->fd = -1;
}

int
match(const char *s1, const char *s2)
{
	return (strncasecmp(s1, s2, strlen(s2)) == 0);
}

void
nextstate(struct con *cp)
{
	if (match(cp->ibuf, "QUIT") && cp->state < 99) {
		snprintf(cp->obuf, cp->osize, "221 %s\r\n", hostname);
		cp->op = cp->obuf;
		cp->ol = strlen(cp->op);
		cp->w = t + cp->stutter;
		cp->laststate = cp->state;
		cp->state = 99;
		return;
	}

	if (match(cp->ibuf, "RSET") && cp->state > 2 && cp->state < 50) {
		snprintf(cp->obuf, cp->osize,
		    "250 Ok to start over.\r\n");
		cp->op = cp->obuf;
		cp->ol = strlen(cp->op);
		cp->w = t + cp->stutter;
		cp->laststate = cp->state;
		cp->state = 2;
		return;
	}
	switch (cp->state) {
	case 0:
		/* banner sent; wait for input */
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->laststate = cp->state;
		cp->state = 1;
		cp->r = t;
		break;
	case 1:
		/* received input: parse, and select next state */
		if (match(cp->ibuf, "HELO") ||
		    match(cp->ibuf, "EHLO")) {
			snprintf(cp->obuf, cp->osize,
			    "250 Hello, spam sender. "
			    "Pleased to be wasting your time.\r\n");
			cp->op = cp->obuf;
			cp->ol = strlen(cp->op);
			cp->laststate = cp->state;
			cp->state = 2;
			cp->w = t + cp->stutter;
			break;
		}
		goto mail;
	case 2:
		/* sent 250 Hello, wait for input */
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->laststate = cp->state;
		cp->state = 3;
		cp->r = t;
		break;
	mail:
	case 3:
		if (match(cp->ibuf, "MAIL")) {
			setlog(cp->mail, sizeof cp->mail, cp->ibuf);
			snprintf(cp->obuf, cp->osize,
			    "250 You are about to try to deliver spam. "
			    "Your time will be spent, for nothing.\r\n");
			cp->op = cp->obuf;
			cp->ol = strlen(cp->op);
			cp->laststate = cp->state;
			cp->state = 4;
			cp->w = t + cp->stutter;
			break;
		}
		goto rcpt;
	case 4:
		/* sent 250 Sender ok */
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->laststate = cp->state;
		cp->state = 5;
		cp->r = t;
		break;
	rcpt:
	case 5:
		if (match(cp->ibuf, "RCPT")) {
			setlog(cp->rcpt, sizeof(cp->rcpt), cp->ibuf);
			snprintf(cp->obuf, cp->osize,
			    "250 This is hurting you more than it is "
			    "hurting me.\r\n");
			cp->op = cp->obuf;
			cp->ol = strlen(cp->op);
			cp->laststate = cp->state;
			cp->state = 6;
			cp->w = t + cp->stutter;
			if (cp->mail[0] && cp->rcpt[0]) {
				if (verbose)
					syslog_r(LOG_INFO, &sdata,
					    "(%s) %s: %s -> %s",
					    cp->blacklists ? "BLACK" : "GREY",
					    cp->addr, cp->mail,
					    cp->rcpt);
				if (debug)
					fprintf(stderr, "(%s) %s: %s -> %s\n",
					    cp->blacklists ? "BLACK" : "GREY",
					    cp->addr, cp->mail, cp->rcpt);
				if (greylist && cp->blacklists == NULL) {
					/* send this info to the greylister */
					fprintf(grey, "IP:%s\nFR:%s\nTO:%s\n",
					    cp->addr, cp->mail, cp->rcpt);
					fflush(grey);
					cp->laststate = cp->state;
					cp->state = 98;
					goto done;
				}
			}
			break;
		}
		goto spam;
	case 6:
		/* sent 250 blah */
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->laststate = cp->state;
		cp->state = 5;
		cp->r = t;
		break;

	spam:
	case 50:
		if (match(cp->ibuf, "DATA")) {
			snprintf(cp->obuf, cp->osize,
			    "354 Enter spam, end with \".\" on a line by "
			    "itself\r\n");
			cp->state = 60;
			if (window && setsockopt(cp->fd, SOL_SOCKET, SO_RCVBUF,
			    &window, sizeof(window)) == -1) {
				syslog_r(LOG_DEBUG, &sdata,"setsockopt: %m");
				/* don't fail if this doesn't work. */
			}
		} else {
			snprintf(cp->obuf, cp->osize,
			    "500 5.5.1 Command unrecognized\r\n");
			cp->state = cp->laststate;
		}
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->op = cp->obuf;
		cp->ol = strlen(cp->op);
		cp->w = t + cp->stutter;
		break;
	case 60:
		/* sent 354 blah */
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->laststate = cp->state;
		cp->state = 70;
		cp->r = t;
		break;
	case 70: {
		char *p, *q;

		for (p = q = cp->ibuf; q <= cp->ip; ++q)
			if (*q == '\n' || q == cp->ip) {
				*q = 0;
				if (q > p && q[-1] == '\r')
					q[-1] = 0;
				if (!strcmp(p, ".") ||
				    (cp->data_body && ++cp->data_lines >= 10)) {
					cp->laststate = cp->state;
					cp->state = 98;
					goto done;
				}
				if (!cp->data_body && !*p)
					cp->data_body = 1;
				if (verbose && cp->data_body && *p)
					syslog_r(LOG_DEBUG, &sdata, "%s: "
					    "Body: %s", cp->addr, p);
				else if (verbose && (match(p, "FROM:") ||
				    match(p, "TO:") || match(p, "SUBJECT:")))
					syslog_r(LOG_INFO, &sdata, "%s: %s",
					    cp->addr, p);
				p = ++q;
			}
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->r = t;
		break;
	}
	done:
	case 98:
		doreply(cp);
		cp->op = cp->obuf;
		cp->ol = strlen(cp->op);
		cp->w = t + cp->stutter;
		cp->laststate = cp->state;
		cp->state = 99;
		break;
	case 99:
		closecon(cp);
		break;
	default:
		errx(1, "illegal state %d", cp->state);
		break;
	}
}

void
handler(struct con *cp)
{
	int end = 0;
	int n;

	if (cp->r) {
		n = read(cp->fd, cp->ip, cp->il);
		if (n == 0)
			closecon(cp);
		else if (n == -1) {
			if (debug > 0)
				perror("read()");
			closecon(cp);
		} else {
			cp->ip[n] = '\0';
			if (cp->rend[0])
				if (strpbrk(cp->ip, cp->rend))
					end = 1;
			cp->ip += n;
			cp->il -= n;
		}
	}
	if (end || cp->il == 0) {
		while (cp->ip > cp->ibuf &&
		    (cp->ip[-1] == '\r' || cp->ip[-1] == '\n'))
			cp->ip--;
		*cp->ip = '\0';
		cp->r = 0;
		nextstate(cp);
	}
}

void
handlew(struct con *cp, int one)
{
	int n;

	if (cp->w) {
		if (*cp->op == '\n' && !cp->sr) {
			/* insert \r before \n */
			n = write(cp->fd, "\r", 1);
			if (n == 0) {
				closecon(cp);
				goto handled;
			} else if (n == -1) {
				if (debug > 0 && errno != EPIPE)
					perror("write()");
				closecon(cp);
				goto handled;
			}
		}
		if (*cp->op == '\r')
			cp->sr = 1;
		else
			cp->sr = 0;
		n = write(cp->fd, cp->op, (one && cp->stutter) ? 1 : cp->ol);
		if (n == 0)
			closecon(cp);
		else if (n == -1) {
			if (debug > 0 && errno != EPIPE)
				perror("write()");
			closecon(cp);
		} else {
			cp->op += n;
			cp->ol -= n;
		}
	}
handled:
	cp->w = t + cp->stutter;
	if (cp->ol == 0) {
		cp->w = 0;
		nextstate(cp);
	}
}

int
main(int argc, char *argv[])
{
	fd_set *fdsr = NULL, *fdsw = NULL;
	struct sockaddr_in sin;
	struct sockaddr_in lin;
	int ch, s, s2, conflisten = 0, i, omax = 0, one = 1;
	socklen_t sinlen;
	u_short port, cfg_port;
	struct servent *ent;
	struct rlimit rlp;
	char *bind_address = NULL;

	tzset();
	openlog_r("spamd", LOG_PID | LOG_NDELAY, LOG_DAEMON, &sdata);

	if ((ent = getservbyname("spamd", "tcp")) == NULL)
		errx(1, "Can't find service \"spamd\" in /etc/services");
	port = ntohs(ent->s_port);
	if ((ent = getservbyname("spamd-cfg", "tcp")) == NULL)
		errx(1, "Can't find service \"spamd-cfg\" in /etc/services");
	cfg_port = ntohs(ent->s_port);

	if (gethostname(hostname, sizeof hostname) == -1)
		err(1, "gethostname");

	while ((ch = getopt(argc, argv, "45b:c:B:p:dgG:r:s:n:vw:")) != -1) {
		switch (ch) {
		case '4':
			nreply = "450";
			break;
		case '5':
			nreply = "550";
			break;
		case 'b':
			bind_address = optarg;
			break;
		case 'B':
			i = atoi(optarg);
			maxblack = i;
			break;
		case 'c':
			i = atoi(optarg);
			if (i > MAXCON)
				usage();
			maxcon = i;
			break;
		case 'p':
			i = atoi(optarg);
			port = i;
			break;
		case 'd':
			debug = 1;
			break;
		case 'g':
			greylist = 1;
			break;
		case 'G':
			if (sscanf(optarg, "%lld:%lld:%lld", &passtime,
			    &greyexp, &whiteexp) != 3)
				usage();
			/* convert to seconds from minutes */
			passtime *= 60;
			/* convert to seconds from hours */
			whiteexp *= (60 * 60);
			/* convert to seconds from hours */
			greyexp *= (60 * 60);
			break;
		case 'r':
			reply = optarg;
			break;
		case 's':
			i = atoi(optarg);
			if (i < 0 || i > 10)
				usage();
			stutter = i;
			break;
		case 'n':
			spamd = optarg;
			break;
		case 'v':
			verbose = 1;
			break;
		case 'w':
			window = atoi(optarg);
			if (window <= 0)
				usage();
			break;
		default:
			usage();
			break;
		}
	}

	if (!greylist)
		maxblack = maxcon;
	else if (maxblack > maxcon)
		usage();

	rlp.rlim_cur = rlp.rlim_max = maxcon + 15;
	if (setrlimit(RLIMIT_NOFILE, &rlp) == -1)
		err(1, "setrlimit");

	con = calloc(maxcon, sizeof(*con));
	if (con == NULL)
		err(1, "calloc");

	con->obuf = malloc(8192);

	if (con->obuf == NULL)
		err(1, "malloc");
	con->osize = 8192;

	for (i = 0; i < maxcon; i++)
		con[i].fd = -1;

	signal(SIGPIPE, SIG_IGN);

	s = socket(AF_INET, SOCK_STREAM, 0);
	if (s == -1)
		err(1, "socket");

	if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &one,
	    sizeof(one)) == -1)
		return (-1);

	conflisten = socket(AF_INET, SOCK_STREAM, 0);
	if (conflisten == -1)
		err(1, "socket");

	if (setsockopt(conflisten, SOL_SOCKET, SO_REUSEADDR, &one,
	    sizeof(one)) == -1)
		return (-1);

	memset(&sin, 0, sizeof sin);
	sin.sin_len = sizeof(sin);
	if (bind_address) {
		if (inet_pton(AF_INET, bind_address, &sin.sin_addr) != 1)
			err(1, "inet_pton");
	} else
		sin.sin_addr.s_addr = htonl(INADDR_ANY);
	sin.sin_family = AF_INET;
	sin.sin_port = htons(port);

	if (bind(s, (struct sockaddr *)&sin, sizeof sin) == -1)
		err(1, "bind");

	memset(&lin, 0, sizeof sin);
	lin.sin_len = sizeof(sin);
	lin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	lin.sin_family = AF_INET;
	lin.sin_port = htons(cfg_port);

	if (bind(conflisten, (struct sockaddr *)&lin, sizeof lin) == -1)
		err(1, "bind local");

	pw = getpwnam("_spamd");
	if (!pw)
		pw = getpwnam("nobody");

	if (debug == 0) {
		if (daemon(1, 1) == -1)
			err(1, "daemon");
	}

	if (greylist) {
		maxblack = (maxblack >= maxcon) ? maxcon - 100 : maxblack;
		if (maxblack < 0)
			maxblack = 0;

		/* open pipe to talk to greylister */
		if (pipe(greypipe) == -1) {
			syslog(LOG_ERR, "pipe (%m)");
			exit(1);
		}
		jail_pid = fork();
		switch(jail_pid) {
		case -1:
			syslog(LOG_ERR, "fork (%m)");
			exit(1);
		case 0:
			/* child - continue */
			close(greypipe[0]);
			grey = fdopen(greypipe[1], "w");
			if (grey == NULL) {
				syslog(LOG_ERR, "fdopen (%m)");
				_exit(1);
			}
			goto jail;
		}
		/* parent - run greylister */
		close(greypipe[1]);
		grey = fdopen(greypipe[0], "r");
		if (grey == NULL) {
			syslog(LOG_ERR, "fdopen (%m)");
			exit(1);
		}
		return(greywatcher());
		/* NOTREACHED */
	}

jail:
	if (chroot("/var/empty") == -1 || chdir("/") == -1) {
		syslog(LOG_ERR, "cannot chdir to /var/empty.");
		exit(1);
	}

	if (pw) {
		setgroups(1, &pw->pw_gid);
		setegid(pw->pw_gid);
		setgid(pw->pw_gid);
		seteuid(pw->pw_uid);
		setuid(pw->pw_uid);
	}

	if (listen(s, 10) == -1)
		err(1, "listen");

	if (listen(conflisten, 10) == -1)
		err(1, "listen");

	if (debug != 0)
		printf("listening for incoming connections.\n");
	syslog_r(LOG_WARNING, &sdata, "listening for incoming connections.");

	while (1) {
		struct timeval tv, *tvp;
		int max, i, n;
		int writers;

		max = MAX(s, conflisten);
		max = MAX(max, conffd);

		time(&t);
		for (i = 0; i < maxcon; i++)
			if (con[i].fd != -1)
				max = MAX(max, con[i].fd);

		if (max > omax) {
			free(fdsr);
			fdsr = NULL;
			free(fdsw);
			fdsw = NULL;
			fdsr = (fd_set *)calloc(howmany(max+1, NFDBITS),
			    sizeof(fd_mask));
			if (fdsr == NULL)
				err(1, "calloc");
			fdsw = (fd_set *)calloc(howmany(max+1, NFDBITS),
			    sizeof(fd_mask));
			if (fdsw == NULL)
				err(1, "calloc");
			omax = max;
		} else {
			memset(fdsr, 0, howmany(max+1, NFDBITS) *
			    sizeof(fd_mask));
			memset(fdsw, 0, howmany(max+1, NFDBITS) *
			    sizeof(fd_mask));
		}

		writers = 0;
		for (i = 0; i < maxcon; i++) {
			if (con[i].fd != -1 && con[i].r) {
				if (con[i].r + MAXTIME <= t) {
					closecon(&con[i]);
					continue;
				}
				FD_SET(con[i].fd, fdsr);
			}
			if (con[i].fd != -1 && con[i].w) {
				if (con[i].w + MAXTIME <= t) {
					closecon(&con[i]);
					continue;
				}
				if (con[i].w <= t)
					FD_SET(con[i].fd, fdsw);
				writers = 1;
			}
		}
		FD_SET(s, fdsr);

		/* only one active config conn at a time */
		if (conffd == -1)
			FD_SET(conflisten, fdsr);
		else
			FD_SET(conffd, fdsr);

		if (writers == 0) {
			tvp = NULL;
		} else {
			tv.tv_sec = 1;
			tv.tv_usec = 0;
			tvp = &tv;
		}

		n = select(max+1, fdsr, fdsw, NULL, tvp);
		if (n == -1) {
			if (errno != EINTR)
				err(1, "select");
			continue;
		}
		if (n == 0)
			continue;

		for (i = 0; i < maxcon; i++) {
			if (con[i].fd != -1 && FD_ISSET(con[i].fd, fdsr))
				handler(&con[i]);
			if (con[i].fd != -1 && FD_ISSET(con[i].fd, fdsw))
				handlew(&con[i], clients + 5 < maxcon);
		}
		if (FD_ISSET(s, fdsr)) {
			sinlen = sizeof(sin);
			s2 = accept(s, (struct sockaddr *)&sin, &sinlen);
			if (s2 == -1)
				/* accept failed, they may try again */
				continue;
			for (i = 0; i < maxcon; i++)
				if (con[i].fd == -1)
					break;
			if (i == maxcon)
				close(s2);
			else {
				initcon(&con[i], s2, (struct sockaddr *)&sin);
				syslog_r(LOG_INFO, &sdata,
				    "%s: connected (%d/%d)%s%s",
				    con[i].addr, clients, blackcount,
				    ((con[i].lists == NULL) ? "" :
				    ", lists:"),
				    ((con[i].lists == NULL) ? "":
				    con[i].lists));
			}
		}
		if (FD_ISSET(conflisten, fdsr)) {
			sinlen = sizeof(lin);
			conffd = accept(conflisten, (struct sockaddr *)&lin,
			    &sinlen);
			if (conffd == -1)
				/* accept failed, they may try again */
				continue;
			else if (ntohs(lin.sin_port) >= IPPORT_RESERVED) {
				close(conffd);
				conffd = -1;
			}
		}
		if (conffd != -1 && FD_ISSET(conffd, fdsr)) {
			do_config();
		}

	}
	exit(1);
}
@


1.5
log
@merge; fix; whitespace; bump libc level
XXX untested
@
text
@d1 2
a2 2
/**	$MirBSD: src/libexec/spamd/spamd.c,v 1.4 2004/06/20 02:56:44 tg Stab $ */
/*	$OpenBSD: spamd.c,v 1.73 2004/10/05 15:20:30 beck Exp $	*/
d52 1
a52 1
__RCSID("$MirBSD: src/libexec/spamd/spamd.c,v 1.4 2004/06/20 02:56:44 tg Stab $");
d631 1
a631 1
		snprintf(cp->obuf, cp->osize, "221 %s\n", hostname);
d640 10
@


1.4
log
@first (user-land) part of time_t64 building
* gcc and egcs are only half-made, using GCC_FOR_TARGET=pgcc/gcc
  (I hope I won't lose Ada now...)
* perl isn't made at all (miniperl...)
* ndat is obsolete anyways
@
text
@d1 2
a2 2
/* $MirBSD$ */
/* $OpenBSD: spamd.c,v 1.66 2004/04/03 01:37:18 dhartmei Exp $	*/
a47 2
#include <sys/types.h>
#include <machine/endian.h>
d52 1
a52 1
__RCSID("$MirBSD$");
d59 1
a59 1
	struct sockaddr_in sin;
d98 1
a98 1
void     initcon(struct con *, int, struct sockaddr_in *);
d487 1
a487 1
		    "450 Temporary failure, please try again later.\r\n");
d532 1
a532 1
initcon(struct con *cp, int fd, struct sockaddr_in *sin)
d536 1
d550 7
a556 3
	memcpy(&cp->sin, sin, sizeof(struct sockaddr_in));
	cp->af = sin->sin_family;
	cp->ia = (void *) &cp->sin.sin_addr;
d559 4
a562 1
	strlcpy(cp->addr, inet_ntoa(sin->sin_addr), sizeof(cp->addr));
d630 10
d709 1
a709 1
					syslog_r(LOG_DEBUG, &sdata,
d1137 1
a1137 1
			fdsr = NULL;
d1216 1
a1216 1
				initcon(&con[i], s2, &sin);
@


1.3
log
@a much easier merge:
* pull OpenBSD 3.5-current
* login_passwd needs not be SUID root, because we don't have YP
* regen Makefile
@
text
@d1 2
a2 1
/*	$OpenBSD: spamd.c,v 1.66 2004/04/03 01:37:18 dhartmei Exp $	*/
d54 2
d937 2
a938 2
			if (sscanf(optarg, "%d:%d:%d", &passtime, &greyexp,
			    &whiteexp) != 3)
d972 1
a972 1
	
d1056 1
a1056 1
		case -1: 
@


1.2
log
@Jumbo patch from wbx@@ to replace the
bcopy(3), bcmp(3) and bzero(3) func-
tions, having been deprecated earli-
er, by their ISO counterparts, name-
ly memmove(3) and the gcc3-optimized
memcmp(3) and memset(3) functions.

I didn't read every single line (be-
cause of the time of day), but looks
fine and builds through. I just nee-
ded to nuke three cases of whitespa-
ce at EOL. Good work wbx@@.

I've also sprinkled in a few patches
of mine addressing the issue that in
some kernel header files, bcopy() is
used as well... also there have been
quite some string cleaning fixes and
a missing header.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.52 2003/11/09 07:35:25 dhartmei Exp $	*/
d51 1
d61 2
a62 1
	char mail[64], rcpt[64];
a76 1
	int obufalloc;
d84 2
d94 2
a95 2
char    *build_reply(struct  con *);
char    *doreply(struct con *);
d109 7
d127 2
d131 1
a136 1

d141 3
a143 2
	    "usage: spamd [-45dv] [-c maxcon] [-n name] [-p port] [-r reply] "
	    "[-s secs]\n");
d145 1
a145 1
	    "             [-w window]\n");
a153 2
	if (!cp->obufalloc)
		cp->obuf = NULL;
a158 1
		cp->obufalloc = 0;
a162 1
		cp->obufalloc = 1;
d164 1
a164 1
	}	
a166 1

a325 1

a413 1

d415 1
a415 1
build_reply(struct con *cp)
d417 1
d419 1
a419 2
	static char matchlists[80];
	int off = 0;
d422 3
a424 9

	matches = sdl_lookup(blacklists, cp->af, cp->ia);
	if (matches == NULL) {
		if (cp->osize)
			free(cp->obuf);
		cp->obuf = NULL;
		cp->osize = 0;
		goto bad;
	}
a425 3
		int used = 0, s = sizeof(matchlists) - 4;
		char *c = cp->obuf + off;
		int left = cp->osize - off;
d437 18
d471 21
a491 1
	return matchlists;
d493 5
a497 13
	/* Out of memory, or no match. give generic reply */
	asprintf(&cp->obuf,
	    "%s-Sorry %s\n"
	    "%s-You are trying to send mail from an address listed by one\n"
	    "%s or more IP-based registries as being a SPAM source.\n",
	    nreply, cp->addr, nreply, nreply);
	if (cp->obuf == NULL) {
		/* we're having a really bad day.. */
		cp->obufalloc = 0; /* know not to free or mangle */
		cp->obuf = "450 Try again\n";
	} else
		cp->osize = strlen(cp->obuf) + 1;
	return matchlists;
d500 1
a500 1
char *
d503 1
a503 3
	if (reply) {
		if (!cp->obufalloc)
			errx(1, "shouldn't happen");
d505 1
a505 3
		return("");
	}
	return (build_reply(cp));
d534 1
d537 7
a543 4
	if (cp->obufalloc) {
		free(cp->obuf);
		cp->obuf = NULL;
	}
d551 2
d554 4
d559 3
a561 2
	    "220 %s ESMTP %s; %s",
	    hostname, spamd, ctime(&t));
d564 1
a564 1
	cp->w = t + stutter;
d568 10
d586 4
a589 2
	syslog_r(LOG_INFO, &sdata, "%s: disconnected after %ld seconds.",
	    cp->addr, (long)(t - cp->s));
d597 6
a602 1
	if (cp->osize > 0 && cp->obufalloc) {
d636 1
a636 1
			    "Pleased to be wasting your time.\n");
d641 1
a641 1
			cp->w = t + stutter;
d659 1
a659 1
			    "Your time will be spent, for nothing.\n");
d664 1
a664 1
			cp->w = t + stutter;
d682 1
a682 1
			    "hurting me.\n");
d687 22
a708 4
			cp->w = t + stutter;
			if (cp->mail[0] && cp->rcpt[0])
				syslog_r(LOG_INFO, &sdata, "%s: %s -> %s",
				    cp->addr, cp->mail, cp->rcpt);
d726 1
a726 1
			    "itself\n");
d728 5
d735 1
a735 1
			    "500 5.5.1 Command unrecognized\n");
d742 1
a742 1
		cp->w = t + stutter;
d745 32
a776 15
		if (!strcmp(cp->ibuf, ".") ||
		    (cp->data_body && ++cp->data_lines >= 10)) {
		        cp->laststate = cp->state;
			cp->state = 98;
			goto done;
		}
		if (!cp->data_body && !*cp->ibuf)
			cp->data_body = 1;
		if (verbose && cp->data_body && *cp->ibuf)
			syslog_r(LOG_DEBUG, &sdata, "%s: Body: %s", cp->addr,
			    cp->ibuf);
		else if (verbose && (match(cp->ibuf, "FROM:") || 
		     match(cp->ibuf, "TO:") || match(cp->ibuf, "SUBJECT:")))
			syslog_r(LOG_INFO, &sdata, "%s: %s", cp->addr,
			    cp->ibuf);
d781 1
d784 1
a784 4
		cp->lists = strdup(doreply(cp));
		if (cp->lists != NULL)
			syslog_r(LOG_INFO, &sdata, "%s: matched lists: %s",
			    cp->addr, cp->lists);
d787 1
a787 1
		cp->w = t + stutter;
d808 1
a808 1
		if (n == 0) {
d810 1
a810 1
		} else if (n == -1) {
a828 3
		if (verbose)
			syslog_r(LOG_DEBUG, &sdata, "%s: says '%s'", cp->addr,
			    cp->ibuf);
d839 1
a839 1
		if (*cp->op == '\n') {
d852 6
a857 2
		n = write(cp->fd, cp->op, one ? 1 : cp->ol);
		if (n == 0) {
d859 1
a859 1
		} else if (n == -1) {
d869 1
a869 1
	cp->w = t + stutter;
d882 2
a883 3
	struct passwd *pw;
	int ch, s, s2, conflisten = 0, i, omax = 0;
	int sinlen, one = 1;
d887 1
d902 1
a902 1
	while ((ch = getopt(argc, argv, "45c:p:dr:s:n:vw:")) != -1) {
d910 7
d930 14
d952 1
d969 5
d975 1
a975 1
	rlp.rlim_cur = rlp.rlim_max = maxcon + 7;
a1001 6
	if (window && setsockopt(s, SOL_SOCKET, SO_RCVBUF, &window,
	    sizeof(window)) == -1) {
		syslog(LOG_ERR, "setsockopt: %s", strerror(errno));
		return (-1);
	}

d1012 5
a1016 1
	sin.sin_addr.s_addr = htonl(INADDR_ANY);
d1036 42
d1097 1
a1097 4
	if (debug == 0) {
		if (daemon(1, 1) == -1)
			err(1, "fork");
	} else
d1116 1
d1118 1
d1198 7
a1204 2
				syslog_r(LOG_INFO, &sdata, "%s: connected (%d)",
				    con[i].addr, clients);
d1211 1
a1211 1
			if (conffd == -1) 
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.26 2003/03/20 01:39:36 david Exp $	*/
d31 1
d55 1
d77 1
d81 2
d91 2
a92 2
void     build_reply(struct  con *);
void     doreply(struct con *);
d96 1
a96 1
int      match(char *, char *);
d115 1
a115 1
#define MAXCON 200
d119 3
d129 4
a132 1
	    "usage: spamd [-45d] [-c maxcon] [-n name] [-p port] [-r reply]\n");
d144 7
a150 1
	if (tmp != NULL) {
d155 1
a155 2
	}
	return (NULL);
d213 4
a216 1
			if (tmp == NULL)
d218 1
d320 1
a320 1
append_error_string (struct con *cp, size_t off, char *fmt, int af, void *ia)
d334 2
a335 1
	i += snprintf(c, len, "%s ", nreply);
d348 1
a348 1
				goto no_mem;
d355 2
a356 1
			i += snprintf(c + i, len, "%s ", nreply);
a404 7
no_mem:
	/* Out of memory, free obuf and bail, caller must deal */
	if (cp->osize)
		free(cp->obuf);
	cp->obuf = NULL;
	cp->osize = 0;
	return (-1);
d408 1
a408 1
void
d412 1
d415 2
d426 1
a426 1
		int used = 0;
d430 10
d449 1
a449 5
				if (c == NULL) {
					if (cp->osize)
						free(cp->obuf);
					cp->obuf = NULL;
					cp->osize = 0;
a450 1
				}
d456 1
a456 1
	return;
d470 1
d473 1
a473 1
void
d480 1
a480 1
		return;
d482 1
a482 1
	build_reply(cp);
d491 1
a491 1
	if (!s)
d493 2
d517 1
a517 1
	bzero(cp, sizeof(struct con));
d530 1
a530 1
	cp->w = t + 1;
d532 1
a532 1
	strlcpy(cp->rend, "\n\r", sizeof cp->rend);
d539 1
a539 2
	if (debug > 0) {
		time_t t;
d541 9
a549 2
		time(&t);
		printf("%s connected for %d seconds.\n", cp->addr, t - cp->s);
d562 1
a562 1
match(char *s1, char *s2)
d575 1
d588 1
d590 1
a590 1
			cp->w = t + 1;
d598 1
d611 1
d613 1
a613 1
			cp->w = t + 1;
d621 1
d634 1
d636 4
a639 1
			cp->w = t + 1;
d647 2
a648 1
		cp->state = 50;
d654 42
a695 3
		syslog_r(LOG_INFO, &sdata, "%s: %s -> %s",
		    cp->addr, cp->mail, cp->rcpt);
		doreply(cp);
d698 2
a700 1
		cp->w = t + 1;
d715 1
a715 1
	int i, n;
d726 1
d728 2
a729 3
				for (i = 0; i < n; i++)
					if (strchr(cp->rend, cp->op[i]))
						end = 1;
d735 3
d740 3
d779 1
a779 1
	cp->w = t + 1;
d797 1
d812 1
a812 1
	while ((ch = getopt(argc, argv, "45c:p:dr:n:")) != -1) {
d836 5
d844 8
d858 4
d885 6
d945 1
d961 2
a962 4
			if (fdsr)
				free(fdsr);
			if (fdsw)
				free(fdsw);
d1015 5
a1019 2
		if (n == -1 && errno == EINTR)
			err(1, "select");
d1032 3
a1034 5
			if (s2 == -1) {
				if (errno == EINTR)
					continue;
				err(1, "accept");
			}
d1040 1
a1040 1
			else
d1042 3
d1050 4
a1053 5
			if (conffd == -1) {
				if (errno == EINTR)
					continue;
				err(1, "accept");
			} else if (ntohs(lin.sin_port) >= IPPORT_RESERVED) {
a1056 1
				
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD repository of CTM 3155 (roughly today at noon).
Mostly in order to go 3.3-current and ease further merges of
both OpenBSD and ELFdiffs after the MirBSD has been enabled
to build again.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.28 2003/03/28 20:35:24 beck Exp $	*/
d86 2
a87 2
char    *build_reply(struct  con *);
char    *doreply(struct con *);
d393 1
a393 1
char *
a396 1
	static char matchlists[80];
a398 2
	matchlists[0] = '\0';

d408 1
a408 1
		int used = 0, s = sizeof(matchlists) - 4; 
a411 10
		/* don't report an insane amount of lists in the logs.
		 * just truncate and indicate with ...
		 */
		if (strlen(matchlists) + strlen(matches[0]->tag) + 1 
		    >= s) 
			strlcat(matchlists, " ...", sizeof(matchlists));
		else {
			strlcat(matchlists, " ", s);
			strlcat(matchlists, matches[0]->tag, s);
		}
d433 1
a433 1
	return matchlists;
a446 1
	return matchlists;
d449 1
a449 1
char *
d456 1
a456 1
		return("");
d458 1
a458 1
	return (build_reply(cp));
a468 2
	while (*f == ' ' || *f == '\t')
		f++;
d612 3
a614 2
		syslog_r(LOG_INFO, &sdata, "%s: %s -> %s %ldsec by lists:%s",
		    cp->addr, cp->mail, cp->rcpt, (long)(t - cp->s), doreply(cp));
@


1.1.1.3
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.30 2003/04/08 22:09:53 vincent Exp $	*/
a74 1
	char *lists;
a534 4
	if (cp->lists != NULL) {
		free(cp->lists);	  
		cp->lists = NULL;
	}
d628 2
a629 1
		cp->lists = strdup(doreply(cp));
a635 3
		syslog_r(LOG_INFO, &sdata, "%s: %s -> %s %ldsec by lists:%s",
		    cp->addr, cp->mail, cp->rcpt, (long)(t - cp->s), 
		    (cp->lists != NULL) ? cp->lists : "");
d919 2
a920 5
		if (n == -1) {
			if (errno != EINTR)
				err(1, "select");
			continue;
		}
@


1.1.1.4
log
@Import OpenBSD source with the "new" command line as well,
in order to be able to provide a MirBSD release which bases
upon a fairly current OpenBSD base source code tree deemed
stable enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.32 2003/04/15 07:16:14 deraadt Exp $	*/
a30 1
#include <sys/resource.h>
d301 1
a301 1
append_error_string(struct con *cp, size_t off, char *fmt, int af, void *ia)
d315 1
a315 2
	snprintf(c, len, "%s ", nreply);
	i += strlen(c);
d335 1
a335 2
			snprintf(c + i, len, "%s ", nreply);
			i += strlen(c);
a730 1
	struct rlimit rlp;
a776 4

	rlp.rlim_cur = rlp.rlim_max = maxcon + 7;
	if (setrlimit(RLIMIT_NOFILE, &rlp) == -1)
		err(1, "setrlimit");
@


1.1.1.5
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.34 2003/05/17 02:41:19 beck Exp $	*/
d485 1
a485 1
	if (!f)
d658 1
a658 1
	int n;
a668 1
			cp->ip[n] = '\0';
d670 3
a672 2
				if (strpbrk(cp->ip, cp->rend))
					end = 1;
@


1.1.1.6
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.35 2003/06/11 14:24:46 deraadt Exp $	*/
d93 1
a93 1
int      match(const char *, const char *);
d554 1
a554 1
match(const char *s1, const char *s2)
@


1.1.1.7
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.36 2003/07/29 18:39:23 deraadt Exp $	*/
d415 1
a415 1
		int used = 0, s = sizeof(matchlists) - 4;
d422 2
a423 2
		if (strlen(matchlists) + strlen(matches[0]->tag) + 1
		    >= s)
d540 1
a540 1
		free(cp->lists);
d644 1
a644 1
		    cp->addr, cp->mail, cp->rcpt, (long)(t - cp->s),
d976 1
@


1.1.1.8
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.40 2003/08/26 18:30:03 dhartmei Exp $	*/
a79 2
	int data_lines;
	int data_body;
a115 1
int stutter = 1;
d123 1
a123 2
	    "usage: spamd [-45d] [-c maxcon] [-n name] [-p port] [-r reply] "
	    "[-s secs]\n");
d524 1
a524 1
	cp->w = t + stutter;
d526 1
a526 1
	strlcpy(cp->rend, "\n", sizeof cp->rend);
d533 2
a534 1
	time_t t;
d536 3
a538 6
	time(&t);
	syslog_r(LOG_INFO, &sdata, "%s: disconnected after %ld seconds.",
	    cp->addr, (long)(t - cp->s));
	if (debug > 0)
		printf("%s connected for %ld seconds.\n", cp->addr,
		    (long)(t - cp->s));
d580 1
a580 1
			cp->w = t + stutter;
d601 1
a601 1
			cp->w = t + stutter;
d622 1
a622 4
			cp->w = t + stutter;
			if (cp->mail[0] && cp->rcpt[0])
				syslog_r(LOG_INFO, &sdata, "%s: %s -> %s",
				    cp->addr, cp->mail, cp->rcpt);
a635 36
		if (match(cp->ibuf, "DATA")) {
			snprintf(cp->obuf, cp->osize,
			    "354 Enter spam, end with \".\" on a line by "
			    "itself\n");
			cp->state = 60;
		} else {
			snprintf(cp->obuf, cp->osize,
			    "500 5.5.1 Command unrecognized\n");
		}
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->op = cp->obuf;
		cp->ol = strlen(cp->op);
		cp->w = t + stutter;
		break;
	case 60:
		if (!strcmp(cp->ibuf, ".") ||
		    (cp->data_body && ++cp->data_lines >= 10)) {
			cp->state = 98;
			goto done;
		}
		if (!cp->data_body && !*cp->ibuf)
			cp->data_body = 1;
		if (cp->data_body && *cp->ibuf)
			syslog_r(LOG_INFO, &sdata, "%s: Body: %s", cp->addr,
			    cp->ibuf);
		else if (match(cp->ibuf, "FROM:") || match(cp->ibuf, "TO:") ||
		    match(cp->ibuf, "SUBJECT:"))
			syslog_r(LOG_INFO, &sdata, "%s: %s", cp->addr,
			    cp->ibuf);
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->r = t;
		break;
	done:
	case 98:
a636 3
		if (cp->lists != NULL)
			syslog_r(LOG_INFO, &sdata, "%s: matched lists: %s",
			    cp->addr, cp->lists);
a638 1
		cp->w = t + stutter;
d640 1
d643 3
a677 3
		while (cp->ip > cp->ibuf &&
		    (cp->ip[-1] == '\r' || cp->ip[-1] == '\n'))
			cp->ip--;
a679 2
		syslog_r(LOG_DEBUG, &sdata, "%s: says '%s'", cp->addr,
		    cp->ibuf);
d716 1
a716 1
	cp->w = t + stutter;
d749 1
a749 1
	while ((ch = getopt(argc, argv, "45c:p:dr:s:n:")) != -1) {
a772 5
		case 's':
			i = atoi(optarg);
			if (i < 0 || i > 10)
				usage();
			stutter = i;
a808 6
	one = 1;
	if (setsockopt(s, SOL_SOCKET, SO_RCVBUF, &one, sizeof(one)) == -1) {
		syslog(LOG_ERR, "setsockopt: %s", strerror(errno));
		return (-1);
	}

a862 1
	syslog_r(LOG_WARNING, &sdata, "listening for incoming connections.");
d961 1
a961 1
			else {
a962 3
				syslog_r(LOG_INFO, &sdata, "%s: connected (%d)",
				    con[i].addr, clients);
			}
@


1.1.1.9
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.45 2003/09/24 01:14:59 deraadt Exp $	*/
d114 1
a114 1
#define MAXCON 800
a118 1
int window;
d139 1
a139 8
	if (tmp == NULL) {
		if (cp->obuf)
			free(cp->obuf);
		cp->obuf = NULL;
		cp->osize = 0;
		cp->obufalloc = 0;
		return (NULL);
	} else {
d144 2
a145 1
	}	
d203 1
a203 5
			if (tmp == NULL) {
				if (av)
					free(av);
				av = NULL;
				ac = 0;
a204 1
			}
d334 1
a334 1
				return (-1);
d391 7
d442 5
a446 1
				if (c == NULL)
d448 1
d799 1
a799 1
	while ((ch = getopt(argc, argv, "45c:p:dr:s:n:w:")) != -1) {
a830 5
		case 'w':
			window = atoi(optarg);
			if (window <= 0)
				usage();
			break;
d864 2
a865 2
	if (window && setsockopt(s, SOL_SOCKET, SO_RCVBUF, &window,
	    sizeof(window)) == -1) {
@


1.1.1.10
log
@cvs is playing games with me.

@@@@@@ CONSIDER THE TREE LOCKED NOW @@@@@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.48 2003/09/26 16:07:29 deraadt Exp $	*/
d141 2
a142 1
		free(cp->obuf);
d211 2
a212 1
				free(av);
d945 4
a948 2
			free(fdsr);
			free(fdsw);
d1018 5
a1022 3
			if (s2 == -1)
				/* accept failed, they may try again */
				continue;
d1038 5
a1042 4
			if (conffd == -1) 
				/* accept failed, they may try again */
				continue;
			else if (ntohs(lin.sin_port) >= IPPORT_RESERVED) {
@


1.1.1.11
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.52 2003/11/09 07:35:25 dhartmei Exp $	*/
a54 1
	int laststate;
a117 1
int verbose;
d127 1
a127 1
	    "usage: spamd [-45dv] [-c maxcon] [-n name] [-p port] [-r reply] "
a128 2
	fprintf(stderr,
	    "             [-w window]\n");
a570 1
		cp->laststate = cp->state;
a582 1
			cp->laststate = cp->state;
a591 1
		cp->laststate = cp->state;
a603 1
			cp->laststate = cp->state;
a612 1
		cp->laststate = cp->state;
a624 1
			cp->laststate = cp->state;
d637 1
a637 2
		cp->laststate = cp->state;
		cp->state = 5;
a650 1
			cp->state = cp->laststate;
a660 1
		        cp->laststate = cp->state;
d666 2
a667 2
		if (verbose && cp->data_body && *cp->ibuf)
			syslog_r(LOG_DEBUG, &sdata, "%s: Body: %s", cp->addr,
d669 2
a670 2
		else if (verbose && (match(cp->ibuf, "FROM:") || 
		     match(cp->ibuf, "TO:") || match(cp->ibuf, "SUBJECT:")))
a685 1
		cp->laststate = cp->state;
d726 2
a727 3
		if (verbose)
			syslog_r(LOG_DEBUG, &sdata, "%s: says '%s'", cp->addr,
			    cp->ibuf);
d797 1
a797 1
	while ((ch = getopt(argc, argv, "45c:p:dr:s:n:vw:")) != -1) {
a827 3
			break;
		case 'v':
			verbose = 1;
@


1.1.1.12
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.66 2004/04/03 01:37:18 dhartmei Exp $	*/
a50 1
#include "grey.h"
d60 1
a60 2
	char mail[MAX_MAIL], rcpt[MAX_MAIL];
	struct sdlist **blacklists;
d75 1
a82 2
	int stutter;
	int sr;
d91 2
a92 2
void     build_reply(struct  con *);
void     doreply(struct con *);
a105 7
int greypipe[2];
FILE *grey;
time_t passtime = PASSTIME;
time_t greyexp = GREYEXP;
time_t whiteexp = WHITEEXP;
struct passwd *pw;
pid_t jail_pid = -1;
a116 2
int maxblack = MAXCON;
int blackcount;
a118 1
int greylist;
d124 1
d129 2
a130 3
	    "usage: spamd [-45dgv] [-B maxblack] [-b address] [-c maxcon]\n");
	fprintf(stderr,
	    "             [-G mins:hours:hours] [-n name] [-p port]\n");
d132 1
a132 1
	    "             [-r reply] [-s secs] [-w window]\n");
d141 2
d148 1
d153 1
d155 1
a155 1
	}
d158 1
d318 1
d407 1
d409 1
a409 1
loglists(struct con *cp)
d411 1
d413 1
a413 2
	struct sdlist **matches;
	int s = sizeof(matchlists) - 4;
d416 9
a424 3
	matches = cp->blacklists;
	if (matches == NULL)
		return(NULL);
d426 3
a439 18
	}
	return matchlists;
}

void
build_reply(struct con *cp)
{
	struct sdlist **matches;
	int off = 0;

	matches = cp->blacklists;
	if (matches == NULL)
		goto nomatch;
	for (; *matches; matches++) {
		int used = 0;
		char *c = cp->obuf + off;
		int left = cp->osize - off;

d456 13
a468 17
	return;
nomatch:
	/* No match. give generic reply */
	free(cp->obuf);
	cp->obuf = NULL;
	cp->osize = 0;
	if (cp->blacklists != NULL)
		asprintf(&cp->obuf,
		    "%s-Sorry %s\n"
		    "%s-You are trying to send mail from an address "
		    "listed by one\n"
		    "%s or more IP-based registries as being a SPAM source.\n",
		    nreply, cp->addr, nreply, nreply);
	else
		asprintf(&cp->obuf,
		    "450 Temporary failure, please try again later.\r\n");
	if (cp->obuf != NULL)
d470 1
a470 9
	else
		cp->osize = 0;
	return;
bad:
	if (cp->obuf != NULL) {
		free(cp->obuf);
		cp->obuf = NULL;
		cp->osize = 0;
	}
d473 1
a473 1
void
d476 3
a478 1
	if (reply)
d480 3
a482 1
	build_reply(cp);
a510 1
	char *tmp;
d513 4
a516 7
	free(cp->obuf);
	cp->obuf = NULL;
	cp->osize = 0;
	free(cp->blacklists);
	cp->blacklists = NULL;
	free(cp->lists);
	cp->lists = NULL;
a523 2
	cp->blacklists = sdl_lookup(blacklists, cp->af, cp->ia);
	cp->stutter = (greylist && cp->blacklists == NULL) ? 0 : stutter;
a524 4
	tmp = strdup(ctime(&t));
	if (tmp == NULL)
		err(1, "malloc");
	tmp[strlen(tmp) - 1] = '\0'; /* nuke newline */
d526 2
a527 3
		 "220 %s ESMTP %s; %s\r\n",
		 hostname, spamd, tmp);
	free(tmp);
d530 1
a530 1
	cp->w = t + cp->stutter;
a533 10
	if (cp->blacklists != NULL) {
		blackcount++;
		if (greylist && blackcount > maxblack) {
			closecon(cp); /* close and free */
			return;
		}
		cp->lists = strdup(loglists(cp));
	}
	else
		cp->lists = NULL;
d542 2
a543 4
	syslog_r(LOG_INFO, &sdata, "%s: disconnected after %ld seconds.%s%s",
	    cp->addr, (long)(t - cp->s),
	    ((cp->lists == NULL) ? "" : " lists:"),
	    ((cp->lists == NULL) ? "": cp->lists));
d551 1
a551 6
	if (cp->blacklists != NULL) {
		blackcount--;
		free(cp->blacklists);
		cp->blacklists = NULL;
	}
	if (cp->obuf != NULL) {
d585 1
a585 1
			    "Pleased to be wasting your time.\r\n");
d590 1
a590 1
			cp->w = t + cp->stutter;
d608 1
a608 1
			    "Your time will be spent, for nothing.\r\n");
d613 1
a613 1
			cp->w = t + cp->stutter;
d631 1
a631 1
			    "hurting me.\r\n");
d636 4
a639 22
			cp->w = t + cp->stutter;
			if (cp->mail[0] && cp->rcpt[0]) {
				if (verbose)
					syslog_r(LOG_DEBUG, &sdata,
					    "(%s) %s: %s -> %s",
					    cp->blacklists ? "BLACK" : "GREY",
					    cp->addr, cp->mail,
					    cp->rcpt);
				if (debug)
					fprintf(stderr, "(%s) %s: %s -> %s\n",
					    cp->blacklists ? "BLACK" : "GREY",
					    cp->addr, cp->mail, cp->rcpt);
				if (greylist && cp->blacklists == NULL) {
					/* send this info to the greylister */
					fprintf(grey, "IP:%s\nFR:%s\nTO:%s\n",
					    cp->addr, cp->mail, cp->rcpt);
					fflush(grey);
					cp->laststate = cp->state;
					cp->state = 98;
					goto done;
				}
			}
d657 1
a657 1
			    "itself\r\n");
a658 5
			if (window && setsockopt(cp->fd, SOL_SOCKET, SO_RCVBUF,
			    &window, sizeof(window)) == -1) {
				syslog_r(LOG_DEBUG, &sdata,"setsockopt: %m");
				/* don't fail if this doesn't work. */
			}
d661 1
a661 1
			    "500 5.5.1 Command unrecognized\r\n");
d668 1
a668 1
		cp->w = t + cp->stutter;
d671 15
a685 32
		/* sent 354 blah */
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->laststate = cp->state;
		cp->state = 70;
		cp->r = t;
		break;
	case 70: {
		char *p, *q;

		for (p = q = cp->ibuf; q <= cp->ip; ++q)
			if (*q == '\n' || q == cp->ip) {
				*q = 0;
				if (q > p && q[-1] == '\r')
					q[-1] = 0;
				if (!strcmp(p, ".") ||
				    (cp->data_body && ++cp->data_lines >= 10)) {
					cp->laststate = cp->state;
					cp->state = 98;
					goto done;
				}
				if (!cp->data_body && !*p)
					cp->data_body = 1;
				if (verbose && cp->data_body && *p)
					syslog_r(LOG_DEBUG, &sdata, "%s: "
					    "Body: %s", cp->addr, p);
				else if (verbose && (match(p, "FROM:") ||
				    match(p, "TO:") || match(p, "SUBJECT:")))
					syslog_r(LOG_INFO, &sdata, "%s: %s",
					    cp->addr, p);
				p = ++q;
			}
a689 1
	}
d692 4
a695 1
		doreply(cp);
d698 1
a698 1
		cp->w = t + cp->stutter;
d719 1
a719 1
		if (n == 0)
d721 1
a721 1
		else if (n == -1) {
d740 3
d753 1
a753 1
		if (*cp->op == '\n' && !cp->sr) {
d766 2
a767 6
		if (*cp->op == '\r')
			cp->sr = 1;
		else
			cp->sr = 0;
		n = write(cp->fd, cp->op, (one && cp->stutter) ? 1 : cp->ol);
		if (n == 0)
d769 1
a769 1
		else if (n == -1) {
d779 1
a779 1
	cp->w = t + cp->stutter;
d792 3
a794 2
	int ch, s, s2, conflisten = 0, i, omax = 0, one = 1;
	socklen_t sinlen;
a797 1
	char *bind_address = NULL;
d812 1
a812 1
	while ((ch = getopt(argc, argv, "45b:c:B:p:dgG:r:s:n:vw:")) != -1) {
a819 7
		case 'b':
			bind_address = optarg;
			break;
		case 'B':
			i = atoi(optarg);
			maxblack = i;
			break;
a832 14
		case 'g':
			greylist = 1;
			break;
		case 'G':
			if (sscanf(optarg, "%d:%d:%d", &passtime, &greyexp,
			    &whiteexp) != 3)
				usage();
			/* convert to seconds from minutes */
			passtime *= 60;
			/* convert to seconds from hours */
			whiteexp *= (60 * 60);
			/* convert to seconds from hours */
			greyexp *= (60 * 60);
			break;
a840 1
			break;
a856 5
	
	if (!greylist)
		maxblack = maxcon;
	else if (maxblack > maxcon)
		usage();
d858 1
a858 1
	rlp.rlim_cur = rlp.rlim_max = maxcon + 15;
d885 6
d901 1
a901 5
	if (bind_address) {
		if (inet_pton(AF_INET, bind_address, &sin.sin_addr) != 1)
			err(1, "inet_pton");
	} else
		sin.sin_addr.s_addr = htonl(INADDR_ANY);
a920 42
	if (debug == 0) {
		if (daemon(1, 1) == -1)
			err(1, "daemon");
	}

	if (greylist) {
		maxblack = (maxblack >= maxcon) ? maxcon - 100 : maxblack;
		if (maxblack < 0)
			maxblack = 0;

		/* open pipe to talk to greylister */
		if (pipe(greypipe) == -1) {
			syslog(LOG_ERR, "pipe (%m)");
			exit(1);
		}
		jail_pid = fork();
		switch(jail_pid) {
		case -1: 
			syslog(LOG_ERR, "fork (%m)");
			exit(1);
		case 0:
			/* child - continue */
			close(greypipe[0]);
			grey = fdopen(greypipe[1], "w");
			if (grey == NULL) {
				syslog(LOG_ERR, "fdopen (%m)");
				_exit(1);
			}
			goto jail;
		}
		/* parent - run greylister */
		close(greypipe[1]);
		grey = fdopen(greypipe[0], "r");
		if (grey == NULL) {
			syslog(LOG_ERR, "fdopen (%m)");
			exit(1);
		}
		return(greywatcher());
		/* NOTREACHED */
	}

jail:
d940 4
a943 1
	if (debug != 0)
a961 1
			fdsr = NULL;
a962 1
			fdsr = NULL;
d1042 2
a1043 7
				syslog_r(LOG_INFO, &sdata,
				    "%s: connected (%d/%d)%s%s",
				    con[i].addr, clients, blackcount,
				    ((con[i].lists == NULL) ? "" :
				    ", lists:"),
				    ((con[i].lists == NULL) ? "":
				    con[i].lists));
d1050 1
a1050 1
			if (conffd == -1)
@


1.1.1.13
log
@import some updates/fixes from openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.73 2004/10/05 15:20:30 beck Exp $	*/
d47 2
d58 1
a58 1
	struct sockaddr_storage ss;
d97 1
a97 1
void     initcon(struct con *, int, struct sockaddr *);
d486 1
a486 1
		    "451 Temporary failure, please try again later.\r\n");
d531 1
a531 1
initcon(struct con *cp, int fd, struct sockaddr *sa)
a534 1
	int error;
d548 3
a550 7
	if (sa->sa_len > sizeof(cp->ss))
		errx(1, "sockaddr size");
	if (sa->sa_family != AF_INET)
		errx(1, "not supported yet");
	memcpy(&cp->ss, sa, sa->sa_len);
	cp->af = sa->sa_family;
	cp->ia = &((struct sockaddr_in *)sa)->sin_addr;
d553 1
a553 4
	error = getnameinfo(sa, sa->sa_len, cp->addr, sizeof(cp->addr), NULL, 0,
	    NI_NUMERICHOST);
	if (error)
		errx(1, "%s", gai_strerror(error));
a620 10
	if (match(cp->ibuf, "QUIT") && cp->state < 99) {
		snprintf(cp->obuf, cp->osize, "221 %s\n", hostname);
		cp->op = cp->obuf;
		cp->ol = strlen(cp->op);
		cp->w = t + cp->stutter;
		cp->laststate = cp->state;
		cp->state = 99;
		return;
	}

d690 1
a690 1
					syslog_r(LOG_INFO, &sdata,
d969 1
a969 1

d1053 1
a1053 1
		case -1:
d1118 1
a1118 1
			fdsw = NULL;
d1197 1
a1197 1
				initcon(&con[i], s2, (struct sockaddr *)&sin);
@


1.1.1.14
log
@your daily OpenBSD update session
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.74 2004/11/17 15:29:38 beck Exp $	*/
d628 1
a628 1
		snprintf(cp->obuf, cp->osize, "221 %s\r\n", hostname);
a636 10
	if (match(cp->ibuf, "RSET") && cp->state > 2 && cp->state < 50) {
		snprintf(cp->obuf, cp->osize,
		    "250 Ok to start over.\r\n");
		cp->op = cp->obuf;
		cp->ol = strlen(cp->op);
		cp->w = t + cp->stutter;
		cp->laststate = cp->state;
		cp->state = 2;
		return;
	}
@


