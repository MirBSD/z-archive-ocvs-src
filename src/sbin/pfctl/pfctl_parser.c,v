head	1.2;
access;
symbols
	tg-mergetmp-mirosx-1:1.2
	tg-mergefixes-1-branch:1.2.0.4
	tg-mergefixes-1-base:1.2
	MIROS_X:1.2.0.2
	MIROS_X_BASE:1.2
	tg-mergetmp-3:1.2
	MIRBSD_XP_MIRPPC:1.1.1.20.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.20
	MIRBSD_XP_SPARC:1.1.1.20.0.2
	MIRBSD_7quater:1.1.1.16
	cvs-200405160640:1.1.1.20
	cvs-200401271800:1.1.1.19
	cvs-200401261630:1.1.1.19
	cvs-200401021645:1.1.1.18
	MIRBSD_7_ALPHA:1.1.1.16.0.6
	MIRBSD_7:1.1.1.16.0.4
	cvs-200312222040:1.1.1.17
	MIRBSD_7ter:1.1.1.16
	MIRBSD_7_DEV:1.1.1.16.0.2
	cvs-200310020700:1.1.1.16
	cvs-200309271030:1.1.1.16
	cvs-200309261655:1.1.1.15
	cvs-200309251530:1.1.1.15
	cvs-200308302005:1.1.1.14
	cvs-200308171200:1.1.1.13
	ctm-3496:1.1.1.13
	ctm-3449:1.1.1.12
	ctm-3437:1.1.1.12
	cvs-200307191805:1.1.1.11
	ctm-3425:1.1.1.10
	cvs-200307091500:1.1.1.9
	cvs-200307072125:1.1.1.9
	ctm-3389:1.1.1.9
	cvs-200307021520:1.1.1.8
	cvs-200306301805:1.1.1.8
	cvs-200306301405:1.1.1.8
	cvs-200306291430:1.1.1.8
	ctm-3341:1.1.1.8
	MIRBSD_5:1.1.1.7
	cvs-200306091240:1.1.1.7
	cvs-200306082100:1.1.1.6
	ctm-3316:1.1.1.6
	ctm-3272:1.1.1.5
	ctm-3264:1.1.1.4
	cvs-200305071630:1.1.1.4
	MIRBSD_4:1.1.1.3
	ctm-3203:1.1.1.3
	cvs-20030410-1130:1.1.1.3
	ctm-3155:1.1.1.2
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.12.07.22.17.22;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.48.40;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.48.40;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.03.29.19.42.15;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.04.10.14.44.42;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.07.17.43.43;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.21.19.02.55;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.06.05.17.31.29;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.06.09.12.44.30;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.06.19.12.42.52;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.07.06.15.40.12;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.07.18.13.42.44;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2003.07.19.18.48.25;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2003.07.22.14.52.33;	author tg;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2003.08.11.18.30.23;	author tg;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2003.08.30.23.01.35;	author tg;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2003.09.25.16.32.29;	author tg;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2003.09.27.11.17.29;	author tg;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2003.12.22.21.10.52;	author tg;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	2004.01.02.18.01.22;	author tg;	state Exp;
branches;
next	1.1.1.19;

1.1.1.19
date	2004.01.26.18.30.28;	author tg;	state Exp;
branches;
next	1.1.1.20;

1.1.1.20
date	2004.05.16.08.26.40;	author tg;	state Stab;
branches;
next	;


desc
@@


1.2
log
@remove pf features which are broken:
 ($interface) -> did never work correctly
 antispoof -> dangerous, false sense of security, side impacts, only for lazies

remove kernel stuff accordingly, but don't change ABI

update documentation
remove orphaned documentation nobody maintains
@
text
@/**	$MirBSD$ */
/*	$OpenBSD: pfctl_parser.c,v 1.198 2004/05/07 16:54:20 henning Exp $ */

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2002,2003 Henning Brauer
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/icmp6.h>
#include <net/pfvar.h>
#include <arpa/inet.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <netdb.h>
#include <stdarg.h>
#include <errno.h>
#include <err.h>
#include <ifaddrs.h>

#include "pfctl_parser.h"
#include "pfctl.h"

__RCSID("$MirBSD$");

void		 print_op (u_int8_t, const char *, const char *);
void		 print_port (u_int8_t, u_int16_t, u_int16_t, const char *);
void		 print_ugid (u_int8_t, unsigned, unsigned, const char *, unsigned);
void		 print_flags (u_int8_t);
void		 print_fromto(struct pf_rule_addr *, pf_osfp_t,
		    struct pf_rule_addr *, u_int8_t, u_int8_t, int);
int		 ifa_skip_if(const char *filter, struct node_host *p);

struct node_host	*host_if(const char *, int);
struct node_host	*host_v4(const char *, int);
struct node_host	*host_v6(const char *, int);
struct node_host	*host_dns(const char *, int, int);

const char *tcpflags = "FSRPAUEW";

static const struct icmptypeent icmp_type[] = {
	{ "echoreq",	ICMP_ECHO },
	{ "echorep",	ICMP_ECHOREPLY },
	{ "unreach",	ICMP_UNREACH },
	{ "squench",	ICMP_SOURCEQUENCH },
	{ "redir",	ICMP_REDIRECT },
	{ "althost",	ICMP_ALTHOSTADDR },
	{ "routeradv",	ICMP_ROUTERADVERT },
	{ "routersol",	ICMP_ROUTERSOLICIT },
	{ "timex",	ICMP_TIMXCEED },
	{ "paramprob",	ICMP_PARAMPROB },
	{ "timereq",	ICMP_TSTAMP },
	{ "timerep",	ICMP_TSTAMPREPLY },
	{ "inforeq",	ICMP_IREQ },
	{ "inforep",	ICMP_IREQREPLY },
	{ "maskreq",	ICMP_MASKREQ },
	{ "maskrep",	ICMP_MASKREPLY },
	{ "trace",	ICMP_TRACEROUTE },
	{ "dataconv",	ICMP_DATACONVERR },
	{ "mobredir",	ICMP_MOBILE_REDIRECT },
	{ "ipv6-where",	ICMP_IPV6_WHEREAREYOU },
	{ "ipv6-here",	ICMP_IPV6_IAMHERE },
	{ "mobregreq",	ICMP_MOBILE_REGREQUEST },
	{ "mobregrep",	ICMP_MOBILE_REGREPLY },
	{ "skip",	ICMP_SKIP },
	{ "photuris",	ICMP_PHOTURIS }
};

static const struct icmptypeent icmp6_type[] = {
	{ "unreach",	ICMP6_DST_UNREACH },
	{ "toobig",	ICMP6_PACKET_TOO_BIG },
	{ "timex",	ICMP6_TIME_EXCEEDED },
	{ "paramprob",	ICMP6_PARAM_PROB },
	{ "echoreq",	ICMP6_ECHO_REQUEST },
	{ "echorep",	ICMP6_ECHO_REPLY },
	{ "groupqry",	ICMP6_MEMBERSHIP_QUERY },
	{ "listqry",	MLD_LISTENER_QUERY },
	{ "grouprep",	ICMP6_MEMBERSHIP_REPORT },
	{ "listenrep",	MLD_LISTENER_REPORT },
	{ "groupterm",	ICMP6_MEMBERSHIP_REDUCTION },
	{ "listendone", MLD_LISTENER_DONE },
	{ "routersol",	ND_ROUTER_SOLICIT },
	{ "routeradv",	ND_ROUTER_ADVERT },
	{ "neighbrsol", ND_NEIGHBOR_SOLICIT },
	{ "neighbradv", ND_NEIGHBOR_ADVERT },
	{ "redir",	ND_REDIRECT },
	{ "routrrenum", ICMP6_ROUTER_RENUMBERING },
	{ "wrureq",	ICMP6_WRUREQUEST },
	{ "wrurep",	ICMP6_WRUREPLY },
	{ "fqdnreq",	ICMP6_FQDN_QUERY },
	{ "fqdnrep",	ICMP6_FQDN_REPLY },
	{ "niqry",	ICMP6_NI_QUERY },
	{ "nirep",	ICMP6_NI_REPLY },
	{ "mtraceresp",	MLD_MTRACE_RESP },
	{ "mtrace",	MLD_MTRACE }
};

static const struct icmpcodeent icmp_code[] = {
	{ "net-unr",		ICMP_UNREACH,	ICMP_UNREACH_NET },
	{ "host-unr",		ICMP_UNREACH,	ICMP_UNREACH_HOST },
	{ "proto-unr",		ICMP_UNREACH,	ICMP_UNREACH_PROTOCOL },
	{ "port-unr",		ICMP_UNREACH,	ICMP_UNREACH_PORT },
	{ "needfrag",		ICMP_UNREACH,	ICMP_UNREACH_NEEDFRAG },
	{ "srcfail",		ICMP_UNREACH,	ICMP_UNREACH_SRCFAIL },
	{ "net-unk",		ICMP_UNREACH,	ICMP_UNREACH_NET_UNKNOWN },
	{ "host-unk",		ICMP_UNREACH,	ICMP_UNREACH_HOST_UNKNOWN },
	{ "isolate",		ICMP_UNREACH,	ICMP_UNREACH_ISOLATED },
	{ "net-prohib",		ICMP_UNREACH,	ICMP_UNREACH_NET_PROHIB },
	{ "host-prohib",	ICMP_UNREACH,	ICMP_UNREACH_HOST_PROHIB },
	{ "net-tos",		ICMP_UNREACH,	ICMP_UNREACH_TOSNET },
	{ "host-tos",		ICMP_UNREACH,	ICMP_UNREACH_TOSHOST },
	{ "filter-prohib",	ICMP_UNREACH,	ICMP_UNREACH_FILTER_PROHIB },
	{ "host-preced",	ICMP_UNREACH,	ICMP_UNREACH_HOST_PRECEDENCE },
	{ "cutoff-preced",	ICMP_UNREACH,	ICMP_UNREACH_PRECEDENCE_CUTOFF },
	{ "redir-net",		ICMP_REDIRECT,	ICMP_REDIRECT_NET },
	{ "redir-host",		ICMP_REDIRECT,	ICMP_REDIRECT_HOST },
	{ "redir-tos-net",	ICMP_REDIRECT,	ICMP_REDIRECT_TOSNET },
	{ "redir-tos-host",	ICMP_REDIRECT,	ICMP_REDIRECT_TOSHOST },
	{ "normal-adv",		ICMP_ROUTERADVERT, ICMP_ROUTERADVERT_NORMAL },
	{ "common-adv",		ICMP_ROUTERADVERT, ICMP_ROUTERADVERT_NOROUTE_COMMON },
	{ "transit",		ICMP_TIMXCEED,	ICMP_TIMXCEED_INTRANS },
	{ "reassemb",		ICMP_TIMXCEED,	ICMP_TIMXCEED_REASS },
	{ "badhead",		ICMP_PARAMPROB,	ICMP_PARAMPROB_ERRATPTR },
	{ "optmiss",		ICMP_PARAMPROB,	ICMP_PARAMPROB_OPTABSENT },
	{ "badlen",		ICMP_PARAMPROB,	ICMP_PARAMPROB_LENGTH },
	{ "unknown-ind",	ICMP_PHOTURIS,	ICMP_PHOTURIS_UNKNOWN_INDEX },
	{ "auth-fail",		ICMP_PHOTURIS,	ICMP_PHOTURIS_AUTH_FAILED },
	{ "decrypt-fail",	ICMP_PHOTURIS,	ICMP_PHOTURIS_DECRYPT_FAILED }
};

static const struct icmpcodeent icmp6_code[] = {
	{ "admin-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_ADMIN },
	{ "noroute-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOROUTE },
	{ "notnbr-unr",	ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOTNEIGHBOR },
	{ "beyond-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_BEYONDSCOPE },
	{ "addr-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_ADDR },
	{ "port-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOPORT },
	{ "transit", ICMP6_TIME_EXCEEDED, ICMP6_TIME_EXCEED_TRANSIT },
	{ "reassemb", ICMP6_TIME_EXCEEDED, ICMP6_TIME_EXCEED_REASSEMBLY },
	{ "badhead", ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER },
	{ "nxthdr", ICMP6_PARAM_PROB, ICMP6_PARAMPROB_NEXTHEADER },
	{ "redironlink", ND_REDIRECT, ND_REDIRECT_ONLINK },
	{ "redirrouter", ND_REDIRECT, ND_REDIRECT_ROUTER }
};

const struct pf_timeout pf_timeouts[] = {
	{ "tcp.first",		PFTM_TCP_FIRST_PACKET },
	{ "tcp.opening",	PFTM_TCP_OPENING },
	{ "tcp.established",	PFTM_TCP_ESTABLISHED },
	{ "tcp.closing",	PFTM_TCP_CLOSING },
	{ "tcp.finwait",	PFTM_TCP_FIN_WAIT },
	{ "tcp.closed",		PFTM_TCP_CLOSED },
	{ "tcp.tsdiff",		PFTM_TS_DIFF },
	{ "udp.first",		PFTM_UDP_FIRST_PACKET },
	{ "udp.single",		PFTM_UDP_SINGLE },
	{ "udp.multiple",	PFTM_UDP_MULTIPLE },
	{ "icmp.first",		PFTM_ICMP_FIRST_PACKET },
	{ "icmp.error",		PFTM_ICMP_ERROR_REPLY },
	{ "other.first",	PFTM_OTHER_FIRST_PACKET },
	{ "other.single",	PFTM_OTHER_SINGLE },
	{ "other.multiple",	PFTM_OTHER_MULTIPLE },
	{ "frag",		PFTM_FRAG },
	{ "interval",		PFTM_INTERVAL },
	{ "adaptive.start",	PFTM_ADAPTIVE_START },
	{ "adaptive.end",	PFTM_ADAPTIVE_END },
	{ "src.track",		PFTM_SRC_NODE },
	{ NULL,			0 }
};

const struct icmptypeent *
geticmptypebynumber(u_int8_t type, sa_family_t af)
{
	unsigned int	i;

	if (af != AF_INET6) {
		for (i=0; i < (sizeof (icmp_type) / sizeof(icmp_type[0]));
		    i++) {
			if (type == icmp_type[i].type)
				return (&icmp_type[i]);
		}
	} else {
		for (i=0; i < (sizeof (icmp6_type) /
		    sizeof(icmp6_type[0])); i++) {
			if (type == icmp6_type[i].type)
				 return (&icmp6_type[i]);
		}
	}
	return (NULL);
}

const struct icmptypeent *
geticmptypebyname(char *w, sa_family_t af)
{
	unsigned int	i;

	if (af != AF_INET6) {
		for (i=0; i < (sizeof (icmp_type) / sizeof(icmp_type[0]));
		    i++) {
			if (!strcmp(w, icmp_type[i].name))
				return (&icmp_type[i]);
		}
	} else {
		for (i=0; i < (sizeof (icmp6_type) /
		    sizeof(icmp6_type[0])); i++) {
			if (!strcmp(w, icmp6_type[i].name))
				return (&icmp6_type[i]);
		}
	}
	return (NULL);
}

const struct icmpcodeent *
geticmpcodebynumber(u_int8_t type, u_int8_t code, sa_family_t af)
{
	unsigned int	i;

	if (af != AF_INET6) {
		for (i=0; i < (sizeof (icmp_code) / sizeof(icmp_code[0]));
		    i++) {
			if (type == icmp_code[i].type &&
			    code == icmp_code[i].code)
				return (&icmp_code[i]);
		}
	} else {
		for (i=0; i < (sizeof (icmp6_code) /
		    sizeof(icmp6_code[0])); i++) {
			if (type == icmp6_code[i].type &&
			    code == icmp6_code[i].code)
				return (&icmp6_code[i]);
		}
	}
	return (NULL);
}

const struct icmpcodeent *
geticmpcodebyname(u_long type, char *w, sa_family_t af)
{
	unsigned int	i;

	if (af != AF_INET6) {
		for (i=0; i < (sizeof (icmp_code) / sizeof(icmp_code[0]));
		    i++) {
			if (type == icmp_code[i].type &&
			    !strcmp(w, icmp_code[i].name))
				return (&icmp_code[i]);
		}
	} else {
		for (i=0; i < (sizeof (icmp6_code) /
		    sizeof(icmp6_code[0])); i++) {
			if (type == icmp6_code[i].type &&
			    !strcmp(w, icmp6_code[i].name))
				return (&icmp6_code[i]);
		}
	}
	return (NULL);
}

void
print_op(u_int8_t op, const char *a1, const char *a2)
{
	if (op == PF_OP_IRG)
		printf(" %s >< %s", a1, a2);
	else if (op == PF_OP_XRG)
		printf(" %s <> %s", a1, a2);
	else if (op == PF_OP_EQ)
		printf(" = %s", a1);
	else if (op == PF_OP_NE)
		printf(" != %s", a1);
	else if (op == PF_OP_LT)
		printf(" < %s", a1);
	else if (op == PF_OP_LE)
		printf(" <= %s", a1);
	else if (op == PF_OP_GT)
		printf(" > %s", a1);
	else if (op == PF_OP_GE)
		printf(" >= %s", a1);
	else if (op == PF_OP_RRG)
		printf(" %s:%s", a1, a2);
}

void
print_port(u_int8_t op, u_int16_t p1, u_int16_t p2, const char *proto)
{
	char		 a1[6], a2[6];
	struct servent	*s;

	s = getservbyport(p1, proto);
	p1 = ntohs(p1);
	p2 = ntohs(p2);
	snprintf(a1, sizeof(a1), "%u", p1);
	snprintf(a2, sizeof(a2), "%u", p2);
	printf(" port");
	if (s != NULL && (op == PF_OP_EQ || op == PF_OP_NE))
		print_op(op, s->s_name, a2);
	else
		print_op(op, a1, a2);
}

void
print_ugid(u_int8_t op, unsigned u1, unsigned u2, const char *t, unsigned umax)
{
	char	a1[11], a2[11];

	snprintf(a1, sizeof(a1), "%u", u1);
	snprintf(a2, sizeof(a2), "%u", u2);
	printf(" %s", t);
	if (u1 == umax && (op == PF_OP_EQ || op == PF_OP_NE))
		print_op(op, "unknown", a2);
	else
		print_op(op, a1, a2);
}

void
print_flags(u_int8_t f)
{
	int	i;

	for (i = 0; tcpflags[i]; ++i)
		if (f & (1 << i))
			printf("%c", tcpflags[i]);
}

void
print_fromto(struct pf_rule_addr *src, pf_osfp_t osfp, struct pf_rule_addr *dst,
    sa_family_t af, u_int8_t proto, int verbose)
{
	char buf[PF_OSFP_LEN*3];
	if (src->addr.type == PF_ADDR_ADDRMASK &&
	    dst->addr.type == PF_ADDR_ADDRMASK &&
	    PF_AZERO(&src->addr.v.a.addr, AF_INET6) &&
	    PF_AZERO(&src->addr.v.a.mask, AF_INET6) &&
	    PF_AZERO(&dst->addr.v.a.addr, AF_INET6) &&
	    PF_AZERO(&dst->addr.v.a.mask, AF_INET6) &&
	    !src->not && !dst->not &&
	    !src->port_op && !dst->port_op &&
	    osfp == PF_OSFP_ANY)
		printf(" all");
	else {
		printf(" from ");
		if (src->not)
			printf("! ");
		print_addr(&src->addr, af, verbose);
		if (src->port_op)
			print_port(src->port_op, src->port[0],
			    src->port[1],
			    proto == IPPROTO_TCP ? "tcp" : "udp");
		if (osfp != PF_OSFP_ANY)
			printf(" os \"%s\"", pfctl_lookup_fingerprint(osfp, buf,
			    sizeof(buf)));

		printf(" to ");
		if (dst->not)
			printf("! ");
		print_addr(&dst->addr, af, verbose);
		if (dst->port_op)
			print_port(dst->port_op, dst->port[0],
			    dst->port[1],
			    proto == IPPROTO_TCP ? "tcp" : "udp");
	}
}

void
print_pool(struct pf_pool *pool, u_int16_t p1, u_int16_t p2,
    sa_family_t af, int id)
{
	struct pf_pooladdr	*pooladdr;

	if ((TAILQ_FIRST(&pool->list) != NULL) &&
	    TAILQ_NEXT(TAILQ_FIRST(&pool->list), entries) != NULL)
		printf("{ ");
	TAILQ_FOREACH(pooladdr, &pool->list, entries){
		switch (id) {
		case PF_NAT:
		case PF_RDR:
		case PF_BINAT:
			print_addr(&pooladdr->addr, af, 0);
			break;
		case PF_PASS:
			if (PF_AZERO(&pooladdr->addr.v.a.addr, af))
				printf("%s", pooladdr->ifname);
			else {
				printf("(%s ", pooladdr->ifname);
				print_addr(&pooladdr->addr, af, 0);
				printf(")");
			}
			break;
		default:
			break;
		}
		if (TAILQ_NEXT(pooladdr, entries) != NULL)
			printf(", ");
		else if (TAILQ_NEXT(TAILQ_FIRST(&pool->list), entries) != NULL)
			printf(" }");
	}
	switch (id) {
	case PF_NAT:
		if ((p1 != PF_NAT_PROXY_PORT_LOW ||
		    p2 != PF_NAT_PROXY_PORT_HIGH) && (p1 != 0 || p2 != 0)) {
			if (p1 == p2)
				printf(" port %u", p1);
			else
				printf(" port %u:%u", p1, p2);
		}
		break;
	case PF_RDR:
		if (p1) {
			printf(" port %u", p1);
			if (p2 && (p2 != p1))
				printf(":%u", p2);
		}
		break;
	default:
		break;
	}
	switch (pool->opts & PF_POOL_TYPEMASK) {
	case PF_POOL_NONE:
		break;
	case PF_POOL_BITMASK:
		printf(" bitmask");
		break;
	case PF_POOL_RANDOM:
		printf(" random");
		break;
	case PF_POOL_SRCHASH:
		printf(" source-hash 0x%08x%08x%08x%08x",
		    pool->key.key32[0], pool->key.key32[1],
		    pool->key.key32[2], pool->key.key32[3]);
		break;
	case PF_POOL_ROUNDROBIN:
		printf(" round-robin");
		break;
	}
	if (pool->opts & PF_POOL_STICKYADDR)
		printf(" sticky-address");
	if (id == PF_NAT && p1 == 0 && p2 == 0)
		printf(" static-port");
}

const char	*pf_reasons[PFRES_MAX+1] = PFRES_NAMES;
const char	*pf_fcounters[FCNT_MAX+1] = FCNT_NAMES;
const char	*pf_scounters[FCNT_MAX+1] = FCNT_NAMES;

void
print_status(struct pf_status *s, int opts)
{
	char	statline[80], *running;
	time_t	runtime;
	int	i;

	runtime = time(NULL) - s->since;
	running = s->running ? "Enabled" : "Disabled";

	if (s->since) {
		unsigned	sec, min, hrs, day = runtime;

		sec = day % 60;
		day /= 60;
		min = day % 60;
		day /= 60;
		hrs = day % 24;
		day /= 24;
		snprintf(statline, sizeof(statline),
		    "Status: %s for %u days %.2u:%.2u:%.2u",
		    running, day, hrs, min, sec);
	} else
		snprintf(statline, sizeof(statline), "Status: %s", running);
	printf("%-44s", statline);
	switch (s->debug) {
	case PF_DEBUG_NONE:
		printf("%15s\n\n", "Debug: None");
		break;
	case PF_DEBUG_URGENT:
		printf("%15s\n\n", "Debug: Urgent");
		break;
	case PF_DEBUG_MISC:
		printf("%15s\n\n", "Debug: Misc");
		break;
	case PF_DEBUG_NOISY:
		printf("%15s\n\n", "Debug: Loud");
		break;
	}
	printf("Hostid: 0x%08x\n\n", ntohl(s->hostid));
	if (s->ifname[0] != 0) {
		printf("Interface Stats for %-16s %5s %16s\n",
		    s->ifname, "IPv4", "IPv6");
		printf("  %-25s %14llu %16llu\n", "Bytes In",
		    (unsigned long long)s->bcounters[0][0],
		    (unsigned long long)s->bcounters[1][0]);
		printf("  %-25s %14llu %16llu\n", "Bytes Out",
		    (unsigned long long)s->bcounters[0][1],
		    (unsigned long long)s->bcounters[1][1]);
		printf("  Packets In\n");
		printf("    %-23s %14llu %16llu\n", "Passed",
		    (unsigned long long)s->pcounters[0][0][PF_PASS],
		    (unsigned long long)s->pcounters[1][0][PF_PASS]);
		printf("    %-23s %14llu %16llu\n", "Blocked",
		    (unsigned long long)s->pcounters[0][0][PF_DROP],
		    (unsigned long long)s->pcounters[1][0][PF_DROP]);
		printf("  Packets Out\n");
		printf("    %-23s %14llu %16llu\n", "Passed",
		    (unsigned long long)s->pcounters[0][1][PF_PASS],
		    (unsigned long long)s->pcounters[1][1][PF_PASS]);
		printf("    %-23s %14llu %16llu\n\n", "Blocked",
		    (unsigned long long)s->pcounters[0][1][PF_DROP],
		    (unsigned long long)s->pcounters[1][1][PF_DROP]);
	}
	printf("%-27s %14s %16s\n", "State Table", "Total", "Rate");
	printf("  %-25s %14u %14s\n", "current entries", s->states, "");
	for (i = 0; i < FCNT_MAX; i++) {
		printf("  %-25s %14llu ", pf_fcounters[i],
			    (unsigned long long)s->fcounters[i]);
		if (runtime > 0)
			printf("%14.1f/s\n",
			    (double)s->fcounters[i] / (double)runtime);
		else
			printf("%14s\n", "");
	}
	if (opts & PF_OPT_VERBOSE) {
		printf("Source Tracking Table\n");
		printf("  %-25s %14u %14s\n", "current entries",
		    s->src_nodes, "");
		for (i = 0; i < SCNT_MAX; i++) {
			printf("  %-25s %14lld ", pf_scounters[i],
				    s->scounters[i]);
			if (runtime > 0)
				printf("%14.1f/s\n",
				    (double)s->scounters[i] / (double)runtime);
			else
				printf("%14s\n", "");
		}
	}
	printf("Counters\n");
	for (i = 0; i < PFRES_MAX; i++) {
		printf("  %-25s %14llu ", pf_reasons[i],
		    (unsigned long long)s->counters[i]);
		if (runtime > 0)
			printf("%14.1f/s\n",
			    (double)s->counters[i] / (double)runtime);
		else
			printf("%14s\n", "");
	}
}

void
print_src_node(struct pf_src_node *sn, int opts)
{
	struct pf_addr_wrap aw;
	int min, sec;

	memset(&aw, 0, sizeof(aw));
	if (sn->af == AF_INET)
		aw.v.a.mask.addr32[0] = 0xffffffff;
	else
		memset(&aw.v.a.mask, 0xff, sizeof(aw.v.a.mask));

	aw.v.a.addr = sn->addr;
	print_addr(&aw, sn->af, opts & PF_OPT_VERBOSE2);
	printf(" -> ");
	aw.v.a.addr = sn->raddr;
	print_addr(&aw, sn->af, opts & PF_OPT_VERBOSE2);
	printf(" (%d states)\n", sn->states);
	if (opts & PF_OPT_VERBOSE) {
		sec = sn->creation % 60;
		sn->creation /= 60;
		min = sn->creation % 60;
		sn->creation /= 60;
		printf("   age %.2u:%.2u:%.2u", sn->creation, min, sec);
		if (sn->states == 0) {
			sec = sn->expire % 60;
			sn->expire /= 60;
			min = sn->expire % 60;
			sn->expire /= 60;
			printf(", expires in %.2u:%.2u:%.2u",
			    sn->expire, min, sec);
		}
		printf(", %u pkts, %u bytes", sn->packets, sn->bytes);
		switch (sn->ruletype) {
		case PF_NAT:
			if (sn->rule.nr != -1)
				printf(", nat rule %u", sn->rule.nr);
			break;
		case PF_RDR:
			if (sn->rule.nr != -1)
				printf(", rdr rule %u", sn->rule.nr);
			break;
		case PF_PASS:
			if (sn->rule.nr != -1)
				printf(", filter rule %u", sn->rule.nr);
			break;
		}
		printf("\n");
	}
}

void
print_rule(struct pf_rule *r, int verbose)
{
	static const char *actiontypes[] = { "pass", "block", "scrub", "nat",
	    "no nat", "binat", "no binat", "rdr", "no rdr" };
	static const char *anchortypes[] = { "anchor", "anchor", "anchor",
	    "nat-anchor", "nat-anchor", "binat-anchor", "binat-anchor",
	    "rdr-anchor", "rdr-anchor" };
	int	i, opts;

	if (verbose)
		printf("@@%d ", r->nr);
	if (r->action > PF_NORDR)
		printf("action(%d)", r->action);
	else if (r->anchorname[0])
		printf("%s %s", anchortypes[r->action], r->anchorname);
	else {
		printf("%s", actiontypes[r->action]);
		if (r->natpass)
			printf(" pass");
	}
	if (r->action == PF_DROP) {
		if (r->rule_flag & PFRULE_RETURN)
			printf(" return");
		else if (r->rule_flag & PFRULE_RETURNRST) {
			if (!r->return_ttl)
				printf(" return-rst");
			else
				printf(" return-rst(ttl %d)", r->return_ttl);
		} else if (r->rule_flag & PFRULE_RETURNICMP) {
			const struct icmpcodeent	*ic, *ic6;

			ic = geticmpcodebynumber(r->return_icmp >> 8,
			    r->return_icmp & 255, AF_INET);
			ic6 = geticmpcodebynumber(r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, AF_INET6);

			switch (r->af) {
			case AF_INET:
				printf(" return-icmp");
				if (ic == NULL)
					printf("(%u)", r->return_icmp & 255);
				else
					printf("(%s)", ic->name);
				break;
			case AF_INET6:
				printf(" return-icmp6");
				if (ic6 == NULL)
					printf("(%u)", r->return_icmp6 & 255);
				else
					printf("(%s)", ic6->name);
				break;
			default:
				printf(" return-icmp");
				if (ic == NULL)
					printf("(%u, ", r->return_icmp & 255);
				else
					printf("(%s, ", ic->name);
				if (ic6 == NULL)
					printf("%u)", r->return_icmp6 & 255);
				else
					printf("%s)", ic6->name);
				break;
			}
		} else
			printf(" drop");
	}
	if (r->direction == PF_IN)
		printf(" in");
	else if (r->direction == PF_OUT)
		printf(" out");
	if (r->log == 1)
		printf(" log");
	else if (r->log == 2)
		printf(" log-all");
	if (r->quick)
		printf(" quick");
	if (r->ifname[0]) {
		if (r->ifnot)
			printf(" on ! %s", r->ifname);
		else
			printf(" on %s", r->ifname);
	}
	if (r->rt) {
		if (r->rt == PF_ROUTETO)
			printf(" route-to");
		else if (r->rt == PF_REPLYTO)
			printf(" reply-to");
		else if (r->rt == PF_DUPTO)
			printf(" dup-to");
		else if (r->rt == PF_FASTROUTE)
			printf(" fastroute");
		if (r->rt != PF_FASTROUTE) {
			printf(" ");
			print_pool(&r->rpool, 0, 0, r->af, PF_PASS);
		}
	}
	if (r->af) {
		if (r->af == AF_INET)
			printf(" inet");
		else
			printf(" inet6");
	}
	if (r->proto) {
		struct protoent	*p;

		if ((p = getprotobynumber(r->proto)) != NULL)
			printf(" proto %s", p->p_name);
		else
			printf(" proto %u", r->proto);
	}
	print_fromto(&r->src, r->os_fingerprint, &r->dst, r->af, r->proto,
	    verbose);
	if (r->uid.op)
		print_ugid(r->uid.op, r->uid.uid[0], r->uid.uid[1], "user",
		    UID_MAX);
	if (r->gid.op)
		print_ugid(r->gid.op, r->gid.gid[0], r->gid.gid[1], "group",
		    GID_MAX);
	if (r->flags || r->flagset) {
		printf(" flags ");
		print_flags(r->flags);
		printf("/");
		print_flags(r->flagset);
	}
	if (r->type) {
		const struct icmptypeent	*it;

		it = geticmptypebynumber(r->type-1, r->af);
		if (r->af != AF_INET6)
			printf(" icmp-type");
		else
			printf(" icmp6-type");
		if (it != NULL)
			printf(" %s", it->name);
		else
			printf(" %u", r->type-1);
		if (r->code) {
			const struct icmpcodeent	*ic;

			ic = geticmpcodebynumber(r->type-1, r->code-1, r->af);
			if (ic != NULL)
				printf(" code %s", ic->name);
			else
				printf(" code %u", r->code-1);
		}
	}
	if (r->tos)
		printf(" tos 0x%2.2x", r->tos);
	if (r->keep_state == PF_STATE_NORMAL)
		printf(" keep state");
	else if (r->keep_state == PF_STATE_MODULATE)
		printf(" modulate state");
	else if (r->keep_state == PF_STATE_SYNPROXY)
		printf(" synproxy state");
	if (r->prob) {
		char	buf[20];

		snprintf(buf, sizeof(buf), "%f", r->prob*100.0/(UINT_MAX+1.0));
		for (i = strlen(buf)-1; i > 0; i--) {
			if (buf[i] == '0')
				buf[i] = '\0';
			else {
				if (buf[i] == '.')
					buf[i] = '\0';
				break;
			}
		}
		printf(" probability %s%%", buf);
	}
	opts = 0;
	if (r->max_states || r->max_src_nodes || r->max_src_states)
		opts = 1;
	if (r->rule_flag & PFRULE_NOSYNC)
		opts = 1;
	if (r->rule_flag & PFRULE_SRCTRACK)
		opts = 1;
	if (r->rule_flag & (PFRULE_IFBOUND | PFRULE_GRBOUND))
		opts = 1;
	for (i = 0; !opts && i < PFTM_MAX; ++i)
		if (r->timeout[i])
			opts = 1;
	if (opts) {
		printf(" (");
		if (r->max_states) {
			printf("max %u", r->max_states);
			opts = 0;
		}
		if (r->rule_flag & PFRULE_NOSYNC) {
			if (!opts)
				printf(", ");
			printf("no-sync");
			opts = 0;
		}
		if (r->rule_flag & PFRULE_SRCTRACK) {
			if (!opts)
				printf(", ");
			printf("source-track");
			if (r->rule_flag & PFRULE_RULESRCTRACK)
				printf(" rule");
			else
				printf(" global");
			opts = 0;
		}
		if (r->max_src_states) {
			if (!opts)
				printf(", ");
			printf("max-src-states %u", r->max_src_states);
			opts = 0;
		}
		if (r->max_src_nodes) {
			if (!opts)
				printf(", ");
			printf("max-src-nodes %u", r->max_src_nodes);
			opts = 0;
		}
		if (r->rule_flag & PFRULE_IFBOUND) {
			if (!opts)
				printf(", ");
			printf("if-bound");
			opts = 0;
		}
		if (r->rule_flag & PFRULE_GRBOUND) {
			if (!opts)
				printf(", ");
			printf("group-bound");
			opts = 0;
		}
		for (i = 0; i < PFTM_MAX; ++i)
			if (r->timeout[i]) {
				if (!opts)
					printf(", ");
				opts = 0;
				printf("%s %u", pf_timeouts[i].name,
				    r->timeout[i]);
			}
		printf(")");
	}
	if (r->rule_flag & PFRULE_FRAGMENT)
		printf(" fragment");
	if (r->rule_flag & PFRULE_NODF)
		printf(" no-df");
	if (r->rule_flag & PFRULE_RANDOMID)
		printf(" random-id");
	if (r->min_ttl)
		printf(" min-ttl %d", r->min_ttl);
	if (r->max_mss)
		printf(" max-mss %d", r->max_mss);
	if (r->allow_opts)
		printf(" allow-opts");
	if (r->action == PF_SCRUB) {
		if (r->rule_flag & PFRULE_REASSEMBLE_TCP)
			printf(" reassemble tcp");

		if (r->rule_flag & PFRULE_FRAGDROP)
			printf(" fragment drop-ovl");
		else if (r->rule_flag & PFRULE_FRAGCROP)
			printf(" fragment crop");
		else
			printf(" fragment reassemble");
	}
	if (r->label[0])
		printf(" label \"%s\"", r->label);
	if (r->qname[0] && r->pqname[0])
		printf(" queue(%s, %s)", r->qname, r->pqname);
	else if (r->qname[0])
		printf(" queue %s", r->qname);
	if (r->tagname[0])
		printf(" tag %s", r->tagname);
	if (r->match_tagname[0]) {
		if (r->match_tag_not)
			printf(" !");
		printf(" tagged %s", r->match_tagname);
	}
	if (!r->anchorname[0] && (r->action == PF_NAT ||
	    r->action == PF_BINAT || r->action == PF_RDR)) {
		printf(" -> ");
		print_pool(&r->rpool, r->rpool.proxy_port[0],
		    r->rpool.proxy_port[1], r->af, r->action);
	}
	printf("\n");
}

void
print_tabledef(const char *name, int flags, int addrs,
    struct node_tinithead *nodes)
{
	struct node_tinit	*ti, *nti;
	struct node_host	*h;

	printf("table <%s>", name);
	if (flags & PFR_TFLAG_CONST)
		printf(" const");
	if (flags & PFR_TFLAG_PERSIST)
		printf(" persist");
	SIMPLEQ_FOREACH(ti, nodes, entries) {
		if (ti->file) {
			printf(" file \"%s\"", ti->file);
			continue;
		}
		printf(" {");
		for (;;) {
			for (h = ti->host; h != NULL; h = h->next) {
				printf(h->not ? " !" : " ");
				print_addr(&h->addr, h->af, 0);
			}
			nti = SIMPLEQ_NEXT(ti, entries);
			if (nti != NULL && nti->file == NULL)
				ti = nti;	/* merge lists */
			else
				break;
		}
		printf(" }");
	}
	if (addrs && SIMPLEQ_EMPTY(nodes))
		printf(" { }");
	printf("\n");
}

int
parse_flags(char *s)
{
	char		*p, *q;
	u_int8_t	 f = 0;

	for (p = s; *p; p++) {
		if ((q = strchr(tcpflags, *p)) == NULL)
			return -1;
		else
			f |= 1 << (q - tcpflags);
	}
	return (f ? f : PF_TH_ALL);
}

void
set_ipmask(struct node_host *h, u_int8_t b)
{
	struct pf_addr	*m, *n;
	int		 i, j = 0;

	m = &h->addr.v.a.mask;

	for (i = 0; i < 4; i++)
		m->addr32[i] = 0;

	while (b >= 32) {
		m->addr32[j++] = 0xffffffff;
		b -= 32;
	}
	for (i = 31; i > 31-b; --i)
		m->addr32[j] |= (1 << i);
	if (b)
		m->addr32[j] = htonl(m->addr32[j]);

	/* Mask off bits of the address that will never be used. */
	n = &h->addr.v.a.addr;
	if (h->addr.type == PF_ADDR_ADDRMASK)
		for (i = 0; i < 4; i++)
			n->addr32[i] = n->addr32[i] & m->addr32[i];
}

int
check_netmask(struct node_host *h, sa_family_t af)
{
	struct node_host	*n = NULL;
	struct pf_addr	*m;

	for (n = h; n != NULL; n = n->next) {
		if (h->addr.type == PF_ADDR_TABLE)
			continue;
		m = &h->addr.v.a.mask;
		/* netmasks > 32 bit are invalid on v4 */
		if (af == AF_INET &&
		    (m->addr32[1] || m->addr32[2] || m->addr32[3])) {
			fprintf(stderr, "netmask %u invalid for IPv4 address\n",
			    unmask(m, AF_INET6));
			return (1);
		}
	}
	return (0);
}

/* interface lookup routines */

struct node_host	*iftab;

void
ifa_load(void)
{
	struct ifaddrs		*ifap, *ifa;
	struct node_host	*n = NULL, *h = NULL;
	struct pfr_buffer	 b;
	struct pfi_if		*p;

	if (getifaddrs(&ifap) < 0)
		err(1, "getifaddrs");

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (!(ifa->ifa_addr->sa_family == AF_INET ||
		    ifa->ifa_addr->sa_family == AF_INET6 ||
		    ifa->ifa_addr->sa_family == AF_LINK))
				continue;
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "address: calloc");
		n->af = ifa->ifa_addr->sa_family;
		n->ifa_flags = ifa->ifa_flags;
#ifdef __KAME__
		if (n->af == AF_INET6 &&
		    IN6_IS_ADDR_LINKLOCAL(&((struct sockaddr_in6 *)
		    ifa->ifa_addr)->sin6_addr) &&
		    ((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_scope_id ==
		    0) {
			struct sockaddr_in6	*sin6;

			sin6 = (struct sockaddr_in6 *)ifa->ifa_addr;
			sin6->sin6_scope_id = sin6->sin6_addr.s6_addr[2] << 8 |
			    sin6->sin6_addr.s6_addr[3];
			sin6->sin6_addr.s6_addr[2] = 0;
			sin6->sin6_addr.s6_addr[3] = 0;
		}
#endif
		n->ifindex = 0;
		if (n->af == AF_INET) {
			memcpy(&n->addr.v.a.addr, &((struct sockaddr_in *)
			    ifa->ifa_addr)->sin_addr.s_addr,
			    sizeof(struct in_addr));
			memcpy(&n->addr.v.a.mask, &((struct sockaddr_in *)
			    ifa->ifa_netmask)->sin_addr.s_addr,
			    sizeof(struct in_addr));
			if (ifa->ifa_broadaddr != NULL)
				memcpy(&n->bcast, &((struct sockaddr_in *)
				    ifa->ifa_broadaddr)->sin_addr.s_addr,
				    sizeof(struct in_addr));
			if (ifa->ifa_dstaddr != NULL)
				memcpy(&n->peer, &((struct sockaddr_in *)
				    ifa->ifa_dstaddr)->sin_addr.s_addr,
				    sizeof(struct in_addr));
		} else if (n->af == AF_INET6) {
			memcpy(&n->addr.v.a.addr, &((struct sockaddr_in6 *)
			    ifa->ifa_addr)->sin6_addr.s6_addr,
			    sizeof(struct in6_addr));
			memcpy(&n->addr.v.a.mask, &((struct sockaddr_in6 *)
			    ifa->ifa_netmask)->sin6_addr.s6_addr,
			    sizeof(struct in6_addr));
			if (ifa->ifa_broadaddr != NULL)
				memcpy(&n->bcast, &((struct sockaddr_in6 *)
				    ifa->ifa_broadaddr)->sin6_addr.s6_addr,
				    sizeof(struct in6_addr));
			if (ifa->ifa_dstaddr != NULL)
				 memcpy(&n->peer, &((struct sockaddr_in6 *)
				    ifa->ifa_dstaddr)->sin6_addr.s6_addr,
				    sizeof(struct in6_addr));
			n->ifindex = ((struct sockaddr_in6 *)
			    ifa->ifa_addr)->sin6_scope_id;
		}
		if ((n->ifname = strdup(ifa->ifa_name)) == NULL)
			err(1, "ifa_load: strdup");
		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}

	/* add interface groups, including clonable and dynamic stuff */
	bzero(&b, sizeof(b));
	b.pfrb_type = PFRB_IFACES;
	for (;;) {
		if (pfr_buf_grow(&b, b.pfrb_size))
			err(1, "ifa_load: pfr_buf_grow");
		b.pfrb_size = b.pfrb_msize;
		if (pfi_get_ifaces(NULL, b.pfrb_caddr, &b.pfrb_size,
		    PFI_FLAG_GROUP))
			err(1, "ifa_load: pfi_get_ifaces");
		if (b.pfrb_size <= b.pfrb_msize)
			break;
	}
	PFRB_FOREACH(p, &b) {
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "address: calloc");
		n->af = AF_LINK;
		n->ifa_flags = PF_IFA_FLAG_GROUP;
		if (p->pfif_flags & PFI_IFLAG_DYNAMIC)
			n->ifa_flags |= PF_IFA_FLAG_DYNAMIC;
		if (p->pfif_flags & PFI_IFLAG_CLONABLE)
			n->ifa_flags |= PF_IFA_FLAG_CLONABLE;
		if (!strcmp(p->pfif_name, "lo"))
			n->ifa_flags |= IFF_LOOPBACK;
		if ((n->ifname = strdup(p->pfif_name)) == NULL)
			err(1, "ifa_load: strdup");
		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}

	iftab = h;
	freeifaddrs(ifap);
}

struct node_host *
ifa_exists(const char *ifa_name, int group_ok)
{
	struct node_host	*n;
	char			*p, buf[IFNAMSIZ];
	int			 group;

	group = !isdigit(ifa_name[strlen(ifa_name) - 1]);
	if (group && !group_ok)
		return (NULL);
	if (iftab == NULL)
		ifa_load();

	for (n = iftab; n; n = n->next) {
		if (n->af == AF_LINK && !strncmp(n->ifname, ifa_name, IFNAMSIZ))
			return (n);
	}
	if (!group) {
		/* look for clonable and/or dynamic interface */
		strlcpy(buf, ifa_name, sizeof(buf));
		for (p = buf + strlen(buf) - 1; p > buf && isdigit(*p); p--)
			*p = '\0';
		for (n = iftab; n != NULL; n = n->next)
			if (n->af == AF_LINK &&
			    !strncmp(n->ifname, buf, IFNAMSIZ))
				break;
		if (n != NULL && n->ifa_flags &
		    (PF_IFA_FLAG_DYNAMIC | PF_IFA_FLAG_CLONABLE))
			return (n);	/* XXX */
	}
	return (NULL);
}

struct node_host *
ifa_lookup(const char *ifa_name, int flags)
{
	struct node_host	*p = NULL, *h = NULL, *n = NULL;
	int			 got4 = 0, got6 = 0;
	const char		 *last_if = NULL;

	if (!strncmp(ifa_name, "self", IFNAMSIZ))
		ifa_name = NULL;

	if (iftab == NULL)
		ifa_load();

	for (p = iftab; p; p = p->next) {
		if (ifa_skip_if(ifa_name, p))
			continue;
		if ((flags & PFI_AFLAG_BROADCAST) && p->af != AF_INET)
			continue;
		if ((flags & PFI_AFLAG_BROADCAST) &&
		    !(p->ifa_flags & IFF_BROADCAST))
			continue;
		if ((flags & PFI_AFLAG_PEER) &&
		    !(p->ifa_flags & IFF_POINTOPOINT))
			continue;
		if ((flags & PFI_AFLAG_NETWORK) && p->ifindex > 0)
			continue;
		if (last_if == NULL || strcmp(last_if, p->ifname))
			got4 = got6 = 0;
		last_if = p->ifname;
		if ((flags & PFI_AFLAG_NOALIAS) && p->af == AF_INET && got4)
			continue;
		if ((flags & PFI_AFLAG_NOALIAS) && p->af == AF_INET6 && got6)
			continue;
		if (p->af == AF_INET)
			got4 = 1;
		else
			got6 = 1;
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "address: calloc");
		n->af = p->af;
		if (flags & PFI_AFLAG_BROADCAST)
			memcpy(&n->addr.v.a.addr, &p->bcast,
			    sizeof(struct pf_addr));
		else if (flags & PFI_AFLAG_PEER)
			memcpy(&n->addr.v.a.addr, &p->peer,
			    sizeof(struct pf_addr));
		else
			memcpy(&n->addr.v.a.addr, &p->addr.v.a.addr,
			    sizeof(struct pf_addr));
		if (flags & PFI_AFLAG_NETWORK)
			set_ipmask(n, unmask(&p->addr.v.a.mask, n->af));
		else {
			if (n->af == AF_INET) {
				if (p->ifa_flags & IFF_LOOPBACK &&
				    p->ifa_flags & IFF_LINK1)
					memcpy(&n->addr.v.a.mask,
					    &p->addr.v.a.mask,
					    sizeof(struct pf_addr));
				else
					set_ipmask(n, 32);
			} else
				set_ipmask(n, 128);
		}
		n->ifindex = p->ifindex;

		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}
	return (h);
}

int
ifa_skip_if(const char *filter, struct node_host *p)
{
	int	n;

	if (p->af != AF_INET && p->af != AF_INET6)
		return (1);
	if (filter == NULL || !*filter)
		return (0);
	if (!strcmp(p->ifname, filter))
		return (0);	/* exact match */
	n = strlen(filter);
	if (n < 1 || n >= IFNAMSIZ)
		return (1);	/* sanity check */
	if (filter[n-1] >= '0' && filter[n-1] <= '9')
		return (1);	/* only do exact match in that case */
	if (strncmp(p->ifname, filter, n))
		return (1);	/* prefix doesn't match */
	return (p->ifname[n] < '0' || p->ifname[n] > '9');
}


struct node_host *
host(const char *s)
{
	struct node_host	*h = NULL;
	int			 mask, v4mask, v6mask, cont = 1;
	char			*p, *q, *ps;

	if ((p = strrchr(s, '/')) != NULL) {
		mask = strtol(p+1, &q, 0);
		if (!q || *q || mask > 128 || q == (p+1)) {
			fprintf(stderr, "invalid netmask\n");
			return (NULL);
		}
		if ((ps = malloc(strlen(s) - strlen(p) + 1)) == NULL)
			err(1, "host: malloc");
		strlcpy(ps, s, strlen(s) - strlen(p) + 1);
		v4mask = v6mask = mask;
	} else {
		if ((ps = strdup(s)) == NULL)
			err(1, "host: strdup");
		v4mask = 32;
		v6mask = 128;
		mask = -1;
	}

	/* interface with this name exists? */
	if (cont && (h = host_if(ps, mask)) != NULL)
		cont = 0;

	/* IPv4 address? */
	if (cont && (h = host_v4(s, mask)) != NULL)
		cont = 0;

	/* IPv6 address? */
	if (cont && (h = host_v6(ps, v6mask)) != NULL)
		cont = 0;

	/* dns lookup */
	if (cont && (h = host_dns(ps, v4mask, v6mask)) != NULL)
		cont = 0;
	free(ps);

	if (h == NULL || cont == 1) {
		fprintf(stderr, "no IP address found for %s\n", s);
		return (NULL);
	}
	return (h);
}

struct node_host *
host_if(const char *s, int mask)
{
	struct node_host	*n, *h = NULL;
	char			*p, *ps;
	int			 flags = 0;

	if ((ps = strdup(s)) == NULL)
		err(1, "host_if: strdup");
	while ((p = strrchr(ps, ':')) != NULL) {
		if (!strcmp(p+1, "network"))
			flags |= PFI_AFLAG_NETWORK;
		else if (!strcmp(p+1, "broadcast"))
			flags |= PFI_AFLAG_BROADCAST;
		else if (!strcmp(p+1, "peer"))
			flags |= PFI_AFLAG_PEER;
		else if (!strcmp(p+1, "0"))
			flags |= PFI_AFLAG_NOALIAS;
		else {
			free(ps);
			return (NULL);
		}
		*p = '\0';
	}
	if (flags & (flags - 1) & PFI_AFLAG_MODEMASK) { /* Yep! */
		fprintf(stderr, "illegal combination of interface modifiers\n");
		free(ps);
		return (NULL);
	}
	if ((flags & (PFI_AFLAG_NETWORK|PFI_AFLAG_BROADCAST)) && mask > -1) {
		fprintf(stderr, "network or broadcast lookup, but "
		    "extra netmask given\n");
		free(ps);
		return (NULL);
	}
	if (ifa_exists(ps, 1) || !strncmp(ps, "self", IFNAMSIZ)) {
		/* interface with this name exists */
		h = ifa_lookup(ps, flags);
		for (n = h; n != NULL && mask > -1; n = n->next)
			set_ipmask(n, mask);
	}

	free(ps);
	return (h);
}

struct node_host *
host_v4(const char *s, int mask)
{
	struct node_host	*h = NULL;
	struct in_addr		 ina;
	int			 bits = 32;

	memset(&ina, 0, sizeof(struct in_addr));
	if (strrchr(s, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(ina))) == -1)
			return (NULL);
	} else {
		if (inet_pton(AF_INET, s, &ina) != 1)
			return (NULL);
	}

	h = calloc(1, sizeof(struct node_host));
	if (h == NULL)
		err(1, "address: calloc");
	h->ifname = NULL;
	h->af = AF_INET;
	h->addr.v.a.addr.addr32[0] = ina.s_addr;
	set_ipmask(h, bits);
	h->next = NULL;
	h->tail = h;

	return (h);
}

struct node_host *
host_v6(const char *s, int mask)
{
	struct addrinfo		 hints, *res;
	struct node_host	*h = NULL;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_DGRAM; /*dummy*/
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(s, "0", &hints, &res) == 0) {
		h = calloc(1, sizeof(struct node_host));
		if (h == NULL)
			err(1, "address: calloc");
		h->ifname = NULL;
		h->af = AF_INET6;
		memcpy(&h->addr.v.a.addr,
		    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr,
		    sizeof(h->addr.v.a.addr));
		h->ifindex =
		    ((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id;
		set_ipmask(h, mask);
		freeaddrinfo(res);
		h->next = NULL;
		h->tail = h;
	}

	return (h);
}

struct node_host *
host_dns(const char *s, int v4mask, int v6mask)
{
	struct addrinfo		 hints, *res0, *res;
	struct node_host	*n, *h = NULL;
	int			 error, noalias = 0;
	int			 got4 = 0, got6 = 0;
	char			*p, *ps;

	if ((ps = strdup(s)) == NULL)
		err(1, "host_dns: strdup");
	if ((p = strrchr(ps, ':')) != NULL && !strcmp(p, ":0")) {
		noalias = 1;
		*p = '\0';
	}
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM; /* DUMMY */
	error = getaddrinfo(ps, NULL, &hints, &res0);
	if (error)
		return (h);

	for (res = res0; res; res = res->ai_next) {
		if (res->ai_family != AF_INET &&
		    res->ai_family != AF_INET6)
			continue;
		if (noalias) {
			if (res->ai_family == AF_INET) {
				if (got4)
					continue;
				got4 = 1;
			} else {
				if (got6)
					continue;
				got6 = 1;
			}
		}
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "host_dns: calloc");
		n->ifname = NULL;
		n->af = res->ai_family;
		if (res->ai_family == AF_INET) {
			memcpy(&n->addr.v.a.addr,
			    &((struct sockaddr_in *)
			    res->ai_addr)->sin_addr.s_addr,
			    sizeof(struct in_addr));
			set_ipmask(n, v4mask);
		} else {
			memcpy(&n->addr.v.a.addr,
			    &((struct sockaddr_in6 *)
			    res->ai_addr)->sin6_addr.s6_addr,
			    sizeof(struct in6_addr));
			n->ifindex =
			    ((struct sockaddr_in6 *)
			    res->ai_addr)->sin6_scope_id;
			set_ipmask(n, v6mask);
		}
		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}
	freeaddrinfo(res0);
	free(ps);

	return (h);
}

/*
 * convert a hostname to a list of addresses and put them in the given buffer.
 * test:
 *	if set to 1, only simple addresses are accepted (no netblock, no "!").
 */
int
append_addr(struct pfr_buffer *b, char *s, int test)
{
	char			 *r;
	struct node_host	*h, *n;
	int			 rv, not = 0;

	for (r = s; *r == '!'; r++)
		not = !not;
	if ((n = host(r)) == NULL) {
		errno = 0;
		return (-1);
	}
	rv = append_addr_host(b, n, test, not);
	do {
		h = n;
		n = n->next;
		free(h);
	} while (n != NULL);
	return (rv);
}

/*
 * same as previous function, but with a pre-parsed input and the ability
 * to "negate" the result. Does not free the node_host list.
 * not:
 *      setting it to 1 is equivalent to adding "!" in front of parameter s.
 */
int
append_addr_host(struct pfr_buffer *b, struct node_host *n, int test, int not)
{
	int			 bits;
	struct pfr_addr		 addr;

	do {
		bzero(&addr, sizeof(addr));
		addr.pfra_not = n->not ^ not;
		addr.pfra_af = n->af;
		addr.pfra_net = unmask(&n->addr.v.a.mask, n->af);
		switch (n->af) {
		case AF_INET:
			addr.pfra_ip4addr.s_addr = n->addr.v.a.addr.addr32[0];
			bits = 32;
			break;
		case AF_INET6:
			memcpy(&addr.pfra_ip6addr, &n->addr.v.a.addr.v6,
			    sizeof(struct in6_addr));
			bits = 128;
			break;
		default:
			errno = EINVAL;
			return (-1);
		}
		if ((test && (not || addr.pfra_net != bits)) ||
		    addr.pfra_net > bits) {
			errno = EINVAL;
			return (-1);
		}
		if (pfr_buf_add(b, &addr))
			return (-1);
	} while ((n = n->next) != NULL);

	return (0);
}

int
pfctl_add_trans(struct pfr_buffer *buf, int rs_num, const char *anchor,
    const char *ruleset)
{
	struct pfioc_trans_e trans;

	bzero(&trans, sizeof(trans));
	trans.rs_num = rs_num;
	if (strlcpy(trans.anchor, anchor,
	    sizeof(trans.anchor)) >= sizeof(trans.anchor) ||
	    strlcpy(trans.ruleset, ruleset,
	    sizeof(trans.ruleset)) >= sizeof(trans.ruleset))
		errx(1, "pfctl_add_trans: strlcpy");

	return pfr_buf_add(buf, &trans);
}

u_int32_t
pfctl_get_ticket(struct pfr_buffer *buf, int rs_num, const char *anchor,
    const char *ruleset)
{
	struct pfioc_trans_e *p;

	PFRB_FOREACH(p, buf)
		if (rs_num == p->rs_num && !strcmp(anchor, p->anchor) &&
		    !strcmp(ruleset, p->ruleset))
			return (p->ticket);
	errx(1, "pfctl_get_ticket: assertion failed");
}

int
pfctl_trans(int dev, struct pfr_buffer *buf, u_long cmd, int from)
{
	struct pfioc_trans trans;

	bzero(&trans, sizeof(trans));
	trans.size = buf->pfrb_size - from;
	trans.esize = sizeof(struct pfioc_trans_e);
	trans.array = ((struct pfioc_trans_e *)buf->pfrb_caddr) + from;
	return ioctl(dev, cmd, &trans);
}
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: pfctl_parser.c,v 1.146 2003/03/19 15:56:08 henning Exp $ */
d6 1
d36 1
d60 2
d63 2
a64 3
void		 print_port (u_int8_t, u_int16_t, u_int16_t, char *);
void		 print_uid (u_int8_t, uid_t, uid_t, const char *);
void		 print_gid (u_int8_t, gid_t, gid_t, const char *);
d66 3
a68 2
void		 print_fromto(struct pf_rule_addr *, struct pf_rule_addr *,
		    u_int8_t, u_int8_t, int);
d75 1
a75 1
char *tcpflags = "FSRPAUEW";
d113 1
a113 1
	{ "listqry",	MLD6_LISTENER_QUERY },
d115 1
a115 1
	{ "listenrep",	MLD6_LISTENER_REPORT },
d117 1
a117 1
	{ "listendone", MLD6_LISTENER_DONE },
d130 2
a131 2
	{ "mtraceresp",	MLD6_MTRACE_RESP },
	{ "mtrace",	MLD6_MTRACE }
d189 1
d200 3
d262 1
a262 1
		   sizeof(icmp6_code[0])); i++) {
d298 1
a298 1
		printf("%s >< %s ", a1, a2);
d300 1
a300 1
		printf("%s <> %s ", a1, a2);
d302 1
a302 1
		printf("= %s ", a1);
d304 1
a304 1
		printf("!= %s ", a1);
d306 1
a306 1
		printf("< %s ", a1);
d308 1
a308 1
		printf("<= %s ", a1);
d310 1
a310 1
		printf("> %s ", a1);
d312 1
a312 1
		printf(">= %s ", a1);
d314 1
a314 1
		printf("%s:%s ", a1, a2);
d318 1
a318 1
print_port(u_int8_t op, u_int16_t p1, u_int16_t p2, char *proto)
d328 1
a328 1
	printf("port ");
d336 1
a336 1
print_uid(u_int8_t op, uid_t u1, uid_t u2, const char *t)
d342 2
a343 16
	printf("%s ", t);
	if (u1 == UID_MAX && (op == PF_OP_EQ || op == PF_OP_NE))
		print_op(op, "unknown", a2);
	else
		print_op(op, a1, a2);
}

void
print_gid(u_int8_t op, gid_t g1, gid_t g2, const char *t)
{
	char	a1[11], a2[11];

	snprintf(a1, sizeof(a1), "%u", g1);
	snprintf(a2, sizeof(a2), "%u", g2);
	printf("%s ", t);
	if (g1 == GID_MAX && (op == PF_OP_EQ || op == PF_OP_NE))
d360 1
a360 1
print_fromto(struct pf_rule_addr *src, struct pf_rule_addr *dst,
d363 3
a365 2
	if (src->addr.type != PF_ADDR_NOROUTE &&
	    dst->addr.type != PF_ADDR_NOROUTE &&
d368 6
a373 3
	    !src->port_op && PF_AZERO(&dst->addr.v.a.addr, AF_INET6) &&
	    PF_AZERO(&dst->addr.v.a.mask, AF_INET6) && !dst->port_op)
		printf("all ");
d375 4
a378 12
		printf("from ");
		if (src->addr.type == PF_ADDR_NOROUTE)
			printf("no-route ");
		else if (PF_AZERO(&src->addr.v.a.addr, AF_INET6) &&
		    PF_AZERO(&src->addr.v.a.mask, AF_INET6))
			printf("any ");
		else {
			if (src->not)
				printf("! ");
			print_addr(&src->addr, af, verbose);
			printf(" ");
		}
d383 3
d387 4
a390 12
		printf("to ");
		if (dst->addr.type == PF_ADDR_NOROUTE)
			printf("no-route ");
		else if (PF_AZERO(&dst->addr.v.a.addr, AF_INET6) &&
		    PF_AZERO(&dst->addr.v.a.mask, AF_INET6))
			printf("any ");
		else {
			if (dst->not)
				printf("! ");
			print_addr(&dst->addr, af, verbose);
			printf(" ");
		}
a398 25
print_rule(struct pf_rule *r, int verbose)
{
	switch (r->action) {
	case PF_NAT:
	case PF_NONAT:
		print_nat(r, verbose);
		break;
	case PF_BINAT:
	case PF_NOBINAT:
		print_binat(r, verbose);
		break;
	case PF_RDR:
	case PF_NORDR:
		print_rdr(r, verbose);
		break;
	default:
	case PF_PASS:
	case PF_DROP:
	case PF_SCRUB:
		print_filter(r, verbose);
		break;
	}
}

void
d412 1
a412 1
			print_addr(&pooladdr->addr.addr, af, 0);
d415 1
a415 1
			if (PF_AZERO(&pooladdr->addr.addr.v.a.addr, af))
d419 1
a419 1
				print_addr(&pooladdr->addr.addr, af, 0);
d433 2
a434 2
		if (p1 != PF_NAT_PROXY_PORT_LOW ||
		    p2 != PF_NAT_PROXY_PORT_HIGH) {
d469 3
a471 1
	if (pool->opts & PF_POOL_STATICPORT)
d475 3
a477 122
void
print_nat(struct pf_rule *n, int verbose)
{
	if (verbose)
		printf("@@%d ", n->nr);
	if (n->anchorname[0])
		printf("nat-anchor %s ", n->anchorname);
	else {
		if (n->action == PF_NONAT)
			printf("no ");
		printf("nat ");
	}
	if (n->ifname[0]) {
		printf("on ");
		if (n->ifnot)
			printf("! ");
		printf("%s ", n->ifname);
	}
	if (n->af) {
		if (n->af == AF_INET)
			printf("inet ");
		else
			printf("inet6 ");
	}
	if (n->proto) {
		struct protoent	*p;

		if ((p = getprotobynumber(n->proto)) != NULL)
			printf("proto %s ", p->p_name);
		else
			printf("proto %u ", n->proto);
	}
	print_fromto(&n->src, &n->dst, n->af, n->proto, verbose);
	if (!n->anchorname[0] && (n->action == PF_NAT)) {
		printf("-> ");
		print_pool(&n->rpool, n->rpool.proxy_port[0],
		    n->rpool.proxy_port[1], n->af, PF_NAT);
	}
	printf("\n");
}

void
print_binat(struct pf_rule *b, int verbose)
{
	if (verbose)
		printf("@@%d ", b->nr);
	if (b->anchorname[0])
		printf("binat-anchor %s ", b->anchorname);
	else {
		if (b->action == PF_NOBINAT)
			printf("no ");
		printf("binat ");
	}
	if (b->ifname[0]) {
		printf("on ");
		printf("%s ", b->ifname);
	}
	if (b->af) {
		if (b->af == AF_INET)
			printf("inet ");
		else
			printf("inet6 ");
	}
	if (b->proto) {
		struct protoent	*p;

		if ((p = getprotobynumber(b->proto)) != NULL)
			printf("proto %s ", p->p_name);
		else
			printf("proto %u ", b->proto);
	}
	print_fromto(&b->src, &b->dst, b->af, b->proto, verbose);
	if (!b->anchorname[0] && (b->action == PF_BINAT)) {
		printf("-> ");
		print_pool(&b->rpool, 0, 0, b->af, PF_BINAT);
	}
	printf("\n");
}

void
print_rdr(struct pf_rule *r, int verbose)
{
	if (verbose)
		printf("@@%d ", r->nr);
	if (r->anchorname[0])
		printf("rdr-anchor %s ", r->anchorname);
	else {
		if (r->action == PF_NORDR)
			printf("no ");
		printf("rdr ");
	}
	if (r->ifname[0]) {
		printf("on ");
		if (r->ifnot)
			printf("! ");
		printf("%s ", r->ifname);
	}
	if (r->af) {
		if (r->af == AF_INET)
			printf("inet ");
		else
			printf("inet6 ");
	}
	if (r->proto) {
		struct protoent	*p;

		if ((p = getprotobynumber(r->proto)) != NULL)
			printf("proto %s ", p->p_name);
		else
			printf("proto %u ", r->proto);
	}
	print_fromto(&r->src, &r->dst, r->af, r->proto, verbose);
	if (!r->anchorname[0] && (r->action == PF_RDR)) {
		printf("-> ");
		print_pool(&r->rpool, r->rpool.proxy_port[0],
		    r->rpool.proxy_port[1], r->af, PF_RDR);
	}
	printf("\n");
}

char	*pf_reasons[PFRES_MAX+1] = PFRES_NAMES;
char	*pf_fcounters[FCNT_MAX+1] = FCNT_NAMES;
d480 1
a480 1
print_status(struct pf_status *s)
d482 1
a482 1
	char	statline[80];
d487 1
d489 1
a489 1
	if (s->running) {
d499 2
a500 2
		    "Status: Enabled for %u days %.2u:%.2u:%.2u",
		    day, hrs, min, sec);
d502 1
a502 1
		snprintf(statline, sizeof(statline), "Status: Disabled");
d505 1
a505 1
	case 0:
d508 1
a508 1
	case 1:
d511 1
a511 1
	case 2:
d514 3
d518 1
d523 2
a524 1
		    s->bcounters[0][0], s->bcounters[1][0]);
d526 2
a527 1
		    s->bcounters[0][1], s->bcounters[1][1]);
d530 2
a531 2
		    s->pcounters[0][0][PF_PASS],
		    s->pcounters[1][0][PF_PASS]);
d533 2
a534 2
		    s->pcounters[0][0][PF_DROP],
		    s->pcounters[1][0][PF_DROP]);
d537 2
a538 2
		    s->pcounters[0][1][PF_PASS],
		    s->pcounters[1][1][PF_PASS]);
d540 2
a541 2
		    s->pcounters[0][1][PF_DROP],
		    s->pcounters[1][1][PF_DROP]);
d546 2
a547 2
		printf("  %-25s %14lld ", pf_fcounters[i],
			    s->fcounters[i]);
d554 14
d570 2
a571 2
		printf("  %-25s %14lld ", pf_reasons[i],
		    s->counters[i]);
d581 1
a581 1
print_filter(struct pf_rule *r, int verbose)
d583 56
d643 10
a652 6
	if (r->anchorname[0])
		printf("anchor %s ", r->anchorname);
	else if (r->action == PF_PASS)
		printf("pass ");
	else if (r->action == PF_DROP) {
		printf("block ");
d654 1
a654 1
			printf("return ");
d657 1
a657 1
				printf("return-rst ");
d659 1
a659 1
				printf("return-rst(ttl %d) ", r->return_ttl);
d668 1
a668 1
			switch(r->af) {
d670 1
a670 1
				printf("return-icmp");
d672 1
a672 1
					printf("(%u) ", r->return_icmp & 255);
d674 1
a674 1
					printf("(%s) ", ic->name);
d677 1
a677 1
				printf("return-icmp6");
d679 1
a679 1
					printf("(%u) ", r->return_icmp6 & 255);
d681 1
a681 1
					printf("(%s) ", ic6->name);
d684 1
a684 1
				printf("return-icmp");
d690 1
a690 1
					printf("%u) ", r->return_icmp6 & 255);
d692 1
a692 1
					printf("%s) ", ic6->name);
d696 2
a697 3
			printf("drop ");
	} else
		printf("scrub ");
d699 1
a699 1
		printf("in ");
d701 1
a701 1
		printf("out ");
d703 1
a703 1
		printf("log ");
d705 1
a705 1
		printf("log-all ");
d707 1
a707 1
		printf("quick ");
d710 1
a710 1
			printf("on ! %s ", r->ifname);
d712 1
a712 1
			printf("on %s ", r->ifname);
d716 1
a716 1
			printf("route-to ");
d718 1
a718 1
			printf("reply-to ");
d720 1
a720 1
			printf("dup-to ");
d722 1
a722 1
			printf("fastroute ");
d724 1
a725 1
			printf(" ");
d730 1
a730 1
			printf("inet ");
d732 1
a732 1
			printf("inet6 ");
d738 1
a738 1
			printf("proto %s ", p->p_name);
d740 1
a740 1
			printf("proto %u ", r->proto);
d742 2
a743 1
	print_fromto(&r->src, &r->dst, r->af, r->proto, verbose);
d745 2
a746 1
		print_uid(r->uid.op, r->uid.uid[0], r->uid.uid[1], "user");
d748 2
a749 1
		print_gid(r->gid.op, r->gid.gid[0], r->gid.gid[1], "group");
d751 1
a751 1
		printf("flags ");
a754 1
		printf(" ");
d761 1
a761 1
			printf("icmp-type");
d763 1
a763 1
			printf("icmp6-type");
d765 1
a765 1
			printf(" %s ", it->name);
d767 1
a767 1
			printf(" %u ", r->type-1);
d773 1
a773 1
				printf("code %s ", ic->name);
d775 1
a775 1
				printf("code %u ", r->code-1);
d779 1
a779 1
		printf("tos 0x%2.2x ", r->tos);
d781 1
a781 1
		printf("keep state ");
d783 18
a800 1
		printf("modulate state ");
d802 7
a808 1
	if (r->max_states)
d814 1
a814 1
		printf("(");
d819 40
d867 1
a867 1
		printf(") ");
d870 1
a870 1
		printf("fragment ");
d872 1
a872 1
		printf("no-df ");
d874 1
a874 1
		printf("random-id ");
d876 1
a876 1
		printf("min-ttl %d ", r->min_ttl);
d878 1
a878 1
		printf("max-mss %d ", r->max_mss);
d880 1
a880 1
		printf("allow-opts ");
d882 3
d886 1
a886 1
			printf("fragment drop-ovl ");
d888 1
a888 1
			printf("fragment crop ");
d890 1
a890 1
			printf("fragment reassemble ");
d893 1
a893 1
		printf("label \"%s\" ", r->label);
d895 1
a895 1
		printf("queue(%s, %s) ", r->qname, r->pqname);
d897 23
a919 1
		printf("queue %s ", r->qname);
d921 26
d987 24
a1010 2
	for (i = 0; i < 4; i++)
		n->addr32[i] = n->addr32[i] & m->addr32[i];
d1022 2
d1042 2
a1043 1
		    ((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_scope_id == 0) {
d1065 4
d1080 4
d1098 38
d1141 1
a1141 1
ifa_exists(const char *ifa_name)
d1144 2
d1147 3
d1157 13
d1174 1
a1174 1
ifa_lookup(const char *ifa_name, enum pfctl_iflookup_mode mode)
d1177 2
a1178 1
	int			 return_all = 0;
d1181 1
a1181 1
		return_all = 1;
d1187 11
a1197 2
		if (!((p->af == AF_INET || p->af == AF_INET6) &&
		    (!strncmp(p->ifname, ifa_name, IFNAMSIZ) || return_all)))
d1199 4
a1202 1
		if (mode == PFCTL_IFLOOKUP_BCAST && p->af != AF_INET)
d1204 1
a1204 1
		if (mode == PFCTL_IFLOOKUP_NET && p->ifindex > 0)
d1206 4
d1214 1
a1214 1
		if (mode == PFCTL_IFLOOKUP_BCAST)
d1217 3
d1223 1
a1223 1
		if (mode == PFCTL_IFLOOKUP_NET)
a1247 3
	if (h == NULL && mode == PFCTL_IFLOOKUP_HOST) {
		fprintf(stderr, "no IP address found for %s\n", ifa_name);
	}
d1251 22
d1274 1
a1274 1
host(const char *s, int mask)
d1277 2
a1278 2
	int			 v4mask, v6mask, cont = 1;
	char			*buf = NULL, *p, *q, *ps;
a1280 5
		if (mask != -1) {
			fprintf(stderr, "address with netmask specified"
			    " and extra netmask supplied\n");
			return (NULL);
		}
d1282 1
a1282 1
		if (!q || *q) {
a1285 2
		if ((buf = strdup(s)) == NULL)
			err(1, "host: strdup");
d1291 5
a1295 15
		if (asprintf(&ps, "%s", s) == -1)
			err(1, "host: asprintf");
		if (mask == -1) {
			if (asprintf(&buf, "%s", s) == -1)
				err(1, "host: asprintf");
			v4mask = 32;
			v6mask = 128;
		} else if (mask <= 128) {
			if (asprintf(&buf, "%s/%d", s, mask) == -1)
				err(1, "host: asprintf");
			v4mask = v6mask = mask;
		} else {
			fprintf(stderr, "illegal mask %d\n", mask);
			return (NULL);
		}
d1303 1
a1303 1
	if (cont && (h = host_v4(buf, mask)) != NULL)
a1304 1
	free(buf);
d1327 1
a1327 1
	int			 mode = PFCTL_IFLOOKUP_HOST;
d1329 3
a1331 2
	if ((p = strrchr(s, ':')) != NULL &&
	    (!strcmp(p+1, "network") || !strcmp(p+1, "broadcast"))) {
d1333 9
a1341 6
			mode = PFCTL_IFLOOKUP_NET;
		if (!strcmp(p+1, "broadcast"))
			mode = PFCTL_IFLOOKUP_BCAST;
		if (mask > -1) {
			fprintf(stderr, "network or broadcast lookup, but "
			    "extra netmask given\n");
d1344 14
a1357 8
		if ((ps = malloc(strlen(s) - strlen(p) + 1)) == NULL)
			err(1, "host: malloc");
		strlcpy(ps, s, strlen(s) - strlen(p) + 1);
	} else
		if ((ps = strdup(s)) == NULL)
			err(1, "host_if: strdup");

	if (ifa_exists(ps) || !strncmp(ps, "self", IFNAMSIZ)) {
d1359 1
a1359 1
		h = ifa_lookup(ps, mode);
d1373 1
a1373 1
	int			 bits;
d1376 6
a1381 14
	if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(ina))) > -1) {
		h = calloc(1, sizeof(struct node_host));
		if (h == NULL)
			err(1, "address: calloc");
		h->ifname = NULL;
		h->af = AF_INET;
		h->addr.v.a.addr.addr32[0] = ina.s_addr;
		/* inet_net_pton acts strange w/ multicast addresses, RFC1112 */
		if (mask == -1 && h->addr.v.a.addr.addr8[0] >= 224 &&
		    h->addr.v.a.addr.addr8[0] < 240)
			bits = 32;
		set_ipmask(h, bits);
		h->next = NULL;
		h->tail = h;
d1384 10
d1432 3
a1434 1
	int			 error;
d1436 6
d1445 1
a1445 1
	error = getaddrinfo(s, NULL, &hints, &res0);
d1453 11
d1495 1
d1498 112
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD repository of CTM 3155 (roughly today at noon).
Mostly in order to go 3.3-current and ease further merges of
both OpenBSD and ELFdiffs after the MirBSD has been enabled
to build again.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.148 2003/03/28 20:37:29 henning Exp $ */
d58 1
a58 1
void		 print_port (u_int8_t, u_int16_t, u_int16_t, const char *);
d70 1
a70 1
const char *tcpflags = "FSRPAUEW";
d309 1
a309 1
print_port(u_int8_t op, u_int16_t p1, u_int16_t p2, const char *proto)
d632 2
a633 2
const char	*pf_reasons[PFRES_MAX+1] = PFRES_NAMES;
const char	*pf_fcounters[FCNT_MAX+1] = FCNT_NAMES;
@


1.1.1.3
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.150 2003/04/05 23:56:32 henning Exp $ */
d59 2
a60 1
void		 print_ugid (u_int8_t, unsigned, unsigned, const char *, unsigned);
d327 1
a327 1
print_ugid(u_int8_t op, unsigned u1, unsigned u2, const char *t, unsigned umax)
d334 15
a348 1
	if (u1 == umax && (op == PF_OP_EQ || op == PF_OP_NE))
d368 2
a369 2
	if (src->addr.type == PF_ADDR_ADDRMASK &&
	    dst->addr.type == PF_ADDR_ADDRMASK &&
d372 2
a373 4
	    PF_AZERO(&dst->addr.v.a.addr, AF_INET6) &&
	    PF_AZERO(&dst->addr.v.a.mask, AF_INET6) &&
	    !src->not && !dst->not &&
	    !src->port_op && !dst->port_op)
d377 11
a387 4
		if (src->not)
			printf("! ");
		print_addr(&src->addr, af, verbose);
		printf(" ");
d394 11
a404 4
		if (dst->not)
			printf("! ");
		print_addr(&dst->addr, af, verbose);
		printf(" ");
d413 25
d512 120
d716 1
a716 1
print_rule(struct pf_rule *r, int verbose)
a717 5
	static const char *actiontypes[] = { "pass", "block", "scrub", "nat",
	    "no nat", "binat", "no binat", "rdr", "no rdr" };
	static const char *anchortypes[] = { "anchor", "anchor", "anchor",
	    "nat-anchor", "nat-anchor", "binat-anchor", "binat-anchor",
	    "rdr-anchor", "rdr-anchor" };
d722 6
a727 7
	if (r->action > PF_NORDR)
		printf("action(%d) ", r->action);
	else if (r->anchorname[0])
		printf("%s %s ", anchortypes[r->action], r->anchorname);
	else
		printf("%s ", actiontypes[r->action]);
	if (r->action == PF_DROP) {
d772 2
a773 1
	}
a818 6
	if (!r->anchorname[0] && (r->action == PF_NAT ||
	    r->action == PF_BINAT || r->action == PF_RDR)) {
		printf("-> ");
		print_pool(&r->rpool, r->rpool.proxy_port[0],
		    r->rpool.proxy_port[1], r->af, r->action);
	}
d820 1
a820 2
		print_ugid(r->uid.op, r->uid.uid[0], r->uid.uid[1], "user",
		    UID_MAX);
d822 1
a822 2
		print_ugid(r->gid.op, r->gid.gid[0], r->gid.gid[1], "group",
		    GID_MAX);
d1106 1
a1106 1
host(const char *s)
d1109 2
a1110 2
	int			 mask, v4mask, v6mask, cont = 1;
	char			*p, *q, *ps;
d1113 5
d1123 2
d1130 15
a1144 5
		if ((ps = strdup(s)) == NULL)
			err(1, "host: strdup");
		v4mask = 32;
		v6mask = 128;
		mask = -1;
d1152 1
a1152 1
	if (cont && (h = host_v4(s, mask)) != NULL)
d1154 1
@


1.1.1.4
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.151 2003/04/25 19:44:57 henning Exp $ */
d1046 4
@


1.1.1.5
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.160 2003/05/19 20:21:53 henning Exp $ */
a192 2
	{ "adaptive.start",	PFTM_ADAPTIVE_START },
	{ "adaptive.end",	PFTM_ADAPTIVE_END },
d652 6
a698 2
	else if (r->keep_state == PF_STATE_SYNPROXY)
		printf("synproxy state ");
a733 3
		if (r->rule_flag & PFRULE_REASSEMBLE_TCP)
			printf("reassemble tcp ");

d747 1
a747 13
	if (r->tagname[0])
		printf("tag %s ", r->tagname);
	if (r->match_tagname[0]) {
		if (r->match_tag_not)
			printf("! ");
		printf("tagged %s ", r->match_tagname);
	}
	if (!r->anchorname[0] && (r->action == PF_NAT ||
	    r->action == PF_BINAT || r->action == PF_RDR)) {
		printf("-> ");
		print_pool(&r->rpool, r->rpool.proxy_port[0],
		    r->rpool.proxy_port[1], r->af, r->action);
	}
a791 23
int
check_netmask(struct node_host *h, sa_family_t af)
{
	struct node_host	*n = NULL;
	struct pf_addr	*m;

	for (n = h; n != NULL; n = n->next) {
		m = &h->addr.v.a.mask;
		/* fix up netmask for dynaddr */
		if (af == AF_INET && h->addr.type == PF_ADDR_DYNIFTL &&
		    unmask(m, AF_INET6) > 32)
			set_ipmask(n, 32);
		/* netmasks > 32 bit are invalid on v4 */
		if (af == AF_INET &&
		    (m->addr32[1] || m->addr32[2] || m->addr32[3])) {
			fprintf(stderr, "netmask %u invalid for IPv4 address\n",
			    unmask(m, AF_INET6));
			return (1);
		}
	}
	return (0);
}

d955 1
a955 1
		if (!q || *q || mask > 128) {
@


1.1.1.6
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.161 2003/05/24 19:14:06 henning Exp $ */
d991 1
a991 1
		if (!q || *q || mask > 128 || q == (p+1)) {
@


1.1.1.7
log
@MFC latest OpenBSD fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.162 2003/06/09 11:14:46 mcbride Exp $ */
d422 2
a423 2
		if ((p1 != PF_NAT_PROXY_PORT_LOW ||
		    p2 != PF_NAT_PROXY_PORT_HIGH) && (p1 != 0 || p2 != 0)) {
d458 1
a458 1
	if (id == PF_NAT && p1 == 0 && p2 == 0)
@


1.1.1.8
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.164 2003/06/12 09:40:33 henning Exp $ */
d107 1
a107 1
	{ "listqry",	MLD_LISTENER_QUERY },
d109 1
a109 1
	{ "listenrep",	MLD_LISTENER_REPORT },
d111 1
a111 1
	{ "listendone", MLD_LISTENER_DONE },
d124 2
a125 2
	{ "mtraceresp",	MLD_MTRACE_RESP },
	{ "mtrace",	MLD_MTRACE }
d801 2
a802 3
	if (h->addr.type == PF_ADDR_ADDRMASK)
		for (i = 0; i < 4; i++)
			n->addr32[i] = n->addr32[i] & m->addr32[i];
@


1.1.1.9
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.167 2003/07/04 11:05:44 henning Exp $ */
d561 1
a561 1
	else {
a562 3
		if (r->natpass)
			printf("pass ");
	}
a1171 68
}

/*
 * convert a hostname to a list of addresses and put them in the given buffer.
 * test:
 *	if set to 1, only simple addresses are accepted (no netblock, no "!").
 */
int
append_addr(struct pfr_buffer *b, char *s, int test)
{
	return append_addr_not(b, s, test, 0);
}

/*
 * same as previous function, but with the ability to "negate" the result.
 * not:
 *	setting it to 1 is equivalent to adding "!" in front of parameter s.
 */
int
append_addr_not(struct pfr_buffer *b, char *s, int test, int not)
{
	char			 buf[256], *r;
	int			 bits;
	struct node_host	*n, *h;
	struct pfr_addr		 addr;

	for (r = s; *r == '!'; r++)
		not = !not;
	if (strlcpy(buf, r, sizeof(buf)) >= sizeof(buf)) {
		errno = EINVAL;
		return (-1);
	}
	if ((n = host(buf)) == NULL) {
		errno = 0;
		return (-1);
	}
	do {
		bzero(&addr, sizeof(addr));
		addr.pfra_not = not;
		addr.pfra_af = n->af;
		addr.pfra_net = unmask(&n->addr.v.a.mask, n->af);
		switch (n->af) {
		case AF_INET:
			addr.pfra_ip4addr.s_addr = n->addr.v.a.addr.addr32[0];
			bits = 32;
			break;
		case AF_INET6:
			memcpy(&addr.pfra_ip6addr, &n->addr.v.a.addr.v6,
			    sizeof(struct in6_addr));
			bits = 128;
			break;
		default:
			errno = EINVAL;
			return (-1);
		}
		if ((test && (not || addr.pfra_net != bits)) ||
		    addr.pfra_net > bits) {
			errno = EINVAL;
			return (-1);
		}
		if (pfr_buf_add(b, &addr))
			return (-1);
		h = n;
		n = n->next;
		free(h);
	} while (n != NULL);

	return (0);
@


1.1.1.10
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.169 2003/07/15 17:12:38 cedric Exp $ */
a766 36
void
print_tabledef(const char *name, int flags, int addrs,
    struct node_tinithead *nodes)
{
	struct node_tinit	*ti, *nti;
	struct node_host	*h;

	printf("table <%s>", name);
	if (flags & PFR_TFLAG_CONST)
		printf(" const");
	if (flags & PFR_TFLAG_PERSIST)
		printf(" persist");
	SIMPLEQ_FOREACH(ti, nodes, entries) {
		if (ti->file) {
			printf(" file \"%s\"", ti->file);
			continue;
		}
		printf(" {");
		for(;;) {
			for (h = ti->host; h != NULL; h = h->next) {
				printf(h->not ? " !" : " ");
				print_addr(&h->addr, h->af, 0);
			}
			nti = SIMPLEQ_NEXT(ti, entries);
			if (nti != NULL && nti->file == NULL)
				ti = nti;	/* merge lists */
			else
				break;
		}
		printf(" }");
	}
	if (addrs && SIMPLEQ_EMPTY(nodes))
		printf(" { }");
	printf("\n");
}

d1185 1
a1185 17
	char			 *r;
	struct node_host	*h, *n;
	int			 rv, not = 0;

	for (r = s; *r == '!'; r++)
		not = !not;
	if ((n = host(r)) == NULL) {
		errno = 0;
		return (-1);
	}
	rv = append_addr_host(b, n, test, not);
	do {
		h = n;
		n = n->next;
		free(h);
	} while (n != NULL);
	return (rv);
d1189 1
a1189 2
 * same as previous function, but with a pre-parsed input and the ability
 * to "negate" the result. Does not free the node_host list.
d1191 1
a1191 1
 *      setting it to 1 is equivalent to adding "!" in front of parameter s.
d1194 1
a1194 1
append_addr_host(struct pfr_buffer *b, struct node_host *n, int test, int not)
d1196 1
d1198 1
d1201 10
d1213 1
a1213 1
		addr.pfra_not = n->not ^ not;
d1237 4
a1240 1
	} while ((n = n->next) != NULL);
@


1.1.1.11
log
@Another sync to OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.170 2003/07/19 13:08:58 cedric Exp $ */
d401 1
a401 1
			print_addr(&pooladdr->addr, af, 0);
d404 1
a404 1
			if (PF_AZERO(&pooladdr->addr.v.a.addr, af))
d408 1
a408 1
				print_addr(&pooladdr->addr, af, 0);
@


1.1.1.12
log
@Sync to OpenBSD 3.3-current
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.171 2003/07/21 22:31:36 henning Exp $ */
d785 1
a785 1
		for (;;) {
@


1.1.1.13
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.172 2003/07/29 19:47:22 cedric Exp $ */
d290 1
a290 1
		printf(" %s >< %s", a1, a2);
d292 1
a292 1
		printf(" %s <> %s", a1, a2);
d294 1
a294 1
		printf(" = %s", a1);
d296 1
a296 1
		printf(" != %s", a1);
d298 1
a298 1
		printf(" < %s", a1);
d300 1
a300 1
		printf(" <= %s", a1);
d302 1
a302 1
		printf(" > %s", a1);
d304 1
a304 1
		printf(" >= %s", a1);
d306 1
a306 1
		printf(" %s:%s", a1, a2);
d320 1
a320 1
	printf(" port");
d334 1
a334 1
	printf(" %s", t);
d363 1
a363 1
		printf(" all");
d365 1
a365 1
		printf(" from ");
d369 1
d375 1
a375 1
		printf(" to ");
d379 1
d558 1
a558 1
		printf("action(%d)", r->action);
d560 1
a560 1
		printf("%s %s", anchortypes[r->action], r->anchorname);
d562 1
a562 1
		printf("%s", actiontypes[r->action]);
d564 1
a564 1
			printf(" pass");
d568 1
a568 1
			printf(" return");
d571 1
a571 1
				printf(" return-rst");
d573 1
a573 1
				printf(" return-rst(ttl %d)", r->return_ttl);
d584 1
a584 1
				printf(" return-icmp");
d586 1
a586 1
					printf("(%u)", r->return_icmp & 255);
d588 1
a588 1
					printf("(%s)", ic->name);
d591 1
a591 1
				printf(" return-icmp6");
d593 1
a593 1
					printf("(%u)", r->return_icmp6 & 255);
d595 1
a595 1
					printf("(%s)", ic6->name);
d598 1
a598 1
				printf(" return-icmp");
d604 1
a604 1
					printf("%u)", r->return_icmp6 & 255);
d606 1
a606 1
					printf("%s)", ic6->name);
d610 1
a610 1
			printf(" drop");
d613 1
a613 1
		printf(" in");
d615 1
a615 1
		printf(" out");
d617 1
a617 1
		printf(" log");
d619 1
a619 1
		printf(" log-all");
d621 1
a621 1
		printf(" quick");
d624 1
a624 1
			printf(" on ! %s", r->ifname);
d626 1
a626 1
			printf(" on %s", r->ifname);
d630 1
a630 1
			printf(" route-to");
d632 1
a632 1
			printf(" reply-to");
d634 1
a634 1
			printf(" dup-to");
d636 1
a636 1
			printf(" fastroute");
d638 1
a639 1
			print_pool(&r->rpool, 0, 0, r->af, PF_PASS);
d644 1
a644 1
			printf(" inet");
d646 1
a646 1
			printf(" inet6");
d652 1
a652 1
			printf(" proto %s", p->p_name);
d654 1
a654 1
			printf(" proto %u", r->proto);
d664 1
a664 1
		printf(" flags ");
d668 1
d675 1
a675 1
			printf(" icmp-type");
d677 1
a677 1
			printf(" icmp6-type");
d679 1
a679 1
			printf(" %s", it->name);
d681 1
a681 1
			printf(" %u", r->type-1);
d687 1
a687 1
				printf(" code %s", ic->name);
d689 1
a689 1
				printf(" code %u", r->code-1);
d693 1
a693 1
		printf(" tos 0x%2.2x", r->tos);
d695 1
a695 1
		printf(" keep state");
d697 1
a697 1
		printf(" modulate state");
d699 1
a699 1
		printf(" synproxy state");
d707 1
a707 1
		printf(" (");
d720 1
a720 1
		printf(")");
d723 1
a723 1
		printf(" fragment");
d725 1
a725 1
		printf(" no-df");
d727 1
a727 1
		printf(" random-id");
d729 1
a729 1
		printf(" min-ttl %d", r->min_ttl);
d731 1
a731 1
		printf(" max-mss %d", r->max_mss);
d733 1
a733 1
		printf(" allow-opts");
d736 1
a736 1
			printf(" reassemble tcp");
d739 1
a739 1
			printf(" fragment drop-ovl");
d741 1
a741 1
			printf(" fragment crop");
d743 1
a743 1
			printf(" fragment reassemble");
d746 1
a746 1
		printf(" label \"%s\"", r->label);
d748 1
a748 1
		printf(" queue(%s, %s)", r->qname, r->pqname);
d750 1
a750 1
		printf(" queue %s", r->qname);
d752 1
a752 1
		printf(" tag %s", r->tagname);
d755 2
a756 2
			printf(" !");
		printf(" tagged %s", r->match_tagname);
d760 1
a760 1
		printf(" -> ");
@


1.1.1.14
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.174 2003/08/22 21:52:11 itojun Exp $ */
d61 2
a62 2
void		 print_fromto(struct pf_rule_addr *, pf_osfp_t,
		    struct pf_rule_addr *, u_int8_t, u_int8_t, int);
d352 1
a352 1
print_fromto(struct pf_rule_addr *src, pf_osfp_t osfp, struct pf_rule_addr *dst,
a354 1
	char buf[PF_OSFP_LEN*3];
d362 1
a362 2
	    !src->port_op && !dst->port_op &&
	    osfp == PF_OSFP_ANY)
a372 3
		if (osfp != PF_OSFP_ANY)
			printf(" os \"%s\"", pfctl_lookup_fingerprint(osfp, buf,
			    sizeof(buf)));
d523 2
a524 2
		printf("  %-25s %14llu", pf_fcounters[i],
			    (unsigned long long)s->fcounters[i]);
d533 2
a534 2
		printf("  %-25s %14llu ", pf_reasons[i],
		    (unsigned long long)s->counters[i]);
d654 1
a654 2
	print_fromto(&r->src, r->os_fingerprint, &r->dst, r->af, r->proto,
	    verbose);
@


1.1.1.15
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.175 2003/09/18 20:27:58 cedric Exp $ */
a854 2
		if (h->addr.type == PF_ADDR_TABLE)
			continue;
@


1.1.1.16
log
@cvs is playing games with me.

@@@@@@ CONSIDER THE TREE LOCKED NOW @@@@@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.176 2003/09/26 21:44:09 cedric Exp $ */
a33 1
#include <sys/ioctl.h>
a1285 42
}

int
pfctl_add_trans(struct pfr_buffer *buf, int rs_num, const char *anchor,
    const char *ruleset) 
{
	struct pfioc_trans_e trans;

	bzero(&trans, sizeof(trans));
	trans.rs_num = rs_num;
	if (strlcpy(trans.anchor, anchor,
	    sizeof(trans.anchor)) >= sizeof(trans.anchor) ||
	    strlcpy(trans.ruleset, ruleset,
	    sizeof(trans.ruleset)) >= sizeof(trans.ruleset))
		errx(1, "pfctl_add_trans: strlcpy");

	return pfr_buf_add(buf, &trans);
}

u_int32_t
pfctl_get_ticket(struct pfr_buffer *buf, int rs_num, const char *anchor,
    const char *ruleset) 
{
	struct pfioc_trans_e *p;
	
	PFRB_FOREACH(p, buf)
		if (rs_num == p->rs_num && !strcmp(anchor, p->anchor) &&
		    !strcmp(ruleset, p->ruleset))
			return (p->ticket);
	errx(1, "pfr_get_ticket: assertion failed");
}

int
pfctl_trans(int dev, struct pfr_buffer *buf, int cmd, int from)
{
	struct pfioc_trans trans;

	bzero(&trans, sizeof(trans));
	trans.size = buf->pfrb_size - from;
	trans.esize = sizeof(struct pfioc_trans_e);
	trans.array = ((struct pfioc_trans_e *)buf->pfrb_caddr) + from;
	return ioctl(dev, cmd, &trans);
@


1.1.1.17
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.185 2003/12/19 16:12:43 henning Exp $ */
a4 1
 * Copyright (c) 2002,2003 Henning Brauer
a195 1
	{ "src.track",		PFTM_SRC_NODE },
a461 2
	if (pool->opts & PF_POOL_STICKYADDR)
		printf(" sticky-address");
a467 1
const char	*pf_scounters[FCNT_MAX+1] = FCNT_NAMES;
d470 1
a470 1
print_status(struct pf_status *s, int opts)
d494 1
a494 1
	case PF_DEBUG_NONE:
d497 1
a497 1
	case PF_DEBUG_URGENT:
d500 1
a500 1
	case PF_DEBUG_MISC:
a502 3
	case PF_DEBUG_NOISY:
		printf("%15s\n\n", "Debug: Loud");
		break;
a503 1
	printf("Hostid: 0x%08x\n\n", ntohl(s->hostid));
d529 1
a529 1
		printf("  %-25s %14llu ", pf_fcounters[i],
a536 14
	if (opts & PF_OPT_VERBOSE) {
		printf("Source Tracking Table\n");
		printf("  %-25s %14u %14s\n", "current entries",
		    s->src_nodes, "");
		for (i = 0; i < SCNT_MAX; i++) {
			printf("  %-25s %14lld ", pf_scounters[i],
				    s->scounters[i]);
			if (runtime > 0)
				printf("%14.1f/s\n",
				    (double)s->scounters[i] / (double)runtime);
			else
				printf("%14s\n", "");
		}
	}
a549 51
print_src_node(struct pf_src_node *sn, int opts)
{
	struct pf_addr_wrap aw;
	int min, sec;

	memset(&aw, 0, sizeof(aw));
	if (sn->af == AF_INET)
		aw.v.a.mask.addr32[0] = 0xffffffff;
	else
		memset(&aw.v.a.mask, 0xff, sizeof(aw.v.a.mask));

	aw.v.a.addr = sn->addr;
	print_addr(&aw, sn->af, opts & PF_OPT_VERBOSE2);
	printf(" -> ");
	aw.v.a.addr = sn->raddr;
	print_addr(&aw, sn->af, opts & PF_OPT_VERBOSE2);
	printf(" (%d states)\n", sn->states);
	if (opts & PF_OPT_VERBOSE) {
		sec = sn->creation % 60;
		sn->creation /= 60;
		min = sn->creation % 60;
		sn->creation /= 60;
		printf("   age %.2u:%.2u:%.2u", sn->creation, min, sec);
		if (sn->states == 0) {
			sec = sn->expire % 60;
			sn->expire /= 60;
			min = sn->expire % 60;
			sn->expire /= 60;
			printf(", expires in %.2u:%.2u:%.2u",
			    sn->expire, min, sec);
		}
		printf(", %u pkts, %u bytes", sn->packets, sn->bytes);
		switch (sn->ruletype) {
		case PF_NAT:
			if (sn->rule.nr != -1)
				printf(", nat rule %u", sn->rule.nr);
			break;
		case PF_RDR:
			if (sn->rule.nr != -1)
				printf(", rdr rule %u", sn->rule.nr);
			break;
		case PF_PASS:
			if (sn->rule.nr != -1)
				printf(", filter rule %u", sn->rule.nr);
			break;
		}
		printf("\n");
	}
}

void
d705 1
a705 5
	if (r->max_states || r->max_src_nodes || r->max_src_states)
		opts = 1;
	if (r->rule_flag & PFRULE_NOSYNC)
		opts = 1;
	if (r->rule_flag & PFRULE_SRCTRACK)
a715 28
		if (r->rule_flag & PFRULE_NOSYNC) {
			if (!opts)
				printf(", ");
			printf("no-sync");
			opts = 0;
		}
		if (r->rule_flag & PFRULE_SRCTRACK) {
			if (!opts)
				printf(", ");
			printf("source-track");
			if (r->rule_flag & PFRULE_RULESRCTRACK)
				printf(" rule");
			else
				printf(" global");
			opts = 0;
		}
		if (r->max_src_states) {
			if (!opts)
				printf(", ");
			printf("max-src-states %u", r->max_src_states);
			opts = 0;
		}
		if (r->max_src_nodes) {
			if (!opts)
				printf(", ");
			printf("max-src-nodes %u", r->max_src_nodes);
			opts = 0;
		}
d1291 1
a1291 1
    const char *ruleset)
d1308 1
a1308 1
    const char *ruleset)
d1311 1
a1311 1

d1320 1
a1320 1
pfctl_trans(int dev, struct pfr_buffer *buf, u_long cmd, int from)
@


1.1.1.18
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.187 2003/12/31 22:14:41 deraadt Exp $ */
a784 2
	if (r->rule_flag & (PFRULE_IFBOUND | PFRULE_GRBOUND))
		opts = 1;
a821 12
		if (r->rule_flag & PFRULE_IFBOUND) {
			if (!opts)
				printf(", ");
			printf("if-bound");
			opts = 0;
		}
		if (r->rule_flag & PFRULE_GRBOUND) {
			if (!opts)
				printf(", ");
			printf("group-bound");
			opts = 0;
		}
a988 2
	struct pfr_buffer	 b;
	struct pfi_if		*p;
a1028 4
			if (ifa->ifa_dstaddr != NULL)
				memcpy(&n->peer, &((struct sockaddr_in *)
				    ifa->ifa_dstaddr)->sin_addr.s_addr,
				    sizeof(struct in_addr));
a1039 4
			if(ifa->ifa_dstaddr != NULL)
				 memcpy(&n->peer, &((struct sockaddr_in6 *)
				    ifa->ifa_dstaddr)->sin6_addr.s6_addr,
				    sizeof(struct in6_addr));
a1053 38

	/* add interface groups, including clonable and dynamic stuff */
	bzero(&b, sizeof(b));
	b.pfrb_type = PFRB_IFACES;
	for (;;) {
		if (pfr_buf_grow(&b, b.pfrb_size))
			err(1, "ifa_load: pfr_buf_grow");
		b.pfrb_size = b.pfrb_msize;
		if (pfi_get_ifaces(NULL, b.pfrb_caddr, &b.pfrb_size,
		    PFI_FLAG_GROUP))
			err(1, "ifa_load: pfi_get_ifaces");
		if (b.pfrb_size <= b.pfrb_msize)
			break;
	}
	PFRB_FOREACH(p, &b) {
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "address: calloc");
		n->af = AF_LINK;
		n->ifa_flags = PF_IFA_FLAG_GROUP;
		if (p->pfif_flags & PFI_IFLAG_DYNAMIC)
			n->ifa_flags |= PF_IFA_FLAG_DYNAMIC;
		if (p->pfif_flags & PFI_IFLAG_CLONABLE)
			n->ifa_flags |= PF_IFA_FLAG_CLONABLE;
		if (!strcmp(p->pfif_name, "lo"))
			n->ifa_flags |= IFF_LOOPBACK;
		if ((n->ifname = strdup(p->pfif_name)) == NULL)
			err(1, "ifa_load: strdup");
		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}

d1059 1
a1059 1
ifa_exists(const char *ifa_name, int group_ok)
a1061 2
	char			*p, buf[IFNAMSIZ];
	int			 group;
a1062 3
	group = !isdigit(ifa_name[strlen(ifa_name) - 1]);
	if (group && !group_ok)
		return (NULL);
a1069 13
	if (!group) {
		/* look for clonable and/or dynamic interface */
		strlcpy(buf, ifa_name, sizeof(buf));
		for (p = buf + strlen(buf) - 1; p > buf && isdigit(*p); p--)
			*p = '\0';
		for (n = iftab; n != NULL; n = n->next)
			if (n->af == AF_LINK &&
			    !strncmp(n->ifname, buf, IFNAMSIZ))
				break;
		if (n != NULL && n->ifa_flags &
		    (PF_IFA_FLAG_DYNAMIC | PF_IFA_FLAG_CLONABLE))
			return (n);	/* XXX */
	}
d1074 1
a1074 1
ifa_lookup(const char *ifa_name, int flags)
d1077 1
a1077 2
	int			 return_all = 0, got4 = 0, got6 = 0;
	const char		 *last_if = NULL;
d1087 1
a1087 12
		    (!strncmp(p->ifname, ifa_name, strlen(ifa_name)) ||
		    return_all)))
			continue;
		if ((flags & PFI_AFLAG_BROADCAST) && p->af != AF_INET)
			continue;
		if ((flags & PFI_AFLAG_BROADCAST) &&
		    !(p->ifa_flags & IFF_BROADCAST))
			continue;
		if ((flags & PFI_AFLAG_PEER) &&
		    !(p->ifa_flags & IFF_POINTOPOINT))
			continue;
		if ((flags & PFI_AFLAG_NETWORK) && p->ifindex > 0)
d1089 1
a1089 4
		if (last_if == NULL || strcmp(last_if, p->ifname))
			got4 = got6 = 0;
		last_if = p->ifname;
		if ((flags & PFI_AFLAG_NOALIAS) && p->af == AF_INET && got4)
d1091 1
a1091 1
		if ((flags & PFI_AFLAG_NOALIAS) && p->af == AF_INET6 && got6)
a1092 4
		if (p->af == AF_INET)
			got4 = 1;
		else
			got6 = 1;
d1097 1
a1097 1
		if (flags & PFI_AFLAG_BROADCAST)
a1099 3
		else if (flags & PFI_AFLAG_PEER)
			memcpy(&n->addr.v.a.addr, &p->peer,
			    sizeof(struct pf_addr));
d1103 1
a1103 1
		if (flags & PFI_AFLAG_NETWORK)
d1128 3
d1188 1
a1188 1
	int			 flags = 0;
d1190 2
a1191 3
	if ((ps = strdup(s)) == NULL)
		err(1, "host_if: strdup");
	while ((p = strrchr(ps, ':')) != NULL) {
d1193 6
a1198 8
			flags |= PFI_AFLAG_NETWORK;
		else if (!strcmp(p+1, "broadcast"))
			flags |= PFI_AFLAG_BROADCAST;
		else if (!strcmp(p+1, "peer"))
			flags |= PFI_AFLAG_PEER;
		else if (!strcmp(p+1, "0"))
			flags |= PFI_AFLAG_NOALIAS;
		else
d1200 9
a1208 12
		*p = '\0';
	}
	if (flags & (flags - 1) & PFI_AFLAG_MODEMASK) { /* Yep! */
		fprintf(stderr, "illegal combination of interface modifiers\n");
		return (NULL);
	}
	if ((flags & (PFI_AFLAG_NETWORK|PFI_AFLAG_BROADCAST)) && mask > -1) {
		fprintf(stderr, "network or broadcast lookup, but "
		    "extra netmask given\n");
		return (NULL);
	}
	if (ifa_exists(ps, 1) || !strncmp(ps, "self", IFNAMSIZ)) {
d1210 1
a1210 1
		h = ifa_lookup(ps, flags);
d1277 1
a1277 3
	int			 error, noalias = 0;
	int			 got4 = 0, got6 = 0;
	char			*p, *ps;
a1278 6
	if ((ps = strdup(s)) == NULL)
		err(1, "host_if: strdup");
	if ((p = strrchr(ps, ':')) != NULL && !strcmp(p, ":0")) {
		noalias = 1;
		*p = '\0';
	}
d1282 1
a1282 1
	error = getaddrinfo(ps, NULL, &hints, &res0);
a1289 11
		if (noalias) {
			if (res->ai_family == AF_INET) {
				if (got4)
					continue;
				got4 = 1;
			} else {
				if (got6)
					continue;
				got6 = 1;
			}
		}
a1320 1
	free(ps);
@


1.1.1.19
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.189 2004/01/25 18:47:15 deraadt Exp $ */
@


1.1.1.20
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.198 2004/05/07 16:54:20 henning Exp $ */
a64 1
int		 ifa_skip_if(const char *filter, struct node_host *p);
a184 1
	{ "tcp.tsdiff",		PFTM_TS_DIFF },
d257 1
a257 1
		    sizeof(icmp6_code[0])); i++) {
d477 1
a477 1
	char	statline[80], *running;
a481 1
	running = s->running ? "Enabled" : "Disabled";
d483 1
a483 1
	if (s->since) {
d493 2
a494 2
		    "Status: %s for %u days %.2u:%.2u:%.2u",
		    running, day, hrs, min, sec);
d496 1
a496 1
		snprintf(statline, sizeof(statline), "Status: %s", running);
d517 1
a517 2
		    (unsigned long long)s->bcounters[0][0],
		    (unsigned long long)s->bcounters[1][0]);
d519 1
a519 2
		    (unsigned long long)s->bcounters[0][1],
		    (unsigned long long)s->bcounters[1][1]);
d522 2
a523 2
		    (unsigned long long)s->pcounters[0][0][PF_PASS],
		    (unsigned long long)s->pcounters[1][0][PF_PASS]);
d525 2
a526 2
		    (unsigned long long)s->pcounters[0][0][PF_DROP],
		    (unsigned long long)s->pcounters[1][0][PF_DROP]);
d529 2
a530 2
		    (unsigned long long)s->pcounters[0][1][PF_PASS],
		    (unsigned long long)s->pcounters[1][1][PF_PASS]);
d532 2
a533 2
		    (unsigned long long)s->pcounters[0][1][PF_DROP],
		    (unsigned long long)s->pcounters[1][1][PF_DROP]);
d660 1
a660 1
			switch (r->af) {
a777 15
	if (r->prob) {
		char	buf[20];

		snprintf(buf, sizeof(buf), "%f", r->prob*100.0/(UINT_MAX+1.0));
		for (i = strlen(buf)-1; i > 0; i--) {
			if (buf[i] == '0')
				buf[i] = '\0';
			else {
				if (buf[i] == '.')
					buf[i] = '\0';
				break;
			}
		}
		printf(" probability %s%%", buf);
	}
d1023 1
a1023 2
		    ((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_scope_id ==
		    0) {
d1060 1
a1060 1
			if (ifa->ifa_dstaddr != NULL)
d1157 1
a1157 1
	int			 got4 = 0, got6 = 0;
d1161 1
a1161 1
		ifa_name = NULL;
d1167 3
a1169 1
		if (ifa_skip_if(ifa_name, p))
a1232 22
int
ifa_skip_if(const char *filter, struct node_host *p)
{
	int	n;

	if (p->af != AF_INET && p->af != AF_INET6)
		return (1);
	if (filter == NULL || !*filter)
		return (0);
	if (!strcmp(p->ifname, filter))
		return (0);	/* exact match */
	n = strlen(filter);
	if (n < 1 || n >= IFNAMSIZ)
		return (1);	/* sanity check */
	if (filter[n-1] >= '0' && filter[n-1] <= '9')
		return (1);	/* only do exact match in that case */
	if (strncmp(p->ifname, filter, n))
		return (1);	/* prefix doesn't match */
	return (p->ifname[n] < '0' || p->ifname[n] > '9');
}


d1300 1
a1300 2
		else {
			free(ps);
a1301 1
		}
a1305 1
		free(ps);
a1310 1
		free(ps);
d1329 1
a1329 1
	int			 bits = 32;
d1332 10
a1341 6
	if (strrchr(s, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(ina))) == -1)
			return (NULL);
	} else {
		if (inet_pton(AF_INET, s, &ina) != 1)
			return (NULL);
a1343 10
	h = calloc(1, sizeof(struct node_host));
	if (h == NULL)
		err(1, "address: calloc");
	h->ifname = NULL;
	h->af = AF_INET;
	h->addr.v.a.addr.addr32[0] = ina.s_addr;
	set_ipmask(h, bits);
	h->next = NULL;
	h->tail = h;

d1387 1
a1387 1
		err(1, "host_dns: strdup");
d1547 1
a1547 1
	errx(1, "pfctl_get_ticket: assertion failed");
@


