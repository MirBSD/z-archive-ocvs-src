head	1.25;
access;
symbols
	tg-mergetmp-mirosx-1:1.25
	tg-mergefixes-1-branch:1.25.0.4
	tg-mergefixes-1-base:1.25
	MIROS_X:1.25.0.2
	MIROS_X_BASE:1.25
	tg-mergetmp-3:1.25
	MIRBSD_XP_MIRPPC:1.24.0.4
	MIRBSD_XP_SPARC_BASE:1.24
	MIRBSD_XP_SPARC:1.24.0.2
	MIRBSD_7quater:1.19
	cvs-200405160640:1.1.1.21
	cvs-200401271800:1.1.1.20
	cvs-200401261630:1.1.1.20
	cvs-200401021645:1.1.1.19
	MIRBSD_7_ALPHA:1.19.0.6
	MIRBSD_7:1.19.0.4
	cvs-200312222040:1.1.1.18
	MIRBSD_7ter:1.19
	MIRBSD_7_DEV:1.19.0.2
	cvs-200310020700:1.1.1.17
	cvs-200309271030:1.1.1.17
	cvs-200309261655:1.1.1.16
	cvs-200309251530:1.1.1.16
	cvs-200308302005:1.1.1.15
	cvs-200308171200:1.1.1.14
	ctm-3496:1.1.1.14
	ctm-3449:1.1.1.13
	ctm-3437:1.1.1.13
	cvs-200307191805:1.1.1.13
	ctm-3425:1.1.1.12
	cvs-200307091500:1.1.1.11
	cvs-200307072125:1.1.1.11
	ctm-3389:1.1.1.11
	cvs-200307021520:1.1.1.10
	cvs-200306301805:1.1.1.10
	cvs-200306301405:1.1.1.10
	cvs-200306291430:1.1.1.10
	ctm-3341:1.1.1.9
	MIRBSD_5:1.9
	cvs-200306091240:1.1.1.8
	cvs-200306082100:1.1.1.7
	ctm-3316:1.1.1.7
	ctm-3272:1.1.1.6
	ctm-3264:1.1.1.5
	cvs-200305071630:1.1.1.5
	MIRBSD_4:1.5
	ctm-3203:1.1.1.4
	cvs-20030410-1130:1.1.1.3
	ctm-3155:1.1.1.2
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2004.12.07.22.17.20;	author tg;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.11.20.08.11;	author tg;	state Stab;
branches;
next	1.23;

1.23
date	2004.05.27.16.43.34;	author tg;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.27.17.42.06;	author tg;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.03.02.26.52;	author tg;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.27.00.30.45;	author tg;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.27.15.46.50;	author tg;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.25.20.59.51;	author tg;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.31.20.54.40;	author tg;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.16.15.25.26;	author tg;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.19.20.23.52;	author tg;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.18.15.45.14;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.06.20.22.12;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.30.15.42.03;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.29.19.49.27;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.19.16.44.20;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.09.12.45.37;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.06.18.28.36;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.22.14.08.10;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.07.20.54.13;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.15.20.11.25;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.10.20.11.38;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.29.21.33.33;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.21.52.02;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.48.40;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.48.40;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.03.29.19.42.12;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.04.10.14.44.41;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.04.15.17.37.17;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.07.17.43.42;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.05.21.19.02.54;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.06.05.17.31.29;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.06.09.12.44.29;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.06.19.12.42.52;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.06.29.17.27.31;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2003.07.06.15.40.11;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2003.07.18.13.42.44;	author tg;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2003.07.19.18.48.24;	author tg;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2003.08.11.18.30.23;	author tg;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2003.08.30.23.01.33;	author tg;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2003.09.25.16.32.28;	author tg;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2003.09.27.11.17.29;	author tg;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	2003.12.22.21.10.51;	author tg;	state Exp;
branches;
next	1.1.1.19;

1.1.1.19
date	2004.01.02.18.01.20;	author tg;	state Exp;
branches;
next	1.1.1.20;

1.1.1.20
date	2004.01.26.18.30.24;	author tg;	state Exp;
branches;
next	1.1.1.21;

1.1.1.21
date	2004.05.16.08.26.18;	author tg;	state Exp;
branches;
next	;


desc
@@


1.25
log
@remove pf features which are broken:
 ($interface) -> did never work correctly
 antispoof -> dangerous, false sense of security, side impacts, only for lazies

remove kernel stuff accordingly, but don't change ABI

update documentation
remove orphaned documentation nobody maintains
@
text
@/**	$MirBSD$ */
/*	$OpenBSD: parse.y,v 1.452 2004/04/24 23:22:54 cedric Exp $	*/

/*
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 * Copyright (c) 2002, 2003, 2004 Thorsten Glaser.
 * Copyright (c) 2002, 2003 Henning Brauer. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
%{
#include <sys/types.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/icmp6.h>
#include <net/pfvar.h>
#include <arpa/inet.h>
#include <altq/altq.h>
#include <altq/altq_cbq.h>
#include <altq/altq_priq.h>
#include <altq/altq_hfsc.h>

#include <stdio.h>
#include <stdlib.h>
#include <netdb.h>
#include <stdarg.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <err.h>
#include <limits.h>
#include <pwd.h>
#include <grp.h>
#include <md5.h>

#include "pfctl_parser.h"
#include "pfctl.h"

__RCSID("$MirBSD: src/sbin/pfctl/parse.y,v 1.24 2004/06/11 20:08:11 tg Stab $");

static struct pfctl	*pf = NULL;
static FILE		*fin = NULL;
static int		 debug = 0;
static int		 lineno = 1;
static int		 errors = 0;
static int		 rulestate = 0;
static u_int16_t	 returnicmpdefault =
			    (ICMP_UNREACH << 8) | ICMP_UNREACH_PORT;
static u_int16_t	 returnicmp6default =
			    (ICMP6_DST_UNREACH << 8) | ICMP6_DST_UNREACH_NOPORT;
static int		 blockpolicy = PFRULE_DROP;
static int		 require_order = 1;
static int		 default_statelock;

enum {
	PFCTL_STATE_NONE,
	PFCTL_STATE_OPTION,
	PFCTL_STATE_SCRUB,
	PFCTL_STATE_QUEUE,
	PFCTL_STATE_NAT,
	PFCTL_STATE_FILTER
};

struct node_proto {
	u_int8_t		 proto;
	struct node_proto	*next;
	struct node_proto	*tail;
};

struct node_port {
	u_int16_t		 port[2];
	u_int8_t		 op;
	struct node_port	*next;
	struct node_port	*tail;
};

struct node_uid {
	uid_t			 uid[2];
	u_int8_t		 op;
	struct node_uid		*next;
	struct node_uid		*tail;
};

struct node_gid {
	gid_t			 gid[2];
	u_int8_t		 op;
	struct node_gid		*next;
	struct node_gid		*tail;
};

struct node_icmp {
	u_int8_t		 code;
	u_int8_t		 type;
	u_int8_t		 proto;
	struct node_icmp	*next;
	struct node_icmp	*tail;
};

enum	{ PF_STATE_OPT_MAX, PF_STATE_OPT_NOSYNC, PF_STATE_OPT_SRCTRACK,
	    PF_STATE_OPT_MAX_SRC_STATES, PF_STATE_OPT_MAX_SRC_NODES,
	    PF_STATE_OPT_STATELOCK, PF_STATE_OPT_TIMEOUT };

enum	{ PF_SRCTRACK_NONE, PF_SRCTRACK, PF_SRCTRACK_GLOBAL, PF_SRCTRACK_RULE };

struct node_state_opt {
	int			 type;
	union {
		u_int32_t	 max_states;
		u_int32_t	 max_src_states;
		u_int32_t	 max_src_nodes;
		u_int8_t	 src_track;
		u_int32_t	 statelock;
		struct {
			int		number;
			u_int32_t	seconds;
		}		 timeout;
	}			 data;
	struct node_state_opt	*next;
	struct node_state_opt	*tail;
};

struct peer {
	struct node_host	*host;
	struct node_port	*port;
};

struct node_queue {
	char			 queue[PF_QNAME_SIZE];
	char			 parent[PF_QNAME_SIZE];
	char			 ifname[IFNAMSIZ];
	int			 scheduler;
	struct node_queue	*next;
	struct node_queue	*tail;
}	*queues = NULL;

struct node_qassign {
	char		*qname;
	char		*pqname;
};

struct filter_opts {
	int			 marker;
#define FOM_FLAGS	0x01
#define FOM_ICMP	0x02
#define FOM_TOS		0x04
#define FOM_KEEP	0x08
#define FOM_SRCTRACK	0x10
	struct node_uid		*uid;
	struct node_gid		*gid;
	struct {
		u_int8_t	 b1;
		u_int8_t	 b2;
		u_int16_t	 w;
		u_int16_t	 w2;
	} flags;
	struct node_icmp	*icmpspec;
	u_int32_t		 tos;
	u_int32_t		 prob;
	struct {
		int			 action;
		struct node_state_opt	*options;
	} keep;
	int			 fragment;
	int			 allowopts;
	char			*label;
	struct node_qassign	 queues;
	char			*tag;
	char			*match_tag;
	u_int8_t		 match_tag_not;
} filter_opts;

struct scrub_opts {
	int			marker;
#define SOM_MINTTL	0x01
#define SOM_MAXMSS	0x02
#define SOM_FRAGCACHE	0x04
	int			nodf;
	int			minttl;
	int			maxmss;
	int			fragcache;
	int			randomid;
	int			reassemble_tcp;
} scrub_opts;

struct queue_opts {
	int			marker;
#define QOM_BWSPEC	0x01
#define QOM_SCHEDULER	0x02
#define QOM_PRIORITY	0x04
#define QOM_TBRSIZE	0x08
#define QOM_QLIMIT	0x10
	struct node_queue_bw	queue_bwspec;
	struct node_queue_opt	scheduler;
	int			priority;
	int			tbrsize;
	int			qlimit;
} queue_opts;

struct table_opts {
	int			flags;
	int			init_addr;
	struct node_tinithead	init_nodes;
} table_opts;

struct pool_opts {
	int			 marker;
#define POM_TYPE		0x01
#define POM_STICKYADDRESS	0x02
	u_int8_t		 opts;
	int			 type;
	int			 staticport;
	struct pf_poolhashkey	*key;

} pool_opts;


struct node_hfsc_opts	hfsc_opts;

int	yyerror(const char *, ...);
int	disallow_table(struct node_host *, const char *);
int	rule_consistent(struct pf_rule *);
int	filter_consistent(struct pf_rule *);
int	nat_consistent(struct pf_rule *);
int	rdr_consistent(struct pf_rule *);
int	process_tabledef(char *, struct table_opts *);
int	yyparse(void);
void	expand_label_str(char *, size_t, const char *, const char *);
void	expand_label_if(const char *, char *, size_t, const char *);
void	expand_label_addr(const char *, char *, size_t, u_int8_t,
	    struct node_host *);
void	expand_label_port(const char *, char *, size_t, struct node_port *);
void	expand_label_proto(const char *, char *, size_t, u_int8_t);
void	expand_label_nr(const char *, char *, size_t);
void	expand_label(char *, size_t, const char *, u_int8_t, struct node_host *,
	    struct node_port *, struct node_host *, struct node_port *,
	    u_int8_t);
void	expand_rule(struct pf_rule *, struct node_if *, struct node_host *,
	    struct node_proto *, struct node_os*, struct node_host *,
	    struct node_port *, struct node_host *, struct node_port *,
	    struct node_uid *, struct node_gid *, struct node_icmp *);
int	expand_altq(struct pf_altq *, struct node_if *, struct node_queue *,
	    struct node_queue_bw bwspec, struct node_queue_opt *);
int	expand_queue(struct pf_altq *, struct node_if *, struct node_queue *,
	    struct node_queue_bw, struct node_queue_opt *);

int	 check_rulestate(int);
int	 kw_cmp(const void *, const void *);
int	 lookup(char *);
int	 lgetc(FILE *);
int	 lungetc(int);
int	 findeol(void);
int	 yylex(void);
int	 atoul(char *, u_long *);
int	 getservice(char *);
int	 rule_label(struct pf_rule *, char *);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entries;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};


int	 symset(const char *, const char *, int);
char	*symget(const char *);

void	 decide_address_family(struct node_host *, sa_family_t *);
void	 remove_invalid_hosts(struct node_host **, sa_family_t *);
int	 invalid_redirect(struct node_host *, sa_family_t);
u_int16_t parseicmpspec(char *, sa_family_t);

TAILQ_HEAD(loadanchorshead, loadanchors)
    loadanchorshead = TAILQ_HEAD_INITIALIZER(loadanchorshead);

struct loadanchors {
	TAILQ_ENTRY(loadanchors)	 entries;
	char				*anchorname;
	char				*rulesetname;
	char				*filename;
};

typedef struct {
	union {
		u_int32_t		 number;
		int			 i;
		char			*string;
		struct {
			u_int8_t	 b1;
			u_int8_t	 b2;
			u_int16_t	 w;
			u_int16_t	 w2;
		}			 b;
		struct range {
			int		 a;
			int		 b;
			int		 t;
		}			 range;
		struct node_if		*interface;
		struct node_proto	*proto;
		struct node_icmp	*icmp;
		struct node_host	*host;
		struct node_os		*os;
		struct node_port	*port;
		struct node_uid		*uid;
		struct node_gid		*gid;
		struct node_state_opt	*state_opt;
		struct peer		 peer;
		struct {
			struct peer	 src, dst;
			struct node_os	*src_os;
		}			 fromto;
		struct {
			struct node_host	*host;
			u_int8_t		 rt;
			u_int8_t		 pool_opts;
			sa_family_t		 af;
			struct pf_poolhashkey	*key;
		}			 route;
		struct redirection {
			struct node_host	*host;
			struct range		 rport;
		}			*redirection;
		struct {
			int			 action;
			struct node_state_opt	*options;
		}			 keep_state;
		struct {
			u_int8_t	 log;
			u_int8_t	 quick;
		}			 logquick;
		struct pf_poolhashkey	*hashkey;
		struct node_queue	*queue;
		struct node_queue_opt	 queue_options;
		struct node_queue_bw	 queue_bwspec;
		struct node_qassign	 qassign;
		struct filter_opts	 filter_opts;
		struct queue_opts	 queue_opts;
		struct scrub_opts	 scrub_opts;
		struct table_opts	 table_opts;
		struct pool_opts	 pool_opts;
		struct node_hfsc_opts	 hfsc_opts;
	} v;
	int lineno;
} YYSTYPE;

#define PREPARE_ANCHOR_RULE(r, a)				\
	do {							\
		memset(&(r), 0, sizeof(r));			\
		if (strlcpy(r.anchorname, (a),			\
		    sizeof(r.anchorname)) >=			\
		    sizeof(r.anchorname)) {			\
			yyerror("anchor name '%s' too long",	\
			    (a));				\
			YYERROR;				\
		}						\
	} while (0)

%}

%token	PASS BLOCK SCRUB RETURN IN OS OUT LOG LOGALL QUICK ON FROM TO FLAGS
%token	RETURNRST RETURNICMP RETURNICMP6 PROTO INET INET6 ALL ANY ICMPTYPE
%token	ICMP6TYPE CODE KEEP MODULATE STATE PORT RDR NAT BINAT ARROW NODF
%token	MINTTL ERROR ALLOWOPTS FASTROUTE FILENAME ROUTETO DUPTO REPLYTO NO LABEL
%token	NOROUTE FRAGMENT USER GROUP MAXMSS MAXIMUM TTL TOS DROP TABLE
%token	REASSEMBLE FRAGDROP FRAGCROP ANCHOR NATANCHOR RDRANCHOR BINATANCHOR
%token	SET OPTIMIZATION TIMEOUT LIMIT LOGINTERFACE BLOCKPOLICY RANDOMID
%token	REQUIREORDER SYNPROXY FINGERPRINTS NOSYNC DEBUG HOSTID FUCKOFF
%token	ANTISPOOF FOR
%token	BITMASK RANDOM SOURCEHASH ROUNDROBIN STATICPORT PROBABILITY
%token	ALTQ CBQ PRIQ HFSC BANDWIDTH TBRSIZE LINKSHARE REALTIME UPPERLIMIT
%token	QUEUE PRIORITY QLIMIT
%token	LOAD
%token	STICKYADDRESS MAXSRCSTATES MAXSRCNODES SOURCETRACK GLOBAL RULE
%token	TAGGED TAG IFBOUND GRBOUND FLOATING STATEPOLICY
%token	<v.string>		STRING
%token	<v.i>			PORTBINARY
%type	<v.interface>		interface if_list if_item_not if_item
%type	<v.number>		number icmptype icmp6type uid gid
%type	<v.number>		tos not yesno natpass
%type	<v.i>			no dir log af fragcache sourcetrack
%type	<v.i>			unaryop statelock
%type	<v.b>			action nataction flags flag blockspec
%type	<v.range>		port rport
%type	<v.hashkey>		hashkey
%type	<v.proto>		proto proto_list proto_item
%type	<v.icmp>		icmpspec
%type	<v.icmp>		icmp_list icmp_item
%type	<v.icmp>		icmp6_list icmp6_item
%type	<v.fromto>		fromto
%type	<v.peer>		ipportspec from to
%type	<v.host>		ipspec xhost host host_list
%type	<v.host>		redir_host_list redirspec
%type	<v.host>		route_host route_host_list routespec
%type	<v.os>			os xos os_list
%type	<v.port>		portspec port_list port_item
%type	<v.uid>			uids uid_list uid_item
%type	<v.gid>			gids gid_list gid_item
%type	<v.route>		route
%type	<v.redirection>		redirection redirpool
%type	<v.string>		label string tag
%type	<v.keep_state>		keep
%type	<v.state_opt>		state_opt_spec state_opt_list state_opt_item
%type	<v.logquick>		logquick
%type	<v.qassign>		qname
%type	<v.queue>		qassign qassign_list qassign_item
%type	<v.queue_options>	scheduler
%type	<v.number>		cbqflags_list cbqflags_item
%type	<v.number>		priqflags_list priqflags_item
%type	<v.hfsc_opts>		hfscopts_list hfscopts_item hfsc_opts
%type	<v.queue_bwspec>	bandwidth
%type	<v.filter_opts>		filter_opts filter_opt filter_opts_l
%type	<v.queue_opts>		queue_opts queue_opt queue_opts_l
%type	<v.scrub_opts>		scrub_opts scrub_opt scrub_opts_l
%type	<v.table_opts>		table_opts table_opt table_opts_l
%type	<v.pool_opts>		pool_opts pool_opt pool_opts_l
%%

ruleset		: /* empty */
		| ruleset '\n'
		| ruleset option '\n'
		| ruleset scrubrule '\n'
		| ruleset natrule '\n'
		| ruleset binatrule '\n'
		| ruleset pfrule '\n'
		| ruleset anchorrule '\n'
		| ruleset loadrule '\n'
		| ruleset altqif '\n'
		| ruleset queuespec '\n'
		| ruleset varset '\n'
		| ruleset tabledef '\n'
		| ruleset error '\n'		{ errors++; }
		;

option		: SET OPTIMIZATION STRING		{
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
				YYERROR;
			}
			if (pfctl_set_optimization(pf, $3) != 0) {
				yyerror("unknown optimization %s", $3);
				free($3);
				YYERROR;
			}
			free ($3);
		}
		| SET TIMEOUT timeout_spec
		| SET TIMEOUT '{' timeout_list '}'
		| SET LIMIT limit_spec
		| SET LIMIT '{' limit_list '}'
		| SET LOGINTERFACE STRING		{
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
				YYERROR;
			}
			if ((ifa_exists($3, 0) == NULL) && strcmp($3, "none")) {
				yyerror("interface %s doesn't exist", $3);
				free($3);
				YYERROR;
			}
			if (pfctl_set_logif(pf, $3) != 0) {
				yyerror("error setting loginterface %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
		}
		| SET HOSTID number {
			if ($3 == 0) {
				yyerror("hostid must be non-zero");
				YYERROR;
			}
			if (pfctl_set_hostid(pf, $3) != 0) {
				yyerror("error setting hostid %08x", $3);
				YYERROR;
			}
		}
		| SET BLOCKPOLICY DROP	{
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set block-policy drop\n");
			if (check_rulestate(PFCTL_STATE_OPTION))
				YYERROR;
			blockpolicy = PFRULE_DROP;
		}
		| SET BLOCKPOLICY RETURN {
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set block-policy return\n");
			if (check_rulestate(PFCTL_STATE_OPTION))
				YYERROR;
			blockpolicy = PFRULE_RETURN;
		}
		| SET REQUIREORDER yesno {
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set require-order %s\n",
				    $3 == 1 ? "yes" : "no");
			require_order = $3;
		}
		| SET FINGERPRINTS STRING {
			if (pf->opts & PF_OPT_VERBOSE)
				printf("fingerprints %s\n", $3);
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
				YYERROR;
			}
			if (pfctl_file_fingerprints(pf->dev, pf->opts, $3)) {
				yyerror("error loading fingerprints %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
		}
		| SET STATEPOLICY statelock {
			if (pf->opts & PF_OPT_VERBOSE)
				switch ($3) {
				case 0:
					printf("set state-policy floating\n");
					break;
				case PFRULE_IFBOUND:
					printf("set state-policy if-bound\n");
					break;
				case PFRULE_GRBOUND:
					printf("set state-policy "
					    "group-bound\n");
					break;
				}
			default_statelock = $3;
		}
		| SET DEBUG STRING {
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
				YYERROR;
			}
			if (pfctl_set_debug(pf, $3) != 0) {
				yyerror("error setting debuglevel %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
		}
		;

string		: string STRING				{
			if (asprintf(&$$, "%s %s", $1, $2) == -1)
				err(1, "string: asprintf");
			free($1);
			free($2);
		}
		| STRING
		;

varset		: STRING '=' string		{
			if (pf->opts & PF_OPT_VERBOSE)
				printf("%s = \"%s\"\n", $1, $3);
			if (symset($1, $3, 0) == -1)
				err(1, "cannot store variable %s", $1);
			free($1);
			free($3);
		}
		;

anchorrule	: ANCHOR string	dir interface af proto fromto filter_opts {
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_FILTER)) {
				free($2);
				YYERROR;
			}

			PREPARE_ANCHOR_RULE(r, $2);
			r.direction = $3;
			r.af = $5;
			r.prob = $8.prob;

			if ($8.match_tag)
				if (strlcpy(r.match_tagname, $8.match_tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			r.match_tag_not = $8.match_tag_not;

			decide_address_family($7.src.host, &r.af);
			decide_address_family($7.dst.host, &r.af);

			expand_rule(&r, $4, NULL, $6, $7.src_os,
			    $7.src.host, $7.src.port, $7.dst.host, $7.dst.port,
			    0, 0, 0);
		}
		| NATANCHOR string interface af proto fromto {
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_NAT)) {
				free($2);
				YYERROR;
			}

			PREPARE_ANCHOR_RULE(r, $2);
			free($2);
			r.action = PF_NAT;
			r.af = $4;

			decide_address_family($6.src.host, &r.af);
			decide_address_family($6.dst.host, &r.af);

			expand_rule(&r, $3, NULL, $5, $6.src_os,
			    $6.src.host, $6.src.port, $6.dst.host, $6.dst.port,
			    0, 0, 0);
		}
		| RDRANCHOR string interface af proto fromto {
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_NAT)) {
				free($2);
				YYERROR;
			}

			PREPARE_ANCHOR_RULE(r, $2);
			free($2);
			r.action = PF_RDR;
			r.af = $4;

			decide_address_family($6.src.host, &r.af);
			decide_address_family($6.dst.host, &r.af);

			if ($6.src.port != NULL) {
				yyerror("source port parameter not supported"
				    " in rdr-anchor");
				YYERROR;
			}
			if ($6.dst.port != NULL) {
				if ($6.dst.port->next != NULL) {
					yyerror("destination port list "
					    "expansion not supported in "
					    "rdr-anchor");
					YYERROR;
				} else if ($6.dst.port->op != PF_OP_EQ) {
					yyerror("destination port operators"
					    " not supported in rdr-anchor");
					YYERROR;
				}
				r.dst.port[0] = $6.dst.port->port[0];
				r.dst.port[1] = $6.dst.port->port[1];
				r.dst.port_op = $6.dst.port->op;
			}

			expand_rule(&r, $3, NULL, $5, $6.src_os,
			    $6.src.host, $6.src.port, $6.dst.host, $6.dst.port,
			    0, 0, 0);
		}
		| BINATANCHOR string interface af proto fromto {
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_NAT)) {
				free($2);
				YYERROR;
			}

			PREPARE_ANCHOR_RULE(r, $2);
			free($2);
			r.action = PF_BINAT;
			r.af = $4;
			if ($5 != NULL) {
				if ($5->next != NULL) {
					yyerror("proto list expansion"
					    " not supported in binat-anchor");
					YYERROR;
				}
				r.proto = $5->proto;
				free($5);
			}

			if ($6.src.host != NULL || $6.src.port != NULL ||
			    $6.dst.host != NULL || $6.dst.port != NULL) {
				yyerror("fromto parameter not supported"
				    " in binat-anchor");
				YYERROR;
			}

			decide_address_family($6.src.host, &r.af);
			decide_address_family($6.dst.host, &r.af);

			pfctl_add_rule(pf, &r);
		}
		;

loadrule	: LOAD ANCHOR string FROM string	{
			char			*t;
			struct loadanchors	*loadanchor;

			t = strsep(&$3, ":");
			if (*t == '\0' || $3 == NULL || *$3 == '\0') {
				yyerror("anchor '%s' invalid\n", $3);
				free(t);
				YYERROR;
			}
			if (strlen(t) >= PF_ANCHOR_NAME_SIZE) {
				yyerror("anchorname %s too long, max %u\n",
				    t, PF_ANCHOR_NAME_SIZE - 1);
				free(t);
				YYERROR;
			}
			if (strlen($3) >= PF_RULESET_NAME_SIZE) {
				yyerror("rulesetname %s too long, max %u\n",
				    $3, PF_RULESET_NAME_SIZE - 1);
				free(t);
				YYERROR;
			}

			loadanchor = calloc(1, sizeof(struct loadanchors));
			if (loadanchor == NULL)
				err(1, "loadrule: calloc");
			if ((loadanchor->anchorname = strdup(t)) == NULL)
				err(1, "loadrule: strdup");
			if ((loadanchor->rulesetname = strdup($3)) == NULL)
				err(1, "loadrule: strdup");
			if ((loadanchor->filename = strdup($5)) == NULL)
				err(1, "loadrule: strdup");

			TAILQ_INSERT_TAIL(&loadanchorshead, loadanchor,
			    entries);

			free(t); /* not $3 */
			free($5);
		};

scrubrule	: SCRUB dir logquick interface af proto fromto scrub_opts
		{
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_SCRUB))
				YYERROR;

			memset(&r, 0, sizeof(r));

			r.action = PF_SCRUB;
			r.direction = $2;

			r.log = $3.log;
			if ($3.quick) {
				yyerror("scrub rules do not support 'quick'");
				YYERROR;
			}

			r.af = $5;
			if ($8.nodf)
				r.rule_flag |= PFRULE_NODF;
			if ($8.randomid)
				r.rule_flag |= PFRULE_RANDOMID;
			if ($8.reassemble_tcp) {
				if (r.direction != PF_INOUT) {
					yyerror("reassemble tcp rules can not "
					    "specify direction");
					YYERROR;
				}
				r.rule_flag |= PFRULE_REASSEMBLE_TCP;
			}
			if ($8.minttl)
				r.min_ttl = $8.minttl;
			if ($8.maxmss)
				r.max_mss = $8.maxmss;
			if ($8.fragcache)
				r.rule_flag |= $8.fragcache;

			expand_rule(&r, $4, NULL, $6, $7.src_os,
			    $7.src.host, $7.src.port, $7.dst.host, $7.dst.port,
			    NULL, NULL, NULL);
		}
		;

scrub_opts	:	{
			bzero(&scrub_opts, sizeof scrub_opts);
		}
		    scrub_opts_l
			{ $$ = scrub_opts; }
		| /* empty */ {
			bzero(&scrub_opts, sizeof scrub_opts);
			$$ = scrub_opts;
		}
		;

scrub_opts_l	: scrub_opts_l scrub_opt
		| scrub_opt
		;

scrub_opt	: NODF	{
			if (scrub_opts.nodf) {
				yyerror("no-df cannot be respecified");
				YYERROR;
			}
			scrub_opts.nodf = 1;
		}
		| MINTTL number {
			if (scrub_opts.marker & SOM_MINTTL) {
				yyerror("min-ttl cannot be respecified");
				YYERROR;
			}
			if ($2 > 255) {
				yyerror("illegal min-ttl value %d", $2);
				YYERROR;
			}
			scrub_opts.marker |= SOM_MINTTL;
			scrub_opts.minttl = $2;
		}
		| MAXMSS number {
			if (scrub_opts.marker & SOM_MAXMSS) {
				yyerror("max-mss cannot be respecified");
				YYERROR;
			}
			if ($2 > 65535) {
				yyerror("illegal max-mss value %d", $2);
				YYERROR;
			}
			scrub_opts.marker |= SOM_MAXMSS;
			scrub_opts.maxmss = $2;
		}
		| fragcache {
			if (scrub_opts.marker & SOM_FRAGCACHE) {
				yyerror("fragcache cannot be respecified");
				YYERROR;
			}
			scrub_opts.marker |= SOM_FRAGCACHE;
			scrub_opts.fragcache = $1;
		}
		| REASSEMBLE STRING {
			if (strcasecmp($2, "tcp") != 0) {
				free($2);
				YYERROR;
			}
			free($2);
			if (scrub_opts.reassemble_tcp) {
				yyerror("reassemble tcp cannot be respecified");
				YYERROR;
			}
			scrub_opts.reassemble_tcp = 1;
		}
		| RANDOMID {
			if (scrub_opts.randomid) {
				yyerror("random-id cannot be respecified");
				YYERROR;
			}
			scrub_opts.randomid = 1;
		}
		;

fragcache	: FRAGMENT REASSEMBLE	{ $$ = 0; /* default */ }
		| FRAGMENT FRAGCROP	{ $$ = PFRULE_FRAGCROP; }
		| FRAGMENT FRAGDROP	{ $$ = PFRULE_FRAGDROP; }
		;

not		: '!'		{ $$ = 1; }
		| /* empty */	{ $$ = 0; }
		;

tabledef	: TABLE '<' STRING '>' table_opts {
			struct node_host	 *h, *nh;
			struct node_tinit	 *ti, *nti;

			if (strlen($3) >= PF_TABLE_NAME_SIZE) {
				yyerror("table name too long, max %d chars",
				    PF_TABLE_NAME_SIZE - 1);
				free($3);
				YYERROR;
			}
			if (pf->loadopt & PFCTL_FLAG_TABLE)
				if (process_tabledef($3, &$5)) {
					free($3);
					YYERROR;
				}
			free($3);
			for (ti = SIMPLEQ_FIRST(&$5.init_nodes);
			    ti != SIMPLEQ_END(&$5.init_nodes); ti = nti) {
				if (ti->file)
					free(ti->file);
				for (h = ti->host; h != NULL; h = nh) {
					nh = h->next;
					free(h);
				}
				nti = SIMPLEQ_NEXT(ti, entries);
				free(ti);
			}
		}
		;

table_opts	:	{
			bzero(&table_opts, sizeof table_opts);
			SIMPLEQ_INIT(&table_opts.init_nodes);
		}
		    table_opts_l
			{ $$ = table_opts; }
		| /* empty */
			{
			bzero(&table_opts, sizeof table_opts);
			SIMPLEQ_INIT(&table_opts.init_nodes);
			$$ = table_opts;
		}
		;

table_opts_l	: table_opts_l table_opt
		| table_opt
		;

table_opt	: STRING		{
			if (!strcmp($1, "const"))
				table_opts.flags |= PFR_TFLAG_CONST;
			else if (!strcmp($1, "persist"))
				table_opts.flags |= PFR_TFLAG_PERSIST;
			else {
				free($1);
				YYERROR;
			}
			free($1);
		}
		| '{' '}'		{ table_opts.init_addr = 1; }
		| '{' host_list '}'	{
			struct node_host	*n;
			struct node_tinit	*ti;

			for (n = $2; n != NULL; n = n->next) {
				switch (n->addr.type) {
				case PF_ADDR_ADDRMASK:
					continue; /* ok */
				case PF_ADDR_TABLE:
					yyerror("tables cannot contain tables");
					break;
				case PF_ADDR_NOROUTE:
					yyerror("\"no-route\" is not permitted "
					    "inside tables");
					break;
				default:
					yyerror("unknown address type %d",
					    n->addr.type);
				}
				YYERROR;
			}
			if (!(ti = calloc(1, sizeof(*ti))))
				err(1, "table_opt: calloc");
			ti->host = $2;
			SIMPLEQ_INSERT_TAIL(&table_opts.init_nodes, ti,
			    entries);
			table_opts.init_addr = 1;
		}
		| FILENAME STRING	{
			struct node_tinit	*ti;

			if (!(ti = calloc(1, sizeof(*ti))))
				err(1, "table_opt: calloc");
			ti->file = $2;
			SIMPLEQ_INSERT_TAIL(&table_opts.init_nodes, ti,
			    entries);
			table_opts.init_addr = 1;
		}
		;

altqif		: ALTQ interface queue_opts QUEUE qassign {
			struct pf_altq	a;

			if (check_rulestate(PFCTL_STATE_QUEUE))
				YYERROR;

			memset(&a, 0, sizeof(a));
			if ($3.scheduler.qtype == ALTQT_NONE) {
				yyerror("no scheduler specified!");
				YYERROR;
			}
			a.scheduler = $3.scheduler.qtype;
			a.qlimit = $3.qlimit;
			a.tbrsize = $3.tbrsize;
			if ($5 == NULL) {
				yyerror("no child queues specified");
				YYERROR;
			}
			if (expand_altq(&a, $2, $5, $3.queue_bwspec,
			    &$3.scheduler))
				YYERROR;
		}
		;

queuespec	: QUEUE STRING interface queue_opts qassign {
			struct pf_altq	a;

			if (check_rulestate(PFCTL_STATE_QUEUE)) {
				free($2);
				YYERROR;
			}

			memset(&a, 0, sizeof(a));

			if (strlcpy(a.qname, $2, sizeof(a.qname)) >=
			    sizeof(a.qname)) {
				yyerror("queue name too long (max "
				    "%d chars)", PF_QNAME_SIZE-1);
				free($2);
				YYERROR;
			}
			free($2);
			if ($4.tbrsize) {
				yyerror("cannot specify tbrsize for queue");
				YYERROR;
			}
			if ($4.priority > 255) {
				yyerror("priority out of range: max 255");
				YYERROR;
			}
			a.priority = $4.priority;
			a.qlimit = $4.qlimit;
			a.scheduler = $4.scheduler.qtype;
			if (expand_queue(&a, $3, $5, $4.queue_bwspec,
			    &$4.scheduler)) {
				yyerror("errors in queue definition");
				YYERROR;
			}
		}
		;

queue_opts	:	{
			bzero(&queue_opts, sizeof queue_opts);
			queue_opts.priority = DEFAULT_PRIORITY;
			queue_opts.qlimit = DEFAULT_QLIMIT;
			queue_opts.scheduler.qtype = ALTQT_NONE;
			queue_opts.queue_bwspec.bw_percent = 100;
		}
		    queue_opts_l
			{ $$ = queue_opts; }
		| /* empty */ {
			bzero(&queue_opts, sizeof queue_opts);
			queue_opts.priority = DEFAULT_PRIORITY;
			queue_opts.qlimit = DEFAULT_QLIMIT;
			queue_opts.scheduler.qtype = ALTQT_NONE;
			queue_opts.queue_bwspec.bw_percent = 100;
			$$ = queue_opts;
		}
		;

queue_opts_l	: queue_opts_l queue_opt
		| queue_opt
		;

queue_opt	: BANDWIDTH bandwidth	{
			if (queue_opts.marker & QOM_BWSPEC) {
				yyerror("bandwidth cannot be respecified");
				YYERROR;
			}
			queue_opts.marker |= QOM_BWSPEC;
			queue_opts.queue_bwspec = $2;
		}
		| PRIORITY number	{
			if (queue_opts.marker & QOM_PRIORITY) {
				yyerror("priority cannot be respecified");
				YYERROR;
			}
			if ($2 > 255) {
				yyerror("priority out of range: max 255");
				YYERROR;
			}
			queue_opts.marker |= QOM_PRIORITY;
			queue_opts.priority = $2;
		}
		| QLIMIT number	{
			if (queue_opts.marker & QOM_QLIMIT) {
				yyerror("qlimit cannot be respecified");
				YYERROR;
			}
			if ($2 > 65535) {
				yyerror("qlimit out of range: max 65535");
				YYERROR;
			}
			queue_opts.marker |= QOM_QLIMIT;
			queue_opts.qlimit = $2;
		}
		| scheduler	{
			if (queue_opts.marker & QOM_SCHEDULER) {
				yyerror("scheduler cannot be respecified");
				YYERROR;
			}
			queue_opts.marker |= QOM_SCHEDULER;
			queue_opts.scheduler = $1;
		}
		| TBRSIZE number	{
			if (queue_opts.marker & QOM_TBRSIZE) {
				yyerror("tbrsize cannot be respecified");
				YYERROR;
			}
			if ($2 > 65535) {
				yyerror("tbrsize too big: max 65535");
				YYERROR;
			}
			queue_opts.marker |= QOM_TBRSIZE;
			queue_opts.tbrsize = $2;
		}
		;

bandwidth	: STRING {
			double	 bps;
			char	*cp;

			$$.bw_percent = 0;

			bps = strtod($1, &cp);
			if (cp != NULL) {
				if (!strcmp(cp, "b"))
					; /* nothing */
				else if (!strcmp(cp, "Kib"))
					bps *= 1024;
				else if (!strcmp(cp, "Mib"))
					bps *= 1024 * 1024;
				else if (!strcmp(cp, "Gib"))
					bps *= 1024 * 1024 * 1024;
				else if (!strcmp(cp, "%")) {
					if (bps < 0 || bps > 100) {
						yyerror("bandwidth spec "
						    "out of range");
						free($1);
						YYERROR;
					}
					$$.bw_percent = bps;
					bps = 0;
				} else {
					yyerror("unknown unit %s", cp);
					free($1);
					YYERROR;
				}
			}
			free($1);
			$$.bw_absolute = (u_int32_t)bps;
		}
		;

scheduler	: CBQ				{
			$$.qtype = ALTQT_CBQ;
			$$.data.cbq_opts.flags = 0;
		}
		| CBQ '(' cbqflags_list ')'	{
			$$.qtype = ALTQT_CBQ;
			$$.data.cbq_opts.flags = $3;
		}
		| PRIQ				{
			$$.qtype = ALTQT_PRIQ;
			$$.data.priq_opts.flags = 0;
		}
		| PRIQ '(' priqflags_list ')'	{
			$$.qtype = ALTQT_PRIQ;
			$$.data.priq_opts.flags = $3;
		}
		| HFSC				{
			$$.qtype = ALTQT_HFSC;
			bzero(&$$.data.hfsc_opts,
			    sizeof(struct node_hfsc_opts));
		}
		| HFSC '(' hfsc_opts ')'	{
			$$.qtype = ALTQT_HFSC;
			$$.data.hfsc_opts = $3;
		}
		;

cbqflags_list	: cbqflags_item				{ $$ |= $1; }
		| cbqflags_list comma cbqflags_item	{ $$ |= $3; }
		;

cbqflags_item	: STRING	{
			if (!strcmp($1, "default"))
				$$ = CBQCLF_DEFCLASS;
			else if (!strcmp($1, "borrow"))
				$$ = CBQCLF_BORROW;
			else if (!strcmp($1, "red"))
				$$ = CBQCLF_RED;
			else if (!strcmp($1, "ecn"))
				$$ = CBQCLF_RED|CBQCLF_ECN;
			else if (!strcmp($1, "rio"))
				$$ = CBQCLF_RIO;
			else {
				yyerror("unknown cbq flag \"%s\"", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

priqflags_list	: priqflags_item			{ $$ |= $1; }
		| priqflags_list comma priqflags_item	{ $$ |= $3; }
		;

priqflags_item	: STRING	{
			if (!strcmp($1, "default"))
				$$ = PRCF_DEFAULTCLASS;
			else if (!strcmp($1, "red"))
				$$ = PRCF_RED;
			else if (!strcmp($1, "ecn"))
				$$ = PRCF_RED|PRCF_ECN;
			else if (!strcmp($1, "rio"))
				$$ = PRCF_RIO;
			else {
				yyerror("unknown priq flag \"%s\"", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

hfsc_opts	:	{
				bzero(&hfsc_opts,
				    sizeof(struct node_hfsc_opts));
			}
		    hfscopts_list				{
			$$ = hfsc_opts;
		}
		;

hfscopts_list	: hfscopts_item
		| hfscopts_list comma hfscopts_item
		;

hfscopts_item	: LINKSHARE bandwidth				{
			if (hfsc_opts.linkshare.used) {
				yyerror("linkshare already specified");
				YYERROR;
			}
			hfsc_opts.linkshare.m2 = $2;
			hfsc_opts.linkshare.used = 1;
		}
		| LINKSHARE '(' bandwidth number bandwidth ')'	{
			if (hfsc_opts.linkshare.used) {
				yyerror("linkshare already specified");
				YYERROR;
			}
			hfsc_opts.linkshare.m1 = $3;
			hfsc_opts.linkshare.d = $4;
			hfsc_opts.linkshare.m2 = $5;
			hfsc_opts.linkshare.used = 1;
		}
		| REALTIME bandwidth				{
			if (hfsc_opts.realtime.used) {
				yyerror("realtime already specified");
				YYERROR;
			}
			hfsc_opts.realtime.m2 = $2;
			hfsc_opts.realtime.used = 1;
		}
		| REALTIME '(' bandwidth number bandwidth ')'	{
			if (hfsc_opts.realtime.used) {
				yyerror("realtime already specified");
				YYERROR;
			}
			hfsc_opts.realtime.m1 = $3;
			hfsc_opts.realtime.d = $4;
			hfsc_opts.realtime.m2 = $5;
			hfsc_opts.realtime.used = 1;
		}
		| UPPERLIMIT bandwidth				{
			if (hfsc_opts.upperlimit.used) {
				yyerror("upperlimit already specified");
				YYERROR;
			}
			hfsc_opts.upperlimit.m2 = $2;
			hfsc_opts.upperlimit.used = 1;
		}
		| UPPERLIMIT '(' bandwidth number bandwidth ')'	{
			if (hfsc_opts.upperlimit.used) {
				yyerror("upperlimit already specified");
				YYERROR;
			}
			hfsc_opts.upperlimit.m1 = $3;
			hfsc_opts.upperlimit.d = $4;
			hfsc_opts.upperlimit.m2 = $5;
			hfsc_opts.upperlimit.used = 1;
		}
		| STRING	{
			if (!strcmp($1, "default"))
				hfsc_opts.flags |= HFCF_DEFAULTCLASS;
			else if (!strcmp($1, "red"))
				hfsc_opts.flags |= HFCF_RED;
			else if (!strcmp($1, "ecn"))
				hfsc_opts.flags |= HFCF_RED|HFCF_ECN;
			else if (!strcmp($1, "rio"))
				hfsc_opts.flags |= HFCF_RIO;
			else {
				yyerror("unknown hfsc flag \"%s\"", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

qassign		: /* empty */		{ $$ = NULL; }
		| qassign_item		{ $$ = $1; }
		| '{' qassign_list '}'	{ $$ = $2; }
		;

qassign_list	: qassign_item			{ $$ = $1; }
		| qassign_list comma qassign_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

qassign_item	: STRING			{
			$$ = calloc(1, sizeof(struct node_queue));
			if ($$ == NULL)
				err(1, "qassign_item: calloc");
			if (strlcpy($$->queue, $1, sizeof($$->queue)) >=
			    sizeof($$->queue)) {
				yyerror("queue name '%s' too long (max "
				    "%d chars)", $1, sizeof($$->queue)-1);
				free($1);
				free($$);
				YYERROR;
			}
			free($1);
			$$->next = NULL;
			$$->tail = $$;
		}
		;

pfrule		: action dir logquick interface route af proto fromto
		    filter_opts
		{
			struct pf_rule		 r;
			struct node_state_opt	*o;
			struct node_proto	*proto;
			int			 srctrack = 0;
			int			 statelock = 0;

			if (check_rulestate(PFCTL_STATE_FILTER))
				YYERROR;

			memset(&r, 0, sizeof(r));

			r.action = $1.b1;
			switch ($1.b2) {
			case PFRULE_RETURNRST:
				r.rule_flag |= PFRULE_RETURNRST;
				r.return_ttl = $1.w;
				break;
			case PFRULE_RETURNICMP:
				r.rule_flag |= PFRULE_RETURNICMP;
				r.return_icmp = $1.w;
				r.return_icmp6 = $1.w2;
				break;
			case PFRULE_RETURN:
				r.rule_flag |= PFRULE_RETURN;
				r.return_icmp = $1.w;
				r.return_icmp6 = $1.w2;
				break;
			}
			r.direction = $2;
			r.log = $3.log;
			r.quick = $3.quick;
			r.prob = $9.prob;

			r.af = $6;
			if ($9.tag)
				if (strlcpy(r.tagname, $9.tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			if ($9.match_tag)
				if (strlcpy(r.match_tagname, $9.match_tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			r.match_tag_not = $9.match_tag_not;
			r.flags = $9.flags.b1;
			r.flagset = $9.flags.b2;
			if (rule_label(&r, $9.label))
				YYERROR;
			free($9.label);
			if ($9.flags.b1 || $9.flags.b2 || $8.src_os) {
				for (proto = $7; proto != NULL &&
				    proto->proto != IPPROTO_TCP;
				    proto = proto->next)
					;	/* nothing */
				if (proto == NULL && $7 != NULL) {
					if ($9.flags.b1 || $9.flags.b2)
						yyerror(
						    "flags only apply to tcp");
					if ($8.src_os)
						yyerror(
						    "OS fingerprinting only "
						    "apply to tcp");
					YYERROR;
				}
#if 0
				if (($9.flags.b1 & parse_flags("S")) == 0 &&
				    $8.src_os) {
					yyerror("OS fingerprinting requires "
					    "the SYN TCP flag (flags S/SA)");
					YYERROR;
				}
#endif
			}

			r.tos = $9.tos;
			r.keep_state = $9.keep.action;
			o = $9.keep.options;
			while (o) {
				struct node_state_opt	*p = o;

				switch (o->type) {
				case PF_STATE_OPT_MAX:
					if (r.max_states) {
						yyerror("state option 'max' "
						    "multiple definitions");
						YYERROR;
					}
					r.max_states = o->data.max_states;
					break;
				case PF_STATE_OPT_NOSYNC:
					if (r.rule_flag & PFRULE_NOSYNC) {
						yyerror("state option 'sync' "
						    "multiple definitions");
						YYERROR;
					}
					r.rule_flag |= PFRULE_NOSYNC;
					break;
				case PF_STATE_OPT_SRCTRACK:
					if (srctrack) {
						yyerror("state option "
						    "'source-track' "
						    "multiple definitions");
						YYERROR;
					}
					srctrack =  o->data.src_track;
					break;
				case PF_STATE_OPT_MAX_SRC_STATES:
					if (r.max_src_states) {
						yyerror("state option "
						    "'max-src-states' "
						    "multiple definitions");
						YYERROR;
					}
					if (o->data.max_src_nodes == 0) {
						yyerror("'max-src-states' must "
						    "be > 0");
						YYERROR;
					}
					r.max_src_states =
					    o->data.max_src_states;
					r.rule_flag |= PFRULE_SRCTRACK;
					break;
				case PF_STATE_OPT_MAX_SRC_NODES:
					if (r.max_src_nodes) {
						yyerror("state option "
						    "'max-src-nodes' "
						    "multiple definitions");
						YYERROR;
					}
					if (o->data.max_src_nodes == 0) {
						yyerror("'max-src-nodes' must "
						    "be > 0");
						YYERROR;
					}
					r.max_src_nodes =
					    o->data.max_src_nodes;
					r.rule_flag |= PFRULE_SRCTRACK |
					    PFRULE_RULESRCTRACK;
					break;
				case PF_STATE_OPT_STATELOCK:
					if (statelock) {
						yyerror("state locking option: "
						    "multiple definitions");
						YYERROR;
					}
					statelock = 1;
					r.rule_flag |= o->data.statelock;
					break;
				case PF_STATE_OPT_TIMEOUT:
					if (r.timeout[o->data.timeout.number]) {
						yyerror("state timeout %s "
						    "multiple definitions",
						    pf_timeouts[o->data.
						    timeout.number].name);
						YYERROR;
					}
					r.timeout[o->data.timeout.number] =
					    o->data.timeout.seconds;
				}
				o = o->next;
				free(p);
			}
			if (srctrack) {
				if (srctrack == PF_SRCTRACK_GLOBAL &&
				    r.max_src_nodes) {
					yyerror("'max-src-nodes' is "
					    "incompatible with "
					    "'source-track global'");
					YYERROR;
				}
				r.rule_flag |= PFRULE_SRCTRACK;
				if (srctrack == PF_SRCTRACK_RULE)
					r.rule_flag |= PFRULE_RULESRCTRACK;
			}
			if (r.keep_state && !statelock)
				r.rule_flag |= default_statelock;

			if ($9.fragment)
				r.rule_flag |= PFRULE_FRAGMENT;
			r.allow_opts = $9.allowopts;

			decide_address_family($8.src.host, &r.af);
			decide_address_family($8.dst.host, &r.af);

			if ($5.rt) {
				if (!r.direction) {
					yyerror("direction must be explicit "
					    "with rules that specify routing");
					YYERROR;
				}
				r.rt = $5.rt;
				r.rpool.opts = $5.pool_opts;
				if ($5.key != NULL)
					memcpy(&r.rpool.key, $5.key,
					    sizeof(struct pf_poolhashkey));
			}
			if (r.rt && r.rt != PF_FASTROUTE) {
				decide_address_family($5.host, &r.af);
				remove_invalid_hosts(&$5.host, &r.af);
				if ($5.host == NULL) {
					yyerror("no routing address with "
					    "matching address family found.");
					YYERROR;
				}
				if ((r.rpool.opts & PF_POOL_TYPEMASK) ==
				    PF_POOL_NONE && ($5.host->next != NULL ||
				    $5.host->addr.type == PF_ADDR_TABLE))
					r.rpool.opts |= PF_POOL_ROUNDROBIN;
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
				    disallow_table($5.host, "tables are only "
				    "supported in round-robin routing pools"))
					YYERROR;
				if ($5.host->next != NULL) {
					if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
					    PF_POOL_ROUNDROBIN) {
						yyerror("r.rpool.opts must "
						    "be PF_POOL_ROUNDROBIN");
						YYERROR;
					}
				}
			}
			if ($9.queues.qname != NULL) {
				if (strlcpy(r.qname, $9.queues.qname,
				    sizeof(r.qname)) >= sizeof(r.qname)) {
					yyerror("rule qname too long (max "
					    "%d chars)", sizeof(r.qname)-1);
					YYERROR;
				}
				free($9.queues.qname);
			}
			if ($9.queues.pqname != NULL) {
				if (strlcpy(r.pqname, $9.queues.pqname,
				    sizeof(r.pqname)) >= sizeof(r.pqname)) {
					yyerror("rule pqname too long (max "
					    "%d chars)", sizeof(r.pqname)-1);
					YYERROR;
				}
				free($9.queues.pqname);
			}

			expand_rule(&r, $4, $5.host, $7, $8.src_os,
			    $8.src.host, $8.src.port, $8.dst.host, $8.dst.port,
			    $9.uid, $9.gid, $9.icmpspec);
		}
		;

filter_opts	:	{ bzero(&filter_opts, sizeof filter_opts); }
		    filter_opts_l
			{ $$ = filter_opts; }
		| /* empty */	{
			bzero(&filter_opts, sizeof filter_opts);
			$$ = filter_opts;
		}
		;

filter_opts_l	: filter_opts_l filter_opt
		| filter_opt
		;

filter_opt	: USER uids {
			if (filter_opts.uid)
				$2->tail->next = filter_opts.uid;
			filter_opts.uid = $2;
		}
		| GROUP gids {
			if (filter_opts.gid)
				$2->tail->next = filter_opts.gid;
			filter_opts.gid = $2;
		}
		| flags {
			if (filter_opts.marker & FOM_FLAGS) {
				yyerror("flags cannot be redefined");
				YYERROR;
			}
			filter_opts.marker |= FOM_FLAGS;
			filter_opts.flags.b1 |= $1.b1;
			filter_opts.flags.b2 |= $1.b2;
			filter_opts.flags.w |= $1.w;
			filter_opts.flags.w2 |= $1.w2;
		}
		| icmpspec {
			if (filter_opts.marker & FOM_ICMP) {
				yyerror("icmp-type cannot be redefined");
				YYERROR;
			}
			filter_opts.marker |= FOM_ICMP;
			filter_opts.icmpspec = $1;
		}
		| tos {
			if (filter_opts.marker & FOM_TOS) {
				yyerror("tos cannot be redefined");
				YYERROR;
			}
			filter_opts.marker |= FOM_TOS;
			filter_opts.tos = $1;
		}
		| keep {
			if (filter_opts.marker & FOM_KEEP) {
				yyerror("modulate or keep cannot be redefined");
				YYERROR;
			}
			filter_opts.marker |= FOM_KEEP;
			filter_opts.keep.action = $1.action;
			filter_opts.keep.options = $1.options;
		}
		| FRAGMENT {
			filter_opts.fragment = 1;
		}
		| ALLOWOPTS {
			filter_opts.allowopts = 1;
		}
		| label	{
			if (filter_opts.label) {
				yyerror("label cannot be redefined");
				YYERROR;
			}
			filter_opts.label = $1;
		}
		| qname	{
			if (filter_opts.queues.qname) {
				yyerror("queue cannot be redefined");
				YYERROR;
			}
			filter_opts.queues = $1;
		}
		| TAG string				{
			filter_opts.tag = $2;
		}
		| not TAGGED string			{
			filter_opts.match_tag = $3;
			filter_opts.match_tag_not = $1;
		}
		| PROBABILITY STRING			{
			char	*e;
			double	 p = strtod($2, &e);

			if (*e == '%') {
				p *= 0.01;
				e++;
			}
			if (*e) {
				yyerror("invalid probability: %s", $2);
				YYERROR;
			}
			p = floor(p * (UINT_MAX+1.0) + 0.5);
			if (p < 1.0 || p >= (UINT_MAX+1.0)) {
				yyerror("invalid probability: %s", $2);
				YYERROR;
			}
			filter_opts.prob = (u_int32_t)p;
			free($2);
		}
		;

action		: PASS			{ $$.b1 = PF_PASS; $$.b2 = $$.w = 0; }
		| BLOCK blockspec	{ $$ = $2; $$.b1 = PF_DROP; }
		| FUCKOFF		{
			$$.b1 = PF_DROP;
			$$.b2 = PFRULE_RETURN;
			$$.w = returnicmpdefault;
			$$.w2 = returnicmp6default;
		}
		;

blockspec	: /* empty */		{
			$$.b2 = blockpolicy;
			$$.w = returnicmpdefault;
			$$.w2 = returnicmp6default;
		}
		| DROP			{
			$$.b2 = PFRULE_DROP;
			$$.w = 0;
			$$.w2 = 0;
		}
		| RETURNRST		{
			$$.b2 = PFRULE_RETURNRST;
			$$.w = 0;
			$$.w2 = 0;
		}
		| RETURNRST '(' TTL number ')'	{
			if ($4 > 255) {
				yyerror("illegal ttl value %d", $4);
				YYERROR;
			}
			$$.b2 = PFRULE_RETURNRST;
			$$.w = $4;
			$$.w2 = 0;
		}
		| RETURNICMP		{
			$$.b2 = PFRULE_RETURNICMP;
			$$.w = returnicmpdefault;
			$$.w2 = returnicmp6default;
		}
		| RETURNICMP6		{
			$$.b2 = PFRULE_RETURNICMP;
			$$.w = returnicmpdefault;
			$$.w2 = returnicmp6default;
		}
		| RETURNICMP '(' STRING ')'	{
			$$.b2 = PFRULE_RETURNICMP;
			if (!($$.w = parseicmpspec($3, AF_INET))) {
				free($3);
				YYERROR;
			}
			free($3);
			$$.w2 = returnicmp6default;
		}
		| RETURNICMP6 '(' STRING ')'	{
			$$.b2 = PFRULE_RETURNICMP;
			$$.w = returnicmpdefault;
			if (!($$.w2 = parseicmpspec($3, AF_INET6))) {
				free($3);
				YYERROR;
			}
			free($3);
		}
		| RETURNICMP '(' STRING comma STRING ')' {
			$$.b2 = PFRULE_RETURNICMP;
			if (!($$.w = parseicmpspec($3, AF_INET)) ||
			    !($$.w2 = parseicmpspec($5, AF_INET6))) {
				free($3);
				free($5);
				YYERROR;
			}
			free($3);
			free($5);
		}
		| RETURN {
			$$.b2 = PFRULE_RETURN;
			$$.w = returnicmpdefault;
			$$.w2 = returnicmp6default;
		}
		;

dir		: /* empty */			{ $$ = 0; }
		| IN				{ $$ = PF_IN; }
		| OUT				{ $$ = PF_OUT; }
		;

logquick	: /* empty */			{ $$.log = 0; $$.quick = 0; }
		| log				{ $$.log = $1; $$.quick = 0; }
		| QUICK				{ $$.log = 0; $$.quick = 1; }
		| log QUICK			{ $$.log = $1; $$.quick = 1; }
		| QUICK log			{ $$.log = $2; $$.quick = 1; }
		;

log		: LOG				{ $$ = 1; }
		| LOGALL			{ $$ = 2; }
		;

interface	: /* empty */			{ $$ = NULL; }
		| ON if_item_not		{ $$ = $2; }
		| ON '{' if_list '}'		{ $$ = $3; }
		;

if_list		: if_item_not			{ $$ = $1; }
		| if_list comma if_item_not	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

if_item_not	: not if_item			{ $$ = $2; $$->not = $1; }
		;

if_item		: STRING			{
			struct node_host	*n;

			if ((n = ifa_exists($1, 1)) == NULL) {
				yyerror("unknown interface %s", $1);
				free($1);
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_if));
			if ($$ == NULL)
				err(1, "if_item: calloc");
			if (strlcpy($$->ifname, $1, sizeof($$->ifname)) >=
			    sizeof($$->ifname)) {
				free($1);
				free($$);
				yyerror("interface name too long");
				YYERROR;
			}
			free($1);
			$$->ifa_flags = n->ifa_flags;
			$$->not = 0;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

af		: /* empty */			{ $$ = 0; }
		| INET				{ $$ = AF_INET; }
		| INET6				{ $$ = AF_INET6; }
		;

proto		: /* empty */			{ $$ = NULL; }
		| PROTO proto_item		{ $$ = $2; }
		| PROTO '{' proto_list '}'	{ $$ = $3; }
		;

proto_list	: proto_item			{ $$ = $1; }
		| proto_list comma proto_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

proto_item	: STRING			{
			u_int8_t	pr;
			u_long		ulval;

			if (atoul($1, &ulval) == 0) {
				if (ulval > 255) {
					yyerror("protocol outside range");
					free($1);
					YYERROR;
				}
				pr = (u_int8_t)ulval;
			} else {
				struct protoent	*p;

				p = getprotobyname($1);
				if (p == NULL) {
					yyerror("unknown protocol %s", $1);
					free($1);
					YYERROR;
				}
				pr = p->p_proto;
			}
			free($1);
			if (pr == 0) {
				yyerror("proto 0 cannot be used");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_proto));
			if ($$ == NULL)
				err(1, "proto_item: calloc");
			$$->proto = pr;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

fromto		: ALL				{
			$$.src.host = NULL;
			$$.src.port = NULL;
			$$.dst.host = NULL;
			$$.dst.port = NULL;
			$$.src_os = NULL;
		}
		| from os to			{
			$$.src = $1;
			$$.src_os = $2;
			$$.dst = $3;
		}
		;

os		: /* empty */			{ $$ = NULL; }
		| OS xos			{ $$ = $2; }
		| OS '{' os_list '}'		{ $$ = $3; }
		;

xos		: STRING {
			$$ = calloc(1, sizeof(struct node_os));
			if ($$ == NULL)
				err(1, "os: calloc");
			$$->os = $1;
			$$->tail = $$;
		}
		;

os_list		: xos				{ $$ = $1; }
		| os_list comma xos		{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

from		: /* empty */			{
			$$.host = NULL;
			$$.port = NULL;
		}
		| FROM ipportspec		{
			$$ = $2;
		}
		;

to		: /* empty */			{
			$$.host = NULL;
			$$.port = NULL;
		}
		| TO ipportspec		{
			$$ = $2;
		}
		;

ipportspec	: ipspec			{
			$$.host = $1;
			$$.port = NULL;
		}
		| ipspec PORT portspec		{
			$$.host = $1;
			$$.port = $3;
		}
		| PORT portspec			{
			$$.host = NULL;
			$$.port = $2;
		}
		;

ipspec		: ANY				{ $$ = NULL; }
		| xhost				{ $$ = $1; }
		| '{' host_list '}'		{ $$ = $2; }
		;

host_list	: xhost				{ $$ = $1; }
		| host_list comma xhost		{
			if ($3 == NULL)
				$$ = $1;
			else if ($1 == NULL)
				$$ = $3;
			else {
				$1->tail->next = $3;
				$1->tail = $3->tail;
				$$ = $1;
			}
		}
		;

xhost		: not host			{
			struct node_host	*n;

			for (n = $2; n != NULL; n = n->next)
				n->not = $1;
			$$ = $2;
		}
		| NOROUTE			{
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "xhost: calloc");
			$$->addr.type = PF_ADDR_NOROUTE;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

host		: STRING			{
			if (($$ = host($1)) == NULL)	{
				/* error. "any" is handled elsewhere */
				free($1);
				yyerror("could not parse host specification");
				YYERROR;
			}
			free($1);

		}
		| STRING '/' number		{
			char	*buf;

			if (asprintf(&buf, "%s/%u", $1, $3) == -1)
				err(1, "host: asprintf");
			free($1);
			if (($$ = host(buf)) == NULL)	{
				/* error. "any" is handled elsewhere */
				free(buf);
				yyerror("could not parse host specification");
				YYERROR;
			}
			free(buf);
		}
		| '<' STRING '>'	{
			if (strlen($2) >= PF_TABLE_NAME_SIZE) {
				yyerror("table name '%s' too long", $2);
				free($2);
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "host: calloc");
			$$->addr.type = PF_ADDR_TABLE;
			if (strlcpy($$->addr.v.tblname, $2,
			    sizeof($$->addr.v.tblname)) >=
			    sizeof($$->addr.v.tblname))
				errx(1, "host: strlcpy");
			free($2);
			$$->next = NULL;
			$$->tail = $$;
		}
		;

number		: STRING			{
			u_long	ulval;

			if (atoul($1, &ulval) == -1) {
				yyerror("%s is not a number", $1);
				free($1);
				YYERROR;
			} else
				$$ = ulval;
			free($1);
		}
		;

portspec	: port_item			{ $$ = $1; }
		| '{' port_list '}'		{ $$ = $2; }
		;

port_list	: port_item			{ $$ = $1; }
		| port_list comma port_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

port_item	: port				{
			$$ = calloc(1, sizeof(struct node_port));
			if ($$ == NULL)
				err(1, "port_item: calloc");
			$$->port[0] = $1.a;
			$$->port[1] = $1.b;
			if ($1.t)
				$$->op = PF_OP_RRG;
			else
				$$->op = PF_OP_EQ;
			$$->next = NULL;
			$$->tail = $$;
		}
		| unaryop port		{
			if ($2.t) {
				yyerror("':' cannot be used with an other "
				    "port operator");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_port));
			if ($$ == NULL)
				err(1, "port_item: calloc");
			$$->port[0] = $2.a;
			$$->port[1] = $2.b;
			$$->op = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
		| port PORTBINARY port		{
			if ($1.t || $3.t) {
				yyerror("':' cannot be used with an other "
				    "port operator");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_port));
			if ($$ == NULL)
				err(1, "port_item: calloc");
			$$->port[0] = $1.a;
			$$->port[1] = $3.a;
			$$->op = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

port		: STRING			{
			char	*p = strchr($1, ':');
			struct servent	*s = NULL;
			u_long		 ulval;

			if (p == NULL) {
				if (atoul($1, &ulval) == 0) {
					if (ulval > 65535) {
						free($1);
						yyerror("illegal port value %d",
						    ulval);
						YYERROR;
					}
					$$.a = htons(ulval);
				} else {
					s = getservbyname($1, "tcp");
					if (s == NULL)
						s = getservbyname($1, "udp");
					if (s == NULL) {
						yyerror("unknown port %s", $1);
						free($1);
						YYERROR;
					}
					$$.a = s->s_port;
				}
				$$.b = 0;
				$$.t = 0;
			} else {
				int port[2];

				*p++ = 0;
				if ((port[0] = getservice($1)) == -1 ||
				    (port[1] = getservice(p)) == -1) {
					free($1);
					YYERROR;
				}
				$$.a = port[0];
				$$.b = port[1];
				$$.t = PF_OP_RRG;
			}
			free($1);
		}
		;

uids		: uid_item			{ $$ = $1; }
		| '{' uid_list '}'		{ $$ = $2; }
		;

uid_list	: uid_item			{ $$ = $1; }
		| uid_list comma uid_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

uid_item	: uid				{
			$$ = calloc(1, sizeof(struct node_uid));
			if ($$ == NULL)
				err(1, "uid_item: calloc");
			$$->uid[0] = $1;
			$$->uid[1] = $1;
			$$->op = PF_OP_EQ;
			$$->next = NULL;
			$$->tail = $$;
		}
		| unaryop uid			{
			if ($2 == UID_MAX && $1 != PF_OP_EQ && $1 != PF_OP_NE) {
				yyerror("user unknown requires operator = or "
				    "!=");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_uid));
			if ($$ == NULL)
				err(1, "uid_item: calloc");
			$$->uid[0] = $2;
			$$->uid[1] = $2;
			$$->op = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
		| uid PORTBINARY uid		{
			if ($1 == UID_MAX || $3 == UID_MAX) {
				yyerror("user unknown requires operator = or "
				    "!=");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_uid));
			if ($$ == NULL)
				err(1, "uid_item: calloc");
			$$->uid[0] = $1;
			$$->uid[1] = $3;
			$$->op = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

uid		: STRING			{
			u_long	ulval;

			if (atoul($1, &ulval) == -1) {
				if (!strcmp($1, "unknown"))
					$$ = UID_MAX;
				else {
					struct passwd	*pw;

					if ((pw = getpwnam($1)) == NULL) {
						yyerror("unknown user %s", $1);
						free($1);
						YYERROR;
					}
					$$ = pw->pw_uid;
				}
			} else {
				if (ulval >= UID_MAX) {
					free($1);
					yyerror("illegal uid value %lu", ulval);
					YYERROR;
				}
				$$ = ulval;
			}
			free($1);
		}
		;

gids		: gid_item			{ $$ = $1; }
		| '{' gid_list '}'		{ $$ = $2; }
		;

gid_list	: gid_item			{ $$ = $1; }
		| gid_list comma gid_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

gid_item	: gid				{
			$$ = calloc(1, sizeof(struct node_gid));
			if ($$ == NULL)
				err(1, "gid_item: calloc");
			$$->gid[0] = $1;
			$$->gid[1] = $1;
			$$->op = PF_OP_EQ;
			$$->next = NULL;
			$$->tail = $$;
		}
		| unaryop gid			{
			if ($2 == GID_MAX && $1 != PF_OP_EQ && $1 != PF_OP_NE) {
				yyerror("group unknown requires operator = or "
				    "!=");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_gid));
			if ($$ == NULL)
				err(1, "gid_item: calloc");
			$$->gid[0] = $2;
			$$->gid[1] = $2;
			$$->op = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
		| gid PORTBINARY gid		{
			if ($1 == GID_MAX || $3 == GID_MAX) {
				yyerror("group unknown requires operator = or "
				    "!=");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_gid));
			if ($$ == NULL)
				err(1, "gid_item: calloc");
			$$->gid[0] = $1;
			$$->gid[1] = $3;
			$$->op = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

gid		: STRING			{
			u_long	ulval;

			if (atoul($1, &ulval) == -1) {
				if (!strcmp($1, "unknown"))
					$$ = GID_MAX;
				else {
					struct group	*grp;

					if ((grp = getgrnam($1)) == NULL) {
						yyerror("unknown group %s", $1);
						free($1);
						YYERROR;
					}
					$$ = grp->gr_gid;
				}
			} else {
				if (ulval >= GID_MAX) {
					yyerror("illegal gid value %lu", ulval);
					free($1);
					YYERROR;
				}
				$$ = ulval;
			}
			free($1);
		}
		;

flag		: STRING			{
			int	f;

			if ((f = parse_flags($1)) < 0) {
				yyerror("bad flags %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
			$$.b1 = f;
		}
		;

flags		: FLAGS flag '/' flag	{ $$.b1 = $2.b1; $$.b2 = $4.b1; }
		| FLAGS '/' flag	{ $$.b1 = 0; $$.b2 = $3.b1; }
		;

icmpspec	: ICMPTYPE icmp_item		{ $$ = $2; }
		| ICMPTYPE '{' icmp_list '}'	{ $$ = $3; }
		| ICMP6TYPE icmp6_item		{ $$ = $2; }
		| ICMP6TYPE '{' icmp6_list '}'	{ $$ = $3; }
		;

icmp_list	: icmp_item			{ $$ = $1; }
		| icmp_list comma icmp_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

icmp6_list	: icmp6_item			{ $$ = $1; }
		| icmp6_list comma icmp6_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

icmp_item	: icmptype		{
			$$ = calloc(1, sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: calloc");
			$$->type = $1;
			$$->code = 0;
			$$->proto = IPPROTO_ICMP;
			$$->next = NULL;
			$$->tail = $$;
		}
		| icmptype CODE STRING	{
			const struct icmpcodeent	*p;
			u_long				 ulval;

			if (atoul($3, &ulval) == 0) {
				if (ulval > 255) {
					free($3);
					yyerror("illegal icmp-code %d", ulval);
					YYERROR;
				}
			} else {
				if ((p = geticmpcodebyname($1-1, $3,
				    AF_INET)) == NULL) {
					yyerror("unknown icmp-code %s", $3);
					free($3);
					YYERROR;
				}
				ulval = p->code;
			}
			free($3);
			$$ = calloc(1, sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: calloc");
			$$->type = $1;
			$$->code = ulval + 1;
			$$->proto = IPPROTO_ICMP;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

icmp6_item	: icmp6type		{
			$$ = calloc(1, sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: calloc");
			$$->type = $1;
			$$->code = 0;
			$$->proto = IPPROTO_ICMPV6;
			$$->next = NULL;
			$$->tail = $$;
		}
		| icmp6type CODE STRING	{
			const struct icmpcodeent	*p;
			u_long				 ulval;

			if (atoul($3, &ulval) == 0) {
				if (ulval > 255) {
					yyerror("illegal icmp6-code %ld",
					    ulval);
					free($3);
					YYERROR;
				}
			} else {
				if ((p = geticmpcodebyname($1-1, $3,
				    AF_INET6)) == NULL) {
					yyerror("unknown icmp6-code %s", $3);
					free($3);
					YYERROR;
				}
				ulval = p->code;
			}
			free($3);
			$$ = calloc(1, sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: calloc");
			$$->type = $1;
			$$->code = ulval + 1;
			$$->proto = IPPROTO_ICMPV6;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

icmptype	: STRING			{
			const struct icmptypeent	*p;
			u_long				 ulval;

			if (atoul($1, &ulval) == 0) {
				if (ulval > 255) {
					yyerror("illegal icmp-type %d", ulval);
					free($1);
					YYERROR;
				}
				$$ = ulval + 1;
			} else {
				if ((p = geticmptypebyname($1, AF_INET)) ==
				    NULL) {
					yyerror("unknown icmp-type %s", $1);
					free($1);
					YYERROR;
				}
				$$ = p->type + 1;
			}
			free($1);
		}
		;

icmp6type	: STRING			{
			const struct icmptypeent	*p;
			u_long				 ulval;

			if (atoul($1, &ulval) == 0) {
				if (ulval > 255) {
					yyerror("illegal icmp6-type %d", ulval);
					free($1);
					YYERROR;
				}
				$$ = ulval + 1;
			} else {
				if ((p = geticmptypebyname($1, AF_INET6)) ==
				    NULL) {
					yyerror("unknown icmp6-type %s", $1);
					free($1);
					YYERROR;
				}
				$$ = p->type + 1;
			}
			free($1);
		}
		;

tos		: TOS STRING			{
			if (!strcmp($2, "lowdelay"))
				$$ = IPTOS_LOWDELAY;
			else if (!strcmp($2, "throughput"))
				$$ = IPTOS_THROUGHPUT;
			else if (!strcmp($2, "reliability"))
				$$ = IPTOS_RELIABILITY;
			else if ($2[0] == '0' && $2[1] == 'x')
				$$ = strtoul($2, NULL, 16);
			else
				$$ = strtoul($2, NULL, 10);
			if (!$$ || $$ > 255) {
				yyerror("illegal tos value %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		;

sourcetrack	: SOURCETRACK		{ $$ = PF_SRCTRACK; }
		| SOURCETRACK GLOBAL	{ $$ = PF_SRCTRACK_GLOBAL; }
		| SOURCETRACK RULE	{ $$ = PF_SRCTRACK_RULE; }
		;

statelock	: IFBOUND {
			$$ = PFRULE_IFBOUND;
		}
		| GRBOUND {
			$$ = PFRULE_GRBOUND;
		}
		| FLOATING {
			$$ = 0;
		}
		;

keep		: KEEP STATE state_opt_spec	{
			$$.action = PF_STATE_NORMAL;
			$$.options = $3;
		}
		| MODULATE STATE state_opt_spec {
			$$.action = PF_STATE_MODULATE;
			$$.options = $3;
		}
		| SYNPROXY STATE state_opt_spec {
			$$.action = PF_STATE_SYNPROXY;
			$$.options = $3;
		}
		;

state_opt_spec	: '(' state_opt_list ')'	{ $$ = $2; }
		| /* empty */			{ $$ = NULL; }
		;

state_opt_list	: state_opt_item		{ $$ = $1; }
		| state_opt_list comma state_opt_item {
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

state_opt_item	: MAXIMUM number		{
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX;
			$$->data.max_states = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		| NOSYNC				{
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_NOSYNC;
			$$->next = NULL;
			$$->tail = $$;
		}
		| MAXSRCSTATES number			{
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX_SRC_STATES;
			$$->data.max_src_states = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		| MAXSRCNODES number			{
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX_SRC_NODES;
			$$->data.max_src_nodes = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		| sourcetrack {
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_SRCTRACK;
			$$->data.src_track = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
		| statelock {
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_STATELOCK;
			$$->data.statelock = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
		| STRING number			{
			int	i;

			for (i = 0; pf_timeouts[i].name &&
			    strcmp(pf_timeouts[i].name, $1); ++i)
				;	/* nothing */
			if (!pf_timeouts[i].name) {
				yyerror("illegal timeout name %s", $1);
				free($1);
				YYERROR;
			}
			if (strchr(pf_timeouts[i].name, '.') == NULL) {
				yyerror("illegal state timeout %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_TIMEOUT;
			$$->data.timeout.number = pf_timeouts[i].timeout;
			$$->data.timeout.seconds = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

label		: LABEL STRING			{
			$$ = $2;
		}
		;

qname		: QUEUE STRING				{
			$$.qname = $2;
		}
		| QUEUE '(' STRING ')'			{
			$$.qname = $3;
		}
		| QUEUE '(' STRING comma STRING ')'	{
			$$.qname = $3;
			$$.pqname = $5;
		}
		;

no		: /* empty */			{ $$ = 0; }
		| NO				{ $$ = 1; }
		;

rport		: STRING			{
			char	*p = strchr($1, ':');

			if (p == NULL) {
				if (($$.a = getservice($1)) == -1) {
					free($1);
					YYERROR;
				}
				$$.b = $$.t = 0;
			} else if (!strcmp(p+1, "*")) {
				*p = 0;
				if (($$.a = getservice($1)) == -1) {
					free($1);
					YYERROR;
				}
				$$.b = 0;
				$$.t = 1;
			} else {
				*p++ = 0;
				if (($$.a = getservice($1)) == -1 ||
				    ($$.b = getservice(p)) == -1) {
					free($1);
					YYERROR;
				}
				if ($$.a == $$.b)
					$$.b = 0;
				$$.t = 0;
			}
			free($1);
		}
		;

redirspec	: host				{ $$ = $1; }
		| '{' redir_host_list '}'	{ $$ = $2; }
		;

redir_host_list	: host				{ $$ = $1; }
		| redir_host_list comma host	{
			$1->tail->next = $3;
			$1->tail = $3->tail;
			$$ = $1;
		}
		;

redirpool	: /* empty */			{ $$ = NULL; }
		| ARROW redirspec		{
			$$ = calloc(1, sizeof(struct redirection));
			if ($$ == NULL)
				err(1, "redirection: calloc");
			$$->host = $2;
			$$->rport.a = $$->rport.b = $$->rport.t = 0;
		}
		| ARROW redirspec PORT rport	{
			$$ = calloc(1, sizeof(struct redirection));
			if ($$ == NULL)
				err(1, "redirection: calloc");
			$$->host = $2;
			$$->rport = $4;
		}
		;

hashkey		: /* empty */
		{
			$$ = calloc(1, sizeof(struct pf_poolhashkey));
			if ($$ == NULL)
				err(1, "hashkey: calloc");
			$$->key32[0] = arc4random();
			$$->key32[1] = arc4random();
			$$->key32[2] = arc4random();
			$$->key32[3] = arc4random();
		}
		| string
		{
			if (!strncmp($1, "0x", 2)) {
				if (strlen($1) != 34) {
					free($1);
					yyerror("hex key must be 128 bits "
						"(32 hex digits) long");
					YYERROR;
				}
				$$ = calloc(1, sizeof(struct pf_poolhashkey));
				if ($$ == NULL)
					err(1, "hashkey: calloc");

				if (sscanf($1, "0x%8x%8x%8x%8x",
				    &$$->key32[0], &$$->key32[1],
				    &$$->key32[2], &$$->key32[3]) != 4) {
					free($$);
					free($1);
					yyerror("invalid hex key");
					YYERROR;
				}
			} else {
				MD5_CTX	context;

				$$ = calloc(1, sizeof(struct pf_poolhashkey));
				if ($$ == NULL)
					err(1, "hashkey: calloc");
				MD5Init(&context);
				MD5Update(&context, (unsigned char *)$1,
				    strlen($1));
				MD5Final((unsigned char *)$$, &context);
				HTONL($$->key32[0]);
				HTONL($$->key32[1]);
				HTONL($$->key32[2]);
				HTONL($$->key32[3]);
			}
			free($1);
		}
		;

pool_opts	:	{ bzero(&pool_opts, sizeof pool_opts); }
		    pool_opts_l
			{ $$ = pool_opts; }
		| /* empty */	{
			bzero(&pool_opts, sizeof pool_opts);
			$$ = pool_opts;
		}
		;

pool_opts_l	: pool_opts_l pool_opt
		| pool_opt
		;

pool_opt	: BITMASK	{
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type =  PF_POOL_BITMASK;
		}
		| RANDOM	{
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type = PF_POOL_RANDOM;
		}
		| SOURCEHASH hashkey {
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type = PF_POOL_SRCHASH;
			pool_opts.key = $2;
		}
		| ROUNDROBIN	{
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type = PF_POOL_ROUNDROBIN;
		}
		| STATICPORT	{
			if (pool_opts.staticport) {
				yyerror("static-port cannot be redefined");
				YYERROR;
			}
			pool_opts.staticport = 1;
		}
		| STICKYADDRESS	{
			if (filter_opts.marker & POM_STICKYADDRESS) {
				yyerror("sticky-address cannot be redefined");
				YYERROR;
			}
			pool_opts.marker |= POM_STICKYADDRESS;
			pool_opts.opts |= PF_POOL_STICKYADDR;
		}
		;

redirection	: /* empty */			{ $$ = NULL; }
		| ARROW host			{
			$$ = calloc(1, sizeof(struct redirection));
			if ($$ == NULL)
				err(1, "redirection: calloc");
			$$->host = $2;
			$$->rport.a = $$->rport.b = $$->rport.t = 0;
		}
		| ARROW host PORT rport	{
			$$ = calloc(1, sizeof(struct redirection));
			if ($$ == NULL)
				err(1, "redirection: calloc");
			$$->host = $2;
			$$->rport = $4;
		}
		;

natpass		: /* empty */	{ $$ = 0; }
		| PASS		{ $$ = 1; }
		;

nataction	: no NAT natpass {
			$$.b2 = $$.w = 0;
			if ($1)
				$$.b1 = PF_NONAT;
			else
				$$.b1 = PF_NAT;
			$$.b2 = $3;
		}
		| no RDR natpass {
			$$.b2 = $$.w = 0;
			if ($1)
				$$.b1 = PF_NORDR;
			else
				$$.b1 = PF_RDR;
			$$.b2 = $3;
		}
		;

natrule		: nataction interface af proto fromto tag redirpool pool_opts
		{
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_NAT))
				YYERROR;

			memset(&r, 0, sizeof(r));

			r.action = $1.b1;
			r.natpass = $1.b2;
			r.af = $3;

			if (!r.af) {
				if ($5.src.host && $5.src.host->af &&
				    !$5.src.host->ifindex)
					r.af = $5.src.host->af;
				else if ($5.dst.host && $5.dst.host->af &&
				    !$5.dst.host->ifindex)
					r.af = $5.dst.host->af;
			}

			if ($6 != NULL)
				if (strlcpy(r.tagname, $6, PF_TAG_NAME_SIZE) >=
				    PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}

			if (r.action == PF_NONAT || r.action == PF_NORDR) {
				if ($7 != NULL) {
					yyerror("translation rule with 'no' "
					    "does not need '->'");
					YYERROR;
				}
			} else {
				if ($7 == NULL || $7->host == NULL) {
					yyerror("translation rule requires '-> "
					    "address'");
					YYERROR;
				}
				if (!r.af && ! $7->host->ifindex)
					r.af = $7->host->af;

				remove_invalid_hosts(&$7->host, &r.af);
				if (invalid_redirect($7->host, r.af))
					YYERROR;
				if (check_netmask($7->host, r.af))
					YYERROR;

				r.rpool.proxy_port[0] = ntohs($7->rport.a);

				switch (r.action) {
				case PF_RDR:
					if (!$7->rport.b && $7->rport.t &&
					    $5.dst.port != NULL) {
						r.rpool.proxy_port[1] =
						    ntohs($7->rport.a) +
						    (ntohs(
						    $5.dst.port->port[1]) -
						    ntohs(
						    $5.dst.port->port[0]));
					} else
						r.rpool.proxy_port[1] =
						    ntohs($7->rport.b);
					break;
				case PF_NAT:
					r.rpool.proxy_port[1] =
					    ntohs($7->rport.b);
					if (!r.rpool.proxy_port[0] &&
					    !r.rpool.proxy_port[1]) {
						r.rpool.proxy_port[0] =
						    PF_NAT_PROXY_PORT_LOW;
						r.rpool.proxy_port[1] =
						    PF_NAT_PROXY_PORT_HIGH;
					} else if (!r.rpool.proxy_port[1])
						r.rpool.proxy_port[1] =
						    r.rpool.proxy_port[0];
					break;
				default:
					break;
				}

				r.rpool.opts = $8.type;
				if ((r.rpool.opts & PF_POOL_TYPEMASK) ==
				    PF_POOL_NONE && ($7->host->next != NULL ||
				    $7->host->addr.type == PF_ADDR_TABLE))
					r.rpool.opts = PF_POOL_ROUNDROBIN;
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
				    disallow_table($7->host, "tables are only "
				    "supported in round-robin redirection "
				    "pools"))
					YYERROR;
				if ($7->host->next != NULL) {
					if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
					    PF_POOL_ROUNDROBIN) {
						yyerror("only round-robin "
						    "valid for multiple "
						    "redirection addresses");
						YYERROR;
					}
				}
			}

			if ($8.key != NULL)
				memcpy(&r.rpool.key, $8.key,
				    sizeof(struct pf_poolhashkey));

			 if ($8.opts)
				r.rpool.opts |= $8.opts;

			if ($8.staticport) {
				if (r.action != PF_NAT) {
					yyerror("the 'static-port' option is "
					    "only valid with nat rules");
					YYERROR;
				}
				if (r.rpool.proxy_port[0] !=
				    PF_NAT_PROXY_PORT_LOW &&
				    r.rpool.proxy_port[1] !=
				    PF_NAT_PROXY_PORT_HIGH) {
					yyerror("the 'static-port' option can't"
					    " be used when specifying a port"
					    " range");
					YYERROR;
				}
				r.rpool.proxy_port[0] = 0;
				r.rpool.proxy_port[1] = 0;
			}

			expand_rule(&r, $2, $7 == NULL ? NULL : $7->host, $4,
			    $5.src_os, $5.src.host, $5.src.port, $5.dst.host,
			    $5.dst.port, 0, 0, 0);
			free($7);
		}
		;

binatrule	: no BINAT natpass interface af proto FROM host TO ipspec tag
		    redirection
		{
			struct pf_rule		binat;
			struct pf_pooladdr	*pa;

			if (check_rulestate(PFCTL_STATE_NAT))
				YYERROR;

			memset(&binat, 0, sizeof(binat));

			if ($1)
				binat.action = PF_NOBINAT;
			else
				binat.action = PF_BINAT;
			binat.natpass = $3;
			binat.af = $5;
			if (!binat.af && $8 != NULL && $8->af)
				binat.af = $8->af;
			if (!binat.af && $10 != NULL && $10->af)
				binat.af = $10->af;
			if (!binat.af && $12 != NULL && $12->host)
				binat.af = $12->host->af;
			if (!binat.af) {
				yyerror("address family (inet/inet6) "
				    "undefined");
				YYERROR;
			}

			if ($4 != NULL) {
				memcpy(binat.ifname, $4->ifname,
				    sizeof(binat.ifname));
				binat.ifnot = $4->not;
				free($4);
			}
			if ($11 != NULL)
				if (strlcpy(binat.tagname, $11,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}

			if ($6 != NULL) {
				binat.proto = $6->proto;
				free($6);
			}

			if ($8 != NULL && disallow_table($8, "invalid use of "
			    "table <%s> as the source address of a binat rule"))
				YYERROR;
			if ($12 != NULL && $12->host != NULL && disallow_table(
			    $12->host, "invalid use of table <%s> as the "
			    "redirect address of a binat rule"))
				YYERROR;

			if ($8 != NULL) {
				if ($8->next) {
					yyerror("multiple binat ip addresses");
					YYERROR;
				}
				if ($8->af != binat.af) {
					yyerror("binat ip versions must match");
					YYERROR;
				}
				if (check_netmask($8, binat.af))
					YYERROR;
				memcpy(&binat.src.addr, &$8->addr,
				    sizeof(binat.src.addr));
				free($8);
			}
			if ($10 != NULL) {
				if ($10->next) {
					yyerror("multiple binat ip addresses");
					YYERROR;
				}
				if ($10->af != binat.af && $10->af) {
					yyerror("binat ip versions must match");
					YYERROR;
				}
				if (check_netmask($10, binat.af))
					YYERROR;
				memcpy(&binat.dst.addr, &$10->addr,
				    sizeof(binat.dst.addr));
				binat.dst.not = $10->not;
				free($10);
			}

			if (binat.action == PF_NOBINAT) {
				if ($12 != NULL) {
					yyerror("'no binat' rule does not need"
					    " '->'");
					YYERROR;
				}
			} else {
				if ($12 == NULL || $12->host == NULL) {
					yyerror("'binat' rule requires"
					    " '-> address'");
					YYERROR;
				}

				remove_invalid_hosts(&$12->host, &binat.af);
				if (invalid_redirect($12->host, binat.af))
					YYERROR;
				if ($12->host->next != NULL) {
					yyerror("binat rule must redirect to "
					    "a single address");
					YYERROR;
				}
				if (check_netmask($12->host, binat.af))
					YYERROR;

				if (!PF_AZERO(&binat.src.addr.v.a.mask,
				    binat.af) &&
				    !PF_AEQ(&binat.src.addr.v.a.mask,
				    &$12->host->addr.v.a.mask, binat.af)) {
					yyerror("'binat' source mask and "
					    "redirect mask must be the same");
					YYERROR;
				}

				TAILQ_INIT(&binat.rpool.list);
				pa = calloc(1, sizeof(struct pf_pooladdr));
				if (pa == NULL)
					err(1, "binat: calloc");
				pa->addr = $12->host->addr;
				pa->ifname[0] = 0;
				TAILQ_INSERT_TAIL(&binat.rpool.list,
				    pa, entries);

				free($12);
			}

			pfctl_add_rule(pf, &binat);
		}
		;

tag		: /* empty */		{ $$ = NULL; }
		| TAG STRING		{ $$ = $2; }
		;

route_host	: STRING			{
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "route_host: calloc");
			$$->ifname = $1;
			if (ifa_exists($$->ifname, 0) == NULL) {
				yyerror("routeto: unknown interface %s",
				    $$->ifname);
				free($1);
				free($$);
				YYERROR;
			}
			set_ipmask($$, 128);
			$$->next = NULL;
			$$->tail = $$;
		}
		| '(' STRING host ')'		{
			$$ = $3;
			$$->ifname = $2;
			if (ifa_exists($$->ifname, 0) == NULL) {
				yyerror("routeto: unknown interface %s",
				    $$->ifname);
				YYERROR;
			}
		}
		;

route_host_list	: route_host				{ $$ = $1; }
		| route_host_list comma route_host	{
			if ($1->af == 0)
				$1->af = $3->af;
			if ($1->af != $3->af) {
				yyerror("all pool addresses must be in the "
				    "same address family");
				YYERROR;
			}
			$1->tail->next = $3;
			$1->tail = $3->tail;
			$$ = $1;
		}
		;

routespec	: route_host			{ $$ = $1; }
		| '{' route_host_list '}'	{ $$ = $2; }
		;

route		: /* empty */			{
			$$.host = NULL;
			$$.rt = 0;
			$$.pool_opts = 0;
		}
		| FASTROUTE {
			$$.host = NULL;
			$$.rt = PF_FASTROUTE;
			$$.pool_opts = 0;
		}
		| ROUTETO routespec pool_opts {
			$$.host = $2;
			$$.rt = PF_ROUTETO;
			$$.pool_opts = $3.type | $3.opts;
			if ($3.key != NULL)
				$$.key = $3.key;
		}
		| REPLYTO routespec pool_opts {
			$$.host = $2;
			$$.rt = PF_REPLYTO;
			$$.pool_opts = $3.type | $3.opts;
			if ($3.key != NULL)
				$$.key = $3.key;
		}
		| DUPTO routespec pool_opts {
			$$.host = $2;
			$$.rt = PF_DUPTO;
			$$.pool_opts = $3.type | $3.opts;
			if ($3.key != NULL)
				$$.key = $3.key;
		}
		;

timeout_spec	: STRING number
		{
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($1);
				YYERROR;
			}
			if (pfctl_set_timeout(pf, $1, $2, 0) != 0) {
				yyerror("unknown timeout %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

timeout_list	: timeout_list comma timeout_spec
		| timeout_spec
		;

limit_spec	: STRING number
		{
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($1);
				YYERROR;
			}
			if (pfctl_set_limit(pf, $1, $2) != 0) {
				yyerror("unable to set limit %s %u", $1, $2);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

limit_list	: limit_list comma limit_spec
		| limit_spec
		;

comma		: ','
		| /* empty */
		;

yesno		: NO			{ $$ = 0; }
		| STRING		{
			if (!strcmp($1, "yes"))
				$$ = 1;
			else {
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

unaryop		: '='		{ $$ = PF_OP_EQ; }
		| '!' '='	{ $$ = PF_OP_NE; }
		| '<' '='	{ $$ = PF_OP_LE; }
		| '<'		{ $$ = PF_OP_LT; }
		| '>' '='	{ $$ = PF_OP_GE; }
		| '>'		{ $$ = PF_OP_GT; }
		;

%%

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	extern char	*infile;

	errors = 1;
	va_start(ap, fmt);
	fprintf(stderr, "%s:%d: ", infile, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
	va_end(ap);
	return (0);
}

int
disallow_table(struct node_host *h, const char *fmt)
{
	for (; h != NULL; h = h->next)
		if (h->addr.type == PF_ADDR_TABLE) {
			yyerror(fmt, h->addr.v.tblname);
			return (1);
		}
	return (0);
}

int
rule_consistent(struct pf_rule *r)
{
	int	problems = 0;

	switch (r->action) {
	case PF_PASS:
	case PF_DROP:
	case PF_SCRUB:
		problems = filter_consistent(r);
		break;
	case PF_NAT:
	case PF_NONAT:
		problems = nat_consistent(r);
		break;
	case PF_RDR:
	case PF_NORDR:
		problems = rdr_consistent(r);
		break;
	case PF_BINAT:
	case PF_NOBINAT:
	default:
		break;
	}
	return (problems);
}

int
filter_consistent(struct pf_rule *r)
{
	int	problems = 0;

	if (r->proto != IPPROTO_TCP && r->proto != IPPROTO_UDP &&
	    (r->src.port_op || r->dst.port_op)) {
		yyerror("port only applies to tcp/udp");
		problems++;
	}
	if (r->proto != IPPROTO_ICMP && r->proto != IPPROTO_ICMPV6 &&
	    (r->type || r->code)) {
		yyerror("icmp-type/code only applies to icmp");
		problems++;
	}
	if (!r->af && (r->type || r->code)) {
		yyerror("must indicate address family with icmp-type/code");
		problems++;
	}
	if ((r->proto == IPPROTO_ICMP && r->af == AF_INET6) ||
	    (r->proto == IPPROTO_ICMPV6 && r->af == AF_INET)) {
		yyerror("proto %s doesn't match address family %s",
		    r->proto == IPPROTO_ICMP ? "icmp" : "icmp6",
		    r->af == AF_INET ? "inet" : "inet6");
		problems++;
	}
	if (r->allow_opts && r->action != PF_PASS) {
		yyerror("allow-opts can only be specified for pass rules");
		problems++;
	}
	if (r->rule_flag & PFRULE_FRAGMENT && (r->src.port_op ||
	    r->dst.port_op || r->flagset || r->type || r->code)) {
		yyerror("fragments can be filtered only on IP header fields");
		problems++;
	}
	if (r->rule_flag & PFRULE_RETURNRST && r->proto != IPPROTO_TCP) {
		yyerror("return-rst can only be applied to TCP rules");
		problems++;
	}
	if (r->max_src_nodes && !(r->rule_flag & PFRULE_RULESRCTRACK)) {
		yyerror("max-src-nodes requires 'source-track rule'");
		problems++;
	}
	if (r->action == PF_DROP && r->keep_state) {
		yyerror("keep state on block rules doesn't make sense");
		problems++;
	}
	if ((r->tagname[0] || r->match_tagname[0]) && !r->keep_state &&
	    r->action == PF_PASS && !r->anchorname[0]) {
		yyerror("tags cannot be used without keep state");
		problems++;
	}
	return (-problems);
}

int
nat_consistent(struct pf_rule *r)
{
	return (0);	/* yeah! */
}

int
rdr_consistent(struct pf_rule *r)
{
	int			 problems = 0;

	if (r->proto != IPPROTO_TCP && r->proto != IPPROTO_UDP) {
		if (r->src.port_op) {
			yyerror("src port only applies to tcp/udp");
			problems++;
		}
		if (r->dst.port_op) {
			yyerror("dst port only applies to tcp/udp");
			problems++;
		}
		if (r->rpool.proxy_port[0]) {
			yyerror("rpool port only applies to tcp/udp");
			problems++;
		}
	}
	if (r->dst.port_op &&
	    r->dst.port_op != PF_OP_EQ && r->dst.port_op != PF_OP_RRG) {
		yyerror("invalid port operator for rdr destination port");
		problems++;
	}
	return (-problems);
}

int
process_tabledef(char *name, struct table_opts *opts)
{
	struct pfr_buffer	 ab;
	struct node_tinit	*ti;

	bzero(&ab, sizeof(ab));
	ab.pfrb_type = PFRB_ADDRS;
	SIMPLEQ_FOREACH(ti, &opts->init_nodes, entries) {
		if (ti->file)
			if (pfr_buf_load(&ab, ti->file, 0, append_addr)) {
				if (errno)
					yyerror("cannot load \"%s\": %s",
					    ti->file, strerror(errno));
				else
					yyerror("file \"%s\" contains bad data",
					    ti->file);
				goto _error;
			}
		if (ti->host)
			if (append_addr_host(&ab, ti->host, 0, 0)) {
				yyerror("cannot create address buffer: %s",
				    strerror(errno));
				goto _error;
			}
	}
	if (pf->opts & PF_OPT_VERBOSE)
		print_tabledef(name, opts->flags, opts->init_addr,
		    &opts->init_nodes);
	if (!(pf->opts & PF_OPT_NOACTION) &&
	    pfctl_define_table(name, opts->flags, opts->init_addr,
	    pf->anchor, pf->ruleset, &ab, pf->tticket)) {
		yyerror("cannot define table %s: %s", name,
		    pfr_strerror(errno));
		goto _error;
	}
	pf->tdirty = 1;
	pfr_buf_clear(&ab);
	return (0);
_error:
	pfr_buf_clear(&ab);
	return (-1);
}

struct keywords {
	const char	*k_name;
	int		 k_val;
};

/* macro gore, but you should've seen the prior indentation nightmare... */

#define FREE_LIST(T,r) \
	do { \
		T *p, *node = r; \
		while (node != NULL) { \
			p = node; \
			node = node->next; \
			free(p); \
		} \
	} while (0)

#define LOOP_THROUGH(T,n,r,C) \
	do { \
		T *n; \
		if (r == NULL) { \
			r = calloc(1, sizeof(T)); \
			if (r == NULL) \
				err(1, "LOOP: calloc"); \
			r->next = NULL; \
		} \
		n = r; \
		while (n != NULL) { \
			do { \
				C; \
			} while (0); \
			n = n->next; \
		} \
	} while (0)

void
expand_label_str(char *label, size_t len, const char *srch, const char *repl)
{
	char *tmp;
	char *p, *q;

	if ((tmp = calloc(1, len)) == NULL)
		err(1, "expand_label_str: calloc");
	p = q = label;
	while ((q = strstr(p, srch)) != NULL) {
		*q = '\0';
		if ((strlcat(tmp, p, len) >= len) ||
		    (strlcat(tmp, repl, len) >= len))
			errx(1, "expand_label: label too long");
		q += strlen(srch);
		p = q;
	}
	if (strlcat(tmp, p, len) >= len)
		errx(1, "expand_label: label too long");
	strlcpy(label, tmp, len);	/* always fits */
	free(tmp);
}

void
expand_label_if(const char *name, char *label, size_t len, const char *ifname)
{
	if (strstr(label, name) != NULL) {
		if (!*ifname)
			expand_label_str(label, len, name, "any");
		else
			expand_label_str(label, len, name, ifname);
	}
}

void
expand_label_addr(const char *name, char *label, size_t len, sa_family_t af,
    struct node_host *h)
{
	char tmp[64], tmp_not[66];

	if (strstr(label, name) != NULL) {
		switch (h->addr.type) {
		case PF_ADDR_TABLE:
			snprintf(tmp, sizeof(tmp), "<%s>", h->addr.v.tblname);
			break;
		case PF_ADDR_NOROUTE:
			snprintf(tmp, sizeof(tmp), "no-route");
			break;
		case PF_ADDR_ADDRMASK:
			if (!af || (PF_AZERO(&h->addr.v.a.addr, af) &&
			    PF_AZERO(&h->addr.v.a.mask, af)))
				snprintf(tmp, sizeof(tmp), "any");
			else {
				char	a[48];
				int	bits;

				if (inet_ntop(af, &h->addr.v.a.addr, a,
				    sizeof(a)) == NULL)
					snprintf(tmp, sizeof(tmp), "?");
				else {
					bits = unmask(&h->addr.v.a.mask, af);
					if ((af == AF_INET && bits < 32) ||
					    (af == AF_INET6 && bits < 128))
						snprintf(tmp, sizeof(tmp),
						    "%s/%d", a, bits);
					else
						snprintf(tmp, sizeof(tmp),
						    "%s", a);
				}
			}
			break;
		default:
			snprintf(tmp, sizeof(tmp), "?");
			break;
		}

		if (h->not) {
			snprintf(tmp_not, sizeof(tmp_not), "! %s", tmp);
			expand_label_str(label, len, name, tmp_not);
		} else
			expand_label_str(label, len, name, tmp);
	}
}

void
expand_label_port(const char *name, char *label, size_t len,
    struct node_port *port)
{
	char	 a1[6], a2[6], op[13] = "";

	if (strstr(label, name) != NULL) {
		snprintf(a1, sizeof(a1), "%u", ntohs(port->port[0]));
		snprintf(a2, sizeof(a2), "%u", ntohs(port->port[1]));
		if (!port->op)
			;
		else if (port->op == PF_OP_IRG)
			snprintf(op, sizeof(op), "%s><%s", a1, a2);
		else if (port->op == PF_OP_XRG)
			snprintf(op, sizeof(op), "%s<>%s", a1, a2);
		else if (port->op == PF_OP_EQ)
			snprintf(op, sizeof(op), "%s", a1);
		else if (port->op == PF_OP_NE)
			snprintf(op, sizeof(op), "!=%s", a1);
		else if (port->op == PF_OP_LT)
			snprintf(op, sizeof(op), "<%s", a1);
		else if (port->op == PF_OP_LE)
			snprintf(op, sizeof(op), "<=%s", a1);
		else if (port->op == PF_OP_GT)
			snprintf(op, sizeof(op), ">%s", a1);
		else if (port->op == PF_OP_GE)
			snprintf(op, sizeof(op), ">=%s", a1);
		expand_label_str(label, len, name, op);
	}
}

void
expand_label_proto(const char *name, char *label, size_t len, u_int8_t proto)
{
	struct protoent *pe;
	char n[4];

	if (strstr(label, name) != NULL) {
		pe = getprotobynumber(proto);
		if (pe != NULL)
			expand_label_str(label, len, name, pe->p_name);
		else {
			snprintf(n, sizeof(n), "%u", proto);
			expand_label_str(label, len, name, n);
		}
	}
}

void
expand_label_nr(const char *name, char *label, size_t len)
{
	char n[11];

	if (strstr(label, name) != NULL) {
		snprintf(n, sizeof(n), "%u", pf->rule_nr);
		expand_label_str(label, len, name, n);
	}
}

void
expand_label(char *label, size_t len, const char *ifname, sa_family_t af,
    struct node_host *src_host, struct node_port *src_port,
    struct node_host *dst_host, struct node_port *dst_port,
    u_int8_t proto)
{
	expand_label_if("$if", label, len, ifname);
	expand_label_addr("$srcaddr", label, len, af, src_host);
	expand_label_addr("$dstaddr", label, len, af, dst_host);
	expand_label_port("$srcport", label, len, src_port);
	expand_label_port("$dstport", label, len, dst_port);
	expand_label_proto("$proto", label, len, proto);
	expand_label_nr("$nr", label, len);
}

int
expand_altq(struct pf_altq *a, struct node_if *interfaces,
    struct node_queue *nqueues, struct node_queue_bw bwspec,
    struct node_queue_opt *opts)
{
	struct pf_altq		 pa, pb;
	char			 qname[PF_QNAME_SIZE];
	struct node_queue	*n;
	struct node_queue_bw	 bw;
	int			 errs = 0;

	if ((pf->loadopt & PFCTL_FLAG_ALTQ) == 0) {
		FREE_LIST(struct node_if, interfaces);
		FREE_LIST(struct node_queue, nqueues);
		return (0);
	}

	LOOP_THROUGH(struct node_if, interface, interfaces,
		memcpy(&pa, a, sizeof(struct pf_altq));
		if (strlcpy(pa.ifname, interface->ifname,
		    sizeof(pa.ifname)) >= sizeof(pa.ifname))
			errx(1, "expand_altq: strlcpy");

		if (interface->not) {
			yyerror("altq on ! <interface> is not supported");
			errs++;
		} else {
			if (eval_pfaltq(pf, &pa, &bwspec, opts))
				errs++;
			else
				if (pfctl_add_altq(pf, &pa))
					errs++;

			if (pf->opts & PF_OPT_VERBOSE) {
				print_altq(&pf->paltq->altq, 0,
				    &bwspec, opts);
				if (nqueues && nqueues->tail) {
					printf("queue { ");
					LOOP_THROUGH(struct node_queue, queue,
					    nqueues,
						printf("%s ",
						    queue->queue);
					);
					printf("}");
				}
				printf("\n");
			}

			if (pa.scheduler == ALTQT_CBQ ||
			    pa.scheduler == ALTQT_HFSC) {
				/* now create a root queue */
				memset(&pb, 0, sizeof(struct pf_altq));
				if (strlcpy(qname, "root_", sizeof(qname)) >=
				    sizeof(qname))
					errx(1, "expand_altq: strlcpy");
				if (strlcat(qname, interface->ifname,
				    sizeof(qname)) >= sizeof(qname))
					errx(1, "expand_altq: strlcat");
				if (strlcpy(pb.qname, qname,
				    sizeof(pb.qname)) >= sizeof(pb.qname))
					errx(1, "expand_altq: strlcpy");
				if (strlcpy(pb.ifname, interface->ifname,
				    sizeof(pb.ifname)) >= sizeof(pb.ifname))
					errx(1, "expand_altq: strlcpy");
				pb.qlimit = pa.qlimit;
				pb.scheduler = pa.scheduler;
				bw.bw_absolute = pa.ifbandwidth;
				bw.bw_percent = 0;
				if (eval_pfqueue(pf, &pb, &bw, opts))
					errs++;
				else
					if (pfctl_add_altq(pf, &pb))
						errs++;
			}

			LOOP_THROUGH(struct node_queue, queue, nqueues,
				n = calloc(1, sizeof(struct node_queue));
				if (n == NULL)
					err(1, "expand_altq: calloc");
				if (pa.scheduler == ALTQT_CBQ ||
				    pa.scheduler == ALTQT_HFSC)
					if (strlcpy(n->parent, qname,
					    sizeof(n->parent)) >=
					    sizeof(n->parent))
						errx(1, "expand_altq: strlcpy");
				if (strlcpy(n->queue, queue->queue,
				    sizeof(n->queue)) >= sizeof(n->queue))
					errx(1, "expand_altq: strlcpy");
				if (strlcpy(n->ifname, interface->ifname,
				    sizeof(n->ifname)) >= sizeof(n->ifname))
					errx(1, "expand_altq: strlcpy");
				n->scheduler = pa.scheduler;
				n->next = NULL;
				n->tail = n;
				if (queues == NULL)
					queues = n;
				else {
					queues->tail->next = n;
					queues->tail = n;
				}
			);
		}
	);
	FREE_LIST(struct node_if, interfaces);
	FREE_LIST(struct node_queue, nqueues);

	return (errs);
}

int
expand_queue(struct pf_altq *a, struct node_if *interfaces,
    struct node_queue *nqueues, struct node_queue_bw bwspec,
    struct node_queue_opt *opts)
{
	struct node_queue	*n, *nq;
	struct pf_altq		 pa;
	u_int8_t		 found = 0;
	u_int8_t		 errs = 0;

	if ((pf->loadopt & PFCTL_FLAG_ALTQ) == 0) {
		FREE_LIST(struct node_queue, nqueues);
		return (0);
	}

	if (queues == NULL) {
		yyerror("queue %s has no parent", a->qname);
		FREE_LIST(struct node_queue, nqueues);
		return (1);
	}

	LOOP_THROUGH(struct node_if, interface, interfaces,
		LOOP_THROUGH(struct node_queue, tqueue, queues,
			if (!strncmp(a->qname, tqueue->queue, PF_QNAME_SIZE) &&
			    (interface->ifname[0] == 0 ||
			    (!interface->not && !strncmp(interface->ifname,
			    tqueue->ifname, IFNAMSIZ)) ||
			    (interface->not && strncmp(interface->ifname,
			    tqueue->ifname, IFNAMSIZ)))) {
				/* found ourself in queues */
				found++;

				memcpy(&pa, a, sizeof(struct pf_altq));

				if (pa.scheduler != ALTQT_NONE &&
				    pa.scheduler != tqueue->scheduler) {
					yyerror("exactly one scheduler type "
					    "per interface allowed");
					return (1);
				}
				pa.scheduler = tqueue->scheduler;

				/* scheduler dependent error checking */
				switch (pa.scheduler) {
				case ALTQT_PRIQ:
					if (nqueues != NULL) {
						yyerror("priq queues cannot "
						    "have child queues");
						return (1);
					}
					if (bwspec.bw_absolute > 0 ||
					    bwspec.bw_percent < 100) {
						yyerror("priq doesn't take "
						    "bandwidth");
						return (1);
					}
					break;
				default:
					break;
				}

				if (strlcpy(pa.ifname, tqueue->ifname,
				    sizeof(pa.ifname)) >= sizeof(pa.ifname))
					errx(1, "expand_queue: strlcpy");
				if (strlcpy(pa.parent, tqueue->parent,
				    sizeof(pa.parent)) >= sizeof(pa.parent))
					errx(1, "expand_queue: strlcpy");

				if (eval_pfqueue(pf, &pa, &bwspec, opts))
					errs++;
				else
					if (pfctl_add_altq(pf, &pa))
						errs++;

				for (nq = nqueues; nq != NULL; nq = nq->next) {
					if (!strcmp(a->qname, nq->queue)) {
						yyerror("queue cannot have "
						    "itself as child");
						errs++;
						continue;
					}
					n = calloc(1,
					    sizeof(struct node_queue));
					if (n == NULL)
						err(1, "expand_queue: calloc");
					if (strlcpy(n->parent, a->qname,
					    sizeof(n->parent)) >=
					    sizeof(n->parent))
						errx(1, "expand_queue strlcpy");
					if (strlcpy(n->queue, nq->queue,
					    sizeof(n->queue)) >=
					    sizeof(n->queue))
						errx(1, "expand_queue strlcpy");
					if (strlcpy(n->ifname, tqueue->ifname,
					    sizeof(n->ifname)) >=
					    sizeof(n->ifname))
						errx(1, "expand_queue strlcpy");
					n->scheduler = tqueue->scheduler;
					n->next = NULL;
					n->tail = n;
					if (queues == NULL)
						queues = n;
					else {
						queues->tail->next = n;
						queues->tail = n;
					}
				}
				if ((pf->opts & PF_OPT_VERBOSE) && (
				    (found == 1 && interface->ifname[0] == 0) ||
				    (found > 0 && interface->ifname[0] != 0))) {
					print_queue(&pf->paltq->altq, 0,
					    &bwspec, interface->ifname[0] != 0,
					    opts);
					if (nqueues && nqueues->tail) {
						printf("{ ");
						LOOP_THROUGH(struct node_queue,
						    queue, nqueues,
							printf("%s ",
							    queue->queue);
						);
						printf("}");
					}
					printf("\n");
				}
			}
		);
	);

	FREE_LIST(struct node_queue, nqueues);
	FREE_LIST(struct node_if, interfaces);

	if (!found) {
		yyerror("queue %s has no parent", a->qname);
		errs++;
	}

	if (errs)
		return (1);
	else
		return (0);
}

void
expand_rule(struct pf_rule *r,
    struct node_if *interfaces, struct node_host *rpool_hosts,
    struct node_proto *protos, struct node_os *src_oses,
    struct node_host *src_hosts, struct node_port *src_ports,
    struct node_host *dst_hosts, struct node_port *dst_ports,
    struct node_uid *uids, struct node_gid *gids, struct node_icmp *icmp_types)
{
	sa_family_t		 af = r->af;
	int			 added = 0, error = 0;
	char			 ifname[IF_NAMESIZE];
	char			 label[PF_RULE_LABEL_SIZE];
	char			 tagname[PF_TAG_NAME_SIZE];
	char			 match_tagname[PF_TAG_NAME_SIZE];
	struct pf_pooladdr	*pa;
	struct node_host	*h;
	u_int8_t		 flags, flagset, keep_state;

	if (strlcpy(label, r->label, sizeof(label)) >= sizeof(label))
		errx(1, "expand_rule: strlcpy");
	if (strlcpy(tagname, r->tagname, sizeof(tagname)) >= sizeof(tagname))
		errx(1, "expand_rule: strlcpy");
	if (strlcpy(match_tagname, r->match_tagname, sizeof(match_tagname)) >=
	    sizeof(match_tagname))
		errx(1, "expand_rule: strlcpy");
	flags = r->flags;
	flagset = r->flagset;
	keep_state = r->keep_state;

	LOOP_THROUGH(struct node_if, interface, interfaces,
	LOOP_THROUGH(struct node_proto, proto, protos,
	LOOP_THROUGH(struct node_icmp, icmp_type, icmp_types,
	LOOP_THROUGH(struct node_host, src_host, src_hosts,
	LOOP_THROUGH(struct node_port, src_port, src_ports,
	LOOP_THROUGH(struct node_os, src_os, src_oses,
	LOOP_THROUGH(struct node_host, dst_host, dst_hosts,
	LOOP_THROUGH(struct node_port, dst_port, dst_ports,
	LOOP_THROUGH(struct node_uid, uid, uids,
	LOOP_THROUGH(struct node_gid, gid, gids,

		r->af = af;
		/* for link-local IPv6 address, interface must match up */
		if ((r->af && src_host->af && r->af != src_host->af) ||
		    (r->af && dst_host->af && r->af != dst_host->af) ||
		    (src_host->af && dst_host->af &&
		    src_host->af != dst_host->af) ||
		    (src_host->ifindex && dst_host->ifindex &&
		    src_host->ifindex != dst_host->ifindex) ||
		    (src_host->ifindex && *interface->ifname &&
		    src_host->ifindex != if_nametoindex(interface->ifname)) ||
		    (dst_host->ifindex && *interface->ifname &&
		    dst_host->ifindex != if_nametoindex(interface->ifname)))
			continue;
		if (!r->af && src_host->af)
			r->af = src_host->af;
		else if (!r->af && dst_host->af)
			r->af = dst_host->af;

		if (*interface->ifname)
			memcpy(r->ifname, interface->ifname, sizeof(r->ifname));
		else if (if_indextoname(src_host->ifindex, ifname))
			memcpy(r->ifname, ifname, sizeof(r->ifname));
		else if (if_indextoname(dst_host->ifindex, ifname))
			memcpy(r->ifname, ifname, sizeof(r->ifname));
		else
			memset(r->ifname, '\0', sizeof(r->ifname));

		if (strlcpy(r->label, label, sizeof(r->label)) >=
		    sizeof(r->label))
			errx(1, "expand_rule: strlcpy");
		if (strlcpy(r->tagname, tagname, sizeof(r->tagname)) >=
		    sizeof(r->tagname))
			errx(1, "expand_rule: strlcpy");
		if (strlcpy(r->match_tagname, match_tagname,
		    sizeof(r->match_tagname)) >= sizeof(r->match_tagname))
			errx(1, "expand_rule: strlcpy");
		expand_label(r->label, PF_RULE_LABEL_SIZE, r->ifname, r->af,
		    src_host, src_port, dst_host, dst_port, proto->proto);
		expand_label(r->tagname, PF_TAG_NAME_SIZE, r->ifname, r->af,
		    src_host, src_port, dst_host, dst_port, proto->proto);
		expand_label(r->match_tagname, PF_TAG_NAME_SIZE, r->ifname,
		    r->af, src_host, src_port, dst_host, dst_port,
		    proto->proto);

		error += check_netmask(src_host, r->af);
		error += check_netmask(dst_host, r->af);

		r->ifnot = interface->not;
		r->proto = proto->proto;
		r->src.addr = src_host->addr;
		r->src.not = src_host->not;
		r->src.port[0] = src_port->port[0];
		r->src.port[1] = src_port->port[1];
		r->src.port_op = src_port->op;
		r->dst.addr = dst_host->addr;
		r->dst.not = dst_host->not;
		r->dst.port[0] = dst_port->port[0];
		r->dst.port[1] = dst_port->port[1];
		r->dst.port_op = dst_port->op;
		r->uid.op = uid->op;
		r->uid.uid[0] = uid->uid[0];
		r->uid.uid[1] = uid->uid[1];
		r->gid.op = gid->op;
		r->gid.gid[0] = gid->gid[0];
		r->gid.gid[1] = gid->gid[1];
		r->type = icmp_type->type;
		r->code = icmp_type->code;

		if ((keep_state == PF_STATE_MODULATE ||
		    keep_state == PF_STATE_SYNPROXY) &&
		    r->proto && r->proto != IPPROTO_TCP)
			r->keep_state = PF_STATE_NORMAL;
		else
			r->keep_state = keep_state;

		if (r->proto && r->proto != IPPROTO_TCP) {
			r->flags = 0;
			r->flagset = 0;
		} else {
			r->flags = flags;
			r->flagset = flagset;
		}
		if (icmp_type->proto && r->proto != icmp_type->proto) {
			yyerror("icmp-type mismatch");
			error++;
		}

		if (src_os && src_os->os) {
			r->os_fingerprint = pfctl_get_fingerprint(src_os->os);
			if ((pf->opts & PF_OPT_VERBOSE2) &&
			    r->os_fingerprint == PF_OSFP_NOMATCH)
				fprintf(stderr,
				    "warning: unknown '%s' OS fingerprint\n",
				    src_os->os);
		} else {
			r->os_fingerprint = PF_OSFP_ANY;
		}

		TAILQ_INIT(&r->rpool.list);
		for (h = rpool_hosts; h != NULL; h = h->next) {
			pa = calloc(1, sizeof(struct pf_pooladdr));
			if (pa == NULL)
				err(1, "expand_rule: calloc");
			pa->addr = h->addr;
			if (h->ifname != NULL) {
				if (strlcpy(pa->ifname, h->ifname,
				    sizeof(pa->ifname)) >=
				    sizeof(pa->ifname))
					errx(1, "expand_rule: strlcpy");
			} else
				pa->ifname[0] = 0;
			TAILQ_INSERT_TAIL(&r->rpool.list, pa, entries);
		}

		if (rule_consistent(r) < 0 || error)
			yyerror("skipping rule due to errors");
		else {
			r->nr = pf->rule_nr++;
			pfctl_add_rule(pf, r);
			added++;
		}

	))))))))));

	FREE_LIST(struct node_if, interfaces);
	FREE_LIST(struct node_proto, protos);
	FREE_LIST(struct node_host, src_hosts);
	FREE_LIST(struct node_port, src_ports);
	FREE_LIST(struct node_os, src_oses);
	FREE_LIST(struct node_host, dst_hosts);
	FREE_LIST(struct node_port, dst_ports);
	FREE_LIST(struct node_uid, uids);
	FREE_LIST(struct node_gid, gids);
	FREE_LIST(struct node_icmp, icmp_types);
	FREE_LIST(struct node_host, rpool_hosts);

	if (!added)
		yyerror("rule expands to no valid combination");
}

#undef FREE_LIST
#undef LOOP_THROUGH

int
check_rulestate(int desired_state)
{
	if (require_order && (rulestate > desired_state)) {
		yyerror("Rules must be in order: options, normalization, "
		    "queueing, translation, filtering");
		return (1);
	}
	rulestate = desired_state;
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "all",		ALL},
		{ "allow-opts",		ALLOWOPTS},
		{ "altq",		ALTQ},
		{ "anchor",		ANCHOR},
		{ "any",		ANY},
		{ "bandwidth",		BANDWIDTH},
		{ "binat",		BINAT},
		{ "binat-anchor",	BINATANCHOR},
		{ "bitmask",		BITMASK},
		{ "block",		BLOCK},
		{ "block-policy",	BLOCKPOLICY},
		{ "cbq",		CBQ},
		{ "code",		CODE},
		{ "crop",		FRAGCROP},
		{ "debug",		DEBUG},
		{ "drop",		DROP},
		{ "drop-ovl",		FRAGDROP},
		{ "dup-to",		DUPTO},
		{ "fastroute",		FASTROUTE},
		{ "file",		FILENAME},
		{ "fingerprints",	FINGERPRINTS},
		{ "flags",		FLAGS},
		{ "floating",		FLOATING},
		{ "for",		FOR},
		{ "fragment",		FRAGMENT},
		{ "from",		FROM},
		{ "fuck-off",		FUCKOFF},
		{ "global",		GLOBAL},
		{ "group",		GROUP},
		{ "group-bound",	GRBOUND},
		{ "hfsc",		HFSC},
		{ "hostid",		HOSTID},
		{ "icmp-type",		ICMPTYPE},
		{ "icmp6-type",		ICMP6TYPE},
		{ "if-bound",		IFBOUND},
		{ "in",			IN},
		{ "inet",		INET},
		{ "inet6",		INET6},
		{ "keep",		KEEP},
		{ "label",		LABEL},
		{ "limit",		LIMIT},
		{ "linkshare",		LINKSHARE},
		{ "load",		LOAD},
		{ "log",		LOG},
		{ "log-all",		LOGALL},
		{ "loginterface",	LOGINTERFACE},
		{ "max",		MAXIMUM},
		{ "max-mss",		MAXMSS},
		{ "max-src-nodes",	MAXSRCNODES},
		{ "max-src-states",	MAXSRCSTATES},
		{ "min-ttl",		MINTTL},
		{ "modulate",		MODULATE},
		{ "nat",		NAT},
		{ "nat-anchor",		NATANCHOR},
		{ "no",			NO},
		{ "no-df",		NODF},
		{ "no-route",		NOROUTE},
		{ "no-sync",		NOSYNC},
		{ "on",			ON},
		{ "optimization",	OPTIMIZATION},
		{ "os",			OS},
		{ "out",		OUT},
		{ "pass",		PASS},
		{ "port",		PORT},
		{ "priority",		PRIORITY},
		{ "priq",		PRIQ},
		{ "probability",	PROBABILITY},
		{ "proto",		PROTO},
		{ "qlimit",		QLIMIT},
		{ "queue",		QUEUE},
		{ "quick",		QUICK},
		{ "random",		RANDOM},
		{ "random-id",		RANDOMID},
		{ "rdr",		RDR},
		{ "rdr-anchor",		RDRANCHOR},
		{ "realtime",		REALTIME},
		{ "reassemble",		REASSEMBLE},
		{ "reply-to",		REPLYTO},
		{ "require-order",	REQUIREORDER},
		{ "return",		RETURN},
		{ "return-icmp",	RETURNICMP},
		{ "return-icmp6",	RETURNICMP6},
		{ "return-rst",		RETURNRST},
		{ "round-robin",	ROUNDROBIN},
		{ "route-to",		ROUTETO},
		{ "rule",		RULE},
		{ "scrub",		SCRUB},
		{ "set",		SET},
		{ "source-hash",	SOURCEHASH},
		{ "source-track",	SOURCETRACK},
		{ "state",		STATE},
		{ "state-policy",	STATEPOLICY},
		{ "static-port",	STATICPORT},
		{ "sticky-address",	STICKYADDRESS},
		{ "synproxy",		SYNPROXY},
		{ "table",		TABLE},
		{ "tag",		TAG},
		{ "tagged",		TAGGED},
		{ "tbrsize",		TBRSIZE},
		{ "timeout",		TIMEOUT},
		{ "to",			TO},
		{ "tos",		TOS},
		{ "ttl",		TTL},
		{ "upperlimit",		UPPERLIMIT},
		{ "user",		USER},
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p) {
		if (debug > 1)
			fprintf(stderr, "%s: %d\n", s, p->k_val);
		return (p->k_val);
	} else {
		if (debug > 1)
			fprintf(stderr, "string: %s\n", s);
		return (STRING);
	}
}

#define MAXPUSHBACK	128

char	*parsebuf;
int	 parseindex;
char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(FILE *f)
{
	int	c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	while ((c = getc(f)) == '\\') {
		next = getc(f);
		if (next != '\n') {
			if (isspace(next))
				yyerror("whitespace after \\");
			ungetc(next, f);
			break;
		}
		yylval.lineno = lineno;
		lineno++;
	}
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(f);
		} while (c == '\t' || c == ' ');
		ungetc(c, f);
		c = ' ';
	}

	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;
	pushback_index = 0;

	/* skip to either EOF or the first real EOL */
	while (1) {
		c = lgetc(fin);
		if (c == '\n') {
			lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	char	 buf[8096];
	char	*p, *val;
	int	 endc, c, next;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(fin)) == ' ')
		; /* nothing */

	yylval.lineno = lineno;
	if (c == '#')
		while ((c = lgetc(fin)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(fin)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = (char)c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		endc = c;
		while (1) {
			if ((c = lgetc(fin)) == EOF)
				return (0);
			if (c == endc) {
				*p = '\0';
				break;
			}
			if (c == '\n') {
				lineno++;
				continue;
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = (char)c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	case '<':
		next = lgetc(fin);
		if (next == '>') {
			yylval.v.i = PF_OP_XRG;
			return (PORTBINARY);
		}
		lungetc(next);
		break;
	case '>':
		next = lgetc(fin);
		if (next == '<') {
			yylval.v.i = PF_OP_IRG;
			return (PORTBINARY);
		}
		lungetc(next);
		break;
	case '-':
		next = lgetc(fin);
		if (next == '>')
			return (ARROW);
		lungetc(next);
		break;
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && x != '<' && x != '>' && \
	x != '!' && x != '=' && x != '/' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = lineno;
		lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
parse_rules(FILE *input, struct pfctl *xpf)
{
	struct sym	*sym, *next;

	fin = input;
	pf = xpf;
	lineno = 1;
	errors = 0;
	rulestate = PFCTL_STATE_NONE;
	returnicmpdefault = (ICMP_UNREACH << 8) | ICMP_UNREACH_PORT;
	returnicmp6default =
	    (ICMP6_DST_UNREACH << 8) | ICMP6_DST_UNREACH_NOPORT;
	blockpolicy = PFRULE_DROP;
	require_order = 1;

	yyparse();

	/* Free macros and check which have not been used. */
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entries);
		if ((pf->opts & PF_OPT_VERBOSE2) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		free(sym->nam);
		free(sym->val);
		TAILQ_REMOVE(&symhead, sym, entries);
		free(sym);
	}

	return (errors ? -1 : 0);
}

/*
 * Over-designed efficiency is a French and German concept, so how about
 * we wait until they discover this ugliness and make it all fancy.
 */
int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entries))
		;	/* nothing */

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entries);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entries);
	return (0);
}

int
pfctl_cmdline_symset(char *s)
{
	char	*sym, *val;
	int	 ret;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	if ((sym = malloc(strlen(s) - strlen(val) + 1)) == NULL)
		err(1, "pfctl_cmdline_symset: malloc");

	strlcpy(sym, s, strlen(s) - strlen(val) + 1);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entries)
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	return (NULL);
}

void
decide_address_family(struct node_host *n, sa_family_t *af)
{
	sa_family_t	target_af = 0;

	while (!*af && n != NULL) {
		if (n->af) {
			if (target_af == 0)
				target_af = n->af;
			if (target_af != n->af)
				return;
		}
		n = n->next;
	}
	if (!*af && target_af)
		*af = target_af;
}

void
remove_invalid_hosts(struct node_host **nh, sa_family_t *af)
{
	struct node_host	*n = *nh, *prev = NULL;

	while (n != NULL) {
		if (*af && n->af && n->af != *af) {
			/* unlink and free n */
			struct node_host *next = n->next;

			/* adjust tail pointer */
			if (n == (*nh)->tail)
				(*nh)->tail = prev;
			/* adjust previous node's next pointer */
			if (prev == NULL)
				*nh = next;
			else
				prev->next = next;
			/* free node */
			if (n->ifname != NULL)
				free(n->ifname);
			free(n);
			n = next;
		} else {
			if (n->af && !*af)
				*af = n->af;
			prev = n;
			n = n->next;
		}
	}
}

int
invalid_redirect(struct node_host *nh, sa_family_t af)
{
	if (!af) {
		struct node_host *n;

		/* tables and dyniftl are ok without an address family */
		for (n = nh; n != NULL; n = n->next) {
			if (n->addr.type != PF_ADDR_TABLE) {
				yyerror("address family not given and "
				    "translation address expands to multiple "
				    "address families");
				return (1);
			}
		}
	}
	if (nh == NULL) {
		yyerror("no translation address with matching address family "
		    "found.");
		return (1);
	}
	return (0);
}

int
atoul(char *s, u_long *ulvalp)
{
	u_long	 ulval;
	char	*ep;

	errno = 0;
	ulval = strtoul(s, &ep, 0);
	if (s[0] == '\0' || *ep != '\0')
		return (-1);
	if (errno == ERANGE && ulval == ULONG_MAX)
		return (-1);
	*ulvalp = ulval;
	return (0);
}

int
getservice(char *n)
{
	struct servent	*s;
	u_long		 ulval;

	if (atoul(n, &ulval) == 0) {
		if (ulval > 65535) {
			yyerror("illegal port value %d", ulval);
			return (-1);
		}
		return (htons(ulval));
	} else {
		s = getservbyname(n, "tcp");
		if (s == NULL)
			s = getservbyname(n, "udp");
		if (s == NULL) {
			yyerror("unknown port %s", n);
			return (-1);
		}
		return (s->s_port);
	}
}

int
rule_label(struct pf_rule *r, char *s)
{
	if (s) {
		if (strlcpy(r->label, s, sizeof(r->label)) >=
		    sizeof(r->label)) {
			yyerror("rule label too long (max %d chars)",
			    sizeof(r->label)-1);
			return (-1);
		}
	}
	return (0);
}

u_int16_t
parseicmpspec(char *w, sa_family_t af)
{
	const struct icmpcodeent	*p;
	u_long				 ulval;
	u_int8_t			 icmptype;

	if (af == AF_INET)
		icmptype = returnicmpdefault >> 8;
	else
		icmptype = returnicmp6default >> 8;

	if (atoul(w, &ulval) == -1) {
		if ((p = geticmpcodebyname(icmptype, w, af)) == NULL) {
			yyerror("unknown icmp code %s", w);
			return (0);
		}
		ulval = p->code;
	}
	if (ulval > 255) {
		yyerror("invalid icmp code %ld", ulval);
		return (0);
	}
	return (icmptype << 8 | ulval);
}

int
pfctl_load_anchors(int dev, int opts, struct pfr_buffer *trans)
{
	struct loadanchors	*la;

	TAILQ_FOREACH(la, &loadanchorshead, entries) {
		if (opts & PF_OPT_VERBOSE)
			fprintf(stderr, "\nLoading anchor %s:%s from %s\n",
			    la->anchorname, la->rulesetname, la->filename);
		if (pfctl_rules(dev, la->filename, opts, la->anchorname,
		    la->rulesetname, trans) == -1)
			return (-1);
	}

	return (0);
}
@


1.24
log
@bcopy -> memmove
@
text
@d1 2
a2 2
/* $MirBSD: src/sbin/pfctl/parse.y,v 1.23 2004/05/27 16:43:34 tg Exp $	*/
/* $OpenBSD: parse.y,v 1.452 2004/04/24 23:22:54 cedric Exp $	*/
d20 1
a20 1
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
d64 1
a64 1
__RCSID("$MirBSD$");
a196 4
struct antispoof_opts {
	char			*label;
} antispoof_opts;

a245 1
int	disallow_alias(struct node_host *, const char *);
a364 1
		struct antispoof_opts	 antispoof_opts;
a385 4
#define DYNIF_MULTIADDR(addr) ((addr).type == PF_ADDR_DYNIFTL && \
	(!((addr).iflags & PFI_AFLAG_NOALIAS) ||		 \
	!isdigit((addr).v.ifname[strlen((addr).v.ifname)-1])))

d419 1
a419 1
%type	<v.host>		ipspec xhost host dynaddr host_list
a431 1
%type	<v.interface>		antispoof_ifspc antispoof_iflst antispoof_if
a439 1
%type	<v.antispoof_opts>	antispoof_opts antispoof_opt antispoof_opts_l
a457 1
		| ruleset antispoof '\n'
a877 122
antispoof	: ANTISPOOF logquick antispoof_ifspc af antispoof_opts {
			struct pf_rule		 r;
			struct node_host	*h = NULL, *hh;
			struct node_if		*i, *j;

			if (check_rulestate(PFCTL_STATE_FILTER))
				YYERROR;

			for (i = $3; i; i = i->next) {
				bzero(&r, sizeof(r));

				r.action = PF_DROP;
				r.direction = PF_IN;
				r.log = $2.log;
				r.quick = $2.quick;
				r.af = $4;
				if (rule_label(&r, $5.label))
					YYERROR;
				j = calloc(1, sizeof(struct node_if));
				if (j == NULL)
					err(1, "antispoof: calloc");
				if (strlcpy(j->ifname, i->ifname,
				    sizeof(j->ifname)) >= sizeof(j->ifname)) {
					free(j);
					yyerror("interface name too long");
					YYERROR;
				}
				j->not = 1;
				if (i->dynamic) {
					h = calloc(1, sizeof(*h));
					if (h == NULL)
						err(1, "address: calloc");
					h->addr.type = PF_ADDR_DYNIFTL;
					set_ipmask(h, 128);
					if (strlcpy(h->addr.v.ifname, i->ifname,
					    sizeof(h->addr.v.ifname)) >=
					    sizeof(h->addr.v.ifname)) {
						yyerror(
						    "interface name too long");
						YYERROR;
					}
					hh = malloc(sizeof(*hh));
					if (hh == NULL)
						 err(1, "address: malloc");
					memmove(hh, h, sizeof(*hh));
					h->addr.iflags = PFI_AFLAG_NETWORK;
				} else {
					h = ifa_lookup(j->ifname,
					    PFI_AFLAG_NETWORK);
					hh = NULL;
				}

				if (h != NULL)
					expand_rule(&r, j, NULL, NULL, NULL, h,
					    NULL, NULL, NULL, NULL, NULL, NULL);

				if ((i->ifa_flags & IFF_LOOPBACK) == 0) {
					bzero(&r, sizeof(r));

					r.action = PF_DROP;
					r.direction = PF_IN;
					r.log = $2.log;
					r.quick = $2.quick;
					r.af = $4;
					if (rule_label(&r, $5.label))
						YYERROR;
					if (hh != NULL)
						h = hh;
					else
						h = ifa_lookup(i->ifname, 0);
					if (h != NULL)
						expand_rule(&r, NULL, NULL,
						    NULL, NULL, h, NULL, NULL,
						    NULL, NULL, NULL, NULL);
				} else
					free(hh);
			}
			free($5.label);
		}
		;

antispoof_ifspc	: FOR antispoof_if		{ $$ = $2; }
		| FOR '{' antispoof_iflst '}'	{ $$ = $3; }
		;

antispoof_iflst	: antispoof_if				{ $$ = $1; }
		| antispoof_iflst comma antispoof_if	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

antispoof_if  : if_item				{ $$ = $1; }
		| '(' if_item ')'		{
			$2->dynamic = 1;
			$$ = $2;
		}
		;

antispoof_opts	:	{ bzero(&antispoof_opts, sizeof antispoof_opts); }
		    antispoof_opts_l
			{ $$ = antispoof_opts; }
		| /* empty */	{
			bzero(&antispoof_opts, sizeof antispoof_opts);
			$$ = antispoof_opts;
		}
		;

antispoof_opts_l	: antispoof_opts_l antispoof_opt
			| antispoof_opt
			;

antispoof_opt	: label	{
			if (antispoof_opts.label) {
				yyerror("label cannot be redefined");
				YYERROR;
			}
			antispoof_opts.label = $1;
		}
		;

a949 4
				case PF_ADDR_DYNIFTL:
					yyerror("dynamic addresses are not "
					    "permitted inside tables");
					break;
d1559 1
a1559 2
				    $5.host->addr.type == PF_ADDR_TABLE ||
				    DYNIF_MULTIADDR($5.host->addr)))
a1565 6
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
				    disallow_alias($5.host, "interface (%s) "
				    "is only supported in round-robin "
				    "routing pools"))
					YYERROR;
a2027 8
		| dynaddr
		| dynaddr '/' number		{
			struct node_host	*n;

			$$ = $1;
			for (n = $1; n != NULL; n = n->next)
				set_ipmask(n, $3);
		}
a2060 54
dynaddr		: '(' STRING ')'		{
			int	 flags = 0;
			char	*p, *op;

			op = $2;
			while ((p = strrchr($2, ':')) != NULL) {
				if (!strcmp(p+1, "network"))
					flags |= PFI_AFLAG_NETWORK;
				else if (!strcmp(p+1, "broadcast"))
					flags |= PFI_AFLAG_BROADCAST;
				else if (!strcmp(p+1, "peer"))
					flags |= PFI_AFLAG_PEER;
				else if (!strcmp(p+1, "0"))
					flags |= PFI_AFLAG_NOALIAS;
				else {
					yyerror("interface %s has bad modifier",
					    $2);
					free(op);
					YYERROR;
				}
				*p = '\0';
			}
			if (flags & (flags - 1) & PFI_AFLAG_MODEMASK) {
				free(op);
				yyerror("illegal combination of "
				    "interface modifiers");
				YYERROR;
			}
			if (ifa_exists($2, 1) == NULL && strcmp($2, "self")) {
				yyerror("interface %s does not exist", $2);
				free(op);
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "address: calloc");
			$$->af = 0;
			set_ipmask($$, 128);
			$$->addr.type = PF_ADDR_DYNIFTL;
			$$->addr.iflags = flags;
			if (strlcpy($$->addr.v.ifname, $2,
			    sizeof($$->addr.v.ifname)) >=
			    sizeof($$->addr.v.ifname)) {
				free(op);
				free($$);
				yyerror("interface name too long");
				YYERROR;
			}
			free(op);
			$$->next = NULL;
			$$->tail = $$;
		}
		;

d2956 1
a2956 2
				    $7->host->addr.type == PF_ADDR_TABLE ||
				    DYNIF_MULTIADDR($7->host->addr)))
a2963 6
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
				    disallow_alias($7->host, "interface (%s) "
				    "is only supported in round-robin "
				    "redirection pools"))
					YYERROR;
a3058 4
			if ($8 != NULL && disallow_alias($8, "invalid use of "
			    "interface (%s) as the source address of a binat "
			    "rule"))
				YYERROR;
a3062 4
			if ($12 != NULL && $12->host != NULL && disallow_alias(
			    $12->host, "invalid use of interface (%s) as the "
			    "redirect address of a binat rule"))
				YYERROR;
a3068 2
				if ($8->addr.type == PF_ADDR_DYNIFTL)
					$8->af = binat.af;
a3318 11
disallow_alias(struct node_host *h, const char *fmt)
{
	for (; h != NULL; h = h->next)
		if (DYNIF_MULTIADDR(h->addr)) {
			yyerror(fmt, h->addr.v.tblname);
			return (1);
		}
	return (0);
}

int
a3553 3
		case PF_ADDR_DYNIFTL:
			snprintf(tmp, sizeof(tmp), "(%s)", h->addr.v.ifname);
			break;
a4130 1
		{ "antispoof",		ANTISPOOF},
d4625 1
a4625 2
			if (n->addr.type != PF_ADDR_TABLE &&
			    n->addr.type != PF_ADDR_DYNIFTL) {
@


1.23
log
@Last piece of OpenBSD 3.5-current merge part I.

Things left:
* merge import in src/gnu/
* fix kernel build (it _is_ broken)

TOP 1 will be done with a _second_ import (easier).
TOP 2 will be done RSN.

----

Also, move RCS IDs to new-style MirOS ones, and fix the
SMM doc, and add output to newfs(8) saying if (!) or if
not (?) it read the random value out of the previous
superblock before making the fs.
@
text
@d1 2
a2 2
/*	$MirBSD: src/sbin/pfctl/parse.y,v 1.22 2004/01/27 17:42:06 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.452 2004/04/24 23:22:54 cedric Exp $	*/
d8 1
a8 1
 * Copyright (c) 2002, 2003 Thorsten Glaser.
d64 2
d935 1
a935 1
					bcopy(h, hh, sizeof(*hh));
@


1.22
log
@first part of mergeing OpenBSD and fixing whitespace and RCS IDs
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.21 2004/01/03 02:26:52 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.436 2004/01/05 22:04:24 henning Exp $	*/
d54 1
d56 1
d123 4
a126 2
	  PF_STATE_OPT_MAX_SRC_STATES, PF_STATE_OPT_MAX_SRC_NODES,
	  PF_STATE_OPT_STATELOCK, PF_STATE_OPT_TIMEOUT };
d181 1
d303 3
a305 2
TAILQ_HEAD(loadanchorshead, loadanchors)	 loadanchorshead =
   TAILQ_HEAD_INITIALIZER(loadanchorshead);
d405 1
a405 1
%token	BITMASK RANDOM SOURCEHASH ROUNDROBIN STATICPORT
d440 1
a440 1
%type	<v.interface>		antispoof_ifspc antispoof_iflst
d474 2
a475 1
			if (check_rulestate(PFCTL_STATE_OPTION))
d477 1
d480 1
d483 1
d490 2
a491 1
			if (check_rulestate(PFCTL_STATE_OPTION))
d493 1
d496 1
d501 1
d504 1
d512 1
a512 1
				yyerror("error setting loginterface %08x", $3);
d539 2
a540 1
			if (check_rulestate(PFCTL_STATE_OPTION))
d542 1
d545 1
d548 1
d552 1
a552 1
				switch($3) {
d567 2
a568 1
			if (check_rulestate(PFCTL_STATE_OPTION))
d570 1
d573 1
d576 1
d594 2
d599 1
a599 1
anchorrule	: ANCHOR string	dir interface af proto fromto {
d602 2
a603 1
			if (check_rulestate(PFCTL_STATE_FILTER))
d605 1
d610 10
d631 2
a632 1
			if (check_rulestate(PFCTL_STATE_NAT))
d634 1
d637 1
d651 2
a652 1
			if (check_rulestate(PFCTL_STATE_NAT))
d654 1
d657 1
d692 2
a693 1
			if (check_rulestate(PFCTL_STATE_NAT))
d695 1
d698 1
d730 1
a730 1
			if (*t == '\0' || *$3 == '\0') {
d732 1
d738 1
d744 1
d812 1
a812 1
		  scrub_opts_l
d864 2
a865 1
			if (strcasecmp($2, "tcp") != 0)
d867 2
d891 1
a891 1
			struct node_host	*h = NULL;
d917 23
a939 1
				h = ifa_lookup(j->ifname, PFI_AFLAG_NETWORK);
d955 10
a964 5
					h = ifa_lookup(i->ifname, 0);
					expand_rule(&r, NULL, NULL, NULL, NULL,
					    h, NULL, NULL, NULL, NULL, NULL,
					    NULL);
				}
d970 1
a970 1
antispoof_ifspc	: FOR if_item			{ $$ = $2; }
d974 2
a975 2
antispoof_iflst	: if_item			{ $$ = $1; }
		| antispoof_iflst comma if_item	{
d982 7
d990 1
a990 1
		  antispoof_opts_l
d1022 1
d1026 2
a1027 1
				if (process_tabledef($3, &$5))
d1029 2
d1040 1
a1040 1
				free (ti);
d1049 1
a1049 1
		   table_opts_l
d1068 2
a1069 1
			else
d1071 2
d1080 1
a1080 1
				switch(n->addr.type) {
d1146 2
a1147 1
			if (check_rulestate(PFCTL_STATE_QUEUE))
d1149 1
d1157 1
d1160 1
d1187 1
a1187 1
		  queue_opts_l
d1277 1
d1284 1
d1288 1
d1337 1
d1340 1
d1359 1
d1362 1
d1370 1
a1370 1
		  hfscopts_list				{
d1444 1
d1447 1
a1469 1
				free($$);
d1472 2
d1476 1
d1483 1
a1483 1
		  filter_opts
d1516 1
d1558 1
a1558 1
					     "the SYN TCP flag (flags S/SA)");
d1591 1
a1591 1
						    "multiple definitons");
d1594 1
a1594 2
					srctrack = 1;
					r.rule_flag |=  o->data.src_track;
d1626 2
a1627 1
					r.rule_flag |= PFRULE_SRCTRACK;
d1630 7
a1636 7
                                        if (statelock) {
                                                yyerror("state locking option: "
                                                    "multiple definitons");
                                                YYERROR;
                                        }
                                        statelock = 1;
                                        r.rule_flag |= o->data.statelock;
d1652 12
d1745 1
a1745 1
		  filter_opts_l
d1830 20
d1898 2
a1899 1
			if (!($$.w = parseicmpspec($3, AF_INET)))
d1901 2
d1908 2
a1909 1
			if (!($$.w2 = parseicmpspec($3, AF_INET6)))
d1911 2
d1916 4
a1919 3
			if (!($$.w = parseicmpspec($3, AF_INET)))
				YYERROR;
			if (!($$.w2 = parseicmpspec($5, AF_INET6)))
d1921 3
d1969 1
d1977 1
d1982 1
d2015 1
d2025 1
d2030 1
d2151 1
d2155 1
d2163 1
d2182 2
a2183 1
				yyerror("table name '%s' too long");
d2194 1
d2205 1
d2209 1
d2215 1
a2215 1
			char	*p;
d2217 1
d2230 1
d2236 1
d2243 1
d2256 1
d2261 1
d2332 1
d2344 1
d2356 2
a2357 1
				    (port[1] = getservice(p)) == -1)
d2359 1
d2364 1
d2433 1
d2440 1
d2446 1
d2515 1
d2523 1
d2528 1
d2537 1
d2540 1
d2587 1
d2595 1
d2600 1
d2630 1
d2637 1
d2642 1
d2661 1
d2669 1
d2674 1
d2685 1
d2693 1
d2698 1
d2715 1
d2718 1
d2722 3
a2724 9
sourcetrack	: SOURCETRACK {
			$$ = PFRULE_SRCTRACK;
		}
		| SOURCETRACK GLOBAL {
			$$ = PFRULE_SRCTRACK;
		}
		| SOURCETRACK RULE {
			$$ = PFRULE_SRCTRACK ^ PFRULE_RULESRCTRACK;
		}
d2825 1
d2830 1
d2833 1
d2846 1
a2846 2
			if (($$ = strdup($2)) == NULL)
				err(1, "rule label strdup() failed");
d2851 1
a2851 2
			if (($$.qname = strdup($2)) == NULL)
				err(1, "qname strdup() failed");
d2854 1
a2854 2
			if (($$.qname = strdup($3)) == NULL)
				err(1, "qname strdup() failed");
d2857 2
a2858 3
			if (($$.qname = strdup($3)) == NULL ||
			    ($$.pqname = strdup($5)) == NULL)
				err(1, "qname strdup() failed");
d2870 2
a2871 1
				if (($$.a = getservice($1)) == -1)
d2873 1
d2877 2
a2878 1
				if (($$.a = getservice($1)) == -1)
d2880 1
d2886 2
a2887 1
				    ($$.b = getservice(p)) == -1)
d2889 1
d2894 1
d2941 1
d2954 1
d2973 1
d2978 1
a2978 1
		   pool_opts_l
d3134 4
a3137 2
						    (ntohs($5.dst.port->port[1]) -
						    ntohs($5.dst.port->port[0]));
d3143 2
a3144 1
					r.rpool.proxy_port[1] = ntohs($7->rport.b);
d3222 1
a3222 1
		  redirection
d3376 1
a3376 2
			if (($$->ifname = strdup($1)) == NULL)
				err(1, "routeto: strdup");
d3380 2
d3390 1
a3390 2
			if (($$->ifname = strdup($2)) == NULL)
				err(1, "routeto: strdup");
d3453 2
a3454 1
			if (check_rulestate(PFCTL_STATE_OPTION))
d3456 1
d3459 1
d3462 1
a3462 1

d3472 2
a3473 1
			if (check_rulestate(PFCTL_STATE_OPTION))
d3475 1
d3478 1
d3481 1
d3497 2
a3498 1
			else
d3500 2
a3604 6
	if ((r->keep_state == PF_STATE_MODULATE || r->keep_state ==
	    PF_STATE_SYNPROXY) && r->proto && r->proto != IPPROTO_TCP) {
		yyerror("modulate/synproxy state can only be applied to "
		    "TCP rules");
		problems++;
	}
d3618 4
d3627 1
a3627 1
	    r->action == PF_PASS) {
d3813 1
a3813 1
						   "%s/%d", a, bits);
d4170 2
d4174 1
a4174 1
	u_int8_t		 flags, flagset;
d4178 5
d4185 1
d4206 1
a4206 1
		    (src_host->ifindex && if_nametoindex(interface->ifname) &&
d4208 1
a4208 1
		    (dst_host->ifindex && if_nametoindex(interface->ifname) &&
d4216 3
a4218 1
		if (if_indextoname(src_host->ifindex, ifname))
d4223 1
a4223 1
			memcpy(r->ifname, interface->ifname, sizeof(r->ifname));
d4228 6
d4266 7
d4431 1
d4682 3
a4684 4
		token = lookup(buf);
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
@


1.21
log
@Merge OpenBSD
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.20 2003/12/27 00:30:45 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.434 2003/12/31 22:14:41 deraadt Exp $	*/
d1412 1
a1412 1
				    PF_TAG_NAME_SIZE) > PF_TAG_NAME_SIZE) {
d1419 1
a1419 1
				    PF_TAG_NAME_SIZE) > PF_TAG_NAME_SIZE) {
d2898 1
a2898 1
				if (strlcpy(r.tagname, $6, PF_TAG_NAME_SIZE) >
d3050 1
d3055 1
a3055 1
				    PF_TAG_NAME_SIZE) > PF_TAG_NAME_SIZE) {
@


1.20
log
@finish merging and sync a bit; bump version etc.
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.19 2003/09/27 15:46:50 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.431 2003/12/19 16:12:43 henning Exp $	*/
d74 1
d122 1
a122 1
	  PF_STATE_OPT_TIMEOUT };
d131 1
d243 1
d384 4
d404 1
a404 1
%token	TAGGED TAG
d411 1
a411 1
%type	<v.i>			unaryop
d482 1
a482 1
			if ((ifa_exists($3) == NULL) && strcmp($3, "none")) {
d531 16
a733 7
			if ($4) {
				if ($4->not) {
					yyerror("scrub rules do not support "
					    "'! <if>'");
					YYERROR;
				}
			}
d865 1
a865 1
				h = ifa_lookup(j->ifname, PFCTL_IFLOOKUP_NET);
d881 1
a881 2
					h = ifa_lookup(i->ifname,
					    PFCTL_IFLOOKUP_HOST);
d1381 1
d1520 9
d1543 2
d1575 3
a1577 2
				    $5.host->addr.type == PF_ADDR_TABLE))
					r.rpool.opts = PF_POOL_ROUNDROBIN;
d1582 7
a1588 1
						YYERROR;
d1816 1
a1816 1
			if ((n = ifa_exists($1)) == NULL) {
d2050 25
a2074 1
			if (ifa_exists($2) == NULL) {
d2084 1
d2536 11
d2617 9
d2959 2
a2960 1
				    $7->host->addr.type == PF_ADDR_TABLE))
d2965 9
a2973 2
				    "supported in round-robin redirction pools"))
						YYERROR;
a2981 9
				} else {
					if ((r.af == AF_INET &&
					    unmask(&$7->host->addr.v.a.mask,
					    r.af) == 32) ||
					    (r.af == AF_INET6 &&
					    unmask(&$7->host->addr.v.a.mask,
					    r.af) == 128)) {
						r.rpool.opts = PF_POOL_NONE;
					}
d3068 4
d3076 4
a3168 2
			struct node_host	*n;

d3174 1
a3174 1
			if ((n = ifa_exists($$->ifname)) == NULL) {
a3183 2
			struct node_host	*n;

d3187 1
a3187 1
			if ((n = ifa_exists($$->ifname)) == NULL) {
d3328 11
a3400 6
	if (!r->af && (r->src.addr.type == PF_ADDR_DYNIFTL ||
	    r->dst.addr.type == PF_ADDR_DYNIFTL)) {
		yyerror("dynamic addresses require address family "
		    "(inet/inet6)");
		problems++;
	}
d3425 1
a3425 14
	int			 problems = 0;
	struct pf_pooladdr	*pa;

	if (!r->af) {
		TAILQ_FOREACH(pa, &r->rpool.list, entries) {
			if (pa->addr.type == PF_ADDR_DYNIFTL) {
				yyerror("dynamic addresses require "
				    "address family (inet/inet6)");
				problems++;
				break;
			}
		}
	}
	return (-problems);
a3431 1
	struct pf_pooladdr	*pa;
a3451 17
	if (!r->af) {
		if (r->src.addr.type == PF_ADDR_DYNIFTL ||
		    r->dst.addr.type == PF_ADDR_DYNIFTL) {
			yyerror("dynamic addresses require address family "
			    "(inet/inet6)");
			problems++;
		} else {
			TAILQ_FOREACH(pa, &r->rpool.list, entries) {
				if (pa->addr.type == PF_ADDR_DYNIFTL) {
					yyerror("dynamic addresses require "
					    "address family (inet/inet6)");
					problems++;
					break;
				}
			}
		}
	}
d4152 1
d4159 1
d4164 1
d4220 1
d4464 1
a4464 1
	struct sym	*sym;
d4480 2
a4481 1
	TAILQ_FOREACH(sym, &symhead, entries) {
d4488 1
d4626 1
a4626 1
		/* only tables are ok without an address family */
d4628 2
a4629 1
			if (n->addr.type != PF_ADDR_TABLE) {
@


1.19
log
@Merge update, bump patchlevel
End cvs playing games with me
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.18 2003/09/25 20:59:51 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.416 2003/09/26 21:44:09 cedric Exp $	*/
d7 3
a9 1
 * Copyright (c) 2002 Thorsten Glaser.
d119 4
a122 1
enum	{ PF_STATE_OPT_MAX=0, PF_STATE_OPT_TIMEOUT=1 };
d127 3
d164 1
d225 12
d247 8
a254 7
void	expand_label_str(char *, const char *, const char *);
void	expand_label_if(const char *, char *, const char *);
void	expand_label_addr(const char *, char *, u_int8_t, struct node_host *);
void	expand_label_port(const char *, char *, struct node_port *);
void	expand_label_proto(const char *, char *, u_int8_t);
void	expand_label_nr(const char *, char *);
void	expand_label(char *, const char *, u_int8_t, struct node_host *,
a333 1
		struct pf_poolhashkey	*hashkey;
a345 4
			int			 type;
			struct pf_poolhashkey	*key;
		}			 pooltype;
		struct {
d353 1
d363 1
d390 1
a390 1
%token	REQUIREORDER FUCKOFF SYNPROXY FINGERPRINTS
d396 1
d403 2
a404 2
%type	<v.i>			no dir log af fragcache
%type	<v.i>			staticport unaryop
a407 1
%type	<v.pooltype>		pooltype
d440 1
d484 10
d524 8
d851 3
a853 2
				expand_rule(&r, j, NULL, NULL, NULL, h, NULL,
				    NULL, NULL, NULL, NULL, NULL);
d912 1
d1176 1
d1365 1
d1454 50
d1546 2
a1547 2
				if (r.rpool.opts == PF_POOL_NONE && (
				    $5.host->next != NULL ||
d1550 4
a1553 4
				if (r.rpool.opts != PF_POOL_ROUNDROBIN)
					if (disallow_table($5.host, "tables "
					    "are only supported in round-robin "
					    "routing pools"))
d1556 1
a1556 1
					if (r.rpool.opts !=
d1805 1
d2466 11
d2481 1
a2481 1
		| MODULATE STATE state_opt_spec	{
d2512 35
d2698 26
a2723 4
pooltype	: /* empty */
		{
			$$.type = PF_POOL_NONE;
			$$.key = NULL;
d2725 7
a2731 4
		| BITMASK
		{
			$$.type = PF_POOL_BITMASK;
			$$.key = NULL;
d2733 6
a2738 4
		| RANDOM
		{
			$$.type = PF_POOL_RANDOM;
			$$.key = NULL;
d2740 6
a2745 4
		| SOURCEHASH hashkey
		{
			$$.type = PF_POOL_SRCHASH;
			$$.key = $2;
d2747 7
a2753 4
		| ROUNDROBIN
		{
			$$.type = PF_POOL_ROUNDROBIN;
			$$.key = NULL;
a2756 4
staticport	: /* empty */			{ $$ = 0; }
		| STATICPORT			{ $$ = 1; }
		;

d2796 1
a2796 2
natrule		: nataction interface af proto fromto tag redirpool pooltype
		  staticport
d2878 3
a2880 1
				if (r.rpool.opts == PF_POOL_NONE)
d2882 4
a2885 4
				if (r.rpool.opts != PF_POOL_ROUNDROBIN)
					if (disallow_table($7->host, "tables "
					    "are only supported in round-robin "
					    "redirection pools"))
d2887 2
a2888 2
				if ($7->host->next) {
					if (r.rpool.opts !=
d2911 4
a2914 1
			if ($9 != NULL) {
d3080 1
d3142 1
a3142 1
		| ROUTETO routespec pooltype {
d3145 1
a3145 1
			$$.pool_opts = $3.type;
d3149 1
a3149 1
		| REPLYTO routespec pooltype {
d3152 1
a3152 1
			$$.pool_opts = $3.type;
d3156 1
a3156 1
		| DUPTO routespec pooltype {
d3159 1
a3159 1
			$$.pool_opts = $3.type;
d3173 1
d3190 1
d3207 1
a3281 4
	if (r->src.port_op == PF_OP_RRG || r->dst.port_op == PF_OP_RRG) {
		yyerror("the ':' port operator only applies to rdr");
		problems++;
	}
a3340 4
	if (r->src.port_op == PF_OP_RRG || r->dst.port_op == PF_OP_RRG) {
		yyerror("the ':' port operator only applies to rdr");
		problems++;
	}
a3378 5
	if (r->src.port_op == PF_OP_RRG) {
		yyerror("the ':' port operator only applies to rdr "
		    "destination port");
		problems++;
	}
d3479 1
a3479 1
expand_label_str(char *label, const char *srch, const char *repl)
d3481 1
a3481 1
	char tmp[PF_RULE_LABEL_SIZE] = "";
d3484 2
d3489 3
a3491 3
		if ((strlcat(tmp, p, sizeof(tmp)) >= sizeof(tmp)) ||
		    (strlcat(tmp, repl, sizeof(tmp)) >= sizeof(tmp)))
			err(1, "expand_label: label too long");
d3495 4
a3498 3
	if (strlcat(tmp, p, sizeof(tmp)) >= sizeof(tmp))
		err(1, "expand_label: label too long");
	strlcpy(label, tmp, PF_RULE_LABEL_SIZE);	/* always fits */
d3502 1
a3502 1
expand_label_if(const char *name, char *label, const char *ifname)
d3506 1
a3506 1
			expand_label_str(label, name, "any");
d3508 1
a3508 1
			expand_label_str(label, name, ifname);
d3513 1
a3513 1
expand_label_addr(const char *name, char *label, sa_family_t af,
d3559 1
a3559 1
			expand_label_str(label, name, tmp_not);
d3561 1
a3561 1
			expand_label_str(label, name, tmp);
d3566 2
a3567 1
expand_label_port(const char *name, char *label, struct node_port *port)
d3592 1
a3592 1
		expand_label_str(label, name, op);
d3597 1
a3597 1
expand_label_proto(const char *name, char *label, u_int8_t proto)
d3605 1
a3605 1
			expand_label_str(label, name, pe->p_name);
d3608 1
a3608 1
			expand_label_str(label, name, n);
d3614 1
a3614 1
expand_label_nr(const char *name, char *label)
d3620 1
a3620 1
		expand_label_str(label, name, n);
d3625 1
a3625 1
expand_label(char *label, const char *ifname, sa_family_t af,
d3630 7
a3636 7
	expand_label_if("$if", label, ifname);
	expand_label_addr("$srcaddr", label, af, src_host);
	expand_label_addr("$dstaddr", label, af, dst_host);
	expand_label_port("$srcport", label, src_port);
	expand_label_port("$dstport", label, dst_port);
	expand_label_proto("$proto", label, proto);
	expand_label_nr("$nr", label);
d3950 7
a3956 2
		expand_label(r->label, r->ifname, r->af, src_host, src_port,
		    dst_host, dst_port, proto->proto);
d4088 1
d4100 1
d4103 1
d4119 2
d4128 1
d4155 1
d4159 1
d4162 1
@


1.18
log
@Merge OpenBSD-current
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.17 2003/08/31 20:54:40 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.415 2003/09/01 15:07:40 henning Exp $	*/
d4483 1
a4483 1
pfctl_load_anchors(int dev, int opts)
d4492 1
a4492 1
		    la->rulesetname) == -1)
@


1.17
log
@Merge import of OpenBSD source, ports and XF4 tree.

While here,
o clean up differences where possible
o whitespace cleanup
o ifdef ./. if defined()
o '...' ./. "..."
o echo foo > bar ./. echo foo >bar
o `...` ./. $(...) ./. $$(...)
o `...' ./. '...'
o modernize "our" tree, e.g. WWW in ports
o fix some typos and brainos introduced when renaming OpenBSD to MirBSD
o use hardware 80387 by default
o migrate Apache 1.3.28 OpenBSD ./. MirBSD ./. KAME
o work around as many CVS bugs as possible (add back/delete files, ...)

Synchronize stuff, ready for ongoing changes.
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.16 2003/08/16 15:25:26 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.414 2003/08/28 19:27:32 kjell Exp $	*/
d4385 2
a4386 2
		for(n = nh; n != NULL; n = n->next) {
			if(n->addr.type != PF_ADDR_TABLE) {
@


1.16
log
@Merge OpenBSD
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.15 2003/07/19 20:23:52 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.405 2003/08/09 14:56:48 cedric Exp $	*/
d236 3
a238 3
	    struct node_proto *, struct node_host *, struct node_port *,
	    struct node_host *, struct node_port *, struct node_uid *,
	    struct node_gid *, struct node_icmp *);
d302 1
d310 1
d364 1
a364 1
%token	PASS BLOCK SCRUB RETURN IN OUT LOG LOGALL QUICK ON FROM TO FLAGS
d371 1
a371 1
%token	REQUIREORDER FUCKOFF SYNPROXY
d398 1
d484 10
d526 1
a526 1
			expand_rule(&r, $4, NULL, $6,
d543 1
a543 1
			expand_rule(&r, $3, NULL, $5,
d581 1
a581 1
			expand_rule(&r, $3, NULL, $5,
d700 1
a700 1
			expand_rule(&r, $4, NULL, $6,
d745 4
d813 2
a814 2
				expand_rule(&r, j, NULL, NULL, h, NULL, NULL,
				    NULL, NULL, NULL, NULL);
d828 3
a830 2
					expand_rule(&r, NULL, NULL, NULL, h,
					    NULL, NULL, NULL, NULL, NULL, NULL);
d1021 2
a1022 1
			    &$4.scheduler))
d1024 1
d1372 1
a1372 1
			if ($9.flags.b1 || $9.flags.b2) {
d1378 14
a1391 1
					yyerror("flags only apply to tcp");
d1394 1
d1454 9
a1463 3
					if (r.rpool.opts == PF_POOL_NONE)
						r.rpool.opts =
						    PF_POOL_ROUNDROBIN;
d1491 1
a1491 1
			expand_rule(&r, $4, $5.host, $7,
d1611 4
d1765 1
d1767 1
a1767 1
		| from to			{
d1769 24
a1792 1
			$$.dst = $2;
d2763 2
a2764 2
			    $5.src.host, $5.src.port, $5.dst.host, $5.dst.port,
			    0, 0, 0);
d3611 1
a3611 1
				/* found ourselve in queues */
d3657 6
d3727 4
a3730 4
    struct node_proto *protos, struct node_host *src_hosts,
    struct node_port *src_ports, struct node_host *dst_hosts,
    struct node_port *dst_ports, struct node_uid *uids,
    struct node_gid *gids, struct node_icmp *icmp_types)
d3750 1
d3823 11
d3858 1
a3858 1
	)))))))));
d3864 1
d3922 1
d3954 1
d4382 11
a4392 3
		yyerror("address family not given and translation "
		    "address expands to multiple address families");
		return (1);
@


1.15
log
@merge OpenBSD tree; bump MirBSD minor
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.14 2003/07/18 15:45:14 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.403 2003/07/19 13:08:58 cedric Exp $	*/
d1787 1
a1787 1
		$$ = calloc(1, sizeof(struct node_host));
a2603 4
				if (disallow_table($7->host, "invalid use of "
				    "table <%s> as the redirection address "
				    "of a translation rule"))
					YYERROR;
d2643 8
a2651 4
					r.rpool.opts = $8.type;
					if (r.rpool.opts == PF_POOL_NONE)
						r.rpool.opts =
						    PF_POOL_ROUNDROBIN;
a2666 7
					} else {
						if ($8.type == PF_POOL_NONE)
							r.rpool.opts =
							    PF_POOL_ROUNDROBIN;
						else
							r.rpool.opts =
							    $8.type;
a2869 3
			if (disallow_table($3, "invalid use of table <%s> in "
			    "a route expression"))
				YYERROR;
@


1.14
log
@mop up; yet retain libcom_err
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.13 2003/07/06 20:22:12 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.402 2003/07/18 06:30:06 cedric Exp $	*/
d2834 1
a2834 1
				pa->addr.addr = $12->host->addr;
d3118 1
a3118 1
			if (pa->addr.addr.type == PF_ADDR_DYNIFTL) {
d3167 1
a3167 1
				if (pa->addr.addr.type == PF_ADDR_DYNIFTL) {
d3763 1
a3763 1
			pa->addr.addr = h->addr;
@


1.13
log
@mop up
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.12 2003/06/30 15:42:03 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.397 2003/07/04 11:05:44 henning Exp $	*/
d18 1
a18 1
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
d213 1
d224 1
d674 1
a674 1
					yyerror("reassmble tcp rules can not "
d857 3
d865 13
a877 7
			if (pfctl_define_table($3, $5.flags, $5.init_addr,
			    (pf->opts & PF_OPT_NOACTION) || !(pf->loadopt &
				(PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL)),
			    pf->anchor, pf->ruleset, pf->ab, pf->tticket)) {
				yyerror("cannot define table %s: %s", $3,
				    pfr_strerror(errno));
				YYERROR;
a878 1
			pf->tdirty = 1;
d884 1
d891 1
d900 1
a900 2
table_opt	: STRING
			{
d908 4
a911 11
		| '{' tableaddrs '}'	{ table_opts.init_addr = 1; }
		| FILENAME STRING	{
			if (pfr_buf_load(pf->ab, $2, 0, append_addr)) {
				if (errno)
					yyerror("cannot load %s: %s", $2,
					    pfr_strerror(errno));
					YYERROR;
			}
			table_opts.init_addr = 1;
		}
		;
d913 19
a931 8
tableaddrs	: /* empty */
		| tableaddrs tableaddr comma

tableaddr	: not STRING {
			if (append_addr_not(pf->ab, $2, 0, $1)) {
				if (errno)
					yyerror("cannot add %s: %s", $2,
					    pfr_strerror(errno));
d934 6
d941 2
a942 2
		| not STRING '/' number {
			char *buf = NULL;
d944 6
a949 13
			if (asprintf(&buf, "%s/%d", $2, $4) < 0) {
				if (errno)
					yyerror("cannot add %s/%d: %s", $2, $4,
					    strerror(errno));
                                YYERROR;
			} else if (append_addr_not(pf->ab, buf, 0, $1)) {
				if (errno)
					yyerror("cannot add %s: %s", buf,
					    pfr_strerror(errno));
				free(buf);
				YYERROR;
			}
			free(buf);
a1766 1
			/* $3 may be a list, so use its tail pointer */
d1772 1
a1772 1
				$1->tail->next = $3->tail;
d1787 1
a1787 1
			$$ = calloc(1, sizeof(struct node_host));
d2421 1
a2421 2
			/* $3 may be a list, so use its tail pointer */
			$1->tail->next = $3->tail;
d2892 1
a2892 2
			/* $3 may be a list, so use its tail pointer */
			$1->tail->next = $3->tail;
d3179 44
d3426 1
a3426 1
	if ((pf->loadopt & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) == 0) {
d3534 1
a3534 1
	if ((pf->loadopt & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) == 0) {
@


1.12
log
@merge fixes
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.11 2003/06/29 19:49:27 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.393 2003/06/19 22:08:35 deraadt Exp $	*/
d7 1
d378 1
a378 1
%type	<v.number>		tos not yesno
d860 1
a860 1
			pfctl_define_table($3, $5.flags, $5.init_addr,
d863 6
a868 1
				pf->anchor, pf->ruleset);
d899 6
a904 1
			pfctl_append_file($2);
d913 6
a918 1
			pfctl_append_addr($2, -1, $1);
d921 15
a935 1
			pfctl_append_addr($2, $4, $1);
d2527 5
a2531 1
nataction	: no NAT {
d2537 1
d2539 1
a2539 1
		| no RDR {
d2545 1
d2560 1
d2696 1
a2696 1
binatrule	: no BINAT interface af proto FROM host TO ipspec tag
d2711 8
a2718 7
			binat.af = $4;
			if (!binat.af && $7 != NULL && $7->af)
				binat.af = $7->af;
			if (!binat.af && $9 != NULL && $9->af)
				binat.af = $9->af;
			if (!binat.af && $11 != NULL && $11->host)
				binat.af = $11->host->af;
d2725 2
a2726 2
			if ($3 != NULL) {
				memcpy(binat.ifname, $3->ifname,
d2728 1
a2728 1
				free($3);
d2730 2
a2731 2
			if ($10 != NULL)
				if (strlcpy(binat.tagname, $10,
d2738 3
a2740 3
			if ($5 != NULL) {
				binat.proto = $5->proto;
				free($5);
d2743 1
a2743 1
			if ($7 != NULL && disallow_table($7, "invalid use of "
d2746 2
a2747 2
			if ($11 != NULL && $11->host != NULL && disallow_table(
			    $11->host, "invalid use of table <%s> as the "
d2751 2
a2752 2
			if ($7 != NULL) {
				if ($7->next) {
d2756 3
a2758 3
				if ($7->addr.type == PF_ADDR_DYNIFTL)
					$7->af = binat.af;
				if ($7->af != binat.af) {
d2762 1
a2762 1
				if (check_netmask($7, binat.af))
d2764 1
a2764 1
				memcpy(&binat.src.addr, &$7->addr,
d2766 1
a2766 1
				free($7);
d2768 2
a2769 2
			if ($9 != NULL) {
				if ($9->next) {
d2773 1
a2773 1
				if ($9->af != binat.af && $9->af) {
d2777 1
a2777 1
				if (check_netmask($9, binat.af))
d2779 1
a2779 1
				memcpy(&binat.dst.addr, &$9->addr,
d2781 2
a2782 2
				binat.dst.not = $9->not;
				free($9);
d2786 1
a2786 1
				if ($11 != NULL) {
d2792 1
a2792 1
				if ($11 == NULL || $11->host == NULL) {
d2798 2
a2799 2
				remove_invalid_hosts(&$11->host, &binat.af);
				if (invalid_redirect($11->host, binat.af))
d2801 1
a2801 1
				if ($11->host->next != NULL) {
d2806 1
a2806 1
				if (check_netmask($11->host, binat.af))
d2812 1
a2812 1
				    &$11->host->addr.v.a.mask, binat.af)) {
d2822 1
a2822 1
				pa->addr.addr = $11->host->addr;
d2827 1
a2827 1
				free($11);
@


1.11
log
@merge the import
amd (automount dmon) bites the dust
rewrite fake-NLS emulation, copyright to me
foobar! fnord!
@
text
@d1 1
a1 1
/*	$MirBSD: parse.y,v 1.10 2003/06/19 16:44:20 tg Exp $	*/
a4317 1

@


1.10
log
@merge cvs import - OpenBSD tree as of Thu Jun 19 16:13:15 UTC 2003
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.9 2003/06/09 12:45:37 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.392 2003/06/18 11:38:19 henning Exp $	*/
d2967 1
@


1.9
log
@merge OpenBSD-current MFC
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.8 2003/06/06 18:28:36 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.390 2003/06/09 11:14:46 mcbride Exp $	*/
d3202 2
a3203 1
		if (h->addr.type == PF_ADDR_DYNIFTL)
d3205 11
a3215 10
		else if (!af || (PF_AZERO(&h->addr.v.a.addr, af) &&
		    PF_AZERO(&h->addr.v.a.mask, af)))
			snprintf(tmp, sizeof(tmp), "any");
		else {
			char	a[48];
			int	bits;

			if (inet_ntop(af, &h->addr.v.a.addr, a, sizeof(a)) ==
			    NULL)
				snprintf(tmp, sizeof(tmp), "?");
d3217 16
a3232 7
				bits = unmask(&h->addr.v.a.mask, af);
				if ((af == AF_INET && bits < 32) ||
				    (af == AF_INET6 && bits < 128))
					snprintf(tmp, sizeof(tmp), "%s/%d",
					    a, bits);
				else
					snprintf(tmp, sizeof(tmp), "%s", a);
d3234 4
@


1.8
log
@Merge OpenBSD-current
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.7 2003/05/22 14:08:10 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.389 2003/05/25 17:07:28 henning Exp $	*/
d2477 1
a2477 1
		| STATICPORT			{ $$ = PF_POOL_STATICPORT; }
d2634 1
a2634 3
				if (r.action == PF_NAT)
					r.rpool.opts |= PF_POOL_STATICPORT;
				else {
d2639 11
@


1.7
log
@merge CVS import stuff
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.6 2003/05/07 20:54:13 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.388 2003/05/19 20:21:53 henning Exp $	*/
a2702 2
			if ($11 != NULL && check_netmask($11->host, binat.af))
				YYERROR;
d2759 2
@


1.6
log
@merge conflicts; fix what(1) stdin
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.5 2003/04/15 20:11:25 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.372 2003/05/03 16:50:38 henning Exp $	*/
d173 3
d192 1
d270 9
d364 1
a364 1
%token	FRAGNORM FRAGDROP FRAGCROP ANCHOR NATANCHOR RDRANCHOR BINATANCHOR
d366 1
a366 1
%token	REQUIREORDER FUCKOFF
d371 2
d398 1
a398 1
%type	<v.string>		label string
d425 1
d602 38
a639 1
scrubrule	: SCRUB dir logquick interface af fromto scrub_opts
d665 1
a665 1
			if ($7.nodf)
d667 1
a667 1
			if ($7.randomid)
d669 14
a682 6
			if ($7.minttl)
				r.min_ttl = $7.minttl;
			if ($7.maxmss)
				r.max_mss = $7.maxmss;
			if ($7.fragcache)
				r.rule_flag |= $7.fragcache;
d684 2
a685 2
			expand_rule(&r, $4, NULL, NULL,
			    $6.src.host, $6.src.port, $6.dst.host, $6.dst.port,
d740 9
d758 1
a758 1
fragcache	: FRAGMENT FRAGNORM	{ $$ = 0; /* default */ }
d1288 15
d1492 7
d1753 8
a1760 1
host		: STRING			{ $$ = host($1); }
d1766 6
a1771 1
			$$ = host(buf);
d2270 4
d2513 1
a2513 1
natrule		: nataction interface af proto fromto redirpool pooltype
d2535 8
d2544 1
a2544 1
				if ($6 != NULL) {
d2550 1
a2550 1
				if ($6 == NULL || $6->host == NULL) {
d2555 1
a2555 1
				if (disallow_table($6->host, "invalid use of "
d2559 2
a2560 2
				if (!r.af && ! $6->host->ifindex)
					r.af = $6->host->af;
d2562 4
a2565 2
				remove_invalid_hosts(&$6->host, &r.af);
				if (invalid_redirect($6->host, r.af))
d2568 1
a2568 1
				r.rpool.proxy_port[0] = ntohs($6->rport.a);
d2572 1
a2572 1
					if (!$6->rport.b && $6->rport.t &&
d2575 1
a2575 1
						    ntohs($6->rport.a) +
d2580 1
a2580 1
						    ntohs($6->rport.b);
d2583 1
a2583 1
					r.rpool.proxy_port[1] = ntohs($6->rport.b);
d2592 1
a2592 1
						    ntohs(r.rpool.proxy_port[0]);
d2598 2
a2599 2
				if ($6->host->next) {
					r.rpool.opts = $7.type;
d2612 1
a2612 1
					    unmask(&$6->host->addr.v.a.mask,
d2615 1
a2615 1
					    unmask(&$6->host->addr.v.a.mask,
d2619 1
a2619 1
						if ($7.type == PF_POOL_NONE)
d2624 1
a2624 1
							    $7.type;
d2629 2
a2630 2
			if ($7.key != NULL)
				memcpy(&r.rpool.key, $7.key,
d2633 1
a2633 1
			if ($8 != NULL) {
d2643 1
a2643 1
			expand_rule(&r, $2, $6 == NULL ? NULL : $6->host, $4,
d2646 1
a2646 1
			free($6);
d2650 2
a2651 1
binatrule	: no BINAT interface af proto FROM host TO ipspec redirection
d2670 2
a2671 2
			if (!binat.af && $10 != NULL && $10->host)
				binat.af = $10->host->af;
d2683 8
d2699 2
a2700 2
			if ($10 != NULL && $10->host != NULL && disallow_table(
			    $10->host, "invalid use of table <%s> as the "
d2703 2
d2717 2
d2732 2
d2741 1
a2741 1
				if ($10 != NULL) {
d2747 1
a2747 1
				if ($10 == NULL || $10->host == NULL) {
d2753 2
a2754 2
				remove_invalid_hosts(&$10->host, &binat.af);
				if (invalid_redirect($10->host, binat.af))
d2756 1
a2756 1
				if ($10->host->next != NULL) {
d2765 1
a2765 1
				    &$10->host->addr.v.a.mask, binat.af)) {
d2775 1
a2775 1
				pa->addr.addr = $10->host->addr;
d2780 1
a2780 1
				free($10);
d2787 3
d3010 4
a3013 3
	if (r->keep_state == PF_STATE_MODULATE && r->proto &&
	    r->proto != IPPROTO_TCP) {
		yyerror("modulate state can only be applied to TCP rules");
d3039 5
d3603 4
d3743 1
d3772 1
a3772 1
		{ "reassemble",		FRAGNORM},
d3786 1
d3788 2
d4034 6
d4042 10
a4051 7
	/* Check which macros have not been used. */
	if (pf->opts & PF_OPT_VERBOSE2)
		for (sym = TAILQ_FIRST(&symhead); sym;
		    sym = TAILQ_NEXT(sym, entries))
			if (!sym->used)
				fprintf(stderr, "warning: macro '%s' not "
				    "used\n", sym->nam);
d4276 18
@


1.5
log
@clean up after cvs
fix some stuff

in the hope to fully have removed sys_mhint... they implemented
it in the name of sys_mquery *d'oh*
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.4 2003/04/10 20:11:38 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.366 2003/04/14 14:50:46 henning Exp $	*/
d175 4
d246 1
d323 1
d396 1
d693 1
a693 1
antispoof	: ANTISPOOF logquick antispoof_ifspc af {
d702 1
a702 1
				memset(&r, 0, sizeof(r));
d709 2
a710 1

d727 1
a727 1
					memset(&r, 0, sizeof(r));
d734 2
a735 1

a737 1

d742 1
d758 22
d791 2
a792 1
				(PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL)));
d1220 3
a1222 1

a1282 1

a1302 11

			if ($9.label) {
				if (strlcpy(r.label, $9.label,
				    sizeof(r.label)) >= sizeof(r.label)) {
					yyerror("rule label too long (max "
					    "%d chars)", sizeof(r.label)-1);
					YYERROR;
				}
				free($9.label);
			}

d2465 1
d3190 1
a3190 1
				    &bwspec);
d3369 2
a3370 1
					    &bwspec, interface->ifname[0] != 0);
d4076 14
@


1.4
log
@clean up the cvs import mess

nb, this doesnt mean the tree builds.
its bed time
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.3 2003/03/29 21:33:33 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.353 2003/04/07 13:40:48 dhartmei Exp $	*/
a143 13
struct node_queue_opt {
	int			 qtype;
	union {
		struct cbq_opts		cbq_opts;
		struct priq_opts	priq_opts;
	}			 data;
};

struct node_queue_bw {
	u_int32_t	bw_absolute;
	u_int16_t	bw_percent;
};

d206 2
d229 1
a229 1
	    struct node_queue_bw bwspec);
d231 1
a231 1
	    struct node_queue_bw);
d321 1
d350 1
a350 1
%token	ALTQ CBQ PRIQ BANDWIDTH TBRSIZE
d387 1
a818 12
			switch (a.scheduler) {
			case ALTQT_CBQ:
				a.pq_u.cbq_opts =
				    $3.scheduler.data.cbq_opts;
				break;
			case ALTQT_PRIQ:
				a.pq_u.priq_opts =
				    $3.scheduler.data.priq_opts;
				break;
			default:
				break;
			}
d825 2
a826 1
			if (expand_altq(&a, $2, $5, $3.queue_bwspec))
d856 2
a857 13
			switch (a.scheduler) {
			case ALTQT_CBQ:
				a.pq_u.cbq_opts =
				    $4.scheduler.data.cbq_opts;
				break;
			case ALTQT_PRIQ:
				a.pq_u.priq_opts =
				    $4.scheduler.data.priq_opts;
				break;
			default:
				break;
			}
			if (expand_queue(&a, $3, $5, $4.queue_bwspec))
d885 1
a885 1
queue_opt	: bandwidth	{
d891 1
a891 1
			queue_opts.queue_bwspec = $1;
d939 1
a939 1
bandwidth	: BANDWIDTH STRING {
d945 1
a945 1
			bps = strtod($2, &cp);
d987 9
d1040 83
d3134 2
a3135 1
    struct node_queue *nqueues, struct node_queue_bw bwspec)
d3140 1
d3159 1
a3159 2
			if (eval_pfaltq(pf, &pa, bwspec.bw_absolute,
			    bwspec.bw_percent))
d3167 1
a3167 1
				    bwspec.bw_percent);
d3180 2
a3181 1
			if (pa.scheduler == ALTQT_CBQ) {
d3198 3
a3200 2
				pb.pq_u.cbq_opts = pa.pq_u.cbq_opts;
				if (eval_pfqueue(pf, &pb, pa.ifbandwidth, 0))
d3211 2
a3212 1
				if (pa.scheduler == ALTQT_CBQ)
d3243 2
a3244 1
    struct node_queue *nqueues, struct node_queue_bw bwspec)
d3309 1
a3309 2
				if (eval_pfqueue(pf, &pa, bwspec.bw_absolute,
				    bwspec.bw_percent))
d3315 1
a3315 1
				for(nq = nqueues; nq != NULL; nq = nq->next) {
d3346 1
a3346 2
					    bwspec.bw_percent,
					    interface->ifname[0] != 0);
a3436 3
		r->qid = qname_to_qid(r->qname);
		if ((r->pqid = qname_to_qid(r->pqname)) == 0)
			r->pqid = r->qid;
d3563 1
d3572 1
d3600 1
d3621 1
@


1.3
log
@merge OpenBSD cvs import conflicts
enable /etc/isdn directory and MAKEDEV.i4b
@
text
@d1 2
a2 2
/*	$MirBSD: parse.y,v 1.2 2003/03/23 21:52:02 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.348 2003/03/27 18:01:57 henning Exp $	*/
d241 1
a241 1
int	expand_queue(struct pf_altq *, struct node_queue *,
d363 1
a363 1
%token	<v.i>			PORTUNARY PORTBINARY
d368 1
a368 1
%type	<v.i>			staticport
d475 1
a475 3
varset		: STRING PORTUNARY string		{
			if ($2 != PF_OP_EQ)
				YYERROR;
d761 1
a761 3
tabledef	: TABLE PORTUNARY STRING PORTUNARY table_opts {
			if ($2 != PF_OP_LT || $4 != PF_OP_GT)
				YYERROR;
d851 1
a851 1
queuespec	: QUEUE STRING queue_opts qassign {
d865 1
a865 1
			if ($3.tbrsize) {
d869 1
a869 1
			if ($3.priority > 255) {
d873 3
a875 3
			a.priority = $3.priority;
			a.qlimit = $3.qlimit;
			a.scheduler = $3.scheduler.qtype;
d879 1
a879 1
				    $3.scheduler.data.cbq_opts;
d883 1
a883 1
				    $3.scheduler.data.priq_opts;
d888 1
a888 1
			if (expand_queue(&a, $4, $3.queue_bwspec))
d1578 9
a1586 2
host		: STRING			{ $$ = host($1, -1); }
		| STRING '/' number		{ $$ = host($1, $3); }
d1595 1
a1595 3
		| PORTUNARY STRING PORTUNARY	{
			if ($1 != PF_OP_LT || $3 != PF_OP_GT)
				YYERROR;
d1672 1
a1672 1
		| PORTUNARY port		{
d1765 1
a1765 1
		| PORTUNARY uid			{
d1844 1
a1844 1
		| PORTUNARY gid			{
d2698 8
d3177 2
a3178 2
expand_queue(struct pf_altq *a, struct node_queue *nqueues,
    struct node_queue_bw bwspec)
d3180 1
a3180 1
	struct node_queue	*n;
d3196 17
a3212 21
	LOOP_THROUGH(struct node_queue, tqueue, queues,
		if (!strncmp(a->qname, tqueue->queue, PF_QNAME_SIZE)) {
			/* found ourselve in queues */
			found++;

			memcpy(&pa, a, sizeof(struct pf_altq));

			if (pa.scheduler != ALTQT_NONE &&
			    pa.scheduler != tqueue->scheduler) {
				yyerror("exactly one scheduler type per "
				    "interface allowed");
				return (1);
			}
			pa.scheduler = tqueue->scheduler;

			/* scheduler dependent error checking */
			switch (pa.scheduler) {
			case ALTQT_PRIQ:
				if (nqueues != NULL) {
					yyerror("priq queues cannot have "
					    "child queues");
d3215 19
a3233 4
				if (bwspec.bw_absolute > 0 ||
				    bwspec.bw_percent < 100) {
					yyerror("priq doesn't take bandwidth");
					return (1);
a3234 4
				break;
			default:
				break;
			}
d3236 6
a3241 6
			if (strlcpy(pa.ifname, tqueue->ifname,
			    sizeof(pa.ifname)) >= sizeof(pa.ifname))
				errx(1, "expand_queue: strlcpy");
			if (strlcpy(pa.parent, tqueue->parent,
			    sizeof(pa.parent)) >= sizeof(pa.parent))
				errx(1, "expand_queue: strlcpy");
d3243 2
a3244 5
			if (eval_pfqueue(pf, &pa, bwspec.bw_absolute,
			    bwspec.bw_percent))
				errs++;
			else
				if (pfctl_add_altq(pf, &pa))
d3246 3
d3250 43
a3292 24
			if (nqueues == NULL)
				continue;

			LOOP_THROUGH(struct node_queue, queue, nqueues,
				n = calloc(1, sizeof(struct node_queue));
				if (n == NULL)
					err(1, "expand_queue: calloc");
				if (strlcpy(n->parent, a->qname,
				    sizeof(n->parent)) >= sizeof(n->parent))
					errx(1, "expand_queue: strlcpy");
				if (strlcpy(n->queue, queue->queue,
				    sizeof(n->queue)) >= sizeof(n->queue))
					errx(1, "expand_queue: strlcpy");
				if (strlcpy(n->ifname, tqueue->ifname,
				    sizeof(n->ifname)) >= sizeof(n->ifname))
					errx(1, "expand_queue: strlcpy");
				n->scheduler = tqueue->scheduler;
				n->next = NULL;
				n->tail = n;
				if (queues == NULL)
					queues = n;
				else {
					queues->tail->next = n;
					queues->tail = n;
d3294 2
a3295 2
			);
		}
a3297 13
	if ((pf->opts & PF_OPT_VERBOSE) && found > 0) {
		print_altq(&pf->paltq->altq, 0, bwspec.bw_percent);
		if (nqueues && nqueues->tail) {
			printf("{ ");
			LOOP_THROUGH(struct node_queue, queue,
			    nqueues,
				printf("%s ", queue->queue);
			);
			printf("}");
		}
		printf("\n");
	}

d3299 1
a3729 11
	case '=':
		yylval.v.i = PF_OP_EQ;
		return (PORTUNARY);
	case '!':
		next = lgetc(fin);
		if (next == '=') {
			yylval.v.i = PF_OP_NE;
			return (PORTUNARY);
		}
		lungetc(next);
		break;
a3734 5
		} else if (next == '=') {
			yylval.v.i = PF_OP_LE;
		} else {
			yylval.v.i = PF_OP_LT;
			lungetc(next);
d3736 1
a3736 1
		return (PORTUNARY);
a3742 5
		} else if (next == '=') {
			yylval.v.i = PF_OP_GE;
		} else {
			yylval.v.i = PF_OP_GT;
			lungetc(next);
d3744 1
a3744 1
		return (PORTUNARY);
d4007 4
@


1.2
log
@Merge MirBSD-old entirely
Remove krb, yp, afs, GPL'd stuff in kernel
Adjust some other stuff

Not to be compiled yet...
@
text
@d1 2
a2 2
/*	$MirBSD: obsd.tygs,v 1.44 2003/03/22 22:33:30 tg Exp $	*/
/*	$OpenBSD: parse.y,v 1.343 2003/03/19 15:51:40 henning Exp $	*/
d219 2
a220 2
int	yyerror(char *, ...);
int	disallow_table(struct node_host *, char *);
d254 1
d256 5
a260 5
	struct sym	*next;
	int		 used;
	int		 persist;
	char		*nam;
	char		*val;
d262 1
a262 1
struct sym	*symhead = NULL;
d357 1
a357 1
%token	REQUIREORDER YES FUCKOFF
a361 1
%token	DEFAULT BORROW RED ECN RIO
d366 1
a366 1
%type	<v.number>		tos not
d458 1
a458 6
		| SET REQUIREORDER YES {
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set require-order yes\n");
			require_order = 1;
		}
		| SET REQUIREORDER NO {
d460 3
a462 2
				printf("set require-order no\n");
			require_order = 0;
d1028 16
a1043 5
cbqflags_item	: DEFAULT	{ $$ = CBQCLF_DEFCLASS; }
		| BORROW	{ $$ = CBQCLF_BORROW; }
		| RED		{ $$ = CBQCLF_RED; }
		| ECN		{ $$ = CBQCLF_RED|CBQCLF_ECN; }
		| RIO		{ $$ = CBQCLF_RIO; }
d1050 14
a1063 4
priqflags_item	: DEFAULT	{ $$ = PRCF_DEFAULTCLASS; }
		| RED		{ $$ = PRCF_RED; }
		| ECN		{ $$ = PRCF_RED|PRCF_ECN; }
		| RIO		{ $$ = PRCF_RIO; }
d2689 8
d2700 1
a2700 1
yyerror(char *fmt, ...)
d2715 1
a2715 1
disallow_table(struct node_host *h, char *fmt)
a3464 1
		{ "borrow",		BORROW},
a3467 1
		{ "default",		DEFAULT},
a3470 1
		{ "ecn",		ECN},
a3514 1
		{ "red",		RED},
a3520 1
		{ "rio",		RIO},
a3534 1
		{ "yes",		YES},
d3797 2
a3798 1
		for (sym = symhead; sym; sym = sym->next)
d3814 2
a3815 1
	for (sym = symhead; sym && strcmp(nam, sym->nam); sym = sym->next)
d3818 10
a3827 3
	if (sym != NULL && sym->persist == 1)
		return (0);

a3841 1
	sym->next = symhead;
d3844 1
a3844 1
	symhead = sym;
d3873 1
a3873 1
	for (sym = symhead; sym; sym = sym->next)
@


1.1
log
@Initial revision
@
text
@d1 1
d356 1
a356 1
%token	REQUIREORDER YES
d988 6
a993 6
				else if (!strcmp(cp, "Kb"))
					bps *= 1000;
				else if (!strcmp(cp, "Mb"))
					bps *= 1000 * 1000;
				else if (!strcmp(cp, "Gb"))
					bps *= 1000 * 1000 * 1000;
d1315 6
d3455 1
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD repository of CTM 3155 (roughly today at noon).
Mostly in order to go 3.3-current and ease further merges of
both OpenBSD and ELFdiffs after the MirBSD has been enabled
to build again.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.348 2003/03/27 18:01:57 henning Exp $	*/
d218 2
a219 2
int	yyerror(const char *, ...);
int	disallow_table(struct node_host *, const char *);
a252 1
TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
d254 5
a258 5
	TAILQ_ENTRY(sym)	 entries;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
d260 1
a260 1

d355 1
a355 1
%token	REQUIREORDER
d360 1
d365 1
a365 1
%type	<v.number>		tos not yesno
d457 6
a462 1
		| SET REQUIREORDER yesno {
d464 2
a465 3
				printf("set require-order %s\n",
				    $3 == 1 ? "yes" : "no");
			require_order = $3;
d1031 5
a1035 16
cbqflags_item	: STRING	{
			if (!strcmp($1, "default"))
				$$ = CBQCLF_DEFCLASS;
			else if (!strcmp($1, "borrow"))
				$$ = CBQCLF_BORROW;
			else if (!strcmp($1, "red"))
				$$ = CBQCLF_RED;
			else if (!strcmp($1, "ecn"))
				$$ = CBQCLF_RED|CBQCLF_ECN;
			else if (!strcmp($1, "rio"))
				$$ = CBQCLF_RIO;
			else {
				yyerror("unknown cbq flag \"%s\"", $1);
				YYERROR;
			}
		}
d1042 4
a1045 14
priqflags_item	: STRING	{
			if (!strcmp($1, "default"))
				$$ = PRCF_DEFAULTCLASS;
			else if (!strcmp($1, "red"))
				$$ = PRCF_RED;
			else if (!strcmp($1, "ecn"))
				$$ = PRCF_RED|PRCF_ECN;
			else if (!strcmp($1, "rio"))
				$$ = PRCF_RIO;
			else {
				yyerror("unknown priq flag \"%s\"", $1);
				YYERROR;
			}
		}
a2664 8
yesno		: NO			{ $$ = 0; }
		| STRING		{
			if (!strcmp($1, "yes"))
				$$ = 1;
			else
				YYERROR;
		}

d2668 1
a2668 1
yyerror(const char *fmt, ...)
d2683 1
a2683 1
disallow_table(struct node_host *h, const char *fmt)
d3433 1
d3437 1
d3441 1
d3485 1
d3492 1
d3507 1
d3770 1
a3770 2
		for (sym = TAILQ_FIRST(&symhead); sym;
		    sym = TAILQ_NEXT(sym, entries))
d3786 1
a3786 2
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entries))
d3789 3
a3791 10
	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entries);
			free(sym);
		}
	}
d3806 1
d3809 1
a3809 1
	TAILQ_INSERT_TAIL(&symhead, sym, entries);
d3838 1
a3838 1
	TAILQ_FOREACH(sym, &symhead, entries)
@


1.1.1.3
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.353 2003/04/07 13:40:48 dhartmei Exp $	*/
d240 1
a240 1
int	expand_queue(struct pf_altq *, struct node_if *, struct node_queue *,
d362 1
a362 1
%token	<v.i>			PORTBINARY
d367 1
a367 1
%type	<v.i>			staticport unaryop
d474 3
a476 1
varset		: STRING '=' string		{
d762 3
a764 1
tabledef	: TABLE '<' STRING '>' table_opts {
d854 1
a854 1
queuespec	: QUEUE STRING interface queue_opts qassign {
d868 1
a868 1
			if ($4.tbrsize) {
d872 1
a872 1
			if ($4.priority > 255) {
d876 3
a878 3
			a.priority = $4.priority;
			a.qlimit = $4.qlimit;
			a.scheduler = $4.scheduler.qtype;
d882 1
a882 1
				    $4.scheduler.data.cbq_opts;
d886 1
a886 1
				    $4.scheduler.data.priq_opts;
d891 1
a891 1
			if (expand_queue(&a, $3, $5, $4.queue_bwspec))
d1575 2
a1576 9
host		: STRING			{ $$ = host($1); }
		| STRING '/' number		{
			char	*buf;

			if (asprintf(&buf, "%s/%u", $1, $3) == -1)
				err(1, "host: asprintf");
			$$ = host(buf);
			free(buf);
		}
d1585 3
a1587 1
		| '<' STRING '>'	{
d1664 1
a1664 1
		| unaryop port		{
d1757 1
a1757 1
		| unaryop uid			{
d1836 1
a1836 1
		| unaryop gid			{
a2689 8
unaryop		: '='		{ $$ = PF_OP_EQ; }
		| '!' '='	{ $$ = PF_OP_NE; }
		| '<' '='	{ $$ = PF_OP_LE; }
		| '<'		{ $$ = PF_OP_LT; }
		| '>' '='	{ $$ = PF_OP_GE; }
		| '>'		{ $$ = PF_OP_GT; }
		;

d3161 2
a3162 2
expand_queue(struct pf_altq *a, struct node_if *interfaces,
    struct node_queue *nqueues, struct node_queue_bw bwspec)
d3164 1
a3164 1
	struct node_queue	*n, *nq;
d3180 21
a3200 17
	LOOP_THROUGH(struct node_if, interface, interfaces,
		LOOP_THROUGH(struct node_queue, tqueue, queues,
			if (!strncmp(a->qname, tqueue->queue, PF_QNAME_SIZE) &&
			    (interface->ifname[0] == 0 ||
			    (!interface->not && !strncmp(interface->ifname,
			    tqueue->ifname, IFNAMSIZ)) ||
			    (interface->not && strncmp(interface->ifname,
			    tqueue->ifname, IFNAMSIZ)))) {
				/* found ourselve in queues */
				found++;

				memcpy(&pa, a, sizeof(struct pf_altq));

				if (pa.scheduler != ALTQT_NONE &&
				    pa.scheduler != tqueue->scheduler) {
					yyerror("exactly one scheduler type "
					    "per interface allowed");
d3203 4
a3206 19
				pa.scheduler = tqueue->scheduler;

				/* scheduler dependent error checking */
				switch (pa.scheduler) {
				case ALTQT_PRIQ:
					if (nqueues != NULL) {
						yyerror("priq queues cannot "
						    "have child queues");
						return (1);
					}
					if (bwspec.bw_absolute > 0 ||
					    bwspec.bw_percent < 100) {
						yyerror("priq doesn't take "
						    "bandwidth");
						return (1);
					}
					break;
				default:
					break;
d3208 4
d3213 6
a3218 6
				if (strlcpy(pa.ifname, tqueue->ifname,
				    sizeof(pa.ifname)) >= sizeof(pa.ifname))
					errx(1, "expand_queue: strlcpy");
				if (strlcpy(pa.parent, tqueue->parent,
				    sizeof(pa.parent)) >= sizeof(pa.parent))
					errx(1, "expand_queue: strlcpy");
d3220 5
a3224 2
				if (eval_pfqueue(pf, &pa, bwspec.bw_absolute,
				    bwspec.bw_percent))
a3225 3
				else
					if (pfctl_add_altq(pf, &pa))
						errs++;
d3227 24
a3250 26
				for(nq = nqueues; nq != NULL; nq = nq->next) {
					n = calloc(1,
					    sizeof(struct node_queue));
					if (n == NULL)
						err(1, "expand_queue: calloc");
					if (strlcpy(n->parent, a->qname,
					    sizeof(n->parent)) >=
					    sizeof(n->parent))
						errx(1, "expand_queue strlcpy");
					if (strlcpy(n->queue, nq->queue,
					    sizeof(n->queue)) >=
					    sizeof(n->queue))
						errx(1, "expand_queue strlcpy");
					if (strlcpy(n->ifname, tqueue->ifname,
					    sizeof(n->ifname)) >=
					    sizeof(n->ifname))
						errx(1, "expand_queue strlcpy");
					n->scheduler = tqueue->scheduler;
					n->next = NULL;
					n->tail = n;
					if (queues == NULL)
						queues = n;
					else {
						queues->tail->next = n;
						queues->tail = n;
					}
d3252 2
a3253 19
				if ((pf->opts & PF_OPT_VERBOSE) && (
				    (found == 1 && interface->ifname[0] == 0) ||
				    (found > 0 && interface->ifname[0] != 0))) {
					print_queue(&pf->paltq->altq, 0,
					    bwspec.bw_percent,
					    interface->ifname[0] != 0);
					if (nqueues && nqueues->tail) {
						printf("{ ");
						LOOP_THROUGH(struct node_queue,
						    queue, nqueues,
							printf("%s ",
							    queue->queue);
						);
						printf("}");
					}
					printf("\n");
				}
			}
		);
d3256 13
a3269 1
	FREE_LIST(struct node_if, interfaces);
d3699 11
d3715 5
d3721 1
a3721 1
		lungetc(next);
d3728 5
d3734 1
a3734 1
		lungetc(next);
a3996 4
	}
	if (ulval > 255) {
		yyerror("invalid icmp code %ld", ulval);
		return (0);
@


1.1.1.4
log
@Import OpenBSD source with the "new" command line as well,
in order to be able to provide a MirBSD release which bases
upon a fairly current OpenBSD base source code tree deemed
stable enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.366 2003/04/14 14:50:46 henning Exp $	*/
d143 13
a217 2
struct node_hfsc_opts	hfsc_opts;

d239 1
a239 1
	    struct node_queue_bw bwspec, struct node_queue_opt *);
d241 1
a241 1
	    struct node_queue_bw, struct node_queue_opt *);
a330 1
		struct node_hfsc_opts	 hfsc_opts;
d359 1
a359 1
%token	ALTQ CBQ PRIQ HFSC BANDWIDTH TBRSIZE LINKSHARE REALTIME UPPERLIMIT
a395 1
%type	<v.hfsc_opts>		hfscopts_list hfscopts_item hfsc_opts
d827 12
d845 1
a845 2
			if (expand_altq(&a, $2, $5, $3.queue_bwspec,
			    &$3.scheduler))
d875 13
a887 2
			if (expand_queue(&a, $3, $5, $4.queue_bwspec,
			    &$4.scheduler))
d915 1
a915 1
queue_opt	: BANDWIDTH bandwidth	{
d921 1
a921 1
			queue_opts.queue_bwspec = $2;
d969 1
a969 1
bandwidth	: STRING {
d975 1
a975 1
			bps = strtod($1, &cp);
a1016 9
		| HFSC				{
			$$.qtype = ALTQT_HFSC;
			bzero(&$$.data.hfsc_opts,
			    sizeof(struct node_hfsc_opts));
		}
		| HFSC '(' hfsc_opts ')'	{
			$$.qtype = ALTQT_HFSC;
			$$.data.hfsc_opts = $3;
		}
a1060 83
hfsc_opts	:	{
				bzero(&hfsc_opts,
				    sizeof(struct node_hfsc_opts));
			}
		  hfscopts_list				{
			$$ = hfsc_opts;
		}
		;

hfscopts_list	: hfscopts_item
		| hfscopts_list comma hfscopts_item
		;

hfscopts_item	: LINKSHARE bandwidth				{
			if (hfsc_opts.linkshare.used) {
				yyerror("linkshare already specified");
				YYERROR;
			}
			hfsc_opts.linkshare.m2 = $2;
			hfsc_opts.linkshare.used = 1;
		}
		| LINKSHARE '(' bandwidth number bandwidth ')'	{
			if (hfsc_opts.linkshare.used) {
				yyerror("linkshare already specified");
				YYERROR;
			}
			hfsc_opts.linkshare.m1 = $3;
			hfsc_opts.linkshare.d = $4;
			hfsc_opts.linkshare.m2 = $5;
			hfsc_opts.linkshare.used = 1;
		}
		| REALTIME bandwidth				{
			if (hfsc_opts.realtime.used) {
				yyerror("realtime already specified");
				YYERROR;
			}
			hfsc_opts.realtime.m2 = $2;
			hfsc_opts.realtime.used = 1;
		}
		| REALTIME '(' bandwidth number bandwidth ')'	{
			if (hfsc_opts.realtime.used) {
				yyerror("realtime already specified");
				YYERROR;
			}
			hfsc_opts.realtime.m1 = $3;
			hfsc_opts.realtime.d = $4;
			hfsc_opts.realtime.m2 = $5;
			hfsc_opts.realtime.used = 1;
		}
		| UPPERLIMIT bandwidth				{
			if (hfsc_opts.upperlimit.used) {
				yyerror("upperlimit already specified");
				YYERROR;
			}
			hfsc_opts.upperlimit.m2 = $2;
			hfsc_opts.upperlimit.used = 1;
		}
		| UPPERLIMIT '(' bandwidth number bandwidth ')'	{
			if (hfsc_opts.upperlimit.used) {
				yyerror("upperlimit already specified");
				YYERROR;
			}
			hfsc_opts.upperlimit.m1 = $3;
			hfsc_opts.upperlimit.d = $4;
			hfsc_opts.upperlimit.m2 = $5;
			hfsc_opts.upperlimit.used = 1;
		}
		| STRING	{
			if (!strcmp($1, "default"))
				hfsc_opts.flags |= HFCF_DEFAULTCLASS;
			else if (!strcmp($1, "red"))
				hfsc_opts.flags |= HFCF_RED;
			else if (!strcmp($1, "ecn"))
				hfsc_opts.flags |= HFCF_RED|HFCF_ECN;
			else if (!strcmp($1, "rio"))
				hfsc_opts.flags |= HFCF_RIO;
			else {
				yyerror("unknown hfsc flag \"%s\"", $1);
				YYERROR;
			}
		}
		;

d3066 1
a3066 2
    struct node_queue *nqueues, struct node_queue_bw bwspec,
    struct node_queue_opt *opts)
a3070 1
	struct node_queue_bw	 bw;
d3089 2
a3090 1
			if (eval_pfaltq(pf, &pa, &bwspec, opts))
d3098 1
a3098 1
				    &bwspec);
d3111 1
a3111 2
			if (pa.scheduler == ALTQT_CBQ ||
			    pa.scheduler == ALTQT_HFSC) {
d3128 2
a3129 3
				bw.bw_absolute = pa.ifbandwidth;
				bw.bw_percent = 0;
				if (eval_pfqueue(pf, &pb, &bw, opts))
d3140 1
a3140 2
				if (pa.scheduler == ALTQT_CBQ ||
				    pa.scheduler == ALTQT_HFSC)
d3171 1
a3171 2
    struct node_queue *nqueues, struct node_queue_bw bwspec,
    struct node_queue_opt *opts)
d3236 2
a3237 1
				if (eval_pfqueue(pf, &pa, &bwspec, opts))
d3243 1
a3243 1
				for (nq = nqueues; nq != NULL; nq = nq->next) {
d3274 2
a3275 1
					    &bwspec, interface->ifname[0] != 0);
d3366 3
a3493 1
		{ "hfsc",		HFSC},
a3501 1
		{ "linkshare",		LINKSHARE},
a3528 1
		{ "realtime",		REALTIME},
a3548 1
		{ "upperlimit",		UPPERLIMIT},
@


1.1.1.5
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.372 2003/05/03 16:50:38 henning Exp $	*/
a173 4
struct antispoof_opts {
	char			*label;
} antispoof_opts;

a240 1
int	 rule_label(struct pf_rule *, char *);
a316 1
		struct antispoof_opts	 antispoof_opts;
a388 1
%type	<v.antispoof_opts>	antispoof_opts antispoof_opt antispoof_opts_l
d685 1
a685 1
antispoof	: ANTISPOOF logquick antispoof_ifspc af antispoof_opts {
d694 1
a694 1
				bzero(&r, sizeof(r));
d701 1
a701 2
				if (rule_label(&r, $5.label))
					YYERROR;
d718 1
a718 1
					bzero(&r, sizeof(r));
d725 1
a725 2
					if (rule_label(&r, $5.label))
						YYERROR;
d728 1
a732 1
			free($5.label);
a747 22
antispoof_opts	:	{ bzero(&antispoof_opts, sizeof antispoof_opts); }
		  antispoof_opts_l
			{ $$ = antispoof_opts; }
		| /* empty */	{
			bzero(&antispoof_opts, sizeof antispoof_opts);
			$$ = antispoof_opts;
		}
		;

antispoof_opts_l	: antispoof_opts_l antispoof_opt
			| antispoof_opt
			;

antispoof_opt	: label	{
			if (antispoof_opts.label) {
				yyerror("label cannot be redefined");
				YYERROR;
			}
			antispoof_opts.label = $1;
		}
		;

d759 1
a759 2
				(PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL)),
				pf->anchor, pf->ruleset);
d1187 1
a1187 3
			if (rule_label(&r, $9.label))
				YYERROR;
			free($9.label);
d1248 1
d1269 11
a2435 1
					r.rpool.proxy_port[1] = ntohs($6->rport.b);
d3160 1
a3160 1
				    &bwspec, opts);
d3339 1
a3339 2
					    &bwspec, interface->ifname[0] != 0,
					    opts);
a4043 14
}

int
rule_label(struct pf_rule *r, char *s)
{
	if (s) {
		if (strlcpy(r->label, s, sizeof(r->label)) >=
		    sizeof(r->label)) {
			yyerror("rule label too long (max %d chars)",
			    sizeof(r->label)-1);
			return (-1);
		}
	}
	return (0);
@


1.1.1.6
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.388 2003/05/19 20:21:53 henning Exp $	*/
a171 3
	char			*tag;
	char			*match_tag;
	u_int8_t		 match_tag_not;
a187 1
	int			reassemble_tcp;
a264 9
TAILQ_HEAD(loadanchorshead, loadanchors)	 loadanchorshead =
   TAILQ_HEAD_INITIALIZER(loadanchorshead);
struct loadanchors {
	TAILQ_ENTRY(loadanchors)	 entries;
	char				*anchorname;
	char				*rulesetname;
	char				*filename;
};

d350 1
a350 1
%token	REASSEMBLE FRAGDROP FRAGCROP ANCHOR NATANCHOR RDRANCHOR BINATANCHOR
d352 1
a352 1
%token	REQUIREORDER SYNPROXY
a356 2
%token	LOAD
%token	TAGGED TAG
d382 1
a382 1
%type	<v.string>		label string tag
a408 1
		| ruleset loadrule '\n'
d585 1
a585 38
loadrule	: LOAD ANCHOR string FROM string	{
			char			*t;
			struct loadanchors	*loadanchor;

			t = strsep(&$3, ":");
			if (*t == '\0' || *$3 == '\0') {
				yyerror("anchor '%s' invalid\n", $3);
				YYERROR;
			}
			if (strlen(t) >= PF_ANCHOR_NAME_SIZE) {
				yyerror("anchorname %s too long, max %u\n",
				    t, PF_ANCHOR_NAME_SIZE - 1);
				YYERROR;
			}
			if (strlen($3) >= PF_RULESET_NAME_SIZE) {
				yyerror("rulesetname %s too long, max %u\n",
				    $3, PF_RULESET_NAME_SIZE - 1);
				YYERROR;
			}

			loadanchor = calloc(1, sizeof(struct loadanchors));
			if (loadanchor == NULL)
				err(1, "loadrule: calloc");
			if ((loadanchor->anchorname = strdup(t)) == NULL)
				err(1, "loadrule: strdup");
			if ((loadanchor->rulesetname = strdup($3)) == NULL)
				err(1, "loadrule: strdup");
			if ((loadanchor->filename = strdup($5)) == NULL)
				err(1, "loadrule: strdup");

			TAILQ_INSERT_TAIL(&loadanchorshead, loadanchor,
			    entries);

			free(t); /* not $3 */
			free($5);
		};

scrubrule	: SCRUB dir logquick interface af proto fromto scrub_opts
d611 1
a611 1
			if ($8.nodf)
d613 1
a613 1
			if ($8.randomid)
d615 6
a620 14
			if ($8.reassemble_tcp) {
				if (r.direction != PF_INOUT) {
					yyerror("reassmble tcp rules can not "
					    "specify direction");
					YYERROR;
				}
				r.rule_flag |= PFRULE_REASSEMBLE_TCP;
			}
			if ($8.minttl)
				r.min_ttl = $8.minttl;
			if ($8.maxmss)
				r.max_mss = $8.maxmss;
			if ($8.fragcache)
				r.rule_flag |= $8.fragcache;
d622 2
a623 2
			expand_rule(&r, $4, NULL, $6,
			    $7.src.host, $7.src.port, $7.dst.host, $7.dst.port,
a677 9
		| REASSEMBLE STRING {
			if (strcasecmp($2, "tcp") != 0)
				YYERROR;
			if (scrub_opts.reassemble_tcp) {
				yyerror("reassemble tcp cannot be respecified");
				YYERROR;
			}
			scrub_opts.reassemble_tcp = 1;
		}
d687 1
a687 1
fragcache	: FRAGMENT REASSEMBLE	{ $$ = 0; /* default */ }
a1216 15
			if ($9.tag)
				if (strlcpy(r.tagname, $9.tag,
				    PF_TAG_NAME_SIZE) > PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			if ($9.match_tag)
				if (strlcpy(r.match_tagname, $9.match_tag,
				    PF_TAG_NAME_SIZE) > PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			r.match_tag_not = $9.match_tag_not;
a1405 7
		| TAG string				{
			filter_opts.tag = $2;
		}
		| not TAGGED string			{
			filter_opts.match_tag = $3;
			filter_opts.match_tag_not = $1;
		}
d1654 1
a1654 8
host		: STRING			{
			if (($$ = host($1)) == NULL)	{
				/* error. "any" is handled elsewhere */
				yyerror("could not parse host specification");
				YYERROR;
			}

		}
d1660 1
a1660 6
			if (($$ = host(buf)) == NULL)	{
				/* error. "any" is handled elsewhere */
				free(buf);
				yyerror("could not parse host specification");
				YYERROR;
			}
a2158 4
		| SYNPROXY STATE state_opt_spec {
			$$.action = PF_STATE_SYNPROXY;
			$$.options = $3;
		}
d2398 1
a2398 1
natrule		: nataction interface af proto fromto tag redirpool pooltype
a2419 8
			if ($6 != NULL)
				if (strlcpy(r.tagname, $6, PF_TAG_NAME_SIZE) >
				    PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}

d2421 1
a2421 1
				if ($7 != NULL) {
d2427 1
a2427 1
				if ($7 == NULL || $7->host == NULL) {
d2432 1
a2432 1
				if (disallow_table($7->host, "invalid use of "
d2436 2
a2437 2
				if (!r.af && ! $7->host->ifindex)
					r.af = $7->host->af;
d2439 2
a2440 4
				remove_invalid_hosts(&$7->host, &r.af);
				if (invalid_redirect($7->host, r.af))
					YYERROR;
				if (check_netmask($7->host, r.af))
d2443 1
a2443 1
				r.rpool.proxy_port[0] = ntohs($7->rport.a);
d2447 1
a2447 1
					if (!$7->rport.b && $7->rport.t &&
d2450 1
a2450 1
						    ntohs($7->rport.a) +
d2455 1
a2455 1
						    ntohs($7->rport.b);
d2458 1
a2458 1
					r.rpool.proxy_port[1] = ntohs($7->rport.b);
d2467 1
a2467 1
						    r.rpool.proxy_port[0];
d2473 2
a2474 2
				if ($7->host->next) {
					r.rpool.opts = $8.type;
d2487 1
a2487 1
					    unmask(&$7->host->addr.v.a.mask,
d2490 1
a2490 1
					    unmask(&$7->host->addr.v.a.mask,
d2494 1
a2494 1
						if ($8.type == PF_POOL_NONE)
d2499 1
a2499 1
							    $8.type;
d2504 2
a2505 2
			if ($8.key != NULL)
				memcpy(&r.rpool.key, $8.key,
d2508 1
a2508 1
			if ($9 != NULL) {
d2518 1
a2518 1
			expand_rule(&r, $2, $7 == NULL ? NULL : $7->host, $4,
d2521 1
a2521 1
			free($7);
d2525 1
a2525 2
binatrule	: no BINAT interface af proto FROM host TO ipspec tag
		  redirection
d2544 2
a2545 2
			if (!binat.af && $11 != NULL && $11->host)
				binat.af = $11->host->af;
a2556 8
			if ($10 != NULL)
				if (strlcpy(binat.tagname, $10,
				    PF_TAG_NAME_SIZE) > PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}

d2565 2
a2566 2
			if ($11 != NULL && $11->host != NULL && disallow_table(
			    $11->host, "invalid use of table <%s> as the "
a2568 2
			if ($11 != NULL && check_netmask($11->host, binat.af))
				YYERROR;
a2580 2
				if (check_netmask($7, binat.af))
					YYERROR;
a2593 2
				if (check_netmask($9, binat.af))
					YYERROR;
d2601 1
a2601 1
				if ($11 != NULL) {
d2607 1
a2607 1
				if ($11 == NULL || $11->host == NULL) {
d2613 2
a2614 2
				remove_invalid_hosts(&$11->host, &binat.af);
				if (invalid_redirect($11->host, binat.af))
d2616 1
a2616 1
				if ($11->host->next != NULL) {
d2625 1
a2625 1
				    &$11->host->addr.v.a.mask, binat.af)) {
d2635 1
a2635 1
				pa->addr.addr = $11->host->addr;
d2640 1
a2640 1
				free($11);
a2646 3
tag		: /* empty */		{ $$ = NULL; }
		| TAG STRING		{ $$ = $2; }

d2867 3
a2869 4
	if ((r->keep_state == PF_STATE_MODULATE || r->keep_state ==
	    PF_STATE_SYNPROXY) && r->proto && r->proto != IPPROTO_TCP) {
		yyerror("modulate/synproxy state can only be applied to "
		    "TCP rules");
a2894 5
	if ((r->tagname[0] || r->match_tagname[0]) && !r->keep_state &&
	    r->action == PF_PASS) {
		yyerror("tags cannot be used without keep state");
		problems++;
	}
a3453 4

		error += check_netmask(src_host, r->af);
		error += check_netmask(dst_host, r->af);

a3588 1
		{ "load",		LOAD},
d3617 1
a3617 1
		{ "reassemble",		REASSEMBLE},
a3630 1
		{ "synproxy",		SYNPROXY},
a3631 2
		{ "tag",		TAG},
		{ "tagged",		TAGGED},
a3875 6
	returnicmpdefault = (ICMP_UNREACH << 8) | ICMP_UNREACH_PORT;
	returnicmp6default =
	    (ICMP6_DST_UNREACH << 8) | ICMP6_DST_UNREACH_NOPORT;
	blockpolicy = PFRULE_DROP;
	require_order = 1;

d3878 7
a3884 10
	/* Free macros and check which have not been used. */
	TAILQ_FOREACH(sym, &symhead, entries) {
		if ((pf->opts & PF_OPT_VERBOSE2) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		free(sym->nam);
		free(sym->val);
		TAILQ_REMOVE(&symhead, sym, entries);
	}

a4108 18

int
pfctl_load_anchors(int dev, int opts)
{
	struct loadanchors	*la;

	TAILQ_FOREACH(la, &loadanchorshead, entries) {
		if (opts & PF_OPT_VERBOSE)
			fprintf(stderr, "\nLoading anchor %s:%s from %s\n",
			    la->anchorname, la->rulesetname, la->filename);
		if (pfctl_rules(dev, la->filename, opts, la->anchorname,
		    la->rulesetname) == -1)
			return (-1);
	}

	return (0);
}

@


1.1.1.7
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.389 2003/05/25 17:07:28 henning Exp $	*/
d2696 2
a2753 2
				if (check_netmask($11->host, binat.af))
					YYERROR;
@


1.1.1.8
log
@MFC latest OpenBSD fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.390 2003/06/09 11:14:46 mcbride Exp $	*/
d2470 1
a2470 1
		| STATICPORT			{ $$ = 1; }
d2627 3
a2629 1
				if (r.action != PF_NAT) {
a2633 11
				if (r.rpool.proxy_port[0] !=
				    PF_NAT_PROXY_PORT_LOW &&
				    r.rpool.proxy_port[1] !=
				    PF_NAT_PROXY_PORT_HIGH) {
					yyerror("the 'static-port' option can't"
					    " be used when specifying a port"
					    " range");
					YYERROR;
				}
				r.rpool.proxy_port[0] = 0;
				r.rpool.proxy_port[1] = 0;
@


1.1.1.9
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.392 2003/06/18 11:38:19 henning Exp $	*/
d3195 1
a3195 2
		switch (h->addr.type) {
		case PF_ADDR_DYNIFTL:
d3197 10
a3206 11
			break;
		case PF_ADDR_TABLE:
			snprintf(tmp, sizeof(tmp), "<%s>", h->addr.v.tblname);
			break;
		case PF_ADDR_NOROUTE:
			snprintf(tmp, sizeof(tmp), "no-route");
			break;
		case PF_ADDR_ADDRMASK:
			if (!af || (PF_AZERO(&h->addr.v.a.addr, af) &&
			    PF_AZERO(&h->addr.v.a.mask, af)))
				snprintf(tmp, sizeof(tmp), "any");
d3208 7
a3214 16
				char	a[48];
				int	bits;

				if (inet_ntop(af, &h->addr.v.a.addr, a,
				    sizeof(a)) == NULL)
					snprintf(tmp, sizeof(tmp), "?");
				else {
					bits = unmask(&h->addr.v.a.mask, af);
					if ((af == AF_INET && bits < 32) ||
					    (af == AF_INET6 && bits < 128))
						snprintf(tmp, sizeof(tmp),
						   "%s/%d", a, bits);
					else
						snprintf(tmp, sizeof(tmp),
						    "%s", a);
				}
a3215 4
			break;
		default:
			snprintf(tmp, sizeof(tmp), "?");
			break;
@


1.1.1.10
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.393 2003/06/19 22:08:35 deraadt Exp $	*/
a2959 1

@


1.1.1.11
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.397 2003/07/04 11:05:44 henning Exp $	*/
d376 1
a376 1
%type	<v.number>		tos not yesno natpass
d858 1
a858 1
			if (pfctl_define_table($3, $5.flags, $5.init_addr,
d861 1
a861 6
			    pf->anchor, pf->ruleset, pf->ab, pf->tticket)) {
				yyerror("cannot define table %s: %s", $3,
				    pfr_strerror(errno));
				YYERROR;
			}
			pf->tdirty = 1;
d892 1
a892 6
			if (pfr_buf_load(pf->ab, $2, 0, append_addr)) {
				if (errno)
					yyerror("cannot load %s: %s", $2,
					    pfr_strerror(errno));
					YYERROR;
			}
d901 1
a901 6
			if (append_addr_not(pf->ab, $2, 0, $1)) {
				if (errno)
					yyerror("cannot add %s: %s", $2,
					    pfr_strerror(errno));
				YYERROR;
			}
d904 1
a904 15
			char *buf = NULL;

			if (asprintf(&buf, "%s/%d", $2, $4) < 0) {
				if (errno)
					yyerror("cannot add %s/%d: %s", $2, $4,
					    strerror(errno));
                                YYERROR;
			} else if (append_addr_not(pf->ab, buf, 0, $1)) {
				if (errno)
					yyerror("cannot add %s: %s", buf,
					    pfr_strerror(errno));
				free(buf);
				YYERROR;
			}
			free(buf);
d2490 1
a2490 5
natpass		: /* empty */	{ $$ = 0; }
		| PASS		{ $$ = 1; }
		;

nataction	: no NAT natpass {
a2495 1
			$$.b2 = $3;
d2497 1
a2497 1
		| no RDR natpass {
a2502 1
			$$.b2 = $3;
a2516 1
			r.natpass = $1.b2;
d2652 1
a2652 1
binatrule	: no BINAT natpass interface af proto FROM host TO ipspec tag
d2667 7
a2673 8
			binat.natpass = $3;
			binat.af = $5;
			if (!binat.af && $8 != NULL && $8->af)
				binat.af = $8->af;
			if (!binat.af && $10 != NULL && $10->af)
				binat.af = $10->af;
			if (!binat.af && $12 != NULL && $12->host)
				binat.af = $12->host->af;
d2680 2
a2681 2
			if ($4 != NULL) {
				memcpy(binat.ifname, $4->ifname,
d2683 1
a2683 1
				free($4);
d2685 2
a2686 2
			if ($11 != NULL)
				if (strlcpy(binat.tagname, $11,
d2693 3
a2695 3
			if ($6 != NULL) {
				binat.proto = $6->proto;
				free($6);
d2698 1
a2698 1
			if ($8 != NULL && disallow_table($8, "invalid use of "
d2701 2
a2702 2
			if ($12 != NULL && $12->host != NULL && disallow_table(
			    $12->host, "invalid use of table <%s> as the "
d2706 2
a2707 2
			if ($8 != NULL) {
				if ($8->next) {
d2711 3
a2713 3
				if ($8->addr.type == PF_ADDR_DYNIFTL)
					$8->af = binat.af;
				if ($8->af != binat.af) {
d2717 1
a2717 1
				if (check_netmask($8, binat.af))
d2719 1
a2719 1
				memcpy(&binat.src.addr, &$8->addr,
d2721 1
a2721 1
				free($8);
d2723 2
a2724 2
			if ($10 != NULL) {
				if ($10->next) {
d2728 1
a2728 1
				if ($10->af != binat.af && $10->af) {
d2732 1
a2732 1
				if (check_netmask($10, binat.af))
d2734 1
a2734 1
				memcpy(&binat.dst.addr, &$10->addr,
d2736 2
a2737 2
				binat.dst.not = $10->not;
				free($10);
d2741 1
a2741 1
				if ($12 != NULL) {
d2747 1
a2747 1
				if ($12 == NULL || $12->host == NULL) {
d2753 2
a2754 2
				remove_invalid_hosts(&$12->host, &binat.af);
				if (invalid_redirect($12->host, binat.af))
d2756 1
a2756 1
				if ($12->host->next != NULL) {
d2761 1
a2761 1
				if (check_netmask($12->host, binat.af))
d2767 1
a2767 1
				    &$12->host->addr.v.a.mask, binat.af)) {
d2777 1
a2777 1
				pa->addr.addr = $12->host->addr;
d2782 1
a2782 1
				free($12);
@


1.1.1.12
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.402 2003/07/18 06:30:06 cedric Exp $	*/
a210 1
	struct node_tinithead	init_nodes;
a220 1
int	process_tabledef(char *, struct table_opts *);
d670 1
a670 1
					yyerror("reassemble tcp rules can not "
a852 3
			struct node_host	 *h, *nh;
			struct node_tinit	 *ti, *nti;

d858 7
a864 13
			if (pf->loadopt & PFCTL_FLAG_TABLE)
				if (process_tabledef($3, &$5))
					YYERROR;
			for (ti = SIMPLEQ_FIRST(&$5.init_nodes);
			    ti != SIMPLEQ_END(&$5.init_nodes); ti = nti) {
				if (ti->file)
					free(ti->file);
				for (h = ti->host; h != NULL; h = nh) {
					nh = h->next;
					free(h);
				}
				nti = SIMPLEQ_NEXT(ti, entries);
				free (ti);
d866 1
a871 1
			SIMPLEQ_INIT(&table_opts.init_nodes);
a877 1
			SIMPLEQ_INIT(&table_opts.init_nodes);
d886 2
a887 1
table_opt	: STRING		{
d895 14
a908 4
		| '{' '}'		{ table_opts.init_addr = 1; }
		| '{' host_list '}'	{
			struct node_host	*n;
			struct node_tinit	*ti;
d910 5
a914 19
			for (n = $2; n != NULL; n = n->next) {
				switch(n->addr.type) {
				case PF_ADDR_ADDRMASK:
					continue; /* ok */
				case PF_ADDR_DYNIFTL:
					yyerror("dynamic addresses are not "
					    "permitted inside tables");
					break;
				case PF_ADDR_TABLE:
					yyerror("tables cannot contain tables");
					break;
				case PF_ADDR_NOROUTE:
					yyerror("\"no-route\" is not permitted "
					    "inside tables");
					break;
				default:
					yyerror("unknown address type %d",
					    n->addr.type);
				}
a916 6
			if (!(ti = calloc(1, sizeof(*ti))))
				err(1, "table_opt: calloc");
			ti->host = $2;
			SIMPLEQ_INSERT_TAIL(&table_opts.init_nodes, ti,
			    entries);
			table_opts.init_addr = 1;
d918 2
a919 2
		| FILENAME STRING	{
			struct node_tinit	*ti;
d921 13
a933 6
			if (!(ti = calloc(1, sizeof(*ti))))
				err(1, "table_opt: calloc");
			ti->file = $2;
			SIMPLEQ_INSERT_TAIL(&table_opts.init_nodes, ti,
			    entries);
			table_opts.init_addr = 1;
d1745 1
d1751 1
a1751 1
				$1->tail->next = $3;
d1766 1
a1766 1
		$$ = calloc(1, sizeof(struct node_host));
d2400 2
a2401 1
			$1->tail->next = $3;
d2872 2
a2873 1
			$1->tail->next = $3;
a3159 44
int
process_tabledef(char *name, struct table_opts *opts)
{
	struct pfr_buffer	 ab;
	struct node_tinit	*ti;

	bzero(&ab, sizeof(ab));
	ab.pfrb_type = PFRB_ADDRS;
	SIMPLEQ_FOREACH(ti, &opts->init_nodes, entries) {
		if (ti->file)
			if (pfr_buf_load(&ab, ti->file, 0, append_addr)) {
				if (errno)
					yyerror("cannot load \"%s\": %s",
					    ti->file, strerror(errno));
				else
					yyerror("file \"%s\" contains bad data",
					    ti->file);
				goto _error;
			}
		if (ti->host)
			if (append_addr_host(&ab, ti->host, 0, 0)) {
				yyerror("cannot create address buffer: %s",
				    strerror(errno));
				goto _error;
			}
	}
	if (pf->opts & PF_OPT_VERBOSE)
		print_tabledef(name, opts->flags, opts->init_addr,
		    &opts->init_nodes);
	if (!(pf->opts & PF_OPT_NOACTION) &&
	    pfctl_define_table(name, opts->flags, opts->init_addr,
	    pf->anchor, pf->ruleset, &ab, pf->tticket)) {
		yyerror("cannot define table %s: %s", name,
		    pfr_strerror(errno));
		goto _error;
	}
	pf->tdirty = 1;
	pfr_buf_clear(&ab);
	return (0);
_error:
	pfr_buf_clear(&ab);
	return (-1);
}

d3363 1
a3363 1
	if ((pf->loadopt & PFCTL_FLAG_ALTQ) == 0) {
d3471 1
a3471 1
	if ((pf->loadopt & PFCTL_FLAG_ALTQ) == 0) {
@


1.1.1.13
log
@Another sync to OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.403 2003/07/19 13:08:58 cedric Exp $	*/
d2826 1
a2826 1
				pa->addr = $12->host->addr;
d3110 1
a3110 1
			if (pa->addr.type == PF_ADDR_DYNIFTL) {
d3159 1
a3159 1
				if (pa->addr.type == PF_ADDR_DYNIFTL) {
d3755 1
a3755 1
			pa->addr = h->addr;
@


1.1.1.14
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.405 2003/08/09 14:56:48 cedric Exp $	*/
d1779 1
a1779 1
			$$ = calloc(1, sizeof(struct node_host));
d2596 4
a2638 8
				r.rpool.opts = $8.type;
				if (r.rpool.opts == PF_POOL_NONE)
					r.rpool.opts = PF_POOL_ROUNDROBIN;
				if (r.rpool.opts != PF_POOL_ROUNDROBIN)
					if (disallow_table($7->host, "tables "
					    "are only supported in round-robin "
					    "redirection pools"))
						YYERROR;
d2640 4
d2659 7
d2869 3
@


1.1.1.15
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.414 2003/08/28 19:27:32 kjell Exp $	*/
d234 3
a236 3
	    struct node_proto *, struct node_os*, struct node_host *,
	    struct node_port *, struct node_host *, struct node_port *,
	    struct node_uid *, struct node_gid *, struct node_icmp *);
a299 1
		struct node_os		*os;
a306 1
			struct node_os	*src_os;
d360 1
a360 1
%token	PASS BLOCK SCRUB RETURN IN OS OUT LOG LOGALL QUICK ON FROM TO FLAGS
d367 1
a367 1
%token	REQUIREORDER SYNPROXY FINGERPRINTS
a393 1
%type	<v.os>			os xos os_list
a478 10
		| SET FINGERPRINTS STRING {
			if (pf->opts & PF_OPT_VERBOSE)
				printf("fingerprints %s\n", $3);
			if (check_rulestate(PFCTL_STATE_OPTION))
				YYERROR;
			if (pfctl_file_fingerprints(pf->dev, pf->opts, $3)) {
				yyerror("error loading fingerprints %s", $3);
				YYERROR;
			}
		}
d511 1
a511 1
			expand_rule(&r, $4, NULL, $6, $7.src_os,
d528 1
a528 1
			expand_rule(&r, $3, NULL, $5, $6.src_os,
d566 1
a566 1
			expand_rule(&r, $3, NULL, $5, $6.src_os,
d685 1
a685 1
			expand_rule(&r, $4, NULL, $6, $7.src_os,
a729 4
			if ($2 > 65535) {
				yyerror("illegal max-mss value %d", $2);
				YYERROR;
			}
d794 2
a795 2
				expand_rule(&r, j, NULL, NULL, NULL, h, NULL,
				    NULL, NULL, NULL, NULL, NULL);
d809 2
a810 3
					expand_rule(&r, NULL, NULL, NULL, NULL,
					    h, NULL, NULL, NULL, NULL, NULL,
					    NULL);
d1001 1
a1001 2
			    &$4.scheduler)) {
				yyerror("errors in queue definition");
a1002 1
			}
d1350 1
a1350 1
			if ($9.flags.b1 || $9.flags.b2 || $8.src_os) {
d1356 1
a1356 14
					if ($9.flags.b1 || $9.flags.b2)
						yyerror(
						    "flags only apply to tcp");
					if ($8.src_os)
						yyerror(
						    "OS fingerprinting only "
						    "apply to tcp");
					YYERROR;
				}
#if 0
				if (($9.flags.b1 & parse_flags("S")) == 0 &&
				    $8.src_os) {
					yyerror("OS fingerprinting requires "
					     "the SYN TCP flag (flags S/SA)");
a1358 1
#endif
a1417 9
				if (r.rpool.opts == PF_POOL_NONE && (
				    $5.host->next != NULL ||
				    $5.host->addr.type == PF_ADDR_TABLE))
					r.rpool.opts = PF_POOL_ROUNDROBIN;
				if (r.rpool.opts != PF_POOL_ROUNDROBIN)
					if (disallow_table($5.host, "tables "
					    "are only supported in round-robin "
					    "routing pools"))
						YYERROR;
d1419 3
d1449 1
a1449 1
			expand_rule(&r, $4, $5.host, $7, $8.src_os,
a1562 4
			if ($4 > 255) {
				yyerror("illegal ttl value %d", $4);
				YYERROR;
			}
a1712 1
			$$.src_os = NULL;
d1714 1
a1714 1
		| from os to			{
d1716 1
a1716 24
			$$.src_os = $2;
			$$.dst = $3;
		}
		;

os		: /* empty */			{ $$ = NULL; }
		| OS xos			{ $$ = $2; }
		| OS '{' os_list '}'		{ $$ = $3; }
		;

xos		: STRING {
			$$ = calloc(1, sizeof(struct node_os));
			if ($$ == NULL)
				err(1, "os: calloc");
			$$->os = $1;
			$$->tail = $$;
		}
		;

os_list		: xos				{ $$ = $1; }
		| os_list comma xos		{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
d2687 2
a2688 2
			    $5.src_os, $5.src.host, $5.src.port, $5.dst.host,
			    $5.dst.port, 0, 0, 0);
d3535 1
a3535 1
				/* found ourself in queues */
a3580 6
					if (!strcmp(a->qname, nq->queue)) {
						yyerror("queue cannot have "
						    "itself as child");
						errs++;
						continue;
					}
d3645 4
a3648 4
    struct node_proto *protos, struct node_os *src_oses,
    struct node_host *src_hosts, struct node_port *src_ports,
    struct node_host *dst_hosts, struct node_port *dst_ports,
    struct node_uid *uids, struct node_gid *gids, struct node_icmp *icmp_types)
a3667 1
	LOOP_THROUGH(struct node_os, src_os, src_oses,
a3739 11
		if (src_os && src_os->os) {
			r->os_fingerprint = pfctl_get_fingerprint(src_os->os);
			if ((pf->opts & PF_OPT_VERBOSE2) &&
			    r->os_fingerprint == PF_OSFP_NOMATCH)
				fprintf(stderr,
				    "warning: unknown '%s' OS fingerprint\n",
				    src_os->os);
		} else {
			r->os_fingerprint = PF_OSFP_ANY;
		}

d3764 1
a3764 1
	))))))))));
a3769 1
	FREE_LIST(struct node_os, src_oses);
a3826 1
		{ "fingerprints",	FINGERPRINTS},
a3856 1
		{ "os",			OS},
d4284 3
a4286 11
		struct node_host *n;

		/* only tables are ok without an address family */
		for(n = nh; n != NULL; n = n->next) {
			if(n->addr.type != PF_ADDR_TABLE) {
				yyerror("address family not given and "
				    "translation address expands to multiple "
				    "address families");
				return (1);
			}
		}
@


1.1.1.16
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.415 2003/09/01 15:07:40 henning Exp $	*/
d4376 2
a4377 2
		for (n = nh; n != NULL; n = n->next) {
			if (n->addr.type != PF_ADDR_TABLE) {
@


1.1.1.17
log
@cvs is playing games with me.

@@@@@@ CONSIDER THE TREE LOCKED NOW @@@@@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.416 2003/09/26 21:44:09 cedric Exp $	*/
d4474 1
a4474 1
pfctl_load_anchors(int dev, int opts, struct pfr_buffer *trans)
d4483 1
a4483 1
		    la->rulesetname, trans) == -1)
@


1.1.1.18
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.431 2003/12/19 16:12:43 henning Exp $	*/
a5 2
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 * Copyright (c) 2002,2003 Henning Brauer. All rights reserved.
d115 1
a115 4
enum	{ PF_STATE_OPT_MAX, PF_STATE_OPT_NOSYNC, PF_STATE_OPT_SRCTRACK,
	  PF_STATE_OPT_MAX_SRC_STATES, PF_STATE_OPT_MAX_SRC_NODES,
	  PF_STATE_OPT_TIMEOUT };

a119 3
		u_int32_t	 max_src_states;
		u_int32_t	 max_src_nodes;
		u_int8_t	 src_track;
a153 1
#define FOM_SRCTRACK	0x10
a213 12
struct pool_opts {
	int			 marker;
#define POM_TYPE		0x01
#define POM_STICKYADDRESS	0x02
	u_int8_t		 opts;
	int			 type;
	int			 staticport;
	struct pf_poolhashkey	*key;

} pool_opts;


d224 7
a230 8
void	expand_label_str(char *, size_t, const char *, const char *);
void	expand_label_if(const char *, char *, size_t, const char *);
void	expand_label_addr(const char *, char *, size_t, u_int8_t,
	    struct node_host *);
void	expand_label_port(const char *, char *, size_t, struct node_port *);
void	expand_label_proto(const char *, char *, size_t, u_int8_t);
void	expand_label_nr(const char *, char *, size_t);
void	expand_label(char *, size_t, const char *, u_int8_t, struct node_host *,
d310 1
d323 4
a333 1
		struct pf_poolhashkey	*hashkey;
a342 1
		struct pool_opts	 pool_opts;
d369 1
a369 1
%token	REQUIREORDER SYNPROXY FINGERPRINTS NOSYNC DEBUG HOSTID
a374 1
%token	STICKYADDRESS MAXSRCSTATES MAXSRCNODES SOURCETRACK GLOBAL RULE
d381 2
a382 2
%type	<v.i>			no dir log af fragcache sourcetrack
%type	<v.i>			unaryop
d386 1
a418 1
%type	<v.pool_opts>		pool_opts pool_opt pool_opts_l
a461 10
		| SET HOSTID number {
			if ($3 == 0) {
				yyerror("hostid must be non-zero");
				YYERROR;
			}
			if (pfctl_set_hostid(pf, $3) != 0) {
				yyerror("error setting loginterface %08x", $3);
				YYERROR;
			}
		}
a491 8
		| SET DEBUG STRING {
			if (check_rulestate(PFCTL_STATE_OPTION))
				YYERROR;
			if (pfctl_set_debug(pf, $3) != 0) {
				yyerror("error setting debuglevel %s", $3);
				YYERROR;
			}
		}
d811 2
a812 3
				if (h != NULL)
					expand_rule(&r, j, NULL, NULL, NULL, h,
					    NULL, NULL, NULL, NULL, NULL, NULL);
a870 1
		;
a1133 1
		;
a1321 1
			int			 srctrack = 0;
a1409 50
				case PF_STATE_OPT_NOSYNC:
					if (r.rule_flag & PFRULE_NOSYNC) {
						yyerror("state option 'sync' "
						    "multiple definitions");
						YYERROR;
					}
					r.rule_flag |= PFRULE_NOSYNC;
					break;
				case PF_STATE_OPT_SRCTRACK:
					if (srctrack) {
						yyerror("state option "
						    "'source-track' "
						    "multiple definitons");
						YYERROR;
					}
					srctrack = 1;
					r.rule_flag |=  o->data.src_track;
					break;
				case PF_STATE_OPT_MAX_SRC_STATES:
					if (r.max_src_states) {
						yyerror("state option "
						    "'max-src-states' "
						    "multiple definitions");
						YYERROR;
					}
					if (o->data.max_src_nodes == 0) {
						yyerror("'max-src-states' must "
						    "be > 0");
						YYERROR;
					}
					r.max_src_states =
					    o->data.max_src_states;
					r.rule_flag |= PFRULE_SRCTRACK;
					break;
				case PF_STATE_OPT_MAX_SRC_NODES:
					if (r.max_src_nodes) {
						yyerror("state option "
						    "'max-src-nodes' "
						    "multiple definitions");
						YYERROR;
					}
					if (o->data.max_src_nodes == 0) {
						yyerror("'max-src-nodes' must "
						    "be > 0");
						YYERROR;
					}
					r.max_src_nodes =
					    o->data.max_src_nodes;
					r.rule_flag |= PFRULE_SRCTRACK;
					break;
d1452 2
a1453 2
				if ((r.rpool.opts & PF_POOL_TYPEMASK) ==
				    PF_POOL_NONE && ($5.host->next != NULL ||
d1456 4
a1459 4
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
				    disallow_table($5.host, "tables are only "
				    "supported in round-robin routing pools"))
d1462 1
a1462 1
					if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
a1704 1
		;
a2364 11
sourcetrack	: SOURCETRACK {
			$$ = PFRULE_SRCTRACK;
		}
		| SOURCETRACK GLOBAL {
			$$ = PFRULE_SRCTRACK;
		}
		| SOURCETRACK RULE {
			$$ = PFRULE_SRCTRACK ^ PFRULE_RULESRCTRACK;
		}
		;

d2369 1
a2369 1
		| MODULATE STATE state_opt_spec {
a2399 35
		| NOSYNC				{
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_NOSYNC;
			$$->next = NULL;
			$$->tail = $$;
		}
		| MAXSRCSTATES number			{
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX_SRC_STATES;
			$$->data.max_src_states = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		| MAXSRCNODES number			{
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX_SRC_NODES;
			$$->data.max_src_nodes = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		| sourcetrack {
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_SRCTRACK;
			$$->data.src_track = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
d2551 4
a2554 6
pool_opts	:	{ bzero(&pool_opts, sizeof pool_opts); }
		   pool_opts_l
			{ $$ = pool_opts; }
		| /* empty */	{
			bzero(&pool_opts, sizeof pool_opts);
			$$ = pool_opts;
d2556 4
a2559 12
		;

pool_opts_l	: pool_opts_l pool_opt
		| pool_opt
		;

pool_opt	: BITMASK	{
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type =  PF_POOL_BITMASK;
d2561 4
a2564 6
		| RANDOM	{
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type = PF_POOL_RANDOM;
d2566 4
a2569 7
		| SOURCEHASH hashkey {
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type = PF_POOL_SRCHASH;
			pool_opts.key = $2;
d2571 4
a2574 21
		| ROUNDROBIN	{
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type = PF_POOL_ROUNDROBIN;
		}
		| STATICPORT	{
			if (pool_opts.staticport) {
				yyerror("static-port cannot be redefined");
				YYERROR;
			}
			pool_opts.staticport = 1;
		}
		| STICKYADDRESS	{
			if (filter_opts.marker & POM_STICKYADDRESS) {
				yyerror("sticky-address cannot be redefined");
				YYERROR;
			}
			pool_opts.marker |= POM_STICKYADDRESS;
			pool_opts.opts |= PF_POOL_STICKYADDR;
d2576 4
d2621 2
a2622 1
natrule		: nataction interface af proto fromto tag redirpool pool_opts
d2704 1
a2704 3
				if ((r.rpool.opts & PF_POOL_TYPEMASK) ==
				    PF_POOL_NONE && ($7->host->next != NULL ||
				    $7->host->addr.type == PF_ADDR_TABLE))
d2706 4
a2709 4
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
				    disallow_table($7->host, "tables are only "
				    "supported in round-robin redirction pools"))
d2711 2
a2712 2
				if ($7->host->next != NULL) {
					if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
d2735 1
a2735 4
			 if ($8.opts)
				r.rpool.opts |= $8.opts;

			if ($8.staticport) {
a2900 1
		;
d2962 1
a2962 1
		| ROUTETO routespec pool_opts {
d2965 1
a2965 1
			$$.pool_opts = $3.type | $3.opts;
d2969 1
a2969 1
		| REPLYTO routespec pool_opts {
d2972 1
a2972 1
			$$.pool_opts = $3.type | $3.opts;
d2976 1
a2976 1
		| DUPTO routespec pool_opts {
d2979 1
a2979 1
			$$.pool_opts = $3.type | $3.opts;
a2992 1

a3008 1
		;
a3024 1
		;
d3099 4
d3162 4
d3204 5
d3309 1
a3309 1
expand_label_str(char *label, size_t len, const char *srch, const char *repl)
d3311 1
a3311 1
	char *tmp;
a3313 2
	if ((tmp = calloc(1, len)) == NULL)
		err(1, "expand_label_str: calloc");
d3317 3
a3319 3
		if ((strlcat(tmp, p, len) >= len) ||
		    (strlcat(tmp, repl, len) >= len))
			errx(1, "expand_label: label too long");
d3323 3
a3325 4
	if (strlcat(tmp, p, len) >= len)
		errx(1, "expand_label: label too long");
	strlcpy(label, tmp, len);	/* always fits */
	free(tmp);
d3329 1
a3329 1
expand_label_if(const char *name, char *label, size_t len, const char *ifname)
d3333 1
a3333 1
			expand_label_str(label, len, name, "any");
d3335 1
a3335 1
			expand_label_str(label, len, name, ifname);
d3340 1
a3340 1
expand_label_addr(const char *name, char *label, size_t len, sa_family_t af,
d3386 1
a3386 1
			expand_label_str(label, len, name, tmp_not);
d3388 1
a3388 1
			expand_label_str(label, len, name, tmp);
d3393 1
a3393 2
expand_label_port(const char *name, char *label, size_t len,
    struct node_port *port)
d3418 1
a3418 1
		expand_label_str(label, len, name, op);
d3423 1
a3423 1
expand_label_proto(const char *name, char *label, size_t len, u_int8_t proto)
d3431 1
a3431 1
			expand_label_str(label, len, name, pe->p_name);
d3434 1
a3434 1
			expand_label_str(label, len, name, n);
d3440 1
a3440 1
expand_label_nr(const char *name, char *label, size_t len)
d3446 1
a3446 1
		expand_label_str(label, len, name, n);
d3451 1
a3451 1
expand_label(char *label, size_t len, const char *ifname, sa_family_t af,
d3456 7
a3462 7
	expand_label_if("$if", label, len, ifname);
	expand_label_addr("$srcaddr", label, len, af, src_host);
	expand_label_addr("$dstaddr", label, len, af, dst_host);
	expand_label_port("$srcport", label, len, src_port);
	expand_label_port("$dstport", label, len, dst_port);
	expand_label_proto("$proto", label, len, proto);
	expand_label_nr("$nr", label, len);
d3776 2
a3777 7
		expand_label(r->label, PF_RULE_LABEL_SIZE, r->ifname, r->af,
		    src_host, src_port, dst_host, dst_port, proto->proto);
		expand_label(r->tagname, PF_TAG_NAME_SIZE, r->ifname, r->af,
		    src_host, src_port, dst_host, dst_port, proto->proto);
		expand_label(r->match_tagname, PF_TAG_NAME_SIZE, r->ifname,
		    r->af, src_host, src_port, dst_host, dst_port,
		    proto->proto);
a3908 1
		{ "debug",		DEBUG},
a3918 1
		{ "global",		GLOBAL},
a3920 1
		{ "hostid",		HOSTID},
a3935 2
		{ "max-src-nodes",	MAXSRCNODES},
		{ "max-src-states",	MAXSRCSTATES},
a3942 1
		{ "no-sync",		NOSYNC},
a3968 1
		{ "rule",		RULE},
a3971 1
		{ "source-track",	SOURCETRACK},
a3973 1
		{ "sticky-address",	STICKYADDRESS},
@


1.1.1.19
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.434 2003/12/31 22:14:41 deraadt Exp $	*/
a71 1
static int		 default_statelock;
d119 1
a119 1
	  PF_STATE_OPT_STATELOCK, PF_STATE_OPT_TIMEOUT };
a127 1
		u_int32_t	 statelock;
a238 1
int	disallow_alias(struct node_host *, const char *);
a378 4
#define DYNIF_MULTIADDR(addr) ((addr).type == PF_ADDR_DYNIFTL && \
	(!((addr).iflags & PFI_AFLAG_NOALIAS) ||		 \
	!isdigit((addr).v.ifname[strlen((addr).v.ifname)-1])))

d395 1
a395 1
%token	TAGGED TAG IFBOUND GRBOUND FLOATING STATEPOLICY
d402 1
a402 1
%type	<v.i>			unaryop statelock
d473 1
a473 1
			if ((ifa_exists($3, 0) == NULL) && strcmp($3, "none")) {
a521 16
		| SET STATEPOLICY statelock {
			if (pf->opts & PF_OPT_VERBOSE)
				switch($3) {
				case 0:
					printf("set state-policy floating\n");
					break;
				case PFRULE_IFBOUND:
					printf("set state-policy if-bound\n");
					break;
				case PFRULE_GRBOUND:
					printf("set state-policy "
					    "group-bound\n");
					break;
				}
			default_statelock = $3;
		}
d709 7
d847 1
a847 1
				h = ifa_lookup(j->ifname, PFI_AFLAG_NETWORK);
d863 2
a864 1
					h = ifa_lookup(i->ifname, 0);
a1363 1
			int			 statelock = 0;
a1501 9
				case PF_STATE_OPT_STATELOCK:
                                        if (statelock) {
                                                yyerror("state locking option: "
                                                    "multiple definitons");
                                                YYERROR;
                                        }
                                        statelock = 1;
                                        r.rule_flag |= o->data.statelock;
					break;
a1515 2
			if (r.keep_state && !statelock)
				r.rule_flag |= default_statelock;
d1546 2
a1547 3
				    $5.host->addr.type == PF_ADDR_TABLE ||
				    DYNIF_MULTIADDR($5.host->addr)))
					r.rpool.opts |= PF_POOL_ROUNDROBIN;
d1552 1
a1552 7
					YYERROR;
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
				    disallow_alias($5.host, "interface (%s) "
				    "is only supported in round-robin "
				    "routing pools"))
					YYERROR;
d1774 1
a1774 1
			if ((n = ifa_exists($1, 1)) == NULL) {
d2008 1
a2008 25
			int	 flags = 0;
			char	*p;

			while ((p = strrchr($2, ':')) != NULL) {
				if (!strcmp(p+1, "network"))
					flags |= PFI_AFLAG_NETWORK;
				else if (!strcmp(p+1, "broadcast"))
					flags |= PFI_AFLAG_BROADCAST;
				else if (!strcmp(p+1, "peer"))
					flags |= PFI_AFLAG_PEER;
				else if (!strcmp(p+1, "0"))
					flags |= PFI_AFLAG_NOALIAS;
				else {
					yyerror("interface %s has bad modifier",
					    $2);
					YYERROR;
				}
				*p = '\0';
			}
			if (flags & (flags - 1) & PFI_AFLAG_MODEMASK) {
				yyerror("illegal combination of "
				    "interface modifiers");
				YYERROR;
			}
			if (ifa_exists($2, 1) == NULL && strcmp($2, "self")) {
a2017 1
			$$->addr.iflags = flags;
a2468 11
statelock	: IFBOUND {
			$$ = PFRULE_IFBOUND;
		}
		| GRBOUND {
			$$ = PFRULE_GRBOUND;
		}
		| FLOATING {
			$$ = 0;
		}
		;

a2538 9
		| statelock {
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_STATELOCK;
			$$->data.statelock = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
d2872 1
a2872 2
				    $7->host->addr.type == PF_ADDR_TABLE ||
				    DYNIF_MULTIADDR($7->host->addr)))
d2877 2
a2878 9
				    "supported in round-robin redirection "
				    "pools"))
					YYERROR;
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
				    disallow_alias($7->host, "interface (%s) "
				    "is only supported in round-robin "
				    "redirection pools"))
					YYERROR;
d2887 9
a2981 4
			if ($8 != NULL && disallow_alias($8, "invalid use of "
			    "interface (%s) as the source address of a binat "
			    "rule"))
				YYERROR;
a2985 4
			if ($12 != NULL && $12->host != NULL && disallow_alias(
			    $12->host, "invalid use of interface (%s) as the "
			    "redirect address of a binat rule"))
				YYERROR;
d3075 2
d3082 1
a3082 1
			if (ifa_exists($$->ifname, 0) == NULL) {
d3092 2
d3097 1
a3097 1
			if (ifa_exists($$->ifname, 0) == NULL) {
a3237 11
disallow_alias(struct node_host *h, const char *fmt)
{
	for (; h != NULL; h = h->next)
		if (DYNIF_MULTIADDR(h->addr)) {
			yyerror(fmt, h->addr.v.tblname);
			return (1);
		}
	return (0);
}

int
d3300 6
d3330 14
a3343 1
	return (0);	/* yeah! */
d3350 1
d3371 17
a4087 1
		{ "floating",		FLOATING},
a4092 1
		{ "group-bound",	GRBOUND},
a4096 1
		{ "if-bound",		IFBOUND},
a4151 1
		{ "state-policy",	STATEPOLICY},
d4395 1
a4395 1
	struct sym	*sym, *next;
d4411 1
a4411 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entries);
a4417 1
		free(sym);
d4555 1
a4555 1
		/* tables and dyniftl are ok without an address family */
d4557 1
a4557 2
			if (n->addr.type != PF_ADDR_TABLE &&
			    n->addr.type != PF_ADDR_DYNIFTL) {
@


1.1.1.20
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.436 2004/01/05 22:04:24 henning Exp $	*/
d1410 1
a1410 1
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
d1417 1
a1417 1
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
d2890 1
a2890 1
				if (strlcpy(r.tagname, $6, PF_TAG_NAME_SIZE) >=
a3041 1
				binat.ifnot = $4->not;
d3046 1
a3046 1
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
@


1.1.1.21
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.452 2004/04/24 23:22:54 cedric Exp $	*/
a51 1
#include <math.h>
a52 1
#include <limits.h>
d119 2
a120 4
	    PF_STATE_OPT_MAX_SRC_STATES, PF_STATE_OPT_MAX_SRC_NODES,
	    PF_STATE_OPT_STATELOCK, PF_STATE_OPT_TIMEOUT };

enum	{ PF_SRCTRACK_NONE, PF_SRCTRACK, PF_SRCTRACK_GLOBAL, PF_SRCTRACK_RULE };
a174 1
	u_int32_t		 prob;
d296 2
a297 3
TAILQ_HEAD(loadanchorshead, loadanchors)
    loadanchorshead = TAILQ_HEAD_INITIALIZER(loadanchorshead);

d397 1
a397 1
%token	BITMASK RANDOM SOURCEHASH ROUNDROBIN STATICPORT PROBABILITY
d432 1
a432 1
%type	<v.interface>		antispoof_ifspc antispoof_iflst antispoof_if
d466 1
a466 2
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
a467 1
			}
a469 1
				free($3);
a471 1
			free ($3);
d478 1
a478 2
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
a479 1
			}
a481 1
				free($3);
a485 1
				free($3);
a487 1
			free($3);
d495 1
a495 1
				yyerror("error setting hostid %08x", $3);
d522 1
a522 2
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
a523 1
			}
a525 1
				free($3);
a527 1
			free($3);
d531 1
a531 1
				switch ($3) {
d546 1
a546 2
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
a547 1
			}
a549 1
				free($3);
a551 1
			free($3);
a568 2
			free($1);
			free($3);
d572 1
a572 1
anchorrule	: ANCHOR string	dir interface af proto fromto filter_opts {
d575 1
a575 2
			if (check_rulestate(PFCTL_STATE_FILTER)) {
				free($2);
a576 1
			}
a580 10
			r.prob = $8.prob;

			if ($8.match_tag)
				if (strlcpy(r.match_tagname, $8.match_tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			r.match_tag_not = $8.match_tag_not;
d592 1
a592 2
			if (check_rulestate(PFCTL_STATE_NAT)) {
				free($2);
a593 1
			}
a595 1
			free($2);
d609 1
a609 2
			if (check_rulestate(PFCTL_STATE_NAT)) {
				free($2);
a610 1
			}
a612 1
			free($2);
d647 1
a647 2
			if (check_rulestate(PFCTL_STATE_NAT)) {
				free($2);
a648 1
			}
a650 1
			free($2);
d682 1
a682 1
			if (*t == '\0' || $3 == NULL || *$3 == '\0') {
a683 1
				free(t);
a688 1
				free(t);
a693 1
				free(t);
d761 1
a761 1
		    scrub_opts_l
d813 1
a813 2
			if (strcasecmp($2, "tcp") != 0) {
				free($2);
a814 2
			}
			free($2);
d837 1
a837 1
			struct node_host	*h = NULL, *hh;
d863 1
a863 23
				if (i->dynamic) {
					h = calloc(1, sizeof(*h));
					if (h == NULL)
						err(1, "address: calloc");
					h->addr.type = PF_ADDR_DYNIFTL;
					set_ipmask(h, 128);
					if (strlcpy(h->addr.v.ifname, i->ifname,
					    sizeof(h->addr.v.ifname)) >=
					    sizeof(h->addr.v.ifname)) {
						yyerror(
						    "interface name too long");
						YYERROR;
					}
					hh = malloc(sizeof(*hh));
					if (hh == NULL)
						 err(1, "address: malloc");
					bcopy(h, hh, sizeof(*hh));
					h->addr.iflags = PFI_AFLAG_NETWORK;
				} else {
					h = ifa_lookup(j->ifname,
					    PFI_AFLAG_NETWORK);
					hh = NULL;
				}
d879 5
a883 10
					if (hh != NULL)
						h = hh;
					else
						h = ifa_lookup(i->ifname, 0);
					if (h != NULL)
						expand_rule(&r, NULL, NULL,
						    NULL, NULL, h, NULL, NULL,
						    NULL, NULL, NULL, NULL);
				} else
					free(hh);
d889 1
a889 1
antispoof_ifspc	: FOR antispoof_if		{ $$ = $2; }
d893 2
a894 2
antispoof_iflst	: antispoof_if				{ $$ = $1; }
		| antispoof_iflst comma antispoof_if	{
a900 7
antispoof_if  : if_item				{ $$ = $1; }
		| '(' if_item ')'		{
			$2->dynamic = 1;
			$$ = $2;
		}
		;

d902 1
a902 1
		    antispoof_opts_l
a933 1
				free($3);
d937 1
a937 2
				if (process_tabledef($3, &$5)) {
					free($3);
a938 2
				}
			free($3);
d948 1
a948 1
				free(ti);
d957 1
a957 1
		    table_opts_l
d976 1
a976 2
			else {
				free($1);
a977 2
			}
			free($1);
d985 1
a985 1
				switch (n->addr.type) {
d1051 1
a1051 2
			if (check_rulestate(PFCTL_STATE_QUEUE)) {
				free($2);
a1052 1
			}
a1059 1
				free($2);
a1061 1
			free($2);
d1088 1
a1088 1
		    queue_opts_l
a1177 1
						free($1);
a1183 1
					free($1);
a1186 1
			free($1);
a1234 1
				free($1);
a1236 1
			free($1);
a1254 1
				free($1);
a1256 1
			free($1);
d1264 1
a1264 1
		    hfscopts_list				{
a1337 1
				free($1);
a1339 1
			free($1);
d1362 1
a1364 2
				free($1);
				free($$);
a1366 1
			free($1);
d1373 1
a1373 1
		    filter_opts
a1405 1
			r.prob = $9.prob;
d1447 1
a1447 1
					    "the SYN TCP flag (flags S/SA)");
d1480 1
a1480 1
						    "multiple definitions");
d1483 2
a1484 1
					srctrack =  o->data.src_track;
d1516 1
a1516 2
					r.rule_flag |= PFRULE_SRCTRACK |
					    PFRULE_RULESRCTRACK;
d1519 7
a1525 7
					if (statelock) {
						yyerror("state locking option: "
						    "multiple definitions");
						YYERROR;
					}
					statelock = 1;
					r.rule_flag |= o->data.statelock;
a1540 12
			if (srctrack) {
				if (srctrack == PF_SRCTRACK_GLOBAL &&
				    r.max_src_nodes) {
					yyerror("'max-src-nodes' is "
					    "incompatible with "
					    "'source-track global'");
					YYERROR;
				}
				r.rule_flag |= PFRULE_SRCTRACK;
				if (srctrack == PF_SRCTRACK_RULE)
					r.rule_flag |= PFRULE_RULESRCTRACK;
			}
d1622 1
a1622 1
		    filter_opts_l
a1706 20
		| PROBABILITY STRING			{
			char	*e;
			double	 p = strtod($2, &e);

			if (*e == '%') {
				p *= 0.01;
				e++;
			}
			if (*e) {
				yyerror("invalid probability: %s", $2);
				YYERROR;
			}
			p = floor(p * (UINT_MAX+1.0) + 0.5);
			if (p < 1.0 || p >= (UINT_MAX+1.0)) {
				yyerror("invalid probability: %s", $2);
				YYERROR;
			}
			filter_opts.prob = (u_int32_t)p;
			free($2);
		}
d1749 1
a1749 2
			if (!($$.w = parseicmpspec($3, AF_INET))) {
				free($3);
a1750 2
			}
			free($3);
d1756 1
a1756 2
			if (!($$.w2 = parseicmpspec($3, AF_INET6))) {
				free($3);
a1757 2
			}
			free($3);
d1761 3
a1763 4
			if (!($$.w = parseicmpspec($3, AF_INET)) ||
			    !($$.w2 = parseicmpspec($5, AF_INET6))) {
				free($3);
				free($5);
a1764 3
			}
			free($3);
			free($5);
a1809 1
				free($1);
a1816 1
				free($1);
a1820 1
			free($1);
a1852 1
					free($1);
a1861 1
					free($1);
a1865 1
			free($1);
a1985 1
				free($1);
a1988 1
			free($1);
a1995 1
			free($1);
d2014 1
a2014 2
				yyerror("table name '%s' too long", $2);
				free($2);
a2024 1
			free($2);
a2034 1
				free($1);
a2037 1
			free($1);
d2043 1
a2043 1
			char	*p, *op;
a2044 1
			op = $2;
a2056 1
					free(op);
a2061 1
				free(op);
a2067 1
				free(op);
a2079 1
				free(op);
a2083 1
			free(op);
a2153 1
						free($1);
a2164 1
						free($1);
d2176 1
a2176 2
				    (port[1] = getservice(p)) == -1) {
					free($1);
a2177 1
				}
a2181 1
			free($1);
a2249 1
						free($1);
a2255 1
					free($1);
a2260 1
			free($1);
a2328 1
						free($1);
a2335 1
					free($1);
a2339 1
			free($1);
a2347 1
				free($1);
a2349 1
			free($1);
a2395 1
					free($3);
a2402 1
					free($3);
a2406 1
			free($3);
a2435 1
					free($3);
a2441 1
					free($3);
a2445 1
			free($3);
a2463 1
					free($1);
a2470 1
					free($1);
a2474 1
			free($1);
a2484 1
					free($1);
a2491 1
					free($1);
a2495 1
			free($1);
a2511 1
				free($2);
a2513 1
			free($2);
d2517 9
a2525 3
sourcetrack	: SOURCETRACK		{ $$ = PF_SRCTRACK; }
		| SOURCETRACK GLOBAL	{ $$ = PF_SRCTRACK_GLOBAL; }
		| SOURCETRACK RULE	{ $$ = PF_SRCTRACK_RULE; }
a2625 1
				free($1);
a2629 1
				free($1);
a2631 1
			free($1);
d2644 2
a2645 1
			$$ = $2;
d2650 2
a2651 1
			$$.qname = $2;
d2654 2
a2655 1
			$$.qname = $3;
d2658 3
a2660 2
			$$.qname = $3;
			$$.pqname = $5;
d2672 1
a2672 2
				if (($$.a = getservice($1)) == -1) {
					free($1);
a2673 1
				}
d2677 1
a2677 2
				if (($$.a = getservice($1)) == -1) {
					free($1);
a2678 1
				}
d2684 1
a2684 2
				    ($$.b = getservice(p)) == -1) {
					free($1);
a2685 1
				}
a2689 1
			free($1);
a2735 1
					free($1);
a2747 1
					free($1);
a2765 1
			free($1);
d2770 1
a2770 1
		    pool_opts_l
d2926 2
a2927 4
						    (ntohs(
						    $5.dst.port->port[1]) -
						    ntohs(
						    $5.dst.port->port[0]));
d2933 1
a2933 2
					r.rpool.proxy_port[1] =
					    ntohs($7->rport.b);
d3011 1
a3011 1
		    redirection
d3165 2
a3166 1
			$$->ifname = $1;
a3169 2
				free($1);
				free($$);
d3178 2
a3179 1
			$$->ifname = $2;
d3242 1
a3242 2
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($1);
a3243 1
			}
a3245 1
				free($1);
d3248 1
a3248 1
			free($1);
d3258 1
a3258 2
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($1);
a3259 1
			}
a3261 1
				free($1);
a3263 1
			free($1);
d3279 1
a3279 2
			else {
				free($1);
a3280 2
			}
			free($1);
d3384 6
a3402 4
	if (r->max_src_nodes && !(r->rule_flag & PFRULE_RULESRCTRACK)) {
		yyerror("max-src-nodes requires 'source-track rule'");
		problems++;
	}
d3408 1
a3408 1
	    r->action == PF_PASS && !r->anchorname[0]) {
d3594 1
a3594 1
						    "%s/%d", a, bits);
a3950 2
	char			 tagname[PF_TAG_NAME_SIZE];
	char			 match_tagname[PF_TAG_NAME_SIZE];
d3953 1
a3953 1
	u_int8_t		 flags, flagset, keep_state;
a3956 5
	if (strlcpy(tagname, r->tagname, sizeof(tagname)) >= sizeof(tagname))
		errx(1, "expand_rule: strlcpy");
	if (strlcpy(match_tagname, r->match_tagname, sizeof(match_tagname)) >=
	    sizeof(match_tagname))
		errx(1, "expand_rule: strlcpy");
a3958 1
	keep_state = r->keep_state;
d3979 1
a3979 1
		    (src_host->ifindex && *interface->ifname &&
d3981 1
a3981 1
		    (dst_host->ifindex && *interface->ifname &&
d3989 1
a3989 3
		if (*interface->ifname)
			memcpy(r->ifname, interface->ifname, sizeof(r->ifname));
		else if (if_indextoname(src_host->ifindex, ifname))
d3994 1
a3994 1
			memset(r->ifname, '\0', sizeof(r->ifname));
a3998 6
		if (strlcpy(r->tagname, tagname, sizeof(r->tagname)) >=
		    sizeof(r->tagname))
			errx(1, "expand_rule: strlcpy");
		if (strlcpy(r->match_tagname, match_tagname,
		    sizeof(r->match_tagname)) >= sizeof(r->match_tagname))
			errx(1, "expand_rule: strlcpy");
a4030 7
		if ((keep_state == PF_STATE_MODULATE ||
		    keep_state == PF_STATE_SYNPROXY) &&
		    r->proto && r->proto != IPPROTO_TCP)
			r->keep_state = PF_STATE_NORMAL;
		else
			r->keep_state = keep_state;

a4187 1
		{ "probability",	PROBABILITY},
d4438 4
a4441 3
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
@


