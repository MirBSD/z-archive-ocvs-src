head	1.3;
access;
symbols
	tg-mergetmp-mirosx-1:1.3
	tg-mergefixes-1-branch:1.3.0.8
	tg-mergefixes-1-base:1.3
	MIROS_X:1.3.0.6
	MIROS_X_BASE:1.3
	tg-mergetmp-3:1.3
	MIRBSD_XP_MIRPPC:1.3.0.4
	MIRBSD_XP_SPARC_BASE:1.3
	MIRBSD_XP_SPARC:1.3.0.2
	MIRBSD_7quater:1.1.1.15
	cvs-200405160640:1.1.1.18
	cvs-200401271800:1.1.1.17
	cvs-200401261630:1.1.1.17
	cvs-200401021645:1.1.1.17
	MIRBSD_7_ALPHA:1.1.1.15.0.6
	MIRBSD_7:1.1.1.15.0.4
	cvs-200312222040:1.1.1.16
	MIRBSD_7ter:1.1.1.15
	MIRBSD_7_DEV:1.1.1.15.0.2
	cvs-200310020700:1.1.1.15
	cvs-200309271030:1.1.1.15
	cvs-200309261655:1.1.1.14
	cvs-200309251530:1.1.1.14
	cvs-200308302005:1.1.1.14
	cvs-200308171200:1.1.1.13
	ctm-3496:1.1.1.13
	ctm-3449:1.1.1.12
	ctm-3437:1.1.1.12
	cvs-200307191805:1.1.1.12
	ctm-3425:1.1.1.12
	cvs-200307091500:1.1.1.11
	cvs-200307072125:1.1.1.11
	ctm-3389:1.1.1.11
	cvs-200307021520:1.1.1.10
	cvs-200306301805:1.1.1.10
	cvs-200306301405:1.1.1.9
	cvs-200306291430:1.1.1.8
	ctm-3341:1.1.1.7
	MIRBSD_5:1.1.1.6
	cvs-200306091240:1.1.1.6
	cvs-200306082100:1.1.1.6
	ctm-3316:1.1.1.6
	ctm-3272:1.1.1.5
	ctm-3264:1.1.1.4
	cvs-200305071630:1.1.1.4
	MIRBSD_4:1.1.1.3
	ctm-3203:1.1.1.3
	cvs-20030410-1130:1.1.1.3
	ctm-3155:1.1.1.2
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.05.27.16.43.37;	author tg;	state Stab;
branches;
next	1.2;

1.2
date	2004.01.10.04.56.58;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.48.40;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.48.40;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.03.29.19.42.15;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.04.10.14.44.41;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.07.17.43.43;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.21.19.02.55;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.06.05.17.31.29;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.06.19.12.42.52;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.06.29.17.27.31;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.06.30.14.12.02;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.06.30.18.16.35;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2003.07.06.15.40.12;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2003.07.18.13.42.44;	author tg;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2003.08.11.18.30.23;	author tg;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2003.08.30.23.01.34;	author tg;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2003.09.27.11.17.29;	author tg;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2003.12.22.21.10.52;	author tg;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2004.01.02.18.01.21;	author tg;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	2004.05.16.08.26.32;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Last piece of OpenBSD 3.5-current merge part I.

Things left:
* merge import in src/gnu/
* fix kernel build (it _is_ broken)

TOP 1 will be done with a _second_ import (easier).
TOP 2 will be done RSN.

----

Also, move RCS IDs to new-style MirOS ones, and fix the
SMM doc, and add output to newfs(8) saying if (!) or if
not (?) it read the random value out of the previous
superblock before making the fs.
@
text
@/*	$OpenBSD: pfctl.c,v 1.215 2004/05/05 23:16:03 frantzen Exp $ */

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2002,2003 Henning Brauer
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <net/if.h>
#include <netinet/in.h>
#include <net/pfvar.h>
#include <arpa/inet.h>
#include <altq/altq.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "pfctl_parser.h"
#include "pfctl.h"

void	 usage(void);
int	 pfctl_enable(int, int);
int	 pfctl_disable(int, int);
int	 pfctl_clear_stats(int, int);
int	 pfctl_clear_rules(int, int, char *, char *);
int	 pfctl_clear_nat(int, int, char *, char *);
int	 pfctl_clear_altq(int, int);
int	 pfctl_clear_src_nodes(int, int);
int	 pfctl_clear_states(int, const char *, int);
int	 pfctl_kill_states(int, const char *, int);
int	 pfctl_get_pool(int, struct pf_pool *, u_int32_t, u_int32_t, int,
	    char *, char *);
void	 pfctl_print_rule_counters(struct pf_rule *, int);
int	 pfctl_show_rules(int, int, int, char *, char *);
int	 pfctl_show_nat(int, int, char *, char *);
int	 pfctl_show_src_nodes(int, int);
int	 pfctl_show_states(int, const char *, int);
int	 pfctl_show_status(int, int);
int	 pfctl_show_timeouts(int, int);
int	 pfctl_show_limits(int, int);
int	 pfctl_debug(int, u_int32_t, int);
int	 pfctl_clear_rule_counters(int, int);
int	 pfctl_test_altqsupport(int, int);
int	 pfctl_show_anchors(int, int, char *);
const char	*pfctl_lookup_option(char *, const char **);

const char	*clearopt;
char		*rulesopt;
const char	*showopt;
const char	*debugopt;
char		*anchoropt;
char		*pf_device = "/dev/pf";
char		*ifaceopt;
char		*tableopt;
const char	*tblcmdopt;
int		 state_killers;
char		*state_kill[2];
int		 loadopt;
int		 altqsupport;

int		 dev = -1;
int		 first_title = 1;
int		 labels = 0;

const char	*infile;

static const struct {
	const char	*name;
	int		index;
} pf_limits[] = {
	{ "states",	PF_LIMIT_STATES },
	{ "src-nodes",	PF_LIMIT_SRC_NODES },
	{ "frags",	PF_LIMIT_FRAGS },
	{ NULL,		0 }
};

struct pf_hint {
	const char	*name;
	int		timeout;
};
static const struct pf_hint pf_hint_normal[] = {
	{ "tcp.first",		2 * 60 },
	{ "tcp.opening",	30 },
	{ "tcp.established",	24 * 60 * 60 },
	{ "tcp.closing",	15 * 60 },
	{ "tcp.finwait",	45 },
	{ "tcp.closed",		90 },
	{ "tcp.tsdiff",		30 },
	{ NULL,			0 }
};
static const struct pf_hint pf_hint_satellite[] = {
	{ "tcp.first",		3 * 60 },
	{ "tcp.opening",	30 + 5 },
	{ "tcp.established",	24 * 60 * 60 },
	{ "tcp.closing",	15 * 60 + 5 },
	{ "tcp.finwait",	45 + 5 },
	{ "tcp.closed",		90 + 5 },
	{ "tcp.tsdiff",		60 },
	{ NULL,			0 }
};
static const struct pf_hint pf_hint_conservative[] = {
	{ "tcp.first",		60 * 60 },
	{ "tcp.opening",	15 * 60 },
	{ "tcp.established",	5 * 24 * 60 * 60 },
	{ "tcp.closing",	60 * 60 },
	{ "tcp.finwait",	10 * 60 },
	{ "tcp.closed",		3 * 60 },
	{ "tcp.tsdiff",		60 },
	{ NULL,			0 }
};
static const struct pf_hint pf_hint_aggressive[] = {
	{ "tcp.first",		30 },
	{ "tcp.opening",	5 },
	{ "tcp.established",	5 * 60 * 60 },
	{ "tcp.closing",	60 },
	{ "tcp.finwait",	30 },
	{ "tcp.closed",		30 },
	{ "tcp.tsdiff",		10 },
	{ NULL,			0 }
};

static const struct {
	const char *name;
	const struct pf_hint *hint;
} pf_hints[] = {
	{ "normal",		pf_hint_normal },
	{ "satellite",		pf_hint_satellite },
	{ "high-latency",	pf_hint_satellite },
	{ "conservative",	pf_hint_conservative },
	{ "aggressive",		pf_hint_aggressive },
	{ NULL,			NULL }
};

static const char *clearopt_list[] = {
	"nat", "queue", "rules", "Sources",
	"state", "info", "Tables", "osfp", "all", NULL
};

static const char *showopt_list[] = {
	"nat", "queue", "rules", "Anchors", "Sources", "state", "info",
	"Interfaces", "labels", "timeouts", "memory", "Tables", "osfp",
	"all", NULL
};

static const char *tblcmdopt_list[] = {
	"kill", "flush", "add", "delete", "load", "replace", "show",
	"test", "zero", NULL
};

static const char *debugopt_list[] = {
	"none", "urgent", "misc", "loud", NULL
};


void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-AdeghNnOqRrvz] ", __progname);
	fprintf(stderr, "[-a anchor[:ruleset]] [-D macro=value]\n");
	fprintf(stderr, "             ");
	fprintf(stderr, "[-F modifier] [-f file] [-i interface] ");
	fprintf(stderr, "[-k host] [-p device]\n");
	fprintf(stderr, "             ");
	fprintf(stderr, "[-s modifier] [-T command [address ...]] ");
	fprintf(stderr, "[-t table] [-x level]\n");
	exit(1);
}

int
pfctl_enable(int dev, int opts)
{
	if (ioctl(dev, DIOCSTART)) {
		if (errno == EEXIST)
			errx(1, "pf already enabled");
		else
			err(1, "DIOCSTART");
	}
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "pf enabled\n");

	if (altqsupport && ioctl(dev, DIOCSTARTALTQ))
		if (errno != EEXIST)
			err(1, "DIOCSTARTALTQ");

	return (0);
}

int
pfctl_disable(int dev, int opts)
{
	if (ioctl(dev, DIOCSTOP)) {
		if (errno == ENOENT)
			errx(1, "pf not enabled");
		else
			err(1, "DIOCSTOP");
	}
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "pf disabled\n");

	if (altqsupport && ioctl(dev, DIOCSTOPALTQ))
			if (errno != ENOENT)
				err(1, "DIOCSTOPALTQ");

	return (0);
}

int
pfctl_clear_stats(int dev, int opts)
{
	if (ioctl(dev, DIOCCLRSTATUS))
		err(1, "DIOCCLRSTATUS");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "pf: statistics cleared\n");
	return (0);
}

int
pfctl_clear_rules(int dev, int opts, char *anchorname, char *rulesetname)
{
	struct pfr_buffer t;

	if (*anchorname && !*rulesetname) {
		struct pfioc_ruleset pr;
		int mnr, nr, r;

		memset(&pr, 0, sizeof(pr));
		memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
		if (ioctl(dev, DIOCGETRULESETS, &pr)) {
			if (errno == EINVAL)
				fprintf(stderr, "No rulesets in anchor '%s'.\n",
				    anchorname);
			else
				err(1, "DIOCGETRULESETS");
			return (-1);
		}
		mnr = pr.nr;
		for (nr = mnr - 1; nr >= 0; --nr) {
			pr.nr = nr;
			if (ioctl(dev, DIOCGETRULESET, &pr))
				err(1, "DIOCGETRULESET");
			r = pfctl_clear_rules(dev, opts | PF_OPT_QUIET,
			    anchorname, pr.name);
			if (r)
				return (r);
		}
		if ((opts & PF_OPT_QUIET) == 0)
			fprintf(stderr, "rules cleared\n");
		return (0);
	}
	memset(&t, 0, sizeof(t));
	t.pfrb_type = PFRB_TRANS;
	if (pfctl_add_trans(&t, PF_RULESET_SCRUB, anchorname, rulesetname) ||
	    pfctl_add_trans(&t, PF_RULESET_FILTER, anchorname, rulesetname) ||
	    pfctl_trans(dev, &t, DIOCXBEGIN, 0) ||
	    pfctl_trans(dev, &t, DIOCXCOMMIT, 0))
		err(1, "pfctl_clear_rules");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "rules cleared\n");
	return (0);
}

int
pfctl_clear_nat(int dev, int opts, char *anchorname, char *rulesetname)
{
	struct pfr_buffer t;

	if (*anchorname && !*rulesetname) {
		struct pfioc_ruleset pr;
		int mnr, nr, r;

		memset(&pr, 0, sizeof(pr));
		memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
		if (ioctl(dev, DIOCGETRULESETS, &pr)) {
			if (errno == EINVAL)
				fprintf(stderr, "No rulesets in anchor '%s'.\n",
				    anchorname);
			else
				err(1, "DIOCGETRULESETS");
			return (-1);
		}
		mnr = pr.nr;
		for (nr = mnr - 1; nr >= 0; --nr) {
			pr.nr = nr;
			if (ioctl(dev, DIOCGETRULESET, &pr))
				err(1, "DIOCGETRULESET");
			r = pfctl_clear_nat(dev, opts | PF_OPT_QUIET,
			    anchorname, pr.name);
			if (r)
				return (r);
		}
		if ((opts & PF_OPT_QUIET) == 0)
			fprintf(stderr, "nat cleared\n");
		return (0);
	}
	memset(&t, 0, sizeof(t));
	t.pfrb_type = PFRB_TRANS;
	if (pfctl_add_trans(&t, PF_RULESET_NAT, anchorname, rulesetname) ||
	    pfctl_add_trans(&t, PF_RULESET_BINAT, anchorname, rulesetname) ||
	    pfctl_add_trans(&t, PF_RULESET_RDR, anchorname, rulesetname) ||
	    pfctl_trans(dev, &t, DIOCXBEGIN, 0) ||
	    pfctl_trans(dev, &t, DIOCXCOMMIT, 0))
		err(1, "pfctl_clear_nat");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "nat cleared\n");
	return (0);
}

int
pfctl_clear_altq(int dev, int opts)
{
	struct pfr_buffer t;

	if (!altqsupport)
		return (-1);
	memset(&t, 0, sizeof(t));
	t.pfrb_type = PFRB_TRANS;
	if (pfctl_add_trans(&t, PF_RULESET_ALTQ, "", "") ||
	    pfctl_trans(dev, &t, DIOCXBEGIN, 0) ||
	    pfctl_trans(dev, &t, DIOCXCOMMIT, 0))
		err(1, "pfctl_clear_altq");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "altq cleared\n");
	return (0);
}

int
pfctl_clear_src_nodes(int dev, int opts)
{
	if (ioctl(dev, DIOCCLRSRCNODES))
		err(1, "DIOCCLRSRCNODES");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "source tracking entries cleared\n");
	return (0);
}

int
pfctl_clear_states(int dev, const char *iface, int opts)
{
	struct pfioc_state_kill psk;

	memset(&psk, 0, sizeof(psk));
	if (iface != NULL && strlcpy(psk.psk_ifname, iface,
	    sizeof(psk.psk_ifname)) >= sizeof(psk.psk_ifname))
		errx(1, "invalid interface: %s", iface);

	if (ioctl(dev, DIOCCLRSTATES, &psk))
		err(1, "DIOCCLRSTATES");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "%d states cleared\n", psk.psk_af);
	return (0);
}

int
pfctl_kill_states(int dev, const char *iface, int opts)
{
	struct pfioc_state_kill psk;
	struct addrinfo *res[2], *resp[2];
	struct sockaddr last_src, last_dst;
	int killed, sources, dests;
	int ret_ga;

	killed = sources = dests = 0;

	memset(&psk, 0, sizeof(psk));
	memset(&psk.psk_src.addr.v.a.mask, 0xff,
	    sizeof(psk.psk_src.addr.v.a.mask));
	memset(&last_src, 0xff, sizeof(last_src));
	memset(&last_dst, 0xff, sizeof(last_dst));
	if (iface != NULL && strlcpy(psk.psk_ifname, iface,
	    sizeof(psk.psk_ifname)) >= sizeof(psk.psk_ifname))
		errx(1, "invalid interface: %s", iface);

	if ((ret_ga = getaddrinfo(state_kill[0], NULL, NULL, &res[0]))) {
		errx(1, "getaddrinfo: %s", gai_strerror(ret_ga));
		/* NOTREACHED */
	}
	for (resp[0] = res[0]; resp[0]; resp[0] = resp[0]->ai_next) {
		if (resp[0]->ai_addr == NULL)
			continue;
		/* We get lots of duplicates.  Catch the easy ones */
		if (memcmp(&last_src, resp[0]->ai_addr, sizeof(last_src)) == 0)
			continue;
		last_src = *(struct sockaddr *)resp[0]->ai_addr;

		psk.psk_af = resp[0]->ai_family;
		sources++;

		if (psk.psk_af == AF_INET)
			psk.psk_src.addr.v.a.addr.v4 =
			    ((struct sockaddr_in *)resp[0]->ai_addr)->sin_addr;
		else if (psk.psk_af == AF_INET6)
			psk.psk_src.addr.v.a.addr.v6 =
			    ((struct sockaddr_in6 *)resp[0]->ai_addr)->
			    sin6_addr;
		else
			errx(1, "Unknown address family %d", psk.psk_af);

		if (state_killers > 1) {
			dests = 0;
			memset(&psk.psk_dst.addr.v.a.mask, 0xff,
			    sizeof(psk.psk_dst.addr.v.a.mask));
			memset(&last_dst, 0xff, sizeof(last_dst));
			if ((ret_ga = getaddrinfo(state_kill[1], NULL, NULL,
			    &res[1]))) {
				errx(1, "getaddrinfo: %s",
				    gai_strerror(ret_ga));
				/* NOTREACHED */
			}
			for (resp[1] = res[1]; resp[1];
			    resp[1] = resp[1]->ai_next) {
				if (resp[1]->ai_addr == NULL)
					continue;
				if (psk.psk_af != resp[1]->ai_family)
					continue;

				if (memcmp(&last_dst, resp[1]->ai_addr,
				    sizeof(last_dst)) == 0)
					continue;
				last_dst = *(struct sockaddr *)resp[1]->ai_addr;

				dests++;

				if (psk.psk_af == AF_INET)
					psk.psk_dst.addr.v.a.addr.v4 =
					    ((struct sockaddr_in *)resp[1]->
					    ai_addr)->sin_addr;
				else if (psk.psk_af == AF_INET6)
					psk.psk_dst.addr.v.a.addr.v6 =
					    ((struct sockaddr_in6 *)resp[1]->
					    ai_addr)->sin6_addr;
				else
					errx(1, "Unknown address family %d",
					    psk.psk_af);

				if (ioctl(dev, DIOCKILLSTATES, &psk))
					err(1, "DIOCKILLSTATES");
				killed += psk.psk_af;
				/* fixup psk.psk_af */
				psk.psk_af = resp[1]->ai_family;
			}
			freeaddrinfo(res[1]);
		} else {
			if (ioctl(dev, DIOCKILLSTATES, &psk))
				err(1, "DIOCKILLSTATES");
			killed += psk.psk_af;
			/* fixup psk.psk_af */
			psk.psk_af = res[0]->ai_family;
		}
	}

	freeaddrinfo(res[0]);

	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "killed %d states from %d sources and %d "
		    "destinations\n", killed, sources, dests);
	return (0);
}

int
pfctl_get_pool(int dev, struct pf_pool *pool, u_int32_t nr,
    u_int32_t ticket, int r_action, char *anchorname, char *rulesetname)
{
	struct pfioc_pooladdr pp;
	struct pf_pooladdr *pa;
	u_int32_t pnr, mpnr;

	memset(&pp, 0, sizeof(pp));
	memcpy(pp.anchor, anchorname, sizeof(pp.anchor));
	memcpy(pp.ruleset, rulesetname, sizeof(pp.ruleset));
	pp.r_action = r_action;
	pp.r_num = nr;
	pp.ticket = ticket;
	if (ioctl(dev, DIOCGETADDRS, &pp)) {
		warn("DIOCGETADDRS");
		return (-1);
	}
	mpnr = pp.nr;
	TAILQ_INIT(&pool->list);
	for (pnr = 0; pnr < mpnr; ++pnr) {
		pp.nr = pnr;
		if (ioctl(dev, DIOCGETADDR, &pp)) {
			warn("DIOCGETADDR");
			return (-1);
		}
		pa = calloc(1, sizeof(struct pf_pooladdr));
		if (pa == NULL)
			err(1, "calloc");
		memmove(pa, &pp.addr, sizeof(struct pf_pooladdr));
		TAILQ_INSERT_TAIL(&pool->list, pa, entries);
	}

	return (0);
}

void
pfctl_clear_pool(struct pf_pool *pool)
{
	struct pf_pooladdr *pa;

	while ((pa = TAILQ_FIRST(&pool->list)) != NULL) {
		TAILQ_REMOVE(&pool->list, pa, entries);
		free(pa);
	}
}

void
pfctl_print_rule_counters(struct pf_rule *rule, int opts)
{
	if (opts & PF_OPT_DEBUG) {
		const char *t[PF_SKIP_COUNT] = { "i", "d", "f",
		    "p", "sa", "sp", "da", "dp" };
		int i;

		printf("  [ Skip steps: ");
		for (i = 0; i < PF_SKIP_COUNT; ++i) {
			if (rule->skip[i].nr == rule->nr + 1)
				continue;
			printf("%s=", t[i]);
			if (rule->skip[i].nr == -1)
				printf("end ");
			else
				printf("%u ", rule->skip[i].nr);
		}
		printf("]\n");

		printf("  [ queue: qname=%s qid=%u pqname=%s pqid=%u ]\n",
		    rule->qname, rule->qid, rule->pqname, rule->pqid);
	}
	if (opts & PF_OPT_VERBOSE)
		printf("  [ Evaluations: %-8llu  Packets: %-8llu  "
			    "Bytes: %-10llu  States: %-6u]\n",
			    (unsigned long long)rule->evaluations,
			    (unsigned long long)rule->packets,
			    (unsigned long long)rule->bytes, rule->states);
}

void
pfctl_print_title(char *title)
{
	if (!first_title)
		printf("\n");
	first_title = 0;
	printf("%s\n", title);
}

int
pfctl_show_rules(int dev, int opts, int format, char *anchorname,
    char *rulesetname)
{
	struct pfioc_rule pr;
	u_int32_t nr, mnr, header = 0;
	int rule_numbers = opts & (PF_OPT_VERBOSE2 | PF_OPT_DEBUG);

	if (*anchorname && !*rulesetname) {
		struct pfioc_ruleset pr;
		int r;

		memset(&pr, 0, sizeof(pr));
		memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
		if (ioctl(dev, DIOCGETRULESETS, &pr)) {
			if (errno == EINVAL)
				fprintf(stderr, "No rulesets in anchor '%s'.\n",
				    anchorname);
			else
				err(1, "DIOCGETRULESETS");
			return (-1);
		}
		if (opts & PF_OPT_SHOWALL && pr.nr)
			pfctl_print_title("FILTER RULES:");
		mnr = pr.nr;
		for (nr = 0; nr < mnr; ++nr) {
			pr.nr = nr;
			if (ioctl(dev, DIOCGETRULESET, &pr))
				err(1, "DIOCGETRULESET");
			r = pfctl_show_rules(dev, opts, format, anchorname,
			    pr.name);
			if (r)
				return (r);
		}
		return (0);
	}

	memset(&pr, 0, sizeof(pr));
	memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
	memcpy(pr.ruleset, rulesetname, sizeof(pr.ruleset));
	if (opts & PF_OPT_SHOWALL) {
		pr.rule.action = PF_PASS;
		if (ioctl(dev, DIOCGETRULES, &pr)) {
			warn("DIOCGETRULES");
			return (-1);
		}
		header++;
	}
	pr.rule.action = PF_SCRUB;
	if (ioctl(dev, DIOCGETRULES, &pr)) {
		warn("DIOCGETRULES");
		return (-1);
	}
	if (opts & PF_OPT_SHOWALL) {
		if (format == 0 && (pr.nr > 0 || header))
			pfctl_print_title("FILTER RULES:");
		else if (format == 1 && labels)
			pfctl_print_title("LABEL COUNTERS:");
	}
	mnr = pr.nr;
	for (nr = 0; nr < mnr; ++nr) {
		pr.nr = nr;
		if (ioctl(dev, DIOCGETRULE, &pr)) {
			warn("DIOCGETRULE");
			return (-1);
		}

		if (pfctl_get_pool(dev, &pr.rule.rpool,
		    nr, pr.ticket, PF_SCRUB, anchorname, rulesetname) != 0)
			return (-1);

		switch (format) {
		case 1:
			if (pr.rule.label[0]) {
				printf("%s ", pr.rule.label);
				printf("%llu %llu %llu\n",
				    (unsigned long long)pr.rule.evaluations,
				    (unsigned long long)pr.rule.packets,
				    (unsigned long long)pr.rule.bytes);
			}
			break;
		default:
			if (pr.rule.label[0] && (opts & PF_OPT_SHOWALL))
				labels = 1;
			print_rule(&pr.rule, rule_numbers);
			pfctl_print_rule_counters(&pr.rule, opts);
		}
		pfctl_clear_pool(&pr.rule.rpool);
	}
	pr.rule.action = PF_PASS;
	if (ioctl(dev, DIOCGETRULES, &pr)) {
		warn("DIOCGETRULES");
		return (-1);
	}
	mnr = pr.nr;
	for (nr = 0; nr < mnr; ++nr) {
		pr.nr = nr;
		if (ioctl(dev, DIOCGETRULE, &pr)) {
			warn("DIOCGETRULE");
			return (-1);
		}

		if (pfctl_get_pool(dev, &pr.rule.rpool,
		    nr, pr.ticket, PF_PASS, anchorname, rulesetname) != 0)
			return (-1);

		switch (format) {
		case 1:
			if (pr.rule.label[0]) {
				printf("%s ", pr.rule.label);
				printf("%llu %llu %llu\n",
				    (unsigned long long)pr.rule.evaluations,
				    (unsigned long long)pr.rule.packets,
				    (unsigned long long)pr.rule.bytes);
			}
			break;
		default:
			if (pr.rule.label[0] && (opts & PF_OPT_SHOWALL))
				labels = 1;
			print_rule(&pr.rule, rule_numbers);
			pfctl_print_rule_counters(&pr.rule, opts);
		}
		pfctl_clear_pool(&pr.rule.rpool);
	}
	return (0);
}

int
pfctl_show_nat(int dev, int opts, char *anchorname, char *rulesetname)
{
	struct pfioc_rule pr;
	u_int32_t mnr, nr;
	static int nattype[3] = { PF_NAT, PF_RDR, PF_BINAT };
	int i, dotitle = opts & PF_OPT_SHOWALL;

	if (*anchorname && !*rulesetname) {
		struct pfioc_ruleset pr;
		int r;

		memset(&pr, 0, sizeof(pr));
		memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
		if (ioctl(dev, DIOCGETRULESETS, &pr)) {
			if (errno == EINVAL)
				fprintf(stderr, "No rulesets in anchor '%s'.\n",
				    anchorname);
			else
				err(1, "DIOCGETRULESETS");
			return (-1);
		}
		mnr = pr.nr;
		for (nr = 0; nr < mnr; ++nr) {
			pr.nr = nr;
			if (ioctl(dev, DIOCGETRULESET, &pr))
				err(1, "DIOCGETRULESET");
			r = pfctl_show_nat(dev, opts, anchorname, pr.name);
			if (r)
				return (r);
		}
		return (0);
	}

	memset(&pr, 0, sizeof(pr));
	memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
	memcpy(pr.ruleset, rulesetname, sizeof(pr.ruleset));
	for (i = 0; i < 3; i++) {
		pr.rule.action = nattype[i];
		if (ioctl(dev, DIOCGETRULES, &pr)) {
			warn("DIOCGETRULES");
			return (-1);
		}
		mnr = pr.nr;
		for (nr = 0; nr < mnr; ++nr) {
			pr.nr = nr;
			if (ioctl(dev, DIOCGETRULE, &pr)) {
				warn("DIOCGETRULE");
				return (-1);
			}
			if (pfctl_get_pool(dev, &pr.rule.rpool, nr,
			    pr.ticket, nattype[i], anchorname,
			    rulesetname) != 0)
				return (-1);
			if (dotitle) {
				pfctl_print_title("TRANSLATION RULES:");
				dotitle = 0;
			}
			print_rule(&pr.rule, opts & PF_OPT_VERBOSE2);
			pfctl_print_rule_counters(&pr.rule, opts);
			pfctl_clear_pool(&pr.rule.rpool);
		}
	}
	return (0);
}

int
pfctl_show_src_nodes(int dev, int opts)
{
	struct pfioc_src_nodes psn;
	struct pf_src_node *p;
	char *inbuf = NULL, *newinbuf = NULL;
	unsigned len = 0;
	int i;

	memset(&psn, 0, sizeof(psn));
	for (;;) {
		psn.psn_len = len;
		if (len) {
			newinbuf = realloc(inbuf, len);
			if (newinbuf == NULL)
				err(1, "realloc");
			psn.psn_buf = inbuf = newinbuf;
		}
		if (ioctl(dev, DIOCGETSRCNODES, &psn) < 0) {
			warn("DIOCGETSRCNODES");
			return (-1);
		}
		if (psn.psn_len + sizeof(struct pfioc_src_nodes) < len)
			break;
		if (len == 0 && psn.psn_len == 0)
			return (0);
		if (len == 0 && psn.psn_len != 0)
			len = psn.psn_len;
		if (psn.psn_len == 0)
			return (0);	/* no src_nodes */
		len *= 2;
	}
	p = psn.psn_src_nodes;
	if (psn.psn_len > 0 && (opts & PF_OPT_SHOWALL))
		pfctl_print_title("SOURCE TRACKING NODES:");
	for (i = 0; i < psn.psn_len; i += sizeof(*p)) {
		print_src_node(p, opts);
		p++;
	}
	return (0);
}

int
pfctl_show_states(int dev, const char *iface, int opts)
{
	struct pfioc_states ps;
	struct pf_state *p;
	char *inbuf = NULL, *newinbuf = NULL;
	unsigned len = 0;
	int i, dotitle = (opts & PF_OPT_SHOWALL);

	memset(&ps, 0, sizeof(ps));
	for (;;) {
		ps.ps_len = len;
		if (len) {
			newinbuf = realloc(inbuf, len);
			if (newinbuf == NULL)
				err(1, "realloc");
			ps.ps_buf = inbuf = newinbuf;
		}
		if (ioctl(dev, DIOCGETSTATES, &ps) < 0) {
			warn("DIOCGETSTATES");
			return (-1);
		}
		if (ps.ps_len + sizeof(struct pfioc_states) < len)
			break;
		if (len == 0 && ps.ps_len == 0)
			return (0);
		if (len == 0 && ps.ps_len != 0)
			len = ps.ps_len;
		if (ps.ps_len == 0)
			return (0);	/* no states */
		len *= 2;
	}
	p = ps.ps_states;
	for (i = 0; i < ps.ps_len; i += sizeof(*p), p++) {
		if (iface != NULL && strcmp(p->u.ifname, iface))
			continue;
		if (dotitle) {
			pfctl_print_title("STATES:");
			dotitle = 0;
		}
		print_state(p, opts);
	}
	return (0);
}

int
pfctl_show_status(int dev, int opts)
{
	struct pf_status status;

	if (ioctl(dev, DIOCGETSTATUS, &status)) {
		warn("DIOCGETSTATUS");
		return (-1);
	}
	if (opts & PF_OPT_SHOWALL)
		pfctl_print_title("INFO:");
	print_status(&status, opts);
	return (0);
}

int
pfctl_show_timeouts(int dev, int opts)
{
	struct pfioc_tm pt;
	int i;

	if (opts & PF_OPT_SHOWALL)
		pfctl_print_title("TIMEOUTS:");
	memset(&pt, 0, sizeof(pt));
	for (i = 0; pf_timeouts[i].name; i++) {
		pt.timeout = pf_timeouts[i].timeout;
		if (ioctl(dev, DIOCGETTIMEOUT, &pt))
			err(1, "DIOCGETTIMEOUT");
		printf("%-20s %10d", pf_timeouts[i].name, pt.seconds);
		if (i >= PFTM_ADAPTIVE_START && i <= PFTM_ADAPTIVE_END)
			printf(" states");
		else
			printf("s");
		printf("\n");
	}
	return (0);

}

int
pfctl_show_limits(int dev, int opts)
{
	struct pfioc_limit pl;
	int i;

	if (opts & PF_OPT_SHOWALL)
		pfctl_print_title("LIMITS:");
	memset(&pl, 0, sizeof(pl));
	for (i = 0; pf_limits[i].name; i++) {
		pl.index = pf_limits[i].index;
		if (ioctl(dev, DIOCGETLIMIT, &pl))
			err(1, "DIOCGETLIMIT");
		printf("%-10s ", pf_limits[i].name);
		if (pl.limit == UINT_MAX)
			printf("unlimited\n");
		else
			printf("hard limit %6u\n", pl.limit);
	}
	return (0);
}

/* callbacks for rule/nat/rdr/addr */
int
pfctl_add_pool(struct pfctl *pf, struct pf_pool *p, sa_family_t af)
{
	struct pf_pooladdr *pa;

	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(pf->dev, DIOCBEGINADDRS, &pf->paddr))
			err(1, "DIOCBEGINADDRS");
	}

	pf->paddr.af = af;
	TAILQ_FOREACH(pa, &p->list, entries) {
		memcpy(&pf->paddr.addr, pa, sizeof(struct pf_pooladdr));
		if ((pf->opts & PF_OPT_NOACTION) == 0) {
			if (ioctl(pf->dev, DIOCADDADDR, &pf->paddr))
				err(1, "DIOCADDADDR");
		}
	}
	return (0);
}

int
pfctl_add_rule(struct pfctl *pf, struct pf_rule *r)
{
	u_int8_t		rs_num;
	struct pfioc_rule	pr;

	switch (r->action) {
	case PF_SCRUB:
		if ((loadopt & PFCTL_FLAG_FILTER) == 0)
			return (0);
		rs_num = PF_RULESET_SCRUB;
		break;
	case PF_DROP:
	case PF_PASS:
		if ((loadopt & PFCTL_FLAG_FILTER) == 0)
			return (0);
		rs_num = PF_RULESET_FILTER;
		break;
	case PF_NAT:
	case PF_NONAT:
		if ((loadopt & PFCTL_FLAG_NAT) == 0)
			return (0);
		rs_num = PF_RULESET_NAT;
		break;
	case PF_RDR:
	case PF_NORDR:
		if ((loadopt & PFCTL_FLAG_NAT) == 0)
			return (0);
		rs_num = PF_RULESET_RDR;
		break;
	case PF_BINAT:
	case PF_NOBINAT:
		if ((loadopt & PFCTL_FLAG_NAT) == 0)
			return (0);
		rs_num = PF_RULESET_BINAT;
		break;
	default:
		errx(1, "Invalid rule type");
		break;
	}

	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		bzero(&pr, sizeof(pr));
		if (strlcpy(pr.anchor, pf->anchor, sizeof(pr.anchor)) >=
		    sizeof(pr.anchor) ||
		    strlcpy(pr.ruleset, pf->ruleset, sizeof(pr.ruleset)) >=
		    sizeof(pr.ruleset))
			errx(1, "pfctl_add_rule: strlcpy");
		if (pfctl_add_pool(pf, &r->rpool, r->af))
			return (1);
		pr.ticket = pfctl_get_ticket(pf->trans, rs_num, pf->anchor,
		    pf->ruleset);
		pr.pool_ticket = pf->paddr.ticket;
		memcpy(&pr.rule, r, sizeof(pr.rule));
		if (ioctl(pf->dev, DIOCADDRULE, &pr))
			err(1, "DIOCADDRULE");
	}
	if (pf->opts & PF_OPT_VERBOSE)
		print_rule(r, pf->opts & PF_OPT_VERBOSE2);
	pfctl_clear_pool(&r->rpool);
	return (0);
}

int
pfctl_add_altq(struct pfctl *pf, struct pf_altq *a)
{
	if (altqsupport &&
	    (loadopt & PFCTL_FLAG_ALTQ) != 0) {
		memcpy(&pf->paltq->altq, a, sizeof(struct pf_altq));
		if ((pf->opts & PF_OPT_NOACTION) == 0) {
			if (ioctl(pf->dev, DIOCADDALTQ, pf->paltq)) {
				if (errno == ENXIO)
					errx(1, "qtype not configured");
				else if (errno == ENODEV)
					errx(1, "%s: driver does not support "
					    "altq", a->ifname);
				else
					err(1, "DIOCADDALTQ");
			}
		}
		pfaltq_store(&pf->paltq->altq);
	}
	return (0);
}

int
pfctl_rules(int dev, char *filename, int opts, char *anchorname,
    char *rulesetname, struct pfr_buffer *trans)
{
#define ERR(x) do { warn(x); goto _error; } while(0)
#define ERRX(x) do { warnx(x); goto _error; } while(0)

	FILE			*fin;
	struct pfr_buffer	*t, buf;
	struct pfioc_altq	 pa;
	struct pfctl		 pf;
	struct pfr_table	 trs;
	int			 osize;

	if (trans == NULL) {
	    bzero(&buf, sizeof(buf));
	    buf.pfrb_type = PFRB_TRANS;
	    t = &buf;
	    osize = 0;
	} else {
	    t = trans;
	    osize = t->pfrb_size;
	}

	memset(&pa, 0, sizeof(pa));
	memset(&pf, 0, sizeof(pf));
	memset(&trs, 0, sizeof(trs));
	if (strlcpy(trs.pfrt_anchor, anchorname,
	    sizeof(trs.pfrt_anchor)) >= sizeof(trs.pfrt_anchor) ||
	    strlcpy(trs.pfrt_ruleset, rulesetname,
	    sizeof(trs.pfrt_ruleset)) >= sizeof(trs.pfrt_ruleset))
		ERRX("pfctl_rules: strlcpy");
	if (strcmp(filename, "-") == 0) {
		fin = stdin;
		infile = "stdin";
	} else {
		if ((fin = pfctl_fopen(filename, "r")) == NULL) {
			warn("%s", filename);
			return (1);
		}
		infile = filename;
	}
	pf.dev = dev;
	pf.opts = opts;
	pf.loadopt = loadopt;
	if (anchorname[0])
		pf.loadopt &= ~PFCTL_FLAG_ALTQ;
	pf.paltq = &pa;
	pf.trans = t;
	pf.rule_nr = 0;
	pf.anchor = anchorname;
	pf.ruleset = rulesetname;

	if ((opts & PF_OPT_NOACTION) == 0) {
		if ((pf.loadopt & PFCTL_FLAG_NAT) != 0) {
			if (pfctl_add_trans(t, PF_RULESET_NAT, anchorname,
			    rulesetname) ||
			    pfctl_add_trans(t, PF_RULESET_BINAT, anchorname,
			    rulesetname) ||
			    pfctl_add_trans(t, PF_RULESET_RDR, anchorname,
			    rulesetname))
				ERR("pfctl_rules");
		}
		if (((altqsupport && (pf.loadopt & PFCTL_FLAG_ALTQ) != 0))) {
			if (pfctl_add_trans(t, PF_RULESET_ALTQ, anchorname,
			    rulesetname))
				ERR("pfctl_rules");
		}
		if ((pf.loadopt & PFCTL_FLAG_FILTER) != 0) {
			if (pfctl_add_trans(t, PF_RULESET_SCRUB, anchorname,
			    rulesetname) ||
			    pfctl_add_trans(t, PF_RULESET_FILTER, anchorname,
			    rulesetname))
				ERR("pfctl_rules");
		}
		if (pf.loadopt & PFCTL_FLAG_TABLE) {
			if (pfctl_add_trans(t, PF_RULESET_TABLE, anchorname,
			    rulesetname))
				ERR("pfctl_rules");
		}
		if (pfctl_trans(dev, t, DIOCXBEGIN, osize))
			ERR("DIOCXBEGIN");
		if (altqsupport && (pf.loadopt & PFCTL_FLAG_ALTQ))
			pa.ticket = pfctl_get_ticket(t, PF_RULESET_ALTQ,
			    anchorname, rulesetname);
		if (pf.loadopt & PFCTL_FLAG_TABLE)
			pf.tticket = pfctl_get_ticket(t, PF_RULESET_TABLE,
			    anchorname, rulesetname);
	}
	if (parse_rules(fin, &pf) < 0) {
		if ((opts & PF_OPT_NOACTION) == 0)
			ERRX("Syntax error in config file: "
			    "pf rules not loaded");
		else
			goto _error;
	}
	if ((altqsupport && (pf.loadopt & PFCTL_FLAG_ALTQ) != 0))
		if (check_commit_altq(dev, opts) != 0)
			ERRX("errors in altq config");
	if (fin != stdin)
		fclose(fin);

	/* process "load anchor" directives */
	if (!anchorname[0] && !rulesetname[0])
		if (pfctl_load_anchors(dev, opts, t) == -1)
			ERRX("load anchors");

	if (trans == NULL && (opts & PF_OPT_NOACTION) == 0)
		if (pfctl_trans(dev, t, DIOCXCOMMIT, 0))
			ERR("DIOCXCOMMIT");
	return (0);

_error:
	if (trans == NULL) {	/* main ruleset */
		if ((opts & PF_OPT_NOACTION) == 0)
			if (pfctl_trans(dev, t, DIOCXROLLBACK, 0))
				err(1, "DIOCXROLLBACK");
		exit(1);
	} else			/* sub ruleset */
		return (-1);

#undef ERR
#undef ERRX
}

FILE *
pfctl_fopen(const char *name, const char *mode) 
{
	struct stat	 st;
	FILE		*fp;

	fp = fopen(name, mode);
	if (fp == NULL)
		return (NULL);
	if (fstat(fileno(fp), &st)) {
		fclose(fp);
		return (NULL);
	}
	if (S_ISDIR(st.st_mode)) {
		fclose(fp);
		errno = EISDIR;
		return (NULL);
	}
	return (fp);
}

int
pfctl_set_limit(struct pfctl *pf, const char *opt, unsigned int limit)
{
	struct pfioc_limit pl;
	int i;

	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

	memset(&pl, 0, sizeof(pl));
	for (i = 0; pf_limits[i].name; i++) {
		if (strcasecmp(opt, pf_limits[i].name) == 0) {
			pl.index = pf_limits[i].index;
			pl.limit = limit;
			if ((pf->opts & PF_OPT_NOACTION) == 0) {
				if (ioctl(pf->dev, DIOCSETLIMIT, &pl)) {
					if (errno == EBUSY) {
						warnx("Current pool "
						    "size exceeds requested "
						    "hard limit");
						return (1);
					} else
						err(1, "DIOCSETLIMIT");
				}
			}
			break;
		}
	}
	if (pf_limits[i].name == NULL) {
		warnx("Bad pool name.");
		return (1);
	}

	if (pf->opts & PF_OPT_VERBOSE)
		printf("set limit %s %d\n", opt, limit);

	return (0);
}

int
pfctl_set_timeout(struct pfctl *pf, const char *opt, int seconds, int quiet)
{
	struct pfioc_tm pt;
	int i;

	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

	memset(&pt, 0, sizeof(pt));
	for (i = 0; pf_timeouts[i].name; i++) {
		if (strcasecmp(opt, pf_timeouts[i].name) == 0) {
			pt.timeout = pf_timeouts[i].timeout;
			break;
		}
	}

	if (pf_timeouts[i].name == NULL) {
		warnx("Bad timeout name.");
		return (1);
	}

	pt.seconds = seconds;
	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(pf->dev, DIOCSETTIMEOUT, &pt))
			err(1, "DIOCSETTIMEOUT");
	}

	if (pf->opts & PF_OPT_VERBOSE && ! quiet)
		printf("set timeout %s %d\n", opt, seconds);

	return (0);
}

int
pfctl_set_optimization(struct pfctl *pf, const char *opt)
{
	const struct pf_hint *hint;
	int i, r;

	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

	for (i = 0; pf_hints[i].name; i++)
		if (strcasecmp(opt, pf_hints[i].name) == 0)
			break;

	hint = pf_hints[i].hint;
	if (hint == NULL) {
		warnx("Bad hint name.");
		return (1);
	}

	for (i = 0; hint[i].name; i++)
		if ((r = pfctl_set_timeout(pf, hint[i].name,
		    hint[i].timeout, 1)))
			return (r);

	if (pf->opts & PF_OPT_VERBOSE)
		printf("set optimization %s\n", opt);

	return (0);
}

int
pfctl_set_logif(struct pfctl *pf, char *ifname)
{
	struct pfioc_if pi;

	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

	memset(&pi, 0, sizeof(pi));
	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (!strcmp(ifname, "none"))
			bzero(pi.ifname, sizeof(pi.ifname));
		else {
			if (strlcpy(pi.ifname, ifname,
			    sizeof(pi.ifname)) >= sizeof(pi.ifname))
				errx(1, "pfctl_set_logif: strlcpy");
		}
		if (ioctl(pf->dev, DIOCSETSTATUSIF, &pi))
			err(1, "DIOCSETSTATUSIF");
	}

	if (pf->opts & PF_OPT_VERBOSE)
		printf("set loginterface %s\n", ifname);

	return (0);
}

int
pfctl_set_hostid(struct pfctl *pf, u_int32_t hostid)
{
	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

	HTONL(hostid);

	if ((pf->opts & PF_OPT_NOACTION) == 0)
		if (ioctl(dev, DIOCSETHOSTID, &hostid))
			err(1, "DIOCSETHOSTID");

	if (pf->opts & PF_OPT_VERBOSE)
		printf("set hostid 0x%08x\n", ntohl(hostid));

	return (0);
}

int
pfctl_set_debug(struct pfctl *pf, char *d)
{
	u_int32_t	level;

	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

	if (!strcmp(d, "none"))
		level = PF_DEBUG_NONE;
	else if (!strcmp(d, "urgent"))
		level = PF_DEBUG_URGENT;
	else if (!strcmp(d, "misc"))
		level = PF_DEBUG_MISC;
	else if (!strcmp(d, "loud"))
		level = PF_DEBUG_NOISY;
	else {
		warnx("unknown debug level \"%s\"", d);
		return (-1);
	}

	if ((pf->opts & PF_OPT_NOACTION) == 0)
		if (ioctl(dev, DIOCSETDEBUG, &level))
			err(1, "DIOCSETDEBUG");

	if (pf->opts & PF_OPT_VERBOSE)
		printf("set debug %s\n", d);

	return (0);
}

int
pfctl_debug(int dev, u_int32_t level, int opts)
{
	if (ioctl(dev, DIOCSETDEBUG, &level))
		err(1, "DIOCSETDEBUG");
	if ((opts & PF_OPT_QUIET) == 0) {
		fprintf(stderr, "debug level set to '");
		switch (level) {
		case PF_DEBUG_NONE:
			fprintf(stderr, "none");
			break;
		case PF_DEBUG_URGENT:
			fprintf(stderr, "urgent");
			break;
		case PF_DEBUG_MISC:
			fprintf(stderr, "misc");
			break;
		case PF_DEBUG_NOISY:
			fprintf(stderr, "loud");
			break;
		default:
			fprintf(stderr, "<invalid>");
			break;
		}
		fprintf(stderr, "'\n");
	}
	return (0);
}

int
pfctl_clear_rule_counters(int dev, int opts)
{
	if (ioctl(dev, DIOCCLRRULECTRS))
		err(1, "DIOCCLRRULECTRS");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "pf: rule counters cleared\n");
	return (0);
}

int
pfctl_test_altqsupport(int dev, int opts)
{
	struct pfioc_altq pa;

	if (ioctl(dev, DIOCGETALTQS, &pa)) {
		if (errno == ENODEV) {
			if (!(opts & PF_OPT_QUIET))
				fprintf(stderr, "No ALTQ support in kernel\n"
				    "ALTQ related functions disabled\n");
			return (0);
		} else
			err(1, "DIOCGETALTQS");
	}
	return (1);
}

int
pfctl_show_anchors(int dev, int opts, char *anchorname)
{
	u_int32_t nr, mnr;

	if (!*anchorname) {
		struct pfioc_anchor pa;

		memset(&pa, 0, sizeof(pa));
		if (ioctl(dev, DIOCGETANCHORS, &pa)) {
			warn("DIOCGETANCHORS");
			return (-1);
		}
		mnr = pa.nr;
		for (nr = 0; nr < mnr; ++nr) {
			pa.nr = nr;
			if (ioctl(dev, DIOCGETANCHOR, &pa)) {
				warn("DIOCGETANCHOR");
				return (-1);
			}
			if (!(opts & PF_OPT_VERBOSE) &&
			    !strcmp(pa.name, PF_RESERVED_ANCHOR))
				continue;
			printf("  %s\n", pa.name);
		}
	} else {
		struct pfioc_ruleset pr;

		memset(&pr, 0, sizeof(pr));
		memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
		if (ioctl(dev, DIOCGETRULESETS, &pr)) {
			if (errno == EINVAL)
				fprintf(stderr, "No rulesets in anchor '%s'.\n",
				    anchorname);
			else
				err(1, "DIOCGETRULESETS");
			return (-1);
		}
		mnr = pr.nr;
		for (nr = 0; nr < mnr; ++nr) {
			pr.nr = nr;
			if (ioctl(dev, DIOCGETRULESET, &pr))
				err(1, "DIOCGETRULESET");
			printf("  %s:%s\n", pr.anchor, pr.name);
		}
	}
	return (0);
}

const char *
pfctl_lookup_option(char *cmd, const char **list)
{
	if (cmd != NULL && *cmd)
		for (; *list; list++)
			if (!strncmp(cmd, *list, strlen(cmd)))
				return (*list);
	return (NULL);
}

int
main(int argc, char *argv[])
{
	int	error = 0;
	int	ch;
	int	mode = O_RDONLY;
	int	opts = 0;
	char	anchorname[PF_ANCHOR_NAME_SIZE];
	char	rulesetname[PF_RULESET_NAME_SIZE];

	if (argc < 2)
		usage();

	while ((ch = getopt(argc, argv,
	    "a:AdD:eqf:F:ghi:k:nNOp:rRs:t:T:vx:z")) != -1) {
		switch (ch) {
		case 'a':
			anchoropt = optarg;
			break;
		case 'd':
			opts |= PF_OPT_DISABLE;
			mode = O_RDWR;
			break;
		case 'D':
			if (pfctl_cmdline_symset(optarg) < 0)
				warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'e':
			opts |= PF_OPT_ENABLE;
			mode = O_RDWR;
			break;
		case 'q':
			opts |= PF_OPT_QUIET;
			break;
		case 'F':
			clearopt = pfctl_lookup_option(optarg, clearopt_list);
			if (clearopt == NULL) {
				warnx("Unknown flush modifier '%s'", optarg);
				usage();
			}
			mode = O_RDWR;
			break;
		case 'i':
			ifaceopt = optarg;
			break;
		case 'k':
			if (state_killers >= 2) {
				warnx("can only specify -k twice");
				usage();
				/* NOTREACHED */
			}
			state_kill[state_killers++] = optarg;
			mode = O_RDWR;
			break;
		case 'n':
			opts |= PF_OPT_NOACTION;
			break;
		case 'N':
			loadopt |= PFCTL_FLAG_NAT;
			break;
		case 'r':
			opts |= PF_OPT_USEDNS;
			break;
		case 'f':
			rulesopt = optarg;
			mode = O_RDWR;
			break;
		case 'g':
			opts |= PF_OPT_DEBUG;
			break;
		case 'A':
			loadopt |= PFCTL_FLAG_ALTQ;
			break;
		case 'R':
			loadopt |= PFCTL_FLAG_FILTER;
			break;
		case 'O':
			loadopt |= PFCTL_FLAG_OPTION;
			break;
		case 'p':
			pf_device = optarg;
			break;
		case 's':
			showopt = pfctl_lookup_option(optarg, showopt_list);
			if (showopt == NULL) {
				warnx("Unknown show modifier '%s'", optarg);
				usage();
			}
			break;
		case 't':
			tableopt = optarg;
			break;
		case 'T':
			tblcmdopt = pfctl_lookup_option(optarg, tblcmdopt_list);
			if (tblcmdopt == NULL) {
				warnx("Unknown table command '%s'", optarg);
				usage();
			}
			break;
		case 'v':
			if (opts & PF_OPT_VERBOSE)
				opts |= PF_OPT_VERBOSE2;
			opts |= PF_OPT_VERBOSE;
			break;
		case 'x':
			debugopt = pfctl_lookup_option(optarg, debugopt_list);
			if (debugopt == NULL) {
				warnx("Unknown debug level '%s'", optarg);
				usage();
			}
			mode = O_RDWR;
			break;
		case 'z':
			opts |= PF_OPT_CLRRULECTRS;
			mode = O_RDWR;
			break;
		case 'h':
			/* FALLTHROUGH */
		default:
			usage();
			/* NOTREACHED */
		}
	}

	if (tblcmdopt != NULL) {
		argc -= optind;
		argv += optind;
		ch = *tblcmdopt;
		if (ch == 'l') {
			loadopt |= PFCTL_FLAG_TABLE;
			tblcmdopt = NULL;
		} else
			mode = strchr("acdfkrz", ch) ? O_RDWR : O_RDONLY;
	} else if (argc != optind) {
		warnx("unknown command line argument: %s ...", argv[optind]);
		usage();
		/* NOTREACHED */
	}
	if (loadopt == 0)
		loadopt = ~0;

	memset(anchorname, 0, sizeof(anchorname));
	memset(rulesetname, 0, sizeof(rulesetname));
	if (anchoropt != NULL) {
		char *t;

		if ((t = strchr(anchoropt, ':')) == NULL) {
			if (strlcpy(anchorname, anchoropt,
			    sizeof(anchorname)) >= sizeof(anchorname))
				errx(1, "anchor name '%s' too long",
				    anchoropt);
		} else {
			char *p;

			if ((p = strdup(anchoropt)) == NULL)
				err(1, "anchoropt: strdup");
			t = strsep(&p, ":");
			if (*t == '\0' || *p == '\0')
				errx(1, "anchor '%s' invalid", anchoropt);
			if (strlcpy(anchorname, t, sizeof(anchorname)) >=
			    sizeof(anchorname))
				errx(1, "anchor name '%s' too long", t);
			if (strlcpy(rulesetname, p, sizeof(rulesetname)) >=
			    sizeof(rulesetname))
				errx(1, "ruleset name '%s' too long", p);
			free(t); /* not p */
		}
		loadopt &= PFCTL_FLAG_FILTER|PFCTL_FLAG_NAT|PFCTL_FLAG_TABLE;
	}

	if ((opts & PF_OPT_NOACTION) == 0) {
		dev = open(pf_device, mode);
		if (dev == -1)
			err(1, "%s", pf_device);
		altqsupport = pfctl_test_altqsupport(dev, opts);
	} else {
		dev = open(pf_device, O_RDONLY);
		if (dev >= 0)
			opts |= PF_OPT_DUMMYACTION;
		/* turn off options */
		opts &= ~ (PF_OPT_DISABLE | PF_OPT_ENABLE);
		clearopt = showopt = debugopt = NULL;
		altqsupport = 1;
	}

	if (opts & PF_OPT_DISABLE)
		if (pfctl_disable(dev, opts))
			error = 1;

	if (showopt != NULL) {
		switch (*showopt) {
		case 'A':
			pfctl_show_anchors(dev, opts, anchorname);
			break;
		case 'r':
			pfctl_load_fingerprints(dev, opts);
			pfctl_show_rules(dev, opts, 0, anchorname,
			    rulesetname);
			break;
		case 'l':
			pfctl_load_fingerprints(dev, opts);
			pfctl_show_rules(dev, opts, 1, anchorname,
			    rulesetname);
			break;
		case 'n':
			pfctl_load_fingerprints(dev, opts);
			pfctl_show_nat(dev, opts, anchorname, rulesetname);
			break;
		case 'q':
			pfctl_show_altq(dev, ifaceopt, opts,
			    opts & PF_OPT_VERBOSE2);
			break;
		case 's':
			pfctl_show_states(dev, ifaceopt, opts);
			break;
		case 'S':
			pfctl_show_src_nodes(dev, opts);
			break;
		case 'i':
			pfctl_show_status(dev, opts);
			break;
		case 't':
			pfctl_show_timeouts(dev, opts);
			break;
		case 'm':
			pfctl_show_limits(dev, opts);
			break;
		case 'a':
			opts |= PF_OPT_SHOWALL;
			pfctl_load_fingerprints(dev, opts);

			pfctl_show_nat(dev, opts, anchorname, rulesetname);
			pfctl_show_rules(dev, opts, 0, anchorname,
			    rulesetname);
			pfctl_show_altq(dev, ifaceopt, opts, 0);
			pfctl_show_states(dev, ifaceopt, opts);
			pfctl_show_src_nodes(dev, opts);
			pfctl_show_status(dev, opts);
			pfctl_show_rules(dev, opts, 1, anchorname, rulesetname);
			pfctl_show_timeouts(dev, opts);
			pfctl_show_limits(dev, opts);
			pfctl_show_tables(anchorname, rulesetname, opts);
			pfctl_show_fingerprints(opts);
			break;
		case 'T':
			pfctl_show_tables(anchorname, rulesetname, opts);
			break;
		case 'o':
			pfctl_load_fingerprints(dev, opts);
			pfctl_show_fingerprints(opts);
			break;
		case 'I':
			pfctl_show_ifaces(ifaceopt, opts);
			break;
		}
	}

	if (clearopt != NULL) {
		switch (*clearopt) {
		case 'r':
			pfctl_clear_rules(dev, opts, anchorname, rulesetname);
			break;
		case 'n':
			pfctl_clear_nat(dev, opts, anchorname, rulesetname);
			break;
		case 'q':
			pfctl_clear_altq(dev, opts);
			break;
		case 's':
			pfctl_clear_states(dev, ifaceopt, opts);
			break;
		case 'S':
			pfctl_clear_src_nodes(dev, opts);
			break;
		case 'i':
			pfctl_clear_stats(dev, opts);
			break;
		case 'a':
			pfctl_clear_rules(dev, opts, anchorname, rulesetname);
			pfctl_clear_nat(dev, opts, anchorname, rulesetname);
			pfctl_clear_tables(anchorname, rulesetname, opts);
			if (!*anchorname && !*rulesetname) {
				pfctl_clear_altq(dev, opts);
				pfctl_clear_states(dev, ifaceopt, opts);
				pfctl_clear_src_nodes(dev, opts);
				pfctl_clear_stats(dev, opts);
				pfctl_clear_fingerprints(dev, opts);
			}
			break;
		case 'o':
			pfctl_clear_fingerprints(dev, opts);
			break;
		case 'T':
			pfctl_clear_tables(anchorname, rulesetname, opts);
			break;
		}
	}
	if (state_killers)
		pfctl_kill_states(dev, ifaceopt, opts);

	if (tblcmdopt != NULL) {
		error = pfctl_command_tables(argc, argv, tableopt,
		    tblcmdopt, rulesopt, anchorname, rulesetname, opts);
		rulesopt = NULL;
	}

	if (rulesopt != NULL)
		if (pfctl_file_fingerprints(dev, opts, PF_OSFP_FILE))
			error = 1;

	if (rulesopt != NULL) {
		if (pfctl_rules(dev, rulesopt, opts, anchorname, rulesetname,
		    NULL))
			error = 1;
		else if (!(opts & PF_OPT_NOACTION) &&
		    (loadopt & PFCTL_FLAG_TABLE))
			warn_namespace_collision(NULL);
	}

	if (opts & PF_OPT_ENABLE)
		if (pfctl_enable(dev, opts))
			error = 1;

	if (debugopt != NULL) {
		switch (*debugopt) {
		case 'n':
			pfctl_debug(dev, PF_DEBUG_NONE, opts);
			break;
		case 'u':
			pfctl_debug(dev, PF_DEBUG_URGENT, opts);
			break;
		case 'm':
			pfctl_debug(dev, PF_DEBUG_MISC, opts);
			break;
		case 'l':
			pfctl_debug(dev, PF_DEBUG_NOISY, opts);
			break;
		}
	}

	if (opts & PF_OPT_CLRRULECTRS) {
		if (pfctl_clear_rule_counters(dev, opts))
			error = 1;
	}
	exit(error);
}
@


1.2
log
@Jumbo patch from wbx@@ to replace the
bcopy(3), bcmp(3) and bzero(3) func-
tions, having been deprecated earli-
er, by their ISO counterparts, name-
ly memmove(3) and the gcc3-optimized
memcmp(3) and memset(3) functions.

I didn't read every single line (be-
cause of the time of day), but looks
fine and builds through. I just nee-
ded to nuke three cases of whitespa-
ce at EOL. Good work wbx@@.

I've also sprinkled in a few patches
of mine addressing the issue that in
some kernel header files, bcopy() is
used as well... also there have been
quite some string cleaning fixes and
a missing header.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.198 2003/12/31 22:14:41 deraadt Exp $ */
d37 1
d66 2
a67 2
int	 pfctl_clear_states(int, int);
int	 pfctl_kill_states(int, int);
d69 1
a69 1
	     char *, char *);
d74 1
a74 1
int	 pfctl_show_states(int, u_int8_t, int);
d76 2
a77 2
int	 pfctl_show_timeouts(int);
int	 pfctl_show_limits(int);
d89 2
d99 2
d109 1
d125 1
d135 1
d145 1
d155 1
d178 1
a178 1
	"Interfaces", "labels", "timeouts", "memory", "Tables", "ospf",
d197 1
a197 1
	fprintf(stderr, "usage: %s [-AdeghnNqrROvz] ", __progname);
d200 2
a201 1
	fprintf(stderr, "[-f file] [-F modifier] [-k host] [-s modifier]\n");
d203 2
a204 1
	fprintf(stderr, "[-t table] [-T command [address ...]] [-x level]\n");
d376 1
a376 1
pfctl_clear_states(int dev, int opts)
d378 8
a385 1
	if (ioctl(dev, DIOCCLRSTATES))
d388 1
a388 1
		fprintf(stderr, "states cleared\n");
d393 1
a393 1
pfctl_kill_states(int dev, int opts)
d408 3
d444 2
a445 1
				errx(1, "getaddrinfo: %s", gai_strerror(ret_ga));
d571 12
a582 2
			    rule->evaluations, rule->packets,
			    rule->bytes, rule->states);
d590 1
a590 1
	u_int32_t nr, mnr;
d607 2
d625 8
d638 6
d661 3
a663 2
				    pr.rule.evaluations, pr.rule.packets,
				    pr.rule.bytes);
d667 2
d696 3
a698 2
				    pr.rule.evaluations, pr.rule.packets,
				    pr.rule.bytes);
d702 2
d718 1
a718 1
	int i;
d766 4
d811 2
d821 1
a821 1
pfctl_show_states(int dev, u_int8_t proto, int opts)
d827 1
a827 1
	int i;
d853 8
a860 4
	for (i = 0; i < ps.ps_len; i += sizeof(*p)) {
		if (!proto || (p->proto == proto))
			print_state(p, opts);
		p++;
d874 2
d881 1
a881 1
pfctl_show_timeouts(int dev)
d886 2
d905 1
a905 1
pfctl_show_limits(int dev)
d910 2
d914 1
a914 1
		pl.index = i;
d1040 6
a1045 6
	FILE *fin;
	struct pfr_buffer      *t, buf;
	struct pfioc_altq	pa;
	struct pfctl		pf;
	struct pfr_table	trs;
	int			osize;
d1069 1
a1069 1
		if ((fin = fopen(filename, "r")) == NULL) {
d1158 21
d1191 1
a1191 1
			pl.index = i;
d1486 2
a1487 2
	while ((ch = getopt(argc, argv, "a:AdD:eqf:F:ghk:nNOrRs:t:T:vx:z")) !=
		-1) {
d1516 3
d1553 3
d1645 1
a1645 1
		dev = open("/dev/pf", mode);
d1647 1
a1647 1
			err(1, "/dev/pf");
d1650 1
a1650 1
		dev = open("/dev/pf", O_RDONLY);
d1683 2
a1684 1
			pfctl_show_altq(dev, opts, opts & PF_OPT_VERBOSE2);
d1687 1
a1687 1
			pfctl_show_states(dev, 0, opts);
d1696 1
a1696 1
			pfctl_show_timeouts(dev);
d1699 1
a1699 1
			pfctl_show_limits(dev);
d1702 1
d1705 1
d1708 2
a1709 3
			pfctl_show_nat(dev, opts, anchorname, rulesetname);
			pfctl_show_altq(dev, opts, 0);
			pfctl_show_states(dev, 0, opts);
d1713 2
a1714 2
			pfctl_show_timeouts(dev);
			pfctl_show_limits(dev);
a1716 1
			pfctl_show_ifaces(opts);
d1726 1
a1726 1
			pfctl_show_ifaces(opts);
d1743 1
a1743 1
			pfctl_clear_states(dev, opts);
a1753 4
			pfctl_clear_altq(dev, opts);
			pfctl_clear_states(dev, opts);
			pfctl_clear_src_nodes(dev, opts);
			pfctl_clear_stats(dev, opts);
d1755 7
a1761 1
			pfctl_clear_fingerprints(dev, opts);
d1772 1
a1772 1
		pfctl_kill_states(dev, opts);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.161 2003/03/11 13:20:17 dhartmei Exp $ */
d5 1
a52 1
#include <assert.h>
d61 2
a62 2
int	 pfctl_clear_rules(int, int);
int	 pfctl_clear_nat(int, int);
d64 1
d67 2
a68 1
int	 pfctl_get_pool(int, struct pf_pool *, u_int32_t, u_int32_t, int);
d70 3
a72 2
int	 pfctl_show_rules(int, int, int);
int	 pfctl_show_nat(int, int);
d74 1
a74 1
int	 pfctl_show_status(int);
a76 1
int	 pfctl_rules(int, char *, int);
d80 2
a81 2
int	 pfctl_show_anchors(int, int);
char	*pfctl_lookup_option(char *, char **);
d83 11
a93 13
char	*clearopt;
char	*rulesopt;
char	*showopt;
char	*debugopt;
char	*anchoropt;
char	*tableopt;
char	*tblcmdopt;
int	 state_killers;
char	*state_kill[2];
int	 loadopt = PFCTL_FLAG_ALL;
int	 altqsupport;
char	 anchorname[PF_ANCHOR_NAME_SIZE];
char	 rulesetname[PF_RULESET_NAME_SIZE];
d95 1
a95 1
int dev = -1;
d97 1
a97 1
const char *infile;
d161 3
a163 2
static char *clearopt_list[] = {
	"nat", "queue", "rules", "state", "info", "Tables", "all", NULL
d166 4
a169 3
static char *showopt_list[] = {
	"nat", "queue", "rules", "Anchors", "state", "info", "labels",
	"timeouts", "memory", "Tables", "all", NULL
d172 1
a172 1
static char *tblcmdopt_list[] = {
d177 2
a178 2
static char *debugopt_list[] = {
	"none", "urgent", "misc", NULL
d208 3
a210 10
	if (altqsupport) {
		if (ioctl(dev, DIOCSTARTALTQ)) {
			if (errno == EEXIST)
				errx(1, "altq already enabled");
			else
				err(1, "DIOCSTARTALTQ");
		}
		if ((opts & PF_OPT_QUIET) == 0)
			fprintf(stderr, "altq enabled\n");
	}
d227 2
a228 5
	if (altqsupport) {
		if (ioctl(dev, DIOCSTOPALTQ)) {
			if (errno == ENOENT)
				errx(1, "altq not enabled");
			else
a229 4
		}
		if ((opts & PF_OPT_QUIET) == 0)
			fprintf(stderr, "altq disabled\n");
	}
d245 1
a245 1
pfctl_clear_rules(int dev, int opts)
d247 1
a247 1
	struct pfioc_rule pr;
d268 2
a269 3
			memcpy(rulesetname, pr.name, sizeof(rulesetname));
			r = pfctl_clear_rules(dev, opts | PF_OPT_QUIET);
			memset(rulesetname, 0, sizeof(rulesetname));
d277 7
a283 13
	memset(&pr, 0, sizeof(pr));
	memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
	memcpy(pr.ruleset, rulesetname, sizeof(pr.ruleset));
	pr.rule.action = PF_SCRUB;
	if (ioctl(dev, DIOCBEGINRULES, &pr))
		err(1, "DIOCBEGINRULES");
	else if (ioctl(dev, DIOCCOMMITRULES, &pr))
		err(1, "DIOCCOMMITRULES");
	pr.rule.action = PF_PASS;
	if (ioctl(dev, DIOCBEGINRULES, &pr))
		err(1, "DIOCBEGINRULES");
	else if (ioctl(dev, DIOCCOMMITRULES, &pr))
		err(1, "DIOCCOMMITRULES");
d290 1
a290 1
pfctl_clear_nat(int dev, int opts)
d292 1
a292 1
	struct pfioc_rule pr;
d313 2
a314 3
			memcpy(rulesetname, pr.name, sizeof(rulesetname));
			r = pfctl_clear_nat(dev, opts | PF_OPT_QUIET);
			memset(rulesetname, 0, sizeof(rulesetname));
d322 8
a329 18
	memset(&pr, 0, sizeof(pr));
	memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
	memcpy(pr.ruleset, rulesetname, sizeof(pr.ruleset));
	pr.rule.action = PF_NAT;
	if (ioctl(dev, DIOCBEGINRULES, &pr))
		err(1, "DIOCBEGINRULES");
	else if (ioctl(dev, DIOCCOMMITRULES, &pr))
		err(1, "DIOCCOMMITRULES");
	pr.rule.action = PF_BINAT;
	if (ioctl(dev, DIOCBEGINRULES, &pr))
		err(1, "DIOCBEGINRULES");
	else if (ioctl(dev, DIOCCOMMITRULES, &pr))
		err(1, "DIOCCOMMITRULES");
	pr.rule.action = PF_RDR;
	if (ioctl(dev, DIOCBEGINRULES, &pr))
		err(1, "DIOCBEGINRULES");
	else if (ioctl(dev, DIOCCOMMITRULES, &pr))
		err(1, "DIOCCOMMITRULES");
d338 1
a338 1
	struct pfioc_altq pa;
d342 6
a347 5
	memset(&pa, 0, sizeof(pa));
	if (ioctl(dev, DIOCBEGINALTQS, &pa.ticket))
		err(1, "DIOCBEGINALTQS");
	else if (ioctl(dev, DIOCCOMMITALTQS, &pa.ticket))
		err(1, "DIOCCOMMITALTQS");
d354 10
d413 1
a413 1
			errx(1, "Unknown address family!?!?!");
d448 2
a449 1
					errx(1, "Unknown address family!?!?!");
d477 1
a477 1
    u_int32_t ticket, int r_action)
d504 1
a504 1
		bcopy(&pp.addr, pa, sizeof(struct pf_pooladdr));
d530 1
a530 1
		printf("[ Skip steps: ");
d542 1
a542 1
		printf("[ queue: qname=%s qid=%u pqname=%s pqid=%u ]\n",
d546 2
a547 2
		printf("[ Evaluations: %-8llu  Packets: %-8llu  "
			    "Bytes: %-10llu  States: %-6u]\n\n",
d553 2
a554 1
pfctl_show_rules(int dev, int opts, int format)
d579 2
a580 3
			memcpy(rulesetname, pr.name, sizeof(rulesetname));
			r = pfctl_show_rules(dev, opts, format);
			memset(rulesetname, 0, sizeof(rulesetname));
d604 1
a604 1
		    nr, pr.ticket, PF_SCRUB) != 0)
d636 1
a636 1
		    nr, pr.ticket, PF_PASS) != 0)
d658 1
a658 1
pfctl_show_nat(int dev, int opts)
d662 2
d684 1
a684 3
			memcpy(rulesetname, pr.name, sizeof(rulesetname));
			r = pfctl_show_nat(dev, opts);
			memset(rulesetname, 0, sizeof(rulesetname));
d694 4
a697 10
	pr.rule.action = PF_NAT;
	if (ioctl(dev, DIOCGETRULES, &pr)) {
		warn("DIOCGETRULES");
		return (-1);
	}
	mnr = pr.nr;
	for (nr = 0; nr < mnr; ++nr) {
		pr.nr = nr;
		if (ioctl(dev, DIOCGETRULE, &pr)) {
			warn("DIOCGETRULE");
d700 15
a714 6
		if (pfctl_get_pool(dev, &pr.rule.rpool, nr,
		    pr.ticket, PF_NAT) != 0)
			return (-1);
		print_nat(&pr.rule, opts & PF_OPT_VERBOSE2);
		pfctl_print_rule_counters(&pr.rule, opts);
		pfctl_clear_pool(&pr.rule.rpool);
d716 23
a738 10
	pr.rule.action = PF_RDR;
	if (ioctl(dev, DIOCGETRULES, &pr)) {
		warn("DIOCGETRULES");
		return (-1);
	}
	mnr = pr.nr;
	for (nr = 0; nr < mnr; ++nr) {
		pr.nr = nr;
		if (ioctl(dev, DIOCGETRULE, &pr)) {
			warn("DIOCGETRULE");
d741 9
a749 6
		if (pfctl_get_pool(dev, &pr.rule.rpool, nr,
		    pr.ticket, PF_RDR) != 0)
			return (-1);
		print_rdr(&pr.rule, opts & PF_OPT_VERBOSE2);
		pfctl_print_rule_counters(&pr.rule, opts);
		pfctl_clear_pool(&pr.rule.rpool);
d751 4
a754 18
	pr.rule.action = PF_BINAT;
	if (ioctl(dev, DIOCGETRULES, &pr)) {
		warn("DIOCGETRULES");
		return (-1);
	}
	mnr = pr.nr;
	for (nr = 0; nr < mnr; ++nr) {
		pr.nr = nr;
		if (ioctl(dev, DIOCGETRULE, &pr)) {
			warn("DIOCGETRULE");
			return (-1);
		}
		if (pfctl_get_pool(dev, &pr.rule.rpool, nr,
		    pr.ticket, PF_BINAT) != 0)
			return (-1);
		print_binat(&pr.rule, opts & PF_OPT_VERBOSE2);
		pfctl_print_rule_counters(&pr.rule, opts);
		pfctl_clear_pool(&pr.rule.rpool);
d764 1
a764 1
	char *inbuf = NULL;
d772 2
a773 2
			ps.ps_buf = inbuf = realloc(inbuf, len);
			if (inbuf == NULL)
d775 1
d781 1
a781 1
		if (ps.ps_len + sizeof(struct pfioc_state) < len)
d801 1
a801 1
pfctl_show_status(int dev)
d809 1
a809 1
	print_status(&status);
d824 6
a829 1
		printf("%-20s %10ds\n", pf_timeouts[i].name, pt.seconds);
d880 2
a881 1
	u_int8_t rs_num;
d885 1
a885 1
		if ((loadopt & (PFCTL_FLAG_FILTER | PFCTL_FLAG_ALL)) == 0)
d891 1
a891 1
		if ((loadopt & (PFCTL_FLAG_FILTER | PFCTL_FLAG_ALL)) == 0)
d897 1
a897 1
		if ((loadopt & (PFCTL_FLAG_NAT | PFCTL_FLAG_ALL)) == 0)
d903 1
a903 1
		if ((loadopt & (PFCTL_FLAG_NAT | PFCTL_FLAG_ALL)) == 0)
d909 1
a909 1
		if ((loadopt & (PFCTL_FLAG_NAT | PFCTL_FLAG_ALL)) == 0)
d919 6
d927 5
a931 4
		memcpy(&pf->prule[rs_num]->rule, r,
		    sizeof(pf->prule[rs_num]->rule));
		pf->prule[rs_num]->pool_ticket = pf->paddr.ticket;
		if (ioctl(pf->dev, DIOCADDRULE, pf->prule[rs_num]))
d944 1
a944 1
	    (loadopt & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0) {
d949 1
a949 2
					fprintf(stderr,
					    "qtype not configured\n");
d951 4
a954 4
					fprintf(stderr,
					    "driver does not support "
					    "altq\n");
				err(1, "DIOCADDALTQ");
d963 2
a964 1
pfctl_rules(int dev, char *filename, int opts)
d966 3
d970 1
a970 1
	struct pfioc_rule	pr[PF_RULESET_MAX];
d973 12
a984 1
	int			i;
d988 6
a993 5
	for (i = 0; i < PF_RULESET_MAX; i++) {
		memset(&pr[i], 0, sizeof(pr[i]));
		memcpy(pr[i].anchor, anchorname, sizeof(pr[i].anchor));
		memcpy(pr[i].ruleset, rulesetname, sizeof(pr[i].ruleset));
	}
d998 4
a1001 1
		fin = fopen(filename, "r");
a1003 33
	if (fin == NULL) {
		warn("%s", filename);
		return (1);
	}
	if ((opts & PF_OPT_NOACTION) == 0) {
		if ((loadopt & (PFCTL_FLAG_NAT | PFCTL_FLAG_ALL)) != 0) {
			pr[PF_RULESET_NAT].rule.action = PF_NAT;
			if (ioctl(dev, DIOCBEGINRULES, &pr[PF_RULESET_NAT]))
				err(1, "DIOCBEGINRULES");
			pr[PF_RULESET_RDR].rule.action = PF_RDR;
			if (ioctl(dev, DIOCBEGINRULES, &pr[PF_RULESET_RDR]))
				err(1, "DIOCBEGINRULES");
			pr[PF_RULESET_BINAT].rule.action = PF_BINAT;
			if (ioctl(dev, DIOCBEGINRULES, &pr[PF_RULESET_BINAT]))
				err(1, "DIOCBEGINRULES");
		}
		if (((altqsupport && (loadopt &
		    (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0)) &&
		    ioctl(dev, DIOCBEGINALTQS, &pa.ticket)) {
			err(1, "DIOCBEGINALTQS");
		}
		if ((loadopt & (PFCTL_FLAG_FILTER | PFCTL_FLAG_ALL)) != 0) {
			pr[PF_RULESET_SCRUB].rule.action = PF_SCRUB;
			if (ioctl(dev, DIOCBEGINRULES, &pr[PF_RULESET_SCRUB]))
				err(1, "DIOCBEGINRULES");
			pr[PF_RULESET_FILTER].rule.action = PF_PASS;
			if (ioctl(dev, DIOCBEGINRULES, &pr[PF_RULESET_FILTER]))
				err(1, "DIOCBEGINRULES");
		}
		if (loadopt & (PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL))
			pfctl_begin_table();
	}
	/* fill in callback data */
d1007 2
d1010 1
a1010 3
	for (i = 0; i < PF_RULESET_MAX; i++) {
		pf.prule[i] = &pr[i];
	}
d1012 3
a1014 5
	if (parse_rules(fin, &pf) < 0)
		errx(1, "Syntax error in file: pf rules not loaded");
	if ((altqsupport && (loadopt & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0))
		if (check_commit_altq(dev, opts) != 0)
			errx(1, "errors in altq config");
d1016 41
a1056 25
		if ((loadopt & (PFCTL_FLAG_NAT | PFCTL_FLAG_ALL)) != 0) {
			pr[PF_RULESET_NAT].rule.action = PF_NAT;
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_NAT]))
				err(1, "DIOCCOMMITRULES");
			pr[PF_RULESET_RDR].rule.action = PF_RDR;
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_RDR]))
				err(1, "DIOCCOMMITRULES");
			pr[PF_RULESET_BINAT].rule.action = PF_BINAT;
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_BINAT]))
				err(1, "DIOCCOMMITRULES");
		}
		if (((altqsupport && (loadopt &
		    (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0)) &&
		    ioctl(dev, DIOCCOMMITALTQS, &pa.ticket))
			err(1, "DIOCCOMMITALTQS");
		if ((loadopt & (PFCTL_FLAG_FILTER | PFCTL_FLAG_ALL)) != 0) {
			pr[PF_RULESET_SCRUB].rule.action = PF_SCRUB;
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_SCRUB]))
				err(1, "DIOCCOMMITRULES");
			pr[PF_RULESET_FILTER].rule.action = PF_PASS;
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_FILTER]))
				err(1, "DIOCCOMMITRULES");
		}
		if (loadopt & (PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL))
			pfctl_commit_table();
d1058 3
d1063 22
a1084 1
	return (0);
d1093 1
a1093 1
	if ((loadopt & (PFCTL_FLAG_OPTION | PFCTL_FLAG_ALL)) == 0)
d1132 1
a1132 1
	if ((loadopt & (PFCTL_FLAG_OPTION | PFCTL_FLAG_ALL)) == 0)
d1166 1
a1166 1
	if ((loadopt & (PFCTL_FLAG_OPTION | PFCTL_FLAG_ALL)) == 0)
d1195 1
a1195 1
	if ((loadopt & (PFCTL_FLAG_OPTION | PFCTL_FLAG_ALL)) == 0)
d1218 49
d1283 3
d1323 1
a1323 1
pfctl_show_anchors(int dev, int opts)
a1335 1
		printf("%u anchors:\n", mnr);
d1342 3
a1360 1
		printf("%u rulesets in anchor %s:\n", mnr, anchorname);
d1371 2
a1372 2
char *
pfctl_lookup_option(char *cmd, char **list)
d1384 6
a1389 4
	int error = 0;
	int ch;
	int mode = O_RDONLY;
	int opts = 0;
a1436 1
			loadopt &= ~PFCTL_FLAG_ALL;
a1449 1
			loadopt &= ~PFCTL_FLAG_ALL;
a1452 1
			loadopt &= ~PFCTL_FLAG_ALL;
a1455 1
			loadopt &= ~PFCTL_FLAG_ALL;
d1505 1
a1505 1
			loadopt = PFCTL_FLAG_TABLE;
d1507 1
a1507 1
		} else {
a1508 6
			if (opts & PF_OPT_NOACTION) {
				dev = open("/dev/pf", mode);
				if (dev >= 0)
					opts |= PF_OPT_DUMMYACTION;
			}
		}
d1514 2
d1543 1
a1543 5
		if (loadopt & PFCTL_FLAG_ALL) {
			loadopt &= ~PFCTL_FLAG_ALL;
			loadopt |= PFCTL_FLAG_FILTER;
			loadopt |= PFCTL_FLAG_NAT;
		}
d1552 3
d1565 67
d1635 1
a1635 1
			pfctl_clear_rules(dev, opts);
d1638 1
a1638 1
			pfctl_clear_nat(dev, opts);
d1646 3
d1653 2
a1654 2
			pfctl_clear_rules(dev, opts);
			pfctl_clear_nat(dev, opts);
d1657 1
d1659 5
a1663 1
			pfctl_clear_tables(opts);
d1666 1
a1666 1
			pfctl_clear_tables(opts);
a1667 2
		default:
			assert(0);
d1675 1
a1675 1
		    tblcmdopt, rulesopt, opts);
d1680 1
a1680 1
		if (pfctl_rules(dev, rulesopt, opts))
d1683 7
a1689 46
	if (showopt != NULL) {
		switch (*showopt) {
		case 'A':
			pfctl_show_anchors(dev, opts);
			break;
		case 'r':
			pfctl_show_rules(dev, opts, 0);
			break;
		case 'l':
			pfctl_show_rules(dev, opts, 1);
			break;
		case 'n':
			pfctl_show_nat(dev, opts);
			break;
		case 'q':
			pfctl_show_altq(dev, opts, opts & PF_OPT_VERBOSE2);
			break;
		case 's':
			pfctl_show_states(dev, 0, opts);
			break;
		case 'i':
			pfctl_show_status(dev);
			break;
		case 't':
			pfctl_show_timeouts(dev);
			break;
		case 'm':
			pfctl_show_limits(dev);
			break;
		case 'a':
			pfctl_show_rules(dev, opts, 0);
			pfctl_show_nat(dev, opts);
			pfctl_show_altq(dev, opts, 0);
			pfctl_show_states(dev, 0, opts);
			pfctl_show_status(dev);
			pfctl_show_rules(dev, opts, 1);
			pfctl_show_timeouts(dev);
			pfctl_show_limits(dev);
			pfctl_show_tables(opts);
			break;
		case 'T':
			pfctl_show_tables(opts);
			break;
		default:
			assert(0);
		}
d1707 3
a1709 2
		default:
			assert(0);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD repository of CTM 3155 (roughly today at noon).
Mostly in order to go 3.3-current and ease further merges of
both OpenBSD and ELFdiffs after the MirBSD has been enabled
to build again.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.163 2003/03/27 20:21:34 dhartmei Exp $ */
d79 1
a79 1
const char	*pfctl_lookup_option(char *, const char **);
d81 1
a81 1
const char	*clearopt;
d83 2
a84 2
const char	*showopt;
const char	*debugopt;
d87 1
a87 1
const char	*tblcmdopt;
d161 1
a161 1
static const char *clearopt_list[] = {
d165 1
a165 1
static const char *showopt_list[] = {
d170 1
a170 1
static const char *tblcmdopt_list[] = {
d175 1
a175 1
static const char *debugopt_list[] = {
d432 1
a432 1
			errx(1, "Unknown address family %d", psk.psk_af);
d467 1
a467 2
					errx(1, "Unknown address family %d",
					    psk.psk_af);
d982 1
a982 4
		if ((fin = fopen(filename, "r")) == NULL) {
			warn("%s", filename);
			return (1);
		}
d985 4
d1027 1
a1027 1
		errx(1, "Syntax error in config file: pf rules not loaded");
d1294 2
a1295 2
const char *
pfctl_lookup_option(char *cmd, const char **list)
@


1.1.1.3
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.167 2003/04/03 15:52:24 cedric Exp $ */
a680 2
	static int nattype[3] = { PF_NAT, PF_RDR, PF_BINAT };
	int i;
d713 29
a741 4
	for (i = 0; i < 3; i++) {
		pr.rule.action = nattype[i];
		if (ioctl(dev, DIOCGETRULES, &pr)) {
			warn("DIOCGETRULES");
d744 18
a761 13
		mnr = pr.nr;
		for (nr = 0; nr < mnr; ++nr) {
			pr.nr = nr;
			if (ioctl(dev, DIOCGETRULE, &pr)) {
				warn("DIOCGETRULE");
				return (-1);
			}
			if (pfctl_get_pool(dev, &pr.rule.rpool, nr,
			    pr.ticket, nattype[i]) != 0)
				return (-1);
			print_rule(&pr.rule, opts & PF_OPT_VERBOSE2);
			pfctl_print_rule_counters(&pr.rule, opts);
			pfctl_clear_pool(&pr.rule.rpool);
d763 6
d949 2
a950 1
					errx(1, "qtype not configured");
d952 4
a955 4
					errx(1, "%s: driver does not support "
					    "altq", a->ifname);
				else
					err(1, "DIOCADDALTQ");
@


1.1.1.4
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.169 2003/04/30 13:22:26 henning Exp $ */
d61 2
a62 2
int	 pfctl_clear_rules(int, int, char *, char *);
int	 pfctl_clear_nat(int, int, char *, char *);
d66 1
a66 2
int	 pfctl_get_pool(int, struct pf_pool *, u_int32_t, u_int32_t, int,
	     char *, char *);
d68 2
a69 2
int	 pfctl_show_rules(int, int, int, char *, char *);
int	 pfctl_show_nat(int, int, char *, char *);
d74 1
a74 1
int	 pfctl_rules(int, char *, int, char *, char *);
d78 1
a78 1
int	 pfctl_show_anchors(int, int, char *);
d92 2
d257 1
a257 1
pfctl_clear_rules(int dev, int opts, char *anchorname, char *rulesetname)
d280 3
a282 2
			r = pfctl_clear_rules(dev, opts | PF_OPT_QUIET,
			    anchorname, pr.name);
d309 1
a309 1
pfctl_clear_nat(int dev, int opts, char *anchorname, char *rulesetname)
d332 3
a334 2
			r = pfctl_clear_nat(dev, opts | PF_OPT_QUIET,
			    anchorname, pr.name);
d496 1
a496 1
    u_int32_t ticket, int r_action, char *anchorname, char *rulesetname)
d572 1
a572 2
pfctl_show_rules(int dev, int opts, int format, char *anchorname,
    char *rulesetname)
d597 3
a599 2
			r = pfctl_show_rules(dev, opts, format, anchorname,
			    pr.name);
d623 1
a623 1
		    nr, pr.ticket, PF_SCRUB, anchorname, rulesetname) != 0)
d655 1
a655 1
		    nr, pr.ticket, PF_PASS, anchorname, rulesetname) != 0)
d677 1
a677 1
pfctl_show_nat(int dev, int opts, char *anchorname, char *rulesetname)
d703 3
a705 1
			r = pfctl_show_nat(dev, opts, anchorname, pr.name);
d729 1
a729 2
			    pr.ticket, nattype[i], anchorname,
			    rulesetname) != 0)
d929 1
a929 2
pfctl_rules(int dev, char *filename, int opts, char *anchorname,
    char *rulesetname)
a990 2
	pf.anchor = anchorname;
	pf.ruleset = rulesetname;
d999 2
a1000 3
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_NAT]) &&
			    (errno != EINVAL || pf.rule_nr))
				err(1, "DIOCCOMMITRULES NAT");
d1002 2
a1003 3
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_RDR]) &&
			    (errno != EINVAL || pf.rule_nr))
				err(1, "DIOCCOMMITRULES RDR");
d1005 2
a1006 3
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_BINAT]) &&
			    (errno != EINVAL || pf.rule_nr))
				err(1, "DIOCCOMMITRULES BINAT");
d1014 2
a1015 3
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_SCRUB]) &&
			    (errno != EINVAL || pf.rule_nr))
				err(1, "DIOCCOMMITRULES SCRUB");
d1017 2
a1018 3
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_FILTER]) &&
			    (errno != EINVAL || pf.rule_nr))
				err(1, "DIOCCOMMITRULES FILTER");
d1212 1
a1212 1
pfctl_show_anchors(int dev, int opts, char *anchorname)
d1272 4
a1275 6
	int	error = 0;
	int	ch;
	int	mode = O_RDONLY;
	int	opts = 0;
	char	anchorname[PF_ANCHOR_NAME_SIZE];
	char	rulesetname[PF_RULESET_NAME_SIZE];
a1440 1
			loadopt |= PFCTL_FLAG_TABLE;
d1463 1
a1463 1
			pfctl_clear_rules(dev, opts, anchorname, rulesetname);
d1466 1
a1466 1
			pfctl_clear_nat(dev, opts, anchorname, rulesetname);
d1478 2
a1479 2
			pfctl_clear_rules(dev, opts, anchorname, rulesetname);
			pfctl_clear_nat(dev, opts, anchorname, rulesetname);
d1483 1
a1483 1
			pfctl_clear_tables(anchorname, rulesetname, opts);
d1486 1
a1486 1
			pfctl_clear_tables(anchorname, rulesetname, opts);
d1497 1
a1497 1
		    tblcmdopt, rulesopt, anchorname, rulesetname, opts);
d1502 1
a1502 1
		if (pfctl_rules(dev, rulesopt, opts, anchorname, rulesetname))
d1508 1
a1508 1
			pfctl_show_anchors(dev, opts, anchorname);
d1511 1
a1511 2
			pfctl_show_rules(dev, opts, 0, anchorname,
			    rulesetname);
d1514 1
a1514 2
			pfctl_show_rules(dev, opts, 1, anchorname,
			    rulesetname);
d1517 1
a1517 1
			pfctl_show_nat(dev, opts, anchorname, rulesetname);
d1535 2
a1536 3
			pfctl_show_rules(dev, opts, 0, anchorname,
			    rulesetname);
			pfctl_show_nat(dev, opts, anchorname, rulesetname);
d1540 1
a1540 1
			pfctl_show_rules(dev, opts, 1, anchorname, rulesetname);
d1543 1
a1543 1
			pfctl_show_tables(anchorname, rulesetname, opts);
d1546 1
a1546 1
			pfctl_show_tables(anchorname, rulesetname, opts);
@


1.1.1.5
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.175 2003/05/19 02:32:47 henning Exp $ */
d75 1
d83 1
a83 1
char		*rulesopt;
d86 2
a87 2
char		*anchoropt;
char		*tableopt;
d89 4
a92 4
int		 state_killers;
char		*state_kill[2];
int		 loadopt = PFCTL_FLAG_ALL;
int		 altqsupport;
d94 1
a94 1
int		 dev = -1;
d96 1
a96 1
const char	*infile;
d205 10
a214 3
	if (altqsupport && ioctl(dev, DIOCSTARTALTQ))
		if (errno != EEXIST)
			err(1, "DIOCSTARTALTQ");
d231 5
a235 2
	if (altqsupport && ioctl(dev, DIOCSTOPALTQ))
			if (errno != ENOENT)
d237 4
d546 1
a546 1
		printf("  [ Skip steps: ");
d558 1
a558 1
		printf("  [ queue: qname=%s qid=%u pqname=%s pqid=%u ]\n",
d562 2
a563 2
		printf("  [ Evaluations: %-8llu  Packets: %-8llu  "
			    "Bytes: %-10llu  States: %-6u]\n",
d756 1
a756 1
		if (ps.ps_len + sizeof(struct pfioc_states) < len)
d799 1
a799 6
		printf("%-20s %10d", pf_timeouts[i].name, pt.seconds);
		if (i >= PFTM_ADAPTIVE_START && i <= PFTM_ADAPTIVE_END)
			printf(" states");
		else
			printf("s");
		printf("\n");
a1028 6

	/* process "load anchor" directives */
	if (!anchorname[0] && !rulesetname[0])
		if (pfctl_load_anchors(dev, opts) == -1)
			return (-1);

@


1.1.1.6
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.176 2003/06/03 12:18:57 henning Exp $ */
d1463 45
a1557 45

	if (clearopt != NULL) {
		switch (*clearopt) {
		case 'r':
			pfctl_clear_rules(dev, opts, anchorname, rulesetname);
			break;
		case 'n':
			pfctl_clear_nat(dev, opts, anchorname, rulesetname);
			break;
		case 'q':
			pfctl_clear_altq(dev, opts);
			break;
		case 's':
			pfctl_clear_states(dev, opts);
			break;
		case 'i':
			pfctl_clear_stats(dev, opts);
			break;
		case 'a':
			pfctl_clear_rules(dev, opts, anchorname, rulesetname);
			pfctl_clear_nat(dev, opts, anchorname, rulesetname);
			pfctl_clear_altq(dev, opts);
			pfctl_clear_states(dev, opts);
			pfctl_clear_stats(dev, opts);
			pfctl_clear_tables(anchorname, rulesetname, opts);
			break;
		case 'T':
			pfctl_clear_tables(anchorname, rulesetname, opts);
			break;
		default:
			assert(0);
		}
	}
	if (state_killers)
		pfctl_kill_states(dev, opts);

	if (tblcmdopt != NULL) {
		error = pfctl_command_tables(argc, argv, tableopt,
		    tblcmdopt, rulesopt, anchorname, rulesetname, opts);
		rulesopt = NULL;
	}

	if (rulesopt != NULL)
		if (pfctl_rules(dev, rulesopt, opts, anchorname, rulesetname))
			error = 1;
@


1.1.1.7
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.177 2003/06/13 12:10:42 cedric Exp $ */
d1225 1
a1225 2
		if (!(opts & PF_OPT_QUIET))
			printf("%u anchors:\n", mnr);
d1248 1
a1248 2
		if (!(opts & PF_OPT_QUIET))
			printf("%u rulesets in anchor %s:\n", mnr, anchorname);
@


1.1.1.8
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.178 2003/06/29 12:22:39 dhartmei Exp $ */
d52 1
d1511 2
d1544 2
d1576 2
@


1.1.1.9
log
@more fixes from -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.177 2003/06/13 12:10:42 cedric Exp $ */
a51 1
#include <assert.h>
a1509 2
		default:
			assert(0);
a1540 2
		default:
			assert(0);
a1570 2
		default:
			assert(0);
@


1.1.1.10
log
@-current
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.178 2003/06/29 12:22:39 dhartmei Exp $ */
d52 1
d1511 2
d1544 2
d1576 2
@


1.1.1.11
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.180 2003/07/03 21:09:13 cedric Exp $ */
a916 3
#define ERR(x) do { warn(x); goto _error; } while(0)
#define ERRX(x) do { warnx(x); goto _error; } while(0)

a920 1
	struct pfr_buffer	ab;
a924 2
	memset(&ab, 0, sizeof(ab));
	ab.pfrb_type = PFRB_ADDRS;
d944 1
a944 1
				ERR("DIOCBEGINRULES");
d947 1
a947 1
				ERR("DIOCBEGINRULES");
d950 1
a950 1
				ERR("DIOCBEGINRULES");
d955 1
a955 1
			ERR("DIOCBEGINALTQS");
d960 1
a960 1
				ERR("DIOCBEGINRULES");
d963 1
a963 5
				ERR("DIOCBEGINRULES");
		}
		if (loadopt & (PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL)) {
		        if (pfr_ina_begin(&pf.tticket, NULL, 0) != 0)
				ERR("begin table");
d965 2
a972 1
	pf.ab = &ab;
d980 1
a980 1
		ERRX("Syntax error in config file: pf rules not loaded");
d983 1
a983 1
			ERRX("errors in altq config");
d989 1
a989 1
				ERR("DIOCCOMMITRULES NAT");
d993 1
a993 1
				ERR("DIOCCOMMITRULES RDR");
d997 1
a997 1
				ERR("DIOCCOMMITRULES BINAT");
d1002 1
a1002 1
			ERR("DIOCCOMMITALTQS");
d1007 1
a1007 1
				ERR("DIOCCOMMITRULES SCRUB");
d1011 1
a1011 6
				ERR("DIOCCOMMITRULES FILTER");
		}
		if (loadopt & (PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL)) {
			if (pfr_ina_commit(pf.tticket, NULL, NULL, 0))
				ERR("commit table");
			pf.tdirty = 0;
d1013 2
d1022 1
a1022 1
			ERRX("load anchors");
a1024 8

_error:
	if (pf.tdirty) /* cleanup kernel leftover */
		pfr_ina_begin(NULL, NULL, 0);
	exit(1);

#undef ERR
#undef ERRX
@


1.1.1.12
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.182 2003/07/18 06:30:07 cedric Exp $ */
d89 1
a89 1
int		 loadopt;
d843 1
a843 1
		if ((loadopt & PFCTL_FLAG_FILTER) == 0)
d849 1
a849 1
		if ((loadopt & PFCTL_FLAG_FILTER) == 0)
d855 1
a855 1
		if ((loadopt & PFCTL_FLAG_NAT) == 0)
d861 1
a861 1
		if ((loadopt & PFCTL_FLAG_NAT) == 0)
d867 1
a867 1
		if ((loadopt & PFCTL_FLAG_NAT) == 0)
d895 1
a895 1
	    (loadopt & PFCTL_FLAG_ALTQ) != 0) {
d924 1
d929 2
d947 1
a947 1
		if ((loadopt & PFCTL_FLAG_NAT) != 0) {
d958 2
a959 1
		if (((altqsupport && (loadopt & PFCTL_FLAG_ALTQ) != 0)) &&
d963 1
a963 1
		if ((loadopt & PFCTL_FLAG_FILTER) != 0) {
d971 2
a972 2
		if (loadopt & PFCTL_FLAG_TABLE) {
			if (pfr_ina_begin(&pf.tticket, NULL, 0) != 0)
d981 1
d990 1
a990 1
	if ((altqsupport && (loadopt & PFCTL_FLAG_ALTQ) != 0))
d994 1
a994 1
		if ((loadopt & PFCTL_FLAG_NAT) != 0) {
d1008 2
a1009 1
		if (((altqsupport && (loadopt & PFCTL_FLAG_ALTQ) != 0)) &&
d1012 1
a1012 1
		if ((loadopt & PFCTL_FLAG_FILTER) != 0) {
d1022 1
a1022 1
		if (loadopt & PFCTL_FLAG_TABLE) {
d1053 1
a1053 1
	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
d1092 1
a1092 1
	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
d1126 1
a1126 1
	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
d1155 1
a1155 1
	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
d1346 1
d1360 1
d1364 1
d1368 1
d1418 1
a1418 1
			loadopt |= PFCTL_FLAG_TABLE;
a1432 2
	if (loadopt == 0)
		loadopt = ~0;
d1460 6
a1465 1
		loadopt &= PFCTL_FLAG_FILTER|PFCTL_FLAG_NAT|PFCTL_FLAG_TABLE;
@


1.1.1.13
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.185 2003/08/04 17:29:44 dhartmei Exp $ */
a923 1
	struct pfr_table	trs;
a927 1
	memset(&trs, 0, sizeof(trs));
a932 5
	if (strlcpy(trs.pfrt_anchor, anchorname,
	    sizeof(trs.pfrt_anchor)) >= sizeof(trs.pfrt_anchor) ||
	    strlcpy(trs.pfrt_ruleset, rulesetname,
	    sizeof(trs.pfrt_ruleset)) >= sizeof(trs.pfrt_ruleset))
		ERRX("pfctl_rules: strlcpy");
d968 1
a968 1
			if (pfr_ina_begin(&trs, &pf.tticket, NULL, 0) != 0)
d983 2
a984 7
	if (parse_rules(fin, &pf) < 0) {
		if ((opts & PF_OPT_NOACTION) == 0)
			ERRX("Syntax error in config file: "
			    "pf rules not loaded");
		else
			goto _error;
	}
d1017 1
a1017 1
			if (pfr_ina_commit(&trs, pf.tticket, NULL, NULL, 0))
d1034 1
a1034 1
		pfr_ina_begin(&trs, NULL, NULL, 0);
@


1.1.1.14
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.188 2003/08/29 21:47:36 cedric Exp $ */
d159 1
a159 1
	"nat", "queue", "rules", "state", "info", "Tables", "osfp", "all", NULL
d164 1
a164 1
	"timeouts", "memory", "Tables", "osfp", "all", NULL
d173 1
a173 1
	"none", "urgent", "misc", "loud", NULL
a1199 3
		case PF_DEBUG_NOISY:
			fprintf(stderr, "loud");
			break;
a1488 1
			pfctl_load_fingerprints(dev, opts);
a1492 1
			pfctl_load_fingerprints(dev, opts);
a1496 1
			pfctl_load_fingerprints(dev, opts);
a1514 2
			pfctl_load_fingerprints(dev, opts);

a1524 1
			pfctl_show_fingerprints(opts);
a1528 4
		case 'o':
			pfctl_load_fingerprints(dev, opts);
			pfctl_show_fingerprints(opts);
			break;
a1555 4
			pfctl_clear_fingerprints(dev, opts);
			break;
		case 'o':
			pfctl_clear_fingerprints(dev, opts);
a1571 4
		if (pfctl_file_fingerprints(dev, opts, PF_OSFP_FILE))
			error = 1;

	if (rulesopt != NULL) {
a1573 4
		else if (!(opts & PF_OPT_NOACTION) &&
		    (loadopt & PFCTL_FLAG_TABLE))
			warn_namespace_collision(NULL);
	}
a1588 3
			break;
		case 'l':
			pfctl_debug(dev, PF_DEBUG_NOISY, opts);
@


1.1.1.15
log
@cvs is playing games with me.

@@@@@@ CONSIDER THE TREE LOCKED NOW @@@@@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.189 2003/09/26 21:44:09 cedric Exp $ */
d242 1
a242 1
	struct pfr_buffer t;
d272 13
a284 7
	memset(&t, 0, sizeof(t));
	t.pfrb_type = PFRB_TRANS;
	if (pfctl_add_trans(&t, PF_RULESET_SCRUB, anchorname, rulesetname) ||
	    pfctl_add_trans(&t, PF_RULESET_FILTER, anchorname, rulesetname) ||
	    pfctl_trans(dev, &t, DIOCXBEGIN, 0) ||
	    pfctl_trans(dev, &t, DIOCXCOMMIT, 0))
		err(1, "pfctl_clear_rules");
d293 1
a293 1
	struct pfr_buffer t;
d323 18
a340 8
	memset(&t, 0, sizeof(t));
	t.pfrb_type = PFRB_TRANS;
	if (pfctl_add_trans(&t, PF_RULESET_NAT, anchorname, rulesetname) ||
	    pfctl_add_trans(&t, PF_RULESET_BINAT, anchorname, rulesetname) ||
	    pfctl_add_trans(&t, PF_RULESET_RDR, anchorname, rulesetname) ||
	    pfctl_trans(dev, &t, DIOCXBEGIN, 0) ||
	    pfctl_trans(dev, &t, DIOCXCOMMIT, 0))
		err(1, "pfctl_clear_nat");
d349 1
a349 1
	struct pfr_buffer t;
d353 5
a357 6
	memset(&t, 0, sizeof(t));
	t.pfrb_type = PFRB_TRANS;
	if (pfctl_add_trans(&t, PF_RULESET_ALTQ, "", "") ||
	    pfctl_trans(dev, &t, DIOCXBEGIN, 0) ||
	    pfctl_trans(dev, &t, DIOCXCOMMIT, 0))
		err(1, "pfctl_clear_altq");
d839 1
a839 2
	u_int8_t		rs_num;
	struct pfioc_rule	pr;
a876 6
		bzero(&pr, sizeof(pr));
		if (strlcpy(pr.anchor, pf->anchor, sizeof(pr.anchor)) >=
		    sizeof(pr.anchor) ||
		    strlcpy(pr.ruleset, pf->ruleset, sizeof(pr.ruleset)) >=
		    sizeof(pr.ruleset))
			errx(1, "pfctl_add_rule: strlcpy");
d879 4
a882 5
		pr.ticket = pfctl_get_ticket(pf->trans, rs_num, pf->anchor,
		    pf->ruleset);    
		pr.pool_ticket = pf->paddr.ticket;
		memcpy(&pr.rule, r, sizeof(pr.rule));
		if (ioctl(pf->dev, DIOCADDRULE, &pr))
d915 1
a915 1
    char *rulesetname, struct pfr_buffer *trans)
d921 1
a921 1
	struct pfr_buffer      *t, buf;
d925 1
a925 1
	int			osize;
a926 10
	if (trans == NULL) {
	    bzero(&buf, sizeof(buf));
	    buf.pfrb_type = PFRB_TRANS;
	    t = &buf;
	    osize = 0;
	} else {
	    t = trans;
	    osize = t->pfrb_size;
	}
    
d930 5
d950 30
a982 2
	if (anchorname[0])
		pf.loadopt &= ~PFCTL_FLAG_ALTQ;
d984 3
a986 1
	pf.trans = t;
a989 37

	if ((opts & PF_OPT_NOACTION) == 0) {
		if ((pf.loadopt & PFCTL_FLAG_NAT) != 0) {
			if (pfctl_add_trans(t, PF_RULESET_NAT, anchorname,
			    rulesetname) ||
			    pfctl_add_trans(t, PF_RULESET_BINAT, anchorname,
			    rulesetname) ||
			    pfctl_add_trans(t, PF_RULESET_RDR, anchorname,
			    rulesetname))
				ERR("pfctl_rules");
		}
		if (((altqsupport && (pf.loadopt & PFCTL_FLAG_ALTQ) != 0))) {
			if (pfctl_add_trans(t, PF_RULESET_ALTQ, anchorname,
			    rulesetname))
				ERR("pfctl_rules");
		}
		if ((pf.loadopt & PFCTL_FLAG_FILTER) != 0) {
			if (pfctl_add_trans(t, PF_RULESET_SCRUB, anchorname,
			    rulesetname) ||
			    pfctl_add_trans(t, PF_RULESET_FILTER, anchorname,
			    rulesetname))
				ERR("pfctl_rules");
		}
		if (pf.loadopt & PFCTL_FLAG_TABLE) {
			if (pfctl_add_trans(t, PF_RULESET_TABLE, anchorname,
			    rulesetname))
				ERR("pfctl_rules");
		}
		if (pfctl_trans(dev, t, DIOCXBEGIN, osize))
			ERR("DIOCXBEGIN");
		if (altqsupport && (pf.loadopt & PFCTL_FLAG_ALTQ))
			pa.ticket = pfctl_get_ticket(t, PF_RULESET_ALTQ,
			    anchorname, rulesetname);
		if (pf.loadopt & PFCTL_FLAG_TABLE)
			pf.tticket = pfctl_get_ticket(t, PF_RULESET_TABLE,
			    anchorname, rulesetname);
	}
d997 1
a997 1
	if ((altqsupport && (pf.loadopt & PFCTL_FLAG_ALTQ) != 0))
d1000 34
d1039 1
a1039 1
		if (pfctl_load_anchors(dev, opts, t) == -1)
a1041 3
	if (trans == NULL && (opts & PF_OPT_NOACTION) == 0)
		if (pfctl_trans(dev, t, DIOCXCOMMIT, 0))
			ERR("DIOCXCOMMIT");
d1045 3
a1047 7
	if (trans == NULL) {	/* main ruleset */
		if ((opts & PF_OPT_NOACTION) == 0)
			if (pfctl_trans(dev, t, DIOCXROLLBACK, 0))
				err(1, "DIOCXROLLBACK");
		exit(1);
	} else			/* sub ruleset */
		return (-1);
d1593 1
a1593 2
		if (pfctl_rules(dev, rulesopt, opts, anchorname, rulesetname,
		    NULL))
@


1.1.1.16
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.196 2003/12/19 16:12:43 henning Exp $ */
a4 1
 * Copyright (c) 2002,2003 Henning Brauer
a62 1
int	 pfctl_clear_src_nodes(int, int);
a69 1
int	 pfctl_show_src_nodes(int, int);
d71 1
a71 1
int	 pfctl_show_status(int, int);
d159 1
a159 2
	"nat", "queue", "rules", "Sources",
	"state", "info", "Tables", "osfp", "all", NULL
d163 2
a164 2
	"nat", "queue", "rules", "Anchors", "Sources", "state", "info",
	"labels", "timeouts", "memory", "Tables", "ospf", "all", NULL
a348 10
pfctl_clear_src_nodes(int dev, int opts)
{
	if (ioctl(dev, DIOCCLRSRCNODES))
		err(1, "DIOCCLRSRCNODES");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "source tracking entries cleared\n");
	return (0);
}

int
a704 40
pfctl_show_src_nodes(int dev, int opts)
{
	struct pfioc_src_nodes psn;
	struct pf_src_node *p;
	char *inbuf = NULL, *newinbuf = NULL;
	unsigned len = 0;
	int i;

	memset(&psn, 0, sizeof(psn));
	for (;;) {
		psn.psn_len = len;
		if (len) {
			newinbuf = realloc(inbuf, len);
			if (newinbuf == NULL)
				err(1, "realloc");
			psn.psn_buf = inbuf = newinbuf;
		}
		if (ioctl(dev, DIOCGETSRCNODES, &psn) < 0) {
			warn("DIOCGETSRCNODES");
			return (-1);
		}
		if (psn.psn_len + sizeof(struct pfioc_src_nodes) < len)
			break;
		if (len == 0 && psn.psn_len == 0)
			return (0);
		if (len == 0 && psn.psn_len != 0)
			len = psn.psn_len;
		if (psn.psn_len == 0)
			return (0);	/* no src_nodes */
		len *= 2;
	}
	p = psn.psn_src_nodes;
	for (i = 0; i < psn.psn_len; i += sizeof(*p)) {
		print_src_node(p, opts);
		p++;
	}
	return (0);
}

int
d709 1
a709 1
	char *inbuf = NULL, *newinbuf = NULL;
d717 2
a718 2
			newinbuf = realloc(inbuf, len);
			if (newinbuf == NULL)
a719 1
			ps.ps_buf = inbuf = newinbuf;
d745 1
a745 1
pfctl_show_status(int dev, int opts)
d753 1
a753 1
	print_status(&status, opts);
d872 1
a872 1
		    pf->ruleset);
d929 1
a929 1

a1161 49
pfctl_set_hostid(struct pfctl *pf, u_int32_t hostid)
{
	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

	HTONL(hostid);

	if ((pf->opts & PF_OPT_NOACTION) == 0)
		if (ioctl(dev, DIOCSETHOSTID, &hostid))
			err(1, "DIOCSETHOSTID");

	if (pf->opts & PF_OPT_VERBOSE)
		printf("set hostid 0x%08x\n", ntohl(hostid));

	return (0);
}

int
pfctl_set_debug(struct pfctl *pf, char *d)
{
	u_int32_t	level;

	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

	if (!strcmp(d, "none"))
		level = PF_DEBUG_NONE;
	else if (!strcmp(d, "urgent"))
		level = PF_DEBUG_URGENT;
	else if (!strcmp(d, "misc"))
		level = PF_DEBUG_MISC;
	else if (!strcmp(d, "loud"))
		level = PF_DEBUG_NOISY;
	else {
		warnx("unknown debug level \"%s\"", d);
		return (-1);
	}

	if ((pf->opts & PF_OPT_NOACTION) == 0)
		if (ioctl(dev, DIOCSETDEBUG, &level))
			err(1, "DIOCSETDEBUG");

	if (pf->opts & PF_OPT_VERBOSE)
		printf("set debug %s\n", d);

	return (0);
}

int
a1488 3
		case 'S':
			pfctl_show_src_nodes(dev, opts);
			break;
d1490 1
a1490 1
			pfctl_show_status(dev, opts);
d1506 1
a1506 2
			pfctl_show_src_nodes(dev, opts);
			pfctl_show_status(dev, opts);
a1536 3
		case 'S':
			pfctl_clear_src_nodes(dev, opts);
			break;
a1544 1
			pfctl_clear_src_nodes(dev, opts);
@


1.1.1.17
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.198 2003/12/31 22:14:41 deraadt Exp $ */
d168 1
a168 2
	"Interfaces", "labels", "timeouts", "memory", "Tables", "ospf",
	"all", NULL
d1335 2
a1342 3
			if (!(opts & PF_OPT_VERBOSE) &&
			    !strcmp(pa.name, PF_RESERVED_ANCHOR))
				continue;
d1359 2
d1507 1
a1507 1
		} else
d1509 6
a1557 3
		dev = open("/dev/pf", O_RDONLY);
		if (dev >= 0)
			opts |= PF_OPT_DUMMYACTION;
a1619 1
			pfctl_show_ifaces(opts);
a1626 3
			break;
		case 'I':
			pfctl_show_ifaces(opts);
@


1.1.1.18
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.215 2004/05/05 23:16:03 frantzen Exp $ */
a36 1
#include <sys/stat.h>
d65 2
a66 2
int	 pfctl_clear_states(int, const char *, int);
int	 pfctl_kill_states(int, const char *, int);
d68 1
a68 1
	    char *, char *);
d73 1
a73 1
int	 pfctl_show_states(int, const char *, int);
d75 2
a76 2
int	 pfctl_show_timeouts(int, int);
int	 pfctl_show_limits(int, int);
a87 2
char		*pf_device = "/dev/pf";
char		*ifaceopt;
a95 2
int		 first_title = 1;
int		 labels = 0;
a103 1
	{ "src-nodes",	PF_LIMIT_SRC_NODES },
a118 1
	{ "tcp.tsdiff",		30 },
a127 1
	{ "tcp.tsdiff",		60 },
a136 1
	{ "tcp.tsdiff",		60 },
a145 1
	{ "tcp.tsdiff",		10 },
d168 1
a168 1
	"Interfaces", "labels", "timeouts", "memory", "Tables", "osfp",
d187 1
a187 1
	fprintf(stderr, "usage: %s [-AdeghNnOqRrvz] ", __progname);
d190 1
a190 2
	fprintf(stderr, "[-F modifier] [-f file] [-i interface] ");
	fprintf(stderr, "[-k host] [-p device]\n");
d192 1
a192 2
	fprintf(stderr, "[-s modifier] [-T command [address ...]] ");
	fprintf(stderr, "[-t table] [-x level]\n");
d364 1
a364 1
pfctl_clear_states(int dev, const char *iface, int opts)
d366 1
a366 8
	struct pfioc_state_kill psk;

	memset(&psk, 0, sizeof(psk));
	if (iface != NULL && strlcpy(psk.psk_ifname, iface,
	    sizeof(psk.psk_ifname)) >= sizeof(psk.psk_ifname))
		errx(1, "invalid interface: %s", iface);

	if (ioctl(dev, DIOCCLRSTATES, &psk))
d369 1
a369 1
		fprintf(stderr, "%d states cleared\n", psk.psk_af);
d374 1
a374 1
pfctl_kill_states(int dev, const char *iface, int opts)
a388 3
	if (iface != NULL && strlcpy(psk.psk_ifname, iface,
	    sizeof(psk.psk_ifname)) >= sizeof(psk.psk_ifname))
		errx(1, "invalid interface: %s", iface);
d422 1
a422 2
				errx(1, "getaddrinfo: %s",
				    gai_strerror(ret_ga));
d548 2
a549 12
			    (unsigned long long)rule->evaluations,
			    (unsigned long long)rule->packets,
			    (unsigned long long)rule->bytes, rule->states);
}

void
pfctl_print_title(char *title)
{
	if (!first_title)
		printf("\n");
	first_title = 0;
	printf("%s\n", title);
d557 1
a557 1
	u_int32_t nr, mnr, header = 0;
a573 2
		if (opts & PF_OPT_SHOWALL && pr.nr)
			pfctl_print_title("FILTER RULES:");
a589 8
	if (opts & PF_OPT_SHOWALL) {
		pr.rule.action = PF_PASS;
		if (ioctl(dev, DIOCGETRULES, &pr)) {
			warn("DIOCGETRULES");
			return (-1);
		}
		header++;
	}
a594 6
	if (opts & PF_OPT_SHOWALL) {
		if (format == 0 && (pr.nr > 0 || header))
			pfctl_print_title("FILTER RULES:");
		else if (format == 1 && labels)
			pfctl_print_title("LABEL COUNTERS:");
	}
d612 2
a613 3
				    (unsigned long long)pr.rule.evaluations,
				    (unsigned long long)pr.rule.packets,
				    (unsigned long long)pr.rule.bytes);
a616 2
			if (pr.rule.label[0] && (opts & PF_OPT_SHOWALL))
				labels = 1;
d644 2
a645 3
				    (unsigned long long)pr.rule.evaluations,
				    (unsigned long long)pr.rule.packets,
				    (unsigned long long)pr.rule.bytes);
a648 2
			if (pr.rule.label[0] && (opts & PF_OPT_SHOWALL))
				labels = 1;
d663 1
a663 1
	int i, dotitle = opts & PF_OPT_SHOWALL;
a710 4
			if (dotitle) {
				pfctl_print_title("TRANSLATION RULES:");
				dotitle = 0;
			}
a751 2
	if (psn.psn_len > 0 && (opts & PF_OPT_SHOWALL))
		pfctl_print_title("SOURCE TRACKING NODES:");
d760 1
a760 1
pfctl_show_states(int dev, const char *iface, int opts)
d766 1
a766 1
	int i, dotitle = (opts & PF_OPT_SHOWALL);
d792 4
a795 8
	for (i = 0; i < ps.ps_len; i += sizeof(*p), p++) {
		if (iface != NULL && strcmp(p->u.ifname, iface))
			continue;
		if (dotitle) {
			pfctl_print_title("STATES:");
			dotitle = 0;
		}
		print_state(p, opts);
a808 2
	if (opts & PF_OPT_SHOWALL)
		pfctl_print_title("INFO:");
d814 1
a814 1
pfctl_show_timeouts(int dev, int opts)
a818 2
	if (opts & PF_OPT_SHOWALL)
		pfctl_print_title("TIMEOUTS:");
d836 1
a836 1
pfctl_show_limits(int dev, int opts)
a840 2
	if (opts & PF_OPT_SHOWALL)
		pfctl_print_title("LIMITS:");
d843 1
a843 1
		pl.index = pf_limits[i].index;
d969 6
a974 6
	FILE			*fin;
	struct pfr_buffer	*t, buf;
	struct pfioc_altq	 pa;
	struct pfctl		 pf;
	struct pfr_table	 trs;
	int			 osize;
d998 1
a998 1
		if ((fin = pfctl_fopen(filename, "r")) == NULL) {
a1086 21
FILE *
pfctl_fopen(const char *name, const char *mode) 
{
	struct stat	 st;
	FILE		*fp;

	fp = fopen(name, mode);
	if (fp == NULL)
		return (NULL);
	if (fstat(fileno(fp), &st)) {
		fclose(fp);
		return (NULL);
	}
	if (S_ISDIR(st.st_mode)) {
		fclose(fp);
		errno = EISDIR;
		return (NULL);
	}
	return (fp);
}

d1099 1
a1099 1
			pl.index = pf_limits[i].index;
d1394 2
a1395 2
	while ((ch = getopt(argc, argv,
	    "a:AdD:eqf:F:ghi:k:nNOp:rRs:t:T:vx:z")) != -1) {
a1423 3
		case 'i':
			ifaceopt = optarg;
			break;
a1457 3
		case 'p':
			pf_device = optarg;
			break;
d1547 1
a1547 1
		dev = open(pf_device, mode);
d1549 1
a1549 1
			err(1, "%s", pf_device);
d1552 1
a1552 1
		dev = open(pf_device, O_RDONLY);
d1585 1
a1585 2
			pfctl_show_altq(dev, ifaceopt, opts,
			    opts & PF_OPT_VERBOSE2);
d1588 1
a1588 1
			pfctl_show_states(dev, ifaceopt, opts);
d1597 1
a1597 1
			pfctl_show_timeouts(dev, opts);
d1600 1
a1600 1
			pfctl_show_limits(dev, opts);
a1602 1
			opts |= PF_OPT_SHOWALL;
a1604 1
			pfctl_show_nat(dev, opts, anchorname, rulesetname);
d1607 3
a1609 2
			pfctl_show_altq(dev, ifaceopt, opts, 0);
			pfctl_show_states(dev, ifaceopt, opts);
d1613 2
a1614 2
			pfctl_show_timeouts(dev, opts);
			pfctl_show_limits(dev, opts);
d1617 1
d1627 1
a1627 1
			pfctl_show_ifaces(ifaceopt, opts);
d1644 1
a1644 1
			pfctl_clear_states(dev, ifaceopt, opts);
d1655 4
d1660 1
a1660 7
			if (!*anchorname && !*rulesetname) {
				pfctl_clear_altq(dev, opts);
				pfctl_clear_states(dev, ifaceopt, opts);
				pfctl_clear_src_nodes(dev, opts);
				pfctl_clear_stats(dev, opts);
				pfctl_clear_fingerprints(dev, opts);
			}
d1671 1
a1671 1
		pfctl_kill_states(dev, ifaceopt, opts);
@


