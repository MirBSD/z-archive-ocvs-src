head	1.13;
access;
symbols
	tg-mergetmp-mirosx-1:1.13
	tg-mergefixes-1-branch:1.13.0.8
	tg-mergefixes-1-base:1.13
	MIROS_X:1.13.0.6
	MIROS_X_BASE:1.13
	tg-mergetmp-3:1.13
	MIRBSD_XP_MIRPPC:1.13.0.4
	MIRBSD_XP_SPARC_BASE:1.13
	MIRBSD_XP_SPARC:1.13.0.2
	MIRBSD_7quater:1.10
	cvs-200405160640:1.1.1.12
	cvs-200401271800:1.1.1.11
	cvs-200401261630:1.1.1.11
	cvs-200401021645:1.1.1.10
	MIRBSD_7_ALPHA:1.10.0.6
	MIRBSD_7:1.10.0.4
	cvs-200312222040:1.1.1.10
	MIRBSD_7ter:1.10
	MIRBSD_7_DEV:1.10.0.2
	cvs-200310020700:1.1.1.9
	cvs-200309271030:1.1.1.9
	cvs-200309261655:1.1.1.9
	cvs-200309251530:1.1.1.9
	cvs-200308302005:1.1.1.9
	cvs-200308171200:1.1.1.8
	ctm-3496:1.1.1.8
	ctm-3449:1.1.1.8
	ctm-3437:1.1.1.8
	cvs-200307191805:1.1.1.8
	ctm-3425:1.1.1.8
	cvs-200307091500:1.1.1.8
	cvs-200307072125:1.1.1.8
	ctm-3389:1.1.1.8
	cvs-200307021520:1.1.1.8
	cvs-200306301805:1.1.1.8
	cvs-200306301405:1.1.1.8
	cvs-200306291430:1.1.1.8
	ctm-3341:1.1.1.7
	MIRBSD_5:1.8
	cvs-200306091240:1.1.1.7
	cvs-200306082100:1.1.1.7
	ctm-3316:1.1.1.6
	ctm-3272:1.1.1.6
	ctm-3264:1.1.1.5
	cvs-200305071630:1.1.1.5
	MIRBSD_4:1.5
	ctm-3203:1.1.1.4
	cvs-20030410-1130:1.1.1.3
	ctm-3155:1.1.1.2
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2004.05.27.16.43.38;	author tg;	state Stab;
branches;
next	1.12;

1.12
date	2004.01.27.17.42.08;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.27.00.30.45;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.31.20.54.41;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.29.19.49.29;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.09.01.05.17;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.22.14.08.11;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.07.20.54.13;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.15.20.11.25;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.10.20.11.39;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.29.21.33.33;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.21.52.02;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.48.40;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.48.40;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.03.29.19.42.15;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.04.10.14.44.42;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.04.15.17.37.19;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.07.17.43.44;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.05.21.19.02.55;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.06.08.22.58.13;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.06.29.17.27.31;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.08.30.23.01.34;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.12.22.21.10.52;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2004.01.26.18.30.27;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2004.05.16.08.26.34;	author tg;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Last piece of OpenBSD 3.5-current merge part I.

Things left:
* merge import in src/gnu/
* fix kernel build (it _is_ broken)

TOP 1 will be done with a _second_ import (easier).
TOP 2 will be done RSN.

----

Also, move RCS IDs to new-style MirOS ones, and fix the
SMM doc, and add output to newfs(8) saying if (!) or if
not (?) it read the random value out of the previous
superblock before making the fs.
@
text
@/*	$MirBSD: src/sbin/pfctl/pfctl_altq.c,v 1.12 2004/01/27 17:42:08 tg Exp $	*/
/*	$OpenBSD: pfctl_altq.c,v 1.84 2004/04/26 02:50:04 kjc Exp $	*/

/*
 * Copyright (c) 2002
 *	Sony Computer Science Laboratories Inc.
 * Copyright (c) 2002, 2003 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include <net/if.h>
#include <netinet/in.h>
#include <net/pfvar.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <altq/altq.h>
#include <altq/altq_cbq.h>
#include <altq/altq_priq.h>
#include <altq/altq_hfsc.h>

#include "pfctl_parser.h"
#include "pfctl.h"

#define is_sc_null(sc)	(((sc) == NULL) || ((sc)->m1 == 0 && (sc)->m2 == 0))

TAILQ_HEAD(altqs, pf_altq) altqs = TAILQ_HEAD_INITIALIZER(altqs);
LIST_HEAD(gen_sc, segment) rtsc, lssc;

struct pf_altq	*qname_to_pfaltq(const char *, const char *);
u_int32_t	 qname_to_qid(const char *);

static int	eval_pfqueue_cbq(struct pfctl *, struct pf_altq *);
static int	cbq_compute_idletime(struct pfctl *, struct pf_altq *);
static int	check_commit_cbq(int, int, struct pf_altq *);
static int	print_cbq_opts(const struct pf_altq *);

static int	eval_pfqueue_priq(struct pfctl *, struct pf_altq *);
static int	check_commit_priq(int, int, struct pf_altq *);
static int	print_priq_opts(const struct pf_altq *);

static int	eval_pfqueue_hfsc(struct pfctl *, struct pf_altq *);
static int	check_commit_hfsc(int, int, struct pf_altq *);
static int	print_hfsc_opts(const struct pf_altq *,
		    const struct node_queue_opt *);

static void		 gsc_add_sc(struct gen_sc *, struct service_curve *);
static int		 is_gsc_under_sc(struct gen_sc *,
			     struct service_curve *);
static void		 gsc_destroy(struct gen_sc *);
static struct segment	*gsc_getentry(struct gen_sc *, double);
static int		 gsc_add_seg(struct gen_sc *, double, double, double,
			     double);
static double		 sc_x2y(struct service_curve *, double);

u_int32_t	 getifspeed(char *);
u_long		 getifmtu(char *);
int		 eval_queue_opts(struct pf_altq *, struct node_queue_opt *,
		     u_int32_t);
u_int32_t	 eval_bwspec(struct node_queue_bw *, u_int32_t);
void		 print_hfsc_sc(const char *, u_int, u_int, u_int,
		     const struct node_hfsc_sc *);

void
pfaltq_store(struct pf_altq *a)
{
	struct pf_altq	*altq;

	if ((altq = malloc(sizeof(*altq))) == NULL)
		err(1, "malloc");
	memcpy(altq, a, sizeof(struct pf_altq));
	TAILQ_INSERT_TAIL(&altqs, altq, entries);
}

void
pfaltq_free(struct pf_altq *a)
{
	struct pf_altq	*altq;

	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(a->ifname, altq->ifname, IFNAMSIZ) == 0 &&
		    strncmp(a->qname, altq->qname, PF_QNAME_SIZE) == 0) {
			TAILQ_REMOVE(&altqs, altq, entries);
			free(altq);
			return;
		}
	}
}

struct pf_altq *
pfaltq_lookup(const char *ifname)
{
	struct pf_altq	*altq;

	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(ifname, altq->ifname, IFNAMSIZ) == 0 &&
		    altq->qname[0] == 0)
			return (altq);
	}
	return (NULL);
}

struct pf_altq *
qname_to_pfaltq(const char *qname, const char *ifname)
{
	struct pf_altq	*altq;

	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(ifname, altq->ifname, IFNAMSIZ) == 0 &&
		    strncmp(qname, altq->qname, PF_QNAME_SIZE) == 0)
			return (altq);
	}
	return (NULL);
}

u_int32_t
qname_to_qid(const char *qname)
{
	struct pf_altq	*altq;

	/*
	 * We guarantee that same named queues on different interfaces
	 * have the same qid, so we do NOT need to limit matching on
	 * one interface!
	 */

	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(qname, altq->qname, PF_QNAME_SIZE) == 0)
			return (altq->qid);
	}
	return (0);
}

void
print_altq(const struct pf_altq *a, unsigned level, struct node_queue_bw *bw,
	struct node_queue_opt *qopts)
{
	if (a->qname[0] != 0) {
		print_queue(a, level, bw, 0, qopts);
		return;
	}

	printf("altq on %s ", a->ifname);

	switch (a->scheduler) {
	case ALTQT_CBQ:
		if (!print_cbq_opts(a))
			printf("cbq ");
		break;
	case ALTQT_PRIQ:
		if (!print_priq_opts(a))
			printf("priq ");
		break;
	case ALTQT_HFSC:
		if (!print_hfsc_opts(a, qopts))
			printf("hfsc ");
		break;
	}

	if (bw != NULL && bw->bw_percent > 0) {
		if (bw->bw_percent < 100)
			printf("bandwidth %u%% ", bw->bw_percent);
	} else
		printf("bandwidth %s ", rate2str((double)a->ifbandwidth));

	if (a->qlimit != DEFAULT_QLIMIT)
		printf("qlimit %u ", a->qlimit);
	printf("tbrsize %u ", a->tbrsize);
}

void
print_queue(const struct pf_altq *a, unsigned level, struct node_queue_bw *bw,
    int print_interface, struct node_queue_opt *qopts)
{
	unsigned	i;

	printf("queue ");
	for (i = 0; i < level; ++i)
		printf(" ");
	printf("%s ", a->qname);
	if (print_interface)
		printf("on %s ", a->ifname);
	if (a->scheduler == ALTQT_CBQ || a->scheduler == ALTQT_HFSC) {
		if (bw != NULL && bw->bw_percent > 0) {
			if (bw->bw_percent < 100)
				printf("bandwidth %u%% ", bw->bw_percent);
		} else
			printf("bandwidth %s ", rate2str((double)a->bandwidth));
	}
	if (a->priority != DEFAULT_PRIORITY)
		printf("priority %u ", a->priority);
	if (a->qlimit != DEFAULT_QLIMIT)
		printf("qlimit %u ", a->qlimit);
	switch (a->scheduler) {
	case ALTQT_CBQ:
		print_cbq_opts(a);
		break;
	case ALTQT_PRIQ:
		print_priq_opts(a);
		break;
	case ALTQT_HFSC:
		print_hfsc_opts(a, qopts);
		break;
	}
}

/*
 * eval_pfaltq computes the discipline parameters.
 */
int
eval_pfaltq(struct pfctl *pf, struct pf_altq *pa, struct node_queue_bw *bw,
    struct node_queue_opt *opts)
{
	u_int	rate, size, errors = 0;

	if (bw->bw_absolute > 0)
		pa->ifbandwidth = bw->bw_absolute;
	else
		if ((rate = getifspeed(pa->ifname)) == 0) {
			fprintf(stderr, "cannot determine interface bandwidth "
			    "for %s, specify an absolute bandwidth\n",
			    pa->ifname);
			errors++;
		} else if ((pa->ifbandwidth = eval_bwspec(bw, rate)) == 0)
			pa->ifbandwidth = rate;

	errors += eval_queue_opts(pa, opts, pa->ifbandwidth);

	/* if tbrsize is not specified, use heuristics */
	if (pa->tbrsize == 0) {
		rate = pa->ifbandwidth;
		if (rate <= 1 * 1000 * 1000)
			size = 1;
		else if (rate <= 10 * 1000 * 1000)
			size = 4;
		else if (rate <= 200 * 1000 * 1000)
			size = 8;
		else
			size = 24;
		size = size * getifmtu(pa->ifname);
		if (size > 0xffff)
			size = 0xffff;
		pa->tbrsize = size;
	}
	return (errors);
}

/*
 * check_commit_altq does consistency check for each interface
 */
int
check_commit_altq(int dev, int opts)
{
	struct pf_altq	*altq;
	int		 error = 0;

	/* call the discipline check for each interface. */
	TAILQ_FOREACH(altq, &altqs, entries) {
		if (altq->qname[0] == 0) {
			switch (altq->scheduler) {
			case ALTQT_CBQ:
				error = check_commit_cbq(dev, opts, altq);
				break;
			case ALTQT_PRIQ:
				error = check_commit_priq(dev, opts, altq);
				break;
			case ALTQT_HFSC:
				error = check_commit_hfsc(dev, opts, altq);
				break;
			default:
				break;
			}
		}
	}
	return (error);
}

/*
 * eval_pfqueue computes the queue parameters.
 */
int
eval_pfqueue(struct pfctl *pf, struct pf_altq *pa, struct node_queue_bw *bw,
    struct node_queue_opt *opts)
{
	/* should be merged with expand_queue */
	struct pf_altq	*if_pa, *parent, *altq;
	u_int32_t	 bwsum;
	int		 error = 0;

	/* find the corresponding interface and copy fields used by queues */
	if ((if_pa = pfaltq_lookup(pa->ifname)) == NULL) {
		fprintf(stderr, "altq not defined on %s\n", pa->ifname);
		return (1);
	}
	pa->scheduler = if_pa->scheduler;
	pa->ifbandwidth = if_pa->ifbandwidth;

	if (qname_to_pfaltq(pa->qname, pa->ifname) != NULL) {
		fprintf(stderr, "queue %s already exists on interface %s\n",
		    pa->qname, pa->ifname);
		return (1);
	}
	pa->qid = qname_to_qid(pa->qname);

	parent = NULL;
	if (pa->parent[0] != 0) {
		parent = qname_to_pfaltq(pa->parent, pa->ifname);
		if (parent == NULL) {
			fprintf(stderr, "parent %s not found for %s\n",
			    pa->parent, pa->qname);
			return (1);
		}
		pa->parent_qid = parent->qid;
	}
	if (pa->qlimit == 0)
		pa->qlimit = DEFAULT_QLIMIT;

	if (pa->scheduler == ALTQT_CBQ || pa->scheduler == ALTQT_HFSC) {
		pa->bandwidth = eval_bwspec(bw,
		    parent == NULL ? 0 : parent->bandwidth);

		if (pa->bandwidth > pa->ifbandwidth) {
			fprintf(stderr, "bandwidth for %s higher than "
			    "interface\n", pa->qname);
			return (1);
		}
		/* check the sum of the child bandwidth is under parent's */
		if (parent != NULL) {
			if (pa->bandwidth > parent->bandwidth) {
				warnx("bandwidth for %s higher than parent",
				    pa->qname);
				return (1);
			}
			bwsum = 0;
			TAILQ_FOREACH(altq, &altqs, entries) {
				if (strncmp(altq->ifname, pa->ifname,
				    IFNAMSIZ) == 0 &&
				    altq->qname[0] != 0 &&
				    strncmp(altq->parent, pa->parent,
				    PF_QNAME_SIZE) == 0)
					bwsum += altq->bandwidth;
			}
			bwsum += pa->bandwidth;
			if (bwsum > parent->bandwidth) {
				warnx("the sum of the child bandwidth higher"
				    " than parent \"%s\"", parent->qname);
			}
		}
	}

	if (eval_queue_opts(pa, opts, parent == NULL? 0 : parent->bandwidth))
		return (1);

	switch (pa->scheduler) {
	case ALTQT_CBQ:
		error = eval_pfqueue_cbq(pf, pa);
		break;
	case ALTQT_PRIQ:
		error = eval_pfqueue_priq(pf, pa);
		break;
	case ALTQT_HFSC:
		error = eval_pfqueue_hfsc(pf, pa);
		break;
	default:
		break;
	}
	return (error);
}

/*
 * CBQ support functions
 */
#define	RM_FILTER_GAIN	5	/* log2 of gain, e.g., 5 => 31/32 */
#define	RM_NS_PER_SEC	(1000000000)

static int
eval_pfqueue_cbq(struct pfctl *pf, struct pf_altq *pa)
{
	struct cbq_opts	*opts;
	u_int		 ifmtu;

	if (pa->priority >= CBQ_MAXPRI) {
		warnx("priority out of range: max %d", CBQ_MAXPRI - 1);
		return (-1);
	}

	ifmtu = getifmtu(pa->ifname);
	opts = &pa->pq_u.cbq_opts;

	if (opts->pktsize == 0) {	/* use default */
		opts->pktsize = ifmtu;
		if (opts->pktsize > MCLBYTES)	/* do what TCP does */
			opts->pktsize &= ~MCLBYTES;
	} else if (opts->pktsize > ifmtu)
		opts->pktsize = ifmtu;
	if (opts->maxpktsize == 0)	/* use default */
		opts->maxpktsize = ifmtu;
	else if (opts->maxpktsize > ifmtu)
		opts->pktsize = ifmtu;

	if (opts->pktsize > opts->maxpktsize)
		opts->pktsize = opts->maxpktsize;

	if (pa->parent[0] == 0)
		opts->flags |= (CBQCLF_ROOTCLASS | CBQCLF_WRR);

	cbq_compute_idletime(pf, pa);
	return (0);
}

/*
 * compute ns_per_byte, maxidle, minidle, and offtime
 */
static int
cbq_compute_idletime(struct pfctl *pf, struct pf_altq *pa)
{
	struct cbq_opts	*opts;
	double		 maxidle_s, maxidle, minidle;
	double		 offtime, nsPerByte, ifnsPerByte, ptime, cptime;
	double		 z, g, f, gton, gtom;
	u_int		 minburst, maxburst;

	opts = &pa->pq_u.cbq_opts;
	ifnsPerByte = (1.0 / (double)pa->ifbandwidth) * RM_NS_PER_SEC * 8;
	minburst = opts->minburst;
	maxburst = opts->maxburst;

	if (pa->bandwidth == 0)
		f = 0.0001;	/* small enough? */
	else
		f = ((double) pa->bandwidth / (double) pa->ifbandwidth);

	nsPerByte = ifnsPerByte / f;
	ptime = (double)opts->pktsize * ifnsPerByte;
	cptime = ptime * (1.0 - f) / f;

	if (nsPerByte * (double)opts->maxpktsize > (double)INT_MAX) {
		/*
		 * this causes integer overflow in kernel!
		 * (bandwidth < 6kbps when max_pkt_size=1500)
		 */
		if (pa->bandwidth != 0 && (pf->opts & PF_OPT_QUIET) == 0)
			warnx("queue bandwidth must be larger than %s",
			    rate2str(ifnsPerByte * (double)opts->maxpktsize /
			    (double)INT_MAX * (double)pa->ifbandwidth));
			fprintf(stderr, "cbq: queue %s is too slow!\n",
			    pa->qname);
		nsPerByte = (double)(INT_MAX / opts->maxpktsize);
	}

	if (maxburst == 0) {  /* use default */
		if (cptime > 10.0 * 1000000)
			maxburst = 4;
		else
			maxburst = 16;
	}
	if (minburst == 0)  /* use default */
		minburst = 2;
	if (minburst > maxburst)
		minburst = maxburst;

	z = (double)(1 << RM_FILTER_GAIN);
	g = (1.0 - 1.0 / z);
	gton = pow(g, (double)maxburst);
	gtom = pow(g, (double)(minburst-1));
	maxidle = ((1.0 / f - 1.0) * ((1.0 - gton) / gton));
	maxidle_s = (1.0 - g);
	if (maxidle > maxidle_s)
		maxidle = ptime * maxidle;
	else
		maxidle = ptime * maxidle_s;
	if (minburst)
		offtime = cptime * (1.0 + 1.0/(1.0 - g) * (1.0 - gtom) / gtom);
	else
		offtime = cptime;
	minidle = -((double)opts->maxpktsize * (double)nsPerByte);

	/* scale parameters */
	maxidle = ((maxidle * 8.0) / nsPerByte) *
	    pow(2.0, (double)RM_FILTER_GAIN);
	offtime = (offtime * 8.0) / nsPerByte *
	    pow(2.0, (double)RM_FILTER_GAIN);
	minidle = ((minidle * 8.0) / nsPerByte) *
	    pow(2.0, (double)RM_FILTER_GAIN);

	maxidle = maxidle / 1000.0;
	offtime = offtime / 1000.0;
	minidle = minidle / 1000.0;

	opts->minburst = minburst;
	opts->maxburst = maxburst;
	opts->ns_per_byte = (u_int)nsPerByte;
	opts->maxidle = (u_int)fabs(maxidle);
	opts->minidle = (int)minidle;
	opts->offtime = (u_int)fabs(offtime);

	return (0);
}

static int
check_commit_cbq(int dev, int opts, struct pf_altq *pa)
{
	struct pf_altq	*altq;
	int		 root_class, default_class;
	int		 error = 0;

	/*
	 * check if cbq has one root queue and one default queue
	 * for this interface
	 */
	root_class = default_class = 0;
	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(altq->ifname, pa->ifname, IFNAMSIZ) != 0)
			continue;
		if (altq->qname[0] == 0)  /* this is for interface */
			continue;
		if (altq->pq_u.cbq_opts.flags & CBQCLF_ROOTCLASS)
			root_class++;
		if (altq->pq_u.cbq_opts.flags & CBQCLF_DEFCLASS)
			default_class++;
	}
	if (root_class != 1) {
		warnx("should have one root queue on %s", pa->ifname);
		error++;
	}
	if (default_class != 1) {
		warnx("should have one default queue on %s", pa->ifname);
		error++;
	}
	return (error);
}

static int
print_cbq_opts(const struct pf_altq *a)
{
	const struct cbq_opts	*opts;

	opts = &a->pq_u.cbq_opts;
	if (opts->flags) {
		printf("cbq(");
		if (opts->flags & CBQCLF_RED)
			printf(" red");
		if (opts->flags & CBQCLF_ECN)
			printf(" ecn");
		if (opts->flags & CBQCLF_RIO)
			printf(" rio");
		if (opts->flags & CBQCLF_CLEARDSCP)
			printf(" cleardscp");
		if (opts->flags & CBQCLF_FLOWVALVE)
			printf(" flowvalve");
		if (opts->flags & CBQCLF_BORROW)
			printf(" borrow");
		if (opts->flags & CBQCLF_WRR)
			printf(" wrr");
		if (opts->flags & CBQCLF_EFFICIENT)
			printf(" efficient");
		if (opts->flags & CBQCLF_ROOTCLASS)
			printf(" root");
		if (opts->flags & CBQCLF_DEFCLASS)
			printf(" default");
		printf(" ) ");

		return (1);
	} else
		return (0);
}

/*
 * PRIQ support functions
 */
static int
eval_pfqueue_priq(struct pfctl *pf, struct pf_altq *pa)
{
	struct pf_altq	*altq;

	if (pa->priority >= PRIQ_MAXPRI) {
		warnx("priority out of range: max %d", PRIQ_MAXPRI - 1);
		return (-1);
	}
	/* the priority should be unique for the interface */
	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(altq->ifname, pa->ifname, IFNAMSIZ) == 0 &&
		    altq->qname[0] != 0 && altq->priority == pa->priority) {
			warnx("%s and %s have the same priority",
			    altq->qname, pa->qname);
			return (-1);
		}
	}

	return (0);
}

static int
check_commit_priq(int dev, int opts, struct pf_altq *pa)
{
	struct pf_altq	*altq;
	int		 default_class;
	int		 error = 0;

	/*
	 * check if priq has one default class for this interface
	 */
	default_class = 0;
	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(altq->ifname, pa->ifname, IFNAMSIZ) != 0)
			continue;
		if (altq->qname[0] == 0)  /* this is for interface */
			continue;
		if (altq->pq_u.priq_opts.flags & PRCF_DEFAULTCLASS)
			default_class++;
	}
	if (default_class != 1) {
		warnx("should have one default queue on %s", pa->ifname);
		error++;
	}
	return (error);
}

static int
print_priq_opts(const struct pf_altq *a)
{
	const struct priq_opts	*opts;

	opts = &a->pq_u.priq_opts;

	if (opts->flags) {
		printf("priq(");
		if (opts->flags & PRCF_RED)
			printf(" red");
		if (opts->flags & PRCF_ECN)
			printf(" ecn");
		if (opts->flags & PRCF_RIO)
			printf(" rio");
		if (opts->flags & PRCF_CLEARDSCP)
			printf(" cleardscp");
		if (opts->flags & PRCF_DEFAULTCLASS)
			printf(" default");
		printf(" ) ");

		return (1);
	} else
		return (0);
}

/*
 * HFSC support functions
 */
static int
eval_pfqueue_hfsc(struct pfctl *pf, struct pf_altq *pa)
{
	struct pf_altq		*altq, *parent;
	struct hfsc_opts	*opts;
	struct service_curve	 sc;

	opts = &pa->pq_u.hfsc_opts;

	if (pa->parent[0] == 0) {
		/* root queue */
		opts->lssc_m1 = pa->ifbandwidth;
		opts->lssc_m2 = pa->ifbandwidth;
		opts->lssc_d = 0;
		return (0);
	}

	LIST_INIT(&rtsc);
	LIST_INIT(&lssc);

	/* if link_share is not specified, use bandwidth */
	if (opts->lssc_m2 == 0)
		opts->lssc_m2 = pa->bandwidth;

	if ((opts->rtsc_m1 > 0 && opts->rtsc_m2 == 0) ||
	    (opts->lssc_m1 > 0 && opts->lssc_m2 == 0) ||
	    (opts->ulsc_m1 > 0 && opts->ulsc_m2 == 0)) {
		warnx("m2 is zero for %s", pa->qname);
		return (-1);
	}

	if ((opts->rtsc_m1 < opts->rtsc_m2 && opts->rtsc_m1 != 0) ||
	    (opts->rtsc_m1 < opts->rtsc_m2 && opts->rtsc_m1 != 0) ||
	    (opts->rtsc_m1 < opts->rtsc_m2 && opts->rtsc_m1 != 0)) {
		warnx("m1 must be zero for convex curve: %s", pa->qname);
		return (-1);
	}

	/*
	 * admission control:
	 * for the real-time service curve, the sum of the service curves
	 * should not exceed 80% of the interface bandwidth.  20% is reserved
	 * not to over-commit the actual interface bandwidth.
	 * for the link-sharing service curve, the sum of the child service
	 * curve should not exceed the parent service curve.
	 * for the upper-limit service curve, the assigned bandwidth should
	 * be smaller than the interface bandwidth, and the upper-limit should
	 * be larger than the real-time service curve when both are defined.
	 */
	parent = qname_to_pfaltq(pa->parent, pa->ifname);
	if (parent == NULL)
		errx(1, "parent %s not found for %s", pa->parent, pa->qname);

	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(altq->ifname, pa->ifname, IFNAMSIZ) != 0)
			continue;
		if (altq->qname[0] == 0)  /* this is for interface */
			continue;

		/* if the class has a real-time service curve, add it. */
		if (opts->rtsc_m2 != 0 && altq->pq_u.hfsc_opts.rtsc_m2 != 0) {
			sc.m1 = altq->pq_u.hfsc_opts.rtsc_m1;
			sc.d = altq->pq_u.hfsc_opts.rtsc_d;
			sc.m2 = altq->pq_u.hfsc_opts.rtsc_m2;
			gsc_add_sc(&rtsc, &sc);
		}

		if (strncmp(altq->parent, pa->parent, PF_QNAME_SIZE) != 0)
			continue;

		/* if the class has a link-sharing service curve, add it. */
		if (opts->lssc_m2 != 0 && altq->pq_u.hfsc_opts.lssc_m2 != 0) {
			sc.m1 = altq->pq_u.hfsc_opts.lssc_m1;
			sc.d = altq->pq_u.hfsc_opts.lssc_d;
			sc.m2 = altq->pq_u.hfsc_opts.lssc_m2;
			gsc_add_sc(&lssc, &sc);
		}
	}

	/* check the real-time service curve.  reserve 20% of interface bw */
	if (opts->rtsc_m2 != 0) {
		/* add this queue to the sum */
		sc.m1 = opts->rtsc_m1;
		sc.d = opts->rtsc_d;
		sc.m2 = opts->rtsc_m2;
		gsc_add_sc(&rtsc, &sc);
		/* compare the sum with 80% of the interface */
		sc.m1 = 0;
		sc.d = 0;
		sc.m2 = pa->ifbandwidth / 100 * 80;
		if (!is_gsc_under_sc(&rtsc, &sc)) {
			warnx("real-time sc exceeds 80%% of the interface "
			    "bandwidth (%s)", rate2str((double)sc.m2));
			goto err_ret;
		}
	}

	/* check the link-sharing service curve. */
	if (opts->lssc_m2 != 0) {
		/* add this queue to the child sum */
		sc.m1 = opts->lssc_m1;
		sc.d = opts->lssc_d;
		sc.m2 = opts->lssc_m2;
		gsc_add_sc(&lssc, &sc);
		/* compare the sum of the children with parent's sc */
		sc.m1 = parent->pq_u.hfsc_opts.lssc_m1;
		sc.d = parent->pq_u.hfsc_opts.lssc_d;
		sc.m2 = parent->pq_u.hfsc_opts.lssc_m2;
		if (!is_gsc_under_sc(&lssc, &sc)) {
			warnx("link-sharing sc exceeds parent's sc");
			goto err_ret;
		}
	}

	/* check the upper-limit service curve. */
	if (opts->ulsc_m2 != 0) {
		if (opts->ulsc_m1 > pa->ifbandwidth ||
		    opts->ulsc_m2 > pa->ifbandwidth) {
			warnx("upper-limit larger than interface bandwidth");
			goto err_ret;
		}
		if (opts->rtsc_m2 != 0 && opts->rtsc_m2 > opts->ulsc_m2) {
			warnx("upper-limit sc smaller than real-time sc");
			goto err_ret;
		}
	}

	gsc_destroy(&rtsc);
	gsc_destroy(&lssc);

	return (0);

err_ret:
	gsc_destroy(&rtsc);
	gsc_destroy(&lssc);
	return (-1);
}

static int
check_commit_hfsc(int dev, int opts, struct pf_altq *pa)
{
	struct pf_altq	*altq, *def = NULL;
	int		 default_class;
	int		 error = 0;

	/* check if hfsc has one default queue for this interface */
	default_class = 0;
	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(altq->ifname, pa->ifname, IFNAMSIZ) != 0)
			continue;
		if (altq->qname[0] == 0)  /* this is for interface */
			continue;
		if (altq->parent[0] == 0)  /* dummy root */
			continue;
		if (altq->pq_u.hfsc_opts.flags & HFCF_DEFAULTCLASS) {
			default_class++;
			def = altq;
		}
	}
	if (default_class != 1) {
		warnx("should have one default queue on %s", pa->ifname);
		return (1);
	}
	/* make sure the default queue is a leaf */
	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(altq->ifname, pa->ifname, IFNAMSIZ) != 0)
			continue;
		if (altq->qname[0] == 0)  /* this is for interface */
			continue;
		if (strncmp(altq->parent, def->qname, PF_QNAME_SIZE) == 0) {
			warnx("default queue is not a leaf");
			error++;
		}
	}
	return (error);
}

static int
print_hfsc_opts(const struct pf_altq *a, const struct node_queue_opt *qopts)
{
	const struct hfsc_opts		*opts;
	const struct node_hfsc_sc	*rtsc, *lssc, *ulsc;

	opts = &a->pq_u.hfsc_opts;
	if (qopts == NULL)
		rtsc = lssc = ulsc = NULL;
	else {
		rtsc = &qopts->data.hfsc_opts.realtime;
		lssc = &qopts->data.hfsc_opts.linkshare;
		ulsc = &qopts->data.hfsc_opts.upperlimit;
	}

	if (opts->flags || opts->rtsc_m2 != 0 || opts->ulsc_m2 != 0 ||
	    (opts->lssc_m2 != 0 && (opts->lssc_m2 != a->bandwidth ||
	    opts->lssc_d != 0))) {
		printf("hfsc(");
		if (opts->flags & HFCF_RED)
			printf(" red");
		if (opts->flags & HFCF_ECN)
			printf(" ecn");
		if (opts->flags & HFCF_RIO)
			printf(" rio");
		if (opts->flags & HFCF_CLEARDSCP)
			printf(" cleardscp");
		if (opts->flags & HFCF_DEFAULTCLASS)
			printf(" default");
		if (opts->rtsc_m2 != 0)
			print_hfsc_sc("realtime", opts->rtsc_m1, opts->rtsc_d,
			    opts->rtsc_m2, rtsc);
		if (opts->lssc_m2 != 0 && (opts->lssc_m2 != a->bandwidth ||
		    opts->lssc_d != 0))
			print_hfsc_sc("linkshare", opts->lssc_m1, opts->lssc_d,
			    opts->lssc_m2, lssc);
		if (opts->ulsc_m2 != 0)
			print_hfsc_sc("upperlimit", opts->ulsc_m1, opts->ulsc_d,
			    opts->ulsc_m2, ulsc);
		printf(" ) ");

		return (1);
	} else
		return (0);
}

/*
 * admission control using generalized service curve
 */
#define	INFINITY	HUGE_VAL  /* positive infinity defined in <math.h> */

/* add a new service curve to a generalized service curve */
static void
gsc_add_sc(struct gen_sc *gsc, struct service_curve *sc)
{
	if (is_sc_null(sc))
		return;
	if (sc->d != 0)
		gsc_add_seg(gsc, 0.0, 0.0, (double)sc->d, (double)sc->m1);
	gsc_add_seg(gsc, (double)sc->d, 0.0, INFINITY, (double)sc->m2);
}

/*
 * check whether all points of a generalized service curve have
 * their y-coordinates no larger than a given two-piece linear
 * service curve.
 */
static int
is_gsc_under_sc(struct gen_sc *gsc, struct service_curve *sc)
{
	struct segment	*s, *last, *end;
	double		 y;

	if (is_sc_null(sc)) {
		if (LIST_EMPTY(gsc))
			return (1);
		LIST_FOREACH(s, gsc, _next) {
			if (s->m != 0)
				return (0);
		}
		return (1);
	}
	/*
	 * gsc has a dummy entry at the end with x = INFINITY.
	 * loop through up to this dummy entry.
	 */
	end = gsc_getentry(gsc, INFINITY);
	if (end == NULL)
		return (1);
	last = NULL;
	for (s = LIST_FIRST(gsc); s != end; s = LIST_NEXT(s, _next)) {
		if (s->y > sc_x2y(sc, s->x))
			return (0);
		last = s;
	}
	/* last now holds the real last segment */
	if (last == NULL)
		return (1);
	if (last->m > sc->m2)
		return (0);
	if (last->x < sc->d && last->m > sc->m1) {
		y = last->y + (sc->d - last->x) * last->m;
		if (y > sc_x2y(sc, sc->d))
			return (0);
	}
	return (1);
}

static void
gsc_destroy(struct gen_sc *gsc)
{
	struct segment	*s;

	while ((s = LIST_FIRST(gsc)) != NULL) {
		LIST_REMOVE(s, _next);
		free(s);
	}
}

/*
 * return a segment entry starting at x.
 * if gsc has no entry starting at x, a new entry is created at x.
 */
static struct segment *
gsc_getentry(struct gen_sc *gsc, double x)
{
	struct segment	*new, *prev, *s;

	prev = NULL;
	LIST_FOREACH(s, gsc, _next) {
		if (s->x == x)
			return (s);	/* matching entry found */
		else if (s->x < x)
			prev = s;
		else
			break;
	}

	/* we have to create a new entry */
	if ((new = calloc(1, sizeof(struct segment))) == NULL)
		return (NULL);

	new->x = x;
	if (x == INFINITY || s == NULL)
		new->d = 0;
	else if (s->x == INFINITY)
		new->d = INFINITY;
	else
		new->d = s->x - x;
	if (prev == NULL) {
		/* insert the new entry at the head of the list */
		new->y = 0;
		new->m = 0;
		LIST_INSERT_HEAD(gsc, new, _next);
	} else {
		/*
		 * the start point intersects with the segment pointed by
		 * prev.  divide prev into 2 segments
		 */
		if (x == INFINITY) {
			prev->d = INFINITY;
			if (prev->m == 0)
				new->y = prev->y;
			else
				new->y = INFINITY;
		} else {
			prev->d = x - prev->x;
			new->y = prev->d * prev->m + prev->y;
		}
		new->m = prev->m;
		LIST_INSERT_AFTER(prev, new, _next);
	}
	return (new);
}

/* add a segment to a generalized service curve */
static int
gsc_add_seg(struct gen_sc *gsc, double x, double y, double d, double m)
{
	struct segment	*start, *end, *s;
	double		 x2;

	if (d == INFINITY)
		x2 = INFINITY;
	else
		x2 = x + d;
	start = gsc_getentry(gsc, x);
	end = gsc_getentry(gsc, x2);
	if (start == NULL || end == NULL)
		return (-1);

	for (s = start; s != end; s = LIST_NEXT(s, _next)) {
		s->m += m;
		s->y += y + (s->x - x) * m;
	}

	end = gsc_getentry(gsc, INFINITY);
	for (; s != end; s = LIST_NEXT(s, _next)) {
		s->y += m * d;
	}

	return (0);
}

/* get y-projection of a service curve */
static double
sc_x2y(struct service_curve *sc, double x)
{
	double	y;

	if (x <= (double)sc->d)
		/* y belongs to the 1st segment */
		y = x * (double)sc->m1;
	else
		/* y belongs to the 2nd segment */
		y = (double)sc->d * (double)sc->m1
			+ (x - (double)sc->d) * (double)sc->m2;
	return (y);
}

/*
 * misc utilities
 */
#define	R2S_BUFS	8
#define	RATESTR_MAX	16

char *
rate2str(double rate)
{
	char		*buf;
	static char	 r2sbuf[R2S_BUFS][RATESTR_MAX];  /* ring bufer */
	static int	 idx = 0;
	int		 i;
#define	unit(i)	( (i)?( (i==1)?"Ki":( (i==2)?"Mi":"Gi" )):"" )

	buf = r2sbuf[idx++];
	if (idx == R2S_BUFS)
		idx = 0;

	for (i = 0; rate >= 1024 && i <= 3; i++)
		rate /= 1024;

	if ((int)(rate * 100) % 100)
		snprintf(buf, RATESTR_MAX, "%.2f %sb", rate, unit(i));
	else
		snprintf(buf, RATESTR_MAX, "%d %sb", (int)rate, unit(i));

	return (buf);
}

u_int32_t
getifspeed(char *ifname)
{
	int		s;
	struct ifreq	ifr;
	struct if_data	ifrdat;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		err(1, "socket");
	if (strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name)) >=
	    sizeof(ifr.ifr_name))
		errx(1, "getifspeed: strlcpy");
	ifr.ifr_data = (caddr_t)&ifrdat;
	if (ioctl(s, SIOCGIFDATA, (caddr_t)&ifr) == -1)
		err(1, "SIOCGIFDATA");
	if (shutdown(s, SHUT_RDWR) == -1)
		err(1, "shutdown");
	if (close(s))
		err(1, "close");
	return ((u_int32_t)ifrdat.ifi_baudrate);
}

u_long
getifmtu(char *ifname)
{
	int		s;
	struct ifreq	ifr;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		err(1, "socket");
	if (strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name)) >=
	    sizeof(ifr.ifr_name))
		errx(1, "getifmtu: strlcpy");
	if (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) == -1)
		err(1, "SIOCGIFMTU");
	if (shutdown(s, SHUT_RDWR) == -1)
		err(1, "shutdown");
	if (close(s))
		err(1, "close");
	if (ifr.ifr_mtu > 0)
		return (ifr.ifr_mtu);
	else {
		warnx("could not get mtu for %s, assuming 1500", ifname);
		return (1500);
	}
}

int
eval_queue_opts(struct pf_altq *pa, struct node_queue_opt *opts,
    u_int32_t ref_bw)
{
	int	errors = 0;

	switch (pa->scheduler) {
	case ALTQT_CBQ:
		pa->pq_u.cbq_opts = opts->data.cbq_opts;
		break;
	case ALTQT_PRIQ:
		pa->pq_u.priq_opts = opts->data.priq_opts;
		break;
	case ALTQT_HFSC:
		pa->pq_u.hfsc_opts.flags = opts->data.hfsc_opts.flags;
		if (opts->data.hfsc_opts.linkshare.used) {
			pa->pq_u.hfsc_opts.lssc_m1 =
			    eval_bwspec(&opts->data.hfsc_opts.linkshare.m1,
			    ref_bw);
			pa->pq_u.hfsc_opts.lssc_m2 =
			    eval_bwspec(&opts->data.hfsc_opts.linkshare.m2,
			    ref_bw);
			pa->pq_u.hfsc_opts.lssc_d =
			    opts->data.hfsc_opts.linkshare.d;
		}
		if (opts->data.hfsc_opts.realtime.used) {
			pa->pq_u.hfsc_opts.rtsc_m1 =
			    eval_bwspec(&opts->data.hfsc_opts.realtime.m1,
			    ref_bw);
			pa->pq_u.hfsc_opts.rtsc_m2 =
			    eval_bwspec(&opts->data.hfsc_opts.realtime.m2,
			    ref_bw);
			pa->pq_u.hfsc_opts.rtsc_d =
			    opts->data.hfsc_opts.realtime.d;
		}
		if (opts->data.hfsc_opts.upperlimit.used) {
			pa->pq_u.hfsc_opts.ulsc_m1 =
			    eval_bwspec(&opts->data.hfsc_opts.upperlimit.m1,
			    ref_bw);
			pa->pq_u.hfsc_opts.ulsc_m2 =
			    eval_bwspec(&opts->data.hfsc_opts.upperlimit.m2,
			    ref_bw);
			pa->pq_u.hfsc_opts.ulsc_d =
			    opts->data.hfsc_opts.upperlimit.d;
		}
		break;
	default:
		warnx("eval_queue_opts: unknown scheduler type %u",
		    opts->qtype);
		errors++;
		break;
	}

	return (errors);
}

u_int32_t
eval_bwspec(struct node_queue_bw *bw, u_int32_t ref_bw)
{
	if (bw->bw_absolute > 0)
		return (bw->bw_absolute);

	if (bw->bw_percent > 0)
		return (ref_bw / 100 * bw->bw_percent);

	return (0);
}

void
print_hfsc_sc(const char *scname, u_int m1, u_int d, u_int m2,
    const struct node_hfsc_sc *sc)
{
	printf(" %s", scname);

	if (d != 0) {
		printf("(");
		if (sc != NULL && sc->m1.bw_percent > 0)
			printf("%u%%", sc->m1.bw_percent);
		else
			printf("%s", rate2str((double)m1));
		printf(" %u", d);
	}

	if (sc != NULL && sc->m2.bw_percent > 0)
		printf(" %u%%", sc->m2.bw_percent);
	else
		printf(" %s", rate2str((double)m2));

	if (d != 0)
		printf(")");
}
@


1.12
log
@first part of mergeing OpenBSD and fixing whitespace and RCS IDs
@
text
@d1 2
a2 2
/*	$MirBSD: pfctl_altq.c,v 1.11 2003/12/27 00:30:45 tg Exp $	*/
/*	$OpenBSD: pfctl_altq.c,v 1.79 2004/01/14 08:42:23 kjc Exp $	*/
a24 1
#include <sys/limits.h>
d32 1
a85 2
static u_int32_t	 max_qid = 0;

d167 1
a167 1
	switch(a->scheduler) {
d308 2
a309 1
	struct pf_altq	*if_pa, *parent;
d341 2
a342 6
		if ((pa->bandwidth = eval_bwspec(bw,
		    parent == NULL ? 0 : parent->bandwidth)) == 0) {
			fprintf(stderr, "bandwidth for %s invalid (%d / %d)\n",
			    pa->qname, bw->bw_absolute, bw->bw_percent);
			return (1);
		}
d349 21
a369 4
		if (parent != NULL && pa->bandwidth > parent->bandwidth) {
			fprintf(stderr, "bandwidth for %s higher than parent\n",
			    pa->qname);
			return (1);
a427 2
	if (pa->qid == 0)
		pa->qid = ++max_qid;
d501 6
a506 3
	maxidle = ((maxidle * 8.0) / nsPerByte) * pow(2.0, (double)RM_FILTER_GAIN);
	offtime = (offtime * 8.0) / nsPerByte * pow(2.0, (double)RM_FILTER_GAIN);
	minidle = ((minidle * 8.0) / nsPerByte) * pow(2.0, (double)RM_FILTER_GAIN);
d514 2
a515 2
	opts->ns_per_byte = (u_int) nsPerByte;
	opts->maxidle = (u_int) fabs(maxidle);
d517 1
a517 1
	opts->offtime = (u_int) fabs(offtime);
a611 3
	if (pa->qid == 0)
		pa->qid = ++max_qid;

a678 2
	if (pa->qid == 0)
		pa->qid = ++max_qid;
d732 1
a732 1
			sc.d  = altq->pq_u.hfsc_opts.rtsc_d;
d743 1
a743 1
			sc.d  = altq->pq_u.hfsc_opts.lssc_d;
d751 6
d758 1
a758 1
		sc.d  = 0;
d761 2
a762 1
			warnx("real-time sc exceeds the interface bandwidth");
d769 6
d776 1
a776 1
		sc.d  = parent->pq_u.hfsc_opts.lssc_d;
d1034 1
a1034 1
	end   = gsc_getentry(gsc, x2);
@


1.11
log
@finish merging and sync a bit; bump version etc.
@
text
@d1 2
a2 2
/*	$MirBSD$	*/
/*	$OpenBSD: pfctl_altq.c,v 1.78 2003/10/21 21:09:13 itojun Exp $	*/
d86 1
a86 1
static u_int32_t	 max_qid = 1;
d265 2
d416 1
a416 1
	else if (pa->qid == 0 && (opts->flags & CBQCLF_DEFCLASS) == 0)
d669 2
a672 1
		pa->qid = HFSC_ROOTCLASS_HANDLE;
d677 1
a677 2
	} else if (pa->qid == 0)
		pa->qid = ++max_qid;
@


1.10
log
@Merge import of OpenBSD source, ports and XF4 tree.

While here,
o clean up differences where possible
o whitespace cleanup
o ifdef ./. if defined()
o '...' ./. "..."
o echo foo > bar ./. echo foo >bar
o `...` ./. $(...) ./. $$(...)
o `...' ./. '...'
o modernize "our" tree, e.g. WWW in ports
o fix some typos and brainos introduced when renaming OpenBSD to MirBSD
o use hardware 80387 by default
o migrate Apache 1.3.28 OpenBSD ./. MirBSD ./. KAME
o work around as many CVS bugs as possible (add back/delete files, ...)

Synchronize stuff, ready for ongoing changes.
@
text
@d1 2
a2 1
/*	$OpenBSD: pfctl_altq.c,v 1.77 2003/08/22 21:50:34 david Exp $	*/
d162 1
a162 1
	if (a->qname[0] != NULL) {
@


1.9
log
@merge the import
amd (automount dæmon) bites the dust
rewrite fake-NLS emulation, copyright to me
foobar! fnord!
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.75 2003/06/20 16:53:48 deraadt Exp $	*/
d389 5
d874 1
a874 1
/* add a new service curve to a generilized service curve */
@


1.8
log
@merge import
@
text
@d1 1
a1 2
/*	$MirBSD: pfctl_altq.c,v 1.7 2003/05/22 14:08:11 tg Exp $	*/
/*	$OpenBSD: pfctl_altq.c,v 1.74 2003/06/06 17:53:05 henning Exp $	*/
d483 3
a485 3
	maxidle = ((maxidle * 8.0) / nsPerByte) * pow(2, RM_FILTER_GAIN);
	offtime = (offtime * 8.0) / nsPerByte * pow(2, RM_FILTER_GAIN);
	minidle = ((minidle * 8.0) / nsPerByte) * pow(2, RM_FILTER_GAIN);
d876 2
a877 2
		gsc_add_seg(gsc, 0, 0, (double)sc->d, (double)sc->m1);
	gsc_add_seg(gsc, (double)sc->d, 0, INFINITY, (double)sc->m2);
@


1.7
log
@merge CVS import stuff
@
text
@d1 2
a2 2
/*	$MirBSD: pfctl_altq.c,v 1.6 2003/05/07 20:54:13 tg Exp $	*/
/*	$OpenBSD: pfctl_altq.c,v 1.73 2003/05/08 22:09:54 dhartmei Exp $	*/
d5 3
a7 3
 * Copyright (C) 2002
 *	Sony Computer Science Laboratories Inc.  All rights reserved.
 * Copyright (C) 2002, 2003 Henning Brauer. All rights reserved.
d9 3
a11 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d13 7
a19 11
 * THIS SOFTWARE IS PROVIDED BY SONY CSL AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL SONY CSL OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
@


1.6
log
@merge conflicts; fix what(1) stdin
@
text
@d1 2
a2 2
/*	$MirBSD: pfctl_altq.c,v 1.5 2003/04/15 20:11:25 tg Exp $	*/
/*	$OpenBSD: pfctl_altq.c,v 1.72 2003/04/15 11:29:24 henning Exp $	*/
d1095 2
d1115 2
@


1.5
log
@clean up after cvs
fix some stuff

in the hope to fully have removed sys_mhint... they implemented
it in the name of sys_mquery *d'oh*
@
text
@d1 2
a2 2
/*	$MirBSD: pfctl_altq.c,v 1.4 2003/04/10 20:11:39 tg Exp $	*/
/*	$OpenBSD: pfctl_altq.c,v 1.68 2003/04/14 16:51:36 henning Exp $	*/
d75 2
a76 1
static int	print_hfsc_opts(const struct pf_altq *);
d92 2
d168 2
a169 1
print_altq(const struct pf_altq *a, unsigned level, struct node_queue_bw *bw)
d172 1
a172 1
		print_queue(a, level, bw, 0);
d188 1
a188 1
		if (!print_hfsc_opts(a))
d206 1
a206 1
    int print_interface)
d235 1
a235 1
		print_hfsc_opts(a);
d829 1
a829 1
print_hfsc_opts(const struct pf_altq *a)
d831 2
a832 1
	const struct hfsc_opts	*opts;
d835 7
d857 3
a859 10
		if (opts->rtsc_m2 != 0) {
			if (opts->rtsc_d != 0)
				printf(" realtime(%s %ums %s)",
				    rate2str((double)opts->rtsc_m1),
				    opts->rtsc_d,
				    rate2str((double)opts->rtsc_m2));
			else
				printf(" realtime %s",
				    rate2str((double)opts->rtsc_m2));
		}
d861 6
a866 20
		    opts->lssc_d != 0)) {
			if (opts->lssc_d != 0)
				printf(" linkshare(%s %ums %s)",
				    rate2str((double)opts->lssc_m1),
				    opts->lssc_d,
				    rate2str((double)opts->lssc_m2));
			else
				printf(" linkshare %s",
				    rate2str((double)opts->lssc_m2));
		}
		if (opts->ulsc_m2 != 0) {
			if (opts->ulsc_d != 0)
				printf(" upperlimit(%s %ums %s)",
				    rate2str((double)opts->ulsc_m1),
				    opts->ulsc_d,
				    rate2str((double)opts->ulsc_m2));
				else
					printf(" upperlimit %s",
					    rate2str((double)opts->ulsc_m2));
		}
d1187 24
@


1.4
log
@clean up the cvs import mess

nb, this doesnt mean the tree builds.
its bed time
@
text
@d1 2
a2 2
/*	$MirBSD: pfctl_altq.c,v 1.3 2003/03/29 21:33:33 tg Exp $	*/
/*	$OpenBSD: pfctl_altq.c,v 1.50 2003/04/05 21:44:46 henning Exp $	*/
d61 3
d67 1
a67 1
static void	print_cbq_opts(const struct pf_altq *);
d71 1
a71 1
static void	print_priq_opts(const struct pf_altq *);
d75 1
a75 1
static void	print_hfsc_opts(const struct pf_altq *);
d88 3
d92 1
a92 1
static u_int32_t	 max_qid = 0;
a163 13
char *
qid_to_qname(u_int32_t qid, const char *ifname)
{
	struct pf_altq	*altq;

	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(ifname, altq->ifname, IFNAMSIZ) == 0 &&
		    altq->qid == qid)
			return (altq->qname);
	}
	return (NULL);
}

d165 1
a165 1
print_altq(const struct pf_altq *a, unsigned level, u_int16_t bwpercent)
d168 1
a168 1
		print_queue(a, level, bwpercent, 0);
d176 1
a176 2
		print_cbq_opts(a);
		if (!a->pq_u.cbq_opts.flags)
d180 1
a180 2
		print_priq_opts(a);
		if (!a->pq_u.priq_opts.flags)
d184 1
a184 2
		print_hfsc_opts(a);
		if (!a->pq_u.hfsc_opts.flags)
d189 3
a191 3
	if (bwpercent > 0) {
		if (bwpercent < 100)
			printf("bandwidth %u%% ", bwpercent);
d194 1
d201 1
a201 1
print_queue(const struct pf_altq *a, unsigned level, u_int16_t bwpercent,
d213 3
a215 3
		if (bwpercent > 0) {
			if (bwpercent < 100)
				printf("bandwidth %u%% ", bwpercent);
d240 2
a241 2
eval_pfaltq(struct pfctl *pf, struct pf_altq *pa, u_int32_t bw_absolute,
    u_int16_t bw_percent)
d245 2
a246 2
	if (bw_absolute > 0)
		pa->ifbandwidth = bw_absolute;
d253 4
a256 5
		} else
			if (bw_percent > 0)
				pa->ifbandwidth = rate / 100 * bw_percent;
			else
				pa->ifbandwidth = rate;
d309 2
a310 2
eval_pfqueue(struct pfctl *pf, struct pf_altq *pa, u_int32_t bw_absolute,
    u_int16_t bw_percent)
d345 2
a346 5
		if (bw_absolute > 0)
			pa->bandwidth = bw_absolute;
		else if (bw_percent > 0 && parent != NULL)
			pa->bandwidth = parent->bandwidth / 100 * bw_percent;
		else {
d348 1
a348 1
			    pa->qname, bw_absolute, bw_percent);
d364 3
d540 1
a540 1
static void
d569 4
a572 1
	}
d629 1
a629 1
static void
d649 4
a652 1
	}
d665 2
d668 1
a668 1
		/* this is for dummy root */
d670 3
a672 1
		pa->pq_u.hfsc_opts.lssc_m2 = pa->ifbandwidth;
d674 2
a675 1
	}
a676 1
	opts = &pa->pq_u.hfsc_opts;
d808 1
a808 1
		error++;
d824 1
a824 1
static void
d831 31
a861 34
	printf("hfsc(");
	if (opts->flags & HFCF_RED)
		printf(" red");
	if (opts->flags & HFCF_ECN)
		printf(" ecn");
	if (opts->flags & HFCF_RIO)
		printf(" rio");
	if (opts->flags & HFCF_CLEARDSCP)
		printf(" cleardscp");
	if (opts->flags & HFCF_DEFAULTCLASS)
		printf(" default");
	if (opts->rtsc_m2 != 0) {
		if (opts->rtsc_d != 0)
			printf(" realtime(%s %ums %s)",
			    rate2str((double)opts->rtsc_m1), opts->rtsc_d,
			    rate2str((double)opts->rtsc_m2));
		else
			printf(" realtime %s",
			    rate2str((double)opts->rtsc_m2));
	}
	if (opts->lssc_m2 != 0) {
		if (opts->lssc_d != 0)
			printf(" linkshare(%s %ums %s)",
			    rate2str((double)opts->lssc_m1), opts->lssc_d,
			    rate2str((double)opts->lssc_m2));
		else
			printf(" linkshare %s",
			    rate2str((double)opts->lssc_m2));
	}
	if (opts->ulsc_m2 != 0) {
		if (opts->ulsc_d != 0)
			printf(" upperlimit(%s %ums %s)",
			    rate2str((double)opts->ulsc_m1), opts->ulsc_d,
			    rate2str((double)opts->ulsc_m2));
d863 8
a870 1
				printf(" upperlimit(%s)",
d872 9
a880 2
	}
	printf(" ) ");
d1128 68
@


1.3
log
@merge OpenBSD cvs import conflicts
enable /etc/isdn directory and MAKEDEV.i4b
@
text
@d1 2
a2 2
/*	$MirBSD: pfctl_altq.c,v 1.2 2003/03/23 21:52:02 tg Exp $	*/
/*	$OpenBSD: pfctl_altq.c,v 1.47 2003/03/28 16:47:39 henning Exp $	*/
d34 1
d175 1
a175 1
		print_queue(a, level, bwpercent);
d210 2
a211 1
print_queue(const struct pf_altq *a, unsigned level, u_int16_t bwpercent)
d219 2
d604 2
a605 2
	/* qid is tied to priority with priq */
	pa->qid = pa->priority + 1;
@


1.2
log
@Merge MirBSD-old entirely
Remove krb, yp, afs, GPL'd stuff in kernel
Adjust some other stuff

Not to be compiled yet...
@
text
@d1 2
a2 2
/*	$MirBSD: obsd.tygs,v 1.44 2003/03/22 22:33:30 tg Exp $	*/
/*	$OpenBSD: pfctl_altq.c,v 1.46 2003/03/11 14:02:12 henning Exp $	*/
d599 3
@


1.1
log
@Initial revision
@
text
@d1 1
d456 1
a456 1
		 * (bandwidth < 6Kbps when max_pkt_size=1500)
d1052 1
a1052 1
	static const char unit[] = " KMG";
d1058 2
a1059 2
	for (i = 0; rate >= 1000 && i <= 3; i++)
		rate /= 1000;
d1062 1
a1062 1
		snprintf(buf, RATESTR_MAX, "%.2f%cb", rate, unit[i]);
d1064 1
a1064 1
		snprintf(buf, RATESTR_MAX, "%d%cb", (int)rate, unit[i]);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD repository of CTM 3155 (roughly today at noon).
Mostly in order to go 3.3-current and ease further merges of
both OpenBSD and ELFdiffs after the MirBSD has been enabled
to build again.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.47 2003/03/28 16:47:39 henning Exp $	*/
a597 3

	/* qid is tied to priority with priq */
	pa->qid = pa->priority + 1;
@


1.1.1.3
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.50 2003/04/05 21:44:46 henning Exp $	*/
a32 1
#include <sys/limits.h>
d173 1
a173 1
		print_queue(a, level, bwpercent, 0);
d208 1
a208 2
print_queue(const struct pf_altq *a, unsigned level, u_int16_t bwpercent,
    int print_interface)
a215 2
	if (print_interface)
		printf("on %s ", a->ifname);
d599 2
a600 2
	if (pa->qid == 0)
		pa->qid = ++max_qid;
@


1.1.1.4
log
@Import OpenBSD source with the "new" command line as well,
in order to be able to provide a MirBSD release which bases
upon a fairly current OpenBSD base source code tree deemed
stable enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.68 2003/04/14 16:51:36 henning Exp $	*/
a59 3
struct pf_altq	*qname_to_pfaltq(const char *, const char *);
u_int32_t	 qname_to_qid(const char *);

d63 1
a63 1
static int	print_cbq_opts(const struct pf_altq *);
d67 1
a67 1
static int	print_priq_opts(const struct pf_altq *);
d71 1
a71 1
static int	print_hfsc_opts(const struct pf_altq *);
a83 3
int		 eval_queue_opts(struct pf_altq *, struct node_queue_opt *,
		     u_int32_t);
u_int32_t	 eval_bwspec(struct node_queue_bw *, u_int32_t);
d85 1
a85 1
static u_int32_t	 max_qid = 1;
d157 13
d171 1
a171 1
print_altq(const struct pf_altq *a, unsigned level, struct node_queue_bw *bw)
d174 1
a174 1
		print_queue(a, level, bw, 0);
d182 2
a183 1
		if (!print_cbq_opts(a))
d187 2
a188 1
		if (!print_priq_opts(a))
d192 2
a193 1
		if (!print_hfsc_opts(a))
d198 3
a200 3
	if (bw != NULL && bw->bw_percent > 0) {
		if (bw->bw_percent < 100)
			printf("bandwidth %u%% ", bw->bw_percent);
a202 1

d209 1
a209 1
print_queue(const struct pf_altq *a, unsigned level, struct node_queue_bw *bw,
d221 3
a223 3
		if (bw != NULL && bw->bw_percent > 0) {
			if (bw->bw_percent < 100)
				printf("bandwidth %u%% ", bw->bw_percent);
d248 2
a249 2
eval_pfaltq(struct pfctl *pf, struct pf_altq *pa, struct node_queue_bw *bw,
    struct node_queue_opt *opts)
d253 2
a254 2
	if (bw->bw_absolute > 0)
		pa->ifbandwidth = bw->bw_absolute;
d261 5
a265 4
		} else if ((pa->ifbandwidth = eval_bwspec(bw, rate)) == 0)
			pa->ifbandwidth = rate;

	errors += eval_queue_opts(pa, opts, pa->ifbandwidth);
d318 2
a319 2
eval_pfqueue(struct pfctl *pf, struct pf_altq *pa, struct node_queue_bw *bw,
    struct node_queue_opt *opts)
d354 5
a358 2
		if ((pa->bandwidth = eval_bwspec(bw,
		    parent == NULL ? 0 : parent->bandwidth)) == 0) {
d360 1
a360 1
			    pa->qname, bw->bw_absolute, bw->bw_percent);
a375 3
	if (eval_queue_opts(pa, opts, parent == NULL? 0 : parent->bandwidth))
		return (1);

d549 1
a549 1
static int
d578 1
a578 4

		return (1);
	} else
		return (0);
d635 1
a635 1
static int
d655 1
a655 4

		return (1);
	} else
		return (0);
a667 2
	opts = &pa->pq_u.hfsc_opts;

d669 1
a669 1
		/* root queue */
d671 1
a671 3
		opts->lssc_m1 = pa->ifbandwidth;
		opts->lssc_m2 = pa->ifbandwidth;
		opts->lssc_d = 0;
d673 1
a673 2
	} else if (pa->qid == 0)
		pa->qid = ++max_qid;
d675 1
d807 1
a807 1
		return (1);
d823 1
a823 1
static int
d830 34
a863 20
	if (opts->flags || opts->rtsc_m2 != 0 || opts->ulsc_m2 != 0 ||
	    (opts->lssc_m2 != 0 && (opts->lssc_m2 != a->bandwidth ||
	    opts->lssc_d != 0))) {
		printf("hfsc(");
		if (opts->flags & HFCF_RED)
			printf(" red");
		if (opts->flags & HFCF_ECN)
			printf(" ecn");
		if (opts->flags & HFCF_RIO)
			printf(" rio");
		if (opts->flags & HFCF_CLEARDSCP)
			printf(" cleardscp");
		if (opts->flags & HFCF_DEFAULTCLASS)
			printf(" default");
		if (opts->rtsc_m2 != 0) {
			if (opts->rtsc_d != 0)
				printf(" realtime(%s %ums %s)",
				    rate2str((double)opts->rtsc_m1),
				    opts->rtsc_d,
				    rate2str((double)opts->rtsc_m2));
d865 1
a865 19
				printf(" realtime %s",
				    rate2str((double)opts->rtsc_m2));
		}
		if (opts->lssc_m2 != 0 && (opts->lssc_m2 != a->bandwidth ||
		    opts->lssc_d != 0)) {
			if (opts->lssc_d != 0)
				printf(" linkshare(%s %ums %s)",
				    rate2str((double)opts->lssc_m1),
				    opts->lssc_d,
				    rate2str((double)opts->lssc_m2));
			else
				printf(" linkshare %s",
				    rate2str((double)opts->lssc_m2));
		}
		if (opts->ulsc_m2 != 0) {
			if (opts->ulsc_d != 0)
				printf(" upperlimit(%s %ums %s)",
				    rate2str((double)opts->ulsc_m1),
				    opts->ulsc_d,
d867 2
a868 9
				else
					printf(" upperlimit %s",
					    rate2str((double)opts->ulsc_m2));
		}
		printf(" ) ");

		return (1);
	} else
		return (0);
a1115 68
}

int
eval_queue_opts(struct pf_altq *pa, struct node_queue_opt *opts,
    u_int32_t ref_bw)
{
	int	errors = 0;

	switch (pa->scheduler) {
	case ALTQT_CBQ:
		pa->pq_u.cbq_opts = opts->data.cbq_opts;
		break;
	case ALTQT_PRIQ:
		pa->pq_u.priq_opts = opts->data.priq_opts;
		break;
	case ALTQT_HFSC:
		pa->pq_u.hfsc_opts.flags = opts->data.hfsc_opts.flags;
		if (opts->data.hfsc_opts.linkshare.used) {
			pa->pq_u.hfsc_opts.lssc_m1 =
			    eval_bwspec(&opts->data.hfsc_opts.linkshare.m1,
			    ref_bw);
			pa->pq_u.hfsc_opts.lssc_m2 =
			    eval_bwspec(&opts->data.hfsc_opts.linkshare.m2,
			    ref_bw);
			pa->pq_u.hfsc_opts.lssc_d =
			    opts->data.hfsc_opts.linkshare.d;
		}
		if (opts->data.hfsc_opts.realtime.used) {
			pa->pq_u.hfsc_opts.rtsc_m1 =
			    eval_bwspec(&opts->data.hfsc_opts.realtime.m1,
			    ref_bw);
			pa->pq_u.hfsc_opts.rtsc_m2 =
			    eval_bwspec(&opts->data.hfsc_opts.realtime.m2,
			    ref_bw);
			pa->pq_u.hfsc_opts.rtsc_d =
			    opts->data.hfsc_opts.realtime.d;
		}
		if (opts->data.hfsc_opts.upperlimit.used) {
			pa->pq_u.hfsc_opts.ulsc_m1 =
			    eval_bwspec(&opts->data.hfsc_opts.upperlimit.m1,
			    ref_bw);
			pa->pq_u.hfsc_opts.ulsc_m2 =
			    eval_bwspec(&opts->data.hfsc_opts.upperlimit.m2,
			    ref_bw);
			pa->pq_u.hfsc_opts.ulsc_d =
			    opts->data.hfsc_opts.upperlimit.d;
		}
		break;
	default:
		warnx("eval_queue_opts: unknown scheduler type %u",
		    opts->qtype);
		errors++;
		break;
	}

	return (errors);
}

u_int32_t
eval_bwspec(struct node_queue_bw *bw, u_int32_t ref_bw)
{
	if (bw->bw_absolute > 0)
		return (bw->bw_absolute);

	if (bw->bw_percent > 0)
		return (ref_bw / 100 * bw->bw_percent);

	return (0);
@


1.1.1.5
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.72 2003/04/15 11:29:24 henning Exp $	*/
d74 1
a74 2
static int	print_hfsc_opts(const struct pf_altq *,
		    const struct node_queue_opt *);
a89 2
void		 print_hfsc_sc(const char *, u_int, u_int, u_int,
		     const struct node_hfsc_sc *);
d164 1
a164 2
print_altq(const struct pf_altq *a, unsigned level, struct node_queue_bw *bw,
	struct node_queue_opt *qopts)
d167 1
a167 1
		print_queue(a, level, bw, 0, qopts);
d183 1
a183 1
		if (!print_hfsc_opts(a, qopts))
d201 1
a201 1
    int print_interface, struct node_queue_opt *qopts)
d230 1
a230 1
		print_hfsc_opts(a, qopts);
d824 1
a824 1
print_hfsc_opts(const struct pf_altq *a, const struct node_queue_opt *qopts)
d826 1
a826 2
	const struct hfsc_opts		*opts;
	const struct node_hfsc_sc	*rtsc, *lssc, *ulsc;
a828 7
	if (qopts == NULL)
		rtsc = lssc = ulsc = NULL;
	else {
		rtsc = &qopts->data.hfsc_opts.realtime;
		lssc = &qopts->data.hfsc_opts.linkshare;
		ulsc = &qopts->data.hfsc_opts.upperlimit;
	}
d844 10
a853 3
		if (opts->rtsc_m2 != 0)
			print_hfsc_sc("realtime", opts->rtsc_m1, opts->rtsc_d,
			    opts->rtsc_m2, rtsc);
d855 20
a874 6
		    opts->lssc_d != 0))
			print_hfsc_sc("linkshare", opts->lssc_m1, opts->lssc_d,
			    opts->lssc_m2, lssc);
		if (opts->ulsc_m2 != 0)
			print_hfsc_sc("upperlimit", opts->ulsc_m1, opts->ulsc_d,
			    opts->ulsc_m2, ulsc);
a1194 24
}

void
print_hfsc_sc(const char *scname, u_int m1, u_int d, u_int m2,
    const struct node_hfsc_sc *sc)
{
	printf(" %s", scname);

	if (d != 0) {
		printf("(");
		if (sc != NULL && sc->m1.bw_percent > 0)
			printf("%u%%", sc->m1.bw_percent);
		else
			printf("%s", rate2str((double)m1));
		printf(" %u", d);
	}

	if (sc != NULL && sc->m2.bw_percent > 0)
		printf(" %u%%", sc->m2.bw_percent);
	else
		printf(" %s", rate2str((double)m2));

	if (d != 0)
		printf(")");
@


1.1.1.6
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.73 2003/05/08 22:09:54 dhartmei Exp $	*/
a1093 2
	if (close(s))
		err(1, "close");
a1111 2
	if (close(s))
		err(1, "close");
@


1.1.1.7
log
@Import OpenBSD CVS of roughly 2000-2200 UTC. Last import before release.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.74 2003/06/06 17:53:05 henning Exp $	*/
d4 3
a6 3
 * Copyright (c) 2002
 *	Sony Computer Science Laboratories Inc.
 * Copyright (c) 2002, 2003 Henning Brauer <henning@@openbsd.org>
d8 8
a15 3
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d17 11
a27 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.1.1.8
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.75 2003/06/20 16:53:48 deraadt Exp $	*/
d483 3
a485 3
	maxidle = ((maxidle * 8.0) / nsPerByte) * pow(2.0, (double)RM_FILTER_GAIN);
	offtime = (offtime * 8.0) / nsPerByte * pow(2.0, (double)RM_FILTER_GAIN);
	minidle = ((minidle * 8.0) / nsPerByte) * pow(2.0, (double)RM_FILTER_GAIN);
d876 2
a877 2
		gsc_add_seg(gsc, 0.0, 0.0, (double)sc->d, (double)sc->m1);
	gsc_add_seg(gsc, (double)sc->d, 0.0, INFINITY, (double)sc->m2);
@


1.1.1.9
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.77 2003/08/22 21:50:34 david Exp $	*/
a388 5
	if (pa->priority >= CBQ_MAXPRI) {
		warnx("priority out of range: max %d", CBQ_MAXPRI - 1);
		return (-1);
	}

d869 1
a869 1
/* add a new service curve to a generalized service curve */
@


1.1.1.10
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.78 2003/10/21 21:09:13 itojun Exp $	*/
d161 1
a161 1
	if (a->qname[0] != 0) {
@


1.1.1.11
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.79 2004/01/14 08:42:23 kjc Exp $	*/
d85 1
a85 1
static u_int32_t	 max_qid = 0;
a263 2
		if (size > 0xffff)
			size = 0xffff;
d413 1
a413 1
	if (pa->qid == 0)
a665 2
	if (pa->qid == 0)
		pa->qid = ++max_qid;
d668 1
d673 2
a674 1
	}
@


1.1.1.12
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.84 2004/04/26 02:50:04 kjc Exp $	*/
d24 1
a31 1
#include <limits.h>
d85 2
d168 1
a168 1
	switch (a->scheduler) {
d309 1
a309 2
	struct pf_altq	*if_pa, *parent, *altq;
	u_int32_t	 bwsum;
d341 6
a346 2
		pa->bandwidth = eval_bwspec(bw,
		    parent == NULL ? 0 : parent->bandwidth);
d353 4
a356 21
		/* check the sum of the child bandwidth is under parent's */
		if (parent != NULL) {
			if (pa->bandwidth > parent->bandwidth) {
				warnx("bandwidth for %s higher than parent",
				    pa->qname);
				return (1);
			}
			bwsum = 0;
			TAILQ_FOREACH(altq, &altqs, entries) {
				if (strncmp(altq->ifname, pa->ifname,
				    IFNAMSIZ) == 0 &&
				    altq->qname[0] != 0 &&
				    strncmp(altq->parent, pa->parent,
				    PF_QNAME_SIZE) == 0)
					bwsum += altq->bandwidth;
			}
			bwsum += pa->bandwidth;
			if (bwsum > parent->bandwidth) {
				warnx("the sum of the child bandwidth higher"
				    " than parent \"%s\"", parent->qname);
			}
d415 2
d490 3
a492 6
	maxidle = ((maxidle * 8.0) / nsPerByte) *
	    pow(2.0, (double)RM_FILTER_GAIN);
	offtime = (offtime * 8.0) / nsPerByte *
	    pow(2.0, (double)RM_FILTER_GAIN);
	minidle = ((minidle * 8.0) / nsPerByte) *
	    pow(2.0, (double)RM_FILTER_GAIN);
d500 2
a501 2
	opts->ns_per_byte = (u_int)nsPerByte;
	opts->maxidle = (u_int)fabs(maxidle);
d503 1
a503 1
	opts->offtime = (u_int)fabs(offtime);
d598 3
d668 2
d723 1
a723 1
			sc.d = altq->pq_u.hfsc_opts.rtsc_d;
d734 1
a734 1
			sc.d = altq->pq_u.hfsc_opts.lssc_d;
a741 6
		/* add this queue to the sum */
		sc.m1 = opts->rtsc_m1;
		sc.d = opts->rtsc_d;
		sc.m2 = opts->rtsc_m2;
		gsc_add_sc(&rtsc, &sc);
		/* compare the sum with 80% of the interface */
d743 1
a743 1
		sc.d = 0;
d746 1
a746 2
			warnx("real-time sc exceeds 80%% of the interface "
			    "bandwidth (%s)", rate2str((double)sc.m2));
a752 6
		/* add this queue to the child sum */
		sc.m1 = opts->lssc_m1;
		sc.d = opts->lssc_d;
		sc.m2 = opts->lssc_m2;
		gsc_add_sc(&lssc, &sc);
		/* compare the sum of the children with parent's sc */
d754 1
a754 1
		sc.d = parent->pq_u.hfsc_opts.lssc_d;
d1012 1
a1012 1
	end = gsc_getentry(gsc, x2);
@


