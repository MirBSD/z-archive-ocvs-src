head	1.10;
access;
symbols
	tg-mergetmp-mirosx-1:1.10
	tg-mergefixes-1-branch:1.10.0.4
	tg-mergefixes-1-base:1.10
	MIROS_X:1.10.0.2
	MIROS_X_BASE:1.10
	tg-mergetmp-3:1.10
	MIRBSD_XP_MIRPPC:1.9.0.4
	cvs-200410141645:1.1.1.12
	MIRBSD_XP_SPARC_BASE:1.9
	MIRBSD_XP_SPARC:1.9.0.2
	MIRBSD_7quater:1.1.1.8
	cvs-200405160640:1.1.1.11
	cvs-200401271800:1.1.1.10
	cvs-200401261630:1.1.1.10
	cvs-200401021645:1.1.1.9
	MIRBSD_7_ALPHA:1.1.1.8.0.6
	MIRBSD_7:1.1.1.8.0.4
	cvs-200312222040:1.1.1.9
	MIRBSD_7ter:1.1.1.8
	MIRBSD_7_DEV:1.1.1.8.0.2
	cvs-200310020700:1.1.1.8
	cvs-200309271030:1.1.1.8
	cvs-200309251530:1.1.1.8
	cvs-200308302005:1.1.1.8
	cvs-200308171200:1.1.1.7
	ctm-3496:1.1.1.7
	ctm-3449:1.1.1.7
	ctm-3437:1.1.1.7
	cvs-200307191805:1.1.1.7
	ctm-3425:1.1.1.7
	cvs-200307091500:1.1.1.6
	ctm-3389:1.1.1.6
	cvs-200306291430:1.1.1.5
	ctm-3341:1.1.1.4
	MIRBSD_5:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2004.10.14.20.50.51;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.06.18.57.23;	author tg;	state Stab;
branches;
next	1.8;

1.8
date	2004.06.05.23.31.48;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.27.16.43.32;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.10.16.05.30;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.27.20.32.10;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.26.21.55.31;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.26.21.44.17;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.16.22.10.15;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.48.36;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.48.36;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.43.35;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.31.22;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.19.12.42.46;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.06.29.17.27.28;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.07.06.15.39.46;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.07.18.13.42.38;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.08.30.23.01.18;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.12.22.21.10.48;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.01.26.18.30.09;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2004.05.16.08.26.01;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2004.10.14.17.20.16;	author tg;	state Exp;
branches;
next	;


desc
@@


1.10
log
@merge openbsd; fix; enhance
@
text
@/**	$MirBSD$ */
/*	$OpenBSD: mkfs.c,v 1.45 2004/10/14 07:40:29 otto Exp $	*/
/*	$NetBSD: mkfs.c,v 1.25 1995/06/18 21:35:38 cgd Exp $	*/

/*
 * Copyright (c) 1980, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/mman.h>

#include <err.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <err.h>

#ifndef STANDALONE
#include <a.out.h>
#include <stdio.h>
#include <errno.h>
#endif

__SCCSID("@@(#)mkfs.c	8.3 (Berkeley) 2/3/94");
__RCSID("$MirBSD: src/sbin/newfs/mkfs.c,v 1.9 2004/06/06 18:57:23 tg Stab $");

/*
 * make file system for cylinder-group style file systems
 */

/*
 * We limit the size of the inode map to be no more than a
 * third of the cylinder group space, since we must leave at
 * least an equal amount of space for the block map.
 *
 * N.B.: MAXIPG must be a multiple of INOPB(fs).
 */
#define MAXIPG(fs)	roundup((fs)->fs_bsize * NBBY / 3, INOPB(fs))

#define UMASK		0755
#define MAXINOPB	(MAXBSIZE / sizeof(struct ufs1_dinode))
#define POWEROF2(num)	(((num) & ((num) - 1)) == 0)

/*
 * variables set up by front end.
 */
extern int	mfs;		/* run as the memory based filesystem */
extern int	Nflag;		/* run mkfs without writing file system */
extern int	Oflag;		/* format as an 4.3BSD file system */
extern int	fssize;		/* file system size */
extern int	ntracks;	/* # tracks/cylinder */
extern int	nsectors;	/* # sectors/track */
extern int	nphyssectors;	/* # sectors/track including spares */
extern int	secpercyl;	/* sectors per cylinder */
extern int	sectorsize;	/* bytes/sector */
extern int	rpm;		/* revolutions/minute of drive */
extern int	interleave;	/* hardware sector interleave */
extern int	trackskew;	/* sector 0 skew, per track */
extern int	fsize;		/* fragment size */
extern int	bsize;		/* block size */
extern int	cpg;		/* cylinders/cylinder group */
extern int	cpgflg;		/* cylinders/cylinder group flag was given */
extern int	minfree;	/* free space threshold */
extern int	opt;		/* optimization preference (space or time) */
extern int	density;	/* number of bytes per inode */
extern int	maxcontig;	/* max contiguous blocks to allocate */
extern int	rotdelay;	/* rotational delay between blocks */
extern int	maxbpg;		/* maximum blocks per file in a cyl group */
extern int	nrpos;		/* # of distinguished rotational positions */
extern int	bbsize;		/* boot block size */
extern int	sbsize;		/* superblock size */
extern int	avgfilesize;	/* expected average file size */
extern int	avgfilesperdir;	/* expected number of files per directory */
extern int	quiet;		/* quiet flag */
extern caddr_t	membase;	/* start address of memory based filesystem */

union fs_u {
	struct fs fs;
	char pad[SBSIZE];
} *fsun;
#define sblock	fsun->fs

struct	csum *fscs;

union cg_u {
	struct cg cg;
	char pad[MAXBSIZE];
} *cgun;
#define acg	cgun->cg

struct ufs1_dinode *zino;
char	*buf;

int	fsi, fso;

daddr_t		alloc(int, int);
static int	charsperline(void);
void		initcg(int, time_t);
void		wtfs(daddr_t, int, void *);
int		fsinit(time_t, mode_t, uid_t, gid_t);
int		makedir(struct direct *, int);
void		iput(struct ufs1_dinode *, ino_t);
void		setblock(struct fs *, unsigned char *, int);
void		clrblock(struct fs *, unsigned char *, int);
int		isblock(struct fs *, unsigned char *, int);
int		urdfs(daddr_t, int, void *);
void		rdfs(daddr_t, int, void *);
void		mkfs(struct partition *, char *, int, int,
		    mode_t, uid_t, gid_t);

#ifndef STANDALONE
volatile sig_atomic_t cur_cylno;
volatile const char *cur_fsys;

void
siginfo(int sig)
{
	int save_errno = errno;
	char buf[128];

	snprintf(buf, sizeof(buf), "%s: initializing cg %ld/%d\n",
	    cur_fsys, (long)cur_cylno, sblock.fs_ncg);
	write(STDERR_FILENO, buf, strlen(buf));
	errno = save_errno;
}
#endif

void
mkfs(struct partition *pp, char *fsys, int fi, int fo,
    mode_t mfsmode, uid_t mfsuid, gid_t mfsgid)
{
	long i, mincpc, mincpg, inospercg;
	long cylno, rpos, blk, j, warn = 0;
	long used, mincpgcnt, bpcg;
	long mapcramped, inodecramped;
	long postblsize, rotblsize, totalsbsize;
	time_t utime;
	quad_t sizepb;
	int width;
	char tmpbuf[100];	/* XXX this will break in about 2,500 years */
#define	sblk2	(sblk2_u.fs)
	union fs_u sblk2_u;

	if ((fsun = calloc(1, sizeof (union fs_u))) == NULL ||
	    (cgun = calloc(1, sizeof (union cg_u))) == NULL ||
	    (zino = calloc(1, MAXBSIZE)) == NULL ||
	    (buf = calloc(1, MAXBSIZE)) == NULL) {
		err(1, "calloc");
	}

#ifndef STANDALONE
	time(&utime);
#endif
	if (mfs) {
		membase = mmap(NULL, fssize * sectorsize, PROT_READ|PROT_WRITE,
		    MAP_ANON|MAP_PRIVATE, -1, (off_t)0);
		if (membase == MAP_FAILED)
			err(12, "mmap");
		madvise(membase, fssize * sectorsize, MADV_RANDOM);
	}
	fsi = fi;
	fso = fo;
	if (Oflag) {
		sblock.fs_inodefmt = FS_42INODEFMT;
		sblock.fs_maxsymlinklen = 0;
	} else {
		sblock.fs_inodefmt = FS_44INODEFMT;
		sblock.fs_maxsymlinklen = MAXSYMLINKLEN;
	}
	/*
	 * Validate the given file system size.
	 * Verify that its last block can actually be accessed.
	 */
	if (fssize <= 0)
		errx(13, "preposterous size %d", fssize);
	wtfs(fssize - 1, sectorsize, (char *)&sblock);
recalc:
	/*
	 * collect and verify the sector and track info
	 */
	sblock.fs_nsect = nsectors;
	sblock.fs_ntrak = ntracks;
	if (sblock.fs_ntrak <= 0)
		errx(14, "preposterous ntrak %d", sblock.fs_ntrak);
	if (sblock.fs_nsect <= 0)
		errx(15, "preposterous nsect %d", sblock.fs_nsect);
	/*
	 * collect and verify the filesystem density info
	 */
	sblock.fs_avgfilesize = avgfilesize;
	sblock.fs_avgfpdir = avgfilesperdir;
	if (sblock.fs_avgfilesize <= 0)
		errx(14, "illegal expected average file size %d",
		    sblock.fs_avgfilesize);
	if (sblock.fs_avgfpdir <= 0)
		errx(15, "illegal expected number of files per directory %d",
		    sblock.fs_avgfpdir);
	/*
	 * collect and verify the block and fragment sizes
	 */
	sblock.fs_bsize = bsize;
	sblock.fs_fsize = fsize;
	if (!POWEROF2(sblock.fs_bsize)) {
		errx(16, "block size must be a power of 2, not %d",
		     sblock.fs_bsize);
	}
	if (!POWEROF2(sblock.fs_fsize)) {
		errx(17, "fragment size must be a power of 2, not %d",
		     sblock.fs_fsize);
	}
	if (sblock.fs_fsize < sectorsize) {
		errx(18, "fragment size %d is too small, minimum is %d",
		     sblock.fs_fsize, sectorsize);
	}
	if (sblock.fs_bsize < MINBSIZE) {
		errx(19, "block size %d is too small, minimum is %d",
		     sblock.fs_bsize, MINBSIZE);
	}
	if (sblock.fs_bsize > MAXBSIZE) {
		errx(19, "block size %d is too large, maximum is %d",
		     sblock.fs_bsize, MAXBSIZE);
	}
	if (sblock.fs_bsize < sblock.fs_fsize) {
		errx(20, "block size (%d) cannot be smaller than fragment size (%d)",
		     sblock.fs_bsize, sblock.fs_fsize);
	}
	sblock.fs_bmask = ~(sblock.fs_bsize - 1);
	sblock.fs_fmask = ~(sblock.fs_fsize - 1);
	sblock.fs_qbmask = ~sblock.fs_bmask;
	sblock.fs_qfmask = ~sblock.fs_fmask;
	for (sblock.fs_bshift = 0, i = sblock.fs_bsize; i > 1; i >>= 1)
		sblock.fs_bshift++;
	for (sblock.fs_fshift = 0, i = sblock.fs_fsize; i > 1; i >>= 1)
		sblock.fs_fshift++;
	sblock.fs_frag = numfrags(&sblock, sblock.fs_bsize);
	for (sblock.fs_fragshift = 0, i = sblock.fs_frag; i > 1; i >>= 1)
		sblock.fs_fragshift++;
	if (sblock.fs_frag > MAXFRAG) {
		errx(21, "fragment size %d is too small, minimum with block size %d is %d",
		    sblock.fs_fsize, sblock.fs_bsize,
		    sblock.fs_bsize / MAXFRAG);
	}
	sblock.fs_nrpos = nrpos;
	sblock.fs_nindir = sblock.fs_bsize / sizeof(daddr_t);
	sblock.fs_inopb = sblock.fs_bsize / sizeof(struct ufs1_dinode);
	sblock.fs_nspf = sblock.fs_fsize / sectorsize;
	for (sblock.fs_fsbtodb = 0, i = NSPF(&sblock); i > 1; i >>= 1)
		sblock.fs_fsbtodb++;
	sblock.fs_sblkno =
	    roundup(howmany(bbsize + sbsize, sblock.fs_fsize), sblock.fs_frag);
	sblock.fs_cblkno = (daddr_t)(sblock.fs_sblkno +
	    roundup(howmany(sbsize, sblock.fs_fsize), sblock.fs_frag));
	sblock.fs_iblkno = sblock.fs_cblkno + sblock.fs_frag;
	sblock.fs_cgoffset = roundup(
	    howmany(sblock.fs_nsect, NSPF(&sblock)), sblock.fs_frag);
	for (sblock.fs_cgmask = 0xffffffff, i = sblock.fs_ntrak; i > 1; i >>= 1)
		sblock.fs_cgmask <<= 1;
	if (!POWEROF2(sblock.fs_ntrak))
		sblock.fs_cgmask <<= 1;
	sblock.fs_maxfilesize = sblock.fs_bsize * NDADDR - 1;
	for (sizepb = sblock.fs_bsize, i = 0; i < NIADDR; i++) {
		sizepb *= NINDIR(&sblock);
		sblock.fs_maxfilesize += sizepb;
	}
	/*
	 * Validate specified/determined secpercyl
	 * and calculate minimum cylinders per group.
	 */
	sblock.fs_spc = secpercyl;
	for (sblock.fs_cpc = NSPB(&sblock), i = sblock.fs_spc;
	     sblock.fs_cpc > 1 && (i & 1) == 0;
	     sblock.fs_cpc >>= 1, i >>= 1)
		/* void */;
	mincpc = sblock.fs_cpc;
	bpcg = sblock.fs_spc * sectorsize;
	inospercg = roundup(bpcg / sizeof(struct ufs1_dinode), INOPB(&sblock));
	if (inospercg > MAXIPG(&sblock))
		inospercg = MAXIPG(&sblock);
	used = (sblock.fs_iblkno + inospercg / INOPF(&sblock)) * NSPF(&sblock);
	mincpgcnt = howmany(sblock.fs_cgoffset * (~sblock.fs_cgmask) + used,
	    sblock.fs_spc);
	mincpg = roundup(mincpgcnt, mincpc);
	/*
	 * Ensure that cylinder group with mincpg has enough space
	 * for block maps.
	 */
	sblock.fs_cpg = mincpg;
	sblock.fs_ipg = inospercg;
	if (maxcontig > 1)
		sblock.fs_contigsumsize = MIN(maxcontig, FS_MAXCONTIG);
	mapcramped = 0;
	/* A cylinder group *must* fit inside one block so force it if not. */
	if (CGSIZE(&sblock) > sblock.fs_bsize && secpercyl > 1024 && ntracks > 1) {
		secpercyl /= 2;
		ntracks /= 2;
		goto recalc;
	}
	while (CGSIZE(&sblock) > sblock.fs_bsize) {
		mapcramped = 1;
		if (sblock.fs_bsize < MAXBSIZE) {
			sblock.fs_bsize <<= 1;
			if ((i & 1) == 0) {
				i >>= 1;
			} else {
				sblock.fs_cpc <<= 1;
				mincpc <<= 1;
				mincpg = roundup(mincpgcnt, mincpc);
				sblock.fs_cpg = mincpg;
			}
			sblock.fs_frag <<= 1;
			sblock.fs_fragshift += 1;
			if (sblock.fs_frag <= MAXFRAG)
				continue;
		}
		if (sblock.fs_fsize == sblock.fs_bsize) {
			errx(22, "no block size to support this disk");
		}
		sblock.fs_frag >>= 1;
		sblock.fs_fragshift -= 1;
		sblock.fs_fsize <<= 1;
		sblock.fs_nspf <<= 1;
	}
	/*
	 * Ensure that cylinder group with mincpg has enough space for inodes.
	 */
	inodecramped = 0;
	used *= sectorsize;
	inospercg = roundup(((int64_t)mincpg * bpcg - used) / density,
	    INOPB(&sblock));
	sblock.fs_ipg = inospercg;
	while (inospercg > MAXIPG(&sblock)) {
		inodecramped = 1;
		if (mincpc == 1 || sblock.fs_frag == 1 ||
		    sblock.fs_bsize == MINBSIZE)
			break;
		printf("With a block size of %d %s %ld\n",
		    sblock.fs_bsize, "minimum bytes per inode is",
		    (mincpg * bpcg - used) / MAXIPG(&sblock) + 1);
		sblock.fs_bsize >>= 1;
		sblock.fs_frag >>= 1;
		sblock.fs_fragshift -= 1;
		mincpc >>= 1;
		sblock.fs_cpg = roundup(mincpgcnt, mincpc);
		if (CGSIZE(&sblock) > sblock.fs_bsize) {
			sblock.fs_bsize <<= 1;
			break;
		}
		mincpg = sblock.fs_cpg;
		inospercg = roundup(((int64_t)mincpg * bpcg - used) / density,
		    INOPB(&sblock));
		sblock.fs_ipg = inospercg;
	}
	if (inodecramped) {
		if (inospercg > MAXIPG(&sblock)) {
			printf("Minimum bytes per inode is %ld\n",
			    (mincpg * bpcg - used) / MAXIPG(&sblock) + 1);
		} else if (!mapcramped) {
			printf("With %d bytes per inode, ", density);
			printf("minimum cylinders per group is %ld\n", mincpg);
		}
	}
	if (mapcramped) {
		printf("With %d sectors per cylinder, ", sblock.fs_spc);
		printf("minimum cylinders per group is %ld\n", mincpg);
	}
	if (inodecramped || mapcramped) {
		if (sblock.fs_bsize != bsize)
			printf("%s to be changed from %d to %d\n",
			    "This requires the block size",
			    bsize, sblock.fs_bsize);
		if (sblock.fs_fsize != fsize)
			printf("\t%s to be changed from %d to %d\n",
			    "and the fragment size",
			    fsize, sblock.fs_fsize);
		exit(23);
	}
	/*
	 * Calculate the number of cylinders per group
	 */
	sblock.fs_cpg = cpg;
	if (sblock.fs_cpg % mincpc != 0) {
		if (!quiet)
			printf("%s groups must have a multiple of %ld "
			    "cylinders\n", cpgflg ? "Cylinder" :
			    "Warning: cylinder", mincpc);
		sblock.fs_cpg = roundup(sblock.fs_cpg, mincpc);
		if (!cpgflg)
			cpg = sblock.fs_cpg;
	}
	/*
	 * Must ensure there is enough space for inodes.
	 */
	sblock.fs_ipg = roundup(((int64_t)sblock.fs_cpg * bpcg - used) /
	    density, INOPB(&sblock));
	while (sblock.fs_ipg > MAXIPG(&sblock)) {
		inodecramped = 1;
		sblock.fs_cpg -= mincpc;
		sblock.fs_ipg = roundup(((int64_t)sblock.fs_cpg * bpcg - used) /
		    density, INOPB(&sblock));
	}
	/*
	 * Must ensure there is enough space to hold block map.
	 */
	if (CGSIZE(&sblock) > sblock.fs_bsize && secpercyl > 1024 && ntracks > 1) {
		secpercyl /= 2;
		ntracks /= 2;
		goto recalc;
	}
	while (CGSIZE(&sblock) > sblock.fs_bsize) {
		mapcramped = 1;
		sblock.fs_cpg -= mincpc;
		sblock.fs_ipg = roundup(((int64_t)sblock.fs_cpg * bpcg - used) /
		    density, INOPB(&sblock));
	}
	sblock.fs_fpg = (sblock.fs_cpg * sblock.fs_spc) / NSPF(&sblock);
	if ((sblock.fs_cpg * sblock.fs_spc) % NSPB(&sblock) != 0) {
		errx(24, "panic (fs_cpg * fs_spc) %% NSPF != 0");
	}
	if (sblock.fs_cpg < mincpg) {
		errx(25, "cylinder groups must have at least %ld cylinders",
			mincpg);
	} else if (cpgflg && sblock.fs_cpg != cpg) {
		if (!mapcramped && !inodecramped)
			errx(26, "!mapcramped && !inodecramped");
		if (mapcramped && inodecramped)
			printf("Block size and bytes per inode restrict");
		else if (mapcramped)
			printf("Block size restricts");
		else
			printf("Bytes per inode restrict");
		printf(" cylinders per group to %d.\n", sblock.fs_cpg);
		if (cpgflg)
			exit(27);
	}
	sblock.fs_cgsize = fragroundup(&sblock, CGSIZE(&sblock));
	/*
	 * Now have size for file system and nsect and ntrak.
	 * Determine number of cylinders and blocks in the file system.
	 */
	sblock.fs_size = dbtofsb(&sblock, fssize);
	sblock.fs_ncyl = sblock.fs_size * NSPF(&sblock) / sblock.fs_spc;
	if (sblock.fs_size * NSPF(&sblock) > sblock.fs_ncyl * sblock.fs_spc) {
		sblock.fs_ncyl++;
		warn = 1;
	}
	if (sblock.fs_ncyl < 1) {
		errx(28,
		    "file systems must have at least one cylinder (not %d)",
		     sblock.fs_ncyl);
	}
	/*
	 * Determine feasability/values of rotational layout tables.
	 *
	 * The size of the rotational layout tables is limited by the
	 * size of the superblock, SBSIZE. The amount of space available
	 * for tables is calculated as (SBSIZE - sizeof (struct fs)).
	 * The size of these tables is inversely proportional to the block
	 * size of the file system. The size increases if sectors per track
	 * are not powers of two, because more cylinders must be described
	 * by the tables before the rotational pattern repeats (fs_cpc).
	 */
	sblock.fs_interleave = interleave;
	sblock.fs_trackskew = trackskew;
	sblock.fs_npsect = nphyssectors;
	sblock.fs_postblformat = FS_DYNAMICPOSTBLFMT;
	sblock.fs_sbsize = fragroundup(&sblock, sizeof(struct fs));
	if (sblock.fs_sbsize > SBSIZE)
		sblock.fs_sbsize = SBSIZE;
	if (sblock.fs_ntrak == 1) {
		sblock.fs_cpc = 0;
		goto next;
	}
	postblsize = sblock.fs_nrpos * sblock.fs_cpc * sizeof(int16_t);
	rotblsize = sblock.fs_cpc * sblock.fs_spc / NSPB(&sblock);
	totalsbsize = sizeof(struct fs) + rotblsize;
	if (sblock.fs_nrpos == 8 && sblock.fs_cpc <= 16) {
		/* use old static table space */
		sblock.fs_postbloff = (char *)(&sblock.fs_opostbl[0][0]) -
		    (char *)(&sblock.fs_firstfield);
		sblock.fs_rotbloff = &sblock.fs_space[0] -
		    (u_char *)(&sblock.fs_firstfield);
	} else {
		/* use dynamic table space */
		sblock.fs_postbloff = &sblock.fs_space[0] -
		    (u_char *)(&sblock.fs_firstfield);
		sblock.fs_rotbloff = sblock.fs_postbloff + postblsize;
		totalsbsize += postblsize;
	}
	if (totalsbsize > SBSIZE || fragroundup(&sblock, totalsbsize) > SBSIZE
	    || sblock.fs_nsect > (1 << NBBY) * NSPB(&sblock)) {
		printf("%s %s %d %s %d.%s",
		    "Warning: insufficient space in super block for\n",
		    "rotational layout tables with nsect", sblock.fs_nsect,
		    "and ntrak", sblock.fs_ntrak,
		    "\nFile system performance may be impaired.\n");
		sblock.fs_cpc = 0;
		goto next;
	}
	sblock.fs_sbsize = fragroundup(&sblock, totalsbsize);
	/*
	 * calculate the available blocks for each rotational position
	 */
	for (cylno = 0; cylno < sblock.fs_cpc; cylno++)
		for (rpos = 0; rpos < sblock.fs_nrpos; rpos++)
			fs_postbl(&sblock, cylno)[rpos] = -1;
	for (i = (rotblsize - 1) * sblock.fs_frag;
	     i >= 0; i -= sblock.fs_frag) {
		cylno = cbtocylno(&sblock, i);
		rpos = cbtorpos(&sblock, i);
		blk = fragstoblks(&sblock, i);
		if (fs_postbl(&sblock, cylno)[rpos] == -1)
			fs_rotbl(&sblock)[blk] = 0;
		else
			fs_rotbl(&sblock)[blk] =
			    fs_postbl(&sblock, cylno)[rpos] - blk;
		fs_postbl(&sblock, cylno)[rpos] = blk;
	}
next:
	/*
	 * Compute/validate number of cylinder groups.
	 */
	sblock.fs_ncg = sblock.fs_ncyl / sblock.fs_cpg;
	if (sblock.fs_ncyl % sblock.fs_cpg)
		sblock.fs_ncg++;
	sblock.fs_dblkno = sblock.fs_iblkno + sblock.fs_ipg / INOPF(&sblock);
	i = MIN(~sblock.fs_cgmask, sblock.fs_ncg - 1);
	if (cgdmin(&sblock, i) - cgbase(&sblock, i) >= sblock.fs_fpg) {
		printf("inode blocks/cyl group (%ld) >= data blocks (%d)\n",
		    cgdmin(&sblock, i) - cgbase(&sblock, i) / sblock.fs_frag,
		    sblock.fs_fpg / sblock.fs_frag);
		printf("number of cylinders per cylinder group (%d) %s.\n",
		    sblock.fs_cpg, "must be increased");
		exit(29);
	}
	j = sblock.fs_ncg - 1;
	if ((i = sblock.fs_size - j * sblock.fs_fpg) < sblock.fs_fpg &&
	    cgdmin(&sblock, j) - cgbase(&sblock, j) > i) {
		if (j == 0) {
			errx(30, "filesystem must have at least %d sectors",
			     NSPF(&sblock) *
			    (cgdmin(&sblock, 0) + 3 * sblock.fs_frag));
		}
		printf("Warning: inode blocks/cyl group (%ld) >= data blocks (%ld) in last\n",
		    (cgdmin(&sblock, j) - cgbase(&sblock, j)) / sblock.fs_frag,
		    i / sblock.fs_frag);
		printf("    cylinder group. This implies %ld sector(s) cannot be allocated.\n",
		    i * NSPF(&sblock));
		sblock.fs_ncg--;
		sblock.fs_ncyl -= sblock.fs_ncyl % sblock.fs_cpg;
		sblock.fs_size = sblock.fs_ncyl * sblock.fs_spc / NSPF(&sblock);
		fssize = fsbtodb(&sblock, sblock.fs_size);
		warn = 0;
	}
	if (!quiet && warn && !mfs) {
		printf("Warning: %d sector(s) in last cylinder unallocated\n",
		    sblock.fs_spc -
		    (dbtofsb(&sblock, fssize) * NSPF(&sblock) -
		    (sblock.fs_ncyl - 1) * sblock.fs_spc));
	}
	/*
	 * fill in remaining fields of the super block
	 */
	sblock.fs_csaddr = cgdmin(&sblock, 0);
	sblock.fs_cssize =
	    fragroundup(&sblock, sblock.fs_ncg * sizeof(struct csum));

	/*
	 * The superblock fields 'fs_csmask' and 'fs_csshift' are no
	 * longer used. However, we still initialise them so that the
	 * filesystem remains compatible with old kernels.
	 */
	i = sblock.fs_bsize / sizeof(struct csum);
	sblock.fs_csmask = ~(i - 1);
	for (sblock.fs_csshift = 0; i > 1; i >>= 1)
		sblock.fs_csshift++;
	if ((fscs = calloc(1, sblock.fs_cssize)) == NULL)
		err(1, "cg summary");
	sblock.fs_magic = FS_MAGIC;
	sblock.fs_rotdelay = rotdelay;
	sblock.fs_minfree = minfree;
	sblock.fs_maxcontig = maxcontig;
	sblock.fs_maxbpg = maxbpg;
	sblock.fs_rps = rpm / 60;
	sblock.fs_optim = opt;
	sblock.fs_cgrotor = 0;
	sblock.fs_cstotal.cs_ndir = 0;
	sblock.fs_cstotal.cs_nbfree = 0;
	sblock.fs_cstotal.cs_nifree = 0;
	sblock.fs_cstotal.cs_nffree = 0;
	sblock.fs_fmod = 0;
	sblock.fs_ronly = 0;
	sblock.fs_clean = FS_ISCLEAN;
	sblock.fs_id[0] = (u_int32_t)utime;
	sblock.fs_id[1] = (u_int32_t)arc4random();

	/*
	 * Dump out summary information about file system.
	 */
	if (!mfs) {
		printf("%s:\t%d sectors in %d %s of %d tracks, %d sectors\n",
		    fsys, sblock.fs_size * NSPF(&sblock), sblock.fs_ncyl,
		    "cylinders", sblock.fs_ntrak, sblock.fs_nsect);
#define B2MBFACTOR (1 / (1024.0 * 1024.0))
		printf("\t%.1fMB in %d cyl groups (%d c/g, %.2fMB/g, %d i/g)\n",
		    (float)sblock.fs_size * sblock.fs_fsize * B2MBFACTOR,
		    sblock.fs_ncg, sblock.fs_cpg,
		    (float)sblock.fs_fpg * sblock.fs_fsize * B2MBFACTOR,
		    sblock.fs_ipg);
#undef B2MBFACTOR
	}
	/*
	 * Now build the cylinders group blocks and
	 * then print out indices of cylinder groups.
	 */
	if (!quiet)
		printf("super-block backups (for fsck -b #) at:\n");
#ifndef STANDALONE
	else if (!mfs && isatty(STDIN_FILENO)) {
		signal(SIGINFO, siginfo);
		cur_fsys = fsys;
	}
#endif
	/* read out old (potential) superblock */
	i = '!';
	if (urdfs((int)SBOFF / sectorsize, sbsize, (char *)&sblk2)) {
		i = '?';
	} else {
		arc4random_push(sblk2.fs_firstfield);
		arc4random_push(sblk2.fs_unused_1);
	}
	if (!quiet)
		putchar(i);

	i = 0;
	width = charsperline();
	for (cylno = 0; cylno < sblock.fs_ncg; cylno++) {
		cur_cylno = (sig_atomic_t)cylno;
		initcg(cylno, utime);
		if (quiet)
			continue;
		j = snprintf(tmpbuf, sizeof tmpbuf, " %ld,",
		    fsbtodb(&sblock, cgsblock(&sblock, cylno)));
		if (i+j >= width) {
			printf("\n");
			i = 0;
		}
		i += j;
		printf("%s", tmpbuf);
		fflush(stdout);
	}
	if (!quiet)
		printf("\n");
	if (Nflag && !mfs)
		exit(0);
	/*
	 * Now construct the initial file system,
	 * then write out the super-block.
	 */
	if (fsinit(utime, mfsmode, mfsuid, mfsgid) != 0)
		errx(32, "fsinit failed");
	sblock.fs_time = utime;
	/* don't write magic until we are done */
	sblock.fs_magic = 0;
	wtfs((int)SBOFF / sectorsize, sbsize, (char *)&sblock);
	sblock.fs_magic = FS_MAGIC;
	sblock.fs_firstfield = arc4random();
	for (i = 0; i < sblock.fs_cssize; i += sblock.fs_bsize)
		wtfs(fsbtodb(&sblock, sblock.fs_csaddr + numfrags(&sblock, i)),
			sblock.fs_cssize - i < sblock.fs_bsize ?
			    sblock.fs_cssize - i : sblock.fs_bsize,
			((char *)fscs) + i);
	/*
	 * Write out the duplicate super blocks
	 */
	for (cylno = 0; cylno < sblock.fs_ncg; cylno++) {
		sblock.fs_unused_1 = arc4random();
		wtfs(fsbtodb(&sblock, cgsblock(&sblock, cylno)),
		    sbsize, (char *)&sblock);
	}
	/* done, can write with magic now */
	sblock.fs_unused_1 = arc4random();
	wtfs((int)SBOFF / sectorsize, sbsize, (char *)&sblock);
	/*
	 * Update information about this partion in pack
	 * label, to that it may be updated on disk.
	 */
	pp->p_fstype = FS_BSDFFS;
	pp->p_fsize = sblock.fs_fsize;
	pp->p_frag = sblock.fs_frag;
	pp->p_cpg = sblock.fs_cpg;
}

/*
 * Initialize a cylinder group.
 */
void
initcg(int cylno, time_t utime)
{
	daddr_t cbase, d, dlower, dupper, dmax, blkno;
	long i, j;
	struct csum *cs;

	/*
	 * Determine block bounds for cylinder group.
	 * Allow space for super block summary information in first
	 * cylinder group.
	 */
	cbase = cgbase(&sblock, cylno);
	dmax = cbase + sblock.fs_fpg;
	if (dmax > sblock.fs_size)
		dmax = sblock.fs_size;
	dlower = cgsblock(&sblock, cylno) - cbase;
	dupper = cgdmin(&sblock, cylno) - cbase;
	if (cylno == 0)
		dupper += howmany(sblock.fs_cssize, sblock.fs_fsize);
	cs = fscs + cylno;
	memset(&acg, 0, sblock.fs_cgsize);
	acg.cg_time = utime;
	acg.cg_magic = CG_MAGIC;
	acg.cg_cgx = cylno;
	if (cylno == sblock.fs_ncg - 1)
		acg.cg_ncyl = sblock.fs_ncyl % sblock.fs_cpg;
	else
		acg.cg_ncyl = sblock.fs_cpg;
	acg.cg_niblk = sblock.fs_ipg;
	acg.cg_ndblk = dmax - cbase;
	if (sblock.fs_contigsumsize > 0)
		acg.cg_nclusterblks = acg.cg_ndblk / sblock.fs_frag;
	acg.cg_btotoff = &acg.cg_space[0] - (u_char *)(&acg.cg_firstfield);
	acg.cg_boff = acg.cg_btotoff + sblock.fs_cpg * sizeof(int32_t);
	acg.cg_iusedoff = acg.cg_boff +
		sblock.fs_cpg * sblock.fs_nrpos * sizeof(int16_t);
	acg.cg_freeoff = acg.cg_iusedoff + howmany(sblock.fs_ipg, NBBY);
	if (sblock.fs_contigsumsize <= 0) {
		acg.cg_nextfreeoff = acg.cg_freeoff +
		   howmany(sblock.fs_cpg * sblock.fs_spc / NSPF(&sblock), NBBY);
	} else {
		acg.cg_clustersumoff = acg.cg_freeoff + howmany
		    (sblock.fs_cpg * sblock.fs_spc / NSPF(&sblock), NBBY) -
		    sizeof(int32_t);
		acg.cg_clustersumoff =
		    roundup(acg.cg_clustersumoff, sizeof(int32_t));
		acg.cg_clusteroff = acg.cg_clustersumoff +
		    (sblock.fs_contigsumsize + 1) * sizeof(int32_t);
		acg.cg_nextfreeoff = acg.cg_clusteroff + howmany
		    (sblock.fs_cpg * sblock.fs_spc / NSPB(&sblock), NBBY);
	}
	if (acg.cg_nextfreeoff > sblock.fs_cgsize)
		errx(37, "panic: cylinder group too big");
	acg.cg_cs.cs_nifree += sblock.fs_ipg;
	if (cylno == 0)
		for (i = 0; i < ROOTINO; i++) {
			setbit(cg_inosused(&acg), i);
			acg.cg_cs.cs_nifree--;
		}
	for (i = 0; i < sblock.fs_ipg / INOPF(&sblock); i += sblock.fs_frag) {
		for (j = 0; j < sblock.fs_bsize / sizeof(struct ufs1_dinode); j++)
			zino[j].di_gen = (u_int32_t)arc4random();
		wtfs(fsbtodb(&sblock, cgimin(&sblock, cylno) + i),
		    sblock.fs_bsize, (char *)zino);
	}
	if (cylno > 0) {
		/*
		 * In cylno 0, beginning space is reserved
		 * for boot and super blocks.
		 */
		for (d = 0; d < dlower; d += sblock.fs_frag) {
			blkno = d / sblock.fs_frag;
			setblock(&sblock, cg_blksfree(&acg), blkno);
			if (sblock.fs_contigsumsize > 0)
				setbit(cg_clustersfree(&acg), blkno);
			acg.cg_cs.cs_nbfree++;
			cg_blktot(&acg)[cbtocylno(&sblock, d)]++;
			cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
			    [cbtorpos(&sblock, d)]++;
		}
		sblock.fs_dsize += dlower;
	}
	sblock.fs_dsize += acg.cg_ndblk - dupper;
	if ((i = dupper % sblock.fs_frag)) {
		acg.cg_frsum[sblock.fs_frag - i]++;
		for (d = dupper + sblock.fs_frag - i; dupper < d; dupper++) {
			setbit(cg_blksfree(&acg), dupper);
			acg.cg_cs.cs_nffree++;
		}
	}
	for (d = dupper; d + sblock.fs_frag <= dmax - cbase; ) {
		blkno = d / sblock.fs_frag;
		setblock(&sblock, cg_blksfree(&acg), blkno);
		if (sblock.fs_contigsumsize > 0)
			setbit(cg_clustersfree(&acg), blkno);
		acg.cg_cs.cs_nbfree++;
		cg_blktot(&acg)[cbtocylno(&sblock, d)]++;
		cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
		    [cbtorpos(&sblock, d)]++;
		d += sblock.fs_frag;
	}
	if (d < dmax - cbase) {
		acg.cg_frsum[dmax - cbase - d]++;
		for (; d < dmax - cbase; d++) {
			setbit(cg_blksfree(&acg), d);
			acg.cg_cs.cs_nffree++;
		}
	}
	if (sblock.fs_contigsumsize > 0) {
		int32_t *sump = cg_clustersum(&acg);
		u_char *mapp = cg_clustersfree(&acg);
		int map = *mapp++;
		int bit = 1;
		int run = 0;

		for (i = 0; i < acg.cg_nclusterblks; i++) {
			if ((map & bit) != 0) {
				run++;
			} else if (run != 0) {
				if (run > sblock.fs_contigsumsize)
					run = sblock.fs_contigsumsize;
				sump[run]++;
				run = 0;
			}
			if ((i & (NBBY - 1)) != (NBBY - 1)) {
				bit <<= 1;
			} else {
				map = *mapp++;
				bit = 1;
			}
		}
		if (run != 0) {
			if (run > sblock.fs_contigsumsize)
				run = sblock.fs_contigsumsize;
			sump[run]++;
		}
	}
	sblock.fs_cstotal.cs_ndir += acg.cg_cs.cs_ndir;
	sblock.fs_cstotal.cs_nffree += acg.cg_cs.cs_nffree;
	sblock.fs_cstotal.cs_nbfree += acg.cg_cs.cs_nbfree;
	sblock.fs_cstotal.cs_nifree += acg.cg_cs.cs_nifree;
	*cs = acg.cg_cs;
	wtfs(fsbtodb(&sblock, cgtod(&sblock, cylno)),
	    sblock.fs_bsize, (char *)&acg);
}

/*
 * initialize the file system
 */
struct ufs1_dinode node;

#ifdef LOSTDIR
#define PREDEFDIR 3
#else
#define PREDEFDIR 2
#endif

struct direct root_dir[] = {
	{ ROOTINO, sizeof(struct direct), DT_DIR, 1, "." },
	{ ROOTINO, sizeof(struct direct), DT_DIR, 2, ".." },
#ifdef LOSTDIR
	{ LOSTFOUNDINO, sizeof(struct direct), DT_DIR, 10, "lost+found" },
#endif
};
struct odirect {
	u_int32_t d_ino;
	u_int16_t d_reclen;
	u_int16_t d_namlen;
	u_char	d_name[MAXNAMLEN + 1];
} oroot_dir[] = {
	{ ROOTINO, sizeof(struct direct), 1, "." },
	{ ROOTINO, sizeof(struct direct), 2, ".." },
#ifdef LOSTDIR
	{ LOSTFOUNDINO, sizeof(struct direct), 10, "lost+found" },
#endif
};
#ifdef LOSTDIR
struct direct lost_found_dir[] = {
	{ LOSTFOUNDINO, sizeof(struct direct), DT_DIR, 1, "." },
	{ ROOTINO, sizeof(struct direct), DT_DIR, 2, ".." },
	{ 0, DIRBLKSIZ, 0, 0, 0 },
};
struct odirect olost_found_dir[] = {
	{ LOSTFOUNDINO, sizeof(struct direct), 1, "." },
	{ ROOTINO, sizeof(struct direct), 2, ".." },
	{ 0, DIRBLKSIZ, 0, 0 },
};
#endif

int
fsinit(time_t utime, mode_t mfsmode, uid_t mfsuid, gid_t mfsgid)
{
	/*
	 * initialize the node
	 */
	node.di_atime = utime;
	node.di_mtime = utime;
	node.di_ctime = utime;
#ifdef LOSTDIR
	/*
	 * create the lost+found directory
	 */
	if (Oflag) {
		int i;

		(void)makedir((struct direct *)olost_found_dir, 2);
		for (i = DIRBLKSIZ; i < sblock.fs_bsize; i += DIRBLKSIZ)
			memcpy(&buf[i], &olost_found_dir[2],
			    DIRSIZ(0, &olost_found_dir[2]));
	} else {
		int i;

		(void)makedir(lost_found_dir, 2);
		for (i = DIRBLKSIZ; i < sblock.fs_bsize; i += DIRBLKSIZ)
			memcpy(&buf[i], &lost_found_dir[2],
			    DIRSIZ(0, &lost_found_dir[2]));
	}
	node.di_mode = IFDIR | 1700;
	node.di_nlink = 2;
	node.di_size = sblock.fs_bsize;
	if ((node.di_db[0] = alloc(node.di_size, node.di_mode)) == 0)
		return (1);
	node.di_blocks = btodb(fragroundup(&sblock, node.di_size));
	wtfs(fsbtodb(&sblock, node.di_db[0]), node.di_size, buf);
	iput(&node, LOSTFOUNDINO);
#endif
	/*
	 * create the root directory
	 */
	if (mfs) {
		node.di_mode = IFDIR | mfsmode;
		node.di_uid = mfsuid;
		node.di_gid = mfsgid;
	} else {
		node.di_mode = IFDIR | UMASK;
		node.di_uid = geteuid();
		node.di_gid = getegid();
	}
	node.di_nlink = PREDEFDIR;
	if (Oflag)
		node.di_size = makedir((struct direct *)oroot_dir, PREDEFDIR);
	else
		node.di_size = makedir(root_dir, PREDEFDIR);
	if ((node.di_db[0] = alloc(sblock.fs_fsize, node.di_mode)) == 0)
		return (1);
	node.di_blocks = btodb(fragroundup(&sblock, node.di_size));
	wtfs(fsbtodb(&sblock, node.di_db[0]), sblock.fs_fsize, buf);
	iput(&node, ROOTINO);
	return (0);
}

/*
 * construct a set of directory entries in "buf".
 * return size of directory.
 */
int
makedir(struct direct *protodir, int entries)
{
	char *cp;
	int i, spcleft;

	spcleft = DIRBLKSIZ;
	for (cp = buf, i = 0; i < entries - 1; i++) {
		protodir[i].d_reclen = DIRSIZ(0, &protodir[i]);
		memcpy(cp, &protodir[i], protodir[i].d_reclen);
		cp += protodir[i].d_reclen;
		spcleft -= protodir[i].d_reclen;
	}
	protodir[i].d_reclen = spcleft;
	memcpy(cp, &protodir[i], DIRSIZ(0, &protodir[i]));
	return (DIRBLKSIZ);
}

/*
 * allocate a block or frag
 */
daddr_t
alloc(int size, int mode)
{
	int i, frag;
	daddr_t d, blkno;

	rdfs(fsbtodb(&sblock, cgtod(&sblock, 0)), sblock.fs_cgsize,
	    (char *)&acg);
	if (acg.cg_magic != CG_MAGIC) {
		printf("cg 0: bad magic number\n");
		return (0);
	}
	if (acg.cg_cs.cs_nbfree == 0) {
		printf("first cylinder group ran out of space\n");
		return (0);
	}
	for (d = 0; d < acg.cg_ndblk; d += sblock.fs_frag)
		if (isblock(&sblock, cg_blksfree(&acg), d / sblock.fs_frag))
			goto goth;
	printf("internal error: can't find block in cyl 0\n");
	return (0);
goth:
	blkno = fragstoblks(&sblock, d);
	clrblock(&sblock, cg_blksfree(&acg), blkno);
	if (sblock.fs_contigsumsize > 0)
		clrbit(cg_clustersfree(&acg), blkno);
	acg.cg_cs.cs_nbfree--;
	sblock.fs_cstotal.cs_nbfree--;
	fscs[0].cs_nbfree--;
	if (mode & IFDIR) {
		acg.cg_cs.cs_ndir++;
		sblock.fs_cstotal.cs_ndir++;
		fscs[0].cs_ndir++;
	}
	cg_blktot(&acg)[cbtocylno(&sblock, d)]--;
	cg_blks(&sblock, &acg, cbtocylno(&sblock, d))[cbtorpos(&sblock, d)]--;
	if (size != sblock.fs_bsize) {
		frag = howmany(size, sblock.fs_fsize);
		fscs[0].cs_nffree += sblock.fs_frag - frag;
		sblock.fs_cstotal.cs_nffree += sblock.fs_frag - frag;
		acg.cg_cs.cs_nffree += sblock.fs_frag - frag;
		acg.cg_frsum[sblock.fs_frag - frag]++;
		for (i = frag; i < sblock.fs_frag; i++)
			setbit(cg_blksfree(&acg), d + i);
	}
	wtfs(fsbtodb(&sblock, cgtod(&sblock, 0)), sblock.fs_cgsize,
	    (char *)&acg);
	return (d);
}

/*
 * Allocate an inode on the disk
 */
void
iput(struct ufs1_dinode *ip, ino_t ino)
{
	struct ufs1_dinode buf[MAXINOPB];
	daddr_t d;

	ip->di_gen = (u_int32_t)arc4random();
	rdfs(fsbtodb(&sblock, cgtod(&sblock, 0)), sblock.fs_cgsize,
	    (char *)&acg);
	if (acg.cg_magic != CG_MAGIC) {
		errx(41, "cg 0: bad magic number (0x%06x != 0x%06x)",
		     acg.cg_magic, CG_MAGIC);
	}
	acg.cg_cs.cs_nifree--;
	setbit(cg_inosused(&acg), ino);
	wtfs(fsbtodb(&sblock, cgtod(&sblock, 0)), sblock.fs_cgsize,
	    (char *)&acg);
	sblock.fs_cstotal.cs_nifree--;
	fscs[0].cs_nifree--;
	if (ino >= sblock.fs_ipg * sblock.fs_ncg) {
		errx(32, "fsinit: inode value %d out of range", ino);
	}
	d = fsbtodb(&sblock, ino_to_fsba(&sblock, ino));
	rdfs(d, sblock.fs_bsize, buf);
	buf[ino_to_fsbo(&sblock, ino)] = *ip;
	wtfs(d, sblock.fs_bsize, buf);
}

/*
 * read a block from the file system
 */
void
rdfs(daddr_t bno, int size, void *bf)
{
	if (urdfs(bno, size, bf)) {
		err(34, "rdfs: read error on block %d", bno);
	}
}

int
urdfs(daddr_t bno, int size, void *bf)
{
	if (mfs) {
		memcpy(bf, membase + bno * sectorsize, size);
		return 0;
	}
	return (size != pread(fsi, bf, size, (off_t)bno * sectorsize));
}

/*
 * write a block to the file system
 */
void
wtfs(daddr_t bno, int size, void *bf)
{
	int n;

	if (mfs) {
		memcpy(membase + bno * sectorsize, bf, size);
		return;
	}
	if (Nflag)
		return;
	n = pwrite(fso, bf, size, (off_t)bno * sectorsize);
	if (n != size) {
		err(36, "wtfs: write error on block %d", bno);
	}
}

/*
 * check if a block is available
 */
int
isblock(struct fs *fs, unsigned char *cp, int h)
{
	unsigned char mask;

	switch (fs->fs_frag) {
	case 8:
		return (cp[h] == 0xff);
	case 4:
		mask = 0x0f << ((h & 0x1) << 2);
		return ((cp[h >> 1] & mask) == mask);
	case 2:
		mask = 0x03 << ((h & 0x3) << 1);
		return ((cp[h >> 2] & mask) == mask);
	case 1:
		mask = 0x01 << (h & 0x7);
		return ((cp[h >> 3] & mask) == mask);
	default:
#ifdef STANDALONE
		printf("isblock bad fs_frag %d\n", fs->fs_frag);
#else
		fprintf(stderr, "isblock bad fs_frag %d\n", fs->fs_frag);
#endif
		return (0);
	}
}

/*
 * take a block out of the map
 */
void
clrblock(struct fs *fs, unsigned char *cp, int h)
{
	switch ((fs)->fs_frag) {
	case 8:
		cp[h] = 0;
		return;
	case 4:
		cp[h >> 1] &= ~(0x0f << ((h & 0x1) << 2));
		return;
	case 2:
		cp[h >> 2] &= ~(0x03 << ((h & 0x3) << 1));
		return;
	case 1:
		cp[h >> 3] &= ~(0x01 << (h & 0x7));
		return;
	default:
#ifdef STANDALONE
		printf("clrblock bad fs_frag %d\n", fs->fs_frag);
#else
		fprintf(stderr, "clrblock bad fs_frag %d\n", fs->fs_frag);
#endif
		return;
	}
}

/*
 * put a block into the map
 */
void
setblock(struct fs *fs, unsigned char *cp, int h)
{
	switch (fs->fs_frag) {
	case 8:
		cp[h] = 0xff;
		return;
	case 4:
		cp[h >> 1] |= (0x0f << ((h & 0x1) << 2));
		return;
	case 2:
		cp[h >> 2] |= (0x03 << ((h & 0x3) << 1));
		return;
	case 1:
		cp[h >> 3] |= (0x01 << (h & 0x7));
		return;
	default:
#ifdef STANDALONE
		printf("setblock bad fs_frag %d\n", fs->fs_frag);
#else
		fprintf(stderr, "setblock bad fs_frag %d\n", fs->fs_frag);
#endif
		return;
	}
}

/*
 * Determine the number of characters in a
 * single line.
 */
static int
charsperline(void)
{
	int columns;
	char *cp;
	struct winsize ws;

	columns = 0;
	if (ioctl(0, TIOCGWINSZ, &ws) != -1)
		columns = ws.ws_col;
	if (columns == 0 && (cp = getenv("COLUMNS")))
		columns = atoi(cp);
	if (columns == 0)
		columns = 80;   /* last resort */
	return columns;
}
@


1.9
log
@oh my goddesses, I broke mfs!
fix by using a second superblock structure (I moved the code
up before, and down yesterday, but didn't remember that the
sblock structure has already been initialized)
@
text
@d1 3
a3 3
/* $MirBSD: src/sbin/newfs/mkfs.c,v 1.8 2004/06/05 23:31:48 tg Exp $	*/
/* $OpenBSD: mkfs.c,v 1.39 2004/05/13 22:36:39 mickey Exp $	*/
/* $NetBSD: mkfs.c,v 1.25 1995/06/18 21:35:38 cgd Exp $	*/
d43 1
d56 1
a56 1
__RCSID("$MirBSD: src/sbin/newfs/mkfs.c,v 1.8 2004/06/05 23:31:48 tg Exp $");
d131 1
a131 1
void		fsinit(time_t);
d139 2
a140 1
void		mkfs(struct partition *pp, char *fsys, int fi, int fo);
d160 2
a161 1
mkfs(struct partition *pp, char *fsys, int fi, int fo)
d187 1
a187 1
		    MAP_ANON|MAP_PRIVATE, -1, 0);
d250 4
d359 2
a360 1
	inospercg = roundup((mincpg * bpcg - used) / density, INOPB(&sblock));
d380 2
a381 2
		inospercg =
		    roundup((mincpg * bpcg - used) / density, INOPB(&sblock));
d424 2
a425 2
	sblock.fs_ipg = roundup((sblock.fs_cpg * bpcg - used) / density,
		INOPB(&sblock));
d429 2
a430 2
		sblock.fs_ipg = roundup((sblock.fs_cpg * bpcg - used) / density,
			INOPB(&sblock));
d443 2
a444 2
		sblock.fs_ipg = roundup((sblock.fs_cpg * bpcg - used) / density,
			INOPB(&sblock));
d498 2
d520 2
a521 2
	if (totalsbsize > SBSIZE ||
	    sblock.fs_nsect > (1 << NBBY) * NSPB(&sblock)) {
d690 2
a691 1
	fsinit(utime);
d779 1
a779 1
	if (acg.cg_nextfreeoff - (long)(&acg.cg_firstfield) > sblock.fs_cgsize) {
a780 1
	}
d917 2
a918 2
void
fsinit(time_t utime)
d948 2
a949 1
	node.di_db[0] = alloc(node.di_size, node.di_mode);
d957 5
a961 3
	if (mfs)
		node.di_mode = IFDIR | 01777;
	else
d963 3
d971 2
a972 1
	node.di_db[0] = alloc(sblock.fs_fsize, node.di_mode);
d976 1
a1061 1
	int c;
a1063 1
	c = ino_to_cg(&sblock, ino);
@


1.8
log
@fix reading in old superblock for once and ever; simplify
@
text
@d1 1
a1 1
/* $MirBSD: src/sbin/newfs/mkfs.c,v 1.7 2004/05/27 16:43:32 tg Exp $	*/
d55 1
a55 1
__RCSID("$MirBSD: src/sbin/newfs/mkfs.c,v 1.7 2004/05/27 16:43:32 tg Exp $");
d169 2
d646 1
a646 1
	if (urdfs((int)SBOFF / sectorsize, sbsize, (char *)&sblock)) {
d649 2
a650 2
		arc4random_push(sblock.fs_firstfield);
		arc4random_push(sblock.fs_unused_1);
@


1.7
log
@Last piece of OpenBSD 3.5-current merge part I.

Things left:
* merge import in src/gnu/
* fix kernel build (it _is_ broken)

TOP 1 will be done with a _second_ import (easier).
TOP 2 will be done RSN.

----

Also, move RCS IDs to new-style MirOS ones, and fix the
SMM doc, and add output to newfs(8) saying if (!) or if
not (?) it read the random value out of the previous
superblock before making the fs.
@
text
@d1 1
a1 1
/* $MirBSD: src/sbin/newfs/mkfs.c,v 1.6 2004/05/10 16:05:30 tg Exp $	*/
d55 1
a55 1
__RCSID("$MirBSD: src/sbin/newfs/mkfs.c,v 1.6 2004/05/10 16:05:30 tg Exp $");
a168 1
	char a4buf[8];
d642 11
a681 9
#ifdef	__MirBSD__
	/* read out old (potential) superblock */
	if (!urdfs((int)SBOFF / sectorsize, 8, (char *)&a4buf)) {
		if (!quiet)
			printf("! ");
		arc4random_addrandom((u_char *)&a4buf, 8);
	} else if (!quiet)
		printf("? ");
#endif
a683 1
#ifdef	__MirBSD__
a684 1
#endif
a693 1
#ifdef	__MirBSD__
a694 1
#endif
a698 1
#ifdef	__MirBSD__
a699 1
#endif
d1070 8
a1080 2
	int n;

d1085 1
a1085 10
	n = pread(fsi, bf, size, (off_t)bno * sectorsize);
	return (n == size) ? 0 : 1;
}

void
rdfs(daddr_t bno, int size, void *bf)
{
	if (urdfs(bno, size, bf)) {
		err(34, "rdfs: read error on block %d", bno);
	}
@


1.6
log
@a non-failing newfs... (at least not more than OpenBSD's)
@
text
@d1 2
a2 2
/* $MirBSD: src/sbin/newfs/mkfs.c,v 1.5 2004/04/27 20:32:10 tg Exp $	*/
/* $OpenBSD: mkfs.c,v 1.38 2004/01/13 01:42:08 tedu Exp $	*/
a33 4
#include <sys/cdefs.h>
__SCCSID("@@(#)mkfs.c	8.3 (Berkeley) 2/3/94");
__RCSID("$MirBSD: src/sbin/newfs/mkfs.c,v 1.5 2004/04/27 20:32:10 tg Exp $");

d51 1
d54 3
d140 17
d637 6
d646 1
d674 3
a676 1
	if (!urdfs((int)SBOFF / sectorsize, 8, (char *)&a4buf))
d678 2
@


1.5
log
@fixup: don't panic mfs; don't fail reading random data
@
text
@d1 3
a3 3
/*	$MirBSD: src/sbin/newfs/mkfs.c,v 1.4 2004/04/26 21:55:31 tg Exp $	*/
/*	$OpenBSD: mkfs.c,v 1.38 2004/01/13 01:42:08 tedu Exp $	*/
/*	$NetBSD: mkfs.c,v 1.25 1995/06/18 21:35:38 cgd Exp $	*/
d36 1
a36 1
__RCSID("$MirBSD: src/sbin/newfs/mkfs.c,v 1.4 2004/04/26 21:55:31 tg Exp $");
d136 1
d650 1
a650 2
	if (!mfs) {
		rdfs((int)SBOFF / sectorsize, 8, (char *)&a4buf);
a651 1
	}
d1047 2
a1048 2
void
rdfs(daddr_t bno, int size, void *bf)
d1054 1
a1054 1
		return;
d1057 7
a1063 1
	if (n != size) {
@


1.4
log
@get rid of warnings
@
text
@d1 1
a1 1
/*	$MirBSD: src/sbin/newfs/mkfs.c,v 1.3 2004/04/26 21:44:17 tg Exp $	*/
d36 1
a36 1
__RCSID("$MirBSD: src/sbin/newfs/mkfs.c,v 1.3 2004/04/26 21:44:17 tg Exp $");
d151 1
a159 6
#ifdef	__MirBSD__
	/* read out old (potential) superblock */
	rdfs((int)SBOFF / sectorsize, sbsize, (char *)&sblock);
	arc4random_addrandom((u_char *)&sblock, 8);
#endif

d647 7
@


1.3
log
@newfs(8) also reads out random data from a potential prior-existing
ffs where it writes its new superblock, and uses arc4random(3) to
throw out magic into them as well (different for each superblock;
fsck_ffs(8) can read these, in case it should be needed)
@
text
@d1 1
a1 1
/*	$MirBSD$	*/
d36 1
a36 1
__RCSID("$MirBSD$");
d50 1
d162 1
a162 1
	arc4random_addrandom(&sblock, 8);
@


1.2
log
@pull in patch from -current by markus:
fix race between mount(2) and exit(2) for mount_mfs.
from netbsd (drochner, newfs.c 1.30, mkfs.c 1.29, no copyright changes)
@
text
@d1 2
a2 1
/*	$OpenBSD: mkfs.c,v 1.24 2003/04/16 10:33:16 markus Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d34 3
a36 7
#ifndef lint
#if 0
static char sccsid[] = "@@(#)mkfs.c	8.3 (Berkeley) 2/3/94";
#else
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.24 2003/04/16 10:33:16 markus Exp $";
#endif
#endif /* not lint */
a39 1
#include <sys/resource.h>
d45 1
d70 1
a70 1
#define MAXINOPB	(MAXBSIZE / sizeof(struct dinode))
a103 1
extern u_long	memleft;	/* virtual memory available */
d120 1
a120 1
struct dinode *zino;
d126 1
a126 1
static int	charsperline();
d131 1
a131 1
void		iput(struct dinode *, ino_t);
d136 1
d139 1
a139 4
mkfs(pp, fsys, fi, fo)
	struct partition *pp;
	char *fsys;
	int fi, fo;
a145 2
	pid_t ppid = -1;
	int status;
d151 5
a155 6
	if ((fsun = (union fs_u *)calloc(1, sizeof (union fs_u))) == 0 ||
	    (cgun = (union cg_u *)malloc(sizeof (union cg_u))) == 0 ||
	    (zino = (struct dinode *)malloc(MAXBSIZE)) == 0 ||
	    (buf = (char *)malloc(MAXBSIZE)) == 0) {
		printf("buffer malloc failed\n");
		exit(1);
d158 6
d168 5
a172 5
		(void)malloc(0);
		if (fssize * sectorsize > memleft)
			fssize = (memleft - 16384) / sectorsize;
		if ((membase = malloc(fssize * sectorsize)) == 0)
			exit(12);
d188 1
a188 1
		printf("preposterous size %d\n", fssize), exit(13);
d197 1
a197 1
		printf("preposterous ntrak %d\n", sblock.fs_ntrak), exit(14);
d199 1
a199 1
		printf("preposterous nsect %d\n", sblock.fs_nsect), exit(15);
d206 2
a207 2
		printf("illegal expected average file size %d\n",
		    sblock.fs_avgfilesize), exit(14);
d209 2
a210 2
		printf("illegal expected number of files per directory %d\n",
		    sblock.fs_avgfpdir), exit(15);
d217 2
a218 3
		printf("block size must be a power of 2, not %d\n",
		    sblock.fs_bsize);
		exit(16);
d221 2
a222 3
		printf("fragment size must be a power of 2, not %d\n",
		    sblock.fs_fsize);
		exit(17);
d225 2
a226 3
		printf("fragment size %d is too small, minimum is %d\n",
		    sblock.fs_fsize, sectorsize);
		exit(18);
d229 2
a230 3
		printf("block size %d is too small, minimum is %d\n",
		    sblock.fs_bsize, MINBSIZE);
		exit(19);
d233 2
a234 3
		printf("block size (%d) cannot be smaller than fragment size (%d)\n",
		    sblock.fs_bsize, sblock.fs_fsize);
		exit(20);
d248 1
a248 1
		printf("fragment size %d is too small, minimum with block size %d is %d\n",
a250 1
		exit(21);
d254 1
a254 1
	sblock.fs_inopb = sblock.fs_bsize / sizeof(struct dinode);
d285 1
a285 1
	inospercg = roundup(bpcg / sizeof(struct dinode), INOPB(&sblock));
d325 1
a325 3
			printf("There is no block size that");
			printf(" can support this disk\n");
			exit(22);
d390 4
a393 2
		printf("%s groups must have a multiple of %ld cylinders\n",
			cpgflg ? "Cylinder" : "Warning: cylinder", mincpc);
d425 1
a425 2
		printf("panic (fs_cpg * fs_spc) %% NSPF != 0");
		exit(24);
d428 1
a428 1
		printf("cylinder groups must have at least %ld cylinders\n",
d430 3
a432 6
		exit(25);
	} else if (sblock.fs_cpg != cpg) {
		if (!cpgflg)
			printf("Warning: ");
		else if (!mapcramped && !inodecramped)
			exit(26);
d455 3
a457 2
		printf("file systems must have at least one cylinder\n");
		exit(28);
d545 2
a546 2
			printf("Filesystem must have at least %d sectors\n",
			    NSPF(&sblock) *
a547 1
			exit(30);
d560 1
a560 1
	if (warn && !mfs) {
d582 2
a583 4
	if ((fscs = (struct csum *)calloc(1, sblock.fs_cssize)) == 0) {
		printf("cg summary malloc failed\n");
		exit(1);
	}
a598 1
#ifdef FSIRAND
d601 1
a601 1
#endif
d649 2
d652 4
d664 4
a667 1
	for (cylno = 0; cylno < sblock.fs_ncg; cylno++)
d670 6
d690 1
a690 3
initcg(cylno, utime)
	int cylno;
	time_t utime;
d742 1
a742 2
		printf("Panic: cylinder group too big\n");
		exit(37);
d751 1
a751 2
#ifdef FSIRAND
		for (j = 0; j < sblock.fs_bsize / sizeof(struct dinode); j++)
a752 1
#endif
d840 1
a840 1
struct dinode node;
d881 1
a881 2
fsinit(utime)
	time_t utime;
d939 1
a939 3
makedir(protodir, entries)
	struct direct *protodir;
	int entries;
d960 1
a960 3
alloc(size, mode)
	int size;
	int mode;
d1013 1
a1013 3
iput(ip, ino)
	struct dinode *ip;
	ino_t ino;
d1015 1
a1015 2
	struct dinode *buf =
	   (struct dinode *)malloc(MAXINOPB * sizeof (struct dinode));
a1018 1
#ifdef FSIRAND
a1019 1
#endif
d1024 2
a1025 2
		printf("cg 0: bad magic number\n");
		exit(31);
d1034 1
a1034 2
		printf("fsinit: inode value out of range (%d).\n", ino);
		exit(32);
a1039 79
	free(buf);
}

/*
 * Replace libc function with one suited to our needs.
 */
static void *
malloc(size)
	size_t size;
{
	void *base, *i;
	static u_long pgsz;
	struct rlimit rlp;

	if (pgsz == 0) {
		base = sbrk(0);
		pgsz = getpagesize() - 1;
		i = (char *)((u_long)(base + pgsz) &~ pgsz);
		base = sbrk(i - base);
		if (getrlimit(RLIMIT_DATA, &rlp) < 0)
			perror("getrlimit");
		rlp.rlim_cur = rlp.rlim_max;
		if (setrlimit(RLIMIT_DATA, &rlp) < 0)
			perror("setrlimit");
		memleft = rlp.rlim_max - (u_long)base;
	}
	size = (size + pgsz) &~ pgsz;
	if (size > memleft)
		size = memleft;
	memleft -= size;
	if (size == 0)
		return (0);
	return (sbrk(size));
}

/*
 * Replace libc function with one suited to our needs.
 */
static void *
realloc(ptr, size)
	void *ptr;
	size_t size;
{
	void *p;

	if ((p = malloc(size)) == NULL)
		return (NULL);
	if (ptr) {
		memcpy(p, ptr, size);
		free(ptr);
	}
	return (p);
}

/*
 * Replace libc function with one suited to our needs.
 */
static void *
calloc(size, numelm)
	size_t size;
	size_t numelm;
{
	void	*base;

	size *= numelm;
	if ((base = malloc(size)) != 0)
		memset(base, 0, size);
	return (base);
}

/*
 * Replace libc function with one suited to our needs.
 */
static void
free(ptr)
	void *ptr;
{
	
	/* do not worry about it for now */
d1046 1
a1046 4
rdfs(bno, size, bf)
	daddr_t bno;
	int size;
	void *bf;
d1056 1
a1056 3
		printf("read error: %d\n", bno);
		perror("rdfs");
		exit(34);
d1064 1
a1064 4
wtfs(bno, size, bf)
	daddr_t bno;
	int size;
	void *bf;
d1076 1
a1076 3
		printf("write error: %d\n", bno);
		perror("wtfs");
		exit(36);
d1084 1
a1084 4
isblock(fs, cp, h)
	struct fs *fs;
	unsigned char *cp;
	int h;
d1114 1
a1114 4
clrblock(fs, cp, h)
	struct fs *fs;
	unsigned char *cp;
	int h;
d1143 1
a1143 4
setblock(fs, cp, h)
	struct fs *fs;
	unsigned char *cp;
	int h;
d1173 1
a1173 1
charsperline()
a1177 1
	extern char *getenv();
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.23 2003/02/19 00:57:14 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.23 2003/02/19 00:57:14 millert Exp $";
a46 1
#include <sys/wait.h>
a55 1
#include <signal.h>
a159 1
	void started();
a174 12
		ppid = getpid();
		(void) signal(SIGUSR1, started);
		if ((i = fork())) {
			if (i == -1) {
				perror("mfs");
				exit(10);
			}
			if (waitpid(i, &status, 0) != -1 && WIFEXITED(status))
				exit(WEXITSTATUS(status));
			exit(11);
			/* NOTREACHED */
		}
a688 12
	/*
	 * Notify parent process of success.
	 * Dissociate from session and tty.
	 */
	if (mfs) {
		kill(ppid, SIGUSR1);
		(void) setsid();
		(void) close(0);
		(void) close(1);
		(void) close(2);
		(void) chdir("/");
	}
a1061 10
}

/*
 * Notify parent process that the filesystem has created itself successfully.
 */
void
started()
{

	_exit(0);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.27 2003/05/06 04:32:16 tedu Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.27 2003/05/06 04:32:16 tedu Exp $";
d47 2
a53 1
#include <sys/mman.h>
d57 1
d113 1
d162 1
d167 3
a169 3
	    (cgun = (union cg_u *)calloc(1, sizeof (union cg_u))) == 0 ||
	    (zino = (struct dinode *)calloc(1, MAXBSIZE)) == 0 ||
	    (buf = (char *)calloc(1, MAXBSIZE)) == 0) {
d178 16
a193 3
		membase = mmap(NULL, fssize * sectorsize, PROT_READ|PROT_WRITE,
		    MAP_ANON|MAP_PRIVATE, -1, 0);
		if (membase == MAP_FAILED)
d633 1
d636 1
a636 1

d704 12
d786 1
d789 1
d1059 2
a1060 1
	struct dinode buf[MAXINOPB];
d1064 1
d1066 1
d1088 89
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.28 2003/06/02 20:06:16 millert Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.28 2003/06/02 20:06:16 millert Exp $";
@


1.1.1.4
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.29 2003/06/11 06:22:14 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.29 2003/06/11 06:22:14 deraadt Exp $";
d141 4
a144 1
mkfs(struct partition *pp, char *fsys, int fi, int fo)
d688 3
a690 1
initcg(int cylno, time_t utime)
d882 2
a883 1
fsinit(time_t utime)
d941 3
a943 1
makedir(struct direct *protodir, int entries)
d964 3
a966 1
alloc(int size, int mode)
d1019 3
a1021 1
iput(struct dinode *ip, ino_t ino)
d1055 4
a1058 1
rdfs(daddr_t bno, int size, void *bf)
d1078 4
a1081 1
wtfs(daddr_t bno, int size, void *bf)
d1103 4
a1106 1
isblock(struct fs *fs, unsigned char *cp, int h)
d1136 4
a1139 1
clrblock(struct fs *fs, unsigned char *cp, int h)
d1168 4
a1171 1
setblock(struct fs *fs, unsigned char *cp, int h)
d1201 1
a1201 1
charsperline(void)
@


1.1.1.5
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.30 2003/06/25 21:24:10 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.30 2003/06/25 21:24:10 deraadt Exp $";
d129 1
a129 1
static int	charsperline(void);
d1179 1
@


1.1.1.6
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.31 2003/07/02 21:44:58 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.31 2003/07/02 21:44:58 deraadt Exp $";
a138 1
void		mkfs(struct partition *pp, char *fsys, int fi, int fo);
d148 2
@


1.1.1.7
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.32 2003/07/16 18:02:35 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.32 2003/07/16 18:02:35 tedu Exp $";
d435 4
a438 2
	} else if (cpgflg && sblock.fs_cpg != cpg) {
		if (!mapcramped && !inodecramped)
@


1.1.1.8
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.33 2003/08/25 23:28:15 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.33 2003/08/25 23:28:15 tedu Exp $";
d73 1
a73 1
#define MAXINOPB	(MAXBSIZE / sizeof(struct ufs1_dinode))
d123 1
a123 1
struct ufs1_dinode *zino;
d134 1
a134 1
void		iput(struct ufs1_dinode *, ino_t);
d156 1
a156 1
	    (zino = (struct ufs1_dinode *)calloc(1, MAXBSIZE)) == 0 ||
d257 1
a257 1
	sblock.fs_inopb = sblock.fs_bsize / sizeof(struct ufs1_dinode);
d288 1
a288 1
	inospercg = roundup(bpcg / sizeof(struct ufs1_dinode), INOPB(&sblock));
d744 1
a744 1
		for (j = 0; j < sblock.fs_bsize / sizeof(struct ufs1_dinode); j++)
d833 1
a833 1
struct ufs1_dinode node;
d1006 1
a1006 1
iput(struct ufs1_dinode *ip, ino_t ino)
d1008 1
a1008 1
	struct ufs1_dinode buf[MAXINOPB];
@


1.1.1.9
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.37 2003/12/05 00:40:29 mickey Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.37 2003/12/05 00:40:29 mickey Exp $";
d154 6
a159 5
	if ((fsun = calloc(1, sizeof (union fs_u))) == NULL ||
	    (cgun = calloc(1, sizeof (union cg_u))) == NULL ||
	    (zino = calloc(1, MAXBSIZE)) == NULL ||
	    (buf = calloc(1, MAXBSIZE)) == NULL) {
		err(1, "calloc");
d169 1
a169 2
			err(12, "mmap");
		madvise(membase, fssize * sectorsize, MADV_RANDOM);
d185 1
a185 1
		errx(13, "preposterous size %d", fssize);
d194 1
a194 1
		errx(14, "preposterous ntrak %d", sblock.fs_ntrak);
d196 1
a196 1
		errx(15, "preposterous nsect %d", sblock.fs_nsect);
d203 2
a204 2
		errx(14, "illegal expected average file size %d",
		    sblock.fs_avgfilesize);
d206 2
a207 2
		errx(15, "illegal expected number of files per directory %d",
		    sblock.fs_avgfpdir);
d214 3
a216 2
		errx(16, "block size must be a power of 2, not %d",
		     sblock.fs_bsize);
d219 3
a221 2
		errx(17, "fragment size must be a power of 2, not %d",
		     sblock.fs_fsize);
d224 3
a226 2
		errx(18, "fragment size %d is too small, minimum is %d",
		     sblock.fs_fsize, sectorsize);
d229 3
a231 2
		errx(19, "block size %d is too small, minimum is %d",
		     sblock.fs_bsize, MINBSIZE);
d234 3
a236 2
		errx(20, "block size (%d) cannot be smaller than fragment size (%d)",
		     sblock.fs_bsize, sblock.fs_fsize);
d250 1
a250 1
		errx(21, "fragment size %d is too small, minimum with block size %d is %d",
d253 1
d328 3
a330 1
			errx(22, "no block size to support this disk");
d428 2
a429 1
		errx(24, "panic (fs_cpg * fs_spc) %% NSPF != 0");
d432 1
a432 1
		errx(25, "cylinder groups must have at least %ld cylinders",
d434 1
d437 1
a437 1
			errx(26, "!mapcramped && !inodecramped");
d460 2
a461 3
		errx(28,
		    "file systems must have at least one cylinder (not %d)",
		     sblock.fs_ncyl);
d549 2
a550 2
			errx(30, "filesystem must have at least %d sectors",
			     NSPF(&sblock) *
d552 1
d587 4
a590 2
	if ((fscs = calloc(1, sblock.fs_cssize)) == NULL)
		err(1, "cg summary");
a655 2
	/* don't write magic until we are done */
	sblock.fs_magic = 0;
a656 1
	sblock.fs_magic = FS_MAGIC;
a667 2
	/* done, can write with magic now */
	wtfs((int)SBOFF / sectorsize, sbsize, (char *)&sblock);
d734 2
a735 1
		errx(37, "panic: cylinder group too big");
d1017 2
a1018 2
		errx(41, "cg 0: bad magic number (0x%06x != 0x%06x)",
		     acg.cg_magic, CG_MAGIC);
d1027 2
a1028 1
		errx(32, "fsinit: inode value %d out of range", ino);
d1050 3
a1052 1
		err(34, "rdfs: read error on block %d", bno);
d1072 3
a1074 1
		err(36, "wtfs: write error on block %d", bno);
@


1.1.1.10
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.38 2004/01/13 01:42:08 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.38 2004/01/13 01:42:08 tedu Exp $";
d387 2
a388 4
		if (!quiet)
			printf("%s groups must have a multiple of %ld "
			    "cylinders\n", cpgflg ? "Cylinder" :
			    "Warning: cylinder", mincpc);
d555 1
a555 1
	if (!quiet && warn && !mfs) {
@


1.1.1.11
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.39 2004/05/13 22:36:39 mickey Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.39 2004/05/13 22:36:39 mickey Exp $";
a56 1
#include <errno.h>
a140 17
#ifndef STANDALONE
volatile sig_atomic_t cur_cylno;
volatile const char *cur_fsys;

void
siginfo(int sig)
{
	int save_errno = errno;
	char buf[128];

	snprintf(buf, sizeof(buf), "%s: initializing cg %ld/%d\n",
	    cur_fsys, (long)cur_cylno, sblock.fs_ncg);
	write(STDERR_FILENO, buf, strlen(buf));
	errno = save_errno;
}
#endif

a619 6
#ifndef STANDALONE
	else if (!mfs && isatty(STDIN_FILENO)) {
		signal(SIGINFO, siginfo);
		cur_fsys = fsys;
	}
#endif
a622 1
		cur_cylno = (sig_atomic_t)cylno;
@


1.1.1.12
log
@fixes for laaarge discs
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.45 2004/10/14 07:40:29 otto Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.45 2004/10/14 07:40:29 otto Exp $";
a49 1
#include <err.h>
d133 1
a133 1
int		fsinit(time_t, mode_t, uid_t, gid_t);
d140 1
a140 2
void		mkfs(struct partition *, char *, int, int,
		    mode_t, uid_t, gid_t);
d160 1
a160 2
mkfs(struct partition *pp, char *fsys, int fi, int fo,
    mode_t mfsmode, uid_t mfsuid, gid_t mfsgid)
d184 1
a184 1
		    MAP_ANON|MAP_PRIVATE, -1, (off_t)0);
a246 4
	if (sblock.fs_bsize > MAXBSIZE) {
		errx(19, "block size %d is too large, maximum is %d",
		     sblock.fs_bsize, MAXBSIZE);
	}
d352 1
a352 2
	inospercg = roundup(((int64_t)mincpg * bpcg - used) / density,
	    INOPB(&sblock));
d372 2
a373 2
		inospercg = roundup(((int64_t)mincpg * bpcg - used) / density,
		    INOPB(&sblock));
d416 2
a417 2
	sblock.fs_ipg = roundup(((int64_t)sblock.fs_cpg * bpcg - used) /
	    density, INOPB(&sblock));
d421 2
a422 2
		sblock.fs_ipg = roundup(((int64_t)sblock.fs_cpg * bpcg - used) /
		    density, INOPB(&sblock));
d435 2
a436 2
		sblock.fs_ipg = roundup(((int64_t)sblock.fs_cpg * bpcg - used) /
		    density, INOPB(&sblock));
a489 2
	if (sblock.fs_sbsize > SBSIZE)
		sblock.fs_sbsize = SBSIZE;
d510 2
a511 2
	if (totalsbsize > SBSIZE || fragroundup(&sblock, totalsbsize) > SBSIZE
	    || sblock.fs_nsect > (1 << NBBY) * NSPB(&sblock)) {
d669 1
a669 2
	if (fsinit(utime, mfsmode, mfsuid, mfsgid) != 0)
		errx(32, "fsinit failed");
d753 1
a753 1
	if (acg.cg_nextfreeoff > sblock.fs_cgsize)
d755 1
d892 2
a893 2
int
fsinit(time_t utime, mode_t mfsmode, uid_t mfsuid, gid_t mfsgid)
d923 1
a923 2
	if ((node.di_db[0] = alloc(node.di_size, node.di_mode)) == 0)
		return (1);
d931 3
a933 5
	if (mfs) {
		node.di_mode = IFDIR | mfsmode;
		node.di_uid = mfsuid;
		node.di_gid = mfsgid;
	} else {
a934 3
		node.di_uid = geteuid();
		node.di_gid = getegid();
	}
d940 1
a940 2
	if ((node.di_db[0] = alloc(sblock.fs_fsize, node.di_mode)) == 0)
		return (1);
a943 1
	return (0);
d1029 1
d1032 1
@


