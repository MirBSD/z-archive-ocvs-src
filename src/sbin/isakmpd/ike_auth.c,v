head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.8
	tg-mergefixes-1-branch:1.1.1.8.0.4
	tg-mergefixes-1-base:1.1.1.8
	MIROS_X:1.1.1.8.0.2
	MIROS_X_BASE:1.1.1.8
	tg-mergetmp-3:1.1.1.8
	cvs-200411261545:1.1.1.8
	MIRBSD_XP_MIRPPC:1.1.1.7.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.7
	MIRBSD_XP_SPARC:1.1.1.7.0.2
	MIRBSD_7quater:1.1.1.5
	cvs-200405160640:1.1.1.7
	cvs-200401271800:1.1.1.6
	cvs-200401261630:1.1.1.6
	cvs-200401021645:1.1.1.6
	MIRBSD_7_ALPHA:1.1.1.5.0.6
	MIRBSD_7:1.1.1.5.0.4
	cvs-200312222040:1.1.1.6
	MIRBSD_7ter:1.1.1.5
	MIRBSD_7_DEV:1.1.1.5.0.2
	cvs-200310020700:1.1.1.5
	cvs-200309271030:1.1.1.5
	cvs-200309251530:1.1.1.5
	cvs-200308302005:1.1.1.5
	cvs-200308171200:1.1.1.5
	ctm-3496:1.1.1.5
	ctm-3449:1.1.1.4
	ctm-3437:1.1.1.4
	cvs-200307191805:1.1.1.4
	ctm-3425:1.1.1.4
	cvs-200307091500:1.1.1.4
	ctm-3389:1.1.1.4
	cvs-200306291430:1.1.1.4
	ctm-3341:1.1.1.4
	MIRBSD_5:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.17.48.28;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.48.28;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.21.19.02.36;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.30.59;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.19.12.42.30;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.08.11.18.29.44;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.22.21.10.33;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.16.08.24.07;	author tg;	state Stab;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.26.15.50.27;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: ike_auth.c,v 1.68 2003/03/13 13:24:48 ho Exp $	*/
/*	$EOM: ike_auth.c,v 1.59 2000/11/21 00:21:31 angelos Exp $	*/

/*
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999 Niels Provos.  All rights reserved.
 * Copyright (c) 1999 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 2000, 2001 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <regex.h>
#if defined (USE_KEYNOTE)
#include <keynote.h>
#endif
#include <policy.h>

#include "sysdep.h"

#include "cert.h"
#include "conf.h"
#include "constants.h"
#if defined (USE_DNSSEC)
#include "dnssec.h"
#endif
#include "exchange.h"
#include "gmp_util.h"
#include "hash.h"
#include "ike_auth.h"
#include "ipsec.h"
#include "ipsec_doi.h"
#include "libcrypto.h"
#include "log.h"
#include "message.h"
#include "prf.h"
#include "transport.h"
#include "util.h"
#include "key.h"
#if defined (USE_X509)
#include "x509.h"
#endif

#ifdef notyet
static u_int8_t *enc_gen_skeyid (struct exchange *, size_t *);
#endif
static u_int8_t *pre_shared_gen_skeyid (struct exchange *, size_t *);

static int pre_shared_decode_hash (struct message *);
static int pre_shared_encode_hash (struct message *);

#if defined (USE_X509) || defined (USE_KEYNOTE)
static u_int8_t *sig_gen_skeyid (struct exchange *, size_t *);
static int rsa_sig_decode_hash (struct message *);
static int rsa_sig_encode_hash (struct message *);
#endif

#if defined (USE_RAWKEY)
#define PUBKEY_DIR_DEFAULT "/etc/isakmpd/pubkeys"
static int get_raw_key_from_file (int, u_int8_t *, size_t, RSA **);
#endif

static int ike_auth_hash (struct exchange *, u_int8_t *);

static struct ike_auth ike_auth[] = {
  {
    IKE_AUTH_PRE_SHARED, pre_shared_gen_skeyid, pre_shared_decode_hash,
    pre_shared_encode_hash
  },
#ifdef notdef
  {
    IKE_AUTH_DSS, sig_gen_skeyid, pre_shared_decode_hash,
    pre_shared_encode_hash
  },
#endif
#if defined (USE_X509) || defined (USE_KEYNOTE)
  {
    IKE_AUTH_RSA_SIG, sig_gen_skeyid, rsa_sig_decode_hash,
    rsa_sig_encode_hash
  },
#endif
#ifdef notdef
  {
    IKE_AUTH_RSA_ENC, enc_gen_skeyid, pre_shared_decode_hash,
    pre_shared_encode_hash
  },
  {
    IKE_AUTH_RSA_ENC_REV, enc_gen_skeyid, pre_shared_decode_hash,
    pre_shared_encode_hash
  },
#endif
};

struct ike_auth *
ike_auth_get (u_int16_t id)
{
  int i;

  for (i = 0; i < sizeof ike_auth / sizeof ike_auth[0]; i++)
    if (id == ike_auth[i].id)
      return &ike_auth[i];
  return 0;
}

/*
 * Find and decode the configured key (pre-shared or public) for the
 * peer denoted by ID.  Stash the len in KEYLEN.
 */
static void *
ike_auth_get_key (int type, char *id, char *local_id, size_t *keylen)
{
  char *key, *buf;
#if defined (USE_X509) || defined (USE_KEYNOTE)
  char *keyfile;
#if defined (USE_X509)
  BIO *keyh;
  RSA *rsakey;
#endif
#endif

  switch (type)
    {
    case IKE_AUTH_PRE_SHARED:
      /* Get the pre-shared key for our peer.  */
      key = conf_get_str (id, "Authentication");
      if (!key && local_id)
	key = conf_get_str (local_id, "Authentication");

      if (!key)
        {
	  log_print ("ike_auth_get_key: "
		     "no key found for peer \"%s\" or local ID \"%s\"",
		     id, local_id);
	  return 0;
	}

      /* If the key starts with 0x it is in hex format.  */
      if (strncasecmp (key, "0x", 2) == 0)
	{
	  *keylen = (strlen (key) - 1) / 2;
	  buf = malloc (*keylen);
	  if (!buf)
	    {
	      log_print ("ike_auth_get_key: malloc (%lu) failed",
		(unsigned long)*keylen);
	      return 0;
	    }
	  if (hex2raw (key + 2, (unsigned char *)buf, *keylen))
	    {
	      free (buf);
	      log_print ("ike_auth_get_key: invalid hex key %s", key);
	      return 0;
	    }
	  key = buf;
	}
      else
	*keylen = strlen (key);
      break;

    case IKE_AUTH_RSA_SIG:
#if defined (USE_X509) || defined (USE_KEYNOTE)
#if defined (USE_KEYNOTE)
      if (local_id &&
	  (keyfile = conf_get_str ("KeyNote", "Credential-directory")) != 0)
        {
	  struct stat sb;
	  struct keynote_deckey dc;
	  char *privkeyfile, *buf2;
	  int fd, pkflen;
	  size_t size;

	  pkflen = strlen (keyfile) + strlen (local_id) +
	    sizeof PRIVATE_KEY_FILE + sizeof "//" - 1;
	  privkeyfile = calloc (pkflen, sizeof (char));
	  if (!privkeyfile)
	    {
	      log_print ("ike_auth_get_key: failed to allocate %d bytes",
			 pkflen);
	      return 0;
	    }

	  snprintf (privkeyfile, pkflen, "%s/%s/%s", keyfile, local_id,
		   PRIVATE_KEY_FILE);
	  keyfile = privkeyfile;

	  if (stat (keyfile, &sb) < 0)
	    {
	      free (keyfile);
	      goto ignorekeynote;
	    }
	  size = (size_t)sb.st_size;

	  fd = open (keyfile, O_RDONLY, 0);
	  if (fd < 0)
	    {
	      log_print ("ike_auth_get_key: failed opening \"%s\"", keyfile);
	      free (keyfile);
	      return 0;
	    }

	  buf = calloc (size + 1, sizeof (char));
	  if (!buf)
	    {
	      log_print ("ike_auth_get_key: failed allocating %lu bytes",
			 (unsigned long)size + 1);
	      free (keyfile);
	      return 0;
	    }

	  if (read (fd, buf, size) != size)
	    {
	      free (buf);
	      log_print ("ike_auth_get_key: "
			 "failed reading %lu bytes from \"%s\"",
			(unsigned long)size, keyfile);
	      free (keyfile);
	      return 0;
	    }

	  close (fd);

	  /* Parse private key string */
	  buf2 = kn_get_string (buf);
	  free (buf);

	  if (kn_decode_key (&dc, buf2, KEYNOTE_PRIVATE_KEY) == -1)
	    {
	      free (buf2);
	      log_print ("ike_auth_get_key: failed decoding key in \"%s\"",
			 keyfile);
	      free (keyfile);
	      return 0;
	    }

	  free (buf2);

	  if (dc.dec_algorithm != KEYNOTE_ALGORITHM_RSA)
	    {
	      log_print ("ike_auth_get_key: wrong algorithm type %d in \"%s\"",
			 dc.dec_algorithm, keyfile);
	      free (keyfile);
	      kn_free_key (&dc);
	      return 0;
	    }

	  free (keyfile);
	  return dc.dec_key;
	}

    ignorekeynote:
#endif /* USE_KEYNOTE */
#ifdef USE_X509
      /* Otherwise, try X.509 */
      keyfile = conf_get_str ("X509-certificates", "Private-key");

      if (check_file_secrecy (keyfile, 0))
	return 0;

      keyh = BIO_new (BIO_s_file ());
      if (keyh == NULL)
	{
	  log_print ("ike_auth_get_key: "
		     "BIO_new (BIO_s_file ()) failed");
	  return 0;
	}
      if (BIO_read_filename (keyh, keyfile) == -1)
	{
	  log_print ("ike_auth_get_key: "
		     "BIO_read_filename (keyh, \"%s\") failed",
		     keyfile);
	  BIO_free (keyh);
	  return 0;
	}

#if SSLEAY_VERSION_NUMBER >= 0x00904100L
      rsakey = PEM_read_bio_RSAPrivateKey (keyh, NULL, NULL, NULL);
#else
      rsakey = PEM_read_bio_RSAPrivateKey (keyh, NULL, NULL);
#endif
      BIO_free (keyh);
      if (!rsakey)
	{
	  log_print ("ike_auth_get_key: PEM_read_bio_RSAPrivateKey failed");
	  return 0;
	}

      return rsakey;
#endif
#endif

    default:
      log_print ("ike_auth_get_key: unknown key type %d", type);
      return 0;
    }

  return key;
}

static u_int8_t *
pre_shared_gen_skeyid (struct exchange *exchange, size_t *sz)
{
  struct prf *prf;
  struct ipsec_exch *ie = exchange->data;
  u_int8_t *skeyid;
  u_int8_t *buf = 0;
  unsigned char *key;
  size_t keylen;

  /*
   * If we're the responder and have the initiator's ID (which is the
   * case in Aggressive mode), try to find the preshared key in the
   * section of the initiator's Phase 1 ID.  This allows us to do
   * mobile user support with preshared keys.
   */
  if (!exchange->initiator && exchange->id_i)
    {
      switch (exchange->id_i[0])
        {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR:
	  util_ntoa ((char **)&buf,
		     exchange->id_i[0] == IPSEC_ID_IPV4_ADDR
		     ? AF_INET : AF_INET6,
		     exchange->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
	  if (!buf)
	    return 0;
	  break;

	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
	  buf = calloc (exchange->id_i_len - ISAKMP_ID_DATA_OFF
			+ ISAKMP_GEN_SZ + 1, sizeof (char));
	  if (!buf)
	    {
              log_print ("pre_shared_gen_skeyid: malloc (%lu) failed",
			 (unsigned long)exchange->id_i_len - ISAKMP_ID_DATA_OFF
			 + ISAKMP_GEN_SZ + 1);
	      return 0;
	    }
	  memcpy (buf, exchange->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		  exchange->id_i_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
	  break;

	  /* XXX Support more ID types ? */
	default:
	  break;
	}
    }

  /*
   * Get the pre-shared key for our peer. This will work even if the key
   * has been passed to us through a mechanism like PFKEYv2.
   */
  key = ike_auth_get_key (IKE_AUTH_PRE_SHARED, exchange->name, (char *)buf,
			  &keylen);
  if (buf)
    free (buf);

  /* Fail if no key could be found.  */
  if (!key)
    return 0;

  /* Store the secret key for later policy processing.  */
  exchange->recv_key = calloc (keylen + 1, sizeof (char));
  exchange->recv_keytype = ISAKMP_KEY_PASSPHRASE;
  if (!exchange->recv_key)
    {
      log_error ("pre_shared_gen_skeyid: malloc (%lu) failed",
	(unsigned long)keylen);
      return 0;
    }
  memcpy (exchange->recv_key, key, keylen);
  exchange->recv_certtype = ISAKMP_CERTENC_NONE;

  prf = prf_alloc (ie->prf_type, ie->hash->type, key, keylen);
  if (!prf)
    return 0;

  *sz = prf->blocksize;
  skeyid = malloc (*sz);
  if (!skeyid)
    {
      log_error ("pre_shared_gen_skeyid: malloc (%lu) failed",
	(unsigned long)*sz);
      prf_free (prf);
      return 0;
    }

  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, exchange->nonce_i, exchange->nonce_i_len);
  prf->Update (prf->prfctx, exchange->nonce_r, exchange->nonce_r_len);
  prf->Final (skeyid, prf->prfctx);
  prf_free (prf);

  return skeyid;
}

#if defined (USE_X509) || defined (USE_KEYNOTE)
/* Both DSS & RSA signature authentication use this algorithm.  */
static u_int8_t *
sig_gen_skeyid (struct exchange *exchange, size_t *sz)
{
  struct prf *prf;
  struct ipsec_exch *ie = exchange->data;
  u_int8_t *skeyid;
  unsigned char *key;

  key = malloc (exchange->nonce_i_len + exchange->nonce_r_len);
  if (!key)
    return 0;
  memcpy (key, exchange->nonce_i, exchange->nonce_i_len);
  memcpy (key + exchange->nonce_i_len, exchange->nonce_r,
	  exchange->nonce_r_len);

  LOG_DBG((LOG_NEGOTIATION, 80, "sig_gen_skeyid: PRF type %d, hash %d",
      ie->prf_type, ie->hash->type));
  LOG_DBG_BUF((LOG_NEGOTIATION, 80, "sig_gen_skeyid: SKEYID initialized with",
      (u_int8_t *)key, exchange->nonce_i_len + exchange->nonce_r_len));

  prf = prf_alloc (ie->prf_type, ie->hash->type, key,
		   exchange->nonce_i_len + exchange->nonce_r_len);
  free (key);
  if (!prf)
    return 0;

  *sz = prf->blocksize;
  skeyid = malloc (*sz);
  if (!skeyid)
    {
      log_error ("sig_gen_skeyid: malloc (%lu) failed",
	(unsigned long)*sz);
      prf_free (prf);
      return 0;
    }

  LOG_DBG((LOG_NEGOTIATION, 80, "sig_gen_skeyid: g^xy length %lu",
      (unsigned long)ie->g_x_len));
  LOG_DBG_BUF((LOG_NEGOTIATION, 80,
      "sig_gen_skeyid: SKEYID fed with g^xy", ie->g_xy, ie->g_x_len));

  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, ie->g_xy, ie->g_x_len);
  prf->Final (skeyid, prf->prfctx);
  prf_free (prf);

  return skeyid;
}
#endif /* USE_X509 || USE_KEYNOTE */

#ifdef notdef
/*
 * Both standard and revised RSA encryption authentication use this SKEYID
 * computation.
 */
static u_int8_t *
enc_gen_skeyid (struct exchange *exchange, size_t *sz)
{
  struct prf *prf;
  struct ipsec_exch *ie = exchange->data;
  struct hash *hash = ie->hash;
  u_int8_t *skeyid;

  hash->Init (hash->ctx);
  hash->Update (hash->ctx, exchange->nonce_i, exchange->nonce_i_len);
  hash->Update (hash->ctx, exchange->nonce_r, exchange->nonce_r_len);
  hash->Final (hash->digest, hash->ctx);
  prf = prf_alloc (ie->prf_type, hash->type, hash->digest, *sz);
  if (!prf)
    return 0;

  *sz = prf->blocksize;
  skeyid = malloc (*sz);
  if (!skeyid)
    {
      log_error ("enc_gen_skeyid: malloc (%d) failed", *sz);
      prf_free (prf);
      return 0;
    }

  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, exchange->cookies, ISAKMP_HDR_COOKIES_LEN);
  prf->Final (skeyid, prf->prfctx);
  prf_free (prf);

  return skeyid;
}
#endif /* notdef */

static int
pre_shared_decode_hash (struct message *msg)
{
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct payload *payload;
  size_t hashsize = ie->hash->hashsize;
  char header[80];
  int initiator = exchange->initiator;
  u_int8_t **hash_p;

  /* Choose the right fields to fill-in.  */
  hash_p = initiator ? &ie->hash_r : &ie->hash_i;

  payload = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH]);
  if (!payload)
    {
      log_print ("pre_shared_decode_hash: no HASH payload found");
      return -1;
    }

  /* Check that the hash is of the correct size.  */
  if (GET_ISAKMP_GEN_LENGTH (payload->p) - ISAKMP_GEN_SZ != hashsize)
    return -1;

  /* XXX Need this hash be in the SA?  */
  *hash_p = malloc (hashsize);
  if (!*hash_p)
    {
      log_error ("pre_shared_decode_hash: malloc (%lu) failed",
	(unsigned long)hashsize);
      return -1;
    }

  memcpy (*hash_p, payload->p + ISAKMP_HASH_DATA_OFF, hashsize);
  snprintf (header, 80, "pre_shared_decode_hash: HASH_%c",
	    initiator ? 'R' : 'I');
  LOG_DBG_BUF ((LOG_MISC, 80, header, *hash_p, hashsize));

  payload->flags |= PL_MARK;

  return 0;
}

#if defined (USE_X509) || defined (USE_KEYNOTE)
/* Decrypt the HASH in SIG, we already need a parsed ID payload.  */
static int
rsa_sig_decode_hash (struct message *msg)
{
  struct cert_handler *handler;
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct payload *p;
  void *cert = 0;
  u_int8_t *rawcert = 0;
  u_int32_t rawcertlen;
  RSA *key = 0;
  size_t hashsize = ie->hash->hashsize;
  char header[80];
  int len;
  int initiator = exchange->initiator;
  u_int8_t **hash_p, **id_cert, *id;
  u_int32_t *id_cert_len;
  size_t id_len;
  int found = 0, n, i, id_found;
#if defined (USE_DNSSEC)
  u_int8_t *rawkey = 0;
  u_int32_t rawkeylen;
#endif

  /* Choose the right fields to fill-in.  */
  hash_p = initiator ? &ie->hash_r : &ie->hash_i;
  id = initiator ? exchange->id_r : exchange->id_i;
  id_len = initiator ? exchange->id_r_len : exchange->id_i_len;

  if (!id || id_len == 0)
    {
      log_print ("rsa_sig_decode_hash: ID is missing");
      return -1;
    }

  /*
   * XXX Assume we should use the same kind of certification as the remote...
   * moreover, just use the first CERT payload to decide what to use.
   */
  p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_CERT]);
  if (!p)
    handler = cert_get (ISAKMP_CERTENC_KEYNOTE);
  else
    handler = cert_get (GET_ISAKMP_CERT_ENCODING (p->p));
  if (!handler)
    {
      log_print ("rsa_sig_decode_hash: cert_get (%d) failed",
		 p ? GET_ISAKMP_CERT_ENCODING (p->p) : -1);
      return -1;
    }

#if defined (USE_POLICY) || defined (USE_KEYNOTE)
  /*
   * We need the policy session initialized now, so we can add
   * credentials etc.
   */
  exchange->policy_id = kn_init ();
  if (exchange->policy_id == -1)
    {
      log_print ("rsa_sig_decode_hash: failed to initialize policy session");
      return -1;
    }
#endif /* USE_POLICY || USE_KEYNOTE */

  /* Obtain a certificate from our certificate storage.  */
  if (handler->cert_obtain (id, id_len, 0, &rawcert, &rawcertlen))
    {
      if (handler->id == ISAKMP_CERTENC_X509_SIG)
        {
	  cert = handler->cert_get (rawcert, rawcertlen);
	  if (!cert)
	    LOG_DBG ((LOG_CRYPTO, 50,
		      "rsa_sig_decode_hash: certificate malformed"));
	  else
	    {
	      if (!handler->cert_get_key (cert, &key))
	        {
		  log_print ("rsa_sig_decode_hash: "
			     "decoding certificate failed");
		  handler->cert_free (cert);
		}
	      else
	        {
		  found++;
		  LOG_DBG ((LOG_CRYPTO, 40,
			    "rsa_sig_decode_hash: using cert of type %d",
			    handler->id));
		  exchange->recv_cert = cert;
		  exchange->recv_certtype = handler->id;
#if defined (USE_POLICY)
		  x509_generate_kn (exchange->policy_id, cert);
#endif /* USE_POLICY */
		}
	    }
	}
      else if (handler->id == ISAKMP_CERTENC_KEYNOTE)
	handler->cert_insert (exchange->policy_id, rawcert);
      free (rawcert);
    }

  /*
   * Walk over potential CERT payloads in this message.
   * XXX I believe this is the wrong spot for this.  CERTs can appear
   * anytime.
   */
  for (p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_CERT]); p;
       p = TAILQ_NEXT (p, link))
    {
      p->flags |= PL_MARK;

      /* When we have found a key, just walk over the rest, marking them.  */
      if (found)
	continue;

      handler = cert_get (GET_ISAKMP_CERT_ENCODING (p->p));
      if (!handler)
	{
	  LOG_DBG ((LOG_MISC, 30,
		    "rsa_sig_decode_hash: no handler for %s CERT encoding",
		    constant_lookup (isakmp_certenc_cst,
				     GET_ISAKMP_CERT_ENCODING (p->p))));
	  continue;
	}

      cert = handler->cert_get (p->p + ISAKMP_CERT_DATA_OFF,
				GET_ISAKMP_GEN_LENGTH (p->p)
				- ISAKMP_CERT_DATA_OFF);
      if (!cert)
	{
	  log_print ("rsa_sig_decode_hash: can not get data from CERT");
	  continue;
	}

      if (!handler->cert_validate (cert))
	{
	  handler->cert_free (cert);
	  log_print ("rsa_sig_decode_hash: received CERT can't be validated");
	  continue;
	}

      if (GET_ISAKMP_CERT_ENCODING (p->p) == ISAKMP_CERTENC_X509_SIG)
        {
	  if (!handler->cert_get_subjects (cert, &n, &id_cert, &id_cert_len))
	    {
	      handler->cert_free (cert);
	      log_print ("rsa_sig_decode_hash: can not get subject from CERT");
	      continue;
	    }

	  id_found = 0;
	  for (i = 0; i < n; i++)
 	    if (id_cert_len[i] == id_len
		&& id[0] == id_cert[i][0]
		&& memcmp (id + 4, id_cert[i] + 4, id_len - 4) == 0)
	      {
		id_found++;
		break;
	      }
	  if (!id_found)
	    {
	      handler->cert_free (cert);
	      log_print ("rsa_sig_decode_hash: no CERT subject match the ID");
	      free (id_cert);
	      continue;
	    }

	  cert_free_subjects (n, id_cert, id_cert_len);
	}

      if (!handler->cert_get_key (cert, &key))
	{
	  handler->cert_free (cert);
	  log_print ("rsa_sig_decode_hash: decoding payload CERT failed");
	  continue;
	}

      /* We validated the cert, cache it for later use.  */
      handler->cert_insert (exchange->policy_id, cert);

      exchange->recv_cert = cert;
      exchange->recv_certtype = GET_ISAKMP_CERT_ENCODING (p->p);

#if defined (USE_POLICY) || defined (USE_KEYNOTE)
      if (exchange->recv_certtype == ISAKMP_CERTENC_KEYNOTE)
        {
	  struct keynote_deckey dc;
	  char *pp;
	  int dclen;

	  dc.dec_algorithm = KEYNOTE_ALGORITHM_RSA;
	  dc.dec_key = key;

	  pp = kn_encode_key (&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
			      KEYNOTE_PUBLIC_KEY);
	  if (pp == NULL)
	    {
	      kn_free_key (&dc);
	      log_print ("rsa_sig_decode_hash: failed to ASCII-encode key");
	      return -1;
	    }

	  dclen = strlen (pp) + sizeof "rsa-hex:";
	  exchange->keynote_key = calloc (dclen, sizeof (char));
	  if (!exchange->keynote_key)
	    {
	      free (pp);
	      kn_free_key (&dc);
	      log_print ("rsa_sig_decode_hash: failed to allocate %d bytes",
			 dclen);
	      return -1;
	    }

	  snprintf (exchange->keynote_key, dclen, "rsa-hex:%s", pp);
	  free (pp);
	}
#endif

      found++;
    }

#if defined (USE_DNSSEC)
  /* If no certificate provided a key, try to find a validated DNSSEC KEY.  */
  if (!found)
    {
      rawkey = dns_get_key (IKE_AUTH_RSA_SIG, msg, &rawkeylen);

      /* We need to convert 'void *rawkey' into 'RSA *key'.  */
      if (dns_RSA_dns_to_x509 (rawkey, rawkeylen, &key) == 0)
	found++;
      else
	log_print ("rsa_sig_decode_hash: KEY to RSA key conversion failed");

      if (rawkey)
	free (rawkey);
    }
#endif /* USE_DNSSEC */

#if defined (USE_RAWKEY)
  /* If we still have not found a key, try to read it from a file. */
  if (!found)
    if (get_raw_key_from_file (IKE_AUTH_RSA_SIG, id, id_len, &key) != -1)
      found++;
#endif

  if (!found)
    {
      log_print ("rsa_sig_decode_hash: no public key found");
      return -1;
    }

  p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_SIG]);
  if (!p)
    {
      log_print ("rsa_sig_decode_hash: missing signature payload");
      RSA_free (key);
      return -1;
    }

  /* Check that the sig is of the correct size.  */
  len = GET_ISAKMP_GEN_LENGTH (p->p) - ISAKMP_SIG_SZ;
  if (len != RSA_size (key))
    {
      RSA_free (key);
      log_print ("rsa_sig_decode_hash: "
		 "SIG payload length does not match public key");
      return -1;
    }

  *hash_p = malloc (len);
  if (!*hash_p)
    {
      RSA_free (key);
      log_error ("rsa_sig_decode_hash: malloc (%d) failed", len);
      return -1;
    }

  len = RSA_public_decrypt (len, p->p + ISAKMP_SIG_DATA_OFF, *hash_p, key,
			    RSA_PKCS1_PADDING);
  if (len == -1)
    {
      RSA_free (key);
      log_print ("rsa_sig_decode_hash: RSA_public_decrypt () failed");
      return -1;
    }

  /* Store key for later use */
  exchange->recv_key = key;
  exchange->recv_keytype = ISAKMP_KEY_RSA;

  if (len != hashsize)
    {
      free (*hash_p);
      *hash_p = 0;
      log_print ("rsa_sig_decode_hash: len %lu != hashsize %lu",
	(unsigned long)len, (unsigned long)hashsize);
      return -1;
    }

  snprintf (header, 80, "rsa_sig_decode_hash: HASH_%c", initiator ? 'R' : 'I');
  LOG_DBG_BUF ((LOG_MISC, 80, header, *hash_p, hashsize));

  p->flags |= PL_MARK;

  return 0;
}
#endif /* USE_X509 || USE_KEYNOTE */

static int
pre_shared_encode_hash (struct message *msg)
{
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  size_t hashsize = ie->hash->hashsize;
  char header[80];
  int initiator = exchange->initiator;
  u_int8_t *buf;

  buf = ipsec_add_hash_payload (msg, hashsize);
  if (!buf)
    return -1;

  if (ike_auth_hash (exchange, buf + ISAKMP_HASH_DATA_OFF) == -1)
    return -1;

  snprintf (header, 80, "pre_shared_encode_hash: HASH_%c",
	    initiator ? 'I' : 'R');
  LOG_DBG_BUF ((LOG_MISC, 80, header, buf + ISAKMP_HASH_DATA_OFF, hashsize));
  return 0;
}

#if defined (USE_X509) || defined (USE_KEYNOTE)
/* Encrypt the HASH into a SIG type.  */
static int
rsa_sig_encode_hash (struct message *msg)
{
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  size_t hashsize = ie->hash->hashsize;
  struct cert_handler *handler;
  char header[80];
  int initiator = exchange->initiator;
  u_int8_t *buf, *data, *buf2;
  u_int32_t datalen;
  u_int8_t *id;
  size_t id_len;
  int idtype;

  id = initiator ? exchange->id_i : exchange->id_r;
  id_len = initiator ? exchange->id_i_len : exchange->id_r_len;

  /* We may have been provided these by the kernel */
  buf = (u_int8_t *)conf_get_str (exchange->name, "Credentials");
  if (buf
      && (idtype = conf_get_num (exchange->name, "Credential_Type", -1) != -1))
    {
      exchange->sent_certtype = idtype;
      handler = cert_get (idtype);
      if (!handler)
	{
	  log_print ("rsa_sig_encode_hash: cert_get (%d) failed", idtype);
	  return -1;
	}

      exchange->sent_cert = handler->cert_from_printable ((char *)buf);
      if (!exchange->sent_cert)
	{
	  log_print ("rsa_sig_encode_hash: failed to retrieve certificate");
	  return -1;
	}

      handler->cert_serialize (exchange->sent_cert, &data, &datalen);
      if (!data)
	{
	  log_print ("rsa_sig_encode_hash: cert serialization failed");
	  return -1;
	}

      goto aftercert; /* Skip all the certificate discovery */
    }

  /* XXX This needs to be configurable.  */
  idtype = ISAKMP_CERTENC_KEYNOTE;

  /* Find a certificate with subjectAltName = id.  */
  handler = cert_get (idtype);
  if (!handler)
    {
      idtype = ISAKMP_CERTENC_X509_SIG;
      handler = cert_get (idtype);
      if (!handler)
	{
	  log_print ("rsa_sig_encode_hash: cert_get(%d) failed", idtype);
	  return -1;
	}
    }

  if (handler->cert_obtain (id, id_len, 0, &data, &datalen) == 0)
    {
      if (idtype == ISAKMP_CERTENC_KEYNOTE)
	{
	  idtype = ISAKMP_CERTENC_X509_SIG;
	  handler = cert_get (idtype);
	  if (!handler)
	    {
	      log_print ("rsa_sig_encode_hash: cert_get(%d) failed", idtype);
	      return -1;
	    }

	  if (handler->cert_obtain (id, id_len, 0, &data, &datalen) == 0)
	    {
	      LOG_DBG ((LOG_MISC, 10,
			"rsa_sig_encode_hash: no certificate to send"));
	      goto skipcert;
	    }
	}
      else
	{
	  LOG_DBG ((LOG_MISC, 10,
		    "rsa_sig_encode_hash: no certificate to send"));
	  goto skipcert;
	}
    }

  /* Let's store the certificate we are going to use */
  exchange->sent_certtype = idtype;
  exchange->sent_cert = handler->cert_get (data, datalen);
  if (!exchange->sent_cert)
    {
      free (data);
      log_print ("rsa_sig_encode_hash: failed to get certificate from wire "
		 "encoding");
      return -1;
    }

 aftercert:

  buf = realloc (data, ISAKMP_CERT_SZ + datalen);
  if (!buf)
    {
      log_error ("rsa_sig_encode_hash: realloc (%p, %d) failed", data,
		 ISAKMP_CERT_SZ + datalen);
      free (data);
      return -1;
    }
  memmove (buf + ISAKMP_CERT_SZ, buf, datalen);
  SET_ISAKMP_CERT_ENCODING (buf, idtype);
  if (message_add_payload (msg, ISAKMP_PAYLOAD_CERT, buf,
			   ISAKMP_CERT_SZ + datalen, 1))
    {
      free (buf);
      return -1;
    }

 skipcert:

  switch (id[ISAKMP_ID_TYPE_OFF - ISAKMP_GEN_SZ])
    {
    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV6_ADDR:
      util_ntoa ((char **)&buf2,
		 id[ISAKMP_ID_TYPE_OFF - ISAKMP_GEN_SZ] == IPSEC_ID_IPV4_ADDR
		 ? AF_INET : AF_INET6,
		 id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
      if (!buf2)
	return 0;
      break;

    case IPSEC_ID_FQDN:
    case IPSEC_ID_USER_FQDN:
      buf2 = calloc (id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
		     sizeof (char));
      if (!buf2)
        {
	  log_print ("rsa_sig_encode_hash: malloc (%lu) failed",
		     (unsigned long)id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1);
	  return 0;
	}
      memcpy (buf2, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
	      id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
      break;

      /* XXX Support more ID types?  */
    default:
      buf2 = 0;
      break;
    }

  /* Again, we may have these from the kernel */
  buf = (u_int8_t *)conf_get_str (exchange->name, "OKAuthentication");
  if (buf)
    {
      key_from_printable (ISAKMP_KEY_RSA, ISAKMP_KEYTYPE_PRIVATE, (char *)buf,
			  &data, &datalen);
      if (!data || datalen == -1)
	{
	  log_print ("rsa_sig_encode_hash: badly formatted RSA private key");
	  return 0;
	}

      exchange->sent_keytype = ISAKMP_KEY_RSA;
      exchange->sent_key = key_internalize (ISAKMP_KEY_RSA,
					    ISAKMP_KEYTYPE_PRIVATE, data,
					    datalen);
      if (!exchange->sent_key)
	{
	  log_print ("rsa_sig_encode_hash: bad RSA private key from dynamic "
		     "SA acquisition subsystem");
	  return 0;
	}
    }
  else /* Try through the regular means.  */
    {
      exchange->sent_key = ike_auth_get_key (IKE_AUTH_RSA_SIG, exchange->name,
					     (char *)buf2, 0);
      free (buf2);

      /* Did we find a key?  */
      if (!exchange->sent_key)
	{
	  log_print ("rsa_sig_encode_hash: could not get private key");
	  return -1;
	}

      exchange->sent_keytype = ISAKMP_KEY_RSA;
    }

  /* Enable RSA blinding.  */
  if (RSA_blinding_on (exchange->sent_key, NULL) != 1)
    {
      log_error ("rsa_sig_encode_hash: RSA_blinding_on () failed.");
      return -1;
    }

  /* XXX hashsize is not necessarily prf->blocksize.  */
  buf = malloc (hashsize);
  if (!buf)
    {
      log_error ("rsa_sig_encode_hash: malloc (%lu) failed",
	(unsigned long)hashsize);
      return -1;
    }

  if (ike_auth_hash (exchange, buf) == -1)
    {
      free (buf);
      return -1;
    }

  snprintf (header, 80, "rsa_sig_encode_hash: HASH_%c", initiator ? 'I' : 'R');
  LOG_DBG_BUF ((LOG_MISC, 80, header, buf, hashsize));

  data = malloc (RSA_size (exchange->sent_key));
  if (!data)
    {
      log_error ("rsa_sig_encode_hash: malloc (%d) failed",
		 RSA_size (exchange->sent_key));
      return -1;
    }

  datalen = RSA_private_encrypt (hashsize, buf, data, exchange->sent_key,
				 RSA_PKCS1_PADDING);
  if (datalen == -1)
    {
      log_print ("rsa_sig_encode_hash: RSA_private_encrypt () failed");
      free (buf);
      return -1;
    }

  free (buf);

  buf = realloc (data, ISAKMP_SIG_SZ + datalen);
  if (!buf)
    {
      log_error ("rsa_sig_encode_hash: realloc (%p, %d) failed", data,
		 ISAKMP_SIG_SZ + datalen);
      free (data);
      return -1;
    }
  memmove (buf + ISAKMP_SIG_SZ, buf, datalen);

  snprintf (header, 80, "rsa_sig_encode_hash: SIG_%c", initiator ? 'I' : 'R');
  LOG_DBG_BUF ((LOG_MISC, 80, header, buf + ISAKMP_SIG_DATA_OFF, datalen));
  if (message_add_payload (msg, ISAKMP_PAYLOAD_SIG, buf,
			   ISAKMP_SIG_SZ + datalen, 1))
    {
      free (buf);
      return -1;
    }
  return 0;
}
#endif /* USE_X509 || USE_KEYNOTE */

int
ike_auth_hash (struct exchange *exchange, u_int8_t *buf)
{
  struct ipsec_exch *ie = exchange->data;
  struct prf *prf;
  struct hash *hash = ie->hash;
  int initiator = exchange->initiator;
  u_int8_t *id;
  size_t id_len;

  /* Choose the right fields to fill-in.  */
  id = initiator ? exchange->id_i : exchange->id_r;
  id_len = initiator ? exchange->id_i_len : exchange->id_r_len;

  /* Allocate the prf and start calculating our HASH.  */
  prf = prf_alloc (ie->prf_type, hash->type, ie->skeyid, ie->skeyid_len);
  if (!prf)
    return -1;

  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, initiator ? ie->g_xi : ie->g_xr, ie->g_x_len);
  prf->Update (prf->prfctx, initiator ? ie->g_xr : ie->g_xi, ie->g_x_len);
  prf->Update (prf->prfctx,
	       exchange->cookies
	       + (initiator ? ISAKMP_HDR_ICOOKIE_OFF : ISAKMP_HDR_RCOOKIE_OFF),
	       ISAKMP_HDR_ICOOKIE_LEN);
  prf->Update (prf->prfctx,
	       exchange->cookies
	       + (initiator ? ISAKMP_HDR_RCOOKIE_OFF : ISAKMP_HDR_ICOOKIE_OFF),
	       ISAKMP_HDR_ICOOKIE_LEN);
  prf->Update (prf->prfctx, ie->sa_i_b, ie->sa_i_b_len);
  prf->Update (prf->prfctx, id, id_len);
  prf->Final (buf, prf->prfctx);
  prf_free (prf);

  return 0;
}

#if defined (USE_RAWKEY)
static int
get_raw_key_from_file (int type, u_int8_t *id, size_t id_len, RSA **rsa)
{
  char filename[FILENAME_MAX];
  char *fstr;
  struct stat st;
  BIO *bio;

  if (type != IKE_AUTH_RSA_SIG) /* XXX More types? */
    {
      LOG_DBG ((LOG_NEGOTIATION, 20, "get_raw_key_from_file: "
		"invalid auth type %d\n", type));
      return -1;
    }

  *rsa = 0;

  fstr = conf_get_str ("General", "Pubkey-directory");
  if (!fstr)
    fstr = PUBKEY_DIR_DEFAULT;

  if (snprintf (filename, sizeof filename, "%s/", fstr) > sizeof filename - 1)
    return -1;

  fstr = ipsec_id_string (id, id_len);
  if (!fstr)
    {
      LOG_DBG ((LOG_NEGOTIATION, 50, "get_raw_key_from_file: "
		"ipsec_id_string failed"));
      return -1;
    }
  strlcat (filename, fstr, sizeof filename - strlen (filename));
  free (fstr);

  /* If the file does not exist, fail silently.  */
  if (stat (filename, &st) == 0)
    {
      bio = BIO_new (BIO_s_file ());
      if (!bio)
	{
	  log_error ("get_raw_key_from_file: could not initialize BIO");
	  return -1;
	}
      if (BIO_read_filename (bio, filename) <= 0)
	{
	  LOG_DBG((LOG_NEGOTIATION, 50, "get_raw_key_from_file: "
		   "BIO_read_filename(bio, \"%s\") failed", filename));
	  BIO_free (bio);
	  return -1;
	}
      LOG_DBG((LOG_NEGOTIATION, 80, "get_raw_key_from_file: reading file %s",
	       filename));
      *rsa = PEM_read_bio_RSA_PUBKEY (bio, NULL, NULL, NULL);
      BIO_free (bio);
    }
  else
    LOG_DBG((LOG_NEGOTIATION, 50, "get_raw_key_from_file: file %s not found",
	     filename));

  return (*rsa ? 0 : -1);
}
#endif /* USE_RAWKEY */
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.74 2003/05/18 19:37:46 ho Exp $	*/
a70 1
#include "monitor.h"
d94 1
a152 1
  size_t fsize;
d291 1
a291 1
      if (check_file_secrecy (keyfile, &fsize))
d323 2
a324 2
#endif /* USE_X509 */
#endif /* USE_X509 || USE_KEYNOTE */
a915 1
  void *sent_key;
d1025 32
d1058 1
a1058 1
  buf = (u_int8_t *)conf_get_str (exchange->name, "PKAuthentication");
d1069 5
a1073 3
      sent_key = key_internalize (ISAKMP_KEY_RSA, ISAKMP_KEYTYPE_PRIVATE, data,
				  datalen);
      if (!sent_key)
a1078 7
#if defined (USE_PRIVSEP)
      {
	/* With USE_PRIVSEP, the sent_key should be a key number. */
	void *key = sent_key;
	sent_key = monitor_RSA_upload_key (key);
      }
#endif
d1082 2
a1083 38
      switch (id[ISAKMP_ID_TYPE_OFF - ISAKMP_GEN_SZ])
	{
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR:
	  util_ntoa ((char **)&buf2,
		     id[ISAKMP_ID_TYPE_OFF - ISAKMP_GEN_SZ] == IPSEC_ID_IPV4_ADDR
		     ? AF_INET : AF_INET6,
		     id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
	  if (!buf2)
	    return 0;
	  break;

	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
	  buf2 = calloc (id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
			 sizeof (char));
	  if (!buf2)
	    {
	      log_print ("rsa_sig_encode_hash: malloc (%lu) failed",
			 (unsigned long)id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1);
	      return 0;
	    }
	  memcpy (buf2, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		  id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
	  break;

	  /* XXX Support more ID types?  */
	default:
	  buf2 = 0;
	  return 0;
	}

#if defined (USE_PRIVSEP)
      sent_key = monitor_RSA_get_private_key (exchange->name, (char *)buf2);
#else
      sent_key = ike_auth_get_key (IKE_AUTH_RSA_SIG, exchange->name,
				   (char *)buf2, 0);
#endif
d1087 1
a1087 1
      if (!sent_key)
d1092 2
a1095 1
#if !defined (USE_PRIVSEP)
d1097 1
a1097 1
  if (RSA_blinding_on (sent_key, NULL) != 1)
a1101 1
#endif
d1121 1
a1121 2
#if !defined (USE_PRIVSEP)
  data = malloc (RSA_size (sent_key));
d1125 1
a1125 1
		 RSA_size (sent_key));
d1129 1
a1129 1
  datalen = RSA_private_encrypt (hashsize, buf, data, sent_key,
a1130 4
#else
  datalen = monitor_RSA_private_encrypt (hashsize, buf, &data, sent_key,
					 RSA_PKCS1_PADDING);
#endif /* USE_PRIVSEP */
a1133 2
      if (data)
	free (data);
a1134 1
      monitor_RSA_free (sent_key);
d1220 1
a1220 1
    fstr = CONF_DFLT_PUBKEY_DIR;
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.77 2003/06/04 07:31:16 ho Exp $	*/
d8 1
a8 1
 * Copyright (c) 2000, 2001, 2003 Håkan Olsson.  All rights reserved.
d18 5
d560 1
a560 1
  snprintf (header, sizeof header, "pre_shared_decode_hash: HASH_%c",
d869 1
a869 2
  snprintf (header, sizeof header, "rsa_sig_decode_hash: HASH_%c",
	    initiator ? 'R' : 'I');
d895 1
a895 1
  snprintf (header, sizeof header, "pre_shared_encode_hash: HASH_%c",
d1129 1
a1129 2
  snprintf (header, sizeof header, "rsa_sig_encode_hash: HASH_%c",
	    initiator ? 'I' : 'R');
d1169 1
a1169 2
  snprintf (header, sizeof header, "rsa_sig_encode_hash: SIG_%c",
	    initiator ? 'I' : 'R');
@


1.1.1.4
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.78 2003/06/10 16:41:29 deraadt Exp $	*/
d717 1
a717 1
	    if (id_cert_len[i] == id_len
@


1.1.1.5
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.79 2003/08/08 08:46:59 ho Exp $	*/
a584 1
  char *tag;
a682 2
	  tag = constant_lookup (isakmp_certenc_cst,
				 GET_ISAKMP_CERT_ENCODING (p->p));
d685 2
a686 1
		    tag ? tag : "<unknown>"));
@


1.1.1.6
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.81 2003/11/06 16:12:07 ho Exp $	*/
d446 4
a449 5
  LOG_DBG ((LOG_NEGOTIATION, 80, "sig_gen_skeyid: PRF type %d, hash %d",
	    ie->prf_type, ie->hash->type));
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, "sig_gen_skeyid: SKEYID initialized with",
		(u_int8_t *)key,
		exchange->nonce_i_len + exchange->nonce_r_len));
d467 4
a470 4
  LOG_DBG ((LOG_NEGOTIATION, 80, "sig_gen_skeyid: g^xy length %lu",
	    (unsigned long)ie->g_x_len));
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, "sig_gen_skeyid: SKEYID fed with g^xy",
		ie->g_xy, ie->g_x_len));
d585 1
d684 2
d688 1
a688 2
		    constant_name (isakmp_certenc_cst,
				   GET_ISAKMP_CERT_ENCODING (p->p))));
d1265 2
a1266 2
	  LOG_DBG ((LOG_NEGOTIATION, 50, "get_raw_key_from_file: "
		    "BIO_read_filename(bio, \"%s\") failed", filename));
d1270 2
a1271 2
      LOG_DBG ((LOG_NEGOTIATION, 80, "get_raw_key_from_file: reading file %s",
		filename));
d1276 2
a1277 2
    LOG_DBG ((LOG_NEGOTIATION, 50, "get_raw_key_from_file: file %s not found",
	      filename));
@


1.1.1.7
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 2
a2 2
/* $OpenBSD: ike_auth.c,v 1.86 2004/04/15 18:39:25 deraadt Exp $	 */
/* $EOM: ike_auth.c,v 1.59 2000/11/21 00:21:31 angelos Exp $	 */
d76 1
a76 1
static u_int8_t *enc_gen_skeyid(struct exchange *, size_t *);
d78 1
a78 1
static u_int8_t *pre_shared_gen_skeyid(struct exchange *, size_t *);
d80 2
a81 2
static int      pre_shared_decode_hash(struct message *);
static int      pre_shared_encode_hash(struct message *);
d84 3
a86 3
static u_int8_t *sig_gen_skeyid(struct exchange *, size_t *);
static int      rsa_sig_decode_hash(struct message *);
static int      rsa_sig_encode_hash(struct message *);
d90 1
a90 1
static int      get_raw_key_from_file(int, u_int8_t *, size_t, RSA **);
d93 1
a93 1
static int      ike_auth_hash(struct exchange *, u_int8_t *);
d96 4
a99 4
	{
		IKE_AUTH_PRE_SHARED, pre_shared_gen_skeyid, pre_shared_decode_hash,
		pre_shared_encode_hash
	},
d101 4
a104 4
	{
		IKE_AUTH_DSS, sig_gen_skeyid, pre_shared_decode_hash,
		pre_shared_encode_hash
	},
d107 4
a110 4
	{
		IKE_AUTH_RSA_SIG, sig_gen_skeyid, rsa_sig_decode_hash,
		rsa_sig_encode_hash
	},
d113 8
a120 8
	{
		IKE_AUTH_RSA_ENC, enc_gen_skeyid, pre_shared_decode_hash,
		pre_shared_encode_hash
	},
	{
		IKE_AUTH_RSA_ENC_REV, enc_gen_skeyid, pre_shared_decode_hash,
		pre_shared_encode_hash
	},
d125 1
a125 1
ike_auth_get(u_int16_t id)
d127 1
a127 1
	size_t	i;
d129 4
a132 4
	for (i = 0; i < sizeof ike_auth / sizeof ike_auth[0]; i++)
		if (id == ike_auth[i].id)
			return &ike_auth[i];
	return 0;
d140 1
a140 1
ike_auth_get_key(int type, char *id, char *local_id, size_t *keylen)
d142 1
a142 1
	char           *key, *buf;
d144 1
a144 1
	char           *keyfile;
d146 3
a148 7
#if defined (USE_PRIVSEP)
	FILE           *keyfp;
#else
	BIO            *keyh;
#endif
	RSA            *rsakey;
	size_t          fsize;
d152 38
a189 39
	switch (type) {
	case IKE_AUTH_PRE_SHARED:
		/* Get the pre-shared key for our peer.  */
		key = conf_get_str(id, "Authentication");
		if (!key && local_id)
			key = conf_get_str(local_id, "Authentication");

		if (!key) {
			log_print("ike_auth_get_key: "
			    "no key found for peer \"%s\" or local ID \"%s\"",
			    id, local_id);
			return 0;
		}
		/* If the key starts with 0x it is in hex format.  */
		if (strncasecmp(key, "0x", 2) == 0) {
			*keylen = (strlen(key) - 1) / 2;
			buf = malloc(*keylen);
			if (!buf) {
				log_error("ike_auth_get_key: malloc (%lu) failed",
				    (unsigned long) *keylen);
				return 0;
			}
			if (hex2raw(key + 2, (unsigned char *) buf, *keylen)) {
				free(buf);
				log_print("ike_auth_get_key: invalid hex key %s",
				    key);
				return 0;
			}
			key = buf;
		} else {
			buf = key;
			key = strdup(buf);
			if (!key) {
				log_error("ike_auth_get_key: strdup() failed");
				return 0;
			}
			*keylen = strlen(key);
		}
		break;
d191 1
a191 1
	case IKE_AUTH_RSA_SIG:
d194 89
a282 75
		if (local_id &&
		    (keyfile = conf_get_str("KeyNote", "Credential-directory")) != 0) {
			struct stat     sb;
			struct keynote_deckey dc;
			char           *privkeyfile, *buf2;
			int             fd, pkflen;
			size_t          size;

			pkflen = strlen(keyfile) + strlen(local_id) +
			    sizeof PRIVATE_KEY_FILE + sizeof "//" - 1;
			privkeyfile = calloc(pkflen, sizeof(char));
			if (!privkeyfile) {
				log_print("ike_auth_get_key: failed to allocate %d bytes",
				    pkflen);
				return 0;
			}
			snprintf(privkeyfile, pkflen, "%s/%s/%s", keyfile, local_id,
				 PRIVATE_KEY_FILE);
			keyfile = privkeyfile;

			if (monitor_stat(keyfile, &sb) < 0) {
				free(keyfile);
				goto ignorekeynote;
			}
			size = (size_t) sb.st_size;

			fd = monitor_open(keyfile, O_RDONLY, 0);
			if (fd < 0) {
				log_print("ike_auth_get_key: failed opening \"%s\"",
				    keyfile);
				free(keyfile);
				return 0;
			}
			buf = calloc(size + 1, sizeof(char));
			if (!buf) {
				log_print("ike_auth_get_key: failed allocating %lu bytes",
				    (unsigned long) size + 1);
				free(keyfile);
				return 0;
			}
			if (read(fd, buf, size) != (ssize_t) size) {
				free(buf);
				log_print("ike_auth_get_key: "
				    "failed reading %lu bytes from \"%s\"",
				    (unsigned long) size, keyfile);
				free(keyfile);
				return 0;
			}
			close(fd);

			/* Parse private key string */
			buf2 = kn_get_string(buf);
			free(buf);

			if (kn_decode_key(&dc, buf2, KEYNOTE_PRIVATE_KEY) == -1) {
				free(buf2);
				log_print("ike_auth_get_key: failed decoding key in \"%s\"",
				    keyfile);
				free(keyfile);
				return 0;
			}
			free(buf2);

			if (dc.dec_algorithm != KEYNOTE_ALGORITHM_RSA) {
				log_print("ike_auth_get_key: wrong algorithm type %d in \"%s\"",
				    dc.dec_algorithm, keyfile);
				free(keyfile);
				kn_free_key(&dc);
				return 0;
			}
			free(keyfile);
			return dc.dec_key;
		}
ignorekeynote:
#endif				/* USE_KEYNOTE */
d284 2
a285 2
		/* Otherwise, try X.509 */
		keyfile = conf_get_str("X509-certificates", "Private-key");
d287 18
a304 2
		if (check_file_secrecy(keyfile, &fsize))
			return 0;
a305 6
#if defined (USE_PRIVSEP)
		keyfp = monitor_fopen(keyfile, "r");
		if (!keyfp) {
			log_print("ike_auth_get_key: failed opening \"%s\"", keyfile);
			return 0;
		}
d307 1
a307 1
		rsakey = PEM_read_RSAPrivateKey(keyfp, NULL, NULL, NULL);
d309 1
a309 1
		rsakey = PEM_read_RSAPrivateKey(keyfp, NULL, NULL);
d311 6
a316 22
		fclose(keyfp);
#else
		keyh = BIO_new(BIO_s_file());
		if (keyh == NULL) {
			log_print("ike_auth_get_key: "
			    "BIO_new (BIO_s_file ()) failed");
			return 0;
		}
		if (BIO_read_filename(keyh, keyfile) == -1) {
			log_print("ike_auth_get_key: "
			    "BIO_read_filename (keyh, \"%s\") failed",
			    keyfile);
			BIO_free(keyh);
			return 0;
		}
#if SSLEAY_VERSION_NUMBER >= 0x00904100L
		rsakey = PEM_read_bio_RSAPrivateKey(keyh, NULL, NULL, NULL);
#else
		rsakey = PEM_read_bio_RSAPrivateKey(keyh, NULL, NULL);
#endif
		BIO_free(keyh);
#endif				/* USE_PRIVSEP */
d318 1
a318 5
		if (!rsakey) {
			log_print("ike_auth_get_key: PEM_read_bio_RSAPrivateKey failed");
			return 0;
		}
		return rsakey;
d322 4
a325 4
	default:
		log_print("ike_auth_get_key: unknown key type %d", type);
		return 0;
	}
d327 1
a327 1
	return key;
d331 1
a331 1
pre_shared_gen_skeyid(struct exchange *exchange, size_t *sz)
d333 45
a377 42
	struct prf     *prf;
	struct ipsec_exch *ie = exchange->data;
	u_int8_t       *skeyid, *buf = 0;
	unsigned char  *key;
	size_t          keylen;

	/*
	 * If we're the responder and have the initiator's ID (which is the
	 * case in Aggressive mode), try to find the preshared key in the
	 * section of the initiator's Phase 1 ID.  This allows us to do
	 * mobile user support with preshared keys.
         */
	if (!exchange->initiator && exchange->id_i) {
		switch (exchange->id_i[0]) {
		case IPSEC_ID_IPV4_ADDR:
		case IPSEC_ID_IPV6_ADDR:
			util_ntoa((char **) &buf,
			    exchange->id_i[0] == IPSEC_ID_IPV4_ADDR ? AF_INET : AF_INET6,
			    exchange->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
			if (!buf)
				return 0;
			break;

		case IPSEC_ID_FQDN:
		case IPSEC_ID_USER_FQDN:
			buf = calloc(exchange->id_i_len - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ + 1, sizeof(char));
			if (!buf) {
				log_print("pre_shared_gen_skeyid: malloc (%lu) failed",
				    (unsigned long) exchange->id_i_len -
				    ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1);
				return 0;
			}
			memcpy(buf,
			    exchange->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    exchange->id_i_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
			break;

			/* XXX Support more ID types ? */
		default:
			break;
		}
d379 48
a426 44
	/*
	 * Get the pre-shared key for our peer. This will work even if the key
	 * has been passed to us through a mechanism like PFKEYv2.
         */
	key = ike_auth_get_key(IKE_AUTH_PRE_SHARED, exchange->name,
	    (char *) buf, &keylen);
	if (buf)
		free(buf);

	/* Fail if no key could be found.  */
	if (!key)
		return 0;

	/* Store the secret key for later policy processing.  */
	exchange->recv_key = calloc(keylen + 1, sizeof(char));
	exchange->recv_keytype = ISAKMP_KEY_PASSPHRASE;
	if (!exchange->recv_key) {
		log_error("pre_shared_gen_skeyid: malloc (%lu) failed",
		    (unsigned long) keylen);
		free(key);
		return 0;
	}
	memcpy(exchange->recv_key, key, keylen);
	exchange->recv_certtype = ISAKMP_CERTENC_NONE;
	free(key);

	prf = prf_alloc(ie->prf_type, ie->hash->type, exchange->recv_key, keylen);
	if (!prf)
		return 0;

	*sz = prf->blocksize;
	skeyid = malloc(*sz);
	if (!skeyid) {
		log_error("pre_shared_gen_skeyid: malloc (%lu) failed",
		    (unsigned long) *sz);
		prf_free(prf);
		return 0;
	}
	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, exchange->nonce_i, exchange->nonce_i_len);
	prf->Update(prf->prfctx, exchange->nonce_r, exchange->nonce_r_len);
	prf->Final(skeyid, prf->prfctx);
	prf_free(prf);
	return skeyid;
d432 1
a432 1
sig_gen_skeyid(struct exchange *exchange, size_t *sz)
d434 11
a444 11
	struct prf     *prf;
	struct ipsec_exch *ie = exchange->data;
	u_int8_t       *skeyid;
	unsigned char  *key;

	key = malloc(exchange->nonce_i_len + exchange->nonce_r_len);
	if (!key)
		return 0;
	memcpy(key, exchange->nonce_i, exchange->nonce_i_len);
	memcpy(key + exchange->nonce_i_len, exchange->nonce_r,
	    exchange->nonce_r_len);
d446 1
a446 1
	LOG_DBG((LOG_NEGOTIATION, 80, "sig_gen_skeyid: PRF type %d, hash %d",
d448 29
a476 2
	LOG_DBG_BUF((LOG_NEGOTIATION, 80, "sig_gen_skeyid: SKEYID initialized with",
	    (u_int8_t *) key, exchange->nonce_i_len + exchange->nonce_r_len));
d478 1
a478 24
	prf = prf_alloc(ie->prf_type, ie->hash->type, key,
	    exchange->nonce_i_len + exchange->nonce_r_len);
	free(key);
	if (!prf)
		return 0;

	*sz = prf->blocksize;
	skeyid = malloc(*sz);
	if (!skeyid) {
		log_error("sig_gen_skeyid: malloc (%lu) failed",
		    (unsigned long) *sz);
		prf_free(prf);
		return 0;
	}
	LOG_DBG((LOG_NEGOTIATION, 80, "sig_gen_skeyid: g^xy length %lu",
	    (unsigned long) ie->g_x_len));
	LOG_DBG_BUF((LOG_NEGOTIATION, 80, "sig_gen_skeyid: SKEYID fed with g^xy",
	    ie->g_xy, ie->g_x_len));

	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, ie->g_xy, ie->g_x_len);
	prf->Final(skeyid, prf->prfctx);
	prf_free(prf);
	return skeyid;
d480 1
a480 1
#endif				/* USE_X509 || USE_KEYNOTE */
d488 1
a488 1
enc_gen_skeyid(struct exchange *exchange, size_t *sz)
d490 28
a517 25
	struct prf     *prf;
	struct ipsec_exch *ie = exchange->data;
	struct hash    *hash = ie->hash;
	u_int8_t       *skeyid;

	hash->Init(hash->ctx);
	hash->Update(hash->ctx, exchange->nonce_i, exchange->nonce_i_len);
	hash->Update(hash->ctx, exchange->nonce_r, exchange->nonce_r_len);
	hash->Final(hash->digest, hash->ctx);
	prf = prf_alloc(ie->prf_type, hash->type, hash->digest, *sz);
	if (!prf)
		return 0;

	*sz = prf->blocksize;
	skeyid = malloc(*sz);
	if (!skeyid) {
		log_error("enc_gen_skeyid: malloc (%d) failed", *sz);
		prf_free(prf);
		return 0;
	}
	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, exchange->cookies, ISAKMP_HDR_COOKIES_LEN);
	prf->Final(skeyid, prf->prfctx);
	prf_free(prf);
	return skeyid;
d519 1
a519 1
#endif				/* notdef */
d522 1
a522 1
pre_shared_decode_hash(struct message *msg)
d524 33
a556 29
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct payload *payload;
	size_t          hashsize = ie->hash->hashsize;
	char            header[80];
	int             initiator = exchange->initiator;
	u_int8_t      **hash_p;

	/* Choose the right fields to fill-in.  */
	hash_p = initiator ? &ie->hash_r : &ie->hash_i;

	payload = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_HASH]);
	if (!payload) {
		log_print("pre_shared_decode_hash: no HASH payload found");
		return -1;
	}
	/* Check that the hash is of the correct size.  */
	if (GET_ISAKMP_GEN_LENGTH(payload->p) - ISAKMP_GEN_SZ != hashsize)
		return -1;

	/* XXX Need this hash be in the SA?  */
	*hash_p = malloc(hashsize);
	if (!*hash_p) {
		log_error("pre_shared_decode_hash: malloc (%lu) failed",
		    (unsigned long) hashsize);
		return -1;
	}
	memcpy(*hash_p, payload->p + ISAKMP_HASH_DATA_OFF, hashsize);
	snprintf(header, sizeof header, "pre_shared_decode_hash: HASH_%c",
d558 3
a560 1
	LOG_DBG_BUF((LOG_MISC, 80, header, *hash_p, hashsize));
d562 1
a562 2
	payload->flags |= PL_MARK;
	return 0;
d568 1
a568 1
rsa_sig_decode_hash(struct message *msg)
d570 16
a585 12
	struct cert_handler *handler;
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct payload *p;
	void           *cert = 0;
	u_int8_t       *rawcert = 0, **hash_p, **id_cert, *id;
	u_int32_t       rawcertlen, *id_cert_len;
	RSA            *key = 0;
	size_t          hashsize = ie->hash->hashsize, id_len;
	char            header[80];
	int             len, initiator = exchange->initiator;
	int             found = 0, n, i, id_found;
d587 2
a588 2
	u_int8_t       *rawkey = 0;
	u_int32_t       rawkeylen;
d591 27
a617 23
	/* Choose the right fields to fill-in.  */
	hash_p = initiator ? &ie->hash_r : &ie->hash_i;
	id = initiator ? exchange->id_r : exchange->id_i;
	id_len = initiator ? exchange->id_r_len : exchange->id_i_len;

	if (!id || id_len == 0) {
		log_print("rsa_sig_decode_hash: ID is missing");
		return -1;
	}
	/*
	 * XXX Assume we should use the same kind of certification as the remote...
	 * moreover, just use the first CERT payload to decide what to use.
         */
	p = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_CERT]);
	if (!p)
		handler = cert_get(ISAKMP_CERTENC_KEYNOTE);
	else
		handler = cert_get(GET_ISAKMP_CERT_ENCODING(p->p));
	if (!handler) {
		log_print("rsa_sig_decode_hash: cert_get (%d) failed",
		    p ? GET_ISAKMP_CERT_ENCODING(p->p) : -1);
		return -1;
	}
d619 37
a655 30
	/*
	 * We need the policy session initialized now, so we can add
	 * credentials etc.
         */
	exchange->policy_id = kn_init();
	if (exchange->policy_id == -1) {
		log_print("rsa_sig_decode_hash: failed to initialize policy session");
		return -1;
	}
#endif				/* USE_POLICY || USE_KEYNOTE */

	/* Obtain a certificate from our certificate storage.  */
	if (handler->cert_obtain(id, id_len, 0, &rawcert, &rawcertlen)) {
		if (handler->id == ISAKMP_CERTENC_X509_SIG) {
			cert = handler->cert_get(rawcert, rawcertlen);
			if (!cert)
				LOG_DBG((LOG_CRYPTO, 50,
				    "rsa_sig_decode_hash: certificate malformed"));
			else {
				if (!handler->cert_get_key(cert, &key)) {
					log_print("rsa_sig_decode_hash: "
					    "decoding certificate failed");
					handler->cert_free(cert);
				} else {
					found++;
					LOG_DBG((LOG_CRYPTO, 40,
					    "rsa_sig_decode_hash: using cert of type %d",
					    handler->id));
					exchange->recv_cert = cert;
					exchange->recv_certtype = handler->id;
d657 2
a658 31
					x509_generate_kn(exchange->policy_id, cert);
#endif				/* USE_POLICY */
				}
			}
		} else if (handler->id == ISAKMP_CERTENC_KEYNOTE)
			handler->cert_insert(exchange->policy_id, rawcert);
		free(rawcert);
	}
	/*
	 * Walk over potential CERT payloads in this message.
	 * XXX I believe this is the wrong spot for this.  CERTs can appear
	 * anytime.
         */
	for (p = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_CERT]); p;
	    p = TAILQ_NEXT(p, link)) {
		p->flags |= PL_MARK;

		/*
		 * When we have found a key, just walk over the rest, marking
		 * them.
		 */
		if (found)
			continue;

		handler = cert_get(GET_ISAKMP_CERT_ENCODING(p->p));
		if (!handler) {
			LOG_DBG((LOG_MISC, 30,
			    "rsa_sig_decode_hash: no handler for %s CERT encoding",
			    constant_name(isakmp_certenc_cst,
			    GET_ISAKMP_CERT_ENCODING(p->p))));
			continue;
d660 85
a744 41
		cert = handler->cert_get(p->p + ISAKMP_CERT_DATA_OFF,
		    GET_ISAKMP_GEN_LENGTH(p->p) - ISAKMP_CERT_DATA_OFF);
		if (!cert) {
			log_print("rsa_sig_decode_hash: can not get data from CERT");
			continue;
		}
		if (!handler->cert_validate(cert)) {
			handler->cert_free(cert);
			log_print("rsa_sig_decode_hash: received CERT can't be validated");
			continue;
		}
		if (GET_ISAKMP_CERT_ENCODING(p->p) == ISAKMP_CERTENC_X509_SIG) {
			if (!handler->cert_get_subjects(cert, &n, &id_cert,
			    &id_cert_len)) {
				handler->cert_free(cert);
				log_print("rsa_sig_decode_hash: can not get subject from CERT");
				continue;
			}
			id_found = 0;
			for (i = 0; i < n; i++)
				if (id_cert_len[i] == id_len &&
				    id[0] == id_cert[i][0] &&
				    memcmp(id + 4, id_cert[i] + 4, id_len - 4) == 0) {
					id_found++;
					break;
				}
			if (!id_found) {
				handler->cert_free(cert);
				log_print("rsa_sig_decode_hash: no CERT subject match the ID");
				free(id_cert);
				continue;
			}
			cert_free_subjects(n, id_cert, id_cert_len);
		}
		if (!handler->cert_get_key(cert, &key)) {
			handler->cert_free(cert);
			log_print("rsa_sig_decode_hash: decoding payload CERT failed");
			continue;
		}
		/* We validated the cert, cache it for later use.  */
		handler->cert_insert(exchange->policy_id, cert);
d746 2
a747 2
		exchange->recv_cert = cert;
		exchange->recv_certtype = GET_ISAKMP_CERT_ENCODING(p->p);
d750 32
a781 27
		if (exchange->recv_certtype == ISAKMP_CERTENC_KEYNOTE) {
			struct keynote_deckey dc;
			char           *pp;
			int             dclen;

			dc.dec_algorithm = KEYNOTE_ALGORITHM_RSA;
			dc.dec_key = key;

			pp = kn_encode_key(&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
			    KEYNOTE_PUBLIC_KEY);
			if (pp == NULL) {
				kn_free_key(&dc);
				log_print("rsa_sig_decode_hash: failed to ASCII-encode key");
				return -1;
			}
			dclen = strlen(pp) + sizeof "rsa-hex:";
			exchange->keynote_key = calloc(dclen, sizeof(char));
			if (!exchange->keynote_key) {
				free(pp);
				kn_free_key(&dc);
				log_print("rsa_sig_decode_hash: failed to allocate %d bytes",
				    dclen);
				return -1;
			}
			snprintf(exchange->keynote_key, dclen, "rsa-hex:%s", pp);
			free(pp);
		}
d784 2
a785 2
		found++;
	}
d788 15
a802 17
	/*
	 * If no certificate provided a key, try to find a validated DNSSEC
	 * KEY.
	 */
	if (!found) {
		rawkey = dns_get_key(IKE_AUTH_RSA_SIG, msg, &rawkeylen);

		/* We need to convert 'void *rawkey' into 'RSA *key'.  */
		if (dns_RSA_dns_to_x509(rawkey, rawkeylen, &key) == 0)
			found++;
		else
			log_print("rsa_sig_decode_hash: KEY to RSA key conversion failed");

		if (rawkey)
			free(rawkey);
	}
#endif				/* USE_DNSSEC */
d805 4
a808 4
	/* If we still have not found a key, try to read it from a file. */
	if (!found)
		if (get_raw_key_from_file(IKE_AUTH_RSA_SIG, id, id_len, &key) != -1)
			found++;
d811 55
a865 43
	if (!found) {
		log_print("rsa_sig_decode_hash: no public key found");
		return -1;
	}
	p = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_SIG]);
	if (!p) {
		log_print("rsa_sig_decode_hash: missing signature payload");
		RSA_free(key);
		return -1;
	}
	/* Check that the sig is of the correct size.  */
	len = GET_ISAKMP_GEN_LENGTH(p->p) - ISAKMP_SIG_SZ;
	if (len != RSA_size(key)) {
		RSA_free(key);
		log_print("rsa_sig_decode_hash: "
		    "SIG payload length does not match public key");
		return -1;
	}
	*hash_p = malloc(len);
	if (!*hash_p) {
		RSA_free(key);
		log_error("rsa_sig_decode_hash: malloc (%d) failed", len);
		return -1;
	}
	len = RSA_public_decrypt(len, p->p + ISAKMP_SIG_DATA_OFF, *hash_p, key,
	    RSA_PKCS1_PADDING);
	if (len == -1) {
		RSA_free(key);
		log_print("rsa_sig_decode_hash: RSA_public_decrypt () failed");
		return -1;
	}
	/* Store key for later use */
	exchange->recv_key = key;
	exchange->recv_keytype = ISAKMP_KEY_RSA;

	if (len != (int) hashsize) {
		free(*hash_p);
		*hash_p = 0;
		log_print("rsa_sig_decode_hash: len %lu != hashsize %lu",
		    (unsigned long) len, (unsigned long) hashsize);
		return -1;
	}
	snprintf(header, sizeof header, "rsa_sig_decode_hash: HASH_%c",
d867 3
a869 1
	LOG_DBG_BUF((LOG_MISC, 80, header, *hash_p, hashsize));
d871 1
a871 2
	p->flags |= PL_MARK;
	return 0;
d873 1
a873 1
#endif				/* USE_X509 || USE_KEYNOTE */
d876 1
a876 1
pre_shared_encode_hash(struct message *msg)
d878 10
a887 10
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	size_t          hashsize = ie->hash->hashsize;
	char            header[80];
	int             initiator = exchange->initiator;
	u_int8_t       *buf;

	buf = ipsec_add_hash_payload(msg, hashsize);
	if (!buf)
		return -1;
d889 2
a890 2
	if (ike_auth_hash(exchange, buf + ISAKMP_HASH_DATA_OFF) == -1)
		return -1;
d892 1
a892 1
	snprintf(header, sizeof header, "pre_shared_encode_hash: HASH_%c",
d894 2
a895 2
	LOG_DBG_BUF((LOG_MISC, 80, header, buf + ISAKMP_HASH_DATA_OFF, hashsize));
	return 0;
d901 1
a901 1
rsa_sig_encode_hash(struct message *msg)
d903 59
a961 35
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	size_t          hashsize = ie->hash->hashsize, id_len;
	struct cert_handler *handler;
	char            header[80];
	int             initiator = exchange->initiator, idtype;
	u_int8_t       *buf, *data, *buf2, *id;
	u_int32_t       datalen;
	int32_t         sigsize;
	void           *sent_key;

	id = initiator ? exchange->id_i : exchange->id_r;
	id_len = initiator ? exchange->id_i_len : exchange->id_r_len;

	/* We may have been provided these by the kernel */
	buf = (u_int8_t *) conf_get_str(exchange->name, "Credentials");
	if (buf &&
	    (idtype = conf_get_num(exchange->name, "Credential_Type", -1) != -1)) {
		exchange->sent_certtype = idtype;
		handler = cert_get(idtype);
		if (!handler) {
			log_print("rsa_sig_encode_hash: cert_get (%d) failed", idtype);
			return -1;
		}
		exchange->sent_cert = handler->cert_from_printable((char *) buf);
		if (!exchange->sent_cert) {
			log_print("rsa_sig_encode_hash: failed to retrieve certificate");
			return -1;
		}
		handler->cert_serialize(exchange->sent_cert, &data, &datalen);
		if (!data) {
			log_print("rsa_sig_encode_hash: cert serialization failed");
			return -1;
		}
		goto aftercert;	/* Skip all the certificate discovery */
d963 1
a963 2
	/* XXX This needs to be configurable.  */
	idtype = ISAKMP_CERTENC_KEYNOTE;
d965 69
a1033 9
	/* Find a certificate with subjectAltName = id.  */
	handler = cert_get(idtype);
	if (!handler) {
		idtype = ISAKMP_CERTENC_X509_SIG;
		handler = cert_get(idtype);
		if (!handler) {
			log_print("rsa_sig_encode_hash: cert_get(%d) failed", idtype);
			return -1;
		}
d1035 8
a1042 19
	if (handler->cert_obtain(id, id_len, 0, &data, &datalen) == 0) {
		if (idtype == ISAKMP_CERTENC_KEYNOTE) {
			idtype = ISAKMP_CERTENC_X509_SIG;
			handler = cert_get(idtype);
			if (!handler) {
				log_print("rsa_sig_encode_hash: cert_get(%d) failed",
				    idtype);
				return -1;
			}
			if (handler->cert_obtain(id, id_len, 0, &data, &datalen) == 0) {
				LOG_DBG((LOG_MISC, 10,
				    "rsa_sig_encode_hash: no certificate to send"));
				goto skipcert;
			}
		} else {
			LOG_DBG((LOG_MISC, 10,
			    "rsa_sig_encode_hash: no certificate to send"));
			goto skipcert;
		}
d1044 35
a1078 75
	/* Let's store the certificate we are going to use */
	exchange->sent_certtype = idtype;
	exchange->sent_cert = handler->cert_get(data, datalen);
	if (!exchange->sent_cert) {
		free(data);
		log_print("rsa_sig_encode_hash: failed to get certificate from wire "
		    "encoding");
		return -1;
	}
aftercert:

	buf = realloc(data, ISAKMP_CERT_SZ + datalen);
	if (!buf) {
		log_error("rsa_sig_encode_hash: realloc (%p, %d) failed", data,
		    ISAKMP_CERT_SZ + datalen);
		free(data);
		return -1;
	}
	memmove(buf + ISAKMP_CERT_SZ, buf, datalen);
	SET_ISAKMP_CERT_ENCODING(buf, idtype);
	if (message_add_payload(msg, ISAKMP_PAYLOAD_CERT, buf,
	    ISAKMP_CERT_SZ + datalen, 1)) {
		free(buf);
		return -1;
	}
skipcert:

	/* Again, we may have these from the kernel */
	buf = (u_int8_t *) conf_get_str(exchange->name, "PKAuthentication");
	if (buf) {
		key_from_printable(ISAKMP_KEY_RSA, ISAKMP_KEYTYPE_PRIVATE, (char *) buf,
		    &data, &datalen);
		if (!data) {
			log_print("rsa_sig_encode_hash: badly formatted RSA private key");
			return 0;
		}
		sent_key = key_internalize(ISAKMP_KEY_RSA, ISAKMP_KEYTYPE_PRIVATE,
		    data, datalen);
		if (!sent_key) {
			log_print("rsa_sig_encode_hash: bad RSA private key from dynamic "
			    "SA acquisition subsystem");
			return 0;
		}
	} else {
		/* Try through the regular means.  */
		switch (id[ISAKMP_ID_TYPE_OFF - ISAKMP_GEN_SZ]) {
		case IPSEC_ID_IPV4_ADDR:
		case IPSEC_ID_IPV6_ADDR:
			util_ntoa((char **) &buf2,
			    id[ISAKMP_ID_TYPE_OFF - ISAKMP_GEN_SZ] ==
			    IPSEC_ID_IPV4_ADDR ? AF_INET : AF_INET6,
			    id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
			if (!buf2)
				return 0;
			break;

		case IPSEC_ID_FQDN:
		case IPSEC_ID_USER_FQDN:
			buf2 = calloc(id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
			    sizeof(char));
			if (!buf2) {
				log_print("rsa_sig_encode_hash: malloc (%lu) failed",
				    (unsigned long) id_len - ISAKMP_ID_DATA_OFF +
				    ISAKMP_GEN_SZ + 1);
				return 0;
			}
			memcpy(buf2, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
			break;

			/* XXX Support more ID types?  */
		default:
			buf2 = 0;
			return 0;
		}
d1080 4
a1083 9
		sent_key = ike_auth_get_key(IKE_AUTH_RSA_SIG, exchange->name,
		    (char *) buf2, 0);
		free(buf2);

		/* Did we find a key?  */
		if (!sent_key) {
			log_print("rsa_sig_encode_hash: could not get private key");
			return -1;
		}
d1086 13
a1098 15
	/* Enable RSA blinding.  */
	if (RSA_blinding_on(sent_key, NULL) != 1) {
		log_error("rsa_sig_encode_hash: RSA_blinding_on () failed.");
		return -1;
	}
	/* XXX hashsize is not necessarily prf->blocksize.  */
	buf = malloc(hashsize);
	if (!buf) {
		log_error("rsa_sig_encode_hash: malloc (%lu) failed",
		    (unsigned long) hashsize);
		return -1;
	}
	if (ike_auth_hash(exchange, buf) == -1) {
		free(buf);
		return -1;
d1100 27
a1126 1
	snprintf(header, sizeof header, "rsa_sig_encode_hash: HASH_%c",
d1128 10
a1137 1
	LOG_DBG_BUF((LOG_MISC, 80, header, buf, hashsize));
d1139 27
a1165 28
	data = malloc(RSA_size(sent_key));
	if (!data) {
		log_error("rsa_sig_encode_hash: malloc (%d) failed",
		    RSA_size(sent_key));
		return -1;
	}
	sigsize = RSA_private_encrypt(hashsize, buf, data, sent_key,
	    RSA_PKCS1_PADDING);
	if (sigsize == -1) {
		log_print("rsa_sig_encode_hash: RSA_private_encrypt () failed");
		if (data)
			free(data);
		free(buf);
		RSA_free(sent_key);
		return -1;
	}
	datalen = (u_int32_t) sigsize;

	free(buf);

	buf = realloc(data, ISAKMP_SIG_SZ + datalen);
	if (!buf) {
		log_error("rsa_sig_encode_hash: realloc (%p, %d) failed", data,
		    ISAKMP_SIG_SZ + datalen);
		free(data);
		return -1;
	}
	memmove(buf + ISAKMP_SIG_SZ, buf, datalen);
d1167 1
a1167 1
	snprintf(header, sizeof header, "rsa_sig_encode_hash: SIG_%c",
d1169 8
a1176 7
	LOG_DBG_BUF((LOG_MISC, 80, header, buf + ISAKMP_SIG_DATA_OFF, datalen));
	if (message_add_payload(msg, ISAKMP_PAYLOAD_SIG, buf,
	    ISAKMP_SIG_SZ + datalen, 1)) {
		free(buf);
		return -1;
	}
	return 0;
d1178 1
a1178 1
#endif				/* USE_X509 || USE_KEYNOTE */
d1181 1
a1181 1
ike_auth_hash(struct exchange *exchange, u_int8_t *buf)
d1183 33
a1215 30
	struct ipsec_exch *ie = exchange->data;
	struct prf     *prf;
	struct hash    *hash = ie->hash;
	int             initiator = exchange->initiator;
	u_int8_t       *id;
	size_t          id_len;

	/* Choose the right fields to fill-in.  */
	id = initiator ? exchange->id_i : exchange->id_r;
	id_len = initiator ? exchange->id_i_len : exchange->id_r_len;

	/* Allocate the prf and start calculating our HASH.  */
	prf = prf_alloc(ie->prf_type, hash->type, ie->skeyid, ie->skeyid_len);
	if (!prf)
		return -1;

	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, initiator ? ie->g_xi : ie->g_xr, ie->g_x_len);
	prf->Update(prf->prfctx, initiator ? ie->g_xr : ie->g_xi, ie->g_x_len);
	prf->Update(prf->prfctx, exchange->cookies +
	    (initiator ? ISAKMP_HDR_ICOOKIE_OFF : ISAKMP_HDR_RCOOKIE_OFF),
	    ISAKMP_HDR_ICOOKIE_LEN);
	prf->Update(prf->prfctx, exchange->cookies +
	    (initiator ? ISAKMP_HDR_RCOOKIE_OFF : ISAKMP_HDR_ICOOKIE_OFF),
	    ISAKMP_HDR_ICOOKIE_LEN);
	prf->Update(prf->prfctx, ie->sa_i_b, ie->sa_i_b_len);
	prf->Update(prf->prfctx, id, id_len);
	prf->Final(buf, prf->prfctx);
	prf_free(prf);
	return 0;
d1220 1
a1220 1
get_raw_key_from_file(int type, u_int8_t *id, size_t id_len, RSA **rsa)
d1222 39
a1260 29
	char            filename[FILENAME_MAX];
	char           *fstr;
	struct stat     st;
#if defined (USE_PRIVSEP)
	FILE           *keyfp;
#else
	BIO            *bio;
#endif

	if (type != IKE_AUTH_RSA_SIG) {	/* XXX More types? */
		LOG_DBG((LOG_NEGOTIATION, 20, "get_raw_key_from_file: "
		    "invalid auth type %d\n", type));
		return -1;
	}
	*rsa = 0;

	fstr = conf_get_str("General", "Pubkey-directory");
	if (!fstr)
		fstr = CONF_DFLT_PUBKEY_DIR;

	if (snprintf(filename, sizeof filename, "%s/", fstr) >
	    (int) sizeof filename - 1)
		return -1;

	fstr = ipsec_id_string(id, id_len);
	if (!fstr) {
		LOG_DBG((LOG_NEGOTIATION, 50, "get_raw_key_from_file: "
		    "ipsec_id_string failed"));
		return -1;
d1262 15
a1276 34
	strlcat(filename, fstr, sizeof filename - strlen(filename));
	free(fstr);

	/* If the file does not exist, fail silently.  */
	if (monitor_stat(filename, &st) == 0) {
#if defined (USE_PRIVSEP)
		keyfp = monitor_fopen(filename, "r");
		if (!keyfp) {
			log_error("get_raw_key_from_file: monitor_fopen (\"%s\", \"r\") "
			    "failed", filename);
			return -1;
		}
		*rsa = PEM_read_RSA_PUBKEY(keyfp, NULL, NULL, NULL);
		fclose(keyfp);
#else
		bio = BIO_new(BIO_s_file());
		if (!bio) {
			log_error("get_raw_key_from_file: could not initialize BIO");
			return -1;
		}
		if (BIO_read_filename(bio, filename) <= 0) {
			LOG_DBG((LOG_NEGOTIATION, 50, "get_raw_key_from_file: "
			    "BIO_read_filename(bio, \"%s\") failed", filename));
			BIO_free(bio);
			return -1;
		}
		LOG_DBG((LOG_NEGOTIATION, 80,
		    "get_raw_key_from_file: reading file %s", filename));
		*rsa = PEM_read_bio_RSA_PUBKEY(bio, NULL, NULL, NULL);
		BIO_free(bio);
#endif				/* USE_PRIVSEP */
	} else
		LOG_DBG((LOG_NEGOTIATION, 50,
		    "get_raw_key_from_file: file %s not found", filename));
d1278 1
a1278 1
	return (*rsa ? 0 : -1);
d1280 1
a1280 1
#endif				/* USE_RAWKEY */
@


1.1.1.8
log
@another bunch of fixes from obsd, and a big isakmpd update (need testers!)
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.95 2004/08/08 19:11:06 deraadt Exp $	 */
d37 2
a40 3

#include <errno.h>
#include <fcntl.h>
a42 1
#include <unistd.h>
d97 1
a97 2
		IKE_AUTH_PRE_SHARED, pre_shared_gen_skeyid,
		pre_shared_decode_hash,
d102 1
a102 2
		IKE_AUTH_DSS, sig_gen_skeyid,
		pre_shared_decode_hash,
d108 1
a108 2
		IKE_AUTH_RSA_SIG, sig_gen_skeyid,
		rsa_sig_decode_hash,
d114 1
a114 2
		IKE_AUTH_RSA_ENC, enc_gen_skeyid,
		pre_shared_decode_hash,
d118 1
a118 2
		IKE_AUTH_RSA_ENC_REV, enc_gen_skeyid,
		pre_shared_decode_hash,
d142 1
a142 1
	char	*key, *buf;
d144 1
a144 2
	int	 fd;
	char	*keyfile;
d146 7
a152 3
	FILE	*keyfp;
	RSA	*rsakey;
	size_t	fsize;
d174 2
a175 2
				log_error("ike_auth_get_key: malloc (%lu) "
				    "failed", (unsigned long)*keylen);
d178 1
a178 1
			if (hex2raw(key + 2, (unsigned char *)buf, *keylen)) {
d180 2
a181 2
				log_print("ike_auth_get_key: invalid hex key "
				    "%s", key);
d199 2
a200 2
		if (local_id && (keyfile = conf_get_str("KeyNote",
		    "Credential-directory")) != 0) {
d204 1
a204 1
			int             pkflen;
d211 2
a212 2
				log_print("ike_auth_get_key: failed to "
				    "allocate %d bytes", pkflen);
d215 2
a216 2
			snprintf(privkeyfile, pkflen, "%s/%s/%s", keyfile,
			    local_id, PRIVATE_KEY_FILE);
d219 1
a219 2
			fd = monitor_open(keyfile, O_RDONLY, 0);
			if (fd < 0) {
d223 1
d225 4
a228 2
			if (fstat(fd, &sb) < 0) {
				log_print("ike_auth_get_key: fstat failed");
a229 1
				close(fd);
a231 2
			size = (size_t)sb.st_size;

d234 2
a235 2
				log_print("ike_auth_get_key: failed allocating"
				    " %lu bytes", (unsigned long)size + 1);
a236 1
				close(fd);
d239 1
a239 1
			if (read(fd, buf, size) != (ssize_t)size) {
d243 1
a243 1
				    (unsigned long)size, keyfile);
a244 1
				close(fd);
d253 4
a256 6
			if (!buf2 || kn_decode_key(&dc, buf2,
			    KEYNOTE_PRIVATE_KEY) == -1) {
				if (buf2)
					free(buf2);
				log_print("ike_auth_get_key: failed decoding "
				    "key in \"%s\"", keyfile);
d263 2
a264 3
				log_print("ike_auth_get_key: wrong algorithm "
				    "type %d in \"%s\"", dc.dec_algorithm,
				    keyfile);
d278 1
a278 9
		fd = monitor_open(keyfile, O_RDONLY, 0);
		if (fd < 0) {
			log_print("ike_auth_get_key: failed opening \"%s\"",
			    keyfile);
			return 0;
		}

		if (check_file_secrecy_fd(fd, keyfile, &fsize) < 0) {
			close(fd);
a279 1
		}
d281 4
a284 3
		if ((keyfp = fdopen(fd, "r")) == NULL) {
			log_print("ike_auth_get_key: fdopen failed");
			close(fd);
d293 21
d316 1
a316 2
			log_print("ike_auth_get_key: "
			    "PEM_read_bio_RSAPrivateKey failed");
d351 2
a352 3
			    exchange->id_i[0] == IPSEC_ID_IPV4_ADDR ? AF_INET :
			    AF_INET6, exchange->id_i + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ);
d362 2
a363 3
				log_print("pre_shared_gen_skeyid: malloc (%lu"
				    ") failed",
				    (unsigned long)exchange->id_i_len -
d368 2
a369 4
			    exchange->id_i + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ,
			    exchange->id_i_len - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ);
d395 1
a395 1
		    (unsigned long)keylen);
d403 1
a403 2
	prf = prf_alloc(ie->prf_type, ie->hash->type, exchange->recv_key,
	    keylen);
d411 1
a411 1
		    (unsigned long)*sz);
d442 2
a443 3
	LOG_DBG_BUF((LOG_NEGOTIATION, 80,
	    "sig_gen_skeyid: SKEYID initialized with",
	    (u_int8_t *)key, exchange->nonce_i_len + exchange->nonce_r_len));
d455 1
a455 1
		    (unsigned long)*sz);
d461 2
a462 2
	LOG_DBG_BUF((LOG_NEGOTIATION, 80,
	    "sig_gen_skeyid: SKEYID fed with g^xy", ie->g_xy, ie->g_x_len));
d522 1
a522 1
	payload = payload_first(msg, ISAKMP_PAYLOAD_HASH);
d535 1
a535 1
		    (unsigned long)hashsize);
d579 2
a580 3
	 * XXX Assume we should use the same kind of certification as the
	 * remote...  moreover, just use the first CERT payload to decide what
	 * to use.
d582 1
a582 1
	p = payload_first(msg, ISAKMP_PAYLOAD_CERT);
d599 1
a599 2
		log_print("rsa_sig_decode_hash: failed to initialize policy "
		    "session");
d609 2
a610 2
				LOG_DBG((LOG_CRYPTO, 50, "rsa_sig_decode_hash:"
				    " certificate malformed"));
d619 2
a620 2
					    "rsa_sig_decode_hash: using cert "
					    "of type %d", handler->id));
d624 1
a624 2
					x509_generate_kn(exchange->policy_id,
					    cert);
d637 1
a637 1
	for (p = payload_first(msg, ISAKMP_PAYLOAD_CERT); p;
d650 2
a651 2
			LOG_DBG((LOG_MISC, 30, "rsa_sig_decode_hash: "
			    "no handler for %s CERT encoding",
d659 1
a659 2
			log_print("rsa_sig_decode_hash: "
			    "can not get data from CERT");
d664 1
a664 2
			log_print("rsa_sig_decode_hash: received CERT can't "
			    "be validated");
d667 1
a667 2
		if (GET_ISAKMP_CERT_ENCODING(p->p) ==
		    ISAKMP_CERTENC_X509_SIG) {
d671 1
a671 2
				log_print("rsa_sig_decode_hash: can not get "
				    "subject from CERT");
d678 1
a678 2
				    memcmp(id + 4, id_cert[i] + 4, id_len - 4)
				    == 0) {
d684 1
a684 2
				log_print("rsa_sig_decode_hash: no CERT "
				    "subject match the ID");
d692 1
a692 2
			log_print("rsa_sig_decode_hash: decoding payload CERT "
			    "failed");
d710 2
a711 2
			pp = kn_encode_key(&dc, INTERNAL_ENC_PKCS1,
			    ENCODING_HEX, KEYNOTE_PUBLIC_KEY);
d714 1
a714 2
				log_print("rsa_sig_decode_hash: failed to "
				    "ASCII-encode key");
d722 2
a723 2
				log_print("rsa_sig_decode_hash: failed to "
				    "allocate %d bytes", dclen);
d726 1
a726 2
			snprintf(exchange->keynote_key, dclen, "rsa-hex:%s",
			    pp);
d746 1
a746 2
			log_print("rsa_sig_decode_hash: KEY to RSA key "
			    "conversion failed");
d756 1
a756 2
		if (get_raw_key_from_file(IKE_AUTH_RSA_SIG, id, id_len, &key)
		    != -1)
d764 1
a764 1
	p = payload_first(msg, ISAKMP_PAYLOAD_SIG);
d799 1
a799 1
		    (unsigned long)len, (unsigned long)hashsize);
d830 1
a830 2
	LOG_DBG_BUF((LOG_MISC, 80, header, buf + ISAKMP_HASH_DATA_OFF,
	    hashsize));
d855 2
a856 2
	if (buf && (idtype = conf_get_num(exchange->name, "Credential_Type",
	    -1) != -1)) {
d860 1
a860 2
			log_print("rsa_sig_encode_hash: cert_get (%d) failed",
			    idtype);
d863 1
a863 2
		exchange->sent_cert =
		    handler->cert_from_printable((char *)buf);
d865 1
a865 2
			log_print("rsa_sig_encode_hash: failed to retrieve "
			    "certificate");
d870 1
a870 2
			log_print("rsa_sig_encode_hash: cert serialization "
			    "failed");
d884 1
a884 2
			log_print("rsa_sig_encode_hash: cert_get(%d) failed",
			    idtype);
d893 2
a894 2
				log_print("rsa_sig_encode_hash: cert_get(%d) "
				    "failed", idtype);
d897 3
a899 4
			if (handler->cert_obtain(id, id_len, 0, &data,
			    &datalen) == 0) {
				LOG_DBG((LOG_MISC, 10, "rsa_sig_encode_hash: "
				    "no certificate to send"));
d913 2
a914 2
		log_print("rsa_sig_encode_hash: failed to get certificate "
		    "from wire encoding");
d938 2
a939 2
		key_from_printable(ISAKMP_KEY_RSA, ISAKMP_KEYTYPE_PRIVATE,
		    (char *)buf, &data, &datalen);
d941 1
a941 2
			log_print("rsa_sig_encode_hash: badly formatted RSA "
			    "private key");
d944 2
a945 2
		sent_key = key_internalize(ISAKMP_KEY_RSA,
		    ISAKMP_KEYTYPE_PRIVATE, data, datalen);
d947 2
a948 2
			log_print("rsa_sig_encode_hash: bad RSA private key "
			    "from dynamic SA acquisition subsystem");
d956 1
a956 1
			util_ntoa((char **)&buf2,
d966 2
a967 2
			buf2 = calloc(id_len - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ + 1, sizeof(char));
d969 3
a971 3
				log_print("rsa_sig_encode_hash: malloc (%lu) "
				    "failed", (unsigned long)id_len -
				    ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1);
d985 1
a985 1
		    (char *)buf2, 0);
d990 1
a990 2
			log_print("rsa_sig_encode_hash: "
			    "could not get private key");
d1004 1
a1004 1
		    (unsigned long)hashsize);
d1024 1
a1024 2
		log_print("rsa_sig_encode_hash: "
		    "RSA_private_encrypt () failed");
d1046 1
a1046 2
	LOG_DBG_BUF((LOG_MISC, 80, header, buf + ISAKMP_SIG_DATA_OFF,
	    datalen));
d1097 2
d1100 3
d1116 1
a1116 1
	    (int)sizeof filename - 1)
d1129 8
a1136 2
	keyfp = monitor_fopen(filename, "r");
	if (keyfp) {
d1139 17
a1155 4
	} else if (errno != ENOENT) {
		log_error("get_raw_key_from_file: monitor_fopen "
		    "(\"%s\", \"r\") failed", filename);
		return -1;
@


