head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.11
	tg-mergefixes-1-branch:1.1.1.11.0.4
	tg-mergefixes-1-base:1.1.1.11
	MIROS_X:1.1.1.11.0.2
	MIROS_X_BASE:1.1.1.11
	tg-mergetmp-3:1.1.1.11
	cvs-200411261545:1.1.1.11
	MIRBSD_XP_MIRPPC:1.1.1.10.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.10
	MIRBSD_XP_SPARC:1.1.1.10.0.2
	MIRBSD_7quater:1.1.1.7.4.2
	cvs-200405160640:1.1.1.10
	cvs-200401271800:1.1.1.9
	cvs-200401261630:1.1.1.9
	cvs-200401021645:1.1.1.8
	MIRBSD_7_ALPHA:1.1.1.7.0.6
	MIRBSD_7:1.1.1.7.0.4
	cvs-200312222040:1.1.1.8
	MIRBSD_7ter:1.1.1.7
	MIRBSD_7_DEV:1.1.1.7.0.2
	cvs-200310020700:1.1.1.7
	cvs-200309271030:1.1.1.7
	cvs-200309251530:1.1.1.7
	cvs-200308302005:1.1.1.6
	cvs-200308171200:1.1.1.6
	ctm-3496:1.1.1.6
	ctm-3449:1.1.1.5
	ctm-3437:1.1.1.4
	cvs-200307191805:1.1.1.4
	ctm-3425:1.1.1.4
	cvs-200307091500:1.1.1.4
	ctm-3389:1.1.1.4
	cvs-200306291430:1.1.1.4
	ctm-3341:1.1.1.4
	MIRBSD_5:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.17.48.28;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.48.28;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.21.19.02.36;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.31.00;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.19.12.42.31;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.07.26.13.14.31;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.08.11.18.29.45;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.09.25.16.32.16;	author tg;	state Exp;
branches
	1.1.1.7.4.1;
next	1.1.1.8;

1.1.1.8
date	2003.12.22.21.10.34;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.01.26.18.29.18;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.05.16.08.24.14;	author tg;	state Stab;
branches;
next	1.1.1.11;

1.1.1.11
date	2004.11.26.15.50.37;	author tg;	state Exp;
branches;
next	;

1.1.1.7.4.1
date	2004.01.20.16.02.25;	author bsiegert;	state Exp;
branches;
next	1.1.1.7.4.2;

1.1.1.7.4.2
date	2004.03.19.19.03.11;	author bsiegert;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: ipsec.c,v 1.72 2002/11/21 12:09:20 ho Exp $	*/
/*	$EOM: ipsec.c,v 1.143 2000/12/11 23:57:42 niklas Exp $	*/

/*
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2001 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 2001 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>

#include "sysdep.h"

#include "attribute.h"
#include "conf.h"
#include "constants.h"
#include "crypto.h"
#include "dh.h"
#include "doi.h"
#include "exchange.h"
#include "hash.h"
#include "ike_aggressive.h"
#include "ike_auth.h"
#include "ike_main_mode.h"
#include "ike_quick_mode.h"
#include "ipsec.h"
#include "ipsec_doi.h"
#include "isakmp.h"
#include "isakmp_cfg.h"
#include "isakmp_fld.h"
#include "isakmp_num.h"
#include "log.h"
#include "math_group.h"
#include "message.h"
#include "prf.h"
#include "sa.h"
#include "timer.h"
#include "transport.h"
#include "util.h"
#include "x509.h"

/* Backwards compatibility.  */
#ifndef NI_MAXHOST
#define NI_MAXHOST 1025
#endif

/* The replay window size used for all IPsec protocols if not overridden.  */
#define DEFAULT_REPLAY_WINDOW 16

struct ipsec_decode_arg {
  struct message *msg;
  struct sa *sa;
  struct proto *proto;
};

/* These variables hold the contacted peers ADT state.  */
struct contact {
  struct sockaddr *addr;
  socklen_t len;
} *contacts = 0;
int contact_cnt = 0, contact_limit = 0;

static int addr_cmp (const void *, const void *);
static int ipsec_add_contact (struct message *msg);
static int ipsec_contacted (struct message *msg);
#ifdef USE_DEBUG
static int ipsec_debug_attribute (u_int16_t, u_int8_t *, u_int16_t, void *);
#endif
static void ipsec_delete_spi (struct sa *, struct proto *, int);
static int16_t *ipsec_exchange_script (u_int8_t);
static void ipsec_finalize_exchange (struct message *);
static void ipsec_free_exchange_data (void *);
static void ipsec_free_proto_data (void *);
static void ipsec_free_sa_data (void *);
static struct keystate *ipsec_get_keystate (struct message *);
static u_int8_t *ipsec_get_spi (size_t *, u_int8_t, struct message *);
static int ipsec_handle_leftover_payload (struct message *, u_int8_t,
					  struct payload *);
static int ipsec_informational_post_hook (struct message *);
static int ipsec_informational_pre_hook (struct message *);
static int ipsec_initiator (struct message *);
static void ipsec_proto_init (struct proto *, char *);
static int ipsec_responder (struct message *);
static void ipsec_setup_situation (u_int8_t *);
static int ipsec_set_network (u_int8_t *, u_int8_t *, struct ipsec_sa *);
static size_t ipsec_situation_size (void);
static u_int8_t ipsec_spi_size (u_int8_t);
static int ipsec_validate_attribute (u_int16_t, u_int8_t *, u_int16_t, void *);
static int ipsec_validate_exchange (u_int8_t);
static int ipsec_validate_id_information (u_int8_t, u_int8_t *, u_int8_t *,
					  size_t, struct exchange *);
static int ipsec_validate_key_information (u_int8_t *, size_t);
static int ipsec_validate_notification (u_int16_t);
static int ipsec_validate_proto (u_int8_t);
static int ipsec_validate_situation (u_int8_t *, size_t *);
static int ipsec_validate_transform_id (u_int8_t, u_int8_t);

static struct doi ipsec_doi = {
  { 0 }, IPSEC_DOI_IPSEC,
  sizeof (struct ipsec_exch), sizeof (struct ipsec_sa),
  sizeof (struct ipsec_proto),
#ifdef USE_DEBUG
  ipsec_debug_attribute,
#endif
  ipsec_delete_spi,
  ipsec_exchange_script,
  ipsec_finalize_exchange,
  ipsec_free_exchange_data,
  ipsec_free_proto_data,
  ipsec_free_sa_data,
  ipsec_get_keystate,
  ipsec_get_spi,
  ipsec_handle_leftover_payload,
  ipsec_informational_post_hook,
  ipsec_informational_pre_hook,
  ipsec_is_attribute_incompatible,
  ipsec_proto_init,
  ipsec_setup_situation,
  ipsec_situation_size,
  ipsec_spi_size,
  ipsec_validate_attribute,
  ipsec_validate_exchange,
  ipsec_validate_id_information,
  ipsec_validate_key_information,
  ipsec_validate_notification,
  ipsec_validate_proto,
  ipsec_validate_situation,
  ipsec_validate_transform_id,
  ipsec_initiator,
  ipsec_responder,
  ipsec_decode_ids
};

int16_t script_quick_mode[] = {
  ISAKMP_PAYLOAD_HASH,		/* Initiator -> responder.  */
  ISAKMP_PAYLOAD_SA,
  ISAKMP_PAYLOAD_NONCE,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_HASH,		/* Responder -> initiator.  */
  ISAKMP_PAYLOAD_SA,
  ISAKMP_PAYLOAD_NONCE,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_HASH,		/* Initiator -> responder.  */
  EXCHANGE_SCRIPT_END
};

int16_t script_new_group_mode[] = {
  ISAKMP_PAYLOAD_HASH,		/* Initiator -> responder.  */
  ISAKMP_PAYLOAD_SA,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_HASH,		/* Responder -> initiator.  */
  ISAKMP_PAYLOAD_SA,
  EXCHANGE_SCRIPT_END
};

struct dst_spi_proto_arg {
  struct sockaddr *dst;
  u_int32_t spi;
  u_int8_t proto;
};

/*
 * Check if SA matches what we are asking for through V_ARG.  It has to
 * be a finished phase 2 SA.
 * if "proto" arg is 0, match any proto
 */
static int
ipsec_sa_check (struct sa *sa, void *v_arg)
{
  struct dst_spi_proto_arg *arg = v_arg;
  struct proto *proto;
  struct sockaddr *dst, *src;
  int incoming;

  if (sa->phase != 2 || !(sa->flags & SA_FLAG_READY))
    return 0;

  sa->transport->vtbl->get_dst (sa->transport, &dst);
  if (memcmp (sockaddr_addrdata (dst), sockaddr_addrdata (arg->dst),
	      sockaddr_addrlen (dst)) == 0)
    incoming = 0;
  else
    {
      sa->transport->vtbl->get_src (sa->transport, &src);
      if (memcmp (sockaddr_addrdata (src), sockaddr_addrdata (arg->dst),
		  sockaddr_addrlen (src)) == 0)
	incoming = 1;
      else
	return 0;
    }

  for (proto = TAILQ_FIRST (&sa->protos); proto;
       proto = TAILQ_NEXT (proto, link))
    if ((arg->proto == 0 || proto->proto == arg->proto)
       && memcmp (proto->spi[incoming], &arg->spi, sizeof arg->spi) == 0)
      return 1;
  return 0;
}

/* Find an SA with a "name" of DST, SPI & PROTO.  */
struct sa *
ipsec_sa_lookup (struct sockaddr *dst, u_int32_t spi, u_int8_t proto)
{
  struct dst_spi_proto_arg arg;

  arg.dst = dst;
  arg.spi = spi;
  arg.proto = proto;

  return sa_find (ipsec_sa_check, &arg);
}

/*
 * Check if SA matches the flow of another SA in V_ARG.  It has to
 * be a finished non-replaced phase 2 SA.
 * XXX At some point other selectors will matter here too.
 */
static int
ipsec_sa_check_flow (struct sa *sa, void *v_arg)
{
  struct sa *sa2 = v_arg;
  struct ipsec_sa *isa = sa->data, *isa2 = sa2->data;

  if (sa == sa2 || sa->phase != 2
      || (sa->flags & (SA_FLAG_READY | SA_FLAG_REPLACED)) != SA_FLAG_READY)
    return 0;

  if (isa->tproto != isa2->tproto || isa->sport != isa2->sport
      || isa->dport != isa2->dport)
    return 0;

  return isa->src_net->sa_family == isa2->src_net->sa_family
    && memcmp (sockaddr_addrdata (isa->src_net),
	       sockaddr_addrdata (isa2->src_net),
	       sockaddr_addrlen (isa->src_net)) == 0
    && memcmp (sockaddr_addrdata (isa->src_mask),
	       sockaddr_addrdata (isa2->src_mask),
	       sockaddr_addrlen (isa->src_mask)) == 0
    && memcmp (sockaddr_addrdata (isa->dst_net),
	       sockaddr_addrdata (isa2->dst_net),
	       sockaddr_addrlen (isa->dst_net)) == 0
    && memcmp (sockaddr_addrdata (isa->dst_mask),
	       sockaddr_addrdata (isa2->dst_mask),
	       sockaddr_addrlen (isa->dst_mask)) == 0;
}

/*
 * Do IPsec DOI specific finalizations task for the exchange where MSG was
 * the final message.
 */
static void
ipsec_finalize_exchange (struct message *msg)
{
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa;
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct sa *sa = 0, *old_sa;
  struct proto *proto, *last_proto = 0;
#ifdef USE_DEBUG
  char *addr1, *addr2, *mask1, *mask2;
#endif

  switch (exchange->phase)
    {
    case 1:
      switch (exchange->type)
	{
	case ISAKMP_EXCH_ID_PROT:
	case ISAKMP_EXCH_AGGRESSIVE:
	  isa = isakmp_sa->data;
	  isa->hash = ie->hash->type;
	  isa->prf_type = ie->prf_type;
	  isa->skeyid_len = ie->skeyid_len;
	  isa->skeyid_d = ie->skeyid_d;
	  isa->skeyid_a = ie->skeyid_a;
	  /* Prevents early free of SKEYID_*.  */
	  ie->skeyid_a = ie->skeyid_d = 0;

	  /* If a lifetime was negotiated setup the expiration timers.  */
	  if (isakmp_sa->seconds)
	    sa_setup_expirations (isakmp_sa);
	  break;
	}
      break;

    case 2:
      switch (exchange->type)
	{
	case IKE_EXCH_QUICK_MODE:
	  /*
	   * Tell the application(s) about the SPIs and key material.
	   */
	  for (sa = TAILQ_FIRST (&exchange->sa_list); sa;
	       sa = TAILQ_NEXT (sa, next))
	    {
	      isa = sa->data;

	      if (exchange->initiator)
		{
		  /* Initiator is source, responder is destination.  */
		  if (ipsec_set_network (ie->id_ci, ie->id_cr, isa))
		    {
		      log_error ("ipsec_finalize_exchange: "
				 "ipsec_set_network failed");
		      return;
		    }
		}
	      else
		{
		  /* Responder is source, initiator is destination.  */
		  if (ipsec_set_network (ie->id_cr, ie->id_ci, isa))
		    {
		      log_error ("ipsec_finalize_exchange: "
				 "ipsec_set_network failed");
		      return;
		    }
		}

	      for (proto = TAILQ_FIRST (&sa->protos), last_proto = 0; proto;
		   proto = TAILQ_NEXT (proto, link))
		{
		  if (sysdep_ipsec_set_spi (sa, proto, 0, isakmp_sa)
		      || (last_proto
			  && sysdep_ipsec_group_spis (sa, last_proto, proto,
						      0))
		      || sysdep_ipsec_set_spi (sa, proto, 1, isakmp_sa)
		      || (last_proto
			  && sysdep_ipsec_group_spis (sa, last_proto, proto,
						      1)))
		    /* XXX Tear down this exchange.  */
		    return;
		  last_proto = proto;
		}

#ifdef USE_DEBUG
	      if (sockaddr2text (isa->src_net, &addr1, 0))
		addr1 = 0;
	      if (sockaddr2text (isa->src_mask, &mask1, 0))
		mask1 = 0;
	      if (sockaddr2text (isa->dst_net, &addr2, 0))
		addr2 = 0;
	      if (sockaddr2text (isa->dst_mask, &mask2, 0))
		mask2 = 0;
		
	      LOG_DBG ((LOG_EXCHANGE, 50,
			"ipsec_finalize_exchange: "
			"src %s %s dst %s %s tproto %u sport %u dport %u",
			addr1 ? addr1 : "<??\?>" , mask1 ? mask1 : "<??\?>",
			addr2 ? addr2 : "<??\?>" , mask2 ? mask2 : "<??\?>",
			isa->tproto, ntohs (isa->sport), ntohs (isa->dport)));

	      if (addr1)
		free (addr1);
	      if (mask1)
		free (mask1);
	      if (addr2)
		free (addr2);
	      if (mask2)
		free (mask2);

#endif /* USE_DEBUG */

	      /*
	       * If this is not an SA acquired by the kernel, it needs
	       * to have a SPD entry (a.k.a. flow) set up.
	       */
	      if (!(sa->flags & SA_FLAG_ONDEMAND)
		  && sysdep_ipsec_enable_sa (sa, isakmp_sa))
		/* XXX Tear down this exchange.  */
		return;

	      /* Mark elder SAs with the same flow information as replaced.  */
	      while ((old_sa = sa_find (ipsec_sa_check_flow, sa)) != 0)
		sa_mark_replaced (old_sa);
	    }
	  break;
	}
    }
}

/* Set the client addresses in ISA from SRC_ID and DST_ID.  */
static int
ipsec_set_network (u_int8_t *src_id, u_int8_t *dst_id, struct ipsec_sa *isa)
{
  int id;

  /* Set source address/mask.  */
  id = GET_ISAKMP_ID_TYPE (src_id);
  switch (id)
    {
    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV4_ADDR_SUBNET:
      isa->src_net =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in));
      if (!isa->src_net)
	return -1;
      isa->src_net->sa_family = AF_INET;
#ifndef USE_OLD_SOCKADDR
      isa->src_net->sa_len = sizeof (struct sockaddr_in);
#endif

      isa->src_mask =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in));
      if (!isa->src_mask)
	return -1;
      isa->src_mask->sa_family = AF_INET;
#ifndef USE_OLD_SOCKADDR
      isa->src_mask->sa_len = sizeof (struct sockaddr_in);
#endif
      break;

    case IPSEC_ID_IPV6_ADDR:
    case IPSEC_ID_IPV6_ADDR_SUBNET:
      isa->src_net =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in6));
      if (!isa->src_net)
	return -1;
      isa->src_net->sa_family = AF_INET6;
#ifndef USE_OLD_SOCKADDR
      isa->src_net->sa_len = sizeof (struct sockaddr_in6);
#endif

      isa->src_mask =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in6));
      if (!isa->src_mask)
	return -1;
      isa->src_mask->sa_family = AF_INET6;
#ifndef USE_OLD_SOCKADDR
      isa->src_mask->sa_len = sizeof (struct sockaddr_in6);
#endif
      break;
    }

  /* Net */
  memcpy (sockaddr_addrdata (isa->src_net), src_id + ISAKMP_ID_DATA_OFF,
	  sockaddr_addrlen (isa->src_net));

  /* Mask */
  switch (id)
    {
    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV6_ADDR:
      memset (sockaddr_addrdata (isa->src_mask), 0xff,
	      sockaddr_addrlen (isa->src_mask));
      break;
    case IPSEC_ID_IPV4_ADDR_SUBNET:
    case IPSEC_ID_IPV6_ADDR_SUBNET:
      memcpy (sockaddr_addrdata (isa->src_mask), src_id + ISAKMP_ID_DATA_OFF +
	      sockaddr_addrlen (isa->src_net),
	      sockaddr_addrlen (isa->src_mask));
      break;
    }

  memcpy (&isa->sport, src_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	  IPSEC_ID_PORT_LEN);

  /* Set destination address.  */
  id = GET_ISAKMP_ID_TYPE (dst_id);
  switch (id)
    {
    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV4_ADDR_SUBNET:
      isa->dst_net =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in));
      if (!isa->dst_net)
	return -1;
      isa->dst_net->sa_family = AF_INET;
#ifndef USE_OLD_SOCKADDR
      isa->dst_net->sa_len = sizeof (struct sockaddr_in);
#endif

      isa->dst_mask =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in));
      if (!isa->dst_mask)
	return -1;
      isa->dst_mask->sa_family = AF_INET;
#ifndef USE_OLD_SOCKADDR
      isa->dst_mask->sa_len = sizeof (struct sockaddr_in);
#endif
      break;

    case IPSEC_ID_IPV6_ADDR:
    case IPSEC_ID_IPV6_ADDR_SUBNET:
      isa->dst_net =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in6));
      if (!isa->dst_net)
	return -1;
      isa->dst_net->sa_family = AF_INET6;
#ifndef USE_OLD_SOCKADDR
      isa->dst_net->sa_len = sizeof (struct sockaddr_in6);
#endif

      isa->dst_mask =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in6));
      if (!isa->dst_mask)
	return -1;
      isa->dst_mask->sa_family = AF_INET6;
#ifndef USE_OLD_SOCKADDR
      isa->dst_mask->sa_len = sizeof (struct sockaddr_in6);
#endif
      break;
    }

  /* Net */
  memcpy (sockaddr_addrdata (isa->dst_net), dst_id + ISAKMP_ID_DATA_OFF,
	  sockaddr_addrlen (isa->dst_net));

  /* Mask */
  switch (id)
    {
    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV6_ADDR:
      memset (sockaddr_addrdata (isa->dst_mask), 0xff,
	      sockaddr_addrlen (isa->dst_mask));
      break;
    case IPSEC_ID_IPV4_ADDR_SUBNET:
    case IPSEC_ID_IPV6_ADDR_SUBNET:
      memcpy (sockaddr_addrdata (isa->dst_mask), dst_id + ISAKMP_ID_DATA_OFF +
	      sockaddr_addrlen (isa->dst_net),
	      sockaddr_addrlen (isa->dst_mask));
      break;
    }

  memcpy (&isa->tproto, dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PROTO_OFF,
	  IPSEC_ID_PROTO_LEN);
  memcpy (&isa->dport, dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	  IPSEC_ID_PORT_LEN);
  return 0;
}

/* Free the DOI-specific exchange data pointed to by VIE.  */
static void
ipsec_free_exchange_data (void *vie)
{
  struct ipsec_exch *ie = vie;
#ifdef USE_ISAKMP_CFG
  struct isakmp_cfg_attr *attr;
#endif

  if (ie->sa_i_b)
    free (ie->sa_i_b);
  if (ie->id_ci)
    free (ie->id_ci);
  if (ie->id_cr)
    free (ie->id_cr);
  if (ie->g_xi)
    free (ie->g_xi);
  if (ie->g_xr)
    free (ie->g_xr);
  if (ie->g_xy)
    free (ie->g_xy);
  if (ie->skeyid)
    free (ie->skeyid);
  if (ie->skeyid_d)
    free (ie->skeyid_d);
  if (ie->skeyid_a)
    free (ie->skeyid_a);
  if (ie->skeyid_e)
    free (ie->skeyid_e);
  if (ie->hash_i)
    free (ie->hash_i);
  if (ie->hash_r)
    free (ie->hash_r);
  if (ie->group)
    group_free (ie->group);
#ifdef USE_ISAKMP_CFG
  for (attr = LIST_FIRST (&ie->attrs); attr; attr = LIST_FIRST (&ie->attrs))
    {
      LIST_REMOVE (attr, link);
      if (attr->length)
	free (attr->value);
      free (attr);
    }
#endif
}

/* Free the DOI-specific SA data pointed to by VISA.  */
static void
ipsec_free_sa_data (void *visa)
{
  struct ipsec_sa *isa = visa;

  if (isa->src_net)
    free (isa->src_net);
  if (isa->src_mask)
    free (isa->src_mask);
  if (isa->dst_net)
    free (isa->dst_net);
  if (isa->dst_mask)
    free (isa->dst_mask);
  if (isa->skeyid_a)
    free (isa->skeyid_a);
  if (isa->skeyid_d)
    free (isa->skeyid_d);
}

/* Free the DOI-specific protocol data of an SA pointed to by VIPROTO.  */
static void
ipsec_free_proto_data (void *viproto)
{
  struct ipsec_proto *iproto = viproto;
  int i;

  for (i = 0; i < 2; i++)
    if (iproto->keymat[i])
      free (iproto->keymat[i]);
}

/* Return exchange script based on TYPE.  */
static int16_t *
ipsec_exchange_script (u_int8_t type)
{
  switch (type)
    {
#ifdef USE_ISAKMP_CFG
    case ISAKMP_EXCH_TRANSACTION:
      return script_transaction;
#endif
    case IKE_EXCH_QUICK_MODE:
      return script_quick_mode;
    case IKE_EXCH_NEW_GROUP_MODE:
      return script_new_group_mode;
    }
  return 0;
}

/* Initialize this DOI, requires doi_init to already have been called.  */
void
ipsec_init (void)
{
  doi_register (&ipsec_doi);
}

/* Given a message MSG, return a suitable IV (or rather keystate).  */
static struct keystate *
ipsec_get_keystate (struct message *msg)
{
  struct keystate *ks;
  struct hash *hash;

  /* If we have already have an IV, use it.  */
  if (msg->exchange && msg->exchange->keystate)
    {
      ks = malloc (sizeof *ks);
      if (!ks)
	{
	  log_error ("ipsec_get_keystate: malloc (%lu) failed",
		(unsigned long)sizeof *ks);
	  return 0;
	}
      memcpy (ks, msg->exchange->keystate, sizeof *ks);
      return ks;
    }

  /*
   * For phase 2 when no SA yet is setup we need to hash the IV used by
   * the ISAKMP SA concatenated with the message ID, and use that as an
   * IV for further cryptographic operations.
   */
  if (!msg->isakmp_sa->keystate)
    {
      log_print ("ipsec_get_keystate: no keystate in ISAKMP SA %p",
		 msg->isakmp_sa);
      return 0;
    }
  ks = crypto_clone_keystate (msg->isakmp_sa->keystate);
  if (!ks)
    return 0;

  hash = hash_get (((struct ipsec_sa *)msg->isakmp_sa->data)->hash);
  hash->Init (hash->ctx);
  LOG_DBG_BUF ((LOG_CRYPTO, 80, "ipsec_get_keystate: final phase 1 IV",
		ks->riv, ks->xf->blocksize));
  hash->Update (hash->ctx, ks->riv, ks->xf->blocksize);
  LOG_DBG_BUF ((LOG_CRYPTO, 80, "ipsec_get_keystate: message ID",
		((u_int8_t *)msg->iov[0].iov_base)
		+ ISAKMP_HDR_MESSAGE_ID_OFF,
		ISAKMP_HDR_MESSAGE_ID_LEN));
  hash->Update (hash->ctx,
		((u_int8_t *)msg->iov[0].iov_base) + ISAKMP_HDR_MESSAGE_ID_OFF,
		ISAKMP_HDR_MESSAGE_ID_LEN);
  hash->Final (hash->digest, hash->ctx);
  crypto_init_iv (ks, hash->digest, ks->xf->blocksize);
  LOG_DBG_BUF ((LOG_CRYPTO, 80, "ipsec_get_keystate: phase 2 IV",
		hash->digest, ks->xf->blocksize));
  return ks;
}

static void
ipsec_setup_situation (u_int8_t *buf)
{
  SET_IPSEC_SIT_SIT (buf + ISAKMP_SA_SIT_OFF, IPSEC_SIT_IDENTITY_ONLY);
}

static size_t
ipsec_situation_size (void)
{
  return IPSEC_SIT_SIT_LEN;
}

static u_int8_t
ipsec_spi_size (u_int8_t proto)
{
  return IPSEC_SPI_SIZE;
}

static int
ipsec_validate_attribute (u_int16_t type, u_int8_t *value, u_int16_t len,
			  void *vmsg)
{
  struct message *msg = vmsg;

  if ((msg->exchange->phase == 1
       && (type < IKE_ATTR_ENCRYPTION_ALGORITHM
	   || type > IKE_ATTR_GROUP_ORDER))
      || (msg->exchange->phase == 2
	  && (type < IPSEC_ATTR_SA_LIFE_TYPE
	      || type > IPSEC_ATTR_ECN_TUNNEL)))
    return -1;
  return 0;
}

static int
ipsec_validate_exchange (u_int8_t exch)
{
  return exch != IKE_EXCH_QUICK_MODE && exch != IKE_EXCH_NEW_GROUP_MODE;
}

static int
ipsec_validate_id_information (u_int8_t type, u_int8_t *extra, u_int8_t *buf,
			       size_t sz, struct exchange *exchange)
{
  u_int8_t proto = GET_IPSEC_ID_PROTO (extra);
  u_int16_t port = GET_IPSEC_ID_PORT (extra);

  LOG_DBG ((LOG_MESSAGE, 0,
	    "ipsec_validate_id_information: proto %d port %d type %d",
	    proto, port, type));
  if (type < IPSEC_ID_IPV4_ADDR || type > IPSEC_ID_KEY_ID)
    return -1;

  switch (type)
    {
    case IPSEC_ID_IPV4_ADDR:
      LOG_DBG_BUF ((LOG_MESSAGE, 40, "ipsec_validate_id_information: IPv4",
		    buf, sizeof (struct in_addr)));
      break;

    case IPSEC_ID_IPV6_ADDR:
      LOG_DBG_BUF ((LOG_MESSAGE, 40, "ipsec_validate_id_information: IPv6",
		    buf, sizeof (struct in6_addr)));
      break;

    case IPSEC_ID_IPV4_ADDR_SUBNET:
      LOG_DBG_BUF ((LOG_MESSAGE, 40,
		    "ipsec_validate_id_information: IPv4 network/netmask",
		    buf, 2 * sizeof (struct in_addr)));
      break;

    case IPSEC_ID_IPV6_ADDR_SUBNET:
      LOG_DBG_BUF ((LOG_MESSAGE, 40,
		    "ipsec_validate_id_information: IPv6 network/netmask",
		    buf, 2 * sizeof (struct in6_addr)));
      break;

    default:
      break;
    }

  if (exchange->phase == 1
      && (proto != IPPROTO_UDP || port != UDP_DEFAULT_PORT)
      && (proto != 0 || port != 0))
    {
/* XXX SSH's ISAKMP tester fails this test (proto 17 - port 0).  */
#ifdef notyet
      return -1;
#else
      log_print ("ipsec_validate_id_information: "
		 "dubious ID information accepted");
#endif
    }

  /* XXX More checks?  */

  return 0;
}

static int
ipsec_validate_key_information (u_int8_t *buf, size_t sz)
{
  /* XXX Not implemented yet.  */
  return 0;
}

static int
ipsec_validate_notification (u_int16_t type)
{
  return type < IPSEC_NOTIFY_RESPONDER_LIFETIME
    || type > IPSEC_NOTIFY_INITIAL_CONTACT ? -1 : 0;
}

static int
ipsec_validate_proto (u_int8_t proto)
{
  return proto < IPSEC_PROTO_IPSEC_AH || proto > IPSEC_PROTO_IPCOMP ? -1 : 0;
}

static int
ipsec_validate_situation (u_int8_t *buf, size_t *sz)
{
  int sit = GET_IPSEC_SIT_SIT (buf);
  int off;

  if (sit & (IPSEC_SIT_SECRECY | IPSEC_SIT_INTEGRITY))
    {
      /*
       * XXX All the roundups below, round up to 32 bit boundaries given
       * that the situation field is aligned.  This is not necessarily so,
       * but I interpret the drafts as this is like this they want it.
       */
      off = ROUNDUP_32 (GET_IPSEC_SIT_SECRECY_LENGTH (buf));
      off += ROUNDUP_32 (GET_IPSEC_SIT_SECRECY_CAT_LENGTH (buf + off));
      off += ROUNDUP_32 (GET_IPSEC_SIT_INTEGRITY_LENGTH (buf + off));
      off += ROUNDUP_32 (GET_IPSEC_SIT_INTEGRITY_CAT_LENGTH (buf + off));
      *sz = off + IPSEC_SIT_SZ;
    }
  else
    *sz = IPSEC_SIT_SIT_LEN;

  /* Currently only "identity only" situations are supported.  */
#ifdef notdef
  return
    sit & ~(IPSEC_SIT_IDENTITY_ONLY | IPSEC_SIT_SECRECY | IPSEC_SIT_INTEGRITY);
#else
   return sit & ~IPSEC_SIT_IDENTITY_ONLY;
#endif
    return 1;
  return 0;
}

static int
ipsec_validate_transform_id (u_int8_t proto, u_int8_t transform_id)
{
  switch (proto)
    {
      /*
       * As no unexpected protocols can occur, we just tie the default case
       * to the first case, in orer to silence a GCC warning.
       */
    default:
    case ISAKMP_PROTO_ISAKMP:
      return transform_id != IPSEC_TRANSFORM_KEY_IKE;
    case IPSEC_PROTO_IPSEC_AH:
      return
	transform_id < IPSEC_AH_MD5 || transform_id > IPSEC_AH_DES ? -1 : 0;
    case IPSEC_PROTO_IPSEC_ESP:
      return transform_id < IPSEC_ESP_DES_IV64
	|| (transform_id > IPSEC_ESP_AES && transform_id < IPSEC_ESP_AES_MARS)
	|| transform_id > IPSEC_ESP_AES_TWOFISH ? -1 : 0;
    case IPSEC_PROTO_IPCOMP:
      return transform_id < IPSEC_IPCOMP_OUI
	|| transform_id > IPSEC_IPCOMP_V42BIS ? -1 : 0;
    }
}

static int
ipsec_initiator (struct message *msg)
{
  struct exchange *exchange = msg->exchange;
  int (**script) (struct message *) = 0;

  /* Check that the SA is coherent with the IKE rules.  */
  if (exchange->type != ISAKMP_EXCH_TRANSACTION
      && ((exchange->phase == 1 && exchange->type != ISAKMP_EXCH_ID_PROT
	   && exchange->type != ISAKMP_EXCH_AGGRESSIVE
	   && exchange->type != ISAKMP_EXCH_INFO)
	  || (exchange->phase == 2 && exchange->type != IKE_EXCH_QUICK_MODE
	      && exchange->type != ISAKMP_EXCH_INFO)))
    {
      log_print ("ipsec_initiator: unsupported exchange type %d in phase %d",
		 exchange->type, exchange->phase);
      return -1;
    }

  switch (exchange->type)
    {
    case ISAKMP_EXCH_ID_PROT:
      script = ike_main_mode_initiator;
      break;
#ifdef USE_AGGRESSIVE
    case ISAKMP_EXCH_AGGRESSIVE:
      script = ike_aggressive_initiator;
      break;
#endif
#ifdef USE_ISAKMP_CFG
    case ISAKMP_EXCH_TRANSACTION:
      script = isakmp_cfg_initiator;
      break;
#endif
    case ISAKMP_EXCH_INFO:
      return message_send_info (msg);
    case IKE_EXCH_QUICK_MODE:
      script = ike_quick_mode_initiator;
      break;
    default:
      log_print ("ipsec_initiator: unsupported exchange type %d",
		 exchange->type);
      return -1;
    }

  /* Run the script code for this step.  */
  if (script)
    return script[exchange->step] (msg);

  return 0;
}

/*
 * delete all SA's from addr with the associated proto and SPI's
 *
 * spis[] is an array of SPIs of size 16-octet for proto ISAKMP
 * or 4-octet otherwise.
 */
static void
ipsec_delete_spi_list (struct sockaddr *addr, u_int8_t proto,
                       u_int8_t *spis, int nspis, char *type)
{
  struct sa *sa;
  int i;

  for (i = 0; i < nspis; i++)
    {
      if (proto == ISAKMP_PROTO_ISAKMP)
        {
          u_int8_t *spi = spis + i * ISAKMP_HDR_COOKIES_LEN;

          /*
           * This really shouldn't happen in IPSEC DOI
           * code, but Cisco VPN 3000 sends ISAKMP DELETE's
           * this way.
           */
          sa = sa_lookup_isakmp_sa (addr, spi);
        }
      else
        {
          u_int32_t spi = ((u_int32_t *)spis)[i];

          sa = ipsec_sa_lookup (addr, spi, proto);
        }

      if (sa == NULL)
        {
	  LOG_DBG ((LOG_SA, 30, "ipsec_delete_spi_list: "
		   "could not locate SA (SPI %08x, proto %u)",
		   spis[i], proto));
	  continue;
	}

      /* Delete the SA and search for the next */
      LOG_DBG ((LOG_SA, 30, "ipsec_delete_spi_list: "
	       "%s made us delete SA %p (%d references) for proto %d",
	       type, sa, sa->refcnt, proto));

      sa_free (sa);
    }
}

/*
 * deal with a NOTIFY of INVALID_SPI
 */
static void
ipsec_invalid_spi (struct message *msg, struct payload *p)
{
  struct sockaddr *dst;
  int invspisz, off;
  u_int32_t spi;
  u_int16_t totsiz;
  u_int8_t spisz;

  /*
   * get the invalid spi out of the variable sized notification data
   * field, which is after the variable sized SPI field [which specifies
   * the receiving entity's phase-1 SPI, not the invalid spi]
   */
  totsiz = GET_ISAKMP_GEN_LENGTH (p->p);
  spisz = GET_ISAKMP_NOTIFY_SPI_SZ (p->p);
  off = ISAKMP_NOTIFY_SPI_OFF + spisz;
  invspisz = totsiz - off;

  if (invspisz != sizeof spi)
    {
      LOG_DBG ((LOG_SA, 40,
	       "ipsec_invalid_spi: SPI size %d in INVALID_SPI "
	       "payload unsupported", spisz));
       return;
    }
  memcpy (&spi, p->p + off, sizeof spi);

  msg->transport->vtbl->get_dst (msg->transport, &dst);

  /* delete matching SPI's from this peer */
  ipsec_delete_spi_list (dst, 0, (u_int8_t *)&spi, 1, "INVALID_SPI");
}

static int
ipsec_responder (struct message *msg)
{
  struct exchange *exchange = msg->exchange;
  int (**script) (struct message *) = 0;
  struct payload *p;
  u_int16_t type;

  /* Check that a new exchange is coherent with the IKE rules.  */
  if (exchange->step == 0 && exchange->type != ISAKMP_EXCH_TRANSACTION
      && ((exchange->phase == 1 && exchange->type != ISAKMP_EXCH_ID_PROT
	   && exchange->type != ISAKMP_EXCH_AGGRESSIVE
	   && exchange->type != ISAKMP_EXCH_INFO)
	  || (exchange->phase == 2 && exchange->type == ISAKMP_EXCH_ID_PROT)))
    {
      message_drop (msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE, 0, 1, 0);
      return -1;
    }

  LOG_DBG ((LOG_MISC, 30,
	    "ipsec_responder: phase %d exchange %d step %d", exchange->phase,
	    exchange->type, exchange->step));
  switch (exchange->type)
    {
    case ISAKMP_EXCH_ID_PROT:
      script = ike_main_mode_responder;
      break;

#ifdef USE_AGGRESSIVE
    case ISAKMP_EXCH_AGGRESSIVE:
      script = ike_aggressive_responder;
      break;
#endif

#ifdef USE_ISAKMP_CFG
    case ISAKMP_EXCH_TRANSACTION:
      script = isakmp_cfg_responder;
      break;
#endif

    case ISAKMP_EXCH_INFO:
      for (p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_NOTIFY]); p;
	   p = TAILQ_NEXT (p, link))
	{
          type = GET_ISAKMP_NOTIFY_MSG_TYPE (p->p);
	  LOG_DBG ((LOG_EXCHANGE, 10,
		    "ipsec_responder: got NOTIFY of type %s",
		    constant_lookup (isakmp_notify_cst, type)));

          if (type == ISAKMP_NOTIFY_INVALID_SPI)
              ipsec_invalid_spi (msg, p);

	  p->flags |= PL_MARK;
	}

      /*
       * If any DELETEs are in here, let the logic of leftover payloads deal
       * with them.
       */

      return 0;

    case IKE_EXCH_QUICK_MODE:
      script = ike_quick_mode_responder;
      break;

    default:
      message_drop (msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE, 0, 1, 0);
      return -1;
    }

  /* Run the script code for this step.  */
  if (script)
    return script[exchange->step] (msg);

  /*
   * XXX So far we don't accept any proposals for exchanges we don't support.
   */
  if (TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_SA]))
    {
      message_drop (msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
      return -1;
    }
  return 0;
}

static enum hashes from_ike_hash (u_int16_t hash)
{
  switch (hash)
    {
    case IKE_HASH_MD5:
      return HASH_MD5;
    case IKE_HASH_SHA:
      return HASH_SHA1;
    }
  return -1;
}

static enum transform from_ike_crypto (u_int16_t crypto)
{
  /* Coincidentally this is the null operation :-)  */
  return crypto;
}

/*
 * Find out whether the attribute of type TYPE with a LEN length value
 * pointed to by VALUE is incompatible with what we can handle.
 * VMSG is a pointer to the current message.
 */
int
ipsec_is_attribute_incompatible (u_int16_t type, u_int8_t *value,
				 u_int16_t len, void *vmsg)
{
  struct message *msg = vmsg;

  if (msg->exchange->phase == 1)
    {
      switch (type)
	{
	case IKE_ATTR_ENCRYPTION_ALGORITHM:
	  return !crypto_get (from_ike_crypto (decode_16 (value)));
	case IKE_ATTR_HASH_ALGORITHM:
	  return !hash_get (from_ike_hash (decode_16 (value)));
	case IKE_ATTR_AUTHENTICATION_METHOD:
	  return !ike_auth_get (decode_16 (value));
	case IKE_ATTR_GROUP_DESCRIPTION:
	  return decode_16 (value) < IKE_GROUP_DESC_MODP_768
	    || decode_16 (value) > IKE_GROUP_DESC_MODP_1536;
	case IKE_ATTR_GROUP_TYPE:
	  return 1;
	case IKE_ATTR_GROUP_PRIME:
	  return 1;
	case IKE_ATTR_GROUP_GENERATOR_1:
	  return 1;
	case IKE_ATTR_GROUP_GENERATOR_2:
	  return 1;
	case IKE_ATTR_GROUP_CURVE_A:
	  return 1;
	case IKE_ATTR_GROUP_CURVE_B:
	  return 1;
	case IKE_ATTR_LIFE_TYPE:
	  return decode_16 (value) < IKE_DURATION_SECONDS
	    || decode_16 (value) > IKE_DURATION_KILOBYTES;
	case IKE_ATTR_LIFE_DURATION:
	  return len != 2 && len != 4;
	case IKE_ATTR_PRF:
	  return 1;
	case IKE_ATTR_KEY_LENGTH:
	  /*
	   * Our crypto routines only allows key-lengths which are multiples
	   * of an octet.
	   */
	  return decode_16 (value) % 8 != 0;
	case IKE_ATTR_FIELD_SIZE:
	  return 1;
	case IKE_ATTR_GROUP_ORDER:
	  return 1;
	}
    }
  else
    {
      switch (type)
	{
	case IPSEC_ATTR_SA_LIFE_TYPE:
	  return decode_16 (value) < IPSEC_DURATION_SECONDS
	    || decode_16 (value) > IPSEC_DURATION_KILOBYTES;
	case IPSEC_ATTR_SA_LIFE_DURATION:
	  return len != 2 && len != 4;
	case IPSEC_ATTR_GROUP_DESCRIPTION:
	  return decode_16 (value) < IKE_GROUP_DESC_MODP_768
	    || decode_16 (value) > IKE_GROUP_DESC_MODP_1536;
	case IPSEC_ATTR_ENCAPSULATION_MODE:
	  return decode_16 (value) < IPSEC_ENCAP_TUNNEL
	    || decode_16 (value) > IPSEC_ENCAP_TRANSPORT;
	case IPSEC_ATTR_AUTHENTICATION_ALGORITHM:
	  return decode_16 (value) < IPSEC_AUTH_HMAC_MD5
	    || decode_16 (value) > IPSEC_AUTH_KPDK;
	case IPSEC_ATTR_KEY_LENGTH:
	  /* XXX Blowfish needs '0'. Others appear to disregard this attr?  */
	  return 0;
	case IPSEC_ATTR_KEY_ROUNDS:
	  return 1;
	case IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE:
	  return 1;
	case IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM:
	  return 1;
	case IPSEC_ATTR_ECN_TUNNEL:
	  return 1;
	}
    }
  /* XXX Silence gcc.  */
  return 1;
}

#ifdef USE_DEBUG
/*
 * Log the attribute of TYPE with a LEN length value pointed to by VALUE
 * in human-readable form.  VMSG is a pointer to the current message.
 */
int
ipsec_debug_attribute (u_int16_t type, u_int8_t *value, u_int16_t len,
		       void *vmsg)
{
  struct message *msg = vmsg;
  char val[20];

  /* XXX Transient solution.  */
  if (len == 2)
    snprintf (val, 20, "%d", decode_16 (value));
  else if (len == 4)
    snprintf (val, 20, "%d", decode_32 (value));
  else
    snprintf (val, 20, "unrepresentable");

  LOG_DBG ((LOG_MESSAGE, 50, "Attribute %s value %s",
	    constant_name (msg->exchange->phase == 1
			   ? ike_attr_cst : ipsec_attr_cst, type),
	    val));
  return 0;
}
#endif

/*
 * Decode the attribute of type TYPE with a LEN length value pointed to by
 * VALUE.  VIDA is a pointer to a context structure where we can find the
 * current message, SA and protocol.
 */
int
ipsec_decode_attribute (u_int16_t type, u_int8_t *value, u_int16_t len,
			void *vida)
{
  struct ipsec_decode_arg *ida = vida;
  struct message *msg = ida->msg;
  struct sa *sa = ida->sa;
  struct ipsec_sa *isa = sa->data;
  struct proto *proto = ida->proto;
  struct ipsec_proto *iproto = proto->data;
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  static int lifetype = 0;

  if (exchange->phase == 1)
    {
      switch (type)
	{
	case IKE_ATTR_ENCRYPTION_ALGORITHM:
	  /* XXX Errors possible?  */
	  exchange->crypto = crypto_get (from_ike_crypto (decode_16 (value)));
	  break;
	case IKE_ATTR_HASH_ALGORITHM:
	  /* XXX Errors possible?  */
	  ie->hash = hash_get (from_ike_hash (decode_16 (value)));
	  break;
	case IKE_ATTR_AUTHENTICATION_METHOD:
	  /* XXX Errors possible?  */
	  ie->ike_auth = ike_auth_get (decode_16 (value));
	  break;
	case IKE_ATTR_GROUP_DESCRIPTION:
	  isa->group_desc = decode_16 (value);
	  break;
	case IKE_ATTR_GROUP_TYPE:
	  break;
	case IKE_ATTR_GROUP_PRIME:
	  break;
	case IKE_ATTR_GROUP_GENERATOR_1:
	  break;
	case IKE_ATTR_GROUP_GENERATOR_2:
	  break;
	case IKE_ATTR_GROUP_CURVE_A:
	  break;
	case IKE_ATTR_GROUP_CURVE_B:
	  break;
	case IKE_ATTR_LIFE_TYPE:
	  lifetype = decode_16 (value);
	  return 0;
	case IKE_ATTR_LIFE_DURATION:
	  switch (lifetype)
	    {
	    case IKE_DURATION_SECONDS:
	      switch (len)
		{
		case 2:
		  sa->seconds = decode_16 (value);
		  break;
		case 4:
		  sa->seconds = decode_32 (value);
		  break;
		default:
		  log_print ("ipsec_decode_attribute: unreasonable lifetime");
		}
	      break;
	    case IKE_DURATION_KILOBYTES:
	      switch (len)
		{
		case 2:
		  sa->kilobytes = decode_16 (value);
		  break;
		case 4:
		  sa->kilobytes = decode_32 (value);
		  break;
		default:
		  log_print ("ipsec_decode_attribute: unreasonable lifetime");
		}
	      break;
	    default:
	      log_print ("ipsec_decode_attribute: unknown lifetime type");
	    }
	  break;
	case IKE_ATTR_PRF:
	  break;
	case IKE_ATTR_KEY_LENGTH:
	  exchange->key_length = decode_16 (value) / 8;
	  break;
	case IKE_ATTR_FIELD_SIZE:
	  break;
	case IKE_ATTR_GROUP_ORDER:
	  break;
	}
    }
  else
    {
      switch (type)
	{
	case IPSEC_ATTR_SA_LIFE_TYPE:
	  lifetype = decode_16 (value);
	  return 0;
	case IPSEC_ATTR_SA_LIFE_DURATION:
	  switch (lifetype)
	    {
	    case IPSEC_DURATION_SECONDS:
	      switch (len)
		{
		case 2:
		  sa->seconds = decode_16 (value);
		  break;
		case 4:
		  sa->seconds = decode_32 (value);
		  break;
		default:
		  log_print ("ipsec_decode_attribute: unreasonable lifetime");
		}
	      break;
	    case IPSEC_DURATION_KILOBYTES:
	      switch (len)
		{
		case 2:
		  sa->kilobytes = decode_16 (value);
		  break;
		case 4:
		  sa->kilobytes = decode_32 (value);
		  break;
		default:
		  log_print ("ipsec_decode_attribute: unreasonable lifetime");
		}
	      break;
	    default:
	      log_print ("ipsec_decode_attribute: unknown lifetime type");
	    }
	  break;
	case IPSEC_ATTR_GROUP_DESCRIPTION:
	  isa->group_desc = decode_16 (value);
	  break;
	case IPSEC_ATTR_ENCAPSULATION_MODE:
	  /* XXX Multiple protocols must have same encapsulation mode, no?  */
	  iproto->encap_mode = decode_16 (value);
	  break;
	case IPSEC_ATTR_AUTHENTICATION_ALGORITHM:
	  iproto->auth = decode_16 (value);
	  break;
	case IPSEC_ATTR_KEY_LENGTH:
	  iproto->keylen = decode_16 (value);
	  break;
	case IPSEC_ATTR_KEY_ROUNDS:
	  iproto->keyrounds = decode_16 (value);
	  break;
	case IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE:
	  break;
	case IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM:
	  break;
	case IPSEC_ATTR_ECN_TUNNEL:
	  break;
	}
    }
  lifetype = 0;
  return 0;
}

/*
 * Walk over the attributes of the transform payload found in BUF, and
 * fill out the fields of the SA attached to MSG.  Also mark the SA as
 * processed.
 */
void
ipsec_decode_transform (struct message *msg, struct sa *sa,
			struct proto *proto, u_int8_t *buf)
{
  struct ipsec_exch *ie = msg->exchange->data;
  struct ipsec_decode_arg ida;

  LOG_DBG ((LOG_MISC, 20, "ipsec_decode_transform: transform %d chosen",
	    GET_ISAKMP_TRANSFORM_NO (buf)));

  ida.msg = msg;
  ida.sa = sa;
  ida.proto = proto;

  /* The default IKE lifetime is 8 hours.  */
  if (sa->phase == 1)
    sa->seconds = 28800;

  /* Extract the attributes and stuff them into the SA.  */
  attribute_map (buf + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		 GET_ISAKMP_GEN_LENGTH (buf) - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		 ipsec_decode_attribute, &ida);

  /*
   * If no pseudo-random function was negotiated, it's HMAC.
   * XXX As PRF_HMAC currently is zero, this is a no-op.
   */
  if (!ie->prf_type)
    ie->prf_type = PRF_HMAC;
}

/*
 * Delete the IPsec SA represented by the INCOMING direction in protocol PROTO
 * of the IKE security association SA.
 */
static void
ipsec_delete_spi (struct sa *sa, struct proto *proto, int incoming)
{
  if (sa->phase == 1)
    return;
  /* XXX Error handling?  Is it interesting?  */
  sysdep_ipsec_delete_spi (sa, proto, incoming);
}

/*
 * Store BUF into the g^x entry of the exchange that message MSG belongs to.
 * PEER is non-zero when the value is our peer's, and zero when it is ours.
 */
static int
ipsec_g_x (struct message *msg, int peer, u_int8_t *buf)
{
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  u_int8_t **g_x;
  int initiator = exchange->initiator ^ peer;
  char header[32];

  g_x = initiator ? &ie->g_xi : &ie->g_xr;
  *g_x = malloc (ie->g_x_len);
  if (!*g_x)
    {
      log_error ("ipsec_g_x: malloc (%lu) failed", (unsigned long)ie->g_x_len);
      return -1;
    }
  memcpy (*g_x, buf, ie->g_x_len);
  snprintf (header, 32, "ipsec_g_x: g^x%c", initiator ? 'i' : 'r');
  LOG_DBG_BUF ((LOG_MISC, 80, header, *g_x, ie->g_x_len));
  return 0;
}

/* Generate our DH value.  */
int
ipsec_gen_g_x (struct message *msg)
{
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  u_int8_t *buf;

  buf = malloc (ISAKMP_KE_SZ + ie->g_x_len);
  if (!buf)
    {
      log_error ("ipsec_gen_g_x: malloc (%lu) failed",
		 ISAKMP_KE_SZ + (unsigned long)ie->g_x_len);
      return -1;
    }

  if (message_add_payload (msg, ISAKMP_PAYLOAD_KEY_EXCH, buf,
			   ISAKMP_KE_SZ + ie->g_x_len, 1))
    {
      free (buf);
      return -1;
    }

  if (dh_create_exchange (ie->group, buf + ISAKMP_KE_DATA_OFF))
    {
      log_print ("ipsec_gen_g_x: dh_create_exchange failed");
      free (buf);
      return -1;
    }
  return ipsec_g_x (msg, 0, buf + ISAKMP_KE_DATA_OFF);
}

/* Save the peer's DH value.  */
int
ipsec_save_g_x (struct message *msg)
{
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct payload *kep;

  kep = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_KEY_EXCH]);
  kep->flags |= PL_MARK;
  ie->g_x_len = GET_ISAKMP_GEN_LENGTH (kep->p) - ISAKMP_KE_DATA_OFF;

  /* Check that the given length matches the group's expectancy.  */
  if (ie->g_x_len != dh_getlen (ie->group))
    {
      /* XXX Is this a good notify type?  */
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
      return -1;
    }

  return ipsec_g_x (msg, 1, kep->p + ISAKMP_KE_DATA_OFF);
}

/*
 * Get a SPI for PROTO and the transport MSG passed over.  Store the
 * size where SZ points.  NB!  A zero return is OK if *SZ is zero.
 */
static u_int8_t *
ipsec_get_spi (size_t *sz, u_int8_t proto, struct message *msg)
{
  struct sockaddr *dst, *src;
  struct transport *transport = msg->transport;

  if (msg->exchange->phase == 1)
    {
      *sz = 0;
      return 0;
    }
  else
    {
      /* We are the destination in the SA we want a SPI for.  */
      transport->vtbl->get_src (transport, &dst);
      /* The peer is the source.  */
      transport->vtbl->get_dst (transport, &src);
      return sysdep_ipsec_get_spi (sz, proto, src, dst, msg->exchange->seq);
    }
}

/*
 * We have gotten a payload PAYLOAD of type TYPE, which did not get handled
 * by the logic of the exchange MSG takes part in.  Now is the time to deal
 * with such a payload if we know how to, if we don't, return -1, otherwise
 * 0.
 */
int
ipsec_handle_leftover_payload (struct message *msg, u_int8_t type,
			       struct payload *payload)
{
  u_int32_t spisz, nspis;
  struct sockaddr *dst;
  int reenter = 0;
  u_int8_t *spis, proto;
  struct sa *sa;

  switch (type)
    {
    case ISAKMP_PAYLOAD_DELETE:
      proto = GET_ISAKMP_DELETE_PROTO (payload->p);
      nspis = GET_ISAKMP_DELETE_NSPIS (payload->p);
      spisz = GET_ISAKMP_DELETE_SPI_SZ (payload->p);

      if (nspis == 0)
        {
	  LOG_DBG ((LOG_SA, 60, "ipsec_handle_leftover_payload: message "
		    "specified zero SPIs, ignoring"));
	  return -1;
	}

      /* verify proper SPI size */
      if ((proto == ISAKMP_PROTO_ISAKMP && spisz != ISAKMP_HDR_COOKIES_LEN)
          || (proto != ISAKMP_PROTO_ISAKMP && spisz != sizeof (u_int32_t)))
        {
	  log_print ("ipsec_handle_leftover_payload: "
		     "invalid SPI size %d for proto %d in DELETE payload",
		     spisz, proto);
	  return -1;
        }

      spis = (u_int8_t *)malloc (nspis * spisz);
      if (!spis)
        {
	  log_error ("ipsec_handle_leftover_payload: malloc (%d) failed",
		     nspis * spisz);
	  return -1;
	}

      /* extract SPI and get dst address */
      memcpy (spis, payload->p + ISAKMP_DELETE_SPI_OFF, nspis * spisz);
      msg->transport->vtbl->get_dst (msg->transport, &dst);

      ipsec_delete_spi_list (dst, proto, spis, nspis, "DELETE");

      free (spis);
      payload->flags |= PL_MARK;
      return 0;

    case ISAKMP_PAYLOAD_NOTIFY:
      switch (GET_ISAKMP_NOTIFY_MSG_TYPE (payload->p))
	{
	case IPSEC_NOTIFY_INITIAL_CONTACT:
	  /*
	   * Find out who is sending this and then delete every SA that is
	   * ready.  Exchanges will timeout themselves and then the
	   * non-ready SAs will disappear too.
	   */
	  msg->transport->vtbl->get_dst (msg->transport, &dst);
	  while ((sa = sa_lookup_by_peer (dst, sysdep_sa_len (dst))) != 0)
	    {
	      /*
	       * Don't delete the current SA -- we received the notification
	       * over it, so it's obviously still active. We temporarily need
               * to remove the SA from the list to avoid an endless loop,
	       * but keep a reference so it won't disappear meanwhile.
	       */
	      if (sa == msg->isakmp_sa)
	        {
		  sa_reference (sa);
                  sa_remove (sa);
                  reenter = 1;
		  continue;
		}

	      LOG_DBG ((LOG_SA, 30,
			"ipsec_handle_leftover_payload: "
			"INITIAL-CONTACT made us delete SA %p",
			sa));
	      sa_delete (sa, 0);
	    }

          if (reenter)
	    {
	      sa_enter (msg->isakmp_sa);
	      sa_release (msg->isakmp_sa);
	    }
	  payload->flags |= PL_MARK;
	  return 0;
	}
    }
  return -1;
}

/* Return the encryption keylength in octets of the ESP protocol PROTO.  */
int
ipsec_esp_enckeylength (struct proto *proto)
{
  struct ipsec_proto *iproto = proto->data;

  /* Compute the keylength to use.  */
  switch (proto->id)
    {
    case IPSEC_ESP_DES:
    case IPSEC_ESP_DES_IV32:
    case IPSEC_ESP_DES_IV64:
      return 8;
    case IPSEC_ESP_3DES:
      return 24;
    case IPSEC_ESP_CAST:
      if (!iproto->keylen)
        return 16;
      return iproto->keylen / 8;
    case IPSEC_ESP_AES:
      if (!iproto->keylen)
	return 16;
      /* Fallthrough */
    default:
      return iproto->keylen / 8;
    }
}

/* Return the authentication keylength in octets of the ESP protocol PROTO.  */
int
ipsec_esp_authkeylength (struct proto *proto)
{
  struct ipsec_proto *iproto = proto->data;

  switch (iproto->auth)
    {
    case IPSEC_AUTH_HMAC_MD5:
      return 16;
    case IPSEC_AUTH_HMAC_SHA:
    case IPSEC_AUTH_HMAC_RIPEMD:
      return 20;
    default:
      return 0;
    }
}

/* Return the authentication keylength in octets of the AH protocol PROTO.  */
int
ipsec_ah_keylength (struct proto *proto)
{
  switch (proto->id)
    {
    case IPSEC_AH_MD5:
      return 16;
    case IPSEC_AH_SHA:
    case IPSEC_AH_RIPEMD:
      return 20;
    default:
      return -1;
    }
}

/* Return the total keymaterial length of the protocol PROTO.  */
int
ipsec_keymat_length (struct proto *proto)
{
  switch (proto->proto)
    {
    case IPSEC_PROTO_IPSEC_ESP:
      return ipsec_esp_enckeylength (proto) + ipsec_esp_authkeylength (proto);
    case IPSEC_PROTO_IPSEC_AH:
      return ipsec_ah_keylength (proto);
    default:
      return -1;
    }
}

/*
 * Out of a named section SECTION in the configuration file find out
 * the network address and mask as well as the ID type.  Put the info
 * in the areas pointed to by ADDR, MASK, TPROTO, PORT, and ID respectively.
 * Return 0 on success and -1 on failure.
 */
int
ipsec_get_id (char *section, int *id, struct sockaddr **addr,
	      struct sockaddr **mask, u_int8_t *tproto, u_int16_t *port)
{
  char *type, *address, *netmask;

  type = conf_get_str (section, "ID-type");
  if (!type)
    {
      log_print ("ipsec_get_id: section %s has no \"ID-type\" tag", section);
      return -1;
    }

  *id = constant_value (ipsec_id_cst, type);
  switch (*id)
    {
    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV6_ADDR:
      address = conf_get_str (section, "Address");
      if (!address)
	{
	  log_print ("ipsec_get_id: section %s has no \"Address\" tag",
		     section);
	  return -1;
	}

      if (text2sockaddr (address, NULL, addr))
	{
	  log_print ("ipsec_get_id: invalid address %s in section %s", address,
		     section);
	  return -1;
	}

      *tproto = conf_get_num (section, "Protocol", 0);
      if (*tproto)
	*port = conf_get_num (section, "Port", 0);
      break;

#ifdef notyet
    case IPSEC_ID_FQDN:
      return -1;

    case IPSEC_ID_USER_FQDN:
      return -1;
#endif

    case IPSEC_ID_IPV4_ADDR_SUBNET:
    case IPSEC_ID_IPV6_ADDR_SUBNET:
      address = conf_get_str (section, "Network");
      if (!address)
	{
	  log_print ("ipsec_get_id: section %s has no \"Network\" tag",
		     section);
	  return -1;
	}

      if (text2sockaddr (address, NULL, addr))
	{
	  log_print ("ipsec_get_id: invalid section %s network %s", section,
		     address);
	  return -1;
	}

      netmask = conf_get_str (section, "Netmask");
      if (!netmask)
	{
	  log_print ("ipsec_get_id: section %s has no \"Netmask\" tag",
		     section);
	  return -1;
	}

      if (text2sockaddr (netmask, NULL, mask))
	{
	  log_print ("ipsec_id_build: invalid section %s network %s", section,
		     netmask);
	  return -1;
	}

      *tproto = conf_get_num (section, "Protocol", 0);
      if (*tproto)
	*port = conf_get_num (section, "Port", 0);
      break;

#ifdef notyet
    case IPSEC_ID_IPV4_RANGE:
      return -1;

    case IPSEC_ID_IPV6_RANGE:
      return -1;

    case IPSEC_ID_DER_ASN1_DN:
      return -1;

    case IPSEC_ID_DER_ASN1_GN:
      return -1;

    case IPSEC_ID_KEY_ID:
      return -1;
#endif

    default:
      log_print ("ipsec_get_id: unknown ID type \"%s\" in section %s", type,
		 section);
      return -1;
    }

  return 0;
}

/*
 * XXX I rather want this function to return a status code, and fail if
 * we cannot fit the information in the supplied buffer.
 */
static void
ipsec_decode_id (char *buf, int size, u_int8_t *id, size_t id_len,
		 int isakmpform)
{
  int id_type;
  char *addr = 0, *mask = 0;
  u_int32_t *idp;

  if (id)
    {
      if (!isakmpform)
	{
	  /* Exchanges and SAs dont carry the IDs in ISAKMP form.  */
	  id -= ISAKMP_GEN_SZ;
	  id_len += ISAKMP_GEN_SZ;
	}

      id_type = GET_ISAKMP_ID_TYPE (id);
      idp = (u_int32_t *)(id + ISAKMP_ID_DATA_OFF);
      switch (id_type)
	{
	case IPSEC_ID_IPV4_ADDR:
	  util_ntoa (&addr, AF_INET, id + ISAKMP_ID_DATA_OFF);
	  snprintf (buf, size, "%08x: %s",
		    decode_32 (id + ISAKMP_ID_DATA_OFF), addr);
	  break;

	case IPSEC_ID_IPV4_ADDR_SUBNET:
	  util_ntoa (&addr, AF_INET, id + ISAKMP_ID_DATA_OFF);
	  util_ntoa (&mask, AF_INET, id + ISAKMP_ID_DATA_OFF + 4);
	  snprintf (buf, size, "%08x/%08x: %s/%s",
		    decode_32 (id + ISAKMP_ID_DATA_OFF),
		    decode_32 (id + ISAKMP_ID_DATA_OFF + 4), addr, mask);
	  break;

	case IPSEC_ID_IPV6_ADDR:
	  util_ntoa (&addr, AF_INET6, id + ISAKMP_ID_DATA_OFF);
	  snprintf (buf, size, "%08x%08x%08x%08x: %s", *idp, *(idp + 1),
		    *(idp + 2), *(idp + 3), addr);
	  break;

	case IPSEC_ID_IPV6_ADDR_SUBNET:
	  util_ntoa (&addr, AF_INET6, id + ISAKMP_ID_DATA_OFF);
	  util_ntoa (&addr, AF_INET6, id + ISAKMP_ID_DATA_OFF +
		     sizeof (struct in6_addr));
	  snprintf (buf, size, "%08x%08x%08x%08x/%08x%08x%08x%08x: %s/%s",
		    *idp, *(idp + 1), *(idp + 2), *(idp + 3), *(idp + 4),
		    *(idp + 5), *(idp + 6), *(idp + 7), addr, mask);
	  break;

	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
	  /* String is not NUL terminated, be careful */
	  id_len -= ISAKMP_ID_DATA_OFF;
	  id_len = MIN(id_len, size - 1);
	  memcpy (buf, id + ISAKMP_ID_DATA_OFF, id_len);
	  buf[id_len] = '\0';
	  break;

#ifdef USE_X509
	case IPSEC_ID_DER_ASN1_DN:
	  addr = x509_DN_string (id + ISAKMP_ID_DATA_OFF,
				 id_len - ISAKMP_ID_DATA_OFF);
	  if (!addr)
	    {
	      snprintf(buf, size, "unparsable ASN1 DN ID");
	      return;
	    }
	  strlcpy (buf, addr, size);
	  break;
#endif

	default:
	  snprintf (buf, size, "<id type unknown: %x>", id_type);
	  break;
	}
    }
  else
    snprintf (buf, size, "<no ipsec id>");
  if (addr)
    free (addr);
  if (mask)
    free (mask);
}

char *
ipsec_decode_ids (char *fmt, u_int8_t *id1, size_t id1_len,
		  u_int8_t *id2, size_t id2_len, int isakmpform)
{
  static char result[1024];
  char s_id1[256], s_id2[256];

  ipsec_decode_id (s_id1, sizeof s_id1, id1, id1_len, isakmpform);
  ipsec_decode_id (s_id2, sizeof s_id2, id2, id2_len, isakmpform);

  snprintf (result, sizeof result, fmt, s_id1, s_id2);
  return result;
}

/*
 * Out of a named section SECTION in the configuration file build an
 * ISAKMP ID payload.  Ths payload size should be stashed in SZ.
 * The caller is responsible for freeing the payload.
 */
u_int8_t *
ipsec_build_id (char *section, size_t *sz)
{
  struct sockaddr *addr, *mask;
  u_int8_t *p;
  int id, subnet = 0;
  u_int8_t tproto = 0;
  u_int16_t port = 0;

  if (ipsec_get_id (section, &id, &addr, &mask, &tproto, &port))
    return 0;

  if (id == IPSEC_ID_IPV4_ADDR_SUBNET || id == IPSEC_ID_IPV6_ADDR_SUBNET)
    subnet = 1;

  *sz = ISAKMP_ID_SZ + sockaddr_addrlen (addr);
  if (subnet)
    *sz += sockaddr_addrlen (mask);

  p = malloc (*sz);
  if (!p)
    {
      log_print ("ipsec_build_id: malloc(%lu) failed", (unsigned long)*sz);
      return 0;
    }

  SET_ISAKMP_ID_TYPE (p, id);
  SET_ISAKMP_ID_DOI_DATA (p, (unsigned char *)"\000\000\000");

  memcpy (p + ISAKMP_ID_DATA_OFF, sockaddr_addrdata (addr),
	  sockaddr_addrlen (addr));
  if (subnet)
    memcpy (p + ISAKMP_ID_DATA_OFF + sockaddr_addrlen (addr),
	    sockaddr_addrdata (mask), sockaddr_addrlen (mask));

  SET_IPSEC_ID_PROTO (p + ISAKMP_ID_DOI_DATA_OFF, tproto);
  SET_IPSEC_ID_PORT (p + ISAKMP_ID_DOI_DATA_OFF, port);

  return p;
}

/*
 * copy an ISAKMPD id
 */
int
ipsec_clone_id (u_int8_t **did, size_t *did_len, u_int8_t *id, size_t id_len)
{
  if (*did)
    free (*did);

  if (!id_len || !id)
    {
      *did = 0;
      *did_len = 0;
      return 0;
    }

  *did = malloc (id_len);
  if (!*did)
    {
      *did_len = 0;
      log_error ("ipsec_clone_id: malloc(%lu) failed", (unsigned long)id_len);
      return -1;
    }

  *did_len = id_len;
  memcpy (*did, id, id_len);

  return 0;
}

/*
 * IPsec-specific PROTO initializations.  SECTION is only set if we are the
 * initiator thus only usable there.
 * XXX I want to fix this later.
 */
void
ipsec_proto_init (struct proto *proto, char *section)
{
  struct ipsec_proto *iproto = proto->data;

  if (proto->sa->phase == 2 && section)
    iproto->replay_window
      = conf_get_num (section, "ReplayWindow", DEFAULT_REPLAY_WINDOW);
}

/*
 * Add a notification payload of type INITIAL CONTACT to MSG if this is
 * the first contact we have made to our peer.
 */
int
ipsec_initial_contact (struct message *msg)
{
  u_int8_t *buf;

  if (ipsec_contacted (msg))
    return 0;

  buf = malloc (ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN);
  if (!buf)
    {
      log_error ("ike_phase_1_initial_contact: malloc (%d) failed",
		 ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN);
      return -1;
    }
  SET_ISAKMP_NOTIFY_DOI (buf, IPSEC_DOI_IPSEC);
  SET_ISAKMP_NOTIFY_PROTO (buf, ISAKMP_PROTO_ISAKMP);
  SET_ISAKMP_NOTIFY_SPI_SZ (buf, ISAKMP_HDR_COOKIES_LEN);
  SET_ISAKMP_NOTIFY_MSG_TYPE (buf, IPSEC_NOTIFY_INITIAL_CONTACT);
  memcpy (buf + ISAKMP_NOTIFY_SPI_OFF, msg->isakmp_sa->cookies,
	  ISAKMP_HDR_COOKIES_LEN);
  if (message_add_payload (msg, ISAKMP_PAYLOAD_NOTIFY, buf,
			   ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN, 1))
    {
      free (buf);
      return -1;
    }

  return ipsec_add_contact (msg);
}

/*
 * Compare the two contacts pointed to by A and B.  Return negative if
 * *A < *B, 0 if they are equal, and positive if *A is the largest of them.
 */
static int
addr_cmp (const void *a, const void *b)
{
  const struct contact *x = a, *y = b;
  int minlen = MIN (x->len, y->len);
  int rv = memcmp (x->addr, y->addr, minlen);

  return rv ? rv : (x->len - y->len);
}

/*
 * Add the peer that MSG is bound to as an address we don't want to send
 * INITIAL CONTACT too from now on.  Do not call this function with a
 * specific address duplicate times. We want fast lookup, speed of insertion
 * is unimportant, if this is to scale.
 */
static int
ipsec_add_contact (struct message *msg)
{
  struct contact *new_contacts;
  struct sockaddr *dst, *addr;
  int cnt;

  if (contact_cnt == contact_limit)
    {
      cnt = contact_limit ? 2 * contact_limit : 64;
      new_contacts = realloc (contacts, cnt * sizeof contacts[0]);
      if (!new_contacts)
	{
	  log_error ("ipsec_add_contact: realloc (%p, %lu) failed", contacts,
		     cnt * (unsigned long)sizeof contacts[0]);
	  return -1;
	}
      contact_limit = cnt;
      contacts = new_contacts;
    }
  msg->transport->vtbl->get_dst (msg->transport, &dst);
  addr = malloc (sysdep_sa_len (dst));
  if (!addr)
    {
      log_error ("ipsec_add_contact: malloc (%d) failed", sysdep_sa_len (dst));
      return -1;
    }
  memcpy (addr, dst, sysdep_sa_len (dst));
  contacts[contact_cnt].addr = addr;
  contacts[contact_cnt++].len = sysdep_sa_len (dst);

  /*
   * XXX There are better algorithms for already mostly-sorted data like
   * this, but only qsort is standard.  I will someday do this inline.
   */
  qsort (contacts, contact_cnt, sizeof *contacts, addr_cmp);
  return 0;
}

/* Return true if the recipient of MSG has already been contacted.  */
static int
ipsec_contacted (struct message *msg)
{
  struct contact contact;

  msg->transport->vtbl->get_dst (msg->transport, &contact.addr);
  contact.len = sysdep_sa_len (contact.addr);
  return contacts
    ? (bsearch (&contact, contacts, contact_cnt, sizeof *contacts, addr_cmp)
       != 0)
    : 0;
}

/* Add a HASH for to MSG.  */
u_int8_t *
ipsec_add_hash_payload (struct message *msg, size_t hashsize)
{
  u_int8_t *buf;

  buf = malloc (ISAKMP_HASH_SZ + hashsize);
  if (!buf)
    {
      log_error ("ipsec_add_hash_payload: malloc (%lu) failed",
		 ISAKMP_HASH_SZ + (unsigned long)hashsize);
      return 0;
    }

  if (message_add_payload (msg, ISAKMP_PAYLOAD_HASH, buf,
			   ISAKMP_HASH_SZ + hashsize, 1))
    {
      free (buf);
      return 0;
    }

  return buf;
}

/* Fill in the HASH payload of MSG.  */
int
ipsec_fill_in_hash (struct message *msg)
{
  struct exchange *exchange = msg->exchange;
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa = isakmp_sa->data;
  struct hash *hash = hash_get (isa->hash);
  struct prf *prf;
  struct payload *payload;
  u_int8_t *buf;
  int i;
  char header[80];

  /* If no SKEYID_a, we need not do anything.  */
  if (!isa->skeyid_a)
    return 0;

  payload = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH]);
  if (!payload)
    {
      log_print ("ipsec_fill_in_hash: no HASH payload found");
      return -1;
    }
  buf = payload->p;

  /* Allocate the prf and start calculating our HASH(1).  */
  LOG_DBG_BUF ((LOG_MISC, 90, "ipsec_fill_in_hash: SKEYID_a", isa->skeyid_a,
		isa->skeyid_len));
  prf = prf_alloc (isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
  if (!prf)
    return -1;

  prf->Init (prf->prfctx);
  LOG_DBG_BUF ((LOG_MISC, 90, "ipsec_fill_in_hash: message_id",
		exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
  prf->Update (prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);

  /* Loop over all payloads after HASH(1).  */
  for (i = 2; i < msg->iovlen; i++)
    {
      /* XXX Misleading payload type printouts.  */
      snprintf (header, 80, "ipsec_fill_in_hash: payload %d after HASH(1)",
		i - 1);
      LOG_DBG_BUF ((LOG_MISC, 90, header, msg->iov[i].iov_base,
		    msg->iov[i].iov_len));
      prf->Update (prf->prfctx, msg->iov[i].iov_base, msg->iov[i].iov_len);
    }
  prf->Final (buf + ISAKMP_HASH_DATA_OFF, prf->prfctx);
  prf_free (prf);
  LOG_DBG_BUF ((LOG_MISC, 80, "ipsec_fill_in_hash: HASH(1)",
		buf + ISAKMP_HASH_DATA_OFF, hash->hashsize));

  return 0;
}

/* Add a HASH payload to MSG, if we have an ISAKMP SA we're protected by.  */
static int
ipsec_informational_pre_hook (struct message *msg)
{
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa;
  struct hash *hash;

  if (!isakmp_sa)
    return 0;
  isa = isakmp_sa->data;
  hash = hash_get (isa->hash);
  return ipsec_add_hash_payload (msg, hash->hashsize) == 0;
}

/*
 * Fill in the HASH payload in MSG, if we have an ISAKMP SA we're protected by.
 */
static int
ipsec_informational_post_hook (struct message *msg)
{
  if (!msg->isakmp_sa)
    return 0;
  return ipsec_fill_in_hash (msg);
}

ssize_t
ipsec_id_size (char *section, u_int8_t *id)
{
  char *type, *data;

  type = conf_get_str (section, "ID-type");
  if (!type)
    {
      log_print ("ipsec_id_size: section %s has no \"ID-type\" tag", section);
      return -1;
    }

  *id = constant_value (ipsec_id_cst, type);
  switch (*id)
    {
    case IPSEC_ID_IPV4_ADDR:
      return sizeof (struct in_addr);
    case IPSEC_ID_IPV4_ADDR_SUBNET:
      return 2 * sizeof (struct in_addr);
    case IPSEC_ID_IPV6_ADDR:
      return sizeof (struct in6_addr);
    case IPSEC_ID_IPV6_ADDR_SUBNET:
      return 2 * sizeof (struct in6_addr);
    case IPSEC_ID_FQDN:
    case IPSEC_ID_USER_FQDN:
    case IPSEC_ID_KEY_ID:
    case IPSEC_ID_DER_ASN1_DN:
    case IPSEC_ID_DER_ASN1_GN:
      data = conf_get_str (section, "Name");
      if (!data)
	{
	  log_print ("ipsec_id_size: section %s has no \"Name\" tag", section);
	  return -1;
	}
      return strlen (data);
    }
  log_print ("ipsec_id_size: unrecognized/unsupported ID-type %d (%s)",
	     *id, type);
  return -1;
}

/*
 * Generate a string version of the ID.
 */
char *
ipsec_id_string (u_int8_t *id, size_t id_len)
{
  char *buf = 0;
  char *addrstr = 0;
  size_t len, size;

  /*
   * XXX Real ugly way of making the offsets correct.  Be aware that id now
   * will point before the actual buffer and cannot be dereferenced without
   * an offset larger than or equal to ISAKM_GEN_SZ.
   */
  id -= ISAKMP_GEN_SZ;

  /* This is the actual length of the ID data field.  */
  id_len += ISAKMP_GEN_SZ - ISAKMP_ID_DATA_OFF;

  /*
   * Conservative allocation.
   * XXX I think the ASN1 DN case can be thought through to give a better
   * estimate.
   */
  size = MAX (sizeof "ipv6/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",
	      sizeof "asn1_dn/" + id_len - ISAKMP_ID_DATA_OFF);
  buf = malloc (size);
  if (!buf)
    /* XXX Log?  */
    goto fail;

  switch (GET_ISAKMP_ID_TYPE (id))
    {
    case IPSEC_ID_IPV4_ADDR:
      if (id_len < sizeof (struct in_addr))
	goto fail;
      util_ntoa (&addrstr, AF_INET, id + ISAKMP_ID_DATA_OFF);
      if (!addrstr)
	goto fail;
      snprintf (buf, size, "ipv4/%s", addrstr);
      break;

    case IPSEC_ID_IPV6_ADDR:
      if (id_len < sizeof (struct in6_addr))
	goto fail;
      util_ntoa (&addrstr, AF_INET6, id + ISAKMP_ID_DATA_OFF);
      if (!addrstr)
	goto fail;
      snprintf (buf, size, "ipv6/%s", addrstr);
      break;

    case IPSEC_ID_FQDN:
    case IPSEC_ID_USER_FQDN:
      strlcpy (buf,
	       GET_ISAKMP_ID_TYPE (id) == IPSEC_ID_FQDN ? "fqdn/" : "ufqdn/",
	       size);
      len = strlen(buf);

      memcpy (buf + len, id + ISAKMP_ID_DATA_OFF, id_len);
      *(buf + len + id_len) = '\0';
      break;

#ifdef USE_X509
    case IPSEC_ID_DER_ASN1_DN:
      strlcpy (buf, "asn1_dn/", size);
      len = strlen(buf);
      addrstr = x509_DN_string (id + ISAKMP_ID_DATA_OFF,
				id_len - ISAKMP_ID_DATA_OFF);
      if (!addrstr)
	goto fail;
      if (size < len + strlen (addrstr) + 1)
	goto fail;
      strlcpy (buf + len, addrstr, size - len);
      break;
#endif

    default:
      /* Unknown type.  */
      LOG_DBG ((LOG_MISC, 10, "ipsec_id_string: unknown identity type %d\n",
		GET_ISAKMP_ID_TYPE (id)));
      goto fail;
    }

  if (addrstr)
    free (addrstr);
  return buf;

 fail:
  if (buf)
    free (buf);
  if (addrstr)
    free (addrstr);
  return 0;
}
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.74 2003/05/14 17:37:22 ho Exp $	*/
d894 1
a894 2
	|| (transform_id > IPSEC_ESP_AES_128_CTR
	    && transform_id < IPSEC_ESP_AES_MARS)
a1705 1
    case IPSEC_ESP_AES_128_CTR:
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.76 2003/06/04 07:31:16 ho Exp $	*/
d17 5
d1250 1
a1250 1
    snprintf (val, sizeof val, "%d", decode_16 (value));
d1252 1
a1252 1
    snprintf (val, sizeof val, "%d", decode_32 (value));
d1254 1
a1254 1
    snprintf (val, sizeof val, "unrepresentable");
d1499 1
a1499 1
  snprintf (header, sizeof header, "ipsec_g_x: g^x%c", initiator ? 'i' : 'r');
d2248 2
a2249 2
      snprintf (header, sizeof header,
		"ipsec_fill_in_hash: payload %d after HASH(1)",	i - 1);
@


1.1.1.4
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.77 2003/06/10 12:21:29 ho Exp $	*/
d334 1
a334 1
		      log_print ("ipsec_finalize_exchange: "
d344 1
a344 1
		      log_print ("ipsec_finalize_exchange: "
a416 1
  char *v;
d427 1
a427 1
	goto memfail;
d436 1
a436 1
	goto memfail;
d448 1
a448 1
	goto memfail;
d457 1
a457 1
	goto memfail;
a462 11

    case IPSEC_ID_IPV4_RANGE:
    case IPSEC_ID_IPV6_RANGE:
    case IPSEC_ID_DER_ASN1_DN:
    case IPSEC_ID_DER_ASN1_GN:
    case IPSEC_ID_KEY_ID:
    default:
      v = constant_lookup (ipsec_id_cst, id);
      log_print ("ipsec_set_network: ID type %d (%s) not supported",
		 id, v ? v : "<unknown>");
      return -1;
d497 1
a497 1
	goto memfail;
d506 1
a506 1
	goto memfail;
d518 1
a518 1
	goto memfail;
d527 1
a527 1
	goto memfail;
a559 4

 memfail:
  log_error ("ipsec_set_network: calloc () failed");
  return -1;
@


1.1.1.5
log
@Import latest OpenBSD ports, XFree and source in sync
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.78 2003/07/25 08:31:16 markus Exp $	*/
d1229 1
a1229 1
	    || decode_16 (value) > IPSEC_AUTH_HMAC_RIPEMD;
a1739 6
    case IPSEC_AUTH_HMAC_SHA2_256:
      return 32;
    case IPSEC_AUTH_HMAC_SHA2_384:
      return 48;
    case IPSEC_AUTH_HMAC_SHA2_512:
      return 64;
a1755 6
    case IPSEC_AH_SHA2_256:
      return 32;
    case IPSEC_AH_SHA2_384:
      return 48;
    case IPSEC_AH_SHA2_512:
      return 64;
@


1.1.1.6
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.79 2003/08/08 08:46:59 ho Exp $	*/
a1058 1
  char *tag;
d1097 1
a1097 2
	  type = GET_ISAKMP_NOTIFY_MSG_TYPE (p->p);
	  tag = constant_lookup (isakmp_notify_cst, type);
d1100 1
a1100 1
		    tag ? tag : "<unknown>"));
d1102 2
a1103 2
	  if (type == ISAKMP_NOTIFY_INVALID_SPI)
	    ipsec_invalid_spi (msg, p);
@


1.1.1.7
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.80 2003/09/02 18:15:55 ho Exp $	*/
d783 1
a783 1
  LOG_DBG ((LOG_MESSAGE, 40,
@


1.1.1.7.4.1
log
@SECURITY: Fix the hole in isakmpd. The fixes are from OpenBSD CVS, from
the OPENBSD_3_4 stable branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.80.2.1 2004/01/13 22:50:07 brad Exp $	*/
d1016 37
d1104 3
a1658 25
	  /*
	   * Permit INITIAL-CONTACT if
	   *   - this is not an AGGRESSIVE mode exchange
	   *   - it is protected by an ISAKMP SA
	   *
	   * XXX Instead of the first condition above, we could permit this
	   * XXX only for phase 2. In the last packet of main-mode, this
	   * XXX payload, while encrypted, is not part of the hash digest.
	   * XXX As we currently send our own INITIAL-CONTACTs at this point,
	   * XXX this too would need to be changed.
	   */
	  if (msg->exchange->type == ISAKMP_EXCH_AGGRESSIVE)
	    {	
	      log_print ("ipsec_handle_leftover_payload: got INITIAL-CONTACT "
			 "in AGGRESSIVE mode");
	      return -1;
	    }

	  if ((msg->exchange->flags & EXCHANGE_FLAG_ENCRYPT) == 0)
	    {
	      log_print ("ipsec_handle_leftover_payload: got INITIAL-CONTACT "
			 "without ISAKMP SA");
	      return -1;
	    }

@


1.1.1.7.4.2
log
@SECURITY: Fix multiple isakmpd vulnerabilities.

Several bugs have been found in the ISAKMP daemon which can lead to memory
leaks and a remote denial of service condition. An attacker can craft
malformed payloads that can cause the isakmpd(8) process to stop
processing requests.
@
text
@d125 1
a125 1
static int ipsec_validate_situation (u_int8_t *, size_t *, size_t);
d856 1
a856 1
ipsec_validate_situation (u_int8_t *buf, size_t *sz, size_t len)
d858 15
a872 5
  if (len < IPSEC_SIT_SIT_OFF + IPSEC_SIT_SIT_LEN)
    { 
      log_print ("ipsec_validate_situation: payload too short: %u",
                 (unsigned int)len);
      return -1;
d874 2
d878 6
a883 1
  if (GET_IPSEC_SIT_SIT (buf) != IPSEC_SIT_IDENTITY_ONLY)
a884 3

  *sz = IPSEC_SIT_SIT_LEN;

@


1.1.1.8
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.84 2003/12/15 10:06:42 hshoexer Exp $	*/
d417 1
d471 1
d473 1
a473 1
		 id, constant_name (ipsec_id_cst, id));
d1003 1
a1003 1
		   ((u_int32_t *)spis)[i], proto));
d1059 1
d1099 1
d1102 1
a1102 1
		    constant_name (isakmp_notify_cst, type)));
d1181 2
a1182 4
	  return (decode_16 (value) < IKE_GROUP_DESC_MODP_768
	          || decode_16 (value) > IKE_GROUP_DESC_MODP_1536) 
	    && (decode_16 (value) < IKE_GROUP_DESC_MODP_2048
	        || decode_16 (value) > IKE_GROUP_DESC_MODP_8192);
d1224 2
a1225 4
	  return (decode_16 (value) < IKE_GROUP_DESC_MODP_768
	          || decode_16 (value) > IKE_GROUP_DESC_MODP_1536)
	    && (decode_16 (value) < IKE_GROUP_DESC_MODP_2048
		|| IKE_GROUP_DESC_MODP_8192 < decode_16 (value));
d1963 1
a1963 1
	  id_len = MIN (id_len, size - 1);
d1974 1
a1974 1
	      snprintf (buf, size, "unparsable ASN1 DN ID");
d2411 1
a2411 1
      len = strlen (buf);
d2420 1
a2420 1
      len = strlen (buf);
@


1.1.1.9
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.85 2004/01/03 16:38:13 ho Exp $	*/
d1014 37
d1100 3
a1658 25
	  /*
	   * Permit INITIAL-CONTACT if
	   *   - this is not an AGGRESSIVE mode exchange
	   *   - it is protected by an ISAKMP SA
	   *
	   * XXX Instead of the first condition above, we could permit this
	   * XXX only for phase 2. In the last packet of main-mode, this
	   * XXX payload, while encrypted, is not part of the hash digest.
	   * XXX As we currently send our own INITIAL-CONTACTs at this point,
	   * XXX this too would need to be changed.
	   */
	  if (msg->exchange->type == ISAKMP_EXCH_AGGRESSIVE)
	    {	
	      log_print ("ipsec_handle_leftover_payload: got INITIAL-CONTACT "
			 "in AGGRESSIVE mode");
	      return -1;
	    }

	  if ((msg->exchange->flags & EXCHANGE_FLAG_ENCRYPT) == 0)
	    {
	      log_print ("ipsec_handle_leftover_payload: got INITIAL-CONTACT "
			 "without ISAKMP SA");
	      return -1;
	    }

@


1.1.1.10
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 2
a2 2
/* $OpenBSD: ipsec.c,v 1.89 2004/04/15 18:39:25 deraadt Exp $	 */
/* $EOM: ipsec.c,v 1.143 2000/12/11 23:57:42 niklas Exp $	 */
d81 3
a83 3
	struct message *msg;
	struct sa      *sa;
	struct proto   *proto;
d88 8
a95 8
	struct sockaddr *addr;
	socklen_t       len;
}              *contacts = 0;
int             contact_cnt = 0, contact_limit = 0;

static int      addr_cmp(const void *, const void *);
static int      ipsec_add_contact(struct message * msg);
static int      ipsec_contacted(struct message * msg);
d97 1
a97 1
static int      ipsec_debug_attribute(u_int16_t, u_int8_t *, u_int16_t, void *);
d99 28
a126 30
static void     ipsec_delete_spi(struct sa *, struct proto *, int);
static int16_t *ipsec_exchange_script(u_int8_t);
static void     ipsec_finalize_exchange(struct message *);
static void     ipsec_free_exchange_data(void *);
static void     ipsec_free_proto_data(void *);
static void     ipsec_free_sa_data(void *);
static struct keystate *ipsec_get_keystate(struct message *);
static u_int8_t *ipsec_get_spi(size_t *, u_int8_t, struct message *);
static int
ipsec_handle_leftover_payload(struct message *, u_int8_t,
			      struct payload *);
static int      ipsec_informational_post_hook(struct message *);
static int      ipsec_informational_pre_hook(struct message *);
static int      ipsec_initiator(struct message *);
static void     ipsec_proto_init(struct proto *, char *);
static int      ipsec_responder(struct message *);
static void     ipsec_setup_situation(u_int8_t *);
static int      ipsec_set_network(u_int8_t *, u_int8_t *, struct ipsec_sa *);
static size_t   ipsec_situation_size(void);
static u_int8_t ipsec_spi_size(u_int8_t);
static int      ipsec_validate_attribute(u_int16_t, u_int8_t *, u_int16_t, void *);
static int      ipsec_validate_exchange(u_int8_t);
static int
ipsec_validate_id_information(u_int8_t, u_int8_t *, u_int8_t *,
			      size_t, struct exchange *);
static int      ipsec_validate_key_information(u_int8_t *, size_t);
static int      ipsec_validate_notification(u_int16_t);
static int      ipsec_validate_proto(u_int8_t);
static int      ipsec_validate_situation(u_int8_t *, size_t *, size_t);
static int      ipsec_validate_transform_id(u_int8_t, u_int8_t);
d129 3
a131 3
	{0}, IPSEC_DOI_IPSEC,
	sizeof(struct ipsec_exch), sizeof(struct ipsec_sa),
	sizeof(struct ipsec_proto),
d133 1
a133 1
	ipsec_debug_attribute,
d135 27
a161 27
	ipsec_delete_spi,
	ipsec_exchange_script,
	ipsec_finalize_exchange,
	ipsec_free_exchange_data,
	ipsec_free_proto_data,
	ipsec_free_sa_data,
	ipsec_get_keystate,
	ipsec_get_spi,
	ipsec_handle_leftover_payload,
	ipsec_informational_post_hook,
	ipsec_informational_pre_hook,
	ipsec_is_attribute_incompatible,
	ipsec_proto_init,
	ipsec_setup_situation,
	ipsec_situation_size,
	ipsec_spi_size,
	ipsec_validate_attribute,
	ipsec_validate_exchange,
	ipsec_validate_id_information,
	ipsec_validate_key_information,
	ipsec_validate_notification,
	ipsec_validate_proto,
	ipsec_validate_situation,
	ipsec_validate_transform_id,
	ipsec_initiator,
	ipsec_responder,
	ipsec_decode_ids
d164 11
a174 11
int16_t         script_quick_mode[] = {
	ISAKMP_PAYLOAD_HASH,	/* Initiator -> responder.  */
	ISAKMP_PAYLOAD_SA,
	ISAKMP_PAYLOAD_NONCE,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_HASH,	/* Responder -> initiator.  */
	ISAKMP_PAYLOAD_SA,
	ISAKMP_PAYLOAD_NONCE,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_HASH,	/* Initiator -> responder.  */
	EXCHANGE_SCRIPT_END
d177 7
a183 7
int16_t         script_new_group_mode[] = {
	ISAKMP_PAYLOAD_HASH,	/* Initiator -> responder.  */
	ISAKMP_PAYLOAD_SA,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_HASH,	/* Responder -> initiator.  */
	ISAKMP_PAYLOAD_SA,
	EXCHANGE_SCRIPT_END
d187 3
a189 3
	struct sockaddr *dst;
	u_int32_t       spi;
	u_int8_t        proto;
d198 1
a198 1
ipsec_sa_check(struct sa *sa, void *v_arg)
d200 19
a218 26
	struct dst_spi_proto_arg *arg = v_arg;
	struct proto   *proto;
	struct sockaddr *dst, *src;
	int             incoming;

	if (sa->phase != 2 || !(sa->flags & SA_FLAG_READY))
		return 0;

	sa->transport->vtbl->get_dst(sa->transport, &dst);
	if (memcmp(sockaddr_addrdata(dst), sockaddr_addrdata(arg->dst),
	    sockaddr_addrlen(dst)) == 0)
		incoming = 0;
	else {
		sa->transport->vtbl->get_src(sa->transport, &src);
		if (memcmp(sockaddr_addrdata(src), sockaddr_addrdata(arg->dst),
		    sockaddr_addrlen(src)) == 0)
			incoming = 1;
		else
			return 0;
	}

	for (proto = TAILQ_FIRST(&sa->protos); proto;
	    proto = TAILQ_NEXT(proto, link))
		if ((arg->proto == 0 || proto->proto == arg->proto) &&
		    memcmp(proto->spi[incoming], &arg->spi, sizeof arg->spi) == 0)
			return 1;
d220 8
d231 2
a232 2
struct sa      *
ipsec_sa_lookup(struct sockaddr * dst, u_int32_t spi, u_int8_t proto)
d234 5
a238 1
	struct dst_spi_proto_arg arg;
d240 1
a240 4
	arg.dst = dst;
	arg.spi = spi;
	arg.proto = proto;
	return sa_find(ipsec_sa_check, &arg);
d249 1
a249 1
ipsec_sa_check_flow(struct sa * sa, void *v_arg)
d251 2
a252 2
	struct sa      *sa2 = v_arg;
	struct ipsec_sa *isa = sa->data, *isa2 = sa2->data;
d254 21
a274 21
	if (sa == sa2 || sa->phase != 2 ||
	    (sa->flags & (SA_FLAG_READY | SA_FLAG_REPLACED)) != SA_FLAG_READY)
		return 0;

	if (isa->tproto != isa2->tproto || isa->sport != isa2->sport ||
	    isa->dport != isa2->dport)
		return 0;

	return isa->src_net->sa_family == isa2->src_net->sa_family &&
	    memcmp(sockaddr_addrdata(isa->src_net),
	    sockaddr_addrdata(isa2->src_net),
	    sockaddr_addrlen(isa->src_net)) == 0 &&
	    memcmp(sockaddr_addrdata(isa->src_mask),
	    sockaddr_addrdata(isa2->src_mask),
	    sockaddr_addrlen(isa->src_mask)) == 0 &&
	    memcmp(sockaddr_addrdata(isa->dst_net),
	    sockaddr_addrdata(isa2->dst_net),
	    sockaddr_addrlen(isa->dst_net)) == 0 &&
	    memcmp(sockaddr_addrdata(isa->dst_mask),
	    sockaddr_addrdata(isa2->dst_mask),
	    sockaddr_addrlen(isa->dst_mask)) == 0;
d282 1
a282 1
ipsec_finalize_exchange(struct message * msg)
d284 6
a289 6
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct ipsec_sa *isa;
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct sa      *sa = 0, *old_sa;
	struct proto   *proto, *last_proto = 0;
d291 1
a291 1
	char           *addr1, *addr2, *mask1, *mask2;
d294 70
a363 21
	switch (exchange->phase) {
	case 1:
		switch (exchange->type) {
		case ISAKMP_EXCH_ID_PROT:
		case ISAKMP_EXCH_AGGRESSIVE:
			isa = isakmp_sa->data;
			isa->hash = ie->hash->type;
			isa->prf_type = ie->prf_type;
			isa->skeyid_len = ie->skeyid_len;
			isa->skeyid_d = ie->skeyid_d;
			isa->skeyid_a = ie->skeyid_a;
			/* Prevents early free of SKEYID_*.  */
			ie->skeyid_a = ie->skeyid_d = 0;

			/*
			 * If a lifetime was negotiated setup the expiration
			 * timers.
			 */
			if (isakmp_sa->seconds)
				sa_setup_expirations(isakmp_sa);
			break;
a364 1
		break;
d366 36
a401 52
	case 2:
		switch (exchange->type) {
		case IKE_EXCH_QUICK_MODE:
			/*
			 * Tell the application(s) about the SPIs and key material.
		         */
			for (sa = TAILQ_FIRST(&exchange->sa_list); sa;
			    sa = TAILQ_NEXT(sa, next)) {
				isa = sa->data;

				if (exchange->initiator) {
					/*
					 * Initiator is source, responder is
					 * destination.
					 */
					if (ipsec_set_network(ie->id_ci,
					    ie->id_cr, isa)) {
						log_print("ipsec_finalize_exchange: "
						    "ipsec_set_network failed");
						return;
					}
				} else {
					/*
					 * Responder is source, initiator is
					 * destination.
					 */
					if (ipsec_set_network(ie->id_cr, ie->id_ci,
					    isa)) {
						log_print("ipsec_finalize_exchange: "
						    "ipsec_set_network failed");
						return;
					}
				}

				for (proto = TAILQ_FIRST(&sa->protos),
				    last_proto = 0; proto;
				    proto = TAILQ_NEXT(proto, link)) {
					if (sysdep_ipsec_set_spi(sa, proto,
					    0, isakmp_sa) ||
					    (last_proto && sysdep_ipsec_group_spis(sa,
					    last_proto, proto, 0)) ||
					    sysdep_ipsec_set_spi(sa, proto,
					    1, isakmp_sa) ||
					    (last_proto && sysdep_ipsec_group_spis(sa,
					    last_proto, proto, 1)))
						/*
						 * XXX Tear down this
						 * exchange.
						 */
						return;
					last_proto = proto;
				}
d403 5
a407 46
#ifdef USE_DEBUG
				if (sockaddr2text(isa->src_net, &addr1, 0))
					addr1 = 0;
				if (sockaddr2text(isa->src_mask, &mask1, 0))
					mask1 = 0;
				if (sockaddr2text(isa->dst_net, &addr2, 0))
					addr2 = 0;
				if (sockaddr2text(isa->dst_mask, &mask2, 0))
					mask2 = 0;

				LOG_DBG((LOG_EXCHANGE, 50,
				    "ipsec_finalize_exchange: "
				    "src %s %s dst %s %s tproto %u sport %u dport %u",
				     addr1 ? addr1 : "<??\?>", mask1 ? mask1 : "<??\?>",
				    addr2 ? addr2 : "<??\?>", mask2 ? mask2 : "<??\?>",
				     isa->tproto, ntohs(isa->sport), ntohs(isa->dport)));

				if (addr1)
					free(addr1);
				if (mask1)
					free(mask1);
				if (addr2)
					free(addr2);
				if (mask2)
					free(mask2);

#endif				/* USE_DEBUG */

				/*
				 * If this is not an SA acquired by the kernel, it needs
				 * to have a SPD entry (a.k.a. flow) set up.
			         */
				if (!(sa->flags & SA_FLAG_ONDEMAND) &&
				    sysdep_ipsec_enable_sa(sa, isakmp_sa))
					/* XXX Tear down this exchange.  */
					return;

				/*
				 * Mark elder SAs with the same flow
				 * information as replaced.
				 */
				while ((old_sa = sa_find(ipsec_sa_check_flow, sa)) != 0)
					sa_mark_replaced(old_sa);
			}
			break;
		}
d409 1
d414 1
a414 1
ipsec_set_network(u_int8_t *src_id, u_int8_t *dst_id, struct ipsec_sa *isa)
d416 1
a416 1
	int             id;
d418 11
a428 10
	/* Set source address/mask.  */
	id = GET_ISAKMP_ID_TYPE(src_id);
	switch (id) {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV4_ADDR_SUBNET:
		isa->src_net = (struct sockaddr *) calloc(1,
		    sizeof(struct sockaddr_in));
		if (!isa->src_net)
			goto memfail;
		isa->src_net->sa_family = AF_INET;
d430 1
a430 1
		isa->src_net->sa_len = sizeof(struct sockaddr_in);
d433 5
a437 5
		isa->src_mask = (struct sockaddr *) calloc(1,
		    sizeof(struct sockaddr_in));
		if (!isa->src_mask)
			goto memfail;
		isa->src_mask->sa_family = AF_INET;
d439 1
a439 1
		isa->src_mask->sa_len = sizeof(struct sockaddr_in);
d441 1
a441 1
		break;
d443 7
a449 7
	case IPSEC_ID_IPV6_ADDR:
	case IPSEC_ID_IPV6_ADDR_SUBNET:
		isa->src_net = (struct sockaddr *) calloc(1,
		    sizeof(struct sockaddr_in6));
		if (!isa->src_net)
			goto memfail;
		isa->src_net->sa_family = AF_INET6;
d451 1
a451 1
		isa->src_net->sa_len = sizeof(struct sockaddr_in6);
d454 5
a458 5
		isa->src_mask = (struct sockaddr *) calloc(1,
		    sizeof(struct sockaddr_in6));
		if (!isa->src_mask)
			goto memfail;
		isa->src_mask->sa_family = AF_INET6;
d460 1
a460 1
		isa->src_mask->sa_len = sizeof(struct sockaddr_in6);
d462 1
a462 33
		break;

	case IPSEC_ID_IPV4_RANGE:
	case IPSEC_ID_IPV6_RANGE:
	case IPSEC_ID_DER_ASN1_DN:
	case IPSEC_ID_DER_ASN1_GN:
	case IPSEC_ID_KEY_ID:
	default:
		log_print("ipsec_set_network: ID type %d (%s) not supported",
		    id, constant_name(ipsec_id_cst, id));
		return -1;
	}

	/* Net */
	memcpy(sockaddr_addrdata(isa->src_net), src_id + ISAKMP_ID_DATA_OFF,
	    sockaddr_addrlen(isa->src_net));

	/* Mask */
	switch (id) {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR:
		memset(sockaddr_addrdata(isa->src_mask), 0xff,
		    sockaddr_addrlen(isa->src_mask));
		break;
	case IPSEC_ID_IPV4_ADDR_SUBNET:
	case IPSEC_ID_IPV6_ADDR_SUBNET:
		memcpy(sockaddr_addrdata(isa->src_mask), src_id + ISAKMP_ID_DATA_OFF +
		    sockaddr_addrlen(isa->src_net), sockaddr_addrlen(isa->src_mask));
		break;
	}

	memcpy(&isa->sport, src_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	       IPSEC_ID_PORT_LEN);
d464 45
a508 10
	/* Set destination address.  */
	id = GET_ISAKMP_ID_TYPE(dst_id);
	switch (id) {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV4_ADDR_SUBNET:
		isa->dst_net =
			(struct sockaddr *) calloc(1, sizeof(struct sockaddr_in));
		if (!isa->dst_net)
			goto memfail;
		isa->dst_net->sa_family = AF_INET;
d510 1
a510 1
		isa->dst_net->sa_len = sizeof(struct sockaddr_in);
d513 5
a517 5
		isa->dst_mask =
			(struct sockaddr *) calloc(1, sizeof(struct sockaddr_in));
		if (!isa->dst_mask)
			goto memfail;
		isa->dst_mask->sa_family = AF_INET;
d519 1
a519 1
		isa->dst_mask->sa_len = sizeof(struct sockaddr_in);
d521 1
a521 1
		break;
d523 7
a529 7
	case IPSEC_ID_IPV6_ADDR:
	case IPSEC_ID_IPV6_ADDR_SUBNET:
		isa->dst_net =
			(struct sockaddr *) calloc(1, sizeof(struct sockaddr_in6));
		if (!isa->dst_net)
			goto memfail;
		isa->dst_net->sa_family = AF_INET6;
d531 1
a531 1
		isa->dst_net->sa_len = sizeof(struct sockaddr_in6);
d534 5
a538 5
		isa->dst_mask =
			(struct sockaddr *) calloc(1, sizeof(struct sockaddr_in6));
		if (!isa->dst_mask)
			goto memfail;
		isa->dst_mask->sa_family = AF_INET6;
d540 1
a540 1
		isa->dst_mask->sa_len = sizeof(struct sockaddr_in6);
d542 2
a543 27
		break;
	}

	/* Net */
	memcpy(sockaddr_addrdata(isa->dst_net), dst_id + ISAKMP_ID_DATA_OFF,
	       sockaddr_addrlen(isa->dst_net));

	/* Mask */
	switch (id) {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR:
		memset(sockaddr_addrdata(isa->dst_mask), 0xff,
		       sockaddr_addrlen(isa->dst_mask));
		break;
	case IPSEC_ID_IPV4_ADDR_SUBNET:
	case IPSEC_ID_IPV6_ADDR_SUBNET:
		memcpy(sockaddr_addrdata(isa->dst_mask), dst_id + ISAKMP_ID_DATA_OFF +
		       sockaddr_addrlen(isa->dst_net),
		       sockaddr_addrlen(isa->dst_mask));
		break;
	}

	memcpy(&isa->tproto, dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PROTO_OFF,
	       IPSEC_ID_PROTO_LEN);
	memcpy(&isa->dport, dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	       IPSEC_ID_PORT_LEN);
	return 0;
d545 29
a573 3
memfail:
	log_error("ipsec_set_network: calloc () failed");
	return -1;
d578 1
a578 1
ipsec_free_exchange_data(void *vie)
d580 1
a580 1
	struct ipsec_exch *ie = vie;
d582 1
a582 1
	struct isakmp_cfg_attr *attr;
d585 26
a610 26
	if (ie->sa_i_b)
		free(ie->sa_i_b);
	if (ie->id_ci)
		free(ie->id_ci);
	if (ie->id_cr)
		free(ie->id_cr);
	if (ie->g_xi)
		free(ie->g_xi);
	if (ie->g_xr)
		free(ie->g_xr);
	if (ie->g_xy)
		free(ie->g_xy);
	if (ie->skeyid)
		free(ie->skeyid);
	if (ie->skeyid_d)
		free(ie->skeyid_d);
	if (ie->skeyid_a)
		free(ie->skeyid_a);
	if (ie->skeyid_e)
		free(ie->skeyid_e);
	if (ie->hash_i)
		free(ie->hash_i);
	if (ie->hash_r)
		free(ie->hash_r);
	if (ie->group)
		group_free(ie->group);
d612 7
a618 6
	for (attr = LIST_FIRST(&ie->attrs); attr; attr = LIST_FIRST(&ie->attrs)) {
		LIST_REMOVE(attr, link);
		if (attr->length)
			free(attr->value);
		free(attr);
	}
d624 1
a624 1
ipsec_free_sa_data(void *visa)
d626 1
a626 1
	struct ipsec_sa *isa = visa;
d628 12
a639 12
	if (isa->src_net)
		free(isa->src_net);
	if (isa->src_mask)
		free(isa->src_mask);
	if (isa->dst_net)
		free(isa->dst_net);
	if (isa->dst_mask)
		free(isa->dst_mask);
	if (isa->skeyid_a)
		free(isa->skeyid_a);
	if (isa->skeyid_d)
		free(isa->skeyid_d);
d644 1
a644 1
ipsec_free_proto_data(void *viproto)
d646 2
a647 2
	struct ipsec_proto *iproto = viproto;
	int             i;
d649 3
a651 3
	for (i = 0; i < 2; i++)
		if (iproto->keymat[i])
			free(iproto->keymat[i]);
d656 1
a656 1
ipsec_exchange_script(u_int8_t type)
d658 2
a659 1
	switch (type) {
d661 2
a662 2
		case ISAKMP_EXCH_TRANSACTION:
		return script_transaction;
d664 6
a669 6
	case IKE_EXCH_QUICK_MODE:
		return script_quick_mode;
	case IKE_EXCH_NEW_GROUP_MODE:
		return script_new_group_mode;
	}
	return 0;
d674 1
a674 1
ipsec_init(void)
d676 1
a676 1
	doi_register(&ipsec_doi);
d681 1
a681 1
ipsec_get_keystate(struct message * msg)
d683 2
a684 2
	struct keystate *ks;
	struct hash    *hash;
d686 46
a731 42
	/* If we have already have an IV, use it.  */
	if (msg->exchange && msg->exchange->keystate) {
		ks = malloc(sizeof *ks);
		if (!ks) {
			log_error("ipsec_get_keystate: malloc (%lu) failed",
				  (unsigned long) sizeof *ks);
			return 0;
		}
		memcpy(ks, msg->exchange->keystate, sizeof *ks);
		return ks;
	}
	/*
	 * For phase 2 when no SA yet is setup we need to hash the IV used by
	 * the ISAKMP SA concatenated with the message ID, and use that as an
	 * IV for further cryptographic operations.
         */
	if (!msg->isakmp_sa->keystate) {
		log_print("ipsec_get_keystate: no keystate in ISAKMP SA %p",
			  msg->isakmp_sa);
		return 0;
	}
	ks = crypto_clone_keystate(msg->isakmp_sa->keystate);
	if (!ks)
		return 0;

	hash = hash_get(((struct ipsec_sa *) msg->isakmp_sa->data)->hash);
	hash->Init(hash->ctx);
	LOG_DBG_BUF((LOG_CRYPTO, 80, "ipsec_get_keystate: final phase 1 IV",
		     ks->riv, ks->xf->blocksize));
	hash->Update(hash->ctx, ks->riv, ks->xf->blocksize);
	LOG_DBG_BUF((LOG_CRYPTO, 80, "ipsec_get_keystate: message ID",
		     ((u_int8_t *) msg->iov[0].iov_base)
		     + ISAKMP_HDR_MESSAGE_ID_OFF,
		     ISAKMP_HDR_MESSAGE_ID_LEN));
	hash->Update(hash->ctx,
	    ((u_int8_t *) msg->iov[0].iov_base) + ISAKMP_HDR_MESSAGE_ID_OFF,
		     ISAKMP_HDR_MESSAGE_ID_LEN);
	hash->Final(hash->digest, hash->ctx);
	crypto_init_iv(ks, hash->digest, ks->xf->blocksize);
	LOG_DBG_BUF((LOG_CRYPTO, 80, "ipsec_get_keystate: phase 2 IV",
		     hash->digest, ks->xf->blocksize));
	return ks;
d735 1
a735 1
ipsec_setup_situation(u_int8_t * buf)
d737 1
a737 1
	SET_IPSEC_SIT_SIT(buf + ISAKMP_SA_SIT_OFF, IPSEC_SIT_IDENTITY_ONLY);
d740 2
a741 2
static          size_t
ipsec_situation_size(void)
d743 1
a743 1
	return IPSEC_SIT_SIT_LEN;
d746 2
a747 2
static          u_int8_t
ipsec_spi_size(u_int8_t proto)
d749 1
a749 1
	return IPSEC_SPI_SIZE;
d753 2
a754 2
ipsec_validate_attribute(u_int16_t type, u_int8_t * value, u_int16_t len,
			 void *vmsg)
d756 1
a756 1
	struct message *msg = vmsg;
d758 8
a765 8
	if ((msg->exchange->phase == 1
	     && (type < IKE_ATTR_ENCRYPTION_ALGORITHM
		 || type > IKE_ATTR_GROUP_ORDER))
	    || (msg->exchange->phase == 2
		&& (type < IPSEC_ATTR_SA_LIFE_TYPE
		    || type > IPSEC_ATTR_ECN_TUNNEL)))
		return -1;
	return 0;
d769 1
a769 1
ipsec_validate_exchange(u_int8_t exch)
d771 1
a771 1
	return exch != IKE_EXCH_QUICK_MODE && exch != IKE_EXCH_NEW_GROUP_MODE;
d775 2
a776 2
ipsec_validate_id_information(u_int8_t type, u_int8_t * extra, u_int8_t * buf,
			      size_t sz, struct exchange * exchange)
d778 2
a779 2
	u_int8_t        proto = GET_IPSEC_ID_PROTO(extra);
	u_int16_t       port = GET_IPSEC_ID_PORT(extra);
d781 5
a785 5
	LOG_DBG((LOG_MESSAGE, 40,
		 "ipsec_validate_id_information: proto %d port %d type %d",
		 proto, port, type));
	if (type < IPSEC_ID_IPV4_ADDR || type > IPSEC_ID_KEY_ID)
		return -1;
d787 6
a792 5
	switch (type) {
	case IPSEC_ID_IPV4_ADDR:
		LOG_DBG_BUF((LOG_MESSAGE, 40, "ipsec_validate_id_information: IPv4",
			     buf, sizeof(struct in_addr)));
		break;
d794 4
a797 4
	case IPSEC_ID_IPV6_ADDR:
		LOG_DBG_BUF((LOG_MESSAGE, 40, "ipsec_validate_id_information: IPv6",
			     buf, sizeof(struct in6_addr)));
		break;
d799 5
a803 5
	case IPSEC_ID_IPV4_ADDR_SUBNET:
		LOG_DBG_BUF((LOG_MESSAGE, 40,
		      "ipsec_validate_id_information: IPv4 network/netmask",
			     buf, 2 * sizeof(struct in_addr)));
		break;
d805 5
a809 5
	case IPSEC_ID_IPV6_ADDR_SUBNET:
		LOG_DBG_BUF((LOG_MESSAGE, 40,
		      "ipsec_validate_id_information: IPv6 network/netmask",
			     buf, 2 * sizeof(struct in6_addr)));
		break;
d811 3
a813 3
	default:
		break;
	}
d815 5
a819 7
	if (exchange->phase == 1
	    && (proto != IPPROTO_UDP || port != UDP_DEFAULT_PORT)
	    && (proto != 0 || port != 0)) {
		/*
		 * XXX SSH's ISAKMP tester fails this test (proto 17 - port
		 * 0).
		 */
d821 1
a821 1
		return -1;
d823 2
a824 2
		log_print("ipsec_validate_id_information: "
			  "dubious ID information accepted");
d826 3
a828 2
	}
	/* XXX More checks?  */
d830 1
a830 1
	return 0;
d834 1
a834 1
ipsec_validate_key_information(u_int8_t * buf, size_t sz)
d836 2
a837 2
	/* XXX Not implemented yet.  */
	return 0;
d841 1
a841 1
ipsec_validate_notification(u_int16_t type)
d843 2
a844 2
	return type < IPSEC_NOTIFY_RESPONDER_LIFETIME
	|| type > IPSEC_NOTIFY_INITIAL_CONTACT ? -1 : 0;
d848 1
a848 1
ipsec_validate_proto(u_int8_t proto)
d850 1
a850 1
	return proto < IPSEC_PROTO_IPSEC_AH || proto > IPSEC_PROTO_IPCOMP ? -1 : 0;
d854 1
a854 1
ipsec_validate_situation(u_int8_t * buf, size_t * sz, size_t len)
d856 2
a857 8
	if (len < IPSEC_SIT_SIT_OFF + IPSEC_SIT_SIT_LEN) {
		log_print("ipsec_validate_situation: payload too short: %u",
			  (unsigned int) len);
		return -1;
	}
	/* Currently only "identity only" situations are supported.  */
	if (GET_IPSEC_SIT_SIT(buf) != IPSEC_SIT_IDENTITY_ONLY)
		return 1;
d859 15
a873 1
	*sz = IPSEC_SIT_SIT_LEN;
d875 9
a883 1
	return 0;
d887 1
a887 1
ipsec_validate_transform_id(u_int8_t proto, u_int8_t transform_id)
d889 21
a909 20
	switch (proto) {
		/*
		 * As no unexpected protocols can occur, we just tie the default case
		 * to the first case, in orer to silence a GCC warning.
	         */
		default:
		case ISAKMP_PROTO_ISAKMP:
		return transform_id != IPSEC_TRANSFORM_KEY_IKE;
	case IPSEC_PROTO_IPSEC_AH:
		return
			transform_id < IPSEC_AH_MD5 || transform_id > IPSEC_AH_DES ? -1 : 0;
	case IPSEC_PROTO_IPSEC_ESP:
		return transform_id < IPSEC_ESP_DES_IV64
			|| (transform_id > IPSEC_ESP_AES_128_CTR
			    && transform_id < IPSEC_ESP_AES_MARS)
			|| transform_id > IPSEC_ESP_AES_TWOFISH ? -1 : 0;
	case IPSEC_PROTO_IPCOMP:
		return transform_id < IPSEC_IPCOMP_OUI
			|| transform_id > IPSEC_IPCOMP_V42BIS ? -1 : 0;
	}
d913 23
a935 20
ipsec_initiator(struct message * msg)
{
	struct exchange *exchange = msg->exchange;
	int             (**script) (struct message *) = 0;

	/* Check that the SA is coherent with the IKE rules.  */
	if (exchange->type != ISAKMP_EXCH_TRANSACTION
	  && ((exchange->phase == 1 && exchange->type != ISAKMP_EXCH_ID_PROT
	       && exchange->type != ISAKMP_EXCH_AGGRESSIVE
	       && exchange->type != ISAKMP_EXCH_INFO)
	   || (exchange->phase == 2 && exchange->type != IKE_EXCH_QUICK_MODE
	       && exchange->type != ISAKMP_EXCH_INFO))) {
		log_print("ipsec_initiator: unsupported exchange type %d in phase %d",
			  exchange->type, exchange->phase);
		return -1;
	}
	switch (exchange->type) {
	case ISAKMP_EXCH_ID_PROT:
		script = ike_main_mode_initiator;
		break;
d937 3
a939 3
	case ISAKMP_EXCH_AGGRESSIVE:
		script = ike_aggressive_initiator;
		break;
d942 18
a959 18
	case ISAKMP_EXCH_TRANSACTION:
		script = isakmp_cfg_initiator;
		break;
#endif
	case ISAKMP_EXCH_INFO:
		return message_send_info(msg);
	case IKE_EXCH_QUICK_MODE:
		script = ike_quick_mode_initiator;
		break;
	default:
		log_print("ipsec_initiator: unsupported exchange type %d",
			  exchange->type);
		return -1;
	}

	/* Run the script code for this step.  */
	if (script)
		return script[exchange->step] (msg);
d961 1
a961 1
	return 0;
d971 2
a972 2
ipsec_delete_spi_list(struct sockaddr * addr, u_int8_t proto,
		      u_int8_t * spis, int nspis, char *type)
d974 2
a975 29
	struct sa      *sa;
	int             i;

	for (i = 0; i < nspis; i++) {
		if (proto == ISAKMP_PROTO_ISAKMP) {
			u_int8_t       *spi = spis + i * ISAKMP_HDR_COOKIES_LEN;

			/*
			 * This really shouldn't happen in IPSEC DOI
			 * code, but Cisco VPN 3000 sends ISAKMP DELETE's
			 * this way.
			 */
			sa = sa_lookup_isakmp_sa(addr, spi);
		} else {
			u_int32_t       spi = ((u_int32_t *) spis)[i];

			sa = ipsec_sa_lookup(addr, spi, proto);
		}

		if (sa == NULL) {
			LOG_DBG((LOG_SA, 30, "ipsec_delete_spi_list: "
				 "could not locate SA (SPI %08x, proto %u)",
				 ((u_int32_t *) spis)[i], proto));
			continue;
		}
		/* Delete the SA and search for the next */
		LOG_DBG((LOG_SA, 30, "ipsec_delete_spi_list: "
		     "%s made us delete SA %p (%d references) for proto %d",
			 type, sa, sa->refcnt, proto));
d977 64
a1040 28
		sa_free(sa);
	}
}

static int
ipsec_responder(struct message * msg)
{
	struct exchange *exchange = msg->exchange;
	int             (**script) (struct message *) = 0;
	struct payload *p;
	u_int16_t       type;

	/* Check that a new exchange is coherent with the IKE rules.  */
	if (exchange->step == 0 && exchange->type != ISAKMP_EXCH_TRANSACTION
	  && ((exchange->phase == 1 && exchange->type != ISAKMP_EXCH_ID_PROT
	       && exchange->type != ISAKMP_EXCH_AGGRESSIVE
	       && exchange->type != ISAKMP_EXCH_INFO)
	      || (exchange->phase == 2 && exchange->type == ISAKMP_EXCH_ID_PROT))) {
		message_drop(msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE, 0, 1, 0);
		return -1;
	}
	LOG_DBG((LOG_MISC, 30,
	   "ipsec_responder: phase %d exchange %d step %d", exchange->phase,
		 exchange->type, exchange->step));
	switch (exchange->type) {
	case ISAKMP_EXCH_ID_PROT:
		script = ike_main_mode_responder;
		break;
d1043 3
a1045 3
	case ISAKMP_EXCH_AGGRESSIVE:
		script = ike_aggressive_responder;
		break;
d1049 58
a1106 56
	case ISAKMP_EXCH_TRANSACTION:
		script = isakmp_cfg_responder;
		break;
#endif

	case ISAKMP_EXCH_INFO:
		for (p = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_NOTIFY]); p;
		     p = TAILQ_NEXT(p, link)) {
			type = GET_ISAKMP_NOTIFY_MSG_TYPE(p->p);
			LOG_DBG((LOG_EXCHANGE, 10,
				 "ipsec_responder: got NOTIFY of type %s",
				 constant_name(isakmp_notify_cst, type)));

			p->flags |= PL_MARK;
		}

		/*
		 * If any DELETEs are in here, let the logic of leftover payloads deal
		 * with them.
	         */

		return 0;

	case IKE_EXCH_QUICK_MODE:
		script = ike_quick_mode_responder;
		break;

	default:
		message_drop(msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE, 0, 1, 0);
		return -1;
	}

	/* Run the script code for this step.  */
	if (script)
		return script[exchange->step] (msg);

	/*
	 * XXX So far we don't accept any proposals for exchanges we don't support.
         */
	if (TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_SA])) {
		message_drop(msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
		return -1;
	}
	return 0;
}

static enum hashes
from_ike_hash(u_int16_t hash)
{
	switch (hash) {
		case IKE_HASH_MD5:
		return HASH_MD5;
	case IKE_HASH_SHA:
		return HASH_SHA1;
	}
	return -1;
d1109 1
a1109 2
static enum transform
from_ike_crypto(u_int16_t crypto)
d1111 2
a1112 2
	/* Coincidentally this is the null operation :-)  */
	return crypto;
d1121 2
a1122 2
ipsec_is_attribute_incompatible(u_int16_t type, u_int8_t * value,
				u_int16_t len, void *vmsg)
d1124 1
a1124 1
	struct message *msg = vmsg;
d1126 81
a1206 79
	if (msg->exchange->phase == 1) {
		switch (type) {
		case IKE_ATTR_ENCRYPTION_ALGORITHM:
			return !crypto_get(from_ike_crypto(decode_16(value)));
		case IKE_ATTR_HASH_ALGORITHM:
			return !hash_get(from_ike_hash(decode_16(value)));
		case IKE_ATTR_AUTHENTICATION_METHOD:
			return !ike_auth_get(decode_16(value));
		case IKE_ATTR_GROUP_DESCRIPTION:
			return (decode_16(value) < IKE_GROUP_DESC_MODP_768
			     || decode_16(value) > IKE_GROUP_DESC_MODP_1536)
				&& (decode_16(value) < IKE_GROUP_DESC_MODP_2048
			    || decode_16(value) > IKE_GROUP_DESC_MODP_8192);
		case IKE_ATTR_GROUP_TYPE:
			return 1;
		case IKE_ATTR_GROUP_PRIME:
			return 1;
		case IKE_ATTR_GROUP_GENERATOR_1:
			return 1;
		case IKE_ATTR_GROUP_GENERATOR_2:
			return 1;
		case IKE_ATTR_GROUP_CURVE_A:
			return 1;
		case IKE_ATTR_GROUP_CURVE_B:
			return 1;
		case IKE_ATTR_LIFE_TYPE:
			return decode_16(value) < IKE_DURATION_SECONDS
				|| decode_16(value) > IKE_DURATION_KILOBYTES;
		case IKE_ATTR_LIFE_DURATION:
			return len != 2 && len != 4;
		case IKE_ATTR_PRF:
			return 1;
		case IKE_ATTR_KEY_LENGTH:
			/*
			 * Our crypto routines only allows key-lengths which are multiples
			 * of an octet.
		         */
			return decode_16(value) % 8 != 0;
		case IKE_ATTR_FIELD_SIZE:
			return 1;
		case IKE_ATTR_GROUP_ORDER:
			return 1;
		}
	} else {
		switch (type) {
		case IPSEC_ATTR_SA_LIFE_TYPE:
			return decode_16(value) < IPSEC_DURATION_SECONDS
				|| decode_16(value) > IPSEC_DURATION_KILOBYTES;
		case IPSEC_ATTR_SA_LIFE_DURATION:
			return len != 2 && len != 4;
		case IPSEC_ATTR_GROUP_DESCRIPTION:
			return (decode_16(value) < IKE_GROUP_DESC_MODP_768
			     || decode_16(value) > IKE_GROUP_DESC_MODP_1536)
				&& (decode_16(value) < IKE_GROUP_DESC_MODP_2048
			    || IKE_GROUP_DESC_MODP_8192 < decode_16(value));
		case IPSEC_ATTR_ENCAPSULATION_MODE:
			return decode_16(value) < IPSEC_ENCAP_TUNNEL
				|| decode_16(value) > IPSEC_ENCAP_TRANSPORT;
		case IPSEC_ATTR_AUTHENTICATION_ALGORITHM:
			return decode_16(value) < IPSEC_AUTH_HMAC_MD5
				|| decode_16(value) > IPSEC_AUTH_HMAC_RIPEMD;
		case IPSEC_ATTR_KEY_LENGTH:
			/*
			 * XXX Blowfish needs '0'. Others appear to disregard
			 * this attr?
			 */
			return 0;
		case IPSEC_ATTR_KEY_ROUNDS:
			return 1;
		case IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE:
			return 1;
		case IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM:
			return 1;
		case IPSEC_ATTR_ECN_TUNNEL:
			return 1;
		}
	}
	/* XXX Silence gcc.  */
	return 1;
d1215 2
a1216 2
ipsec_debug_attribute(u_int16_t type, u_int8_t * value, u_int16_t len,
		      void *vmsg)
d1218 2
a1219 2
	struct message *msg = vmsg;
	char            val[20];
d1221 13
a1233 13
	/* XXX Transient solution.  */
	if (len == 2)
		snprintf(val, sizeof val, "%d", decode_16(value));
	else if (len == 4)
		snprintf(val, sizeof val, "%d", decode_32(value));
	else
		snprintf(val, sizeof val, "unrepresentable");

	LOG_DBG((LOG_MESSAGE, 50, "Attribute %s value %s",
		 constant_name(msg->exchange->phase == 1
			       ? ike_attr_cst : ipsec_attr_cst, type),
		 val));
	return 0;
d1243 2
a1244 2
ipsec_decode_attribute(u_int16_t type, u_int8_t * value, u_int16_t len,
		       void *vida)
d1246 109
a1354 81
	struct ipsec_decode_arg *ida = vida;
	struct message *msg = ida->msg;
	struct sa      *sa = ida->sa;
	struct ipsec_sa *isa = sa->data;
	struct proto   *proto = ida->proto;
	struct ipsec_proto *iproto = proto->data;
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	static int      lifetype = 0;

	if (exchange->phase == 1) {
		switch (type) {
		case IKE_ATTR_ENCRYPTION_ALGORITHM:
			/* XXX Errors possible?  */
			exchange->crypto = crypto_get(from_ike_crypto(decode_16(value)));
			break;
		case IKE_ATTR_HASH_ALGORITHM:
			/* XXX Errors possible?  */
			ie->hash = hash_get(from_ike_hash(decode_16(value)));
			break;
		case IKE_ATTR_AUTHENTICATION_METHOD:
			/* XXX Errors possible?  */
			ie->ike_auth = ike_auth_get(decode_16(value));
			break;
		case IKE_ATTR_GROUP_DESCRIPTION:
			isa->group_desc = decode_16(value);
			break;
		case IKE_ATTR_GROUP_TYPE:
			break;
		case IKE_ATTR_GROUP_PRIME:
			break;
		case IKE_ATTR_GROUP_GENERATOR_1:
			break;
		case IKE_ATTR_GROUP_GENERATOR_2:
			break;
		case IKE_ATTR_GROUP_CURVE_A:
			break;
		case IKE_ATTR_GROUP_CURVE_B:
			break;
		case IKE_ATTR_LIFE_TYPE:
			lifetype = decode_16(value);
			return 0;
		case IKE_ATTR_LIFE_DURATION:
			switch (lifetype) {
			case IKE_DURATION_SECONDS:
				switch (len) {
				case 2:
					sa->seconds = decode_16(value);
					break;
				case 4:
					sa->seconds = decode_32(value);
					break;
				default:
					log_print("ipsec_decode_attribute: unreasonable lifetime");
				}
				break;
			case IKE_DURATION_KILOBYTES:
				switch (len) {
				case 2:
					sa->kilobytes = decode_16(value);
					break;
				case 4:
					sa->kilobytes = decode_32(value);
					break;
				default:
					log_print("ipsec_decode_attribute: unreasonable lifetime");
				}
				break;
			default:
				log_print("ipsec_decode_attribute: unknown lifetime type");
			}
			break;
		case IKE_ATTR_PRF:
			break;
		case IKE_ATTR_KEY_LENGTH:
			exchange->key_length = decode_16(value) / 8;
			break;
		case IKE_ATTR_FIELD_SIZE:
			break;
		case IKE_ATTR_GROUP_ORDER:
			break;
d1356 12
a1367 60
	} else {
		switch (type) {
		case IPSEC_ATTR_SA_LIFE_TYPE:
			lifetype = decode_16(value);
			return 0;
		case IPSEC_ATTR_SA_LIFE_DURATION:
			switch (lifetype) {
			case IPSEC_DURATION_SECONDS:
				switch (len) {
				case 2:
					sa->seconds = decode_16(value);
					break;
				case 4:
					sa->seconds = decode_32(value);
					break;
				default:
					log_print("ipsec_decode_attribute: unreasonable lifetime");
				}
				break;
			case IPSEC_DURATION_KILOBYTES:
				switch (len) {
				case 2:
					sa->kilobytes = decode_16(value);
					break;
				case 4:
					sa->kilobytes = decode_32(value);
					break;
				default:
					log_print("ipsec_decode_attribute: unreasonable lifetime");
				}
				break;
			default:
				log_print("ipsec_decode_attribute: unknown lifetime type");
			}
			break;
		case IPSEC_ATTR_GROUP_DESCRIPTION:
			isa->group_desc = decode_16(value);
			break;
		case IPSEC_ATTR_ENCAPSULATION_MODE:
			/*
			 * XXX Multiple protocols must have same
			 * encapsulation mode, no?
			 */
			iproto->encap_mode = decode_16(value);
			break;
		case IPSEC_ATTR_AUTHENTICATION_ALGORITHM:
			iproto->auth = decode_16(value);
			break;
		case IPSEC_ATTR_KEY_LENGTH:
			iproto->keylen = decode_16(value);
			break;
		case IPSEC_ATTR_KEY_ROUNDS:
			iproto->keyrounds = decode_16(value);
			break;
		case IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE:
			break;
		case IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM:
			break;
		case IPSEC_ATTR_ECN_TUNNEL:
			break;
d1369 31
a1399 3
	}
	lifetype = 0;
	return 0;
d1408 2
a1409 2
ipsec_decode_transform(struct message * msg, struct sa * sa,
		       struct proto * proto, u_int8_t * buf)
d1411 2
a1412 2
	struct ipsec_exch *ie = msg->exchange->data;
	struct ipsec_decode_arg ida;
d1414 2
a1415 2
	LOG_DBG((LOG_MISC, 20, "ipsec_decode_transform: transform %d chosen",
		 GET_ISAKMP_TRANSFORM_NO(buf)));
d1417 19
a1435 19
	ida.msg = msg;
	ida.sa = sa;
	ida.proto = proto;

	/* The default IKE lifetime is 8 hours.  */
	if (sa->phase == 1)
		sa->seconds = 28800;

	/* Extract the attributes and stuff them into the SA.  */
	attribute_map(buf + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		 GET_ISAKMP_GEN_LENGTH(buf) - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		      ipsec_decode_attribute, &ida);

	/*
	 * If no pseudo-random function was negotiated, it's HMAC.
	 * XXX As PRF_HMAC currently is zero, this is a no-op.
         */
	if (!ie->prf_type)
		ie->prf_type = PRF_HMAC;
d1443 1
a1443 1
ipsec_delete_spi(struct sa * sa, struct proto * proto, int incoming)
d1445 4
a1448 4
	if (sa->phase == 1)
		return;
	/* XXX Error handling?  Is it interesting?  */
	sysdep_ipsec_delete_spi(sa, proto, incoming);
d1456 1
a1456 1
ipsec_g_x(struct message * msg, int peer, u_int8_t * buf)
d1458 17
a1474 16
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	u_int8_t      **g_x;
	int             initiator = exchange->initiator ^ peer;
	char            header[32];

	g_x = initiator ? &ie->g_xi : &ie->g_xr;
	*g_x = malloc(ie->g_x_len);
	if (!*g_x) {
		log_error("ipsec_g_x: malloc (%lu) failed", (unsigned long) ie->g_x_len);
		return -1;
	}
	memcpy(*g_x, buf, ie->g_x_len);
	snprintf(header, sizeof header, "ipsec_g_x: g^x%c", initiator ? 'i' : 'r');
	LOG_DBG_BUF((LOG_MISC, 80, header, *g_x, ie->g_x_len));
	return 0;
d1479 1
a1479 1
ipsec_gen_g_x(struct message * msg)
d1481 26
a1506 21
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	u_int8_t       *buf;

	buf = malloc(ISAKMP_KE_SZ + ie->g_x_len);
	if (!buf) {
		log_error("ipsec_gen_g_x: malloc (%lu) failed",
			  ISAKMP_KE_SZ + (unsigned long) ie->g_x_len);
		return -1;
	}
	if (message_add_payload(msg, ISAKMP_PAYLOAD_KEY_EXCH, buf,
				ISAKMP_KE_SZ + ie->g_x_len, 1)) {
		free(buf);
		return -1;
	}
	if (dh_create_exchange(ie->group, buf + ISAKMP_KE_DATA_OFF)) {
		log_print("ipsec_gen_g_x: dh_create_exchange failed");
		free(buf);
		return -1;
	}
	return ipsec_g_x(msg, 0, buf + ISAKMP_KE_DATA_OFF);
d1511 1
a1511 1
ipsec_save_g_x(struct message * msg)
d1513 17
a1529 15
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct payload *kep;

	kep = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_KEY_EXCH]);
	kep->flags |= PL_MARK;
	ie->g_x_len = GET_ISAKMP_GEN_LENGTH(kep->p) - ISAKMP_KE_DATA_OFF;

	/* Check that the given length matches the group's expectancy.  */
	if (ie->g_x_len != (size_t) dh_getlen(ie->group)) {
		/* XXX Is this a good notify type?  */
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
		return -1;
	}
	return ipsec_g_x(msg, 1, kep->p + ISAKMP_KE_DATA_OFF);
d1537 1
a1537 1
ipsec_get_spi(size_t * sz, u_int8_t proto, struct message * msg)
d1539 2
a1540 2
	struct sockaddr *dst, *src;
	struct transport *transport = msg->transport;
d1542 13
a1554 10
	if (msg->exchange->phase == 1) {
		*sz = 0;
		return 0;
	} else {
		/* We are the destination in the SA we want a SPI for.  */
		transport->vtbl->get_src(transport, &dst);
		/* The peer is the source.  */
		transport->vtbl->get_dst(transport, &src);
		return sysdep_ipsec_get_spi(sz, proto, src, dst, msg->exchange->seq);
	}
d1564 2
a1565 2
ipsec_handle_leftover_payload(struct message * msg, u_int8_t type,
			      struct payload * payload)
d1567 113
a1679 99
	u_int32_t       spisz, nspis;
	struct sockaddr *dst;
	int             reenter = 0;
	u_int8_t       *spis, proto;
	struct sa      *sa;

	switch (type) {
	case ISAKMP_PAYLOAD_DELETE:
		proto = GET_ISAKMP_DELETE_PROTO(payload->p);
		nspis = GET_ISAKMP_DELETE_NSPIS(payload->p);
		spisz = GET_ISAKMP_DELETE_SPI_SZ(payload->p);

		if (nspis == 0) {
			LOG_DBG((LOG_SA, 60, "ipsec_handle_leftover_payload: message "
				 "specified zero SPIs, ignoring"));
			return -1;
		}
		/* verify proper SPI size */
		if ((proto == ISAKMP_PROTO_ISAKMP && spisz != ISAKMP_HDR_COOKIES_LEN)
		    || (proto != ISAKMP_PROTO_ISAKMP && spisz != sizeof(u_int32_t))) {
			log_print("ipsec_handle_leftover_payload: "
			"invalid SPI size %d for proto %d in DELETE payload",
				  spisz, proto);
			return -1;
		}
		spis = (u_int8_t *) malloc(nspis * spisz);
		if (!spis) {
			log_error("ipsec_handle_leftover_payload: malloc (%d) failed",
				  nspis * spisz);
			return -1;
		}
		/* extract SPI and get dst address */
		memcpy(spis, payload->p + ISAKMP_DELETE_SPI_OFF, nspis * spisz);
		msg->transport->vtbl->get_dst(msg->transport, &dst);

		ipsec_delete_spi_list(dst, proto, spis, nspis, "DELETE");

		free(spis);
		payload->flags |= PL_MARK;
		return 0;

	case ISAKMP_PAYLOAD_NOTIFY:
		switch (GET_ISAKMP_NOTIFY_MSG_TYPE(payload->p)) {
		case IPSEC_NOTIFY_INITIAL_CONTACT:
			/*
			 * Permit INITIAL-CONTACT if
			 *   - this is not an AGGRESSIVE mode exchange
			 *   - it is protected by an ISAKMP SA
		         *
			 * XXX Instead of the first condition above, we could permit this
			 * XXX only for phase 2. In the last packet of main-mode, this
			 * XXX payload, while encrypted, is not part of the hash digest.
			 * XXX As we currently send our own INITIAL-CONTACTs at this point,
			 * XXX this too would need to be changed.
		         */
			if (msg->exchange->type == ISAKMP_EXCH_AGGRESSIVE) {
				log_print("ipsec_handle_leftover_payload: got INITIAL-CONTACT "
					  "in AGGRESSIVE mode");
				return -1;
			}
			if ((msg->exchange->flags & EXCHANGE_FLAG_ENCRYPT) == 0) {
				log_print("ipsec_handle_leftover_payload: got INITIAL-CONTACT "
					  "without ISAKMP SA");
				return -1;
			}
			/*
			 * Find out who is sending this and then delete every SA that is
			 * ready.  Exchanges will timeout themselves and then the
			 * non-ready SAs will disappear too.
		         */
			msg->transport->vtbl->get_dst(msg->transport, &dst);
			while ((sa = sa_lookup_by_peer(dst, sysdep_sa_len(dst))) != 0) {
				/*
				 * Don't delete the current SA -- we received the
				 * notification over it, so it's obviously still
				 * active. We temporarily need to remove the SA
				 * from the list to avoid an endless loop, but
				 * keep a reference so it won't disappear meanwhile.
			         */
				if (sa == msg->isakmp_sa) {
					sa_reference(sa);
					sa_remove(sa);
					reenter = 1;
					continue;
				}
				LOG_DBG((LOG_SA, 30,
				    "ipsec_handle_leftover_payload: "
				    "INITIAL-CONTACT made us delete SA %p",
				    sa));
				sa_delete(sa, 0);
			}

			if (reenter) {
				sa_enter(msg->isakmp_sa);
				sa_release(msg->isakmp_sa);
			}
			payload->flags |= PL_MARK;
			return 0;
		}
d1681 2
a1682 1
	return -1;
d1687 1
a1687 1
ipsec_esp_enckeylength(struct proto * proto)
d1689 1
a1689 1
	struct ipsec_proto *iproto = proto->data;
d1691 21
a1711 20
	/* Compute the keylength to use.  */
	switch (proto->id) {
	case IPSEC_ESP_DES:
	case IPSEC_ESP_DES_IV32:
	case IPSEC_ESP_DES_IV64:
		return 8;
	case IPSEC_ESP_3DES:
		return 24;
	case IPSEC_ESP_CAST:
		if (!iproto->keylen)
			return 16;
		return iproto->keylen / 8;
	case IPSEC_ESP_AES:
	case IPSEC_ESP_AES_128_CTR:
		if (!iproto->keylen)
			return 16;
		/* Fallthrough */
	default:
		return iproto->keylen / 8;
	}
d1716 1
a1716 1
ipsec_esp_authkeylength(struct proto * proto)
d1718 1
a1718 1
	struct ipsec_proto *iproto = proto->data;
d1720 16
a1735 15
	switch (iproto->auth) {
	case IPSEC_AUTH_HMAC_MD5:
		return 16;
	case IPSEC_AUTH_HMAC_SHA:
	case IPSEC_AUTH_HMAC_RIPEMD:
		return 20;
	case IPSEC_AUTH_HMAC_SHA2_256:
		return 32;
	case IPSEC_AUTH_HMAC_SHA2_384:
		return 48;
	case IPSEC_AUTH_HMAC_SHA2_512:
		return 64;
	default:
		return 0;
	}
d1740 1
a1740 1
ipsec_ah_keylength(struct proto * proto)
d1742 16
a1757 15
	switch (proto->id) {
		case IPSEC_AH_MD5:
		return 16;
	case IPSEC_AH_SHA:
	case IPSEC_AH_RIPEMD:
		return 20;
	case IPSEC_AH_SHA2_256:
		return 32;
	case IPSEC_AH_SHA2_384:
		return 48;
	case IPSEC_AH_SHA2_512:
		return 64;
	default:
		return -1;
	}
d1762 1
a1762 1
ipsec_keymat_length(struct proto * proto)
d1764 9
a1772 8
	switch (proto->proto) {
		case IPSEC_PROTO_IPSEC_ESP:
		return ipsec_esp_enckeylength(proto) + ipsec_esp_authkeylength(proto);
	case IPSEC_PROTO_IPSEC_AH:
		return ipsec_ah_keylength(proto);
	default:
		return -1;
	}
d1782 2
a1783 2
ipsec_get_id(char *section, int *id, struct sockaddr ** addr,
	     struct sockaddr ** mask, u_int8_t * tproto, u_int16_t * port)
d1785 1
a1785 1
	char           *type, *address, *netmask;
d1787 31
a1817 24
	type = conf_get_str(section, "ID-type");
	if (!type) {
		log_print("ipsec_get_id: section %s has no \"ID-type\" tag", section);
		return -1;
	}
	*id = constant_value(ipsec_id_cst, type);
	switch (*id) {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR:
		address = conf_get_str(section, "Address");
		if (!address) {
			log_print("ipsec_get_id: section %s has no \"Address\" tag",
				  section);
			return -1;
		}
		if (text2sockaddr(address, NULL, addr)) {
			log_print("ipsec_get_id: invalid address %s in section %s", address,
				  section);
			return -1;
		}
		*tproto = conf_get_num(section, "Protocol", 0);
		if (*tproto)
			*port = conf_get_num(section, "Port", 0);
		break;
d1820 2
a1821 2
	case IPSEC_ID_FQDN:
		return -1;
d1823 2
a1824 2
	case IPSEC_ID_USER_FQDN:
		return -1;
d1827 36
a1862 28
	case IPSEC_ID_IPV4_ADDR_SUBNET:
	case IPSEC_ID_IPV6_ADDR_SUBNET:
		address = conf_get_str(section, "Network");
		if (!address) {
			log_print("ipsec_get_id: section %s has no \"Network\" tag",
				  section);
			return -1;
		}
		if (text2sockaddr(address, NULL, addr)) {
			log_print("ipsec_get_id: invalid section %s network %s", section,
				  address);
			return -1;
		}
		netmask = conf_get_str(section, "Netmask");
		if (!netmask) {
			log_print("ipsec_get_id: section %s has no \"Netmask\" tag",
				  section);
			return -1;
		}
		if (text2sockaddr(netmask, NULL, mask)) {
			log_print("ipsec_id_build: invalid section %s network %s", section,
				  netmask);
			return -1;
		}
		*tproto = conf_get_num(section, "Protocol", 0);
		if (*tproto)
			*port = conf_get_num(section, "Port", 0);
		break;
d1865 2
a1866 2
	case IPSEC_ID_IPV4_RANGE:
		return -1;
d1868 2
a1869 2
	case IPSEC_ID_IPV6_RANGE:
		return -1;
d1871 2
a1872 2
	case IPSEC_ID_DER_ASN1_DN:
		return -1;
d1874 2
a1875 2
	case IPSEC_ID_DER_ASN1_GN:
		return -1;
d1877 2
a1878 2
	case IPSEC_ID_KEY_ID:
		return -1;
d1881 5
a1885 5
	default:
		log_print("ipsec_get_id: unknown ID type \"%s\" in section %s", type,
			  section);
		return -1;
	}
d1887 1
a1887 1
	return 0;
d1895 2
a1896 2
ipsec_decode_id(char *buf, size_t size, u_int8_t * id, size_t id_len,
		int isakmpform)
d1898 54
a1951 53
	int             id_type;
	char           *addr = 0, *mask = 0;
	u_int32_t      *idp;

	if (id) {
		if (!isakmpform) {
			/*
			 * Exchanges and SAs dont carry the IDs in ISAKMP
			 * form.
			 */
			id -= ISAKMP_GEN_SZ;
			id_len += ISAKMP_GEN_SZ;
		}
		id_type = GET_ISAKMP_ID_TYPE(id);
		idp = (u_int32_t *) (id + ISAKMP_ID_DATA_OFF);
		switch (id_type) {
		case IPSEC_ID_IPV4_ADDR:
			util_ntoa(&addr, AF_INET, id + ISAKMP_ID_DATA_OFF);
			snprintf(buf, size, "%08x: %s",
				 decode_32(id + ISAKMP_ID_DATA_OFF), addr);
			break;

		case IPSEC_ID_IPV4_ADDR_SUBNET:
			util_ntoa(&addr, AF_INET, id + ISAKMP_ID_DATA_OFF);
			util_ntoa(&mask, AF_INET, id + ISAKMP_ID_DATA_OFF + 4);
			snprintf(buf, size, "%08x/%08x: %s/%s",
				 decode_32(id + ISAKMP_ID_DATA_OFF),
			decode_32(id + ISAKMP_ID_DATA_OFF + 4), addr, mask);
			break;

		case IPSEC_ID_IPV6_ADDR:
			util_ntoa(&addr, AF_INET6, id + ISAKMP_ID_DATA_OFF);
			snprintf(buf, size, "%08x%08x%08x%08x: %s", *idp, *(idp + 1),
				 *(idp + 2), *(idp + 3), addr);
			break;

		case IPSEC_ID_IPV6_ADDR_SUBNET:
			util_ntoa(&addr, AF_INET6, id + ISAKMP_ID_DATA_OFF);
			util_ntoa(&addr, AF_INET6, id + ISAKMP_ID_DATA_OFF +
				  sizeof(struct in6_addr));
			snprintf(buf, size, "%08x%08x%08x%08x/%08x%08x%08x%08x: %s/%s",
			*idp, *(idp + 1), *(idp + 2), *(idp + 3), *(idp + 4),
			    *(idp + 5), *(idp + 6), *(idp + 7), addr, mask);
			break;

		case IPSEC_ID_FQDN:
		case IPSEC_ID_USER_FQDN:
			/* String is not NUL terminated, be careful */
			id_len -= ISAKMP_ID_DATA_OFF;
			id_len = MIN(id_len, size - 1);
			memcpy(buf, id + ISAKMP_ID_DATA_OFF, id_len);
			buf[id_len] = '\0';
			break;
d1954 10
a1963 9
		case IPSEC_ID_DER_ASN1_DN:
			addr = x509_DN_string(id + ISAKMP_ID_DATA_OFF,
					      id_len - ISAKMP_ID_DATA_OFF);
			if (!addr) {
				snprintf(buf, size, "unparsable ASN1 DN ID");
				return;
			}
			strlcpy(buf, addr, size);
			break;
d1966 16
a1981 15
		default:
			snprintf(buf, size, "<id type unknown: %x>", id_type);
			break;
		}
	} else
		snprintf(buf, size, "<no ipsec id>");
	if (addr)
		free(addr);
	if (mask)
		free(mask);
}

char           *
ipsec_decode_ids(char *fmt, u_int8_t * id1, size_t id1_len,
		 u_int8_t * id2, size_t id2_len, int isakmpform)
d1983 2
a1984 2
	static char     result[1024];
	char            s_id1[256], s_id2[256];
d1986 2
a1987 2
	ipsec_decode_id(s_id1, sizeof s_id1, id1, id1_len, isakmpform);
	ipsec_decode_id(s_id2, sizeof s_id2, id2, id2_len, isakmpform);
d1989 2
a1990 2
	snprintf(result, sizeof result, fmt, s_id1, s_id2);
	return result;
d1998 2
a1999 2
u_int8_t       *
ipsec_build_id(char *section, size_t * sz)
d2001 31
a2031 29
	struct sockaddr *addr, *mask;
	u_int8_t       *p;
	int             id, subnet = 0;
	u_int8_t        tproto = 0;
	u_int16_t       port = 0;

	if (ipsec_get_id(section, &id, &addr, &mask, &tproto, &port))
		return 0;

	if (id == IPSEC_ID_IPV4_ADDR_SUBNET || id == IPSEC_ID_IPV6_ADDR_SUBNET)
		subnet = 1;

	*sz = ISAKMP_ID_SZ + sockaddr_addrlen(addr);
	if (subnet)
		*sz += sockaddr_addrlen(mask);

	p = malloc(*sz);
	if (!p) {
		log_print("ipsec_build_id: malloc(%lu) failed", (unsigned long) *sz);
		return 0;
	}
	SET_ISAKMP_ID_TYPE(p, id);
	SET_ISAKMP_ID_DOI_DATA(p, (unsigned char *) "\000\000\000");

	memcpy(p + ISAKMP_ID_DATA_OFF, sockaddr_addrdata(addr),
	       sockaddr_addrlen(addr));
	if (subnet)
		memcpy(p + ISAKMP_ID_DATA_OFF + sockaddr_addrlen(addr),
		       sockaddr_addrdata(mask), sockaddr_addrlen(mask));
d2033 2
a2034 2
	SET_IPSEC_ID_PROTO(p + ISAKMP_ID_DOI_DATA_OFF, tproto);
	SET_IPSEC_ID_PORT(p + ISAKMP_ID_DOI_DATA_OFF, port);
d2036 1
a2036 1
	return p;
d2043 1
a2043 1
ipsec_clone_id(u_int8_t ** did, size_t * did_len, u_int8_t * id, size_t id_len)
d2045 2
a2046 2
	if (*did)
		free(*did);
d2048 17
a2064 13
	if (!id_len || !id) {
		*did = 0;
		*did_len = 0;
		return 0;
	}
	*did = malloc(id_len);
	if (!*did) {
		*did_len = 0;
		log_error("ipsec_clone_id: malloc(%lu) failed", (unsigned long) id_len);
		return -1;
	}
	*did_len = id_len;
	memcpy(*did, id, id_len);
d2066 1
a2066 1
	return 0;
d2075 1
a2075 1
ipsec_proto_init(struct proto * proto, char *section)
d2077 1
a2077 1
	struct ipsec_proto *iproto = proto->data;
d2079 3
a2081 3
	if (proto->sa->phase == 2 && section)
		iproto->replay_window
			= conf_get_num(section, "ReplayWindow", DEFAULT_REPLAY_WINDOW);
d2089 1
a2089 1
ipsec_initial_contact(struct message * msg)
d2091 1
a2091 1
	u_int8_t       *buf;
d2093 2
a2094 2
	if (ipsec_contacted(msg))
		return 0;
d2096 21
a2116 18
	buf = malloc(ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN);
	if (!buf) {
		log_error("ike_phase_1_initial_contact: malloc (%d) failed",
			  ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN);
		return -1;
	}
	SET_ISAKMP_NOTIFY_DOI(buf, IPSEC_DOI_IPSEC);
	SET_ISAKMP_NOTIFY_PROTO(buf, ISAKMP_PROTO_ISAKMP);
	SET_ISAKMP_NOTIFY_SPI_SZ(buf, ISAKMP_HDR_COOKIES_LEN);
	SET_ISAKMP_NOTIFY_MSG_TYPE(buf, IPSEC_NOTIFY_INITIAL_CONTACT);
	memcpy(buf + ISAKMP_NOTIFY_SPI_OFF, msg->isakmp_sa->cookies,
	       ISAKMP_HDR_COOKIES_LEN);
	if (message_add_payload(msg, ISAKMP_PAYLOAD_NOTIFY, buf,
			    ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN, 1)) {
		free(buf);
		return -1;
	}
	return ipsec_add_contact(msg);
d2124 1
a2124 1
addr_cmp(const void *a, const void *b)
d2126 3
a2128 3
	const struct contact *x = a, *y = b;
	int             minlen = MIN(x->len, y->len);
	int             rv = memcmp(x->addr, y->addr, minlen);
d2130 1
a2130 1
	return rv ? rv : (x->len - y->len);
d2140 1
a2140 1
ipsec_add_contact(struct message * msg)
d2142 34
a2175 31
	struct contact *new_contacts;
	struct sockaddr *dst, *addr;
	int             cnt;

	if (contact_cnt == contact_limit) {
		cnt = contact_limit ? 2 * contact_limit : 64;
		new_contacts = realloc(contacts, cnt * sizeof contacts[0]);
		if (!new_contacts) {
			log_error("ipsec_add_contact: realloc (%p, %lu) failed", contacts,
				  cnt * (unsigned long) sizeof contacts[0]);
			return -1;
		}
		contact_limit = cnt;
		contacts = new_contacts;
	}
	msg->transport->vtbl->get_dst(msg->transport, &dst);
	addr = malloc(sysdep_sa_len(dst));
	if (!addr) {
		log_error("ipsec_add_contact: malloc (%d) failed", sysdep_sa_len(dst));
		return -1;
	}
	memcpy(addr, dst, sysdep_sa_len(dst));
	contacts[contact_cnt].addr = addr;
	contacts[contact_cnt++].len = sysdep_sa_len(dst);

	/*
	 * XXX There are better algorithms for already mostly-sorted data like
	 * this, but only qsort is standard.  I will someday do this inline.
         */
	qsort(contacts, contact_cnt, sizeof *contacts, addr_cmp);
	return 0;
d2180 1
a2180 1
ipsec_contacted(struct message * msg)
d2182 1
a2182 1
	struct contact  contact;
d2184 6
a2189 6
	msg->transport->vtbl->get_dst(msg->transport, &contact.addr);
	contact.len = sysdep_sa_len(contact.addr);
	return contacts
		? (bsearch(&contact, contacts, contact_cnt, sizeof *contacts, addr_cmp)
		   != 0)
		: 0;
d2193 2
a2194 2
u_int8_t       *
ipsec_add_hash_payload(struct message * msg, size_t hashsize)
d2196 16
a2211 1
	u_int8_t       *buf;
d2213 1
a2213 12
	buf = malloc(ISAKMP_HASH_SZ + hashsize);
	if (!buf) {
		log_error("ipsec_add_hash_payload: malloc (%lu) failed",
			  ISAKMP_HASH_SZ + (unsigned long) hashsize);
		return 0;
	}
	if (message_add_payload(msg, ISAKMP_PAYLOAD_HASH, buf,
				ISAKMP_HASH_SZ + hashsize, 1)) {
		free(buf);
		return 0;
	}
	return buf;
d2218 1
a2218 1
ipsec_fill_in_hash(struct message * msg)
d2220 48
a2267 46
	struct exchange *exchange = msg->exchange;
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct ipsec_sa *isa = isakmp_sa->data;
	struct hash    *hash = hash_get(isa->hash);
	struct prf     *prf;
	struct payload *payload;
	u_int8_t       *buf;
	u_int32_t       i;
	char            header[80];

	/* If no SKEYID_a, we need not do anything.  */
	if (!isa->skeyid_a)
		return 0;

	payload = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_HASH]);
	if (!payload) {
		log_print("ipsec_fill_in_hash: no HASH payload found");
		return -1;
	}
	buf = payload->p;

	/* Allocate the prf and start calculating our HASH(1).  */
	LOG_DBG_BUF((LOG_MISC, 90, "ipsec_fill_in_hash: SKEYID_a", isa->skeyid_a,
		     isa->skeyid_len));
	prf = prf_alloc(isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
	if (!prf)
		return -1;

	prf->Init(prf->prfctx);
	LOG_DBG_BUF((LOG_MISC, 90, "ipsec_fill_in_hash: message_id",
		     exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
	prf->Update(prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);

	/* Loop over all payloads after HASH(1).  */
	for (i = 2; i < msg->iovlen; i++) {
		/* XXX Misleading payload type printouts.  */
		snprintf(header, sizeof header,
		     "ipsec_fill_in_hash: payload %d after HASH(1)", i - 1);
		LOG_DBG_BUF((LOG_MISC, 90, header, msg->iov[i].iov_base,
			     msg->iov[i].iov_len));
		prf->Update(prf->prfctx, msg->iov[i].iov_base, msg->iov[i].iov_len);
	}
	prf->Final(buf + ISAKMP_HASH_DATA_OFF, prf->prfctx);
	prf_free(prf);
	LOG_DBG_BUF((LOG_MISC, 80, "ipsec_fill_in_hash: HASH(1)",
		     buf + ISAKMP_HASH_DATA_OFF, hash->hashsize));
d2269 1
a2269 1
	return 0;
d2274 1
a2274 1
ipsec_informational_pre_hook(struct message * msg)
d2276 9
a2284 9
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct ipsec_sa *isa;
	struct hash    *hash;

	if (!isakmp_sa)
		return 0;
	isa = isakmp_sa->data;
	hash = hash_get(isa->hash);
	return ipsec_add_hash_payload(msg, hash->hashsize) == 0;
d2291 1
a2291 1
ipsec_informational_post_hook(struct message * msg)
d2293 3
a2295 3
	if (!msg->isakmp_sa)
		return 0;
	return ipsec_fill_in_hash(msg);
d2299 1
a2299 1
ipsec_id_size(char *section, u_int8_t * id)
d2301 1
a2301 1
	char           *type, *data;
d2303 34
a2336 30
	type = conf_get_str(section, "ID-type");
	if (!type) {
		log_print("ipsec_id_size: section %s has no \"ID-type\" tag", section);
		return -1;
	}
	*id = constant_value(ipsec_id_cst, type);
	switch (*id) {
	case IPSEC_ID_IPV4_ADDR:
		return sizeof(struct in_addr);
	case IPSEC_ID_IPV4_ADDR_SUBNET:
		return 2 * sizeof(struct in_addr);
	case IPSEC_ID_IPV6_ADDR:
		return sizeof(struct in6_addr);
	case IPSEC_ID_IPV6_ADDR_SUBNET:
		return 2 * sizeof(struct in6_addr);
	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
	case IPSEC_ID_KEY_ID:
	case IPSEC_ID_DER_ASN1_DN:
	case IPSEC_ID_DER_ASN1_GN:
		data = conf_get_str(section, "Name");
		if (!data) {
			log_print("ipsec_id_size: section %s has no \"Name\" tag", section);
			return -1;
		}
		return strlen(data);
	}
	log_print("ipsec_id_size: unrecognized/unsupported ID-type %d (%s)",
		  *id, type);
	return -1;
d2342 2
a2343 2
char           *
ipsec_id_string(u_int8_t * id, size_t id_len)
d2345 56
a2400 55
	char           *buf = 0;
	char           *addrstr = 0;
	size_t          len, size;

	/*
	 * XXX Real ugly way of making the offsets correct.  Be aware that id now
	 * will point before the actual buffer and cannot be dereferenced without
	 * an offset larger than or equal to ISAKM_GEN_SZ.
         */
	id -= ISAKMP_GEN_SZ;

	/* This is the actual length of the ID data field.  */
	id_len += ISAKMP_GEN_SZ - ISAKMP_ID_DATA_OFF;

	/*
	 * Conservative allocation.
	 * XXX I think the ASN1 DN case can be thought through to give a better
	 * estimate.
         */
	size = MAX(sizeof "ipv6/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",
		   sizeof "asn1_dn/" + id_len - ISAKMP_ID_DATA_OFF);
	buf = malloc(size);
	if (!buf)
		/* XXX Log?  */
		goto fail;

	switch (GET_ISAKMP_ID_TYPE(id)) {
	case IPSEC_ID_IPV4_ADDR:
		if (id_len < sizeof(struct in_addr))
			goto fail;
		util_ntoa(&addrstr, AF_INET, id + ISAKMP_ID_DATA_OFF);
		if (!addrstr)
			goto fail;
		snprintf(buf, size, "ipv4/%s", addrstr);
		break;

	case IPSEC_ID_IPV6_ADDR:
		if (id_len < sizeof(struct in6_addr))
			goto fail;
		util_ntoa(&addrstr, AF_INET6, id + ISAKMP_ID_DATA_OFF);
		if (!addrstr)
			goto fail;
		snprintf(buf, size, "ipv6/%s", addrstr);
		break;

	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
		strlcpy(buf,
		GET_ISAKMP_ID_TYPE(id) == IPSEC_ID_FQDN ? "fqdn/" : "ufqdn/",
			size);
		len = strlen(buf);

		memcpy(buf + len, id + ISAKMP_ID_DATA_OFF, id_len);
		*(buf + len + id_len) = '\0';
		break;
d2403 30
a2432 30
	case IPSEC_ID_DER_ASN1_DN:
		strlcpy(buf, "asn1_dn/", size);
		len = strlen(buf);
		addrstr = x509_DN_string(id + ISAKMP_ID_DATA_OFF,
					 id_len - ISAKMP_ID_DATA_OFF);
		if (!addrstr)
			goto fail;
		if (size < len + strlen(addrstr) + 1)
			goto fail;
		strlcpy(buf + len, addrstr, size - len);
		break;
#endif

	default:
		/* Unknown type.  */
		LOG_DBG((LOG_MISC, 10, "ipsec_id_string: unknown identity type %d\n",
			 GET_ISAKMP_ID_TYPE(id)));
		goto fail;
	}

	if (addrstr)
		free(addrstr);
	return buf;

fail:
	if (buf)
		free(buf);
	if (addrstr)
		free(addrstr);
	return 0;
@


1.1.1.11
log
@another bunch of fixes from obsd, and a big isakmpd update (need testers!)
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.104 2004/09/17 13:53:08 ho Exp $	 */
a49 3
#if defined (USE_DPD)
#include "dpd.h"
#endif
a64 3
#if defined (USE_NAT_TRAVERSAL)
#include "nat_traversal.h"
#endif
a69 1
#ifdef USE_X509
a70 3
#endif

extern int acquire_only;
d94 2
a95 2
static int      ipsec_add_contact(struct message *);
static int      ipsec_contacted(struct message *);
d97 1
a97 2
static int      ipsec_debug_attribute(u_int16_t, u_int8_t *, u_int16_t,
    void *);
d107 3
a109 2
static int	ipsec_handle_leftover_payload(struct message *, u_int8_t,
    struct payload *);
d119 1
a119 2
static int      ipsec_validate_attribute(u_int16_t, u_int8_t *, u_int16_t,
    void *);
d121 3
a123 2
static int	ipsec_validate_id_information(u_int8_t, u_int8_t *, u_int8_t *,
    size_t, struct exchange *);
d166 1
a166 1
int16_t script_quick_mode[] = {
d179 1
a179 1
int16_t script_new_group_mode[] = {
d226 1
a226 2
		    memcmp(proto->spi[incoming], &arg->spi, sizeof arg->spi)
		    == 0)
d232 2
a233 2
struct sa *
ipsec_sa_lookup(struct sockaddr *dst, u_int32_t spi, u_int8_t proto)
d249 1
a249 1
ipsec_sa_check_flow(struct sa *sa, void *v_arg)
d282 1
a282 1
ipsec_finalize_exchange(struct message *msg)
a313 5

#if defined (USE_NAT_TRAVERSAL)
			if (isakmp_sa->flags & SA_FLAG_NAT_T_KEEPALIVE)
				nat_t_setup_keepalive(isakmp_sa);
#endif
d322 1
a322 2
			 * Tell the application(s) about the SPIs and key
			 * material.
d335 2
a336 4
						log_print(
						    "ipsec_finalize_exchange: "
						    "ipsec_set_network "
						    "failed");
d344 4
a347 6
					if (ipsec_set_network(ie->id_cr,
					    ie->id_ci, isa)) {
						log_print(
						    "ipsec_finalize_exchange: "
						    "ipsec_set_network "
						    "failed");
d357 2
a358 3
					    (last_proto &&
					    sysdep_ipsec_group_spis(sa,
						last_proto, proto, 0)) ||
d360 3
a362 4
						1, isakmp_sa) ||
					    (last_proto &&
						sysdep_ipsec_group_spis(sa,
						last_proto, proto, 1)))
d382 5
a386 8
				    "ipsec_finalize_exchange: src %s %s "
				    "dst %s %s tproto %u sport %u dport %u",
				    addr1 ? addr1 : "<??\?>",
				    mask1 ?  mask1 : "<??\?>",
				    addr2 ? addr2 : "<??\?>",
				    mask2 ? mask2 : "<??\?>",
				    isa->tproto, ntohs(isa->sport),
				    ntohs(isa->dport)));
d400 2
a401 3
				 * If this is not an SA acquired by the
				 * kernel, it needs to have a SPD entry
				 * (a.k.a. flow) set up.
d403 2
a404 4
				if (!(sa->flags & SA_FLAG_ONDEMAND ||
					conf_get_str("General", "Acquire-Only")
					|| acquire_only)
				    && sysdep_ipsec_enable_sa(sa, isakmp_sa))
d412 1
a412 2
				while ((old_sa = sa_find(ipsec_sa_check_flow,
				    sa)) != 0)
d424 1
a424 1
	int	id;
d431 1
a431 1
		isa->src_net = (struct sockaddr *)calloc(1,
d440 1
a440 1
		isa->src_mask = (struct sockaddr *)calloc(1,
d452 1
a452 1
		isa->src_net = (struct sockaddr *)calloc(1,
d461 1
a461 1
		isa->src_mask = (struct sockaddr *)calloc(1,
d495 2
a496 3
		memcpy(sockaddr_addrdata(isa->src_mask), src_id +
		    ISAKMP_ID_DATA_OFF + sockaddr_addrlen(isa->src_net),
		    sockaddr_addrlen(isa->src_mask));
d500 2
a501 3
	memcpy(&isa->sport,
	    src_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	    IPSEC_ID_PORT_LEN);
d508 2
a509 2
		isa->dst_net = (struct sockaddr *)calloc(1,
		    sizeof(struct sockaddr_in));
d517 2
a518 2
		isa->dst_mask = (struct sockaddr *)calloc(1,
		    sizeof(struct sockaddr_in));
d529 2
a530 2
		isa->dst_net = (struct sockaddr *)calloc(1,
		    sizeof(struct sockaddr_in6));
d538 2
a539 2
		isa->dst_mask = (struct sockaddr *)calloc(1,
		    sizeof(struct sockaddr_in6));
d551 1
a551 1
	    sockaddr_addrlen(isa->dst_net));
d558 1
a558 1
		    sockaddr_addrlen(isa->dst_mask));
d562 3
a564 3
		memcpy(sockaddr_addrdata(isa->dst_mask), dst_id +
		    ISAKMP_ID_DATA_OFF + sockaddr_addrlen(isa->dst_net),
		    sockaddr_addrlen(isa->dst_mask));
d568 4
a571 5
	memcpy(&isa->tproto, dst_id + ISAKMP_ID_DOI_DATA_OFF +
	    IPSEC_ID_PROTO_OFF, IPSEC_ID_PROTO_LEN);
	memcpy(&isa->dport,
	    dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	    IPSEC_ID_PORT_LEN);
d615 1
a615 2
	for (attr = LIST_FIRST(&ie->attrs); attr;
	    attr = LIST_FIRST(&ie->attrs)) {
d682 1
a682 1
ipsec_get_keystate(struct message *msg)
d692 1
a692 1
			    (unsigned long) sizeof *ks);
d705 1
a705 1
		    msg->isakmp_sa);
d712 1
a712 1
	hash = hash_get(((struct ipsec_sa *)msg->isakmp_sa->data)->hash);
d715 1
a715 1
	    ks->riv, ks->xf->blocksize));
d718 4
d723 1
a723 3
	    ISAKMP_HDR_MESSAGE_ID_LEN));
	hash->Update(hash->ctx, ((u_int8_t *) msg->iov[0].iov_base) +
	    ISAKMP_HDR_MESSAGE_ID_OFF, ISAKMP_HDR_MESSAGE_ID_LEN);
d727 1
a727 1
	    hash->digest, ks->xf->blocksize));
d732 1
a732 1
ipsec_setup_situation(u_int8_t *buf)
d737 1
a737 1
static size_t
d743 1
a743 1
static u_int8_t
d751 1
a751 1
    void *vmsg)
d756 2
a757 2
	    && (type < IKE_ATTR_ENCRYPTION_ALGORITHM
		|| type > IKE_ATTR_GROUP_ORDER))
d772 2
a773 2
ipsec_validate_id_information(u_int8_t type, u_int8_t *extra, u_int8_t *buf,
    size_t sz, struct exchange *exchange)
d779 2
a780 2
	    "ipsec_validate_id_information: proto %d port %d type %d",
	    proto, port, type));
d786 2
a787 3
		LOG_DBG_BUF((LOG_MESSAGE, 40,
		    "ipsec_validate_id_information: IPv4", buf,
		    sizeof(struct in_addr)));
d791 2
a792 3
		LOG_DBG_BUF((LOG_MESSAGE, 40,
		    "ipsec_validate_id_information: IPv6", buf,
		    sizeof(struct in6_addr)));
d797 2
a798 2
		    "ipsec_validate_id_information: IPv4 network/netmask",
		    buf, 2 * sizeof(struct in_addr)));
d803 2
a804 2
		    "ipsec_validate_id_information: IPv6 network/netmask",
		    buf, 2 * sizeof(struct in6_addr)));
d821 2
a822 2
		log_print("ipsec_validate_id_information: dubious ID "
		    "information accepted");
d831 1
a831 1
ipsec_validate_key_information(u_int8_t *buf, size_t sz)
d841 1
a841 1
	    || type > IPSEC_NOTIFY_INITIAL_CONTACT ? -1 : 0;
d847 1
a847 2
	return proto < IPSEC_PROTO_IPSEC_AH
	    || proto > IPSEC_PROTO_IPCOMP ? -1 : 0;
d851 1
a851 1
ipsec_validate_situation(u_int8_t *buf, size_t *sz, size_t len)
d855 1
a855 1
		    (unsigned int) len);
d872 2
a873 3
		 * As no unexpected protocols can occur, we just tie the
		 * default case to the first case, in orer to silence a GCC
		 * warning.
d877 4
a880 4
			return transform_id != IPSEC_TRANSFORM_KEY_IKE;
		case IPSEC_PROTO_IPSEC_AH:
			return transform_id < IPSEC_AH_MD5
			    || transform_id > IPSEC_AH_DES ? -1 : 0;
d883 3
a885 3
		    || (transform_id > IPSEC_ESP_AES_128_CTR
			&& transform_id < IPSEC_ESP_AES_MARS)
		    || transform_id > IPSEC_ESP_AES_TWOFISH ? -1 : 0;
d888 1
a888 1
		    || transform_id > IPSEC_IPCOMP_V42BIS ? -1 : 0;
d893 1
a893 1
ipsec_initiator(struct message *msg)
d896 1
a896 1
	int             (**script)(struct message *) = 0;
d900 7
a906 9
	    && ((exchange->phase == 1 &&
		exchange->type != ISAKMP_EXCH_ID_PROT &&
		exchange->type != ISAKMP_EXCH_AGGRESSIVE &&
		exchange->type != ISAKMP_EXCH_INFO)
	    || (exchange->phase == 2 &&	
		exchange->type != IKE_EXCH_QUICK_MODE &&
		exchange->type != ISAKMP_EXCH_INFO))) {
		log_print("ipsec_initiator: unsupported exchange type %d "
		    "in phase %d", exchange->type, exchange->phase);
d948 2
a949 2
ipsec_delete_spi_list(struct sockaddr *addr, u_int8_t proto, u_int8_t *spis,
    int nspis, char *type)
d956 1
a956 1
			u_int8_t *spi = spis + i * ISAKMP_HDR_COOKIES_LEN;
d965 1
a965 1
			u_int32_t spi = ((u_int32_t *)spis)[i];
d971 3
a973 3
			LOG_DBG((LOG_SA, 30, "ipsec_delete_spi_list: could "
			    "not locate SA (SPI %08x, proto %u)",
			    ((u_int32_t *)spis)[i], proto));
d978 2
a979 2
		    "%s made us delete SA %p (%d references) for proto %d",
		    type, sa, sa->refcnt, proto));
d986 1
a986 1
ipsec_responder(struct message *msg)
d989 1
a989 1
	int             (**script)(struct message *) = 0;
d995 5
a999 9
	    && ((exchange->phase == 1 &&
		exchange->type != ISAKMP_EXCH_ID_PROT &&
		exchange->type != ISAKMP_EXCH_AGGRESSIVE &&
		exchange->type != ISAKMP_EXCH_INFO)
	    || (exchange->phase == 2 &&
		exchange->type != IKE_EXCH_QUICK_MODE &&
		exchange->type != ISAKMP_EXCH_INFO))) {
		message_drop(msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE,
		    0, 1, 0);
d1002 3
a1004 2
	LOG_DBG((LOG_MISC, 30, "ipsec_responder: phase %d exchange %d step %d",
	    exchange->phase, exchange->type, exchange->step));
d1009 1
d1015 1
d1021 1
d1023 2
a1024 2
		for (p = payload_first(msg, ISAKMP_PAYLOAD_NOTIFY); p;
		    p = TAILQ_NEXT(p, link)) {
d1027 2
a1028 14
			    "ipsec_responder: got NOTIFY of type %s",
			    constant_name(isakmp_notify_cst, type)));

			switch (type) {
			case IPSEC_NOTIFY_INITIAL_CONTACT:
				/* Handled by leftover logic. */
				break;

#if defined (USE_DPD)
			case ISAKMP_NOTIFY_STATUS_DPD_R_U_THERE:
			case ISAKMP_NOTIFY_STATUS_DPD_R_U_THERE_ACK:
				dpd_handle_notify(msg, p);
				break;
#endif
d1030 1
a1030 4
			default:
				p->flags |= PL_MARK;
				break;
			}
d1034 2
a1035 2
		 * If any DELETEs are in here, let the logic of leftover
		 * payloads deal with them.
d1037 1
d1045 1
a1045 2
		message_drop(msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE,
		    0, 1, 0);
d1054 1
a1054 2
	 * XXX So far we don't accept any proposals for exchanges we don't
	 * support.
d1056 1
a1056 1
	if (payload_first(msg, ISAKMP_PAYLOAD_SA)) {
d1088 2
a1089 2
ipsec_is_attribute_incompatible(u_int16_t type, u_int8_t *value, u_int16_t len,
    void *vmsg)
a1091 1
	u_int16_t dv = decode_16(value);
d1096 1
a1096 1
			return !crypto_get(from_ike_crypto(dv));
d1098 1
a1098 1
			return !hash_get(from_ike_hash(dv));
d1100 1
a1100 1
			return !ike_auth_get(dv);
d1102 4
a1105 4
			return (dv < IKE_GROUP_DESC_MODP_768
				|| dv > IKE_GROUP_DESC_MODP_1536)
			    && (dv < IKE_GROUP_DESC_MODP_2048
				|| dv > IKE_GROUP_DESC_MODP_8192);
d1119 2
a1120 2
			return dv < IKE_DURATION_SECONDS
			    || dv > IKE_DURATION_KILOBYTES;
d1127 2
a1128 2
			 * Our crypto routines only allows key-lengths which
			 * are multiples of an octet.
d1130 1
a1130 1
			return dv % 8 != 0;
d1139 2
a1140 2
			return dv < IPSEC_DURATION_SECONDS
			    || dv > IPSEC_DURATION_KILOBYTES;
d1144 4
a1147 4
			return (dv < IKE_GROUP_DESC_MODP_768
				|| dv > IKE_GROUP_DESC_MODP_1536)
			    && (dv < IKE_GROUP_DESC_MODP_2048
				|| IKE_GROUP_DESC_MODP_8192 < dv);
d1149 2
a1150 9
#if defined (USE_NAT_TRAVERSAL)
			return dv != IPSEC_ENCAP_TUNNEL
			    && dv != IPSEC_ENCAP_TRANSPORT
			    && dv != IPSEC_ENCAP_UDP_ENCAP_TUNNEL
			    && dv != IPSEC_ENCAP_UDP_ENCAP_TRANSPORT;
#else
			return dv < IPSEC_ENCAP_TUNNEL
			    || dv > IPSEC_ENCAP_TRANSPORT;
#endif /* USE_NAT_TRAVERSAL */
d1152 2
a1153 2
			return dv < IPSEC_AUTH_HMAC_MD5
			    || dv > IPSEC_AUTH_HMAC_RIPEMD;
d1180 2
a1181 2
ipsec_debug_attribute(u_int16_t type, u_int8_t *value, u_int16_t len,
    void *vmsg)
d1195 3
a1197 2
	    constant_name(msg->exchange->phase == 1 ? ike_attr_cst :
	    ipsec_attr_cst, type), val));
d1208 2
a1209 2
ipsec_decode_attribute(u_int16_t type, u_int8_t *value, u_int16_t len,
    void *vida)
d1225 1
a1225 2
			exchange->crypto = crypto_get(from_ike_crypto(
			    decode_16(value)));
d1264 1
a1264 2
					log_print("ipsec_decode_attribute: "
					    "unreasonable lifetime");
d1276 1
a1276 2
					log_print("ipsec_decode_attribute: "
					    "unreasonable lifetime");
d1280 1
a1280 2
				log_print("ipsec_decode_attribute: unknown "
				    "lifetime type");
d1309 1
a1309 2
					log_print("ipsec_decode_attribute: "
					    "unreasonable lifetime");
d1321 1
a1321 2
					log_print("ipsec_decode_attribute: "
					    "unreasonable lifetime");
d1325 1
a1325 2
				log_print("ipsec_decode_attribute: unknown "
				    "lifetime type");
d1365 2
a1366 2
ipsec_decode_transform(struct message *msg, struct sa *sa, struct proto *proto,
    u_int8_t *buf)
d1372 1
a1372 1
	    GET_ISAKMP_TRANSFORM_NO(buf)));
d1384 2
a1385 2
	    GET_ISAKMP_GEN_LENGTH(buf) - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
	    ipsec_decode_attribute, &ida);
d1400 1
a1400 1
ipsec_delete_spi(struct sa *sa, struct proto *proto, int incoming)
d1413 1
a1413 1
ipsec_g_x(struct message *msg, int peer, u_int8_t *buf)
d1424 1
a1424 2
		log_error("ipsec_g_x: malloc (%lu) failed",
		    (unsigned long)ie->g_x_len);
d1428 1
a1428 2
	snprintf(header, sizeof header, "ipsec_g_x: g^x%c",
	    initiator ? 'i' : 'r');
d1435 1
a1435 1
ipsec_gen_g_x(struct message *msg)
d1444 1
a1444 1
		    ISAKMP_KE_SZ + (unsigned long)ie->g_x_len);
d1448 1
a1448 1
	    ISAKMP_KE_SZ + ie->g_x_len, 1)) {
d1462 1
a1462 1
ipsec_save_g_x(struct message *msg)
d1468 1
a1468 1
	kep = payload_first(msg, ISAKMP_PAYLOAD_KEY_EXCH);
d1486 1
a1486 1
ipsec_get_spi(size_t *sz, u_int8_t proto, struct message *msg)
d1499 1
a1499 2
		return sysdep_ipsec_get_spi(sz, proto, src, dst,
		    msg->exchange->seq);
d1510 2
a1511 2
ipsec_handle_leftover_payload(struct message *msg, u_int8_t type,
    struct payload *payload)
d1526 2
a1527 2
			LOG_DBG((LOG_SA, 60, "ipsec_handle_leftover_payload: "
			    "message specified zero SPIs, ignoring"));
d1531 5
a1535 7
		if ((proto == ISAKMP_PROTO_ISAKMP && spisz !=
			ISAKMP_HDR_COOKIES_LEN)
		    || (proto != ISAKMP_PROTO_ISAKMP && spisz !=
			sizeof(u_int32_t))) {
			log_print("ipsec_handle_leftover_payload: invalid SPI "
			    "size %d for proto %d in DELETE payload",
			    spisz, proto);
d1540 2
a1541 2
			log_error("ipsec_handle_leftover_payload: malloc "
			    "(%d) failed", nspis * spisz);
d1562 5
a1566 6
			 * XXX Instead of the first condition above, we could
			 * XXX permit this only for phase 2. In the last
			 * XXX packet of main-mode, this payload, while
			 * XXX encrypted, is not part of the hash digest.  As
			 * XXX we currently send our own INITIAL-CONTACTs at
			 * XXX this point, this too would need to be changed.
d1569 2
a1570 2
				log_print("ipsec_handle_leftover_payload: got "
				    "INITIAL-CONTACT in AGGRESSIVE mode");
d1573 3
a1575 10
			if ((msg->exchange->flags & EXCHANGE_FLAG_ENCRYPT)
			    == 0) {
				log_print("ipsec_handle_leftover_payload: got "
				    "INITIAL-CONTACT without ISAKMP SA");
				return -1;
			}

			if ((msg->flags & MSG_AUTHENTICATED) == 0) {
				log_print("ipsec_handle_leftover_payload: "
				    "got unauthenticated INITIAL-CONTACT");
d1579 3
a1581 4
			 * Find out who is sending this and then delete every
			 * SA that is ready.  Exchanges will timeout
			 * themselves and then the non-ready SAs will
			 * disappear too.
d1584 1
a1584 2
			while ((sa = sa_lookup_by_peer(dst,
			    sysdep_sa_len(dst))) != 0) {
d1586 5
a1590 6
				 * Don't delete the current SA -- we received
				 * the notification over it, so it's obviously
				 * still active. We temporarily need to remove
				 * the SA from the list to avoid an endless
				 * loop, but keep a reference so it won't
				 * disappear meanwhile.
d1618 1
a1618 1
ipsec_esp_enckeylength(struct proto *proto)
d1646 1
a1646 1
ipsec_esp_authkeylength(struct proto *proto)
d1669 1
a1669 1
ipsec_ah_keylength(struct proto *proto)
d1690 1
a1690 1
ipsec_keymat_length(struct proto *proto)
d1694 1
a1694 2
		return ipsec_esp_enckeylength(proto)
		    + ipsec_esp_authkeylength(proto);
a1701 43
/* Helper function for ipsec_get_id().  */
static int
ipsec_get_proto_port(char *section, u_int8_t *tproto, u_int16_t *port)
{
	struct protoent	*pe = NULL;
	struct servent	*se;
	char	*pstr;

	pstr = conf_get_str(section, "Protocol");
	if (!pstr) {
		*tproto = 0;
		return 0;
	}
	*tproto = (u_int8_t)atoi(pstr);
	if (!*tproto) {
		pe = getprotobyname(pstr);
		if (pe)
			*tproto = pe->p_proto;
	}
	if (!*tproto) {
		log_print("ipsec_get_proto_port: protocol \"%s\" unknown",
		    pstr);
		return -1;
	}

	pstr = conf_get_str(section, "Port");
	if (!pstr)
		return 0;
	*port = (u_int16_t)atoi(pstr);
	if (!*port) {
		se = getservbyname(pstr,
		    pe ? pe->p_name : (pstr ? pstr : NULL));
		if (se)
			*port = se->s_port;
	}
	if (!*port) {
		log_print("ipsec_get_proto_port: port \"%s\" unknown",
		    pstr);
		return -1;
	}
	return 0;
}

d1709 2
a1710 2
ipsec_get_id(char *section, int *id, struct sockaddr **addr,
    struct sockaddr **mask, u_int8_t *tproto, u_int16_t *port)
d1712 1
a1712 1
	char	*type, *address, *netmask;
d1716 1
a1716 2
		log_print("ipsec_get_id: section %s has no \"ID-type\" tag",
		    section);
d1722 1
a1722 3
	case IPSEC_ID_IPV6_ADDR: {
		int ret;

d1725 2
a1726 2
			log_print("ipsec_get_id: section %s has no "
			    "\"Address\" tag", section);
d1730 2
a1731 2
			log_print("ipsec_get_id: invalid address %s in "
			    "section %s", address, section);
d1734 4
a1737 6
		ret = ipsec_get_proto_port(section, tproto, port);
		if (ret < 0)
			free(*addr);

		return ret;
	}
d1748 1
a1748 3
	case IPSEC_ID_IPV6_ADDR_SUBNET: {
		int ret;

d1751 2
a1752 2
			log_print("ipsec_get_id: section %s has no "
			    "\"Network\" tag", section);
d1756 2
a1757 2
			log_print("ipsec_get_id: invalid section %s "
			    "network %s", section, address);
d1762 2
a1763 3
			log_print("ipsec_get_id: section %s has no "
			    "\"Netmask\" tag", section);
			free(*addr);
d1767 2
a1768 3
			log_print("ipsec_id_build: invalid section %s "
			    "network %s", section, netmask);
			free(*addr);
d1771 4
a1774 7
		ret = ipsec_get_proto_port(section, tproto, port);
		if (ret < 0) {
			free(*mask);
			free(*addr);
		}
		return ret;
	}
d1794 2
a1795 2
		log_print("ipsec_get_id: unknown ID type \"%s\" in "
		    "section %s", type, section);
d1807 2
a1808 2
ipsec_decode_id(char *buf, size_t size, u_int8_t *id, size_t id_len,
    int isakmpform)
d1829 1
a1829 1
			    decode_32(id + ISAKMP_ID_DATA_OFF), addr);
d1836 1
a1836 1
			    decode_32(id + ISAKMP_ID_DATA_OFF),
d1842 2
a1843 2
			snprintf(buf, size, "%08x%08x%08x%08x: %s", *idp,
			    *(idp + 1), *(idp + 2), *(idp + 3), addr);
d1848 4
a1851 5
			util_ntoa(&mask, AF_INET6, id + ISAKMP_ID_DATA_OFF +
			    sizeof(struct in6_addr));
			snprintf(buf, size,
			    "%08x%08x%08x%08x/%08x%08x%08x%08x: %s/%s", *idp,
			    *(idp + 1), *(idp + 2), *(idp + 3), *(idp + 4),
d1867 1
a1867 1
			    id_len - ISAKMP_ID_DATA_OFF);
d1888 3
a1890 3
char *
ipsec_decode_ids(char *fmt, u_int8_t *id1, size_t id1_len, u_int8_t *id2,
    size_t id2_len, int isakmpform)
d1907 2
a1908 2
u_int8_t *
ipsec_build_id(char *section, size_t *sz)
d1928 1
a1928 5
		log_print("ipsec_build_id: malloc(%lu) failed",
		    (unsigned long)*sz);
		if (subnet)
			free(mask);
		free(addr);
d1932 1
a1932 1
	SET_ISAKMP_ID_DOI_DATA(p, (unsigned char *)"\000\000\000");
d1935 1
a1935 1
	    sockaddr_addrlen(addr));
d1938 1
a1938 1
		    sockaddr_addrdata(mask), sockaddr_addrlen(mask));
a1942 3
	if (subnet)
		free(mask);
	free(addr);
d1950 1
a1950 1
ipsec_clone_id(u_int8_t **did, size_t *did_len, u_int8_t *id, size_t id_len)
d1963 1
a1963 2
		log_error("ipsec_clone_id: malloc(%lu) failed",
		    (unsigned long)id_len);
d1978 1
a1978 1
ipsec_proto_init(struct proto *proto, char *section)
d1983 2
a1984 2
		iproto->replay_window = conf_get_num(section, "ReplayWindow",
		    DEFAULT_REPLAY_WINDOW);
d1992 1
a1992 1
ipsec_initial_contact(struct message *msg)
d1994 1
a1994 1
	u_int8_t *buf;
d2002 1
a2002 1
		    ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN);
d2010 1
a2010 1
	    ISAKMP_HDR_COOKIES_LEN);
d2012 1
a2012 1
	    ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN, 1)) {
d2040 1
a2040 1
ipsec_add_contact(struct message *msg)
d2050 2
a2051 3
			log_error("ipsec_add_contact: "
			    "realloc (%p, %lu) failed", contacts,
			    cnt * (unsigned long) sizeof contacts[0]);
d2060 1
a2060 2
		log_error("ipsec_add_contact: malloc (%d) failed",
		    sysdep_sa_len(dst));
d2077 1
a2077 1
ipsec_contacted(struct message *msg)
d2083 4
a2086 2
	return contacts ? (bsearch(&contact, contacts, contact_cnt,
	    sizeof *contacts, addr_cmp) != 0) : 0;
d2090 2
a2091 2
u_int8_t *
ipsec_add_hash_payload(struct message *msg, size_t hashsize)
d2093 1
a2093 1
	u_int8_t *buf;
d2098 1
a2098 1
		    ISAKMP_HASH_SZ + (unsigned long) hashsize);
d2102 1
a2102 1
	    ISAKMP_HASH_SZ + hashsize, 1)) {
d2111 1
a2111 1
ipsec_fill_in_hash(struct message *msg)
d2127 1
a2127 1
	payload = payload_first(msg, ISAKMP_PAYLOAD_HASH);
d2135 3
a2137 4
	LOG_DBG_BUF((LOG_MISC, 90, "ipsec_fill_in_hash: SKEYID_a",
	    isa->skeyid_a, isa->skeyid_len));
	prf = prf_alloc(isa->prf_type, hash->type, isa->skeyid_a,
	    isa->skeyid_len);
d2143 2
a2144 3
	    exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
	prf->Update(prf->prfctx, exchange->message_id,
	    ISAKMP_HDR_MESSAGE_ID_LEN);
d2150 1
a2150 1
		    "ipsec_fill_in_hash: payload %d after HASH(1)", i - 1);
d2152 2
a2153 3
		    msg->iov[i].iov_len));
		prf->Update(prf->prfctx, msg->iov[i].iov_base,
		    msg->iov[i].iov_len);
d2157 2
a2158 2
	LOG_DBG_BUF((LOG_MISC, 80, "ipsec_fill_in_hash: HASH(1)", buf +
	    ISAKMP_HASH_DATA_OFF, hash->hashsize));
d2165 1
a2165 1
ipsec_informational_pre_hook(struct message *msg)
d2182 1
a2182 1
ipsec_informational_post_hook(struct message *msg)
d2190 1
a2190 1
ipsec_id_size(char *section, u_int8_t *id)
d2192 1
a2192 1
	char *type, *data;
d2196 1
a2196 2
		log_print("ipsec_id_size: section %s has no \"ID-type\" tag",
		    section);
d2216 1
a2216 2
			log_print("ipsec_id_size: "
			    "section %s has no \"Name\" tag", section);
d2222 1
a2222 1
	    *id, type);
d2229 2
a2230 2
char *
ipsec_id_string(u_int8_t *id, size_t id_len)
d2237 3
a2239 3
	 * XXX Real ugly way of making the offsets correct.  Be aware that id
	 * now will point before the actual buffer and cannot be dereferenced
	 * without an offset larger than or equal to ISAKM_GEN_SZ.
d2252 1
a2252 1
	    sizeof "asn1_dn/" + id_len - ISAKMP_ID_DATA_OFF);
d2281 1
a2281 1
		    size);
d2293 1
a2293 1
		    id_len - ISAKMP_ID_DATA_OFF);
d2304 2
a2305 3
		LOG_DBG((LOG_MISC, 10,
		    "ipsec_id_string: unknown identity type %d\n",
		    GET_ISAKMP_ID_TYPE(id)));
@


