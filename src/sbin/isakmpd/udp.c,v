head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.7
	tg-mergefixes-1-branch:1.1.1.7.0.4
	tg-mergefixes-1-base:1.1.1.7
	MIROS_X:1.1.1.7.0.2
	MIROS_X_BASE:1.1.1.7
	tg-mergetmp-3:1.1.1.7
	cvs-200411261545:1.1.1.7
	MIRBSD_XP_MIRPPC:1.1.1.6.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.6
	MIRBSD_XP_SPARC:1.1.1.6.0.2
	MIRBSD_7quater:1.1.1.5
	cvs-200405160640:1.1.1.6
	cvs-200401271800:1.1.1.5
	cvs-200401261630:1.1.1.5
	cvs-200401021645:1.1.1.5
	MIRBSD_7_ALPHA:1.1.1.5.0.6
	MIRBSD_7:1.1.1.5.0.4
	cvs-200312222040:1.1.1.5
	MIRBSD_7ter:1.1.1.5
	MIRBSD_7_DEV:1.1.1.5.0.2
	cvs-200310020700:1.1.1.5
	cvs-200309271030:1.1.1.5
	cvs-200309251530:1.1.1.4
	cvs-200308302005:1.1.1.4
	cvs-200308171200:1.1.1.4
	ctm-3496:1.1.1.4
	ctm-3449:1.1.1.4
	ctm-3437:1.1.1.4
	cvs-200307191805:1.1.1.4
	ctm-3425:1.1.1.4
	cvs-200307091500:1.1.1.4
	ctm-3389:1.1.1.4
	cvs-200306291430:1.1.1.4
	ctm-3341:1.1.1.4
	MIRBSD_5:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.17.48.32;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.48.32;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.21.19.02.40;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.31.07;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.19.12.42.34;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.09.27.11.17.17;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.16.08.24.47;	author tg;	state Stab;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.26.15.51.29;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: udp.c,v 1.58 2003/02/12 15:11:31 markus Exp $	*/
/*	$EOM: udp.c,v 1.57 2001/01/26 10:09:57 niklas Exp $	*/

/*
 * Copyright (c) 1998, 1999, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2000 Angelos D. Keromytis.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#ifndef linux
#include <sys/sockio.h>
#endif
#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <err.h>
#include <limits.h>
#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "sysdep.h"

#include "conf.h"
#include "if.h"
#include "isakmp.h"
#include "log.h"
#include "message.h"
#include "sysdep.h"
#include "transport.h"
#include "udp.h"
#include "util.h"

#define UDP_SIZE 65536

/* If a system doesn't have SO_REUSEPORT, SO_REUSEADDR will have to do.  */
#ifndef SO_REUSEPORT
#define SO_REUSEPORT SO_REUSEADDR
#endif

struct udp_transport {
  struct transport transport;
  struct sockaddr *src;
  struct sockaddr *dst;
  int s;
  LIST_ENTRY (udp_transport) link;
};

static struct transport *udp_clone (struct udp_transport *, struct sockaddr *);
static struct transport *udp_create (char *);
static void udp_reinit (void);
static void udp_remove (struct transport *);
static void udp_report (struct transport *);
static int udp_fd_set (struct transport *, fd_set *, int);
static int udp_fd_isset (struct transport *, fd_set *);
static void udp_handle_message (struct transport *);
static struct transport *udp_make (struct sockaddr *);
static int udp_send_message (struct message *);
static void udp_get_dst (struct transport *, struct sockaddr **);
static void udp_get_src (struct transport *, struct sockaddr **);
static char *udp_decode_ids (struct transport *);
#if 0
static in_port_t udp_decode_port (char *);
#endif

static struct transport_vtbl udp_transport_vtbl = {
  { 0 }, "udp",
  udp_create,
  udp_reinit,
  udp_remove,
  udp_report,
  udp_fd_set,
  udp_fd_isset,
  udp_handle_message,
  udp_send_message,
  udp_get_dst,
  udp_get_src,
  udp_decode_ids
};

/* A list of UDP transports we listen for messages on.  */
static LIST_HEAD (udp_listen_list, udp_transport) udp_listen_list;

char *udp_default_port = 0;
char *udp_bind_port = 0;
int bind_family = 0;
static struct transport *default_transport, *default_transport6;

/* Find an UDP transport listening on ADDR:PORT.  */
static struct udp_transport *
udp_listen_lookup (struct sockaddr *addr)
{
  struct udp_transport *u;

  for (u = LIST_FIRST (&udp_listen_list); u; u = LIST_NEXT (u, link))
    if (sysdep_sa_len (u->src) == sysdep_sa_len (addr)
	&& memcmp (u->src, addr, sysdep_sa_len (addr)) == 0)
      return u;
  return 0;
}

/* Create a UDP transport structure bound to LADDR just for listening.  */
static struct transport *
udp_make (struct sockaddr *laddr)
{
  struct udp_transport *t = 0;
  int s, on, wildcardaddress = 0;

  t = calloc (1, sizeof *t);
  if (!t)
    {
      log_print ("udp_make: malloc (%lu) failed", (unsigned long)sizeof *t);
      return 0;
    }

  s = socket (laddr->sa_family, SOCK_DGRAM, IPPROTO_UDP);
  if (s == -1)
    {
      log_error ("udp_make: socket (%d, %d, %d)", laddr->sa_family, SOCK_DGRAM,
		 IPPROTO_UDP);
      goto err;
    }

  /* Make sure we don't get our traffic encrypted.  */
  if (sysdep_cleartext (s, laddr->sa_family) == -1)
    goto err;

  /* Wildcard address ?  */
  switch (laddr->sa_family)
    {
    case AF_INET:
      if (((struct sockaddr_in *)laddr)->sin_addr.s_addr == INADDR_ANY)
	wildcardaddress = 1;
      break;
    case AF_INET6:
      if (IN6_IS_ADDR_UNSPECIFIED(&((struct sockaddr_in6 *)laddr)->sin6_addr))
	wildcardaddress = 1;
      break;
    }

  /*
   * In order to have several bound specific address-port combinations
   * with the same port SO_REUSEADDR is needed.
   * If this is a wildcard socket and we are not listening there, but only
   * sending from it make sure it is entirely reuseable with SO_REUSEPORT.
   */
  on = 1;
  if (setsockopt (s, SOL_SOCKET,
		  wildcardaddress ? SO_REUSEPORT : SO_REUSEADDR,
		  (void *)&on, sizeof on) == -1)
    {
      log_error ("udp_make: setsockopt (%d, %d, %d, %p, %lu)", s, SOL_SOCKET,
		 wildcardaddress ? SO_REUSEPORT : SO_REUSEADDR,
		 &on, (unsigned long)sizeof on);
      goto err;
    }

  t->transport.vtbl = &udp_transport_vtbl;
  t->src = laddr;
  if (bind (s, t->src, sysdep_sa_len (t->src)))
    {
      char *tstr;
      if (sockaddr2text (t->src, &tstr, 0))
	  log_error ("udp_make: bind (%d, %p, %lu)", s, &t->src,
		(unsigned long)sizeof t->src);
      else
	{
	  log_error ("udp_make: bind (%d, %s, %lu)", s, tstr,
		(unsigned long)sizeof t->src);
	  free (tstr);
	}
      goto err;
    }

  t->s = s;
  transport_add (&t->transport);
  transport_reference (&t->transport);
  t->transport.flags |= TRANSPORT_LISTEN;
  return &t->transport;

err:
  if (s >= 0)
    close (s);
  if (t)
    {
      /* Already closed.  */
      t->s = -1;
      udp_remove (&t->transport);
    }
  return 0;
}

/* Clone a listen transport U, record a destination RADDR for outbound use.  */
static struct transport *
udp_clone (struct udp_transport *u, struct sockaddr *raddr)
{
  struct transport *t;
  struct udp_transport *u2;

  t = malloc (sizeof *u);
  if (!t)
    {
      log_error ("udp_clone: malloc (%lu) failed", (unsigned long)sizeof *u);
      return 0;
    }
  u2 = (struct udp_transport *)t;

  memcpy (u2, u, sizeof *u);

  u2->src = malloc (sysdep_sa_len (u->src));
  if (!u2->src)
    {
      log_error ("udp_clone: malloc (%d) failed", sysdep_sa_len (u->src));
      free (t);
      return 0;
    }
  memcpy (u2->src, u->src, sysdep_sa_len (u->src));

  u2->dst = malloc (sysdep_sa_len (raddr));
  if (!u2->dst)
    {
      log_error ("udp_clone: malloc (%d) failed", sysdep_sa_len (raddr));
      free (u2->src);
      free (t);
      return 0;
    }
  memcpy (u2->dst, raddr, sysdep_sa_len (raddr));

  t->flags &= ~TRANSPORT_LISTEN;

  transport_add (t);

  return t;
}

/*
 * Initialize an object of the UDP transport class.  Fill in the local
 * IP address and port information and create a server socket bound to
 * that specific port.  Add the polymorphic transport structure to the
 * system-wide pools of known ISAKMP transports.
 */
static struct transport *
udp_bind (const struct sockaddr *addr)
{
  struct sockaddr *src = malloc (sysdep_sa_len ((struct sockaddr *)addr));

  if (!src)
    return 0;

  memcpy (src, addr, sysdep_sa_len ((struct sockaddr *)addr));
  return udp_make (src);
}

/*
 * When looking at a specific network interface address, if it's an INET one,
 * create an UDP server socket bound to it.
 * Return 0 if successful, -1 otherwise.
 */
static int
udp_bind_if (char *ifname, struct sockaddr *if_addr, void *arg)
{
  char *port = (char *)arg;
  struct sockaddr saddr;
  struct conf_list *listen_on;
  struct udp_transport *u;
  struct conf_list_node *address;
  struct sockaddr *addr;
  struct transport *t;
  struct ifreq flags_ifr;
  char *addr_str, *ep;
  int s, error;
  long lport;

  /*
   * Well, UDP is an internet protocol after all so drop other ifreqs.
   */
  if ((if_addr->sa_family != AF_INET
       || sysdep_sa_len (if_addr) != sizeof (struct sockaddr_in))
      && (if_addr->sa_family != AF_INET6
	  || sysdep_sa_len (if_addr) != sizeof (struct sockaddr_in6)))
    return 0;

  /*
   * Only create sockets for families we should listen to.
   */
  if (bind_family)
    switch (if_addr->sa_family)
      {
      case AF_INET:
	if ((bind_family & BIND_FAMILY_INET4) == 0)
	  return 0;
	break;
      case AF_INET6:
	if ((bind_family & BIND_FAMILY_INET6) == 0)
	  return 0;
	break;
      default:
	return 0;
      }

  /*
   * These special addresses are not useable as they have special meaning
   * in the IP stack.
   */
  if (if_addr->sa_family == AF_INET
      && (((struct sockaddr_in *)if_addr)->sin_addr.s_addr == INADDR_ANY
	  || (((struct sockaddr_in *)if_addr)->sin_addr.s_addr
	      == INADDR_NONE)) )
    return 0;

  /*
   * Go through the list of transports and see if we already have this
   * address bound. If so, unmark the transport and skip it; this allows
   * us to call this function when we suspect a new address has appeared.
   */
  bcopy (if_addr, &saddr, sizeof saddr);
  switch (saddr.sa_family)  /* Add the port number to the sockaddr. */
    {
    case AF_INET:
      ((struct sockaddr_in *)&saddr)->sin_port
	= htons (strtol (port, &ep, 10));
      break;
    case AF_INET6:
      ((struct sockaddr_in6 *)&saddr)->sin6_port
	= htons (strtol (port, &ep, 10));
      break;
    }

  if ((u = udp_listen_lookup (&saddr)) != 0)
    {
      u->transport.flags &= ~TRANSPORT_MARK;
      return 0;
    }

  /* Don't bother with interfaces that are down.  */
  s = socket (if_addr->sa_family, SOCK_DGRAM, 0);
  if (s == -1)
    {
      log_error ("udp_bind_if: socket (%d, SOCK_DGRAM, 0) failed",
		 if_addr->sa_family);
      return -1;
    }
  strlcpy (flags_ifr.ifr_name, ifname, sizeof flags_ifr.ifr_name);
  if (ioctl (s, SIOCGIFFLAGS, (caddr_t)&flags_ifr) == -1)
    {
      log_error ("udp_bind_if: ioctl (%d, SIOCGIFFLAGS, ...) failed", s);
      return -1;
    }
  close (s);
  if (!(flags_ifr.ifr_flags & IFF_UP))
    return 0;

  /*
   * Set port.
   * XXX Use getservbyname too.
   */
  lport = strtol (port, &ep, 10);
  if (*ep != '\0' || lport < 0 || lport > USHRT_MAX)
    {
      log_print ("udp_bind_if: "
		 "port string \"%s\" not convertible to in_port_t", port);
      return -1;
    }

  switch (if_addr->sa_family)
    {
    case AF_INET:
      ((struct sockaddr_in *)if_addr)->sin_port = htons (lport);
      break;
    case AF_INET6:
      ((struct sockaddr_in6 *)if_addr)->sin6_port = htons (lport);
      break;
    default:
      log_print ("udp_bind_if: unsupported protocol family %d",
		 if_addr->sa_family);
      break;
    }

  /*
   * If we are explicit about what addresses we can listen to, be sure
   * to respect that option.
   * This is quite wasteful redoing the list-run for every interface,
   * but who cares?  This is not an operation that needs to be fast.
   */
  listen_on = conf_get_list ("General", "Listen-on");
  if (listen_on)
    {
      for (address = TAILQ_FIRST (&listen_on->fields); address;
	   address = TAILQ_NEXT (address, link))
	{
	  if (text2sockaddr (address->field, port, &addr))
	    {
	      log_print ("udp_bind_if: invalid address %s in \"Listen-on\"",
			 address->field);
	      continue;
	    }

	  /* If found, take the easy way out. */
	  if (memcmp (addr, if_addr, sysdep_sa_len (addr)) == 0)
	    {
	      free (addr);
	      break;
	    }
	  free (addr);
	}
      conf_free_list (listen_on);

      /*
       * If address is zero then we did not find the address among the ones
       * we should listen to.
       * XXX We do not discover if we do not find our listen addresses...
       * Maybe this should be the other way round.
       */
      if (!address)
	return 0;
    }

  t = udp_bind (if_addr);
  if (!t)
    {
      error = sockaddr2text (if_addr, &addr_str, 0);
      log_print ("udp_bind_if: failed to create a socket on %s:%s",
		 error ? "unknown" : addr_str, port);
      if (!error)
	free (addr_str);
      return -1;
    }
  LIST_INSERT_HEAD (&udp_listen_list, (struct udp_transport *)t, link);
  return 0;
}

/*
 * NAME is a section name found in the config database.  Setup and return
 * a transport useable to talk to the peer specified by that name.
 */
static struct transport *
udp_create (char *name)
{
  struct udp_transport *u;
  struct transport *rv;
  struct sockaddr *dst, *addr;
  char *addr_str, *port_str;

  port_str = conf_get_str (name, "Port");
  if (!port_str)
    port_str = udp_default_port;
  if (!port_str)
    port_str = "500";

  addr_str = conf_get_str (name, "Address");
  if (!addr_str)
    {
      log_print ("udp_create: no address configured for \"%s\"", name);
      return 0;
    }
  if (text2sockaddr (addr_str, port_str, &dst))
    {
      log_print ("udp_create: address \"%s\" not understood", addr_str);
      return 0;
    }

  addr_str = conf_get_str (name, "Local-address");
  if (!addr_str)
    addr_str = conf_get_str ("General", "Listen-on");
  if (!addr_str)
    {
      if ((dst->sa_family == AF_INET && !default_transport)
	  || (dst->sa_family == AF_INET6 && !default_transport6))
	{
	  log_print ("udp_create: no default transport");
	  rv = 0;
	  goto ret;
	}
      else
	{
	  /* XXX Ugly!  */
	  rv = udp_clone ((struct udp_transport *)(dst->sa_family == AF_INET
						   ? default_transport
						   : default_transport6), dst);
	  goto ret;
	}
    }

  if (text2sockaddr (addr_str, port_str, &addr))
    {
      log_print ("udp_create: address \"%s\" not understood", addr_str);
      rv = 0;
      goto ret;
    }
  u = udp_listen_lookup (addr);
  free (addr);
  if (!u)
    {
      log_print ("udp_create: %s:%s must exist as a listener too", addr_str,
		 port_str);
      rv = 0;
      goto ret;
    }
  rv = udp_clone (u, dst);

 ret:
  free (dst);
  return rv;
}

void
udp_remove (struct transport *t)
{
  struct udp_transport *u = (struct udp_transport *)t;

  if (u->src)
    free (u->src);
  if (u->dst)
    free (u->dst);
  if (t->flags & TRANSPORT_LISTEN)
    {
      if (u->s >= 0)
	close (u->s);
      if (t == default_transport)
	default_transport = 0;
      else if (t == default_transport6)
	default_transport6 = 0;
      if (u->link.le_prev)
	LIST_REMOVE (u, link);
    }
  free (t);
}

/* Report transport-method specifics of the T transport.  */
void
udp_report (struct transport *t)
{
  struct udp_transport *u = (struct udp_transport *)t;
  char *src, *dst;

  if (sockaddr2text (u->src, &src, 0))
    goto ret;

  if (!u->dst || sockaddr2text (u->dst, &dst, 0))
    dst = 0;

  LOG_DBG ((LOG_REPORT, 0, "udp_report: fd %d src %s dst %s", u->s, src,
	    dst ? dst : "<none>"));

 ret:
  if (dst)
    free (dst);
  if (src)
    free (src);
}

/*
 * Probe the interface list and determine what new interfaces have
 * appeared.
 *
 * At the same time, we try to determine whether existing interfaces have
 * been rendered invalid; we do this by marking all UDP transports before
 * we call udp_bind_if () through if_map (), and then releasing those
 * transports that have not been unmarked.
 */
static void
udp_reinit (void)
{
  struct udp_transport *u, *u2;
  char *port;

  /* Initialize the protocol and port numbers.  */
  port = udp_default_port ? udp_default_port : "500";

  /* Mark all UDP transports, except the default ones. */
  for (u = LIST_FIRST (&udp_listen_list); u; u = LIST_NEXT (u, link))
    if (&u->transport != default_transport
	&& &u->transport != default_transport6)
       u->transport.flags |= TRANSPORT_MARK;

  /* Re-probe interface list.  */
  if (if_map (udp_bind_if, port) == -1)
    log_error ("udp_init: Could not bind the ISAKMP UDP port %s on all "
	       "interfaces", port);

  /*
   * Release listening transports for local addresses that no
   * longer exist. udp_bind_if () will have left those still marked.
   */
  u = LIST_FIRST (&udp_listen_list);
  while (u)
    {
      u2 = LIST_NEXT (u, link);

      if (u->transport.flags & TRANSPORT_MARK)
	{
	  LIST_REMOVE (u, link);
	  transport_release (&u->transport);
	}

      u = u2;
    }
}

/*
 * Find out the magic numbers for the UDP protocol as well as the UDP port
 * to use.  Setup an UDP server for each address of this machine, and one
 * for the generic case when we are the initiator.
 */
void
udp_init (void)
{
  struct sockaddr_storage dflt_stor;
  struct sockaddr_in *dflt = (struct sockaddr_in *)&dflt_stor;
  char *port;
  long lport;
  char *ep;

  /* Initialize the protocol and port numbers.  */
  port = udp_default_port ? udp_default_port : "500";

  LIST_INIT (&udp_listen_list);

  transport_method_add (&udp_transport_vtbl);

  /* Bind the ISAKMP UDP port on all network interfaces we have.  */
  if (if_map (udp_bind_if, port) == -1)
      log_fatal ("udp_init: Could not bind the ISAKMP UDP port %s on all "
		 "interfaces", port);

  /*
   * Get port.
   * XXX Use getservbyname too.
   */
  lport = strtol (port, &ep, 10);
  if (*ep != '\0' || lport < 0 || lport > USHRT_MAX)
    {
      log_print ("udp_init: port string \"%s\" not convertible to in_port_t",
		 port);
      return;
    }

  /*
   * Bind to INADDR_ANY in case of new addresses popping up.
   * Packet reception on this transport is taken as a hint to reprobe the
   * interface list.
   */
  if (!bind_family || (bind_family & BIND_FAMILY_INET4))
    {
      memset (&dflt_stor, 0, sizeof dflt_stor);
      dflt->sin_family = AF_INET;
      ((struct sockaddr_in *)dflt)->sin_len = sizeof (struct sockaddr_in);
      ((struct sockaddr_in *)dflt)->sin_port = htons (lport);

      default_transport = udp_bind ((struct sockaddr *)&dflt_stor);
      if (!default_transport)
	{
	  log_error ("udp_init: could not allocate default "
		     "IPv4 ISAKMP UDP port");
	  return;
	}
      LIST_INSERT_HEAD (&udp_listen_list,
			(struct udp_transport *)default_transport, link);
    }
  
  if (!bind_family || (bind_family & BIND_FAMILY_INET6))
    {
      memset (&dflt_stor, 0, sizeof dflt_stor);
      dflt->sin_family = AF_INET6;
      ((struct sockaddr_in6 *)dflt)->sin6_len = sizeof (struct sockaddr_in6);
      ((struct sockaddr_in6 *)dflt)->sin6_port = htons (lport);

      default_transport6 = udp_bind ((struct sockaddr *)&dflt_stor);
      if (!default_transport6)
	{
	  log_error ("udp_init: could not allocate default "
		     "IPv6 ISAKMP UDP port");
	  return;
	}
      LIST_INSERT_HEAD (&udp_listen_list,
			(struct udp_transport *)default_transport6, link);
    }
}

/*
 * Set transport T's socket in FDS, return a value useable by select(2)
 * as the number of file descriptors to check.
 */
static int
udp_fd_set (struct transport *t, fd_set *fds, int bit)
{
  struct udp_transport *u = (struct udp_transport *)t;

  if (bit)
    FD_SET (u->s, fds);
  else
    FD_CLR (u->s, fds);

  return u->s + 1;
}

/* Check if transport T's socket is set in FDS.  */
static int
udp_fd_isset (struct transport *t, fd_set *fds)
{
  struct udp_transport *u = (struct udp_transport *)t;

  return FD_ISSET (u->s, fds);
}

/*
 * A message has arrived on transport T's socket.  If T is single-ended,
 * clone it into a double-ended transport which we will use from now on.
 * Package the message as we want it and continue processing in the message
 * module.
 */
static void
udp_handle_message (struct transport *t)
{
  struct udp_transport *u = (struct udp_transport *)t;
  u_int8_t buf[UDP_SIZE];
  struct sockaddr_storage from;
  u_int32_t len = sizeof from;
  ssize_t n;
  struct message *msg;

  n = recvfrom (u->s, buf, UDP_SIZE, 0, (struct sockaddr *)&from, &len);
  if (n == -1)
    {
      log_error ("recvfrom (%d, %p, %d, %d, %p, %p)", u->s, buf, UDP_SIZE, 0,
		 &from, &len);
      return;
    }

  /*
   * If we received the packet over the default transports, reprobe the
   * interfaces.
   */
  if (t == default_transport || t == default_transport6)
    {
      udp_reinit ();

      /*
       * As we don't know the actual destination address of the packet,
       * we can't really deal with it. So, just ignore it and hope we
       * catch the retransmission.
       */
      return;
    }

  /*
   * Make a specialized UDP transport structure out of the incoming
   * transport and the address information we got from recvfrom(2).
   */
  t = udp_clone (u, (struct sockaddr *)&from);
  if (!t)
    return;

  msg = message_alloc (t, buf, n);
  if (!msg)
    {
      log_error ("failed to allocate message structure, dropping packet "
		 "received on transport %p", u);
      return;
    }
  message_recv (msg);
}

/* Physically send the message MSG over its associated transport.  */
static int
udp_send_message (struct message *msg)
{
  struct udp_transport *u = (struct udp_transport *)msg->transport;
  ssize_t n;
  struct msghdr m;

  /*
   * Sending on connected sockets requires that no destination address is
   * given, or else EISCONN will occur.
   */
  m.msg_name = (caddr_t)u->dst;
  m.msg_namelen = sysdep_sa_len (u->dst);
  m.msg_iov = msg->iov;
  m.msg_iovlen = msg->iovlen;
  m.msg_control = 0;
  m.msg_controllen = 0;
  m.msg_flags = 0;
  n = sendmsg (u->s, &m, 0);
  if (n == -1)
    {
      /* XXX We should check whether the address has gone away */
      log_error ("sendmsg (%d, %p, %d)", u->s, &m, 0);
      return -1;
    }
  return 0;
}

/*
 * Get transport T's peer address and stuff it into the sockaddr pointed
 * to by DST.
 */
static void
udp_get_dst (struct transport *t, struct sockaddr **dst)
{
  *dst = ((struct udp_transport *)t)->dst;
}

/*
 * Get transport T's local address and stuff it into the sockaddr pointed
 * to by SRC.  Put its length into SRC_LEN.
 */
static void
udp_get_src (struct transport *t, struct sockaddr **src)
{
  *src = ((struct udp_transport *)t)->src;
}

static char *
udp_decode_ids (struct transport *t)
{
  static char result[1024];
  char idsrc[256], iddst[256];

#ifdef HAVE_GETNAMEINFO
  if (getnameinfo (((struct udp_transport *)t)->src,
		   sysdep_sa_len (((struct udp_transport *)t)->src),
		   idsrc, sizeof idsrc, NULL, 0, NI_NUMERICHOST) != 0)
    {
      log_print ("udp_decode_ids: getnameinfo () failed for 'src'");
      strlcpy (idsrc, "<error>", 256);
    }

  if (getnameinfo (((struct udp_transport *)t)->dst,
		   sysdep_sa_len (((struct udp_transport *)t)->dst),
		   iddst, sizeof iddst, NULL, 0, NI_NUMERICHOST) != 0)
    {
      log_print ("udp_decode_ids: getnameinfo () failed for 'dst'");
      strlcpy (iddst, "<error>", 256);
    }
#else
  strlcpy (idsrc, inet_ntoa (((struct udp_transport *)t)->src.sin_addr), 256);
  strlcpy (iddst, inet_ntoa (((struct udp_transport *)t)->dst.sin_addr), 256);
#endif /* HAVE_GETNAMEINFO */

  snprintf (result, 1024, "src: %s dst: %s", idsrc, iddst);

  return result;
}

#if 0
/*
 * Take a string containing an ext representation of port and return a
 * binary port number in host byte order.  Return zero if anything goes wrong.
 * XXX Currently unused.
 */
static in_port_t
udp_decode_port (char *port_str)
{
  char *port_str_end;
  long port_long;
  struct servent *service;

  port_long = ntohl (strtol (port_str, &port_str_end, 0));
  if (port_str == port_str_end)
    {
      service = getservbyname (port_str, "udp");
      if (!service)
	{
	  log_print ("udp_decode_port: service \"%s\" unknown", port_str);
	  return 0;
	}
      return ntohs (service->s_port);
    }
  else if (port_long < 1 || port_long > 65535)
    {
      log_print ("udp_decode_port: port %ld out of range", port_long);
      return 0;
    }

  return port_long;
}
#endif
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.61 2003/05/18 20:06:14 ho Exp $	*/
a61 1
#include "monitor.h"
d193 1
a193 1
  if (monitor_bind (s, t->src, sysdep_sa_len (t->src)))
d296 1
a296 2
  struct sockaddr_storage saddr_st;
  struct sockaddr *saddr = (struct sockaddr *)&saddr_st;
d349 2
a350 2
  memcpy (saddr, if_addr, sizeof saddr_st);
  switch (saddr->sa_family)  /* Add the port number to the sockaddr. */
d353 1
a353 1
      ((struct sockaddr_in *)saddr)->sin_port
d357 1
a357 1
      ((struct sockaddr_in6 *)saddr)->sin6_port
d362 1
a362 1
  if ((u = udp_listen_lookup (saddr)) != 0)
d611 1
a611 1
    log_print ("udp_init: Could not bind the ISAKMP UDP port %s on all "
a679 1
#if !defined (LINUX_IPSEC)
a680 1
#endif
a697 1
#if !defined (LINUX_IPSEC)
a698 1
#endif
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.63 2003/06/04 07:31:17 ho Exp $	*/
d16 5
d879 1
a879 1
  snprintf (result, sizeof result, "src: %s dst: %s", idsrc, iddst);
@


1.1.1.4
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.64 2003/06/10 16:41:29 deraadt Exp $	*/
d692 1
a692 1

@


1.1.1.5
log
@cvs is playing games with me.

@@@@@@ CONSIDER THE TREE LOCKED NOW @@@@@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.65 2003/09/26 11:29:11 cedric Exp $	*/
a639 1
  struct conf_list *listen_on;
a654 10

  /* Only listen to the specified address if Listen-on is configured */
  listen_on = conf_get_list ("General", "Listen-on");
  if (listen_on)
    {
      LOG_DBG ((LOG_TRANSPORT, 50,
		"udp_init: not binding ISAKMP UDP port to INADDR_ANY"));
      conf_free_list (listen_on);
      return;
    }
@


1.1.1.6
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 2
a2 2
/* $OpenBSD: udp.c,v 1.69 2004/04/15 18:39:26 deraadt Exp $	 */
/* $EOM: udp.c,v 1.57 2001/01/26 10:09:57 niklas Exp $	 */
d65 1
a65 1
/* If a system doesn't have SO_REUSEPORT, SO_REUSEADDR will have to do. */
d71 5
a75 4
	struct transport transport;
	struct sockaddr *src, *dst;
	int             s;
	LIST_ENTRY(udp_transport) link;
d78 13
a90 13
static struct transport *udp_clone(struct udp_transport *, struct sockaddr *);
static struct transport *udp_create(char *);
static void     udp_reinit(void);
static void     udp_remove(struct transport *);
static void     udp_report(struct transport *);
static int      udp_fd_set(struct transport *, fd_set *, int);
static int      udp_fd_isset(struct transport *, fd_set *);
static void     udp_handle_message(struct transport *);
static struct transport *udp_make(struct sockaddr *);
static int      udp_send_message(struct message *);
static void     udp_get_dst(struct transport *, struct sockaddr **);
static void     udp_get_src(struct transport *, struct sockaddr **);
static char    *udp_decode_ids(struct transport *);
d92 1
a92 1
static in_port_t udp_decode_port(char *);
d96 12
a107 12
	{0}, "udp",
	udp_create,
	udp_reinit,
	udp_remove,
	udp_report,
	udp_fd_set,
	udp_fd_isset,
	udp_handle_message,
	udp_send_message,
	udp_get_dst,
	udp_get_src,
	udp_decode_ids
d111 1
a111 2
static
LIST_HEAD(udp_listen_list, udp_transport) udp_listen_list;
d113 3
a116 3
char		*udp_default_port = 0;
char		*udp_bind_port = 0;
int		bind_family = 0;
d120 1
a120 1
udp_listen_lookup(struct sockaddr *addr)
d122 1
a122 1
	struct udp_transport *u;
d124 5
a128 5
	for (u = LIST_FIRST(&udp_listen_list); u; u = LIST_NEXT(u, link))
		if (sysdep_sa_len(u->src) == sysdep_sa_len(addr) &&
		    memcmp(u->src, addr, sysdep_sa_len(addr)) == 0)
			return u;
	return 0;
d133 1
a133 1
udp_make(struct sockaddr *laddr)
d135 2
a136 29
	struct udp_transport *t = 0;
	int		s, on, wildcardaddress = 0;

	t = calloc(1, sizeof *t);
	if (!t) {
		log_print("udp_make: malloc (%lu) failed", (unsigned long) sizeof *t);
		return 0;
	}
	s = monitor_socket(laddr->sa_family, SOCK_DGRAM, IPPROTO_UDP);
	if (s == -1) {
		log_error("udp_make: socket (%d, %d, %d)", laddr->sa_family,
		    SOCK_DGRAM, IPPROTO_UDP);
		goto err;
	}
	/* Make sure we don't get our traffic encrypted.  */
	if (sysdep_cleartext(s, laddr->sa_family) == -1)
		goto err;

	/* Wildcard address ?  */
	switch (laddr->sa_family) {
	case AF_INET:
		if (((struct sockaddr_in *) laddr)->sin_addr.s_addr == INADDR_ANY)
			wildcardaddress = 1;
		break;
	case AF_INET6:
		if (IN6_IS_ADDR_UNSPECIFIED(&((struct sockaddr_in6 *) laddr)->sin6_addr))
			wildcardaddress = 1;
		break;
	}
d138 71
a208 35
	/*
	 * In order to have several bound specific address-port combinations
	 * with the same port SO_REUSEADDR is needed.
	 * If this is a wildcard socket and we are not listening there, but only
	 * sending from it make sure it is entirely reuseable with SO_REUSEPORT.
	 */
	on = 1;
	if (monitor_setsockopt(s, SOL_SOCKET,
	    wildcardaddress ? SO_REUSEPORT : SO_REUSEADDR,
	    (void *) &on, sizeof on) == -1) {
		log_error("udp_make: setsockopt (%d, %d, %d, %p, %lu)", s, SOL_SOCKET,
		    wildcardaddress ? SO_REUSEPORT : SO_REUSEADDR,
		    &on, (unsigned long) sizeof on);
		goto err;
	}
	t->transport.vtbl = &udp_transport_vtbl;
	t->src = laddr;
	if (monitor_bind(s, t->src, sysdep_sa_len(t->src))) {
		char	*tstr;

		if (sockaddr2text(t->src, &tstr, 0))
			log_error("udp_make: bind (%d, %p, %lu)", s, &t->src,
			    (unsigned long) sizeof t->src);
		else {
			log_error("udp_make: bind (%d, %s, %lu)", s, tstr,
			    (unsigned long) sizeof t->src);
			free(tstr);
		}
		goto err;
	}
	t->s = s;
	transport_add(&t->transport);
	transport_reference(&t->transport);
	t->transport.flags |= TRANSPORT_LISTEN;
	return &t->transport;
d211 9
a219 8
	if (s >= 0)
		close(s);
	if (t) {
		/* Already closed.  */
		t->s = -1;
		udp_remove(&t->transport);
	}
	return 0;
d224 1
a224 1
udp_clone(struct udp_transport *u, struct sockaddr *raddr)
d226 2
a227 2
	struct udp_transport *u2;
	struct transport *t;
d229 28
a256 8
	t = malloc(sizeof *u);
	if (!t) {
		log_error("udp_clone: malloc (%lu) failed", (unsigned long) sizeof *u);
		return 0;
	}
	u2 = (struct udp_transport *) t;

	memcpy(u2, u, sizeof *u);
d258 1
a258 7
	u2->src = malloc(sysdep_sa_len(u->src));
	if (!u2->src) {
		log_error("udp_clone: malloc (%d) failed", sysdep_sa_len(u->src));
		free(t);
		return 0;
	}
	memcpy(u2->src, u->src, sysdep_sa_len(u->src));
d260 1
a260 8
	u2->dst = malloc(sysdep_sa_len(raddr));
	if (!u2->dst) {
		log_error("udp_clone: malloc (%d) failed", sysdep_sa_len(raddr));
		free(u2->src);
		free(t);
		return 0;
	}
	memcpy(u2->dst, raddr, sysdep_sa_len(raddr));
d262 1
a262 3
	t->flags &= ~TRANSPORT_LISTEN;
	transport_add(t);
	return t;
d272 1
a272 1
udp_bind(const struct sockaddr *addr)
d274 1
a274 1
	struct sockaddr *src = malloc(sysdep_sa_len((struct sockaddr *) addr));
d276 2
a277 2
	if (!src)
		return 0;
d279 2
a280 2
	memcpy(src, addr, sysdep_sa_len((struct sockaddr *) addr));
	return udp_make(src);
d289 1
a289 1
udp_bind_if(char *ifname, struct sockaddr *if_addr, void *arg)
d291 39
a329 38
	char	*port = (char *) arg, *addr_str, *ep;
	struct sockaddr_storage saddr_st;
	struct sockaddr *saddr = (struct sockaddr *) & saddr_st;
	struct conf_list *listen_on;
	struct udp_transport *u;
	struct conf_list_node *address;
	struct sockaddr *addr;
	struct transport *t;
	struct ifreq    flags_ifr;
	int		s, error;
	long		lport;

	/*
	 * Well, UDP is an internet protocol after all so drop other ifreqs.
	*/
	if ((if_addr->sa_family != AF_INET ||
	    sysdep_sa_len(if_addr) != sizeof(struct sockaddr_in)) &&
	    (if_addr->sa_family != AF_INET6 ||
	    sysdep_sa_len(if_addr) != sizeof(struct sockaddr_in6)))
		return 0;

	/*
	 * Only create sockets for families we should listen to.
	 */
	if (bind_family) {
		switch (if_addr->sa_family) {
		case AF_INET:
			if ((bind_family & BIND_FAMILY_INET4) == 0)
				return 0;
			break;
		case AF_INET6:
			if ((bind_family & BIND_FAMILY_INET6) == 0)
				return 0;
			break;
		default:
			return 0;
		}
	}
d331 116
a446 70
	/*
	 * These special addresses are not useable as they have special meaning
	 * in the IP stack.
	 */
	if (if_addr->sa_family == AF_INET &&
	    (((struct sockaddr_in *) if_addr)->sin_addr.s_addr == INADDR_ANY ||
	    (((struct sockaddr_in *) if_addr)->sin_addr.s_addr == INADDR_NONE)))
		return 0;

	/*
	 * Go through the list of transports and see if we already have this
	 * address bound. If so, unmark the transport and skip it; this allows
	 * us to call this function when we suspect a new address has appeared.
	 */
	if (sysdep_sa_len(if_addr) > sizeof saddr_st)
		return 0;
	memcpy(saddr, if_addr, sysdep_sa_len(if_addr));
	switch (saddr->sa_family) {	/* Add the port number to the sockaddr. */
	case AF_INET:
		((struct sockaddr_in *) saddr)->sin_port =
		    htons(strtol(port, &ep, 10));
		break;
	case AF_INET6:
		((struct sockaddr_in6 *) saddr)->sin6_port =
		    htons(strtol(port, &ep, 10));
		break;
	}

	if ((u = udp_listen_lookup(saddr)) != 0) {
		u->transport.flags &= ~TRANSPORT_MARK;
		return 0;
	}
	/* Don't bother with interfaces that are down.  */
	s = monitor_socket(if_addr->sa_family, SOCK_DGRAM, 0);
	if (s == -1) {
		log_error("udp_bind_if: socket (%d, SOCK_DGRAM, 0) failed",
		    if_addr->sa_family);
		return -1;
	}
	strlcpy(flags_ifr.ifr_name, ifname, sizeof flags_ifr.ifr_name);
	if (ioctl(s, SIOCGIFFLAGS, (caddr_t) & flags_ifr) == -1) {
		log_error("udp_bind_if: ioctl (%d, SIOCGIFFLAGS, ...) failed", s);
		return -1;
	}
	close(s);
	if (!(flags_ifr.ifr_flags & IFF_UP))
		return 0;

	/*
	 * Set port.
	 * XXX Use getservbyname too.
	 */
	lport = strtol(port, &ep, 10);
	if (*ep != '\0' || lport < (long) 0 || lport > (long) USHRT_MAX) {
		log_print("udp_bind_if: "
		    "port string \"%s\" not convertible to in_port_t", port);
		return -1;
	}
	switch (if_addr->sa_family) {
	case AF_INET:
		((struct sockaddr_in *) if_addr)->sin_port = htons(lport);
		break;
	case AF_INET6:
		((struct sockaddr_in6 *) if_addr)->sin6_port = htons(lport);
		break;
	default:
		log_print("udp_bind_if: unsupported protocol family %d",
		    if_addr->sa_family);
		break;
	}
d448 12
a459 44
	/*
	 * If we are explicit about what addresses we can listen to, be sure
	 * to respect that option.
	 * This is quite wasteful redoing the list-run for every interface,
	 * but who cares?  This is not an operation that needs to be fast.
	 */
	listen_on = conf_get_list("General", "Listen-on");
	if (listen_on) {
		for (address = TAILQ_FIRST(&listen_on->fields); address;
		    address = TAILQ_NEXT(address, link)) {
			if (text2sockaddr(address->field, port, &addr)) {
				log_print("udp_bind_if: invalid address %s in \"Listen-on\"",
				    address->field);
				continue;
			}
			/* If found, take the easy way out. */
			if (memcmp(addr, if_addr, sysdep_sa_len(addr)) == 0) {
				free(addr);
				break;
			}
			free(addr);
		}
		conf_free_list(listen_on);

		/*
		 * If address is zero then we did not find the address among the ones
		 * we should listen to.
		 * XXX We do not discover if we do not find our listen addresses...
		 * Maybe this should be the other way round.
		 */
		if (!address)
			return 0;
	}
	t = udp_bind(if_addr);
	if (!t) {
		error = sockaddr2text(if_addr, &addr_str, 0);
		log_print("udp_bind_if: failed to create a socket on %s:%s",
		    error ? "unknown" : addr_str, port);
		if (!error)
			free(addr_str);
		return -1;
	}
	LIST_INSERT_HEAD(&udp_listen_list, (struct udp_transport *) t, link);
	return 0;
d467 1
a467 1
udp_create(char *name)
d469 65
a533 55
	struct udp_transport *u;
	struct transport *rv;
	struct sockaddr *dst, *addr;
	char	*addr_str, *port_str;

	port_str = conf_get_str(name, "Port");
	if (!port_str)
		port_str = udp_default_port;
	if (!port_str)
		port_str = "500";

	addr_str = conf_get_str(name, "Address");
	if (!addr_str) {
		log_print("udp_create: no address configured for \"%s\"", name);
		return 0;
	}
	if (text2sockaddr(addr_str, port_str, &dst)) {
		log_print("udp_create: address \"%s\" not understood", addr_str);
		return 0;
	}
	addr_str = conf_get_str(name, "Local-address");
	if (!addr_str)
		addr_str = conf_get_str("General", "Listen-on");
	if (!addr_str) {
		if ((dst->sa_family == AF_INET && !default_transport) ||
		    (dst->sa_family == AF_INET6 && !default_transport6)) {
			log_print("udp_create: no default transport");
			rv = 0;
			goto ret;
		} else {
			/* XXX Ugly! */
			rv = udp_clone((struct udp_transport *)
			    (dst->sa_family == AF_INET ? default_transport :
			    default_transport6), dst);
			goto ret;
		}
	}
	if (text2sockaddr(addr_str, port_str, &addr)) {
		log_print("udp_create: address \"%s\" not understood", addr_str);
		rv = 0;
		goto ret;
	}
	u = udp_listen_lookup(addr);
	free(addr);
	if (!u) {
		log_print("udp_create: %s:%s must exist as a listener too", addr_str,
		    port_str);
		rv = 0;
		goto ret;
	}
	rv = udp_clone(u, dst);

ret:
	free(dst);
	return rv;
d537 1
a537 1
udp_remove(struct transport * t)
d539 1
a539 1
	struct udp_transport *u = (struct udp_transport *) t;
d541 16
a556 15
	if (u->src)
		free(u->src);
	if (u->dst)
		free(u->dst);
	if (t->flags & TRANSPORT_LISTEN) {
		if (u->s >= 0)
			close(u->s);
		if (t == default_transport)
			default_transport = 0;
		else if (t == default_transport6)
			default_transport6 = 0;
		if (u->link.le_prev)
			LIST_REMOVE(u, link);
	}
	free(t);
d559 1
a559 1
/* Report transport-method specifics of the T transport. */
d561 1
a561 1
udp_report(struct transport * t)
d563 2
a564 2
	struct udp_transport *u = (struct udp_transport *) t;
	char	*src, *dst;
d566 2
a567 2
	if (sockaddr2text(u->src, &src, 0))
		goto ret;
d569 2
a570 2
	if (!u->dst || sockaddr2text(u->dst, &dst, 0))
		dst = 0;
d572 1
a572 1
	LOG_DBG((LOG_REPORT, 0, "udp_report: fd %d src %s dst %s", u->s, src,
d575 5
a579 5
ret:
	if (dst)
		free(dst);
	if (src)
		free(src);
d592 1
a592 1
udp_reinit(void)
d594 2
a595 2
	struct udp_transport *u, *u2;
	char		*port;
d597 2
a598 2
	/* Initialize the protocol and port numbers. */
	port = udp_default_port ? udp_default_port : "500";
d600 24
a623 24
	/* Mark all UDP transports, except the default ones. */
	for (u = LIST_FIRST(&udp_listen_list); u; u = LIST_NEXT(u, link))
		if (&u->transport != default_transport &&
		    &u->transport != default_transport6)
			u->transport.flags |= TRANSPORT_MARK;

	/* Re-probe interface list. */
	if (if_map(udp_bind_if, port) == -1)
		log_print("udp_init: Could not bind the ISAKMP UDP port %s on all "
		    "interfaces", port);

	/*
	 * Release listening transports for local addresses that no
	 * longer exist. udp_bind_if () will have left those still marked.
         */
	u = LIST_FIRST(&udp_listen_list);
	while (u) {
		u2 = LIST_NEXT(u, link);

		if (u->transport.flags & TRANSPORT_MARK) {
			LIST_REMOVE(u, link);
			transport_release(&u->transport);
		}
		u = u2;
d625 3
d636 1
a636 1
udp_init(void)
d638 50
a687 45
	struct sockaddr_storage dflt_stor;
	struct sockaddr_in *dflt = (struct sockaddr_in *) & dflt_stor;
	struct conf_list *listen_on;
	char           *port;
	long            lport;
	char           *ep;

	/* Initialize the protocol and port numbers.  */
	port = udp_default_port ? udp_default_port : "500";

	LIST_INIT(&udp_listen_list);

	transport_method_add(&udp_transport_vtbl);

	/* Bind the ISAKMP UDP port on all network interfaces we have.  */
	if (if_map(udp_bind_if, port) == -1)
		log_fatal("udp_init: Could not bind the ISAKMP UDP port %s on all "
		    "interfaces", port);

	/* Only listen to the specified address if Listen-on is configured */
	listen_on = conf_get_list("General", "Listen-on");
	if (listen_on) {
		LOG_DBG((LOG_TRANSPORT, 50,
		    "udp_init: not binding ISAKMP UDP port to INADDR_ANY"));
		conf_free_list(listen_on);
		return;
	}
	/*
	 * Get port.
	 * XXX Use getservbyname too.
         */
	lport = strtol(port, &ep, 10);
	if (*ep != '\0' || lport < (long) 0 || lport > (long) USHRT_MAX) {
		log_print("udp_init: port string \"%s\" not convertible to in_port_t",
		    port);
		return;
	}
	/*
	 * Bind to INADDR_ANY in case of new addresses popping up.
	 * Packet reception on this transport is taken as a hint to reprobe the
	 * interface list.
         */
	if (!bind_family || (bind_family & BIND_FAMILY_INET4)) {
		memset(&dflt_stor, 0, sizeof dflt_stor);
		dflt->sin_family = AF_INET;
d689 1
a689 1
		((struct sockaddr_in *) dflt)->sin_len = sizeof(struct sockaddr_in);
d691 1
a691 1
		((struct sockaddr_in *) dflt)->sin_port = htons(lport);
d693 15
a707 12
		default_transport = udp_bind((struct sockaddr *) & dflt_stor);
		if (!default_transport) {
			log_error("udp_init: could not allocate default "
			    "IPv4 ISAKMP UDP port");
			return;
		}
		LIST_INSERT_HEAD(&udp_listen_list,
		    (struct udp_transport *) default_transport, link);
	}
	if (!bind_family || (bind_family & BIND_FAMILY_INET6)) {
		memset(&dflt_stor, 0, sizeof dflt_stor);
		dflt->sin_family = AF_INET6;
d709 1
a709 1
		((struct sockaddr_in6 *) dflt)->sin6_len = sizeof(struct sockaddr_in6);
d711 1
a711 1
		((struct sockaddr_in6 *) dflt)->sin6_port = htons(lport);
d713 10
a722 9
		default_transport6 = udp_bind((struct sockaddr *) & dflt_stor);
		if (!default_transport6) {
			log_error("udp_init: could not allocate default "
			    "IPv6 ISAKMP UDP port");
			return;
		}
		LIST_INSERT_HEAD(&udp_listen_list,
		    (struct udp_transport *) default_transport6, link);
	}
d730 1
a730 1
udp_fd_set(struct transport * t, fd_set * fds, int bit)
d732 1
a732 1
	struct udp_transport *u = (struct udp_transport *) t;
d734 4
a737 4
	if (bit)
		FD_SET(u->s, fds);
	else
		FD_CLR(u->s, fds);
d739 1
a739 1
	return u->s + 1;
d744 1
a744 1
udp_fd_isset(struct transport * t, fd_set * fds)
d746 1
a746 1
	struct udp_transport *u = (struct udp_transport *) t;
d748 1
a748 1
	return FD_ISSET(u->s, fds);
d758 1
a758 1
udp_handle_message(struct transport * t)
d760 47
a806 42
	struct udp_transport *u = (struct udp_transport *) t;
	u_int8_t        buf[UDP_SIZE];
	struct sockaddr_storage from;
	u_int32_t       len = sizeof from;
	ssize_t         n;
	struct message *msg;

	n = recvfrom(u->s, buf, UDP_SIZE, 0, (struct sockaddr *) & from, &len);
	if (n == -1) {
		log_error("recvfrom (%d, %p, %d, %d, %p, %p)", u->s, buf, UDP_SIZE, 0,
		    &from, &len);
		return;
	}
	/*
	 * If we received the packet over the default transports, reprobe the
	 * interfaces.
         */
	if (t == default_transport || t == default_transport6) {
		udp_reinit();

		/*
		 * As we don't know the actual destination address of the packet,
		 * we can't really deal with it. So, just ignore it and hope we
		 * catch the retransmission.
	         */
		return;
	}
	/*
	 * Make a specialized UDP transport structure out of the incoming
	 * transport and the address information we got from recvfrom(2).
         */
	t = udp_clone(u, (struct sockaddr *) & from);
	if (!t)
		return;

	msg = message_alloc(t, buf, n);
	if (!msg) {
		log_error("failed to allocate message structure, dropping packet "
		    "received on transport %p", u);
		return;
	}
	message_recv(msg);
d811 1
a811 1
udp_send_message(struct message * msg)
d813 23
a835 22
	struct udp_transport *u = (struct udp_transport *) msg->transport;
	ssize_t         n;
	struct msghdr   m;

	/*
	 * Sending on connected sockets requires that no destination address is
	 * given, or else EISCONN will occur.
         */
	m.msg_name = (caddr_t) u->dst;
	m.msg_namelen = sysdep_sa_len(u->dst);
	m.msg_iov = msg->iov;
	m.msg_iovlen = msg->iovlen;
	m.msg_control = 0;
	m.msg_controllen = 0;
	m.msg_flags = 0;
	n = sendmsg(u->s, &m, 0);
	if (n == -1) {
		/* XXX We should check whether the address has gone away */
		log_error("sendmsg (%d, %p, %d)", u->s, &m, 0);
		return -1;
	}
	return 0;
d843 1
a843 1
udp_get_dst(struct transport * t, struct sockaddr ** dst)
d845 1
a845 1
	*dst = ((struct udp_transport *) t)->dst;
d853 1
a853 1
udp_get_src(struct transport * t, struct sockaddr ** src)
d855 1
a855 1
	*src = ((struct udp_transport *) t)->src;
d859 1
a859 1
udp_decode_ids(struct transport * t)
d861 2
a862 2
	static char     result[1024];
	char            idsrc[256], iddst[256];
d865 15
a879 12
	if (getnameinfo(((struct udp_transport *) t)->src,
	    sysdep_sa_len(((struct udp_transport *) t)->src),
	    idsrc, sizeof idsrc, NULL, 0, NI_NUMERICHOST) != 0) {
		log_print("udp_decode_ids: getnameinfo () failed for 'src'");
		strlcpy(idsrc, "<error>", 256);
	}
	if (getnameinfo(((struct udp_transport *) t)->dst,
	    sysdep_sa_len(((struct udp_transport *) t)->dst),
	    iddst, sizeof iddst, NULL, 0, NI_NUMERICHOST) != 0) {
		log_print("udp_decode_ids: getnameinfo () failed for 'dst'");
		strlcpy(iddst, "<error>", 256);
	}
d881 3
a883 3
	strlcpy(idsrc, inet_ntoa(((struct udp_transport *) t)->src.sin_addr), 256);
	strlcpy(iddst, inet_ntoa(((struct udp_transport *) t)->dst.sin_addr), 256);
#endif				/* HAVE_GETNAMEINFO */
d885 3
a887 2
	snprintf(result, sizeof result, "src: %s dst: %s", idsrc, iddst);
	return result;
d897 1
a897 1
udp_decode_port(char *port_str)
d899 22
a920 18
	char           *port_str_end;
	long            port_long;
	struct servent *service;

	port_long = ntohl(strtol(port_str, &port_str_end, 0));
	if (port_str == port_str_end) {
		service = getservbyname(port_str, "udp");
		if (!service) {
			log_print("udp_decode_port: service \"%s\" unknown",
			    port_str);
			return 0;
		}
		return ntohs(service->s_port);
	} else if (port_long < 1 || port_long > 65535) {
		log_print("udp_decode_port: port %ld out of range", port_long);
		return 0;
	}
	return port_long;
@


1.1.1.7
log
@another bunch of fixes from obsd, and a big isakmpd update (need testers!)
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.79 2004/08/08 19:11:06 deraadt Exp $	 */
a6 1
 * Copyright (c) 2003, 2004 Håkan Olsson.  All rights reserved.
a61 1
#include "virtual.h"
d70 6
a75 8
/* These are reused by udp_encap.c, thus not 'static' here.  */
struct transport *udp_clone(struct transport *, struct sockaddr *);
int		  udp_fd_set(struct transport *, fd_set *, int);
int		  udp_fd_isset(struct transport *, fd_set *);
void		  udp_get_dst(struct transport *, struct sockaddr **);
void		  udp_get_src(struct transport *, struct sockaddr **);
char		 *udp_decode_ids(struct transport *);
void		  udp_remove(struct transport *);
d77 1
d79 2
d82 2
d86 4
a89 1
static int      udp_send_message(struct message *, struct transport *);
d95 1
a95 1
	{0}, "udp_physical",
d97 1
a97 1
	0,
d106 1
a106 3
	udp_decode_ids,
	udp_clone,
	0
d109 5
d118 3
a120 2
void
udp_init(void)
d122 7
a128 1
	transport_method_add(&udp_transport_vtbl);
d136 1
a136 2
	int	s, on, wildcardaddress = 0;
	char	*tstr;
d140 1
a140 3
		log_print("udp_make: calloc (1, %lu) failed",
		    (unsigned long)sizeof *t);
		free(laddr);
d143 1
a143 3
	t->src = laddr;

	s = socket(laddr->sa_family, SOCK_DGRAM, IPPROTO_UDP);
d156 1
a156 2
		if (((struct sockaddr_in *)laddr)->sin_addr.s_addr ==
		    INADDR_ANY)
d160 1
a160 1
		if (IN6_IS_ADDR_UNSPECIFIED(&((struct sockaddr_in6 *)laddr)->sin6_addr))
d167 3
a169 3
	 * with the same port SO_REUSEADDR is needed.  If this is a wildcard
	 * socket and we are not listening there, but only sending from it
	 * make sure it is entirely reuseable with SO_REUSEPORT.
d172 1
a172 1
	if (setsockopt(s, SOL_SOCKET,
d174 4
a177 4
	    (void *)&on, sizeof on) == -1) {
		log_error("udp_make: setsockopt (%d, %d, %d, %p, %lu)", s,
		    SOL_SOCKET, wildcardaddress ? SO_REUSEPORT : SO_REUSEADDR,
		    &on, (unsigned long)sizeof on);
d181 1
d183 2
d187 1
a187 1
			    (unsigned long)sizeof t->src);
d190 1
a190 1
			    (unsigned long)sizeof t->src);
d196 2
a197 11
	if (sockaddr2text(t->src, &tstr, 0))
		LOG_DBG((LOG_MISC, 20, "udp_make: "
		    "transport %p socket %d family %d", t, s,
		    t->src->sa_family == AF_INET ? 4 : 6));
	else {
		LOG_DBG((LOG_MISC, 20, "udp_make: "
		    "transport %p socket %d ip %s port %d", t, s,
		    tstr, ntohs(sockaddr_port(t->src))));
		free (tstr);
	}
	transport_setup(&t->transport, 0);
d213 2
a214 2
struct transport *
udp_clone(struct transport *ut, struct sockaddr *raddr)
a215 1
	struct udp_transport *u = (struct udp_transport *)ut;
d221 1
a221 2
		log_error("udp_clone: malloc (%lu) failed",
		    (unsigned long)sizeof *u);
d224 1
a224 1
	u2 = (struct udp_transport *)t;
d230 1
a230 2
		log_error("udp_clone: malloc (%d) failed",
		    sysdep_sa_len(u->src));
d238 1
a238 2
		log_error("udp_clone: malloc (%d) failed",
		    sysdep_sa_len(raddr));
d246 1
a246 1
	transport_setup(t, 0);
d256 1
a256 1
struct transport *
d259 1
a259 1
	struct sockaddr *src;
a260 1
	src = malloc(sysdep_sa_len((struct sockaddr *)addr));
d264 1
a264 1
	memcpy(src, addr, sysdep_sa_len((struct sockaddr *)addr));
d269 164
a438 1
	struct virtual_transport *v;
d440 2
a441 2
	struct transport *rv, *t;
	struct sockaddr	*dst, *addr;
a442 2
	struct conf_list *addr_list = 0;
	struct conf_list_node *addr_node;
d448 1
a448 1
		port_str = UDP_DEFAULT_PORT_STR;
d452 1
a452 2
		log_print("udp_create: no address configured for \"%s\"",
		    name);
d456 1
a456 2
		log_print("udp_create: address \"%s\" not understood",
		    addr_str);
d461 4
a464 6
		addr_list = conf_get_list("General", "Listen-on");
	if (!addr_str && !addr_list) {
		v = virtual_get_default(dst->sa_family);
		u = (struct udp_transport *)v->main;

		if (!u) {
d469 4
a472 22
			rv = udp_clone((struct transport *)u, dst);
			if (rv)
				rv->vtbl = &udp_transport_vtbl;
			goto ret;
		}
	}

	if (addr_list) {
		for (addr_node = TAILQ_FIRST(&addr_list->fields);
		     addr_node; addr_node = TAILQ_NEXT(addr_node, link))
			if (text2sockaddr(addr_node->field, port_str, &addr)
			    == 0) {
				v = virtual_listen_lookup(addr);
				free(addr);
				if (v) {
					addr_str = addr_node->field;
					break;
				}
			}
		if (!addr_str) {
			log_print("udp_create: no matching listener found");
			rv = 0;
d477 1
a477 2
		log_print("udp_create: address \"%s\" not understood",
		    addr_str);
d481 1
a481 2

	v = virtual_listen_lookup(addr);
d483 3
a485 3
	if (!v) {
		log_print("udp_create: %s:%s must exist as a listener too",
		    addr_str, port_str);
d489 1
a489 4
	t = (struct transport *)v;
	rv = udp_clone(v->main, dst);
	if (rv)
		rv->vtbl = &udp_transport_vtbl;
a491 2
	if (addr_list)
		conf_free_list(addr_list);
d497 1
a497 1
udp_remove(struct transport *t)
d499 1
a499 1
	struct udp_transport *u = (struct udp_transport *)t;
d505 10
a514 6
	if ((t->flags & TRANSPORT_LISTEN) && u->s >= 0)
		close(u->s);
	if (t->link.le_prev)
		LIST_REMOVE(t, link);

	LOG_DBG((LOG_TRANSPORT, 90, "udp_remove: removed transport %p", t));
d520 1
a520 1
udp_report(struct transport *t)
d522 2
a523 3
	struct udp_transport *u = (struct udp_transport *)t;
	char		*src = NULL, *dst = NULL;
	in_port_t	 sport, dport;
a526 1
	sport = sockaddr_port(u->src);
a529 1
	dport = dst ? sockaddr_port(u->dst) : 0;
d531 2
a532 2
	LOG_DBG((LOG_REPORT, 0, "udp_report: fd %d src %s:%u dst %s:%u", u->s,
	    src, ntohs(sport), dst ? dst : "<none>", ntohs(dport)));
d542 157
d705 1
a705 1
udp_handle_message(struct transport *t)
d707 1
a707 1
	struct udp_transport *u = (struct udp_transport *)t;
d714 1
a714 1
	n = recvfrom(u->s, buf, UDP_SIZE, 0, (struct sockaddr *)&from, &len);
d716 16
a731 2
		log_error("recvfrom (%d, %p, %d, %d, %p, %p)", u->s, buf,
		    UDP_SIZE, 0, &from, &len);
d738 1
a738 1
	t = t->virtual->vtbl->clone(t->virtual, (struct sockaddr *)&from);
d744 2
a745 3
		log_error("failed to allocate message structure, dropping "
		    "packet received on transport %p", u);
		t->vtbl->remove(t);
d753 1
a753 1
udp_send_message(struct message *msg, struct transport *t)
d755 1
a755 1
	struct udp_transport *u = (struct udp_transport *)t;
a778 21
int
udp_fd_set(struct transport *t, fd_set *fds, int bit)
{
	struct udp_transport		*u = (struct udp_transport *)t;

	if (bit)
		FD_SET(u->s, fds);
	else
		FD_CLR(u->s, fds);

	return u->s + 1;
}

int
udp_fd_isset(struct transport *t, fd_set *fds)
{
	struct udp_transport		*u = (struct udp_transport *)t;

	return FD_ISSET(u->s, fds);
}

d783 2
a784 2
void
udp_get_dst(struct transport *t, struct sockaddr **dst)
d786 1
a786 1
	*dst = ((struct udp_transport *)t)->dst;
d793 2
a794 2
void
udp_get_src(struct transport *t, struct sockaddr **src)
d796 1
a796 1
	*src = ((struct udp_transport *)t)->src;
d799 2
a800 2
char *
udp_decode_ids(struct transport *t)
a801 1
	struct sockaddr *src, *dst;
d805 4
a808 5
	t->vtbl->get_src(t, &src);
	t->vtbl->get_dst(t, &dst);

	if (getnameinfo(src, sysdep_sa_len(src), idsrc, sizeof idsrc, NULL, 0,
	    NI_NUMERICHOST) != 0) {
d812 3
a814 2
	if (getnameinfo(dst, sysdep_sa_len(dst), iddst, sizeof iddst, NULL, 0,
	    NI_NUMERICHOST) != 0) {
d818 4
@


