head	1.4;
access;
symbols
	tg-mergetmp-mirosx-1:1.4
	tg-mergefixes-1-branch:1.4.0.4
	tg-mergefixes-1-base:1.4
	MIROS_X:1.4.0.2
	MIROS_X_BASE:1.4
	tg-mergetmp-3:1.4
	cvs-200411261545:1.1.1.8
	MIRBSD_XP_MIRPPC:1.3.0.4
	MIRBSD_XP_SPARC_BASE:1.3
	MIRBSD_XP_SPARC:1.3.0.2
	MIRBSD_7quater:1.1.1.5
	cvs-200405160640:1.1.1.7
	cvs-200401271800:1.1.1.6
	cvs-200401261630:1.1.1.6
	cvs-200401021645:1.1.1.6
	MIRBSD_7_ALPHA:1.1.1.5.0.6
	MIRBSD_7:1.1.1.5.0.4
	cvs-200312222040:1.1.1.6
	MIRBSD_7ter:1.1.1.5
	MIRBSD_7_DEV:1.1.1.5.0.2
	cvs-200310020700:1.1.1.5
	cvs-200309271030:1.1.1.5
	cvs-200309251530:1.1.1.5
	cvs-200308302005:1.1.1.5
	cvs-200308171200:1.1.1.5
	ctm-3496:1.1.1.5
	ctm-3449:1.1.1.5
	ctm-3437:1.1.1.4
	cvs-200307191805:1.1.1.4
	ctm-3425:1.1.1.4
	cvs-200307091500:1.1.1.4
	ctm-3389:1.1.1.4
	cvs-200306291430:1.1.1.4
	ctm-3341:1.1.1.4
	MIRBSD_5:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.11.26.16.46.07;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.27.16.43.24;	author tg;	state Stab;
branches;
next	1.2;

1.2
date	2004.01.10.04.56.57;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.48.28;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.48.28;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.21.19.02.39;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.31.06;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.19.12.42.34;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.07.26.13.14.35;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.22.21.10.38;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.16.08.24.41;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.26.15.51.18;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@* merge
* fix a time_t bug I apparently introduced,
  which would show up in ~2038
* fix some more time_t and bcopy stuff
* fix all the Makefiles (bad ho@@!)
* check for tests

There's quite some discussion ongoing at license-discuss@@opensource.org
recently, not only about licences. The D-FSL was submitted, and it's
apparent that we can be liable for known bugs in our code too, depending
on the mood of the judge. That's why I rather full-update this one.
We're now en par with #7-stable again.
@
text
@/* $MirBSD: src/sbin/isakmpd/policy.c,v 1.3 2004/05/27 16:43:24 tg Stab $ */
/* $OpenBSD: policy.c,v 1.78 2004/08/08 19:11:06 deraadt Exp $	 */
/* $EOM: policy.c,v 1.49 2000/10/24 13:33:39 niklas Exp $ */

/*
 * Copyright (c) 1999, 2000, 2001 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2001 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/param.h>
#include <sys/mman.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <regex.h>
#include <ctype.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <keynote.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <openssl/ssl.h>
#include <netdb.h>

#include "sysdep.h"

#include "conf.h"
#include "exchange.h"
#include "ipsec.h"
#include "isakmp_doi.h"
#include "sa.h"
#include "transport.h"
#include "log.h"
#include "message.h"
#include "monitor.h"
#include "util.h"
#include "policy.h"
#include "x509.h"

__RCSID("$MirBSD: src/sbin/isakmpd/policy.c,v 1.3 2004/05/27 16:43:24 tg Stab $");

char          **policy_asserts = NULL;
int		ignore_policy = 0;
int             policy_asserts_num = 0;
struct exchange *policy_exchange = 0;
struct sa      *policy_sa = 0;
struct sa      *policy_isakmp_sa = 0;

static const char hextab[] = {
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
};

/*
 * Adaptation of Vixie's inet_ntop4 ()
 */
static const char *
my_inet_ntop4(const in_addr_t *src, char *dst, size_t size, int normalize)
{
	static const char fmt[] = "%03u.%03u.%03u.%03u";
	char            tmp[sizeof "255.255.255.255"];
	in_addr_t       src2;

	if (normalize)
		src2 = ntohl(*src);
	else
		src2 = *src;

	if (snprintf(tmp, sizeof tmp, fmt, ((u_int8_t *)&src2)[0],
	    ((u_int8_t *)&src2)[1], ((u_int8_t *)&src2)[2],
	    ((u_int8_t *)&src2)[3]) > (int)size) {
		errno = ENOSPC;
		return 0;
	}
	strlcpy(dst, tmp, size);
	return dst;
}

static const char *
my_inet_ntop6(const unsigned char *src, char *dst, size_t size)
{
	static const char fmt[] =
	    "%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x";
	char	tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"];

	if (snprintf(tmp, sizeof tmp, fmt, src[0], src[1], src[2], src[3],
	    src[4], src[5], src[6], src[7], src[8], src[9], src[10], src[11],
	    src[12], src[13], src[14], src[15]) > (int)size) {
		errno = ENOSPC;
		return 0;
	}
	strlcpy(dst, tmp, size);
	return dst;
}

char *
policy_callback(char *name)
{
	struct proto   *proto;

	u_int8_t       *attr, *value, *id, *idlocal, *idremote;
	size_t          id_sz, idlocalsz, idremotesz;
	struct sockaddr *sin;
	struct ipsec_exch *ie;
	struct ipsec_sa *is;
	size_t          i;
	int             fmt, lifetype = 0;
	in_addr_t       net, subnet;
	u_int16_t       len, type;
	time_t          tt;
	char           *addr;
	static char     mytimeofday[15];

	/* We use all these as a cache.  */
#define PMAX 32
	static char    *esp_present, *ah_present, *comp_present;
	static char    *ah_hash_alg, *ah_auth_alg, *esp_auth_alg, *esp_enc_alg;
	static char    *comp_alg, ah_life_kbytes[PMAX], ah_life_seconds[PMAX];
	static char     esp_life_kbytes[PMAX], esp_life_seconds[PMAX];
	static char     comp_life_kbytes[PMAX];
	static char    *ah_ecn, *esp_ecn, *comp_ecn;
	static char     comp_life_seconds[PMAX], *ah_encapsulation;
	static char    *esp_encapsulation, *comp_encapsulation;
	static char     ah_key_length[PMAX], esp_key_length[PMAX];
	static char     ah_key_rounds[PMAX], esp_key_rounds[PMAX];
	static char	comp_dict_size[PMAX], comp_private_alg[PMAX];
	static char    *remote_filter_type, *local_filter_type;
	static char     remote_filter_addr_upper[NI_MAXHOST];
	static char     remote_filter_addr_lower[NI_MAXHOST];
	static char     local_filter_addr_upper[NI_MAXHOST];
	static char     local_filter_addr_lower[NI_MAXHOST];
	static char     ah_group_desc[PMAX], esp_group_desc[PMAX];
	static char	comp_group_desc[PMAX], remote_ike_address[NI_MAXHOST];
	static char     local_ike_address[NI_MAXHOST];
	static char    *remote_id_type, remote_id_addr_upper[NI_MAXHOST];
	static char    *phase_1, remote_id_addr_lower[NI_MAXHOST];
	static char    *remote_id_proto, remote_id_port[PMAX];
	static char     remote_filter_port[PMAX], local_filter_port[PMAX];
	static char    *remote_filter_proto, *local_filter_proto, *pfs;
	static char    *initiator, remote_filter_proto_num[3];
	static char	local_filter_proto_num[3], remote_id_proto_num[3];
	static char     phase1_group[PMAX];

	/* Allocated.  */
	static char    *remote_filter = 0, *local_filter = 0, *remote_id = 0;

	static int      dirty = 1;

	/* We only need to set dirty at initialization time really.  */
	if (strcmp(name, KEYNOTE_CALLBACK_CLEANUP) == 0
	    || strcmp(name, KEYNOTE_CALLBACK_INITIALIZE) == 0) {
		esp_present = ah_present = comp_present = pfs = "no";
		ah_hash_alg = ah_auth_alg = phase_1 = "";
		esp_auth_alg = esp_enc_alg = comp_alg = ah_encapsulation = "";
		ah_ecn = esp_ecn = comp_ecn = "no";
		esp_encapsulation = comp_encapsulation = "";
		remote_filter_type = "";
		local_filter_type = remote_id_type = initiator = "";
		remote_filter_proto = local_filter_proto = "";
		remote_id_proto = "";

		if (remote_filter != 0) {
			free(remote_filter);
			remote_filter = 0;
		}
		if (local_filter != 0) {
			free(local_filter);
			local_filter = 0;
		}
		if (remote_id != 0) {
			free(remote_id);
			remote_id = 0;
		}
		memset(remote_ike_address, 0, sizeof remote_ike_address);
		memset(local_ike_address, 0, sizeof local_ike_address);
		memset(ah_life_kbytes, 0, sizeof ah_life_kbytes);
		memset(ah_life_seconds, 0, sizeof ah_life_seconds);
		memset(esp_life_kbytes, 0, sizeof esp_life_kbytes);
		memset(esp_life_seconds, 0, sizeof esp_life_seconds);
		memset(comp_life_kbytes, 0, sizeof comp_life_kbytes);
		memset(comp_life_seconds, 0, sizeof comp_life_seconds);
		memset(ah_key_length, 0, sizeof ah_key_length);
		memset(ah_key_rounds, 0, sizeof ah_key_rounds);
		memset(esp_key_length, 0, sizeof esp_key_length);
		memset(esp_key_rounds, 0, sizeof esp_key_rounds);
		memset(comp_dict_size, 0, sizeof comp_dict_size);
		memset(comp_private_alg, 0, sizeof comp_private_alg);
		memset(remote_filter_addr_upper, 0,
		    sizeof remote_filter_addr_upper);
		memset(remote_filter_addr_lower, 0,
		    sizeof remote_filter_addr_lower);
		memset(local_filter_addr_upper, 0,
		    sizeof local_filter_addr_upper);
		memset(local_filter_addr_lower, 0,
		    sizeof local_filter_addr_lower);
		memset(remote_id_addr_upper, 0, sizeof remote_id_addr_upper);
		memset(remote_id_addr_lower, 0, sizeof remote_id_addr_lower);
		memset(ah_group_desc, 0, sizeof ah_group_desc);
		memset(esp_group_desc, 0, sizeof esp_group_desc);
		memset(remote_id_port, 0, sizeof remote_id_port);
		memset(remote_filter_port, 0, sizeof remote_filter_port);
		memset(local_filter_port, 0, sizeof local_filter_port);
		memset(phase1_group, 0, sizeof phase1_group);

		dirty = 1;
		return "";
	}
	/*
	 * If dirty is set, this is the first request for an attribute, so
	 * populate our value cache.
         */
	if (dirty) {
		ie = policy_exchange->data;

		if (ie->pfs)
			pfs = "yes";

		is = policy_isakmp_sa->data;
		snprintf(phase1_group, sizeof phase1_group, "%u",
		    is->group_desc);

		for (proto = TAILQ_FIRST(&policy_sa->protos); proto;
		    proto = TAILQ_NEXT(proto, link)) {
			switch (proto->proto) {
			case IPSEC_PROTO_IPSEC_AH:
				ah_present = "yes";
				switch (proto->id) {
				case IPSEC_AH_MD5:
					ah_hash_alg = "md5";
					break;

				case IPSEC_AH_SHA:
					ah_hash_alg = "sha";
					break;

				case IPSEC_AH_RIPEMD:
					ah_hash_alg = "ripemd";
					break;

				case IPSEC_AH_SHA2_256:
					ah_auth_alg = "sha2-256";
					break;

				case IPSEC_AH_SHA2_384:
					ah_auth_alg = "sha2-384";
					break;

				case IPSEC_AH_SHA2_512:
					ah_auth_alg = "sha2-512";
					break;

				case IPSEC_AH_DES:
					ah_hash_alg = "des";
					break;
				}

				break;

			case IPSEC_PROTO_IPSEC_ESP:
				esp_present = "yes";
				switch (proto->id) {
				case IPSEC_ESP_DES_IV64:
					esp_enc_alg = "des-iv64";
					break;

				case IPSEC_ESP_DES:
					esp_enc_alg = "des";
					break;

				case IPSEC_ESP_3DES:
					esp_enc_alg = "3des";
					break;

				case IPSEC_ESP_AES:
				case IPSEC_ESP_AES_128_CTR:
					esp_enc_alg = "aes";
					break;

				case IPSEC_ESP_RC5:
					esp_enc_alg = "rc5";
					break;

				case IPSEC_ESP_IDEA:
					esp_enc_alg = "idea";
					break;

				case IPSEC_ESP_CAST:
					esp_enc_alg = "cast";
					break;

				case IPSEC_ESP_BLOWFISH:
					esp_enc_alg = "blowfish";
					break;

				case IPSEC_ESP_3IDEA:
					esp_enc_alg = "3idea";
					break;

				case IPSEC_ESP_DES_IV32:
					esp_enc_alg = "des-iv32";
					break;

				case IPSEC_ESP_RC4:
					esp_enc_alg = "rc4";
					break;

				case IPSEC_ESP_NULL:
					esp_enc_alg = "null";
					break;
				}

				break;

			case IPSEC_PROTO_IPCOMP:
				comp_present = "yes";
				switch (proto->id) {
				case IPSEC_IPCOMP_OUI:
					comp_alg = "oui";
					break;

				case IPSEC_IPCOMP_DEFLATE:
					comp_alg = "deflate";
					break;

				case IPSEC_IPCOMP_LZS:
					comp_alg = "lzs";
					break;

				case IPSEC_IPCOMP_V42BIS:
					comp_alg = "v42bis";
					break;
				}

				break;
			}

			for (attr = proto->chosen->p +
			    ISAKMP_TRANSFORM_SA_ATTRS_OFF;
			    attr < proto->chosen->p +
			    GET_ISAKMP_GEN_LENGTH(proto->chosen->p);
			    attr = value + len) {
				if (attr + ISAKMP_ATTR_VALUE_OFF >
				    (proto->chosen->p +
				    GET_ISAKMP_GEN_LENGTH(proto->chosen->p)))
					return "";

				type = GET_ISAKMP_ATTR_TYPE(attr);
				fmt = ISAKMP_ATTR_FORMAT(type);
				type = ISAKMP_ATTR_TYPE(type);
				value = attr + (fmt ?
				    ISAKMP_ATTR_LENGTH_VALUE_OFF :
				    ISAKMP_ATTR_VALUE_OFF);
				len = (fmt ? ISAKMP_ATTR_LENGTH_VALUE_LEN :
				    GET_ISAKMP_ATTR_LENGTH_VALUE(attr));

				if (value + len > proto->chosen->p +
				    GET_ISAKMP_GEN_LENGTH(proto->chosen->p))
					return "";

				switch (type) {
				case IPSEC_ATTR_SA_LIFE_TYPE:
					lifetype = decode_16(value);
					break;

				case IPSEC_ATTR_SA_LIFE_DURATION:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						if (lifetype == IPSEC_DURATION_SECONDS) {
							if (len == 2)
								snprintf(ah_life_seconds, sizeof ah_life_seconds,
								    "%u", decode_16(value));
							else
								snprintf(ah_life_seconds, sizeof ah_life_seconds,
								    "%u", decode_32(value));
						} else {
							if (len == 2)
								snprintf(ah_life_kbytes, sizeof ah_life_kbytes,
								    "%u", decode_16(value));
							else
								snprintf(ah_life_kbytes, sizeof ah_life_kbytes,
								    "%u", decode_32(value));
						}

						break;

					case IPSEC_PROTO_IPSEC_ESP:
						if (lifetype == IPSEC_DURATION_SECONDS) {
							if (len == 2)
								snprintf(esp_life_seconds,
								    sizeof esp_life_seconds, "%u",
								    decode_16(value));
							else
								snprintf(esp_life_seconds,
								    sizeof esp_life_seconds, "%u",
								    decode_32(value));
						} else {
							if (len == 2)
								snprintf(esp_life_kbytes,
								    sizeof esp_life_kbytes, "%u",
								     decode_16(value));
							else
								snprintf(esp_life_kbytes,
								    sizeof esp_life_kbytes, "%u",
								    decode_32(value));
						}

						break;

					case IPSEC_PROTO_IPCOMP:
						if (lifetype == IPSEC_DURATION_SECONDS) {
							if (len == 2)
								snprintf(comp_life_seconds,
								    sizeof comp_life_seconds, "%u",
								    decode_16(value));
							else
								snprintf(comp_life_seconds,
								    sizeof comp_life_seconds, "%u",
								    decode_32(value));
						} else {
							if (len == 2)
								snprintf(comp_life_kbytes,
								    sizeof comp_life_kbytes, "%u",
								    decode_16(value));
							else
								snprintf(comp_life_kbytes,
								    sizeof comp_life_kbytes, "%u",
								    decode_32(value));
						}
						break;
					}
					break;

				case IPSEC_ATTR_GROUP_DESCRIPTION:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						snprintf(ah_group_desc,
						    sizeof ah_group_desc, "%u",
						    decode_16(value));
						break;

					case IPSEC_PROTO_IPSEC_ESP:
						snprintf(esp_group_desc,
						    sizeof esp_group_desc, "%u",
						    decode_16(value));
						break;

					case IPSEC_PROTO_IPCOMP:
						snprintf(comp_group_desc,
						    sizeof comp_group_desc, "%u",
						    decode_16(value));
						break;
					}
					break;

				case IPSEC_ATTR_ECN_TUNNEL:
					if (decode_16(value))
						switch (proto->proto) {
						case IPSEC_PROTO_IPSEC_AH:
							ah_ecn = "yes";
							break;

						case IPSEC_PROTO_IPSEC_ESP:
							esp_ecn = "yes";
							break;

						case IPSEC_PROTO_IPCOMP:
							comp_ecn = "yes";
							break;
						}

				case IPSEC_ATTR_ENCAPSULATION_MODE:
					if (decode_16(value) == IPSEC_ENCAP_TUNNEL)
						switch (proto->proto) {
						case IPSEC_PROTO_IPSEC_AH:
							ah_encapsulation = "tunnel";
							break;

						case IPSEC_PROTO_IPSEC_ESP:
							esp_encapsulation = "tunnel";
							break;

						case IPSEC_PROTO_IPCOMP:
							comp_encapsulation = "tunnel";
							break;
						}
#if defined (USE_NAT_TRAVERSAL)
					else if (decode_16(value) == IPSEC_ENCAP_UDP_ENCAP_TUNNEL)
						switch (proto->proto) {
						case IPSEC_PROTO_IPSEC_AH:
							ah_encapsulation = "udp-encap-tunnel";
							break;

						case IPSEC_PROTO_IPSEC_ESP:
							esp_encapsulation = "udp-encap-tunnel";
							break;

						case IPSEC_PROTO_IPCOMP:
							comp_encapsulation = "udp-encap-tunnel";
							break;
						}
					/* XXX IPSEC_ENCAP_UDP_ENCAP_TRANSPORT */
#endif
					else
						switch (proto->proto) {
						case IPSEC_PROTO_IPSEC_AH:
							ah_encapsulation = "transport";
							break;

						case IPSEC_PROTO_IPSEC_ESP:
							esp_encapsulation = "transport";
							break;

						case IPSEC_PROTO_IPCOMP:
							comp_encapsulation = "transport";
							break;
						}
					break;

				case IPSEC_ATTR_AUTHENTICATION_ALGORITHM:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						switch (decode_16(value)) {
						case IPSEC_AUTH_HMAC_MD5:
							ah_auth_alg = "hmac-md5";
							break;

						case IPSEC_AUTH_HMAC_SHA:
							ah_auth_alg = "hmac-sha";
							break;

						case IPSEC_AUTH_HMAC_RIPEMD:
							ah_auth_alg = "hmac-ripemd";
							break;

						case IPSEC_AUTH_HMAC_SHA2_256:
							ah_auth_alg = "hmac-sha2-256";
							break;

						case IPSEC_AUTH_HMAC_SHA2_384:
							ah_auth_alg = "hmac-sha2-384";
							break;

						case IPSEC_AUTH_HMAC_SHA2_512:
							ah_auth_alg = "hmac-sha2-512";
							break;

						case IPSEC_AUTH_DES_MAC:
							ah_auth_alg = "des-mac";
							break;

						case IPSEC_AUTH_KPDK:
							ah_auth_alg = "kpdk";
							break;
						}
						break;

					case IPSEC_PROTO_IPSEC_ESP:
						switch (decode_16(value)) {
						case IPSEC_AUTH_HMAC_MD5:
							esp_auth_alg = "hmac-md5";
							break;

						case IPSEC_AUTH_HMAC_SHA:
							esp_auth_alg = "hmac-sha";
							break;

						case IPSEC_AUTH_HMAC_RIPEMD:
							esp_auth_alg = "hmac-ripemd";
							break;

						case IPSEC_AUTH_HMAC_SHA2_256:
							esp_auth_alg = "hmac-sha2-256";
							break;

						case IPSEC_AUTH_HMAC_SHA2_384:
							esp_auth_alg = "hmac-sha2-384";
							break;

						case IPSEC_AUTH_HMAC_SHA2_512:
							esp_auth_alg = "hmac-sha2-512";
							break;

						case IPSEC_AUTH_DES_MAC:
							esp_auth_alg = "des-mac";
							break;

						case IPSEC_AUTH_KPDK:
							esp_auth_alg = "kpdk";
							break;
						}
						break;
					}
					break;

				case IPSEC_ATTR_KEY_LENGTH:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						snprintf(ah_key_length,
						    sizeof ah_key_length, "%u",
						    decode_16(value));
						break;

					case IPSEC_PROTO_IPSEC_ESP:
						snprintf(esp_key_length,
						    sizeof esp_key_length, "%u",
						    decode_16(value));
						break;
					}
					break;

				case IPSEC_ATTR_KEY_ROUNDS:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						snprintf(ah_key_rounds,
						    sizeof ah_key_rounds, "%u",
						    decode_16(value));
						break;

					case IPSEC_PROTO_IPSEC_ESP:
						snprintf(esp_key_rounds,
						    sizeof esp_key_rounds, "%u",
						    decode_16(value));
						break;
					}
					break;

				case IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE:
					snprintf(comp_dict_size,
					    sizeof comp_dict_size, "%u",
					    decode_16(value));
					break;

				case IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM:
					snprintf(comp_private_alg,
					    sizeof comp_private_alg, "%u",
					    decode_16(value));
					break;
				}
			}
		}

		policy_sa->transport->vtbl->get_src(policy_sa->transport,
		    &sin);
		if (sockaddr2text(sin, &addr, 1)) {
			log_error("policy_callback: sockaddr2text failed");
			goto bad;
		}
		strlcpy(local_ike_address, addr, sizeof local_ike_address);
		free(addr);

		policy_sa->transport->vtbl->get_dst(policy_sa->transport,
		    &sin);
		if (sockaddr2text(sin, &addr, 1)) {
			log_error("policy_callback: sockaddr2text failed");
			goto bad;
		}
		strlcpy(remote_ike_address, addr, sizeof remote_ike_address);
		free(addr);

		switch (policy_isakmp_sa->exch_type) {
		case ISAKMP_EXCH_AGGRESSIVE:
			phase_1 = "aggressive";
			break;

		case ISAKMP_EXCH_ID_PROT:
			phase_1 = "main";
			break;
		}

		if (policy_isakmp_sa->initiator) {
			id = policy_isakmp_sa->id_r;
			id_sz = policy_isakmp_sa->id_r_len;
		} else {
			id = policy_isakmp_sa->id_i;
			id_sz = policy_isakmp_sa->id_i_len;
		}

		switch (id[0]) {
		case IPSEC_ID_IPV4_ADDR:
			remote_id_type = "IPv4 address";

			net = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ);
			my_inet_ntop4(&net, remote_id_addr_upper,
				      sizeof remote_id_addr_upper - 1, 1);
			my_inet_ntop4(&net, remote_id_addr_lower,
				      sizeof remote_id_addr_lower - 1, 1);
			remote_id = strdup(remote_id_addr_upper);
			if (!remote_id) {
				log_error("policy_callback: "
				    "strdup (\"%s\") failed",
				    remote_id_addr_upper);
				goto bad;
			}
			break;

		case IPSEC_ID_IPV4_RANGE:
			remote_id_type = "IPv4 range";

			net = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ);
			my_inet_ntop4(&net, remote_id_addr_lower,
			    sizeof remote_id_addr_lower - 1, 1);
			net = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ + 4);
			my_inet_ntop4(&net, remote_id_addr_upper,
			    sizeof remote_id_addr_upper - 1, 1);
			len = strlen(remote_id_addr_upper) +
			    strlen(remote_id_addr_lower) + 2;
			remote_id = calloc(len, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: "
				    "calloc (%d, %lu) failed", len,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			strlcpy(remote_id, remote_id_addr_lower, len);
			strlcat(remote_id, "-", len);
			strlcat(remote_id, remote_id_addr_upper, len);
			break;

		case IPSEC_ID_IPV4_ADDR_SUBNET:
			remote_id_type = "IPv4 subnet";

			net = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ);
			subnet = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ + 4);
			net &= subnet;
			my_inet_ntop4(&net, remote_id_addr_lower,
			    sizeof remote_id_addr_lower - 1, 1);
			net |= ~subnet;
			my_inet_ntop4(&net, remote_id_addr_upper,
			    sizeof remote_id_addr_upper - 1, 1);
			len = strlen(remote_id_addr_upper) +
				 strlen(remote_id_addr_lower) + 2;
			remote_id = calloc(len, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: "
				    "calloc (%d, %lu) failed", len,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			strlcpy(remote_id, remote_id_addr_lower, len);
			strlcat(remote_id, "-", len);
			strlcat(remote_id, remote_id_addr_upper, len);
			break;

		case IPSEC_ID_IPV6_ADDR:
			remote_id_type = "IPv6 address";
			my_inet_ntop6(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    remote_id_addr_upper, sizeof remote_id_addr_upper);
			strlcpy(remote_id_addr_lower, remote_id_addr_upper,
			    sizeof remote_id_addr_lower);
			remote_id = strdup(remote_id_addr_upper);
			if (!remote_id) {
				log_error("policy_callback: "
				    "strdup (\"%s\") failed",
				    remote_id_addr_upper);
				goto bad;
			}
			break;

		case IPSEC_ID_IPV6_RANGE:
			remote_id_type = "IPv6 range";

			my_inet_ntop6(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    remote_id_addr_lower,
			    sizeof remote_id_addr_lower - 1);

			my_inet_ntop6(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ + 16, remote_id_addr_upper,
			    sizeof remote_id_addr_upper - 1);

			len = strlen(remote_id_addr_upper) +
			    strlen(remote_id_addr_lower) + 2;
			remote_id = calloc(len, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: "
				    "calloc (%d, %lu) failed", len,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			strlcpy(remote_id, remote_id_addr_lower, len);
			strlcat(remote_id, "-", len);
			strlcat(remote_id, remote_id_addr_upper, len);
			break;

		case IPSEC_ID_IPV6_ADDR_SUBNET:
		    {
			struct in6_addr net, mask;

			remote_id_type = "IPv6 subnet";

			memmove(&net, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    sizeof(net));
			memmove(&mask,
			    id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 16,
			    sizeof(mask));

			for (i = 0; i < 16; i++)
				net.s6_addr[i] &= mask.s6_addr[i];

			my_inet_ntop6((unsigned char *)&net,
			    remote_id_addr_lower,
			    sizeof remote_id_addr_lower - 1);

			for (i = 0; i < 16; i++)
				net.s6_addr[i] |= ~mask.s6_addr[i];

			my_inet_ntop6((unsigned char *)&net,
			    remote_id_addr_upper,
			    sizeof remote_id_addr_upper - 1);

			len = strlen(remote_id_addr_upper) +
			    strlen(remote_id_addr_lower) + 2;
			remote_id = calloc(len, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: "
				    "calloc (%d, %lu) failed", len,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			strlcpy(remote_id, remote_id_addr_lower, len);
			strlcat(remote_id, "-", len);
			strlcat(remote_id, remote_id_addr_upper, len);
			break;
		    }

		case IPSEC_ID_FQDN:
			remote_id_type = "FQDN";
			remote_id = calloc(id_sz - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ + 1, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: "
				    "calloc (%lu, %lu) failed",
				    (unsigned long)id_sz - ISAKMP_ID_DATA_OFF +
				    ISAKMP_GEN_SZ + 1,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			memcpy(remote_id,
			    id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
			break;

		case IPSEC_ID_USER_FQDN:
			remote_id_type = "User FQDN";
			remote_id = calloc(id_sz - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ + 1, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: "
				    "calloc (%lu, %lu) failed",
				    (unsigned long)id_sz - ISAKMP_ID_DATA_OFF +
				    ISAKMP_GEN_SZ + 1,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			memcpy(remote_id,
			    id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
			break;

		case IPSEC_ID_DER_ASN1_DN:
			remote_id_type = "ASN1 DN";

			remote_id = x509_DN_string(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ,
			    id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
			if (!remote_id) {
				LOG_DBG((LOG_POLICY, 50,
				    "policy_callback: failed to decode name"));
				goto bad;
			}
			break;

		case IPSEC_ID_DER_ASN1_GN:	/* XXX */
			remote_id_type = "ASN1 GN";
			break;

		case IPSEC_ID_KEY_ID:
			remote_id_type = "Key ID";
			remote_id = calloc(2 * (id_sz - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ) + 1, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: "
				    "calloc (%lu, %lu) failed",
				    2 * ((unsigned long)id_sz -
					ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			/* Does it contain any non-printable characters ? */
			for (i = 0;
			     i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ;
			     i++)
				if (!isprint(*(id + ISAKMP_ID_DATA_OFF -
				    ISAKMP_GEN_SZ + i)))
					break;
			if (i >= id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) {
				memcpy(remote_id, id + ISAKMP_ID_DATA_OFF -
				    ISAKMP_GEN_SZ,
				    id_sz - ISAKMP_ID_DATA_OFF +
				    ISAKMP_GEN_SZ);
				break;
			}
			/* Non-printable characters, convert to hex */
			for (i = 0;
			    i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ;
			     i++) {
				remote_id[2 * i] = hextab[*(id +
				    ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) >> 4];
				remote_id[2 * i + 1] = hextab[*(id +
				    ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) & 0xF];
			}
			break;

		default:
			log_print("policy_callback: "
			    "unknown remote ID type %u", id[0]);
			goto bad;
		}

		switch (id[1]) {
		case IPPROTO_TCP:
			remote_id_proto = "tcp";
			break;

		case IPPROTO_UDP:
			remote_id_proto = "udp";
			break;

#ifdef IPPROTO_ETHERIP
		case IPPROTO_ETHERIP:
			remote_id_proto = "etherip";
			break;
#endif

		default:
			snprintf(remote_id_proto_num,
			    sizeof remote_id_proto_num, "%d",
			    id[1]);
			remote_id_proto = remote_id_proto_num;
			break;
		}

		snprintf(remote_id_port, sizeof remote_id_port, "%u",
		    decode_16(id + 2));

		if (policy_exchange->initiator) {
			initiator = "yes";
			idlocal = ie->id_ci;
			idremote = ie->id_cr;
			idlocalsz = ie->id_ci_sz;
			idremotesz = ie->id_cr_sz;
		} else {
			initiator = "no";
			idlocal = ie->id_cr;
			idremote = ie->id_ci;
			idlocalsz = ie->id_cr_sz;
			idremotesz = ie->id_ci_sz;
		}

		/* Initialize the ID variables.  */
		if (idremote) {
			switch (GET_ISAKMP_ID_TYPE(idremote)) {
			case IPSEC_ID_IPV4_ADDR:
				remote_filter_type = "IPv4 address";

				net = decode_32(idremote + ISAKMP_ID_DATA_OFF);
				my_inet_ntop4(&net, remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1, 1);
				my_inet_ntop4(&net, remote_filter_addr_lower,
				    sizeof remote_filter_addr_lower - 1, 1);
				remote_filter =
				    strdup(remote_filter_addr_upper);
				if (!remote_filter) {
					log_error("policy_callback: strdup "
					    "(\"%s\") failed",
					    remote_filter_addr_upper);
					goto bad;
				}
				break;

			case IPSEC_ID_IPV4_RANGE:
				remote_filter_type = "IPv4 range";

				net = decode_32(idremote + ISAKMP_ID_DATA_OFF);
				my_inet_ntop4(&net, remote_filter_addr_lower,
				    sizeof remote_filter_addr_lower - 1, 1);
				net = decode_32(idremote + ISAKMP_ID_DATA_OFF +
				    4);
				my_inet_ntop4(&net, remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1, 1);
				len = strlen(remote_filter_addr_upper) +
				    strlen(remote_filter_addr_lower) + 2;
				remote_filter = calloc(len, sizeof(char));
				if (!remote_filter) {
					log_error("policy_callback: calloc "
					    "(%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(remote_filter,
				    remote_filter_addr_lower, len);
				strlcat(remote_filter, "-", len);
				strlcat(remote_filter,
				    remote_filter_addr_upper, len);
				break;

			case IPSEC_ID_IPV4_ADDR_SUBNET:
				remote_filter_type = "IPv4 subnet";

				net = decode_32(idremote + ISAKMP_ID_DATA_OFF);
				subnet = decode_32(idremote +
				    ISAKMP_ID_DATA_OFF + 4);
				net &= subnet;
				my_inet_ntop4(&net, remote_filter_addr_lower,
				    sizeof remote_filter_addr_lower - 1, 1);
				net |= ~subnet;
				my_inet_ntop4(&net, remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1, 1);
				len = strlen(remote_filter_addr_upper) +
				    strlen(remote_filter_addr_lower) + 2;
				remote_filter = calloc(len, sizeof(char));
				if (!remote_filter) {
					log_error("policy_callback: calloc "
					    "(%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(remote_filter,
				    remote_filter_addr_lower, len);
				strlcat(remote_filter, "-", len);
				strlcat(remote_filter,
				    remote_filter_addr_upper, len);
				break;

			case IPSEC_ID_IPV6_ADDR:
				remote_filter_type = "IPv6 address";
				my_inet_ntop6(idremote + ISAKMP_ID_DATA_OFF,
				    remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1);
				strlcpy(remote_filter_addr_lower,
				    remote_filter_addr_upper,
				    sizeof remote_filter_addr_lower);
				remote_filter =
				    strdup(remote_filter_addr_upper);
				if (!remote_filter) {
					log_error("policy_callback: strdup "
					    "(\"%s\") failed",
					    remote_filter_addr_upper);
					goto bad;
				}
				break;

			case IPSEC_ID_IPV6_RANGE:
				remote_filter_type = "IPv6 range";

				my_inet_ntop6(idremote + ISAKMP_ID_DATA_OFF,
				    remote_filter_addr_lower,
				    sizeof remote_filter_addr_lower - 1);

				my_inet_ntop6(idremote + ISAKMP_ID_DATA_OFF +
				    16, remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1);

				len = strlen(remote_filter_addr_upper) +
				    strlen(remote_filter_addr_lower) + 2;
				remote_filter = calloc(len, sizeof(char));
				if (!remote_filter) {
					log_error("policy_callback: calloc "
					    "(%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(remote_filter,
				    remote_filter_addr_lower, len);
				strlcat(remote_filter, "-", len);
				strlcat(remote_filter,
				    remote_filter_addr_upper, len);
				break;

			case IPSEC_ID_IPV6_ADDR_SUBNET:
				{
					struct in6_addr net, mask;

					remote_filter_type = "IPv6 subnet";

					memmove(&net,
					    idremote + ISAKMP_ID_DATA_OFF,
					    sizeof(net));
					memmove(&mask,
					    idremote + ISAKMP_ID_DATA_OFF + 16,
					    sizeof(mask));

					for (i = 0; i < 16; i++)
						net.s6_addr[i] &=
						    mask.s6_addr[i];

					my_inet_ntop6((unsigned char *)&net,
					    remote_filter_addr_lower,
					sizeof remote_filter_addr_lower - 1);

					for (i = 0; i < 16; i++)
						net.s6_addr[i] |=
						    ~mask.s6_addr[i];

					my_inet_ntop6((unsigned char *)&net,
					    remote_filter_addr_upper,
					sizeof remote_filter_addr_upper - 1);

					len = strlen(remote_filter_addr_upper)
						+ strlen(remote_filter_addr_lower) + 2;
					remote_filter = calloc(len,
					    sizeof(char));
					if (!remote_filter) {
						log_error("policy_callback: "
						    "calloc (%d, %lu) failed",
						    len,
						    (unsigned long)sizeof(char));
						goto bad;
					}
					strlcpy(remote_filter,
					    remote_filter_addr_lower, len);
					strlcat(remote_filter, "-", len);
					strlcat(remote_filter,
					    remote_filter_addr_upper, len);
					break;
				}

			case IPSEC_ID_FQDN:
				remote_filter_type = "FQDN";
				remote_filter = malloc(idremotesz -
				    ISAKMP_ID_DATA_OFF + 1);
				if (!remote_filter) {
					log_error("policy_callback: "
					    "malloc (%lu) failed",
					    (unsigned long)idremotesz -
					    ISAKMP_ID_DATA_OFF + 1);
					goto bad;
				}
				memcpy(remote_filter,
				    idremote + ISAKMP_ID_DATA_OFF,
				    idremotesz - ISAKMP_ID_DATA_OFF);
				remote_filter[idremotesz - ISAKMP_ID_DATA_OFF]
				    = '\0';
				break;

			case IPSEC_ID_USER_FQDN:
				remote_filter_type = "User FQDN";
				remote_filter = malloc(idremotesz -
				    ISAKMP_ID_DATA_OFF + 1);
				if (!remote_filter) {
					log_error("policy_callback: "
					    "malloc (%lu) failed",
					    (unsigned long)idremotesz -
					    ISAKMP_ID_DATA_OFF + 1);
					goto bad;
				}
				memcpy(remote_filter,
				    idremote + ISAKMP_ID_DATA_OFF,
				    idremotesz - ISAKMP_ID_DATA_OFF);
				remote_filter[idremotesz - ISAKMP_ID_DATA_OFF]
				    = '\0';
				break;

			case IPSEC_ID_DER_ASN1_DN:
				remote_filter_type = "ASN1 DN";

				remote_filter = x509_DN_string(idremote +
				    ISAKMP_ID_DATA_OFF,
				    idremotesz - ISAKMP_ID_DATA_OFF);
				if (!remote_filter) {
					LOG_DBG((LOG_POLICY, 50,
					    "policy_callback: "
					    "failed to decode name"));
					goto bad;
				}
				break;

			case IPSEC_ID_DER_ASN1_GN:	/* XXX -- not sure
							 * what's in this.  */
				remote_filter_type = "ASN1 GN";
				break;

			case IPSEC_ID_KEY_ID:
				remote_filter_type = "Key ID";
				remote_filter
					= calloc(2 * (idremotesz -
					    ISAKMP_ID_DATA_OFF) + 1,
					    sizeof(char));
				if (!remote_filter) {
					log_error("policy_callback: "
					    "calloc (%lu, %lu) failed",
					    2 * ((unsigned long)idremotesz -
						ISAKMP_ID_DATA_OFF) + 1,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				/*
				 * Does it contain any non-printable
				 * characters ?
				 */
				for (i = 0;
				     i < idremotesz - ISAKMP_ID_DATA_OFF; i++)
					if (!isprint(*(idremote +
					    ISAKMP_ID_DATA_OFF + i)))
						break;
				if (i >= idremotesz - ISAKMP_ID_DATA_OFF) {
					memcpy(remote_filter,
					    idremote + ISAKMP_ID_DATA_OFF,
					    idremotesz - ISAKMP_ID_DATA_OFF);
					break;
				}
				/* Non-printable characters, convert to hex */
				for (i = 0;
				     i < idremotesz - ISAKMP_ID_DATA_OFF;
				     i++) {
					remote_filter[2 * i]
					    = hextab[*(idremote +
						ISAKMP_ID_DATA_OFF) >> 4];
					remote_filter[2 * i + 1]
					    = hextab[*(idremote +
						ISAKMP_ID_DATA_OFF) & 0xF];
				}
				break;

			default:
				log_print("policy_callback: "
				    "unknown Remote ID type %u",
				    GET_ISAKMP_ID_TYPE(idremote));
				goto bad;
			}

			switch (idremote[ISAKMP_GEN_SZ + 1]) {
			case IPPROTO_TCP:
				remote_filter_proto = "tcp";
				break;

			case IPPROTO_UDP:
				remote_filter_proto = "udp";
				break;

#ifdef IPPROTO_ETHERIP
			case IPPROTO_ETHERIP:
				remote_filter_proto = "etherip";
				break;
#endif

			default:
				snprintf(remote_filter_proto_num,
				    sizeof remote_filter_proto_num, "%d",
				    idremote[ISAKMP_GEN_SZ + 1]);
				remote_filter_proto = remote_filter_proto_num;
				break;
			}

			snprintf(remote_filter_port, sizeof remote_filter_port,
			    "%u", decode_16(idremote + ISAKMP_GEN_SZ + 2));
		} else {
			policy_sa->transport->vtbl->get_dst(policy_sa->transport, &sin);
			switch (sin->sa_family) {
			case AF_INET:
				remote_filter_type = "IPv4 address";
				break;
			case AF_INET6:
				remote_filter_type = "IPv6 address";
				break;
			default:
				log_print("policy_callback: "
				    "unsupported protocol family %d",
				    sin->sa_family);
				goto bad;
			}
			if (sockaddr2text(sin, &addr, 1)) {
				log_error("policy_callback: "
				    "sockaddr2text failed");
				goto bad;
			}
			memcpy(remote_filter_addr_upper, addr,
			       sizeof remote_filter_addr_upper);
			memcpy(remote_filter_addr_lower, addr,
			       sizeof remote_filter_addr_lower);
			free(addr);
			remote_filter = strdup(remote_filter_addr_upper);
			if (!remote_filter) {
				log_error("policy_callback: "
				    "strdup (\"%s\") failed",
				    remote_filter_addr_upper);
				goto bad;
			}
		}

		if (idlocal) {
			switch (GET_ISAKMP_ID_TYPE(idlocal)) {
			case IPSEC_ID_IPV4_ADDR:
				local_filter_type = "IPv4 address";

				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF);
				my_inet_ntop4(&net, local_filter_addr_upper,
				     sizeof local_filter_addr_upper - 1, 1);
				my_inet_ntop4(&net, local_filter_addr_lower,
				     sizeof local_filter_addr_upper - 1, 1);
				local_filter = strdup(local_filter_addr_upper);
				if (!local_filter) {
					log_error("policy_callback: "
					    "strdup (\"%s\") failed",
					    local_filter_addr_upper);
					goto bad;
				}
				break;

			case IPSEC_ID_IPV4_RANGE:
				local_filter_type = "IPv4 range";

				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF);
				my_inet_ntop4(&net, local_filter_addr_lower,
				     sizeof local_filter_addr_lower - 1, 1);
				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF +
				    4);
				my_inet_ntop4(&net, local_filter_addr_upper,
				     sizeof local_filter_addr_upper - 1, 1);
				len = strlen(local_filter_addr_upper)
					+ strlen(local_filter_addr_lower) + 2;
				local_filter = calloc(len, sizeof(char));
				if (!local_filter) {
					log_error("policy_callback: "
					    "calloc (%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(local_filter, local_filter_addr_lower,
				    len);
				strlcat(local_filter, "-", len);
				strlcat(local_filter, local_filter_addr_upper,
				    len);
				break;

			case IPSEC_ID_IPV4_ADDR_SUBNET:
				local_filter_type = "IPv4 subnet";

				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF);
				subnet = decode_32(idlocal +
				    ISAKMP_ID_DATA_OFF + 4);
				net &= subnet;
				my_inet_ntop4(&net, local_filter_addr_lower,
				     sizeof local_filter_addr_lower - 1, 1);
				net |= ~subnet;
				my_inet_ntop4(&net, local_filter_addr_upper,
				     sizeof local_filter_addr_upper - 1, 1);
				len = strlen(local_filter_addr_upper)
					+ strlen(local_filter_addr_lower) + 2;
				local_filter = calloc(len, sizeof(char));
				if (!local_filter) {
					log_error("policy_callback: "
					    "calloc (%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(local_filter, local_filter_addr_lower,
				    len);
				strlcat(local_filter, "-", len);
				strlcat(local_filter, local_filter_addr_upper,
				    len);
				break;

			case IPSEC_ID_IPV6_ADDR:
				local_filter_type = "IPv6 address";
				my_inet_ntop6(idlocal + ISAKMP_ID_DATA_OFF,
					      local_filter_addr_upper,
					sizeof local_filter_addr_upper - 1);
				strlcpy(local_filter_addr_lower,
				    local_filter_addr_upper,
				    sizeof local_filter_addr_lower);
				local_filter = strdup(local_filter_addr_upper);
				if (!local_filter) {
					log_error("policy_callback: "
					    "strdup (\"%s\") failed",
					    local_filter_addr_upper);
					goto bad;
				}
				break;

			case IPSEC_ID_IPV6_RANGE:
				local_filter_type = "IPv6 range";

				my_inet_ntop6(idlocal + ISAKMP_ID_DATA_OFF,
					      local_filter_addr_lower,
					sizeof local_filter_addr_lower - 1);

				my_inet_ntop6(idlocal + ISAKMP_ID_DATA_OFF +
				    16, local_filter_addr_upper,
				    sizeof local_filter_addr_upper - 1);

				len = strlen(local_filter_addr_upper)
					+ strlen(local_filter_addr_lower) + 2;
				local_filter = calloc(len, sizeof(char));
				if (!local_filter) {
					log_error("policy_callback: "
					    "calloc (%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(local_filter, local_filter_addr_lower,
				    len);
				strlcat(local_filter, "-", len);
				strlcat(local_filter, local_filter_addr_upper,
				    len);
				break;

			case IPSEC_ID_IPV6_ADDR_SUBNET:
				{
					struct in6_addr net, mask;

					local_filter_type = "IPv6 subnet";

					memmove(&net,
					    idlocal + ISAKMP_ID_DATA_OFF,
					    sizeof(net));
					memmove(&mask,
					    idlocal + ISAKMP_ID_DATA_OFF + 16,
					    sizeof(mask));

					for (i = 0; i < 16; i++)
						net.s6_addr[i] &=
						    mask.s6_addr[i];

					my_inet_ntop6((unsigned char *)&net,
					    local_filter_addr_lower,
					sizeof local_filter_addr_lower - 1);

					for (i = 0; i < 16; i++)
						net.s6_addr[i] |=
						    ~mask.s6_addr[i];

					my_inet_ntop6((unsigned char *)&net,
					    local_filter_addr_upper,
					    sizeof local_filter_addr_upper -
					    1);

					len = strlen(local_filter_addr_upper)
					    + strlen(local_filter_addr_lower)
					    + 2;
					local_filter = calloc(len,
					    sizeof(char));
					if (!local_filter) {
						log_error("policy_callback: "
						    "calloc (%d, %lu) failed",
						    len,
						    (unsigned long)sizeof(char));
						goto bad;
					}
					strlcpy(local_filter,
					    local_filter_addr_lower, len);
					strlcat(local_filter, "-", len);
					strlcat(local_filter,
					    local_filter_addr_upper, len);
					break;
				}

			case IPSEC_ID_FQDN:
				local_filter_type = "FQDN";
				local_filter = malloc(idlocalsz -
				    ISAKMP_ID_DATA_OFF + 1);
				if (!local_filter) {
					log_error("policy_callback: "
					    "malloc (%lu) failed",
					    (unsigned long)idlocalsz -
					    ISAKMP_ID_DATA_OFF + 1);
					goto bad;
				}
				memcpy(local_filter,
				    idlocal + ISAKMP_ID_DATA_OFF,
				    idlocalsz - ISAKMP_ID_DATA_OFF);
				local_filter[idlocalsz - ISAKMP_ID_DATA_OFF]
				    = '\0';
				break;

			case IPSEC_ID_USER_FQDN:
				local_filter_type = "User FQDN";
				local_filter = malloc(idlocalsz -
				    ISAKMP_ID_DATA_OFF + 1);
				if (!local_filter) {
					log_error("policy_callback: "
					    "malloc (%lu) failed",
					    (unsigned long)idlocalsz -
					    ISAKMP_ID_DATA_OFF + 1);
					goto bad;
				}
				memcpy(local_filter,
				    idlocal + ISAKMP_ID_DATA_OFF,
				    idlocalsz - ISAKMP_ID_DATA_OFF);
				local_filter[idlocalsz - ISAKMP_ID_DATA_OFF]
				    = '\0';
				break;

			case IPSEC_ID_DER_ASN1_DN:
				local_filter_type = "ASN1 DN";

				local_filter = x509_DN_string(idlocal +
				    ISAKMP_ID_DATA_OFF,
				    idlocalsz - ISAKMP_ID_DATA_OFF);
				if (!local_filter) {
					LOG_DBG((LOG_POLICY, 50,
					    "policy_callback: failed to decode"
					    " name"));
					goto bad;
				}
				break;

			case IPSEC_ID_DER_ASN1_GN:
				/* XXX -- not sure what's in this.  */
				local_filter_type = "ASN1 GN";
				break;

			case IPSEC_ID_KEY_ID:
				local_filter_type = "Key ID";
				local_filter = calloc(2 * (idlocalsz -
				    ISAKMP_ID_DATA_OFF) + 1,
				    sizeof(char));
				if (!local_filter) {
					log_error("policy_callback: "
					    "calloc (%lu, %lu) failed",
					    2 * ((unsigned long)idlocalsz -
						ISAKMP_ID_DATA_OFF) + 1,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				/*
				 * Does it contain any non-printable
				 * characters ?
				 */
				for (i = 0;
				     i < idlocalsz - ISAKMP_ID_DATA_OFF; i++)
					if (!isprint(*(idlocal +
					    ISAKMP_ID_DATA_OFF + i)))
						break;
				if (i >= idlocalsz - ISAKMP_ID_DATA_OFF) {
					memcpy(local_filter, idlocal +
					    ISAKMP_ID_DATA_OFF,
					    idlocalsz - ISAKMP_ID_DATA_OFF);
					break;
				}
				/* Non-printable characters, convert to hex */
				for (i = 0;
				     i < idlocalsz - ISAKMP_ID_DATA_OFF; i++) {
					local_filter[2 * i]
					    = hextab[*(idlocal +
						ISAKMP_ID_DATA_OFF) >> 4];
					local_filter[2 * i + 1]
					    = hextab[*(idlocal +
						ISAKMP_ID_DATA_OFF) & 0xF];
				}
				break;

			default:
				log_print("policy_callback: "
				    "unknown Local ID type %u",
				    GET_ISAKMP_ID_TYPE(idlocal));
				goto bad;
			}

			switch (idlocal[ISAKMP_GEN_SZ + 1]) {
			case IPPROTO_TCP:
				local_filter_proto = "tcp";
				break;

			case IPPROTO_UDP:
				local_filter_proto = "udp";
				break;

#ifdef IPPROTO_ETHERIP
			case IPPROTO_ETHERIP:
				local_filter_proto = "etherip";
				break;
#endif

			default:
				snprintf(local_filter_proto_num,
				    sizeof local_filter_proto_num,
				    "%d", idlocal[ISAKMP_GEN_SZ + 1]);
				local_filter_proto = local_filter_proto_num;
				break;
			}

			snprintf(local_filter_port, sizeof local_filter_port,
			    "%u", decode_16(idlocal + ISAKMP_GEN_SZ + 2));
		} else {
			policy_sa->transport->vtbl->get_src(policy_sa->transport,
			    (struct sockaddr **)&sin);
			switch (sin->sa_family) {
			case AF_INET:
				local_filter_type = "IPv4 address";
				break;
			case AF_INET6:
				local_filter_type = "IPv6 address";
				break;
			default:
				log_print("policy_callback: "
				    "unsupported protocol family %d",
				    sin->sa_family);
				goto bad;
			}

			if (sockaddr2text(sin, &addr, 1)) {
				log_error("policy_callback: "
				    "sockaddr2text failed");
				goto bad;
			}
			memcpy(local_filter_addr_upper, addr,
			    sizeof local_filter_addr_upper);
			memcpy(local_filter_addr_lower, addr,
			    sizeof local_filter_addr_lower);
			free(addr);
			local_filter = strdup(local_filter_addr_upper);
			if (!local_filter) {
				log_error("policy_callback: "
				    "strdup (\"%s\") failed",
				    local_filter_addr_upper);
				goto bad;
			}
		}

		LOG_DBG((LOG_POLICY, 80,
		    "Policy context (action attributes):"));
		LOG_DBG((LOG_POLICY, 80, "esp_present == %s", esp_present));
		LOG_DBG((LOG_POLICY, 80, "ah_present == %s", ah_present));
		LOG_DBG((LOG_POLICY, 80, "comp_present == %s", comp_present));
		LOG_DBG((LOG_POLICY, 80, "ah_hash_alg == %s", ah_hash_alg));
		LOG_DBG((LOG_POLICY, 80, "esp_enc_alg == %s", esp_enc_alg));
		LOG_DBG((LOG_POLICY, 80, "comp_alg == %s", comp_alg));
		LOG_DBG((LOG_POLICY, 80, "ah_auth_alg == %s", ah_auth_alg));
		LOG_DBG((LOG_POLICY, 80, "esp_auth_alg == %s", esp_auth_alg));
		LOG_DBG((LOG_POLICY, 80, "ah_life_seconds == %s",
		    ah_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "ah_life_kbytes == %s",
		    ah_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "esp_life_seconds == %s",
		    esp_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "esp_life_kbytes == %s",
		    esp_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "comp_life_seconds == %s",
		    comp_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "comp_life_kbytes == %s",
		    comp_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "ah_encapsulation == %s",
		    ah_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "esp_encapsulation == %s",
		    esp_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "comp_encapsulation == %s",
		    comp_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "comp_dict_size == %s",
		    comp_dict_size));
		LOG_DBG((LOG_POLICY, 80, "comp_private_alg == %s",
		    comp_private_alg));
		LOG_DBG((LOG_POLICY, 80, "ah_key_length == %s",
		    ah_key_length));
		LOG_DBG((LOG_POLICY, 80, "ah_key_rounds == %s",
		    ah_key_rounds));
		LOG_DBG((LOG_POLICY, 80, "esp_key_length == %s",
		    esp_key_length));
		LOG_DBG((LOG_POLICY, 80, "esp_key_rounds == %s",
		    esp_key_rounds));
		LOG_DBG((LOG_POLICY, 80, "ah_group_desc == %s",
		    ah_group_desc));
		LOG_DBG((LOG_POLICY, 80, "esp_group_desc == %s",
		    esp_group_desc));
		LOG_DBG((LOG_POLICY, 80, "comp_group_desc == %s",
		    comp_group_desc));
		LOG_DBG((LOG_POLICY, 80, "ah_ecn == %s", ah_ecn));
		LOG_DBG((LOG_POLICY, 80, "esp_ecn == %s", esp_ecn));
		LOG_DBG((LOG_POLICY, 80, "comp_ecn == %s", comp_ecn));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_type == %s",
		    remote_filter_type));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_addr_upper == %s",
		    remote_filter_addr_upper));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_addr_lower == %s",
		    remote_filter_addr_lower));
		LOG_DBG((LOG_POLICY, 80, "remote_filter == %s",
		    (remote_filter ? remote_filter : "")));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_port == %s",
		    remote_filter_port));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_proto == %s",
		    remote_filter_proto));
		LOG_DBG((LOG_POLICY, 80, "local_filter_type == %s",
		    local_filter_type));
		LOG_DBG((LOG_POLICY, 80, "local_filter_addr_upper == %s",
		    local_filter_addr_upper));
		LOG_DBG((LOG_POLICY, 80, "local_filter_addr_lower == %s",
		    local_filter_addr_lower));
		LOG_DBG((LOG_POLICY, 80, "local_filter == %s",
		    (local_filter ? local_filter : "")));
		LOG_DBG((LOG_POLICY, 80, "local_filter_port == %s",
		    local_filter_port));
		LOG_DBG((LOG_POLICY, 80, "local_filter_proto == %s",
		    local_filter_proto));
		LOG_DBG((LOG_POLICY, 80, "remote_id_type == %s",
		    remote_id_type));
		LOG_DBG((LOG_POLICY, 80, "remote_id_addr_upper == %s",
		    remote_id_addr_upper));
		LOG_DBG((LOG_POLICY, 80, "remote_id_addr_lower == %s",
		    remote_id_addr_lower));
		LOG_DBG((LOG_POLICY, 80, "remote_id == %s",
		    (remote_id ? remote_id : "")));
		LOG_DBG((LOG_POLICY, 80, "remote_id_port == %s",
		    remote_id_port));
		LOG_DBG((LOG_POLICY, 80, "remote_id_proto == %s",
		    remote_id_proto));
		LOG_DBG((LOG_POLICY, 80, "remote_negotiation_address == %s",
		    remote_ike_address));
		LOG_DBG((LOG_POLICY, 80, "local_negotiation_address == %s",
		    local_ike_address));
		LOG_DBG((LOG_POLICY, 80, "pfs == %s", pfs));
		LOG_DBG((LOG_POLICY, 80, "initiator == %s", initiator));
		LOG_DBG((LOG_POLICY, 80, "phase1_group_desc == %s",
		    phase1_group));

		/* Unset dirty now.  */
		dirty = 0;
	}
	if (strcmp(name, "phase_1") == 0)
		return phase_1;

	if (strcmp(name, "GMTTimeOfDay") == 0) {
		tt = time((time_t)NULL);
		strftime(mytimeofday, 14, "%Y%m%d%H%M%S", gmtime(&tt));
		return mytimeofday;
	}
	if (strcmp(name, "LocalTimeOfDay") == 0) {
		tt = time((time_t)NULL);
		strftime(mytimeofday, 14, "%Y%m%d%H%M%S", localtime(&tt));
		return mytimeofday;
	}
	if (strcmp(name, "initiator") == 0)
		return initiator;

	if (strcmp(name, "pfs") == 0)
		return pfs;

	if (strcmp(name, "app_domain") == 0)
		return "IPsec policy";

	if (strcmp(name, "doi") == 0)
		return "ipsec";

	if (strcmp(name, "esp_present") == 0)
		return esp_present;

	if (strcmp(name, "ah_present") == 0)
		return ah_present;

	if (strcmp(name, "comp_present") == 0)
		return comp_present;

	if (strcmp(name, "ah_hash_alg") == 0)
		return ah_hash_alg;

	if (strcmp(name, "ah_auth_alg") == 0)
		return ah_auth_alg;

	if (strcmp(name, "esp_auth_alg") == 0)
		return esp_auth_alg;

	if (strcmp(name, "esp_enc_alg") == 0)
		return esp_enc_alg;

	if (strcmp(name, "comp_alg") == 0)
		return comp_alg;

	if (strcmp(name, "ah_life_kbytes") == 0)
		return ah_life_kbytes;

	if (strcmp(name, "ah_life_seconds") == 0)
		return ah_life_seconds;

	if (strcmp(name, "esp_life_kbytes") == 0)
		return esp_life_kbytes;

	if (strcmp(name, "esp_life_seconds") == 0)
		return esp_life_seconds;

	if (strcmp(name, "comp_life_kbytes") == 0)
		return comp_life_kbytes;

	if (strcmp(name, "comp_life_seconds") == 0)
		return comp_life_seconds;

	if (strcmp(name, "ah_encapsulation") == 0)
		return ah_encapsulation;

	if (strcmp(name, "esp_encapsulation") == 0)
		return esp_encapsulation;

	if (strcmp(name, "comp_encapsulation") == 0)
		return comp_encapsulation;

	if (strcmp(name, "ah_key_length") == 0)
		return ah_key_length;

	if (strcmp(name, "ah_key_rounds") == 0)
		return ah_key_rounds;

	if (strcmp(name, "esp_key_length") == 0)
		return esp_key_length;

	if (strcmp(name, "esp_key_rounds") == 0)
		return esp_key_rounds;

	if (strcmp(name, "comp_dict_size") == 0)
		return comp_dict_size;

	if (strcmp(name, "comp_private_alg") == 0)
		return comp_private_alg;

	if (strcmp(name, "remote_filter_type") == 0)
		return remote_filter_type;

	if (strcmp(name, "remote_filter") == 0)
		return (remote_filter ? remote_filter : "");

	if (strcmp(name, "remote_filter_addr_upper") == 0)
		return remote_filter_addr_upper;

	if (strcmp(name, "remote_filter_addr_lower") == 0)
		return remote_filter_addr_lower;

	if (strcmp(name, "remote_filter_port") == 0)
		return remote_filter_port;

	if (strcmp(name, "remote_filter_proto") == 0)
		return remote_filter_proto;

	if (strcmp(name, "local_filter_type") == 0)
		return local_filter_type;

	if (strcmp(name, "local_filter") == 0)
		return (local_filter ? local_filter : "");

	if (strcmp(name, "local_filter_addr_upper") == 0)
		return local_filter_addr_upper;

	if (strcmp(name, "local_filter_addr_lower") == 0)
		return local_filter_addr_lower;

	if (strcmp(name, "local_filter_port") == 0)
		return local_filter_port;

	if (strcmp(name, "local_filter_proto") == 0)
		return local_filter_proto;

	if (strcmp(name, "remote_ike_address") == 0)
		return remote_ike_address;

	if (strcmp(name, "remote_negotiation_address") == 0)
		return remote_ike_address;

	if (strcmp(name, "local_ike_address") == 0)
		return local_ike_address;

	if (strcmp(name, "local_negotiation_address") == 0)
		return local_ike_address;

	if (strcmp(name, "remote_id_type") == 0)
		return remote_id_type;

	if (strcmp(name, "remote_id") == 0)
		return (remote_id ? remote_id : "");

	if (strcmp(name, "remote_id_addr_upper") == 0)
		return remote_id_addr_upper;

	if (strcmp(name, "remote_id_addr_lower") == 0)
		return remote_id_addr_lower;

	if (strcmp(name, "remote_id_port") == 0)
		return remote_id_port;

	if (strcmp(name, "remote_id_proto") == 0)
		return remote_id_proto;

	if (strcmp(name, "phase1_group_desc") == 0)
		return phase1_group;

	if (strcmp(name, "esp_group_desc") == 0)
		return esp_group_desc;

	if (strcmp(name, "ah_group_desc") == 0)
		return ah_group_desc;

	if (strcmp(name, "comp_group_desc") == 0)
		return comp_group_desc;

	if (strcmp(name, "comp_ecn") == 0)
		return comp_ecn;

	if (strcmp(name, "ah_ecn") == 0)
		return ah_ecn;

	if (strcmp(name, "esp_ecn") == 0)
		return esp_ecn;

	return "";

bad:
	policy_callback(KEYNOTE_CALLBACK_INITIALIZE);
	return "";
}

void
policy_init(void)
{
	char           *ptr, *policy_file;
	char          **asserts;
	size_t          sz, len;
	int             fd, i;

	LOG_DBG((LOG_POLICY, 30, "policy_init: initializing"));

	/* Do we want to use the policy modules?  */
	if (ignore_policy ||
	    strncmp("yes", conf_get_str("General", "Use-Keynote"), 3))
		return;

	/* Get policy file from configuration.  */
	policy_file = conf_get_str("General", "Policy-file");
	if (!policy_file)
		policy_file = CONF_DFLT_POLICY_FILE;

	/* Open policy file.  */
	fd = monitor_open(policy_file, O_RDONLY, 0);
	if (fd == -1)
		log_fatal("policy_init: open (\"%s\", O_RDONLY) failed",
		    policy_file);

	/* Check file modes and collect file size */
	if (check_file_secrecy_fd(fd, policy_file, &sz)) {
		close(fd);
		log_fatal("policy_init: cannot read %s", policy_file);
	}

	/* Allocate memory to keep policies.  */
	ptr = calloc(sz + 1, sizeof(char));
	if (!ptr)
		log_fatal("policy_init: calloc (%lu, %lu) failed",
		    (unsigned long)sz + 1, (unsigned long)sizeof(char));

	/* Just in case there are short reads...  */
	for (len = 0; len < sz; len += i) {
		i = read(fd, ptr + len, sz - len);
		if (i == -1)
			log_fatal("policy_init: read (%d, %p, %lu) failed", fd,
			    ptr + len, (unsigned long)(sz - len));
	}

	/* We're done with this.  */
	close(fd);

	/* Parse buffer, break up into individual policies.  */
	asserts = kn_read_asserts(ptr, sz, &i);

	/* Begone!  */
	free(ptr);

	if (asserts == (char **)NULL)
		log_print("policy_init: all policies flushed");

	/* Cleanup */
	if (policy_asserts) {
		for (fd = 0; fd < policy_asserts_num; fd++)
			if (policy_asserts && policy_asserts[fd])
				free(policy_asserts[fd]);

		free(policy_asserts);
	}
	policy_asserts = asserts;
	policy_asserts_num = i;
}

/* Nothing needed for initialization */
int
keynote_cert_init(void)
{
	return 1;
}

/* Just copy and return.  */
void           *
keynote_cert_get(u_int8_t *data, u_int32_t len)
{
	char	*foo = malloc(len + 1);

	if (foo == NULL)
		return NULL;

	memcpy(foo, data, len);
	foo[len] = '\0';
	return foo;
}

/*
 * We just verify the signature on the credentials.
 * On signature failure, just drop the whole payload.
 */
int
keynote_cert_validate(void *scert)
{
	char	**foo;
	int	  num, i;

	if (scert == NULL)
		return 0;

	foo = kn_read_asserts((char *)scert, strlen((char *)scert), &num);
	if (foo == NULL)
		return 0;

	for (i = 0; i < num; i++) {
		if (kn_verify_assertion(scert, strlen((char *)scert))
		    != SIGRESULT_TRUE) {
			for (; i < num; i++)
				free(foo[i]);
			free(foo);
			return 0;
		}
		free(foo[i]);
	}

	free(foo);
	return 1;
}

/* Add received credentials.  */
int
keynote_cert_insert(int sid, void *scert)
{
	char	**foo;
	int	  num;

	if (scert == NULL)
		return 0;

	foo = kn_read_asserts((char *)scert, strlen((char *)scert), &num);
	if (foo == NULL)
		return 0;

	while (num--)
		kn_add_assertion(sid, foo[num], strlen(foo[num]), 0);

	return 1;
}

/* Just regular memory free.  */
void
keynote_cert_free(void *cert)
{
	free(cert);
}

/* Verify that the key given to us is valid.  */
int
keynote_certreq_validate(u_int8_t *data, u_int32_t len)
{
	struct keynote_deckey dc;
	int	 err = 1;
	char	*dat;

	dat = calloc(len + 1, sizeof(char));
	if (!dat) {
		log_error("keynote_certreq_validate: calloc (%d, %lu) failed",
		    len + 1, (unsigned long)sizeof(char));
		return 0;
	}
	memcpy(dat, data, len);

	if (kn_decode_key(&dc, dat, KEYNOTE_PUBLIC_KEY) != 0)
		err = 0;
	else
		kn_free_key(&dc);

	free(dat);

	return err;
}

/* Beats me what we should be doing with this.  */
void *
keynote_certreq_decode(u_int8_t *data, u_int32_t len)
{
	/* XXX */
	return NULL;
}

void
keynote_free_aca(void *blob)
{
	/* XXX */
}

int
keynote_cert_obtain(u_int8_t *id, size_t id_len, void *data, u_int8_t **cert,
    u_int32_t *certlen)
{
	char           *dirname, *file, *addr_str;
	struct stat     sb;
	size_t          size;
	int             idtype, fd, len;

	if (!id) {
		log_print("keynote_cert_obtain: ID is missing");
		return 0;
	}
	/* Get type of ID.  */
	idtype = id[0];
	id += ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
	id_len -= ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;

	dirname = conf_get_str("KeyNote", "Credential-directory");
	if (!dirname) {
		LOG_DBG((LOG_POLICY, 30,
			 "keynote_cert_obtain: no Credential-directory"));
		return 0;
	}
	len = strlen(dirname) + strlen(CREDENTIAL_FILE) + 3;

	switch (idtype) {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR:
		util_ntoa(&addr_str, idtype == IPSEC_ID_IPV4_ADDR ?
		    AF_INET : AF_INET6, id);
		if (addr_str == 0)
			return 0;

		file = calloc(len + strlen(addr_str), sizeof(char));
		if (file == NULL) {
			log_error("keynote_cert_obtain: failed to allocate "
			    "%lu bytes", (unsigned long)len +
			    strlen(addr_str));
			free(addr_str);
			return 0;
		}
		snprintf(file, len + strlen(addr_str), "%s/%s/%s", dirname,
		    addr_str, CREDENTIAL_FILE);
		free(addr_str);
		break;

	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN: {
			file = calloc(len + id_len, sizeof(char));
			if (file == NULL) {
				log_error("keynote_cert_obtain: "
				    "failed to allocate %lu bytes",
				    (unsigned long)len + id_len);
				return 0;
			}
			snprintf(file, len + id_len, "%s/", dirname);
			memcpy(file + strlen(dirname) + 1, id, id_len);
			snprintf(file + strlen(dirname) + 1 + id_len,
			    len - strlen(dirname) - 1, "/%s", CREDENTIAL_FILE);
			break;
		}

	default:
		return 0;
	}

	fd = monitor_open(file, O_RDONLY, 0);
	if (fd < 0) {
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: "
		    "failed to open \"%s\"", file));
		free(file);
		return 0;
	}

	if (fstat(fd, &sb) < 0) {
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: "
		    "failed to stat \"%s\"", file));
		free(file);
		close(fd);
		return 0;
	}
	size = (size_t)sb.st_size;

	*cert = calloc(size + 1, sizeof(char));
	if (*cert == NULL) {
		log_error("keynote_cert_obtain: failed to allocate %lu bytes",
		    (unsigned long)size);
		free(file);
		return 0;
	}

	if (read(fd, *cert, size) != (int)size) {
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: "
		    "failed to read %lu bytes from \"%s\"",
		    (unsigned long)size, file));
		free(file);
		close(fd);
		return 0;
	}
	close(fd);
	free(file);
	*certlen = size;
	return 1;
}

/* This should never be called.  */
int
keynote_cert_get_subjects(void *scert, int *n, u_int8_t ***id,
    u_int32_t **id_len)
{
	return 0;
}

/* Get the authorizer key.  */
int
keynote_cert_get_key(void *scert, void *keyp)
{
	struct keynote_keylist *kl;
	int             sid, kid, num;
	char          **foo;

	foo = kn_read_asserts((char *)scert, strlen((char *)scert), &num);
	if (foo == NULL || num == 0) {
		log_print("keynote_cert_get_key: "
		    "failed to decompose credentials");
		return 0;
	}
	kid = kn_init();
	if (kid == -1) {
		log_print("keynote_cert_get_key: "
		    "failed to initialize new policy session");
		while (num--)
			free(foo[num]);
		free(foo);
		return 0;
	}
	sid = kn_add_assertion(kid, foo[num - 1], strlen(foo[num - 1]), 0);
	while (num--)
		free(foo[num]);
	free(foo);

	if (sid == -1) {
		log_print("keynote_cert_get_key: failed to add assertion");
		kn_close(kid);
		return 0;
	}
	*(RSA **)keyp = NULL;

	kl = kn_get_licensees(kid, sid);
	while (kl) {
		if (kl->key_alg == KEYNOTE_ALGORITHM_RSA ||
		    kl->key_alg == KEYNOTE_ALGORITHM_X509) {
			*(RSA **)keyp = RSAPublicKey_dup(kl->key_key);
			break;
		}
		kl = kl->key_next;
	}

	kn_remove_assertion(kid, sid);
	kn_close(kid);
	return *(RSA **)keyp == NULL ? 0 : 1;
}

void *
keynote_cert_dup(void *cert)
{
	return strdup((char *)cert);
}

void
keynote_serialize(void *cert, u_int8_t **data, u_int32_t *datalen)
{
	*datalen = strlen((char *)cert) + 1;
	*data = (u_int8_t *)strdup(cert);	/* i.e an extra character at
						 * the end... */
	if (*data == NULL)
		log_error("keynote_serialize: malloc (%d) failed", *datalen);
}

/* From cert to printable */
char *
keynote_printable(void *cert)
{
	return strdup((char *)cert);
}

/* From printable to cert */
void *
keynote_from_printable(char *cert)
{
	return strdup(cert);
}
@


1.3
log
@Last piece of OpenBSD 3.5-current merge part I.

Things left:
* merge import in src/gnu/
* fix kernel build (it _is_ broken)

TOP 1 will be done with a _second_ import (easier).
TOP 2 will be done RSN.

----

Also, move RCS IDs to new-style MirOS ones, and fix the
SMM doc, and add output to newfs(8) saying if (!) or if
not (?) it read the random value out of the previous
superblock before making the fs.
@
text
@d1 2
a2 2
/* $MirBSD$ */
/* $OpenBSD: policy.c,v 1.71 2004/04/28 20:20:31 hshoexer Exp $	 */
d69 1
a69 1
__RCSID("$MirBSD$");
d72 1
d87 1
a87 1
my_inet_ntop4(const in_addr_t * src, char *dst, size_t size, int normalize)
d113 1
a113 1
	char            tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"];
d115 2
a116 2
	if (snprintf(tmp, sizeof tmp, fmt, src[0], src[1], src[2], src[3], src[4],
	    src[5], src[6], src[7], src[8], src[9], src[10], src[11],
d151 6
a156 4
	static char     comp_life_seconds[PMAX], *ah_encapsulation, *esp_encapsulation;
	static char    *comp_encapsulation, ah_key_length[PMAX], esp_key_length[PMAX];
	static char     ah_key_rounds[PMAX], esp_key_rounds[PMAX], comp_dict_size[PMAX];
	static char     comp_private_alg[PMAX], *remote_filter_type, *local_filter_type;
d161 2
a162 2
	static char     ah_group_desc[PMAX], esp_group_desc[PMAX], comp_group_desc[PMAX];
	static char     remote_ike_address[NI_MAXHOST];
d164 2
a165 3
	static char    *remote_id_type, remote_id_addr_upper[NI_MAXHOST],
	               *phase_1;
	static char     remote_id_addr_lower[NI_MAXHOST];
d168 3
a170 4
	static char    *remote_filter_proto, *local_filter_proto, *pfs,
	               *initiator;
	static char     remote_filter_proto_num[3], local_filter_proto_num[3];
	static char     remote_id_proto_num[3];
d185 2
a186 1
		esp_encapsulation = comp_encapsulation = remote_filter_type = "";
d188 2
a189 1
		remote_filter_proto = local_filter_proto = remote_id_proto = "";
d217 8
a224 4
		memset(remote_filter_addr_upper, 0, sizeof remote_filter_addr_upper);
		memset(remote_filter_addr_lower, 0, sizeof remote_filter_addr_lower);
		memset(local_filter_addr_upper, 0, sizeof local_filter_addr_upper);
		memset(local_filter_addr_lower, 0, sizeof local_filter_addr_lower);
d248 2
a249 1
		snprintf(phase1_group, sizeof phase1_group, "%u", is->group_desc);
d366 2
a367 1
			for (attr = proto->chosen->p + ISAKMP_TRANSFORM_SA_ATTRS_OFF;
d379 2
a380 1
				value = attr + (fmt ? ISAKMP_ATTR_LENGTH_VALUE_OFF :
d515 17
d671 2
a672 1
		policy_sa->transport->vtbl->get_src(policy_sa->transport, &sin);
d680 2
a681 1
		policy_sa->transport->vtbl->get_dst(policy_sa->transport, &sin);
d711 2
a712 1
			net = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
d719 2
a720 1
				log_error("policy_callback: strdup (\"%s\") failed",
d729 2
a730 1
			net = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
d733 2
a734 1
			net = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 4);
d741 3
a743 2
				log_error("policy_callback: calloc (%d, %lu) failed",
				    len, (unsigned long)sizeof(char));
d754 4
a757 2
			net = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
			subnet = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 4);
d768 3
a770 2
				log_error("policy_callback: calloc (%d, %lu) failed",
				    len, (unsigned long)sizeof(char));
d786 2
a787 1
				log_error("policy_callback: strdup (\"%s\") failed",
d800 2
a801 2
			my_inet_ntop6(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 16,
			    remote_id_addr_upper,
d808 3
a810 2
				log_error("policy_callback: calloc (%d, %lu) failed",
				    len, (unsigned long)sizeof(char));
d826 2
a827 1
			memmove(&mask, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 16,
d833 2
a834 1
			my_inet_ntop6((unsigned char *)&net, remote_id_addr_lower,
d840 2
a841 1
			my_inet_ntop6((unsigned char *)&net, remote_id_addr_upper,
d848 3
a850 2
				log_error("policy_callback: calloc (%d, %lu) failed",
				    len, (unsigned long)sizeof(char));
d864 2
a865 1
				log_error("policy_callback: calloc (%lu, %lu) failed",
d871 2
a872 1
			memcpy(remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
d881 2
a882 1
				log_error("policy_callback: calloc (%lu, %lu) failed",
d888 2
a889 1
			memcpy(remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
d915 2
a916 1
				log_error("policy_callback: calloc (%lu, %lu) failed",
d918 1
a918 1
				    ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1,
d923 3
a925 1
			for (i = 0; i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ; i++)
d932 2
a933 1
				    id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
d938 2
a939 1
			    i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ; i++) {
d948 2
a949 1
			log_print("policy_callback: unknown remote ID type %u", id[0]);
d969 2
a970 1
			snprintf(remote_id_proto_num, sizeof remote_id_proto_num, "%d",
d1004 2
a1005 1
				remote_filter = strdup(remote_filter_addr_upper);
d1020 2
a1021 1
				net = decode_32(idremote + ISAKMP_ID_DATA_OFF + 4);
d1033 2
a1034 1
				strlcpy(remote_filter, remote_filter_addr_lower, len);
d1036 2
a1037 1
				strlcat(remote_filter, remote_filter_addr_upper, len);
d1044 2
a1045 1
				subnet = decode_32(idremote + ISAKMP_ID_DATA_OFF + 4);
d1061 2
a1062 1
				strlcpy(remote_filter, remote_filter_addr_lower, len);
d1064 2
a1065 1
				strlcat(remote_filter, remote_filter_addr_upper, len);
d1076 2
a1077 1
				remote_filter = strdup(remote_filter_addr_upper);
d1093 2
a1094 2
				my_inet_ntop6(idremote + ISAKMP_ID_DATA_OFF + 16,
				    remote_filter_addr_upper,
d1106 2
a1107 1
				strlcpy(remote_filter, remote_filter_addr_lower, len);
d1109 2
a1110 1
				strlcat(remote_filter, remote_filter_addr_upper, len);
d1119 6
a1124 2
					memmove(&net, idremote + ISAKMP_ID_DATA_OFF, sizeof(net));
					memmove(&mask, idremote + ISAKMP_ID_DATA_OFF + 16, sizeof(mask));
d1127 2
a1128 1
						net.s6_addr[i] &= mask.s6_addr[i];
d1130 2
a1131 1
					my_inet_ntop6((unsigned char *)&net, remote_filter_addr_lower,
d1135 2
a1136 1
						net.s6_addr[i] |= ~mask.s6_addr[i];
d1138 2
a1139 1
					my_inet_ntop6((unsigned char *)&net, remote_filter_addr_upper,
d1144 2
a1145 1
					remote_filter = calloc(len, sizeof(char));
d1147 4
a1150 2
						log_error("policy_callback: calloc (%d, %lu) failed", len,
							  (unsigned long)sizeof(char));
d1153 2
a1154 1
					strlcpy(remote_filter, remote_filter_addr_lower, len);
d1156 2
a1157 1
					strlcat(remote_filter, remote_filter_addr_upper, len);
d1163 2
a1164 1
				remote_filter = malloc(idremotesz - ISAKMP_ID_DATA_OFF + 1);
d1166 4
a1169 2
					log_error("policy_callback: malloc (%lu) failed",
						  (unsigned long)idremotesz - ISAKMP_ID_DATA_OFF + 1);
d1172 5
a1176 3
				memcpy(remote_filter, idremote + ISAKMP_ID_DATA_OFF,
				       idremotesz - ISAKMP_ID_DATA_OFF);
				remote_filter[idremotesz - ISAKMP_ID_DATA_OFF] = '\0';
d1181 2
a1182 1
				remote_filter = malloc(idremotesz - ISAKMP_ID_DATA_OFF + 1);
d1184 4
a1187 2
					log_error("policy_callback: malloc (%lu) failed",
						  (unsigned long)idremotesz - ISAKMP_ID_DATA_OFF + 1);
d1190 5
a1194 3
				memcpy(remote_filter, idremote + ISAKMP_ID_DATA_OFF,
				       idremotesz - ISAKMP_ID_DATA_OFF);
				remote_filter[idremotesz - ISAKMP_ID_DATA_OFF] = '\0';
d1200 3
a1202 2
				remote_filter = x509_DN_string(idremote + ISAKMP_ID_DATA_OFF,
					   idremotesz - ISAKMP_ID_DATA_OFF);
d1205 2
a1206 1
						 "policy_callback: failed to decode name"));
d1219 3
a1221 2
					= calloc(2 * (idremotesz - ISAKMP_ID_DATA_OFF) + 1,
						 sizeof(char));
d1223 5
a1227 3
					log_error("policy_callback: calloc (%lu, %lu) failed",
						  2 * ((unsigned long)idremotesz - ISAKMP_ID_DATA_OFF) + 1,
					      (unsigned long)sizeof(char));
d1234 4
a1237 2
				for (i = 0; i < idremotesz - ISAKMP_ID_DATA_OFF; i++)
					if (!isprint(*(idremote + ISAKMP_ID_DATA_OFF + i)))
d1240 3
a1242 2
					memcpy(remote_filter, idremote + ISAKMP_ID_DATA_OFF,
					   idremotesz - ISAKMP_ID_DATA_OFF);
d1246 3
a1248 1
				for (i = 0; i < idremotesz - ISAKMP_ID_DATA_OFF; i++) {
d1250 2
a1251 1
						= hextab[*(idremote + ISAKMP_ID_DATA_OFF) >> 4];
d1253 2
a1254 1
						= hextab[*(idremote + ISAKMP_ID_DATA_OFF) & 0xF];
d1259 3
a1261 2
				log_print("policy_callback: unknown Remote ID type %u",
					  GET_ISAKMP_ID_TYPE(idremote));
d1282 2
a1283 2
				       sizeof remote_filter_proto_num, "%d",
					 idremote[ISAKMP_GEN_SZ + 1]);
d1288 2
a1289 2
			snprintf(remote_filter_port, sizeof remote_filter_port, "%u",
				 decode_16(idremote + ISAKMP_GEN_SZ + 2));
d1300 3
a1302 2
				log_print("policy_callback: unsupported protocol family %d",
					  sin->sa_family);
d1306 2
a1307 1
				log_error("policy_callback: sockaddr2text failed");
d1317 3
a1319 2
				log_error("policy_callback: strdup (\"%s\") failed",
					  remote_filter_addr_upper);
d1336 3
a1338 2
					log_error("policy_callback: strdup (\"%s\") failed",
						  local_filter_addr_upper);
d1349 2
a1350 1
				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF + 4);
d1357 3
a1359 2
					log_error("policy_callback: calloc (%d, %lu) failed", len,
					      (unsigned long)sizeof(char));
d1362 2
a1363 1
				strlcpy(local_filter, local_filter_addr_lower, len);
d1365 2
a1366 1
				strlcat(local_filter, local_filter_addr_upper, len);
d1373 2
a1374 1
				subnet = decode_32(idlocal + ISAKMP_ID_DATA_OFF + 4);
d1385 3
a1387 2
					log_error("policy_callback: calloc (%d, %lu) failed", len,
					      (unsigned long)sizeof(char));
d1390 2
a1391 1
				strlcpy(local_filter, local_filter_addr_lower, len);
d1393 2
a1394 1
				strlcat(local_filter, local_filter_addr_upper, len);
d1402 3
a1404 2
				strlcpy(local_filter_addr_lower, local_filter_addr_upper,
					sizeof local_filter_addr_lower);
d1407 3
a1409 2
					log_error("policy_callback: strdup (\"%s\") failed",
						  local_filter_addr_upper);
d1421 3
a1423 3
				my_inet_ntop6(idlocal + ISAKMP_ID_DATA_OFF + 16,
					      local_filter_addr_upper,
					sizeof local_filter_addr_upper - 1);
d1429 3
a1431 2
					log_error("policy_callback: calloc (%d, %lu) failed", len,
					      (unsigned long)sizeof(char));
d1434 2
a1435 1
				strlcpy(local_filter, local_filter_addr_lower, len);
d1437 2
a1438 1
				strlcat(local_filter, local_filter_addr_upper, len);
d1447 6
a1452 2
					memmove(&net, idlocal + ISAKMP_ID_DATA_OFF, sizeof(net));
					memmove(&mask, idlocal + ISAKMP_ID_DATA_OFF + 16, sizeof(mask));
d1455 2
a1456 1
						net.s6_addr[i] &= mask.s6_addr[i];
d1458 2
a1459 1
					my_inet_ntop6((unsigned char *)&net, local_filter_addr_lower,
d1463 2
a1464 1
						net.s6_addr[i] |= ~mask.s6_addr[i];
d1466 4
a1469 2
					my_inet_ntop6((unsigned char *)&net, local_filter_addr_upper,
					sizeof local_filter_addr_upper - 1);
d1472 4
a1475 2
						+ strlen(local_filter_addr_lower) + 2;
					local_filter = calloc(len, sizeof(char));
d1477 4
a1480 2
						log_error("policy_callback: calloc (%d, %lu) failed", len,
							  (unsigned long)sizeof(char));
d1483 2
a1484 1
					strlcpy(local_filter, local_filter_addr_lower, len);
d1486 2
a1487 1
					strlcat(local_filter, local_filter_addr_upper, len);
d1493 2
a1494 1
				local_filter = malloc(idlocalsz - ISAKMP_ID_DATA_OFF + 1);
d1496 4
a1499 2
					log_error("policy_callback: malloc (%lu) failed",
						  (unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF + 1);
d1502 5
a1506 3
				memcpy(local_filter, idlocal + ISAKMP_ID_DATA_OFF,
				       idlocalsz - ISAKMP_ID_DATA_OFF);
				local_filter[idlocalsz - ISAKMP_ID_DATA_OFF] = '\0';
d1511 2
a1512 1
				local_filter = malloc(idlocalsz - ISAKMP_ID_DATA_OFF + 1);
d1514 4
a1517 2
					log_error("policy_callback: malloc (%lu) failed",
						  (unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF + 1);
d1520 5
a1524 3
				memcpy(local_filter, idlocal + ISAKMP_ID_DATA_OFF,
				       idlocalsz - ISAKMP_ID_DATA_OFF);
				local_filter[idlocalsz - ISAKMP_ID_DATA_OFF] = '\0';
d1530 3
a1532 2
				local_filter = x509_DN_string(idlocal + ISAKMP_ID_DATA_OFF,
					    idlocalsz - ISAKMP_ID_DATA_OFF);
d1535 2
a1536 1
						 "policy_callback: failed to decode name"));
d1548 3
a1550 2
				local_filter = calloc(2 * (idlocalsz - ISAKMP_ID_DATA_OFF) + 1,
						      sizeof(char));
d1552 5
a1556 3
					log_error("policy_callback: calloc (%lu, %lu) failed",
						  2 * ((unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF) + 1,
					      (unsigned long)sizeof(char));
d1563 4
a1566 2
				for (i = 0; i < idlocalsz - ISAKMP_ID_DATA_OFF; i++)
					if (!isprint(*(idlocal + ISAKMP_ID_DATA_OFF + i)))
d1569 2
a1570 1
					memcpy(local_filter, idlocal + ISAKMP_ID_DATA_OFF,
d1575 2
a1576 1
				for (i = 0; i < idlocalsz - ISAKMP_ID_DATA_OFF; i++) {
d1578 2
a1579 1
						= hextab[*(idlocal + ISAKMP_ID_DATA_OFF) >> 4];
d1581 2
a1582 1
						= hextab[*(idlocal + ISAKMP_ID_DATA_OFF) & 0xF];
d1587 3
a1589 2
				log_print("policy_callback: unknown Local ID type %u",
					  GET_ISAKMP_ID_TYPE(idlocal));
d1609 3
a1611 2
				snprintf(local_filter_proto_num, sizeof local_filter_proto_num,
					 "%d", idlocal[ISAKMP_GEN_SZ + 1]);
d1616 2
a1617 2
			snprintf(local_filter_port, sizeof local_filter_port, "%u",
				 decode_16(idlocal + ISAKMP_GEN_SZ + 2));
d1620 1
a1620 1
						(struct sockaddr **)&sin);
d1629 3
a1631 2
				log_print("policy_callback: unsupported protocol family %d",
					  sin->sa_family);
d1636 2
a1637 1
				log_error("policy_callback: sockaddr2text failed");
d1641 1
a1641 1
			       sizeof local_filter_addr_upper);
d1643 1
a1643 1
			       sizeof local_filter_addr_lower);
d1647 3
a1649 2
				log_error("policy_callback: strdup (\"%s\") failed",
					  local_filter_addr_upper);
d1654 2
a1655 1
		LOG_DBG((LOG_POLICY, 80, "Policy context (action attributes):"));
d1664 16
a1679 8
		LOG_DBG((LOG_POLICY, 80, "ah_life_seconds == %s", ah_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "ah_life_kbytes == %s", ah_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "esp_life_seconds == %s", esp_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "esp_life_kbytes == %s", esp_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "comp_life_seconds == %s", comp_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "comp_life_kbytes == %s", comp_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "ah_encapsulation == %s", ah_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "esp_encapsulation == %s", esp_encapsulation));
d1681 19
a1699 10
			 comp_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "comp_dict_size == %s", comp_dict_size));
		LOG_DBG((LOG_POLICY, 80, "comp_private_alg == %s", comp_private_alg));
		LOG_DBG((LOG_POLICY, 80, "ah_key_length == %s", ah_key_length));
		LOG_DBG((LOG_POLICY, 80, "ah_key_rounds == %s", ah_key_rounds));
		LOG_DBG((LOG_POLICY, 80, "esp_key_length == %s", esp_key_length));
		LOG_DBG((LOG_POLICY, 80, "esp_key_rounds == %s", esp_key_rounds));
		LOG_DBG((LOG_POLICY, 80, "ah_group_desc == %s", ah_group_desc));
		LOG_DBG((LOG_POLICY, 80, "esp_group_desc == %s", esp_group_desc));
		LOG_DBG((LOG_POLICY, 80, "comp_group_desc == %s", comp_group_desc));
d1704 1
a1704 1
			 remote_filter_type));
d1706 1
a1706 1
			 remote_filter_addr_upper));
d1708 1
a1708 1
			 remote_filter_addr_lower));
d1710 1
a1710 1
			 (remote_filter ? remote_filter : "")));
d1712 1
a1712 1
			 remote_filter_port));
d1714 3
a1716 2
			 remote_filter_proto));
		LOG_DBG((LOG_POLICY, 80, "local_filter_type == %s", local_filter_type));
d1718 1
a1718 1
			 local_filter_addr_upper));
d1720 1
a1720 1
			 local_filter_addr_lower));
d1722 3
a1724 2
			 (local_filter ? local_filter : "")));
		LOG_DBG((LOG_POLICY, 80, "local_filter_port == %s", local_filter_port));
d1726 3
a1728 2
			 local_filter_proto));
		LOG_DBG((LOG_POLICY, 80, "remote_id_type == %s", remote_id_type));
d1730 1
a1730 1
			 remote_id_addr_upper));
d1732 1
a1732 1
			 remote_id_addr_lower));
d1734 5
a1738 3
			 (remote_id ? remote_id : "")));
		LOG_DBG((LOG_POLICY, 80, "remote_id_port == %s", remote_id_port));
		LOG_DBG((LOG_POLICY, 80, "remote_id_proto == %s", remote_id_proto));
d1740 1
a1740 1
			 remote_ike_address));
d1742 1
a1742 1
			 local_ike_address));
d1745 2
a1746 1
		LOG_DBG((LOG_POLICY, 80, "phase1_group_desc == %s", phase1_group));
d1949 5
a1958 4
	/* Check file modes and collect file size */
	if (check_file_secrecy(policy_file, &sz))
		log_fatal("policy_init: cannot read %s", policy_file);

d1962 8
a1969 1
		log_fatal("policy_init: open (\"%s\", O_RDONLY) failed", policy_file);
d1974 2
a1975 2
		log_fatal("policy_init: calloc (%lu, %lu) failed", (unsigned long)sz + 1,
			  (unsigned long)sizeof(char));
d1981 2
a1982 2
			log_fatal("policy_init: read (%d, %p, %lu) failed", fd, ptr + len,
				  (unsigned long)(sz - len));
d2018 1
a2018 1
keynote_cert_get(u_int8_t * data, u_int32_t len)
d2020 1
a2020 1
	char           *foo = malloc(len + 1);
d2037 2
a2038 2
	char          **foo;
	int             num, i;
d2066 2
a2067 2
	char          **foo;
	int             num;
d2091 1
a2091 1
keynote_certreq_validate(u_int8_t * data, u_int32_t len)
d2094 2
a2095 2
	int             err = 1;
	char           *dat;
d2099 2
a2100 2
		log_error("keynote_certreq_validate: calloc (%d, %lu) failed", len + 1,
			  (unsigned long)sizeof(char));
d2116 2
a2117 2
void           *
keynote_certreq_decode(u_int8_t * data, u_int32_t len)
d2130 2
a2131 2
keynote_cert_obtain(u_int8_t * id, size_t id_len, void *data, u_int8_t ** cert,
		    u_int32_t * certlen)
d2158 2
a2159 2
		util_ntoa(&addr_str, idtype == IPSEC_ID_IPV4_ADDR ? AF_INET : AF_INET6,
			  id);
d2165 3
a2167 2
			log_error("keynote_cert_obtain: failed to allocate %lu bytes",
				  (unsigned long)len + strlen(addr_str));
d2171 2
a2172 2
		snprintf(file, len + strlen(addr_str), "%s/%s/%s", dirname, addr_str,
		    CREDENTIAL_FILE);
d2177 1
a2177 2
	case IPSEC_ID_USER_FQDN:
		{
d2180 2
a2181 1
				log_error("keynote_cert_obtain: failed to allocate %lu bytes",
d2196 4
a2199 3
	if (monitor_stat(file, &sb) < 0) {
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: failed to stat \"%s\"",
		    file));
d2203 8
d2220 1
a2220 7
	fd = monitor_open(file, O_RDONLY, 0);
	if (fd < 0) {
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: failed to open \"%s\"",
		    file));
		free(file);
		return 0;
	}
d2222 3
a2224 2
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: failed to read %lu "
		    "bytes from \"%s\"", (unsigned long)size, file));
d2253 2
a2254 1
		log_print("keynote_cert_get_key: failed to decompose credentials");
d2259 2
a2260 2
		log_print("keynote_cert_get_key: failed to initialize new policy "
		    "session");
d2280 2
a2281 1
		if (kl->key_alg == KEYNOTE_ALGORITHM_RSA) {
@


1.2
log
@Jumbo patch from wbx@@ to replace the
bcopy(3), bcmp(3) and bzero(3) func-
tions, having been deprecated earli-
er, by their ISO counterparts, name-
ly memmove(3) and the gcc3-optimized
memcmp(3) and memset(3) functions.

I didn't read every single line (be-
cause of the time of day), but looks
fine and builds through. I just nee-
ded to nuke three cases of whitespa-
ce at EOL. Good work wbx@@.

I've also sprinkled in a few patches
of mine addressing the issue that in
some kernel header files, bcopy() is
used as well... also there have been
quite some string cleaning fixes and
a missing header.
@
text
@d1 3
a3 2
/*	$OpenBSD: policy.c,v 1.67 2003/11/06 16:12:08 ho Exp $	*/
/*	$EOM: policy.c,v 1.49 2000/10/24 13:33:39 niklas Exp $ */
a34 1
#include <sys/types.h>
d69 4
a72 2
char **keynote_policy_asserts = NULL;
int keynote_policy_asserts_num = 0;
d74 2
a75 2
struct sa *policy_sa = 0;
struct sa *policy_isakmp_sa = 0;
d78 2
a79 2
  '0', '1', '2', '3', '4', '5', '6', '7',
  '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
d86 1
a86 1
my_inet_ntop4 (const in_addr_t *src, char *dst, size_t size, int normalize)
d88 17
a104 18
  static const char fmt[] = "%03u.%03u.%03u.%03u";
  char tmp[sizeof "255.255.255.255"];
  in_addr_t src2;

  if (normalize)
    src2 = ntohl (*src);
  else
    src2 = *src;

  if (snprintf (tmp, sizeof tmp, fmt, ((u_int8_t *) &src2)[0],
		((u_int8_t *) &src2)[1], ((u_int8_t *) &src2)[2],
		((u_int8_t *) &src2)[3]) > size)
    {
      errno = ENOSPC;
      return 0;
    }
  strlcpy (dst, tmp, size);
  return dst;
d108 1
a108 1
my_inet_ntop6 (const unsigned char *src, char *dst, size_t size)
d110 12
a121 12
  static const char fmt[] = "%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x";
  char tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"];

  if (snprintf (tmp, sizeof tmp, fmt, src[0], src[1], src[2], src[3], src[4],
		src[5], src[6], src[7], src[8], src[9], src[10], src[11],
		src[12], src[13], src[14], src[15]) > size)
    {
      errno = ENOSPC;
      return 0;
    }
  strlcpy (dst, tmp, size);
  return dst;
d125 1
a125 1
policy_callback (char *name)
d127 1
a127 1
  struct proto *proto;
d129 12
a140 11
  u_int8_t *attr, *value, *id, *idlocal, *idremote;
  size_t id_sz, idlocalsz, idremotesz;
  struct sockaddr *sin;
  struct ipsec_exch *ie;
  struct ipsec_sa *is;
  int fmt, i, lifetype = 0;
  in_addr_t net, subnet;
  u_int16_t len, type;
  time_t tt;
  char *addr;
  static char mytimeofday[15];
d142 1
a142 1
  /* We use all these as a cache.  */
d144 210
a353 143
  static char *esp_present, *ah_present, *comp_present;
  static char *ah_hash_alg, *ah_auth_alg, *esp_auth_alg, *esp_enc_alg;
  static char *comp_alg, ah_life_kbytes[PMAX], ah_life_seconds[PMAX];
  static char esp_life_kbytes[PMAX], esp_life_seconds[PMAX];
  static char comp_life_kbytes[PMAX];
  static char *ah_ecn, *esp_ecn, *comp_ecn;
  static char comp_life_seconds[PMAX], *ah_encapsulation, *esp_encapsulation;
  static char *comp_encapsulation, ah_key_length[PMAX], esp_key_length[PMAX];
  static char ah_key_rounds[PMAX], esp_key_rounds[PMAX], comp_dict_size[PMAX];
  static char comp_private_alg[PMAX], *remote_filter_type, *local_filter_type;
  static char remote_filter_addr_upper[NI_MAXHOST];
  static char remote_filter_addr_lower[NI_MAXHOST];
  static char local_filter_addr_upper[NI_MAXHOST];
  static char local_filter_addr_lower[NI_MAXHOST];
  static char ah_group_desc[PMAX], esp_group_desc[PMAX], comp_group_desc[PMAX];
  static char remote_ike_address[NI_MAXHOST];
  static char local_ike_address[NI_MAXHOST];
  static char *remote_id_type, remote_id_addr_upper[NI_MAXHOST], *phase_1;
  static char remote_id_addr_lower[NI_MAXHOST];
  static char *remote_id_proto, remote_id_port[PMAX];
  static char remote_filter_port[PMAX], local_filter_port[PMAX];
  static char *remote_filter_proto, *local_filter_proto, *pfs, *initiator;
  static char remote_filter_proto_num[3], local_filter_proto_num[3];
  static char remote_id_proto_num[3];
  static char phase1_group[PMAX];

  /* Allocated.  */
  static char *remote_filter = 0, *local_filter = 0, *remote_id = 0;

  static int dirty = 1;

  /* We only need to set dirty at initialization time really.  */
  if (strcmp (name, KEYNOTE_CALLBACK_CLEANUP) == 0
      || strcmp (name, KEYNOTE_CALLBACK_INITIALIZE) == 0)
    {
      esp_present = ah_present = comp_present = pfs = "no";
      ah_hash_alg = ah_auth_alg = phase_1 = "";
      esp_auth_alg = esp_enc_alg = comp_alg = ah_encapsulation = "";
      ah_ecn = esp_ecn = comp_ecn = "no";
      esp_encapsulation = comp_encapsulation = remote_filter_type = "";
      local_filter_type = remote_id_type = initiator = "";
      remote_filter_proto = local_filter_proto = remote_id_proto = "";

      if (remote_filter != 0)
        {
	  free (remote_filter);
	  remote_filter = 0;
	}

      if (local_filter != 0)
        {
	  free (local_filter);
	  local_filter = 0;
	}

      if (remote_id != 0)
        {
	  free (remote_id);
	  remote_id = 0;
	}

      memset (remote_ike_address, 0, sizeof remote_ike_address);
      memset (local_ike_address, 0, sizeof local_ike_address);
      memset (ah_life_kbytes, 0, sizeof ah_life_kbytes);
      memset (ah_life_seconds, 0, sizeof ah_life_seconds);
      memset (esp_life_kbytes, 0, sizeof esp_life_kbytes);
      memset (esp_life_seconds, 0, sizeof esp_life_seconds);
      memset (comp_life_kbytes, 0, sizeof comp_life_kbytes);
      memset (comp_life_seconds, 0, sizeof comp_life_seconds);
      memset (ah_key_length, 0, sizeof ah_key_length);
      memset (ah_key_rounds, 0, sizeof ah_key_rounds);
      memset (esp_key_length, 0, sizeof esp_key_length);
      memset (esp_key_rounds, 0, sizeof esp_key_rounds);
      memset (comp_dict_size, 0, sizeof comp_dict_size);
      memset (comp_private_alg, 0, sizeof comp_private_alg);
      memset (remote_filter_addr_upper, 0, sizeof remote_filter_addr_upper);
      memset (remote_filter_addr_lower, 0, sizeof remote_filter_addr_lower);
      memset (local_filter_addr_upper, 0, sizeof local_filter_addr_upper);
      memset (local_filter_addr_lower, 0, sizeof local_filter_addr_lower);
      memset (remote_id_addr_upper, 0, sizeof remote_id_addr_upper);
      memset (remote_id_addr_lower, 0, sizeof remote_id_addr_lower);
      memset (ah_group_desc, 0, sizeof ah_group_desc);
      memset (esp_group_desc, 0, sizeof esp_group_desc);
      memset (remote_id_port, 0, sizeof remote_id_port);
      memset (remote_filter_port, 0, sizeof remote_filter_port);
      memset (local_filter_port, 0, sizeof local_filter_port);
      memset (phase1_group, 0, sizeof phase1_group);

      dirty = 1;
      return "";
    }

  /*
   * If dirty is set, this is the first request for an attribute, so
   * populate our value cache.
   */
  if (dirty)
    {
      ie = policy_exchange->data;

      if (ie->pfs)
	pfs = "yes";

      is = policy_isakmp_sa->data;
      snprintf (phase1_group, sizeof phase1_group, "%u", is->group_desc);

      for (proto = TAILQ_FIRST (&policy_sa->protos); proto;
	   proto = TAILQ_NEXT (proto, link))
	{
	  switch (proto->proto)
	    {
	    case IPSEC_PROTO_IPSEC_AH:
	      ah_present = "yes";
	      switch (proto->id)
		{
		case IPSEC_AH_MD5:
		  ah_hash_alg = "md5";
		  break;

		case IPSEC_AH_SHA:
		  ah_hash_alg = "sha";
		  break;

		case IPSEC_AH_RIPEMD:
		  ah_hash_alg = "ripemd";
		  break;

		case IPSEC_AH_SHA2_256:
		  ah_auth_alg = "sha2-256";
		  break;

		case IPSEC_AH_SHA2_384:
		  ah_auth_alg = "sha2-384";
		  break;

		case IPSEC_AH_SHA2_512:
		  ah_auth_alg = "sha2-512";
		  break;

		case IPSEC_AH_DES:
		  ah_hash_alg = "des";
		  break;
		}
d355 2
a356 1
	      break;
d358 284
a641 52
	    case IPSEC_PROTO_IPSEC_ESP:
	      esp_present = "yes";
	      switch (proto->id)
		{
		case IPSEC_ESP_DES_IV64:
		  esp_enc_alg = "des-iv64";
		  break;

		case IPSEC_ESP_DES:
		  esp_enc_alg = "des";
		  break;

		case IPSEC_ESP_3DES:
		  esp_enc_alg = "3des";
		  break;

		case IPSEC_ESP_AES:
		case IPSEC_ESP_AES_128_CTR:
		  esp_enc_alg = "aes";
		  break;

		case IPSEC_ESP_RC5:
		  esp_enc_alg = "rc5";
		  break;

		case IPSEC_ESP_IDEA:
		  esp_enc_alg = "idea";
		  break;

		case IPSEC_ESP_CAST:
		  esp_enc_alg = "cast";
		  break;

		case IPSEC_ESP_BLOWFISH:
		  esp_enc_alg = "blowfish";
		  break;

		case IPSEC_ESP_3IDEA:
		  esp_enc_alg = "3idea";
		  break;

		case IPSEC_ESP_DES_IV32:
		  esp_enc_alg = "des-iv32";
		  break;

		case IPSEC_ESP_RC4:
		  esp_enc_alg = "rc4";
		  break;

		case IPSEC_ESP_NULL:
		  esp_enc_alg = "null";
		  break;
d644 20
a663 1
	      break;
d665 3
a667 19
	    case IPSEC_PROTO_IPCOMP:
	      comp_present = "yes";
	      switch (proto->id)
		{
		case IPSEC_IPCOMP_OUI:
		  comp_alg = "oui";
		  break;

		case IPSEC_IPCOMP_DEFLATE:
		  comp_alg = "deflate";
		  break;

		case IPSEC_IPCOMP_LZS:
		  comp_alg = "lzs";
		  break;

		case IPSEC_IPCOMP_V42BIS:
		  comp_alg = "v42bis";
		  break;
d670 24
a693 2
	      break;
	    }
d695 2
a696 9
	  for (attr = proto->chosen->p + ISAKMP_TRANSFORM_SA_ATTRS_OFF;
	       attr
		 < proto->chosen->p + GET_ISAKMP_GEN_LENGTH (proto->chosen->p);
	       attr = value + len)
	    {
	      if (attr + ISAKMP_ATTR_VALUE_OFF
		  > (proto->chosen->p
		     + GET_ISAKMP_GEN_LENGTH (proto->chosen->p)))
		return "";
d698 18
a715 7
	      type = GET_ISAKMP_ATTR_TYPE (attr);
	      fmt = ISAKMP_ATTR_FORMAT (type);
	      type = ISAKMP_ATTR_TYPE (type);
	      value = attr + (fmt ? ISAKMP_ATTR_LENGTH_VALUE_OFF :
			      ISAKMP_ATTR_VALUE_OFF);
	      len = (fmt ? ISAKMP_ATTR_LENGTH_VALUE_LEN :
		     GET_ISAKMP_ATTR_LENGTH_VALUE (attr));
d717 2
a718 3
	      if (value + len > proto->chosen->p +
		  GET_ISAKMP_GEN_LENGTH (proto->chosen->p))
		return "";
d720 20
a739 5
	      switch (type)
		{
		case IPSEC_ATTR_SA_LIFE_TYPE:
		  lifetype = decode_16 (value);
		  break;
d741 11
a751 73
		case IPSEC_ATTR_SA_LIFE_DURATION:
		  switch (proto->proto)
		    {
		    case IPSEC_PROTO_IPSEC_AH:
		      if (lifetype == IPSEC_DURATION_SECONDS)
			{
			  if (len == 2)
			    snprintf (ah_life_seconds, sizeof ah_life_seconds,
				      "%u", decode_16 (value));
			  else
			    snprintf (ah_life_seconds, sizeof ah_life_seconds,
				      "%u", decode_32 (value));
			}
		      else
			{
			  if (len == 2)
			    snprintf (ah_life_kbytes, sizeof ah_life_kbytes,
				      "%u", decode_16 (value));
			  else
			    snprintf (ah_life_kbytes, sizeof ah_life_kbytes,
				      "%u", decode_32 (value));
			}

		      break;

		    case IPSEC_PROTO_IPSEC_ESP:
		      if (lifetype == IPSEC_DURATION_SECONDS)
			{
			  if (len == 2)
			    snprintf (esp_life_seconds,
				      sizeof esp_life_seconds, "%u",
				      decode_16 (value));
			  else
			    snprintf (esp_life_seconds,
				      sizeof esp_life_seconds, "%u",
				      decode_32 (value));
			}
		      else
			{
			  if (len == 2)
			    snprintf (esp_life_kbytes,
				      sizeof esp_life_kbytes, "%u",
				      decode_16 (value));
			  else
			    snprintf (esp_life_kbytes,
				      sizeof esp_life_kbytes, "%u",
				      decode_32 (value));
			}

		      break;

		    case IPSEC_PROTO_IPCOMP:
		      if (lifetype == IPSEC_DURATION_SECONDS)
			{
			  if (len == 2)
			    snprintf (comp_life_seconds,
				      sizeof comp_life_seconds, "%u",
				      decode_16 (value));
			  else
			    snprintf (comp_life_seconds,
				      sizeof comp_life_seconds, "%u",
				      decode_32 (value));
			}
		      else
			{
			  if (len == 2)
			    snprintf (comp_life_kbytes,
				      sizeof comp_life_kbytes, "%u",
				      decode_16 (value));
			  else
			    snprintf (comp_life_kbytes,
				      sizeof comp_life_kbytes, "%u",
				      decode_32 (value));
d753 4
d758 20
a777 3
		      break;
		    }
		  break;
d779 1
a779 2
		case IPSEC_ATTR_GROUP_DESCRIPTION:
		  switch (proto->proto)
d781 33
a813 14
		    case IPSEC_PROTO_IPSEC_AH:
		      snprintf (ah_group_desc, sizeof ah_group_desc, "%u",
				decode_16 (value));
		      break;

		    case IPSEC_PROTO_IPSEC_ESP:
		      snprintf (esp_group_desc, sizeof esp_group_desc, "%u",
			       decode_16 (value));
		      break;

		    case IPSEC_PROTO_IPCOMP:
		      snprintf (comp_group_desc, sizeof comp_group_desc, "%u",
			       decode_16 (value));
		      break;
a814 1
		  break;
d816 13
a828 6
		case IPSEC_ATTR_ECN_TUNNEL:
		  if (decode_16 (value))
		    switch (proto->proto)
		      {
		      case IPSEC_PROTO_IPSEC_AH:
			ah_ecn = "yes";
d831 13
a843 2
		      case IPSEC_PROTO_IPSEC_ESP:
			esp_ecn = "yes";
d846 11
a856 2
		      case IPSEC_PROTO_IPCOMP:
			comp_ecn = "yes";
a857 1
		      }
d859 2
a860 6
		case IPSEC_ATTR_ENCAPSULATION_MODE:
		  if (decode_16 (value) == IPSEC_ENCAP_TUNNEL)
		    switch (proto->proto)
		      {
		      case IPSEC_PROTO_IPSEC_AH:
			ah_encapsulation = "tunnel";
d863 30
a892 2
		      case IPSEC_PROTO_IPSEC_ESP:
			esp_encapsulation = "tunnel";
d895 8
a902 2
		      case IPSEC_PROTO_IPCOMP:
			comp_encapsulation = "tunnel";
d904 3
a906 6
		      }
		  else
		    switch (proto->proto)
		      {
		      case IPSEC_PROTO_IPSEC_AH:
			ah_encapsulation = "transport";
d909 3
a911 2
		      case IPSEC_PROTO_IPSEC_ESP:
			esp_encapsulation = "transport";
d913 1
d915 4
a918 2
		      case IPSEC_PROTO_IPCOMP:
			comp_encapsulation = "transport";
d920 4
a923 2
		      }
		  break;
d925 238
a1162 74
		case IPSEC_ATTR_AUTHENTICATION_ALGORITHM:
		  switch (proto->proto)
		    {
		    case IPSEC_PROTO_IPSEC_AH:
		      switch (decode_16 (value))
			{
			case IPSEC_AUTH_HMAC_MD5:
			  ah_auth_alg = "hmac-md5";
			  break;

			case IPSEC_AUTH_HMAC_SHA:
			  ah_auth_alg = "hmac-sha";
			  break;

			case IPSEC_AUTH_HMAC_RIPEMD:
			  ah_auth_alg = "hmac-ripemd";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_256:
			  ah_auth_alg = "hmac-sha2-256";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_384:
			  ah_auth_alg = "hmac-sha2-384";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_512:
			  ah_auth_alg = "hmac-sha2-512";
			  break;

			case IPSEC_AUTH_DES_MAC:
			  ah_auth_alg = "des-mac";
			  break;

			case IPSEC_AUTH_KPDK:
			  ah_auth_alg = "kpdk";
			  break;
			}
		      break;

		    case IPSEC_PROTO_IPSEC_ESP:
		      switch (decode_16 (value))
			{
			case IPSEC_AUTH_HMAC_MD5:
			  esp_auth_alg = "hmac-md5";
			  break;

			case IPSEC_AUTH_HMAC_SHA:
			  esp_auth_alg = "hmac-sha";
			  break;

			case IPSEC_AUTH_HMAC_RIPEMD:
			  esp_auth_alg = "hmac-ripemd";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_256:
			  esp_auth_alg = "hmac-sha2-256";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_384:
			  esp_auth_alg = "hmac-sha2-384";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_512:
			  esp_auth_alg = "hmac-sha2-512";
			  break;

			case IPSEC_AUTH_DES_MAC:
			  esp_auth_alg = "des-mac";
			  break;

			case IPSEC_AUTH_KPDK:
			  esp_auth_alg = "kpdk";
			  break;
a1163 3
		      break;
		    }
		  break;
d1165 14
a1178 14
		case IPSEC_ATTR_KEY_LENGTH:
		  switch (proto->proto)
		    {
		    case IPSEC_PROTO_IPSEC_AH:
		      snprintf (ah_key_length, sizeof ah_key_length, "%u",
				decode_16 (value));
		      break;

		    case IPSEC_PROTO_IPSEC_ESP:
		      snprintf (esp_key_length, sizeof esp_key_length, "%u",
			       decode_16 (value));
		      break;
		    }
		  break;
d1180 7
a1186 14
		case IPSEC_ATTR_KEY_ROUNDS:
		  switch (proto->proto)
		    {
		    case IPSEC_PROTO_IPSEC_AH:
		      snprintf (ah_key_rounds, sizeof ah_key_rounds, "%u",
				decode_16 (value));
		      break;

		    case IPSEC_PROTO_IPSEC_ESP:
		      snprintf (esp_key_rounds, sizeof esp_key_rounds, "%u",
			       decode_16 (value));
		      break;
		    }
		  break;
d1188 31
a1218 9
		case IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE:
		  snprintf (comp_dict_size, sizeof comp_dict_size, "%u",
			    decode_16 (value));
		  break;

		case IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM:
		  snprintf (comp_private_alg, sizeof comp_private_alg, "%u",
			    decode_16 (value));
		  break;
a1219 2
	    }
	}
d1221 257
a1477 8
      policy_sa->transport->vtbl->get_src (policy_sa->transport, &sin);
      if (sockaddr2text (sin, &addr, 1))
	{
	  log_error ("policy_callback: sockaddr2text failed");
	  goto bad;
	}
      strlcpy (local_ike_address, addr, sizeof local_ike_address);
      free (addr);
d1479 16
a1494 8
      policy_sa->transport->vtbl->get_dst (policy_sa->transport, &sin);
      if (sockaddr2text (sin, &addr, 1))
	{
	  log_error ("policy_callback: sockaddr2text failed");
	  goto bad;
	}
      strlcpy (remote_ike_address, addr, sizeof remote_ike_address);
      free (addr);
d1496 69
a1564 5
      switch (policy_isakmp_sa->exch_type)
	{
	case ISAKMP_EXCH_AGGRESSIVE:
	  phase_1 = "aggressive";
	  break;
d1566 2
a1567 3
	case ISAKMP_EXCH_ID_PROT:
	  phase_1 = "main";
	  break;
d1569 2
d1572 4
a1575 4
      if (policy_isakmp_sa->initiator)
        {
	  id = policy_isakmp_sa->id_r;
	  id_sz = policy_isakmp_sa->id_r_len;
d1577 4
a1580 4
      else
        {
	  id = policy_isakmp_sa->id_i;
	  id_sz = policy_isakmp_sa->id_i_len;
d1582 29
d1612 14
a1625 4
      switch (id[0])
        {
	case IPSEC_ID_IPV4_ADDR:
	  remote_id_type = "IPv4 address";
d1627 2
a1628 63
	  net = decode_32 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
	  my_inet_ntop4 (&net, remote_id_addr_upper,
			 sizeof remote_id_addr_upper - 1, 1);
	  my_inet_ntop4 (&net, remote_id_addr_lower,
			 sizeof remote_id_addr_lower - 1, 1);
	  remote_id = strdup (remote_id_addr_upper);
	  if (!remote_id)
	    {
	      log_error ("policy_callback: strdup (\"%s\") failed",
			 remote_id_addr_upper);
	      goto bad;
	    }
	  break;

	case IPSEC_ID_IPV4_RANGE:
	  remote_id_type = "IPv4 range";

	  net = decode_32 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
	  my_inet_ntop4 (&net, remote_id_addr_lower,
			 sizeof remote_id_addr_lower - 1, 1);
	  net = decode_32 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 4);
	  my_inet_ntop4 (&net, remote_id_addr_upper,
			 sizeof remote_id_addr_upper - 1, 1);
	  len = strlen (remote_id_addr_upper) + strlen (remote_id_addr_lower)
	    + 2;
	  remote_id = calloc (len, sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%d, %lu) failed", len,
			 (unsigned long)sizeof (char));
	      goto bad;
	    }

	  strlcpy (remote_id, remote_id_addr_lower, len);
	  strlcat (remote_id, "-", len);
	  strlcat (remote_id, remote_id_addr_upper, len);
	  break;

	case IPSEC_ID_IPV4_ADDR_SUBNET:
	  remote_id_type = "IPv4 subnet";

	  net = decode_32 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
	  subnet = decode_32 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 4);
	  net &= subnet;
	  my_inet_ntop4 (&net, remote_id_addr_lower,
			 sizeof remote_id_addr_lower - 1, 1);
	  net |= ~subnet;
	  my_inet_ntop4 (&net, remote_id_addr_upper,
			 sizeof remote_id_addr_upper - 1, 1);
	  len = strlen (remote_id_addr_upper) + strlen (remote_id_addr_lower)
	    + 2;
	  remote_id = calloc (len, sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%d, %lu) failed", len,
			 (unsigned long)sizeof (char));
	      goto bad;
	    }

	  strlcpy (remote_id, remote_id_addr_lower, len);
	  strlcat (remote_id, "-", len);
	  strlcat (remote_id, remote_id_addr_upper, len);
	  break;
d1630 2
a1631 78
	case IPSEC_ID_IPV6_ADDR:
	  remote_id_type = "IPv6 address";
	  my_inet_ntop6 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			 remote_id_addr_upper, sizeof remote_id_addr_upper);
	  strlcpy (remote_id_addr_lower, remote_id_addr_upper,
		   sizeof remote_id_addr_lower);
	  remote_id = strdup (remote_id_addr_upper);
	  if (!remote_id)
	    {
	      log_error ("policy_callback: strdup (\"%s\") failed",
			 remote_id_addr_upper);
	      goto bad;
	    }
	  break;

	case IPSEC_ID_IPV6_RANGE:
	  remote_id_type = "IPv6 range";

	  my_inet_ntop6 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			 remote_id_addr_lower,
			 sizeof remote_id_addr_lower - 1);

	  my_inet_ntop6 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 16,
			 remote_id_addr_upper,
			 sizeof remote_id_addr_upper - 1);

	  len = strlen (remote_id_addr_upper) + strlen (remote_id_addr_lower)
	    + 2;
	  remote_id = calloc (len, sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%d, %lu) failed", len,
			 (unsigned long)sizeof (char));
	      goto bad;
	    }

	  strlcpy (remote_id, remote_id_addr_lower, len);
	  strlcat (remote_id, "-", len);
	  strlcat (remote_id, remote_id_addr_upper, len);
	  break;

	case IPSEC_ID_IPV6_ADDR_SUBNET:
	{
	  struct in6_addr net, mask;

	  remote_id_type = "IPv6 subnet";

	  memmove (&net, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, sizeof (net));
	  memmove (&mask, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 16,
		 sizeof (mask));

	  for (i = 0; i < 16; i++)
	    net.s6_addr[i] &= mask.s6_addr[i];

	  my_inet_ntop6 ((unsigned char *) &net, remote_id_addr_lower,
			 sizeof remote_id_addr_lower - 1);

	  for (i = 0; i < 16; i++)
	    net.s6_addr[i] |= ~mask.s6_addr[i];

	  my_inet_ntop6 ((unsigned char *) &net, remote_id_addr_upper,
			 sizeof remote_id_addr_upper - 1);

	  len = strlen (remote_id_addr_upper) + strlen (remote_id_addr_lower)
	    + 2;
	  remote_id = calloc (len, sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%d, %lu) failed", len,
			 (unsigned long)sizeof (char));
	      goto bad;
	    }

	  strlcpy (remote_id, remote_id_addr_lower, len);
	  strlcat (remote_id, "-", len);
	  strlcat (remote_id, remote_id_addr_upper, len);
	  break;
	}
d1633 2
a1634 14
	case IPSEC_ID_FQDN:
	  remote_id_type = "FQDN";
	  remote_id = calloc (id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
			      sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%lu, %lu) failed",
		 (unsigned long)id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
		 (unsigned long)sizeof (char));
	      goto bad;
	    }
	  memcpy (remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		  id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
	  break;
d1636 2
a1637 64
	case IPSEC_ID_USER_FQDN:
	  remote_id_type = "User FQDN";
	  remote_id = calloc (id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
			      sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%lu, %lu) failed",
		 (unsigned long)id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
		 (unsigned long)sizeof (char));
	      goto bad;
	    }
	  memcpy (remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		  id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
	  break;

	case IPSEC_ID_DER_ASN1_DN:
	  remote_id_type = "ASN1 DN";

	  remote_id = x509_DN_string (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
				      id_sz - ISAKMP_ID_DATA_OFF
				      + ISAKMP_GEN_SZ);
	  if (!remote_id)
	    {
	      LOG_DBG ((LOG_POLICY, 50,
			"policy_callback: failed to decode name"));
	      goto bad;
	    }
	  break;

	case IPSEC_ID_DER_ASN1_GN: /* XXX */
	  remote_id_type = "ASN1 GN";
	  break;

	case IPSEC_ID_KEY_ID:
	  remote_id_type = "Key ID";
	  remote_id
	    = calloc (2 * (id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1,
		      sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%lu, %lu) failed",
		 2 * ((unsigned long)id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1,
		 (unsigned long)sizeof (char));
	      goto bad;
	    }
	  /* Does it contain any non-printable characters ? */
	  for (i = 0; i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ; i++)
	    if (!isprint (*(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + i)))
	      break;
	  if (i >= id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ)
	    {
	      memcpy (remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		      id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
	      break;
	    }
	  /* Non-printable characters, convert to hex */
          for (i = 0; i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ; i++)
	    {
	      remote_id[2 * i]
		= hextab[*(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) >> 4];
	      remote_id[2 * i + 1]
		= hextab[*(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) & 0xF];
	    }
	  break;
d1639 2
a1640 4
	default:
	  log_print ("policy_callback: unknown remote ID type %u", id[0]);
	  goto bad;
	}
d1642 2
a1643 9
      switch (id[1])
        {
	case IPPROTO_TCP:
	  remote_id_proto = "tcp";
	  break;

	case IPPROTO_UDP:
	  remote_id_proto = "udp";
	  break;
d1645 2
a1646 5
#ifdef IPPROTO_ETHERIP
	case IPPROTO_ETHERIP:
	  remote_id_proto = "etherip";
	  break;
#endif
d1648 2
a1649 48
	default:
	  snprintf (remote_id_proto_num, sizeof remote_id_proto_num, "%d",
		    id[1]);
	  remote_id_proto = remote_id_proto_num;
	  break;
	}

      snprintf (remote_id_port, sizeof remote_id_port, "%u",
		decode_16 (id + 2));

      if (policy_exchange->initiator)
        {
	  initiator = "yes";
	  idlocal = ie->id_ci;
	  idremote = ie->id_cr;
	  idlocalsz = ie->id_ci_sz;
	  idremotesz = ie->id_cr_sz;
        }
      else
        {
	  initiator = "no";
	  idlocal = ie->id_cr;
	  idremote = ie->id_ci;
	  idlocalsz = ie->id_cr_sz;
	  idremotesz = ie->id_ci_sz;
	}

      /* Initialize the ID variables.  */
      if (idremote)
        {
	  switch (GET_ISAKMP_ID_TYPE (idremote))
	    {
	    case IPSEC_ID_IPV4_ADDR:
	      remote_filter_type = "IPv4 address";

	      net = decode_32 (idremote + ISAKMP_ID_DATA_OFF);
	      my_inet_ntop4 (&net, remote_filter_addr_upper,
			     sizeof remote_filter_addr_upper - 1, 1);
	      my_inet_ntop4 (&net, remote_filter_addr_lower,
			     sizeof remote_filter_addr_lower - 1, 1);
	      remote_filter = strdup (remote_filter_addr_upper);
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: strdup (\"%s\") failed",
			     remote_filter_addr_upper);
		  goto bad;
		}
	      break;
d1651 2
a1652 2
	    case IPSEC_ID_IPV4_RANGE:
	      remote_filter_type = "IPv4 range";
d1654 2
a1655 15
	      net = decode_32 (idremote + ISAKMP_ID_DATA_OFF);
	      my_inet_ntop4 (&net, remote_filter_addr_lower,
			     sizeof remote_filter_addr_lower - 1, 1);
	      net = decode_32 (idremote + ISAKMP_ID_DATA_OFF + 4);
	      my_inet_ntop4 (&net, remote_filter_addr_upper,
			     sizeof remote_filter_addr_upper - 1, 1);
	      len = strlen (remote_filter_addr_upper)
		+ strlen (remote_filter_addr_lower) + 2;
	      remote_filter = calloc (len, sizeof (char));
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
d1657 2
a1658 45
	      strlcpy (remote_filter, remote_filter_addr_lower, len);
	      strlcat (remote_filter, "-", len);
	      strlcat (remote_filter, remote_filter_addr_upper, len);
	      break;

	    case IPSEC_ID_IPV4_ADDR_SUBNET:
	      remote_filter_type = "IPv4 subnet";

	      net = decode_32 (idremote + ISAKMP_ID_DATA_OFF);
	      subnet = decode_32 (idremote + ISAKMP_ID_DATA_OFF + 4);
	      net &= subnet;
	      my_inet_ntop4 (&net, remote_filter_addr_lower,
			     sizeof remote_filter_addr_lower - 1, 1);
	      net |= ~subnet;
	      my_inet_ntop4 (&net, remote_filter_addr_upper,
			     sizeof remote_filter_addr_upper - 1, 1);
	      len = strlen (remote_filter_addr_upper)
		+ strlen (remote_filter_addr_lower) + 2;
	      remote_filter = calloc (len, sizeof (char));
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
	      strlcpy (remote_filter, remote_filter_addr_lower, len);
	      strlcat (remote_filter, "-", len);
	      strlcat (remote_filter, remote_filter_addr_upper, len);
	      break;

	    case IPSEC_ID_IPV6_ADDR:
	      remote_filter_type = "IPv6 address";
	      my_inet_ntop6 (idremote + ISAKMP_ID_DATA_OFF,
			     remote_filter_addr_upper,
			     sizeof remote_filter_addr_upper - 1);
	      strlcpy (remote_filter_addr_lower, remote_filter_addr_upper,
		       sizeof remote_filter_addr_lower);
	      remote_filter = strdup (remote_filter_addr_upper);
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: strdup (\"%s\") failed",
			     remote_filter_addr_upper);
		  goto bad;
		}
	      break;
d1660 2
a1661 2
	    case IPSEC_ID_IPV6_RANGE:
	      remote_filter_type = "IPv6 range";
d1663 2
a1664 17
	      my_inet_ntop6 (idremote + ISAKMP_ID_DATA_OFF,
			     remote_filter_addr_lower,
			     sizeof remote_filter_addr_lower - 1);

	      my_inet_ntop6 (idremote + ISAKMP_ID_DATA_OFF + 16,
			     remote_filter_addr_upper,
			     sizeof remote_filter_addr_upper - 1);

	      len = strlen (remote_filter_addr_upper)
		+ strlen (remote_filter_addr_lower) + 2;
	      remote_filter = calloc (len, sizeof (char));
	      if (!remote_filter)
		{
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
d1666 2
a1667 4
	      strlcpy (remote_filter, remote_filter_addr_lower, len);
	      strlcat (remote_filter, "-", len);
	      strlcat (remote_filter, remote_filter_addr_upper, len);
	      break;
d1669 2
a1670 3
	    case IPSEC_ID_IPV6_ADDR_SUBNET:
	    {
	      struct in6_addr net, mask;
d1672 2
a1673 1
	      remote_filter_type = "IPv6 subnet";
d1675 2
a1676 2
	      memmove (&net, idremote + ISAKMP_ID_DATA_OFF, sizeof (net));
	      memmove (&mask, idremote + ISAKMP_ID_DATA_OFF + 16, sizeof (mask));
d1678 2
a1679 2
	      for (i = 0; i < 16; i++)
		net.s6_addr[i] &= mask.s6_addr[i];
d1681 2
a1682 2
	      my_inet_ntop6 ((unsigned char *) &net, remote_filter_addr_lower,
			     sizeof remote_filter_addr_lower - 1);
d1684 2
a1685 2
	      for (i = 0; i < 16; i++)
		net.s6_addr[i] |= ~mask.s6_addr[i];
d1687 2
a1688 2
	      my_inet_ntop6 ((unsigned char *) &net, remote_filter_addr_upper,
			     sizeof remote_filter_addr_upper - 1);
d1690 2
a1691 9
	      len = strlen (remote_filter_addr_upper)
		+ strlen (remote_filter_addr_lower) + 2;
	      remote_filter = calloc (len, sizeof (char));
	      if (!remote_filter)
		{
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
d1693 2
a1694 46
	      strlcpy (remote_filter, remote_filter_addr_lower, len);
	      strlcat (remote_filter, "-", len);
	      strlcat (remote_filter, remote_filter_addr_upper, len);
	      break;
	    }

	    case IPSEC_ID_FQDN:
	      remote_filter_type = "FQDN";
	      remote_filter = malloc (idremotesz - ISAKMP_ID_DATA_OFF + 1);
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: malloc (%lu) failed",
			     (unsigned long)idremotesz - ISAKMP_ID_DATA_OFF + 1);
		  goto bad;
		}
	      memcpy (remote_filter, idremote + ISAKMP_ID_DATA_OFF,
		      idremotesz - ISAKMP_ID_DATA_OFF);
	      remote_filter[idremotesz - ISAKMP_ID_DATA_OFF] = '\0';
	      break;

	    case IPSEC_ID_USER_FQDN:
	      remote_filter_type = "User FQDN";
	      remote_filter = malloc (idremotesz - ISAKMP_ID_DATA_OFF + 1);
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: malloc (%lu) failed",
			     (unsigned long)idremotesz - ISAKMP_ID_DATA_OFF + 1);
		  goto bad;
		}
	      memcpy (remote_filter, idremote + ISAKMP_ID_DATA_OFF,
		      idremotesz - ISAKMP_ID_DATA_OFF);
	      remote_filter[idremotesz - ISAKMP_ID_DATA_OFF] = '\0';
	      break;

	    case IPSEC_ID_DER_ASN1_DN:
	      remote_filter_type = "ASN1 DN";

	      remote_filter = x509_DN_string (idremote + ISAKMP_ID_DATA_OFF,
					      idremotesz - ISAKMP_ID_DATA_OFF);
	      if (!remote_filter)
	        {
		  LOG_DBG ((LOG_POLICY, 50,
			    "policy_callback: failed to decode name"));
		  goto bad;
		}
	      break;
d1696 2
a1697 51
	    case IPSEC_ID_DER_ASN1_GN: /* XXX -- not sure what's in this.  */
	      remote_filter_type = "ASN1 GN";
	      break;

	    case IPSEC_ID_KEY_ID:
	      remote_filter_type = "Key ID";
	      remote_filter
		= calloc (2 * (idremotesz - ISAKMP_ID_DATA_OFF) + 1,
			  sizeof (char));
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: calloc (%lu, %lu) failed",
		     2 * ((unsigned long)idremotesz - ISAKMP_ID_DATA_OFF) + 1,
		     (unsigned long)sizeof (char));
		  goto bad;
	        }
	      /* Does it contain any non-printable characters ? */
	      for (i = 0; i < idremotesz - ISAKMP_ID_DATA_OFF; i++)
		if (!isprint (*(idremote + ISAKMP_ID_DATA_OFF + i)))
		  break;
	      if (i >= idremotesz - ISAKMP_ID_DATA_OFF)
	        {
		  memcpy (remote_filter, idremote + ISAKMP_ID_DATA_OFF,
			  idremotesz - ISAKMP_ID_DATA_OFF);
		  break;
		}
	      /* Non-printable characters, convert to hex */
              for (i = 0; i < idremotesz - ISAKMP_ID_DATA_OFF; i++)
	        {
		  remote_filter[2 * i]
		    = hextab[*(idremote + ISAKMP_ID_DATA_OFF) >> 4];
		  remote_filter[2 * i + 1]
		    = hextab[*(idremote + ISAKMP_ID_DATA_OFF) & 0xF];
	        }
	      break;

	    default:
	      log_print ("policy_callback: unknown Remote ID type %u",
			 GET_ISAKMP_ID_TYPE (idremote));
	      goto bad;
	    }

	  switch (idremote[ISAKMP_GEN_SZ + 1])
	    {
	    case IPPROTO_TCP:
	      remote_filter_proto = "tcp";
	      break;

	    case IPPROTO_UDP:
	      remote_filter_proto = "udp";
	      break;
d1699 2
a1700 5
#ifdef IPPROTO_ETHERIP
	    case IPPROTO_ETHERIP:
	      remote_filter_proto = "etherip";
	      break;
#endif
d1702 2
a1703 66
	    default:
	      snprintf (remote_filter_proto_num,
			sizeof remote_filter_proto_num, "%d",
			idremote[ISAKMP_GEN_SZ + 1]);
	      remote_filter_proto = remote_filter_proto_num;
	      break;
	    }

	  snprintf (remote_filter_port, sizeof remote_filter_port, "%u",
		    decode_16 (idremote + ISAKMP_GEN_SZ + 2));
	}
      else
        {
	  policy_sa->transport->vtbl->get_dst (policy_sa->transport, &sin);
	  switch (sin->sa_family)
	    {
	    case AF_INET:
	      remote_filter_type = "IPv4 address";
	      break;
	    case AF_INET6:
	      remote_filter_type = "IPv6 address";
	      break;
	    default:
	      log_print ("policy_callback: unsupported protocol family %d",
			 sin->sa_family);
	      goto bad;
	    }
	  if (sockaddr2text (sin, &addr, 1))
	    {
	      log_error ("policy_callback: sockaddr2text failed");
	      goto bad;
	    }
	  memcpy (remote_filter_addr_upper, addr,
		  sizeof remote_filter_addr_upper);
	  memcpy (remote_filter_addr_lower, addr,
		  sizeof remote_filter_addr_lower);
	  free (addr);
	  remote_filter = strdup (remote_filter_addr_upper);
	  if (!remote_filter)
	    {
	      log_error ("policy_callback: strdup (\"%s\") failed",
			 remote_filter_addr_upper);
	      goto bad;
	    }
	}

      if (idlocal)
        {
	  switch (GET_ISAKMP_ID_TYPE (idlocal))
	    {
	    case IPSEC_ID_IPV4_ADDR:
	      local_filter_type = "IPv4 address";

	      net = decode_32 (idlocal + ISAKMP_ID_DATA_OFF);
	      my_inet_ntop4 (&net, local_filter_addr_upper,
			     sizeof local_filter_addr_upper - 1, 1);
	      my_inet_ntop4 (&net, local_filter_addr_lower,
			     sizeof local_filter_addr_upper - 1, 1);
	      local_filter = strdup (local_filter_addr_upper);
	      if (!local_filter)
	        {
		  log_error ("policy_callback: strdup (\"%s\") failed",
			     local_filter_addr_upper);
		  goto bad;
		}
	      break;
d1705 2
a1706 2
	    case IPSEC_ID_IPV4_RANGE:
	      local_filter_type = "IPv4 range";
d1708 2
a1709 60
	      net = decode_32 (idlocal + ISAKMP_ID_DATA_OFF);
	      my_inet_ntop4 (&net, local_filter_addr_lower,
			     sizeof local_filter_addr_lower - 1, 1);
	      net = decode_32 (idlocal + ISAKMP_ID_DATA_OFF + 4);
	      my_inet_ntop4 (&net, local_filter_addr_upper,
			     sizeof local_filter_addr_upper - 1, 1);
	      len = strlen (local_filter_addr_upper)
		+ strlen (local_filter_addr_lower) + 2;
	      local_filter = calloc (len, sizeof (char));
	      if (!local_filter)
	        {
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
	      strlcpy (local_filter, local_filter_addr_lower, len);
	      strlcat (local_filter, "-", len);
	      strlcat (local_filter, local_filter_addr_upper, len);
	      break;

	    case IPSEC_ID_IPV4_ADDR_SUBNET:
	      local_filter_type = "IPv4 subnet";

	      net = decode_32 (idlocal + ISAKMP_ID_DATA_OFF);
	      subnet = decode_32 (idlocal + ISAKMP_ID_DATA_OFF + 4);
	      net &= subnet;
	      my_inet_ntop4 (&net, local_filter_addr_lower,
			     sizeof local_filter_addr_lower - 1, 1);
	      net |= ~subnet;
	      my_inet_ntop4 (&net, local_filter_addr_upper,
			     sizeof local_filter_addr_upper - 1, 1);
	      len = strlen (local_filter_addr_upper)
		+ strlen (local_filter_addr_lower) + 2;
	      local_filter = calloc (len, sizeof (char));
	      if (!local_filter)
	        {
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
	      strlcpy (local_filter, local_filter_addr_lower, len);
	      strlcat (local_filter, "-", len);
	      strlcat (local_filter, local_filter_addr_upper, len);
	      break;

	    case IPSEC_ID_IPV6_ADDR:
	      local_filter_type = "IPv6 address";
	      my_inet_ntop6 (idlocal + ISAKMP_ID_DATA_OFF,
			     local_filter_addr_upper,
			     sizeof local_filter_addr_upper - 1);
	      strlcpy (local_filter_addr_lower, local_filter_addr_upper,
		       sizeof local_filter_addr_lower);
	      local_filter = strdup (local_filter_addr_upper);
	      if (!local_filter)
	        {
		  log_error ("policy_callback: strdup (\"%s\") failed",
			     local_filter_addr_upper);
		  goto bad;
		}
	      break;
d1711 2
a1712 2
	    case IPSEC_ID_IPV6_RANGE:
	      local_filter_type = "IPv6 range";
d1714 2
a1715 17
	      my_inet_ntop6 (idlocal + ISAKMP_ID_DATA_OFF,
			     local_filter_addr_lower,
			     sizeof local_filter_addr_lower - 1);

	      my_inet_ntop6 (idlocal + ISAKMP_ID_DATA_OFF + 16,
			     local_filter_addr_upper,
			     sizeof local_filter_addr_upper - 1);

	      len = strlen (local_filter_addr_upper)
		+ strlen (local_filter_addr_lower) + 2;
	      local_filter = calloc (len, sizeof (char));
	      if (!local_filter)
		{
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
d1717 2
a1718 4
	      strlcpy (local_filter, local_filter_addr_lower, len);
	      strlcat (local_filter, "-", len);
	      strlcat (local_filter, local_filter_addr_upper, len);
	      break;
d1720 2
a1721 3
	    case IPSEC_ID_IPV6_ADDR_SUBNET:
	    {
	      struct in6_addr net, mask;
d1723 2
a1724 1
	      local_filter_type = "IPv6 subnet";
d1726 2
a1727 2
	      memmove (&net, idlocal + ISAKMP_ID_DATA_OFF, sizeof (net));
	      memmove (&mask, idlocal + ISAKMP_ID_DATA_OFF + 16, sizeof (mask));
d1729 2
a1730 2
	      for (i = 0; i < 16; i++)
		net.s6_addr[i] &= mask.s6_addr[i];
d1732 2
a1733 2
	      my_inet_ntop6 ((unsigned char *) &net, local_filter_addr_lower,
			     sizeof local_filter_addr_lower - 1);
d1735 2
a1736 2
	      for (i = 0; i < 16; i++)
		net.s6_addr[i] |= ~mask.s6_addr[i];
d1738 2
a1739 2
	      my_inet_ntop6 ((unsigned char *) &net, local_filter_addr_upper,
			     sizeof local_filter_addr_upper - 1);
d1741 2
a1742 9
	      len = strlen (local_filter_addr_upper)
		+ strlen (local_filter_addr_lower) + 2;
	      local_filter = calloc (len, sizeof (char));
	      if (!local_filter)
		{
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
d1744 2
a1745 46
	      strlcpy (local_filter, local_filter_addr_lower, len);
	      strlcat (local_filter, "-", len);
	      strlcat (local_filter, local_filter_addr_upper, len);
	      break;
	    }

	    case IPSEC_ID_FQDN:
	      local_filter_type = "FQDN";
	      local_filter = malloc (idlocalsz - ISAKMP_ID_DATA_OFF + 1);
	      if (!local_filter)
	        {
		  log_error ("policy_callback: malloc (%lu) failed",
			     (unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF + 1);
		  goto bad;
		}
	      memcpy (local_filter, idlocal + ISAKMP_ID_DATA_OFF,
		      idlocalsz - ISAKMP_ID_DATA_OFF);
	      local_filter[idlocalsz - ISAKMP_ID_DATA_OFF] = '\0';
	      break;

	    case IPSEC_ID_USER_FQDN:
	      local_filter_type = "User FQDN";
	      local_filter = malloc (idlocalsz - ISAKMP_ID_DATA_OFF + 1);
	      if (!local_filter)
	        {
		  log_error ("policy_callback: malloc (%lu) failed",
			     (unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF + 1);
		  goto bad;
		}
	      memcpy (local_filter, idlocal + ISAKMP_ID_DATA_OFF,
		      idlocalsz - ISAKMP_ID_DATA_OFF);
	      local_filter[idlocalsz - ISAKMP_ID_DATA_OFF] = '\0';
	      break;

	    case IPSEC_ID_DER_ASN1_DN:
	      local_filter_type = "ASN1 DN";

	      local_filter = x509_DN_string (idlocal + ISAKMP_ID_DATA_OFF,
					     idlocalsz - ISAKMP_ID_DATA_OFF);
	      if (!local_filter)
	        {
		  LOG_DBG ((LOG_POLICY, 50,
			    "policy_callback: failed to decode name"));
		  goto bad;
		}
	      break;
d1747 2
a1748 51
	    case IPSEC_ID_DER_ASN1_GN:
	      /* XXX -- not sure what's in this.  */
	      local_filter_type = "ASN1 GN";
	      break;

	    case IPSEC_ID_KEY_ID:
	      local_filter_type = "Key ID";
	      local_filter = calloc (2 * (idlocalsz - ISAKMP_ID_DATA_OFF) + 1,
				     sizeof (char));
	      if (!local_filter)
	        {
		  log_error ("policy_callback: calloc (%lu, %lu) failed",
		     2 * ((unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF) + 1,
		     (unsigned long)sizeof (char));
		  goto bad;
	        }
	      /* Does it contain any non-printable characters ? */
	      for (i = 0; i < idlocalsz - ISAKMP_ID_DATA_OFF; i++)
		if (!isprint (*(idlocal + ISAKMP_ID_DATA_OFF + i)))
		  break;
	      if (i >= idlocalsz - ISAKMP_ID_DATA_OFF)
	        {
		  memcpy (local_filter, idlocal + ISAKMP_ID_DATA_OFF,
			  idlocalsz - ISAKMP_ID_DATA_OFF);
		  break;
		}
	      /* Non-printable characters, convert to hex */
              for (i = 0; i < idlocalsz - ISAKMP_ID_DATA_OFF; i++)
	        {
		  local_filter[2 * i]
		    = hextab[*(idlocal + ISAKMP_ID_DATA_OFF) >> 4];
		  local_filter[2 * i + 1]
		    = hextab[*(idlocal + ISAKMP_ID_DATA_OFF) & 0xF];
	        }
	      break;

	    default:
	      log_print ("policy_callback: unknown Local ID type %u",
			 GET_ISAKMP_ID_TYPE (idlocal));
	      goto bad;
	    }

	  switch (idlocal[ISAKMP_GEN_SZ + 1])
	    {
	    case IPPROTO_TCP:
	      local_filter_proto = "tcp";
	      break;

	    case IPPROTO_UDP:
	      local_filter_proto = "udp";
	      break;
d1750 1
a1750 5
#ifdef IPPROTO_ETHERIP
	    case IPPROTO_ETHERIP:
	      local_filter_proto = "etherip";
	      break;
#endif
d1752 3
a1754 311
	    default:
	      snprintf (local_filter_proto_num, sizeof local_filter_proto_num,
			"%d", idlocal[ISAKMP_GEN_SZ + 1]);
	      local_filter_proto = local_filter_proto_num;
	      break;
	    }

	  snprintf (local_filter_port, sizeof local_filter_port, "%u",
		    decode_16 (idlocal + ISAKMP_GEN_SZ + 2));
	}
      else
        {
	  policy_sa->transport->vtbl->get_src (policy_sa->transport,
					       (struct sockaddr **)&sin);
	  switch (sin->sa_family)
	    {
	    case AF_INET:
	      local_filter_type = "IPv4 address";
	      break;
	    case AF_INET6:
	      local_filter_type = "IPv6 address";
	      break;
	    default:
	      log_print ("policy_callback: unsupported protocol family %d",
			 sin->sa_family);
	      goto bad;
	    }

	  if (sockaddr2text (sin, &addr, 1))
	    {
	      log_error ("policy_callback: sockaddr2text failed");
	      goto bad;
	    }
	  memcpy (local_filter_addr_upper, addr,
		  sizeof local_filter_addr_upper);
	  memcpy (local_filter_addr_lower, addr,
		  sizeof local_filter_addr_lower);
	  free (addr);
	  local_filter = strdup (local_filter_addr_upper);
	  if (!local_filter)
	    {
	      log_error ("policy_callback: strdup (\"%s\") failed",
			 local_filter_addr_upper);
	      goto bad;
	    }
        }

      LOG_DBG ((LOG_POLICY, 80, "Policy context (action attributes):"));
      LOG_DBG ((LOG_POLICY, 80, "esp_present == %s", esp_present));
      LOG_DBG ((LOG_POLICY, 80, "ah_present == %s", ah_present));
      LOG_DBG ((LOG_POLICY, 80, "comp_present == %s", comp_present));
      LOG_DBG ((LOG_POLICY, 80, "ah_hash_alg == %s", ah_hash_alg));
      LOG_DBG ((LOG_POLICY, 80, "esp_enc_alg == %s", esp_enc_alg));
      LOG_DBG ((LOG_POLICY, 80, "comp_alg == %s", comp_alg));
      LOG_DBG ((LOG_POLICY, 80, "ah_auth_alg == %s", ah_auth_alg));
      LOG_DBG ((LOG_POLICY, 80, "esp_auth_alg == %s", esp_auth_alg));
      LOG_DBG ((LOG_POLICY, 80, "ah_life_seconds == %s", ah_life_seconds));
      LOG_DBG ((LOG_POLICY, 80, "ah_life_kbytes == %s", ah_life_kbytes));
      LOG_DBG ((LOG_POLICY, 80, "esp_life_seconds == %s", esp_life_seconds));
      LOG_DBG ((LOG_POLICY, 80, "esp_life_kbytes == %s", esp_life_kbytes));
      LOG_DBG ((LOG_POLICY, 80, "comp_life_seconds == %s", comp_life_seconds));
      LOG_DBG ((LOG_POLICY, 80, "comp_life_kbytes == %s", comp_life_kbytes));
      LOG_DBG ((LOG_POLICY, 80, "ah_encapsulation == %s", ah_encapsulation));
      LOG_DBG ((LOG_POLICY, 80, "esp_encapsulation == %s", esp_encapsulation));
      LOG_DBG ((LOG_POLICY, 80, "comp_encapsulation == %s",
		comp_encapsulation));
      LOG_DBG ((LOG_POLICY, 80, "comp_dict_size == %s", comp_dict_size));
      LOG_DBG ((LOG_POLICY, 80, "comp_private_alg == %s", comp_private_alg));
      LOG_DBG ((LOG_POLICY, 80, "ah_key_length == %s", ah_key_length));
      LOG_DBG ((LOG_POLICY, 80, "ah_key_rounds == %s", ah_key_rounds));
      LOG_DBG ((LOG_POLICY, 80, "esp_key_length == %s", esp_key_length));
      LOG_DBG ((LOG_POLICY, 80, "esp_key_rounds == %s", esp_key_rounds));
      LOG_DBG ((LOG_POLICY, 80, "ah_group_desc == %s", ah_group_desc));
      LOG_DBG ((LOG_POLICY, 80, "esp_group_desc == %s", esp_group_desc));
      LOG_DBG ((LOG_POLICY, 80, "comp_group_desc == %s", comp_group_desc));
      LOG_DBG ((LOG_POLICY, 80, "ah_ecn == %s", ah_ecn));
      LOG_DBG ((LOG_POLICY, 80, "esp_ecn == %s", esp_ecn));
      LOG_DBG ((LOG_POLICY, 80, "comp_ecn == %s", comp_ecn));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_type == %s",
		remote_filter_type));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_addr_upper == %s",
		remote_filter_addr_upper));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_addr_lower == %s",
		remote_filter_addr_lower));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter == %s",
		(remote_filter ? remote_filter : "")));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_port == %s",
		remote_filter_port));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_proto == %s",
		remote_filter_proto));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_type == %s", local_filter_type));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_addr_upper == %s",
		local_filter_addr_upper));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_addr_lower == %s",
		local_filter_addr_lower));
      LOG_DBG ((LOG_POLICY, 80, "local_filter == %s",
		(local_filter ? local_filter : "")));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_port == %s", local_filter_port));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_proto == %s",
		local_filter_proto));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_type == %s", remote_id_type));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_addr_upper == %s",
		remote_id_addr_upper));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_addr_lower == %s",
		remote_id_addr_lower));
      LOG_DBG ((LOG_POLICY, 80, "remote_id == %s",
		(remote_id ? remote_id : "")));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_port == %s", remote_id_port));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_proto == %s", remote_id_proto));
      LOG_DBG ((LOG_POLICY, 80, "remote_negotiation_address == %s",
		remote_ike_address));
      LOG_DBG ((LOG_POLICY, 80, "local_negotiation_address == %s",
		local_ike_address));
      LOG_DBG ((LOG_POLICY, 80, "pfs == %s", pfs));
      LOG_DBG ((LOG_POLICY, 80, "initiator == %s", initiator));
      LOG_DBG ((LOG_POLICY, 80, "phase1_group_desc == %s", phase1_group));

      /* Unset dirty now.  */
      dirty = 0;
    }

  if (strcmp (name, "phase_1") == 0)
    return phase_1;

  if (strcmp (name, "GMTTimeOfDay") == 0)
    {
      tt = time ((time_t) NULL);
      strftime (mytimeofday, 14, "%Y%m%d%H%M%S", gmtime (&tt));
      return mytimeofday;
    }

  if (strcmp (name, "LocalTimeOfDay") == 0)
    {
      tt = time ((time_t) NULL);
      strftime (mytimeofday, 14, "%Y%m%d%H%M%S", localtime (&tt));
      return mytimeofday;
    }

  if (strcmp (name, "initiator") == 0)
    return initiator;

  if (strcmp (name, "pfs") == 0)
    return pfs;

  if (strcmp (name, "app_domain") == 0)
    return "IPsec policy";

  if (strcmp (name, "doi") == 0)
    return "ipsec";

  if (strcmp (name, "esp_present") == 0)
    return esp_present;

  if (strcmp (name, "ah_present") == 0)
    return ah_present;

  if (strcmp (name, "comp_present") == 0)
    return comp_present;

  if (strcmp (name, "ah_hash_alg") == 0)
    return ah_hash_alg;

  if (strcmp (name, "ah_auth_alg") == 0)
    return ah_auth_alg;

  if (strcmp (name, "esp_auth_alg") == 0)
    return esp_auth_alg;

  if (strcmp (name, "esp_enc_alg") == 0)
    return esp_enc_alg;

  if (strcmp (name, "comp_alg") == 0)
    return comp_alg;

  if (strcmp (name, "ah_life_kbytes") == 0)
    return ah_life_kbytes;

  if (strcmp (name, "ah_life_seconds") == 0)
    return ah_life_seconds;

  if (strcmp (name, "esp_life_kbytes") == 0)
    return esp_life_kbytes;

  if (strcmp (name, "esp_life_seconds") == 0)
    return esp_life_seconds;

  if (strcmp (name, "comp_life_kbytes") == 0)
    return comp_life_kbytes;

  if (strcmp (name, "comp_life_seconds") == 0)
    return comp_life_seconds;

  if (strcmp (name, "ah_encapsulation") == 0)
    return ah_encapsulation;

  if (strcmp (name, "esp_encapsulation") == 0)
    return esp_encapsulation;

  if (strcmp (name, "comp_encapsulation") == 0)
    return comp_encapsulation;

  if (strcmp (name, "ah_key_length") == 0)
    return ah_key_length;

  if (strcmp (name, "ah_key_rounds") == 0)
    return ah_key_rounds;

  if (strcmp (name, "esp_key_length") == 0)
    return esp_key_length;

  if (strcmp (name, "esp_key_rounds") == 0)
    return esp_key_rounds;

  if (strcmp (name, "comp_dict_size") == 0)
    return comp_dict_size;

  if (strcmp (name, "comp_private_alg") == 0)
    return comp_private_alg;

  if (strcmp (name, "remote_filter_type") == 0)
    return remote_filter_type;

  if (strcmp (name, "remote_filter") == 0)
    return (remote_filter ? remote_filter : "");

  if (strcmp (name, "remote_filter_addr_upper") == 0)
    return remote_filter_addr_upper;

  if (strcmp (name, "remote_filter_addr_lower") == 0)
    return remote_filter_addr_lower;

  if (strcmp (name, "remote_filter_port") == 0)
    return remote_filter_port;

  if (strcmp (name, "remote_filter_proto") == 0)
    return remote_filter_proto;

  if (strcmp (name, "local_filter_type") == 0)
    return local_filter_type;

  if (strcmp (name, "local_filter") == 0)
    return (local_filter ? local_filter : "");

  if (strcmp (name, "local_filter_addr_upper") == 0)
    return local_filter_addr_upper;

  if (strcmp (name, "local_filter_addr_lower") == 0)
    return local_filter_addr_lower;

  if (strcmp (name, "local_filter_port") == 0)
    return local_filter_port;

  if (strcmp (name, "local_filter_proto") == 0)
    return local_filter_proto;

  if (strcmp (name, "remote_ike_address") == 0)
    return remote_ike_address;

  if (strcmp (name, "remote_negotiation_address") == 0)
    return remote_ike_address;

  if (strcmp (name, "local_ike_address") == 0)
    return local_ike_address;

  if (strcmp (name, "local_negotiation_address") == 0)
    return local_ike_address;

  if (strcmp (name, "remote_id_type") == 0)
    return remote_id_type;

  if (strcmp (name, "remote_id") == 0)
    return (remote_id ? remote_id : "");

  if (strcmp (name, "remote_id_addr_upper") == 0)
    return remote_id_addr_upper;

  if (strcmp (name, "remote_id_addr_lower") == 0)
    return remote_id_addr_lower;

  if (strcmp (name, "remote_id_port") == 0)
    return remote_id_port;

  if (strcmp (name, "remote_id_proto") == 0)
    return remote_id_proto;

  if (strcmp (name, "phase1_group_desc") == 0)
    return phase1_group;

  if (strcmp (name, "esp_group_desc") == 0)
    return esp_group_desc;

  if (strcmp (name, "ah_group_desc") == 0)
    return ah_group_desc;

  if (strcmp (name, "comp_group_desc") == 0)
    return comp_group_desc;

  if (strcmp (name, "comp_ecn") == 0)
    return comp_ecn;

  if (strcmp (name, "ah_ecn") == 0)
    return ah_ecn;

  if (strcmp (name, "esp_ecn") == 0)
    return esp_ecn;

  return "";

 bad:
  policy_callback (KEYNOTE_CALLBACK_INITIALIZE);
  return "";
d1758 1
a1758 1
policy_init (void)
d1760 34
a1793 54
  char *ptr, *policy_file;
  char **asserts;
  size_t sz;
  int fd, len, i;

  LOG_DBG ((LOG_POLICY, 30, "policy_init: initializing"));

  /* Get policy file from configuration.  */
  policy_file = conf_get_str ("General", "Policy-file");
  if (!policy_file)
    policy_file = CONF_DFLT_POLICY_FILE;

  /* Check file modes and collect file size */
  if (check_file_secrecy (policy_file, &sz))
    log_fatal ("policy_init: cannot read %s", policy_file);

  /* Open policy file.  */
  fd = monitor_open (policy_file, O_RDONLY, 0);
  if (fd == -1)
    log_fatal ("policy_init: open (\"%s\", O_RDONLY) failed", policy_file);

  /* Allocate memory to keep policies.  */
  ptr = calloc (sz + 1, sizeof (char));
  if (!ptr)
    log_fatal ("policy_init: calloc (%lu, %lu) failed", (unsigned long)sz + 1,
	       (unsigned long)sizeof (char));

  /* Just in case there are short reads...  */
  for (len = 0; len < sz; len += i)
    {
      i = read (fd, ptr + len, sz - len);
      if (i == -1)
	log_fatal ("policy_init: read (%d, %p, %lu) failed", fd, ptr + len,
		   (unsigned long)(sz - len));
    }

  /* We're done with this.  */
  close (fd);

  /* Parse buffer, break up into individual policies.  */
  asserts = kn_read_asserts (ptr, sz, &i);

  /* Begone!  */
  free (ptr);

  if (asserts == (char **) NULL)
    log_print ("policy_init: all policies flushed");

  /* Cleanup */
  if (keynote_policy_asserts)
    {
      for (fd = 0; fd < keynote_policy_asserts_num; fd++)
        if (keynote_policy_asserts && keynote_policy_asserts[fd])
          free (keynote_policy_asserts[fd]);
d1795 2
a1796 2
      free (keynote_policy_asserts);
    }
d1798 19
a1816 2
  keynote_policy_asserts = asserts;
  keynote_policy_asserts_num = i;
d1821 1
a1821 1
keynote_cert_init (void)
d1823 1
a1823 1
  return 1;
d1827 2
a1828 2
void *
keynote_cert_get (u_int8_t *data, u_int32_t len)
d1830 1
a1830 1
  char *foo = malloc (len + 1);
d1832 2
a1833 2
  if (foo == NULL)
    return NULL;
d1835 3
a1837 3
  memcpy (foo, data, len);
  foo[len] = '\0';
  return foo;
d1845 1
a1845 1
keynote_cert_validate (void *scert)
d1847 2
a1848 2
  char **foo;
  int num, i;
d1850 2
a1851 2
  if (scert == NULL)
    return 0;
d1853 13
a1865 13
  foo = kn_read_asserts ((char *) scert, strlen ((char *) scert), &num);
  if (foo == NULL)
    return 0;

  for (i = 0; i < num; i++)
    {
      if (kn_verify_assertion (scert, strlen ((char *) scert))
	  != SIGRESULT_TRUE)
        {
	  for (; i < num; i++)
	    free (foo[i]);
	  free (foo);
	  return 0;
d1868 2
a1869 5
      free (foo[i]);
    }

  free (foo);
  return 1;
d1874 1
a1874 1
keynote_cert_insert (int sid, void *scert)
d1876 2
a1877 2
  char **foo;
  int num;
d1879 2
a1880 2
  if (scert == NULL)
    return 0;
d1882 3
a1884 3
  foo = kn_read_asserts ((char *) scert, strlen ((char *) scert), &num);
  if (foo == NULL)
    return 0;
d1886 2
a1887 2
  while (num--)
    kn_add_assertion (sid, foo[num], strlen (foo[num]), 0);
d1889 1
a1889 1
  return 1;
d1894 1
a1894 1
keynote_cert_free (void *cert)
d1896 1
a1896 1
  free (cert);
d1901 1
a1901 1
keynote_certreq_validate (u_int8_t *data, u_int32_t len)
d1903 11
a1913 13
  struct keynote_deckey dc;
  int err = 1;
  char *dat;

  dat = calloc (len + 1, sizeof (char));
  if (!dat)
    {
      log_error ("keynote_certreq_validate: calloc (%d, %lu) failed", len + 1,
		 (unsigned long)sizeof (char));
	return 0;
    }

  memcpy (dat, data, len);
d1915 4
a1918 4
  if (kn_decode_key (&dc, dat, KEYNOTE_PUBLIC_KEY) != 0)
    err = 0;
  else
    kn_free_key (&dc);
d1920 1
a1920 1
  free (dat);
d1922 1
a1922 1
  return err;
d1926 2
a1927 2
void *
keynote_certreq_decode (u_int8_t *data, u_int32_t len)
d1929 2
a1930 2
  /* XXX */
  return NULL;
d1934 1
a1934 1
keynote_free_aca (void *blob)
d1936 1
a1936 1
  /* XXX */
d1940 2
a1941 2
keynote_cert_obtain (u_int8_t *id, size_t id_len, void *data, u_int8_t **cert,
		     u_int32_t *certlen)
d1943 69
a2011 34
  char *dirname, *file, *addr_str;
  struct stat sb;
  size_t size;
  int idtype, fd, len;

  if (!id)
    {
      log_print ("keynote_cert_obtain: ID is missing");
      return 0;
    }

  /* Get type of ID.  */
  idtype = id[0];
  id += ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
  id_len -= ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;

  dirname = conf_get_str ("KeyNote", "Credential-directory");
  if (!dirname)
    {
      LOG_DBG ((LOG_POLICY, 30,
		"keynote_cert_obtain: no Credential-directory"));
      return 0;
    }

  len = strlen (dirname) + strlen (CREDENTIAL_FILE) + 3;

  switch (idtype)
    {
    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV6_ADDR:
      util_ntoa (&addr_str, idtype == IPSEC_ID_IPV4_ADDR ? AF_INET : AF_INET6,
		 id);
      if (addr_str == 0)
	return 0;
d2013 25
a2037 76
      file = calloc (len + strlen (addr_str), sizeof (char));
      if (file == NULL)
	{
	  log_error ("keynote_cert_obtain: failed to allocate %lu bytes",
		     (unsigned long)len + strlen (addr_str));
	  free (addr_str);
	  return 0;
	}

      snprintf (file, len + strlen (addr_str), "%s/%s/%s", dirname, addr_str,
		CREDENTIAL_FILE);
      free (addr_str);
      break;

    case IPSEC_ID_FQDN:
    case IPSEC_ID_USER_FQDN:
      {
        file = calloc (len + id_len, sizeof (char));
	if (file == NULL)
	  {
	    log_error ("keynote_cert_obtain: failed to allocate %lu bytes",
		       (unsigned long)len + id_len);
	    return 0;
	  }

	snprintf (file, len + id_len, "%s/", dirname);
	memcpy (file + strlen (dirname) + 1, id, id_len);
	snprintf (file + strlen (dirname) + 1 + id_len,
		  len - strlen (dirname) - 1, "/%s", CREDENTIAL_FILE);
	break;
      }

    default:
      return 0;
    }

  if (stat (file, &sb) < 0)
    {
      LOG_DBG ((LOG_POLICY, 30, "keynote_cert_obtain: failed to stat \"%s\"",
		file));
      free (file);
      return 0;
    }
  size = (size_t)sb.st_size;

  *cert = calloc (size + 1, sizeof (char));
  if (*cert == NULL)
    {
      log_error ("keynote_cert_obtain: failed to allocate %lu bytes",
		 (unsigned long)size);
      free (file);
      return 0;
    }

  fd = open (file, O_RDONLY, 0);
  if (fd < 0)
    {
      LOG_DBG ((LOG_POLICY, 30, "keynote_cert_obtain: failed to open \"%s\"",
		file));
      free (file);
      return 0;
    }

  if (read (fd, *cert, size) != size)
    {
      LOG_DBG ((LOG_POLICY, 30, "keynote_cert_obtain: failed to read %lu "
		"bytes from \"%s\"", (unsigned long)size, file));
      free (file);
      close (fd);
      return 0;
    }

  close (fd);
  free (file);
  *certlen = size;
  return 1;
d2042 2
a2043 2
keynote_cert_get_subjects (void *scert, int *n, u_int8_t ***id,
			   u_int32_t **id_len)
d2045 1
a2045 1
  return 0;
d2050 1
a2050 1
keynote_cert_get_key (void *scert, void *keyp)
d2052 42
a2093 51
  struct keynote_keylist *kl;
  int sid, kid, num;
  char **foo;

  foo = kn_read_asserts ((char *)scert, strlen ((char *)scert), &num);
  if (foo == NULL || num == 0)
    {
      log_print ("keynote_cert_get_key: failed to decompose credentials");
      return 0;
    }

  kid = kn_init ();
  if (kid == -1)
    {
      log_print ("keynote_cert_get_key: failed to initialize new policy "
		 "session");
      while (num--)
	free (foo[num]);
      free (foo);
      return 0;
    }

  sid = kn_add_assertion (kid, foo[num - 1], strlen (foo[num - 1]), 0);
  while (num--)
    free (foo[num]);
  free (foo);

  if (sid == -1)
    {
      log_print ("keynote_cert_get_key: failed to add assertion");
      kn_close (kid);
      return 0;
    }

  *(RSA **)keyp = NULL;

  kl = kn_get_licensees (kid, sid);
  while (kl)
    {
      if (kl->key_alg == KEYNOTE_ALGORITHM_RSA)
	{
	  *(RSA **)keyp = RSAPublicKey_dup (kl->key_key);
	  break;
	}

      kl = kl->key_next;
    }

  kn_remove_assertion (kid, sid);
  kn_close (kid);
  return *(RSA **)keyp == NULL ? 0 : 1;
d2097 1
a2097 1
keynote_cert_dup (void *cert)
d2099 1
a2099 1
  return strdup ((char *)cert);
d2103 1
a2103 1
keynote_serialize (void *cert, u_int8_t **data, u_int32_t *datalen)
d2105 5
a2109 4
  *datalen = strlen ((char *)cert) + 1;
  *data = (u_int8_t *)strdup (cert); /* i.e an extra character at the end... */
  if (*data == NULL)
    log_error ("keynote_serialize: malloc (%d) failed", *datalen);
d2114 1
a2114 1
keynote_printable (void *cert)
d2116 1
a2116 1
  return strdup ((char *)cert);
d2121 1
a2121 1
keynote_from_printable (char *cert)
d2123 1
a2123 1
  return strdup (cert);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.57 2002/11/14 16:38:05 ho Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d64 1
d246 1
a246 1
      snprintf (phase1_group, PMAX, "%u", is->group_desc);
d269 12
d305 1
d403 2
a404 2
			    snprintf (ah_life_seconds, PMAX, "%u",
				      decode_16 (value));
d406 2
a407 2
			    snprintf (ah_life_seconds, PMAX, "%u",
				      decode_32 (value));
d412 2
a413 2
			    snprintf (ah_life_kbytes, PMAX, "%u",
				      decode_16 (value));
d415 2
a416 2
			    snprintf (ah_life_kbytes, PMAX, "%u",
				      decode_32 (value));
d425 2
a426 1
			    snprintf (esp_life_seconds, PMAX, "%u",
d429 2
a430 1
			    snprintf (esp_life_seconds, PMAX, "%u",
d436 2
a437 1
			    snprintf (esp_life_kbytes, PMAX, "%u",
d440 2
a441 1
			    snprintf (esp_life_kbytes, PMAX, "%u",
d451 2
a452 1
			    snprintf (comp_life_seconds, PMAX, "%u",
d455 2
a456 1
			    snprintf (comp_life_seconds, PMAX, "%u",
d462 2
a463 1
			    snprintf (comp_life_kbytes, PMAX, "%u",
d466 2
a467 1
			    snprintf (comp_life_kbytes, PMAX, "%u",
d479 2
a480 1
		      snprintf (ah_group_desc, PMAX, "%u", decode_16 (value));
d484 1
a484 1
		      snprintf (esp_group_desc, PMAX, "%u",
d489 1
a489 1
		      snprintf (comp_group_desc, PMAX, "%u",
d563 12
d600 12
d628 2
a629 1
		      snprintf (ah_key_length, PMAX, "%u", decode_16 (value));
d633 1
a633 1
		      snprintf (esp_key_length, PMAX, "%u",
d643 2
a644 1
		      snprintf (ah_key_rounds, PMAX, "%u", decode_16 (value));
d648 1
a648 1
		      snprintf (esp_key_rounds, PMAX, "%u",
d655 2
a656 1
		  snprintf (comp_dict_size, PMAX, "%u", decode_16 (value));
d660 2
a661 1
		  snprintf (comp_private_alg, PMAX, "%u", decode_16 (value));
d719 1
a719 1
  	    {
d784 1
a784 1
  	    {
d823 2
a824 2
	  bcopy (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, &net, sizeof (net));
	  bcopy (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 16, &mask,
d956 3
a958 2
 	default:
	  snprintf (remote_id_proto_num, 3, "%d", id[1]);
d963 1
a963 1
      snprintf (remote_id_port, sizeof remote_id_port - 1, "%u",
d1102 2
a1103 2
	      bcopy (idremote + ISAKMP_ID_DATA_OFF, &net, sizeof (net));
	      bcopy (idremote + ISAKMP_ID_DATA_OFF + 16, &mask, sizeof (mask));
d1232 4
a1235 3
 	    default:
	      snprintf (remote_filter_proto_num, 3, "%d",
		       idremote[ISAKMP_GEN_SZ + 1]);
d1240 2
a1241 2
	  snprintf (remote_filter_port, sizeof remote_filter_port - 1,
		    "%u", decode_16 (idremote + ISAKMP_GEN_SZ + 2));
d1395 2
a1396 2
	      bcopy (idlocal + ISAKMP_ID_DATA_OFF, &net, sizeof (net));
	      bcopy (idlocal + ISAKMP_ID_DATA_OFF + 16, &mask, sizeof (mask));
d1525 3
a1527 3
 	    default:
	      snprintf (local_filter_proto_num, 3, "%d",
		       idlocal[ISAKMP_GEN_SZ + 1]);
d1532 2
a1533 2
	  snprintf (local_filter_port, sizeof local_filter_port - 1,
		    "%u", decode_16 (idlocal + ISAKMP_GEN_SZ + 2));
d1851 1
a1851 1
    policy_file = POLICY_FILE_DEFAULT;
d1858 1
a1858 1
  fd = open (policy_file, O_RDONLY);
d2213 1
a2213 1
  return strdup((char *)cert);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.62 2003/05/18 19:37:47 ho Exp $	*/
a68 1
#include "monitor.h"
a296 1
		case IPSEC_ESP_AES_128_CTR:
d1803 1
a1803 1
    policy_file = CONF_DFLT_POLICY_FILE;
d1810 1
a1810 1
  fd = monitor_open (policy_file, O_RDONLY, 0);
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.64 2003/06/04 07:31:17 ho Exp $	*/
d17 5
d251 1
a251 1
      snprintf (phase1_group, sizeof phase1_group, "%u", is->group_desc);
d396 2
a397 2
			    snprintf (ah_life_seconds, sizeof ah_life_seconds,
				      "%u", decode_16 (value));
d399 2
a400 2
			    snprintf (ah_life_seconds, sizeof ah_life_seconds,
				      "%u", decode_32 (value));
d405 2
a406 2
			    snprintf (ah_life_kbytes, sizeof ah_life_kbytes,
				      "%u", decode_16 (value));
d408 2
a409 2
			    snprintf (ah_life_kbytes, sizeof ah_life_kbytes,
				      "%u", decode_32 (value));
d418 1
a418 2
			    snprintf (esp_life_seconds,
				      sizeof esp_life_seconds, "%u",
d421 1
a421 2
			    snprintf (esp_life_seconds,
				      sizeof esp_life_seconds, "%u",
d427 1
a427 2
			    snprintf (esp_life_kbytes,
				      sizeof esp_life_kbytes, "%u",
d430 1
a430 2
			    snprintf (esp_life_kbytes,
				      sizeof esp_life_kbytes, "%u",
d440 1
a440 2
			    snprintf (comp_life_seconds,
				      sizeof comp_life_seconds, "%u",
d443 1
a443 2
			    snprintf (comp_life_seconds,
				      sizeof comp_life_seconds, "%u",
d449 1
a449 2
			    snprintf (comp_life_kbytes,
				      sizeof comp_life_kbytes, "%u",
d452 1
a452 2
			    snprintf (comp_life_kbytes,
				      sizeof comp_life_kbytes, "%u",
d464 1
a464 2
		      snprintf (ah_group_desc, sizeof ah_group_desc, "%u",
				decode_16 (value));
d468 1
a468 1
		      snprintf (esp_group_desc, sizeof esp_group_desc, "%u",
d473 1
a473 1
		      snprintf (comp_group_desc, sizeof comp_group_desc, "%u",
d588 1
a588 2
		      snprintf (ah_key_length, sizeof ah_key_length, "%u",
				decode_16 (value));
d592 1
a592 1
		      snprintf (esp_key_length, sizeof esp_key_length, "%u",
d602 1
a602 2
		      snprintf (ah_key_rounds, sizeof ah_key_rounds, "%u",
				decode_16 (value));
d606 1
a606 1
		      snprintf (esp_key_rounds, sizeof esp_key_rounds, "%u",
d613 1
a613 2
		  snprintf (comp_dict_size, sizeof comp_dict_size, "%u",
			    decode_16 (value));
d617 1
a617 2
		  snprintf (comp_private_alg, sizeof comp_private_alg, "%u",
			    decode_16 (value));
d913 1
a913 2
	  snprintf (remote_id_proto_num, sizeof remote_id_proto_num, "%d",
		    id[1]);
d918 1
a918 1
      snprintf (remote_id_port, sizeof remote_id_port, "%u",
d1188 2
a1189 3
	      snprintf (remote_filter_proto_num,
			sizeof remote_filter_proto_num, "%d",
			idremote[ISAKMP_GEN_SZ + 1]);
d1194 2
a1195 2
	  snprintf (remote_filter_port, sizeof remote_filter_port, "%u",
		    decode_16 (idremote + ISAKMP_GEN_SZ + 2));
d1480 2
a1481 2
	      snprintf (local_filter_proto_num, sizeof local_filter_proto_num,
			"%d", idlocal[ISAKMP_GEN_SZ + 1]);
d1486 2
a1487 2
	  snprintf (local_filter_port, sizeof local_filter_port, "%u",
		    decode_16 (idlocal + ISAKMP_GEN_SZ + 2));
@


1.1.1.4
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.65 2003/06/10 16:41:29 deraadt Exp $	*/
d683 1
a683 1
	    {
d748 1
a748 1
	    {
d920 1
a920 1
	default:
d1196 1
a1196 1
	    default:
d1489 1
a1489 1
	    default:
@


1.1.1.5
log
@Import latest OpenBSD ports, XFree and source in sync
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.66 2003/07/25 08:31:16 markus Exp $	*/
a268 12
		case IPSEC_AH_SHA2_256:
		  ah_auth_alg = "sha2-256";
		  break;

		case IPSEC_AH_SHA2_384:
		  ah_auth_alg = "sha2-384";
		  break;

		case IPSEC_AH_SHA2_512:
		  ah_auth_alg = "sha2-512";
		  break;

a550 12
			case IPSEC_AUTH_HMAC_SHA2_256:
			  ah_auth_alg = "hmac-sha2-256";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_384:
			  ah_auth_alg = "hmac-sha2-384";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_512:
			  ah_auth_alg = "hmac-sha2-512";
			  break;

a573 12
			  break;

			case IPSEC_AUTH_HMAC_SHA2_256:
			  esp_auth_alg = "hmac-sha2-256";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_384:
			  esp_auth_alg = "hmac-sha2-384";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_512:
			  esp_auth_alg = "hmac-sha2-512";
@


1.1.1.6
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.67 2003/11/06 16:12:08 ho Exp $	*/
d2213 1
a2213 1
  return strdup ((char *)cert);
@


1.1.1.7
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 2
a2 2
/* $OpenBSD: policy.c,v 1.71 2004/04/28 20:20:31 hshoexer Exp $	 */
/* $EOM: policy.c,v 1.49 2000/10/24 13:33:39 niklas Exp $ */
d69 2
a70 2
char          **policy_asserts = NULL;
int             policy_asserts_num = 0;
d72 2
a73 2
struct sa      *policy_sa = 0;
struct sa      *policy_isakmp_sa = 0;
d76 2
a77 2
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
d84 1
a84 1
my_inet_ntop4(const in_addr_t * src, char *dst, size_t size, int normalize)
d86 18
a103 17
	static const char fmt[] = "%03u.%03u.%03u.%03u";
	char            tmp[sizeof "255.255.255.255"];
	in_addr_t       src2;

	if (normalize)
		src2 = ntohl(*src);
	else
		src2 = *src;

	if (snprintf(tmp, sizeof tmp, fmt, ((u_int8_t *)&src2)[0],
	    ((u_int8_t *)&src2)[1], ((u_int8_t *)&src2)[2],
	    ((u_int8_t *)&src2)[3]) > (int)size) {
		errno = ENOSPC;
		return 0;
	}
	strlcpy(dst, tmp, size);
	return dst;
d107 1
a107 1
my_inet_ntop6(const unsigned char *src, char *dst, size_t size)
d109 12
a120 12
	static const char fmt[] =
	    "%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x";
	char            tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"];

	if (snprintf(tmp, sizeof tmp, fmt, src[0], src[1], src[2], src[3], src[4],
	    src[5], src[6], src[7], src[8], src[9], src[10], src[11],
	    src[12], src[13], src[14], src[15]) > (int)size) {
		errno = ENOSPC;
		return 0;
	}
	strlcpy(dst, tmp, size);
	return dst;
d124 1
a124 1
policy_callback(char *name)
d126 1
a126 1
	struct proto   *proto;
d128 11
a138 12
	u_int8_t       *attr, *value, *id, *idlocal, *idremote;
	size_t          id_sz, idlocalsz, idremotesz;
	struct sockaddr *sin;
	struct ipsec_exch *ie;
	struct ipsec_sa *is;
	size_t          i;
	int             fmt, lifetype = 0;
	in_addr_t       net, subnet;
	u_int16_t       len, type;
	time_t          tt;
	char           *addr;
	static char     mytimeofday[15];
d140 1
a140 1
	/* We use all these as a cache.  */
d142 143
a284 82
	static char    *esp_present, *ah_present, *comp_present;
	static char    *ah_hash_alg, *ah_auth_alg, *esp_auth_alg, *esp_enc_alg;
	static char    *comp_alg, ah_life_kbytes[PMAX], ah_life_seconds[PMAX];
	static char     esp_life_kbytes[PMAX], esp_life_seconds[PMAX];
	static char     comp_life_kbytes[PMAX];
	static char    *ah_ecn, *esp_ecn, *comp_ecn;
	static char     comp_life_seconds[PMAX], *ah_encapsulation, *esp_encapsulation;
	static char    *comp_encapsulation, ah_key_length[PMAX], esp_key_length[PMAX];
	static char     ah_key_rounds[PMAX], esp_key_rounds[PMAX], comp_dict_size[PMAX];
	static char     comp_private_alg[PMAX], *remote_filter_type, *local_filter_type;
	static char     remote_filter_addr_upper[NI_MAXHOST];
	static char     remote_filter_addr_lower[NI_MAXHOST];
	static char     local_filter_addr_upper[NI_MAXHOST];
	static char     local_filter_addr_lower[NI_MAXHOST];
	static char     ah_group_desc[PMAX], esp_group_desc[PMAX], comp_group_desc[PMAX];
	static char     remote_ike_address[NI_MAXHOST];
	static char     local_ike_address[NI_MAXHOST];
	static char    *remote_id_type, remote_id_addr_upper[NI_MAXHOST],
	               *phase_1;
	static char     remote_id_addr_lower[NI_MAXHOST];
	static char    *remote_id_proto, remote_id_port[PMAX];
	static char     remote_filter_port[PMAX], local_filter_port[PMAX];
	static char    *remote_filter_proto, *local_filter_proto, *pfs,
	               *initiator;
	static char     remote_filter_proto_num[3], local_filter_proto_num[3];
	static char     remote_id_proto_num[3];
	static char     phase1_group[PMAX];

	/* Allocated.  */
	static char    *remote_filter = 0, *local_filter = 0, *remote_id = 0;

	static int      dirty = 1;

	/* We only need to set dirty at initialization time really.  */
	if (strcmp(name, KEYNOTE_CALLBACK_CLEANUP) == 0
	    || strcmp(name, KEYNOTE_CALLBACK_INITIALIZE) == 0) {
		esp_present = ah_present = comp_present = pfs = "no";
		ah_hash_alg = ah_auth_alg = phase_1 = "";
		esp_auth_alg = esp_enc_alg = comp_alg = ah_encapsulation = "";
		ah_ecn = esp_ecn = comp_ecn = "no";
		esp_encapsulation = comp_encapsulation = remote_filter_type = "";
		local_filter_type = remote_id_type = initiator = "";
		remote_filter_proto = local_filter_proto = remote_id_proto = "";

		if (remote_filter != 0) {
			free(remote_filter);
			remote_filter = 0;
		}
		if (local_filter != 0) {
			free(local_filter);
			local_filter = 0;
		}
		if (remote_id != 0) {
			free(remote_id);
			remote_id = 0;
		}
		memset(remote_ike_address, 0, sizeof remote_ike_address);
		memset(local_ike_address, 0, sizeof local_ike_address);
		memset(ah_life_kbytes, 0, sizeof ah_life_kbytes);
		memset(ah_life_seconds, 0, sizeof ah_life_seconds);
		memset(esp_life_kbytes, 0, sizeof esp_life_kbytes);
		memset(esp_life_seconds, 0, sizeof esp_life_seconds);
		memset(comp_life_kbytes, 0, sizeof comp_life_kbytes);
		memset(comp_life_seconds, 0, sizeof comp_life_seconds);
		memset(ah_key_length, 0, sizeof ah_key_length);
		memset(ah_key_rounds, 0, sizeof ah_key_rounds);
		memset(esp_key_length, 0, sizeof esp_key_length);
		memset(esp_key_rounds, 0, sizeof esp_key_rounds);
		memset(comp_dict_size, 0, sizeof comp_dict_size);
		memset(comp_private_alg, 0, sizeof comp_private_alg);
		memset(remote_filter_addr_upper, 0, sizeof remote_filter_addr_upper);
		memset(remote_filter_addr_lower, 0, sizeof remote_filter_addr_lower);
		memset(local_filter_addr_upper, 0, sizeof local_filter_addr_upper);
		memset(local_filter_addr_lower, 0, sizeof local_filter_addr_lower);
		memset(remote_id_addr_upper, 0, sizeof remote_id_addr_upper);
		memset(remote_id_addr_lower, 0, sizeof remote_id_addr_lower);
		memset(ah_group_desc, 0, sizeof ah_group_desc);
		memset(esp_group_desc, 0, sizeof esp_group_desc);
		memset(remote_id_port, 0, sizeof remote_id_port);
		memset(remote_filter_port, 0, sizeof remote_filter_port);
		memset(local_filter_port, 0, sizeof local_filter_port);
		memset(phase1_group, 0, sizeof phase1_group);
d286 1
a286 127
		dirty = 1;
		return "";
	}
	/*
	 * If dirty is set, this is the first request for an attribute, so
	 * populate our value cache.
         */
	if (dirty) {
		ie = policy_exchange->data;

		if (ie->pfs)
			pfs = "yes";

		is = policy_isakmp_sa->data;
		snprintf(phase1_group, sizeof phase1_group, "%u", is->group_desc);

		for (proto = TAILQ_FIRST(&policy_sa->protos); proto;
		    proto = TAILQ_NEXT(proto, link)) {
			switch (proto->proto) {
			case IPSEC_PROTO_IPSEC_AH:
				ah_present = "yes";
				switch (proto->id) {
				case IPSEC_AH_MD5:
					ah_hash_alg = "md5";
					break;

				case IPSEC_AH_SHA:
					ah_hash_alg = "sha";
					break;

				case IPSEC_AH_RIPEMD:
					ah_hash_alg = "ripemd";
					break;

				case IPSEC_AH_SHA2_256:
					ah_auth_alg = "sha2-256";
					break;

				case IPSEC_AH_SHA2_384:
					ah_auth_alg = "sha2-384";
					break;

				case IPSEC_AH_SHA2_512:
					ah_auth_alg = "sha2-512";
					break;

				case IPSEC_AH_DES:
					ah_hash_alg = "des";
					break;
				}

				break;

			case IPSEC_PROTO_IPSEC_ESP:
				esp_present = "yes";
				switch (proto->id) {
				case IPSEC_ESP_DES_IV64:
					esp_enc_alg = "des-iv64";
					break;

				case IPSEC_ESP_DES:
					esp_enc_alg = "des";
					break;

				case IPSEC_ESP_3DES:
					esp_enc_alg = "3des";
					break;

				case IPSEC_ESP_AES:
				case IPSEC_ESP_AES_128_CTR:
					esp_enc_alg = "aes";
					break;

				case IPSEC_ESP_RC5:
					esp_enc_alg = "rc5";
					break;

				case IPSEC_ESP_IDEA:
					esp_enc_alg = "idea";
					break;

				case IPSEC_ESP_CAST:
					esp_enc_alg = "cast";
					break;

				case IPSEC_ESP_BLOWFISH:
					esp_enc_alg = "blowfish";
					break;

				case IPSEC_ESP_3IDEA:
					esp_enc_alg = "3idea";
					break;

				case IPSEC_ESP_DES_IV32:
					esp_enc_alg = "des-iv32";
					break;

				case IPSEC_ESP_RC4:
					esp_enc_alg = "rc4";
					break;

				case IPSEC_ESP_NULL:
					esp_enc_alg = "null";
					break;
				}

				break;

			case IPSEC_PROTO_IPCOMP:
				comp_present = "yes";
				switch (proto->id) {
				case IPSEC_IPCOMP_OUI:
					comp_alg = "oui";
					break;

				case IPSEC_IPCOMP_DEFLATE:
					comp_alg = "deflate";
					break;

				case IPSEC_IPCOMP_LZS:
					comp_alg = "lzs";
					break;

				case IPSEC_IPCOMP_V42BIS:
					comp_alg = "v42bis";
					break;
				}
d288 52
a339 287
				break;
			}

			for (attr = proto->chosen->p + ISAKMP_TRANSFORM_SA_ATTRS_OFF;
			    attr < proto->chosen->p +
			    GET_ISAKMP_GEN_LENGTH(proto->chosen->p);
			    attr = value + len) {
				if (attr + ISAKMP_ATTR_VALUE_OFF >
				    (proto->chosen->p +
				    GET_ISAKMP_GEN_LENGTH(proto->chosen->p)))
					return "";

				type = GET_ISAKMP_ATTR_TYPE(attr);
				fmt = ISAKMP_ATTR_FORMAT(type);
				type = ISAKMP_ATTR_TYPE(type);
				value = attr + (fmt ? ISAKMP_ATTR_LENGTH_VALUE_OFF :
				    ISAKMP_ATTR_VALUE_OFF);
				len = (fmt ? ISAKMP_ATTR_LENGTH_VALUE_LEN :
				    GET_ISAKMP_ATTR_LENGTH_VALUE(attr));

				if (value + len > proto->chosen->p +
				    GET_ISAKMP_GEN_LENGTH(proto->chosen->p))
					return "";

				switch (type) {
				case IPSEC_ATTR_SA_LIFE_TYPE:
					lifetype = decode_16(value);
					break;

				case IPSEC_ATTR_SA_LIFE_DURATION:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						if (lifetype == IPSEC_DURATION_SECONDS) {
							if (len == 2)
								snprintf(ah_life_seconds, sizeof ah_life_seconds,
								    "%u", decode_16(value));
							else
								snprintf(ah_life_seconds, sizeof ah_life_seconds,
								    "%u", decode_32(value));
						} else {
							if (len == 2)
								snprintf(ah_life_kbytes, sizeof ah_life_kbytes,
								    "%u", decode_16(value));
							else
								snprintf(ah_life_kbytes, sizeof ah_life_kbytes,
								    "%u", decode_32(value));
						}

						break;

					case IPSEC_PROTO_IPSEC_ESP:
						if (lifetype == IPSEC_DURATION_SECONDS) {
							if (len == 2)
								snprintf(esp_life_seconds,
								    sizeof esp_life_seconds, "%u",
								    decode_16(value));
							else
								snprintf(esp_life_seconds,
								    sizeof esp_life_seconds, "%u",
								    decode_32(value));
						} else {
							if (len == 2)
								snprintf(esp_life_kbytes,
								    sizeof esp_life_kbytes, "%u",
								     decode_16(value));
							else
								snprintf(esp_life_kbytes,
								    sizeof esp_life_kbytes, "%u",
								    decode_32(value));
						}

						break;

					case IPSEC_PROTO_IPCOMP:
						if (lifetype == IPSEC_DURATION_SECONDS) {
							if (len == 2)
								snprintf(comp_life_seconds,
								    sizeof comp_life_seconds, "%u",
								    decode_16(value));
							else
								snprintf(comp_life_seconds,
								    sizeof comp_life_seconds, "%u",
								    decode_32(value));
						} else {
							if (len == 2)
								snprintf(comp_life_kbytes,
								    sizeof comp_life_kbytes, "%u",
								    decode_16(value));
							else
								snprintf(comp_life_kbytes,
								    sizeof comp_life_kbytes, "%u",
								    decode_32(value));
						}
						break;
					}
					break;

				case IPSEC_ATTR_GROUP_DESCRIPTION:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						snprintf(ah_group_desc,
						    sizeof ah_group_desc, "%u",
						    decode_16(value));
						break;

					case IPSEC_PROTO_IPSEC_ESP:
						snprintf(esp_group_desc,
						    sizeof esp_group_desc, "%u",
						    decode_16(value));
						break;

					case IPSEC_PROTO_IPCOMP:
						snprintf(comp_group_desc,
						    sizeof comp_group_desc, "%u",
						    decode_16(value));
						break;
					}
					break;

				case IPSEC_ATTR_ECN_TUNNEL:
					if (decode_16(value))
						switch (proto->proto) {
						case IPSEC_PROTO_IPSEC_AH:
							ah_ecn = "yes";
							break;

						case IPSEC_PROTO_IPSEC_ESP:
							esp_ecn = "yes";
							break;

						case IPSEC_PROTO_IPCOMP:
							comp_ecn = "yes";
							break;
						}

				case IPSEC_ATTR_ENCAPSULATION_MODE:
					if (decode_16(value) == IPSEC_ENCAP_TUNNEL)
						switch (proto->proto) {
						case IPSEC_PROTO_IPSEC_AH:
							ah_encapsulation = "tunnel";
							break;

						case IPSEC_PROTO_IPSEC_ESP:
							esp_encapsulation = "tunnel";
							break;

						case IPSEC_PROTO_IPCOMP:
							comp_encapsulation = "tunnel";
							break;
						}
					else
						switch (proto->proto) {
						case IPSEC_PROTO_IPSEC_AH:
							ah_encapsulation = "transport";
							break;

						case IPSEC_PROTO_IPSEC_ESP:
							esp_encapsulation = "transport";
							break;

						case IPSEC_PROTO_IPCOMP:
							comp_encapsulation = "transport";
							break;
						}
					break;

				case IPSEC_ATTR_AUTHENTICATION_ALGORITHM:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						switch (decode_16(value)) {
						case IPSEC_AUTH_HMAC_MD5:
							ah_auth_alg = "hmac-md5";
							break;

						case IPSEC_AUTH_HMAC_SHA:
							ah_auth_alg = "hmac-sha";
							break;

						case IPSEC_AUTH_HMAC_RIPEMD:
							ah_auth_alg = "hmac-ripemd";
							break;

						case IPSEC_AUTH_HMAC_SHA2_256:
							ah_auth_alg = "hmac-sha2-256";
							break;

						case IPSEC_AUTH_HMAC_SHA2_384:
							ah_auth_alg = "hmac-sha2-384";
							break;

						case IPSEC_AUTH_HMAC_SHA2_512:
							ah_auth_alg = "hmac-sha2-512";
							break;

						case IPSEC_AUTH_DES_MAC:
							ah_auth_alg = "des-mac";
							break;

						case IPSEC_AUTH_KPDK:
							ah_auth_alg = "kpdk";
							break;
						}
						break;

					case IPSEC_PROTO_IPSEC_ESP:
						switch (decode_16(value)) {
						case IPSEC_AUTH_HMAC_MD5:
							esp_auth_alg = "hmac-md5";
							break;

						case IPSEC_AUTH_HMAC_SHA:
							esp_auth_alg = "hmac-sha";
							break;

						case IPSEC_AUTH_HMAC_RIPEMD:
							esp_auth_alg = "hmac-ripemd";
							break;

						case IPSEC_AUTH_HMAC_SHA2_256:
							esp_auth_alg = "hmac-sha2-256";
							break;

						case IPSEC_AUTH_HMAC_SHA2_384:
							esp_auth_alg = "hmac-sha2-384";
							break;

						case IPSEC_AUTH_HMAC_SHA2_512:
							esp_auth_alg = "hmac-sha2-512";
							break;

						case IPSEC_AUTH_DES_MAC:
							esp_auth_alg = "des-mac";
							break;

						case IPSEC_AUTH_KPDK:
							esp_auth_alg = "kpdk";
							break;
						}
						break;
					}
					break;

				case IPSEC_ATTR_KEY_LENGTH:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						snprintf(ah_key_length,
						    sizeof ah_key_length, "%u",
						    decode_16(value));
						break;

					case IPSEC_PROTO_IPSEC_ESP:
						snprintf(esp_key_length,
						    sizeof esp_key_length, "%u",
						    decode_16(value));
						break;
					}
					break;

				case IPSEC_ATTR_KEY_ROUNDS:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						snprintf(ah_key_rounds,
						    sizeof ah_key_rounds, "%u",
						    decode_16(value));
						break;

					case IPSEC_PROTO_IPSEC_ESP:
						snprintf(esp_key_rounds,
						    sizeof esp_key_rounds, "%u",
						    decode_16(value));
						break;
					}
					break;

				case IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE:
					snprintf(comp_dict_size,
					    sizeof comp_dict_size, "%u",
					    decode_16(value));
					break;

				case IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM:
					snprintf(comp_private_alg,
					    sizeof comp_private_alg, "%u",
					    decode_16(value));
					break;
				}
			}
d342 1
a342 20
		policy_sa->transport->vtbl->get_src(policy_sa->transport, &sin);
		if (sockaddr2text(sin, &addr, 1)) {
			log_error("policy_callback: sockaddr2text failed");
			goto bad;
		}
		strlcpy(local_ike_address, addr, sizeof local_ike_address);
		free(addr);

		policy_sa->transport->vtbl->get_dst(policy_sa->transport, &sin);
		if (sockaddr2text(sin, &addr, 1)) {
			log_error("policy_callback: sockaddr2text failed");
			goto bad;
		}
		strlcpy(remote_ike_address, addr, sizeof remote_ike_address);
		free(addr);

		switch (policy_isakmp_sa->exch_type) {
		case ISAKMP_EXCH_AGGRESSIVE:
			phase_1 = "aggressive";
			break;
d344 19
a362 3
		case ISAKMP_EXCH_ID_PROT:
			phase_1 = "main";
			break;
d365 2
a366 24
		if (policy_isakmp_sa->initiator) {
			id = policy_isakmp_sa->id_r;
			id_sz = policy_isakmp_sa->id_r_len;
		} else {
			id = policy_isakmp_sa->id_i;
			id_sz = policy_isakmp_sa->id_i_len;
		}

		switch (id[0]) {
		case IPSEC_ID_IPV4_ADDR:
			remote_id_type = "IPv4 address";

			net = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
			my_inet_ntop4(&net, remote_id_addr_upper,
				      sizeof remote_id_addr_upper - 1, 1);
			my_inet_ntop4(&net, remote_id_addr_lower,
				      sizeof remote_id_addr_lower - 1, 1);
			remote_id = strdup(remote_id_addr_upper);
			if (!remote_id) {
				log_error("policy_callback: strdup (\"%s\") failed",
				    remote_id_addr_upper);
				goto bad;
			}
			break;
d368 9
a376 2
		case IPSEC_ID_IPV4_RANGE:
			remote_id_type = "IPv4 range";
d378 7
a384 18
			net = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
			my_inet_ntop4(&net, remote_id_addr_lower,
			    sizeof remote_id_addr_lower - 1, 1);
			net = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 4);
			my_inet_ntop4(&net, remote_id_addr_upper,
			    sizeof remote_id_addr_upper - 1, 1);
			len = strlen(remote_id_addr_upper) +
			    strlen(remote_id_addr_lower) + 2;
			remote_id = calloc(len, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: calloc (%d, %lu) failed",
				    len, (unsigned long)sizeof(char));
				goto bad;
			}
			strlcpy(remote_id, remote_id_addr_lower, len);
			strlcat(remote_id, "-", len);
			strlcat(remote_id, remote_id_addr_upper, len);
			break;
d386 3
a388 2
		case IPSEC_ID_IPV4_ADDR_SUBNET:
			remote_id_type = "IPv4 subnet";
d390 5
a394 20
			net = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
			subnet = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 4);
			net &= subnet;
			my_inet_ntop4(&net, remote_id_addr_lower,
			    sizeof remote_id_addr_lower - 1, 1);
			net |= ~subnet;
			my_inet_ntop4(&net, remote_id_addr_upper,
			    sizeof remote_id_addr_upper - 1, 1);
			len = strlen(remote_id_addr_upper) +
				 strlen(remote_id_addr_lower) + 2;
			remote_id = calloc(len, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: calloc (%d, %lu) failed",
				    len, (unsigned long)sizeof(char));
				goto bad;
			}
			strlcpy(remote_id, remote_id_addr_lower, len);
			strlcat(remote_id, "-", len);
			strlcat(remote_id, remote_id_addr_upper, len);
			break;
d396 73
a468 11
		case IPSEC_ID_IPV6_ADDR:
			remote_id_type = "IPv6 address";
			my_inet_ntop6(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    remote_id_addr_upper, sizeof remote_id_addr_upper);
			strlcpy(remote_id_addr_lower, remote_id_addr_upper,
			    sizeof remote_id_addr_lower);
			remote_id = strdup(remote_id_addr_upper);
			if (!remote_id) {
				log_error("policy_callback: strdup (\"%s\") failed",
				    remote_id_addr_upper);
				goto bad;
a469 1
			break;
d471 3
a473 2
		case IPSEC_ID_IPV6_RANGE:
			remote_id_type = "IPv6 range";
d475 2
a476 22
			my_inet_ntop6(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    remote_id_addr_lower,
			    sizeof remote_id_addr_lower - 1);

			my_inet_ntop6(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 16,
			    remote_id_addr_upper,
			    sizeof remote_id_addr_upper - 1);

			len = strlen(remote_id_addr_upper) +
			    strlen(remote_id_addr_lower) + 2;
			remote_id = calloc(len, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: calloc (%d, %lu) failed",
				    len, (unsigned long)sizeof(char));
				goto bad;
			}
			strlcpy(remote_id, remote_id_addr_lower, len);
			strlcat(remote_id, "-", len);
			strlcat(remote_id, remote_id_addr_upper, len);
			break;

		case IPSEC_ID_IPV6_ADDR_SUBNET:
d478 14
a491 33
			struct in6_addr net, mask;

			remote_id_type = "IPv6 subnet";

			bcopy(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, &net,
			    sizeof(net));
			bcopy(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 16, &mask,
			    sizeof(mask));

			for (i = 0; i < 16; i++)
				net.s6_addr[i] &= mask.s6_addr[i];

			my_inet_ntop6((unsigned char *)&net, remote_id_addr_lower,
			    sizeof remote_id_addr_lower - 1);

			for (i = 0; i < 16; i++)
				net.s6_addr[i] |= ~mask.s6_addr[i];

			my_inet_ntop6((unsigned char *)&net, remote_id_addr_upper,
			    sizeof remote_id_addr_upper - 1);

			len = strlen(remote_id_addr_upper) +
			    strlen(remote_id_addr_lower) + 2;
			remote_id = calloc(len, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: calloc (%d, %lu) failed",
				    len, (unsigned long)sizeof(char));
				goto bad;
			}
			strlcpy(remote_id, remote_id_addr_lower, len);
			strlcat(remote_id, "-", len);
			strlcat(remote_id, remote_id_addr_upper, len);
			break;
d493 1
d495 6
a500 13
		case IPSEC_ID_FQDN:
			remote_id_type = "FQDN";
			remote_id = calloc(id_sz - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ + 1, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: calloc (%lu, %lu) failed",
				    (unsigned long)id_sz - ISAKMP_ID_DATA_OFF +
				    ISAKMP_GEN_SZ + 1,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			memcpy(remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
d503 2
a504 13
		case IPSEC_ID_USER_FQDN:
			remote_id_type = "User FQDN";
			remote_id = calloc(id_sz - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ + 1, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: calloc (%lu, %lu) failed",
				    (unsigned long)id_sz - ISAKMP_ID_DATA_OFF +
				    ISAKMP_GEN_SZ + 1,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			memcpy(remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
d507 2
a508 11
		case IPSEC_ID_DER_ASN1_DN:
			remote_id_type = "ASN1 DN";

			remote_id = x509_DN_string(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ,
			    id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
			if (!remote_id) {
				LOG_DBG((LOG_POLICY, 50,
				    "policy_callback: failed to decode name"));
				goto bad;
			}
d510 1
d512 6
a517 2
		case IPSEC_ID_DER_ASN1_GN:	/* XXX */
			remote_id_type = "ASN1 GN";
d520 2
a521 30
		case IPSEC_ID_KEY_ID:
			remote_id_type = "Key ID";
			remote_id = calloc(2 * (id_sz - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ) + 1, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: calloc (%lu, %lu) failed",
				    2 * ((unsigned long)id_sz -
				    ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			/* Does it contain any non-printable characters ? */
			for (i = 0; i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ; i++)
				if (!isprint(*(id + ISAKMP_ID_DATA_OFF -
				    ISAKMP_GEN_SZ + i)))
					break;
			if (i >= id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) {
				memcpy(remote_id, id + ISAKMP_ID_DATA_OFF -
				    ISAKMP_GEN_SZ,
				    id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
				break;
			}
			/* Non-printable characters, convert to hex */
			for (i = 0;
			    i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ; i++) {
				remote_id[2 * i] = hextab[*(id +
				    ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) >> 4];
				remote_id[2 * i + 1] = hextab[*(id +
				    ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) & 0xF];
			}
d524 2
a525 8
		default:
			log_print("policy_callback: unknown remote ID type %u", id[0]);
			goto bad;
		}

		switch (id[1]) {
		case IPPROTO_TCP:
			remote_id_proto = "tcp";
d527 6
a532 3

		case IPPROTO_UDP:
			remote_id_proto = "udp";
d535 2
a536 3
#ifdef IPPROTO_ETHERIP
		case IPPROTO_ETHERIP:
			remote_id_proto = "etherip";
a537 1
#endif
d539 2
a540 4
		default:
			snprintf(remote_id_proto_num, sizeof remote_id_proto_num, "%d",
			    id[1]);
			remote_id_proto = remote_id_proto_num;
d542 2
a543 1
		}
d545 74
a618 241
		snprintf(remote_id_port, sizeof remote_id_port, "%u",
		    decode_16(id + 2));

		if (policy_exchange->initiator) {
			initiator = "yes";
			idlocal = ie->id_ci;
			idremote = ie->id_cr;
			idlocalsz = ie->id_ci_sz;
			idremotesz = ie->id_cr_sz;
		} else {
			initiator = "no";
			idlocal = ie->id_cr;
			idremote = ie->id_ci;
			idlocalsz = ie->id_cr_sz;
			idremotesz = ie->id_ci_sz;
		}

		/* Initialize the ID variables.  */
		if (idremote) {
			switch (GET_ISAKMP_ID_TYPE(idremote)) {
			case IPSEC_ID_IPV4_ADDR:
				remote_filter_type = "IPv4 address";

				net = decode_32(idremote + ISAKMP_ID_DATA_OFF);
				my_inet_ntop4(&net, remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1, 1);
				my_inet_ntop4(&net, remote_filter_addr_lower,
				    sizeof remote_filter_addr_lower - 1, 1);
				remote_filter = strdup(remote_filter_addr_upper);
				if (!remote_filter) {
					log_error("policy_callback: strdup "
					    "(\"%s\") failed",
					    remote_filter_addr_upper);
					goto bad;
				}
				break;

			case IPSEC_ID_IPV4_RANGE:
				remote_filter_type = "IPv4 range";

				net = decode_32(idremote + ISAKMP_ID_DATA_OFF);
				my_inet_ntop4(&net, remote_filter_addr_lower,
				    sizeof remote_filter_addr_lower - 1, 1);
				net = decode_32(idremote + ISAKMP_ID_DATA_OFF + 4);
				my_inet_ntop4(&net, remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1, 1);
				len = strlen(remote_filter_addr_upper) +
				    strlen(remote_filter_addr_lower) + 2;
				remote_filter = calloc(len, sizeof(char));
				if (!remote_filter) {
					log_error("policy_callback: calloc "
					    "(%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(remote_filter, remote_filter_addr_lower, len);
				strlcat(remote_filter, "-", len);
				strlcat(remote_filter, remote_filter_addr_upper, len);
				break;

			case IPSEC_ID_IPV4_ADDR_SUBNET:
				remote_filter_type = "IPv4 subnet";

				net = decode_32(idremote + ISAKMP_ID_DATA_OFF);
				subnet = decode_32(idremote + ISAKMP_ID_DATA_OFF + 4);
				net &= subnet;
				my_inet_ntop4(&net, remote_filter_addr_lower,
				    sizeof remote_filter_addr_lower - 1, 1);
				net |= ~subnet;
				my_inet_ntop4(&net, remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1, 1);
				len = strlen(remote_filter_addr_upper) +
				    strlen(remote_filter_addr_lower) + 2;
				remote_filter = calloc(len, sizeof(char));
				if (!remote_filter) {
					log_error("policy_callback: calloc "
					    "(%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(remote_filter, remote_filter_addr_lower, len);
				strlcat(remote_filter, "-", len);
				strlcat(remote_filter, remote_filter_addr_upper, len);
				break;

			case IPSEC_ID_IPV6_ADDR:
				remote_filter_type = "IPv6 address";
				my_inet_ntop6(idremote + ISAKMP_ID_DATA_OFF,
				    remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1);
				strlcpy(remote_filter_addr_lower,
				    remote_filter_addr_upper,
				    sizeof remote_filter_addr_lower);
				remote_filter = strdup(remote_filter_addr_upper);
				if (!remote_filter) {
					log_error("policy_callback: strdup "
					    "(\"%s\") failed",
					    remote_filter_addr_upper);
					goto bad;
				}
				break;

			case IPSEC_ID_IPV6_RANGE:
				remote_filter_type = "IPv6 range";

				my_inet_ntop6(idremote + ISAKMP_ID_DATA_OFF,
				    remote_filter_addr_lower,
				    sizeof remote_filter_addr_lower - 1);

				my_inet_ntop6(idremote + ISAKMP_ID_DATA_OFF + 16,
				    remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1);

				len = strlen(remote_filter_addr_upper) +
				    strlen(remote_filter_addr_lower) + 2;
				remote_filter = calloc(len, sizeof(char));
				if (!remote_filter) {
					log_error("policy_callback: calloc "
					    "(%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(remote_filter, remote_filter_addr_lower, len);
				strlcat(remote_filter, "-", len);
				strlcat(remote_filter, remote_filter_addr_upper, len);
				break;

			case IPSEC_ID_IPV6_ADDR_SUBNET:
				{
					struct in6_addr net, mask;

					remote_filter_type = "IPv6 subnet";

					bcopy(idremote + ISAKMP_ID_DATA_OFF, &net, sizeof(net));
					bcopy(idremote + ISAKMP_ID_DATA_OFF + 16, &mask, sizeof(mask));

					for (i = 0; i < 16; i++)
						net.s6_addr[i] &= mask.s6_addr[i];

					my_inet_ntop6((unsigned char *)&net, remote_filter_addr_lower,
					sizeof remote_filter_addr_lower - 1);

					for (i = 0; i < 16; i++)
						net.s6_addr[i] |= ~mask.s6_addr[i];

					my_inet_ntop6((unsigned char *)&net, remote_filter_addr_upper,
					sizeof remote_filter_addr_upper - 1);

					len = strlen(remote_filter_addr_upper)
						+ strlen(remote_filter_addr_lower) + 2;
					remote_filter = calloc(len, sizeof(char));
					if (!remote_filter) {
						log_error("policy_callback: calloc (%d, %lu) failed", len,
							  (unsigned long)sizeof(char));
						goto bad;
					}
					strlcpy(remote_filter, remote_filter_addr_lower, len);
					strlcat(remote_filter, "-", len);
					strlcat(remote_filter, remote_filter_addr_upper, len);
					break;
				}

			case IPSEC_ID_FQDN:
				remote_filter_type = "FQDN";
				remote_filter = malloc(idremotesz - ISAKMP_ID_DATA_OFF + 1);
				if (!remote_filter) {
					log_error("policy_callback: malloc (%lu) failed",
						  (unsigned long)idremotesz - ISAKMP_ID_DATA_OFF + 1);
					goto bad;
				}
				memcpy(remote_filter, idremote + ISAKMP_ID_DATA_OFF,
				       idremotesz - ISAKMP_ID_DATA_OFF);
				remote_filter[idremotesz - ISAKMP_ID_DATA_OFF] = '\0';
				break;

			case IPSEC_ID_USER_FQDN:
				remote_filter_type = "User FQDN";
				remote_filter = malloc(idremotesz - ISAKMP_ID_DATA_OFF + 1);
				if (!remote_filter) {
					log_error("policy_callback: malloc (%lu) failed",
						  (unsigned long)idremotesz - ISAKMP_ID_DATA_OFF + 1);
					goto bad;
				}
				memcpy(remote_filter, idremote + ISAKMP_ID_DATA_OFF,
				       idremotesz - ISAKMP_ID_DATA_OFF);
				remote_filter[idremotesz - ISAKMP_ID_DATA_OFF] = '\0';
				break;

			case IPSEC_ID_DER_ASN1_DN:
				remote_filter_type = "ASN1 DN";

				remote_filter = x509_DN_string(idremote + ISAKMP_ID_DATA_OFF,
					   idremotesz - ISAKMP_ID_DATA_OFF);
				if (!remote_filter) {
					LOG_DBG((LOG_POLICY, 50,
						 "policy_callback: failed to decode name"));
					goto bad;
				}
				break;

			case IPSEC_ID_DER_ASN1_GN:	/* XXX -- not sure
							 * what's in this.  */
				remote_filter_type = "ASN1 GN";
				break;

			case IPSEC_ID_KEY_ID:
				remote_filter_type = "Key ID";
				remote_filter
					= calloc(2 * (idremotesz - ISAKMP_ID_DATA_OFF) + 1,
						 sizeof(char));
				if (!remote_filter) {
					log_error("policy_callback: calloc (%lu, %lu) failed",
						  2 * ((unsigned long)idremotesz - ISAKMP_ID_DATA_OFF) + 1,
					      (unsigned long)sizeof(char));
					goto bad;
				}
				/*
				 * Does it contain any non-printable
				 * characters ?
				 */
				for (i = 0; i < idremotesz - ISAKMP_ID_DATA_OFF; i++)
					if (!isprint(*(idremote + ISAKMP_ID_DATA_OFF + i)))
						break;
				if (i >= idremotesz - ISAKMP_ID_DATA_OFF) {
					memcpy(remote_filter, idremote + ISAKMP_ID_DATA_OFF,
					   idremotesz - ISAKMP_ID_DATA_OFF);
					break;
				}
				/* Non-printable characters, convert to hex */
				for (i = 0; i < idremotesz - ISAKMP_ID_DATA_OFF; i++) {
					remote_filter[2 * i]
						= hextab[*(idremote + ISAKMP_ID_DATA_OFF) >> 4];
					remote_filter[2 * i + 1]
						= hextab[*(idremote + ISAKMP_ID_DATA_OFF) & 0xF];
				}
				break;

			default:
				log_print("policy_callback: unknown Remote ID type %u",
					  GET_ISAKMP_ID_TYPE(idremote));
				goto bad;
d620 3
d624 14
a637 8
			switch (idremote[ISAKMP_GEN_SZ + 1]) {
			case IPPROTO_TCP:
				remote_filter_proto = "tcp";
				break;

			case IPPROTO_UDP:
				remote_filter_proto = "udp";
				break;
d639 14
a652 13
#ifdef IPPROTO_ETHERIP
			case IPPROTO_ETHERIP:
				remote_filter_proto = "etherip";
				break;
#endif

			default:
				snprintf(remote_filter_proto_num,
				       sizeof remote_filter_proto_num, "%d",
					 idremote[ISAKMP_GEN_SZ + 1]);
				remote_filter_proto = remote_filter_proto_num;
				break;
			}
d654 9
a662 31
			snprintf(remote_filter_port, sizeof remote_filter_port, "%u",
				 decode_16(idremote + ISAKMP_GEN_SZ + 2));
		} else {
			policy_sa->transport->vtbl->get_dst(policy_sa->transport, &sin);
			switch (sin->sa_family) {
			case AF_INET:
				remote_filter_type = "IPv4 address";
				break;
			case AF_INET6:
				remote_filter_type = "IPv6 address";
				break;
			default:
				log_print("policy_callback: unsupported protocol family %d",
					  sin->sa_family);
				goto bad;
			}
			if (sockaddr2text(sin, &addr, 1)) {
				log_error("policy_callback: sockaddr2text failed");
				goto bad;
			}
			memcpy(remote_filter_addr_upper, addr,
			       sizeof remote_filter_addr_upper);
			memcpy(remote_filter_addr_lower, addr,
			       sizeof remote_filter_addr_lower);
			free(addr);
			remote_filter = strdup(remote_filter_addr_upper);
			if (!remote_filter) {
				log_error("policy_callback: strdup (\"%s\") failed",
					  remote_filter_addr_upper);
				goto bad;
			}
d664 2
d667 8
a674 217
		if (idlocal) {
			switch (GET_ISAKMP_ID_TYPE(idlocal)) {
			case IPSEC_ID_IPV4_ADDR:
				local_filter_type = "IPv4 address";

				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF);
				my_inet_ntop4(&net, local_filter_addr_upper,
				     sizeof local_filter_addr_upper - 1, 1);
				my_inet_ntop4(&net, local_filter_addr_lower,
				     sizeof local_filter_addr_upper - 1, 1);
				local_filter = strdup(local_filter_addr_upper);
				if (!local_filter) {
					log_error("policy_callback: strdup (\"%s\") failed",
						  local_filter_addr_upper);
					goto bad;
				}
				break;

			case IPSEC_ID_IPV4_RANGE:
				local_filter_type = "IPv4 range";

				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF);
				my_inet_ntop4(&net, local_filter_addr_lower,
				     sizeof local_filter_addr_lower - 1, 1);
				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF + 4);
				my_inet_ntop4(&net, local_filter_addr_upper,
				     sizeof local_filter_addr_upper - 1, 1);
				len = strlen(local_filter_addr_upper)
					+ strlen(local_filter_addr_lower) + 2;
				local_filter = calloc(len, sizeof(char));
				if (!local_filter) {
					log_error("policy_callback: calloc (%d, %lu) failed", len,
					      (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(local_filter, local_filter_addr_lower, len);
				strlcat(local_filter, "-", len);
				strlcat(local_filter, local_filter_addr_upper, len);
				break;

			case IPSEC_ID_IPV4_ADDR_SUBNET:
				local_filter_type = "IPv4 subnet";

				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF);
				subnet = decode_32(idlocal + ISAKMP_ID_DATA_OFF + 4);
				net &= subnet;
				my_inet_ntop4(&net, local_filter_addr_lower,
				     sizeof local_filter_addr_lower - 1, 1);
				net |= ~subnet;
				my_inet_ntop4(&net, local_filter_addr_upper,
				     sizeof local_filter_addr_upper - 1, 1);
				len = strlen(local_filter_addr_upper)
					+ strlen(local_filter_addr_lower) + 2;
				local_filter = calloc(len, sizeof(char));
				if (!local_filter) {
					log_error("policy_callback: calloc (%d, %lu) failed", len,
					      (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(local_filter, local_filter_addr_lower, len);
				strlcat(local_filter, "-", len);
				strlcat(local_filter, local_filter_addr_upper, len);
				break;

			case IPSEC_ID_IPV6_ADDR:
				local_filter_type = "IPv6 address";
				my_inet_ntop6(idlocal + ISAKMP_ID_DATA_OFF,
					      local_filter_addr_upper,
					sizeof local_filter_addr_upper - 1);
				strlcpy(local_filter_addr_lower, local_filter_addr_upper,
					sizeof local_filter_addr_lower);
				local_filter = strdup(local_filter_addr_upper);
				if (!local_filter) {
					log_error("policy_callback: strdup (\"%s\") failed",
						  local_filter_addr_upper);
					goto bad;
				}
				break;

			case IPSEC_ID_IPV6_RANGE:
				local_filter_type = "IPv6 range";

				my_inet_ntop6(idlocal + ISAKMP_ID_DATA_OFF,
					      local_filter_addr_lower,
					sizeof local_filter_addr_lower - 1);

				my_inet_ntop6(idlocal + ISAKMP_ID_DATA_OFF + 16,
					      local_filter_addr_upper,
					sizeof local_filter_addr_upper - 1);

				len = strlen(local_filter_addr_upper)
					+ strlen(local_filter_addr_lower) + 2;
				local_filter = calloc(len, sizeof(char));
				if (!local_filter) {
					log_error("policy_callback: calloc (%d, %lu) failed", len,
					      (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(local_filter, local_filter_addr_lower, len);
				strlcat(local_filter, "-", len);
				strlcat(local_filter, local_filter_addr_upper, len);
				break;

			case IPSEC_ID_IPV6_ADDR_SUBNET:
				{
					struct in6_addr net, mask;

					local_filter_type = "IPv6 subnet";

					bcopy(idlocal + ISAKMP_ID_DATA_OFF, &net, sizeof(net));
					bcopy(idlocal + ISAKMP_ID_DATA_OFF + 16, &mask, sizeof(mask));

					for (i = 0; i < 16; i++)
						net.s6_addr[i] &= mask.s6_addr[i];

					my_inet_ntop6((unsigned char *)&net, local_filter_addr_lower,
					sizeof local_filter_addr_lower - 1);

					for (i = 0; i < 16; i++)
						net.s6_addr[i] |= ~mask.s6_addr[i];

					my_inet_ntop6((unsigned char *)&net, local_filter_addr_upper,
					sizeof local_filter_addr_upper - 1);

					len = strlen(local_filter_addr_upper)
						+ strlen(local_filter_addr_lower) + 2;
					local_filter = calloc(len, sizeof(char));
					if (!local_filter) {
						log_error("policy_callback: calloc (%d, %lu) failed", len,
							  (unsigned long)sizeof(char));
						goto bad;
					}
					strlcpy(local_filter, local_filter_addr_lower, len);
					strlcat(local_filter, "-", len);
					strlcat(local_filter, local_filter_addr_upper, len);
					break;
				}

			case IPSEC_ID_FQDN:
				local_filter_type = "FQDN";
				local_filter = malloc(idlocalsz - ISAKMP_ID_DATA_OFF + 1);
				if (!local_filter) {
					log_error("policy_callback: malloc (%lu) failed",
						  (unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF + 1);
					goto bad;
				}
				memcpy(local_filter, idlocal + ISAKMP_ID_DATA_OFF,
				       idlocalsz - ISAKMP_ID_DATA_OFF);
				local_filter[idlocalsz - ISAKMP_ID_DATA_OFF] = '\0';
				break;

			case IPSEC_ID_USER_FQDN:
				local_filter_type = "User FQDN";
				local_filter = malloc(idlocalsz - ISAKMP_ID_DATA_OFF + 1);
				if (!local_filter) {
					log_error("policy_callback: malloc (%lu) failed",
						  (unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF + 1);
					goto bad;
				}
				memcpy(local_filter, idlocal + ISAKMP_ID_DATA_OFF,
				       idlocalsz - ISAKMP_ID_DATA_OFF);
				local_filter[idlocalsz - ISAKMP_ID_DATA_OFF] = '\0';
				break;

			case IPSEC_ID_DER_ASN1_DN:
				local_filter_type = "ASN1 DN";

				local_filter = x509_DN_string(idlocal + ISAKMP_ID_DATA_OFF,
					    idlocalsz - ISAKMP_ID_DATA_OFF);
				if (!local_filter) {
					LOG_DBG((LOG_POLICY, 50,
						 "policy_callback: failed to decode name"));
					goto bad;
				}
				break;

			case IPSEC_ID_DER_ASN1_GN:
				/* XXX -- not sure what's in this.  */
				local_filter_type = "ASN1 GN";
				break;

			case IPSEC_ID_KEY_ID:
				local_filter_type = "Key ID";
				local_filter = calloc(2 * (idlocalsz - ISAKMP_ID_DATA_OFF) + 1,
						      sizeof(char));
				if (!local_filter) {
					log_error("policy_callback: calloc (%lu, %lu) failed",
						  2 * ((unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF) + 1,
					      (unsigned long)sizeof(char));
					goto bad;
				}
				/*
				 * Does it contain any non-printable
				 * characters ?
				 */
				for (i = 0; i < idlocalsz - ISAKMP_ID_DATA_OFF; i++)
					if (!isprint(*(idlocal + ISAKMP_ID_DATA_OFF + i)))
						break;
				if (i >= idlocalsz - ISAKMP_ID_DATA_OFF) {
					memcpy(local_filter, idlocal + ISAKMP_ID_DATA_OFF,
					    idlocalsz - ISAKMP_ID_DATA_OFF);
					break;
				}
				/* Non-printable characters, convert to hex */
				for (i = 0; i < idlocalsz - ISAKMP_ID_DATA_OFF; i++) {
					local_filter[2 * i]
						= hextab[*(idlocal + ISAKMP_ID_DATA_OFF) >> 4];
					local_filter[2 * i + 1]
						= hextab[*(idlocal + ISAKMP_ID_DATA_OFF) & 0xF];
				}
				break;

			default:
				log_print("policy_callback: unknown Local ID type %u",
					  GET_ISAKMP_ID_TYPE(idlocal));
				goto bad;
			}
d676 8
a683 8
			switch (idlocal[ISAKMP_GEN_SZ + 1]) {
			case IPPROTO_TCP:
				local_filter_proto = "tcp";
				break;

			case IPPROTO_UDP:
				local_filter_proto = "udp";
				break;
d685 5
a689 117
#ifdef IPPROTO_ETHERIP
			case IPPROTO_ETHERIP:
				local_filter_proto = "etherip";
				break;
#endif

			default:
				snprintf(local_filter_proto_num, sizeof local_filter_proto_num,
					 "%d", idlocal[ISAKMP_GEN_SZ + 1]);
				local_filter_proto = local_filter_proto_num;
				break;
			}

			snprintf(local_filter_port, sizeof local_filter_port, "%u",
				 decode_16(idlocal + ISAKMP_GEN_SZ + 2));
		} else {
			policy_sa->transport->vtbl->get_src(policy_sa->transport,
						(struct sockaddr **)&sin);
			switch (sin->sa_family) {
			case AF_INET:
				local_filter_type = "IPv4 address";
				break;
			case AF_INET6:
				local_filter_type = "IPv6 address";
				break;
			default:
				log_print("policy_callback: unsupported protocol family %d",
					  sin->sa_family);
				goto bad;
			}

			if (sockaddr2text(sin, &addr, 1)) {
				log_error("policy_callback: sockaddr2text failed");
				goto bad;
			}
			memcpy(local_filter_addr_upper, addr,
			       sizeof local_filter_addr_upper);
			memcpy(local_filter_addr_lower, addr,
			       sizeof local_filter_addr_lower);
			free(addr);
			local_filter = strdup(local_filter_addr_upper);
			if (!local_filter) {
				log_error("policy_callback: strdup (\"%s\") failed",
					  local_filter_addr_upper);
				goto bad;
			}
		}

		LOG_DBG((LOG_POLICY, 80, "Policy context (action attributes):"));
		LOG_DBG((LOG_POLICY, 80, "esp_present == %s", esp_present));
		LOG_DBG((LOG_POLICY, 80, "ah_present == %s", ah_present));
		LOG_DBG((LOG_POLICY, 80, "comp_present == %s", comp_present));
		LOG_DBG((LOG_POLICY, 80, "ah_hash_alg == %s", ah_hash_alg));
		LOG_DBG((LOG_POLICY, 80, "esp_enc_alg == %s", esp_enc_alg));
		LOG_DBG((LOG_POLICY, 80, "comp_alg == %s", comp_alg));
		LOG_DBG((LOG_POLICY, 80, "ah_auth_alg == %s", ah_auth_alg));
		LOG_DBG((LOG_POLICY, 80, "esp_auth_alg == %s", esp_auth_alg));
		LOG_DBG((LOG_POLICY, 80, "ah_life_seconds == %s", ah_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "ah_life_kbytes == %s", ah_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "esp_life_seconds == %s", esp_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "esp_life_kbytes == %s", esp_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "comp_life_seconds == %s", comp_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "comp_life_kbytes == %s", comp_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "ah_encapsulation == %s", ah_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "esp_encapsulation == %s", esp_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "comp_encapsulation == %s",
			 comp_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "comp_dict_size == %s", comp_dict_size));
		LOG_DBG((LOG_POLICY, 80, "comp_private_alg == %s", comp_private_alg));
		LOG_DBG((LOG_POLICY, 80, "ah_key_length == %s", ah_key_length));
		LOG_DBG((LOG_POLICY, 80, "ah_key_rounds == %s", ah_key_rounds));
		LOG_DBG((LOG_POLICY, 80, "esp_key_length == %s", esp_key_length));
		LOG_DBG((LOG_POLICY, 80, "esp_key_rounds == %s", esp_key_rounds));
		LOG_DBG((LOG_POLICY, 80, "ah_group_desc == %s", ah_group_desc));
		LOG_DBG((LOG_POLICY, 80, "esp_group_desc == %s", esp_group_desc));
		LOG_DBG((LOG_POLICY, 80, "comp_group_desc == %s", comp_group_desc));
		LOG_DBG((LOG_POLICY, 80, "ah_ecn == %s", ah_ecn));
		LOG_DBG((LOG_POLICY, 80, "esp_ecn == %s", esp_ecn));
		LOG_DBG((LOG_POLICY, 80, "comp_ecn == %s", comp_ecn));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_type == %s",
			 remote_filter_type));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_addr_upper == %s",
			 remote_filter_addr_upper));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_addr_lower == %s",
			 remote_filter_addr_lower));
		LOG_DBG((LOG_POLICY, 80, "remote_filter == %s",
			 (remote_filter ? remote_filter : "")));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_port == %s",
			 remote_filter_port));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_proto == %s",
			 remote_filter_proto));
		LOG_DBG((LOG_POLICY, 80, "local_filter_type == %s", local_filter_type));
		LOG_DBG((LOG_POLICY, 80, "local_filter_addr_upper == %s",
			 local_filter_addr_upper));
		LOG_DBG((LOG_POLICY, 80, "local_filter_addr_lower == %s",
			 local_filter_addr_lower));
		LOG_DBG((LOG_POLICY, 80, "local_filter == %s",
			 (local_filter ? local_filter : "")));
		LOG_DBG((LOG_POLICY, 80, "local_filter_port == %s", local_filter_port));
		LOG_DBG((LOG_POLICY, 80, "local_filter_proto == %s",
			 local_filter_proto));
		LOG_DBG((LOG_POLICY, 80, "remote_id_type == %s", remote_id_type));
		LOG_DBG((LOG_POLICY, 80, "remote_id_addr_upper == %s",
			 remote_id_addr_upper));
		LOG_DBG((LOG_POLICY, 80, "remote_id_addr_lower == %s",
			 remote_id_addr_lower));
		LOG_DBG((LOG_POLICY, 80, "remote_id == %s",
			 (remote_id ? remote_id : "")));
		LOG_DBG((LOG_POLICY, 80, "remote_id_port == %s", remote_id_port));
		LOG_DBG((LOG_POLICY, 80, "remote_id_proto == %s", remote_id_proto));
		LOG_DBG((LOG_POLICY, 80, "remote_negotiation_address == %s",
			 remote_ike_address));
		LOG_DBG((LOG_POLICY, 80, "local_negotiation_address == %s",
			 local_ike_address));
		LOG_DBG((LOG_POLICY, 80, "pfs == %s", pfs));
		LOG_DBG((LOG_POLICY, 80, "initiator == %s", initiator));
		LOG_DBG((LOG_POLICY, 80, "phase1_group_desc == %s", phase1_group));
d691 3
a693 2
		/* Unset dirty now.  */
		dirty = 0;
a694 2
	if (strcmp(name, "phase_1") == 0)
		return phase_1;
d696 4
a699 4
	if (strcmp(name, "GMTTimeOfDay") == 0) {
		tt = time((time_t)NULL);
		strftime(mytimeofday, 14, "%Y%m%d%H%M%S", gmtime(&tt));
		return mytimeofday;
d701 4
a704 4
	if (strcmp(name, "LocalTimeOfDay") == 0) {
		tt = time((time_t)NULL);
		strftime(mytimeofday, 14, "%Y%m%d%H%M%S", localtime(&tt));
		return mytimeofday;
a705 2
	if (strcmp(name, "initiator") == 0)
		return initiator;
d707 4
a710 2
	if (strcmp(name, "pfs") == 0)
		return pfs;
d712 63
a774 2
	if (strcmp(name, "app_domain") == 0)
		return "IPsec policy";
d776 78
a853 2
	if (strcmp(name, "doi") == 0)
		return "ipsec";
d855 14
a868 2
	if (strcmp(name, "esp_present") == 0)
		return esp_present;
d870 64
a933 2
	if (strcmp(name, "ah_present") == 0)
		return ah_present;
d935 4
a938 2
	if (strcmp(name, "comp_present") == 0)
		return comp_present;
d940 9
a948 2
	if (strcmp(name, "ah_hash_alg") == 0)
		return ah_hash_alg;
d950 5
a954 2
	if (strcmp(name, "ah_auth_alg") == 0)
		return ah_auth_alg;
d956 48
a1003 2
	if (strcmp(name, "esp_auth_alg") == 0)
		return esp_auth_alg;
d1005 2
a1006 2
	if (strcmp(name, "esp_enc_alg") == 0)
		return esp_enc_alg;
d1008 15
a1022 2
	if (strcmp(name, "comp_alg") == 0)
		return comp_alg;
d1024 45
a1068 2
	if (strcmp(name, "ah_life_kbytes") == 0)
		return ah_life_kbytes;
d1070 2
a1071 2
	if (strcmp(name, "ah_life_seconds") == 0)
		return ah_life_seconds;
d1073 17
a1089 2
	if (strcmp(name, "esp_life_kbytes") == 0)
		return esp_life_kbytes;
d1091 4
a1094 2
	if (strcmp(name, "esp_life_seconds") == 0)
		return esp_life_seconds;
d1096 3
a1098 2
	if (strcmp(name, "comp_life_kbytes") == 0)
		return comp_life_kbytes;
d1100 1
a1100 2
	if (strcmp(name, "comp_life_seconds") == 0)
		return comp_life_seconds;
d1102 2
a1103 2
	if (strcmp(name, "ah_encapsulation") == 0)
		return ah_encapsulation;
d1105 2
a1106 2
	if (strcmp(name, "esp_encapsulation") == 0)
		return esp_encapsulation;
d1108 2
a1109 2
	if (strcmp(name, "comp_encapsulation") == 0)
		return comp_encapsulation;
d1111 2
a1112 2
	if (strcmp(name, "ah_key_length") == 0)
		return ah_key_length;
d1114 2
a1115 2
	if (strcmp(name, "ah_key_rounds") == 0)
		return ah_key_rounds;
d1117 9
a1125 2
	if (strcmp(name, "esp_key_length") == 0)
		return esp_key_length;
d1127 46
a1172 2
	if (strcmp(name, "esp_key_rounds") == 0)
		return esp_key_rounds;
d1174 51
a1224 2
	if (strcmp(name, "comp_dict_size") == 0)
		return comp_dict_size;
d1226 5
a1230 2
	if (strcmp(name, "comp_private_alg") == 0)
		return comp_private_alg;
d1232 66
a1297 2
	if (strcmp(name, "remote_filter_type") == 0)
		return remote_filter_type;
d1299 2
a1300 2
	if (strcmp(name, "remote_filter") == 0)
		return (remote_filter ? remote_filter : "");
d1302 60
a1361 2
	if (strcmp(name, "remote_filter_addr_upper") == 0)
		return remote_filter_addr_upper;
d1363 2
a1364 2
	if (strcmp(name, "remote_filter_addr_lower") == 0)
		return remote_filter_addr_lower;
d1366 17
a1382 2
	if (strcmp(name, "remote_filter_port") == 0)
		return remote_filter_port;
d1384 4
a1387 2
	if (strcmp(name, "remote_filter_proto") == 0)
		return remote_filter_proto;
d1389 3
a1391 2
	if (strcmp(name, "local_filter_type") == 0)
		return local_filter_type;
d1393 1
a1393 2
	if (strcmp(name, "local_filter") == 0)
		return (local_filter ? local_filter : "");
d1395 2
a1396 2
	if (strcmp(name, "local_filter_addr_upper") == 0)
		return local_filter_addr_upper;
d1398 2
a1399 2
	if (strcmp(name, "local_filter_addr_lower") == 0)
		return local_filter_addr_lower;
d1401 2
a1402 2
	if (strcmp(name, "local_filter_port") == 0)
		return local_filter_port;
d1404 2
a1405 2
	if (strcmp(name, "local_filter_proto") == 0)
		return local_filter_proto;
d1407 2
a1408 2
	if (strcmp(name, "remote_ike_address") == 0)
		return remote_ike_address;
d1410 9
a1418 2
	if (strcmp(name, "remote_negotiation_address") == 0)
		return remote_ike_address;
d1420 46
a1465 2
	if (strcmp(name, "local_ike_address") == 0)
		return local_ike_address;
d1467 51
a1517 2
	if (strcmp(name, "local_negotiation_address") == 0)
		return local_ike_address;
d1519 5
a1523 14
	if (strcmp(name, "remote_id_type") == 0)
		return remote_id_type;

	if (strcmp(name, "remote_id") == 0)
		return (remote_id ? remote_id : "");

	if (strcmp(name, "remote_id_addr_upper") == 0)
		return remote_id_addr_upper;

	if (strcmp(name, "remote_id_addr_lower") == 0)
		return remote_id_addr_lower;

	if (strcmp(name, "remote_id_port") == 0)
		return remote_id_port;
d1525 311
a1835 29
	if (strcmp(name, "remote_id_proto") == 0)
		return remote_id_proto;

	if (strcmp(name, "phase1_group_desc") == 0)
		return phase1_group;

	if (strcmp(name, "esp_group_desc") == 0)
		return esp_group_desc;

	if (strcmp(name, "ah_group_desc") == 0)
		return ah_group_desc;

	if (strcmp(name, "comp_group_desc") == 0)
		return comp_group_desc;

	if (strcmp(name, "comp_ecn") == 0)
		return comp_ecn;

	if (strcmp(name, "ah_ecn") == 0)
		return ah_ecn;

	if (strcmp(name, "esp_ecn") == 0)
		return esp_ecn;

	return "";

bad:
	policy_callback(KEYNOTE_CALLBACK_INITIALIZE);
	return "";
d1839 1
a1839 1
policy_init(void)
d1841 54
a1894 34
	char           *ptr, *policy_file;
	char          **asserts;
	size_t          sz, len;
	int             fd, i;

	LOG_DBG((LOG_POLICY, 30, "policy_init: initializing"));

	/* Get policy file from configuration.  */
	policy_file = conf_get_str("General", "Policy-file");
	if (!policy_file)
		policy_file = CONF_DFLT_POLICY_FILE;

	/* Check file modes and collect file size */
	if (check_file_secrecy(policy_file, &sz))
		log_fatal("policy_init: cannot read %s", policy_file);

	/* Open policy file.  */
	fd = monitor_open(policy_file, O_RDONLY, 0);
	if (fd == -1)
		log_fatal("policy_init: open (\"%s\", O_RDONLY) failed", policy_file);

	/* Allocate memory to keep policies.  */
	ptr = calloc(sz + 1, sizeof(char));
	if (!ptr)
		log_fatal("policy_init: calloc (%lu, %lu) failed", (unsigned long)sz + 1,
			  (unsigned long)sizeof(char));

	/* Just in case there are short reads...  */
	for (len = 0; len < sz; len += i) {
		i = read(fd, ptr + len, sz - len);
		if (i == -1)
			log_fatal("policy_init: read (%d, %p, %lu) failed", fd, ptr + len,
				  (unsigned long)(sz - len));
	}
d1896 2
a1897 2
	/* We're done with this.  */
	close(fd);
d1899 2
a1900 19
	/* Parse buffer, break up into individual policies.  */
	asserts = kn_read_asserts(ptr, sz, &i);

	/* Begone!  */
	free(ptr);

	if (asserts == (char **)NULL)
		log_print("policy_init: all policies flushed");

	/* Cleanup */
	if (policy_asserts) {
		for (fd = 0; fd < policy_asserts_num; fd++)
			if (policy_asserts && policy_asserts[fd])
				free(policy_asserts[fd]);

		free(policy_asserts);
	}
	policy_asserts = asserts;
	policy_asserts_num = i;
d1905 1
a1905 1
keynote_cert_init(void)
d1907 1
a1907 1
	return 1;
d1911 2
a1912 2
void           *
keynote_cert_get(u_int8_t * data, u_int32_t len)
d1914 1
a1914 1
	char           *foo = malloc(len + 1);
d1916 2
a1917 2
	if (foo == NULL)
		return NULL;
d1919 3
a1921 3
	memcpy(foo, data, len);
	foo[len] = '\0';
	return foo;
d1929 1
a1929 1
keynote_cert_validate(void *scert)
d1931 2
a1932 2
	char          **foo;
	int             num, i;
d1934 2
a1935 2
	if (scert == NULL)
		return 0;
d1937 13
a1949 13
	foo = kn_read_asserts((char *)scert, strlen((char *)scert), &num);
	if (foo == NULL)
		return 0;

	for (i = 0; i < num; i++) {
		if (kn_verify_assertion(scert, strlen((char *)scert))
		    != SIGRESULT_TRUE) {
			for (; i < num; i++)
				free(foo[i]);
			free(foo);
			return 0;
		}
		free(foo[i]);
d1952 5
a1956 2
	free(foo);
	return 1;
d1961 1
a1961 1
keynote_cert_insert(int sid, void *scert)
d1963 2
a1964 2
	char          **foo;
	int             num;
d1966 2
a1967 2
	if (scert == NULL)
		return 0;
d1969 3
a1971 3
	foo = kn_read_asserts((char *)scert, strlen((char *)scert), &num);
	if (foo == NULL)
		return 0;
d1973 2
a1974 2
	while (num--)
		kn_add_assertion(sid, foo[num], strlen(foo[num]), 0);
d1976 1
a1976 1
	return 1;
d1981 1
a1981 1
keynote_cert_free(void *cert)
d1983 1
a1983 1
	free(cert);
d1988 1
a1988 1
keynote_certreq_validate(u_int8_t * data, u_int32_t len)
d1990 13
a2002 11
	struct keynote_deckey dc;
	int             err = 1;
	char           *dat;

	dat = calloc(len + 1, sizeof(char));
	if (!dat) {
		log_error("keynote_certreq_validate: calloc (%d, %lu) failed", len + 1,
			  (unsigned long)sizeof(char));
		return 0;
	}
	memcpy(dat, data, len);
d2004 4
a2007 4
	if (kn_decode_key(&dc, dat, KEYNOTE_PUBLIC_KEY) != 0)
		err = 0;
	else
		kn_free_key(&dc);
d2009 1
a2009 1
	free(dat);
d2011 1
a2011 1
	return err;
d2015 2
a2016 2
void           *
keynote_certreq_decode(u_int8_t * data, u_int32_t len)
d2018 2
a2019 2
	/* XXX */
	return NULL;
d2023 1
a2023 1
keynote_free_aca(void *blob)
d2025 1
a2025 1
	/* XXX */
d2029 2
a2030 2
keynote_cert_obtain(u_int8_t * id, size_t id_len, void *data, u_int8_t ** cert,
		    u_int32_t * certlen)
d2032 34
a2065 57
	char           *dirname, *file, *addr_str;
	struct stat     sb;
	size_t          size;
	int             idtype, fd, len;

	if (!id) {
		log_print("keynote_cert_obtain: ID is missing");
		return 0;
	}
	/* Get type of ID.  */
	idtype = id[0];
	id += ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
	id_len -= ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;

	dirname = conf_get_str("KeyNote", "Credential-directory");
	if (!dirname) {
		LOG_DBG((LOG_POLICY, 30,
			 "keynote_cert_obtain: no Credential-directory"));
		return 0;
	}
	len = strlen(dirname) + strlen(CREDENTIAL_FILE) + 3;

	switch (idtype) {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR:
		util_ntoa(&addr_str, idtype == IPSEC_ID_IPV4_ADDR ? AF_INET : AF_INET6,
			  id);
		if (addr_str == 0)
			return 0;

		file = calloc(len + strlen(addr_str), sizeof(char));
		if (file == NULL) {
			log_error("keynote_cert_obtain: failed to allocate %lu bytes",
				  (unsigned long)len + strlen(addr_str));
			free(addr_str);
			return 0;
		}
		snprintf(file, len + strlen(addr_str), "%s/%s/%s", dirname, addr_str,
		    CREDENTIAL_FILE);
		free(addr_str);
		break;

	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
		{
			file = calloc(len + id_len, sizeof(char));
			if (file == NULL) {
				log_error("keynote_cert_obtain: failed to allocate %lu bytes",
				    (unsigned long)len + id_len);
				return 0;
			}
			snprintf(file, len + id_len, "%s/", dirname);
			memcpy(file + strlen(dirname) + 1, id, id_len);
			snprintf(file + strlen(dirname) + 1 + id_len,
			    len - strlen(dirname) - 1, "/%s", CREDENTIAL_FILE);
			break;
		}
d2067 76
a2142 37
	default:
		return 0;
	}

	if (monitor_stat(file, &sb) < 0) {
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: failed to stat \"%s\"",
		    file));
		free(file);
		return 0;
	}
	size = (size_t)sb.st_size;

	*cert = calloc(size + 1, sizeof(char));
	if (*cert == NULL) {
		log_error("keynote_cert_obtain: failed to allocate %lu bytes",
		    (unsigned long)size);
		free(file);
		return 0;
	}
	fd = monitor_open(file, O_RDONLY, 0);
	if (fd < 0) {
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: failed to open \"%s\"",
		    file));
		free(file);
		return 0;
	}
	if (read(fd, *cert, size) != (int)size) {
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: failed to read %lu "
		    "bytes from \"%s\"", (unsigned long)size, file));
		free(file);
		close(fd);
		return 0;
	}
	close(fd);
	free(file);
	*certlen = size;
	return 1;
d2147 2
a2148 2
keynote_cert_get_subjects(void *scert, int *n, u_int8_t ***id,
    u_int32_t **id_len)
d2150 1
a2150 1
	return 0;
d2155 1
a2155 1
keynote_cert_get_key(void *scert, void *keyp)
d2157 51
a2207 42
	struct keynote_keylist *kl;
	int             sid, kid, num;
	char          **foo;

	foo = kn_read_asserts((char *)scert, strlen((char *)scert), &num);
	if (foo == NULL || num == 0) {
		log_print("keynote_cert_get_key: failed to decompose credentials");
		return 0;
	}
	kid = kn_init();
	if (kid == -1) {
		log_print("keynote_cert_get_key: failed to initialize new policy "
		    "session");
		while (num--)
			free(foo[num]);
		free(foo);
		return 0;
	}
	sid = kn_add_assertion(kid, foo[num - 1], strlen(foo[num - 1]), 0);
	while (num--)
		free(foo[num]);
	free(foo);

	if (sid == -1) {
		log_print("keynote_cert_get_key: failed to add assertion");
		kn_close(kid);
		return 0;
	}
	*(RSA **)keyp = NULL;

	kl = kn_get_licensees(kid, sid);
	while (kl) {
		if (kl->key_alg == KEYNOTE_ALGORITHM_RSA) {
			*(RSA **)keyp = RSAPublicKey_dup(kl->key_key);
			break;
		}
		kl = kl->key_next;
	}

	kn_remove_assertion(kid, sid);
	kn_close(kid);
	return *(RSA **)keyp == NULL ? 0 : 1;
d2211 1
a2211 1
keynote_cert_dup(void *cert)
d2213 1
a2213 1
	return strdup((char *)cert);
d2217 1
a2217 1
keynote_serialize(void *cert, u_int8_t **data, u_int32_t *datalen)
d2219 4
a2222 5
	*datalen = strlen((char *)cert) + 1;
	*data = (u_int8_t *)strdup(cert);	/* i.e an extra character at
						 * the end... */
	if (*data == NULL)
		log_error("keynote_serialize: malloc (%d) failed", *datalen);
d2227 1
a2227 1
keynote_printable(void *cert)
d2229 1
a2229 1
	return strdup((char *)cert);
d2234 1
a2234 1
keynote_from_printable(char *cert)
d2236 1
a2236 1
	return strdup(cert);
@


1.1.1.8
log
@another bunch of fixes from obsd, and a big isakmpd update (need testers!)
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.78 2004/08/08 19:11:06 deraadt Exp $	 */
a69 1
int		ignore_policy = 0;
d84 1
a84 1
my_inet_ntop4(const in_addr_t *src, char *dst, size_t size, int normalize)
d110 1
a110 1
	char	tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"];
d112 2
a113 2
	if (snprintf(tmp, sizeof tmp, fmt, src[0], src[1], src[2], src[3],
	    src[4], src[5], src[6], src[7], src[8], src[9], src[10], src[11],
d148 4
a151 6
	static char     comp_life_seconds[PMAX], *ah_encapsulation;
	static char    *esp_encapsulation, *comp_encapsulation;
	static char     ah_key_length[PMAX], esp_key_length[PMAX];
	static char     ah_key_rounds[PMAX], esp_key_rounds[PMAX];
	static char	comp_dict_size[PMAX], comp_private_alg[PMAX];
	static char    *remote_filter_type, *local_filter_type;
d156 2
a157 2
	static char     ah_group_desc[PMAX], esp_group_desc[PMAX];
	static char	comp_group_desc[PMAX], remote_ike_address[NI_MAXHOST];
d159 3
a161 2
	static char    *remote_id_type, remote_id_addr_upper[NI_MAXHOST];
	static char    *phase_1, remote_id_addr_lower[NI_MAXHOST];
d164 4
a167 3
	static char    *remote_filter_proto, *local_filter_proto, *pfs;
	static char    *initiator, remote_filter_proto_num[3];
	static char	local_filter_proto_num[3], remote_id_proto_num[3];
d182 1
a182 2
		esp_encapsulation = comp_encapsulation = "";
		remote_filter_type = "";
d184 1
a184 2
		remote_filter_proto = local_filter_proto = "";
		remote_id_proto = "";
d212 4
a215 8
		memset(remote_filter_addr_upper, 0,
		    sizeof remote_filter_addr_upper);
		memset(remote_filter_addr_lower, 0,
		    sizeof remote_filter_addr_lower);
		memset(local_filter_addr_upper, 0,
		    sizeof local_filter_addr_upper);
		memset(local_filter_addr_lower, 0,
		    sizeof local_filter_addr_lower);
d239 1
a239 2
		snprintf(phase1_group, sizeof phase1_group, "%u",
		    is->group_desc);
d356 1
a356 2
			for (attr = proto->chosen->p +
			    ISAKMP_TRANSFORM_SA_ATTRS_OFF;
d368 1
a368 2
				value = attr + (fmt ?
				    ISAKMP_ATTR_LENGTH_VALUE_OFF :
a502 17
#if defined (USE_NAT_TRAVERSAL)
					else if (decode_16(value) == IPSEC_ENCAP_UDP_ENCAP_TUNNEL)
						switch (proto->proto) {
						case IPSEC_PROTO_IPSEC_AH:
							ah_encapsulation = "udp-encap-tunnel";
							break;

						case IPSEC_PROTO_IPSEC_ESP:
							esp_encapsulation = "udp-encap-tunnel";
							break;

						case IPSEC_PROTO_IPCOMP:
							comp_encapsulation = "udp-encap-tunnel";
							break;
						}
					/* XXX IPSEC_ENCAP_UDP_ENCAP_TRANSPORT */
#endif
d642 1
a642 2
		policy_sa->transport->vtbl->get_src(policy_sa->transport,
		    &sin);
d650 1
a650 2
		policy_sa->transport->vtbl->get_dst(policy_sa->transport,
		    &sin);
d680 1
a680 2
			net = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ);
d687 1
a687 2
				log_error("policy_callback: "
				    "strdup (\"%s\") failed",
d696 1
a696 2
			net = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ);
d699 1
a699 2
			net = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ + 4);
d706 2
a707 3
				log_error("policy_callback: "
				    "calloc (%d, %lu) failed", len,
				    (unsigned long)sizeof(char));
d718 2
a719 4
			net = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ);
			subnet = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ + 4);
d730 2
a731 3
				log_error("policy_callback: "
				    "calloc (%d, %lu) failed", len,
				    (unsigned long)sizeof(char));
d747 1
a747 2
				log_error("policy_callback: "
				    "strdup (\"%s\") failed",
d760 2
a761 2
			my_inet_ntop6(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ + 16, remote_id_addr_upper,
d768 2
a769 3
				log_error("policy_callback: "
				    "calloc (%d, %lu) failed", len,
				    (unsigned long)sizeof(char));
d785 2
a786 2
			bcopy(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 16,
			    &mask, sizeof(mask));
d791 1
a791 2
			my_inet_ntop6((unsigned char *)&net,
			    remote_id_addr_lower,
d797 1
a797 2
			my_inet_ntop6((unsigned char *)&net,
			    remote_id_addr_upper,
d804 2
a805 3
				log_error("policy_callback: "
				    "calloc (%d, %lu) failed", len,
				    (unsigned long)sizeof(char));
d819 1
a819 2
				log_error("policy_callback: "
				    "calloc (%lu, %lu) failed",
d825 1
a825 2
			memcpy(remote_id,
			    id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
d834 1
a834 2
				log_error("policy_callback: "
				    "calloc (%lu, %lu) failed",
d840 1
a840 2
			memcpy(remote_id,
			    id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
d866 1
a866 2
				log_error("policy_callback: "
				    "calloc (%lu, %lu) failed",
d868 1
a868 1
					ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1,
d873 1
a873 3
			for (i = 0;
			     i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ;
			     i++)
d880 1
a880 2
				    id_sz - ISAKMP_ID_DATA_OFF +
				    ISAKMP_GEN_SZ);
d885 1
a885 2
			    i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ;
			     i++) {
d894 1
a894 2
			log_print("policy_callback: "
			    "unknown remote ID type %u", id[0]);
d914 1
a914 2
			snprintf(remote_id_proto_num,
			    sizeof remote_id_proto_num, "%d",
d948 1
a948 2
				remote_filter =
				    strdup(remote_filter_addr_upper);
d963 1
a963 2
				net = decode_32(idremote + ISAKMP_ID_DATA_OFF +
				    4);
d975 1
a975 2
				strlcpy(remote_filter,
				    remote_filter_addr_lower, len);
d977 1
a977 2
				strlcat(remote_filter,
				    remote_filter_addr_upper, len);
d984 1
a984 2
				subnet = decode_32(idremote +
				    ISAKMP_ID_DATA_OFF + 4);
d1000 1
a1000 2
				strlcpy(remote_filter,
				    remote_filter_addr_lower, len);
d1002 1
a1002 2
				strlcat(remote_filter,
				    remote_filter_addr_upper, len);
d1013 1
a1013 2
				remote_filter =
				    strdup(remote_filter_addr_upper);
d1029 2
a1030 2
				my_inet_ntop6(idremote + ISAKMP_ID_DATA_OFF +
				    16, remote_filter_addr_upper,
d1042 1
a1042 2
				strlcpy(remote_filter,
				    remote_filter_addr_lower, len);
d1044 1
a1044 2
				strlcat(remote_filter,
				    remote_filter_addr_upper, len);
d1053 2
a1054 4
					bcopy(idremote + ISAKMP_ID_DATA_OFF,
					    &net, sizeof(net));
					bcopy(idremote + ISAKMP_ID_DATA_OFF +
					    16, &mask, sizeof(mask));
d1057 1
a1057 2
						net.s6_addr[i] &=
						    mask.s6_addr[i];
d1059 1
a1059 2
					my_inet_ntop6((unsigned char *)&net,
					    remote_filter_addr_lower,
d1063 1
a1063 2
						net.s6_addr[i] |=
						    ~mask.s6_addr[i];
d1065 1
a1065 2
					my_inet_ntop6((unsigned char *)&net,
					    remote_filter_addr_upper,
d1070 1
a1070 2
					remote_filter = calloc(len,
					    sizeof(char));
d1072 2
a1073 4
						log_error("policy_callback: "
						    "calloc (%d, %lu) failed",
						    len,
						    (unsigned long)sizeof(char));
d1076 1
a1076 2
					strlcpy(remote_filter,
					    remote_filter_addr_lower, len);
d1078 1
a1078 2
					strlcat(remote_filter,
					    remote_filter_addr_upper, len);
d1084 1
a1084 2
				remote_filter = malloc(idremotesz -
				    ISAKMP_ID_DATA_OFF + 1);
d1086 2
a1087 4
					log_error("policy_callback: "
					    "malloc (%lu) failed",
					    (unsigned long)idremotesz -
					    ISAKMP_ID_DATA_OFF + 1);
d1090 3
a1092 5
				memcpy(remote_filter,
				    idremote + ISAKMP_ID_DATA_OFF,
				    idremotesz - ISAKMP_ID_DATA_OFF);
				remote_filter[idremotesz - ISAKMP_ID_DATA_OFF]
				    = '\0';
d1097 1
a1097 2
				remote_filter = malloc(idremotesz -
				    ISAKMP_ID_DATA_OFF + 1);
d1099 2
a1100 4
					log_error("policy_callback: "
					    "malloc (%lu) failed",
					    (unsigned long)idremotesz -
					    ISAKMP_ID_DATA_OFF + 1);
d1103 3
a1105 5
				memcpy(remote_filter,
				    idremote + ISAKMP_ID_DATA_OFF,
				    idremotesz - ISAKMP_ID_DATA_OFF);
				remote_filter[idremotesz - ISAKMP_ID_DATA_OFF]
				    = '\0';
d1111 2
a1112 3
				remote_filter = x509_DN_string(idremote +
				    ISAKMP_ID_DATA_OFF,
				    idremotesz - ISAKMP_ID_DATA_OFF);
d1115 1
a1115 2
					    "policy_callback: "
					    "failed to decode name"));
d1128 2
a1129 3
					= calloc(2 * (idremotesz -
					    ISAKMP_ID_DATA_OFF) + 1,
					    sizeof(char));
d1131 3
a1133 5
					log_error("policy_callback: "
					    "calloc (%lu, %lu) failed",
					    2 * ((unsigned long)idremotesz -
						ISAKMP_ID_DATA_OFF) + 1,
					    (unsigned long)sizeof(char));
d1140 2
a1141 4
				for (i = 0;
				     i < idremotesz - ISAKMP_ID_DATA_OFF; i++)
					if (!isprint(*(idremote +
					    ISAKMP_ID_DATA_OFF + i)))
d1144 2
a1145 3
					memcpy(remote_filter,
					    idremote + ISAKMP_ID_DATA_OFF,
					    idremotesz - ISAKMP_ID_DATA_OFF);
d1149 1
a1149 3
				for (i = 0;
				     i < idremotesz - ISAKMP_ID_DATA_OFF;
				     i++) {
d1151 1
a1151 2
					    = hextab[*(idremote +
						ISAKMP_ID_DATA_OFF) >> 4];
d1153 1
a1153 2
					    = hextab[*(idremote +
						ISAKMP_ID_DATA_OFF) & 0xF];
d1158 2
a1159 3
				log_print("policy_callback: "
				    "unknown Remote ID type %u",
				    GET_ISAKMP_ID_TYPE(idremote));
d1180 2
a1181 2
				    sizeof remote_filter_proto_num, "%d",
				    idremote[ISAKMP_GEN_SZ + 1]);
d1186 2
a1187 2
			snprintf(remote_filter_port, sizeof remote_filter_port,
			    "%u", decode_16(idremote + ISAKMP_GEN_SZ + 2));
d1198 2
a1199 3
				log_print("policy_callback: "
				    "unsupported protocol family %d",
				    sin->sa_family);
d1203 1
a1203 2
				log_error("policy_callback: "
				    "sockaddr2text failed");
d1213 2
a1214 3
				log_error("policy_callback: "
				    "strdup (\"%s\") failed",
				    remote_filter_addr_upper);
d1231 2
a1232 3
					log_error("policy_callback: "
					    "strdup (\"%s\") failed",
					    local_filter_addr_upper);
d1243 1
a1243 2
				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF +
				    4);
d1250 2
a1251 3
					log_error("policy_callback: "
					    "calloc (%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
d1254 1
a1254 2
				strlcpy(local_filter, local_filter_addr_lower,
				    len);
d1256 1
a1256 2
				strlcat(local_filter, local_filter_addr_upper,
				    len);
d1263 1
a1263 2
				subnet = decode_32(idlocal +
				    ISAKMP_ID_DATA_OFF + 4);
d1274 2
a1275 3
					log_error("policy_callback: "
					    "calloc (%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
d1278 1
a1278 2
				strlcpy(local_filter, local_filter_addr_lower,
				    len);
d1280 1
a1280 2
				strlcat(local_filter, local_filter_addr_upper,
				    len);
d1288 2
a1289 3
				strlcpy(local_filter_addr_lower,
				    local_filter_addr_upper,
				    sizeof local_filter_addr_lower);
d1292 2
a1293 3
					log_error("policy_callback: "
					    "strdup (\"%s\") failed",
					    local_filter_addr_upper);
d1305 3
a1307 3
				my_inet_ntop6(idlocal + ISAKMP_ID_DATA_OFF +
				    16, local_filter_addr_upper,
				    sizeof local_filter_addr_upper - 1);
d1313 2
a1314 3
					log_error("policy_callback: "
					    "calloc (%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
d1317 1
a1317 2
				strlcpy(local_filter, local_filter_addr_lower,
				    len);
d1319 1
a1319 2
				strlcat(local_filter, local_filter_addr_upper,
				    len);
d1328 2
a1329 4
					bcopy(idlocal + ISAKMP_ID_DATA_OFF,
					    &net, sizeof(net));
					bcopy(idlocal + ISAKMP_ID_DATA_OFF +
					    16, &mask, sizeof(mask));
d1332 1
a1332 2
						net.s6_addr[i] &=
						    mask.s6_addr[i];
d1334 1
a1334 2
					my_inet_ntop6((unsigned char *)&net,
					    local_filter_addr_lower,
d1338 1
a1338 2
						net.s6_addr[i] |=
						    ~mask.s6_addr[i];
d1340 2
a1341 4
					my_inet_ntop6((unsigned char *)&net,
					    local_filter_addr_upper,
					    sizeof local_filter_addr_upper -
					    1);
d1344 2
a1345 4
					    + strlen(local_filter_addr_lower)
					    + 2;
					local_filter = calloc(len,
					    sizeof(char));
d1347 2
a1348 4
						log_error("policy_callback: "
						    "calloc (%d, %lu) failed",
						    len,
						    (unsigned long)sizeof(char));
d1351 1
a1351 2
					strlcpy(local_filter,
					    local_filter_addr_lower, len);
d1353 1
a1353 2
					strlcat(local_filter,
					    local_filter_addr_upper, len);
d1359 1
a1359 2
				local_filter = malloc(idlocalsz -
				    ISAKMP_ID_DATA_OFF + 1);
d1361 2
a1362 4
					log_error("policy_callback: "
					    "malloc (%lu) failed",
					    (unsigned long)idlocalsz -
					    ISAKMP_ID_DATA_OFF + 1);
d1365 3
a1367 5
				memcpy(local_filter,
				    idlocal + ISAKMP_ID_DATA_OFF,
				    idlocalsz - ISAKMP_ID_DATA_OFF);
				local_filter[idlocalsz - ISAKMP_ID_DATA_OFF]
				    = '\0';
d1372 1
a1372 2
				local_filter = malloc(idlocalsz -
				    ISAKMP_ID_DATA_OFF + 1);
d1374 2
a1375 4
					log_error("policy_callback: "
					    "malloc (%lu) failed",
					    (unsigned long)idlocalsz -
					    ISAKMP_ID_DATA_OFF + 1);
d1378 3
a1380 5
				memcpy(local_filter,
				    idlocal + ISAKMP_ID_DATA_OFF,
				    idlocalsz - ISAKMP_ID_DATA_OFF);
				local_filter[idlocalsz - ISAKMP_ID_DATA_OFF]
				    = '\0';
d1386 2
a1387 3
				local_filter = x509_DN_string(idlocal +
				    ISAKMP_ID_DATA_OFF,
				    idlocalsz - ISAKMP_ID_DATA_OFF);
d1390 1
a1390 2
					    "policy_callback: failed to decode"
					    " name"));
d1402 2
a1403 3
				local_filter = calloc(2 * (idlocalsz -
				    ISAKMP_ID_DATA_OFF) + 1,
				    sizeof(char));
d1405 3
a1407 5
					log_error("policy_callback: "
					    "calloc (%lu, %lu) failed",
					    2 * ((unsigned long)idlocalsz -
						ISAKMP_ID_DATA_OFF) + 1,
					    (unsigned long)sizeof(char));
d1414 2
a1415 4
				for (i = 0;
				     i < idlocalsz - ISAKMP_ID_DATA_OFF; i++)
					if (!isprint(*(idlocal +
					    ISAKMP_ID_DATA_OFF + i)))
d1418 1
a1418 2
					memcpy(local_filter, idlocal +
					    ISAKMP_ID_DATA_OFF,
d1423 1
a1423 2
				for (i = 0;
				     i < idlocalsz - ISAKMP_ID_DATA_OFF; i++) {
d1425 1
a1425 2
					    = hextab[*(idlocal +
						ISAKMP_ID_DATA_OFF) >> 4];
d1427 1
a1427 2
					    = hextab[*(idlocal +
						ISAKMP_ID_DATA_OFF) & 0xF];
d1432 2
a1433 3
				log_print("policy_callback: "
				    "unknown Local ID type %u",
				    GET_ISAKMP_ID_TYPE(idlocal));
d1453 2
a1454 3
				snprintf(local_filter_proto_num,
				    sizeof local_filter_proto_num,
				    "%d", idlocal[ISAKMP_GEN_SZ + 1]);
d1459 2
a1460 2
			snprintf(local_filter_port, sizeof local_filter_port,
			    "%u", decode_16(idlocal + ISAKMP_GEN_SZ + 2));
d1463 1
a1463 1
			    (struct sockaddr **)&sin);
d1472 2
a1473 3
				log_print("policy_callback: "
				    "unsupported protocol family %d",
				    sin->sa_family);
d1478 1
a1478 2
				log_error("policy_callback: "
				    "sockaddr2text failed");
d1482 1
a1482 1
			    sizeof local_filter_addr_upper);
d1484 1
a1484 1
			    sizeof local_filter_addr_lower);
d1488 2
a1489 3
				log_error("policy_callback: "
				    "strdup (\"%s\") failed",
				    local_filter_addr_upper);
d1494 1
a1494 2
		LOG_DBG((LOG_POLICY, 80,
		    "Policy context (action attributes):"));
d1503 8
a1510 16
		LOG_DBG((LOG_POLICY, 80, "ah_life_seconds == %s",
		    ah_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "ah_life_kbytes == %s",
		    ah_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "esp_life_seconds == %s",
		    esp_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "esp_life_kbytes == %s",
		    esp_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "comp_life_seconds == %s",
		    comp_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "comp_life_kbytes == %s",
		    comp_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "ah_encapsulation == %s",
		    ah_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "esp_encapsulation == %s",
		    esp_encapsulation));
d1512 10
a1521 19
		    comp_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "comp_dict_size == %s",
		    comp_dict_size));
		LOG_DBG((LOG_POLICY, 80, "comp_private_alg == %s",
		    comp_private_alg));
		LOG_DBG((LOG_POLICY, 80, "ah_key_length == %s",
		    ah_key_length));
		LOG_DBG((LOG_POLICY, 80, "ah_key_rounds == %s",
		    ah_key_rounds));
		LOG_DBG((LOG_POLICY, 80, "esp_key_length == %s",
		    esp_key_length));
		LOG_DBG((LOG_POLICY, 80, "esp_key_rounds == %s",
		    esp_key_rounds));
		LOG_DBG((LOG_POLICY, 80, "ah_group_desc == %s",
		    ah_group_desc));
		LOG_DBG((LOG_POLICY, 80, "esp_group_desc == %s",
		    esp_group_desc));
		LOG_DBG((LOG_POLICY, 80, "comp_group_desc == %s",
		    comp_group_desc));
d1526 1
a1526 1
		    remote_filter_type));
d1528 1
a1528 1
		    remote_filter_addr_upper));
d1530 1
a1530 1
		    remote_filter_addr_lower));
d1532 1
a1532 1
		    (remote_filter ? remote_filter : "")));
d1534 1
a1534 1
		    remote_filter_port));
d1536 2
a1537 3
		    remote_filter_proto));
		LOG_DBG((LOG_POLICY, 80, "local_filter_type == %s",
		    local_filter_type));
d1539 1
a1539 1
		    local_filter_addr_upper));
d1541 1
a1541 1
		    local_filter_addr_lower));
d1543 2
a1544 3
		    (local_filter ? local_filter : "")));
		LOG_DBG((LOG_POLICY, 80, "local_filter_port == %s",
		    local_filter_port));
d1546 2
a1547 3
		    local_filter_proto));
		LOG_DBG((LOG_POLICY, 80, "remote_id_type == %s",
		    remote_id_type));
d1549 1
a1549 1
		    remote_id_addr_upper));
d1551 1
a1551 1
		    remote_id_addr_lower));
d1553 3
a1555 5
		    (remote_id ? remote_id : "")));
		LOG_DBG((LOG_POLICY, 80, "remote_id_port == %s",
		    remote_id_port));
		LOG_DBG((LOG_POLICY, 80, "remote_id_proto == %s",
		    remote_id_proto));
d1557 1
a1557 1
		    remote_ike_address));
d1559 1
a1559 1
		    local_ike_address));
d1562 1
a1562 2
		LOG_DBG((LOG_POLICY, 80, "phase1_group_desc == %s",
		    phase1_group));
a1764 5
	/* Do we want to use the policy modules?  */
	if (ignore_policy ||
	    strncmp("yes", conf_get_str("General", "Use-Keynote"), 3))
		return;

d1770 4
d1777 1
a1777 8
		log_fatal("policy_init: open (\"%s\", O_RDONLY) failed",
		    policy_file);

	/* Check file modes and collect file size */
	if (check_file_secrecy_fd(fd, policy_file, &sz)) {
		close(fd);
		log_fatal("policy_init: cannot read %s", policy_file);
	}
d1782 2
a1783 2
		log_fatal("policy_init: calloc (%lu, %lu) failed",
		    (unsigned long)sz + 1, (unsigned long)sizeof(char));
d1789 2
a1790 2
			log_fatal("policy_init: read (%d, %p, %lu) failed", fd,
			    ptr + len, (unsigned long)(sz - len));
d1826 1
a1826 1
keynote_cert_get(u_int8_t *data, u_int32_t len)
d1828 1
a1828 1
	char	*foo = malloc(len + 1);
d1845 2
a1846 2
	char	**foo;
	int	  num, i;
d1874 2
a1875 2
	char	**foo;
	int	  num;
d1899 1
a1899 1
keynote_certreq_validate(u_int8_t *data, u_int32_t len)
d1902 2
a1903 2
	int	 err = 1;
	char	*dat;
d1907 2
a1908 2
		log_error("keynote_certreq_validate: calloc (%d, %lu) failed",
		    len + 1, (unsigned long)sizeof(char));
d1924 2
a1925 2
void *
keynote_certreq_decode(u_int8_t *data, u_int32_t len)
d1938 2
a1939 2
keynote_cert_obtain(u_int8_t *id, size_t id_len, void *data, u_int8_t **cert,
    u_int32_t *certlen)
d1966 2
a1967 2
		util_ntoa(&addr_str, idtype == IPSEC_ID_IPV4_ADDR ?
		    AF_INET : AF_INET6, id);
d1973 2
a1974 3
			log_error("keynote_cert_obtain: failed to allocate "
			    "%lu bytes", (unsigned long)len +
			    strlen(addr_str));
d1978 2
a1979 2
		snprintf(file, len + strlen(addr_str), "%s/%s/%s", dirname,
		    addr_str, CREDENTIAL_FILE);
d1984 2
a1985 1
	case IPSEC_ID_USER_FQDN: {
d1988 1
a1988 2
				log_error("keynote_cert_obtain: "
				    "failed to allocate %lu bytes",
d2003 3
a2005 4
	fd = monitor_open(file, O_RDONLY, 0);
	if (fd < 0) {
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: "
		    "failed to open \"%s\"", file));
a2008 8

	if (fstat(fd, &sb) < 0) {
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: "
		    "failed to stat \"%s\"", file));
		free(file);
		close(fd);
		return 0;
	}
d2018 7
a2024 1

d2026 2
a2027 3
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: "
		    "failed to read %lu bytes from \"%s\"",
		    (unsigned long)size, file));
d2056 1
a2056 2
		log_print("keynote_cert_get_key: "
		    "failed to decompose credentials");
d2061 2
a2062 2
		log_print("keynote_cert_get_key: "
		    "failed to initialize new policy session");
d2082 1
a2082 2
		if (kl->key_alg == KEYNOTE_ALGORITHM_RSA ||
		    kl->key_alg == KEYNOTE_ALGORITHM_X509) {
@


