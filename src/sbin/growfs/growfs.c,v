head	1.12;
access;
symbols
	tg-mergetmp-mirosx-1:1.12.2.1
	tg-mergefixes-1-branch:1.12.0.4
	tg-mergefixes-1-base:1.12
	MIROS_X:1.12.0.2
	MIROS_X_BASE:1.12
	tg-mergetmp-3:1.12
	MIRBSD_XP_MIRPPC:1.11.0.4
	MIRBSD_XP_SPARC_BASE:1.11
	MIRBSD_XP_SPARC:1.11.0.2
	MIRBSD_7quater:1.9
	cvs-200405160640:1.1.1.5
	cvs-200401271800:1.1.1.4
	cvs-200401261630:1.1.1.4
	cvs-200401021645:1.1.1.4
	MIRBSD_7_ALPHA:1.9.0.6
	MIRBSD_7:1.9.0.4
	cvs-200312222040:1.1.1.4
	MIRBSD_7ter:1.9
	MIRBSD_7_DEV:1.9.0.2
	cvs-200310020700:1.1.1.3
	cvs-200309271030:1.1.1.3
	cvs-200309251530:1.1.1.3
	cvs-200308302005:1.1.1.3
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.1
	openbsd:1.1.1
	MIRBSD_5:1.2
	MIRBSD_4:1.2;
locks; strict;
comment	@ * @;


1.12
date	2004.10.11.20.18.43;	author tg;	state Exp;
branches
	1.12.2.1
	1.12.4.1;
next	1.11;

1.11
date	2004.05.27.16.43.14;	author tg;	state Stab;
branches;
next	1.10;

1.10
date	2003.12.27.00.30.41;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.01.21.32.46;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.01.21.21.52;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.31.20.54.38;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.18.15.52.51;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.18.15.51.32;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.17.18.56.03;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.17.08.56.01;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.05.19.48.33;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.04.05.19.43.26;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.08.11.18.30.41;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.17.14.22.11;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.30.23.02.20;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.22.21.11.02;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.16.08.23.34;	author tg;	state Exp;
branches;
next	;

1.12.2.1
date	2004.12.28.12.59.35;	author tg;	state Exp;
branches;
next	;

1.12.4.1
date	2004.12.28.18.42.16;	author tg;	state Exp;
branches;
next	;


desc
@@


1.12
log
@From: Ted Unangst <tedu@@zeitbombe.org>
growfs fix, from part of freebsd commit
@
text
@/**	$MirBSD: src/sbin/growfs/growfs.c,v 1.11 2004/05/27 16:43:14 tg Stab $	*/

/*
 * growfs(8) from FreeBSD-current as of Mon Sep  1 21:04:19 UTC 2003
 * The UFS2 patch was applied backwards.
 */

/*
 * Copyright (c) 2000 Christoph Herrmann, Thomas-Henning von Kamptz
 * Copyright (c) 1980, 1989, 1993 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christoph Herrmann and Thomas-Henning von Kamptz, Munich and Frankfurt.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgment:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors, as well as Christoph
 *      Herrmann and Thomas-Henning von Kamptz.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $TSHeader: src/sbin/growfs/growfs.c,v 1.5 2000/12/12 19:31:00 tomsoft Exp $
 *
 */

/* ********************************************************** INCLUDES ***** */
#include <sys/param.h>
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/disk.h>

#include <stdio.h>
#include <paths.h>
#include <ctype.h>
#include <err.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include <ufs/ufs/dinode.h>
#include <ufs/ffs/fs.h>

#include "debug.h"

__RCSID("$MirBSD: src/sbin/growfs/growfs.c,v 1.11 2004/05/27 16:43:14 tg Stab $");

/* *************************************************** GLOBALS & TYPES ***** */
#ifdef FS_DEBUG
int	_dbg_lvl_ = (DL_INFO);	/* DL_TRC */
#endif /* FS_DEBUG */

static union {
	struct fs	fs;
	char	pad[SBSIZE];
} fsun1, fsun2;
#define	sblock	fsun1.fs	/* the new superblock */
#define	osblock	fsun2.fs	/* the old superblock */

static union {
	struct cg	cg;
	char	pad[MAXBSIZE];
} cgun1, cgun2;
#define	acg	cgun1.cg	/* a cylinder cgroup (new) */
#define	aocg	cgun2.cg	/* an old cylinder group */

static char	ablk[MAXBSIZE];		/* a block */
static char	i1blk[MAXBSIZE];	/* some indirect blocks */
static char	i2blk[MAXBSIZE];
static char	i3blk[MAXBSIZE];

	/* where to write back updated blocks */
static daddr_t	in_src, i1_src, i2_src, i3_src;

	/* what object contains the reference */
enum pointer_source {
	GFS_PS_INODE,
	GFS_PS_IND_BLK_LVL1,
	GFS_PS_IND_BLK_LVL2,
	GFS_PS_IND_BLK_LVL3
};

static struct csum	*fscs;		/* cylinder summary */
static ino_t		 maxino;	/* last valid inode */

static struct ufs1_dinode	zino[MAXBSIZE/sizeof(struct ufs1_dinode)]; /* some inodes */
static int		unlabeled = 0;	/* unlabeled partition, e.g. vinum volume etc. */

/*
 * An array of elements of type struct gfs_bpp describes all blocks to
 * be relocated in order to free the space needed for the cylinder group
 * summary for all cylinder groups located in the first cylinder group.
 */
struct gfs_bpp {
	daddr_t	old;		/* old block number */
	daddr_t	new;		/* new block number */
#define GFS_FL_FIRST	1
#define GFS_FL_LAST	2
	unsigned int	flags;	/* special handling required */
	int	found;		/* how many references were updated */
};

/* ******************************************************** PROTOTYPES ***** */
static void	growfs(int, int, unsigned int);
static void	rdfs(daddr_t, size_t, void *, int);
static void	wtfs(daddr_t, size_t, void *, int, unsigned int);
static daddr_t	alloc(void);
static int	charsperline(void);
static void	usage(void);
static int	isblock(struct fs *, unsigned char *, int);
static void	clrblock(struct fs *, unsigned char *, int);
static void	setblock(struct fs *, unsigned char *, int);
static void	initcg(int, time_t, int, unsigned int);
static void	updjcg(int, time_t, int, int, unsigned int);
static void	updcsloc(time_t, int, int, unsigned int);
static struct disklabel	*get_disklabel(int);
static void	return_disklabel(int, struct disklabel *, unsigned int);
static struct ufs1_dinode	*ginode(ino_t, int, int);
static void	frag_adjust(daddr_t, int);
static void	cond_bl_upd(ufs_daddr_t *, struct gfs_bpp *,
    enum pointer_source, int, unsigned int);
static void	updclst(int);
static void	updrefs(int, ino_t, struct gfs_bpp *, int, int, unsigned int);

/* ************************************************************ growfs ***** */
/*
 * Here we actually start growing the file system. We basically read the
 * cylinder summary from the first cylinder group as we want to update
 * this on the fly during our various operations. First we handle the
 * changes in the former last cylinder group. Afterwards we create all new
 * cylinder groups.  Now we handle the cylinder group containing the
 * cylinder summary which might result in a relocation of the whole
 * structure.  In the end we write back the updated cylinder summary, the
 * new superblock, and slightly patched versions of the super block
 * copies.
 */
static void
growfs(int fsi, int fso, unsigned int Nflag)
{
	DBG_FUNC("growfs")
	int	i;
	int	cylno, j;
	time_t	utime;
	int	width;
	char	tmpbuf[100];

	DBG_ENTER;

	time(&utime);

	/*
	 * Get the cylinder summary into the memory.
	 */
	fscs = (struct csum *)calloc((size_t)1, (size_t)sblock.fs_cssize);
	if(fscs == NULL) {
		errx(1, "calloc failed");
	}
	for (i = 0; i < osblock.fs_cssize; i += osblock.fs_bsize) {
		rdfs(fsbtodb(&osblock, osblock.fs_csaddr +
		    numfrags(&osblock, i)), (size_t)MIN(osblock.fs_cssize - i,
		    osblock.fs_bsize), (void *)(((char *)fscs)+i), fsi);
	}

#ifdef FS_DEBUG
{
	struct csum	*dbg_csp;
	int	dbg_csc;
	char	dbg_line[80];

	dbg_csp=fscs;
	for(dbg_csc=0; dbg_csc<osblock.fs_ncg; dbg_csc++) {
		snprintf(dbg_line, sizeof(dbg_line),
		    "%d. old csum in old location", dbg_csc);
		DBG_DUMP_CSUM(&osblock,
		    dbg_line,
		    dbg_csp++);
	}
}
#endif /* FS_DEBUG */
	DBG_PRINT0("fscs read\n");

	/*
	 * Do all needed changes in the former last cylinder group.
	 */
	updjcg(osblock.fs_ncg-1, utime, fsi, fso, Nflag);

	/*
	 * Dump out summary information about filesystem.
	 */
	printf("growfs:\t%d sectors in %d %s of %d tracks, %d sectors\n",
	    sblock.fs_size * NSPF(&sblock), sblock.fs_ncyl,
	    "cylinders", sblock.fs_ntrak, sblock.fs_nsect);
#define B2MBFACTOR (1 / (1024.0 * 1024.0))
	printf("\t%.1fMB in %d cyl groups (%d c/g, %.2fMB/g, %d i/g)\n",
	    (float)sblock.fs_size * sblock.fs_fsize * B2MBFACTOR,
	    sblock.fs_ncg, sblock.fs_cpg,
	    (float)sblock.fs_fpg * sblock.fs_fsize * B2MBFACTOR,
	    sblock.fs_ipg);
#undef B2MBFACTOR

	/*
	 * Now build the cylinders group blocks and
	 * then print out indices of cylinder groups.
	 */
	printf("superblock backups (for fsck -b #) at:\n");
	i = 0;
	width = charsperline();

	/*
	 * Iterate for only the new cylinder groups.
	 */
	for (cylno = osblock.fs_ncg; cylno < sblock.fs_ncg; cylno++) {
		initcg(cylno, utime, fso, Nflag);
		j = snprintf(tmpbuf, 100, " %d%s",
		    (int)fsbtodb(&sblock, cgsblock(&sblock, cylno)),
		    cylno < (sblock.fs_ncg - 1) ? "," : "");
		if (i + j >= width) {
			printf("\n");
			i = 0;
		}
		i += j;
		printf("%s", tmpbuf);
		fflush(stdout);
	}
	printf("\n");

	/*
	 * Do all needed changes in the first cylinder group.
	 * allocate blocks in new location
	 */
	updcsloc(utime, fsi, fso, Nflag);

	/*
	 * Now write the cylinder summary back to disk.
	 */
	for (i = 0; i < sblock.fs_cssize; i += sblock.fs_bsize) {
		wtfs(fsbtodb(&sblock, sblock.fs_csaddr + numfrags(&sblock, i)),
		    (size_t)MIN(sblock.fs_cssize - i, sblock.fs_bsize),
		    (void *)(((char *)fscs) + i), fso, Nflag);
	}
	DBG_PRINT0("fscs written\n");

#ifdef FS_DEBUG
{
	struct csum	*dbg_csp;
	int	dbg_csc;
	char	dbg_line[80];

	dbg_csp=fscs;
	for(dbg_csc=0; dbg_csc<sblock.fs_ncg; dbg_csc++) {
		snprintf(dbg_line, sizeof(dbg_line),
		    "%d. new csum in new location", dbg_csc);
		DBG_DUMP_CSUM(&sblock,
		    dbg_line,
		    dbg_csp++);
	}
}
#endif /* FS_DEBUG */

	/*
	 * Now write the new superblock back to disk.
	 */
	sblock.fs_time = utime;
	wtfs((daddr_t)(SBOFF / DEV_BSIZE), (size_t)SBSIZE, (void *)&sblock,
	    fso, Nflag);
	DBG_PRINT0("sblock written\n");
	DBG_DUMP_FS(&sblock,
	    "new initial sblock");

	/*
	 * Clean up the dynamic fields in our superblock copies.
	 */
	sblock.fs_fmod = 0;
	sblock.fs_clean = 1;
	sblock.fs_ronly = 0;
	sblock.fs_cgrotor = 0;
	sblock.fs_state = 0;
	memset((void *)&sblock.fs_fsmnt, 0, sizeof(sblock.fs_fsmnt));
	sblock.fs_flags &= FS_DOSOFTDEP;

	/*
	 * XXX
	 * The following fields are currently distributed from the superblock
	 * to the copies:
	 *     fs_minfree
	 *     fs_rotdelay
	 *     fs_maxcontig
	 *     fs_maxbpg
	 *     fs_minfree,
	 *     fs_optim
	 *     fs_flags regarding SOFTPDATES
	 *
	 * We probably should rather change the summary for the cylinder group
	 * statistics here to the value of what would be in there, if the file
	 * system were created initially with the new size. Therefor we still
	 * need to find an easy way of calculating that.
	 * Possibly we can try to read the first superblock copy and apply the
	 * "diffed" stats between the old and new superblock by still copying
	 * certain parameters onto that.
	 */

	/*
	 * Write out the duplicate superblocks.
	 */
	for (cylno = 0; cylno < sblock.fs_ncg; cylno++) {
		wtfs(fsbtodb(&sblock, cgsblock(&sblock, cylno)),
		    (size_t)SBSIZE, (void *)&sblock, fso, Nflag);
	}
	DBG_PRINT0("sblock copies written\n");
	DBG_DUMP_FS(&sblock,
	    "new other sblocks");

	DBG_LEAVE;
	return;
}

/* ************************************************************ initcg ***** */
/*
 * This creates a new cylinder group structure, for more details please see
 * the source of newfs(8), as this function is taken over almost unchanged.
 * As this is never called for the first cylinder group, the special
 * provisions for that case are removed here.
 */
static void
initcg(int cylno, time_t utime, int fso, unsigned int Nflag)
{
	DBG_FUNC("initcg")
	daddr_t cbase, d, dlower, dupper, dmax, blkno;
	int i;
	struct csum *cs;
	int j;

	DBG_ENTER;

	/*
	 * Determine block bounds for cylinder group.
	 */
	cbase = cgbase(&sblock, cylno);
	dmax = cbase + sblock.fs_fpg;
	if (dmax > sblock.fs_size) {
		dmax = sblock.fs_size;
	}
	dlower = cgsblock(&sblock, cylno) - cbase;
	dupper = cgdmin(&sblock, cylno) - cbase;
	if (cylno == 0) { /* XXX fscs may be relocated */
		dupper += howmany(sblock.fs_cssize, sblock.fs_fsize);
	}
	cs = fscs + cylno;
	memset(&acg, 0, (size_t)sblock.fs_cgsize);
	acg.cg_time = utime;
	acg.cg_magic = CG_MAGIC;
	acg.cg_cgx = cylno;
	if (cylno == sblock.fs_ncg - 1) {
		acg.cg_ncyl = sblock.fs_ncyl % sblock.fs_cpg;
	} else {
		acg.cg_ncyl = sblock.fs_cpg;
	}
	acg.cg_niblk = sblock.fs_ipg;
	acg.cg_ndblk = dmax - cbase;
	if (sblock.fs_contigsumsize > 0) {
		acg.cg_nclusterblks = acg.cg_ndblk / sblock.fs_frag;
	}
	acg.cg_btotoff = &acg.cg_space[0] - (u_char *)(&acg.cg_firstfield);
	acg.cg_boff = acg.cg_btotoff + sblock.fs_cpg * sizeof(int32_t);
	acg.cg_iusedoff = acg.cg_boff +
	    sblock.fs_cpg * sblock.fs_nrpos * sizeof(u_int16_t);
	acg.cg_freeoff = acg.cg_iusedoff + howmany(sblock.fs_ipg, NBBY);
	if (sblock.fs_contigsumsize <= 0) {
		acg.cg_nextfreeoff = acg.cg_freeoff +
		    howmany(sblock.fs_cpg * sblock.fs_spc / NSPF(&sblock), NBBY);
	} else {
		acg.cg_clustersumoff = acg.cg_freeoff + howmany
		    (sblock.fs_cpg * sblock.fs_spc / NSPF(&sblock), NBBY) -
		    sizeof(u_int32_t);
		acg.cg_clustersumoff =
		    roundup(acg.cg_clustersumoff, sizeof(u_int32_t));
		acg.cg_clusteroff = acg.cg_clustersumoff +
		    (sblock.fs_contigsumsize + 1) * sizeof(u_int32_t);
		acg.cg_nextfreeoff = acg.cg_clusteroff + howmany
		    (sblock.fs_cpg * sblock.fs_spc / NSPB(&sblock), NBBY);
	}
	if (acg.cg_nextfreeoff-(int)(&acg.cg_firstfield) > sblock.fs_cgsize) {
		/*
		 * XXX This should never happen as we would have had that panic
		 *     already on filesystem creation
		 */
		errx(37, "panic: cylinder group too big");
	}
	acg.cg_cs.cs_nifree += sblock.fs_ipg;
	if (cylno == 0)
		for (i = 0; (size_t)i < ROOTINO; i++) {
			setbit(cg_inosused(&acg), i);
			acg.cg_cs.cs_nifree--;
		}
	for (i = 0; i < sblock.fs_ipg / INOPF(&sblock); i += sblock.fs_frag) {
		for (j = 0; (unsigned)j < sblock.fs_bsize / sizeof(struct ufs1_dinode); j++) {
			zino[j].di_gen = arc4random();
		}
		wtfs(fsbtodb(&sblock, cgimin(&sblock, cylno) + i),
		    (size_t)sblock.fs_bsize, (void *)zino, fso, Nflag);
	}
	for (d = 0; d < dlower; d += sblock.fs_frag) {
		blkno = d / sblock.fs_frag;
		setblock(&sblock, cg_blksfree(&acg), blkno);
		if (sblock.fs_contigsumsize > 0) {
			setbit(cg_clustersfree(&acg), blkno);
		}
		acg.cg_cs.cs_nbfree++;
		cg_blktot(&acg)[cbtocylno(&sblock, d)]++;
		cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
		    [cbtorpos(&sblock, d)]++;
	}
	sblock.fs_dsize += dlower;
	sblock.fs_dsize += acg.cg_ndblk - dupper;
	if ((i = dupper % sblock.fs_frag)) {
		acg.cg_frsum[sblock.fs_frag - i]++;
		for (d = dupper + sblock.fs_frag - i; dupper < d; dupper++) {
			setbit(cg_blksfree(&acg), dupper);
			acg.cg_cs.cs_nffree++;
		}
	}
	for (d = dupper; d + sblock.fs_frag <= dmax - cbase;) {
		blkno = d / sblock.fs_frag;
		setblock(&sblock, cg_blksfree(&acg), blkno);
		if (sblock.fs_contigsumsize > 0) {
			setbit(cg_clustersfree(&acg), blkno);
		}
		acg.cg_cs.cs_nbfree++;
		cg_blktot(&acg)[cbtocylno(&sblock, d)]++;
		cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
		    [cbtorpos(&sblock, d)]++;
		d += sblock.fs_frag;
	}
	if (d < dmax - cbase) {
		acg.cg_frsum[dmax - cbase - d]++;
		for (; d < dmax - cbase; d++) {
			setbit(cg_blksfree(&acg), d);
			acg.cg_cs.cs_nffree++;
		}
	}
	if (sblock.fs_contigsumsize > 0) {
		int32_t	*sump = cg_clustersum(&acg);
		u_char	*mapp = cg_clustersfree(&acg);
		int	map = *mapp++;
		int	bit = 1;
		int	run = 0;

		for (i = 0; i < acg.cg_nclusterblks; i++) {
			if ((map & bit) != 0) {
				run++;
			} else if (run != 0) {
				if (run > sblock.fs_contigsumsize) {
					run = sblock.fs_contigsumsize;
				}
				sump[run]++;
				run = 0;
			}
			if ((i & (NBBY - 1)) != (NBBY - 1)) {
				bit <<= 1;
			} else {
				map = *mapp++;
				bit = 1;
			}
		}
		if (run != 0) {
			if (run > sblock.fs_contigsumsize) {
				run = sblock.fs_contigsumsize;
			}
			sump[run]++;
		}
	}
	sblock.fs_cstotal.cs_ndir += acg.cg_cs.cs_ndir;
	sblock.fs_cstotal.cs_nffree += acg.cg_cs.cs_nffree;
	sblock.fs_cstotal.cs_nbfree += acg.cg_cs.cs_nbfree;
	sblock.fs_cstotal.cs_nifree += acg.cg_cs.cs_nifree;
	*cs = acg.cg_cs;
	wtfs(fsbtodb(&sblock, cgtod(&sblock, cylno)),
	    (size_t)sblock.fs_bsize, (void *)&acg, fso, Nflag);
	DBG_DUMP_CG(&sblock,
	    "new cg",
	    &acg);

	DBG_LEAVE;
	return;
}

/* ******************************************************* frag_adjust ***** */
/*
 * Here we add or subtract (sign +1/-1) the available fragments in a given
 * block to or from the fragment statistics. By subtracting before and adding
 * after an operation on the free frag map we can easy update the fragment
 * statistic, which seems to be otherwise an rather complex operation.
 */
static void
frag_adjust(daddr_t frag, int sign)
{
	DBG_FUNC("frag_adjust")
	int fragsize;
	int f;

	DBG_ENTER;

	fragsize=0;
	/*
	 * Here frag only needs to point to any fragment in the block we want
	 * to examine.
	 */
	for(f=rounddown(frag, sblock.fs_frag);
	    f<roundup(frag+1, sblock.fs_frag);
	    f++) {
		/*
		 * Count contiguous free fragments.
		 */
		if(isset(cg_blksfree(&acg), f)) {
			fragsize++;
		} else {
			if(fragsize && fragsize<sblock.fs_frag) {
				/*
				 * We found something in between.
				 */
				acg.cg_frsum[fragsize]+=sign;
				DBG_PRINT2("frag_adjust [%d]+=%d\n",
				    fragsize,
				    sign);
			}
			fragsize=0;
		}
	}
	if(fragsize && fragsize<sblock.fs_frag) {
		/*
		 * We found something.
		 */
		acg.cg_frsum[fragsize]+=sign;
		DBG_PRINT2("frag_adjust [%d]+=%d\n",
		    fragsize,
		    sign);
	}
	DBG_PRINT2("frag_adjust [[%d]]+=%d\n",
	    fragsize,
	    sign);

	DBG_LEAVE;
	return;
}

/* ******************************************************* cond_bl_upd ***** */
/*
 * Here we conditionally update a pointer to a fragment. We check for all
 * relocated blocks if any of its fragments is referenced by the current
 * field, and update the pointer to the respective fragment in our new
 * block.  If we find a reference we write back the block immediately,
 * as there is no easy way for our general block reading engine to figure
 * out if a write back operation is needed.
 */
static void
cond_bl_upd(ufs_daddr_t *block, struct gfs_bpp *field,
    enum pointer_source source, int fso, unsigned int Nflag)
{
	DBG_FUNC("cond_bl_upd")
	struct gfs_bpp	*f;
	char *src;
	daddr_t dst=0;

	DBG_ENTER;

	f=field;
	while(f->old) { /* for all old blocks */
		if(*block/sblock.fs_frag == f->old) {
			/*
			 * The fragment is part of the block, so update.
			 */
			*block = (f->new * sblock.fs_frag + (*block % sblock.fs_frag));
			f->found++;
			DBG_PRINT3("scg (%d->%d)[%d] reference updated\n",
			    f->old,
			    f->new,
			    *block%sblock.fs_frag);

			/* Write the block back to disk immediately */
			switch (source) {
			case GFS_PS_INODE:
				src=ablk;
				dst=in_src;
				break;
			case GFS_PS_IND_BLK_LVL1:
				src=i1blk;
				dst=i1_src;
				break;
			case GFS_PS_IND_BLK_LVL2:
				src=i2blk;
				dst=i2_src;
				break;
			case GFS_PS_IND_BLK_LVL3:
				src=i3blk;
				dst=i3_src;
				break;
			default:	/* error */
				src=NULL;
				break;
			}
			if(src) {
				/*
				 * XXX	If src is not of type inode we have to
				 *	implement  copy on write here in  case
				 *	of active snapshots.
				 */
				wtfs(dst, (size_t)sblock.fs_bsize, (void *)src,
				    fso, Nflag);
			}

			/*
			 * The same block can't be found again in this loop.
			 */
			break;
		}
		f++;
	}

	DBG_LEAVE;
	return;
}

/* ************************************************************ updjcg ***** */
/*
 * Here we do all needed work for the former last cylinder group. It has to be
 * changed in any case, even if the file system ended exactly on the end of
 * this group, as there is some slightly inconsistent handling of the number
 * of cylinders in the cylinder group. We start again by reading the cylinder
 * group from disk. If the last block was not fully available, we first handle
 * the missing fragments, then we handle all new full blocks in that file
 * system and finally we handle the new last fragmented block in the file
 * system.  We again have to handle the fragment statistics rotational layout
 * tables and cluster summary during all those operations.
 */
static void
updjcg(int cylno, time_t utime, int fsi, int fso, unsigned int Nflag)
{
	DBG_FUNC("updjcg")
	daddr_t	cbase, dmax, dupper;
	struct csum	*cs;
	int	i,k;
	int	j=0;

	DBG_ENTER;

	/*
	 * Read the former last (joining) cylinder group from disk, and make
	 * a copy.
	 */
	rdfs(fsbtodb(&osblock, cgtod(&osblock, cylno)),
	    (size_t)osblock.fs_cgsize, (void *)&aocg, fsi);
	DBG_PRINT0("jcg read\n");
	DBG_DUMP_CG(&sblock,
	    "old joining cg",
	    &aocg);

	memcpy((void *)&cgun1, (void *)&cgun2, sizeof(cgun2));

	/*
	 * If the cylinder group had already its new final size almost
	 * nothing is to be done ... except:
	 * For some reason the value of cg_ncyl in the last cylinder group has
	 * to be zero instead of fs_cpg. As this is now no longer the last
	 * cylinder group we have to change that value now to fs_cpg.
	 */

	if(cgbase(&osblock, cylno+1) == osblock.fs_size) {
		acg.cg_ncyl=sblock.fs_cpg;

		wtfs(fsbtodb(&sblock, cgtod(&sblock, cylno)),
		    (size_t)sblock.fs_cgsize, (void *)&acg, fso, Nflag);
		DBG_PRINT0("jcg written\n");
		DBG_DUMP_CG(&sblock,
		    "new joining cg",
		    &acg);

		DBG_LEAVE;
		return;
	}

	/*
	 * Set up some variables needed later.
	 */
	cbase = cgbase(&sblock, cylno);
	dmax = cbase + sblock.fs_fpg;
	if (dmax > sblock.fs_size)
		dmax = sblock.fs_size;
	dupper = cgdmin(&sblock, cylno) - cbase;
	if (cylno == 0) { /* XXX fscs may be relocated */
		dupper += howmany(sblock.fs_cssize, sblock.fs_fsize);
	}

	/*
	 * Set pointer to the cylinder summary for our cylinder group.
	 */
	cs = fscs + cylno;

	/*
	 * Touch the cylinder group, update all fields in the cylinder group as
	 * needed, update the free space in the superblock.
	 */
	acg.cg_time = utime;
	if (cylno == sblock.fs_ncg - 1) {
		/*
		 * This is still the last cylinder group.
		 */
		acg.cg_ncyl = sblock.fs_ncyl % sblock.fs_cpg;
	} else {
		acg.cg_ncyl = sblock.fs_cpg;
	}
	DBG_PRINT4("jcg dbg: %d %u %d %u\n",
	    cylno,
	    sblock.fs_ncg,
	    acg.cg_ncyl,
	    sblock.fs_cpg);
	acg.cg_ndblk = dmax - cbase;
	sblock.fs_dsize += acg.cg_ndblk-aocg.cg_ndblk;
	if (sblock.fs_contigsumsize > 0) {
		acg.cg_nclusterblks = acg.cg_ndblk / sblock.fs_frag;
	}

	/*
	 * Now we have to update the free fragment bitmap for our new free
	 * space.  There again we have to handle the fragmentation and also
	 * the rotational layout tables and the cluster summary.  This is
	 * also done per fragment for the first new block if the old file
	 * system end was not on a block boundary, per fragment for the new
	 * last block if the new filesystem end is not on a block boundary,
	 * and per block for all space in between.
	 *
	 * Handle the first new block here if it was partially available
	 * before.
	 */
	if(osblock.fs_size % sblock.fs_frag) {
		if(roundup(osblock.fs_size, sblock.fs_frag)<=sblock.fs_size) {
			/*
			 * The new space is enough to fill at least this
			 * block
			 */
			j=0;
			for(i=roundup(osblock.fs_size-cbase, sblock.fs_frag)-1;
			    i>=osblock.fs_size-cbase;
			    i--) {
				setbit(cg_blksfree(&acg), i);
				acg.cg_cs.cs_nffree++;
				j++;
			}

			/*
			 * Check if the fragment just created could join an
			 * already existing fragment at the former end of the
			 * filesystem.
			 */
			if(isblock(&sblock, cg_blksfree(&acg),
			    ((osblock.fs_size - cgbase(&sblock, cylno))/
			    sblock.fs_frag))) {
				/*
				 * The block is now completely available.
				 */
				DBG_PRINT0("block was\n");
				acg.cg_frsum[osblock.fs_size%sblock.fs_frag]--;
				acg.cg_cs.cs_nbfree++;
				acg.cg_cs.cs_nffree-=sblock.fs_frag;
				k=rounddown(osblock.fs_size-cbase,
				    sblock.fs_frag);
				cg_blktot(&acg)[cbtocylno(&sblock, k)]++;
				cg_blks(&sblock, &acg, cbtocylno(&sblock, k))
		   		    [cbtorpos(&sblock, k)]++;
				updclst((osblock.fs_size-cbase)/sblock.fs_frag);
			} else {
				/*
				 * Lets rejoin a possible partially growed
				 * fragment.
				 */
				k=0;
				while(isset(cg_blksfree(&acg), i) &&
				    (i>=rounddown(osblock.fs_size-cbase,
				    sblock.fs_frag))) {
					i--;
					k++;
				}
				if(k) {
					acg.cg_frsum[k]--;
				}
				acg.cg_frsum[k+j]++;
			}
		} else {
			/*
			 * We only grow by some fragments within this last
			 * block.
			 */
			for(i=sblock.fs_size-cbase-1;
				i>=osblock.fs_size-cbase;
				i--) {
				setbit(cg_blksfree(&acg), i);
				acg.cg_cs.cs_nffree++;
				j++;
			}
			/*
			 * Lets rejoin a possible partially growed fragment.
			 */
			k=0;
			while(isset(cg_blksfree(&acg), i) &&
			    (i>=rounddown(osblock.fs_size-cbase,
			    sblock.fs_frag))) {
				i--;
				k++;
			}
			if(k) {
				acg.cg_frsum[k]--;
			}
			acg.cg_frsum[k+j]++;
		}
	}

	/*
	 * Handle all new complete blocks here.
	 */
	for(i=roundup(osblock.fs_size-cbase, sblock.fs_frag);
	    i+sblock.fs_frag<=dmax-cbase;	/* XXX <= or only < ? */
	    i+=sblock.fs_frag) {
		j = i / sblock.fs_frag;
		setblock(&sblock, cg_blksfree(&acg), j);
		updclst(j);
		acg.cg_cs.cs_nbfree++;
		cg_blktot(&acg)[cbtocylno(&sblock, i)]++;
		cg_blks(&sblock, &acg, cbtocylno(&sblock, i))
		    [cbtorpos(&sblock, i)]++;
	}

	/*
	 * Handle the last new block if there are stll some new fragments left.
	 * Here we don't have to bother about the cluster summary or the even
	 * the rotational layout table.
	 */
	if (i < (dmax - cbase)) {
		acg.cg_frsum[dmax - cbase - i]++;
		for (; i < dmax - cbase; i++) {
			setbit(cg_blksfree(&acg), i);
			acg.cg_cs.cs_nffree++;
		}
	}

	sblock.fs_cstotal.cs_nffree +=
	    (acg.cg_cs.cs_nffree - aocg.cg_cs.cs_nffree);
	sblock.fs_cstotal.cs_nbfree +=
	    (acg.cg_cs.cs_nbfree - aocg.cg_cs.cs_nbfree);
	/*
	 * The following statistics are not changed here:
	 *     sblock.fs_cstotal.cs_ndir
	 *     sblock.fs_cstotal.cs_nifree
	 * As the statistics for this cylinder group are ready, copy it to
	 * the summary information array.
	 */
	*cs = acg.cg_cs;

	/*
	 * Write the updated "joining" cylinder group back to disk.
	 */
	wtfs(fsbtodb(&sblock, cgtod(&sblock, cylno)), (size_t)sblock.fs_cgsize,
	    (void *)&acg, fso, Nflag);
	DBG_PRINT0("jcg written\n");
	DBG_DUMP_CG(&sblock,
	    "new joining cg",
	    &acg);

	DBG_LEAVE;
	return;
}

/* ********************************************************** updcsloc ***** */
/*
 * Here we update the location of the cylinder summary. We have two possible
 * ways of growing the cylinder summary.
 * (1)	We can try to grow the summary in the current location, and relocate
 *	possibly used blocks within the current cylinder group.
 * (2)	Alternatively we can relocate the whole cylinder summary to the first
 *	new completely empty cylinder group. Once the cylinder summary is no
 *	longer in the beginning of the first cylinder group you should never
 *	use a version of fsck which is not aware of the possibility to have
 *	this structure in a non standard place.
 * Option (1) is considered to be less intrusive to the structure of the file-
 * system. So we try to stick to that whenever possible. If there is not enough
 * space in the cylinder group containing the cylinder summary we have to use
 * method (2). In case of active snapshots in the file system we probably can
 * completely avoid implementing copy on write if we stick to method (2) only.
 */
static void
updcsloc(time_t utime, int fsi, int fso, unsigned int Nflag)
{
	DBG_FUNC("updcsloc")
	struct csum	*cs;
	int	ocscg, ncscg;
	int	blocks;
	daddr_t	cbase, dupper, odupper, d, f, g;
	int	ind;
	int	cylno, inc;
	struct gfs_bpp	*bp;
	int	i, l;
	int	lcs=0;
	int	block;

	DBG_ENTER;

	if(howmany(sblock.fs_cssize, sblock.fs_fsize) ==
	    howmany(osblock.fs_cssize, osblock.fs_fsize)) {
		/*
		 * No new fragment needed.
		 */
		DBG_LEAVE;
		return;
	}
	ocscg=dtog(&osblock, osblock.fs_csaddr);
	cs=fscs+ocscg;
	blocks = 1+howmany(sblock.fs_cssize, sblock.fs_bsize)-
	    howmany(osblock.fs_cssize, osblock.fs_bsize);

	/*
	 * Read original cylinder group from disk, and make a copy.
	 * XXX	If Nflag is set in some very rare cases we now miss
	 *	some changes done in updjcg by reading the unmodified
	 *	block from disk.
	 */
	rdfs(fsbtodb(&osblock, cgtod(&osblock, ocscg)),
	    (size_t)osblock.fs_cgsize, (void *)&aocg, fsi);
	DBG_PRINT0("oscg read\n");
	DBG_DUMP_CG(&sblock,
	    "old summary cg",
	    &aocg);

	memcpy((void *)&cgun1, (void *)&cgun2, sizeof(cgun2));

	/*
	 * Touch the cylinder group, set up local variables needed later
	 * and update the superblock.
	 */
	acg.cg_time = utime;

	/*
	 * XXX	In the case of having active snapshots we may need much more
	 *	blocks for the copy on write. We need each block twice, and
	 *	also up to 8*3 blocks for indirect blocks for all possible
	 *	references.
	 */
	if(/*((int)sblock.fs_time&0x3)>0||*/ cs->cs_nbfree < blocks) {
		/*
		 * There is not enough space in the old cylinder group to
		 * relocate all blocks as needed, so we relocate the whole
		 * cylinder group summary to a new group. We try to use the
		 * first complete new cylinder group just created. Within the
		 * cylinder group we align the area immediately after the
		 * cylinder group information location in order to be as
		 * close as possible to the original implementation of ffs.
		 *
		 * First we have to make sure we'll find enough space in the
		 * new cylinder group. If not, then we currently give up.
		 * We start with freeing everything which was used by the
		 * fragments of the old cylinder summary in the current group.
		 * Now we write back the group meta data, read in the needed
		 * meta data from the new cylinder group, and start allocating
		 * within that group. Here we can assume, the group to be
		 * completely empty. Which makes the handling of fragments and
		 * clusters a lot easier.
		 */
		DBG_TRC;
		if(sblock.fs_ncg-osblock.fs_ncg < 2) {
			errx(2, "panic: not enough space");
		}

		/*
		 * Point "d" to the first fragment not used by the cylinder
		 * summary.
		 */
		d=osblock.fs_csaddr+(osblock.fs_cssize/osblock.fs_fsize);

		/*
		 * Set up last cluster size ("lcs") already here. Calculate
		 * the size for the trailing cluster just behind where "d"
		 * points to.
		 */
		if(sblock.fs_contigsumsize > 0) {
			for(block=howmany(d%sblock.fs_fpg, sblock.fs_frag),
			    lcs=0; lcs<sblock.fs_contigsumsize;
			    block++, lcs++) {
				if(isclr(cg_clustersfree(&acg), block)){
					break;
				}
			}
		}

		/*
		 * Point "d" to the last frag used by the cylinder summary.
		 */
		d--;

		DBG_PRINT1("d=%d\n", d);
		if((d+1)%sblock.fs_frag) {
			/*
			 * The end of the cylinder summary is not a complete
			 * block.
			 */
			DBG_TRC;
			frag_adjust(d%sblock.fs_fpg, -1);
			for(; (d+1)%sblock.fs_frag; d--) {
				DBG_PRINT1("d=%d\n", d);
				setbit(cg_blksfree(&acg), d%sblock.fs_fpg);
				acg.cg_cs.cs_nffree++;
				sblock.fs_cstotal.cs_nffree++;
			}
			/*
			 * Point "d" to the last fragment of the last
			 * (incomplete) block of the cylinder summary.
			 */
			d++;
			frag_adjust(d%sblock.fs_fpg, 1);

			if(isblock(&sblock, cg_blksfree(&acg),
			    (d%sblock.fs_fpg)/sblock.fs_frag)) {
				DBG_PRINT1("d=%d\n", d);
				acg.cg_cs.cs_nffree-=sblock.fs_frag;
				acg.cg_cs.cs_nbfree++;
				sblock.fs_cstotal.cs_nffree-=sblock.fs_frag;
				sblock.fs_cstotal.cs_nbfree++;
				cg_blktot(&acg)[cbtocylno(&sblock,
				    d%sblock.fs_fpg)]++;
				cg_blks(&sblock, &acg, cbtocylno(&sblock,
				    d%sblock.fs_fpg))[cbtorpos(&sblock,
				    d%sblock.fs_fpg)]++;
				if(sblock.fs_contigsumsize > 0) {
					setbit(cg_clustersfree(&acg),
					    (d%sblock.fs_fpg)/sblock.fs_frag);
					if(lcs < sblock.fs_contigsumsize) {
						if(lcs) {
							cg_clustersum(&acg)
							    [lcs]--;
						}
						lcs++;
						cg_clustersum(&acg)[lcs]++;
					}
				}
			}
			/*
			 * Point "d" to the first fragment of the block before
			 * the last incomplete block.
			 */
			d--;
		}

		DBG_PRINT1("d=%d\n", d);
		for(d=rounddown(d, sblock.fs_frag); d >= osblock.fs_csaddr;
		    d-=sblock.fs_frag) {
			DBG_TRC;
			DBG_PRINT1("d=%d\n", d);
			setblock(&sblock, cg_blksfree(&acg),
			    (d%sblock.fs_fpg)/sblock.fs_frag);
			acg.cg_cs.cs_nbfree++;
			sblock.fs_cstotal.cs_nbfree++;
			cg_blktot(&acg)[cbtocylno(&sblock, d%sblock.fs_fpg)]++;
			cg_blks(&sblock, &acg, cbtocylno(&sblock,
			    d%sblock.fs_fpg))[cbtorpos(&sblock,
			    d%sblock.fs_fpg)]++;
			if(sblock.fs_contigsumsize > 0) {
				setbit(cg_clustersfree(&acg),
				    (d%sblock.fs_fpg)/sblock.fs_frag);
				/*
				 * The last cluster size is already set up.
				 */
				if(lcs < sblock.fs_contigsumsize) {
					if(lcs) {
						cg_clustersum(&acg)[lcs]--;
					}
					lcs++;
					cg_clustersum(&acg)[lcs]++;
				}
			}
		}
		*cs = acg.cg_cs;

		/*
		 * Now write the former cylinder group containing the cylinder
		 * summary back to disk.
		 */
		wtfs(fsbtodb(&sblock, cgtod(&sblock, ocscg)),
		    (size_t)sblock.fs_cgsize, (void *)&acg, fso, Nflag);
		DBG_PRINT0("oscg written\n");
		DBG_DUMP_CG(&sblock,
		    "old summary cg",
		    &acg);

		/*
		 * Find the beginning of the new cylinder group containing the
		 * cylinder summary.
		 */
		sblock.fs_csaddr=cgdmin(&sblock, osblock.fs_ncg);
		ncscg=dtog(&sblock, sblock.fs_csaddr);
		cs=fscs+ncscg;


		/*
		 * If Nflag is specified, we would now read random data instead
		 * of an empty cg structure from disk. So we can't simulate that
		 * part for now.
		 */
		if(Nflag) {
			DBG_PRINT0("nscg update skipped\n");
			DBG_LEAVE;
			return;
		}

		/*
		 * Read the future cylinder group containing the cylinder
		 * summary from disk, and make a copy.
		 */
		rdfs(fsbtodb(&sblock, cgtod(&sblock, ncscg)),
		    (size_t)sblock.fs_cgsize, (void *)&aocg, fsi);
		DBG_PRINT0("nscg read\n");
		DBG_DUMP_CG(&sblock,
		    "new summary cg",
		    &aocg);

		memcpy((void *)&cgun1, (void *)&cgun2, sizeof(cgun2));

		/*
		 * Allocate all complete blocks used by the new cylinder
		 * summary.
		 */
		for(d=sblock.fs_csaddr; d+sblock.fs_frag <=
		    sblock.fs_csaddr+(sblock.fs_cssize/sblock.fs_fsize);
		    d+=sblock.fs_frag) {
			clrblock(&sblock, cg_blksfree(&acg),
			    (d%sblock.fs_fpg)/sblock.fs_frag);
			acg.cg_cs.cs_nbfree--;
			sblock.fs_cstotal.cs_nbfree--;
			cg_blktot(&acg)[cbtocylno(&sblock, d%sblock.fs_fpg)]--;
			cg_blks(&sblock, &acg, cbtocylno(&sblock,
			    d%sblock.fs_fpg))[cbtorpos(&sblock,
			    d%sblock.fs_fpg)]--;
			if(sblock.fs_contigsumsize > 0) {
				clrbit(cg_clustersfree(&acg),
				    (d%sblock.fs_fpg)/sblock.fs_frag);
			}
		}

		/*
		 * Allocate all fragments used by the cylinder summary in the
		 * last block.
		 */
		if(d<sblock.fs_csaddr+(sblock.fs_cssize/sblock.fs_fsize)) {
			for(; d-sblock.fs_csaddr<
			    sblock.fs_cssize/sblock.fs_fsize;
			    d++) {
				clrbit(cg_blksfree(&acg), d%sblock.fs_fpg);
				acg.cg_cs.cs_nffree--;
				sblock.fs_cstotal.cs_nffree--;
			}
			acg.cg_cs.cs_nbfree--;
			acg.cg_cs.cs_nffree+=sblock.fs_frag;
			sblock.fs_cstotal.cs_nbfree--;
			sblock.fs_cstotal.cs_nffree+=sblock.fs_frag;
			cg_blktot(&acg)[cbtocylno(&sblock, d%sblock.fs_fpg)]--;
			cg_blks(&sblock, &acg, cbtocylno(&sblock,
			    d%sblock.fs_fpg))[cbtorpos(&sblock,
			    d%sblock.fs_fpg)]--;
			if(sblock.fs_contigsumsize > 0) {
				clrbit(cg_clustersfree(&acg),
				    (d%sblock.fs_fpg)/sblock.fs_frag);
			}

			frag_adjust(d%sblock.fs_fpg, +1);
		}
		/*
		 * XXX	Handle the cluster statistics here in the case this
		 *	cylinder group is now almost full, and the remaining
		 *	space is less than the maximum cluster size. This is
		 *	probably not needed, as you would hardly find a file
		 *	system which has only MAXCSBUFS+FS_MAXCONTIG of free
		 *	space right behind the cylinder group information in
		 *	any new cylinder group.
		 */

		/*
		 * Update our statistics in the cylinder summary.
		 */
		*cs = acg.cg_cs;

		/*
		 * Write the new cylinder group containing the cylinder summary
		 * back to disk.
		 */
		wtfs(fsbtodb(&sblock, cgtod(&sblock, ncscg)),
		    (size_t)sblock.fs_cgsize, (void *)&acg, fso, Nflag);
		DBG_PRINT0("nscg written\n");
		DBG_DUMP_CG(&sblock,
		    "new summary cg",
		    &acg);

		DBG_LEAVE;
		return;
	}
	/*
	 * We have got enough of space in the current cylinder group, so we
	 * can relocate just a few blocks, and let the summary information
	 * grow in place where it is right now.
	 */
	DBG_TRC;

	cbase = cgbase(&osblock, ocscg);	/* old and new are equal */
	dupper = sblock.fs_csaddr - cbase +
	    howmany(sblock.fs_cssize, sblock.fs_fsize);
	odupper = osblock.fs_csaddr - cbase +
	    howmany(osblock.fs_cssize, osblock.fs_fsize);

	sblock.fs_dsize -= dupper-odupper;

	/*
	 * Allocate the space for the array of blocks to be relocated.
	 */
 	bp=(struct gfs_bpp *)malloc(((dupper-odupper)/sblock.fs_frag+2)*
	    sizeof(struct gfs_bpp));
	if(bp == NULL) {
		errx(1, "malloc failed");
	}
	memset((char *)bp, 0, ((dupper-odupper)/sblock.fs_frag+2)*
	    sizeof(struct gfs_bpp));

	/*
	 * Lock all new frags needed for the cylinder group summary. This is
	 * done per fragment in the first and last block of the new required
	 * area, and per block for all other blocks.
	 *
	 * Handle the first new block here (but only if some fragments where
	 * already used for the cylinder summary).
	 */
	ind=0;
	frag_adjust(odupper, -1);
	for(d=odupper; ((d<dupper)&&(d%sblock.fs_frag)); d++) {
		DBG_PRINT1("scg first frag check loop d=%d\n",
		    d);
		if(isclr(cg_blksfree(&acg), d)) {
			if (!ind) {
				bp[ind].old=d/sblock.fs_frag;
				bp[ind].flags|=GFS_FL_FIRST;
				if(roundup(d, sblock.fs_frag) >= dupper) {
					bp[ind].flags|=GFS_FL_LAST;
				}
				ind++;
			}
		} else {
			clrbit(cg_blksfree(&acg), d);
			acg.cg_cs.cs_nffree--;
			sblock.fs_cstotal.cs_nffree--;
		}
		/*
		 * No cluster handling is needed here, as there was at least
		 * one fragment in use by the cylinder summary in the old
		 * filesystem.
		 * No block-free counter handling here as this block was not
		 * a free block.
		 */
	}
	frag_adjust(odupper, 1);

	/*
	 * Handle all needed complete blocks here.
	 */
	for(; d+sblock.fs_frag<=dupper; d+=sblock.fs_frag) {
		DBG_PRINT1("scg block check loop d=%d\n",
		    d);
		if(!isblock(&sblock, cg_blksfree(&acg), d/sblock.fs_frag)) {
			for(f=d; f<d+sblock.fs_frag; f++) {
				if(isset(cg_blksfree(&aocg), f)) {
					acg.cg_cs.cs_nffree--;
					sblock.fs_cstotal.cs_nffree--;
				}
			}
			clrblock(&sblock, cg_blksfree(&acg), d/sblock.fs_frag);
			bp[ind].old=d/sblock.fs_frag;
			ind++;
		} else {
			clrblock(&sblock, cg_blksfree(&acg), d/sblock.fs_frag);
			acg.cg_cs.cs_nbfree--;
			sblock.fs_cstotal.cs_nbfree--;
			cg_blktot(&acg)[cbtocylno(&sblock, d)]--;
			cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
			    [cbtorpos(&sblock, d)]--;
			if(sblock.fs_contigsumsize > 0) {
				clrbit(cg_clustersfree(&acg), d/sblock.fs_frag);
				for(lcs=0, l=(d/sblock.fs_frag)+1;
				    lcs<sblock.fs_contigsumsize;
				    l++, lcs++) {
					if(isclr(cg_clustersfree(&acg),l)){
						break;
					}
				}
				if(lcs < sblock.fs_contigsumsize) {
					cg_clustersum(&acg)[lcs+1]--;
					if(lcs) {
						cg_clustersum(&acg)[lcs]++;
					}
				}
			}
		}
		/*
		 * No fragment counter handling is needed here, as this finally
		 * doesn't change after the relocation.
		 */
	}

	/*
	 * Handle all fragments needed in the last new affected block.
	 */
	if(d<dupper) {
		frag_adjust(dupper-1, -1);

		if(isblock(&sblock, cg_blksfree(&acg), d/sblock.fs_frag)) {
			acg.cg_cs.cs_nbfree--;
			sblock.fs_cstotal.cs_nbfree--;
			acg.cg_cs.cs_nffree+=sblock.fs_frag;
			sblock.fs_cstotal.cs_nffree+=sblock.fs_frag;
			cg_blktot(&acg)[cbtocylno(&sblock, d)]--;
			cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
			    [cbtorpos(&sblock, d)]--;
			if(sblock.fs_contigsumsize > 0) {
				clrbit(cg_clustersfree(&acg), d / sblock.fs_frag);
				for (lcs = 0, l = (d / sblock.fs_frag) + 1;
				    lcs < sblock.fs_contigsumsize;
				    l++, lcs++) {
					if(isclr(cg_clustersfree(&acg),l)){
						break;
					}
				}
				if(lcs < sblock.fs_contigsumsize) {
					cg_clustersum(&acg)[lcs+1]--;
					if(lcs) {
						cg_clustersum(&acg)[lcs]++;
					}
				}
			}
		}

		for(; d<dupper; d++) {
			DBG_PRINT1("scg second frag check loop d=%d\n",
			    d);
			if(isclr(cg_blksfree(&acg), d)) {
				bp[ind].old = d / sblock.fs_frag;
				bp[ind].flags |= GFS_FL_LAST;
			} else {
				clrbit(cg_blksfree(&acg), d);
				acg.cg_cs.cs_nffree--;
				sblock.fs_cstotal.cs_nffree--;
			}
		}
		if(bp[ind].flags & GFS_FL_LAST) { /* we have to advance here */
			ind++;
		}
		frag_adjust(dupper-1, 1);
	}

	/*
	 * If we found a block to relocate just do so.
	 */
	if(ind) {
		for(i=0; i<ind; i++) {
			if(!bp[i].old) { /* no more blocks listed */
				/*
				 * XXX	A relative blocknumber should not be
				 *	zero, which is not explicitly
				 *	guaranteed by our code.
				 */
				break;
			}
			/*
			 * Allocate a complete block in the same (current)
			 * cylinder group.
			 */
			bp[i].new=alloc()/sblock.fs_frag;

			/*
			 * There is no frag_adjust() needed for the new block
			 * as it will have no fragments yet :-).
			 */
			for(f=bp[i].old*sblock.fs_frag,
			    g=bp[i].new*sblock.fs_frag;
			    f<(bp[i].old+1)*sblock.fs_frag;
			    f++, g++) {
				if(isset(cg_blksfree(&aocg), f)) {
					setbit(cg_blksfree(&acg), g);
					acg.cg_cs.cs_nffree++;
					sblock.fs_cstotal.cs_nffree++;
				}
			}

			/*
			 * Special handling is required if this was the first
			 * block. We have to consider the fragments which were
			 * used by the cylinder summary in the original block
			 * which re to be free in the copy of our block.  We
			 * have to be careful if this first block happens to
			 * be also the last block to be relocated.
			 */
			if(bp[i].flags & GFS_FL_FIRST) {
				for(f=bp[i].old*sblock.fs_frag,
				    g=bp[i].new*sblock.fs_frag;
				    f<odupper;
				    f++, g++) {
					setbit(cg_blksfree(&acg), g);
					acg.cg_cs.cs_nffree++;
					sblock.fs_cstotal.cs_nffree++;
				}
				if(!(bp[i].flags & GFS_FL_LAST)) {
					frag_adjust(bp[i].new*sblock.fs_frag,1);
				}
			}

			/*
			 * Special handling is required if this is the last
			 * block to be relocated.
			 */
			if(bp[i].flags & GFS_FL_LAST) {
				frag_adjust(bp[i].new*sblock.fs_frag, 1);
				frag_adjust(bp[i].old*sblock.fs_frag, -1);
				for(f=dupper;
				    f<roundup(dupper, sblock.fs_frag);
				    f++) {
					if(isclr(cg_blksfree(&acg), f)) {
						setbit(cg_blksfree(&acg), f);
						acg.cg_cs.cs_nffree++;
						sblock.fs_cstotal.cs_nffree++;
					}
				}
				frag_adjust(bp[i].old*sblock.fs_frag, 1);
			}

			/*
			 * !!! Attach the cylindergroup offset here.
			 */
			bp[i].old+=cbase/sblock.fs_frag;
			bp[i].new+=cbase/sblock.fs_frag;

			/*
			 * Copy the content of the block.
			 */
			/*
			 * XXX	Here we will have to implement a copy on write
			 *	in the case we have any active snapshots.
			 */
			rdfs(fsbtodb(&sblock, bp[i].old*sblock.fs_frag),
			    (size_t)sblock.fs_bsize, (void *)&ablk, fsi);
			wtfs(fsbtodb(&sblock, bp[i].new*sblock.fs_frag),
			    (size_t)sblock.fs_bsize, (void *)&ablk, fso, Nflag);
			DBG_DUMP_HEX(&sblock, "copied full block",
			    (unsigned char *)&ablk);

			DBG_PRINT2("scg (%d->%d) block relocated\n",
			    bp[i].old, bp[i].new);
		}

		/*
		 * Now we have to update all references to any fragment which
		 * belongs to any block relocated. We iterate now over all
		 * cylinder groups, within those over all non zero length
		 * inodes.
		 */
		for (cylno=0; cylno < osblock.fs_ncg; cylno++) {
			DBG_PRINT1("scg doing cg (%d)\n", cylno);
			for (inc = osblock.fs_ipg - 1; inc > 0; inc--) {
				updrefs(cylno, (ino_t)inc, bp, fsi, fso, Nflag);
			}
		}

		/*
		 * All inodes are checked, now make sure the number of
		 * references found make sense.
		 */
		for(i=0; i<ind; i++) {
			if(!bp[i].found || (bp[i].found>sblock.fs_frag)) {
				warnx("error: %d refs found for block %d.",
				    bp[i].found, bp[i].old);
			}

		}
	}
	/*
	 * The following statistics are not changed here:
	 *     sblock.fs_cstotal.cs_ndir
	 *     sblock.fs_cstotal.cs_nifree
	 * The following statistics were already updated on the fly:
	 *     sblock.fs_cstotal.cs_nffree
	 *     sblock.fs_cstotal.cs_nbfree
	 * As the statistics for this cylinder group are ready, copy it to
	 * the summary information array.
	 */

	*cs = acg.cg_cs;

	/*
	 * Write summary cylinder group back to disk.
	 */
	wtfs(fsbtodb(&sblock, cgtod(&sblock, ocscg)), (size_t)sblock.fs_cgsize,
	    (void *)&acg, fso, Nflag);
	DBG_PRINT0("scg written\n");
	DBG_DUMP_CG(&sblock,
	    "new summary cg",
	    &acg);

	DBG_LEAVE;
}

/* ************************************************************** rdfs ***** */
/*
 * Here we read some block(s) from disk.
 */
static void
rdfs(daddr_t bno, size_t size, void *bf, int fsi)
{
	DBG_FUNC("rdfs")
	ssize_t	n;

	DBG_ENTER;

	if (bno < 0)
		err(32, "rdfs: attempting to read negative block number");

	if (lseek(fsi, (off_t)bno * DEV_BSIZE, 0) < 0) {
		err(33, "rdfs: seek error: %ld", (long)bno);
	}
	n = read(fsi, bf, size);
	if (n != (ssize_t)size) {
		err(34, "rdfs: read error: %ld", (long)bno);
	}

	DBG_LEAVE;
}

/* ************************************************************** wtfs ***** */
/*
 * Here we write some block(s) to disk.
 */
static void
wtfs(daddr_t bno, size_t size, void *bf, int fso, unsigned int Nflag)
{
	DBG_FUNC("wtfs")
	ssize_t	n;

	DBG_ENTER;

	if (Nflag) {
		DBG_LEAVE;
		return;
	}
	if (lseek(fso, (off_t)bno * DEV_BSIZE, SEEK_SET) < 0) {
		err(35, "wtfs: seek error: %ld", (long)bno);
	}
	n = write(fso, bf, size);
	if (n != (ssize_t)size) {
		err(36, "wtfs: write error: %ld", (long)bno);
	}

	DBG_LEAVE;
}

/* ************************************************************* alloc ***** */
/*
 * Here we allocate a free block in the current cylinder group. It is assumed,
 * that acg contains the current cylinder group. As we may take a block from
 * somewhere in the filesystem we have to handle cluster summary here.
 */
static daddr_t
alloc(void)
{
	DBG_FUNC("alloc")
	daddr_t	d, blkno;
	int	lcs1, lcs2;
	int	l;
	int	csmin, csmax;
	int	dlower, dupper, dmax;

	DBG_ENTER;

	if (acg.cg_magic != CG_MAGIC) {
		warnx("acg: bad magic number");
		DBG_LEAVE;
		return (0);
	}
	if (acg.cg_cs.cs_nbfree == 0) {
		warnx("error: cylinder group ran out of space");
		DBG_LEAVE;
		return (0);
	}
	/*
	 * We start seeking for free blocks only from the space available after
	 * the end of the new grown cylinder summary. Otherwise we allocate a
	 * block here which we have to relocate a couple of seconds later again
	 * again, and we are not prepared to to this anyway.
	 */
	blkno = -1;
	dlower = cgsblock(&sblock, acg.cg_cgx) - cgbase(&sblock, acg.cg_cgx);
	dupper = cgdmin(&sblock, acg.cg_cgx) - cgbase(&sblock, acg.cg_cgx);
	dmax = cgbase(&sblock, acg.cg_cgx) + sblock.fs_fpg;
	if (dmax > sblock.fs_size) {
		dmax = sblock.fs_size;
	}
	dmax -= cgbase(&sblock, acg.cg_cgx); /* retransform into cg */
	csmin = sblock.fs_csaddr - cgbase(&sblock, acg.cg_cgx);
	csmax = csmin + howmany(sblock.fs_cssize, sblock.fs_fsize);
	DBG_PRINT3("seek range: dl=%d, du=%d, dm=%d\n",
	    dlower, dupper, dmax);
	DBG_PRINT2("range cont: csmin=%d, csmax=%d\n", csmin, csmax);

	for (d = 0; (d < dlower && blkno == -1); d += sblock.fs_frag) {
		if(d>=csmin && d<=csmax) {
			continue;
		}
		if(isblock(&sblock, cg_blksfree(&acg), fragstoblks(&sblock,
		    d))) {
			blkno = fragstoblks(&sblock, d);/* Yeah found a block */
			break;
		}
	}
	for (d = dupper; (d < dmax && blkno == -1); d += sblock.fs_frag) {
		if(d>=csmin && d<=csmax) {
			continue;
		}
		if(isblock(&sblock, cg_blksfree(&acg), fragstoblks(&sblock,
		    d))) {
			blkno = fragstoblks(&sblock, d);/* Yeah found a block */
			break;
		}
	}
	if(blkno==-1) {
		warnx("internal error: couldn't find promised block in cg");
		DBG_LEAVE;
		return (0);
	}

	/*
	 * This is needed if the block was found already in the first loop.
	 */
	d=blkstofrags(&sblock, blkno);

	clrblock(&sblock, cg_blksfree(&acg), blkno);
	if (sblock.fs_contigsumsize > 0) {
		/*
		 * Handle the cluster allocation bitmap.
		 */
		clrbit(cg_clustersfree(&acg), blkno);
		/*
		 * We possibly have split a cluster here, so we have to do
		 * recalculate the sizes of the remaining cluster halves now,
		 * and use them for updating the cluster summary information.
		 *
		 * Lets start with the blocks before our allocated block ...
		 */
		for(lcs1=0, l=blkno-1; lcs1<sblock.fs_contigsumsize;
		    l--, lcs1++) {
			if(isclr(cg_clustersfree(&acg),l)){
				break;
			}
		}
		/*
		 * ... and continue with the blocks right after our allocated
		 * block.
		 */
		for(lcs2=0, l=blkno+1; lcs2<sblock.fs_contigsumsize;
		    l++, lcs2++) {
			if(isclr(cg_clustersfree(&acg),l)){
				break;
			}
		}

		/*
		 * Now update all counters.
		 */
		cg_clustersum(&acg)[MIN(lcs1+lcs2+1,sblock.fs_contigsumsize)]--;
		if(lcs1) {
			cg_clustersum(&acg)[lcs1]++;
		}
		if(lcs2) {
			cg_clustersum(&acg)[lcs2]++;
		}
	}
	/*
	 * Update all statistics based on blocks.
	 */
	acg.cg_cs.cs_nbfree--;
	sblock.fs_cstotal.cs_nbfree--;
	cg_blktot(&acg)[cbtocylno(&sblock, d)]--;
	cg_blks(&sblock, &acg, cbtocylno(&sblock, d))[cbtorpos(&sblock, d)]--;

	DBG_LEAVE;
	return (d);
}

/* *********************************************************** isblock ***** */
/*
 * Here we check if all frags of a block are free. For more details again
 * please see the source of newfs(8), as this function is taken over almost
 * unchanged.
 */
static int
isblock(struct fs *fs, unsigned char *cp, int h)
{
	DBG_FUNC("isblock")
	unsigned char	mask;

	DBG_ENTER;

	switch (fs->fs_frag) {
	case 8:
		DBG_LEAVE;
		return (cp[h] == 0xff);
	case 4:
		mask = 0x0f << ((h & 0x1) << 2);
		DBG_LEAVE;
		return ((cp[h >> 1] & mask) == mask);
	case 2:
		mask = 0x03 << ((h & 0x3) << 1);
		DBG_LEAVE;
		return ((cp[h >> 2] & mask) == mask);
	case 1:
		mask = 0x01 << (h & 0x7);
		DBG_LEAVE;
		return ((cp[h >> 3] & mask) == mask);
	default:
		fprintf(stderr, "isblock bad fs_frag %d\n", fs->fs_frag);
		DBG_LEAVE;
		return (0);
	}
}

/* ********************************************************** clrblock ***** */
/*
 * Here we allocate a complete block in the block map. For more details again
 * please see the source of newfs(8), as this function is taken over almost
 * unchanged.
 */
static void
clrblock(struct fs *fs, unsigned char *cp, int h)
{
	DBG_FUNC("clrblock")

	DBG_ENTER;

	switch ((fs)->fs_frag) {
	case 8:
		cp[h] = 0;
		break;
	case 4:
		cp[h >> 1] &= ~(0x0f << ((h & 0x1) << 2));
		break;
	case 2:
		cp[h >> 2] &= ~(0x03 << ((h & 0x3) << 1));
		break;
	case 1:
		cp[h >> 3] &= ~(0x01 << (h & 0x7));
		break;
	default:
		warnx("clrblock bad fs_frag %d", fs->fs_frag);
		break;
	}

	DBG_LEAVE;
}

/* ********************************************************** setblock ***** */
/*
 * Here we free a complete block in the free block map. For more details again
 * please see the source of newfs(8), as this function is taken over almost
 * unchanged.
 */
static void
setblock(struct fs *fs, unsigned char *cp, int h)
{
	DBG_FUNC("setblock")

	DBG_ENTER;

	switch (fs->fs_frag) {
	case 8:
		cp[h] = 0xff;
		break;
	case 4:
		cp[h >> 1] |= (0x0f << ((h & 0x1) << 2));
		break;
	case 2:
		cp[h >> 2] |= (0x03 << ((h & 0x3) << 1));
		break;
	case 1:
		cp[h >> 3] |= (0x01 << (h & 0x7));
		break;
	default:
		warnx("setblock bad fs_frag %d", fs->fs_frag);
		break;
	}

	DBG_LEAVE;
}

/* ************************************************************ ginode ***** */
/*
 * This function provides access to an individual inode. We find out in which
 * block the requested inode is located, read it from disk if needed, and
 * return the pointer into that block. We maintain a cache of one block to
 * not read the same block again and again if we iterate linearly over all
 * inodes.
 */
static struct ufs1_dinode *
ginode(ino_t inumber, int fsi, int cg)
{
	DBG_FUNC("ginode")
	ufs_daddr_t	iblk;
	static ino_t	startinum=0;	/* first inode in cached block */
	struct ufs1_dinode	*pi;

	DBG_ENTER;

	pi=(struct ufs1_dinode *)(void *)ablk;
	inumber+=(cg * sblock.fs_ipg);
	if (inumber < ROOTINO) {
		DBG_LEAVE;
		return NULL;
	}
	if (inumber > maxino)
		errx(8, "bad inode number %d to ginode", inumber);
	if (startinum == 0 || inumber < startinum ||
	    inumber >= startinum + INOPB(&sblock)) {
		/*
		 * The block needed is not cached, so we have to read it from
		 * disk now.
		 */
		iblk = ino_to_fsba(&sblock, inumber);
		in_src=fsbtodb(&sblock, iblk);
		rdfs(in_src, (size_t)sblock.fs_bsize, (void *)&ablk, fsi);
		startinum = (inumber / INOPB(&sblock)) * INOPB(&sblock);
	}

	DBG_LEAVE;
	return (&(pi[inumber % INOPB(&sblock)]));
}

/* ****************************************************** charsperline ***** */
/*
 * Figure out how many lines our current terminal has. For more details again
 * please see the source of newfs(8), as this function is taken over almost
 * unchanged.
 */
static int
charsperline(void)
{
	DBG_FUNC("charsperline")
	int	columns;
	char	*cp;
	struct winsize	ws;

	DBG_ENTER;

	columns = 0;
	if (ioctl(0, TIOCGWINSZ, &ws) != -1) {
		columns = ws.ws_col;
	}
	if (columns == 0 && (cp = getenv("COLUMNS"))) {
		columns = atoi(cp);
	}
	if (columns == 0) {
		columns = 80;	/* last resort */
	}

	DBG_LEAVE;
	return columns;
}

/* ************************************************************** main ***** */
/*
 * growfs(8)  is a utility which allows to increase the size of an existing
 * ufs file system. Currently this can only be done on unmounted file system.
 * It recognizes some command line options to specify the new desired size,
 * and it does some basic checkings. The old file system size is determined
 * and after some more checks like we can really access the new last block
 * on the disk etc. we calculate the new parameters for the superblock. After
 * having done this we just call growfs() which will do the work.  Before
 * we finish the only thing left is to update the disklabel.
 * We still have to provide support for snapshots. Therefore we first have to
 * understand what data structures are always replicated in the snapshot on
 * creation, for all other blocks we touch during our procedure, we have to
 * keep the old blocks unchanged somewhere available for the snapshots. If we
 * are lucky, then we only have to handle our blocks to be relocated in that
 * way.
 * Also we have to consider in what order we actually update the critical
 * data structures of the file system to make sure, that in case of a disaster
 * fsck(8) is still able to restore any lost data.
 * The foreseen last step then will be to provide for growing even mounted
 * file systems. There we have to extend the mount() system call to provide
 * userland access to the filesystem locking facility.
 */
int
main(int argc, char **argv)
{
	DBG_FUNC("main")
	char	*device, *rdev;
	char	ch;
	unsigned int	size=0;
	unsigned int	Nflag=0;
	int	ExpertFlag=0;
	struct stat	st;
	struct disklabel	*lp;
	struct partition	*pp;
	int	fsi,fso;
	u_int32_t p_size;
	char	reply[5];
#ifdef FSMAXSNAP
	int	j;
#endif /* FSMAXSNAP */

	DBG_ENTER;

	while ((ch = getopt(argc, argv, "Ns:y")) != -1) {
		switch (ch) {
		case 'N':
			Nflag=1;
			break;
		case 's':
			size = (size_t)atol(optarg);
			if(size < 1) {
				usage();
			}
			break;
		case 'y':
			ExpertFlag=1;
			break;
		case '?':
			/* FALLTHROUGH */
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if(argc != 1) {
		usage();
	}
	device=*argv;

	/*
	 * Rather than guessing, use opendev() to get the device
	 * name, which we open for reading.
	 */
	if ((fsi = opendev(device, O_RDONLY, 0, &rdev)) < 0)
		err(1, "%s", rdev);

	/*
	 * Try to access our device for writing ...
	 */
	if (Nflag) {
		fso = -1;
	} else {
		fso = open(rdev, O_WRONLY);
		if (fso < 0)
			err(1, "%s", rdev);
	}

	/*
	 * Now we have a file descriptor for our device, fstat() it to
	 * figure out the partition number.
	 */
	if (fstat(fsi, &st) != 0)
		err(1, "%s: fstat()", rdev);

	/*
	 * Try to read a label from the disk.  Then get the partition from the
	 * device minor number, using DISKPART().  Probably don't need to
	 * check against getmaxpartitions().
	 */
	lp = get_disklabel(fsi);
	if (DISKPART(st.st_rdev) < getmaxpartitions())
		pp = &lp->d_partitions[DISKPART(st.st_rdev)];
	else
		errx(1, "%s: invalid partition number %u",
		    rdev, DISKPART(st.st_rdev));

	p_size = pp->p_size;
	/*
	 * Check if that partition is suitable for growing a file system.
	 */
	if (p_size < 1) {
		errx(1, "partition is unavailable");
	}
	if (!unlabeled) if (pp->p_fstype != FS_BSDFFS) {
		errx(1, "partition not 4.2BSD");
	}

	/*
	 * Read the current superblock, and take a backup.
	 */
	rdfs((daddr_t)(SBOFF / DEV_BSIZE), (size_t)SBSIZE, &osblock, fsi);
	if (osblock.fs_magic != FS_MAGIC)
		errx(1, "superblock not recognized");
	memcpy((void *)&fsun1, (void *)&fsun2, sizeof(fsun2));
	maxino = sblock.fs_ncg * sblock.fs_ipg;

	DBG_OPEN("/tmp/growfs.debug"); /* already here we need a superblock */
	DBG_DUMP_FS(&sblock,
	    "old sblock");

	/*
	 * Determine size to grow to. Default to the full size specified in
	 * the disk label.
	 */
	sblock.fs_size = dbtofsb(&osblock, p_size);
	if (size != 0) {
		if (size > p_size){
			errx(1, "There is not enough space (%d < %d)",
			    p_size, size);
		}
		sblock.fs_size = dbtofsb(&osblock, size);
	}

	/*
	 * Are we really growing ?
	 */
	if(osblock.fs_size >= sblock.fs_size) {
		errx(1, "we are not growing (%d->%d)", osblock.fs_size,
		    sblock.fs_size);
	}


#ifdef FSMAXSNAP
	/*
	 * Check if we find an active snapshot.
	 */
	if(ExpertFlag == 0) {
		for (j = 0; j < FSMAXSNAP; j++) {
			if(sblock.fs_snapinum[j]) {
				errx(1, "active snapshot found in filesystem\n"
				    "	please remove all snapshots before "
				    "using growfs");
			}
			if(!sblock.fs_snapinum[j]) { /* list is dense */
				break;
			}
		}
	}
#endif

	if (ExpertFlag == 0 && Nflag == 0) {
		printf("We strongly recommend you to make a backup "
		    "before growing the Filesystem\n\n"
		    " Did you backup your data (Yes/No) ? ");
		fgets(reply, (int)sizeof(reply), stdin);
		if (strcmp(reply, "Yes\n")){
			printf("\n Nothing done \n");
			exit (0);
		}
	}

	printf("new filesystemsize is: %d frags\n", sblock.fs_size);

	/*
	 * Try to access our new last block in the filesystem. Even if we
	 * later on realize we have to abort our operation, on that block
	 * there should be no data, so we can't destroy something yet.
	 */
	wtfs((daddr_t)p_size-1, (size_t)DEV_BSIZE, (void *)&sblock, fso,
	    Nflag);

	/*
	 * Now calculate new superblock values and check for reasonable
	 * bound for new filesystem size:
	 *     fs_size:    is derived from label or user input
	 *     fs_dsize:   should get updated in the routines creating or
	 *                 updating the cylinder groups on the fly
	 *     fs_cstotal: should get updated in the routines creating or
	 *                 updating the cylinder groups
	 */

	/*
	 * Update the number of cylinders in the filesystem.
	 */
	sblock.fs_ncyl = sblock.fs_size * NSPF(&sblock) / sblock.fs_spc;
	if (sblock.fs_size * NSPF(&sblock) > sblock.fs_ncyl * sblock.fs_spc) {
		sblock.fs_ncyl++;
	}

	/*
	 * Update the number of cylinder groups in the filesystem.
	 */
	sblock.fs_ncg = sblock.fs_ncyl / sblock.fs_cpg;
	if (sblock.fs_ncyl % sblock.fs_cpg) {
		sblock.fs_ncg++;
	}

	if ((sblock.fs_size - (sblock.fs_ncg-1) * sblock.fs_fpg) <
	    sblock.fs_fpg && cgdmin(&sblock, (sblock.fs_ncg-1))-
	    cgbase(&sblock, (sblock.fs_ncg-1)) > (sblock.fs_size -
	    (sblock.fs_ncg-1) * sblock.fs_fpg)) {
		/*
		 * The space in the new last cylinder group is too small,
		 * so revert back.
		 */
		sblock.fs_ncg--;
#if 1 /* this is a bit more safe */
		sblock.fs_ncyl = sblock.fs_ncg * sblock.fs_cpg;
#else
		sblock.fs_ncyl -= sblock.fs_ncyl % sblock.fs_cpg;
#endif
		sblock.fs_ncyl -= sblock.fs_ncyl % sblock.fs_cpg;
		printf("Warning: %d sector(s) cannot be allocated.\n",
		    (sblock.fs_size-(sblock.fs_ncg)*sblock.fs_fpg) *
		    NSPF(&sblock));
		sblock.fs_size = sblock.fs_ncyl * sblock.fs_spc / NSPF(&sblock);
	}

	/*
	 * Update the space for the cylinder group summary information in the
	 * respective cylinder group data area.
	 */
	sblock.fs_cssize =
	    fragroundup(&sblock, sblock.fs_ncg * sizeof(struct csum));

	if(osblock.fs_size >= sblock.fs_size) {
		errx(1, "not enough new space");
	}

	DBG_PRINT0("sblock calculated\n");

	/*
	 * Ok, everything prepared, so now let's do the tricks.
	 */
	growfs(fsi, fso, Nflag);

	/*
	 * Update the disk label.
	 */
    if (!unlabeled) {
        pp->p_fsize = sblock.fs_fsize;
        pp->p_frag = sblock.fs_frag;
        pp->p_cpg = sblock.fs_fpg;

        return_disklabel(fso, lp, Nflag);
        DBG_PRINT0("label rewritten\n");
    }

	close(fsi);
	if (fso > -1)
		close(fso);

	DBG_CLOSE;

	DBG_LEAVE;
	return 0;
}

/* ************************************************** return_disklabel ***** */
/*
 * Write the updated disklabel back to disk.
 */
static void
return_disklabel(int fd, struct disklabel *lp, unsigned int Nflag)
{
	DBG_FUNC("return_disklabel")
	u_short	sum;
	u_short	*ptr;

	DBG_ENTER;

	if(!lp) {
		DBG_LEAVE;
		return;
	}
	if(!Nflag) {
		lp->d_checksum=0;
		sum = 0;
		ptr = (u_short *)lp;

		/*
		 * recalculate checksum
		 */
		while(ptr < (u_short *)&lp->d_partitions[lp->d_npartitions]) {
			sum ^= *ptr++;
		}
		lp->d_checksum=sum;

		if (ioctl(fd, DIOCWDINFO, (char *)lp) < 0) {
			errx(1, "DIOCWDINFO failed");
		}
	}
	free(lp);

	DBG_LEAVE;
	return ;
}

/* ***************************************************** get_disklabel ***** */
/*
 * Read the disklabel from disk.
 */
static struct disklabel *
get_disklabel(int fd)
{
	DBG_FUNC("get_disklabel")
	static struct	disklabel *lab;

	DBG_ENTER;

	lab=(struct disklabel *)malloc(sizeof(struct disklabel));
	if (!lab)
		errx(1, "malloc failed");

    if (!ioctl(fd, DIOCGDINFO, (char *)lab))
        return (lab);

    unlabeled++;

	DBG_LEAVE;
	return (NULL);
}


/* ************************************************************* usage ***** */
/*
 * Dump a line of usage.
 */
static void
usage(void)
{
	DBG_FUNC("usage")

	DBG_ENTER;

	fprintf(stderr, "usage: growfs [-Ny] [-s size] special\n");

	DBG_LEAVE;
	exit(1);
}

/* *********************************************************** updclst ***** */
/*
 * This updates most parameters and the bitmap related to cluster. We have to
 * assume that sblock, osblock, acg are set up.
 */
static void
updclst(int block)
{
	DBG_FUNC("updclst")
	static int	lcs=0;

	DBG_ENTER;

	if(sblock.fs_contigsumsize < 1) { /* no clustering */
		return;
	}
	/*
	 * update cluster allocation map
	 */
	setbit(cg_clustersfree(&acg), block);

	/*
	 * update cluster summary table
	 */
	if(!lcs) {
		/*
		 * calculate size for the trailing cluster
		 */
		for(block--; lcs<sblock.fs_contigsumsize; block--, lcs++) {
			if(isclr(cg_clustersfree(&acg), block)){
				break;
			}
		}
	}
	if(lcs < sblock.fs_contigsumsize) {
		if(lcs) {
			cg_clustersum(&acg)[lcs]--;
		}
		lcs++;
		cg_clustersum(&acg)[lcs]++;
	}

	DBG_LEAVE;
	return;
}

/* *********************************************************** updrefs ***** */
/*
 * This updates all references to relocated blocks for the given inode.  The
 * inode is given as number within the cylinder group, and the number of the
 * cylinder group.
 */
static void
updrefs(int cg, ino_t in, struct gfs_bpp *bp, int fsi, int fso, unsigned int
    Nflag)
{
	DBG_FUNC("updrefs")
	unsigned int	ictr, ind2ctr, ind3ctr;
	ufs_daddr_t	*iptr, *ind2ptr, *ind3ptr;
	struct ufs1_dinode	*ino;
	int	remaining_blocks;

	DBG_ENTER;

	/*
	 * XXX We should skip unused inodes even from beeing read from disk
	 *     here by using the bitmap.
	 */
	ino=ginode(in, fsi, cg);
	if(!((ino->di_mode & IFMT)==IFDIR || (ino->di_mode & IFMT)==IFREG ||
	    (ino->di_mode & IFMT)==IFLNK)) {
		DBG_LEAVE;
		return; /* only check DIR, FILE, LINK */
	}
	if(((ino->di_mode & IFMT)==IFLNK) && (ino->di_size<MAXSYMLINKLEN)) {
		DBG_LEAVE;
		return;	/* skip short symlinks */
	}
	if(!ino->di_size) {
		DBG_LEAVE;
		return;	/* skip empty file */
	}
	if(!ino->di_blocks) {
		DBG_LEAVE;
		return;	/* skip empty swiss cheesy file or old fastlink */
	}
	DBG_PRINT2("scg checking inode (%d in %d)\n",
	    in,
	    cg);

	/*
	 * Start checking all direct blocks.
	 */
	remaining_blocks=howmany(ino->di_size, sblock.fs_bsize);
	for(ictr=0; ictr < MIN(NDADDR, (unsigned int)remaining_blocks);
	    ictr++) {
		iptr = &(ino->di_db[ictr]);
		if(*iptr) {
			cond_bl_upd(iptr, bp, GFS_PS_INODE, fso, Nflag);
		}
	}
	DBG_PRINT0("~~scg direct blocks checked\n");

	remaining_blocks-=NDADDR;
	if(remaining_blocks<0) {
		DBG_LEAVE;
		return;
	}
	if(ino->di_ib[0]) {
		/*
		 * Start checking first indirect block
		 */
		cond_bl_upd(&(ino->di_ib[0]), bp, GFS_PS_INODE, fso, Nflag);
		i1_src=fsbtodb(&sblock, ino->di_ib[0]);
		rdfs(i1_src, (size_t)sblock.fs_bsize, (void *)&i1blk, fsi);
		for(ictr=0; ictr < MIN(howmany(sblock.fs_bsize,
		    sizeof(ufs_daddr_t)), (unsigned int)remaining_blocks);
		    ictr++) {
			iptr=&((ufs_daddr_t *)(void *)&i1blk)[ictr];
			if(*iptr) {
				cond_bl_upd(iptr, bp, GFS_PS_IND_BLK_LVL1,
				    fso, Nflag);
			}
		}
	}
	DBG_PRINT0("scg indirect_1 blocks checked\n");

	remaining_blocks -= howmany(sblock.fs_bsize, sizeof(ufs_daddr_t));
	if(remaining_blocks<0) {
		DBG_LEAVE;
		return;
	}
	if(ino->di_ib[1]) {
		/*
		 * Start checking second indirect block
		 */
		cond_bl_upd(&(ino->di_ib[1]), bp, GFS_PS_INODE, fso, Nflag);
		i2_src=fsbtodb(&sblock, ino->di_ib[1]);
		rdfs(i2_src, (size_t)sblock.fs_bsize, (void *)&i2blk, fsi);
		for(ind2ctr=0; ind2ctr < howmany(sblock.fs_bsize,
		    sizeof(ufs_daddr_t)); ind2ctr++) {
			ind2ptr=&((ufs_daddr_t *)(void *)&i2blk)[ind2ctr];
			if(!*ind2ptr) {
				continue;
			}
			cond_bl_upd(ind2ptr, bp, GFS_PS_IND_BLK_LVL2, fso,
			    Nflag);
			i1_src=fsbtodb(&sblock, *ind2ptr);
			rdfs(i1_src, (size_t)sblock.fs_bsize, (void *)&i1blk,
			    fsi);
			for (ictr=0; ictr < MIN(howmany((unsigned int)
			    sblock.fs_bsize, sizeof(ufs_daddr_t)),
			    (unsigned int)remaining_blocks); ictr++) {
				iptr=&((ufs_daddr_t *)(void *)&i1blk)[ictr];
				if(*iptr) {
					cond_bl_upd(iptr, bp,
					    GFS_PS_IND_BLK_LVL1, fso, Nflag);
				}
			}
		}
	}
	DBG_PRINT0("scg indirect_2 blocks checked\n");

#define SQUARE(a) ((a)*(a))
	remaining_blocks-=SQUARE(howmany(sblock.fs_bsize, sizeof(ufs_daddr_t)));
#undef SQUARE
	if(remaining_blocks<0) {
		DBG_LEAVE;
		return;
	}

	if(ino->di_ib[2]) {
		/*
		 * Start checking third indirect block
		 */
		cond_bl_upd(&(ino->di_ib[2]), bp, GFS_PS_INODE, fso, Nflag);
		i3_src = fsbtodb(&sblock, ino->di_ib[2]);
		rdfs(i3_src, (size_t)sblock.fs_bsize, &i3blk, fsi);
		for (ind3ctr = 0; ind3ctr < howmany(sblock.fs_bsize,
		    sizeof(ufs_daddr_t)); ind3ctr++) {
			ind3ptr = &((ufs_daddr_t *)&i3blk)[ind3ctr];
			if (!*ind3ptr)
				continue;
			cond_bl_upd(ind3ptr, bp, GFS_PS_IND_BLK_LVL3, fso,
			    Nflag);
			i2_src = fsbtodb(&sblock, *ind3ptr);
			rdfs(i2_src, (size_t)sblock.fs_bsize, &i2blk,
			    fsi);
			for (ind2ctr = 0; ind2ctr < howmany(sblock.fs_bsize,
			    sizeof(ufs_daddr_t)); ind2ctr++) {
				ind2ptr = &((ufs_daddr_t *)&i2blk)[ind2ctr];
				if (!*ind2ptr)
					continue;
				cond_bl_upd(ind2ptr, bp, GFS_PS_IND_BLK_LVL2,
				    fso, Nflag);
				i1_src = fsbtodb(&sblock, *ind2ptr);
				rdfs(i1_src, (size_t)sblock.fs_bsize,
				    &i1blk, fsi);
				for (ictr = 0; ictr < MIN(howmany(sblock.fs_bsize,
				    sizeof(ufs_daddr_t)),
				    (unsigned int)remaining_blocks); ictr++) {
					iptr = &((ufs_daddr_t *)&i1blk)[ictr];
					if (*iptr) {
						cond_bl_upd(iptr, bp,
						    GFS_PS_IND_BLK_LVL1, fso,
						    Nflag);
					}
				}
			}
		}
	}

	DBG_PRINT0("scg indirect_3 blocks checked\n");

	DBG_LEAVE;
	return;
}
@


1.12.4.1
log
@merge the first bunch of MirOS X (branch MIROS_X tag tg-mergetmp-mirosx-1) into mergefixes branch
@
text
@d1 1
a1 1
/**	$MirBSD: src/sbin/growfs/growfs.c,v 1.12.2.1 2004/12/28 12:59:35 tg Exp $	*/
d71 1
a71 1
__RCSID("$MirBSD: src/sbin/growfs/growfs.c,v 1.12.2.1 2004/12/28 12:59:35 tg Exp $");
d1925 1
d1928 1
a1928 1
	int	ch, ExpertFlag=0;
@


1.12.2.1
log
@char doesn't hold a char, it's too small
use int
@
text
@d1 1
a1 1
/**	$MirBSD: src/sbin/growfs/growfs.c,v 1.12 2004/10/11 20:18:43 tg Exp $	*/
d71 1
a71 1
__RCSID("$MirBSD: src/sbin/growfs/growfs.c,v 1.12 2004/10/11 20:18:43 tg Exp $");
d1925 1
d1928 1
a1928 1
	int	ch, ExpertFlag=0;
@


1.11
log
@Last piece of OpenBSD 3.5-current merge part I.

Things left:
* merge import in src/gnu/
* fix kernel build (it _is_ broken)

TOP 1 will be done with a _second_ import (easier).
TOP 2 will be done RSN.

----

Also, move RCS IDs to new-style MirOS ones, and fix the
SMM doc, and add output to newfs(8) saying if (!) or if
not (?) it read the random value out of the previous
superblock before making the fs.
@
text
@d1 2
a2 1
/*	$MirBSD: src/sbin/growfs/growfs.c,v 1.10 2003/12/27 00:30:41 tg Exp $	*/
d71 1
a71 1
__RCSID("$MirBSD$");
d109 1
d1491 1
a1491 1
			for (inc = osblock.fs_ipg - 1; inc >= 0; inc--) {
d1546 3
d1844 6
d2024 1
d2431 1
a2431 1
			
@


1.10
log
@finish merging and sync a bit; bump version etc.
@
text
@d1 1
a1 1
/*	$MirBSD: growfs.c,v 1.9 2003/09/01 21:32:46 tg Exp $	*/
d70 2
d1993 1
a1993 1
		     rdev, DISKPART(st.st_rdev));
d2120 1
a2120 1
		printf( "Warning: %d sector(s) cannot be allocated.\n",
d2157 2
a2158 1
	if(fso>-1) close(fso);
@


1.9
log
@fixes for non-FreeBSD and gcc
@
text
@d1 1
a1 1
/*	$MirBSD: growfs.c,v 1.8 2003/09/01 21:21:52 tg Exp $	*/
a47 12
#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 2000 Christoph Herrmann, Thomas-Henning von Kamptz\n\
Copyright (c) 1980, 1989, 1993 The Regents of the University of California.\n\
All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static const char rcsid[] =
  "$MirBSD: growfs.c,v 1.8 2003/09/01 21:21:52 tg Exp $";
#endif /* not lint */

d63 2
a144 1
static void	get_dev_size(int, int *);
d1195 1
a1195 1
		 *	space is less then the maximum cluster size. This is
a1883 26
/* ****************************************************** get_dev_size ***** */
/*
 * Get the size of the partition if we can't figure it out from the disklabel,
 * e.g. from vinum volumes.
 */
static void
get_dev_size(int fd, int *size)
{
   int sectorsize = 0;
   off_t mediasize;

#ifdef	DIOCGSECTORSIZE
   if (ioctl(fd, DIOCGSECTORSIZE, &sectorsize) == -1)
#endif
	err(1,"DIOCGSECTORSIZE");
#ifdef	DIOCGMEDIASIZE
   if (ioctl(fd, DIOCGMEDIASIZE, &mediasize) == -1)
#endif
	err(1,"DIOCGMEDIASIZE");

   if (sectorsize <= 0)
	errx(1, "bogus sectorsize: %d", sectorsize);

   *size = mediasize / sectorsize;
}

d1911 1
a1911 1
	char	*device, *special, *cp;
a1913 1
	size_t	len;
d1928 1
a1928 1
	while((ch=getopt(argc, argv, "Ns:vy")) != -1) {
a1938 2
		case 'v': /* for compatibility to newfs */
			break;
d1957 2
a1958 1
	 * Now try to guess the (raw)device name.
d1960 2
a1961 31
	if (0 == strrchr(device, '/')) {
		/*
		 * No path prefix was given, so try in that order:
		 *     /dev/r%s
		 *     /dev/%s
		 *     /dev/vinum/r%s
		 *     /dev/vinum/%s.
		 *
		 * FreeBSD now doesn't distinguish between raw and block
		 * devices any longer, but it should still work this way.
		 */
		len=strlen(device)+strlen(_PATH_DEV)+2+strlen("vinum/");
		special=(char *)malloc(len);
		if(special == NULL) {
			errx(1, "malloc failed");
		}
		snprintf(special, len, "%sr%s", _PATH_DEV, device);
		if (stat(special, &st) == -1) {
			snprintf(special, len, "%s%s", _PATH_DEV, device);
			if (stat(special, &st) == -1) {
				snprintf(special, len, "%svinum/r%s",
				    _PATH_DEV, device);
				if (stat(special, &st) == -1) {
					/* For now this is the 'last resort' */
					snprintf(special, len, "%svinum/%s",
					    _PATH_DEV, device);
				}
			}
		}
		device = special;
	}
d1964 1
a1964 1
	 * Try to access our devices for writing ...
d1969 3
a1971 4
		fso = open(device, O_WRONLY);
		if (fso < 0) {
			err(1, "%s", device);
		}
d1975 2
a1976 1
	 * ... and reading.
d1978 2
a1979 4
	fsi = open(device, O_RDONLY);
	if (fsi < 0) {
		err(1, "%s", device);
	}
d1982 3
a1984 3
	 * Try to read a label and guess the slice if not specified. This
	 * code should guess the right thing and avoid to bother the user
	 * with the task of specifying the option -v on vinum volumes.
a1985 1
	cp=device+strlen(device)-1;
d1987 5
a1991 13
    if (lp != NULL) {
        if (isdigit(*cp)) {
            pp = &lp->d_partitions[2];
        } else if (*cp>='a' && *cp<='h') {
            pp = &lp->d_partitions[*cp - 'a'];
        } else {
            errx(1, "unknown device");
        }
        p_size = pp->p_size;
    } else {
        get_dev_size(fsi, &p_size);
	pp = NULL; /* peace gcc */
    }
d1993 1
@


1.8
log
@update from freebsd-current (not everything though - debug.* not yet,
because we don't have ufs2)
@
text
@d1 1
a1 1
/*	$MirBSD: growfs.c,v 1.7 2003/08/31 20:54:38 tg Exp $	*/
d57 1
a57 1
  "$MirBSD: growfs.c,v 1.7 2003/08/31 20:54:38 tg Exp $";
d1903 1
a1903 1
   int sectorsize;
d1906 1
d1908 1
d1910 1
d1912 1
d2069 1
d2078 1
a2078 1
	if (pp->p_fstype != FS_BSDFFS) {
@


1.7
log
@Merge import of OpenBSD source, ports and XF4 tree.

While here,
o clean up differences where possible
o whitespace cleanup
o ifdef ./. if defined()
o '...' ./. "..."
o echo foo > bar ./. echo foo >bar
o `...` ./. $(...) ./. $$(...)
o `...' ./. '...'
o modernize "our" tree, e.g. WWW in ports
o fix some typos and brainos introduced when renaming OpenBSD to MirBSD
o use hardware 80387 by default
o migrate Apache 1.3.28 OpenBSD ./. MirBSD ./. KAME
o work around as many CVS bugs as possible (add back/delete files, ...)

Synchronize stuff, ready for ongoing changes.
@
text
@d1 1
a1 1
/*	$MirBSD: growfs.c,v 1.6 2003/08/18 15:52:51 tg Exp $	*/
d3 1
a3 1
 * growfs(8) from FreeBSD-current as of Sat Apr  5 18:43:44 UTC 2003
d11 1
a11 1
 * 
d14 1
a14 1
 * 
d31 1
a31 1
 * 
d57 1
a57 1
  "$MirBSD: growfs.c,v 1.6 2003/08/18 15:52:51 tg Exp $";
d65 1
d118 1
d121 1
a121 1
 * An  array of elements of type struct gfs_bpp describes all blocks  to
d155 1
d159 3
a161 3
 * Here  we actually start growing the filesystem. We basically  read  the
 * cylinder  summary  from the first cylinder group as we want  to  update
 * this  on  the fly during our various operations. First  we  handle  the
d163 3
a165 3
 * cylinder  groups.  Now  we handle the  cylinder  group  containing  the
 * cylinder  summary  which  might result in a  relocation  of  the  whole
 * structure.  In the end we write back the updated cylinder summary,  the
d315 1
a315 1
	 * The following fields are currently distributed from the  superblock
d327 1
a327 1
	 * system were created initially with the new size. Therefor we  still
d330 1
a330 1
	 * "diffed" stats between the old and new superblock by still  copying
d351 3
a353 3
 * This creates a new cylinder group structure, for more details please  see
 * the  source of newfs(8), as this function is taken over almost unchanged.
 * As  this  is  never called for the  first  cylinder  group,  the  special
d521 1
a521 1
 * Here  we add or subtract (sign +1/-1) the available fragments in  a  given
d523 1
a523 1
 * after  an operation on the free frag map we can easy update  the  fragment
d540 1
a540 1
	for(f=rounddown(frag, sblock.fs_frag); 
d581 3
a583 3
 * relocated blocks if any of it's fragments is referenced by the current
 * field,  and update the pointer to the respective fragment in  our  new
 * block.  If  we find a reference we write back the  block  immediately,
d658 3
a660 3
 * changed  in  any case, even if the filesystem ended exactly on the  end  of
 * this  group, as there is some slightly inconsistent handling of the  number
 * of cylinders in the cylinder group. We start again by reading the  cylinder
d662 3
a664 3
 * the  missing  fragments, then we handle all new full blocks  in  that  file
 * system  and  finally we handle the new last fragmented block  in  the  file
 * system.  We again have to handle the fragment statistics rotational  layout
d692 1
a692 1
	 * If  the  cylinder  group had already it's  new  final  size  almost
d695 1
a695 1
	 * to  be  zero instead of fs_cpg. As this is now no longer  the  last
d697 1
a697 1
	 */ 
d755 5
a759 5
	 * Now  we have to update the free fragment bitmap for our new  free
	 * space.  There again we have to handle the fragmentation and  also
	 * the  rotational  layout tables and the cluster summary.  This  is
	 * also  done per fragment for the first new block if the  old  file
	 * system end was not on a block boundary, per fragment for the  new
d782 1
a782 1
			 * Check  if the fragment just created could join  an
d790 1
a790 1
				 * The block is now completely available
d865 1
a865 1
	 * Here  we don't have to bother about the cluster summary or the  even
d905 1
a905 1
 * Here  we update the location of the cylinder summary. We have  two  possible
d907 1
a907 1
 * (1)	We can try to grow the summary in the current location, and  relocate
d910 3
a912 3
 *	new completely empty cylinder group. Once the cylinder summary is  no
 *	longer in the beginning of the first cylinder group you should  never
 *	use  a version of fsck which is not aware of the possibility to  have
d914 1
a914 1
 * Option (1) is considered to be less intrusive to the structure of the  file-
d916 2
a917 2
 * space  in the cylinder group containing the cylinder summary we have to  use
 * method  (2). In case of active snapshots in the filesystem we  probably  can
d973 2
a974 2
	 *	blocks for the copy on write. We need each block twice,  and
	 *	also  up to 8*3 blocks for indirect blocks for all  possible
d979 3
a981 3
		 * There  is  not enough space in the old cylinder  group  to
		 * relocate  all blocks as needed, so we relocate  the  whole
		 * cylinder  group summary to a new group. We try to use  the
d983 2
a984 2
		 * cylinder  group we align the area immediately  after  the
		 * cylinder  group  information location in order  to  be  as
d987 3
a989 3
		 * First  we have to make sure we'll find enough space in  the
		 * new  cylinder  group. If not, then we  currently  give  up.
		 * We  start  with freeing everything which was  used  by  the
d991 1
a991 1
		 * Now  we write back the group meta data, read in the  needed
d993 1
a993 1
		 * within  that  group. Here we can assume, the  group  to  be
d1010 1
a1010 1
		 * the size for the trailing cluster just behind where  "d"
d1028 1
a1028 2
		DBG_PRINT1("d=%d\n",
		    d);
d1037 1
a1037 2
				DBG_PRINT1("d=%d\n",
				    d);
d1043 1
a1043 1
			 * Point  "d" to the last fragment of the  last
d1051 1
a1051 2
				DBG_PRINT1("d=%d\n",
				    d);
d1081 1
a1081 2
		DBG_PRINT1("d=%d\n",
		    d);
d1085 1
a1085 2
			DBG_PRINT1("d=%d\n",
			    d);
d1204 1
a1204 1
		 * XXX	Handle the cluster statistics here in the case  this
d1234 1
a1234 1
	 * can relocate just a few blocks, and let the summary  information
d1259 2
a1260 2
	 * Lock all new frags needed for the cylinder group summary. This  is
	 * done per fragment in the first and last block of the new  required
d1263 1
a1263 1
	 * Handle the first new  block here (but only if some fragments where
d1287 1
a1287 1
		 * one  fragment in use by the cylinder summary in  the  old
d1399 1
a1399 1
				 *	zero,   which  is   not   explicitly
d1426 1
a1426 1
			 * Special handling is required if this was the  first
d1428 3
a1430 3
			 * used by the cylinder summary in the original  block
			 * which  re to be free in the copy of our  block.  We
			 * have  to be careful if this first block happens  to
a1444 1
				
d1467 1
a1467 1
			 * !!! Attach the cylindergroup offset here. 
d1492 2
a1493 2
		 * belongs  to any block relocated. We iterate now  over  all
		 * cylinder  groups,  within those over all non  zero  length 
d1594 1
a1594 1
 * that  acg contains the current cylinder group. As we may take a block  from
d1621 1
a1621 1
	 * the  end of the new grown cylinder summary. Otherwise we allocate  a
d1677 1
a1677 1
		 * We  possibly have split a cluster here, so we have  to  do
d1725 1
a1725 1
 * Here  we check if all frags of a block are free. For more details  again
d1763 1
a1763 1
 * please  see the source of newfs(8), as this function is taken over  almost
d1797 1
a1797 1
 * please  see the source of newfs(8), as this function is taken  over  almost
d1831 3
a1833 3
 * block  the  requested inode is located, read it from disk if  needed,  and
 * return  the pointer into that block. We maintain a cache of one  block  to
 * not  read the same block again and again if we iterate linearly  over  all
d1867 1
a1867 1
 * please  see the source of newfs(8), as this function is taken over  almost
d1895 22
d1919 5
a1923 5
 * growfs(8)  is a utility which allows to increase the size of  an  existing
 * ufs filesystem. Currently this can only be done on unmounted file  system.
 * It  recognizes some command line options to specify the new desired  size,
 * and  it does some basic checkings. The old filesystem size is  determined
 * and  after some more checks like we can really access the new  last  block
d1925 1
a1925 1
 * having  done  this we just call growfs() which will do  the  work.  Before
d1928 2
a1929 2
 * understand  what data structures are always replicated in the snapshot  on
 * creation,  for all other blocks we touch during our procedure, we have  to
d1931 1
a1931 1
 * are lucky, then we only have to handle our blocks to be relocated in  that
d1933 2
a1934 2
 * Also  we  have to consider in what order we actually update  the  critical
 * data structures of the filesystem to make sure, that in case of a disaster
d1936 2
a1937 2
 * The  foreseen last step then will be to provide for growing  even  mounted
 * file  systems. There we have to extend the mount() system call to  provide
d1954 1
d2002 2
a2003 2
		 * 
		 * FreeBSD now doesn't distinguish between raw and  block
d2048 2
a2049 2
	 * Try  to read a label and guess the slice if not  specified.  This
	 * code  should guess the right thing and avoid to bother the user
d2054 12
a2065 11
/** we don't have VINUM
 *	if(lp->d_type == DTYPE_VINUM) {
 *		pp = &lp->d_partitions[0];
 *	} else */
	if (isdigit(*cp)) {
		pp = &lp->d_partitions[2];
	} else if (*cp>='a' && *cp<='h') {
		pp = &lp->d_partitions[*cp - 'a'];
	} else {
		errx(1, "unknown device");
	}
d2068 1
a2068 1
	 * Check if that partition looks suited for growing a filesystem.
d2070 1
a2070 1
	if (pp->p_size < 1) {
d2093 1
a2093 1
	sblock.fs_size = dbtofsb(&osblock, pp->p_size);
d2095 1
a2095 1
		if (size > pp->p_size){
d2097 1
a2097 1
			    pp->p_size, size);
d2099 1
a2099 1
		sblock.fs_size = dbtofsb(&osblock, size);	
d2137 1
a2137 1
		}		
d2147 1
a2147 1
	wtfs((daddr_t)pp->p_size-1, (size_t)DEV_BSIZE, (void *)&sblock, fso,
d2203 1
a2203 1
	
d2218 8
a2225 6
	pp->p_fsize = sblock.fs_fsize;
	pp->p_frag = sblock.fs_frag;
	pp->p_cpg = sblock.fs_cpg;

	return_disklabel(fso, lp, Nflag);
	DBG_PRINT0("label rewritten\n");
d2289 1
a2289 1
	if (!lab) {
d2291 5
a2295 4
	}
	if (ioctl(fd, DIOCGDINFO, (char *)lab) < 0) {
		errx(1, "DIOCGDINFO failed");
	}
d2298 1
a2298 1
	return (lab);
d2308 1
a2308 1
{	
d2322 1
a2322 1
 * assume, that sblock, osblock, acg are set up.
d2326 1
a2326 1
{	
d2352 1
a2352 1
	} 
d2374 1
a2374 1
{	
@


1.6
log
@nuke sprintf
@
text
@d1 1
a1 1
/*	$MirBSD: growfs.c,v 1.5 2003/08/18 15:51:32 tg Exp $	*/
d57 1
a57 1
  "$MirBSD: growfs.c,v 1.5 2003/08/18 15:51:32 tg Exp $";
d116 1
a116 1
static struct dinode	zino[MAXBSIZE/sizeof(struct dinode)]; /* some inodes */
d147 1
a147 1
static struct dinode	*ginode(ino_t, int, int);
d425 1
a425 1
		for (j = 0; j < sblock.fs_bsize / sizeof(struct dinode); j++) {
d1839 1
a1839 1
static struct dinode *
d1845 1
a1845 1
	struct dinode	*pi;
d1849 1
a1849 1
	pi=(struct dinode *)(void *)ablk;
d2354 1
a2354 1
	struct dinode	*ino;
@


1.5
log
@tree breaker (pasto)
@
text
@d1 1
a1 1
/*	$MirBSD: growfs.c,v 1.4 2003/08/17 18:56:03 tg Exp $	*/
d57 1
a57 1
  "$MirBSD: growfs.c,v 1.4 2003/08/17 18:56:03 tg Exp $";
d243 1
a243 1
		j = sprintf(tmpbuf, " %d%s",
@


1.4
log
@merge OpenBSD, remove a few 0x60
@
text
@d1 1
a1 1
/*	$MirBSD: growfs.c,v 1.3 2003/08/17 08:56:01 tg Exp $	*/
d57 1
a57 1
  "$MirBSD: growfs.c,v 1.3 2003/08/17 08:56:01 tg Exp $";
d2471 3
a2473 3
		i3_src=fsbtodb(&sblock, ino->di_ib[2]);
		rdfs(i3_src, (size_t)sblock.fs_bsize, (void *)&i3blk, fsi);
		for(ind3ctr=0; ind3ctr < howmany(sblock.fs_bsize,
d2475 2
a2476 2
			ind3ptr=&((ufs_daddr_t *)(void *)&i3blk)[ind3ctr];
			if(!*ind3ptr) {
a2477 1
			}
d2480 2
a2481 2
			i2_src=fsbtodb(&sblock, *ind3ptr);
			rdfs(i2_src, (size_t)sblock.fs_bsize, (void *)&i2blk,
d2483 1
a2483 1
			for(ind2ctr=0; ind2ctr < howmany(sblock.fs_bsize,
d2486 1
a2486 2
				    [ind2ctr];
				if(!*ind2ptr) {
a2487 1
				}
d2490 1
a2490 1
				i1_src=fsbtodb(&sblock, *ind2ptr);
d2492 2
a2493 2
				    (void *)&i1blk, fsi);
				for(ictr=0; ictr < MIN(howmany(sblock.fs_bsize,
d2496 2
a2497 3
					iptr=&((ufs_daddr_t *)(void *)&i1blk)
					    [ictr];
					if(*iptr) {
@


1.3
log
@Merge OpenBSD
@
text
@d1 1
a1 1
/*	$MirBSD: growfs.c,v 1.2 2003/04/05 19:48:33 tg Exp $	*/
d57 1
a57 1
  "$MirBSD: src/sbin/growfs/growfs.c,v 1.8 2002/05/16 04:10:11 trhodes Exp $";
d2099 1
a2099 1
				    "using growfs\n");
@


1.2
log
@on request from tedu <tedu@@stanford.edu> make growfs(8)
use arc4random(3) instead of random(3) for inode numbers.

Also, unifdef FSI_RAND since it's good(tm).
@
text
@d1 1
a1 1
/*	$MirBSD: growfs.c,v 1.1 2003/04/05 19:43:26 tg Exp $	*/
d57 1
a57 1
  "$FreeBSD: src/sbin/growfs/growfs.c,v 1.8 2002/05/16 04:10:11 trhodes Exp $";
d234 1
a234 1
	printf("super-block backups (for fsck -b #) at:\n");
d245 1
a245 1
		    cylno < (sblock.fs_ncg-1) ? "," : "" );
d332 1
a332 1
	 * Write out the duplicate super blocks.
d399 1
a399 1
		    howmany(sblock.fs_cpg* sblock.fs_spc/ NSPF(&sblock), NBBY);
d451 1
a451 1
	for (d = dupper; d + sblock.fs_frag <= dmax - cbase; ) {
d541 1
a541 1
		 * Count contiguos free fragments.
d601 1
a601 1
			*block=(f->new*sblock.fs_frag+(*block%sblock.fs_frag));
d980 1
a980 1
		 * cylinder  group we allign the area immediately  after  the
d1043 1
a1043 1
			 * (incomplete) block of the clinder summary.
d1324 1
a1324 1
				    l++, lcs++ ) {
d1358 4
a1361 4
				clrbit(cg_clustersfree(&acg), d/sblock.fs_frag);
				for(lcs=0, l=(d/sblock.fs_frag)+1;
				    lcs<sblock.fs_contigsumsize;
				    l++, lcs++ ) {
d1379 2
a1380 2
				bp[ind].old=d/sblock.fs_frag;
				bp[ind].flags|=GFS_FL_LAST;
d1486 1
a1486 2
			DBG_DUMP_HEX(&sblock,
			    "copied full block",
d1490 1
a1490 2
			    bp[i].old,
			    bp[i].new);
d1499 3
a1501 4
		for(cylno=0; cylno<osblock.fs_ncg; cylno++) {
			DBG_PRINT1("scg doing cg (%d)\n",
			    cylno);
			for(inc=osblock.fs_ipg-1 ; inc>=0 ; inc--) {
a1541 1
	return;
a1564 1
	return;
a1591 1
	return;
d1628 4
a1631 4
	blkno=-1;
	dlower=cgsblock(&sblock, acg.cg_cgx)-cgbase(&sblock, acg.cg_cgx);
	dupper=cgdmin(&sblock, acg.cg_cgx)-cgbase(&sblock, acg.cg_cgx);
	dmax=cgbase(&sblock, acg.cg_cgx)+sblock.fs_fpg;
d1635 3
a1637 3
	dmax-=cgbase(&sblock, acg.cg_cgx); /* retransform into cg */
	csmin=sblock.fs_csaddr-cgbase(&sblock, acg.cg_cgx);
	csmax=csmin+howmany(sblock.fs_cssize, sblock.fs_fsize);
d1639 2
a1640 6
	    dlower,
	    dupper,
	    dmax);
	DBG_PRINT2("range cont: csmin=%d, csmax=%d\n",
	    csmin,
	    csmax);
d1642 1
a1642 1
	for(d=0; (d<dlower && blkno==-1); d+=sblock.fs_frag) {
d1652 1
a1652 1
	for(d=dupper; (d<dmax && blkno==-1); d+=sblock.fs_frag) {
d1687 1
a1687 1
		    l--, lcs1++ ) {
d1697 1
a1697 1
		    l++, lcs2++ ) {
a1794 1
	return;
a1828 1
	return;
d1943 1
a1943 1
		switch(ch) {
d1948 2
a1949 2
			size=(size_t)atol(optarg);
			if(size<1) {
d2028 3
a2030 3
	 * Try  to read a label and gess the slice if not  specified.  This
	 * code  should guess the right thing and avaid to bother the  user
	 * user with the task of specifying the option -v on vinum volumes.
d2059 2
a2060 3
	rdfs((daddr_t)(SBOFF/DEV_BSIZE), (size_t)SBSIZE, (void *)&(osblock),
	    fsi);
	if (osblock.fs_magic != FS_MAGIC) {
a2061 1
	}
d2095 1
a2095 1
		for(j=0; j<FSMAXSNAP; j++) {
d2158 1
a2158 1
	    (sblock.fs_ncg-1) * sblock.fs_fpg )) {
d2233 1
a2233 1
		ptr=(u_short *)lp;
d2297 1
a2297 1
 * This updates most paramters and the bitmap related to cluster. We have to
d2323 1
a2323 1
		for(block--; lcs<sblock.fs_contigsumsize; block--, lcs++ ) {
d2391 1
a2391 1
		iptr=&(ino->di_db[ictr]);
d2422 1
a2422 1
	remaining_blocks-= howmany(sblock.fs_bsize, sizeof(ufs_daddr_t));
d2445 1
a2445 1
			for(ictr=0; ictr<MIN(howmany((unsigned int)
d2474 1
a2474 1
		    sizeof(ufs_daddr_t)); ind3ctr ++) {
d2485 2
a2486 2
			    sizeof(ufs_daddr_t)); ind2ctr ++) {
				ind2ptr=&((ufs_daddr_t *)(void *)&i2blk)
a2515 1

@


1.1
log
@Add a .Mx macro to mandocs, equivalent to .Fx .Nx and .Ox

Import growfs(8) and ffsinfo(8) from FreeBSD
Unpatch UFS2 support
Add missing includes

This has been tested on a vnd(4) device in life,
but not throughly. Anyone who wants to patch in
the fsck_ffs(8) patch mentioned in the man page
is welcome.
@
text
@d1 1
a1 1
/*	$MirBSD$	*/
a174 2
#ifdef FSIRAND
	static int	randinit=0;
a177 9
	if (!randinit) {
		randinit = 1;
		srandomdev();
	}
#else /* not FSIRAND */

	DBG_ENTER;

#endif /* FSIRAND */
a359 1
#ifdef FSIRAND
a360 1
#endif
a424 1
#ifdef FSIRAND
d426 1
a426 1
			zino[j].di_gen = random();
a427 1
#endif
@


1.1.1.1
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 6
a6 1
/*	$OpenBSD: growfs.c,v 1.4 2003/08/07 16:37:52 fgsch Exp $	*/
d11 1
a11 1
 *
d14 1
a14 1
 *
d31 1
a31 1
 *
d53 1
d55 3
a57 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.4 2003/08/07 16:37:52 fgsch Exp $";
d85 1
a85 1
	struct	fs fs;
d92 1
a92 1
	struct	cg cg;
d116 1
a116 1
static struct dinode	zino[MAXBSIZE / sizeof(struct dinode)]; /* some inodes */
d175 2
d180 9
d194 2
a195 2
	fscs = calloc((size_t)1, (size_t)sblock.fs_cssize);
	if (fscs == NULL)
d197 1
d201 1
a201 1
		    osblock.fs_bsize), (((char *)fscs) + i), fsi);
d210 2
a211 2
	dbg_csp = fscs;
	for (dbg_csc = 0; dbg_csc < osblock.fs_ncg; dbg_csc++) {
d225 1
a225 1
	updjcg(osblock.fs_ncg - 1, utime, fsi, fso, Nflag);
d245 1
a245 1
	printf("superblock backups (for fsck -b #) at:\n");
d254 1
a254 1
		j = snprintf(tmpbuf, sizeof tmpbuf, " %d%s",
d256 1
a256 1
		    cylno < (sblock.fs_ncg - 1) ? "," : "");
d279 1
a279 1
		    (((char *)fscs) + i), fso, Nflag);
d289 2
a290 2
	dbg_csp = fscs;
	for (dbg_csc = 0; dbg_csc < sblock.fs_ncg; dbg_csc++) {
d293 3
a295 1
		DBG_DUMP_CSUM(&sblock, dbg_line, dbg_csp++);
d304 1
a304 1
	wtfs((daddr_t)(SBOFF / DEV_BSIZE), (size_t)SBSIZE, &sblock,
d307 2
a308 1
	DBG_DUMP_FS(&sblock, "new initial sblock");
d318 1
a318 1
	memset(&sblock.fs_fsmnt, 0, sizeof(sblock.fs_fsmnt));
d331 1
a331 1
	 *     fs_flags regarding SOFTUPDATES
d343 1
a343 1
	 * Write out the duplicate superblocks.
d347 1
a347 1
		    (size_t)SBSIZE, &sblock, fso, Nflag);
d350 2
a351 1
	DBG_DUMP_FS(&sblock, "new other sblocks");
d354 1
d371 1
d373 1
d382 1
a382 1
	if (dmax > sblock.fs_size)
d384 1
d387 1
a387 1
	if (cylno == 0) /* XXX fscs may be relocated */
d389 1
d395 1
a395 1
	if (cylno == sblock.fs_ncg - 1)
d397 1
a397 1
	else
d399 1
d402 1
a402 1
	if (sblock.fs_contigsumsize > 0)
d404 1
d412 1
a412 1
		    howmany(sblock.fs_cpg * sblock.fs_spc / NSPF(&sblock), NBBY);
d438 5
a442 2
		for (j = 0; (unsigned)j < sblock.fs_bsize / sizeof(struct dinode); j++)
			zino[j].di_gen = arc4random();
d444 1
a444 1
		    (size_t)sblock.fs_bsize, zino, fso, Nflag);
d466 1
a466 1
	for (d = dupper; d + sblock.fs_frag <= dmax - cbase;) {
d493 1
a493 1
			if ((map & bit) != 0)
d495 2
a496 2
			else if (run != 0) {
				if (run > sblock.fs_contigsumsize)
d498 1
d502 1
a502 1
			if ((i & (NBBY - 1)) != (NBBY - 1))
d504 1
a504 1
			else {
d522 4
a525 2
	    (size_t)sblock.fs_bsize, &acg, fso, Nflag);
	DBG_DUMP_CG(&sblock, "new cg", &acg);
d528 1
d547 1
a547 1
	fragsize = 0;
d552 3
a554 3
#define	rounddown(x, y)	(((x)/(y))*(y))
	for (f = rounddown(frag, sblock.fs_frag);
	    f < roundup(frag + 1, sblock.fs_frag); f++) {
d556 1
a556 1
		 * Count contiguous free fragments.
d558 1
a558 1
		if (isset(cg_blksfree(&acg), f))
d560 2
a561 2
		else {
			if (fragsize && fragsize < sblock.fs_frag) {
d566 3
a568 1
				DBG_PRINT2("frag_adjust [%d]+=%d\n", fragsize, sign);
d570 1
a570 1
			fragsize = 0;
d573 1
a573 1
	if (fragsize && fragsize < sblock.fs_frag) {
d578 7
a584 3
		DBG_PRINT2("frag_adjust [%d]+=%d\n", fragsize, sign);
	}
	DBG_PRINT2("frag_adjust [[%d]]+=%d\n", fragsize, sign);
d587 1
d606 1
a606 1
	daddr_t dst = 0;
d610 3
a612 3
	f = field;
	while (f->old) { /* for all old blocks */
		if (*block/sblock.fs_frag == f->old) {
d616 1
a616 1
			*block = (f->new * sblock.fs_frag + (*block % sblock.fs_frag));
d619 3
a621 1
			    f->old, f->new, *block % sblock.fs_frag);
d626 2
a627 2
				src = ablk;
				dst = in_src;
d630 2
a631 2
				src = i1blk;
				dst = i1_src;
d634 2
a635 2
				src = i2blk;
				dst = i2_src;
d638 2
a639 2
				src = i3blk;
				dst = i3_src;
d642 1
a642 1
				src = NULL;
d645 1
a645 1
			if (src) {
d651 1
a651 1
				wtfs(dst, (size_t)sblock.fs_bsize, src,
d664 1
d685 2
a686 2
	int	i, k;
	int	j = 0;
d695 1
a695 1
	    (size_t)osblock.fs_cgsize, &aocg, fsi);
d697 3
a699 1
	DBG_DUMP_CG(&sblock, "old joining cg", &aocg);
d701 1
a701 1
	memcpy(&cgun1, &cgun2, sizeof(cgun2));
d709 1
a709 1
	 */
d711 2
a712 2
	if (cgbase(&osblock, cylno + 1) == osblock.fs_size) {
		acg.cg_ncyl = sblock.fs_cpg;
d715 1
a715 1
		    (size_t)sblock.fs_cgsize, &acg, fso, Nflag);
d717 4
a720 1
		DBG_DUMP_CG(&sblock, "new joining cg", &acg);
d733 1
a733 1
	if (cylno == 0) /* XXX fscs may be relocated */
d735 1
d755 4
a758 1
	DBG_PRINT4("jcg dbg: %d %u %d %u\n", cylno, sblock.fs_ncg, acg.cg_ncyl,
d761 2
a762 2
	sblock.fs_dsize += acg.cg_ndblk - aocg.cg_ndblk;
	if (sblock.fs_contigsumsize > 0)
d764 1
d778 2
a779 2
	if (osblock.fs_size % sblock.fs_frag) {
		if (roundup(osblock.fs_size, sblock.fs_frag)<=sblock.fs_size) {
d784 4
a787 3
			j = 0;
			for (i = roundup(osblock.fs_size - cbase, sblock.fs_frag)-1;
			    i >= osblock.fs_size - cbase; i--) {
d798 1
a798 1
			if (isblock(&sblock, cg_blksfree(&acg),
d805 1
a805 1
				acg.cg_frsum[osblock.fs_size % sblock.fs_frag]--;
d808 1
a808 1
				k = rounddown(osblock.fs_size - cbase,
d812 2
a813 2
				    [cbtorpos(&sblock, k)]++;
				updclst((osblock.fs_size - cbase)/sblock.fs_frag);
d819 3
a821 3
				k = 0;
				while (isset(cg_blksfree(&acg), i) &&
				    (i >= rounddown(osblock.fs_size - cbase,
d826 1
a826 1
				if (k)
d828 2
a829 1
				acg.cg_frsum[k + j]++;
d836 3
a838 2
			for (i = sblock.fs_size - cbase - 1;
			    i >= osblock.fs_size - cbase; i--) {
d846 3
a848 3
			k = 0;
			while (isset(cg_blksfree(&acg), i) &&
			    (i >= rounddown(osblock.fs_size - cbase,
d853 1
a853 1
			if (k)
d855 2
a856 1
			acg.cg_frsum[k + j]++;
d863 3
a865 3
	for (i = roundup(osblock.fs_size - cbase, sblock.fs_frag);
	    i + sblock.fs_frag<=dmax-cbase;	/* XXX <= or only < ? */
	    i += sblock.fs_frag) {
d905 1
a905 1
	    &acg, fso, Nflag);
d912 1
d944 1
a944 1
	int	lcs = 0;
d949 1
a949 1
	if (howmany(sblock.fs_cssize, sblock.fs_fsize) ==
d957 2
a958 2
	ocscg = dtog(&osblock, osblock.fs_csaddr);
	cs = fscs + ocscg;
d969 1
a969 1
	    (size_t)osblock.fs_cgsize, &aocg, fsi);
d975 1
a975 1
	memcpy(&cgun1, &cgun2, sizeof(cgun2));
d989 1
a989 1
	if (/* ((int)sblock.fs_time & 0x3) > 0 || */ cs->cs_nbfree < blocks) {
d995 1
a995 1
		 * cylinder  group we align the area immediately  after  the
d1010 1
a1010 1
		if (sblock.fs_ncg - osblock.fs_ncg < 2)
d1012 1
d1018 1
a1018 1
		d = osblock.fs_csaddr+(osblock.fs_cssize/osblock.fs_fsize);
d1025 3
a1027 3
		if (sblock.fs_contigsumsize > 0) {
			for (block = howmany(d % sblock.fs_fpg, sblock.fs_frag),
			    lcs = 0; lcs < sblock.fs_contigsumsize;
d1029 1
a1029 1
				if (isclr(cg_clustersfree(&acg), block))
d1031 1
d1040 3
a1042 2
		DBG_PRINT1("d=%d\n", d);
		if ((d + 1) % sblock.fs_frag) {
d1048 2
a1049 2
			frag_adjust(d % sblock.fs_fpg, -1);
			for (; (d + 1) % sblock.fs_frag; d--) {
d1052 1
a1052 1
				setbit(cg_blksfree(&acg), d % sblock.fs_fpg);
d1058 1
a1058 1
			 * (incomplete) block of the cylinder summary.
d1061 1
a1061 1
			frag_adjust(d % sblock.fs_fpg, 1);
d1063 2
a1064 2
			if (isblock(&sblock, cg_blksfree(&acg),
			    (d % sblock.fs_fpg)/sblock.fs_frag)) {
d1072 1
a1072 1
				    d % sblock.fs_fpg)]++;
d1074 3
a1076 3
				    d % sblock.fs_fpg))[cbtorpos(&sblock,
				    d % sblock.fs_fpg)]++;
				if (sblock.fs_contigsumsize > 0) {
d1078 6
a1083 4
					    (d % sblock.fs_fpg)/sblock.fs_frag);
					if (lcs < sblock.fs_contigsumsize) {
						if (lcs)
							cg_clustersum(&acg)[lcs]--;
d1098 2
a1099 2
		for (d = rounddown(d, sblock.fs_frag); d >= osblock.fs_csaddr;
		    d -= sblock.fs_frag) {
d1104 1
a1104 1
			    (d % sblock.fs_fpg)/sblock.fs_frag);
d1107 1
a1107 1
			cg_blktot(&acg)[cbtocylno(&sblock, d % sblock.fs_fpg)]++;
d1109 3
a1111 3
			    d % sblock.fs_fpg))[cbtorpos(&sblock,
			    d % sblock.fs_fpg)]++;
			 if (sblock.fs_contigsumsize > 0) {
d1113 1
a1113 1
				    (d % sblock.fs_fpg)/sblock.fs_frag);
d1117 2
a1118 2
				if (lcs < sblock.fs_contigsumsize) {
					if (lcs)
d1120 1
d1133 1
a1133 1
		    (size_t)sblock.fs_cgsize, &acg, fso, Nflag);
d1135 3
a1137 1
		DBG_DUMP_CG(&sblock, "old summary cg", &acg);
d1143 3
a1145 3
		sblock.fs_csaddr = cgdmin(&sblock, osblock.fs_ncg);
		ncscg = dtog(&sblock, sblock.fs_csaddr);
		cs = fscs + ncscg;
d1153 1
a1153 1
		if (Nflag) {
d1164 1
a1164 1
		    (size_t)sblock.fs_cgsize, &aocg, fsi);
d1170 1
a1170 1
		memcpy(&cgun1, &cgun2, sizeof(cgun2));
d1176 1
a1176 1
		for (d = sblock.fs_csaddr; d + sblock.fs_frag <=
d1187 1
a1187 1
			if (sblock.fs_contigsumsize > 0) {
d1197 2
a1198 2
		if (d < sblock.fs_csaddr+(sblock.fs_cssize/sblock.fs_fsize)) {
			for (; d - sblock.fs_csaddr<
d1213 1
a1213 1
			if (sblock.fs_contigsumsize > 0) {
d1240 1
a1240 1
		    (size_t)sblock.fs_cgsize, &acg, fso, Nflag);
d1262 1
a1262 1
	sblock.fs_dsize -= dupper - odupper;
d1267 1
a1267 1
	bp= malloc(((dupper - odupper)/sblock.fs_frag + 2) *
d1269 1
a1269 1
	if (bp == NULL)
d1271 2
a1272 1
	memset(bp, 0, ((dupper - odupper) / sblock.fs_frag + 2) *
d1283 1
a1283 1
	ind = 0;
d1285 4
a1288 3
	for (d = odupper; ((d < dupper) && (d % sblock.fs_frag)); d++) {
		DBG_PRINT1("scg first frag check loop d=%d\n", d);
		if (isclr(cg_blksfree(&acg), d)) {
d1290 1
a1290 1
				bp[ind].old = d / sblock.fs_frag;
d1292 3
a1294 2
				if (roundup(d, sblock.fs_frag) >= dupper)
					bp[ind].flags |= GFS_FL_LAST;
d1306 1
a1306 1
		 * No block - free counter handling here as this block was not
d1315 1
a1315 1
	for (; d + sblock.fs_frag<=dupper; d+=sblock.fs_frag) {
d1318 3
a1320 3
		if (!isblock(&sblock, cg_blksfree(&acg), d/sblock.fs_frag)) {
			for (f = d; f < d + sblock.fs_frag; f++) {
				if (isset(cg_blksfree(&aocg), f)) {
d1326 1
a1326 1
			bp[ind].old = d / sblock.fs_frag;
d1335 6
a1340 6
			if (sblock.fs_contigsumsize > 0) {
				clrbit(cg_clustersfree(&acg), d / sblock.fs_frag);
				for (lcs = 0, l = (d / sblock.fs_frag) + 1;
				    lcs < sblock.fs_contigsumsize;
				    l++, lcs++) {
					if (isclr(cg_clustersfree(&acg), l))
d1342 1
d1344 3
a1346 3
				if (lcs < sblock.fs_contigsumsize) {
					cg_clustersum(&acg)[lcs + 1]--;
					if (lcs)
d1348 1
d1361 2
a1362 2
	if (d < dupper) {
		frag_adjust(dupper - 1, -1);
d1364 1
a1364 1
		if (isblock(&sblock, cg_blksfree(&acg), d/sblock.fs_frag)) {
d1372 6
a1377 6
			if (sblock.fs_contigsumsize > 0) {
				clrbit(cg_clustersfree(&acg), d / sblock.fs_frag);
				for (lcs = 0, l = (d / sblock.fs_frag) + 1;
				    lcs < sblock.fs_contigsumsize;
				    l++, lcs++) {
					if (isclr(cg_clustersfree(&acg), l))
d1379 1
d1381 3
a1383 3
				if (lcs < sblock.fs_contigsumsize) {
					cg_clustersum(&acg)[lcs + 1]--;
					if (lcs)
d1385 1
d1390 6
a1395 5
		for (; d < dupper; d++) {
			DBG_PRINT1("scg second frag check loop d=%d\n", d);
			if (isclr(cg_blksfree(&acg), d)) {
				bp[ind].old = d / sblock.fs_frag;
				bp[ind].flags |= GFS_FL_LAST;
d1402 1
a1402 1
		if (bp[ind].flags & GFS_FL_LAST) /* we have to advance here */
d1404 2
a1405 1
		frag_adjust(dupper - 1, 1);
d1411 3
a1413 3
	if (ind) {
		for (i = 0; i < ind; i++) {
			if (!bp[i].old) { /* no more blocks listed */
d1425 1
a1425 1
			bp[i].new = alloc() / sblock.fs_frag;
d1431 3
a1433 3
			for (f = bp[i].old * sblock.fs_frag,
			    g = bp[i].new * sblock.fs_frag;
			    f < (bp[i].old + 1) * sblock.fs_frag;
d1435 1
a1435 1
				if (isset(cg_blksfree(&aocg), f)) {
d1450 5
a1454 4
			if (bp[i].flags & GFS_FL_FIRST) {
				for (f = bp[i].old * sblock.fs_frag,
				    g = bp[i].new * sblock.fs_frag;
				    f < odupper; f++, g++) {
d1459 4
a1462 3
				if (!(bp[i].flags & GFS_FL_LAST))
					frag_adjust(bp[i].new * sblock.fs_frag,1);

d1469 7
a1475 6
			if (bp[i].flags & GFS_FL_LAST) {
				frag_adjust(bp[i].new * sblock.fs_frag, 1);
				frag_adjust(bp[i].old * sblock.fs_frag, -1);
				for (f = dupper;
				    f < roundup(dupper, sblock.fs_frag); f++) {
					if (isclr(cg_blksfree(&acg), f)) {
d1481 1
a1481 1
				frag_adjust(bp[i].old * sblock.fs_frag, 1);
d1485 1
a1485 1
			 * !!! Attach the cylindergroup offset here.
d1487 2
a1488 2
			bp[i].old += cbase / sblock.fs_frag;
			bp[i].new += cbase / sblock.fs_frag;
d1497 6
a1502 5
			rdfs(fsbtodb(&sblock, bp[i].old * sblock.fs_frag),
			    (size_t)sblock.fs_bsize, &ablk, fsi);
			wtfs(fsbtodb(&sblock, bp[i].new * sblock.fs_frag),
			    (size_t)sblock.fs_bsize, &ablk, fso, Nflag);
			DBG_DUMP_HEX(&sblock, "copied full block",
d1506 2
a1507 1
			    bp[i].old, bp[i].new);
d1513 1
a1513 1
		 * cylinder  groups,  within those over all non  zero  length
d1516 4
a1519 3
		for (cylno = 0; cylno < osblock.fs_ncg; cylno++) {
			DBG_PRINT1("scg doing cg (%d)\n", cylno);
			for (inc = osblock.fs_ipg - 1; inc >= 0; inc--) {
d1528 2
a1529 2
		for (i = 0; i < ind; i++) {
			if (!bp[i].found || (bp[i].found>sblock.fs_frag)) {
d1553 1
a1553 1
	    &acg, fso, Nflag);
d1560 1
d1584 1
d1603 1
a1603 1
	if (lseek(fso, (off_t)bno * DEV_BSIZE, SEEK_SET) < 0)
d1605 1
d1607 1
a1607 1
	if (n != (ssize_t)size)
d1609 1
d1612 1
d1649 4
a1652 4
	blkno = -1;
	dlower = cgsblock(&sblock, acg.cg_cgx) - cgbase(&sblock, acg.cg_cgx);
	dupper = cgdmin(&sblock, acg.cg_cgx) - cgbase(&sblock, acg.cg_cgx);
	dmax = cgbase(&sblock, acg.cg_cgx) + sblock.fs_fpg;
d1656 3
a1658 3
	dmax -= cgbase(&sblock, acg.cg_cgx); /* retransform into cg */
	csmin = sblock.fs_csaddr - cgbase(&sblock, acg.cg_cgx);
	csmax = csmin + howmany(sblock.fs_cssize, sblock.fs_fsize);
d1660 6
a1665 2
	    dlower, dupper, dmax);
	DBG_PRINT2("range cont: csmin=%d, csmax=%d\n", csmin, csmax);
d1667 2
a1668 2
	for (d = 0; (d < dlower && blkno == -1); d += sblock.fs_frag) {
		if (d >= csmin && d<=csmax) {
d1671 1
a1671 1
		if (isblock(&sblock, cg_blksfree(&acg), fragstoblks(&sblock,
d1677 2
a1678 2
	for (d = dupper; (d < dmax && blkno == -1); d += sblock.fs_frag) {
		if (d >= csmin && d <= csmax) {
d1681 1
a1681 1
		if (isblock(&sblock, cg_blksfree(&acg), fragstoblks(&sblock,
d1687 1
a1687 1
	if (blkno==-1) {
d1696 1
a1696 1
	d = blkstofrags(&sblock, blkno);
d1711 3
a1713 3
		for (lcs1 = 0, l = blkno - 1; lcs1<sblock.fs_contigsumsize;
		    l--, lcs1++) {
			if (isclr(cg_clustersfree(&acg), l))
d1715 1
d1721 3
a1723 3
		for (lcs2 = 0, l = blkno + 1; lcs2<sblock.fs_contigsumsize;
		    l++, lcs2++) {
			if (isclr(cg_clustersfree(&acg), l))
d1725 1
d1731 2
a1732 2
		cg_clustersum(&acg)[MIN(lcs1+lcs2 + 1, sblock.fs_contigsumsize)]--;
		if (lcs1)
d1734 2
a1735 1
		if (lcs2)
d1737 1
d1820 1
d1855 1
d1871 1
a1871 1
	static ino_t	startinum = 0;	/* first inode in cached block */
d1876 2
a1877 2
	pi = (struct dinode *)ablk;
	inumber += (cg * sblock.fs_ipg);
d1885 2
a1886 2
		in_src = fsbtodb(&sblock, iblk);
		rdfs(in_src, (size_t)sblock.fs_bsize, &ablk, fsi);
d1954 1
a1954 1
	unsigned int	size = 0;
d1956 2
a1957 2
	unsigned int	Nflag = 0;
	int	ExpertFlag = 0;
d1961 1
a1961 1
	int	fsi, fso;
d1969 2
a1970 2
	while ((ch = getopt(argc, argv, "Ns:vy")) != -1) {
		switch (ch) {
d1972 1
a1972 1
			Nflag = 1;
d1975 2
a1976 2
			size = (size_t)atol(optarg);
			if (size < 1) {
d1983 1
a1983 1
			ExpertFlag = 1;
d1994 1
a1994 1
	if (argc != 1) {
d1997 1
a1997 1
	device = *argv;
d2005 1
d2007 9
a2015 5
		 *     /dev/r%s
		 */
		len = strlen(device) + strlen(_PATH_DEV) + 2;
		special = malloc(len);
		if (special == NULL)
d2017 14
a2030 3
		snprintf(special, len, "%s%s", _PATH_DEV, device);
		if (stat(special, &st) == -1)
			snprintf(special, len, "%sr%s", _PATH_DEV, device);
d2041 1
a2041 1
		if (fso < 0)
d2043 1
d2050 1
a2050 1
	if (fsi < 0)
d2052 1
d2055 3
a2057 3
	 * Try  to read a label and guess the slice if not  specified.  This
	 * code  should guess the right thing and avoid to bother the user
	 * with the task of specifying the option -v on vinum volumes.
d2059 1
a2059 1
	cp = device + strlen(device)-1;
d2061 5
a2065 1
	if (isdigit(*cp))
d2067 1
a2067 1
	else if (*cp>='a' && *cp<='h')
d2069 1
a2069 1
	else
d2071 1
d2076 1
a2076 1
	if (pp->p_size < 1)
d2078 2
a2079 1
	if (pp->p_fstype != FS_BSDFFS)
d2081 1
d2086 3
a2088 2
	rdfs((daddr_t)(SBOFF / DEV_BSIZE), (size_t)SBSIZE, &osblock, fsi);
	if (osblock.fs_magic != FS_MAGIC)
d2090 2
a2091 1
	memcpy(&fsun1, &fsun2, sizeof(fsun2));
d2094 2
a2095 1
	DBG_DUMP_FS(&sblock, "old sblock");
d2103 1
a2103 1
		if (size > pp->p_size) {
d2107 1
a2107 1
		sblock.fs_size = dbtofsb(&osblock, size);
d2113 1
a2113 1
	if (osblock.fs_size >= sblock.fs_size) {
d2123 3
a2125 3
	if (ExpertFlag == 0) {
		for (j = 0; j < FSMAXSNAP; j++) {
			if (sblock.fs_snapinum[j]) {
d2130 1
a2130 1
			if (!sblock.fs_snapinum[j]) /* list is dense */
d2132 1
d2138 1
a2138 1
		printf("We strongly recommend you make a backup "
d2142 1
a2142 1
		if (strcmp(reply, "Yes\n")) {
d2145 1
a2145 1
		}
d2148 1
a2148 1
	printf("new file system size is: %d frags\n", sblock.fs_size);
d2155 1
a2155 1
	wtfs((daddr_t)pp->p_size - 1, (size_t)DEV_BSIZE, &sblock, fso,
d2172 1
a2172 1
	if (sblock.fs_size * NSPF(&sblock) > sblock.fs_ncyl * sblock.fs_spc)
d2174 1
d2180 1
a2180 1
	if (sblock.fs_ncyl % sblock.fs_cpg)
d2182 1
d2184 4
a2187 4
	if ((sblock.fs_size - (sblock.fs_ncg - 1) * sblock.fs_fpg) <
	    sblock.fs_fpg && cgdmin(&sblock, (sblock.fs_ncg - 1))-
	    cgbase(&sblock, (sblock.fs_ncg - 1)) > (sblock.fs_size -
	    (sblock.fs_ncg - 1) * sblock.fs_fpg)) {
d2211 2
a2212 2

	if (osblock.fs_size >= sblock.fs_size) {
d2234 1
a2234 1
	if (fso > -1) close(fso);
d2239 1
a2239 1
	return (0);
d2255 1
a2255 1
	if (!lp) {
d2259 2
a2260 2
	if (!Nflag) {
		lp->d_checksum = 0;
d2262 1
a2262 1
		ptr = (u_short *)lp;
d2267 1
a2267 1
		while (ptr < (u_short *)&lp->d_partitions[lp->d_npartitions])
d2269 2
d2272 1
a2272 3
		lp->d_checksum = sum;

		if (ioctl(fd, DIOCWDINFO, (char *)lp) < 0)
d2274 1
d2279 1
d2294 2
a2295 2
	lab = malloc(sizeof(struct disklabel));
	if (!lab)
d2297 2
a2298 1
	if (ioctl(fd, DIOCGDINFO, (char *)lab) < 0)
d2300 1
d2313 1
a2313 1
{
d2326 1
a2326 1
 * This updates most parameters and the bitmap related to cluster. We have to
d2331 1
a2331 1
{
d2333 1
a2333 1
	static int	lcs = 0;
d2337 1
a2337 1
	if (sblock.fs_contigsumsize < 1) /* no clustering */
d2339 1
d2348 1
a2348 1
	if (!lcs) {
d2352 2
a2353 2
		for (block--; lcs < sblock.fs_contigsumsize; block--, lcs++) {
			if (isclr(cg_clustersfree(&acg), block))
d2355 1
d2357 3
a2359 3
	}
	if (lcs < sblock.fs_contigsumsize) {
		if (lcs)
d2361 1
d2367 1
d2379 1
a2379 1
{
d2392 3
a2394 3
	ino = ginode(in, fsi, cg);
	if (!((ino->di_mode & IFMT) == IFDIR || (ino->di_mode & IFMT) == IFREG ||
	    (ino->di_mode & IFMT) == IFLNK)) {
d2398 1
a2398 1
	if (((ino->di_mode & IFMT) == IFLNK) && (ino->di_size < MAXSYMLINKLEN)) {
d2402 1
a2402 1
	if (!ino->di_size) {
d2406 1
a2406 1
	if (!ino->di_blocks) {
d2410 3
a2412 1
	DBG_PRINT2("scg checking inode (%d in %d)\n", in, cg);
d2417 2
a2418 2
	remaining_blocks = howmany(ino->di_size, sblock.fs_bsize);
	for (ictr = 0; ictr < MIN(NDADDR, (unsigned int)remaining_blocks);
d2420 2
a2421 2
		iptr = &(ino->di_db[ictr]);
		if (*iptr)
d2423 1
d2427 2
a2428 2
	remaining_blocks -= NDADDR;
	if (remaining_blocks < 0) {
d2432 1
a2432 1
	if (ino->di_ib[0]) {
d2437 3
a2439 3
		i1_src = fsbtodb(&sblock, ino->di_ib[0]);
		rdfs(i1_src, (size_t)sblock.fs_bsize, &i1blk, fsi);
		for (ictr = 0; ictr < MIN(howmany(sblock.fs_bsize,
d2442 2
a2443 2
			iptr = &((ufs_daddr_t *)&i1blk)[ictr];
			if (*iptr) {
d2451 2
a2452 2
	remaining_blocks -= howmany(sblock.fs_bsize, sizeof(ufs_daddr_t));
	if (remaining_blocks<0) {
d2456 1
a2456 1
	if (ino->di_ib[1]) {
d2461 3
a2463 3
		i2_src = fsbtodb(&sblock, ino->di_ib[1]);
		rdfs(i2_src, (size_t)sblock.fs_bsize, &i2blk, fsi);
		for (ind2ctr = 0; ind2ctr < howmany(sblock.fs_bsize,
d2465 2
a2466 2
			ind2ptr = &((ufs_daddr_t *)&i2blk)[ind2ctr];
			if (!*ind2ptr)
d2468 1
d2471 2
a2472 2
			i1_src = fsbtodb(&sblock, *ind2ptr);
			rdfs(i1_src, (size_t)sblock.fs_bsize, &i1blk,
d2474 1
a2474 1
			for (ictr = 0; ictr < MIN(howmany((unsigned int)
d2477 2
a2478 2
				iptr = &((ufs_daddr_t *)&i1blk)[ictr];
				if (*iptr) {
d2488 1
a2488 1
	remaining_blocks -= SQUARE(howmany(sblock.fs_bsize, sizeof(ufs_daddr_t)));
d2490 1
a2490 1
	if (remaining_blocks < 0) {
d2494 2
a2495 2

	if (ino->di_ib[2]) {
d2500 6
a2505 6
		i3_src = fsbtodb(&sblock, ino->di_ib[2]);
		rdfs(i3_src, (size_t)sblock.fs_bsize, &i3blk, fsi);
		for (ind3ctr = 0; ind3ctr < howmany(sblock.fs_bsize,
		    sizeof(ufs_daddr_t)); ind3ctr++) {
			ind3ptr = &((ufs_daddr_t *)&i3blk)[ind3ctr];
			if (!*ind3ptr)
d2507 1
d2510 2
a2511 2
			i2_src = fsbtodb(&sblock, *ind3ptr);
			rdfs(i2_src, (size_t)sblock.fs_bsize, &i2blk,
d2513 5
a2517 4
			for (ind2ctr = 0; ind2ctr < howmany(sblock.fs_bsize,
			    sizeof(ufs_daddr_t)); ind2ctr++) {
				ind2ptr = &((ufs_daddr_t *)&i2blk)[ind2ctr];
				if (!*ind2ptr)
d2519 1
d2522 1
a2522 1
				i1_src = fsbtodb(&sblock, *ind2ptr);
d2524 2
a2525 2
				    &i1blk, fsi);
				for (ictr = 0; ictr < MIN(howmany(sblock.fs_bsize,
d2528 3
a2530 2
					iptr = &((ufs_daddr_t *)&i1blk)[ictr];
					if (*iptr) {
d2543 1
@


1.1.1.2
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.5 2003/08/16 17:31:55 deraadt Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.5 2003/08/16 17:31:55 deraadt Exp $";
d1999 1
a1999 1
				    "using growfs");
@


1.1.1.3
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.6 2003/08/25 23:28:15 tedu Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.6 2003/08/25 23:28:15 tedu Exp $";
d108 1
a108 1
static struct ufs1_dinode	zino[MAXBSIZE / sizeof(struct ufs1_dinode)]; /* some inodes */
d139 1
a139 1
static struct ufs1_dinode	*ginode(ino_t, int, int);
d407 1
a407 1
		for (j = 0; (unsigned)j < sblock.fs_bsize / sizeof(struct ufs1_dinode); j++)
d1765 1
a1765 1
static struct ufs1_dinode *
d1771 1
a1771 1
	struct ufs1_dinode	*pi;
d1775 1
a1775 1
	pi = (struct ufs1_dinode *)ablk;
d2243 1
a2243 1
	struct ufs1_dinode	*ino;
@


1.1.1.4
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.10 2003/11/08 19:17:28 jmc Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.10 2003/11/08 19:17:28 jmc Exp $";
a65 2
#include <util.h>

d1152 1
a1152 1
		 *	space is less than the maximum cluster size. This is
d1851 2
a1852 2
	char	*device, *rdev;
	int	ch;
d1854 1
d1868 1
a1868 1
	while ((ch = getopt(argc, argv, "Ns:y")) != -1) {
d1879 2
d1899 1
a1899 2
	 * Rather than guessing, use opendev() to get the device
	 * name, which we open for reading.
d1901 15
a1915 2
	if ((fsi = opendev(device, O_RDONLY, 0, &rdev)) < 0)
		err(1, "%s", rdev);
d1918 1
a1918 1
	 * Try to access our device for writing ...
d1923 1
a1923 1
		fso = open(rdev, O_WRONLY);
d1925 1
a1925 1
			err(1, "%s", rdev);
d1929 1
a1929 2
	 * Now we have a file descriptor for our device, fstat() it to
	 * figure out the partition number.
d1931 3
a1933 2
	if (fstat(fsi, &st) != 0)
		err(1, "%s: fstat()", rdev);
d1936 3
a1938 3
	 * Try to read a label from the disk.  Then get the partition from the
	 * device minor number, using DISKPART().  Probably don't need to
	 * check against getmaxpartitions().
d1940 1
d1942 4
a1945 2
	if (DISKPART(st.st_rdev) < getmaxpartitions())
		pp = &lp->d_partitions[DISKPART(st.st_rdev)];
d1947 1
a1947 2
		errx(1, "%s: invalid partition number %u",
		     rdev, DISKPART(st.st_rdev));
@


1.1.1.5
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.11 2004/03/15 08:52:01 deraadt Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.11 2004/03/15 08:52:01 deraadt Exp $";
d1932 1
a1932 1
		    rdev, DISKPART(st.st_rdev));
d2052 1
a2052 1
		printf("Warning: %d sector(s) cannot be allocated.\n",
d2087 1
a2087 2
	if (fso > -1)
		close(fso);
@


