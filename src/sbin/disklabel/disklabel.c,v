head	1.18;
access;
symbols
	tg-mergetmp-mirosx-1:1.18
	tg-mergefixes-1-branch:1.18.0.4
	tg-mergefixes-1-base:1.18
	MIROS_X:1.18.0.2
	MIROS_X_BASE:1.18
	tg-mergetmp-3:1.18
	cvs-200412111650:1.1.1.11
	MIRBSD_XP_MIRPPC:1.16.0.4
	cvs-200410141645:1.1.1.11
	MIRBSD_XP_SPARC_BASE:1.16
	MIRBSD_XP_SPARC:1.16.0.2
	MIRBSD_7quater:1.9
	cvs-200405160640:1.1.1.10
	cvs-200401271800:1.1.1.9
	cvs-200401261630:1.1.1.9
	cvs-200401021645:1.1.1.9
	MIRBSD_7_ALPHA:1.9.0.6
	MIRBSD_7:1.9.0.4
	cvs-200312222040:1.1.1.9
	MIRBSD_7ter:1.9
	MIRBSD_7_DEV:1.9.0.2
	cvs-200310020700:1.1.1.8
	cvs-200309271030:1.1.1.8
	cvs-200309251530:1.1.1.8
	cvs-200308302005:1.1.1.8
	cvs-200308171200:1.1.1.8
	ctm-3496:1.1.1.8
	ctm-3449:1.1.1.7
	ctm-3437:1.1.1.7
	cvs-200307191805:1.1.1.7
	ctm-3425:1.1.1.7
	cvs-200307091500:1.1.1.6
	ctm-3389:1.1.1.6
	cvs-200306291430:1.1.1.5
	ctm-3341:1.1.1.4
	MIRBSD_5:1.4
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2004.12.05.13.24.46;	author tg;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.14.20.50.48;	author tg;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.27.16.43.11;	author tg;	state Stab;
branches;
next	1.15;

1.15
date	2004.01.03.18.29.45;	author tg;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.03.00.46.56;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.02.23.44.11;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.02.23.40.16;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.02.23.25.06;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.27.00.30.37;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.16.15.25.20;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.18.15.45.10;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.06.20.22.06;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.29.19.48.41;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.19.16.44.15;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.06.18.28.27;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.24.19.49.38;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.20.20.00.57;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.48.23;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.48.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.14.44.10;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.30.44;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.19.12.42.14;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.06.29.17.26.56;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.07.06.15.39.18;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.07.18.13.42.03;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.08.11.18.29.25;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.12.22.21.10.22;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.05.16.08.23.02;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2004.10.14.17.19.16;	author tg;	state Exp;
branches;
next	;


desc
@@


1.18
log
@* replace all occurences of old eMail addresses of mine
  with their more recent counterparts
* no $Log keyword!
* update licence template to most recent version in files touched
* in some places, don't add our own licence boilerplate, just
  add my name to the others
* make dev/rndvar.h suitable for inclusion in asm code
* include dev/rndvar.h by in_cksum.s instead of
  hardcoding pool size
* ENTRY(a); ENTRY(b) -> NENTRY(a); ENTRY(b)
* RCS IDs belong into .comment not .text
@
text
@/**	$MirBSD: src/sbin/disklabel/disklabel.c,v 1.17 2004/10/14 20:50:48 tg Exp $ */
/*	$OpenBSD: disklabel.c,v 1.93 2004/10/04 15:09:41 otto Exp $	*/

/*
 * Copyright (c) 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 2004
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
 *
 * This code is derived from software contributed to Berkeley by
 * Symmetric Computer Systems.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1987, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/wait.h>
#define DKTYPENAMES
#include <sys/disklabel.h>

#include <ufs/ffs/fs.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <signal.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <util.h>
#include "pathnames.h"
#include "extern.h"

__RCSID("$MirBSD: src/sbin/disklabel/disklabel.c,v 1.17 2004/10/14 20:50:48 tg Exp $");

/*
 * Disklabel: read and write disklabels.
 * The label is usually placed on one of the first sectors of the disk.
 * Many machines also place a bootstrap in the same area,
 * in which case the label is embedded in the bootstrap.
 * The bootstrap source must leave space at the proper offset
 * for the label on such machines.
 */

#ifndef BBSIZE
#define	BBSIZE	8192			/* size of boot area, with label */
#endif

#ifndef NUMBOOT
#define NUMBOOT 0
#endif

char	*dkname, *specname;
char	tmpfil[] = _PATH_TMPFILE;
char	namebuf[BBSIZE], *np = namebuf;
struct	disklabel lab;
char	bootarea[BBSIZE];

#if NUMBOOT > 0
int	installboot;	/* non-zero if we should install a boot program */
char	*bootbuf;	/* pointer to buffer with remainder of boot prog */
int	bootsize;	/* size of remaining boot program */
char	*xxboot;	/* primary boot */
char	*bootxx;	/* secondary boot */
char	boot0[MAXPATHLEN];
#if NUMBOOT > 1
char	boot1[MAXPATHLEN];
#endif
#endif

enum {
	UNSPEC, EDIT, EDITOR, READ, RESTORE, SETWRITEABLE, WRITE, WRITEBOOT
} op = UNSPEC;

int	cflag;
int	dflag;
int	rflag;
int	tflag;
int	nwflag;
int	verbose;
int	donothing;

#ifdef DOSLABEL
struct dos_partition *dosdp;	/* DOS partition, if found */
struct dos_partition *readmbr(int);
#endif

void	makedisktab(FILE *, struct disklabel *);
void	makelabel(char *, char *, struct disklabel *);
int	writelabel(int, char *, struct disklabel *);
void	l_perror(char *);
int	edit(struct disklabel *, int);
int	editit(void);
char	*skip(char *);
char	*word(char *);
int	getasciilabel(FILE *, struct disklabel *);
int	cmplabel(struct disklabel *, struct disklabel *);
void	setbootflag(struct disklabel *);
void	usage(void);
u_int32_t getnum(char *, u_int32_t, u_int32_t, const char **);

int
main(int argc, char *argv[])
{
	int ch, f, writeable, error = 0;
	char *fstabfile = NULL;
	struct disklabel *lp;
	char print_unit = 0;
	FILE *t;

	while ((ch = getopt(argc, argv, "BEf:NRWb:cdenp:rs:tvw")) != -1)
		switch (ch) {
#if NUMBOOT > 0
		case 'B':
			++installboot;
			break;
		case 'b':
			xxboot = optarg;
			break;
#if NUMBOOT > 1
		case 's':
			bootxx = optarg;
			break;
#endif
#endif
		case 'N':
			if (op != UNSPEC)
				usage();
			writeable = 0;
			op = SETWRITEABLE;
			break;
		case 'R':
			if (op != UNSPEC)
				usage();
			op = RESTORE;
			break;
		case 'W':
			if (op != UNSPEC)
				usage();
			writeable = 1;
			op = SETWRITEABLE;
			break;
		case 'c':
			++cflag;
			break;
		case 'd':
			++dflag;
			break;
		case 'e':
			if (op != UNSPEC)
				usage();
			op = EDIT;
			break;
		case 'E':
			if (op != UNSPEC)
				usage();
			op = EDITOR;
			break;
		case 'f':
			fstabfile = optarg;
			break;
		case 'r':
			++rflag;
			break;
		case 't':
			++tflag;
			break;
		case 'w':
			if (op != UNSPEC)
				usage();
			op = WRITE;
			break;
		case 'p':
			if (strchr("bckmg", optarg[0]) == NULL ||
			    optarg[1] != '\0')
				usage();
			print_unit = optarg[0];
			break;
		case 'n':
			donothing++;
			break;
		case 'v':
			verbose++;
			break;
		case '?':
		default:
			usage();
	}
	argc -= optind;
	argv += optind;

#if NUMBOOT > 0
	if (installboot) {
		rflag++;
		if (op == UNSPEC)
			op = WRITEBOOT;
	} else {
		if (op == UNSPEC)
			op = READ;
	}
#else
	if (op == UNSPEC)
		op = READ;
#endif

	if (argc < 1 || (rflag && cflag + dflag > 0) ||
	    (fstabfile && op != EDITOR))
		usage();

	dkname = argv[0];
	f = opendev(dkname, (op == READ ? O_RDONLY : O_RDWR), OPENDEV_PART,
	    &specname);
	if (f < 0)
		err(4, "%s", specname);

#ifdef DOSLABEL
	/*
	 * Check for presence of DOS partition table in
	 * master boot record. Return pointer to MirBSD
	 * partition, if present. If no valid partition table,
	 * return 0. If valid partition table present, but no
	 * partition to use, return a pointer to a non-386bsd
	 * partition.
	 */
	dosdp = readmbr(f);
#endif

	switch (op) {
	case EDIT:
		if (argc != 1)
			usage();
		if ((lp = readlabel(f)) == NULL)
			exit(1);
		error = edit(lp, f);
		break;
	case EDITOR:
		if (argc != 1)
			usage();
		if ((lp = readlabel(f)) == NULL)
			exit(1);
		error = editor(lp, f, specname, fstabfile);
		break;
	case READ:
		if (argc != 1)
			usage();
		if ((lp = readlabel(f)) == NULL)
			exit(1);
		if (tflag)
			makedisktab(stdout, lp);
		else
			display(stdout, lp, print_unit);
		error = checklabel(lp);
		break;
	case RESTORE:
		if (argc < 2 || argc > 3)
			usage();
#if NUMBOOT > 0
		if (installboot && argc == 3)
			makelabel(argv[2], NULL, &lab);
#endif
		lp = makebootarea(bootarea, &lab, f);
		if (!(t = fopen(argv[1], "r")))
			err(4, "%s", argv[1]);
		if (getasciilabel(t, lp))
			error = writelabel(f, bootarea, lp);
		else
			error = 1;
		break;
	case SETWRITEABLE:
		if (!donothing) {
			if (ioctl(f, DIOCWLABEL, (char *)&writeable) < 0)
				err(4, "ioctl DIOCWLABEL");
		}
		break;
	case WRITE:
		if (argc < 2 || argc > 3)
			usage();
		makelabel(argv[1], argc == 3 ? argv[2] : NULL, &lab);
		lp = makebootarea(bootarea, &lab, f);
		*lp = lab;
		if (checklabel(lp) == 0)
			error = writelabel(f, bootarea, lp);
		break;
#if NUMBOOT > 0
	case WRITEBOOT:
	{
		struct disklabel tlab;

		if ((lp = readlabel(f)) == NULL)
			exit(1);
		tlab = *lp;
		if (argc == 2)
			makelabel(argv[1], NULL, &lab);
		lp = makebootarea(bootarea, &lab, f);
		*lp = tlab;
		if (checklabel(lp) == 0)
			error = writelabel(f, bootarea, lp);
		break;
	}
#endif
	default:
		break;
	}
	exit(error);
}

/*
 * Construct a prototype disklabel from /etc/disktab.  As a side
 * effect, set the names of the primary and secondary boot files
 * if specified.
 */
void
makelabel(char *type, char *name, struct disklabel *lp)
{
	struct disklabel *dp;

	dp = getdiskbyname(type);
	if (dp == NULL)
		errx(1, "unknown disk type: %s", type);
	*lp = *dp;
#if NUMBOOT > 0
	/*
	 * Set bootstrap name(s).
	 * 1. If set from command line, use those,
	 * 2. otherwise, check if disktab specifies them (b0 or b1),
	 * 3. otherwise, makebootarea() will choose ones based on the name
	 *    of the disk special file. E.g. /dev/ra0 -> raboot, bootra
	 */
	if (!xxboot && lp->d_boot0) {
		if (*lp->d_boot0 != '/')
			(void)snprintf(boot0, sizeof boot0, "%s%s",
			    _PATH_BOOTDIR, lp->d_boot0);
		else
			(void)strlcpy(boot0, lp->d_boot0, sizeof boot0);
		xxboot = boot0;
	}
#if NUMBOOT > 1
	if (!bootxx && lp->d_boot1) {
		if (*lp->d_boot1 != '/')
			(void)snprintf(boot1, sizeof boot1, "%s%s",
			    _PATH_BOOTDIR, lp->d_boot1);
		else
			(void)strlcpy(boot1, lp->d_boot1, sizeof boot1);
		bootxx = boot1;
	}
#endif
#endif
	/* d_packname is union d_boot[01], so zero */
	memset(lp->d_packname, 0, sizeof(lp->d_packname));
	if (name)
		(void)strncpy(lp->d_packname, name, sizeof(lp->d_packname));
}

int
writelabel(int f, char *boot, struct disklabel *lp)
{
	int writeable;
	off_t sectoffset = 0;

	if (nwflag) {
		warnx("DANGER! The disklabel was not found at the correct location!");
		warnx("To repair this situation, use 'disklabel %s > file' to",
		    dkname);
		warnx("save it, then use 'disklabel -R %s file' to replace it.",
		    dkname);
		warnx("A new disklabel is not being installed now.");
		return(0); /* Actually 1 but we want to exit */
	}
#if NUMBOOT > 0
	setbootflag(lp);
#endif
	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);
	if (rflag) {
#ifdef DOSLABEL
		struct partition *pp = &lp->d_partitions[2];

		/*
		 * If MirBSD BIOS partition is missing, or if
		 * the label to be written is not within partition,
		 * prompt first. Need to allow this in case operator
		 * wants to convert the drive for dedicated use.
		 * In this case, partition 'a' had better start at 0,
		 * otherwise we reject the request as meaningless. -wfj
		 */
		if (dosdp && pp->p_size &&
		    (dosdp->dp_typ == DOSPTYP_MIRBSD ||
		    dosdp->dp_typ == DOSPTYP_OPENBSD ||
		    dosdp->dp_typ == DOSPTYP_FREEBSD ||
		    dosdp->dp_typ == DOSPTYP_NETBSD)) {
		        sectoffset = (off_t)get_le(&dosdp->dp_start) *
			    lp->d_secsize;
		} else {
			if (dosdp) {
				int first, ch;

				printf("Erase the previous contents of the disk? [n]: ");
				fflush(stdout);
				first = ch = getchar();
				while (ch != '\n' && ch != EOF)
					ch = getchar();
				if (first != 'y' && first != 'Y')
					exit(0);
			}
			sectoffset = 0;
		}

#if NUMBOOT > 0
		/*
		 * If we are not installing a boot program
		 * we must read the current bootarea so we don't
		 * clobber the existing boot.
		 */
		if (!installboot) {
			struct disklabel tlab;

			if (lseek(f, sectoffset, SEEK_SET) < 0) {
				perror("lseek");
				return (1);
			}
			tlab = *lp;
			if (read(f, boot, tlab.d_bbsize) != tlab.d_bbsize) {
				perror("read");
				return (1);
			}
			*lp =tlab;
		}
#endif
#endif

		/*
		 * First set the kernel disk label,
		 * then write a label to the raw disk.
		 * If the SDINFO ioctl fails because it is unimplemented,
		 * keep going; otherwise, the kernel consistency checks
		 * may prevent us from changing the current (in-core)
		 * label.
		 */
		if (!donothing) {
			if (ioctl(f, DIOCSDINFO, lp) < 0 &&
			    errno != ENODEV && errno != ENOTTY) {
				l_perror("ioctl DIOCSDINFO");
				return (1);
			}
		}
		if (verbose)
			printf("writing label to block %lld (0x%qx)\n",
			    (long long)sectoffset/DEV_BSIZE,
			    (long long)sectoffset/DEV_BSIZE);
		if (!donothing) {
			if (lseek(f, sectoffset, SEEK_SET) < 0) {
				perror("lseek");
				return (1);
			}
			/*
			 * write enable label sector before write (if necessary),
			 * disable after writing.
			 */
			writeable = 1;

			if (ioctl(f, DIOCWLABEL, &writeable) < 0)
				perror("ioctl DIOCWLABEL");
#ifdef __alpha__
			/*
			 * The Alpha requires that the boot block be checksummed.
			 * The first 63 8-byte quantites are summed into the 64th.
			 */
			{
				int i;
				u_int64_t *dp, sum;

				dp = (u_int64_t *)boot;
				sum = 0;
				for (i = 0; i < 63; i++)
					sum += dp[i];
				dp[63] = sum;
			}
#endif
			if (write(f, boot, lp->d_bbsize) != lp->d_bbsize) {
				perror("write");
				return (1);
			}
		}
#if NUMBOOT > 0
		/*
		 * Output the remainder of the disklabel
		 */
		if (!donothing && bootbuf && write(f, bootbuf, bootsize) != bootsize) {
			perror("write");
			return(1);
		}
#endif
		writeable = 0;
		if (!donothing)
			if (ioctl(f, DIOCWLABEL, &writeable) < 0)
				perror("ioctl DIOCWLABEL");
	} else {
		if (!donothing) {
			if (ioctl(f, DIOCWDINFO, lp) < 0) {
				l_perror("ioctl DIOCWDINFO");
				return (1);
			}
		}
	}
	return (0);
}

void
l_perror(char *s)
{

	switch (errno) {
	case ESRCH:
		warnx("%s: No disk label on disk;\n"
		    "use \"disklabel -r\" to install initial label", s);
		break;
	case EINVAL:
		warnx("%s: Label magic number or checksum is wrong!\n"
		    "(disklabel or kernel is out of date?)", s);
		break;
	case EBUSY:
		warnx("%s: Open partition would move or shrink", s);
		break;
	case EXDEV:
		warnx("%s: Labeled partition or 'a' partition must start "
		    "at beginning of disk", s);
		break;
	default:
		warn("%s", s);
		break;
	}
}

#ifdef DOSLABEL
/* read sector containing partition table from the disc */
int
read_pt(int f, long offs, int *target)
{
	if (lseek(f, (off_t)offs * DEV_BSIZE, SEEK_SET) < 0)
		return -1;
	if (read(f, target, DEV_BSIZE) < DEV_BSIZE)
		return -1;
	return 0;
}

/* scan partition table for BIOS partition of given type */
int
scan_pt(struct dos_partition *dp, u_int8_t what)
{
	int part;

	for (part = 0; part < NDOSPART; ++part) {
		if ((!get_le(&dp[part].dp_size)) || (dp[part].dp_typ != what))
			continue;
		fprintf(stderr, "# found partition %d: "
		    "type %02X ofs %d (0x%Xh) size %d (0x%X)%s\n",
		    part, dp[part].dp_typ,
		    get_le(&dp[part].dp_start), get_le(&dp[part].dp_start),
		    get_le(&dp[part].dp_size), get_le(&dp[part].dp_size),
		    ( ((what == DOSPTYP_EXTENDL) || (what == DOSPTYP_EXTENDLX)
		       || (what == DOSPTYP_EXTEND)) ? ", chaining..." : "."));
		return part;
	}
	return NDOSPART;
}

/*
 * Fetch DOS partition table from disk.
 */
struct dos_partition *
readmbr(int f)
{
	static int mbr[DEV_BSIZE / sizeof(int)];
	long mbrofs;
	struct dos_partition *dp;
	u_int16_t signature;
	int part;

	mbrofs = DOSBBSECTOR;
loop:	if (read_pt(f, mbrofs, mbr))
	    err(4, "can't read partition table");

	/*
	 * This must be done this way due to alignment restrictions
	 * in for example mips processors.
         */
	dp = (struct dos_partition *)mbr;
	signature = *((u_char *)mbr + DOSMBR_SIGNATURE_OFF) |
	    (*((u_char *)mbr + DOSMBR_SIGNATURE_OFF + 1) << 8);
	memmove((char *)mbr, (char *)mbr + DOSPARTOFF, sizeof(*dp) * NDOSPART);

	/*
	 * Don't (yet) know disk geometry (BIOS), use
	 * partition table to find MirBSD partition, and obtain
	 * disklabel from there.
	 */
	/* Check if table is valid. Adjust offsets of partitions. */
	for (part = 0; part < NDOSPART; part++) {
		set_le(&dp[part].dp_start,
		    get_le(&dp[part].dp_start) + mbrofs);
		if ((dp[part].dp_flag & ~0x80) != 0)
			return (0);
	}

	/* scan for MirBSD (or OpenBSD, FreeBSD, NetBSD) partition */
	if ((part = scan_pt(dp, DOSPTYP_MIRBSD)) < NDOSPART)
		return (&dp[part]);
	if ((part = scan_pt(dp, DOSPTYP_OPENBSD)) < NDOSPART)
		return (&dp[part]);
	if ((part = scan_pt(dp, DOSPTYP_NETBSD)) < NDOSPART)
		return (&dp[part]);
	if ((part = scan_pt(dp, DOSPTYP_FREEBSD)) < NDOSPART)
		return (&dp[part]);

	/*
	 * If there is no signature and no MirBSD partition, this is probably
	 * not an MBR.
	 */
	if (signature != DOSMBR_SIGNATURE)
		return (NULL);

	/*
	 * still not found? scan for extended partition
	 * XXX this code assumes: only one 05, 0F or 85 per partition table
	 */
	if ((part = scan_pt(dp, DOSPTYP_EXTEND)) == NDOSPART)
	    if ((part = scan_pt(dp, DOSPTYP_EXTENDL)) == NDOSPART)
	    if ((part = scan_pt(dp, DOSPTYP_EXTENDLX)) == NDOSPART) {
		/* if still none found, find first used partition */
		if (read_pt(f, DOSBBSECTOR, mbr)) {
		    warn("can't read master boot record");
		    return (NULL);
		}
		dp = (struct dos_partition *)mbr;
		memcpy((char *)mbr, (char *)mbr + DOSPARTOFF,
		    sizeof(*dp) * NDOSPART);
		for (part = 0; part < NDOSPART; part++) {
			if (get_le(&dp[part].dp_size)) {
				warnx("warning, DOS partition table with"
				    " no valid MirBSD partition");
				return (&dp[part]);
			}
		}
		/* Table appears to be empty. */
		return (NULL);
	}

	/* we have an extended partition, loop */
	mbrofs = get_le(&dp[part].dp_start);
	goto loop;
	/* NOTREACHED */
}
#endif

/*
 * Fetch disklabel for disk.
 * Use ioctl to get label unless -r flag is given.
 */
struct disklabel *
readlabel(int f)
{
	struct disklabel *lp = NULL;

	if (rflag) {
		char *msg;
		off_t sectoffset = 0;

#ifdef DOSLABEL
		if (dosdp && get_le(&dosdp->dp_size) &&
		    (dosdp->dp_typ == DOSPTYP_MIRBSD ||
		    dosdp->dp_typ == DOSPTYP_OPENBSD ||
		    dosdp->dp_typ == DOSPTYP_FREEBSD ||
		    dosdp->dp_typ == DOSPTYP_NETBSD))
			sectoffset = (off_t)get_le(&dosdp->dp_start) *
			    DEV_BSIZE;
#endif
		if (verbose)
			printf("reading label from block %lld, offset %lld\n",
			    (long long)sectoffset/DEV_BSIZE,
			    sectoffset/DEV_BSIZE +
			    (LABELSECTOR * DEV_BSIZE) + LABELOFFSET);
		if (lseek(f, sectoffset, SEEK_SET) < 0 ||
		    read(f, bootarea, BBSIZE) < BBSIZE)
			err(4, "%s", specname);

		lp = (struct disklabel *)(bootarea +
			(LABELSECTOR * DEV_BSIZE) + LABELOFFSET);
		if (lp->d_magic == DISKMAGIC &&
		    lp->d_magic2 == DISKMAGIC) {
			if (lp->d_npartitions <= MAXPARTITIONS &&
			    dkcksum(lp) == 0)
				return (lp);

			msg = "disk label corrupted";
		}
		else {
			warnx("no disklabel found. scanning.");
		}
		nwflag++;

		msg = "no disk label";
		for (lp = (struct disklabel *)bootarea;
		    lp <= (struct disklabel *)(bootarea + BBSIZE - sizeof(*lp));
		    lp = (struct disklabel *)((char *)lp + sizeof(long))) {
			if (lp->d_magic == DISKMAGIC &&
			    lp->d_magic2 == DISKMAGIC) {
				if (lp->d_npartitions <= MAXPARTITIONS &&
				    dkcksum(lp) == 0) {
					warnx("found at 0x%lx",
					    (long)((char *)lp - bootarea));
					return (lp);
				}
				msg = "disk label corrupted";
			}
		}
		warnx("%s", msg);
		return(NULL);
	} else {
		if (cflag && ioctl(f, DIOCRLDINFO) < 0)
			err(4, "ioctl DIOCRLDINFO");
		if (dflag) {
			lp = &lab;
			if (ioctl(f, DIOCGPDINFO, lp) < 0)
				err(4, "ioctl DIOCGPDINFO");
		} else {
			lp = &lab;
			if (ioctl(f, DIOCGDINFO, lp) < 0)
				err(4, "ioctl DIOCGDINFO");
		}
	}
	return (lp);
}

/*
 * Construct a bootarea (d_bbsize bytes) in the specified buffer "boot"
 * Returns a pointer to the disklabel portion of the bootarea.
 */
struct disklabel *
makebootarea(char *boot, struct disklabel *dp, int f)
{
	struct disklabel *lp;
	char *p;
#if NUMBOOT > 0
	char *dkbasename;
	int b;
#if NUMBOOT == 1
	struct stat sb;
#endif
#endif

	/* XXX */
	if (dp->d_secsize == 0) {
		dp->d_secsize = DEV_BSIZE;
		dp->d_bbsize = BBSIZE;
	}
	lp = (struct disklabel *)
	    (boot + (LABELSECTOR * dp->d_secsize) + LABELOFFSET);
	memset(lp, 0, sizeof *lp);
#if NUMBOOT > 0
	/*
	 * If we are not installing a boot program but we are installing a
	 * label on disk then we must read the current bootarea so we don't
	 * clobber the existing boot.
	 */
	if (!installboot) {
#ifndef __i386__
		if (rflag) {
			if (read(f, boot, BBSIZE) < BBSIZE)
				err(4, "%s", specname);
			memset(lp, 0, sizeof *lp);
		}
#endif
		return (lp);
	}
	/*
	 * We are installing a boot program.  Determine the name(s) and
	 * read them into the appropriate places in the boot area.
	 */
	if (!xxboot || !bootxx) {
		dkbasename = np;
		if ((p = strrchr(dkname, '/')) == NULL)
			p = dkname;
		else
			p++;
		while (*p && !isdigit(*p))
			*np++ = *p++;
		*np++ = '\0';

		if (!xxboot) {
			(void)snprintf(np, namebuf + sizeof namebuf - np,
			    "%s%sboot", _PATH_BOOTDIR, dkbasename);
			if (access(np, F_OK) < 0 && dkbasename[0] == 'r')
				dkbasename++;
			xxboot = np;
			(void)snprintf(xxboot,
			    namebuf + sizeof namebuf - np,
			    "%s%sboot", _PATH_BOOTDIR, dkbasename);
			np += strlen(xxboot) + 1;
		}
#if NUMBOOT > 1
		if (!bootxx) {
			(void)snprintf(np, namebuf + sizeof namebuf - np,
			    "%sboot%s", _PATH_BOOTDIR, dkbasename);
			if (access(np, F_OK) < 0 && dkbasename[0] == 'r')
				dkbasename++;
			bootxx = np;
			(void)snprintf(bootxx, namebuf + sizeof namebuf - bootxx,
			    "%sboot%s", _PATH_BOOTDIR, dkbasename);
			np += strlen(bootxx) + 1;
		}
#endif
	}
	if (verbose)
		warnx("bootstraps: xxboot = %s, bootxx = %s", xxboot,
		    bootxx ? bootxx : "NONE");

	/*
	 * Strange rules:
	 * 1. One-piece bootstrap (hp300/hp800)
	 *	up to d_bbsize bytes of "xxboot" go in bootarea, the rest
	 *	is remembered and written later following the bootarea.
	 * 2. Two-piece bootstraps (vax/i386?/mips?)
	 *	up to d_secsize bytes of "xxboot" go in first d_secsize
	 *	bytes of bootarea, remaining d_bbsize-d_secsize filled
	 *	from "bootxx".
	 */
	b = open(xxboot, O_RDONLY);
	if (b < 0)
		err(4, "%s", xxboot);
#if NUMBOOT > 1
	if (read(b, boot, (int)dp->d_secsize) < 0)
		err(4, "%s", xxboot);
	(void)close(b);
	b = open(bootxx, O_RDONLY);
	if (b < 0)
		err(4, "%s", bootxx);
	if (read(b, &boot[dp->d_secsize], (int)(dp->d_bbsize-dp->d_secsize)) < 0)
		err(4, "%s", bootxx);
#else
	if (read(b, boot, (int)dp->d_bbsize) < 0)
		err(4, "%s", xxboot);
	(void)fstat(b, &sb);
	bootsize = (int)sb.st_size - dp->d_bbsize;
	if (bootsize > 0) {
		/* XXX assume d_secsize is a power of two */
		bootsize = (bootsize + dp->d_secsize-1) & ~(dp->d_secsize-1);
		bootbuf = (char *)malloc((size_t)bootsize);
		if (bootbuf == 0)
			err(4, "%s", xxboot);
		if (read(b, bootbuf, bootsize) < 0) {
			free(bootbuf);
			err(4, "%s", xxboot);
		}
	}
#endif
	(void)close(b);
#endif
	/*
	 * Make sure no part of the bootstrap is written in the area
	 * reserved for the label.
	 */
	for (p = (char *)lp; p < (char *)lp + sizeof(struct disklabel); p++)
		if (*p)
			errx(2, "Bootstrap doesn't leave room for disk label");
	return (lp);
}

void
makedisktab(FILE *f, struct disklabel *lp)
{
	int i;
	char *did = "\\\n\t:";
	struct partition *pp;

	if (lp->d_packname[0])
		(void)fprintf(f, "%.*s|", (int)sizeof(lp->d_packname),
		    lp->d_packname);
	if (lp->d_typename[0])
		(void)fprintf(f, "%.*s|", (int)sizeof(lp->d_typename),
		    lp->d_typename);
	(void)fputs("Automatically generated label:\\\n\t:dt=", f);
	if ((unsigned) lp->d_type < DKMAXTYPES)
		(void)fprintf(f, "%s:", dktypenames[lp->d_type]);
	else
		(void)fprintf(f, "unknown%d:", lp->d_type);

	(void)fprintf(f, "se#%u:", lp->d_secsize);
	(void)fprintf(f, "ns#%u:", lp->d_nsectors);
	(void)fprintf(f, "nt#%u:", lp->d_ntracks);
	(void)fprintf(f, "nc#%u:", lp->d_ncylinders);
	(void)fprintf(f, "sc#%u:", lp->d_secpercyl);
	(void)fprintf(f, "su#%u:", lp->d_secperunit);

	if (lp->d_rpm != 3600) {
		(void)fprintf(f, "%srm#%hu:", did, lp->d_rpm);
		did = "";
	}
	if (lp->d_interleave != 1) {
		(void)fprintf(f, "%sil#%hu:", did, lp->d_interleave);
		did = "";
	}
	if (lp->d_trackskew != 0) {
		(void)fprintf(f, "%ssk#%hu:", did, lp->d_trackskew);
		did = "";
	}
	if (lp->d_cylskew != 0) {
		(void)fprintf(f, "%scs#%hu:", did, lp->d_cylskew);
		did = "";
	}
	if (lp->d_headswitch != 0) {
		(void)fprintf(f, "%shs#%u:", did, lp->d_headswitch);
		did = "";
	}
	if (lp->d_trkseek != 0) {
		(void)fprintf(f, "%sts#%u:", did, lp->d_trkseek);
		did = "";
	}
	for (i = 0; i < NDDATA; i++)
		if (lp->d_drivedata[i])
			(void)fprintf(f, "d%d#%u", i, lp->d_drivedata[i]);
	pp = lp->d_partitions;
	for (i = 0; i < lp->d_npartitions; i++, pp++) {
		if (pp->p_size) {
			char c = 'a' + i;

			(void)fprintf(f, "\\\n\t:");
			(void)fprintf(f, "p%c#%u:", c, pp->p_size);
			(void)fprintf(f, "o%c#%u:", c, pp->p_offset);
			if (pp->p_fstype != FS_UNUSED) {
				if ((unsigned) pp->p_fstype < FSMAXTYPES)
					(void)fprintf(f, "t%c=%s:", c,
					    fstypenames[pp->p_fstype]);
				else
					(void)fprintf(f, "t%c=unknown%d:",
					    c, pp->p_fstype);
			}
			switch (pp->p_fstype) {

			case FS_UNUSED:
				break;

			case FS_BSDFFS:
				(void)fprintf(f, "b%c#%u:", c,
				    pp->p_fsize * pp->p_frag);
				(void)fprintf(f, "f%c#%u:", c, pp->p_fsize);
				break;

			default:
				break;
			}
		}
	}
	(void)fputc('\n', f);
	(void)fflush(f);
}

/*
 * Display a particular partition.
 */
void
display_partition(FILE *f, struct disklabel *lp, char **mp, int i,
    char unit)
{
	volatile struct partition *pp = &lp->d_partitions[i];
	double p_size, p_offset;

	unit = toupper(unit);
	p_size = -1.0;			/* no conversion by default */
	p_offset = 0.0;
	switch (unit) {
	case 'B':
		p_size = (double)pp->p_size * lp->d_secsize;
		p_offset = (double)pp->p_offset * lp->d_secsize;
		break;

	case 'C':
		p_size = (double)pp->p_size / lp->d_secpercyl;
		p_offset = (double)pp->p_offset / lp->d_secpercyl;
		break;

	case 'K':
		p_size = (double)pp->p_size / (1024 / lp->d_secsize);
		p_offset = (double)pp->p_offset / (1024 / lp->d_secsize);
		break;

	case 'M':
		p_size = (double)pp->p_size / ((1024*1024) / lp->d_secsize);
		p_offset = (double)pp->p_offset / ((1024*1024) / lp->d_secsize);
		break;

	case 'G':
		p_size = (double)pp->p_size / ((1024*1024*1024) / lp->d_secsize);
		p_offset = (double)pp->p_offset / ((1024*1024*1024) / lp->d_secsize);
		break;
	}

	if (pp->p_size) {
		if (p_size < 0)
			fprintf(f, "  %c: %13u %13u ", 'a' + i,
			    pp->p_size, pp->p_offset);
		else
			fprintf(f, "  %c: %12.*f%c %12.*f%c ", 'a' + i,
			    unit == 'B' ? 0 : 1, p_size, unit,
			    unit == 'B' ? 0 : 1, p_offset, unit);
		if ((unsigned) pp->p_fstype < FSMAXTYPES)
			fprintf(f, "%7.7s", fstypenames[pp->p_fstype]);
		else
			fprintf(f, "%7d", pp->p_fstype);
		switch (pp->p_fstype) {

		case FS_UNUSED:				/* XXX */
			fprintf(f, "  %5u %5u %4.4s ",
			    pp->p_fsize, pp->p_fsize * pp->p_frag, "");
			break;

		case FS_BSDFFS:
			fprintf(f, "  %5u %5u %4hu ",
			    pp->p_fsize, pp->p_fsize * pp->p_frag,
			    pp->p_cpg);
			break;

		default:
			fprintf(f, "%19.19s", "");
			break;
		}
		if (mp != NULL) {
			if (mp[i] != NULL)
				fprintf(f, "# %s", mp[i]);
		} else if (lp->d_secpercyl) {
			fprintf(f, "# Cyl %5u",
			    pp->p_offset / lp->d_secpercyl);
			if (pp->p_offset % lp->d_secpercyl)
				putc('*', f);
			else
				putc(' ', f);
			fprintf(f, "-%6u",
			    (pp->p_offset +
			    pp->p_size + lp->d_secpercyl - 1) /
			    lp->d_secpercyl - 1);
			if ((pp->p_offset + pp->p_size) % lp->d_secpercyl)
				putc('*', f);
			else
				putc(' ', f);
		}
		putc('\n', f);
	}
}

void
display(FILE *f, struct disklabel *lp, char unit)
{
	int i, j;

	fprintf(f, "# %s:\n", specname);
	if ((unsigned) lp->d_type < DKMAXTYPES)
		fprintf(f, "type: %s\n", dktypenames[lp->d_type]);
	else
		fprintf(f, "type: %d\n", lp->d_type);
	fprintf(f, "disk: %.*s\n", (int)sizeof(lp->d_typename), lp->d_typename);
	fprintf(f, "label: %.*s\n", (int)sizeof(lp->d_packname), lp->d_packname);
	fprintf(f, "flags:");
	if (lp->d_flags & D_REMOVABLE)
		fprintf(f, " removable");
	if (lp->d_flags & D_ECC)
		fprintf(f, " ecc");
	if (lp->d_flags & D_BADSECT)
		fprintf(f, " badsect");
	putc('\n', f);
	fprintf(f, "bytes/sector: %u\n", lp->d_secsize);
	fprintf(f, "sectors/track: %u\n", lp->d_nsectors);
	fprintf(f, "tracks/cylinder: %u\n", lp->d_ntracks);
	fprintf(f, "sectors/cylinder: %u\n", lp->d_secpercyl);
	fprintf(f, "cylinders: %u\n", lp->d_ncylinders);
	fprintf(f, "total sectors: %u\n", lp->d_secperunit);
	fprintf(f, "rpm: %hu\n", lp->d_rpm);
	fprintf(f, "interleave: %hu\n", lp->d_interleave);
	fprintf(f, "trackskew: %hu\n", lp->d_trackskew);
	fprintf(f, "cylinderskew: %hu\n", lp->d_cylskew);
	fprintf(f, "headswitch: %u\t\t# microseconds\n", lp->d_headswitch);
	fprintf(f, "track-to-track seek: %u\t# microseconds\n",
	    lp->d_trkseek);
	fprintf(f, "drivedata: ");
	for (i = NDDATA - 1; i >= 0; i--)
		if (lp->d_drivedata[i])
			break;
	if (i < 0)
		i = 0;
	for (j = 0; j <= i; j++)
		fprintf(f, "%d ", lp->d_drivedata[j]);
	fprintf(f, "\n\n%hu partitions:\n", lp->d_npartitions);
	fprintf(f, "#    %13.13s %13.13s  fstype [fsize bsize  cpg]\n",
	    "size", "offset");
	for (i = 0; i < lp->d_npartitions; i++)
		display_partition(f, lp, NULL, i, unit);
	fflush(f);
}

int
edit(struct disklabel *lp, int f)
{
	int first, ch, fd;
	struct disklabel label;
	FILE *fp;

	if ((fd = mkstemp(tmpfil)) == -1 || (fp = fdopen(fd, "w")) == NULL) {
		if (fd != -1)
			close(fd);
		warn("%s", tmpfil);
		return (1);
	}
	display(fp, lp, 0);
	fprintf(fp, "\n# Notes:\n");
	fprintf(fp,
"# Up to 16 partitions are valid, named from 'a' to 'p'.  Partition 'a' is\n"
"# your root filesystem, 'b' is your swap, and 'c' should cover your whole\n"
"# disk. Any other partition is free for any use.  'size' and 'offset' are\n"
"# in 512-byte blocks. fstype should be '4.2BSD', 'swap', or 'none' or some\n"
"# other values.  fsize/bsize/cpg should typically be '2048 16384 16' for a\n"
"# 4.2BSD filesystem (or '512 4096 16' except on alpha, sun4, ...)\n");
	fclose(fp);
	for (;;) {
		if (!editit())
			break;
		fp = fopen(tmpfil, "r");
		if (fp == NULL) {
			warn("%s", tmpfil);
			break;
		}
		memset(&label, 0, sizeof(label));
		if (getasciilabel(fp, &label)) {
			if (cmplabel(lp, &label) == 0) {
				puts("No changes.");
				fclose(fp);
				(void) unlink(tmpfil);
				return (0);
			}
			*lp = label;
			if (writelabel(f, bootarea, lp) == 0) {
				fclose(fp);
				(void) unlink(tmpfil);
				return (0);
			}
		}
		fclose(fp);
		printf("re-edit the label? [y]: ");
		fflush(stdout);
		first = ch = getchar();
		while (ch != '\n' && ch != EOF)
			ch = getchar();
		if (first == 'n' || first == 'N')
			break;
	}
	(void)unlink(tmpfil);
	return (1);
}

int
editit(void)
{
	pid_t pid;
	int stat = 0, len;
	char *argp[] = {"sh", "-c", NULL, NULL};
	char *ed, *p;

	if ((ed = getenv("EDITOR")) == NULL)
		ed = _PATH_VI;
	len = strlen(ed) + 1 + strlen(tmpfil) + 1;
	p = (char *)malloc(len);
	if (!p) {
		warn("failed to start editor");
		return (0);
	}
	snprintf(p, len, "%s %s", ed, tmpfil);
	argp[2] = p;

	/* Turn off signals. */
	(void)signal(SIGHUP, SIG_IGN);
	(void)signal(SIGINT, SIG_IGN);
	(void)signal(SIGQUIT, SIG_IGN);
	while ((pid = fork()) < 0) {
		if (errno != EAGAIN) {
			warn("fork");
			free(p);
			stat = 1;
			goto bail;
		}
		sleep(1);
	}
	if (pid == 0) {
		execv(_PATH_BSHELL, argp);
		_exit(127);
	}
	free(p);
	for (;;) {
		if (waitpid(pid, (int *)&stat, WUNTRACED) == -1) {
			if (errno == EINTR)
				continue;
			if (errno == ECHILD)
				stat = 1;
			break;
		}
		if (WIFSTOPPED(stat))
			raise(WSTOPSIG(stat));
		else if (WIFEXITED(stat))
			break;
	}
bail:
	(void)signal(SIGHUP, SIG_DFL);
	(void)signal(SIGINT, SIG_DFL);
	(void)signal(SIGQUIT, SIG_DFL);
	return (!stat);
}

char *
skip(char *cp)
{

	cp += strspn(cp, " \t");
	if (*cp == '\0')
		return (NULL);
	return (cp);
}

char *
word(char *cp)
{

	cp += strcspn(cp, " \t");
	if (*cp == '\0')
		return (NULL);
	*cp++ = '\0';
	cp += strspn(cp, " \t");
	if (*cp == '\0')
		return (NULL);
	return (cp);
}

/* Base the max value on the sizeof of the value we are reading */
#define GETNUM(field, nptr, min, errstr) 				\
	    getnum((nptr), (min),					\
		sizeof(field) == 4 ? UINT_MAX : 			\
		(sizeof(field) == 2 ? USHRT_MAX : UCHAR_MAX),  (errstr))

u_int32_t
getnum(char *nptr, u_int32_t min, u_int32_t max, const char **errstr)
{
	char *p, c;
	u_int32_t ret;

	for (p = nptr; *p != '\0' && !isspace(*p); p++)
		;
	c = *p;
	*p = '\0';
	ret = strtonum(nptr, min, max, errstr);
	*p = c;
	return (ret);
}

/*
 * Read an ascii label in from fd f,
 * in the same format as that put out by display(),
 * and fill in lp.
 */
int
getasciilabel(FILE *f, struct disklabel *lp)
{
	char **cpp, *cp;
	const char *errstr;
	struct partition *pp;
	char *tp, *s, line[BUFSIZ];
	int lineno = 0, errors = 0;
	u_int32_t v;

	lp->d_bbsize = BBSIZE;				/* XXX */
	lp->d_sbsize = SBSIZE;				/* XXX */
	while (fgets(line, sizeof(line) - 1, f)) {
		lineno++;
		if ((cp = strpbrk(line, "#\r\n")))
			*cp = '\0';
		cp = skip(line);
		if (cp == NULL)
			continue;
		tp = strchr(cp, ':');
		if (tp == NULL) {
			warnx("line %d: syntax error", lineno);
			errors++;
			continue;
		}
		*tp++ = '\0', tp = skip(tp);
		if (!strcmp(cp, "type")) {
			if (tp == NULL)
				tp = "unknown";
			else if (strcasecmp(tp, "IDE") == 0)
				tp = "ESDI";
			cpp = dktypenames;
			for (; cpp < &dktypenames[DKMAXTYPES]; cpp++)
				if ((s = *cpp) && !strcasecmp(s, tp)) {
					lp->d_type = cpp - dktypenames;
					goto next;
				}
			v = GETNUM(lp->d_type, tp, 0, &errstr);
			if (errstr || v >= DKMAXTYPES)
				warnx("line %d: warning, unknown disk type: %s",
				    lineno, tp);
			lp->d_type = v;
			continue;
		}
		if (!strcmp(cp, "flags")) {
			for (v = 0; (cp = tp) && *cp != '\0';) {
				tp = word(cp);
				if (!strcmp(cp, "removable"))
					v |= D_REMOVABLE;
				else if (!strcmp(cp, "ecc"))
					v |= D_ECC;
				else if (!strcmp(cp, "badsect"))
					v |= D_BADSECT;
				else {
					warnx("line %d: bad flag: %s",
					    lineno, cp);
					errors++;
				}
			}
			lp->d_flags = v;
			continue;
		}
		if (!strcmp(cp, "drivedata")) {
			int i;

			for (i = 0; (cp = tp) && *cp != '\0' && i < NDDATA;) {
				v = GETNUM(lp->d_drivedata[i], cp, 0, &errstr);
				if (errstr)
					warnx("line %d: bad drivedata %s",
					   lineno, cp);
				lp->d_drivedata[i++] = v;
				tp = word(cp);
			}
			continue;
		}
		if (sscanf(cp, "%d partitions", &v) == 1) {
			if (v == 0 || v > MAXPARTITIONS) {
				warnx("line %d: bad # of partitions", lineno);
				lp->d_npartitions = MAXPARTITIONS;
				errors++;
			} else
				lp->d_npartitions = v;
			continue;
		}
		if (tp == NULL)
			tp = "";
		if (!strcmp(cp, "disk")) {
			strncpy(lp->d_typename, tp, sizeof (lp->d_typename));
			continue;
		}
		if (!strcmp(cp, "label")) {
			strncpy(lp->d_packname, tp, sizeof (lp->d_packname));
			continue;
		}
		if (!strcmp(cp, "bytes/sector")) {
			v = GETNUM(lp->d_secsize, tp, 1, &errstr);
			if (errstr || (v % 512) != 0) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_secsize = v;
			continue;
		}
		if (!strcmp(cp, "sectors/track")) {
			v = GETNUM(lp->d_nsectors, tp, 1, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_nsectors = v;
			continue;
		}
		if (!strcmp(cp, "sectors/cylinder")) {
			v = GETNUM(lp->d_secpercyl, tp, 1, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_secpercyl = v;
			continue;
		}
		if (!strcmp(cp, "tracks/cylinder")) {
			v = GETNUM(lp->d_ntracks, tp, 1, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_ntracks = v;
			continue;
		}
		if (!strcmp(cp, "cylinders")) {
			v = GETNUM(lp->d_ncylinders, tp, 1, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_ncylinders = v;
			continue;
		}
		if (!strcmp(cp, "total sectors")) {
			v = GETNUM(lp->d_secperunit, tp, 1, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_secperunit = v;
			continue;
		}
		if (!strcmp(cp, "rpm")) {
			v = GETNUM(lp->d_rpm, tp, 1, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_rpm = v;
			continue;
		}
		if (!strcmp(cp, "interleave")) {
			v = GETNUM(lp->d_interleave, tp, 1, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_interleave = v;
			continue;
		}
		if (!strcmp(cp, "trackskew")) {
			v = GETNUM(lp->d_trackskew, tp, 0, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_trackskew = v;
			continue;
		}
		if (!strcmp(cp, "cylinderskew")) {
			v = GETNUM(lp->d_cylskew, tp, 0, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_cylskew = v;
			continue;
		}
		if (!strcmp(cp, "headswitch")) {
			v = GETNUM(lp->d_headswitch, tp, 0, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_headswitch = v;
			continue;
		}
		if (!strcmp(cp, "track-to-track seek")) {
			v = GETNUM(lp->d_trkseek, tp, 0, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_trkseek = v;
			continue;
		}
		if ('a' <= *cp && *cp <= 'z' && cp[1] == '\0') {
			unsigned part = *cp - 'a';

			if (part >= lp->d_npartitions) {
				if (part >= MAXPARTITIONS) {
					warnx("line %d: bad partition name: %s",
					    lineno, cp);
					errors++;
					continue;
				} else {
					lp->d_npartitions = part + 1;
				}
			}
			pp = &lp->d_partitions[part];
#define NXTNUM(n, field, errstr) { \
	if (tp == NULL) {					\
		warnx("line %d: too few fields", lineno);	\
		errors++;					\
		break;						\
	} else							\
		cp = tp, tp = word(cp), (n) = GETNUM(field, cp, 0, errstr); \
}
			NXTNUM(v, pp->p_size, &errstr);
			if (errstr) {
				warnx("line %d: bad partition size: %s",
				    lineno, cp);
				errors++;
			} else
				pp->p_size = v;
			NXTNUM(v, pp->p_offset, &errstr);
			if (errstr) {
				warnx("line %d: bad partition offset: %s",
				    lineno, cp);
				errors++;
			} else
				pp->p_offset = v;
			if (tp == NULL) {
				pp->p_fstype = FS_UNUSED;
				goto gottype;
			}
			cp = tp, tp = word(cp);
			cpp = fstypenames;
			for (; cpp < &fstypenames[FSMAXTYPES]; cpp++)
				if ((s = *cpp) && !strcasecmp(s, cp)) {
					pp->p_fstype = cpp - fstypenames;
					goto gottype;
				}
			if (isdigit(*cp))
				v = GETNUM(pp->p_fstype, cp, 0, &errstr);
			else
				v = FSMAXTYPES;
			if (errstr || v >= FSMAXTYPES) {
				warnx("line %d: warning, unknown filesystem type: %s",
				    lineno, cp);
				v = FS_UNUSED;
			}
			pp->p_fstype = v;
	gottype:
			switch (pp->p_fstype) {

			case FS_UNUSED:				/* XXX */
				if (tp == NULL)	/* ok to skip fsize/bsize */
					break;
				NXTNUM(pp->p_fsize, pp->p_fsize, &errstr);
				if (pp->p_fsize == 0)
					break;
				NXTNUM(v, v, &errstr);
				pp->p_frag = v / pp->p_fsize;
				break;

			case FS_BSDFFS:
				NXTNUM(pp->p_fsize, pp->p_fsize, &errstr);
				if (pp->p_fsize == 0)
					break;
				NXTNUM(v, v, &errstr);
				pp->p_frag = v / pp->p_fsize;
				NXTNUM(pp->p_cpg, pp->p_cpg, &errstr);
				break;

			default:
				break;
			}
			continue;
		}
		warnx("line %d: unknown field: %s", lineno, cp);
		errors++;
	next:
		;
	}
	errors += checklabel(lp);
	return (errors == 0);
}

/*
 * Check disklabel for errors and fill in
 * derived fields according to supplied values.
 */
int
checklabel(struct disklabel *lp)
{
	struct partition *pp;
	int i, errors = 0;
	char part;

	if (lp->d_secsize == 0) {
		warnx("sector size %d", lp->d_secsize);
		return (1);
	}
	if (lp->d_nsectors == 0) {
		warnx("sectors/track %d", lp->d_nsectors);
		return (1);
	}
	if (lp->d_ntracks == 0) {
		warnx("tracks/cylinder %d", lp->d_ntracks);
		return (1);
	}
	if  (lp->d_ncylinders == 0) {
		warnx("cylinders/unit %d", lp->d_ncylinders);
		errors++;
	}
	if (lp->d_rpm == 0)
		warnx("warning, revolutions/minute %d", lp->d_rpm);
	if (lp->d_secpercyl == 0)
		lp->d_secpercyl = lp->d_nsectors * lp->d_ntracks;
	if (lp->d_secperunit == 0)
		lp->d_secperunit = lp->d_secpercyl * lp->d_ncylinders;
	if (lp->d_bbsize == 0) {
		warnx("boot block size %d", lp->d_bbsize);
		errors++;
	} else if (lp->d_bbsize % lp->d_secsize)
		warnx("warning, boot block size %% sector-size != 0");
	if (lp->d_sbsize == 0) {
		warnx("super block size %d", lp->d_sbsize);
		errors++;
	} else if (lp->d_sbsize % lp->d_secsize)
		warnx("warning, super block size %% sector-size != 0");
	if (lp->d_npartitions > MAXPARTITIONS)
		warnx("warning, number of partitions (%d) > MAXPARTITIONS (%d)",
		    lp->d_npartitions, MAXPARTITIONS);
	for (i = 0; i < lp->d_npartitions; i++) {
		part = 'a' + i;
		pp = &lp->d_partitions[i];
		if (pp->p_size == 0 && pp->p_offset != 0)
			warnx("warning, partition %c: size 0, but offset %d",
			    part, pp->p_offset);
#ifdef CYLCHECK
		if (pp->p_size % lp->d_secpercyl)
			warnx("warning, partition %c: size %% cylinder-size != 0",
			    part);
		if (pp->p_offset % lp->d_secpercyl)
			warnx("warning, partition %c: offset %% cylinder-size != 0",
			    part);
#endif
#ifdef AAT0
		if (i == 0 && pp->p_size != 0 && pp->p_offset != 0) {
			warnx("this architecture requires partition 'a' to "
			    "start at sector 0");
			errors++;
		}
#endif
		if (pp->p_offset > lp->d_secperunit) {
			warnx("partition %c: offset past end of unit", part);
			errors++;
		}
		if (pp->p_offset + pp->p_size > lp->d_secperunit) {
			warnx("partition %c: partition extends past end of unit",
			    part);
			errors++;
		}
		if (pp->p_frag == 0 && pp->p_fsize != 0) {
			warnx("partition %c: block size < fragment size", part);
			errors++;
		}
	}
	for (; i < MAXPARTITIONS; i++) {
		part = 'a' + i;
		pp = &lp->d_partitions[i];
		if (pp->p_size || pp->p_offset)
			warnx("warning, unused partition %c: size %d offset %d",
			    'a' + i, pp->p_size, pp->p_offset);
	}
	return (errors);
}

#if NUMBOOT > 0
/*
 * If we are installing a boot program that doesn't fit in d_bbsize
 * we need to mark those partitions that the boot overflows into.
 * This allows newfs to prevent creation of a filesystem where it might
 * clobber bootstrap code.
 */
void
setbootflag(struct disklabel *lp)
{
	struct partition *pp;
	int i, errors = 0;
	u_long boffset;
	char part;

	if (bootbuf == 0)
		return;
	boffset = bootsize / lp->d_secsize;
	for (i = 0; i < lp->d_npartitions; i++) {
		part = 'a' + i;
		pp = &lp->d_partitions[i];
		if (pp->p_size == 0)
			continue;
		if (boffset <= pp->p_offset) {
			if (pp->p_fstype == FS_BOOT)
				pp->p_fstype = FS_UNUSED;
		} else if (pp->p_fstype != FS_BOOT) {
			if (pp->p_fstype != FS_UNUSED) {
				warnx("boot overlaps used partition %c", part);
				errors++;
			} else {
				pp->p_fstype = FS_BOOT;
				warnx("warning, boot overlaps partition %c, %s",
				    part, "marked as FS_BOOT");
			}
		}
	}
	if (errors)
		errx(4, "cannot install boot program");
}
#endif

int
cmplabel(struct disklabel *lp1, struct disklabel *lp2)
{
	struct disklabel lab1 = *lp1;
	struct disklabel lab2 = *lp2;

	/* We don't compare these fields */
	lab1.d_magic = lab2.d_magic;
	lab1.d_magic2 = lab2.d_magic2;
	lab1.d_checksum = lab2.d_checksum;
	lab1.d_bbsize = lab2.d_bbsize;
	lab1.d_sbsize = lab2.d_sbsize;

	return (memcmp(&lab1, &lab2, sizeof(struct disklabel)));
}

void
usage(void)
{
	char *boot = "";
	char blank[] = "                             ";

#if NUMBOOT == 1
	boot = " [-b boot1]";
#elif NUMBOOT == 2
	boot = " [-b boot1] [-s boot2]";
#endif
	blank[strlen(boot)] = '\0';

	fprintf(stderr, "usage:\n");
	fprintf(stderr,
	    "  disklabel [-c | -d | -r | -t] [-v] [-p unit] disk\t\t(read)\n");
	fprintf(stderr,
	    "  disklabel -w [-c | -d | -r] [-nv] disk disktype [packid]\t(write)\n");
	fprintf(stderr,
	    "  disklabel -e [-c | -d | -r] [-nv] disk\t\t\t(edit)\n");
	fprintf(stderr,
	    "  disklabel -E [-c | -d | -r] [-nv] [-f tempfile] disk\t\t(simple editor)\n");
	fprintf(stderr,
	    "  disklabel -R [-nrv] disk protofile\t\t\t\t(restore)\n");
	fprintf(stderr,
	    "  disklabel -N | -W [-nv] disk\t\t\t\t\t(protect)\n\n");
	fprintf(stderr,
	    "  disklabel -B  [-nv]%s disk [disktype]\t       (boot)\n",
	    boot);
	fprintf(stderr,
	    "  disklabel -Bw [-nv]%s disk disktype [packid]     (write)\n",
	    boot);
	fprintf(stderr,
	    "  disklabel -BR [-nv]%s disk protofile [disktype]  (restore)\n\n",
	    boot);
	fprintf(stderr,
	    "'disk' may be of the form: sd0 or /dev/rsd0%c.\n", 'a'+RAW_PART);
	fprintf(stderr,
	    "'disktype' is an entry from %s, see disktab(5) for more info.\n",
	    DISKTAB);
	fprintf(stderr,
	    "'packid' is an identification string for the device.\n");
	fprintf(stderr,
	    "'protofile' is the output from the read cmd form; -R is powerful.\n");
#ifdef SEEALSO
	fprintf(stderr,
	    "For procedures specific to this architecture see: %s\n", SEEALSO);
#endif
	exit(1);
}
@


1.17
log
@merge openbsd; fix; enhance
@
text
@d1 1
a1 1
/**	$MirBSD$ */
d8 1
a8 1
 *	Thorsten Glaser <x86@@ePost.de> for the MirOS Project
d67 1
a67 1
__RCSID("$MirBSD: src/sbin/disklabel/disklabel.c,v 1.16 2004/05/27 16:43:11 tg Stab $");
@


1.16
log
@Last piece of OpenBSD 3.5-current merge part I.

Things left:
* merge import in src/gnu/
* fix kernel build (it _is_ broken)

TOP 1 will be done with a _second_ import (easier).
TOP 2 will be done RSN.

----

Also, move RCS IDs to new-style MirOS ones, and fix the
SMM doc, and add output to newfs(8) saying if (!) or if
not (?) it read the random value out of the previous
superblock before making the fs.
@
text
@d1 2
a2 2
/*	$MirBSD: src/sbin/disklabel/disklabel.c,v 1.15 2004/01/03 18:29:45 tg Exp $	*/
/*	$OpenBSD: disklabel.c,v 1.87 2004/04/07 14:09:35 aaron Exp $	*/
d57 1
d67 1
a67 1
__RCSID("$MirBSD$");
a124 6
struct disklabel *readlabel(int);
struct disklabel *makebootarea(char *, struct disklabel *, int);
void	display(FILE *, struct disklabel *, char);
void	display_partition(FILE *, struct disklabel *, char **, int, char, int);
int	width_partition(struct disklabel *, int);
int	editor(struct disklabel *, int, char *, char *);
a129 1
int	checklabel(struct disklabel *);
d133 1
a133 1
u_short	dkcksum(struct disklabel *);
d299 2
d930 1
a930 1
		(void)fprintf(f, "%srm#%d:", did, lp->d_rpm);
d934 1
a934 1
		(void)fprintf(f, "%sil#%d:", did, lp->d_interleave);
d938 1
a938 1
		(void)fprintf(f, "%ssk#%d:", did, lp->d_trackskew);
d942 1
a942 1
		(void)fprintf(f, "%scs#%d:", did, lp->d_cylskew);
a991 11
int
width_partition(struct disklabel *lp, int unit)
{
	unit = toupper(unit);
	switch (unit) {
	case 'K':
		return 10;
	}
	return 8;
}

d993 1
a993 1
 * Display a particular partion.
d997 1
a997 1
    char unit, int width)
a1001 2
	if (width == 0)
		width = 8;
d1034 2
a1035 2
			fprintf(f, "  %c: %*u %*u  ", 'a' + i,
			    width, pp->p_size, width, pp->p_offset);
d1037 3
a1039 2
			fprintf(f, "  %c: %*.1f%c %*.1f%c  ", 'a' + i,
			    width-1, p_size, unit, width-1, p_offset, unit);
d1041 1
a1041 1
			fprintf(f, "%8.8s", fstypenames[pp->p_fstype]);
d1043 1
a1043 1
			fprintf(f, "%8d", pp->p_fstype);
d1047 1
a1047 1
			fprintf(f, "    %5d %5d %5.5s ",
d1052 1
a1052 1
			fprintf(f, "    %5d %5d %5d ",
d1058 1
a1058 1
			fprintf(f, "%22.22s", "");
d1063 1
a1063 1
				fprintf(f, " # %s", mp[i]);
d1065 1
a1065 1
			fprintf(f, "\t# (Cyl. %4d",
d1071 1
a1071 1
			fprintf(f, "- %u",
d1077 2
a1078 1
			putc(')', f);
a1087 1
	int width;
d1104 13
a1116 14
	fprintf(f, "bytes/sector: %ld\n", (long)lp->d_secsize);
	fprintf(f, "sectors/track: %ld\n", (long)lp->d_nsectors);
	fprintf(f, "tracks/cylinder: %ld\n", (long)lp->d_ntracks);
	fprintf(f, "sectors/cylinder: %ld\n", (long)lp->d_secpercyl);
	fprintf(f, "cylinders: %ld\n", (long)lp->d_ncylinders);
	fprintf(f, "total sectors: %ld\n", (long)lp->d_secperunit);
	fprintf(f, "rpm: %ld\n", (long)lp->d_rpm);
	fprintf(f, "interleave: %ld\n", (long)lp->d_interleave);
	fprintf(f, "trackskew: %ld\n", (long)lp->d_trackskew);
	fprintf(f, "cylinderskew: %ld\n", (long)lp->d_cylskew);
	fprintf(f, "headswitch: %ld\t\t# microseconds\n",
	    (long)lp->d_headswitch);
	fprintf(f, "track-to-track seek: %ld\t# microseconds\n",
	    (long)lp->d_trkseek);
d1125 3
a1127 5
	fprintf(f, "\n\n%d partitions:\n", lp->d_npartitions);
	width = width_partition(lp, 0);
	fprintf(f,
	    "#    %*.*s %*.*s    fstype   [fsize bsize   cpg]\n",
	    width, width, "size", width, width, "offset");
d1129 1
a1129 1
		display_partition(f, lp, NULL, i, unit, width);
d1195 2
a1196 2
	pid_t pid, xpid;
	int stat, len;
d1230 7
a1236 1
		xpid = waitpid(pid, (int *)&stat, WUNTRACED);
d1273 21
d1303 1
d1306 2
a1307 1
	int v, lineno = 0, errors = 0;
d1336 2
a1337 2
			v = atoi(tp);
			if ((unsigned)v >= DKMAXTYPES)
d1365 5
a1369 1
				lp->d_drivedata[i++] = atoi(cp);
d1375 1
a1375 1
			if (v == 0 || (unsigned)v > MAXPARTITIONS) {
d1394 2
a1395 2
			v = atoi(tp);
			if (v <= 0 || (v % 512) != 0) {
d1403 2
a1404 2
			v = atoi(tp);
			if (v <= 0) {
d1412 2
a1413 2
			v = atoi(tp);
			if (v <= 0) {
d1421 2
a1422 2
			v = atoi(tp);
			if (v <= 0) {
d1430 2
a1431 2
			v = atoi(tp);
			if (v <= 0) {
d1439 2
a1440 2
			v = atoi(tp);
			if (v <= 0) {
d1448 2
a1449 2
			v = atoi(tp);
			if (v <= 0) {
d1457 2
a1458 2
			v = atoi(tp);
			if (v <= 0) {
d1466 2
a1467 2
			v = atoi(tp);
			if (v < 0) {
d1475 2
a1476 2
			v = atoi(tp);
			if (v < 0) {
d1484 2
a1485 2
			v = atoi(tp);
			if (v < 0) {
d1493 2
a1494 2
			v = atoi(tp);
			if (v < 0) {
d1515 1
a1515 1
#define NXTNUM(n) { \
d1521 1
a1521 1
		cp = tp, tp = word(cp), (n) = atoi(cp);		\
d1523 2
a1524 2
			NXTNUM(v);
			if (v < 0) {
d1530 2
a1531 2
			NXTNUM(v);
			if (v < 0) {
d1549 1
a1549 1
				v = atoi(cp);
d1552 1
a1552 1
			if ((unsigned)v >= FSMAXTYPES) {
d1564 1
a1564 1
				NXTNUM(pp->p_fsize);
d1567 1
a1567 1
				NXTNUM(v);
d1572 1
a1572 1
				NXTNUM(pp->p_fsize);
d1575 1
a1575 1
				NXTNUM(v);
d1577 1
a1577 1
				NXTNUM(pp->p_cpg);
@


1.15
log
@it appears to work, moving out the partition with the disklabel
into an extended partition.

snippets from dmesg, fdisk and disklabel:

MirBSD#7u96 3.4-20040103 (GENERIC) #330: Sat Jan  3 18:04:27 UTC 2004
	tg@@odem.66h.42h.de:/usr/src/sys/arch/i386/compile/GENERIC
[...]
Searching for raid components...
debug: found partition 0: type 0F ofs 1 (0x1h) size 1 (0x1), chaining...
debug: found partition 3: type 27 ofs 15200640 (0xE7F180h) size 23869440 (0x16C3800).
warning: broken MBR signature
warning: broken MBR signature
dkcsum: wd0 matched BIOS disk 80



Disk: wd0	geometry: 38760/16/63 [39070080 Sectors]
Offset: 0	Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 0F    0   0  2 -    0   0  2 [           1:           1 ] Extended LBA
 1: DB  510   0  1 - 15079  15 63 [      514080:    14686560 ] CPM/C.DOS/C*
 2: 06    0   0  3 -  509  15 63 [           2:      514078 ] DOS > 32MB
*3: DB 15080   0  1 - 38759  15 63 [    15200640:    23869440 ] CPM/C.DOS/C*
Offset: 1	Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 1: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
*3: 27 15080   0  1 - 38759  15 63 [    15200640:    23869440 ] MirBSD



# found partition 0: type 0F ofs 1 (0x1h) size 1 (0x1), chaining...
# found partition 3: type 27 ofs 15200640 (0xE7F180h) size 23869440 (0x16C3800).
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: IC25N020ATCS04-0
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 39070080
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0		# microseconds
track-to-track seek: 0	# microseconds
drivedata: 0

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a: 17053344 22016736    4.2BSD     2048 16384   328 	# (Cyl. 21842 - 38759)
  b:   524160 15200640      swap                      	# (Cyl. 15080 - 15599)
  c: 39070080        0    unused        0     0       	# (Cyl.    0 - 38759)
  d:  6291936 15724800    4.2BSD     2048 16384   328 	# (Cyl. 15600 - 21841)
  e: 14686560   514080    4.2BSD     2048 16384   328 	# (Cyl.  510 - 15079)
  m:   514078        2     MSDOS                      	# (Cyl.    0*- 509)
  p:        2        0   unknown                      	# (Cyl.    0 - 0*)
@
text
@d1 2
a2 2
/*	$MirBSD: disklabel.c,v 1.14 2004/01/03 00:46:56 tg Exp $	*/
/*	$OpenBSD: disklabel.c,v 1.86 2003/12/20 09:29:27 jmc Exp $	*/
a43 4
#ifndef lint
static const char rcsid[] = "$MirBSD: disklabel.c,v 1.14 2004/01/03 00:46:56 tg Exp $";
#endif /* not lint */

d66 2
d150 1
a150 1
	while ((ch = getopt(argc, argv, "BEFf:NRWb:cdenp:rs:tvw")) != -1)
@


1.14
log
@adjust the start offset of every partition by the start offset
of the partition table it's described in (this is a specificum
of the PC architecture I never really grokked)
@
text
@d1 1
a1 1
/*	$MirBSD: disklabel.c,v 1.13 2004/01/02 23:44:11 tg Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$MirBSD: disklabel.c,v 1.13 2004/01/02 23:44:11 tg Exp $";
d420 1
a420 1
		 * If MirBSD DOS partition is missing, or if
a545 15
#ifdef __vax__
	if (lp->d_type == DTYPE_SMD && lp->d_flags & D_BADSECT) {
		daddr_t alt;
		int i;

		alt = lp->d_ncylinders * lp->d_secpercyl - lp->d_nsectors;
		for (i = 1; i < 11 && i < lp->d_nsectors; i += 2) {
			(void)lseek(f, (off_t)((alt + i) * lp->d_secsize),
			    SEEK_SET);
			if (!donothing)
				if (write(f, boot, lp->d_secsize) < lp->d_secsize)
					warn("alternate label %d write", i/2);
		}
	}
#endif
d576 1
d587 1
d657 1
a657 1
	 * If there is no signature and no MirBSD partition this is probably
@


1.13
log
@prefer NetBSD over FreeBSD one, mirrors libsa and fbsd has only 8 entries
@
text
@d1 1
a1 1
/*	$MirBSD: disklabel.c,v 1.12 2004/01/02 23:40:16 tg Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$MirBSD: disklabel.c,v 1.12 2004/01/02 23:40:16 tg Exp $";
d651 1
a651 1
	/* Check if table is valid. */
d653 2
@


1.12
log
@fix errors, make it compile and fix warnung about obsolete use of bcopy()
@
text
@d1 1
a1 1
/*	$MirBSD: disklabel.c,v 1.11 2004/01/02 23:25:06 tg Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$MirBSD: disklabel.c,v 1.11 2004/01/02 23:25:06 tg Exp $";
d662 2
a664 2
		return (&dp[part]);
	if ((part = scan_pt(dp, DOSPTYP_NETBSD)) < NDOSPART)
@


1.11
log
@* enable having the disklabel partition as an entry
  in an extended partition table instead of in the MBR
  (kernel etc. diffs to follow)
* partition -> slice where applicable
  MirOS standard:
	partition = MBR entry or chained (extended partition)
	slice = disklabel entry
	volume = Windows 2000 dynamic disc entry
* whitespace, 0x60 etc. cleanup; add my (c)
@
text
@d1 1
a1 1
/*	$MirBSD: disklabel.c,v 1.10 2003/12/27 00:30:37 tg Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$MirBSD: disklabel.c,v 1.10 2003/12/27 00:30:37 tg Exp $";
d607 1
a607 1
		if ((!get_le(&dp[part].dp_size) || (dp[part].dp_typ != what))
d644 1
a644 1
	bcopy((char *)mbr+DOSPARTOFF, (char *)mbr, sizeof(*dp) * NDOSPART);
d687 1
a687 1
		bcopy((char *)mbr + DOSPARTOFF, (char *)mbr,
d701 1
a701 1
	mbrofs = get_le(dp[part].dp_start);
@


1.10
log
@finish merging and sync a bit; bump version etc.
@
text
@d1 1
a1 1
/*	$MirBSD: disklabel.c,v 1.9 2003/08/16 15:25:20 tg Exp $	*/
d7 2
d25 1
a25 1
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
d45 1
a45 1
static const char rcsid[] = "$MirBSD: disklabel.c,v 1.9 2003/08/16 15:25:20 tg Exp $";
d401 1
a401 1
		warnx("To repair this situation, use `disklabel %s > file' to",
d403 1
a403 1
		warnx("save it, then use `disklabel -R %s file' to replace it.",
d591 30
d628 1
d633 4
a641 3
	if (lseek(f, (off_t)DOSBBSECTOR * DEV_BSIZE, SEEK_SET) < 0 ||
	    read(f, mbr, sizeof(mbr)) < sizeof(mbr))
		err(4, "can't read master boot record");
d656 10
a665 41
	/* Find MirBSD partition. */
	for (part = 0; part < NDOSPART; part++) {
		if (get_le(&dp[part].dp_size) && dp[part].dp_typ == DOSPTYP_MIRBSD) {
			fprintf(stderr, "# using MBR partition %d: "
			    "type %02X off %d (0x%x) size %d (0x%x)\n", part,
			    dp[part].dp_typ,
			    get_le(&dp[part].dp_start), get_le(&dp[part].dp_start),
			    get_le(&dp[part].dp_size), get_le(&dp[part].dp_size));
			return (&dp[part]);
		}
	}
	for (part = 0; part < NDOSPART; part++) {
		if (get_le(&dp[part].dp_size) && dp[part].dp_typ == DOSPTYP_OPENBSD) {
			fprintf(stderr, "# using MBR partition %d: "
			    "type %02X off %d (0x%x) size %d (0x%x)\n", part,
			    dp[part].dp_typ,
			    get_le(&dp[part].dp_start), get_le(&dp[part].dp_start),
			    get_le(&dp[part].dp_size), get_le(&dp[part].dp_size));
			return (&dp[part]);
		}
	}
	for (part = 0; part < NDOSPART; part++) {
		if (get_le(&dp[part].dp_size) && dp[part].dp_typ == DOSPTYP_FREEBSD) {
			fprintf(stderr, "# using MBR partition %d: "
			    "type %02X off %d (0x%x) size %d (0x%x)\n", part,
			    dp[part].dp_typ,
			    get_le(&dp[part].dp_start), get_le(&dp[part].dp_start),
			    get_le(&dp[part].dp_size), get_le(&dp[part].dp_size));
			return (&dp[part]);
		}
	}
	for (part = 0; part < NDOSPART; part++) {
		if (get_le(&dp[part].dp_size) && dp[part].dp_typ == DOSPTYP_NETBSD) {
			fprintf(stderr, "# using MBR partition %d: "
			    "type %02X off %d (0x%x) size %d (0x%x)\n", part,
			    dp[part].dp_typ,
			    get_le(&dp[part].dp_start), get_le(&dp[part].dp_start),
			    get_le(&dp[part].dp_size), get_le(&dp[part].dp_size));
			return (&dp[part]);
		}
	}
d674 21
a694 5
	/* If no MirBSD partition, find first used partition. */
	for (part = 0; part < NDOSPART; part++) {
		if (get_le(&dp[part].dp_size)) {
			warnx("warning, DOS partition table with no valid MirBSD partition");
			return (&dp[part]);
d696 2
d699 5
a703 2
	/* Table appears to be empty. */
	return (NULL);
d787 1
a787 1
 * Construct a bootarea (d_bbsize bytes) in the specified buffer ``boot''
d872 1
a872 1
	 *	up to d_bbsize bytes of ``xxboot'' go in bootarea, the rest
d875 1
a875 1
	 *	up to d_secsize bytes of ``xxboot'' go in first d_secsize
d877 1
a877 1
	 *	from ``bootxx''.
a1625 13
#ifdef i386__notyet
	if (dosdp && dosdp->dp_size &&
	    (dosdp->dp_typ == DOSPTYP_MIRBSD ||
	    dosdp->dp_typ == DOSPTYP_OPENBSD ||
	    dosdp->dp_typ == DOSPTYP_FREEBSD ||
	    dosdp->dp_typ == DOSPTYP_NETBSD)) {
		&& lp->d_secperunit > dosdp->dp_start + dosdp->dp_size) {
		warnx("exceeds DOS partition size");
		errors++;
		lp->d_secperunit = dosdp->dp_start + dosdp->dp_size;
	}
	/* XXX should also check geometry against BIOS's idea */
#endif
d1778 1
a1778 1
	    "`disk' may be of the form: sd0 or /dev/rsd0%c.\n", 'a'+RAW_PART);
d1780 1
a1780 1
	    "`disktype' is an entry from %s, see disktab(5) for more info.\n",
d1783 1
a1783 1
	    "`packid' is an identification string for the device.\n");
d1785 1
a1785 1
	    "`protofile' is the output from the read cmd form; -R is powerful.\n");
@


1.9
log
@Merge OpenBSD
@
text
@d1 2
a2 2
/*	$MirBSD: disklabel.c,v 1.8 2003/07/18 15:45:10 tg Exp $	*/
/*	$OpenBSD: disklabel.c,v 1.85 2003/07/29 18:38:35 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$MirBSD: disklabel.c,v 1.8 2003/07/18 15:45:10 tg Exp $";
d1738 1
a1738 1
	boot = " [-B [-b xxboot]]";
d1740 1
a1740 1
	boot = " [-B [-b xxboot [-s bootxx]]]";
d1746 1
a1746 2
	    "  disklabel [-nv] [-r|-cd] [-p unit] [-t] disk%s (read)\n",
	    blank);
d1748 1
a1748 2
	    "  disklabel [-nv] [-r|-cd] -e disk%s       (edit)\n",
	    blank);
d1750 1
a1750 2
	    "  disklabel [-nv] [-r|-cd] [-f temp] -E disk%.*s  (simple editor)\n",
	    (int)strlen(blank) - 5, blank);
d1752 7
a1758 1
	    "  disklabel [-nv] [-r]%s -R disk proto     (restore)\n",
d1761 1
a1761 1
	    "  disklabel [-nv] [-r]%s -w disk dtab [id] (write)\n",
d1764 2
a1765 1
	    "  disklabel [-nv] [-N|-W] disk%s           (protect)\n", blank);
d1767 1
a1767 1
	    "`disk' may be of the forms: sd0 or /dev/rsd0%c.\n", 'a'+RAW_PART);
d1769 1
a1769 1
	    "`dtab' is an entry from %s, see disktab(5) for more info.\n",
d1772 3
a1774 1
	    "`proto' is the output from the read cmd form; -R is powerful.\n");
@


1.8
log
@mop up; yet retain libcom_err
@
text
@d1 2
a2 2
/*	$MirBSD: disklabel.c,v 1.7 2003/07/06 20:22:06 tg Exp $	*/
/*	$OpenBSD: disklabel.c,v 1.84 2003/07/16 18:03:44 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$MirBSD: disklabel.c,v 1.7 2003/07/06 20:22:06 tg Exp $";
d499 1
a499 1
			
d611 1
a611 1
		
@


1.7
log
@mop up
@
text
@d1 2
a2 2
/*	$MirBSD: disklabel.c,v 1.6 2003/06/29 19:48:41 tg Exp $	*/
/*	$OpenBSD: disklabel.c,v 1.83 2003/07/02 21:22:10 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$MirBSD: disklabel.c,v 1.6 2003/06/29 19:48:41 tg Exp $";
d1161 2
a1162 2
"# other values.  fsize/bsize/cpg should typically be '1024 8192 16' for a\n"
"# 4.2BSD filesystem\n");
@


1.6
log
@merge the import
amd (automount dmon) bites the dust
rewrite fake-NLS emulation, copyright to me
foobar! fnord!
@
text
@d1 2
a2 2
/*	$MirBSD: disklabel.c,v 1.5 2003/06/19 16:44:15 tg Exp $	*/
/*	$OpenBSD: disklabel.c,v 1.82 2003/06/25 21:11:48 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$MirBSD: disklabel.c,v 1.5 2003/06/19 16:44:15 tg Exp $";
d66 1
@


1.5
log
@merge cvs import - OpenBSD tree as of Thu Jun 19 16:13:15 UTC 2003
@
text
@d1 2
a2 2
/*	$MirBSD: disklabel.c,v 1.4 2003/06/06 18:28:27 tg Exp $	*/
/*	$OpenBSD: disklabel.c,v 1.81 2003/06/11 06:22:12 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$MirBSD: disklabel.c,v 1.81 2003/06/11 06:22:12 deraadt Exp $";
a1203 1
	extern char *getenv();
@


1.4
log
@Merge OpenBSD-current
@
text
@d1 2
a2 2
/*	$MirBSD: disklabel.c,v 1.3 2003/05/24 19:49:38 tg Exp $	*/
/*	$OpenBSD: disklabel.c,v 1.80 2003/06/02 20:06:14 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$MirBSD: disklabel.c,v 1.3 2003/05/24 19:49:38 tg Exp $";
d141 1
a141 3
main(argc, argv)
	int argc;
	char *argv[];
d349 1
a349 3
makelabel(type, name, lp)
	char *type, *name;
	struct disklabel *lp;
d391 1
a391 4
writelabel(f, boot, lp)
	int f;
	char *boot;
	struct disklabel *lp;
d562 1
a562 2
l_perror(s)
	char *s;
d592 1
a592 2
readmbr(f)
	int f;
d687 1
a687 2
readlabel(f)
	int f;
d766 1
a766 4
makebootarea(boot, dp, f)
	char *boot;
	struct disklabel *dp;
	int f;
d896 1
a896 3
makedisktab(f, lp)
	FILE *f;
	struct disklabel *lp;
d985 1
a985 2
width_partition(lp, unit)
	struct disklabel *lp;
d999 2
a1000 7
display_partition(f, lp, mp, i, unit, width)
	FILE *f;
	struct disklabel *lp;
	char **mp;
	int i;
	char unit;
	int width;
d1088 1
a1088 4
display(f, lp, unit)
	FILE *f;
	struct disklabel *lp;
	char unit;
d1141 1
a1141 3
edit(lp, f)
	struct disklabel *lp;
	int f;
d1200 1
a1200 1
editit()
d1252 1
a1252 2
skip(cp)
	char *cp;
d1262 1
a1262 2
word(cp)
	char *cp;
d1281 1
a1281 3
getasciilabel(f, lp)
	FILE *f;
	struct disklabel *lp;
d1574 1
a1574 2
checklabel(lp)
	struct disklabel *lp;
d1681 1
a1681 2
setbootflag(lp)
	struct disklabel *lp;
d1716 1
a1716 3
cmplabel(lp1, lp2)
	struct disklabel *lp1;
	struct disklabel *lp2;
d1732 1
a1732 1
usage()
@


1.3
log
@fix build (a ( was too much)
@
text
@d1 2
a2 2
/*	$MirBSD: disklabel.c,v 1.2 2003/05/20 20:00:57 tg Exp $	*/
/*	$OpenBSD: disklabel.c,v 1.79 2003/04/06 00:45:12 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static const char rcsid[] = "$MirBSD: disklabel.c,v 1.2 2003/05/20 20:00:57 tg Exp $";
@


1.2
log
@employ our own idea of a MirBSD disklabel and partition type:
 0xA6 OpenBSD is used as fall-back
 0x27 MirBSD disklabel is the new type
reason: addition of FS_* constants in sys/sys/disklabel.h
might get us outta sync with OpenBSD laters (NTFS here)

talk about "slices" in disklabel
remove trailing newlines etc. in fdisk
@
text
@d1 1
a1 1
/*	$MirBSD$	*/
d47 1
a47 1
static const char rcsid[] = "$MirBSD: disklabel.c,v 1.79 2003/04/06 00:45:12 deraadt Exp $";
d437 1
a437 1
		    (dosdp->dp_typ == DOSPTYP_OPENBSD ||
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: disklabel.c,v 1.78 2003/02/13 00:10:39 tedu Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.78 2003/02/13 00:10:39 tedu Exp $";
d263 1
a263 1
	 * master boot record. Return pointer to OpenBSD
d428 1
a428 1
		 * If OpenBSD DOS partition is missing, or if
d436 1
d626 1
a626 1
	 * partition table to find OpenBSD partition, and obtain
d634 11
a644 1
	/* Find OpenBSD partition. */
d677 1
a677 1
	 * If there is no signature and no OpenBSD partition this is probably
d683 1
a683 1
	/* If no OpenBSD partition, find first used partition. */
d686 1
a686 1
			warnx("warning, DOS partition table with no valid OpenBSD partition");
d711 2
a712 1
		    (dosdp->dp_typ == DOSPTYP_OPENBSD ||
d834 2
a835 2
			(void)sprintf(np, "%s%sboot",
			    _PATH_BOOTDIR, dkbasename);
d839 3
a841 2
			(void)sprintf(xxboot, "%s%sboot",
			    _PATH_BOOTDIR, dkbasename);
d846 2
a847 2
			(void)sprintf(np, "%sboot%s",
			    _PATH_BOOTDIR, dkbasename);
d851 2
a852 2
			(void)sprintf(bootxx, "%sboot%s",
			    _PATH_BOOTDIR, dkbasename);
d1191 1
a1191 1
"# 4.2BSD filesystem (or '512 4096 16' except on alpha, sun4, ...)\n");
d1639 2
a1640 1
	    (dosdp->dp_typ == DOSPTYP_OPENBSD ||
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.79 2003/04/06 00:45:12 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.79 2003/04/06 00:45:12 deraadt Exp $";
d821 2
a822 2
			(void)snprintf(np, namebuf + sizeof namebuf - np,
			    "%s%sboot", _PATH_BOOTDIR, dkbasename);
d826 2
a827 3
			(void)snprintf(xxboot,
			    namebuf + sizeof namebuf - np,
			    "%s%sboot", _PATH_BOOTDIR, dkbasename);
d832 2
a833 2
			(void)snprintf(np, namebuf + sizeof namebuf - np,
			    "%sboot%s", _PATH_BOOTDIR, dkbasename);
d837 2
a838 2
			(void)snprintf(bootxx, namebuf + sizeof namebuf - bootxx,
			    "%sboot%s", _PATH_BOOTDIR, dkbasename);
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.80 2003/06/02 20:06:14 millert Exp $	*/
d18 5
a22 1
 * 3. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.80 2003/06/02 20:06:14 millert Exp $";
@


1.1.1.4
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.81 2003/06/11 06:22:12 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.81 2003/06/11 06:22:12 deraadt Exp $";
d140 3
a142 1
main(int argc, char *argv[])
d350 3
a352 1
makelabel(char *type, char *name, struct disklabel *lp)
d394 4
a397 1
writelabel(int f, char *boot, struct disklabel *lp)
d567 2
a568 1
l_perror(char *s)
d598 2
a599 1
readmbr(int f)
d684 2
a685 1
readlabel(int f)
d763 4
a766 1
makebootarea(char *boot, struct disklabel *dp, int f)
d896 3
a898 1
makedisktab(FILE *f, struct disklabel *lp)
d987 2
a988 1
width_partition(struct disklabel *lp, int unit)
d1002 7
a1008 2
display_partition(FILE *f, struct disklabel *lp, char **mp, int i,
    char unit, int width)
d1096 4
a1099 1
display(FILE *f, struct disklabel *lp, char unit)
d1152 3
a1154 1
edit(struct disklabel *lp, int f)
d1213 1
a1213 1
editit(void)
d1265 2
a1266 1
skip(char *cp)
d1276 2
a1277 1
word(char *cp)
d1296 3
a1298 1
getasciilabel(FILE *f, struct disklabel *lp)
d1591 2
a1592 1
checklabel(struct disklabel *lp)
d1698 2
a1699 1
setbootflag(struct disklabel *lp)
d1734 3
a1736 1
cmplabel(struct disklabel *lp1, struct disklabel *lp2)
d1752 1
a1752 1
usage(void)
@


1.1.1.5
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.82 2003/06/25 21:11:48 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.82 2003/06/25 21:11:48 deraadt Exp $";
d1191 1
@


1.1.1.6
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.83 2003/07/02 21:22:10 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.83 2003/07/02 21:22:10 deraadt Exp $";
a64 1
#include "extern.h"
@


1.1.1.7
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.84 2003/07/16 18:03:44 tedu Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.84 2003/07/16 18:03:44 tedu Exp $";
d1148 1
a1148 1
"# other values.  fsize/bsize/cpg should typically be '2048 16384 16' for a\n"
@


1.1.1.8
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.85 2003/07/29 18:38:35 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.85 2003/07/29 18:38:35 deraadt Exp $";
d497 1
a497 1

d609 1
a609 1

@


1.1.1.9
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.86 2003/12/20 09:29:27 jmc Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.86 2003/12/20 09:29:27 jmc Exp $";
d1724 1
a1724 1
	boot = " [-b boot1]";
d1726 1
a1726 1
	boot = " [-b boot1] [-s boot2]";
d1732 2
a1733 1
	    "  disklabel [-c | -d | -r | -t] [-v] [-p unit] disk\t\t(read)\n");
d1735 2
a1736 1
	    "  disklabel -w [-c | -d | -r] [-nv] disk disktype [packid]\t(write)\n");
d1738 2
a1739 1
	    "  disklabel -e [-c | -d | -r] [-nv] disk\t\t\t(edit)\n");
d1741 1
a1741 7
	    "  disklabel -E [-c | -d | -r] [-nv] [-f tempfile] disk\t\t(simple editor)\n");
	fprintf(stderr,
	    "  disklabel -R [-nrv] disk protofile\t\t\t\t(restore)\n");
	fprintf(stderr,
	    "  disklabel -N | -W [-nv] disk\t\t\t\t\t(protect)\n\n");
	fprintf(stderr,
	    "  disklabel -B  [-nv]%s disk [disktype]\t       (boot)\n",
d1744 1
a1744 1
	    "  disklabel -Bw [-nv]%s disk disktype [packid]     (write)\n",
d1747 1
a1747 2
	    "  disklabel -BR [-nv]%s disk protofile [disktype]  (restore)\n\n",
	    boot);
d1749 1
a1749 1
	    "`disk' may be of the form: sd0 or /dev/rsd0%c.\n", 'a'+RAW_PART);
d1751 1
a1751 1
	    "`disktype' is an entry from %s, see disktab(5) for more info.\n",
d1754 1
a1754 3
	    "`packid' is an identification string for the device.\n");
	fprintf(stderr,
	    "`protofile' is the output from the read cmd form; -R is powerful.\n");
@


1.1.1.10
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.87 2004/04/07 14:09:35 aaron Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.87 2004/04/07 14:09:35 aaron Exp $";
d149 1
a149 1
	while ((ch = getopt(argc, argv, "BEf:NRWb:cdenp:rs:tvw")) != -1)
@


1.1.1.11
log
@another obsd-current
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.93 2004/10/04 15:09:41 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.93 2004/10/04 15:09:41 otto Exp $";
a57 1
#include <limits.h>
d123 6
d134 1
d138 1
a138 1
u_int32_t getnum(char *, u_int32_t, u_int32_t, const char **);
a303 2
		else
			error = 1;
d624 1
a624 1
			    "type %02X off %u (0x%x) size %u (0x%x)\n", part,
d634 1
a634 1
			    "type %02X off %u (0x%x) size %u (0x%x)\n", part,
d644 1
a644 1
			    "type %02X off %u (0x%x) size %u (0x%x)\n", part,
d910 1
a910 1
		(void)fprintf(f, "%srm#%hu:", did, lp->d_rpm);
d914 1
a914 1
		(void)fprintf(f, "%sil#%hu:", did, lp->d_interleave);
d918 1
a918 1
		(void)fprintf(f, "%ssk#%hu:", did, lp->d_trackskew);
d922 1
a922 1
		(void)fprintf(f, "%scs#%hu:", did, lp->d_cylskew);
d972 11
d984 1
a984 1
 * Display a particular partition.
d988 1
a988 1
    char unit)
d993 2
d1027 2
a1028 2
			fprintf(f, "  %c: %13u %13u ", 'a' + i,
			    pp->p_size, pp->p_offset);
d1030 2
a1031 3
			fprintf(f, "  %c: %12.*f%c %12.*f%c ", 'a' + i,
			    unit == 'B' ? 0 : 1, p_size, unit,
			    unit == 'B' ? 0 : 1, p_offset, unit);
d1033 1
a1033 1
			fprintf(f, "%7.7s", fstypenames[pp->p_fstype]);
d1035 1
a1035 1
			fprintf(f, "%7d", pp->p_fstype);
d1039 1
a1039 1
			fprintf(f, "  %5u %5u %4.4s ",
d1044 1
a1044 1
			fprintf(f, "  %5u %5u %4hu ",
d1050 1
a1050 1
			fprintf(f, "%19.19s", "");
d1055 1
a1055 1
				fprintf(f, "# %s", mp[i]);
d1057 1
a1057 1
			fprintf(f, "# Cyl %5u",
d1063 1
a1063 1
			fprintf(f, "-%6u",
d1069 1
a1069 2
			else
				putc(' ', f);
d1079 1
d1096 14
a1109 13
	fprintf(f, "bytes/sector: %u\n", lp->d_secsize);
	fprintf(f, "sectors/track: %u\n", lp->d_nsectors);
	fprintf(f, "tracks/cylinder: %u\n", lp->d_ntracks);
	fprintf(f, "sectors/cylinder: %u\n", lp->d_secpercyl);
	fprintf(f, "cylinders: %u\n", lp->d_ncylinders);
	fprintf(f, "total sectors: %u\n", lp->d_secperunit);
	fprintf(f, "rpm: %hu\n", lp->d_rpm);
	fprintf(f, "interleave: %hu\n", lp->d_interleave);
	fprintf(f, "trackskew: %hu\n", lp->d_trackskew);
	fprintf(f, "cylinderskew: %hu\n", lp->d_cylskew);
	fprintf(f, "headswitch: %u\t\t# microseconds\n", lp->d_headswitch);
	fprintf(f, "track-to-track seek: %u\t# microseconds\n",
	    lp->d_trkseek);
d1118 5
a1122 3
	fprintf(f, "\n\n%hu partitions:\n", lp->d_npartitions);
	fprintf(f, "#    %13.13s %13.13s  fstype [fsize bsize  cpg]\n",
	    "size", "offset");
d1124 1
a1124 1
		display_partition(f, lp, NULL, i, unit);
d1190 2
a1191 2
	pid_t pid;
	int stat = 0, len;
d1225 1
a1225 7
		if (waitpid(pid, (int *)&stat, WUNTRACED) == -1) {
			if (errno == EINTR)
				continue;
			if (errno == ECHILD)
				stat = 1;
			break;
		}
a1261 21
/* Base the max value on the sizeof of the value we are reading */
#define GETNUM(field, nptr, min, errstr) 				\
	    getnum((nptr), (min),					\
		sizeof(field) == 4 ? UINT_MAX : 			\
		(sizeof(field) == 2 ? USHRT_MAX : UCHAR_MAX),  (errstr))

u_int32_t
getnum(char *nptr, u_int32_t min, u_int32_t max, const char **errstr)
{
	char *p, c;
	u_int32_t ret;

	for (p = nptr; *p != '\0' && !isspace(*p); p++)
		;
	c = *p;
	*p = '\0';
	ret = strtonum(nptr, min, max, errstr);
	*p = c;
	return (ret);
}

a1270 1
	const char *errstr;
d1273 1
a1273 2
	int lineno = 0, errors = 0;
	u_int32_t v;
d1302 2
a1303 2
			v = GETNUM(lp->d_type, tp, 0, &errstr);
			if (errstr || v >= DKMAXTYPES)
d1331 1
a1331 5
				v = GETNUM(lp->d_drivedata[i], cp, 0, &errstr);
				if (errstr)
					warnx("line %d: bad drivedata %s",
					   lineno, cp);
				lp->d_drivedata[i++] = v;
d1337 1
a1337 1
			if (v == 0 || v > MAXPARTITIONS) {
d1356 2
a1357 2
			v = GETNUM(lp->d_secsize, tp, 1, &errstr);
			if (errstr || (v % 512) != 0) {
d1365 2
a1366 2
			v = GETNUM(lp->d_nsectors, tp, 1, &errstr);
			if (errstr) {
d1374 2
a1375 2
			v = GETNUM(lp->d_secpercyl, tp, 1, &errstr);
			if (errstr) {
d1383 2
a1384 2
			v = GETNUM(lp->d_ntracks, tp, 1, &errstr);
			if (errstr) {
d1392 2
a1393 2
			v = GETNUM(lp->d_ncylinders, tp, 1, &errstr);
			if (errstr) {
d1401 2
a1402 2
			v = GETNUM(lp->d_secperunit, tp, 1, &errstr);
			if (errstr) {
d1410 2
a1411 2
			v = GETNUM(lp->d_rpm, tp, 1, &errstr);
			if (errstr) {
d1419 2
a1420 2
			v = GETNUM(lp->d_interleave, tp, 1, &errstr);
			if (errstr) {
d1428 2
a1429 2
			v = GETNUM(lp->d_trackskew, tp, 0, &errstr);
			if (errstr) {
d1437 2
a1438 2
			v = GETNUM(lp->d_cylskew, tp, 0, &errstr);
			if (errstr) {
d1446 2
a1447 2
			v = GETNUM(lp->d_headswitch, tp, 0, &errstr);
			if (errstr) {
d1455 2
a1456 2
			v = GETNUM(lp->d_trkseek, tp, 0, &errstr);
			if (errstr) {
d1477 1
a1477 1
#define NXTNUM(n, field, errstr) { \
d1483 1
a1483 1
		cp = tp, tp = word(cp), (n) = GETNUM(field, cp, 0, errstr); \
d1485 2
a1486 2
			NXTNUM(v, pp->p_size, &errstr);
			if (errstr) {
d1492 2
a1493 2
			NXTNUM(v, pp->p_offset, &errstr);
			if (errstr) {
d1511 1
a1511 1
				v = GETNUM(pp->p_fstype, cp, 0, &errstr);
d1514 1
a1514 1
			if (errstr || v >= FSMAXTYPES) {
d1526 1
a1526 1
				NXTNUM(pp->p_fsize, pp->p_fsize, &errstr);
d1529 1
a1529 1
				NXTNUM(v, v, &errstr);
d1534 1
a1534 1
				NXTNUM(pp->p_fsize, pp->p_fsize, &errstr);
d1537 1
a1537 1
				NXTNUM(v, v, &errstr);
d1539 1
a1539 1
				NXTNUM(pp->p_cpg, pp->p_cpg, &errstr);
@


