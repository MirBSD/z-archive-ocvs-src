head	1.14;
access;
symbols
	tg-mergetmp-mirosx-1:1.14
	tg-mergefixes-1-branch:1.14.0.4
	tg-mergefixes-1-base:1.14
	MIROS_X:1.14.0.2
	MIROS_X_BASE:1.14
	tg-mergetmp-3:1.14
	cvs-200412111650:1.1.1.12
	MIRBSD_XP_MIRPPC:1.12.0.4
	cvs-200410141645:1.1.1.11
	MIRBSD_XP_SPARC_BASE:1.12
	MIRBSD_XP_SPARC:1.12.0.2
	MIRBSD_7quater:1.9
	cvs-200405160640:1.1.1.10
	cvs-200401271800:1.1.1.10
	cvs-200401261630:1.1.1.10
	cvs-200401021645:1.1.1.10
	MIRBSD_7_ALPHA:1.9.0.6
	MIRBSD_7:1.9.0.4
	cvs-200312222040:1.1.1.9
	MIRBSD_7ter:1.9
	MIRBSD_7_DEV:1.9.0.2
	cvs-200310020700:1.1.1.8
	cvs-200309271030:1.1.1.8
	cvs-200309251530:1.1.1.8
	cvs-200308302005:1.1.1.7
	cvs-200308171200:1.1.1.6
	ctm-3496:1.1.1.6
	ctm-3449:1.1.1.5
	ctm-3437:1.1.1.5
	cvs-200307191805:1.1.1.5
	ctm-3425:1.1.1.5
	cvs-200307091500:1.1.1.4
	ctm-3389:1.1.1.4
	cvs-200306291430:1.1.1.4
	ctm-3341:1.1.1.4
	MIRBSD_5:1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2004.12.11.17.00.28;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.14.20.50.49;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.03.00.37.53;	author tg;	state Stab;
branches;
next	1.11;

1.11
date	2004.01.02.23.25.07;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.27.00.30.37;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.25.20.59.50;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.31.20.54.35;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.16.15.25.20;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.18.15.45.10;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.28.20.57.56;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.19.16.44.15;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.06.18.28.28;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.20.20.00.57;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.48.23;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.48.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.14.44.10;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.30.44;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.19.12.42.15;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.07.18.13.42.03;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.08.11.18.29.26;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.08.30.22.59.47;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.09.25.16.32.06;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.12.22.21.10.22;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.01.02.18.00.53;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2004.10.14.17.19.17;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2004.12.11.16.57.34;	author tg;	state Exp;
branches;
next	;


desc
@@


1.14
log
@merge
@
text
@/**	$MirBSD: src/sbin/disklabel/editor.c,v 1.13 2004/10/14 20:50:49 tg Exp $ */
/*	$OpenBSD: editor.c,v 1.98 2004/12/11 07:28:05 otto Exp $	*/

/*
 * Copyright (c) 1997-2000 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#define	DKTYPENAMES
#include <sys/disklabel.h>
#include <sys/reboot.h>
#include <sys/sysctl.h>
#include <machine/cpu.h>
#ifdef CPU_BIOS
#include <machine/biosvar.h>
#endif

#include <ufs/ffs/fs.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <string.h>
#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "extern.h"
#include "pathnames.h"

__RCSID("$MirBSD: src/sbin/disklabel/editor.c,v 1.13 2004/10/14 20:50:49 tg Exp $");

/* flags for getuint() */
#define	DO_CONVERSIONS	0x00000001
#define	DO_ROUNDING	0x00000002

#ifndef NUMBOOT
#define NUMBOOT 0
#endif

/* structure to describe a portion of a disk */
struct diskchunk {
	u_int32_t start;
	u_int32_t stop;
};

/* used when sorting mountpoints in mpsave() */
struct mountinfo {
	char *mountpoint;
	int partno;
};

void	edit_parms(struct disklabel *, u_int32_t *);
void	editor_add(struct disklabel *, char **, u_int32_t *, char *);
void	editor_change(struct disklabel *, u_int32_t *, char *);
void	editor_countfree(struct disklabel *, u_int32_t *);
void	editor_delete(struct disklabel *, char **, u_int32_t *, char *);
void	editor_display(struct disklabel *, char **, u_int32_t *, char);
void	editor_help(char *);
void	editor_modify(struct disklabel *, char **, u_int32_t *, char *);
void	editor_name(struct disklabel *, char **, char *);
char	*getstring(char *, char *, char *);
u_int32_t getuint(struct disklabel *, int, char *, char *, u_int32_t, u_int32_t, u_int32_t, int);
int	has_overlap(struct disklabel *, u_int32_t *, int);
void	make_contiguous(struct disklabel *);
u_int32_t next_offset(struct disklabel *, u_int32_t *);
int	partition_cmp(const void *, const void *);
struct partition **sort_partitions(struct disklabel *, u_int16_t *);
void	getdisktype(struct disklabel *, char *, char *);
void	find_bounds(struct disklabel *, struct disklabel *);
void	set_bounds(struct disklabel *, u_int32_t *);
struct diskchunk *free_chunks(struct disklabel *);
char **	mpcopy(char **, char **);
int	micmp(const void *, const void *);
int	mpequal(char **, char **);
int	mpsave(struct disklabel *, char **, char *, char *);
int	get_bsize(struct disklabel *, int);
int	get_cpg(struct disklabel *, int);
int	get_fsize(struct disklabel *, int);
int	get_fstype(struct disklabel *, int);
int	get_mp(struct disklabel *, char **, int);
int	get_offset(struct disklabel *, int);
int	get_size(struct disklabel *, int, u_int32_t *, int);
void	get_geometry(int, struct disklabel **, struct disklabel **);
void	set_geometry(struct disklabel *, struct disklabel *, struct disklabel *, struct disklabel *, char *);
void	zero_partitions(struct disklabel *, u_int32_t *);

static u_int32_t starting_sector;
static u_int32_t ending_sector;
static int expert;

/*
 * Simple partition editor.  Primarily intended for new labels.
 */
int
editor(struct disklabel *lp, int f, char *dev, char *fstabfile)
{
	struct disklabel lastlabel, tmplabel, label = *lp;
	struct disklabel *disk_geop, *bios_geop;
	struct partition *pp;
	u_int32_t freesectors;
	FILE *fp;
	char buf[BUFSIZ], *cmd, *arg;
	char **mountpoints = NULL, **omountpoints = NULL, **tmpmountpoints = NULL;

	/* Alloc and init mount point info */
	if (fstabfile) {
		if (!(mountpoints = calloc(MAXPARTITIONS, sizeof(char *))) ||
		    !(omountpoints = calloc(MAXPARTITIONS, sizeof(char *))) ||
		    !(tmpmountpoints = calloc(MAXPARTITIONS, sizeof(char *))))
			errx(4, "out of memory");
	}

	/* Don't allow disk type of "unknown" */
	getdisktype(&label, "You need to specify a type for this disk.", dev);

	/* Get the on-disk and BIOS geometries if possible */
	get_geometry(f, &disk_geop, &bios_geop);

	/* How big is the MirBSD portion of the disk?  */
	find_bounds(&label, bios_geop);

	/* Set freesectors based on bounds and initial label */
	editor_countfree(&label, &freesectors);

	/* Make sure there is no partition overlap. */
	if (has_overlap(&label, &freesectors, 1))
		errx(1, "can't run when there is partition overlap.");

	/* If we don't have a 'c' slice, create one. */
	pp = &label.d_partitions[RAW_PART];
	if (label.d_npartitions < 3 || pp->p_size == 0) {
		puts("No 'c' slice found, adding one that spans the disk.");
		if (label.d_npartitions < 3)
			label.d_npartitions = 3;
		pp->p_offset = 0;
		pp->p_size = label.d_secperunit;
		pp->p_fstype = FS_UNUSED;
		pp->p_fsize = pp->p_frag = pp->p_cpg = 0;
	}

#ifdef CYLCHECK
	puts("This platform requires that partition offsets/sizes be on cylinder boundaries.\nSlice offsets/sizes will be rounded to the nearest cylinder automatically.");
#endif

	/* Set d_bbsize and d_sbsize as necessary */
	if (label.d_bbsize == 0)
		label.d_bbsize = BBSIZE;
	if (label.d_sbsize == 0)
		label.d_sbsize = SBSIZE;

	/* Interleave must be >= 1 */
	if (label.d_interleave == 0)
		label.d_interleave = 1;

	puts("\nInitial label editor (enter '?' for help at any prompt)");
	lastlabel = label;
	for (;;) {
		fputs("> ", stdout);
		if (fgets(buf, sizeof(buf), stdin) == NULL) {
			putchar('\n');
			buf[0] = 'q';
			buf[1] = '\0';
		}
		if ((cmd = strtok(buf, " \t\r\n")) == NULL)
			continue;
		arg = strtok(NULL, " \t\r\n");

		switch (*cmd) {

		case '?':
		case 'h':
			editor_help(arg ? arg : "");
			break;

		case 'a':
			tmplabel = lastlabel;
			lastlabel = label;
			if (mountpoints != NULL) {
				mpcopy(tmpmountpoints, omountpoints);
				mpcopy(omountpoints, mountpoints);
			}
			editor_add(&label, mountpoints, &freesectors, arg);
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
			if (mountpoints != NULL && mpequal(omountpoints, tmpmountpoints))
				mpcopy(omountpoints, tmpmountpoints);
			break;

		case 'b':
			tmplabel = lastlabel;
			lastlabel = label;
			set_bounds(&label, &freesectors);
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
			break;

		case 'c':
			tmplabel = lastlabel;
			lastlabel = label;
			editor_change(&label, &freesectors, arg);
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
			break;

		case 'D':
			tmplabel = lastlabel;
			lastlabel = label;
			if (ioctl(f, DIOCGPDINFO, &label) == 0)
				editor_countfree(&label, &freesectors);
			else {
				warn("unable to get default partition table");
				lastlabel = tmplabel;
			}
			break;

		case 'd':
			tmplabel = lastlabel;
			lastlabel = label;
			if (mountpoints != NULL) {
				mpcopy(tmpmountpoints, omountpoints);
				mpcopy(omountpoints, mountpoints);
			}
			editor_delete(&label, mountpoints, &freesectors, arg);
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
			if (mountpoints != NULL && mpequal(omountpoints, tmpmountpoints))
				mpcopy(omountpoints, tmpmountpoints);
			break;

		case 'e':
			tmplabel = lastlabel;
			lastlabel = label;
			edit_parms(&label, &freesectors);
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
			break;

		case 'g':
			tmplabel = lastlabel;
			lastlabel = label;
			set_geometry(&label, disk_geop, bios_geop, lp, arg);
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
			break;

		case 'm':
			tmplabel = lastlabel;
			lastlabel = label;
			if (mountpoints != NULL) {
				mpcopy(tmpmountpoints, omountpoints);
				mpcopy(omountpoints, mountpoints);
			}
			editor_modify(&label, mountpoints, &freesectors, arg);
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
			if (mountpoints != NULL && mpequal(omountpoints, tmpmountpoints))
				mpcopy(omountpoints, tmpmountpoints);
			break;

		case 'n':
			if (mountpoints == NULL) {
				fputs("This option is not valid when run "
				    "without the -f flag.\n", stderr);
				break;
			}
			mpcopy(tmpmountpoints, omountpoints);
			mpcopy(omountpoints, mountpoints);
			editor_name(&label, mountpoints, arg);
			if (mpequal(omountpoints, tmpmountpoints))
				mpcopy(omountpoints, tmpmountpoints);
			break;

		case 'p':
			editor_display(&label, mountpoints, &freesectors,
			    arg ? *arg : 0);
			break;

		case 'M': {
			sig_t opipe = signal(SIGPIPE, SIG_IGN);
			char *pager;
			extern char manpage[];

			if ((pager = getenv("PAGER")) == NULL || *pager == '\0')
				pager = _PATH_LESS;
			if ((fp = popen(pager, "w")) != NULL) {
				(void) fwrite(manpage, strlen(manpage), 1, fp);
				pclose(fp);
			} else
				warn("unable to execute %s", pager);

			(void)signal(SIGPIPE, opipe);
			break;
		}

		case 'q':
			if (donothing) {
				puts("In no change mode, not writing label.");
				return(1);
			}
			/* Save mountpoint info if there is any. */
			if (mountpoints != NULL)
				mpsave(&label, mountpoints, dev, fstabfile);
			if (memcmp(lp, &label, sizeof(label)) == 0) {
				puts("No label changes.");
				return(1);
			}
			do {
				arg = getstring("Write new label?",
				    "Write the modified label to disk?",
				    "y");
			} while (arg && tolower(*arg) != 'y' && tolower(*arg) != 'n');
			if (arg && tolower(*arg) == 'y') {
				if (writelabel(f, bootarea, &label) == 0) {
					*lp = label;
					return(0);
				}
				warnx("unable to write label");
			}
			return(1);
			/* NOTREACHED */
			break;

		case 'r':
		    /* Recalculate free space */
		    editor_countfree(&label, &freesectors);
		    puts("Recalculated free space.");
		    break;

		case 's':
			if (arg == NULL) {
				arg = getstring("Filename",
				    "Name of the file to save label into.",
				    NULL);
				if (arg == NULL && *arg == '\0')
					break;
			}
			if ((fp = fopen(arg, "w")) == NULL) {
				warn("cannot open %s", arg);
			} else {
				display(fp, &label, 0);
				(void)fclose(fp);
			}
			break;

		case 'u':
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0 &&
			    mountpoints != NULL &&
			    mpequal(mountpoints, omountpoints)) {
				puts("Nothing to undo!");
			} else {
				tmplabel = label;
				label = lastlabel;
				lastlabel = tmplabel;
				/* Recalculate free space */
				editor_countfree(&label, &freesectors);
				/* Restore mountpoints */
				if (mountpoints != NULL)
					mpcopy(mountpoints, omountpoints);
				puts("Last change undone.");
			}
			break;

		case 'w':
			if (donothing)  {
				puts("In no change mode, not writing label.");
				break;
			}
			/* Save mountpoint info if there is any. */
			if (mountpoints != NULL)
				mpsave(&label, mountpoints, dev, fstabfile);
			/* Save label if it has changed. */
			if (memcmp(lp, &label, sizeof(label)) == 0)
				puts("No label changes.");
			else if (writelabel(f, bootarea, &label) != 0)
				warnx("unable to write label");
			else
				*lp = label;
			break;

		case 'X':
			expert = !expert;
			printf("%s expert mode\n", expert ? "Entering" :
			    "Exiting");
			break;

		case 'x':
			return(1);
			break;

		case 'z':
			tmplabel = lastlabel;
			lastlabel = label;
			zero_partitions(&label, &freesectors);
			break;

		case '\n':
			break;

		default:
			printf("Unknown option: %c ('?' for help)\n", *cmd);
			break;
		}
	}
}

/*
 * Add a new partition.
 */
void
editor_add(struct disklabel *lp, char **mp, u_int32_t *freep, char *p)
{
	struct partition *pp;
	struct diskchunk *chunks;
	char buf[BUFSIZ];
	int i, partno;
	u_int32_t ui, old_offset, old_size;

	/* XXX - prompt user to steal space from another partition instead */
	if (*freep == 0) {
		fputs("No space left, you need to shrink a slice\n",
		    stderr);
		return;
	}

	/* XXX - make more like other editor_* */
	if (p != NULL) {
		partno = p[0] - 'a';
		if (partno < 0 || partno == RAW_PART ||
		    partno >= MAXPARTITIONS) {
			fprintf(stderr,
			    "Slice must be between 'a' and '%c' "
			    "(excluding 'c').\n", 'a' + MAXPARTITIONS - 1);
			return;
		} else if (lp->d_partitions[partno].p_fstype != FS_UNUSED &&
		    lp->d_partitions[partno].p_size != 0) {
			fprintf(stderr,
			    "Slice '%c' exists.  Delete it first.\n",
			    p[0]);
			return;
		}
	} else {
		/* Find first unused partition that is not 'c' */
		for (partno = 0; partno < MAXPARTITIONS; partno++, p++) {
			if (lp->d_partitions[partno].p_size == 0 &&
			    partno != RAW_PART)
				break;
		}
		if (partno < MAXPARTITIONS) {
			buf[0] = partno + 'a';
			buf[1] = '\0';
			p = &buf[0];
		} else
			p = NULL;
		for (;;) {
			p = getstring("slice",
			    "The letter of the new slice, a - p.", p);
			if (p == NULL)
				return;
			partno = p[0] - 'a';
			if (lp->d_partitions[partno].p_fstype != FS_UNUSED &&
			    lp->d_partitions[partno].p_size != 0) {
				fprintf(stderr,
				    "Slice '%c' already exists.\n", p[0]);
			} else if (partno >= 0 && partno < MAXPARTITIONS)
				break;
			fprintf(stderr,
			    "Slice must be between 'a' and '%c'.\n",
			    'a' + MAXPARTITIONS - 1);
		}
	}

	/* Increase d_npartitions if necessary */
	if (partno >= lp->d_npartitions)
		lp->d_npartitions = partno + 1;

	/* Set defaults */
	pp = &lp->d_partitions[partno];
	if (partno >= lp->d_npartitions)
		lp->d_npartitions = partno + 1;
	memset(pp, 0, sizeof(*pp));
	pp->p_size = *freep;
	pp->p_offset = next_offset(lp, &pp->p_size);
	pp->p_fstype = partno == 1 ? FS_SWAP : FS_BSDFFS;
#if defined (__sparc__) && !defined(__sparc64__)
	/* can't boot from > 8k boot blocks */
	pp->p_fsize = partno == 0 ? 1024 : 2048;
#else
	pp->p_fsize = 2048;
#endif
	pp->p_frag = 8;
	pp->p_cpg = 16;
	old_offset = pp->p_offset;
	old_size = pp->p_size;

getoff1:
	/* Get offset */
	if (get_offset(lp, partno) != 0) {
		pp->p_size = 0;			/* effective delete */
		return;
	}

	/* Recompute recommended size based on new offset */
	ui = pp->p_fstype;
	pp->p_fstype = FS_UNUSED;
	chunks = free_chunks(lp);
	for (i = 0; chunks[i].start != 0 || chunks[i].stop != 0; i++) {
		if (pp->p_offset >= chunks[i].start &&
		    pp->p_offset < chunks[i].stop) {
			pp->p_size = chunks[i].stop - pp->p_offset;
			break;
		}
	}
	pp->p_fstype = ui;

	/* Get size */
	if (get_size(lp, partno, freep, 1) != 0 || pp->p_size == 0) {
		pp->p_size = 0;			/* effective delete */
		return;
	}

	/* Check for overlap */
	if (has_overlap(lp, freep, 0)) {
		printf("\nPlease re-enter an offset and size for slice "
		    "%c.\n", 'a' + partno);
		pp->p_offset = old_offset;
		pp->p_size = old_size;
		goto getoff1;		/* Yeah, I know... */
	}

	/* Get filesystem type and mountpoint */
	if (get_fstype(lp, partno) != 0 || get_mp(lp, mp, partno) != 0) {
		pp->p_size = 0;			/* effective delete */
		return;
	}

	if (expert && pp->p_fstype == FS_BSDFFS) {
		/* Get fsize, bsize, and cpg */
		if (get_fsize(lp, partno) != 0 || get_bsize(lp, partno) != 0 ||
		    get_cpg(lp, partno) != 0) {
			pp->p_size = 0;			/* effective delete */
			return;
		}
	}

	/* Update free sector count and make sure things stay contiguous. */
	*freep -= pp->p_size;
	if (pp->p_size + pp->p_offset > ending_sector ||
	    has_overlap(lp, freep, -1))
		make_contiguous(lp);
}

/*
 * Set the mountpoint of an existing slice ('name').
 */
void
editor_name(struct disklabel *lp, char **mp, char *p)
{
	struct partition *pp;
	int partno;

	/* Change which slice? */
	if (p == NULL) {
		p = getstring("slice to name",
		    "The letter of the slice to name, a - p.", NULL);
	}
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		return;
	}
	partno = p[0] - 'a';
	pp = &lp->d_partitions[partno];
	if (partno < 0 || partno >= lp->d_npartitions) {
		fprintf(stderr, "Slice must be between 'a' and '%c'.\n",
		    'a' + lp->d_npartitions - 1);
		return;
	} else if (partno >= lp->d_npartitions ||
	    (pp->p_fstype == FS_UNUSED && pp->p_size == 0)) {
		fprintf(stderr, "Slice '%c' is not in use.\n", 'a' + partno);
		return;
	}

	/* Not all fstypes can be named */
	if (pp->p_fstype == FS_UNUSED || pp->p_fstype == FS_SWAP ||
	    pp->p_fstype == FS_BOOT || pp->p_fstype == FS_OTHER) {
		fprintf(stderr, "You cannot name a filesystem of type %s.\n",
		    fstypenames[lp->d_partitions[partno].p_fstype]);
		return;
	}

	get_mp(lp, mp, partno);
}

/*
 * Change an existing slice.
 */
void
editor_modify(struct disklabel *lp, char **mp, u_int32_t *freep, char *p)
{
	struct partition origpart, *pp;
	int partno;

	/* Change which slice? */
	if (p == NULL) {
		p = getstring("slice to modify",
		    "The letter of the slice to modify, a - p.", NULL);
	}
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		return;
	}
	partno = p[0] - 'a';
	pp = &lp->d_partitions[partno];
	origpart = lp->d_partitions[partno];
	if (partno < 0 || partno >= lp->d_npartitions) {
		fprintf(stderr, "Slice must be between 'a' and '%c'.\n",
		    'a' + lp->d_npartitions - 1);
		return;
	} else if (partno >= lp->d_npartitions ||
	    (pp->p_fstype == FS_UNUSED && pp->p_size == 0)) {
		fprintf(stderr, "Slice '%c' is not in use.\n", 'a' + partno);
		return;
	}

	/* Get filesystem type */
	if (get_fstype(lp, partno) != 0) {
		*pp = origpart;			/* undo changes */
		return;
	}

	/* Did they disable/enable the slice? */
	if ((pp->p_fstype == FS_UNUSED || pp->p_fstype == FS_BOOT) &&
	    origpart.p_fstype != FS_UNUSED && origpart.p_fstype != FS_BOOT)
		*freep += origpart.p_size;
	else if (pp->p_fstype != FS_UNUSED && pp->p_fstype != FS_BOOT &&
	    (origpart.p_fstype == FS_UNUSED || origpart.p_fstype == FS_BOOT)) {
		if (pp->p_size > *freep) {
			fprintf(stderr,
			    "Warning, need %u sectors but there are only %u "
			    "free.  Setting size to %u.\n", pp->p_size, *freep,
			    *freep);
			pp->p_fstype = *freep;
			*freep = 0;
		} else
			*freep -= pp->p_size;		/* have enough space */
	}

getoff2:
	/* Get offset */
	if (get_offset(lp, partno) != 0) {
		*pp = origpart;			/* undo changes */
		return;
	}

	/* Get size */
	if (get_size(lp, partno, freep, 0) != 0 || pp->p_size == 0) {
		pp->p_size = 0;			/* effective delete */
		return;
	}

	/* Check for overlap and restore if not resolved */
	if (has_overlap(lp, freep, 0)) {
		puts("\nPlease re-enter an offset and size");
		pp->p_offset = origpart.p_offset;
		pp->p_size = origpart.p_size;
		goto getoff2;		/* Yeah, I know... */
	}

	/* get mount point */
	if (get_mp(lp, mp, partno) != 0) {
		*pp = origpart;			/* undo changes */
		return;
	}

	if (expert && (pp->p_fstype == FS_BSDFFS || pp->p_fstype == FS_UNUSED)){
		/* get fsize */
		if (get_fsize(lp, partno) != 0) {
			*pp = origpart;		/* undo changes */
			return;
		}

		/* get bsize */
		if (get_bsize(lp, partno) != 0) {
			*pp = origpart;		/* undo changes */
			return;
		}

		if (pp->p_fstype == FS_BSDFFS) {
			/* get cpg */
			if (get_cpg(lp, partno) != 0) {
				*pp = origpart;	/* undo changes */
				return;
			}
		}
	}

	/* Make sure things stay contiguous. */
	if (pp->p_size + pp->p_offset > ending_sector ||
	    has_overlap(lp, freep, -1))
		make_contiguous(lp);
}

/*
 * Delete an existing slice.
 */
void
editor_delete(struct disklabel *lp, char **mp, u_int32_t *freep, char *p)
{
	int c;

	if (p == NULL) {
		p = getstring("slice to delete",
		    "The letter of the slice to delete, a - p, or '*'.",
		    NULL);
	}
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		return;
	}
	if (p[0] == '*') {
		for (c = 0; c < lp->d_npartitions; c++) {
			if (c == RAW_PART)
				continue;

			/* Update free sector count. */
			if (lp->d_partitions[c].p_fstype != FS_UNUSED &&
			    lp->d_partitions[c].p_fstype != FS_BOOT &&
			    lp->d_partitions[c].p_size != 0)
				*freep += lp->d_partitions[c].p_size;

			(void)memset(&lp->d_partitions[c], 0,
			    sizeof(lp->d_partitions[c]));
		}
		return;
	}
	c = p[0] - 'a';
	if (c < 0 || c >= lp->d_npartitions)
		fprintf(stderr, "Slice must be between 'a' and '%c'.\n",
		    'a' + lp->d_npartitions - 1);
	else if (c >= lp->d_npartitions || (lp->d_partitions[c].p_fstype ==
	    FS_UNUSED && lp->d_partitions[c].p_size == 0))
		fprintf(stderr, "Slice '%c' is not in use.\n", 'a' + c);
	else if (c == RAW_PART)
		fputs(
"You may not delete the 'c' slice.  The 'c' slice must exist and\n"
"should span the entire disk.  By default it is of type 'unused' and so\n"
"does not take up any space.\n", stderr);
	else {
		/* Update free sector count. */
		if (lp->d_partitions[c].p_offset < ending_sector &&
		    lp->d_partitions[c].p_offset >= starting_sector &&
		    lp->d_partitions[c].p_fstype != FS_UNUSED &&
		    lp->d_partitions[c].p_fstype != FS_BOOT &&
		    lp->d_partitions[c].p_size != 0)
			*freep += lp->d_partitions[c].p_size;

		/* Really delete it (as opposed to just setting to "unused") */
		(void)memset(&lp->d_partitions[c], 0,
		    sizeof(lp->d_partitions[c]));
	}
	if (mp != NULL && mp[c] != NULL) {
		free(mp[c]);
		mp[c] = NULL;
	}
}

/*
 * Simplified display() for use with the builtin editor.
 */
void
editor_display(struct disklabel *lp, char **mp, u_int32_t *freep, char unit)
{
	int i;

	printf("device: %s\n", specname);
	printf("type: %s\n", dktypenames[lp->d_type]);
	printf("disk: %.*s\n", (int)sizeof(lp->d_typename), lp->d_typename);
	printf("label: %.*s\n", (int)sizeof(lp->d_packname), lp->d_packname);
	printf("bytes/sector: %u\n", lp->d_secsize);
	printf("sectors/track: %u\n", lp->d_nsectors);
	printf("tracks/cylinder: %u\n", lp->d_ntracks);
	printf("sectors/cylinder: %u\n", lp->d_secpercyl);
	printf("cylinders: %u\n", lp->d_ncylinders);
	printf("total sectors: %u\n", lp->d_secperunit);
	printf("free sectors: %u\n", *freep);
	printf("rpm: %hu\n", lp->d_rpm);
	printf("\n%hu slices:\n", lp->d_npartitions);
	printf("#    %13.13s %13.13s  fstype [fsize bsize  cpg]\n",
	    "size", "offset");
	for (i = 0; i < lp->d_npartitions; i++)
		display_partition(stdout, lp, mp, i, unit);
}

/*
 * Find the next reasonable starting offset and returns it.
 * Assumes there is a least one free sector left (returns 0 if not).
 */
u_int32_t
next_offset(struct disklabel *lp, u_int32_t *sizep)
{
	struct partition **spp;
	struct diskchunk *chunks;
	u_int16_t npartitions;
	u_int32_t new_offset, new_size;
	int i, good_offset;

	/* Get a sorted list of the slices */
	if ((spp = sort_partitions(lp, &npartitions)) == NULL)
		return(starting_sector);

	new_offset = starting_sector;
	for (i = 0; i < npartitions; i++ ) {
		/*
		 * Is new_offset inside this slice?  If so,
		 * make it the next sector after the slice ends.
		 */
		if (spp[i]->p_offset + spp[i]->p_size < ending_sector &&
		    ((new_offset >= spp[i]->p_offset &&
		    new_offset < spp[i]->p_offset + spp[i]->p_size) ||
		    (new_offset + *sizep >= spp[i]->p_offset && new_offset
		    + *sizep <= spp[i]->p_offset + spp[i]->p_size)))
			new_offset = spp[i]->p_offset + spp[i]->p_size;
	}

	/* Did we find a suitable offset? */
	for (good_offset = 1, i = 0; i < npartitions; i++ ) {
		if (new_offset + *sizep >= spp[i]->p_offset &&
		    new_offset + *sizep <= spp[i]->p_offset + spp[i]->p_size) {
			/* Nope */
			good_offset = 0;
			break;
		}
	}

	/* Specified size is too big, find something that fits */
	if (!good_offset) {
		chunks = free_chunks(lp);
		new_size = 0;
		for (i = 0; chunks[i].start != 0 || chunks[i].stop != 0; i++) {
			if (chunks[i].stop - chunks[i].start > new_size) {
			    new_size = chunks[i].stop - chunks[i].start;
			    new_offset = chunks[i].start;
			}
		}
		/* XXX - should do something intelligent if new_size == 0 */
		*sizep = new_size;
	}

	(void)free(spp);
	return(new_offset);
}

/*
 * Change the size of an existing slice.
 */
void
editor_change(struct disklabel *lp, u_int32_t *freep, char *p)
{
	int partno;
	u_int32_t newsize;
	struct partition *pp;

	if (p == NULL) {
		p = getstring("slice to change size",
		    "The letter of the slice to change size, a - p.", NULL);
	}
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		return;
	}
	partno = p[0] - 'a';
	if (partno < 0 || partno >= lp->d_npartitions) {
		fprintf(stderr, "Slice must be between 'a' and '%c'.\n",
		    'a' + lp->d_npartitions - 1);
		return;
	} else if (partno >= lp->d_npartitions ||
	    lp->d_partitions[partno].p_size == 0) {
		fprintf(stderr, "Slice '%c' is not in use.\n", 'a' + partno);
		return;
	}
	pp = &lp->d_partitions[partno];

	printf("Slice %c is currently %u sectors in size (%u free).\n",
	    partno + 'a', pp->p_size, *freep);
	/* XXX - make maxsize lp->d_secperunit if FS_UNUSED/FS_BOOT? */
	newsize = getuint(lp, partno, "new size", "Size of the slice.  "
	    "You may also say +/- amount for a relative change.",
	    pp->p_size, pp->p_size + *freep, pp->p_offset, DO_CONVERSIONS |
	    (pp->p_fstype == FS_BSDFFS ? DO_ROUNDING : 0));
	if (newsize == UINT_MAX - 1) {
		fputs("Command aborted\n", stderr);
		return;
	} else if (newsize == UINT_MAX) {
		fputs("Invalid entry\n", stderr);
		return;
	} else if (newsize == pp->p_size)
		return;

	if (pp->p_fstype != FS_UNUSED && pp->p_fstype != FS_BOOT) {
		if (newsize > pp->p_size) {
			if (newsize - pp->p_size > *freep) {
				fprintf(stderr,
				    "Only %u sectors free, you asked for %u\n",
				    *freep, newsize - pp->p_size);
				return;
			}
			*freep -= newsize - pp->p_size;
		} else if (newsize < pp->p_size) {
			*freep += pp->p_size - newsize;
		}
	} else {
		if (partno == RAW_PART && newsize +
		    pp->p_offset > lp->d_secperunit) {
			fputs("'c' slice may not be larger than the disk\n",
			    stderr);
			return;
		}
	}
	pp->p_size = newsize;
	if (newsize + pp->p_offset > ending_sector ||
	    has_overlap(lp, freep, -1))
		make_contiguous(lp);
}

void
make_contiguous(struct disklabel *lp)
{
	struct partition **spp;
	u_int16_t npartitions;
	int i;

	/* Get a sorted list of the slices */
	if ((spp = sort_partitions(lp, &npartitions)) == NULL)
		return;

	/*
	 * Make everything contiguous but don't muck with start of the first one
	 * or slices not in the BSD part of the label.
	 */
	for (i = 1; i < npartitions; i++) {
		if (spp[i]->p_offset >= starting_sector ||
		    spp[i]->p_offset < ending_sector)
			spp[i]->p_offset =
			    spp[i - 1]->p_offset + spp[i - 1]->p_size;
	}

	(void)free(spp);
}

/*
 * Sort the slices based on starting offset.
 * This assumes there can be no overlap.
 */
int
partition_cmp(const void *e1, const void *e2)
{
	struct partition *p1 = *(struct partition **)e1;
	struct partition *p2 = *(struct partition **)e2;

	if (p1->p_offset < p2->p_offset)
		return -1;
	else if (p1->p_offset > p2->p_offset)
		return 1;
	else
		return 0;
}

char *
getstring(char *prompt, char *helpstring, char *oval)
{
	static char buf[BUFSIZ];
	int n;

	buf[0] = '\0';
	do {
		printf("%s: [%s] ", prompt, oval ? oval : "");
		if (fgets(buf, sizeof(buf), stdin) == NULL) {
			buf[0] = '\0';
			if (feof(stdin)) {
				clearerr(stdin);
				putchar('\n');
				return(NULL);
			}
		}
		n = strlen(buf);
		if (n > 0 && buf[n-1] == '\n')
			buf[--n] = '\0';
		if (buf[0] == '?')
			puts(helpstring);
		else if (oval != NULL && buf[0] == '\0')
			strlcpy(buf, oval, sizeof(buf));
	} while (buf[0] == '?');

	return(&buf[0]);
}

/*
 * Returns UINT_MAX on error
 * Usually only called by helper functions.
 */
u_int32_t
getuint(struct disklabel *lp, int partno, char *prompt, char *helpstring,
    u_int32_t oval, u_int32_t maxval, u_int32_t offset, int flags)
{
	char buf[BUFSIZ], *endptr, *p, operator = '\0';
	u_int32_t rval = oval;
	size_t n;
	int mult = 1;
	double d, percent = 1.0;

	/* We only care about the remainder */
	offset = offset % lp->d_secpercyl;

	buf[0] = '\0';
	do {
		printf("%s: [%u] ", prompt, oval);
		if (fgets(buf, sizeof(buf), stdin) == NULL) {
			buf[0] = '\0';
			if (feof(stdin)) {
				clearerr(stdin);
				putchar('\n');
				return(UINT_MAX - 1);
			}
		}
		n = strlen(buf);
		if (n > 0 && buf[n-1] == '\n')
			buf[--n] = '\0';
		if (buf[0] == '?')
			puts(helpstring);
	} while (buf[0] == '?');

	if (buf[0] == '*' && buf[1] == '\0') {
		rval = maxval;
	} else {
		/* deal with units */
		if (buf[0] != '\0' && n > 0) {
			if ((flags & DO_CONVERSIONS)) {
				switch (tolower(buf[n-1])) {

				case 'c':
					mult = lp->d_secpercyl;
					buf[--n] = '\0';
					break;
				case 'b':
					mult = -lp->d_secsize;
					buf[--n] = '\0';
					break;
				case 'k':
					mult = 1024 / lp->d_secsize;
					buf[--n] = '\0';
					break;
				case 'm':
					mult = 1048576 / lp->d_secsize;
					buf[--n] = '\0';
					break;
				case 'g':
					mult = 1073741824 / lp->d_secsize;
					buf[--n] = '\0';
					break;
				case '%':
					buf[--n] = '\0';
					percent = strtod(buf, NULL) / 100.0;
					snprintf(buf, sizeof(buf), "%d",
					    lp->d_secperunit);
					break;
				case '&':
					buf[--n] = '\0';
					percent = strtod(buf, NULL) / 100.0;
					snprintf(buf, sizeof(buf), "%d",
					    maxval);
					break;
				}
			}

			/* Did they give us an operator? */
			p = &buf[0];
			if (*p == '+' || *p == '-')
				operator = *p++;

			endptr = p;
			errno = 0;
			d = strtod(p, &endptr);
			if (errno == ERANGE)
				rval = UINT_MAX;	/* too big/small */
			else if (*endptr != '\0') {
				errno = EINVAL;		/* non-numbers in str */
				rval = UINT_MAX;
			} else {
				/* XXX - should check for overflow */
				if (mult > 0)
					rval = d * mult * percent;
				else
					/* Negative mult means divide (fancy) */
					rval = d / (-mult) * percent;

				/* Apply the operator */
				if (operator == '+')
					rval += oval;
				else if (operator == '-')
					rval = oval - rval;
			}
		}
	}
	if ((flags & DO_ROUNDING) && rval < UINT_MAX) {
#ifndef CYLCHECK
		/* Round to nearest cylinder unless given in sectors */
		if (mult != 1)
#endif
		{
			u_int32_t cyls;

			/* If we round up past the end, round down instead */
			cyls = (u_int32_t)((rval / (double)lp->d_secpercyl)
			    + 0.5);
			if (cyls != 0 && lp->d_secpercyl != 0) {
				if ((cyls * lp->d_secpercyl) - offset > maxval)
					cyls--;

				if (rval != (cyls * lp->d_secpercyl) - offset) {
					rval = (cyls * lp->d_secpercyl) - offset;
					printf("Rounding to nearest cylinder: %u\n",
					    rval);
				}
			}
		}
	}

	return(rval);
}

/*
 * Check for slice overlap in lp and prompt the user
 * to resolve the overlap if any is found.  Returns 1
 * if unable to resolve, else 0.
 */
int
has_overlap(struct disklabel *lp, u_int32_t *freep, int resolve)
{
	struct partition **spp;
	u_int16_t npartitions;
	int c, i, j;
	char buf[BUFSIZ];

	/* Get a sorted list of the partitions */
	spp = sort_partitions(lp, &npartitions);

	if (npartitions < RAW_PART) {
		(void)free(spp);
		return(0);			/* nothing to do */
	}

	/* Now that we have things sorted by starting sector check overlap */
	for (i = 0; i < npartitions; i++) {
		for (j = i + 1; j < npartitions; j++) {
			/* `if last_sec_in_part + 1 > first_sec_in_next_part' */
			if (spp[i]->p_offset + spp[i]->p_size > spp[j]->p_offset) {
				/* Don't print, just return */
				if (resolve == -1) {
					(void)free(spp);
					return(1);
				}

				/* Overlap!  Convert to real part numbers. */
				i = ((char *)spp[i] - (char *)lp->d_partitions)
				    / sizeof(**spp);
				j = ((char *)spp[j] - (char *)lp->d_partitions)
				    / sizeof(**spp);
				printf("\nError, slices %c and %c overlap:\n",
				    'a' + i, 'a' + j);
				printf("#    %13.13s %13.13s  fstype "
				    "[fsize bsize  cpg]\n", "size", "offset");
				display_partition(stdout, lp, NULL, i, 0);
				display_partition(stdout, lp, NULL, j, 0);

				/* Did they ask us to resolve it ourselves? */
				if (resolve != 1) {
					(void)free(spp);
					return(1);
				}

				/* Get slice to disable or ^D */
				do {
					printf("Disable which one? (^D to abort) [%c %c] ",
					    'a' + i, 'a' + j);
					buf[0] = '\0';
					if (!fgets(buf, sizeof(buf), stdin)) {
						putchar('\n');
						return(1);	/* ^D */
					}
					c = buf[0] - 'a';
				} while (buf[1] != '\n' && buf[1] != '\0' &&
				    c != i && c != j);

				/* Mark the selected one as unused */
				lp->d_partitions[c].p_fstype = FS_UNUSED;
				*freep += lp->d_partitions[c].p_size;
				(void)free(spp);
				return(has_overlap(lp, freep, resolve));
			}
		}
	}

	(void)free(spp);
	return(0);
}

void
edit_parms(struct disklabel *lp, u_int32_t *freep)
{
	char *p;
	u_int32_t ui;
	struct disklabel oldlabel = *lp;

	printf("Changing device parameters for %s:\n", specname);

	/* disk type */
	for (;;) {
		p = getstring("disk type",
		    "What kind of disk is this?  Usually SCSI, ESDI, ST506, or "
		    "floppy (use ESDI for IDE).", dktypenames[lp->d_type]);
		if (p == NULL) {
			fputs("Command aborted\n", stderr);
			return;
		}
		if (strcasecmp(p, "IDE") == 0)
			ui = DTYPE_ESDI;
		else
			for (ui = 1; ui < DKMAXTYPES &&
			    strcasecmp(p, dktypenames[ui]); ui++)
				;
		if (ui < DKMAXTYPES) {
			break;
		} else {
			printf("\"%s\" is not a valid disk type.\n", p);
			fputs("Valid types are: ", stdout);
			for (ui = 1; ui < DKMAXTYPES; ui++) {
				printf("\"%s\"", dktypenames[ui]);
				if (ui < DKMAXTYPES - 1)
					fputs(", ", stdout);
			}
			putchar('\n');
		}
	}
	lp->d_type = ui;

	/* pack/label id */
	p = getstring("label name",
	    "15 char string that describes this label, usually the disk name.",
	    lp->d_packname);
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		*lp = oldlabel;		/* undo damage */
		return;
	}
	strncpy(lp->d_packname, p, sizeof(lp->d_packname));	/* checked */

	/* sectors/track */
	for (;;) {
		ui = getuint(lp, 0, "sectors/track",
		    "The Numer of sectors per track.", lp->d_nsectors,
		    lp->d_nsectors, 0, 0);
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*lp = oldlabel;		/* undo damage */
			return;
		} if (ui == UINT_MAX)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	lp->d_nsectors = ui;

	/* tracks/cylinder */
	for (;;) {
		ui = getuint(lp, 0, "tracks/cylinder",
		    "The number of tracks per cylinder.", lp->d_ntracks,
		    lp->d_ntracks, 0, 0);
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*lp = oldlabel;		/* undo damage */
			return;
		} else if (ui == UINT_MAX)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	lp->d_ntracks = ui;

	/* sectors/cylinder */
	for (;;) {
		ui = getuint(lp, 0, "sectors/cylinder",
		    "The number of sectors per cylinder (Usually sectors/track "
		    "* tracks/cylinder).", lp->d_secpercyl, lp->d_secpercyl,
		    0, 0);
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*lp = oldlabel;		/* undo damage */
			return;
		} else if (ui == UINT_MAX)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	lp->d_secpercyl = ui;

	/* number of cylinders */
	for (;;) {
		ui = getuint(lp, 0, "number of cylinders",
		    "The total number of cylinders on the disk.",
		    lp->d_ncylinders, lp->d_ncylinders, 0, 0);
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*lp = oldlabel;		/* undo damage */
			return;
		} else if (ui == UINT_MAX)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	lp->d_ncylinders = ui;

	/* total sectors */
	for (;;) {
		ui = getuint(lp, 0, "total sectors",
		    "The total number of sectors on the disk.",
		    lp->d_secperunit ? lp->d_secperunit :
		    lp->d_ncylinders * lp->d_ncylinders,
		    lp->d_ncylinders * lp->d_ncylinders, 0, 0);
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*lp = oldlabel;		/* undo damage */
			return;
		} else if (ui == UINT_MAX)
			fputs("Invalid entry\n", stderr);
		else if (ui > lp->d_secperunit &&
		    ending_sector == lp->d_secperunit) {
			/* grow free count */
			*freep += ui - lp->d_secperunit;
			puts("You may want to increase the size of the 'c' "
			    "slice.");
			break;
		} else if (ui < lp->d_secperunit &&
		    ending_sector == lp->d_secperunit) {
			/* shrink free count */
			if (lp->d_secperunit - ui > *freep)
				fprintf(stderr,
				    "Not enough free space to shrink by %u "
				    "sectors (only %u sectors left)\n",
				    lp->d_secperunit - ui, *freep);
			else {
				*freep -= lp->d_secperunit - ui;
				break;
			}
		} else
			break;
	}
	/* Adjust ending_sector if necessary. */
	if (ending_sector > ui)
		ending_sector = ui;
	lp->d_secperunit = ui;

	/* rpm */
	for (;;) {
		ui = getuint(lp, 0, "rpm",
		  "The rotational speed of the disk in revolutions per minute.",
		  lp->d_rpm, lp->d_rpm, 0, 0);
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*lp = oldlabel;		/* undo damage */
			return;
		} else if (ui == UINT_MAX)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	lp->d_rpm = ui;

	/* interleave */
	for (;;) {
		ui = getuint(lp, 0, "interleave",
		  "The physical sector interleave, set when formatting.  Almost always 1.",
		  lp->d_interleave, lp->d_interleave, 0, 0);
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*lp = oldlabel;		/* undo damage */
			return;
		} else if (ui == UINT_MAX || ui == 0)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	lp->d_interleave = ui;
}

struct partition **
sort_partitions(struct disklabel *lp, u_int16_t *npart)
{
	u_int16_t npartitions;
	struct partition **spp;
	int i;

	/* How many "real" slices do we have? */
	for (npartitions = 0, i = 0; i < lp->d_npartitions; i++) {
		if (lp->d_partitions[i].p_fstype != FS_UNUSED &&
		    lp->d_partitions[i].p_fstype != FS_BOOT &&
		    lp->d_partitions[i].p_size != 0)
			npartitions++;
	}
	if (npartitions == 0) {
		*npart = 0;
		return(NULL);
	}

	/* Create an array of pointers to the slice data */
	if ((spp = malloc(sizeof(struct partition *) * npartitions)) == NULL)
		errx(4, "out of memory");
	for (npartitions = 0, i = 0; i < lp->d_npartitions; i++) {
		if (lp->d_partitions[i].p_fstype != FS_UNUSED &&
		    lp->d_partitions[i].p_fstype != FS_BOOT &&
		    lp->d_partitions[i].p_size != 0)
			spp[npartitions++] = &lp->d_partitions[i];
	}

	/*
	 * Sort the partitions based on starting offset.
	 * This is safe because we guarantee no overlap.
	 */
	if (npartitions > 1)
		if (heapsort((void *)spp, npartitions, sizeof(spp[0]),
		    partition_cmp))
			err(4, "failed to sort disklabel");

	*npart = npartitions;
	return(spp);
}

/*
 * Get a valid disk type if necessary.
 */
void
getdisktype(struct disklabel *lp, char *banner, char *dev)
{
	int i;
	char *s, *def = "SCSI";
	struct dtypes {
		char *dev;
		char *type;
	} dtypes[] = {
		{ "raid", "SCSI" },
		{ "sd",   "SCSI" },
		{ "rz",   "SCSI" },
		{ "wd",   "IDE" },
		{ "fd",   "FLOPPY" },
		{ "xd",   "SMD" },
		{ "xy",   "SMD" },
		{ "hd",   "HP-IB" },
		{ "ccd",  "CCD" },
		{ "vnd",  "VND" },
		{ "svnd", "VND" },
		{ NULL,   NULL }
	};

	if ((s = basename(dev)) != NULL) {
		if (*s == 'r')
			s++;
		i = strcspn(s, "0123456789");
		s[i] = '\0';
		dev = s;
		for (i = 0; dtypes[i].dev != NULL; i++) {
			if (strcmp(dev, dtypes[i].dev) == 0) {
				def = dtypes[i].type;
				break;
			}
		}
	}

	if (lp->d_type > DKMAXTYPES || lp->d_type == 0) {
		puts(banner);
		puts("Possible values are:");
		printf("\"IDE\", ");
		for (i = 1; i < DKMAXTYPES; i++) {
			printf("\"%s\"", dktypenames[i]);
			if (i < DKMAXTYPES - 1)
				fputs(", ", stdout);
		}
		putchar('\n');

		for (;;) {
			s = getstring("Disk type",
			    "What kind of disk is this?  Usually SCSI, IDE, "
			    "ESDI, CCD, ST506, or floppy.", def);
			if (s == NULL)
				continue;
			if (strcasecmp(s, "IDE") == 0) {
				lp->d_type = DTYPE_ESDI;
				return;
			}
			for (i = 1; i < DKMAXTYPES; i++)
				if (strcasecmp(s, dktypenames[i]) == 0) {
					lp->d_type = i;
					return;
				}
			printf("\"%s\" is not a valid disk type.\n", s);
			fputs("Valid types are: ", stdout);
			for (i = 1; i < DKMAXTYPES; i++) {
				printf("\"%s\"", dktypenames[i]);
				if (i < DKMAXTYPES - 1)
					fputs(", ", stdout);
			}
			putchar('\n');
		}
	}
}

/*
 * Get beginning and ending sectors of the MirBSD portion of the disk
 * from the user.
 * XXX - should mention MBR values if DOSLABEL
 */
void
set_bounds(struct disklabel *lp, u_int32_t *freep)
{
	u_int32_t ui, start_temp;

	/* Starting sector */
	do {
		ui = getuint(lp, 0, "Starting sector",
		  "The start of the MirBSD portion of the disk.",
		  starting_sector, lp->d_secperunit, 0, 0);
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return;
		}
	} while (ui >= lp->d_secperunit);
	start_temp = ui;

	/* Size */
	do {
		ui = getuint(lp, 0, "Size ('*' for entire disk)",
		  "The size of the MirBSD portion of the disk ('*' for the "
		  "entire disk).", ending_sector - starting_sector,
		  lp->d_secperunit - start_temp, 0, 0);
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return;
		}
	} while (ui > lp->d_secperunit - start_temp);
	ending_sector = start_temp + ui;
	starting_sector = start_temp;

	/* Recalculate the free sectors */
	editor_countfree(lp, freep);
}

/*
 * Return a list of the "chunks" of free space available
 */
struct diskchunk *
free_chunks(struct disklabel *lp)
{
	u_int16_t npartitions;
	struct partition **spp;
	static struct diskchunk chunks[MAXPARTITIONS + 2];
	int i, numchunks;

	/* Sort the slices based on offset */
	spp = sort_partitions(lp, &npartitions);

	/* If there are no partitions, it's all free. */
	if (spp == NULL) {
		chunks[0].start = starting_sector;
		chunks[0].stop = ending_sector;
		chunks[1].start = chunks[1].stop = 0;
		return(chunks);
	}

	/* Find chunks of free space */
	numchunks = 0;
	if (spp && spp[0]->p_offset > 0) {
		chunks[0].start = starting_sector;
		chunks[0].stop = spp[0]->p_offset;
		numchunks++;
	}
	for (i = 0; i < npartitions; i++) {
		if (i + 1 < npartitions) {
			if (spp[i]->p_offset + spp[i]->p_size < spp[i+1]->p_offset) {
				chunks[numchunks].start =
				    spp[i]->p_offset + spp[i]->p_size;
				chunks[numchunks].stop = spp[i+1]->p_offset;
				numchunks++;
			}
		} else {
			/* Last partition */
			if (spp[i]->p_offset + spp[i]->p_size < ending_sector) {

				chunks[numchunks].start =
				    spp[i]->p_offset + spp[i]->p_size;
				chunks[numchunks].stop = ending_sector;
				numchunks++;
			}
		}
	}

	/* Terminate and return */
	chunks[numchunks].start = chunks[numchunks].stop = 0;
	(void)free(spp);
	return(chunks);
}

/*
 * What is the MirBSD portion of the disk?  Uses the MBR if applicable.
 */
void
find_bounds(struct disklabel *lp, struct disklabel *bios_lp)
{
#ifdef DOSLABEL
	struct partition *pp = &lp->d_partitions[RAW_PART];
#endif
	/* Defaults */
	/* XXX - reserve a cylinder for hp300? */
	starting_sector = 0;
	ending_sector = lp->d_secperunit;

#ifdef DOSLABEL
	/*
	 * If we have an MBR, use values from the {Mir,Open,Free,Net}BSD partition
	 */
	if (dosdp) {
	    if (dosdp->dp_typ == DOSPTYP_MIRBSD ||
		    dosdp->dp_typ == DOSPTYP_OPENBSD ||
		    dosdp->dp_typ == DOSPTYP_FREEBSD ||
		    dosdp->dp_typ == DOSPTYP_NETBSD) {
			u_int32_t i, new_end;

			/* Set start and end based on fdisk partition bounds */
			starting_sector = get_le(&dosdp->dp_start);
			ending_sector = starting_sector + get_le(&dosdp->dp_size);

			/*
			 * If the ending sector of the BSD fdisk partition
			 * is equal to the ending sector of the BIOS geometry
			 * but the real sector count > BIOS sector count,
			 * adjust the bounds accordingly.  We do this because
			 * the BIOS geometry is limited to disks of ~4gig.
			 */
			if (bios_lp && ending_sector == bios_lp->d_secperunit &&
			    lp->d_secperunit > bios_lp->d_secperunit)
				ending_sector = lp->d_secperunit;

			/*
			 * If there are any BSD or SWAP partitions beyond
			 * ending_sector we extend ending_sector to include
			 * them.  This is done because the BIOS geometry is
			 * generally different from the disk geometry.
			 */
			for (i = new_end = 0; i < lp->d_npartitions; i++) {
				pp = &lp->d_partitions[i];
				if ((pp->p_fstype == FS_BSDFFS ||
				    pp->p_fstype == FS_SWAP) &&
				    pp->p_size + pp->p_offset > new_end)
					new_end = pp->p_size + pp->p_offset;
			}
			if (new_end > ending_sector)
				ending_sector = new_end;
		} else {
			/* Don't trounce the MBR */
			starting_sector = 63;
		}

		printf("\nTreating sectors %u-%u as the MirBSD portion of the "
		    "disk.\nYou can use the 'b' command to change this.\n",
		    starting_sector, ending_sector);
	}
#elif (NUMBOOT == 1)
	/* Boot blocks take up the first cylinder */
	starting_sector = lp->d_secpercyl;
	printf("\nReserving the first data cylinder for boot blocks.\n"
	    "You can use the 'b' command to change this.\n");
#endif
}

/*
 * Calculate free space.
 */
void
editor_countfree(struct disklabel *lp, u_int32_t *freep)
{
	struct partition *pp;
	int i;

	*freep = ending_sector - starting_sector;
	for (i = 0; i < lp->d_npartitions; i++) {
		    pp = &lp->d_partitions[i];
		    if (pp->p_fstype != FS_UNUSED && pp->p_fstype != FS_BOOT &&
			pp->p_size > 0 &&
			pp->p_offset + pp->p_size <= ending_sector &&
			pp->p_offset >= starting_sector)
			*freep -= pp->p_size;
	}
}

void
editor_help(char *arg)
{

	/* XXX - put these strings in a table instead? */
	switch (*arg) {
	case 'p':
		puts(
"The 'p' command prints the current disk label.  By default, it prints the\n"
"size and offset in sectors (a sector is usually 512 bytes).  The 'p' command\n"
"takes an optional units argument.  Possible values are 'b' for bytes, 'c'\n"
"for cylinders, 'k' for kilobytes, 'm' for megabytes, and 'g' for gigabytes.\n");
		break;
	case 'M':
		puts(
"The 'M' command pipes the entire MirBSD manual page for disk label through\n"
"the pager specified by the PAGER environment variable or 'less' if PAGER is\n"
"not set.  It is especially useful during install when the normal system\n"
"manual is not available.\n");
		break;
	case 'e':
		puts(
"The 'e' command is used to edit the disk drive parameters.  These include\n"
"the number of sectors/track, tracks/cylinder, sectors/cylinder, number of\n"
"cylinders on the disk , total sectors on the disk, rpm, interleave, disk\n"
"type, and a descriptive label string.  You should not change these unless\n"
"you know what you are doing\n");
		break;
	case 'a':
		puts(
"The 'a' command adds new slices to the disk.  It takes as an optional\n"
"argument the slice letter to add.  If you do not specify a slice\n"
"letter, you will be prompted for it; the next available letter will be the\n"
"default answer\n");
		break;
	case 'b':
		puts(
"The 'b' command is used to change the boundaries of the MirBSD portion of\n"
"the disk.  This is only useful on disks with an fdisk partition.  By default,\n"
"on a disk with an fdisk partition, the boundaries are set to be the first\n"
"and last sectors of the MirBSD fdisk partition.  You should only change\n"
"these if your fdisk partition table is incorrect or you have a disk larger\n"
"than 8gig, since 8gig is the maximum size an fdisk partition can be.  You\n"
"may enter '*' at the 'Size' prompt to indicate the entire size of the disk\n"
"(minus the starting sector).  Use this option with care; if you extend the\n"
"boundaries such that they overlap with another operating system you will\n"
"corrupt the other operating system's data.\n");
		break;
	case 'c':
		puts(
"The 'c' command is used to change the size of an existing slice.  It\n"
"takes as an optional argument the slice letter to change.  If you do not\n"
"specify a slice letter, you will be prompted for one.  You may add a '+'\n"
"or '-' prefix to the new size to increase or decrease the existing value\n"
"instead of entering an absolute value.  You may also use a suffix to indicate\n"
"the units the values is in terms of.  Possible suffixes are 'b' for bytes,\n"
"'c' for cylinders, 'k' for kilobytes, 'm' for megabytes, 'g' for gigabytes or\n"
"no suffix for sectors (usually 512 bytes).  You may also enter '*' to change\n"
"the size to be the total number of free sectors remaining.\n");
		break;
	case 'D':
		puts(
"The 'D' command will set the disk label to the default values as reported\n"
"by the disk itself.  This similates the case where there is no disk label.\n");
		break;
	case 'd':
		puts(
"The 'd' command is used to delete an existing slice.  It takes as an\n"
"optional argument the slice letter to change.  If you do not specify a\n"
"slice letter, you will be prompted for one.  You may not delete the ``c''\n"
"slice as 'c' must always exist and by default is marked as 'unused' (so\n"
"it does not take up any space).\n");
		break;
	case 'g':
		puts(
"The 'g' command is used select which disk geometry to use, the disk, BIOS, or\n"
"user geometry.  It takes as an optional argument ``d'', ``b'', or ``u''.  If \n"
"you do not specify the type as an argument, you will be prompted for it.\n");
		break;
	case 'm':
		puts(
"The 'm' command is used to modify an existing slice.  It takes as an\n"
"optional argument the slice letter to change.  If you do not specify a\n"
"slice letter, you will be prompted for one.  This option allows the user\n"
"to change the filesystem type, starting offset, slice size, block fragment\n"
"size, block size, and cylinders per group for the specified slice (not all\n"
"parameters are configurable for non-BSD slices).\n");
		break;
	case 'n':
		puts(
"The 'n' command is used to set the mount point for a slice (ie: name it).\n"
"It takes as an optional argument the slice letter to name.  If you do\n"
"not specify a slice letter, you will be prompted for one.  This option\n"
"is only valid if disklabel was invoked with the -F flag.\n");
		break;
	case 'r':
		puts(
"The 'r' command is used to recalculate the free space available.  This option\n"
"should really not be necessary under normal circumstances but can be useful if\n"
"disklabel gets confused.\n");
		break;
	case 'u':
		puts(
"The 'u' command will undo (or redo) the last change.  Entering 'u' once will\n"
"undo your last change.  Entering it again will restore the change.\n");
		break;
	case 's':
		puts(
"The 's' command is used to save a copy of the label to a file in ascii format\n"
"(suitable for loading via disklabel's [-R] option).  It takes as an optional\n"
"argument the filename to save the label to.  If you do not specify a filename,\n"
"you will be prompted for one.\n");
		break;
	case 'w':
		puts(
"The 'w' command will write the current label to disk.  This option will\n"
"commit any changes to the on-disk label.\n");
		break;
	case 'q':
		puts(
"The 'q' command quits the label editor.  If any changes have been made you\n"
"will be asked whether or not to save the changes to the on-disk label.\n");
		break;
	case 'X':
		puts(
"The 'X' command toggles disklabel in to/out of 'expert mode'.  By default,\n"
"some settings are reserved for experts only (such as the block and fragment\n"
"size on ffs slices).\n");
		break;
	case 'x':
		puts(
"The 'x' command exits the label editor without saving any changes to the\n"
"on-disk label.\n");
		break;
	case 'z':
		puts(
"The 'z' command zeroes out the existing disklabel, leaving only the 'c'\n"
"slice.  The drive parameters are not changed.\n");
		break;
	default:
		puts("Available commands:");
		puts("\t? [cmnd]  - this message or command specific help.");
		puts("\ta [part]  - add new slice.");
		puts("\tb         - set MirBSD disk boundaries.");
		puts("\tc [part]  - change slice size.");
		puts("\tD         - set label to default.");
		puts("\td [part]  - delete slice.");
		puts("\te         - edit drive parameters.");
		puts("\tg [b|d|u] - use [b]ios, [d]isk or [u]ser geometry.");
		puts("\tM         - show entire MirBSD man page for disklabel.");
		puts("\tm [part]  - modify existing slice.");
		puts("\tn [part]  - set the mount point for a slice.");
		puts("\tp [unit]  - print label.");
		puts("\tq         - quit and save changes.");
		puts("\tr         - recalculate free space.");
		puts("\ts [path]  - save label to file.");
		puts("\tu         - undo last change.");
		puts("\tw         - write label to disk.");
		puts("\tX         - toggle expert mode.");
		puts("\tx         - exit without saving changes.");
		puts("\tz         - zero out slice table.");
		puts(
"Numeric parameters may use suffixes to indicate units:\n\t"
"'b' for bytes, 'c' for cylinders, 'k' for kilobytes, 'm' for megabytes,\n\t"
"'g' for gigabytes or no suffix for sectors (usually 512 bytes).\n\t"
"'%' for percent of total disk size, '&' for percent of free space.\n\t"
"Non-sector units will be rounded to the nearest cylinder.\n"
"Entering '?' at most prompts will give you (simple) context sensitive help.");
		break;
	}
}

char **
mpcopy(char **to, char **from)
{
	int i;
	char *top;

	for (i = 0; i < MAXPARTITIONS; i++) {
		if (from[i] != NULL) {
			int len = strlen(from[i]) + 1;

			top = realloc(to[i], len);
			if (top == NULL)
				errx(4, "out of memory");
			to[i] = top;
			(void)strlcpy(to[i], from[i], len);
		} else if (to[i] != NULL) {
			free(to[i]);
			to[i] = NULL;
		}
	}
	return(to);
}

int
mpequal(char **mp1, char **mp2)
{
	int i;

	for (i = 0; i < MAXPARTITIONS; i++) {
		if (mp1[i] == NULL && mp2[i] == NULL)
			continue;

		if ((mp1[i] != NULL && mp2[i] == NULL) ||
		    (mp1[i] == NULL && mp2[i] != NULL) ||
		    (strcmp(mp1[i], mp2[i]) != 0))
			return(0);
	}
	return(1);
}

int
mpsave(struct disklabel *lp, char **mp, char *cdev, char *fstabfile)
{
	int i, j, mpset;
	char bdev[MAXPATHLEN], *p;
	struct mountinfo mi[MAXPARTITIONS];
	FILE *fp;

	memset(&mi, 0, sizeof(mi));

	for (i = 0, mpset = 0; i < MAXPARTITIONS; i++) {
		if (mp[i] != NULL) {
			mi[i].mountpoint = mp[i];
			mi[i].partno = i;
			mpset = 1;
		}
	}
	/* Exit if there is nothing to do... */
	if (!mpset)
		return(0);

	/* Convert cdev to bdev */
	if (strncmp(_PATH_DEV, cdev, sizeof(_PATH_DEV) - 1) == 0 &&
	    cdev[sizeof(_PATH_DEV) - 1] == 'r') {
		snprintf(bdev, sizeof(bdev), "%s%s", _PATH_DEV,
		    &cdev[sizeof(_PATH_DEV)]);
	} else {
		if ((p = strrchr(cdev, '/')) == NULL || *(++p) != 'r')
			return(1);
		*p = '\0';
		snprintf(bdev, sizeof(bdev), "%s%s", cdev, p + 1);
		*p = 'r';
	}
	bdev[strlen(bdev) - 1] = '\0';

	/* Sort mountpoints so we don't try to mount /usr/local before /usr */
	qsort((void *)mi, MAXPARTITIONS, sizeof(struct mountinfo), micmp);

	if ((fp = fopen(fstabfile, "w")) == NULL)
		return(1);

	for (i = 0; i < MAXPARTITIONS && mi[i].mountpoint != NULL; i++) {
		j =  mi[i].partno;
		fprintf(fp, "%s%c %s %s rw 1 %d\n", bdev, 'a' + j,
		    mi[i].mountpoint,
		    fstypesnames[lp->d_partitions[j].p_fstype],
		    j == 0 ? 1 : 2);
	}
	fclose(fp);
	return(0);
}

int
get_offset(struct disklabel *lp, int partno)
{
	u_int32_t ui;
	struct partition *pp = &lp->d_partitions[partno];

	for (;;) {
		ui = getuint(lp, partno, "offset",
		   "Starting sector for this slice.", pp->p_offset,
		   pp->p_offset, 0, DO_CONVERSIONS |
		   (pp->p_fstype == FS_BSDFFS ? DO_ROUNDING : 0));
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return(1);
		} else if (ui == UINT_MAX)
			fputs("Invalid entry\n", stderr);
		else if (ui < starting_sector)
			fprintf(stderr, "The MirBSD portion of the disk starts"
			    " at sector %u, you tried to add a slice at %u."
			    "  You can use the 'b' command to change the size "
			    "of the MirBSD portion.\n" , starting_sector, ui);
		else if (ui >= ending_sector)
			fprintf(stderr, "The MirBSD portion of the disk ends "
			    "at sector %u, you tried to add a slice at %u."
			    "  You can use the 'b' command to change the size "
			    "of the MirBSD portion.\n", ending_sector, ui);
#ifdef AAT0
		else if (partno == 0 && ui != 0)
			fprintf(stderr, "This architecture requires that "
			    "slice 'a' start at sector 0.\n");
#endif
		else
			break;
	}
	pp->p_offset = ui;
	return(0);
}

int
get_size(struct disklabel *lp, int partno, u_int32_t *freep, int new)
{
	u_int32_t ui;
	struct partition *pp = &lp->d_partitions[partno];

	for (;;) {
		ui = getuint(lp, partno, "size", "Size of the slice.",
		    pp->p_size, *freep, pp->p_offset, DO_CONVERSIONS |
		    ((pp->p_fstype == FS_BSDFFS || pp->p_fstype == FS_SWAP) ?
		    DO_ROUNDING : 0));
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return(1);
		} else if (ui == UINT_MAX) {
			fputs("Invalid entry\n", stderr);
			continue;
		}
		if (new) {
			if (ui > *freep)
				/* XXX - steal space from another slice */
				fprintf(stderr,"Sorry, there are only %u "
				    "sectors left\n", *freep);
			else if (pp->p_offset + ui > ending_sector)
				fprintf(stderr, "The MirBSD portion of the "
				    "disk ends at sector %u, you tried to add "
				    "a slice ending at sector %u.  You can "
				    "use the 'b' command to change the size of "
				    "the MirBSD portion.\n",
				    ending_sector, pp->p_offset + ui);
			else
				break;			/* ok */
		} else {
			if (ui == pp->p_size)
				break;			/* no change */
			if (partno == RAW_PART &&
			    ui + pp->p_offset > lp->d_secperunit) {
				fputs("'c' slice may not be larger than the disk\n",
				    stderr);
			} else if (pp->p_fstype == FS_UNUSED ||
			    pp->p_fstype == FS_BOOT) {
				/* don't care what's free */
				pp->p_size = ui;
				break;
			} else {
				if (ui > pp->p_size + *freep)
					/* XXX - steal from another slice */
					fprintf(stderr,
					    "Size may not be larger than %u "
					    "sectors\n", pp->p_size + *freep);
				else {
					*freep += pp->p_size - ui;
					pp->p_size = ui;
					break;			/* ok */
				}
			}
		}
	}
	pp->p_size = ui;
	return(0);
}

int
get_fsize(struct disklabel *lp, int partno)
{
	u_int32_t ui;
	struct partition *pp = &lp->d_partitions[partno];

	for (;;) {
		ui = getuint(lp, partno, "fragment size",
		    "Size of fs block fragments.  Usually 2048 or 1024/512.",
		    pp->p_fsize, pp->p_fsize, 0, 0);
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return(1);
		} else if (ui == UINT_MAX)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	if (ui == 0)
		puts("Zero fragment size implies zero block size");
	pp->p_fsize = ui;
	return(0);
}

int
get_bsize(struct disklabel *lp, int partno)
{
	u_int32_t ui;
	struct partition *pp = &lp->d_partitions[partno];

	/* Avoid dividing by zero... */
	if (pp->p_fsize == 0) {
		pp->p_frag = 0;
		return(1);
	}

	for (;;) {
		ui = getuint(lp, partno, "block size",
		    "Size of filesystem blocks.  Usually 16384 or 4096.",
		    pp->p_fsize * pp->p_frag, pp->p_fsize * pp->p_frag,
		    0, 0);

		/* sanity checks */
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return(1);
		} else if (ui == UINT_MAX)
			fputs("Invalid entry\n", stderr);
		else if (ui < getpagesize())
			fprintf(stderr,
			    "Error: block size must be at least as big "
			    "as page size (%d).\n", getpagesize());
		else if (ui % pp->p_fsize != 0)
			fputs("Error: block size must be a multiple of the "
			    "fragment size.\n", stderr);
		else if (ui / pp->p_fsize < 1)
			fputs("Error: block size must be at least as big as "
			    "fragment size.\n", stderr);
		else
			break;
	}
	pp->p_frag = ui / pp->p_fsize;
	return(0);
}

int
get_cpg(struct disklabel *lp, int partno)
{
	u_int32_t ui;
	struct partition *pp = &lp->d_partitions[partno];

	for (;;) {
		ui = getuint(lp, partno, "cpg",
		    "Number of filesystem cylinders per group."
		    "  Usually 16 or 8.",
		    pp->p_cpg ? pp->p_cpg : 16, 16, 0, 0);
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return(1);
		} else if (ui == UINT_MAX)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	pp->p_cpg = ui;
	return(0);
}

int
get_fstype(struct disklabel *lp, int partno)
{
	char *p;
	u_int32_t ui;
	struct partition *pp = &lp->d_partitions[partno];

	if (pp->p_fstype < FSMAXTYPES) {
		p = getstring("FS type",
		    "Filesystem type (usually 4.2BSD or swap)",
		    fstypenames[pp->p_fstype]);
		if (p == NULL) {
			fputs("Command aborted\n", stderr);
			return(1);
		}
		for (ui = 0; ui < FSMAXTYPES; ui++) {
			if (!strcasecmp(p, fstypenames[ui])) {
				pp->p_fstype = ui;
				break;
			}
		}
		if (ui >= FSMAXTYPES) {
			printf("Unrecognized filesystem type '%s', treating as 'unknown'\n", p);
			pp->p_fstype = FS_OTHER;
		}
	} else {
		for (;;) {
			ui = getuint(lp, partno, "FS type (decimal)",
			    "Filesystem type as a decimal number; usually 7 (4.2BSD) or 1 (swap).",
			    pp->p_fstype, pp->p_fstype, 0, 0);
			if (ui == UINT_MAX - 1) {
				fputs("Command aborted\n", stderr);
				return(1);
			} if (ui == UINT_MAX)
				fputs("Invalid entry\n", stderr);
			else
				break;
		}
		pp->p_fstype = ui;
	}
	return(0);
}

int
get_mp(struct disklabel *lp, char **mp, int partno)
{
	char *p;
	struct partition *pp = &lp->d_partitions[partno];

	if (mp != NULL && pp->p_fstype != FS_UNUSED &&
	    pp->p_fstype != FS_SWAP && pp->p_fstype != FS_BOOT &&
	    pp->p_fstype != FS_OTHER) {
		for (;;) {
			p = getstring("mount point",
			    "Where to mount this filesystem (ie: / /var /usr)",
			    mp[partno] ? mp[partno] : "none");
			if (p == NULL) {
				fputs("Command aborted\n", stderr);
				return(1);
			}
			if (strcasecmp(p, "none") == 0) {
				if (mp[partno] != NULL) {
					free(mp[partno]);
					mp[partno] = NULL;
				}
				break;
			}
			if (*p == '/') {
				/* XXX - might as well realloc */
				if (mp[partno] != NULL)
					free(mp[partno]);
				if ((mp[partno] = strdup(p)) == NULL)
					errx(4, "out of memory");
				break;
			}
			fputs("Mount points must start with '/'\n", stderr);
		}
	}
	return(0);
}

int
micmp(const void *a1, const void *a2)
{
	struct mountinfo *mi1 = (struct mountinfo *)a1;
	struct mountinfo *mi2 = (struct mountinfo *)a2;

	/* We want all the NULLs at the end... */
	if (mi1->mountpoint == NULL && mi2->mountpoint == NULL)
		return(0);
	else if (mi1->mountpoint == NULL)
		return(1);
	else if (mi2->mountpoint == NULL)
		return(-1);
	else
		return(strcmp(mi1->mountpoint, mi2->mountpoint));
}

void
get_geometry(int f, struct disklabel **dgpp, struct disklabel **bgpp)
{
#ifdef CPU_BIOS
	int mib[4];
	size_t size;
	dev_t devno;
	bios_diskinfo_t di;
#endif
	struct stat st;
	struct disklabel *disk_geop;
#ifdef CPU_BIOS
	struct disklabel *bios_geop;
#endif
	if (fstat(f, &st) == -1)
		err(4, "Can't stat device");

	/* Get disk geometry */
	if ((disk_geop = calloc(1, sizeof(struct disklabel))) == NULL)
		errx(4, "out of memory");
	if (ioctl(f, DIOCGPDINFO, disk_geop) < 0 &&
	    ioctl(f, DIOCGDINFO, disk_geop) < 0)
		err(4, "ioctl DIOCGDINFO");
	*dgpp = disk_geop;

	/* Get BIOS geometry */
	*bgpp = NULL;
#ifdef CPU_BIOS
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_CHR2BLK;
	mib[2] = st.st_rdev;
	size = sizeof(devno);
	if (sysctl(mib, 3, &devno, &size, NULL, 0) == -1) {
		warn("sysctl(machdep.chr2blk)");
		return;
	}
	devno = MAKEBOOTDEV(major(devno), 0, 0, DISKUNIT(devno), RAW_PART);

	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_BIOS;
	mib[2] = BIOS_DISKINFO;
	mib[3] = devno;
	size = sizeof(di);
	if (sysctl(mib, 4, &di, &size, NULL, 0) == -1) {
		warn("Can't get bios geometry");
		return;
	}
	if ((bios_geop = calloc(1, sizeof(struct disklabel))) == NULL)
		errx(4, "out of memory");

	bios_geop->d_secsize = DEV_BSIZE;
	bios_geop->d_nsectors = di.bios_sectors;
	bios_geop->d_ntracks = di.bios_heads;
	bios_geop->d_ncylinders = di.bios_cylinders;
	bios_geop->d_secpercyl = di.bios_sectors * di.bios_heads;
	bios_geop->d_secperunit = di.bios_cylinders *
	    di.bios_heads * di.bios_sectors;
	*bgpp = bios_geop;
#endif
}

void
set_geometry(struct disklabel *lp, struct disklabel *dgp,
    struct disklabel *bgp, struct disklabel *ugp, char *p)
{
	if (p == NULL) {
		p = getstring("[d]isk, [b]ios, or [u]ser geometry",
		    "Enter 'd' to use the geometry based on what the disk "
		    "itself thinks it is, 'b' to use what the BIOS says,"
		    "or 'u' to use the geometry that was found on in the label.",
		    "d");
	}
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		return;
	}
	switch (*p) {
	case 'b':
	case 'B':
		if (bgp == NULL)
			fputs("BIOS geometry not defined.\n", stderr);
		else {
			lp->d_secsize = bgp->d_secsize;
			lp->d_nsectors = bgp->d_nsectors;
			lp->d_ntracks = bgp->d_ntracks;
			lp->d_ncylinders = bgp->d_ncylinders;
			lp->d_secpercyl = bgp->d_secpercyl;
			lp->d_secperunit = bgp->d_secperunit;
		}
		break;
	case 'd':
	case 'D':
		if (dgp == NULL)
			fputs("BIOS geometry not defined.\n", stderr);
		else {
			lp->d_secsize = dgp->d_secsize;
			lp->d_nsectors = dgp->d_nsectors;
			lp->d_ntracks = dgp->d_ntracks;
			lp->d_ncylinders = dgp->d_ncylinders;
			lp->d_secpercyl = dgp->d_secpercyl;
			lp->d_secperunit = dgp->d_secperunit;
		}
		break;
	case 'u':
	case 'U':
		if (ugp == NULL)
			fputs("BIOS geometry not defined.\n", stderr);
		else {
			lp->d_secsize = ugp->d_secsize;
			lp->d_nsectors = ugp->d_nsectors;
			lp->d_ntracks = ugp->d_ntracks;
			lp->d_ncylinders = ugp->d_ncylinders;
			lp->d_secpercyl = ugp->d_secpercyl;
			lp->d_secperunit = ugp->d_secperunit;
			if (dgp != NULL && ugp->d_secsize == dgp->d_secsize &&
			    ugp->d_nsectors == dgp->d_nsectors &&
			    ugp->d_ntracks == dgp->d_ntracks &&
			    ugp->d_ncylinders == dgp->d_ncylinders &&
			    ugp->d_secpercyl == dgp->d_secpercyl &&
			    ugp->d_secperunit == dgp->d_secperunit)
				fputs("Note: user geometry is the same as disk "
				    "geometry.\n", stderr);
		}
		break;
	default:
		fputs("You must enter either 'd', 'b', or 'u'.\n", stderr);
		break;
	}
}

void
zero_partitions(struct disklabel *lp, u_int32_t *freep)
{
	int i;

	for (i = 0; i < MAXPARTITIONS; i++)
		memset(&lp->d_partitions[i], 0, sizeof(struct partition));
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	editor_countfree(lp, freep);
}
@


1.13
log
@merge openbsd; fix; enhance
@
text
@d1 2
a2 2
/**	$MirBSD$ */
/*	$OpenBSD: editor.c,v 1.96 2004/10/04 15:09:41 otto Exp $	*/
d46 1
a46 1
__RCSID("$MirBSD$");
d975 6
a980 1
	return((int)(p1->p_offset - p2->p_offset));
d1185 2
a1186 1
				puts("         size   offset    fstype   [fsize bsize   cpg]");
@


1.12
log
@merge OpenBSD, fix mdoc error
@
text
@d1 2
a2 2
/*	$MirBSD: editor.c,v 1.11 2004/01/02 23:25:07 tg Exp $	*/
/*	$OpenBSD: editor.c,v 1.93 2003/12/29 19:51:34 millert Exp $	*/
a19 5
#ifndef lint
static char rcsid[] = "$OpenBSD: editor.c,v 1.93 2003/12/29 19:51:34 millert Exp $";
#endif /* not lint */

#include <sys/types.h>
d43 1
d46 2
a68 1
int	editor(struct disklabel *, int, char *, char *);
a106 15
/* from disklabel.c */
int	checklabel(struct disklabel *);
void	display(FILE *, struct disklabel *, char);
void	display_partition(FILE *, struct disklabel *, char **, int, char, int);
int	width_partition(struct disklabel *, int);

struct disklabel *readlabel(int);
struct disklabel *makebootarea(char *, struct disklabel *, int);
int	writelabel(int, char *, struct disklabel *);
extern	char *bootarea, *specname;
extern	int donothing;
#ifdef DOSLABEL
extern	struct dos_partition *dosdp;	/* DOS partition, if found */
#endif

a788 1
	int width;
d794 6
a799 6
	printf("bytes/sector: %ld\n", (long)lp->d_secsize);
	printf("sectors/track: %ld\n", (long)lp->d_nsectors);
	printf("tracks/cylinder: %ld\n", (long)lp->d_ntracks);
	printf("sectors/cylinder: %ld\n", (long)lp->d_secpercyl);
	printf("cylinders: %ld\n", (long)lp->d_ncylinders);
	printf("total sectors: %ld\n", (long)lp->d_secperunit);
d801 4
a804 5
	printf("rpm: %ld\n", (long)lp->d_rpm);
	printf("\n%d slices:\n", lp->d_npartitions);
	width = width_partition(lp, unit);
	printf("#    %*.*s %*.*s    fstype   [fsize bsize   cpg]\n",
		width, width, "size", width, width, "offset");
d806 1
a806 1
		display_partition(stdout, lp, mp, i, unit, width);
d1181 2
a1182 2
				display_partition(stdout, lp, NULL, i, 0, 0);
				display_partition(stdout, lp, NULL, j, 0, 0);
@


1.11
log
@* enable having the disklabel partition as an entry
  in an extended partition table instead of in the MBR
  (kernel etc. diffs to follow)
* partition -> slice where applicable
  MirOS standard:
	partition = MBR entry or chained (extended partition)
	slice = disklabel entry
	volume = Windows 2000 dynamic disc entry
* whitespace, 0x60 etc. cleanup; add my (c)
@
text
@d1 2
a2 2
/*	$MirBSD: editor.c,v 1.10 2003/12/27 00:30:37 tg Exp $	*/
/*	$OpenBSD: editor.c,v 1.92 2003/12/20 09:29:27 jmc Exp $	*/
d20 4
d1039 1
a1039 1
	double d;
d1090 12
d1121 1
a1121 1
					rval = d * mult;
d1124 1
a1124 1
					rval = d / (-mult);
d1896 1
@


1.10
log
@finish merging and sync a bit; bump version etc.
@
text
@d1 1
a1 1
/*	$MirBSD: editor.c,v 1.9 2003/09/25 20:59:50 tg Exp $	*/
d159 1
a159 1
	/* If we don't have a 'c' partition, create one. */
d162 1
a162 1
		puts("No 'c' partition found, adding one that spans the disk.");
d172 1
a172 1
	puts("This platform requires that partition offsets/sizes be on cylinder boundaries.\nPartition offsets/sizes will be rounded to the nearest cylinder automatically.");
d450 1
a450 1
		fputs("No space left, you need to shrink a partition\n",
d461 1
a461 1
			    "Partition must be between 'a' and '%c' "
d467 1
a467 1
			    "Partition '%c' exists.  Delete it first.\n",
d485 2
a486 2
			p = getstring("partition",
			    "The letter of the new partition, a - p.", p);
d493 1
a493 1
				    "Partition '%c' already exists.\n", p[0]);
d497 1
a497 1
			    "Partition must be between 'a' and '%c'.\n",
d553 1
a553 1
		printf("\nPlease re-enter an offset and size for partition "
d583 1
a583 1
 * Set the mountpoint of an existing partition ('name').
d591 1
a591 1
	/* Change which partition? */
d593 2
a594 2
		p = getstring("partition to name",
		    "The letter of the partition to name, a - p.", NULL);
d603 1
a603 1
		fprintf(stderr, "Partition must be between 'a' and '%c'.\n",
d608 1
a608 1
		fprintf(stderr, "Partition '%c' is not in use.\n", 'a' + partno);
d624 1
a624 1
 * Change an existing partition.
d632 1
a632 1
	/* Change which partition? */
d634 2
a635 2
		p = getstring("partition to modify",
		    "The letter of the partition to modify, a - p.", NULL);
d645 1
a645 1
		fprintf(stderr, "Partition must be between 'a' and '%c'.\n",
d650 1
a650 1
		fprintf(stderr, "Partition '%c' is not in use.\n", 'a' + partno);
d660 1
a660 1
	/* Did they disable/enable the partition? */
d733 1
a733 1
 * Delete an existing partition.
d741 2
a742 2
		p = getstring("partition to delete",
		    "The letter of the partition to delete, a - p, or '*'.",
d767 1
a767 1
		fprintf(stderr, "Partition must be between 'a' and '%c'.\n",
d771 1
a771 1
		fprintf(stderr, "Partition '%c' is not in use.\n", 'a' + c);
d774 1
a774 1
"You may not delete the 'c' partition.  The 'c' partition must exist and\n"
d817 1
a817 1
	printf("\n%d partitions:\n", lp->d_npartitions);
d838 1
a838 1
	/* Get a sorted list of the partitions */
d845 2
a846 2
		 * Is new_offset inside this partition?  If so,
		 * make it the next sector after the partition ends.
d885 1
a885 1
 * Change the size of an existing partition.
d895 2
a896 2
		p = getstring("partition to change size",
		    "The letter of the partition to change size, a - p.", NULL);
d904 1
a904 1
		fprintf(stderr, "Partition must be between 'a' and '%c'.\n",
d909 1
a909 1
		fprintf(stderr, "Partition '%c' is not in use.\n", 'a' + partno);
d914 1
a914 1
	printf("Partition %c is currently %u sectors in size (%u free).\n",
d917 1
a917 1
	newsize = getuint(lp, partno, "new size", "Size of the partition.  "
d945 1
a945 1
			fputs("'c' partition may not be larger than the disk\n",
d963 1
a963 1
	/* Get a sorted list of the partitions */
d969 1
a969 1
	 * or partitions not in the BSD part of the label.
d982 1
a982 1
 * Sort the partitions based on starting offset.
d1146 1
a1146 1
 * Check for partition overlap in lp and prompt the user
d1182 1
a1182 1
				printf("\nError, partitions %c and %c overlap:\n",
d1194 1
a1194 1
				/* Get partition to disable or ^D */
d1353 1
a1353 1
			    "partition.");
d1415 1
a1415 1
	/* How many "real" partitions do we have? */
d1427 1
a1427 1
	/* Create an array of pointers to the partition data */
d1444 1
a1444 1
			err(4, "failed to sort partition table");
d1462 1
d1579 1
a1579 1
	/* Sort the partitions based on offset */
d1745 2
a1746 2
"The 'a' command adds new partitions to the disk.  It takes as an optional\n"
"argument the partition letter to add.  If you do not specify a partition\n"
d1765 3
a1767 3
"The 'c' command is used to change the size of an existing partition.  It\n"
"takes as an optional argument the partition letter to change.  If you do not\n"
"specify a partition letter, you will be prompted for one.  You may add a '+'\n"
d1782 4
a1785 4
"The 'd' command is used to delete an existing partition.  It takes as an\n"
"optional argument the partition letter to change.  If you do not specify a\n"
"partition letter, you will be prompted for one.  You may not delete the ``c''\n"
"partition as 'c' must always exist and by default is marked as 'unused' (so\n"
d1796 6
a1801 5
"The 'm' command is used to modify an existing partition.  It takes as an\n"    "optional argument the partition letter to change.  If you do not specify a\n"
"partition letter, you will be prompted for one.  This option allows the user\n"
"to change the filesystem type, starting offset, partition size, block fragment\n"
"size, block size, and cylinders per group for the specified partition (not all\n"
"parameters are configurable for non-BSD partitions).\n");
d1805 3
a1807 3
"The 'n' command is used to set the mount point for a partition (ie: name it).\n"
"It takes as an optional argument the partition letter to name.  If you do\n"
"not specify a partition letter, you will be prompted for one.  This option\n"
d1842 1
a1842 1
"size on ffs partitions).\n");
d1851 2
a1852 2
"The 'z' command zeroes out the existing partition table, leaving only the 'c'\n"
"partition.  The drive parameters are not changed.\n");
d1857 1
a1857 1
		puts("\ta [part]  - add new partition.");
d1859 1
a1859 1
		puts("\tc [part]  - change partition size.");
d1861 1
a1861 1
		puts("\td [part]  - delete partition.");
d1865 2
a1866 2
		puts("\tm [part]  - modify existing partition.");
		puts("\tn [part]  - set the mount point for a partition.");
d1875 1
a1875 1
		puts("\tz         - zero out partition table.");
d1986 1
a1986 1
		   "Starting sector for this partition.", pp->p_offset,
d1996 1
a1996 1
			    " at sector %u, you tried to add a partition at %u."
d2001 1
a2001 1
			    "at sector %u, you tried to add a partition at %u."
d2007 1
a2007 1
			    "partition 'a' start at sector 0.\n");
d2023 1
a2023 1
		ui = getuint(lp, partno, "size", "Size of the partition.",
d2036 1
a2036 1
				/* XXX - steal space from another partition */
d2042 1
a2042 1
				    "a partition ending at sector %u.  You can "
d2053 1
a2053 1
				fputs("'c' partition may not be larger than the disk\n",
d2062 1
a2062 1
					/* XXX - steal from another partition */
@


1.9
log
@Merge OpenBSD-current
@
text
@d1 2
a2 2
/*	$MirBSD: editor.c,v 1.8 2003/08/31 20:54:35 tg Exp $	*/
/*	$OpenBSD: editor.c,v 1.91 2003/09/24 20:40:19 deraadt Exp $	*/
a19 4
#ifndef lint
static char rcsid[] = "$MirBSD: editor.c,v 1.8 2003/08/31 20:54:35 tg Exp $";
#endif /* not lint */

d1854 1
a1854 3
		puts("\tp [unit]  - print label.");
		puts("\tM         - show entire MirBSD man page for disklabel.");
		puts("\te         - edit drive parameters.");
d1858 1
d1860 3
a1862 2
		puts("\tD         - set label to default.");
		puts("\tg [d|b]   - Use [d]isk or [b]ios geometry.");
d1865 2
d1868 1
a1869 1
		puts("\ts [path]  - save label to file.");
d1871 1
a1871 1
		puts("\tq         - quit and save changes.");
a1872 1
		puts("\tX         - toggle expert mode.");
a1873 1
		puts("\t? [cmnd]  - this message or command specific help.");
@


1.8
log
@Merge import of OpenBSD source, ports and XF4 tree.

While here,
o clean up differences where possible
o whitespace cleanup
o ifdef ./. if defined()
o '...' ./. "..."
o echo foo > bar ./. echo foo >bar
o `...` ./. $(...) ./. $$(...)
o `...' ./. '...'
o modernize "our" tree, e.g. WWW in ports
o fix some typos and brainos introduced when renaming OpenBSD to MirBSD
o use hardware 80387 by default
o migrate Apache 1.3.28 OpenBSD ./. MirBSD ./. KAME
o work around as many CVS bugs as possible (add back/delete files, ...)

Synchronize stuff, ready for ongoing changes.
@
text
@d1 2
a2 2
/*	$MirBSD: editor.c,v 1.7 2003/08/16 15:25:20 tg Exp $	*/
/*	$OpenBSD: editor.c,v 1.90 2003/08/29 00:17:09 tedu Exp $	*/
d21 1
a21 1
static char rcsid[] = "$MirBSD: editor.c,v 1.7 2003/08/16 15:25:20 tg Exp $";
d1892 1
d1898 2
a1899 2
			to[i] = realloc(to[i], len);
			if (to[i] == NULL)
d1901 1
@


1.7
log
@Merge OpenBSD
@
text
@d1 2
a2 2
/*	$MirBSD: editor.c,v 1.6 2003/07/18 15:45:10 tg Exp $	*/
/*	$OpenBSD: editor.c,v 1.88 2003/07/29 18:38:35 deraadt Exp $	*/
d21 1
a21 1
static char rcsid[] = "$MirBSD: editor.c,v 1.6 2003/07/18 15:45:10 tg Exp $";
d518 4
d523 1
@


1.6
log
@mop up; yet retain libcom_err
@
text
@d1 2
a2 2
/*	$MirBSD: editor.c,v 1.5 2003/06/28 20:57:56 tg Exp $	*/
/*	$OpenBSD: editor.c,v 1.87 2003/07/16 18:03:44 tedu Exp $	*/
d21 1
a21 1
static char rcsid[] = "$MirBSD: editor.c,v 1.5 2003/06/28 20:57:56 tg Exp $";
d543 1
a543 1
	
d610 1
a610 1
	
d652 1
a652 1
	
d840 1
a840 1
	
d1175 1
a1175 1
					
d1561 1
a1561 1
	
d1606 1
a1606 1
				
@


1.5
log
@adjust default fsize in disklabel
@
text
@d1 2
a2 2
/*	$MirBSD: editor.c,v 1.4 2003/06/19 16:44:15 tg Exp $	*/
/*	$OpenBSD: editor.c,v 1.86 2003/06/17 21:56:24 millert Exp $	*/
d21 1
a21 1
static char rcsid[] = "$MirBSD: editor.c,v 1.4 2003/06/19 16:44:15 tg Exp $";
d2081 1
a2081 1
		    "Size of fs block fragments.  Usually 1024 or 512.",
d2111 1
a2111 1
		    "Size of filesystem blocks.  Usually 8192 or 4096.",
@


1.4
log
@merge cvs import - OpenBSD tree as of Thu Jun 19 16:13:15 UTC 2003
@
text
@d1 1
a1 1
/*	$MirBSD: editor.c,v 1.3 2003/06/06 18:28:28 tg Exp $	*/
d21 1
a21 1
static char rcsid[] = "$MirBSD: editor.c,v 1.86 2003/06/17 21:56:24 millert Exp $";
d518 1
a518 1
	pp->p_fsize = 1024;
@


1.3
log
@Merge OpenBSD-current
@
text
@d1 2
a2 2
/*	$MirBSD: editor.c,v 1.2 2003/05/20 20:00:57 tg Exp $	*/
/*	$OpenBSD: editor.c,v 1.84 2003/06/03 01:52:40 millert Exp $	*/
d11 7
a17 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d21 1
a21 1
static char rcsid[] = "$MirBSD: editor.c,v 1.2 2003/05/20 20:00:57 tg Exp $";
d129 1
a129 5
editor(lp, f, dev, fstabfile)
	struct disklabel *lp;
	int f;
	char *dev;
	char *fstabfile;
d444 1
a444 5
editor_add(lp, mp, freep, p)
	struct disklabel *lp;
	char **mp;
	u_int32_t *freep;
	char *p;
d585 1
a585 4
editor_name(lp, mp, p)
	struct disklabel *lp;
	char **mp;
	char *p;
d626 1
a626 5
editor_modify(lp, mp, freep, p)
	struct disklabel *lp;
	char **mp;
	u_int32_t *freep;
	char *p;
d735 1
a735 5
editor_delete(lp, mp, freep, p)
	struct disklabel *lp;
	char **mp;
	u_int32_t *freep;
	char *p;
d799 1
a799 5
editor_display(lp, mp, freep, unit)
	struct disklabel *lp;
	char **mp;
	u_int32_t *freep;
	char unit;
d829 1
a829 3
next_offset(lp, sizep)
	struct disklabel *lp;
	u_int32_t *sizep;
d887 1
a887 4
editor_change(lp, freep, p)
	struct disklabel *lp;
	u_int32_t *freep;
	char *p;
d956 1
a956 2
make_contiguous(lp)
	struct disklabel *lp;
d985 1
a985 2
partition_cmp(e1, e2)
	const void *e1, *e2;
d994 1
a994 4
getstring(prompt, helpstring, oval)
	char *prompt;
	char *helpstring;
	char *oval;
d1027 2
a1028 9
getuint(lp, partno, prompt, helpstring, oval, maxval, offset, flags)
	struct disklabel *lp;
	int partno;
	char *prompt;
	char *helpstring;
	u_int32_t oval;
	u_int32_t maxval;		/* XXX - used inconsistently */
	u_int32_t offset;
	int flags;
d1150 1
a1150 4
has_overlap(lp, freep, resolve)
	struct disklabel *lp;
	u_int32_t *freep;
	int resolve;
d1220 1
a1220 3
edit_parms(lp, freep)
	struct disklabel *lp;
	u_int32_t *freep;
d1408 1
a1408 3
sort_partitions(lp, npart)
	struct disklabel *lp;
	u_int16_t *npart;
d1453 1
a1453 4
getdisktype(lp, banner, dev)
	struct disklabel *lp;
	char *banner;
	char *dev;
d1532 1
a1532 3
set_bounds(lp, freep)
	struct disklabel *lp;
	u_int32_t *freep;
d1570 1
a1570 2
free_chunks(lp)
	struct disklabel *lp;
d1625 1
a1625 3
find_bounds(lp, bios_lp)
	struct disklabel *lp;
	struct disklabel *bios_lp;
d1697 1
a1697 3
editor_countfree(lp, freep)
	struct disklabel *lp;
	u_int32_t *freep;
d1714 1
a1714 2
editor_help(arg)
	char *arg;
d1884 1
a1884 3
mpcopy(to, from)
	char **to;
	char **from;
d1905 1
a1905 3
mpequal(mp1, mp2)
	char **mp1;
	char **mp2;
d1922 1
a1922 5
mpsave(lp, mp, cdev, fstabfile)
	struct disklabel *lp;
	char **mp;
	char *cdev;
	char *fstabfile;
d1974 1
a1974 3
get_offset(lp, partno)
	struct disklabel *lp;
	int partno;
d2012 1
a2012 5
get_size(lp, partno, freep, new)
	struct disklabel *lp;
	int partno;
	u_int32_t *freep;
	int new;
d2074 1
a2074 3
get_fsize(lp, partno)
	struct disklabel *lp;
	int partno;
d2098 1
a2098 3
get_bsize(lp, partno)
	struct disklabel *lp;
	int partno;
d2139 1
a2139 3
get_cpg(lp, partno)
	struct disklabel *lp;
	int partno;
d2162 1
a2162 3
get_fstype(lp, partno)
	struct disklabel *lp;
	int partno;
d2205 1
a2205 4
get_mp(lp, mp, partno)
	struct disklabel *lp;
	char **mp;
	int partno;
d2243 1
a2243 3
micmp(a1, a2)
	const void *a1;
	const void *a2;
d2260 1
a2260 4
get_geometry(f, dgpp, bgpp)
	int f;
	struct disklabel **dgpp;
	struct disklabel **bgpp;
d2321 2
a2322 6
set_geometry(lp, dgp, bgp, ugp, p)
	struct disklabel *lp;
	struct disklabel *dgp;
	struct disklabel *bgp;
	struct disklabel *ugp;
	char *p;
d2390 1
a2390 3
zero_partitions(lp, freep)
	struct disklabel *lp;
	u_int32_t *freep;
@


1.2
log
@employ our own idea of a MirBSD disklabel and partition type:
 0xA6 OpenBSD is used as fall-back
 0x27 MirBSD disklabel is the new type
reason: addition of FS_* constants in sys/sys/disklabel.h
might get us outta sync with OpenBSD laters (NTFS here)

talk about "slices" in disklabel
remove trailing newlines etc. in fdisk
@
text
@d1 2
a2 2
/*	$MirBSD$	*/
/*	$OpenBSD: editor.c,v 1.83 2003/04/05 23:19:44 millert Exp $	*/
a5 1
 * All rights reserved.
d7 3
a9 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d11 7
a17 10
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d21 1
a21 1
static char rcsid[] = "$MirBSD: editor.c,v 1.83 2003/04/05 23:19:44 millert Exp $";
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: editor.c,v 1.82 2003/02/13 00:10:39 tedu Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.82 2003/02/13 00:10:39 tedu Exp $";
d168 1
a168 1
	/* How big is the OpenBSD portion of the disk?  */
d1059 2
a1060 4
		else if (oval != NULL && buf[0] == '\0') {
			(void)strncpy(buf, oval, sizeof(buf) - 1);
			buf[sizeof(buf) - 1] = '\0';
		}
d1323 1
a1323 2
	strncpy(lp->d_packname, p, sizeof(lp->d_packname) - 1);
	lp->d_packname[sizeof(lp->d_packname) - 1] = '\0';
d1588 1
a1588 1
 * Get beginning and ending sectors of the OpenBSD portion of the disk
d1602 1
a1602 1
		  "The start of the OpenBSD portion of the disk.",
d1614 1
a1614 1
		  "The size of the OpenBSD portion of the disk ('*' for the "
d1686 1
a1686 1
 * What is the OpenBSD portion of the disk?  Uses the MBR if applicable.
d1703 1
a1703 1
	 * If we have an MBR, use values from the {Open,Free,Net}BSD partition
d1706 2
a1707 1
	    if (dosdp->dp_typ == DOSPTYP_OPENBSD ||
d1747 1
a1747 1
		printf("\nTreating sectors %u-%u as the OpenBSD portion of the "
d1797 1
a1797 1
"The 'M' command pipes the entire OpenBSD manual page for disk label through\n"
d1819 1
a1819 1
"The 'b' command is used to change the boundaries of the OpenBSD portion of\n"
d1822 1
a1822 1
"and last sectors of the OpenBSD fdisk partition.  You should only change\n"
d1923 1
a1923 1
		puts("\tM         - show entire OpenBSD man page for disklabel.");
d1926 1
a1926 1
		puts("\tb         - set OpenBSD disk boundaries.");
d2069 1
a2069 1
			fprintf(stderr, "The OpenBSD portion of the disk starts"
d2072 1
a2072 1
			    "of the OpenBSD portion.\n" , starting_sector, ui);
d2074 1
a2074 1
			fprintf(stderr, "The OpenBSD portion of the disk ends "
d2077 1
a2077 1
			    "of the OpenBSD portion.\n", ending_sector, ui);
d2118 1
a2118 1
				fprintf(stderr, "The OpenBSD portion of the "
d2122 1
a2122 1
				    "the OpenBSD portion.\n",
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.83 2003/04/05 23:19:44 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.83 2003/04/05 23:19:44 millert Exp $";
d1058 4
a1061 2
		else if (oval != NULL && buf[0] == '\0')
			strlcpy(buf, oval, sizeof(buf));
d1324 2
a1325 1
	strncpy(lp->d_packname, p, sizeof(lp->d_packname));	/* checked */
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.84 2003/06/03 01:52:40 millert Exp $	*/
d5 1
d7 10
a16 3
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d18 10
a27 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.84 2003/06/03 01:52:40 millert Exp $";
@


1.1.1.4
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.86 2003/06/17 21:56:24 millert Exp $	*/
d10 7
a16 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.86 2003/06/17 21:56:24 millert Exp $";
d128 5
a132 1
editor(struct disklabel *lp, int f, char *dev, char *fstabfile)
d447 5
a451 1
editor_add(struct disklabel *lp, char **mp, u_int32_t *freep, char *p)
d592 4
a595 1
editor_name(struct disklabel *lp, char **mp, char *p)
d636 5
a640 1
editor_modify(struct disklabel *lp, char **mp, u_int32_t *freep, char *p)
d749 5
a753 1
editor_delete(struct disklabel *lp, char **mp, u_int32_t *freep, char *p)
d817 5
a821 1
editor_display(struct disklabel *lp, char **mp, u_int32_t *freep, char unit)
d851 3
a853 1
next_offset(struct disklabel *lp, u_int32_t *sizep)
d911 4
a914 1
editor_change(struct disklabel *lp, u_int32_t *freep, char *p)
d983 2
a984 1
make_contiguous(struct disklabel *lp)
d1013 2
a1014 1
partition_cmp(const void *e1, const void *e2)
d1023 4
a1026 1
getstring(char *prompt, char *helpstring, char *oval)
d1059 9
a1067 2
getuint(struct disklabel *lp, int partno, char *prompt, char *helpstring,
    u_int32_t oval, u_int32_t maxval, u_int32_t offset, int flags)
d1189 4
a1192 1
has_overlap(struct disklabel *lp, u_int32_t *freep, int resolve)
d1262 3
a1264 1
edit_parms(struct disklabel *lp, u_int32_t *freep)
d1452 3
a1454 1
sort_partitions(struct disklabel *lp, u_int16_t *npart)
d1499 4
a1502 1
getdisktype(struct disklabel *lp, char *banner, char *dev)
d1581 3
a1583 1
set_bounds(struct disklabel *lp, u_int32_t *freep)
d1621 2
a1622 1
free_chunks(struct disklabel *lp)
d1677 3
a1679 1
find_bounds(struct disklabel *lp, struct disklabel *bios_lp)
d1750 3
a1752 1
editor_countfree(struct disklabel *lp, u_int32_t *freep)
d1769 2
a1770 1
editor_help(char *arg)
d1940 3
a1942 1
mpcopy(char **to, char **from)
d1963 3
a1965 1
mpequal(char **mp1, char **mp2)
d1982 5
a1986 1
mpsave(struct disklabel *lp, char **mp, char *cdev, char *fstabfile)
d2038 3
a2040 1
get_offset(struct disklabel *lp, int partno)
d2078 5
a2082 1
get_size(struct disklabel *lp, int partno, u_int32_t *freep, int new)
d2144 3
a2146 1
get_fsize(struct disklabel *lp, int partno)
d2170 3
a2172 1
get_bsize(struct disklabel *lp, int partno)
d2213 3
a2215 1
get_cpg(struct disklabel *lp, int partno)
d2238 3
a2240 1
get_fstype(struct disklabel *lp, int partno)
d2283 4
a2286 1
get_mp(struct disklabel *lp, char **mp, int partno)
d2324 3
a2326 1
micmp(const void *a1, const void *a2)
d2343 4
a2346 1
get_geometry(int f, struct disklabel **dgpp, struct disklabel **bgpp)
d2407 6
a2412 2
set_geometry(struct disklabel *lp, struct disklabel *dgp,
    struct disklabel *bgp, struct disklabel *ugp, char *p)
d2480 3
a2482 1
zero_partitions(struct disklabel *lp, u_int32_t *freep)
@


1.1.1.5
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.87 2003/07/16 18:03:44 tedu Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.87 2003/07/16 18:03:44 tedu Exp $";
d517 1
a517 1
	pp->p_fsize = 2048;
d2079 1
a2079 1
		    "Size of fs block fragments.  Usually 2048 or 512.",
d2109 1
a2109 1
		    "Size of filesystem blocks.  Usually 16384 or 4096.",
@


1.1.1.6
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.88 2003/07/29 18:38:35 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.88 2003/07/29 18:38:35 deraadt Exp $";
d542 1
a542 1

d609 1
a609 1

d651 1
a651 1

d839 1
a839 1

d1174 1
a1174 1

d1560 1
a1560 1

d1605 1
a1605 1

@


1.1.1.7
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.90 2003/08/29 00:17:09 tedu Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.90 2003/08/29 00:17:09 tedu Exp $";
a516 4
#if defined (__sparc__) && !defined(__sparc64__)
	/* can't boot from > 8k boot blocks */
	pp->p_fsize = partno == 0 ? 1024 : 2048;
#else
a517 1
#endif
@


1.1.1.8
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.91 2003/09/24 20:40:19 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.91 2003/09/24 20:40:19 deraadt Exp $";
a1889 1
	char *top;
d1895 2
a1896 2
			top = realloc(to[i], len);
			if (top == NULL)
a1897 1
			to[i] = top;
@


1.1.1.9
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.92 2003/12/20 09:29:27 jmc Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.92 2003/12/20 09:29:27 jmc Exp $";
d1856 3
a1858 1
		puts("\t? [cmnd]  - this message or command specific help.");
d1862 1
d1864 1
a1864 4
		puts("\td [part]  - delete partition.");
		puts("\te         - edit drive parameters.");
		puts("\tg [b|d|u] - use [b]ios, [d]isk or [u]ser geometry.");
		puts("\tM         - show entire OpenBSD man page for disklabel.");
a1866 2
		puts("\tp [unit]  - print label.");
		puts("\tq         - quit and save changes.");
d1868 1
a1869 1
		puts("\tu         - undo last change.");
d1871 2
a1873 1
		puts("\tx         - exit without saving changes.");
d1875 1
@


1.1.1.10
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.93 2003/12/29 19:51:34 millert Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.93 2003/12/29 19:51:34 millert Exp $";
d1038 1
a1038 1
	double d, percent = 1.0;
a1088 12
				case '%':
					buf[--n] = '\0';
					percent = strtod(buf, NULL) / 100.0;
					snprintf(buf, sizeof(buf), "%d",
					    lp->d_secperunit);
					break;
				case '&':
					buf[--n] = '\0';
					percent = strtod(buf, NULL) / 100.0;
					snprintf(buf, sizeof(buf), "%d",
					    maxval);
					break;
d1108 1
a1108 1
					rval = d * mult * percent;
d1111 1
a1111 1
					rval = d / (-mult) * percent;
a1879 1
"'%' for percent of total disk size, '&' for percent of free space.\n\t"
@


1.1.1.11
log
@another obsd-current
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.96 2004/10/04 15:09:41 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.96 2004/10/04 15:09:41 otto Exp $";
a46 1
#include "extern.h"
d70 1
d109 15
d806 1
d812 6
a817 6
	printf("bytes/sector: %u\n", lp->d_secsize);
	printf("sectors/track: %u\n", lp->d_nsectors);
	printf("tracks/cylinder: %u\n", lp->d_ntracks);
	printf("sectors/cylinder: %u\n", lp->d_secpercyl);
	printf("cylinders: %u\n", lp->d_ncylinders);
	printf("total sectors: %u\n", lp->d_secperunit);
d819 5
a823 4
	printf("rpm: %hu\n", lp->d_rpm);
	printf("\n%hu partitions:\n", lp->d_npartitions);
	printf("#    %13.13s %13.13s  fstype [fsize bsize  cpg]\n",
	    "size", "offset");
d825 1
a825 1
		display_partition(stdout, lp, mp, i, unit);
d1200 2
a1201 2
				display_partition(stdout, lp, NULL, i, 0);
				display_partition(stdout, lp, NULL, j, 0);
@


1.1.1.12
log
@some more updates/fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.98 2004/12/11 07:28:05 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.98 2004/12/11 07:28:05 otto Exp $";
d298 2
a299 3
			char *pager, *cmd = NULL;
			extern const char manpage[];
			extern const int manpage_sz;
d303 2
a304 4

			if (asprintf(&cmd, "gunzip -qc|%s", pager) != -1 &&
			    (fp = popen(cmd, "w")) != NULL) {
				(void) fwrite(manpage, manpage_sz, 1, fp);
a308 1
			free(cmd);
d977 1
a977 6
	if (p1->p_offset < p2->p_offset)
		return -1;
	else if (p1->p_offset > p2->p_offset)
		return 1;
	else
		return 0;
d1182 1
a1182 2
				printf("#    %13.13s %13.13s  fstype "
				    "[fsize bsize  cpg]\n", "size", "offset");
@


