head	1.12;
access;
symbols
	tg-mergetmp-mirosx-1:1.12
	MIROS_X:1.12.0.2
	MIROS_X_BASE:1.12
	mksh-18:1.12
	mirbsdksh-1_17:1.12
	MIRBSD_XP_MIRPPC:1.8.0.4
	mirbsdksh-1_16:1.12
	cvs-200411032110:1.1.1.5
	cvs-200411031520:1.1.1.5
	MIRBSD_XP_SPARC_BASE:1.8
	MIRBSD_XP_SPARC:1.8.0.2
	mirbsdksh-1_12:1.7
	cvs-200408271355:1.1.1.5
	MIRBSD_7quater:1.7
	mirbsdksh-1_11:1.7
	mirbsdksh-1_10:1.7
	cvs-200405160640:1.1.1.5
	mirbsdksh-1_6:1.3
	mirbsdksh-1_5:1.2
	mirbsdksh-1_4:1.2
	mirbsdksh-1_3:1.1.1.4
	mirbsdksh-1_2:1.1.1.4
	ksh_maintainer:1.3.0.2
	pdksh-5_2_14:1.1.3.1
	tg:1.1.3
	cvs-200401271800:1.1.1.4
	cvs-200401261630:1.1.1.4
	cvs-200401021645:1.1.1.4
	MIRBSD_7_ALPHA:1.1.1.4.0.6
	MIRBSD_7:1.7.0.2
	cvs-200312222040:1.1.1.4
	MIRBSD_7ter:1.1.1.4
	MIRBSD_7_DEV:1.1.1.4.0.2
	cvs-200310020700:1.1.1.4
	cvs-200309271030:1.1.1.4
	cvs-200309251530:1.1.1.4
	cvs-200308302005:1.1.1.4
	cvs-200308171200:1.1.1.4
	ctm-3496:1.1.1.4
	ctm-3449:1.1.1.3
	ctm-3437:1.1.1.3
	cvs-200307191805:1.1.1.3
	ctm-3425:1.1.1.3
	cvs-200307091500:1.1.1.3
	ctm-3389:1.1.1.3
	cvs-200306291430:1.1.1.3
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2004.11.10.17.13.11;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.28.11.53.44;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.28.11.11.19;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.28.11.03.24;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.21.11.57.17;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.24.19.56.20;	author tg;	state Stab;
branches;
next	1.6;

1.6
date	2004.05.24.19.06.55;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.23.12.47.01;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.29.18.58.16;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.27.19.59.57;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.17.00.47.20;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.35.03;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.35.03;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.15.23;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.29.14.51.25;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.11.17.45.54;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.16.07.17.40;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2004.03.21.00.34.08;	author tg;	state Exp;
branches;
next	;


desc
@@


1.12
log
@remove mail check functionality (everybody SANE uses uw, imaps and mbx now)
update notes
fix Build.sh
@
text
@/**	$MirBSD: src/bin/ksh/var.c,v 1.11 2004/10/28 11:53:44 tg Exp $ */
/*	$OpenBSD: var.c,v 1.17 2004/05/08 19:42:35 deraadt Exp $	*/

#include "sh.h"
#include "ksh_time.h"
#include "ksh_limval.h"
#include "ksh_stat.h"
#include <ctype.h>

__RCSID("$MirBSD: src/bin/ksh/var.c,v 1.11 2004/10/28 11:53:44 tg Exp $");

/*
 * Variables
 *
 * WARNING: unreadable code, needs a rewrite
 *
 * if (flag&INTEGER), val.i contains integer value, and type contains base.
 * otherwise, (val.s + type) contains string value.
 * if (flag&EXPORT), val.s contains "name=value" for E-Z exporting.
 */
static	struct tbl vtemp;
static	struct table specials;
static char	*formatstr(struct tbl *vp, const char *s);
static void	export(struct tbl *vp, const char *val);
static int	special(const char *name);
static void	unspecial(const char *name);
static void	getspec(struct tbl *vp);
static void	setspec(struct tbl *vp);
static void	unsetspec(struct tbl *vp);
static struct tbl *arraysearch(struct tbl *, int);

/*
 * create a new block for function calls and simple commands
 * assume caller has allocated and set up e->loc
 */
void
newblock(void)
{
	struct block *l;
	static char *const empty[] = {null};

	l = (struct block *) alloc(sizeof(struct block), ATEMP);
	l->flags = 0;
	ainit(&l->area); /* todo: could use e->area (l->area => l->areap) */
	if (!e->loc) {
		l->argc = 0;
		l->argv = (char **) empty;
	} else {
		l->argc = e->loc->argc;
		l->argv = e->loc->argv;
	}
	l->exit = l->error = NULL;
	tinit(&l->vars, &l->area, 0);
	tinit(&l->funs, &l->area, 0);
	l->next = e->loc;
	e->loc = l;
}

/*
 * pop a block handling special variables
 */
void
popblock(void)
{
	struct block *l = e->loc;
	struct tbl *vp, **vpp = l->vars.tbls, *vq;
	int i;

	e->loc = l->next;	/* pop block */
	for (i = l->vars.size; --i >= 0; )
		if ((vp = *vpp++) != NULL && (vp->flag&SPECIAL)) {
			if ((vq = global(vp->name))->flag & ISSET)
				setspec(vq);
			else
				unsetspec(vq);
		}
	if (l->flags & BF_DOGETOPTS)
		user_opt = l->getopts_state;
	afreeall(&l->area);
	afree(l, ATEMP);
}

/* called by main() to initialize variable data structures */
void
initvar(void)
{
	static const struct {
		const char *name;
		int v;
	} names[] = {
			{ "COLUMNS",		V_COLUMNS },
			{ "IFS",		V_IFS },
			{ "OPTIND",		V_OPTIND },
			{ "PATH",		V_PATH },
			{ "POSIXLY_CORRECT",	V_POSIXLY_CORRECT },
			{ "TMPDIR",		V_TMPDIR },
#ifdef HISTORY
			{ "HISTFILE",		V_HISTFILE },
			{ "HISTSIZE",		V_HISTSIZE },
#endif /* HISTORY */
#ifdef EDIT
			{ "EDITOR",		V_EDITOR },
			{ "VISUAL",		V_VISUAL },
#endif /* EDIT */
#ifdef KSH
			{ "RANDOM",		V_RANDOM },
			{ "SECONDS",		V_SECONDS },
			{ "TMOUT",		V_TMOUT },
#endif /* KSH */
			{ "LINENO",		V_LINENO },
			{ (char *) 0,	0 }
		};
	int i;
	struct tbl *tp;

	tinit(&specials, APERM, 32); /* must be 2^n (currently 17 specials) */
	for (i = 0; names[i].name; i++) {
		tp = tenter(&specials, names[i].name, hash(names[i].name));
		tp->flag = DEFINED|ISSET;
		tp->type = names[i].v;
	}
}

/* Used to calculate an array index for global()/local().  Sets *arrayp to
 * non-zero if this is an array, sets *valp to the array index, returns
 * the basename of the array.
 */
const char *array_index_calc(const char *n, bool_t *arrayp, int *valp);

const char *
array_index_calc(const char *n, bool_t *arrayp, int *valp)
{
	const char *p;
	int len;

	*arrayp = FALSE;
	p = skip_varname(n, FALSE);
	if (p != n && *p == '[' && (len = array_ref_len(p))) {
		char *sub, *tmp;
		long rval;

		/* Calculate the value of the subscript */
		*arrayp = TRUE;
		tmp = str_nsave(p+1, len-2, ATEMP);
		sub = substitute(tmp, 0);
		afree(tmp, ATEMP);
		n = str_nsave(n, p - n, ATEMP);
		evaluate(sub, &rval, KSH_UNWIND_ERROR);
		if (rval < 0 || rval > ARRAYMAX)
			errorf("%s: subscript out of range", n);
		*valp = rval;
		afree(sub, ATEMP);
	}
	return n;
}

/*
 * Search for variable, if not found create globally.
 */
struct tbl *
global(const char *n)
{
	struct block *l = e->loc;
	struct tbl *vp;
	int c;
	unsigned h;
	bool_t	 array;
	int	 val;

	/* Check to see if this is an array */
	n = array_index_calc(n, &array, &val);
	h = hash(n);
	c = n[0];
	if (!letter(c)) {
		if (array)
			errorf("bad substitution");
		vp = &vtemp;
		vp->flag = DEFINED;
		vp->type = 0;
		vp->areap = ATEMP;
		*vp->name = c;
		if (digit(c)) {
			for (c = 0; digit(*n); n++)
				c = c*10 + *n-'0';
			if (c <= l->argc)
				/* setstr can't fail here */
				setstr(vp, l->argv[c], KSH_RETURN_ERROR);
			vp->flag |= RDONLY;
			return vp;
		}
		vp->flag |= RDONLY;
		if (n[1] != '\0')
			return vp;
		vp->flag |= ISSET|INTEGER;
		switch (c) {
		  case '$':
			vp->val.i = kshpid;
			break;
		  case '!':
			/* If no job, expand to nothing */
			if ((vp->val.i = j_async()) == 0)
				vp->flag &= ~(ISSET|INTEGER);
			break;
		  case '?':
			vp->val.i = exstat;
			break;
		  case '#':
			vp->val.i = l->argc;
			break;
		  case '-':
			vp->flag &= ~INTEGER;
			vp->val.s = getoptions();
			break;
		  default:
			vp->flag &= ~(ISSET|INTEGER);
		}
		return vp;
	}
	for (l = e->loc; ; l = l->next) {
		vp = tsearch(&l->vars, n, h);
		if (vp != NULL) {
			if (array)
				return arraysearch(vp, val);
			else
				return vp;
		}
		if (l->next == NULL)
			break;
	}
	vp = tenter(&l->vars, n, h);
	if (array)
		vp = arraysearch(vp, val);
	vp->flag |= DEFINED;
	if (special(n))
		vp->flag |= SPECIAL;
	return vp;
}

/*
 * Search for local variable, if not found create locally.
 */
struct tbl *
local(const char *n, bool_t copy)
{
	struct block *l = e->loc;
	struct tbl *vp;
	unsigned h;
	bool_t	 array;
	int	 val;

	/* Check to see if this is an array */
	n = array_index_calc(n, &array, &val);
	h = hash(n);
	if (!letter(*n)) {
		vp = &vtemp;
		vp->flag = DEFINED|RDONLY;
		vp->type = 0;
		vp->areap = ATEMP;
		return vp;
	}
	vp = tenter(&l->vars, n, h);
	if (copy && !(vp->flag & DEFINED)) {
		struct block *ll = l;
		struct tbl *vq = (struct tbl *) 0;

		while ((ll = ll->next) && !(vq = tsearch(&ll->vars, n, h)))
			;
		if (vq) {
			vp->flag |= vq->flag & (EXPORT|INTEGER|RDONLY
						|LJUST|RJUST|ZEROFIL
						|LCASEV|UCASEV_AL|INT_U|INT_L);
			if (vq->flag & INTEGER)
				vp->type = vq->type;
			vp->u2.field = vq->u2.field;
		}
	}
	if (array)
		vp = arraysearch(vp, val);
	vp->flag |= DEFINED;
	if (special(n))
		vp->flag |= SPECIAL;
	return vp;
}

/* get variable string value */
char *
str_val(struct tbl *vp)
{
	char *s;

	if ((vp->flag&SPECIAL))
		getspec(vp);
	if (!(vp->flag&ISSET))
		s = null;		/* special to dollar() */
	else if (!(vp->flag&INTEGER))	/* string source */
		s = vp->val.s + vp->type;
	else {				/* integer source */
		/* worst case number length is when base=2, so use BITS(long) */
			     /* minus base #     number    null */
		static char strbuf[1 + 2 + 1 + BITS(long) + 1];
		const char *digits = (vp->flag & UCASEV_AL) ?
				  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
				: "0123456789abcdefghijklmnopqrstuvwxyz";
		unsigned long n;
		int base;

		s = strbuf + sizeof(strbuf);
		if (vp->flag & INT_U)
			n = (unsigned long) vp->val.i;
		else
			n = (vp->val.i < 0) ? -vp->val.i : vp->val.i;
		base = (vp->type == 0) ? 10 : vp->type;

		*--s = '\0';
		do {
			*--s = digits[n % base];
			n /= base;
		} while (n != 0);
		if (base != 10) {
			*--s = '#';
			*--s = digits[base % 10];
			if (base >= 10)
				*--s = digits[base / 10];
		}
		if (!(vp->flag & INT_U) && vp->val.i < 0)
			*--s = '-';
		if (vp->flag & (RJUST|LJUST)) /* case already dealt with */
			s = formatstr(vp, s);
	}
	return s;
}

/* get variable integer value, with error checking */
long
intval(struct tbl *vp)
{
	long num;
	int base;

	base = getint(vp, &num);
	if (base == -1)
		/* XXX check calls - is error here ok by POSIX? */
		errorf("%s: bad number", str_val(vp));
	return num;
}

/* set variable to string value */
int
setstr(struct tbl *vq, const char *s, int error_ok)
{
	int no_ro_check = error_ok & 0x4;
	error_ok &= ~0x4;
	if ((vq->flag & RDONLY) && !no_ro_check) {
		warningf(TRUE, "%s: is read only", vq->name);
		if (!error_ok)
			errorf(null);
		return 0;
	}
	if (!(vq->flag&INTEGER)) { /* string dest */
		if ((vq->flag&ALLOC)) {
			/* debugging */
			if (s >= vq->val.s
			    && s <= vq->val.s + strlen(vq->val.s))
				internal_errorf(TRUE,
				    "setstr: %s=%s: assigning to self",
				    vq->name, s);
			afree((void*)vq->val.s, vq->areap);
		}
		vq->flag &= ~(ISSET|ALLOC);
		vq->type = 0;
		if (s && (vq->flag & (UCASEV_AL|LCASEV|LJUST|RJUST)))
			s = formatstr(vq, s);
		if ((vq->flag&EXPORT))
			export(vq, s);
		else {
			vq->val.s = str_save(s, vq->areap);
			vq->flag |= ALLOC;
		}
	} else			/* integer dest */
		if (!v_evaluate(vq, s, error_ok))
			return 0;
	vq->flag |= ISSET;
	if ((vq->flag&SPECIAL))
		setspec(vq);
	return 1;
}

/* set variable to integer */
void
setint(struct tbl *vq, long int n)
{
	if (!(vq->flag&INTEGER)) {
		struct tbl *vp = &vtemp;
		vp->flag = (ISSET|INTEGER);
		vp->type = 0;
		vp->areap = ATEMP;
		vp->val.i = n;
		/* setstr can't fail here */
		setstr(vq, str_val(vp), KSH_RETURN_ERROR);
	} else
		vq->val.i = n;
	vq->flag |= ISSET;
	if ((vq->flag&SPECIAL))
		setspec(vq);
}

int
getint(struct tbl *vp, long int *nump)
{
	char *s;
	int c;
	int base, neg;
	int have_base = 0;
	long num;

	if (vp->flag&SPECIAL)
		getspec(vp);
	/* XXX is it possible for ISSET to be set and val.s to be 0? */
	if (!(vp->flag&ISSET) || (!(vp->flag&INTEGER) && vp->val.s == NULL))
		return -1;
	if (vp->flag&INTEGER) {
		*nump = vp->val.i;
		return vp->type;
	}
	s = vp->val.s + vp->type;
	if (s == NULL)	/* redundant given initial test */
		s = null;
	base = 10;
	num = 0;
	neg = 0;
	for (c = *s++; c ; c = *s++) {
		if (c == '-') {
			neg++;
		} else if (c == '#') {
			base = (int) num;
			if (have_base || base < 2 || base > 36)
				return -1;
			num = 0;
			have_base = 1;
		} else if (letnum(c)) {
			if (isdigit(c))
				c -= '0';
			else if (islower(c))
				c -= 'a' - 10; /* todo: assumes ascii */
			else if (isupper(c))
				c -= 'A' - 10; /* todo: assumes ascii */
			else
				c = -1; /* _: force error */
			if (c < 0 || c >= base)
				return -1;
			num = num * base + c;
		} else
			return -1;
	}
	if (neg)
		num = -num;
	*nump = num;
	return base;
}

/* convert variable vq to integer variable, setting its value from vp
 * (vq and vp may be the same)
 */
struct tbl *
setint_v(struct tbl *vq, struct tbl *vp)
{
	int base;
	long num;

	if ((base = getint(vp, &num)) == -1)
		return NULL;
	if (!(vq->flag & INTEGER) && (vq->flag & ALLOC)) {
		vq->flag &= ~ALLOC;
		afree(vq->val.s, vq->areap);
	}
	vq->val.i = num;
	if (vq->type == 0) /* default base */
		vq->type = base;
	vq->flag |= ISSET|INTEGER;
	if (vq->flag&SPECIAL)
		setspec(vq);
	return vq;
}

static char *
formatstr(struct tbl *vp, const char *s)
{
	int olen, nlen;
	char *p, *q;

	olen = strlen(s);

	if (vp->flag & (RJUST|LJUST)) {
		if (!vp->u2.field)	/* default field width */
			vp->u2.field = olen;
		nlen = vp->u2.field;
	} else
		nlen = olen;

	p = (char *) alloc(nlen + 1, ATEMP);
	if (vp->flag & (RJUST|LJUST)) {
		int slen;

		if (vp->flag & RJUST) {
			const char *q = s + olen;
			/* strip trailing spaces (at&t ksh uses q[-1] == ' ') */
			while (q > s && isspace(q[-1]))
				--q;
			slen = q - s;
			if (slen > vp->u2.field) {
				s += slen - vp->u2.field;
				slen = vp->u2.field;
			}
			shf_snprintf(p, nlen + 1,
				((vp->flag & ZEROFIL) && digit(*s)) ?
					  "%0*s%.*s" : "%*s%.*s",
				vp->u2.field - slen, null, slen, s);
		} else {
			/* strip leading spaces/zeros */
			while (isspace(*s))
				s++;
			if (vp->flag & ZEROFIL)
				while (*s == '0')
					s++;
			shf_snprintf(p, nlen + 1, "%-*.*s",
				vp->u2.field, vp->u2.field, s);
		}
	} else
		memcpy(p, s, olen + 1);

	if (vp->flag & UCASEV_AL) {
		for (q = p; *q; q++)
			if (islower(*q))
				*q = toupper(*q);
	} else if (vp->flag & LCASEV) {
		for (q = p; *q; q++)
			if (isupper(*q))
				*q = tolower(*q);
	}

	return p;
}

/*
 * make vp->val.s be "name=value" for quick exporting.
 */
static void
export(struct tbl *vp, const char *val)
{
	char *xp;
	char *op = (vp->flag&ALLOC) ? vp->val.s : NULL;
	int namelen = strlen(vp->name);
	int vallen = strlen(val) + 1;

	vp->flag |= ALLOC;
	xp = (char*)alloc(namelen + 1 + vallen, vp->areap);
	memcpy(vp->val.s = xp, vp->name, namelen);
	xp += namelen;
	*xp++ = '=';
	vp->type = xp - vp->val.s; /* offset to value */
	memcpy(xp, val, vallen);
	if (op != NULL)
		afree((void*)op, vp->areap);
}

/*
 * lookup variable (according to (set&LOCAL)),
 * set its attributes (INTEGER, RDONLY, EXPORT, TRACE, LJUST, RJUST, ZEROFIL,
 * LCASEV, UCASEV_AL), and optionally set its value if an assignment.
 */
struct tbl *
typeset(const char *var, Tflag set, Tflag clr, int field, int base)
{
	struct tbl *vp;
	struct tbl *vpbase, *t;
	char *tvar;
	const char *val;

	/* check for valid variable name, search for value */
	val = skip_varname(var, FALSE);
	if (val == var)
		return NULL;
	if (*val == '[') {
		int len;

		len = array_ref_len(val);
		if (len == 0)
			return NULL;
		/* IMPORT is only used when the shell starts up and is
		 * setting up its environment.  Allow only simple array
		 * references at this time since parameter/command substitution
		 * is preformed on the [expression], which would be a major
		 * security hole.
		 */
		if (set & IMPORT) {
			int i;
			for (i = 1; i < len - 1; i++)
				if (!digit(val[i]))
					return NULL;
		}
		val += len;
	}
	if (*val == '=')
		tvar = str_nsave(var, val++ - var, ATEMP);
	else {
		/* Importing from original environment: must have an = */
		if (set & IMPORT)
			return NULL;
		tvar = (char *) var;
		val = NULL;
	}

	/* Prevent typeset from creating a local PATH/ENV/SHELL */
	if (Flag(FRESTRICTED) && (strcmp(tvar, "PATH") == 0
				  || strcmp(tvar, "ENV") == 0
				  || strcmp(tvar, "SHELL") == 0))
		errorf("%s: restricted", tvar);

	vp = (set&LOCAL) ? local(tvar, (set & LOCAL_COPY) ? TRUE : FALSE)
		: global(tvar);
	set &= ~(LOCAL|LOCAL_COPY);

	vpbase = (vp->flag & ARRAY) ? global(arrayname(var)) : vp;

	/* only allow export flag to be set.  at&t ksh allows any attribute to
	 * be changed, which means it can be truncated or modified
	 * (-L/-R/-Z/-i).
	 */
	if ((vpbase->flag&RDONLY)
	    && (val || clr || (set & ~EXPORT)))
		/* XXX check calls - is error here ok by POSIX? */
		errorf("%s: is read only", tvar);
	if (val)
		afree(tvar, ATEMP);

	/* most calls are with set/clr == 0 */
	if (set | clr) {
		int ok = 1;
		/* XXX if x[0] isn't set, there will be problems: need to have
		 * one copy of attributes for arrays...
		 */
		for (t = vpbase; t; t = t->u.array) {
			int fake_assign;
			char UNINITIALIZED(*s);
			char UNINITIALIZED(*free_me);

			fake_assign = (t->flag & ISSET) && (!val || t != vp)
				      && ((set & (UCASEV_AL|LCASEV|LJUST|RJUST|ZEROFIL))
					  || ((t->flag & INTEGER) && (clr & INTEGER))
					  || (!(t->flag & INTEGER) && (set & INTEGER)));
			if (fake_assign) {
				if (t->flag & INTEGER) {
					s = str_val(t);
					free_me = (char *) 0;
				} else {
					s = t->val.s + t->type;
					free_me = (t->flag & ALLOC) ? t->val.s
								  : (char *) 0;
				}
				t->flag &= ~ALLOC;
			}
			if (!(t->flag & INTEGER) && (set & INTEGER)) {
				t->type = 0;
				t->flag &= ~ALLOC;
			}
			t->flag = (t->flag | set) & ~clr;
			/* Don't change base if assignment is to be done,
			 * in case assignment fails.
			 */
			if ((set & INTEGER) && base > 0 && (!val || t != vp))
				t->type = base;
			if (set & (LJUST|RJUST|ZEROFIL))
				t->u2.field = field;
			if (fake_assign) {
				if (!setstr(t, s, KSH_RETURN_ERROR)) {
					/* Somewhat arbitrary action here:
					 * zap contents of variable, but keep
					 * the flag settings.
					 */
					ok = 0;
					if (t->flag & INTEGER)
						t->flag &= ~ISSET;
					else {
						if (t->flag & ALLOC)
							afree((void*) t->val.s,
							      t->areap);
						t->flag &= ~(ISSET|ALLOC);
						t->type = 0;
					}
				}
				if (free_me)
					afree((void *) free_me, t->areap);
			}
		}
		if (!ok)
		    errorf(null);
	}

	if (val != NULL) {
		if (vp->flag&INTEGER) {
			/* do not zero base before assignment */
			setstr(vp, val, KSH_UNWIND_ERROR | 0x4);
			/* Done after assignment to override default */
			if (base > 0)
				vp->type = base;
		} else
			/* setstr can't fail (readonly check already done) */
			setstr(vp, val, KSH_RETURN_ERROR | 0x4);
	}

	/* only x[0] is ever exported, so use vpbase */
	if ((vpbase->flag&EXPORT) && !(vpbase->flag&INTEGER)
	    && vpbase->type == 0)
		export(vpbase, (vpbase->flag&ISSET) ? vpbase->val.s : null);

	return vp;
}

/* Unset a variable.  array_ref is set if there was an array reference in
 * the name lookup (eg, x[2]).
 */
void
unset(struct tbl *vp, int array_ref)
{
	if (vp->flag & ALLOC)
		afree((void*)vp->val.s, vp->areap);
	if ((vp->flag & ARRAY) && !array_ref) {
		struct tbl *a, *tmp;

		/* Free up entire array */
		for (a = vp->u.array; a; ) {
			tmp = a;
			a = a->u.array;
			if (tmp->flag & ALLOC)
				afree((void *) tmp->val.s, tmp->areap);
			afree(tmp, tmp->areap);
		}
		vp->u.array = (struct tbl *) 0;
	}
	/* If foo[0] is being unset, the remainder of the array is kept... */
	vp->flag &= SPECIAL | (array_ref ? ARRAY|DEFINED : 0);
	if (vp->flag & SPECIAL)
		unsetspec(vp);	/* responsible for 'unspecial'ing var */
}

/* return a pointer to the first char past a legal variable name (returns the
 * argument if there is no legal name, returns * a pointer to the terminating
 * null if whole string is legal).
 */
char *
skip_varname(const char *s, int aok)
{
	int alen;

	if (s && letter(*s)) {
		while (*++s && letnum(*s))
			;
		if (aok && *s == '[' && (alen = array_ref_len(s)))
			s += alen;
	}
	return (char *) s;
}

/* Return a pointer to the first character past any legal variable name.  */
char *
skip_wdvarname(const char *s, int aok)

	        	/* skip array de-reference? */
{
	if (s[0] == CHAR && letter(s[1])) {
		do
			s += 2;
		while (s[0] == CHAR && letnum(s[1]));
		if (aok && s[0] == CHAR && s[1] == '[') {
			/* skip possible array de-reference */
			const char *p = s;
			char c;
			int depth = 0;

			while (1) {
				if (p[0] != CHAR)
					break;
				c = p[1];
				p += 2;
				if (c == '[')
					depth++;
				else if (c == ']' && --depth == 0) {
					s = p;
					break;
				}
			}
		}
	}
	return (char *) s;
}

/* Check if coded string s is a variable name */
int
is_wdvarname(const char *s, int aok)
{
	char *p = skip_wdvarname(s, aok);

	return p != s && p[0] == EOS;
}

/* Check if coded string s is a variable assignment */
int
is_wdvarassign(const char *s)
{
	char *p = skip_wdvarname(s, TRUE);

	return p != s && p[0] == CHAR && p[1] == '=';
}

/*
 * Make the exported environment from the exported names in the dictionary.
 */
char **
makenv(void)
{
	struct block *l = e->loc;
	XPtrV env;
	struct tbl *vp, **vpp;
	int i;

	XPinit(env, 64);
	for (l = e->loc; l != NULL; l = l->next)
		for (vpp = l->vars.tbls, i = l->vars.size; --i >= 0; )
			if ((vp = *vpp++) != NULL
			    && (vp->flag&(ISSET|EXPORT)) == (ISSET|EXPORT)) {
				struct block *l2;
				struct tbl *vp2;
				unsigned h = hash(vp->name);

				/* unexport any redefined instances */
				for (l2 = l->next; l2 != NULL; l2 = l2->next) {
					vp2 = tsearch(&l2->vars, vp->name, h);
					if (vp2 != NULL)
						vp2->flag &= ~EXPORT;
				}
				if ((vp->flag&INTEGER)) {
					/* integer to string */
					char *val;
					val = str_val(vp);
					vp->flag &= ~(INTEGER|RDONLY);
					/* setstr can't fail here */
					setstr(vp, val, KSH_RETURN_ERROR);
				}
				XPput(env, vp->val.s);
			}
	XPput(env, NULL);
	return (char **) XPclose(env);
}

/*
 * Called after a fork in parent to bump the random number generator.
 */
void
change_random(void)
{
	rnd_seed(time(NULL) * getpid());
}

/*
 * handle special variables with side effects - PATH, SECONDS.
 */

/* Test if name is a special parameter */
static int
special(const char *name)
{
	struct tbl *tp;

	tp = tsearch(&specials, name, hash(name));
	return tp && (tp->flag & ISSET) ? tp->type : V_NONE;
}

/* Make a variable non-special */
static void
unspecial(const char *name)
{
	struct tbl *tp;

	tp = tsearch(&specials, name, hash(name));
	if (tp)
		tdelete(tp);
}

#ifdef KSH
static	time_t	seconds;		/* time SECONDS last set */
#endif /* KSH */
static	int	user_lineno;		/* what user set $LINENO to */

static void
getspec(struct tbl *vp)
{
	switch (special(vp->name)) {
#ifdef KSH
	  case V_SECONDS:
		vp->flag &= ~SPECIAL;
		/* On start up the value of SECONDS is used before seconds
		 * has been set - don't do anything in this case
		 * (see initcoms[] in main.c).
		 */
		if (vp->flag & ISSET)
			setint(vp, (long) (time((time_t *)0) - seconds));
		vp->flag |= SPECIAL;
		break;
	  case V_RANDOM:
		vp->flag &= ~SPECIAL;
		setint(vp, rnd_get());
		vp->flag |= SPECIAL;
		break;
#endif /* KSH */
#ifdef HISTORY
	  case V_HISTSIZE:
		vp->flag &= ~SPECIAL;
		setint(vp, (long) histsize);
		vp->flag |= SPECIAL;
		break;
#endif /* HISTORY */
	  case V_OPTIND:
		vp->flag &= ~SPECIAL;
		setint(vp, (long) user_opt.uoptind);
		vp->flag |= SPECIAL;
		break;
	  case V_LINENO:
		vp->flag &= ~SPECIAL;
		setint(vp, (long) current_lineno + user_lineno);
		vp->flag |= SPECIAL;
		break;
	}
}

static void
setspec(struct tbl *vp)
{
	char *s;

	switch (special(vp->name)) {
	  case V_PATH:
		if (path)
			afree(path, APERM);
		path = str_save(str_val(vp), APERM);
		flushcom(1);	/* clear tracked aliases */
		break;
	  case V_IFS:
		setctypes(s = str_val(vp), C_IFS);
		ifs0 = *s;
		break;
	  case V_OPTIND:
		vp->flag &= ~SPECIAL;
		getopts_reset((int) intval(vp));
		vp->flag |= SPECIAL;
		break;
	  case V_POSIXLY_CORRECT:
		change_flag(FPOSIX, OF_SPECIAL, 1);
		break;
	  case V_TMPDIR:
		if (tmpdir) {
			afree(tmpdir, APERM);
			tmpdir = (char *) 0;
		}
		/* Use tmpdir iff it is an absolute path, is writable and
		 * searchable and is a directory...
		 */
		{
			struct stat statb;
			s = str_val(vp);
			if (ISABSPATH(s) && eaccess(s, W_OK|X_OK) == 0
			    && stat(s, &statb) == 0 && S_ISDIR(statb.st_mode))
				tmpdir = str_save(s, APERM);
		}
		break;
#ifdef HISTORY
	  case V_HISTSIZE:
		vp->flag &= ~SPECIAL;
		sethistsize((int) intval(vp));
		vp->flag |= SPECIAL;
		break;
	  case V_HISTFILE:
		sethistfile(str_val(vp));
		break;
#endif /* HISTORY */
#ifdef EDIT
	  case V_VISUAL:
		set_editmode(str_val(vp));
		break;
	  case V_EDITOR:
		if (!(global("VISUAL")->flag & ISSET))
			set_editmode(str_val(vp));
		break;
	  case V_COLUMNS:
		if ((x_cols = intval(vp)) <= MIN_COLS)
			x_cols = MIN_COLS;
		break;
#endif /* EDIT */
#ifdef KSH
	  case V_RANDOM:
		vp->flag &= ~SPECIAL;
		rnd_put(intval(vp));
		vp->flag |= SPECIAL;
		break;
	  case V_SECONDS:
		vp->flag &= ~SPECIAL;
		seconds = time((time_t*) 0) - intval(vp);
		vp->flag |= SPECIAL;
		break;
	  case V_TMOUT:
		/* at&t ksh seems to do this (only listen if integer) */
		if (vp->flag & INTEGER)
			ksh_tmout = vp->val.i >= 0 ? vp->val.i : 0;
		break;
#endif /* KSH */
	  case V_LINENO:
		vp->flag &= ~SPECIAL;
		/* The -1 is because line numbering starts at 1. */
		user_lineno = (unsigned int) intval(vp) - current_lineno - 1;
		vp->flag |= SPECIAL;
		break;
	}
}

static void
unsetspec(struct tbl *vp)
{
	switch (special(vp->name)) {
	  case V_PATH:
		if (path)
			afree(path, APERM);
		path = str_save(def_path, APERM);
		flushcom(1);	/* clear tracked aliases */
		break;
	  case V_IFS:
		setctypes(" \t\n", C_IFS);
		ifs0 = ' ';
		break;
	  case V_TMPDIR:
		/* should not become unspecial */
		if (tmpdir) {
			afree(tmpdir, APERM);
			tmpdir = (char *) 0;
		}
		break;
	  case V_LINENO:
#ifdef KSH
	  case V_RANDOM:
	  case V_SECONDS:
	  case V_TMOUT:		/* at&t ksh leaves previous value in place */
#endif /* KSH */
		unspecial(vp->name);
		break;

	  /* at&t ksh man page says OPTIND, OPTARG and _ lose special meaning,
	   * but OPTARG does not (still set by getopts) and _ is also still
	   * set in various places.
	   * Don't know what at&t does for:
	   *		HISTSIZE, HISTFILE,
	   * Unsetting these in at&t ksh does not loose the 'specialness':
	   *    no effect: IFS, COLUMNS, PATH, TMPDIR,
	   *		VISUAL, EDITOR,
	   * pdkshisms: no effect:
	   *		POSIXLY_CORRECT (use set +o posix instead)
	   */
	}
}

/*
 * Search for (and possibly create) a table entry starting with
 * vp, indexed by val.
 */
static struct tbl *
arraysearch(struct tbl *vp, int val)
{
	struct tbl *prev, *curr, *new;
	size_t namelen = strlen(vp->name) + 1;

	vp->flag |= ARRAY|DEFINED;

	/* The table entry is always [0] */
	if (val == 0) {
		vp->index = 0;
		return vp;
	}
	prev = vp;
	curr = vp->u.array;
	while (curr && curr->index < val) {
		prev = curr;
		curr = curr->u.array;
	}
	if (curr && curr->index == val) {
		if (curr->flag&ISSET)
			return curr;
		else
			new = curr;
	} else
		new = (struct tbl *)alloc(sizeof(struct tbl) + namelen,
		    vp->areap);
	strlcpy(new->name, vp->name, namelen);
	new->flag = vp->flag & ~(ALLOC|DEFINED|ISSET|SPECIAL);
	new->type = vp->type;
	new->areap = vp->areap;
	new->u2.field = vp->u2.field;
	new->index = val;
	if (curr != new) {		/* not reusing old array entry */
		prev->u.array = new;
		new->u.array = curr;
	}
	return new;
}

/* Return the length of an array reference (eg, [1+2]) - cp is assumed
 * to point to the open bracket.  Returns 0 if there is no matching closing
 * bracket.
 */
int
array_ref_len(const char *cp)
{
	const char *s = cp;
	int c;
	int depth = 0;

	while ((c = *s++) && (c != ']' || --depth))
		if (c == '[')
			depth++;
	if (!c)
		return 0;
	return s - cp;
}

/*
 * Make a copy of the base of an array name
 */
char *
arrayname(const char *str)
{
	const char *p;

	if ((p = strchr(str, '[')) == 0)
		/* Shouldn't happen, but why worry? */
		return (char *) str;

	return str_nsave(str, p - str, ATEMP);
}

/* Set (or overwrite, if !reset) the array variable var to the values in vals.
 */
void
set_array(const char *var, int reset, char **vals)
{
	struct tbl *vp, *vq;
	int i;

	/* to get local array, use "typeset foo; set -A foo" */
	vp = global(var);

	/* Note: at&t ksh allows set -A but not set +A of a read-only var */
	if ((vp->flag&RDONLY))
		errorf("%s: is read only", var);
	/* This code is quite non-optimal */
	if (reset > 0)
		/* trash existing values and attributes */
		unset(vp, 0);
	/* todo: would be nice for assignment to completely succeed or
	 * completely fail.  Only really effects integer arrays:
	 * evaluation of some of vals[] may fail...
	 */
	for (i = 0; vals[i]; i++) {
		vq = arraysearch(vp, i);
		/* would be nice to deal with errors here... (see above) */
		setstr(vq, vals[i], KSH_RETURN_ERROR);
	}
}
@


1.11
log
@run GNU protoize
protect header files
nuke some dead code
regenerate configure script
let silly code die
@
text
@d1 1
a1 1
/**	$MirBSD: src/bin/ksh/var.c,v 1.10 2004/10/28 11:11:19 tg Exp $ */
d10 1
a10 1
__RCSID("$MirBSD: src/bin/ksh/var.c,v 1.10 2004/10/28 11:11:19 tg Exp $");
a105 3
			{ "MAIL",		V_MAIL },
			{ "MAILCHECK",		V_MAILCHECK },
			{ "MAILPATH",		V_MAILPATH },
a998 11
	  case V_MAIL:
		mbset(str_val(vp));
		break;
	  case V_MAILPATH:
		mpset(str_val(vp));
		break;
	  case V_MAILCHECK:
		vp->flag &= ~SPECIAL;
		mcset(intval(vp));
		vp->flag |= SPECIAL;
		break;
a1044 9
#ifdef KSH
	  case V_MAIL:
		mbset((char *) 0);
		break;
	  case V_MAILPATH:
		mpset((char *) 0);
		break;
#endif /* KSH */

a1046 1
	  case V_MAILCHECK:	/* at&t ksh leaves previous value in place */
d1058 1
a1058 1
	   *		MAIL, MAILPATH, HISTSIZE, HISTFILE,
@


1.10
log
@de-register, de-inline, de-__P
@
text
@d1 1
a1 1
/**	$MirBSD: src/bin/ksh/var.c,v 1.9 2004/10/28 11:03:24 tg Exp $ */
d10 1
a10 1
__RCSID("$MirBSD$");
d37 1
a37 1
newblock()
d63 1
a63 1
popblock()
d85 1
a85 1
initvar()
d134 1
a134 4
array_index_calc(n, arrayp, valp)
	const char *n;
	bool_t *arrayp;
	int *valp;
d164 1
a164 2
global(n)
	const char *n;
d246 1
a246 3
local(n, copy)
	const char *n;
	bool_t copy;
d290 1
a290 2
str_val(vp)
	struct tbl *vp;
d338 1
a338 2
intval(vp)
	struct tbl *vp;
d352 1
a352 4
setstr(vq, s, error_ok)
	struct tbl *vq;
	const char *s;
	int error_ok;
d393 1
a393 3
setint(vq, n)
	struct tbl *vq;
	long n;
d411 1
a411 3
getint(vp, nump)
	struct tbl *vp;
	long *nump;
d468 1
a468 2
setint_v(vq, vp)
	struct tbl *vq, *vp;
d489 1
a489 3
formatstr(vp, s)
	struct tbl *vp;
	const char *s;
d551 1
a551 3
export(vp, val)
	struct tbl *vp;
	const char *val;
d575 1
a575 4
typeset(var, set, clr, field, base)
	const char *var;
	Tflag clr, set;
	int field, base;
d726 1
a726 3
unset(vp, array_ref)
	struct tbl *vp;
	int array_ref;
d754 1
a754 3
skip_varname(s, aok)
	const char *s;
	int aok;
d769 3
a771 3
skip_wdvarname(s, aok)
	const char *s;
	int aok;	/* skip array de-reference? */
d802 1
a802 3
is_wdvarname(s, aok)
	const char *s;
	int aok;
d811 1
a811 2
is_wdvarassign(s)
	const char *s;
d822 1
a822 1
makenv()
d862 1
a862 1
change_random()
d873 1
a873 2
special(name)
	const char * name;
d883 1
a883 2
unspecial(name)
	const char * name;
d898 1
a898 2
getspec(vp)
	struct tbl *vp;
d939 1
a939 2
setspec(vp)
	struct tbl *vp;
d1039 1
a1039 2
unsetspec(vp)
	struct tbl *vp;
d1097 1
a1097 3
arraysearch(vp, val)
	struct tbl *vp;
	int val;
d1141 1
a1141 2
array_ref_len(cp)
	const char *cp;
d1159 1
a1159 2
arrayname(str)
	const char *str;
d1173 1
a1173 4
set_array(var, reset, vals)
	const char *var;
	int reset;
	char **vals;
@


1.9
log
@-Wall -Werror -W -pedantic clean
@
text
@d1 1
a1 1
/**	$MirBSD: src/bin/ksh/var.c,v 1.8 2004/09/21 11:57:17 tg Exp $ */
d10 2
d23 8
a30 8
static char	*formatstr	ARGS((struct tbl *vp, const char *s));
static void	export		ARGS((struct tbl *vp, const char *val));
static int	special		ARGS((const char *name));
static void	unspecial	ARGS((const char *name));
static void	getspec		ARGS((struct tbl *vp));
static void	setspec		ARGS((struct tbl *vp));
static void	unsetspec	ARGS((struct tbl *vp));
static struct tbl *arraysearch  ARGS((struct tbl *, int));
@


1.8
log
@unify spacing of RCS IDs
@
text
@d1 1
a1 1
/**	$MirBSD$ */
d37 1
a37 1
	register struct block *l;
d63 3
a65 3
	register struct block *l = e->loc;
	register struct tbl *vp, **vpp = l->vars.tbls, *vq;
	register int i;
d166 1
a166 1
	register const char *n;
d168 3
a170 3
	register struct block *l = e->loc;
	register struct tbl *vp;
	register int c;
d249 1
a249 1
	register const char *n;
d252 2
a253 2
	register struct block *l = e->loc;
	register struct tbl *vp;
d295 1
a295 1
	register struct tbl *vp;
d312 2
a313 2
		register unsigned long n;
		register int base;
d344 1
a344 1
	register struct tbl *vp;
d359 1
a359 1
	register struct tbl *vq;
d403 1
a403 1
	register struct tbl *vq;
d407 1
a407 1
		register struct tbl *vp = &vtemp;
d426 2
a427 2
	register char *s;
	register int c;
d482 1
a482 1
	register struct tbl *vq, *vp;
d568 1
a568 1
	register struct tbl *vp;
d571 1
a571 1
	register char *xp;
d594 1
a594 1
	register const char *var;
d598 1
a598 1
	register struct tbl *vp;
d748 1
a748 1
	register struct tbl *vp;
d854 2
a855 2
	register struct tbl *vp, **vpp;
	register int i;
d862 2
a863 2
				register struct block *l2;
				register struct tbl *vp2;
d902 1
a902 1
	register const char * name;
d904 1
a904 1
	register struct tbl *tp;
d913 1
a913 1
	register const char * name;
d915 1
a915 1
	register struct tbl *tp;
d929 1
a929 1
	register struct tbl *vp;
d971 1
a971 1
	register struct tbl *vp;
d1072 1
a1072 1
	register struct tbl *vp;
@


1.7
log
@polish, mop up whitespace, etc.

passes regressions on MirOS
@
text
@d1 2
a2 2
/* $MirBSD$ */
/* $OpenBSD: var.c,v 1.17 2004/05/08 19:42:35 deraadt Exp $	*/
@


1.6
log
@overhaul the random stuff ;-)
@
text
@d1 1
a1 1
/* $MirBSD: src/bin/ksh/var.c,v 1.5 2004/05/23 12:47:01 tg Exp $	*/
@


1.5
log
@* merge OpenBSD 3.5-current
* retain local changes to ls and md5 (md4, hint hint)
* fix up ksh (limits - we still have 4096 bytes input buffer;
  random usage)
* fix manpages (mdX, ksh)
@
text
@d1 1
a1 1
/* $MirBSD: src/bin/ksh/var.c,v 1.4 2004/04/29 18:58:16 tg Exp $	*/
d892 1
a892 1
    srand(prng_seed(rand() ^ time(NULL)));
d945 1
a945 1
		setint(vp, (long) (rand() & 0x7fff));
d1047 1
a1047 2
		srand(prng_seed(((unsigned int)intval(vp))
		    ^ ((unsigned long)rand() << 24)));
a1236 31
}

/* Return a seed PRNG value, and feed one back to arc4random */
long
prng_seed(val)
	long val;
{
	unsigned long i, j;

#ifdef	HAVE_ARC4RANDOM
	i = arc4random();
#else
	i = ((long) (time((time_t *)0) * getpid()));
#endif
	j = (rand() << 16) | rand();

	i ^= val;
	j ^= val;

#if defined(HAVE_ARC4RANDOM_PUSH)
	arc4random_push(j);
#elif defined(HAVE_ARC4RANDOM_ADDRANDOM)
	arc4random_addrandom((u_char *)(&j), sizeof (j));
#else
	while (j) {
		rand();
		j >>= 1;
	}
#endif

	return i;
@


1.4
log
@correct pointer type, noticed by gecko2 (Andreas G.), thanks
@
text
@d1 2
a2 2
/* $MirBSD: src/bin/ksh/var.c,v 1.3 2004/04/27 19:59:57 tg Exp $	*/
/* $OpenBSD: var.c,v 1.16 2003/08/05 20:52:27 millert Exp $	*/
a887 2
 * Done to ensure children will not get the same random number sequence
 * if the parent doesn't use $RANDOM.
d892 1
a892 1
    prng_seed(rand());
@


1.3
log
@* mirbsdksh and mirosksh != rksh
* use arc4random familiy for randomness, if exists
* feed back randomness on reseed and variable assignments
@
text
@d1 1
a1 1
/* $MirBSD: src/bin/ksh/var.c,v 1.2 2004/04/17 00:47:20 tg Exp $	*/
d1262 1
a1262 1
	arc4random_addrandom(&j, sizeof (j));
@


1.2
log
@throw out a bunch more of 0x60 characters throughout code and comments
@
text
@d1 2
a2 2
/*	$MirBSD$	*/
/*	$OpenBSD: var.c,v 1.16 2003/08/05 20:52:27 millert Exp $	*/
d894 1
a894 1
    rand();
d1049 2
a1050 1
		srand((unsigned int)intval(vp));
d1240 31
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: var.c,v 1.13 2003/03/13 09:03:07 deraadt Exp $	*/
d129 2
d389 1
a389 2
			if (vq->val.s)		/* <sjg> don't lie */
				vq->flag |= ALLOC;
d769 1
a769 1
		unsetspec(vp);	/* responsible for `unspecial'ing var */
d1118 1
a1118 1
	   * Unsetting these in at&t ksh does not loose the `specialness':
d1137 1
d1158 1
a1158 1
		new = (struct tbl *)alloc(sizeof(struct tbl)+strlen(vp->name)+1,
d1160 1
a1160 1
	strcpy(new->name, vp->name);
@


1.1.3.1
log
@Import upstream pdksh-5.2.14 (latest version) in order to be able
to play around with it a bit
@
text
@d1 2
d68 1
a68 1
		if ((vp = *vpp++) != NULL && (vp->flag&SPECIAL))
d73 1
d168 1
a168 1
	unsigned h; 
d223 1
a223 1
		if (vp != NULL)
d228 1
d360 3
a362 1
	if (vq->flag & RDONLY) {
d429 1
a429 1
	
d440 1
a440 1
	if (s == NULL)	/* redundent given initial test */
d484 1
a484 1
	
d607 1
a607 1
		
d628 1
a628 1
		/* Importing from original envirnment: must have an = */
d699 1
a699 1
					 * zap contents of varibale, but keep
d724 1
a724 1
			setstr(vp, val, KSH_UNWIND_ERROR);
d730 1
a730 1
			setstr(vp, val, KSH_RETURN_ERROR);
d1155 2
a1156 1
		new = (struct tbl *)alloc(sizeof(struct tbl)+strlen(vp->name)+1, vp->areap);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.14 2003/04/16 23:11:52 tdeval Exp $	*/
a1134 1
	size_t namelen = strlen(vp->name) + 1;
d1155 1
a1155 1
		new = (struct tbl *)alloc(sizeof(struct tbl) + namelen,
d1157 1
a1157 1
	strlcpy(new->name, vp->name, namelen);
@


1.1.1.3
log
@Sync OpenBSD source tree from -current CVS.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.15 2003/06/26 00:09:45 deraadt Exp $	*/
a127 2
const char *array_index_calc(const char *n, bool_t *arrayp, int *valp);

@


1.1.1.4
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.16 2003/08/05 20:52:27 millert Exp $	*/
d388 2
a389 1
			vq->flag |= ALLOC;
@


1.1.1.5
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.17 2004/05/08 19:42:35 deraadt Exp $	*/
a885 6
 * Someone has set the srand() value, therefore from now on
 * we return values from rand() instead of arc4random()
 */
int use_rand = 0;

/*
d893 1
a893 2
	if (use_rand)
		rand();
d946 1
a946 4
		if (use_rand)
			setint(vp, (long) (rand() & 0x7fff));
		else
			setint(vp, (long) (arc4random() & 0x7fff));
a1048 1
		use_rand = 1;
@


