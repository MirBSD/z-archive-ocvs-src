head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.4
	tg-mergefixes-1-branch:1.1.1.4.0.8
	tg-mergefixes-1-base:1.1.1.4
	MIROS_X:1.1.1.4.0.6
	MIROS_X_BASE:1.1.1.4
	tg-mergetmp-3:1.1.1.4
	MIRBSD_XP_MIRPPC:1.1.1.4.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.4
	MIRBSD_XP_SPARC:1.1.1.4.0.2
	MIRBSD_7quater:1.1.1.3
	cvs-200405160640:1.1.1.4
	cvs-200401271800:1.1.1.4
	cvs-200401261630:1.1.1.4
	cvs-200401021645:1.1.1.4
	MIRBSD_7_ALPHA:1.1.1.3.0.6
	MIRBSD_7:1.1.1.3.0.4
	cvs-200312222040:1.1.1.4
	MIRBSD_7ter:1.1.1.3
	MIRBSD_7_DEV:1.1.1.3.0.2
	cvs-200310020700:1.1.1.3
	cvs-200309271030:1.1.1.3
	cvs-200309251530:1.1.1.3
	cvs-200308302005:1.1.1.3
	cvs-200308171200:1.1.1.3
	ctm-3496:1.1.1.3
	ctm-3449:1.1.1.3
	ctm-3437:1.1.1.3
	cvs-200307191805:1.1.1.3
	ctm-3425:1.1.1.3
	cvs-200307091500:1.1.1.3
	ctm-3389:1.1.1.3
	cvs-200306291430:1.1.1.3
	ctm-3341:1.1.1.3
	MIRBSD_5:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	ctm-3255:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.17.46.45;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.46.45;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.05.20.56.22;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.25.52;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.22.21.07.11;	author tg;	state Stab;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: common.c,v 1.3 1997/03/14 05:12:43 millert Exp $	*/
/*	$NetBSD: common.c,v 1.3 1997/01/14 04:17:22 lukem Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christos Zoulas of Cornell University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if !defined(lint) && !defined(SCCSID)
#if 0
static char sccsid[] = "@@(#)common.c	8.1 (Berkeley) 6/4/93";
#else
static char rcsid[] = "$OpenBSD: common.c,v 1.3 1997/03/14 05:12:43 millert Exp $";
#endif
#endif /* not lint && not SCCSID */

/*
 * common.c: Common Editor functions
 */
#include "sys.h"
#include "el.h"

/* ed_end_of_file(): 
 *	Indicate end of file
 *	[^D]
 */
protected el_action_t
/*ARGSUSED*/
ed_end_of_file(el, c)
    EditLine *el;
    int c;
{
    re_goto_bottom(el);
    *el->el_line.lastchar = '\0';
    return CC_EOF;
}


/* ed_insert(): 
 *	Add character to the line
 *	Insert a character [bound to all insert keys]
 */
protected el_action_t
ed_insert(el, c)
    EditLine *el;
    int c;
{
    int i;

    if (c == '\0')
	return CC_ERROR;

    if (el->el_line.lastchar + el->el_state.argument >= 
	el->el_line.limit)
	return CC_ERROR;	/* end of buffer space */

    if (el->el_state.argument == 1) {
	if (el->el_state.inputmode != MODE_INSERT) {
	    el->el_chared.c_undo.buf[el->el_chared.c_undo.isize++] = 
		*el->el_line.cursor;
	    el->el_chared.c_undo.buf[el->el_chared.c_undo.isize] = '\0';
	    c_delafter(el, 1);   
    	}

        c_insert(el, 1);

	*el->el_line.cursor++ = c;
	el->el_state.doingarg = 0;		/* just in case */
	re_fastaddc(el);			/* fast refresh for one char. */
    }
    else {
	if (el->el_state.inputmode != MODE_INSERT) {

	    for(i = 0;i < el->el_state.argument; i++) 
		el->el_chared.c_undo.buf[el->el_chared.c_undo.isize++] = 
			el->el_line.cursor[i];

	    el->el_chared.c_undo.buf[el->el_chared.c_undo.isize] = '\0';
	    c_delafter(el, el->el_state.argument);   
    	}

        c_insert(el, el->el_state.argument);

	while (el->el_state.argument--)
	    *el->el_line.cursor++ = c;
	re_refresh(el);
    }

    if (el->el_state.inputmode == MODE_REPLACE_1)
	(void)vi_command_mode(el, 0);

    return CC_NORM;
}


/* ed_delete_prev_word(): 
 *	Delete from beginning of current word to cursor
 *	[M-^?] [^W]
 */
protected el_action_t
/*ARGSUSED*/
ed_delete_prev_word(el, c)
    EditLine *el;
    int c;
{
    char *cp, *p, *kp;

    if (el->el_line.cursor == el->el_line.buffer)
	return CC_ERROR;

    cp = c__prev_word(el->el_line.cursor, el->el_line.buffer, 
		      el->el_state.argument, ce__isword);

    for (p = cp, kp = el->el_chared.c_kill.buf; p < el->el_line.cursor; p++)
	*kp++ = *p;
    el->el_chared.c_kill.last = kp;

    c_delbefore(el, el->el_line.cursor - cp);	/* delete before dot */
    el->el_line.cursor = cp;
    if (el->el_line.cursor < el->el_line.buffer)
	el->el_line.cursor = el->el_line.buffer;	/* bounds check */
    return CC_REFRESH;
}


/* ed_delete_next_char(): 
 *	Delete character under cursor
 *	[^D] [x]
 */
protected el_action_t
/*ARGSUSED*/
ed_delete_next_char(el, c)
    EditLine *el;
    int c;
{
#ifdef notdef /* XXX */
#define EL el->el_line
fprintf(stderr, "\nD(b: %x(%s)  c: %x(%s) last: %x(%s) limit: %x(%s)\n", 
	EL.buffer, EL.buffer, EL.cursor, EL.cursor, EL.lastchar, EL.lastchar, EL.limit, EL.limit);
#endif
    if (el->el_line.cursor == el->el_line.lastchar) {/* if I'm at the end */
	if (el->el_map.type == MAP_VI) {
	    if (el->el_line.cursor == el->el_line.buffer) {	
		/* if I'm also at the beginning */
#ifdef KSHVI
		return CC_ERROR;
#else
		term_overwrite(el, STReof, 4);/* then do a EOF */
		term__flush();
		return CC_EOF;
#endif
	    }
	    else  {
#ifdef KSHVI
		el->el_line.cursor--;
#else
		return CC_ERROR;
#endif
	    }
	}
	else {
	    if (el->el_line.cursor != el->el_line.buffer)
		el->el_line.cursor--;
	    else
		return CC_ERROR;
	}
    }
    c_delafter(el, el->el_state.argument);	/* delete after dot */
    if (el->el_line.cursor >= el->el_line.lastchar && el->el_line.cursor > el->el_line.buffer)
	el->el_line.cursor = el->el_line.lastchar - 1;	/* bounds check */
    return CC_REFRESH;
}


/* ed_kill_line(): 
 *	Cut to the end of line
 *	[^K] [^K]
 */
protected el_action_t
/*ARGSUSED*/
ed_kill_line(el, c)
    EditLine *el;
    int c;
{
    char *kp, *cp;

    cp = el->el_line.cursor;
    kp = el->el_chared.c_kill.buf;
    while (cp < el->el_line.lastchar)
	*kp++ = *cp++;		/* copy it */
    el->el_chared.c_kill.last = kp;
    el->el_line.lastchar = el->el_line.cursor; /* zap! -- delete to end */
    return CC_REFRESH;
}


/* ed_move_to_end(): 
 *	Move cursor to the end of line
 *	[^E] [^E]
 */
protected el_action_t
/*ARGSUSED*/
ed_move_to_end(el, c)
    EditLine *el;
    int c;
{
    el->el_line.cursor = el->el_line.lastchar;
    if (el->el_map.type == MAP_VI) {
#ifdef VI_MOVE
	el->el_line.cursor--;
#endif
	if (el->el_chared.c_vcmd.action & DELETE) {
	    cv_delfini(el);
	    return CC_REFRESH;
	}
    }
    return CC_CURSOR;
}


/* ed_move_to_beg(): 
 *	Move cursor to the beginning of line
 *	[^A] [^A]
 */
protected el_action_t
/*ARGSUSED*/
ed_move_to_beg(el, c)
    EditLine *el;
    int c;
{
    el->el_line.cursor = el->el_line.buffer;

    if (el->el_map.type == MAP_VI) {
        /* We want FIRST non space character */
        while (isspace(*el->el_line.cursor)) 
	    el->el_line.cursor++;
	if (el->el_chared.c_vcmd.action & DELETE) {
	    cv_delfini(el);
	    return CC_REFRESH;
	}
    }

    return CC_CURSOR;
}


/* ed_transpose_chars(): 
 *	Exchange the character to the left of the cursor with the one under it
 *	[^T] [^T]
 */
protected el_action_t
ed_transpose_chars(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor < el->el_line.lastchar) {
	if (el->el_line.lastchar <= &el->el_line.buffer[1])
	    return CC_ERROR;
	else 
	    el->el_line.cursor++;
    }
    if (el->el_line.cursor > &el->el_line.buffer[1]) {
	/* must have at least two chars entered */
	c = el->el_line.cursor[-2];
	el->el_line.cursor[-2] = el->el_line.cursor[-1];
	el->el_line.cursor[-1] = c;
	return CC_REFRESH;
    }
    else 
	return CC_ERROR;
}


/* ed_next_char(): 
 *	Move to the right one character
 *	[^F] [^F]
 */
protected el_action_t
/*ARGSUSED*/
ed_next_char(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor >= el->el_line.lastchar)
	return CC_ERROR;

    el->el_line.cursor += el->el_state.argument;
    if (el->el_line.cursor > el->el_line.lastchar)
	el->el_line.cursor = el->el_line.lastchar;

    if (el->el_map.type == MAP_VI)
	if (el->el_chared.c_vcmd.action & DELETE) {
	    cv_delfini(el);
	    return CC_REFRESH;
	}

    return CC_CURSOR;
}


/* ed_prev_word(): 
 *	Move to the beginning of the current word
 *	[M-b] [b]
 */
protected el_action_t
/*ARGSUSED*/
ed_prev_word(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor == el->el_line.buffer)
	return CC_ERROR;

    el->el_line.cursor = c__prev_word(el->el_line.cursor, el->el_line.buffer, 
				      el->el_state.argument, 
				      ce__isword);

    if (el->el_map.type == MAP_VI)
	if (el->el_chared.c_vcmd.action & DELETE) {
	    cv_delfini(el);
	    return CC_REFRESH;
	}

    return CC_CURSOR;
}


/* ed_prev_char(): 
 *	Move to the left one character
 *	[^B] [^B]
 */
protected el_action_t
/*ARGSUSED*/
ed_prev_char(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor > el->el_line.buffer) {
	el->el_line.cursor -= el->el_state.argument;
	if (el->el_line.cursor < el->el_line.buffer)
	    el->el_line.cursor = el->el_line.buffer;

	if (el->el_map.type == MAP_VI)
	    if (el->el_chared.c_vcmd.action & DELETE) {
		cv_delfini(el);
		return CC_REFRESH;
	    }

	return CC_CURSOR;
    }
    else 
	return CC_ERROR;
}


/* ed_quoted_insert(): 
 *	Add the next character typed verbatim
 *	[^V] [^V]
 */
protected el_action_t
ed_quoted_insert(el, c)
    EditLine *el;
    int c;
{
    int     num;
    char    tc;

    tty_quotemode(el);
    num = el_getc(el, &tc);
    c = (unsigned char) tc;
    tty_noquotemode(el);
    if (num == 1)
	return ed_insert(el, c);
    else
	return ed_end_of_file(el, 0);
}


/* ed_digit(): 
 *	Adds to argument or enters a digit
 */
protected el_action_t
ed_digit(el, c)
    EditLine *el;
    int c;
{
    if (!isdigit(c))
	return CC_ERROR;

    if (el->el_state.doingarg) {	
	/* if doing an arg, add this in... */
	if (el->el_state.lastcmd == EM_UNIVERSAL_ARGUMENT)	
	    el->el_state.argument = c - '0';
	else {
	    if (el->el_state.argument > 1000000)
		return CC_ERROR;
	    el->el_state.argument = 
		(el->el_state.argument * 10) + (c - '0');
	}
	return CC_ARGHACK;
    }
    else {
	if (el->el_line.lastchar + 1 >= el->el_line.limit)
	    return CC_ERROR;

	if (el->el_state.inputmode != MODE_INSERT) {
	    el->el_chared.c_undo.buf[el->el_chared.c_undo.isize++] = 
		*el->el_line.cursor;
	    el->el_chared.c_undo.buf[el->el_chared.c_undo.isize] = '\0';
	    c_delafter(el, 1);  
    	}
	c_insert(el, 1);
	*el->el_line.cursor++ = c;
	el->el_state.doingarg = 0;
	re_fastaddc(el);
    }
    return CC_NORM;
}


/* ed_argument_digit(): 
 *	Digit that starts argument
 *	For ESC-n
 */
protected el_action_t
ed_argument_digit(el, c)
    EditLine *el;
    register int c;
{
    if (!isdigit(c))
	return CC_ERROR;

    if (el->el_state.doingarg) {
	if (el->el_state.argument > 1000000)
	    return CC_ERROR;
	el->el_state.argument = (el->el_state.argument * 10) + (c - '0');
    }
    else {			/* else starting an argument */
	el->el_state.argument = c - '0';
	el->el_state.doingarg = 1;
    }
    return CC_ARGHACK;
}


/* ed_unassigned(): 
 *	Indicates unbound character
 *	Bound to keys that are not assigned
 */
protected el_action_t
/*ARGSUSED*/
ed_unassigned(el, c)
    EditLine *el;
    int c;
{
    term_beep(el);
    term__flush();
    return CC_NORM;
}


/**
 ** TTY key handling.
 **/

/* ed_tty_sigint(): 
 *	Tty interrupt character
 *	[^C]
 */
protected el_action_t
/*ARGSUSED*/
ed_tty_sigint(el, c)
    EditLine *el;
    int c;
{			
    return CC_NORM;
}


/* ed_tty_dsusp(): 
 *	Tty delayed suspend character
 *	[^Y]
 */
protected el_action_t
/*ARGSUSED*/
ed_tty_dsusp(el, c)
    EditLine *el;
    int c;
{
    return CC_NORM;
}


/* ed_tty_flush_output(): 
 *	Tty flush output characters
 *	[^O]
 */
protected el_action_t
/*ARGSUSED*/
ed_tty_flush_output(el, c)
    EditLine *el;
    int c;
{
    return CC_NORM;
}


/* ed_tty_sigquit(): 
 *	Tty quit character
 *	[^\]
 */
protected el_action_t
/*ARGSUSED*/
ed_tty_sigquit(el, c)
    EditLine *el;
    int c;
{
    return CC_NORM;
}


/* ed_tty_sigtstp(): 
 *	Tty suspend character
 *	[^Z]
 */
protected el_action_t
/*ARGSUSED*/
ed_tty_sigtstp(el, c)
    EditLine *el;
    int c;
{
    return CC_NORM;
}


/* ed_tty_stop_output(): 
 *	Tty disallow output characters
 *	[^S]
 */
protected el_action_t
/*ARGSUSED*/
ed_tty_stop_output(el, c)
    EditLine *el;
    int c;
{
    return CC_NORM;
}


/* ed_tty_start_output(): 
 *	Tty allow output characters
 *	[^Q]
 */
protected el_action_t
/*ARGSUSED*/
ed_tty_start_output(el, c)
    EditLine *el;
    int c;
{
    return CC_NORM;
}


/* ed_newline(): 
 *	Execute command
 *	[^J]
 */
protected el_action_t
/*ARGSUSED*/
ed_newline(el, c)
    EditLine *el;
    int c;
{
    re_goto_bottom(el);
    *el->el_line.lastchar++ = '\n';
    *el->el_line.lastchar = '\0';
    if (el->el_map.type == MAP_VI)
	el->el_chared.c_vcmd.ins = el->el_line.buffer;
    return CC_NEWLINE;
}


/* ed_delete_prev_char(): 
 *	Delete the character to the left of the cursor
 *	[^?]
 */
protected el_action_t
/*ARGSUSED*/
ed_delete_prev_char(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor <= el->el_line.buffer) 
	return CC_ERROR;

    c_delbefore(el, el->el_state.argument);	
    el->el_line.cursor -= el->el_state.argument;
    if (el->el_line.cursor < el->el_line.buffer)
	el->el_line.cursor = el->el_line.buffer;
    return CC_REFRESH;
}


/* ed_clear_screen(): 
 *	Clear screen leaving current line at the top
 *	[^L]
 */
protected el_action_t
/*ARGSUSED*/
ed_clear_screen(el, c)
    EditLine *el;
    int c;
{
    term_clear_screen(el);	/* clear the whole real screen */
    re_clear_display(el);		/* reset everything */
    return CC_REFRESH;
}


/* ed_redisplay(): 
 *	Redisplay everything
 *	^R
 */
protected el_action_t
/*ARGSUSED*/
ed_redisplay(el, c)
    EditLine *el;
    int c;
{
    return CC_REDISPLAY;
}


/* ed_start_over(): 
 *	Erase current line and start from scratch
 *	[^G]
 */
protected el_action_t
/*ARGSUSED*/
ed_start_over(el, c)
    EditLine *el;
    int c;
{
    ch_reset(el);
    return CC_REFRESH;
}


/* ed_sequence_lead_in(): 
 *	First character in a bound sequence
 *	Placeholder for external keys
 */
protected el_action_t
/*ARGSUSED*/
ed_sequence_lead_in(el, c)
    EditLine *el;
    int c;
{
    return CC_NORM;
}


/* ed_prev_history(): 
 *	Move to the previous history line
 *	[^P] [k]
 */
protected el_action_t
/*ARGSUSED*/
ed_prev_history(el, c)
    EditLine *el;
    int c;
{
    char    beep = 0;

    el->el_chared.c_undo.action = NOP;
    *el->el_line.lastchar = '\0';		/* just in case */

    if (el->el_history.eventno == 0) {	/* save the current buffer away */
	(void)strncpy(el->el_history.buf, el->el_line.buffer, EL_BUFSIZ - 1);
	el->el_history.buf[EL_BUFSIZ - 1] = '\0';
	el->el_history.last = el->el_history.buf + 
		(el->el_line.lastchar - el->el_line.buffer);
    }

    el->el_history.eventno += el->el_state.argument;

    if (hist_get(el) == CC_ERROR) {
	beep = 1;
	/* el->el_history.eventno was fixed by first call */
	(void)hist_get(el); 
    }

    re_refresh(el);
    if (beep)
	return CC_ERROR;
    else
	return CC_NORM;	/* was CC_UP_HIST */
}


/* ed_next_history(): 
 *	Move to the next history line
 *	[^N] [j]
 */
protected el_action_t
/*ARGSUSED*/
ed_next_history(el, c)
    EditLine *el;
    int c;
{
    el->el_chared.c_undo.action = NOP;
    *el->el_line.lastchar = '\0';		/* just in case */

    el->el_history.eventno -= el->el_state.argument;

    if (el->el_history.eventno < 0) {
	el->el_history.eventno = 0;
	return CC_ERROR;	/* make it beep */
    }

    return hist_get(el);
}


/* ed_search_prev_history(): 
 *	Search previous in history for a line matching the current
 *	next search history [M-P] [K]
 */
protected el_action_t
/*ARGSUSED*/
ed_search_prev_history(el, c)
    EditLine *el;
    int c;
{
    const char *hp;
    int h;
    bool_t    found = 0;

    el->el_chared.c_vcmd.action = NOP;
    el->el_chared.c_undo.action = NOP;
    *el->el_line.lastchar = '\0';		/* just in case */
    if (el->el_history.eventno < 0) {
#ifdef DEBUG_EDIT
	(void)fprintf(el->el_errfile, "e_prev_search_hist(): eventno < 0;\n");
#endif
	el->el_history.eventno = 0;
	return CC_ERROR;
    }

    if (el->el_history.eventno == 0) {
	(void)strncpy(el->el_history.buf, el->el_line.buffer, EL_BUFSIZ - 1);
	el->el_history.buf[EL_BUFSIZ - 1] = '\0';
	el->el_history.last = el->el_history.buf + 
		(el->el_line.lastchar - el->el_line.buffer);
    }


    if (el->el_history.ref == NULL)
	return CC_ERROR;

    hp = HIST_FIRST(el);
    if (hp == NULL)
	return CC_ERROR;

    c_setpat(el);		/* Set search pattern !! */

    for (h = 1; h <= el->el_history.eventno; h++)
	hp = HIST_NEXT(el);

    while (hp != NULL) {
#ifdef SDEBUG
	(void)fprintf(el->el_errfile, "Comparing with \"%s\"\n", hp);
#endif
	if ((strncmp(hp, el->el_line.buffer, 
		     el->el_line.lastchar - el->el_line.buffer) || 
	    hp[el->el_line.lastchar-el->el_line.buffer]) && 
	    c_hmatch(el, hp)) {
	    found++;
	    break;
	}
	h++;
	hp = HIST_NEXT(el);
    }

    if (!found) {
#ifdef SDEBUG
	(void)fprintf(el->el_errfile, "not found\n"); 
#endif
	return CC_ERROR;
    }

    el->el_history.eventno = h;

    return hist_get(el);
}


/* ed_search_next_history(): 
 *	Search next in history for a line matching the current
 *	[M-N] [J]
 */
protected el_action_t
/*ARGSUSED*/
ed_search_next_history(el, c)
    EditLine *el;
    int c;
{
    const char *hp;
    int h;
    bool_t    found = 0;

    el->el_chared.c_vcmd.action = NOP;
    el->el_chared.c_undo.action = NOP;
    *el->el_line.lastchar = '\0';		/* just in case */

    if (el->el_history.eventno == 0)
	return CC_ERROR;

    if (el->el_history.ref == NULL)
	return CC_ERROR;

    hp = HIST_FIRST(el);
    if (hp == NULL)
	return CC_ERROR;

    c_setpat(el);		/* Set search pattern !! */

    for (h = 1; h < el->el_history.eventno && hp; h++) {
#ifdef SDEBUG
	(void)fprintf(el->el_errfile, "Comparing with \"%s\"\n", hp);
#endif
	if ((strncmp(hp, el->el_line.buffer, 
		     el->el_line.lastchar - el->el_line.buffer) || 
	     hp[el->el_line.lastchar-el->el_line.buffer]) && 
	    c_hmatch(el, hp))
	    found = h;
	hp = HIST_NEXT(el);
    }

    if (!found) {		/* is it the current history number? */
	if (!c_hmatch(el, el->el_history.buf)) {
#ifdef SDEBUG
	    (void)fprintf(el->el_errfile, "not found\n"); 
#endif
	    return CC_ERROR;
	}
    }

    el->el_history.eventno = found;

    return hist_get(el);
}


/* ed_prev_line():
 *	Move up one line
 *	Could be [k] [^p]
 */
protected el_action_t
/*ARGSUSED*/
ed_prev_line(el, c)
    EditLine *el;
    int c;
{
    char *ptr;
    int nchars = c_hpos(el);
    
    /*
     * Move to the line requested
     */
    if (*(ptr = el->el_line.cursor) == '\n')
	ptr--;

    for (; ptr >= el->el_line.buffer; ptr--)
	if (*ptr == '\n' && --el->el_state.argument <= 0)
	    break;

    if (el->el_state.argument > 0)
	return CC_ERROR;

    /*
     * Move to the beginning of the line
     */
    for (ptr--; ptr >= el->el_line.buffer && *ptr != '\n'; ptr--)
	continue;
    
    /*
     * Move to the character requested
     */
    for (ptr++; 
	 nchars-- > 0 && ptr < el->el_line.lastchar && *ptr != '\n'; 
	 ptr++)
	continue;
    
    el->el_line.cursor = ptr;
    return CC_CURSOR;
}


/* ed_next_line():
 *	Move down one line
 *	Could be [j] [^n]
 */
protected el_action_t
/*ARGSUSED*/
ed_next_line(el, c)
    EditLine *el;
    int c;
{
    char *ptr;
    int nchars = c_hpos(el);

    /*
     * Move to the line requested
     */
    for (ptr = el->el_line.cursor; ptr < el->el_line.lastchar; ptr++)
	if (*ptr == '\n' && --el->el_state.argument <= 0)
	    break;

    if (el->el_state.argument > 0)
	return CC_ERROR;

    /*
     * Move to the character requested
     */
    for (ptr++;
	 nchars-- > 0 && ptr < el->el_line.lastchar && *ptr != '\n'; 
    	 ptr++)
	continue;
    
    el->el_line.cursor = ptr;
    return CC_CURSOR;
}


/* ed_command(): 
 *	Editline extended command
 *	[M-X] [:]
 */
protected el_action_t
/*ARGSUSED*/
ed_command(el, c)
    EditLine *el;
    int c;
{
    char tmpbuf[EL_BUFSIZ];
    int tmplen;

    el->el_line.buffer[0] = '\0';
    el->el_line.lastchar = el->el_line.buffer;
    el->el_line.cursor = el->el_line.buffer;

    c_insert(el, 3);	/* prompt + ": " */
    *el->el_line.cursor++ = '\n';
    *el->el_line.cursor++ = ':';
    *el->el_line.cursor++ = ' ';
    re_refresh(el);

    tmplen = c_gets(el, tmpbuf);
    tmpbuf[tmplen] = '\0';

    el->el_line.buffer[0] = '\0';
    el->el_line.lastchar = el->el_line.buffer;
    el->el_line.cursor = el->el_line.buffer;

    if (parse_line(el, tmpbuf) == -1)
	return CC_ERROR;
    else
	return CC_REFRESH;
}
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@sync the libraries as well before doing flag day
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.4 2003/05/01 21:11:21 avsm Exp $	*/
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.4 2003/05/01 21:11:21 avsm Exp $";
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.5 2003/06/02 20:18:40 millert Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.5 2003/06/02 20:18:40 millert Exp $";
@


1.1.1.4
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 2
a2 2
/*	$OpenBSD: common.c,v 1.6 2003/10/31 08:42:24 otto Exp $	*/
/*	$NetBSD: common.c,v 1.16 2003/08/07 16:44:30 agc Exp $	*/
a35 1
#include "config.h"
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.6 2003/10/31 08:42:24 otto Exp $";
d47 1
d50 1
a50 1
/* ed_end_of_file():
d56 3
a58 1
ed_end_of_file(EditLine *el, int c __attribute__((__unused__)))
d60 3
a62 4

	re_goto_bottom(el);
	*el->el_line.lastchar = '\0';
	return (CC_EOF);
d66 1
a66 1
/* ed_insert():
d71 3
a73 1
ed_insert(EditLine *el, int c)
d75 29
a103 1
	int count = el->el_state.argument;
d105 3
a107 2
	if (c == '\0')
		return (CC_ERROR);
d109 1
a109 6
	if (el->el_line.lastchar + el->el_state.argument >=
	    el->el_line.limit) {
		/* end of buffer space, try to allocate more */
		if (!ch_enlargebufs(el, (size_t) count))
			return CC_ERROR;	/* error allocating more */
	}
d111 4
a114 15
	if (count == 1) {
		if (el->el_state.inputmode == MODE_INSERT
		    || el->el_line.cursor >= el->el_line.lastchar)
			c_insert(el, 1);

		*el->el_line.cursor++ = c;
		re_fastaddc(el);		/* fast refresh for one char. */
	} else {
		if (el->el_state.inputmode != MODE_REPLACE_1)
			c_insert(el, el->el_state.argument);

		while (count-- && el->el_line.cursor < el->el_line.lastchar)
			*el->el_line.cursor++ = c;
		re_refresh(el);
	}
d116 2
a117 2
	if (el->el_state.inputmode == MODE_REPLACE_1)
		return vi_command_mode(el, 0);
d119 1
a119 1
	return (CC_NORM);
d123 1
a123 1
/* ed_delete_prev_word():
d129 3
a131 1
ed_delete_prev_word(EditLine *el, int c __attribute__((__unused__)))
d133 1
a133 1
	char *cp, *p, *kp;
d135 2
a136 2
	if (el->el_line.cursor == el->el_line.buffer)
		return (CC_ERROR);
d138 2
a139 2
	cp = c__prev_word(el->el_line.cursor, el->el_line.buffer,
	    el->el_state.argument, ce__isword);
d141 3
a143 3
	for (p = cp, kp = el->el_chared.c_kill.buf; p < el->el_line.cursor; p++)
		*kp++ = *p;
	el->el_chared.c_kill.last = kp;
d145 5
a149 5
	c_delbefore(el, el->el_line.cursor - cp);	/* delete before dot */
	el->el_line.cursor = cp;
	if (el->el_line.cursor < el->el_line.buffer)
		el->el_line.cursor = el->el_line.buffer; /* bounds check */
	return (CC_REFRESH);
d153 1
a153 1
/* ed_delete_next_char():
d159 8
a166 8
ed_delete_next_char(EditLine *el, int c __attribute__((__unused__)))
{
#ifdef notdef			/* XXX */
#define	EL	el->el_line
	(void) fprintf(el->el_errlfile,
	    "\nD(b: %x(%s)  c: %x(%s) last: %x(%s) limit: %x(%s)\n",
	    EL.buffer, EL.buffer, EL.cursor, EL.cursor, EL.lastchar,
	    EL.lastchar, EL.limit, EL.limit);
d168 4
a171 5
	if (el->el_line.cursor == el->el_line.lastchar) {
			/* if I'm at the end */
		if (el->el_map.type == MAP_VI) {
			if (el->el_line.cursor == el->el_line.buffer) {
				/* if I'm also at the beginning */
d173 1
a173 1
				return (CC_ERROR);
d175 3
a177 4
				term_overwrite(el, STReof, 4);
					/* then do a EOF */
				term__flush();
				return (CC_EOF);
d179 2
a180 1
			} else {
d182 1
a182 1
				el->el_line.cursor--;
d184 1
a184 1
				return (CC_ERROR);
d186 1
a186 7
			}
		} else {
			if (el->el_line.cursor != el->el_line.buffer)
				el->el_line.cursor--;
			else
				return (CC_ERROR);
		}
d188 11
a198 6
	c_delafter(el, el->el_state.argument);	/* delete after dot */
	if (el->el_line.cursor >= el->el_line.lastchar &&
	    el->el_line.cursor > el->el_line.buffer)
			/* bounds check */
		el->el_line.cursor = el->el_line.lastchar - 1;
	return (CC_REFRESH);
d202 1
a202 1
/* ed_kill_line():
d208 3
a210 1
ed_kill_line(EditLine *el, int c __attribute__((__unused__)))
d212 1
a212 1
	char *kp, *cp;
d214 7
a220 8
	cp = el->el_line.cursor;
	kp = el->el_chared.c_kill.buf;
	while (cp < el->el_line.lastchar)
		*kp++ = *cp++;	/* copy it */
	el->el_chared.c_kill.last = kp;
			/* zap! -- delete to end */
	el->el_line.lastchar = el->el_line.cursor;
	return (CC_REFRESH);
d224 1
a224 1
/* ed_move_to_end():
d230 3
a232 1
ed_move_to_end(EditLine *el, int c __attribute__((__unused__)))
d234 2
a235 3

	el->el_line.cursor = el->el_line.lastchar;
	if (el->el_map.type == MAP_VI) {
d237 1
a237 1
		el->el_line.cursor--;
d239 3
a241 4
		if (el->el_chared.c_vcmd.action != NOP) {
			cv_delfini(el);
			return (CC_REFRESH);
		}
d243 2
a244 1
	return (CC_CURSOR);
d248 1
a248 1
/* ed_move_to_beg():
d254 3
a256 1
ed_move_to_beg(EditLine *el, int c __attribute__((__unused__)))
d258 1
d260 9
a268 1
	el->el_line.cursor = el->el_line.buffer;
d270 1
a270 10
	if (el->el_map.type == MAP_VI) {
			/* We want FIRST non space character */
		while (isspace((unsigned char) *el->el_line.cursor))
			el->el_line.cursor++;
		if (el->el_chared.c_vcmd.action != NOP) {
			cv_delfini(el);
			return (CC_REFRESH);
		}
	}
	return (CC_CURSOR);
d274 1
a274 1
/* ed_transpose_chars():
d279 19
a297 17
ed_transpose_chars(EditLine *el, int c)
{

	if (el->el_line.cursor < el->el_line.lastchar) {
		if (el->el_line.lastchar <= &el->el_line.buffer[1])
			return (CC_ERROR);
		else
			el->el_line.cursor++;
	}
	if (el->el_line.cursor > &el->el_line.buffer[1]) {
		/* must have at least two chars entered */
		c = el->el_line.cursor[-2];
		el->el_line.cursor[-2] = el->el_line.cursor[-1];
		el->el_line.cursor[-1] = c;
		return (CC_REFRESH);
	} else
		return (CC_ERROR);
d301 1
a301 1
/* ed_next_char():
d307 3
a309 1
ed_next_char(EditLine *el, int c __attribute__((__unused__)))
d311 2
a312 1
	char *lim = el->el_line.lastchar;
d314 3
a316 9
	if (el->el_line.cursor >= lim ||
	    (el->el_line.cursor == lim - 1 &&
	    el->el_map.type == MAP_VI &&
	    el->el_chared.c_vcmd.action == NOP))
		return (CC_ERROR);

	el->el_line.cursor += el->el_state.argument;
	if (el->el_line.cursor > lim)
		el->el_line.cursor = lim;
d318 7
a324 6
	if (el->el_map.type == MAP_VI)
		if (el->el_chared.c_vcmd.action != NOP) {
			cv_delfini(el);
			return (CC_REFRESH);
		}
	return (CC_CURSOR);
d328 1
a328 1
/* ed_prev_word():
d334 3
a336 1
ed_prev_word(EditLine *el, int c __attribute__((__unused__)))
d338 2
d341 3
a343 2
	if (el->el_line.cursor == el->el_line.buffer)
		return (CC_ERROR);
d345 5
a349 4
	el->el_line.cursor = c__prev_word(el->el_line.cursor,
	    el->el_line.buffer,
	    el->el_state.argument,
	    ce__isword);
d351 1
a351 6
	if (el->el_map.type == MAP_VI)
		if (el->el_chared.c_vcmd.action != NOP) {
			cv_delfini(el);
			return (CC_REFRESH);
		}
	return (CC_CURSOR);
d355 1
a355 1
/* ed_prev_char():
d361 3
a363 1
ed_prev_char(EditLine *el, int c __attribute__((__unused__)))
d365 4
d370 5
a374 4
	if (el->el_line.cursor > el->el_line.buffer) {
		el->el_line.cursor -= el->el_state.argument;
		if (el->el_line.cursor < el->el_line.buffer)
			el->el_line.cursor = el->el_line.buffer;
d376 4
a379 8
		if (el->el_map.type == MAP_VI)
			if (el->el_chared.c_vcmd.action != NOP) {
				cv_delfini(el);
				return (CC_REFRESH);
			}
		return (CC_CURSOR);
	} else
		return (CC_ERROR);
d383 1
a383 1
/* ed_quoted_insert():
d388 15
a402 13
ed_quoted_insert(EditLine *el, int c)
{
	int num;
	char tc;

	tty_quotemode(el);
	num = el_getc(el, &tc);
	c = (unsigned char) tc;
	tty_noquotemode(el);
	if (num == 1)
		return (ed_insert(el, c));
	else
		return (ed_end_of_file(el, 0));
d406 1
a406 1
/* ed_digit():
d410 35
a444 20
ed_digit(EditLine *el, int c)
{

	if (!isdigit(c))
		return (CC_ERROR);

	if (el->el_state.doingarg) {
			/* if doing an arg, add this in... */
		if (el->el_state.lastcmd == EM_UNIVERSAL_ARGUMENT)
			el->el_state.argument = c - '0';
		else {
			if (el->el_state.argument > 1000000)
				return (CC_ERROR);
			el->el_state.argument =
			    (el->el_state.argument * 10) + (c - '0');
		}
		return (CC_ARGHACK);
	}

	return ed_insert(el, c);
d448 1
a448 1
/* ed_argument_digit():
d453 17
a469 16
ed_argument_digit(EditLine *el, int c)
{

	if (!isdigit(c))
		return (CC_ERROR);

	if (el->el_state.doingarg) {
		if (el->el_state.argument > 1000000)
			return (CC_ERROR);
		el->el_state.argument = (el->el_state.argument * 10) +
		    (c - '0');
	} else {		/* else starting an argument */
		el->el_state.argument = c - '0';
		el->el_state.doingarg = 1;
	}
	return (CC_ARGHACK);
d473 1
a473 1
/* ed_unassigned():
d479 7
a485 4
ed_unassigned(EditLine *el, int c __attribute__((__unused__)))
{

	return (CC_ERROR);
d493 1
a493 1
/* ed_tty_sigint():
d499 5
a503 5
ed_tty_sigint(EditLine *el __attribute__((__unused__)), 
	      int c __attribute__((__unused__)))
{

	return (CC_NORM);
d507 1
a507 1
/* ed_tty_dsusp():
d513 3
a515 2
ed_tty_dsusp(EditLine *el __attribute__((__unused__)), 
	     int c __attribute__((__unused__)))
d517 1
a517 2

	return (CC_NORM);
d521 1
a521 1
/* ed_tty_flush_output():
d527 3
a529 2
ed_tty_flush_output(EditLine *el __attribute__((__unused__)), 
		    int c __attribute__((__unused__)))
d531 1
a531 2

	return (CC_NORM);
d535 1
a535 1
/* ed_tty_sigquit():
d541 3
a543 2
ed_tty_sigquit(EditLine *el __attribute__((__unused__)), 
	       int c __attribute__((__unused__)))
d545 1
a545 2

	return (CC_NORM);
d549 1
a549 1
/* ed_tty_sigtstp():
d555 3
a557 2
ed_tty_sigtstp(EditLine *el __attribute__((__unused__)), 
	       int c __attribute__((__unused__)))
d559 1
a559 2

	return (CC_NORM);
d563 1
a563 1
/* ed_tty_stop_output():
d569 3
a571 2
ed_tty_stop_output(EditLine *el __attribute__((__unused__)), 
		   int c __attribute__((__unused__)))
d573 1
a573 2

	return (CC_NORM);
d577 1
a577 1
/* ed_tty_start_output():
d583 3
a585 2
ed_tty_start_output(EditLine *el __attribute__((__unused__)), 
		    int c __attribute__((__unused__)))
d587 1
a587 2

	return (CC_NORM);
d591 1
a591 1
/* ed_newline():
d597 3
a599 1
ed_newline(EditLine *el, int c __attribute__((__unused__)))
d601 6
a606 5

	re_goto_bottom(el);
	*el->el_line.lastchar++ = '\n';
	*el->el_line.lastchar = '\0';
	return (CC_NEWLINE);
d610 1
a610 1
/* ed_delete_prev_char():
d616 12
a627 11
ed_delete_prev_char(EditLine *el, int c __attribute__((__unused__)))
{

	if (el->el_line.cursor <= el->el_line.buffer)
		return (CC_ERROR);

	c_delbefore(el, el->el_state.argument);
	el->el_line.cursor -= el->el_state.argument;
	if (el->el_line.cursor < el->el_line.buffer)
		el->el_line.cursor = el->el_line.buffer;
	return (CC_REFRESH);
d631 1
a631 1
/* ed_clear_screen():
d637 3
a639 1
ed_clear_screen(EditLine *el, int c __attribute__((__unused__)))
d641 3
a643 4

	term_clear_screen(el);	/* clear the whole real screen */
	re_clear_display(el);	/* reset everything */
	return (CC_REFRESH);
d647 1
a647 1
/* ed_redisplay():
d653 3
a655 2
ed_redisplay(EditLine *el __attribute__((__unused__)), 
	     int c __attribute__((__unused__)))
d657 1
a657 2

	return (CC_REDISPLAY);
d661 1
a661 1
/* ed_start_over():
d667 3
a669 1
ed_start_over(EditLine *el, int c __attribute__((__unused__)))
d671 2
a672 3

	ch_reset(el);
	return (CC_REFRESH);
d676 1
a676 1
/* ed_sequence_lead_in():
d682 3
a684 2
ed_sequence_lead_in(EditLine *el __attribute__((__unused__)), 
		    int c __attribute__((__unused__)))
d686 1
a686 2

	return (CC_NORM);
d690 1
a690 1
/* ed_prev_history():
d696 3
a698 1
ed_prev_history(EditLine *el, int c __attribute__((__unused__)))
d700 11
a710 2
	char beep = 0;
	int sv_event = el->el_history.eventno;
d712 1
a712 2
	el->el_chared.c_undo.len = -1;
	*el->el_line.lastchar = '\0';		/* just in case */
d714 5
a718 8
	if (el->el_history.eventno == 0) {	/* save the current buffer
						 * away */
		(void) strncpy(el->el_history.buf, el->el_line.buffer,
		    EL_BUFSIZ);
		el->el_history.last = el->el_history.buf +
		    (el->el_line.lastchar - el->el_line.buffer);
	}
	el->el_history.eventno += el->el_state.argument;
d720 5
a724 12
	if (hist_get(el) == CC_ERROR) {
		if (el->el_map.type == MAP_VI) {
			el->el_history.eventno = sv_event;
			return CC_ERROR;
		}
		beep = 1;
		/* el->el_history.eventno was fixed by first call */
		(void) hist_get(el);
	}
	if (beep)
		return CC_REFRESH_BEEP;
	return CC_REFRESH;
d728 1
a728 1
/* ed_next_history():
d734 3
a736 1
ed_next_history(EditLine *el, int c __attribute__((__unused__)))
d738 2
a739 1
	el_action_t beep = CC_REFRESH, rval;
d741 1
a741 2
	el->el_chared.c_undo.len = -1;
	*el->el_line.lastchar = '\0';	/* just in case */
d743 4
a746 10
	el->el_history.eventno -= el->el_state.argument;

	if (el->el_history.eventno < 0) {
		el->el_history.eventno = 0;
		beep = CC_REFRESH_BEEP;
	}
	rval = hist_get(el);
	if (rval == CC_REFRESH)
		return beep;
	return rval;
d748 1
d752 1
a752 1
/* ed_search_prev_history():
d758 12
a769 10
ed_search_prev_history(EditLine *el, int c __attribute__((__unused__)))
{
	const char *hp;
	int h;
	bool_t found = 0;

	el->el_chared.c_vcmd.action = NOP;
	el->el_chared.c_undo.len = -1;
	*el->el_line.lastchar = '\0';	/* just in case */
	if (el->el_history.eventno < 0) {
d771 1
a771 2
		(void) fprintf(el->el_errfile,
		    "e_prev_search_hist(): eventno < 0;\n");
d773 14
a786 11
		el->el_history.eventno = 0;
		return (CC_ERROR);
	}
	if (el->el_history.eventno == 0) {
		(void) strncpy(el->el_history.buf, el->el_line.buffer,
		    EL_BUFSIZ);
		el->el_history.last = el->el_history.buf +
		    (el->el_line.lastchar - el->el_line.buffer);
	}
	if (el->el_history.ref == NULL)
		return (CC_ERROR);
d788 3
a790 3
	hp = HIST_FIRST(el);
	if (hp == NULL)
		return (CC_ERROR);
d792 1
a792 1
	c_setpat(el);		/* Set search pattern !! */
d794 2
a795 2
	for (h = 1; h <= el->el_history.eventno; h++)
		hp = HIST_NEXT(el);
d797 1
a797 1
	while (hp != NULL) {
d799 1
a799 1
		(void) fprintf(el->el_errfile, "Comparing with \"%s\"\n", hp);
d801 10
a810 10
		if ((strncmp(hp, el->el_line.buffer, (size_t)
			    (el->el_line.lastchar - el->el_line.buffer)) ||
			hp[el->el_line.lastchar - el->el_line.buffer]) &&
		    c_hmatch(el, hp)) {
			found++;
			break;
		}
		h++;
		hp = HIST_NEXT(el);
	}
d812 1
a812 1
	if (!found) {
d814 1
a814 1
		(void) fprintf(el->el_errfile, "not found\n");
d816 4
a819 3
		return (CC_ERROR);
	}
	el->el_history.eventno = h;
d821 1
a821 1
	return (hist_get(el));
d825 1
a825 1
/* ed_search_next_history():
d831 3
a833 1
ed_search_next_history(EditLine *el, int c __attribute__((__unused__)))
d835 3
a837 3
	const char *hp;
	int h;
	bool_t found = 0;
d839 3
a841 3
	el->el_chared.c_vcmd.action = NOP;
	el->el_chared.c_undo.len = -1;
	*el->el_line.lastchar = '\0';	/* just in case */
d843 2
a844 2
	if (el->el_history.eventno == 0)
		return (CC_ERROR);
d846 2
a847 2
	if (el->el_history.ref == NULL)
		return (CC_ERROR);
d849 3
a851 3
	hp = HIST_FIRST(el);
	if (hp == NULL)
		return (CC_ERROR);
d853 1
a853 1
	c_setpat(el);		/* Set search pattern !! */
d855 1
a855 1
	for (h = 1; h < el->el_history.eventno && hp; h++) {
d857 1
a857 1
		(void) fprintf(el->el_errfile, "Comparing with \"%s\"\n", hp);
d859 7
a865 7
		if ((strncmp(hp, el->el_line.buffer, (size_t)
			    (el->el_line.lastchar - el->el_line.buffer)) ||
			hp[el->el_line.lastchar - el->el_line.buffer]) &&
		    c_hmatch(el, hp))
			found = h;
		hp = HIST_NEXT(el);
	}
d867 2
a868 2
	if (!found) {		/* is it the current history number? */
		if (!c_hmatch(el, el->el_history.buf)) {
d870 1
a870 1
			(void) fprintf(el->el_errfile, "not found\n");
d872 1
a872 2
			return (CC_ERROR);
		}
d874 3
a876 1
	el->el_history.eventno = found;
d878 1
a878 1
	return (hist_get(el));
d888 36
a923 34
ed_prev_line(EditLine *el, int c __attribute__((__unused__)))
{
	char *ptr;
	int nchars = c_hpos(el);

	/*
         * Move to the line requested
         */
	if (*(ptr = el->el_line.cursor) == '\n')
		ptr--;

	for (; ptr >= el->el_line.buffer; ptr--)
		if (*ptr == '\n' && --el->el_state.argument <= 0)
			break;

	if (el->el_state.argument > 0)
		return (CC_ERROR);

	/*
         * Move to the beginning of the line
         */
	for (ptr--; ptr >= el->el_line.buffer && *ptr != '\n'; ptr--)
		continue;

	/*
         * Move to the character requested
         */
	for (ptr++;
	    nchars-- > 0 && ptr < el->el_line.lastchar && *ptr != '\n';
	    ptr++)
		continue;

	el->el_line.cursor = ptr;
	return (CC_CURSOR);
d933 27
a959 25
ed_next_line(EditLine *el, int c __attribute__((__unused__)))
{
	char *ptr;
	int nchars = c_hpos(el);

	/*
         * Move to the line requested
         */
	for (ptr = el->el_line.cursor; ptr < el->el_line.lastchar; ptr++)
		if (*ptr == '\n' && --el->el_state.argument <= 0)
			break;

	if (el->el_state.argument > 0)
		return (CC_ERROR);

	/*
         * Move to the character requested
         */
	for (ptr++;
	    nchars-- > 0 && ptr < el->el_line.lastchar && *ptr != '\n';
	    ptr++)
		continue;

	el->el_line.cursor = ptr;
	return (CC_CURSOR);
d963 1
a963 1
/* ed_command():
d969 27
a995 13
ed_command(EditLine *el, int c __attribute__((__unused__)))
{
	char tmpbuf[EL_BUFSIZ];
	int tmplen;

	tmplen = c_gets(el, tmpbuf, "\n: ");
	term__putc('\n');

	if (tmplen < 0 || (tmpbuf[tmplen] = 0, parse_line(el, tmpbuf)) == -1)
		term_beep(el);

	el->el_map.current = el->el_map.key;
	re_clear_display(el);
@


