head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.4
	tg-mergefixes-1-branch:1.1.1.4.0.8
	tg-mergefixes-1-base:1.1.1.4
	MIROS_X:1.1.1.4.0.6
	MIROS_X_BASE:1.1.1.4
	tg-mergetmp-3:1.1.1.4
	MIRBSD_XP_MIRPPC:1.1.1.4.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.4
	MIRBSD_XP_SPARC:1.1.1.4.0.2
	MIRBSD_7quater:1.1.1.3
	cvs-200405160640:1.1.1.4
	cvs-200401271800:1.1.1.4
	cvs-200401261630:1.1.1.4
	cvs-200401021645:1.1.1.4
	MIRBSD_7_ALPHA:1.1.1.3.0.6
	MIRBSD_7:1.1.1.3.0.4
	cvs-200312222040:1.1.1.4
	MIRBSD_7ter:1.1.1.3
	MIRBSD_7_DEV:1.1.1.3.0.2
	cvs-200310020700:1.1.1.3
	cvs-200309271030:1.1.1.3
	cvs-200309251530:1.1.1.3
	cvs-200308302005:1.1.1.3
	cvs-200308171200:1.1.1.3
	ctm-3496:1.1.1.3
	ctm-3449:1.1.1.3
	ctm-3437:1.1.1.3
	cvs-200307191805:1.1.1.3
	ctm-3425:1.1.1.3
	cvs-200307091500:1.1.1.3
	ctm-3389:1.1.1.3
	cvs-200306291430:1.1.1.3
	ctm-3341:1.1.1.3
	MIRBSD_5:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	ctm-3255:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.17.46.45;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.46.45;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.05.20.56.27;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.25.54;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.22.21.07.14;	author tg;	state Stab;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: vi.c,v 1.4 2002/02/16 21:27:26 millert Exp $	*/
/*	$NetBSD: vi.c,v 1.2 1997/01/11 06:48:19 lukem Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christos Zoulas of Cornell University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if !defined(lint) && !defined(SCCSID)
#if 0
static char sccsid[] = "@@(#)vi.c	8.1 (Berkeley) 6/4/93";
#else
static char rcsid[] = "$OpenBSD: vi.c,v 1.4 2002/02/16 21:27:26 millert Exp $";
#endif
#endif /* not lint && not SCCSID */

/*
 * vi.c: Vi mode commands.
 */
#include "sys.h"
#include "el.h"

private el_action_t cv_action(EditLine *, int);

/* cv_action():
 *	Handle vi actions.
 */
private el_action_t
cv_action(el, c)
    EditLine *el;
    int c;
{
    register char *cp, *kp;

    if (el->el_chared.c_vcmd.action & DELETE) {
	el->el_chared.c_vcmd.action = NOP;
	el->el_chared.c_vcmd.pos = 0;
	
	el->el_chared.c_undo.isize = 0;
	el->el_chared.c_undo.dsize = 0;
	kp = el->el_chared.c_undo.buf;
	for (cp = el->el_line.buffer; cp < el->el_line.lastchar; cp++) {
	    *kp++ = *cp;
	    el->el_chared.c_undo.dsize++;
	}
		
	el->el_chared.c_undo.action = INSERT;
	el->el_chared.c_undo.ptr  = el->el_line.buffer;
	el->el_line.lastchar = el->el_line.buffer;
	el->el_line.cursor   = el->el_line.buffer;
	if (c & INSERT)
	    el->el_map.current = el->el_map.key;
	    
	return CC_REFRESH;
    }

    el->el_chared.c_vcmd.pos = el->el_line.cursor;
    el->el_chared.c_vcmd.action = c;
    return CC_ARGHACK;

#ifdef notdef
    /*
     * I don't think that this is needed. But we keep it for now
     */
    else if (el_chared.c_vcmd.action == NOP) {
	el->el_chared.c_vcmd.pos = el->el_line.cursor;
	el->el_chared.c_vcmd.action = c;
	return CC_ARGHACK;
    }
    else {
	el->el_chared.c_vcmd.action = 0;
	el->el_chared.c_vcmd.pos = 0;
	return CC_ERROR;
    }
#endif
}


/* cv_paste():
 *	Paste previous deletion before or after the cursor
 */
protected el_action_t
cv_paste(el, c)
    EditLine *el;
    int c;
{
    char *ptr;
    c_undo_t *un = &el->el_chared.c_undo;
#ifdef DEBUG_PASTE
    (void)fprintf(el->el_errfile, "Paste: %x \"%s\" +%d -%d\n", 
		   un->action, un->buf, un->isize, un->dsize);
#endif
    if (un->isize == 0)
	return CC_ERROR;

    if (!c && el->el_line.cursor < el->el_line.lastchar)
	el->el_line.cursor++;
    ptr = el->el_line.cursor;
	
    c_insert(el, un->isize);
    if (el->el_line.cursor + un->isize > el->el_line.lastchar)
	return CC_ERROR;
    (void)memcpy(ptr, un->buf, un->isize);
    return CC_REFRESH;
}


/* vi_paste_next(): 
 *	Vi paste previous deletion to the right of the cursor
 *	[p]
 */
protected el_action_t
/*ARGSUSED*/
vi_paste_next(el, c)
    EditLine *el;
    int c;
{
    return cv_paste(el, 0);
}


/* vi_paste_prev(): 
 *	Vi paste previous deletion to the left of the cursor
 *	[P]
 */
protected el_action_t
/*ARGSUSED*/
vi_paste_prev(el, c)
    EditLine *el;
    int c;
{
    return cv_paste(el, 1);
}


/* vi_prev_space_word(): 
 *	Vi move to the previous space delimited word
 *	[B]
 */
protected el_action_t
/*ARGSUSED*/
vi_prev_space_word(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor == el->el_line.buffer)
	return CC_ERROR;

    el->el_line.cursor = cv_prev_word(el, el->el_line.cursor, 
				      el->el_line.buffer, 
			 	      el->el_state.argument, 
				      cv__isword); 

    if (el->el_chared.c_vcmd.action & DELETE) {
	cv_delfini(el);
	return CC_REFRESH;
    }

    return CC_CURSOR;
}


/* vi_prev_word(): 
 *	Vi move to the previous word
 *	[B]
 */
protected el_action_t
/*ARGSUSED*/
vi_prev_word(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor == el->el_line.buffer)
	return CC_ERROR;

    el->el_line.cursor = cv_prev_word(el, el->el_line.cursor, 
				      el->el_line.buffer, 
			 	      el->el_state.argument, 
				      ce__isword); 

    if (el->el_chared.c_vcmd.action & DELETE) {
	cv_delfini(el);
	return CC_REFRESH;
    }

    return CC_CURSOR;
}


/* vi_next_space_word(): 
 *	Vi move to the next space delimited word
 *	[W]
 */
protected el_action_t
/*ARGSUSED*/
vi_next_space_word(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor == el->el_line.lastchar)
	return CC_ERROR;

    el->el_line.cursor = cv_next_word(el, el->el_line.cursor, 
				      el->el_line.lastchar, 
				      el->el_state.argument, 
				      cv__isword);

    if (el->el_map.type == MAP_VI)
	if (el->el_chared.c_vcmd.action & DELETE) {
	    cv_delfini(el);
	    return CC_REFRESH;
	}

    return CC_CURSOR;
}

/* vi_next_word(): 
 *	Vi move to the next word
 *	[w]
 */
protected el_action_t
/*ARGSUSED*/
vi_next_word(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor == el->el_line.lastchar)
	return CC_ERROR;

    el->el_line.cursor = cv_next_word(el, el->el_line.cursor, 
				      el->el_line.lastchar, 
				      el->el_state.argument,
				      ce__isword);

    if (el->el_map.type == MAP_VI)
	if (el->el_chared.c_vcmd.action & DELETE) {
	    cv_delfini(el);
	    return CC_REFRESH;
	}

    return CC_CURSOR;
}



/* vi_change_case(): 
 *	Vi change case of character under the cursor and advance one character
 *	[~]
 */
protected el_action_t
vi_change_case(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor < el->el_line.lastchar) {
	c = *el->el_line.cursor;
	if (isupper(c))
	    *el->el_line.cursor++ = tolower(c);
	else if (islower(c))
	    *el->el_line.cursor++ = toupper(c);
	else
	    el->el_line.cursor++;
	re_fastaddc(el);
	return CC_NORM;
    }
    return CC_ERROR;
}


/* vi_change_meta(): 
 *	Vi change prefix command
 *	[c]
 */
protected el_action_t
/*ARGSUSED*/
vi_change_meta(el, c)
    EditLine *el;
    int c;
{
    /*
     * Delete with insert == change: first we delete and then we leave in
     * insert mode.
     */
    return cv_action(el, DELETE|INSERT);
}


/* vi_insert_at_bol(): 
 *	Vi enter insert mode at the beginning of line
 *	[I]
 */
protected el_action_t
/*ARGSUSED*/
vi_insert_at_bol(el, c)
    EditLine *el;
    int c;
{
    el->el_line.cursor = el->el_line.buffer;
    el->el_chared.c_vcmd.ins = el->el_line.cursor;

    el->el_chared.c_undo.ptr = el->el_line.cursor;
    el->el_chared.c_undo.action = DELETE;

    el->el_map.current = el->el_map.key;
    return CC_CURSOR;
}


/* vi_replace_char(): 
 *	Vi replace character under the cursor with the next character typed
 *	[r]
 */
protected el_action_t
/*ARGSUSED*/
vi_replace_char(el, c)
    EditLine *el;
    int c;
{
    el->el_map.current = el->el_map.key;
    el->el_state.inputmode = MODE_REPLACE_1;
    el->el_chared.c_undo.action = CHANGE;
    el->el_chared.c_undo.ptr = el->el_line.cursor;
    el->el_chared.c_undo.isize = 0;
    el->el_chared.c_undo.dsize = 0;
    return CC_NORM;
}


/* vi_replace_mode(): 
 *	Vi enter replace mode
 *	[R]
 */
protected el_action_t
/*ARGSUSED*/
vi_replace_mode(el, c)
    EditLine *el;
    int c;
{
    el->el_map.current = el->el_map.key;
    el->el_state.inputmode = MODE_REPLACE;
    el->el_chared.c_undo.action = CHANGE;
    el->el_chared.c_undo.ptr = el->el_line.cursor;
    el->el_chared.c_undo.isize = 0;
    el->el_chared.c_undo.dsize = 0;
    return CC_NORM;
}


/* vi_substitute_char(): 
 *	Vi replace character under the cursor and enter insert mode
 *	[r]
 */
protected el_action_t
/*ARGSUSED*/
vi_substitute_char(el, c)
    EditLine *el;
    int c;
{
    c_delafter(el, el->el_state.argument);
    el->el_map.current = el->el_map.key;
    return CC_REFRESH;
}


/* vi_substitute_line(): 
 *	Vi substitute entire line
 *	[S]
 */
protected el_action_t
/*ARGSUSED*/
vi_substitute_line(el, c)
    EditLine *el;
    int c;
{
    (void)em_kill_line(el, 0);
    el->el_map.current = el->el_map.key;
    return CC_REFRESH;
}


/* vi_change_to_eol(): 
 *	Vi change to end of line
 *	[C]
 */
protected el_action_t
/*ARGSUSED*/
vi_change_to_eol(el, c)
    EditLine *el;
    int c;
{
    (void)ed_kill_line(el, 0);
    el->el_map.current = el->el_map.key;
    return CC_REFRESH;
}


/* vi_insert():
 *	Vi enter insert mode
 *	[i]
 */
protected el_action_t
/*ARGSUSED*/
vi_insert(el, c)
    EditLine *el;
    int c;
{
    el->el_map.current = el->el_map.key;

    el->el_chared.c_vcmd.ins = el->el_line.cursor;
    el->el_chared.c_undo.ptr = el->el_line.cursor;
    el->el_chared.c_undo.action = DELETE;

    return CC_NORM;
}


/* vi_add():
 *	Vi enter insert mode after the cursor 
 *	[a]
 */
protected el_action_t
/*ARGSUSED*/
vi_add(el, c)
    EditLine *el;
    int c;
{
    int ret;
    el->el_map.current = el->el_map.key;
    if (el->el_line.cursor < el->el_line.lastchar) {
	el->el_line.cursor++;
	if (el->el_line.cursor > el->el_line.lastchar)
	    el->el_line.cursor = el->el_line.lastchar;
	ret = CC_CURSOR;
    }
    else
	ret = CC_NORM;

    el->el_chared.c_vcmd.ins = el->el_line.cursor;
    el->el_chared.c_undo.ptr = el->el_line.cursor;
    el->el_chared.c_undo.action = DELETE;

    return ret;
}


/* vi_add_at_eol():
 *	Vi enter insert mode at end of line
 *	[A]
 */
protected el_action_t
/*ARGSUSED*/
vi_add_at_eol(el, c)
    EditLine *el;
    int c;
{
    el->el_map.current = el->el_map.key;
    el->el_line.cursor = el->el_line.lastchar;

    /* Mark where insertion begins */
    el->el_chared.c_vcmd.ins = el->el_line.lastchar; 
    el->el_chared.c_undo.ptr = el->el_line.lastchar;
    el->el_chared.c_undo.action = DELETE;
    return CC_CURSOR;
}


/* vi_delete_meta():
 *	Vi delete prefix command 
 *	[d]
 */
protected el_action_t
/*ARGSUSED*/
vi_delete_meta(el, c)
    EditLine *el;
    int c;
{
    return cv_action(el, DELETE);
}


/* vi_end_word():
 *	Vi move to the end of the current space delimited word 
 *	[E] 
 */
protected el_action_t
/*ARGSUSED*/
vi_end_word(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor == el->el_line.lastchar)
	return CC_ERROR;

    el->el_line.cursor = cv__endword(el->el_line.cursor, el->el_line.lastchar, 
				     el->el_state.argument);

    if (el->el_chared.c_vcmd.action & DELETE) {
	el->el_line.cursor++;
	cv_delfini(el);
	return CC_REFRESH;
    }

    return CC_CURSOR;
}


/* vi_to_end_word():
 *	Vi move to the end of the current word
 *	[e]
 */
protected el_action_t
/*ARGSUSED*/
vi_to_end_word(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor == el->el_line.lastchar)
	return CC_ERROR;

    el->el_line.cursor = cv__endword(el->el_line.cursor, el->el_line.lastchar, 
				     el->el_state.argument);

    if (el->el_chared.c_vcmd.action & DELETE) {
	el->el_line.cursor++;
	cv_delfini(el);
	return CC_REFRESH;
    }

    return CC_CURSOR;
}


/* vi_undo():
 *	Vi undo last change
 *	[u]
 */
protected el_action_t
/*ARGSUSED*/
vi_undo(el, c)
    EditLine *el;
    int c;
{
    char *cp, *kp;
    char temp;
    int	 i, size;
    c_undo_t *un = &el->el_chared.c_undo;

#ifdef DEBUG_UNDO
    (void)fprintf(el->el_errfile, "Undo: %x \"%s\" +%d -%d\n", 
		   un->action, un->buf, un->isize, un->dsize);
#endif
    switch (un->action) {
    case DELETE:
	if (un->dsize == 0) 
	    return CC_NORM;

	(void)memcpy(un->buf, un->ptr, un->dsize);
	for (cp = un->ptr; cp <= el->el_line.lastchar; cp++)
	    *cp = cp[un->dsize];

	el->el_line.lastchar -= un->dsize;
	el->el_line.cursor   =  un->ptr;
	
	un->action = INSERT;
	un->isize = un->dsize;
	un->dsize = 0;
	break;

    case DELETE|INSERT:
	size = un->isize - un->dsize;
	if (size > 0) 
	    i = un->dsize;
	else 
	    i = un->isize;
	cp = un->ptr;
	kp = un->buf;
	while (i-- > 0) {
	    temp = *kp;
	    *kp++ = *cp;
	    *cp++ = temp;
	}
	if (size > 0) {
	    el->el_line.cursor = cp;
	    c_insert(el, size);
	    while (size-- > 0 && cp < el->el_line.lastchar) {
		temp = *kp;
		*kp++ = *cp;
		*cp++ = temp;
	    }
	}
	else if (size < 0) {
	    size = -size;
	    for (; cp <= el->el_line.lastchar; cp++) {
		*kp++ = *cp;
		*cp = cp[size];
	    }
	    el->el_line.lastchar -= size;
	}
	el->el_line.cursor = un->ptr;
	i = un->dsize;
	un->dsize = un->isize;
	un->isize = i;
	break;

    case INSERT:
	if (un->isize == 0) 
	    return CC_NORM;

	el->el_line.cursor = un->ptr;
	c_insert(el, un->isize);
	memcpy(un->ptr, un->buf, un->isize);
	un->action = DELETE;
	un->dsize = un->isize;
	un->isize = 0;
	break;

    case CHANGE:
	if (un->isize == 0) 
	    return CC_NORM;

	el->el_line.cursor = un->ptr;
	size = (int) (el->el_line.cursor - el->el_line.lastchar); 
	if (size < un->isize)
	    size = un->isize;
	cp = un->ptr;
	kp = un->buf;
	for(i = 0; i < size; i++) {
	    temp = *kp;
	    *kp++ = *cp;
	    *cp++ = temp;
	}
	un->dsize = 0;
	break;

    default:
	return CC_ERROR;
    }

    return CC_REFRESH;
}


/* vi_command_mode():
 *	Vi enter command mode (use alternative key bindings)
 *	[<ESC>]
 */
protected el_action_t
/*ARGSUSED*/
vi_command_mode(el, c)
    EditLine *el;
    int c;
{
    int size;
    /* [Esc] cancels pending action */
    el->el_chared.c_vcmd.ins = 0;
    el->el_chared.c_vcmd.action = NOP;	
    el->el_chared.c_vcmd.pos = 0;

    el->el_state.doingarg = 0;
    size = el->el_chared.c_undo.ptr - el->el_line.cursor;
    if (size < 0)
	size = -size;
    if (el->el_chared.c_undo.action == (INSERT|DELETE) ||
        el->el_chared.c_undo.action == DELETE)
	el->el_chared.c_undo.dsize = size;
    else
	el->el_chared.c_undo.isize = size;

    el->el_state.inputmode = MODE_INSERT;
    el->el_map.current = el->el_map.alt;
#ifdef VI_MOVE
    if (el->el_line.cursor > el->el_line.buffer)
	el->el_line.cursor--;
#endif
    return CC_CURSOR;
}

/* vi_zero():
 *	Vi move to the beginning of line 
 *	[0]
 */
protected el_action_t
vi_zero(el, c)
    EditLine *el;
    int c;
{
    if (el->el_state.doingarg) {
	if (el->el_state.argument > 1000000)
	    return CC_ERROR;
	el->el_state.argument = 
		(el->el_state.argument * 10) + (c - '0');
	return CC_ARGHACK;
    }
    else {
	el->el_line.cursor = el->el_line.buffer;
	if (el->el_chared.c_vcmd.action & DELETE) {
	   cv_delfini(el);
	   return CC_REFRESH;
        }
	return CC_CURSOR;
    }
}


/* vi_delete_prev_char():
 * 	Vi move to previous character (backspace) 
 *	[^H]
 */ 
protected el_action_t
/*ARGSUSED*/
vi_delete_prev_char(el, c)
    EditLine *el;
    int c;
{
    if (el->el_chared.c_vcmd.ins == 0) 
	return CC_ERROR;

    if (el->el_chared.c_vcmd.ins > 
	el->el_line.cursor - el->el_state.argument)
	return CC_ERROR;

    c_delbefore(el, el->el_state.argument);	
    el->el_line.cursor -= el->el_state.argument;

    return CC_REFRESH;
} /* end v_del_char_prev  */


/* vi_list_or_eof():
 *	Vi list choices for completion or indicate end of file if empty line
 *	[^D]
 */
protected el_action_t
/*ARGSUSED*/
vi_list_or_eof(el, c)
    EditLine *el;
    int c;
{
#ifdef notyet
    if (el->el_line.cursor == el->el_line.lastchar && 
	el->el_line.cursor == el->el_line.buffer) {
#endif
	term_overwrite(el, STReof, 4);	/* then do a EOF */
	term__flush();
	return CC_EOF;
#ifdef notyet
    }
    else {
	re_goto_bottom(el);
	*el->el_line.lastchar = '\0';	/* just in case */
	return CC_LIST_CHOICES;
    }
#endif
}


/* vi_kill_line_prev():
 *	Vi cut from beginning of line to cursor 
 *	[^U]
 */
protected el_action_t
/*ARGSUSED*/
vi_kill_line_prev(el, c)
    EditLine *el;
    int c;
{
    char *kp, *cp;

    cp = el->el_line.buffer;
    kp = el->el_chared.c_kill.buf;
    while (cp < el->el_line.cursor)
	*kp++ = *cp++;		/* copy it */
    el->el_chared.c_kill.last = kp;
    c_delbefore(el, el->el_line.cursor - el->el_line.buffer);
    el->el_line.cursor = el->el_line.buffer;		/* zap! */
    return CC_REFRESH;
}


/* vi_search_prev():
 *	Vi search history previous
 *	[?]
 */
protected el_action_t
/*ARGSUSED*/
vi_search_prev(el, c)
    EditLine *el;
    int c;
{
    return cv_search(el, ED_SEARCH_PREV_HISTORY);
}


/* vi_search_next():
 *	Vi search history next
 *	[/]
 */
protected el_action_t
/*ARGSUSED*/
vi_search_next(el, c)
    EditLine *el;
    int c;
{
    return cv_search(el, ED_SEARCH_NEXT_HISTORY);
}


/* vi_repeat_search_next():
 *	Vi repeat current search in the same search direction
 *	[n]
 */
protected el_action_t
/*ARGSUSED*/
vi_repeat_search_next(el, c)
    EditLine *el;
    int c;
{
    if (el->el_search.patlen == 0) 
	return CC_ERROR;
    else
	return cv_repeat_srch(el, el->el_search.patdir);
}


/* vi_repeat_search_prev():
 *	Vi repeat current search in the opposite search direction
 *	[N]
 */
/*ARGSUSED*/
protected el_action_t
vi_repeat_search_prev(el, c)
    EditLine *el;
    int c;
{
    if (el->el_search.patlen == 0) 
	return CC_ERROR;
    else
	return cv_repeat_srch(el, 
			      el->el_search.patdir == ED_SEARCH_PREV_HISTORY ?
			      ED_SEARCH_NEXT_HISTORY : ED_SEARCH_PREV_HISTORY);
}


/* vi_next_char():
 *	Vi move to the character specified next
 *	[f]
 */
protected el_action_t
/*ARGSUSED*/
vi_next_char(el, c)
    EditLine *el;
    int c;
{
    char ch;

    if (el_getc(el, &ch) != 1)
	return ed_end_of_file(el, 0);

    el->el_search.chadir = CHAR_FWD;
    el->el_search.chacha = ch;

    return cv_csearch_fwd(el, ch, el->el_state.argument, 0);

}


/* vi_prev_char():
 *	Vi move to the character specified previous
 *	[F]
 */
protected el_action_t
/*ARGSUSED*/
vi_prev_char(el, c)
    EditLine *el;
    int c;
{
    char ch;

    if (el_getc(el, &ch) != 1)
	return ed_end_of_file(el, 0);

    el->el_search.chadir = CHAR_BACK;
    el->el_search.chacha = ch;

    return cv_csearch_back(el, ch, el->el_state.argument, 0);
}


/* vi_to_next_char():
 *	Vi move up to the character specified next
 *	[t]
 */
protected el_action_t
/*ARGSUSED*/
vi_to_next_char(el, c)
    EditLine *el;
    int c;
{
    char ch;

    if (el_getc(el, &ch) != 1)
	return ed_end_of_file(el, 0);

    return cv_csearch_fwd(el, ch, el->el_state.argument, 1);

}


/* vi_to_prev_char():
 *	Vi move up to the character specified previous
 *	[T]
 */
protected el_action_t
/*ARGSUSED*/
vi_to_prev_char(el, c)
    EditLine *el;
    int c;
{
    char ch;
    if (el_getc(el, &ch) != 1)
	return ed_end_of_file(el, 0);

    return cv_csearch_back(el, ch, el->el_state.argument, 1);
}


/* vi_repeat_next_char():
 *	Vi repeat current character search in the same search direction
 *	[;]
 */
protected el_action_t
/*ARGSUSED*/
vi_repeat_next_char(el, c)
    EditLine *el;
    int c;
{
    if (el->el_search.chacha == 0)
	return CC_ERROR;

    return el->el_search.chadir == CHAR_FWD ? 
	cv_csearch_fwd(el, el->el_search.chacha, el->el_state.argument, 0) : 
        cv_csearch_back(el, el->el_search.chacha, el->el_state.argument, 0);
}


/* vi_repeat_prev_char():
 *	Vi repeat current character search in the opposite search direction
 *	[,]
 */
protected el_action_t
/*ARGSUSED*/
vi_repeat_prev_char(el, c)
    EditLine *el;
    int c;
{
    if (el->el_search.chacha == 0)
	return CC_ERROR;

    return el->el_search.chadir == CHAR_BACK ? 
	cv_csearch_fwd(el, el->el_search.chacha, el->el_state.argument, 0) : 
        cv_csearch_back(el, el->el_search.chacha, el->el_state.argument, 0);
}
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@sync the libraries as well before doing flag day
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.5 2003/05/01 21:11:21 avsm Exp $	*/
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: vi.c,v 1.5 2003/05/01 21:11:21 avsm Exp $";
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.6 2003/06/02 20:18:40 millert Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: vi.c,v 1.6 2003/06/02 20:18:40 millert Exp $";
@


1.1.1.4
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 2
a2 2
/*	$OpenBSD: vi.c,v 1.7 2003/10/31 08:42:24 otto Exp $	*/
/*	$NetBSD: vi.c,v 1.19 2003/08/07 16:44:35 agc Exp $	*/
a35 5
#include "config.h"
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

d40 1
a40 1
static const char rcsid[] = "$OpenBSD: vi.c,v 1.7 2003/10/31 08:42:24 otto Exp $";
d47 1
d50 1
a50 2
private el_action_t	cv_action(EditLine *, int);
private el_action_t	cv_paste(EditLine *, int);
d56 3
a58 1
cv_action(EditLine *el, int c)
d60 1
d62 21
a82 15
	if (el->el_chared.c_vcmd.action != NOP) {
		/* 'cc', 'dd' and (possibly) friends */
		if (c != el->el_chared.c_vcmd.action)
			return CC_ERROR;

		if (!(c & YANK))
			cv_undo(el);
		cv_yank(el, el->el_line.buffer,
			    el->el_line.lastchar - el->el_line.buffer);
		el->el_chared.c_vcmd.action = NOP;
		el->el_chared.c_vcmd.pos = 0;
		el->el_line.lastchar = el->el_line.buffer;
		el->el_line.cursor = el->el_line.buffer;
		if (c & INSERT)
			el->el_map.current = el->el_map.key;
d84 9
a92 2
		return (CC_REFRESH);
	}
d95 8
a102 1
	return (CC_ARGHACK);
d105 1
d109 4
a112 2
private el_action_t
cv_paste(EditLine *el, int c)
d114 2
a115 6
	char *ptr;
	c_kill_t *k = &el->el_chared.c_kill;
	int len = k->last - k->buf;

	if (k->buf == NULL || len == 0)
		return (CC_ERROR);
d117 2
a118 1
	(void) fprintf(el->el_errfile, "Paste: \"%.*s\"\n", len, k->buf);
d120 2
d123 9
a131 11
	cv_undo(el);

	if (!c && el->el_line.cursor < el->el_line.lastchar)
		el->el_line.cursor++;
	ptr = el->el_line.cursor;

	c_insert(el, len);
	if (el->el_line.cursor + len > el->el_line.lastchar)
		return (CC_ERROR);
	(void) memcpy(ptr, k->buf, len +0u);
	return (CC_REFRESH);
d135 1
a135 1
/* vi_paste_next():
d141 3
a143 1
vi_paste_next(EditLine *el, int c __attribute__((__unused__)))
d145 1
a145 2

	return (cv_paste(el, 0));
d149 1
a149 1
/* vi_paste_prev():
d155 3
a157 1
vi_paste_prev(EditLine *el, int c __attribute__((__unused__)))
d159 1
a159 2

	return (cv_paste(el, 1));
d163 1
a163 1
/* vi_prev_big_word():
d169 3
a171 1
vi_prev_big_word(EditLine *el, int c)
d173 2
d176 4
a179 2
	if (el->el_line.cursor == el->el_line.buffer)
		return (CC_ERROR);
d181 4
a184 4
	el->el_line.cursor = cv_prev_word(el->el_line.cursor,
	    el->el_line.buffer,
	    el->el_state.argument,
	    cv__isWord);
d186 1
a186 5
	if (el->el_chared.c_vcmd.action != NOP) {
		cv_delfini(el);
		return (CC_REFRESH);
	}
	return (CC_CURSOR);
d190 1
a190 1
/* vi_prev_word():
d192 1
a192 1
 *	[b]
d196 3
a198 1
vi_prev_word(EditLine *el, int c __attribute__((__unused__)))
d200 2
d203 4
a206 2
	if (el->el_line.cursor == el->el_line.buffer)
		return (CC_ERROR);
d208 4
a211 4
	el->el_line.cursor = cv_prev_word(el->el_line.cursor,
	    el->el_line.buffer,
	    el->el_state.argument,
	    cv__isword);
d213 1
a213 5
	if (el->el_chared.c_vcmd.action != NOP) {
		cv_delfini(el);
		return (CC_REFRESH);
	}
	return (CC_CURSOR);
d217 1
a217 1
/* vi_next_big_word():
d223 3
a225 1
vi_next_big_word(EditLine *el, int c)
d227 2
d230 4
a233 2
	if (el->el_line.cursor >= el->el_line.lastchar - 1)
		return (CC_ERROR);
d235 5
a239 2
	el->el_line.cursor = cv_next_word(el, el->el_line.cursor,
	    el->el_line.lastchar, el->el_state.argument, cv__isWord);
d241 1
a241 6
	if (el->el_map.type == MAP_VI)
		if (el->el_chared.c_vcmd.action != NOP) {
			cv_delfini(el);
			return (CC_REFRESH);
		}
	return (CC_CURSOR);
d244 1
a244 2

/* vi_next_word():
d250 3
a252 1
vi_next_word(EditLine *el, int c __attribute__((__unused__)))
d254 2
d257 4
a260 2
	if (el->el_line.cursor >= el->el_line.lastchar - 1)
		return (CC_ERROR);
d262 5
a266 2
	el->el_line.cursor = cv_next_word(el, el->el_line.cursor,
	    el->el_line.lastchar, el->el_state.argument, cv__isword);
d268 1
a268 6
	if (el->el_map.type == MAP_VI)
		if (el->el_chared.c_vcmd.action != NOP) {
			cv_delfini(el);
			return (CC_REFRESH);
		}
	return (CC_CURSOR);
d272 2
a273 1
/* vi_change_case():
d278 13
a290 22
vi_change_case(EditLine *el, int c)
{
	int i;

	if (el->el_line.cursor >= el->el_line.lastchar)
		return (CC_ERROR);
	cv_undo(el);
	for (i = 0; i < el->el_state.argument; i++) {

		c = *(unsigned char *)el->el_line.cursor;
		if (isupper(c))
			*el->el_line.cursor = tolower(c);
		else if (islower(c))
			*el->el_line.cursor = toupper(c);

		if (++el->el_line.cursor >= el->el_line.lastchar) {
			el->el_line.cursor--;
			re_fastaddc(el);
			break;
		}
		re_fastaddc(el);
	}
d292 2
d297 1
a297 1
/* vi_change_meta():
d303 3
a305 1
vi_change_meta(EditLine *el, int c __attribute__((__unused__)))
d307 5
a311 6

	/*
         * Delete with insert == change: first we delete and then we leave in
         * insert mode.
         */
	return (cv_action(el, DELETE | INSERT));
d315 1
a315 1
/* vi_insert_at_bol():
d321 3
a323 1
vi_insert_at_bol(EditLine *el, int c __attribute__((__unused__)))
d325 5
d331 2
a332 4
	el->el_line.cursor = el->el_line.buffer;
	cv_undo(el);
	el->el_map.current = el->el_map.key;
	return (CC_CURSOR);
d336 1
a336 1
/* vi_replace_char():
d342 3
a344 1
vi_replace_char(EditLine *el, int c __attribute__((__unused__)))
d346 7
a352 8

	if (el->el_line.cursor >= el->el_line.lastchar)
		return CC_ERROR;

	el->el_map.current = el->el_map.key;
	el->el_state.inputmode = MODE_REPLACE_1;
	cv_undo(el);
	return (CC_ARGHACK);
d356 1
a356 1
/* vi_replace_mode():
d362 3
a364 1
vi_replace_mode(EditLine *el, int c __attribute__((__unused__)))
d366 7
a372 5

	el->el_map.current = el->el_map.key;
	el->el_state.inputmode = MODE_REPLACE;
	cv_undo(el);
	return (CC_NORM);
d376 1
a376 1
/* vi_substitute_char():
d378 1
a378 1
 *	[s]
d382 3
a384 1
vi_substitute_char(EditLine *el, int c __attribute__((__unused__)))
d386 3
a388 4

	c_delafter(el, el->el_state.argument);
	el->el_map.current = el->el_map.key;
	return (CC_REFRESH);
d392 1
a392 1
/* vi_substitute_line():
d398 3
a400 1
vi_substitute_line(EditLine *el, int c __attribute__((__unused__)))
d402 3
a404 7

	cv_undo(el);
	cv_yank(el, el->el_line.buffer,
		    el->el_line.lastchar - el->el_line.buffer);
	(void) em_kill_line(el, 0);
	el->el_map.current = el->el_map.key;
	return (CC_REFRESH);
d408 1
a408 1
/* vi_change_to_eol():
d414 7
a420 9
vi_change_to_eol(EditLine *el, int c __attribute__((__unused__)))
{

	cv_undo(el);
	cv_yank(el, el->el_line.cursor,
		    el->el_line.lastchar - el->el_line.cursor);
	(void) ed_kill_line(el, 0);
	el->el_map.current = el->el_map.key;
	return (CC_REFRESH);
d430 3
a432 1
vi_insert(EditLine *el, int c __attribute__((__unused__)))
d434 5
d440 1
a440 3
	el->el_map.current = el->el_map.key;
	cv_undo(el);
	return (CC_NORM);
d445 1
a445 1
 *	Vi enter insert mode after the cursor
d450 18
a467 14
vi_add(EditLine *el, int c __attribute__((__unused__)))
{
	int ret;

	el->el_map.current = el->el_map.key;
	if (el->el_line.cursor < el->el_line.lastchar) {
		el->el_line.cursor++;
		if (el->el_line.cursor > el->el_line.lastchar)
			el->el_line.cursor = el->el_line.lastchar;
		ret = CC_CURSOR;
	} else
		ret = CC_NORM;

	cv_undo(el);
d469 1
a469 1
	return (ret);
d479 12
a490 7
vi_add_at_eol(EditLine *el, int c __attribute__((__unused__)))
{

	el->el_map.current = el->el_map.key;
	el->el_line.cursor = el->el_line.lastchar;
	cv_undo(el);
	return (CC_CURSOR);
d495 1
a495 1
 *	Vi delete prefix command
d500 3
a502 1
vi_delete_meta(EditLine *el, int c __attribute__((__unused__)))
d504 1
a504 2

	return (cv_action(el, DELETE));
d508 3
a510 3
/* vi_end_big_word():
 *	Vi move to the end of the current space delimited word
 *	[E]
d514 3
a516 1
vi_end_big_word(EditLine *el, int c)
d518 2
d521 2
a522 2
	if (el->el_line.cursor == el->el_line.lastchar)
		return (CC_ERROR);
d524 5
a528 2
	el->el_line.cursor = cv__endword(el->el_line.cursor,
	    el->el_line.lastchar, el->el_state.argument, cv__isWord);
d530 1
a530 6
	if (el->el_chared.c_vcmd.action != NOP) {
		el->el_line.cursor++;
		cv_delfini(el);
		return (CC_REFRESH);
	}
	return (CC_CURSOR);
d534 1
a534 1
/* vi_end_word():
d540 3
a542 1
vi_end_word(EditLine *el, int c __attribute__((__unused__)))
d544 2
d547 2
a548 2
	if (el->el_line.cursor == el->el_line.lastchar)
		return (CC_ERROR);
d550 5
a554 2
	el->el_line.cursor = cv__endword(el->el_line.cursor,
	    el->el_line.lastchar, el->el_state.argument, cv__isword);
d556 1
a556 6
	if (el->el_chared.c_vcmd.action != NOP) {
		el->el_line.cursor++;
		cv_delfini(el);
		return (CC_REFRESH);
	}
	return (CC_CURSOR);
d566 95
a660 3
vi_undo(EditLine *el, int c __attribute__((__unused__)))
{
	c_undo_t un = el->el_chared.c_undo;
d662 3
a664 11
	if (un.len == -1)
		return CC_ERROR;

	/* switch line buffer and undo buffer */
	el->el_chared.c_undo.buf = el->el_line.buffer;
	el->el_chared.c_undo.len = el->el_line.lastchar - el->el_line.buffer;
	el->el_chared.c_undo.cursor = el->el_line.cursor - el->el_line.buffer;
	el->el_line.limit = un.buf + (el->el_line.limit - el->el_line.buffer);
	el->el_line.buffer = un.buf;
	el->el_line.cursor = un.buf + un.cursor;
	el->el_line.lastchar = un.buf + un.len;
d666 1
a666 1
	return (CC_REFRESH);
d676 19
a694 2
vi_command_mode(EditLine *el, int c __attribute__((__unused__)))
{
d696 2
a697 8
	/* [Esc] cancels pending action */
	el->el_chared.c_vcmd.action = NOP;
	el->el_chared.c_vcmd.pos = 0;

	el->el_state.doingarg = 0;

	el->el_state.inputmode = MODE_INSERT;
	el->el_map.current = el->el_map.alt;
d699 2
a700 2
	if (el->el_line.cursor > el->el_line.buffer)
		el->el_line.cursor--;
d702 1
a702 1
	return (CC_CURSOR);
a704 1

d706 1
a706 1
 *	Vi move to the beginning of line
d710 12
a721 6
vi_zero(EditLine *el, int c)
{

	if (el->el_state.doingarg)
		return ed_argument_digit(el, c);

d723 6
a728 5
	if (el->el_chared.c_vcmd.action != NOP) {
		cv_delfini(el);
		return (CC_REFRESH);
	}
	return (CC_CURSOR);
d733 3
a735 3
 * 	Vi move to previous character (backspace)
 *	[^H] in insert mode only
 */
d738 3
a740 1
vi_delete_prev_char(EditLine *el, int c __attribute__((__unused__)))
d742 2
a743 1
	char *cp;
d745 3
a747 3
	cp = el->el_line.cursor;
	if (cp <= el->el_line.buffer)
		return (CC_ERROR);
d749 2
a750 5
	/* do the delete here so we dont mess up the undo and paste buffers */
	el->el_line.cursor = --cp;
	for (; cp < el->el_line.lastchar; cp++)
		cp[0] = cp[1];
	el->el_line.lastchar = cp - 1;
d752 2
a753 2
	return (CC_REFRESH);
}
d762 3
a764 1
vi_list_or_eof(EditLine *el, int c __attribute__((__unused__)))
a765 15

	if (el->el_line.cursor == el->el_line.lastchar) {
		if (el->el_line.cursor == el->el_line.buffer) {
			term_overwrite(el, STReof, 4);	/* then do a EOF */
			term__flush();
			return (CC_EOF);
		} else {
			/*
			 * Here we could list completions, but it is an
			 * error right now
			 */
			term_beep(el);
			return (CC_ERROR);
		}
	} else {
d767 13
a779 9
		re_goto_bottom(el);
		*el->el_line.lastchar = '\0';	/* just in case */
		return (CC_LIST_CHOICES);
#else
		/*
		 * Just complain for now.
		 */
		term_beep(el);
		return (CC_ERROR);
a780 1
	}
d785 1
a785 1
 *	Vi cut from beginning of line to cursor
d790 14
a803 12
vi_kill_line_prev(EditLine *el, int c __attribute__((__unused__)))
{
	char *kp, *cp;

	cp = el->el_line.buffer;
	kp = el->el_chared.c_kill.buf;
	while (cp < el->el_line.cursor)
		*kp++ = *cp++;	/* copy it */
	el->el_chared.c_kill.last = kp;
	c_delbefore(el, el->el_line.cursor - el->el_line.buffer);
	el->el_line.cursor = el->el_line.buffer;	/* zap! */
	return (CC_REFRESH);
d813 3
a815 1
vi_search_prev(EditLine *el, int c __attribute__((__unused__)))
d817 1
a817 2

	return (cv_search(el, ED_SEARCH_PREV_HISTORY));
d827 3
a829 1
vi_search_next(EditLine *el, int c __attribute__((__unused__)))
d831 1
a831 2

	return (cv_search(el, ED_SEARCH_NEXT_HISTORY));
d841 3
a843 1
vi_repeat_search_next(EditLine *el, int c __attribute__((__unused__)))
d845 4
a848 5

	if (el->el_search.patlen == 0)
		return (CC_ERROR);
	else
		return (cv_repeat_srch(el, el->el_search.patdir));
d858 3
a860 1
vi_repeat_search_prev(EditLine *el, int c __attribute__((__unused__)))
d862 6
a867 7

	if (el->el_search.patlen == 0)
		return (CC_ERROR);
	else
		return (cv_repeat_srch(el,
		    el->el_search.patdir == ED_SEARCH_PREV_HISTORY ?
		    ED_SEARCH_NEXT_HISTORY : ED_SEARCH_PREV_HISTORY));
d877 3
a879 1
vi_next_char(EditLine *el, int c __attribute__((__unused__)))
d881 10
a890 1
	return cv_csearch(el, CHAR_FWD, -1, el->el_state.argument, 0);
d900 3
a902 1
vi_prev_char(EditLine *el, int c __attribute__((__unused__)))
d904 9
a912 1
	return cv_csearch(el, CHAR_BACK, -1, el->el_state.argument, 0);
d922 3
a924 1
vi_to_next_char(EditLine *el, int c __attribute__((__unused__)))
d926 7
a932 1
	return cv_csearch(el, CHAR_FWD, -1, el->el_state.argument, 1);
d942 9
a950 3
vi_to_prev_char(EditLine *el, int c __attribute__((__unused__)))
{
	return cv_csearch(el, CHAR_BACK, -1, el->el_state.argument, 1);
d960 3
a962 1
vi_repeat_next_char(EditLine *el, int c __attribute__((__unused__)))
d964 2
d967 3
a969 2
	return cv_csearch(el, el->el_search.chadir, el->el_search.chacha,
		el->el_state.argument, el->el_search.chatflg);
d979 3
a981 138
vi_repeat_prev_char(EditLine *el, int c __attribute__((__unused__)))
{
	el_action_t r;
	int dir = el->el_search.chadir;

	r = cv_csearch(el, -dir, el->el_search.chacha,
		el->el_state.argument, el->el_search.chatflg);
	el->el_search.chadir = dir;
	return r;
}


/* vi_match():
 *	Vi go to matching () {} or []
 *	[%]
 */
protected el_action_t
/*ARGSUSED*/
vi_match(EditLine *el, int c)
{
	const char match_chars[] = "()[]{}";
	char *cp;
	int delta, i, count;
	char o_ch, c_ch;

	*el->el_line.lastchar = '\0';		/* just in case */

	i = strcspn(el->el_line.cursor, match_chars);
	o_ch = el->el_line.cursor[i];
	if (o_ch == 0)
		return CC_ERROR;
	delta = strchr(match_chars, o_ch) - match_chars;
	c_ch = match_chars[delta ^ 1];
	count = 1;
	delta = 1 - (delta & 1) * 2;

	for (cp = &el->el_line.cursor[i]; count; ) {
		cp += delta;
		if (cp < el->el_line.buffer || cp >= el->el_line.lastchar)
			return CC_ERROR;
		if (*cp == o_ch)
			count++;
		else if (*cp == c_ch)
			count--;
	}

	el->el_line.cursor = cp;

	if (el->el_chared.c_vcmd.action != NOP) {
		/* NB posix says char under cursor should NOT be deleted
		   for -ve delta - this is different to netbsd vi. */
		if (delta > 0)
			el->el_line.cursor++;
		cv_delfini(el);
		return (CC_REFRESH);
	}
	return (CC_CURSOR);
}

/* vi_undo_line():
 *	Vi undo all changes to line
 *	[U]
 */
protected el_action_t
/*ARGSUSED*/
vi_undo_line(EditLine *el, int c)
{

	cv_undo(el);
	return hist_get(el);
}

/* vi_to_column():
 *	Vi go to specified column
 *	[|]
 * NB netbsd vi goes to screen column 'n', posix says nth character
 */
protected el_action_t
/*ARGSUSED*/
vi_to_column(EditLine *el, int c)
{

	el->el_line.cursor = el->el_line.buffer;
	el->el_state.argument--;
	return ed_next_char(el, 0);
}

/* vi_yank_end():
 *	Vi yank to end of line
 *	[Y]
 */
protected el_action_t
/*ARGSUSED*/
vi_yank_end(EditLine *el, int c)
{

	cv_yank(el, el->el_line.cursor,
		el->el_line.lastchar - el->el_line.cursor);
	return CC_REFRESH;
}

/* vi_yank():
 *	Vi yank
 *	[y]
 */
protected el_action_t
/*ARGSUSED*/
vi_yank(EditLine *el, int c)
{

	return cv_action(el, YANK);
}

/* vi_comment_out():
 *	Vi comment out current command
 *	[c]
 */
protected el_action_t
/*ARGSUSED*/
vi_comment_out(EditLine *el, int c)
{

	el->el_line.cursor = el->el_line.buffer;
	c_insert(el, 1);
	*el->el_line.cursor = '#';
	re_refresh(el);
	return ed_newline(el, 0);
}

/* vi_alias():
 *	Vi include shell alias
 *	[@@]
 * NB: posix impiles that we should enter insert mode, however
 * this is against historical precedent...
 */
protected el_action_t
/*ARGSUSED*/
vi_alias(EditLine *el, int c)
d983 1
a983 20
#ifdef __weak_extern
	char alias_name[3];
	char *alias_text;
	extern char *get_alias_text(const char *);
	__weak_extern(get_alias_text);

	if (get_alias_text == 0) {
		return CC_ERROR;
	}

	alias_name[0] = '_';
	alias_name[2] = 0;
	if (el_getc(el, &alias_name[1]) != 1)
		return CC_ERROR;

	alias_text = get_alias_text(alias_name);
	if (alias_text != NULL)
		el_push(el, alias_text);
	return CC_NORM;
#else
a984 177
#endif
}

/* vi_to_history_line():
 *	Vi go to specified history file line.
 *	[G]
 */
protected el_action_t
/*ARGSUSED*/
vi_to_history_line(EditLine *el, int c)
{
	int sv_event_no = el->el_history.eventno;
	el_action_t rval;


	if (el->el_history.eventno == 0) {
		 (void) strncpy(el->el_history.buf, el->el_line.buffer,
		     EL_BUFSIZ);
		 el->el_history.last = el->el_history.buf +
			 (el->el_line.lastchar - el->el_line.buffer);
	}

	/* Lack of a 'count' means oldest, not 1 */
	if (!el->el_state.doingarg) {
		el->el_history.eventno = 0x7fffffff;
		hist_get(el);
	} else {
		/* This is brain dead, all the rest of this code counts
		 * upwards going into the past.  Here we need count in the
		 * other direction (to match the output of fc -l).
		 * I could change the world, but this seems to suffice.
		 */
		el->el_history.eventno = 1;
		if (hist_get(el) == CC_ERROR)
			return CC_ERROR;
		el->el_history.eventno = 1 + el->el_history.ev.num 
					- el->el_state.argument;
		if (el->el_history.eventno < 0) {
			el->el_history.eventno = sv_event_no;
			return CC_ERROR;
		}
	}
	rval = hist_get(el);
	if (rval == CC_ERROR)
		el->el_history.eventno = sv_event_no;
	return rval;
}

/* vi_histedit():
 *	Vi edit history line with vi
 *	[v]
 */
protected el_action_t
/*ARGSUSED*/
vi_histedit(EditLine *el, int c)
{
	int fd;
	pid_t pid;
	int st;
	char tempfile[] = "/tmp/histedit.XXXXXXXXXX";
	char *cp;

	if (el->el_state.doingarg) {
		if (vi_to_history_line(el, 0) == CC_ERROR)
			return CC_ERROR;
	}

	fd = mkstemp(tempfile);
	if (fd < 0)
		return CC_ERROR;
	cp = el->el_line.buffer;
	write(fd, cp, el->el_line.lastchar - cp +0u);
	write(fd, "\n", 1);
	pid = fork();
	switch (pid) {
	case -1:
		close(fd);
		unlink(tempfile);
		return CC_ERROR;
	case 0:
		close(fd);
		execlp("vi", "vi", tempfile, (char*)NULL);
		exit(0);
		/*NOTREACHED*/
	default:
		while (waitpid(pid, &st, 0) != pid)
			continue;
		lseek(fd, 0ll, SEEK_SET);
		st = read(fd, cp, el->el_line.limit - cp +0u);
		if (st > 0 && cp[st - 1] == '\n')
			st--;
		el->el_line.cursor = cp;
		el->el_line.lastchar = cp + st;
		break;
	}

	close(fd);
	unlink(tempfile);
	/* return CC_REFRESH; */
	return ed_newline(el, 0);
}

/* vi_history_word():
 *	Vi append word from previous input line
 *	[_]
 * Who knows where this one came from!
 * '_' in vi means 'entire current line', so 'cc' is a synonym for 'c_'
 */
protected el_action_t
/*ARGSUSED*/
vi_history_word(EditLine *el, int c)
{
	const char *wp = HIST_FIRST(el);
	const char *wep, *wsp;
	int len;
	char *cp;
	const char *lim;

	if (wp == NULL)
		return CC_ERROR;

	wep = wsp = 0;
	do {
		while (isspace((unsigned char)*wp))
			wp++;
		if (*wp == 0)
			break;
		wsp = wp;
		while (*wp && !isspace((unsigned char)*wp))
			wp++;
		wep = wp;
	} while ((!el->el_state.doingarg || --el->el_state.argument > 0) && *wp != 0);

	if (wsp == 0 || (el->el_state.doingarg && el->el_state.argument != 0))
		return CC_ERROR;

	cv_undo(el);
	len = wep - wsp;
	if (el->el_line.cursor < el->el_line.lastchar)
		el->el_line.cursor++;
	c_insert(el, len + 1);
	cp = el->el_line.cursor;
	lim = el->el_line.limit;
	if (cp < lim)
		*cp++ = ' ';
	while (wsp < wep && cp < lim)
		*cp++ = *wsp++;
	el->el_line.cursor = cp;

	el->el_map.current = el->el_map.key;
	return CC_REFRESH;
}

/* vi_redo():
 *	Vi redo last non-motion command
 *	[.]
 */
protected el_action_t
/*ARGSUSED*/
vi_redo(EditLine *el, int c)
{
	c_redo_t *r = &el->el_chared.c_redo;

	if (!el->el_state.doingarg && r->count) {
		el->el_state.doingarg = 1;
		el->el_state.argument = r->count;
	}

	el->el_chared.c_vcmd.pos = el->el_line.cursor;
	el->el_chared.c_vcmd.action = r->action;
	if (r->pos != r->buf) {
		if (r->pos + 1 > r->lim)
			/* sanity */
			r->pos = r->lim - 1;
		r->pos[0] = 0;
		el_push(el, r->buf);
	}
d986 3
a988 3
	el->el_state.thiscmd = r->cmd;
	el->el_state.thisch = r->ch;
	return  (*el->el_map.func[r->cmd])(el, r->ch);
@


