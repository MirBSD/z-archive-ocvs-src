head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.1
	tg-mergefixes-1-branch:1.1.1.1.0.14
	tg-mergefixes-1-base:1.1.1.1
	MIROS_X:1.1.1.1.0.12
	MIROS_X_BASE:1.1.1.1
	tg-mergetmp-3:1.1.1.1
	cvs-200412031430:1.1.1.1
	MIRBSD_XP_MIRPPC:1.1.1.1.0.10
	MIRBSD_XP_SPARC_BASE:1.1.1.1
	MIRBSD_XP_SPARC:1.1.1.1.0.8
	cvs-200406230735:1.1.1.1
	MIRBSD_7quater:1.1.1.1
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.17.47.05;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.47.05;	author tg;	state Stab;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: uthread_stack.c,v 1.7 2000/03/22 02:06:05 d Exp $	*/
/*
 * Copyright 1999, David Leonard. All rights reserved.
 * <insert BSD-style license&disclaimer>
 */

/*
 * Thread stack allocation.
 *
 * If stack pointers grow down, towards the beginning of stack storage,
 * the first page of the storage is protected using mprotect() so as
 * to generate a SIGSEGV if a thread overflows its stack. Similarly,
 * for stacks that grow up, the last page of the storage is protected.
 */

#include <stddef.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/user.h>
#include <sys/mman.h>
#include <pthread.h>
#include <pthread_np.h>
#include "pthread_private.h"

struct stack *
_thread_stack_alloc(base, size)
	void *base;
	size_t size;
{
	struct stack *stack;
	int nbpg = getpagesize();

	/* Maintain a stack of default-sized stacks that we can re-use. */
	if (base == NULL && size == PTHREAD_STACK_DEFAULT) {
		if (pthread_mutex_lock(&_gc_mutex) != 0)
			PANIC("Cannot lock gc mutex");

		if ((stack = SLIST_FIRST(&_stackq)) != NULL) {
			SLIST_REMOVE_HEAD(&_stackq, qe);
			if (pthread_mutex_unlock(&_gc_mutex) != 0)
				PANIC("Cannot unlock gc mutex");
			return stack;
		}
		if (pthread_mutex_unlock(&_gc_mutex) != 0)
			PANIC("Cannot unlock gc mutex");
	}

	/* Allocate some storage to hold information about the stack: */
	stack = (struct stack *)malloc(sizeof (struct stack));
	if (stack == NULL) 
		return NULL;

	if (base != NULL) {
		/* Use the user's storage */
		stack->base = base;
		stack->size = size;
		stack->redzone = NULL;
		stack->storage = NULL;
		return stack;
	}

	/* Allocate some storage for the stack, with some overhead: */
	stack->storage = malloc(size + nbpg * 2);
	if (stack->storage == NULL) {
		free(stack);
		return NULL;
	}

	/*
	 * Compute the location of the red zone.
	 * Use _BSD_PTRDIFF_T_ to convert the storage base pointer
	 * into an integer so that page alignment can be done with
	 * integer arithmetic.
	 */
#if defined(MACHINE_STACK_GROWS_UP)
	/* Red zone is the last page of the storage: */
	stack->redzone = (void *)(((_BSD_PTRDIFF_T_)stack->storage +
	    size + nbpg - 1) & ~(nbpg - 1));
	stack->base = (caddr_t)stack->storage;
	stack->size = size;
#else
	/* Red zone is the first page of the storage: */
	stack->redzone = (void *)(((_BSD_PTRDIFF_T_)stack->storage + 
	    nbpg - 1) & ~(nbpg - 1));
	stack->base = (caddr_t)stack->redzone + nbpg;
	stack->size = size;
#endif
	if (mprotect(stack->redzone, nbpg, 0) == -1)
		PANIC("Cannot protect stack red zone");

	return stack;
}

void
_thread_stack_free(stack)
	struct stack *stack;
{
	int nbpg = getpagesize();

	/* Cache allocated stacks of default size: */
	if (stack->storage != NULL && stack->size == PTHREAD_STACK_DEFAULT)
		SLIST_INSERT_HEAD(&_stackq, stack, qe);
	else {
		/* Restore storage protection to what malloc gave us: */
		if (stack->redzone)
			mprotect(stack->redzone, nbpg,
			    PROT_READ|PROT_WRITE);

		/* Free storage: */
		if (stack->storage)
			free(stack->storage);

		/* Free stack information storage: */
		free(stack);
	}
}
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@
