head	1.17;
access;
symbols
	tg-mergetmp-mirosx-1:1.17
	tg-mergefixes-1-branch:1.17.0.100
	tg-mergefixes-1-base:1.17
	MIROS_X:1.17
	MIROS_X_BASE:1.17
	tg-mergetmp-3:1.17
	MIRBSD_XP_MIRPPC:1.6.0.4
	cvs-200410222040:1.1.1.3
	tg-mergetmp-1:1.1.1.2
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	cvs-200406230735:1.1.1.2
	MIRBSD_7quater:1.1.1.1
	cvs-200405160640:1.1.1.2
	cvs-200402042200:1.1.1.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309261655:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	ctm-3229:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2004.12.24.06.16.35;	author tg;	state Exp;
branches
	1.17.100.1;
next	1.16;

1.16
date	2004.12.23.17.25.11;	author tg;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.22.16.41.53;	author tg;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.22.15.33.01;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.22.15.32.18;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.22.04.26.41;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.22.03.01.50;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.22.02.49.24;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.22.02.48.24;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.31.16.48.27;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.22.21.53.41;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.23.14.47.04;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.06.23.12.37.11;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.09.19.20.16;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.09.16.56.06;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.09.14.49.16;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.46.33;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.46.33;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.22.21.06.49;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.10.22.20.49.09;	author tg;	state Exp;
branches;
next	;

1.17.100.1
date	2004.12.28.22.11.07;	author tg;	state Exp;
branches;
next	;


desc
@@


1.17
log
@clean up the mktime class functions (time2sub), now that
the gmtime/localtime class functions (localsub) work
- time2sub mostly rewritten
- passes FSF testsuite in 63 bit
- passes FSF testsuite in 64 bit PARTIALLY: only for UTC timezone
  (the testsuite checks Japan and USA zones itself, too bad)
- much cleaner design

get rid of override_mktime kludge
@
text
@/**	$MirBSD: src/lib/libc/time/localtime.c,v 1.16 2004/12/23 17:25:11 tg Exp $ */

/*-
 * Copyright (c) 2004
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
 *
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
 *
 * All advertising materials mentioning features or use of this soft-
 * ware must display the following acknowledgement:
 *	This product includes material provided by Thorsten Glaser.
 *
 * Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
 * any kind, expressed or implied, to the maximum extent permitted by
 * applicable law, but with the warranty of being written without ma-
 * licious intent or gross negligence; in no event shall licensor, an
 * author or contributor be held liable for any damage, direct, indi-
 * rect or other, however caused, arising in any way out of the usage
 * of this work, even if advised of the possibility of such damage.
 *-
 * based upon public domain implementation by
 * 1996-06-05 by Arthur David Olson (arthur_david_olson@@nih.gov).
 */

#include <sys/param.h>
__SCCSID("@@(#)localtime.c	7.80");
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.16 2004/12/23 17:25:11 tg Exp $");

/*
** Leap second handling from Bradley White (bww@@k.gp.cs.cmu.edu).
** POSIX-style TZ environment variable handling from Guy Harris
** (guy@@auspex.com).
*/

/* LINTLIBRARY */

#include "private.h"
#include "tzfile.h"
#include "fcntl.h"
#include "thread_private.h"

/*
** SunOS 4.1.1 headers lack O_BINARY.
*/

#ifdef O_BINARY
#define OPEN_MODE	(O_RDONLY | O_BINARY)
#else
#define OPEN_MODE	O_RDONLY
#endif

#ifndef WILDABBR
/*
** Someone might make incorrect use of a time zone abbreviation:
**	1.	They might reference tzname[0] before calling tzset (explicitly
**		or implicitly).
**	2.	They might reference tzname[1] before calling tzset (explicitly
**		or implicitly).
**	3.	They might reference tzname[1] after setting to a time zone
**		in which Daylight Saving Time is never observed.
**	4.	They might reference tzname[0] after setting to a time zone
**		in which Standard Time is never observed.
**	5.	They might reference tm.TM_ZONE after calling offtime.
** What's best to do in the above cases is open to debate;
** for now, we just set things up so that in any of the five cases
** WILDABBR is used.  Another possibility:  initialize tzname[0] to the
** string "tzname[0] used before set", and similarly for the other cases.
** And another:  initialize tzname[0] to "ERA", with an explanation in the
** manual page of what this "time zone abbreviation" means (doing this so
** that tzname[0] has the "normal" length of three characters).
*/
#define WILDABBR	"   "
#endif

static char wildabbr[] = "WILDABBR";
static const char gmt[] = "UTC";

/*
** The DST rules to use if TZ has no rules and we can't load TZDEFRULES.
** We default to US rules as of 1999-08-17.
** POSIX 1003.1 section 8.1.1 says that the default DST rules are
** implementation dependent; for historical reasons, US rules are a
** common default.
*/
#ifndef TZDEFRULESTRING
#define TZDEFRULESTRING ",M4.1.0,M10.5.0"
#endif

struct ttinfo {				/* time type information */
	long tt_gmtoff;			/* UTC offset in seconds */
	int tt_isdst;			/* used to set tm_isdst */
	int tt_abbrind;			/* abbreviation list index */
	int tt_ttisstd;			/* TRUE if transition is std time */
	int tt_ttisgmt;			/* TRUE if transition is UTC */
};

struct lsinfo {				/* leap second information */
	time_t ls_trans;		/* transition time */
	long ls_corr;			/* correction to apply */
};

#ifdef TZNAME_MAX
#define MY_TZNAME_MAX	TZNAME_MAX
#else
#define MY_TZNAME_MAX	255
#endif

struct state {
	int leapcnt;
	int timecnt;
	int typecnt;
	int charcnt;
	time_t ats[TZ_MAX_TIMES];
	unsigned char types[TZ_MAX_TIMES];
	struct ttinfo ttis[TZ_MAX_TYPES];
	/* CONSTCOND */
	char chars[MAX(MAX(TZ_MAX_CHARS + 1, sizeof gmt),
	         (2 * (MY_TZNAME_MAX + 1)))];
	struct lsinfo lsis[TZ_MAX_LEAPS];
};

struct rule {
	int r_type;			/* type of rule--see below */
	int r_day;			/* day number of rule */
	int r_week;			/* week number of rule */
	int r_mon;			/* month number of rule */
	long r_time;			/* transition time of rule */
};

#define JULIAN_DAY		0	/* Jn - Julian day */
#define DAY_OF_YEAR		1	/* n - day of year */
#define MONTH_NTH_DAY_OF_WEEK	2	/* Mm.n.d - month, week, day of week */

/*
** Prototypes for static functions.
*/

static long detzcode(const char *codep);
static const char *getzname(const char *strp);
static const char *getnum(const char *strp, int *nump, int min, int max);
static const char *getsecs(const char *strp, long *secsp);
static const char *getoffset(const char *strp, long *offsetp);
static const char *getrule(const char *strp, struct rule *rulep);
static void gmtload(struct state *sp);
static void gmtsub(const time_t *timep, long offset, struct tm *tmp);
static void localsub(const time_t *timep, long offset, struct tm *tmp);
static int increment_overflow(int *number, int delta);
static int long_increment_overflow(time_t *number, time_t delta);
static int long_normalize_overflow(time_t *tensptr, int *unitsptr, int base);
static int normalize_overflow(int *tensptr, int *unitsptr, int base);
static void settzname(void);
static time_t time1(struct tm *tmp, void (*funcp) (const time_t *, long, struct tm *), long offset);
static time_t time2(struct tm *tmp, void (*funcp) (const time_t *, long, struct tm *), long offset, int *okayp);
static time_t time2sub(struct tm *tmp, void (*funcp) (const time_t *, long, struct tm *), long offset, int *okayp, int do_norm_secs);
static void timesub(const time_t *timep, long offset, const struct state *sp, struct tm *tmp);
static int tmcomp(const struct tm *atmp, const struct tm *btmp);
static time_t transtime(time_t janfirst, int year, const struct rule *rulep, long offset);
static int tzload(const char *name, struct state *sp);
static int tzparse(const char *name, struct state *sp, int lastditch);
time_t *tm_getleaps(void);

static struct state lclmem;
static struct state gmtmem;
#define lclptr		(&lclmem)
#define gmtptr		(&gmtmem)

#ifndef TZ_STRLEN_MAX
#define TZ_STRLEN_MAX 255
#endif

static char lcl_TZname[TZ_STRLEN_MAX + 1];
static int lcl_is_set;
static int gmt_is_set;
_THREAD_PRIVATE_MUTEX(lcl);
_THREAD_PRIVATE_MUTEX(gmt);

char *tzname[2] = {
	wildabbr,
	wildabbr
};

/*
** Section 4.12.3 of X3.159-1989 requires that
**	Except for the strftime function, these functions [asctime,
**	ctime, gmtime, localtime] return values in one of two static
**	objects: a broken-down time structure and an array of char.
** Thanks to Paul Eggert (eggert@@twinsun.com) for noting this.
*/

static struct tm tm;

static long
detzcode(codep)
	const char *const codep;
{
	long result;
	int i;

	result = (codep[0] & 0x80) ? ~0L : 0L;
	for (i = 0; i < 4; ++i)
		result = (result << 8) | (codep[i] & 0xff);
	return result;
}

static void
settzname(void)
{
	struct state *const sp = lclptr;
	int i;

	tzname[0] = wildabbr;
	tzname[1] = wildabbr;
	for (i = 0; i < sp->typecnt; ++i) {
		const struct ttinfo *const ttisp = &sp->ttis[i];

		tzname[ttisp->tt_isdst] =
		    &sp->chars[ttisp->tt_abbrind];
	}
	/*
	** And to get the latest zone names into tzname. . .
	*/
	for (i = 0; i < sp->timecnt; ++i) {
		const struct ttinfo *const ttisp =
		&sp->ttis[
		    sp->types[i]];

		tzname[ttisp->tt_isdst] =
		    &sp->chars[ttisp->tt_abbrind];
	}
}

static int
tzload(name, sp)
	const char *name;
	struct state *const sp;
{
	const char *p;
	int i;
	int fid;

	if (name != NULL && issetugid() != 0)
		if ((name[0] == ':' && (strchr(name, '/') || strstr(name, ".."))) ||
		    name[0] == '/' || strchr(name, '.'))
			name = NULL;
	if (name == NULL && (name = TZDEFAULT) == NULL)
		return -1;
	{
		int doaccess;
		/*
		** Section 4.9.1 of the C standard says that
		** "FILENAME_MAX expands to an integral constant expression
		** that is the size needed for an array of char large enough
		** to hold the longest file name string that the implementation
		** guarantees can be opened."
		*/
		char fullname[FILENAME_MAX];

		if (name[0] == ':')
			++name;
		doaccess = name[0] == '/';
		if (!doaccess) {
			if ((p = TZDIR) == NULL)
				return -1;
			if ((strlen(p) + strlen(name) + 1) >= sizeof fullname)
				return -1;
			(void)strlcpy(fullname, p, sizeof fullname);
			(void)strlcat(fullname, "/", sizeof fullname);
			(void)strlcat(fullname, name, sizeof fullname);
			/*
			** Set doaccess if '.' (as in "../") shows up in name.
			*/
			if (strchr(name, '.') != NULL)
				doaccess = TRUE;
			name = fullname;
		}
		if (doaccess && access(name, R_OK) != 0)
			return -1;
		if ((fid = open(name, OPEN_MODE)) == -1)
			return -1;
	}
	{
		struct tzhead *tzhp;
		union {
			struct tzhead tzhead;
			char buf[sizeof *sp + sizeof *tzhp];
		}     u;
		int ttisstdcnt;
		int ttisgmtcnt;

		i = read(fid, u.buf, sizeof u.buf);
		if (close(fid) != 0)
			return -1;
		ttisstdcnt = (int)detzcode(u.tzhead.tzh_ttisstdcnt);
		ttisgmtcnt = (int)detzcode(u.tzhead.tzh_ttisgmtcnt);
		sp->leapcnt = (int)detzcode(u.tzhead.tzh_leapcnt);
		sp->timecnt = (int)detzcode(u.tzhead.tzh_timecnt);
		sp->typecnt = (int)detzcode(u.tzhead.tzh_typecnt);
		sp->charcnt = (int)detzcode(u.tzhead.tzh_charcnt);
		p = u.tzhead.tzh_charcnt + sizeof u.tzhead.tzh_charcnt;
		if (sp->leapcnt < 0 || sp->leapcnt > TZ_MAX_LEAPS ||
		    sp->typecnt <= 0 || sp->typecnt > TZ_MAX_TYPES ||
		    sp->timecnt < 0 || sp->timecnt > TZ_MAX_TIMES ||
		    sp->charcnt < 0 || sp->charcnt > TZ_MAX_CHARS ||
		    (ttisstdcnt != sp->typecnt && ttisstdcnt != 0) ||
		    (ttisgmtcnt != sp->typecnt && ttisgmtcnt != 0))
			return -1;
		if (i - (p - u.buf)<sp->timecnt * 4 +	/* ats */
		    sp->timecnt +	/* types */
		    sp->typecnt * (4 + 2) +	/* ttinfos */
		    sp->charcnt +	/* chars */
		    sp->leapcnt * (4 + 4) +	/* lsinfos */
		    ttisstdcnt +	/* ttisstds */
		    ttisgmtcnt)		/* ttisgmts */
			return -1;
		for (i = 0; i < sp->timecnt; ++i) {
			sp->ats[i] = detzcode(p);
			p += 4;
		}
		for (i = 0; i < sp->timecnt; ++i) {
			sp->types[i] = (unsigned char)*p++;
			if (sp->types[i] >= sp->typecnt)
				return -1;
		}
		for (i = 0; i < sp->typecnt; ++i) {
			struct ttinfo *ttisp;

			ttisp = &sp->ttis[i];
			ttisp->tt_gmtoff = detzcode(p);
			p += 4;
			ttisp->tt_isdst = (unsigned char)*p++;
			if (ttisp->tt_isdst != 0 && ttisp->tt_isdst != 1)
				return -1;
			ttisp->tt_abbrind = (unsigned char)*p++;
			if (ttisp->tt_abbrind < 0 ||
			    ttisp->tt_abbrind > sp->charcnt)
				return -1;
		}
		for (i = 0; i < sp->charcnt; ++i)
			sp->chars[i] = *p++;
		sp->chars[i] = '\0';	/* ensure '\0' at end */
		for (i = 0; i < sp->leapcnt; ++i) {
			struct lsinfo *lsisp;

			lsisp = &sp->lsis[i];
			lsisp->ls_trans = detzcode(p);
			p += 4;
			lsisp->ls_corr = detzcode(p);
			p += 4;
		}
		for (i = 0; i < sp->typecnt; ++i) {
			struct ttinfo *ttisp;

			ttisp = &sp->ttis[i];
			if (ttisstdcnt == 0)
				ttisp->tt_ttisstd = FALSE;
			else {
				ttisp->tt_ttisstd = *p++;
				if (ttisp->tt_ttisstd != TRUE &&
				    ttisp->tt_ttisstd != FALSE)
					return -1;
			}
		}
		for (i = 0; i < sp->typecnt; ++i) {
			struct ttinfo *ttisp;

			ttisp = &sp->ttis[i];
			if (ttisgmtcnt == 0)
				ttisp->tt_ttisgmt = FALSE;
			else {
				ttisp->tt_ttisgmt = *p++;
				if (ttisp->tt_ttisgmt != TRUE &&
				    ttisp->tt_ttisgmt != FALSE)
					return -1;
			}
		}
	}
	return 0;
}

static const int mon_lengths[2][MONSPERYEAR] = {
	{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
	{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};

static const int year_lengths[2] = {
	DAYSPERNYEAR, DAYSPERLYEAR
};

/*
** Given a pointer into a time zone string, scan until a character that is not
** a valid character in a zone name is found.  Return a pointer to that
** character.
*/

static const char *
getzname(strp)
	const char *strp;
{
	char c;

	while ((c = *strp) != '\0' && !is_digit(c) && c != ',' && c != '-' &&
	    c != '+')
		++strp;
	return strp;
}

/*
** Given a pointer into a time zone string, extract a number from that string.
** Check that the number is within a specified range; if it is not, return
** NULL.
** Otherwise, return a pointer to the first character not part of the number.
*/

static const char *
getnum(strp, nump, min, max)
	const char *strp;
	int *const nump;
	const int min;
	const int max;
{
	char c;
	int num;

	if (strp == NULL || !is_digit(c = *strp))
		return NULL;
	num = 0;
	do {
		num = num * 10 + (c - '0');
		if (num > max)
			return NULL;	/* illegal value */
		c = *++strp;
	} while (is_digit(c));
	if (num < min)
		return NULL;		/* illegal value */
	*nump = num;
	return strp;
}

/*
** Given a pointer into a time zone string, extract a number of seconds,
** in hh[:mm[:ss]] form, from the string.
** If any error occurs, return NULL.
** Otherwise, return a pointer to the first character not part of the number
** of seconds.
*/

static const char *
getsecs(strp, secsp)
	const char *strp;
	long *const secsp;
{
	int num;

	/*
	** `HOURSPERDAY * DAYSPERWEEK - 1' allows quasi-Posix rules like
	** "M10.4.6/26", which does not conform to Posix,
	** but which specifies the equivalent of
	** ``02:00 on the first Sunday on or after 23 Oct''.
	*/
	strp = getnum(strp, &num, 0, HOURSPERDAY * DAYSPERWEEK - 1);
	if (strp == NULL)
		return NULL;
	*secsp = num * (long)SECSPERHOUR;
	if (*strp == ':') {
		++strp;
		strp = getnum(strp, &num, 0, MINSPERHOUR - 1);
		if (strp == NULL)
			return NULL;
		*secsp += num * SECSPERMIN;
		if (*strp == ':') {
			++strp;
			/* `SECSPERMIN' allows for leap seconds.  */
			strp = getnum(strp, &num, 0, SECSPERMIN);
			if (strp == NULL)
				return NULL;
			*secsp += num;
		}
	}
	return strp;
}

/*
** Given a pointer into a time zone string, extract an offset, in
** [+-]hh[:mm[:ss]] form, from the string.
** If any error occurs, return NULL.
** Otherwise, return a pointer to the first character not part of the time.
*/

static const char *
getoffset(strp, offsetp)
	const char *strp;
	long *const offsetp;
{
	int neg = 0;

	if (*strp == '-') {
		neg = 1;
		++strp;
	} else if (*strp == '+')
		++strp;
	strp = getsecs(strp, offsetp);
	if (strp == NULL)
		return NULL;		/* illegal time */
	if (neg)
		*offsetp = -*offsetp;
	return strp;
}

/*
** Given a pointer into a time zone string, extract a rule in the form
** date[/time].  See POSIX section 8 for the format of "date" and "time".
** If a valid rule is not found, return NULL.
** Otherwise, return a pointer to the first character not part of the rule.
*/

static const char *
getrule(strp, rulep)
	const char *strp;
	struct rule *const rulep;
{
	if (*strp == 'J') {
		/*
		** Julian day.
		*/
		rulep->r_type = JULIAN_DAY;
		++strp;
		strp = getnum(strp, &rulep->r_day, 1, DAYSPERNYEAR);
	} else if (*strp == 'M') {
		/*
		** Month, week, day.
		*/
		rulep->r_type = MONTH_NTH_DAY_OF_WEEK;
		++strp;
		strp = getnum(strp, &rulep->r_mon, 1, MONSPERYEAR);
		if (strp == NULL)
			return NULL;
		if (*strp++ != '.')
			return NULL;
		strp = getnum(strp, &rulep->r_week, 1, 5);
		if (strp == NULL)
			return NULL;
		if (*strp++ != '.')
			return NULL;
		strp = getnum(strp, &rulep->r_day, 0, DAYSPERWEEK - 1);
	} else if (is_digit(*strp)) {
		/*
		** Day of year.
		*/
		rulep->r_type = DAY_OF_YEAR;
		strp = getnum(strp, &rulep->r_day, 0, DAYSPERLYEAR - 1);
	} else
		return NULL;		/* invalid format */
	if (strp == NULL)
		return NULL;
	if (*strp == '/') {
		/*
		** Time specified.
		*/
		++strp;
		strp = getsecs(strp, &rulep->r_time);
	} else
		rulep->r_time = 2 * SECSPERHOUR;	/* default = 2:00:00 */
	return strp;
}

/*
** Given the Epoch-relative time of January 1, 00:00:00 UTC, in a year, the
** year, a rule, and the offset from UTC at the time that rule takes effect,
** calculate the Epoch-relative time that rule takes effect.
*/

static time_t
transtime(janfirst, year, rulep, offset)
	const time_t janfirst;
	const int year;
	const struct rule *const rulep;
	const long offset;
{
	int leapyear;
	time_t value;
	int i;
	int d, m1, yy0, yy1, yy2, dow;

	INITIALIZE(value);
	leapyear = isleap(year);
	switch (rulep->r_type) {

	case JULIAN_DAY:
		/*
		** Jn - Julian day, 1 == January 1, 60 == March 1 even in leap
		** years.
		** In non-leap years, or if the day number is 59 or less, just
		** add SECSPERDAY times the day number-1 to the time of
		** January 1, midnight, to get the day.
		*/
		value = janfirst + (rulep->r_day - 1) * SECSPERDAY;
		if (leapyear && rulep->r_day >= 60)
			value += SECSPERDAY;
		break;

	case DAY_OF_YEAR:
		/*
		** n - day of year.
		** Just add SECSPERDAY times the day number to the time of
		** January 1, midnight, to get the day.
		*/
		value = janfirst + rulep->r_day * SECSPERDAY;
		break;

	case MONTH_NTH_DAY_OF_WEEK:
		/*
		** Mm.n.d - nth "dth day" of month m.
		*/
		value = janfirst;
		for (i = 0; i < rulep->r_mon - 1; ++i)
			value += mon_lengths[leapyear][i] * SECSPERDAY;

		/*
		** Use Zeller's Congruence to get day-of-week of first day of
		** month.
		*/
		m1 = (rulep->r_mon + 9) % 12 + 1;
		yy0 = (rulep->r_mon <= 2) ? (year - 1) : year;
		yy1 = yy0 / 100;
		yy2 = yy0 % 100;
		dow = ((26 * m1 - 2) / 10 +
		    1 + yy2 + yy2 / 4 + yy1 / 4 - 2 * yy1) % 7;
		if (dow < 0)
			dow += DAYSPERWEEK;

		/*
		** "dow" is the day-of-week of the first day of the month.  Get
		** the day-of-month (zero-origin) of the first "dow" day of the
		** month.
		*/
		d = rulep->r_day - dow;
		if (d < 0)
			d += DAYSPERWEEK;
		for (i = 1; i < rulep->r_week; ++i) {
			if (d + DAYSPERWEEK >=
			    mon_lengths[leapyear][rulep->r_mon - 1])
				break;
			d += DAYSPERWEEK;
		}

		/*
		** "d" is the day-of-month (zero-origin) of the day we want.
		*/
		value += d * SECSPERDAY;
		break;
	}

	/*
	** "value" is the Epoch-relative time of 00:00:00 UTC on the day in
	** question.  To get the Epoch-relative time of the specified local
	** time on that day, add the transition time and the current offset
	** from UTC.
	*/
	return value + rulep->r_time + offset;
}

/*
** Given a POSIX section 8-style TZ string, fill in the rule tables as
** appropriate.
*/

static int
tzparse(name, sp, lastditch)
	const char *name;
	struct state *const sp;
	const int lastditch;
{
	const char *stdname;
	const char *dstname;
	size_t stdlen;
	size_t dstlen;
	long stdoffset;
	long dstoffset;
	time_t *atp;
	unsigned char *typep;
	char *cp;
	int load_result;

	INITIALIZE(dstname);
	stdname = name;
	if (lastditch) {
		stdlen = strlen(name);	/* length of standard zone name */
		name += stdlen;
		if (stdlen >= sizeof sp->chars)
			stdlen = (sizeof sp->chars) - 1;
		stdoffset = 0;
	} else {
		name = getzname(name);
		stdlen = name - stdname;
		if (stdlen < 3)
			return -1;
		if (*name == '\0')
			return -1;
		name = getoffset(name, &stdoffset);
		if (name == NULL)
			return -1;
	}
	load_result = tzload(TZDEFRULES, sp);
	if (load_result != 0)
		sp->leapcnt = 0;	/* so, we're off a little */
	if (*name != '\0') {
		dstname = name;
		name = getzname(name);
		dstlen = name - dstname;/* length of DST zone name */
		if (dstlen < 3)
			return -1;
		if (*name != '\0' && *name != ',' && *name != ';') {
			name = getoffset(name, &dstoffset);
			if (name == NULL)
				return -1;
		} else
			dstoffset = stdoffset - SECSPERHOUR;
		if (*name == '\0' && load_result != 0)
			name = TZDEFRULESTRING;
		if (*name == ',' || *name == ';') {
			struct rule start;
			struct rule end;
			int year;
			time_t janfirst;
			time_t starttime;
			time_t endtime;

			++name;
			if ((name = getrule(name, &start)) == NULL)
				return -1;
			if (*name++ != ',')
				return -1;
			if ((name = getrule(name, &end)) == NULL)
				return -1;
			if (*name != '\0')
				return -1;
			sp->typecnt = 2;/* standard time and DST */
			/*
			** Two transitions per year, from EPOCH_YEAR to 2037.
			*/
			sp->timecnt = 2 * (2037 - EPOCH_YEAR + 1);
			if (sp->timecnt > TZ_MAX_TIMES)
				return -1;
			sp->ttis[0].tt_gmtoff = -dstoffset;
			sp->ttis[0].tt_isdst = 1;
			sp->ttis[0].tt_abbrind = stdlen + 1;
			sp->ttis[1].tt_gmtoff = -stdoffset;
			sp->ttis[1].tt_isdst = 0;
			sp->ttis[1].tt_abbrind = 0;
			atp = sp->ats;
			typep = sp->types;
			janfirst = 0;
			for (year = EPOCH_YEAR; year <= 2037; ++year) {
				starttime = transtime(janfirst, year, &start,
				    stdoffset);
				endtime = transtime(janfirst, year, &end,
				    dstoffset);
				if (starttime > endtime) {
					*atp++ = endtime;
					*typep++ = 1;	/* DST ends */
					*atp++ = starttime;
					*typep++ = 0;	/* DST begins */
				} else {
					*atp++ = starttime;
					*typep++ = 0;	/* DST begins */
					*atp++ = endtime;
					*typep++ = 1;	/* DST ends */
				}
				janfirst += year_lengths[isleap(year)] *
				    SECSPERDAY;
			}
		} else {
			long theirstdoffset;
			long theirdstoffset;
			long theiroffset;
			int isdst;
			int i;
			int j;

			if (*name != '\0')
				return -1;
			/*
			** Initial values of theirstdoffset and theirdstoffset.
			*/
			theirstdoffset = 0;
			for (i = 0; i < sp->timecnt; ++i) {
				j = sp->types[i];
				if (!sp->ttis[j].tt_isdst) {
					theirstdoffset =
					    -sp->ttis[j].tt_gmtoff;
					break;
				}
			}
			theirdstoffset = 0;
			for (i = 0; i < sp->timecnt; ++i) {
				j = sp->types[i];
				if (sp->ttis[j].tt_isdst) {
					theirdstoffset =
					    -sp->ttis[j].tt_gmtoff;
					break;
				}
			}
			/*
			** Initially we're assumed to be in standard time.
			*/
			isdst = FALSE;
			theiroffset = theirstdoffset;
			/*
			** Now juggle transition times and types
			** tracking offsets as you do.
			*/
			for (i = 0; i < sp->timecnt; ++i) {
				j = sp->types[i];
				sp->types[i] = sp->ttis[j].tt_isdst;
				if (sp->ttis[j].tt_ttisgmt) {
					/* No adjustment to transition time */
				} else {
					/*
					** If summer time is in effect, and the
					** transition time was not specified as
					** standard time, add the summer time
					** offset to the transition time;
					** otherwise, add the standard time
					** offset to the transition time.
					*/
					/*
					** Transitions from DST to DDST
					** will effectively disappear since
					** POSIX provides for only one DST
					** offset.
					*/
					if (isdst && !sp->ttis[j].tt_ttisstd) {
						sp->ats[i] += dstoffset -
						    theirdstoffset;
					} else {
						sp->ats[i] += stdoffset -
						    theirstdoffset;
					}
				}
				theiroffset = -sp->ttis[j].tt_gmtoff;
				if (sp->ttis[j].tt_isdst)
					theirdstoffset = theiroffset;
				else
					theirstdoffset = theiroffset;
			}
			/*
			** Finally, fill in ttis.
			** ttisstd and ttisgmt need not be handled.
			*/
			sp->ttis[0].tt_gmtoff = -stdoffset;
			sp->ttis[0].tt_isdst = FALSE;
			sp->ttis[0].tt_abbrind = 0;
			sp->ttis[1].tt_gmtoff = -dstoffset;
			sp->ttis[1].tt_isdst = TRUE;
			sp->ttis[1].tt_abbrind = stdlen + 1;
			sp->typecnt = 2;
		}
	} else {
		dstlen = 0;
		sp->typecnt = 1;	/* only standard time */
		sp->timecnt = 0;
		sp->ttis[0].tt_gmtoff = -stdoffset;
		sp->ttis[0].tt_isdst = 0;
		sp->ttis[0].tt_abbrind = 0;
	}
	sp->charcnt = stdlen + 1;
	if (dstlen != 0)
		sp->charcnt += dstlen + 1;
	if ((size_t)sp->charcnt > sizeof sp->chars)
		return -1;
	cp = sp->chars;
	strlcpy(cp, stdname, stdlen + 1);
	cp += stdlen + 1;
	if (dstlen != 0) {
		strlcpy(cp, dstname, dstlen + 1);
	}
	return 0;
}

static void
gmtload(sp)
	struct state *const sp;
{
	if (tzload(gmt, sp) != 0)
		(void)tzparse(gmt, sp, TRUE);
}
static
void
tzsetwall_basic(void)
{
	if (lcl_is_set < 0)
		return;
	lcl_is_set = -1;

	if (tzload((char *)NULL, lclptr) != 0)
		gmtload(lclptr);
	settzname();
}

void
tzsetwall(void)
{
	_THREAD_PRIVATE_MUTEX_LOCK(lcl);
	tzsetwall_basic();
	_THREAD_PRIVATE_MUTEX_UNLOCK(lcl);
}

static
void
tzset_basic(void)
{
	const char *name;

	name = getenv("TZ");
	if (name == NULL) {
		tzsetwall_basic();
		return;
	}
	if (lcl_is_set > 0 && strcmp(lcl_TZname, name) == 0)
		return;
	lcl_is_set = strlen(name) < sizeof lcl_TZname;
	if (lcl_is_set)
		(void)strlcpy(lcl_TZname, name, sizeof lcl_TZname);

	if (*name == '\0') {
		/*
		** User wants it fast rather than right.
		*/
		lclptr->leapcnt = 0;	/* so, we're off a little */
		lclptr->timecnt = 0;
		lclptr->typecnt = 0;
		lclptr->ttis[0].tt_isdst = 0;
		lclptr->ttis[0].tt_gmtoff = 0;
		lclptr->ttis[0].tt_abbrind = 0;
		(void)strlcpy(lclptr->chars, gmt, sizeof lclptr->chars);
	} else if (tzload(name, lclptr) != 0)
		if (name[0] == ':' || tzparse(name, lclptr, FALSE) != 0)
			(void)gmtload(lclptr);
	settzname();
}

void
tzset(void)
{
	_THREAD_PRIVATE_MUTEX_LOCK(lcl);
	tzset_basic();
	_THREAD_PRIVATE_MUTEX_UNLOCK(lcl);
}

/*
** The easy way to behave "as if no library function calls" localtime
** is to not call it--so we drop its guts into "localsub", which can be
** freely called.  (And no, the PANS doesn't require the above behavior--
** but it *is* desirable.)
**
** The unused offset argument is for the benefit of mktime variants.
*/

/*ARGSUSED*/
static void
localsub(timep, offset, tmp)
	const time_t *const timep;
	const long offset __attribute__((unused));
	struct tm *const tmp;
{
	struct state *sp;
	const struct ttinfo *ttisp;
	int i;
	const time_t t = *timep;

	sp = lclptr;
	if (sp->timecnt == 0 || t < sp->ats[0]) {
		i = 0;
		while (sp->ttis[i].tt_isdst)
			if (++i >= sp->typecnt) {
				i = 0;
				break;
			}
	} else {
		for (i = 1; i < sp->timecnt; ++i)
			if (t < sp->ats[i])
				break;
		i = sp->types[i - 1];
	}
	ttisp = &sp->ttis[i];
	/*
	** To get (wrong) behavior that's compatible with System V Release 2.0
	** you'd replace the statement below with
	**	t += ttisp->tt_gmtoff;
	**	timesub(&t, 0L, sp, tmp);
	*/
	timesub(&t, ttisp->tt_gmtoff, sp, tmp);
	tmp->tm_isdst = ttisp->tt_isdst;
	tzname[tmp->tm_isdst] = &sp->chars[ttisp->tt_abbrind];
#ifdef TM_ZONE
	tmp->TM_ZONE = &sp->chars[ttisp->tt_abbrind];
#endif /* defined TM_ZONE */
}

/*
** Re-entrant version of localtime.
*/

struct tm *
localtime_r(timep, p_tm)
	const time_t *const timep;
	struct tm *p_tm;
{
	_THREAD_PRIVATE_MUTEX_LOCK(lcl);
	tzset_basic();
	localsub(timep, 0L, p_tm);
	_THREAD_PRIVATE_MUTEX_UNLOCK(lcl);
	return p_tm;
}

struct tm *
localtime(timep)
	const time_t *const timep;
{
	_THREAD_PRIVATE_KEY(localtime);
	struct tm *p_tm = (struct tm *)_THREAD_PRIVATE(localtime, tm, NULL);

	if (p_tm == NULL)
		return NULL;
	return localtime_r(timep, p_tm);
}

/*
** gmtsub is to gmtime as localsub is to localtime.
*/

static void
gmtsub(timep, offset, tmp)
	const time_t *const timep;
	const long offset;
	struct tm *const tmp;
{
	_THREAD_PRIVATE_MUTEX_LOCK(gmt);
	if (!gmt_is_set) {
		gmt_is_set = TRUE;
		gmtload(gmtptr);
	}
	_THREAD_PRIVATE_MUTEX_UNLOCK(gmt);
	timesub(timep, offset, gmtptr, tmp);
#ifdef TM_ZONE
	/*
	** Could get fancy here and deliver something such as
	** "UTC+xxxx" or "UTC-xxxx" if offset is non-zero,
	** but this is no time for a treasure hunt.
	*/
	if (offset != 0)
		tmp->TM_ZONE = wildabbr;
	else {
		tmp->TM_ZONE = gmtptr->chars;
	}
#endif /* defined TM_ZONE */
}

/*
** Re-entrant version of gmtime.
*/

struct tm *
gmtime_r(timep, p_tm)
	const time_t *timep;
	struct tm *p_tm;
{
	gmtsub(timep, 0L, p_tm);
	return p_tm;
}

struct tm *
gmtime(timep)
	const time_t *const timep;
{
	_THREAD_PRIVATE_KEY(gmtime);
	struct tm *p_tm = (struct tm *)_THREAD_PRIVATE(gmtime, tm, NULL);

	if (p_tm == NULL)
		return NULL;
	return gmtime_r(timep, p_tm);

}

struct tm *
offtime(timep, offset)
	const time_t *const timep;
	const long offset;
{
	gmtsub(timep, offset, &tm);
	return &tm;
}

static void
timesub(timep, offset, sp, tmp)
	const time_t *const timep;
	const long offset;
	const struct state *const sp;
	struct tm *const tmp;
{
	const struct lsinfo *lp;
	time_t days;
	long rem, corr;
	int hit, i;
	mjd_t tmjd;

	corr = 0;
	hit = 0;
	i = sp->leapcnt;
	while (--i >= 0) {
		lp = &sp->lsis[i];
		if (*timep >= lp->ls_trans) {
			if (*timep == lp->ls_trans) {
				hit = ((i == 0 && lp->ls_corr > 0) ||
				    lp->ls_corr > sp->lsis[i - 1].ls_corr);
				if (hit)
					while (i > 0 &&
					    sp->lsis[i].ls_trans ==
					    sp->lsis[i - 1].ls_trans + 1 &&
					    sp->lsis[i].ls_corr ==
					    sp->lsis[i - 1].ls_corr + 1) {
						++hit;
						--i;
					}
			}
			corr = lp->ls_corr;
			break;
		}
	}
	days = *timep / SECSPERDAY;
	rem = (int32_t)(*timep % SECSPERDAY);
#ifdef mc68k
	if (*timep == 0x80000000) {
		/*
		** A 3B1 muffs the division on the most negative number.
		*/
		days = -24855;
		rem = -11648;
	}
#endif /* defined mc68k */
	rem += (offset - corr);
	while (rem < 0) {
		rem += SECSPERDAY;
		--days;
	}
	while (rem >= SECSPERDAY) {
		rem -= SECSPERDAY;
		++days;
	}

	tmjd.mjd = days + 40587;
	tmjd.sec = rem;
	*tmp = mjd2tm(tmjd);
#ifdef TM_GMTOFF
	tmp->TM_GMTOFF = offset;
#endif /* defined TM_GMTOFF */
}

char *
ctime(timep)
	const time_t *const timep;
{
/*
** Section 4.12.3.2 of X3.159-1989 requires that
**	The ctime function converts the calendar time pointed to by timer
**	to local time in the form of a string.  It is equivalent to
**		asctime(localtime(timer))
*/
	return asctime(localtime(timep));
}

char *
ctime_r(timep, buf)
	const time_t *const timep;
	char *buf;
{
	struct tm ctime_tm;

	return asctime_r(localtime_r(timep, &ctime_tm), buf);
}

/*
** Adapted from code provided by Robert Elz, who writes:
**	The "best" way to do mktime I think is based on an idea of Bob
**	Kridle's (so its said...) from a long time ago.
**	[kridle@@xinet.com as of 1996-01-16.]
**	It does a binary search of the time_t space.  Since time_t's are
**	just 32 bits, its a max of 32 iterations (even at 64 bits it
**	would still be very reasonable).
*/

#ifndef WRONG
#define WRONG	(-1)
#endif /* !defined WRONG */

/*
** Simplified normalize logic courtesy Paul Eggert (eggert@@twinsun.com).
*/

static int
increment_overflow(number, delta)
	int *number;
	int delta;
{
	int number0;

	number0 = *number;
	*number += delta;
	return (*number < number0) != (delta < 0);
}

static int
long_increment_overflow(number, delta)
	time_t *number;
	time_t delta;
{
	time_t number0;

	number0 = *number;
	*number += delta;
	return (*number < number0) != (delta < 0);
}

static int
normalize_overflow(tensptr, unitsptr, base)
	int *const tensptr;
	int *const unitsptr;
	const int base;
{
	int tensdelta;

	tensdelta = (*unitsptr >= 0) ?
	    (*unitsptr / base) :
	    (-1 - (-1 - *unitsptr) / base);
	*unitsptr -= tensdelta * base;
	return increment_overflow(tensptr, tensdelta);
}

static int
long_normalize_overflow(tensptr, unitsptr, base)
	time_t *const tensptr;
	int *const unitsptr;
	const int base;
{
	time_t tensdelta;

	tensdelta = (*unitsptr >= 0) ?
	    (*unitsptr / base) :
	    (-1 - (-1 - *unitsptr) / base);
	*unitsptr -= (int)(tensdelta) * base;
	return long_increment_overflow(tensptr, tensdelta);
}

static int
tmcomp(atmp, btmp)
	const struct tm *const atmp;
	const struct tm *const btmp;
{
	int result;
	time_t resyr = atmp->tm_year - btmp->tm_year;

	if (resyr > 0)
		return 1;
	else if (resyr < 0)
		return -1;

	if ((result = (atmp->tm_mon - btmp->tm_mon)) == 0 &&
	    (result = (atmp->tm_mday - btmp->tm_mday)) == 0 &&
	    (result = (atmp->tm_hour - btmp->tm_hour)) == 0 &&
	    (result = (atmp->tm_min - btmp->tm_min)) == 0)
		result = atmp->tm_sec - btmp->tm_sec;
	return result;
}

static time_t
time2sub(struct tm *const tmp, void (*const funcp) (const time_t *, long,
    struct tm *), const long offset, int *const okayp, const int do_norm_secs)
{
	const struct state *sp;
	int dir;
	int bits;
	int i, j;
	time_t li;
	time_t y;
	time_t newt;
	time_t t;
	struct tm yourtm, mytm;

	*okayp = FALSE;
	yourtm = *tmp;
	yourtm.tm_zone = NULL;
	yourtm.tm_gmtoff = 0;
	if (do_norm_secs) {
		if (normalize_overflow(&yourtm.tm_min, &yourtm.tm_sec,
		    SECSPERMIN))
			return WRONG;
	}
	if (normalize_overflow(&yourtm.tm_hour, &yourtm.tm_min, MINSPERHOUR))
		return WRONG;
	if (normalize_overflow(&yourtm.tm_mday, &yourtm.tm_hour, HOURSPERDAY))
		return WRONG;
	y = yourtm.tm_year;
	if (long_normalize_overflow(&y, &yourtm.tm_mon, MONSPERYEAR))
		return WRONG;
	/*
	** Turn y into an actual year number for now.
	** It is converted back to an offset from TM_YEAR_BASE later.
	*/
	if (long_increment_overflow(&y, (time_t)TM_YEAR_BASE))
		return WRONG;
	if (y < 0)
		++y;
	while (yourtm.tm_mday <= 0) {
		if (long_increment_overflow(&y, (time_t)-1))
			return WRONG;
		yourtm.tm_mday += year_lengths[isleap(y + (1 < yourtm.tm_mon))];
	}
	while (yourtm.tm_mday > DAYSPERLYEAR) {
		yourtm.tm_mday -= year_lengths[isleap(y + (1 < yourtm.tm_mon))];
		if (long_increment_overflow(&y, (time_t)1))
			return WRONG;
	}
	for (;;) {
		i = mon_lengths[isleap(y)][yourtm.tm_mon];
		if (yourtm.tm_mday <= i)
			break;
		yourtm.tm_mday -= i;
		if (++yourtm.tm_mon >= MONSPERYEAR) {
			yourtm.tm_mon = 0;
			if (long_increment_overflow(&y, (time_t)1))
				return WRONG;
		}
	}
	if (long_increment_overflow(&y, (time_t)-TM_YEAR_BASE))
		return WRONG;
	if (y < 1)
		--y;
	yourtm.tm_year = y;

	t = tai2timet(mjd2tai(tm2mjd(yourtm)));
	(*funcp) (&t, offset, &mytm);
	mytm.tm_zone = NULL;
	mytm.tm_gmtoff = 0;
	t += (t - tai2timet(mjd2tai(tm2mjd(mytm))));
	(*funcp) (&t, offset, &mytm);

	if (tmcomp(&mytm, &yourtm)) {
		t -= 3600;
		(*funcp) (&t, offset, &mytm);
	}
	if (tmcomp(&mytm, &yourtm))
		return WRONG;

	*tmp = mytm;
	*okayp = TRUE;
	return t;
}

static time_t
time2(tmp, funcp, offset, okayp)
	struct tm *const tmp;
	void (*const funcp) (const time_t *, long, struct tm *);
	const long offset;
	int *const okayp;
{
	time_t t;

	/*
	** First try without normalization of seconds
	** (in case tm_sec contains a value associated with a leap second).
	** If that fails, try with normalization of seconds.
	*/
	t = time2sub(tmp, funcp, offset, okayp, FALSE);
	return *okayp ? t : time2sub(tmp, funcp, offset, okayp, TRUE);
}

static time_t
time1(tmp, funcp, offset)
	struct tm *const tmp;
	void (*const funcp) (const time_t *, long, struct tm *);
	const long offset;
{
	time_t t;
	const struct state *sp;
	int samei, otheri;
	int sameind, otherind;
	int i;
	int nseen;
	int seen[TZ_MAX_TYPES];
	int types[TZ_MAX_TYPES];
	int okay;

	if (tmp->tm_isdst > 1)
		tmp->tm_isdst = 1;
	t = time2(tmp, funcp, offset, &okay);
#ifdef PCTS
	/*
	** PCTS code courtesy Grant Sullivan (grant@@osf.org).
	*/
	if (okay)
		return t;
	if (tmp->tm_isdst < 0)
		tmp->tm_isdst = 0;	/* reset to std and try again */
#endif /* defined PCTS */
#ifndef PCTS
	if (okay || tmp->tm_isdst < 0)
		return t;
#endif /* !defined PCTS */
	/*
	** We're supposed to assume that somebody took a time of one type
	** and did some math on it that yielded a "struct tm" that's bad.
	** We try to divine the type they started from and adjust to the
	** type they need.
	*/
	/*
	** The (void *) casts are the benefit of SunOS 3.3 on Sun 2's.
	*/
	sp = (const struct state *)(((void *)funcp == (void *)localsub) ?
	    lclptr : gmtptr);
	for (i = 0; i < sp->typecnt; ++i)
		seen[i] = FALSE;
	nseen = 0;
	for (i = sp->timecnt - 1; i >= 0; --i)
		if (!seen[sp->types[i]]) {
			seen[sp->types[i]] = TRUE;
			types[nseen++] = sp->types[i];
		}
	for (sameind = 0; sameind < nseen; ++sameind) {
		samei = types[sameind];
		if (sp->ttis[samei].tt_isdst != tmp->tm_isdst)
			continue;
		for (otherind = 0; otherind < nseen; ++otherind) {
			otheri = types[otherind];
			if (sp->ttis[otheri].tt_isdst == tmp->tm_isdst)
				continue;
			tmp->tm_sec += (int)(sp->ttis[otheri].tt_gmtoff -
			    sp->ttis[samei].tt_gmtoff);
			tmp->tm_isdst = !tmp->tm_isdst;
			t = time2(tmp, funcp, offset, &okay);
			if (okay)
				return t;
			tmp->tm_sec -= (int)(sp->ttis[otheri].tt_gmtoff -
			    sp->ttis[samei].tt_gmtoff);
			tmp->tm_isdst = !tmp->tm_isdst;
		}
	}
	return WRONG;
}

time_t
mktime(tmp)
	struct tm *tmp;
{
	time_t ret;

	_THREAD_PRIVATE_MUTEX_LOCK(lcl);
	tzset_basic();
	ret = time1(tmp, localsub, 0L);
	_THREAD_PRIVATE_MUTEX_UNLOCK(lcl);
	return ret;
}

time_t
timelocal(tmp)
	struct tm *const tmp;
{
	tmp->tm_isdst = -1;		/* in case it wasn't initialized */
	return mktime(tmp);
}

time_t
timegm(tmp)
	struct tm *const tmp;
{
	tmp->tm_isdst = 0;
	return time1(tmp, gmtsub, 0L);
}

time_t
timeoff(tmp, offset)
	struct tm *const tmp;
	const long offset;
{
	tmp->tm_isdst = 0;
	return time1(tmp, gmtsub, offset);
}

/* private interface */
void
_initialise_leaps(void)
{
	extern void _pushleap(time_t);
	struct state sp;
	int i;

	/* load leap seconds for UTC */
	gmtload(&sp);

	/* sanity */
	if ((!sp.leapcnt) || (sp.lsis[0].ls_trans != 78796800)
	    || (sp.leapcnt > TZ_MAX_LEAPS))
		return;

	/* copy over */
	for (i = 0; i < sp.leapcnt; ++i)
		/* XXX this does not handle negative leap seconds */
		/* XXX should abort(3) if they occur */
		_pushleap(sp.lsis[i].ls_trans);
}
@


1.17.100.1
log
@reindent and unifdef
zdump: make dumptime more generally available
@
text
@d1 1
a1 1
/**	$MirBSD: src/lib/libc/time/localtime.c,v 1.17 2004/12/24 06:16:35 tg Exp $ */
d32 1
a32 1
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.17 2004/12/24 06:16:35 tg Exp $");
d1401 1
d1409 5
@


1.16
log
@gmtime(3) and localtime(3) use an internal conversion engine called
localsub() which first splits off the time_t into the usual tuple
(day, seconds, leap second information) then performs a conversion.
There is little effort to convert the internal temporary tuple to
a mjd_t which makes us able to use mjd2tm() internally.
The results are good:

:: before
tm:             Thu Dec 23 16:43:27 2004 yday=357 dst=0 zone=<NULL> 0
gmtime:         Thu Jan -8 16:43:27 2005 yday=-9 dst=0 zone=<UTC> 0
localtime:      Thu Jan -8 17:43:27 2005 yday=-9 dst=0 zone=<CET> 3600

:: after
tm:             Thu Dec 23 16:43:27 2004 yday=357 dst=0 zone=<NULL> 0
gmtime:         Thu Dec 23 16:43:27 2004 yday=357 dst=0 zone=<UTC> 0
localtime:      Thu Dec 23 17:43:27 2004 yday=357 dst=0 zone=<CET> 3600

while here, clean up unused variables, simplify exporttai() and importtai()
and fix -Wall -Werror -W -pedantic -Wno-long-long compilates.
@
text
@d1 1
a1 1
/**	$MirBSD: src/share/misc/licence.template,v 1.20 2004/12/03 16:18:37 tg Rel $ */
d32 1
a32 1
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.15 2004/11/22 16:41:53 tg Exp $");
d1281 2
a1282 6
time2sub(tmp, funcp, offset, okayp, do_norm_secs)
	struct tm *const tmp;
	void (*const funcp) (const time_t *, long, struct tm *);
	const long offset;
	int *const okayp;
	const int do_norm_secs;
a1287 1
	int saved_seconds;
d1296 2
d1316 2
d1321 1
a1321 2
		li = y + (1 < yourtm.tm_mon);
		yourtm.tm_mday += year_lengths[isleap(li)];
d1324 1
a1324 2
		li = y + (1 < yourtm.tm_mon);
		yourtm.tm_mday -= year_lengths[isleap(li)];
d1341 2
d1344 10
a1353 34
	if (yourtm.tm_year != y)
		return WRONG;
	if (yourtm.tm_sec >= 0 && yourtm.tm_sec < SECSPERMIN)
		saved_seconds = 0;
	else if (y + TM_YEAR_BASE < EPOCH_YEAR) {
		/*
		** We can't set tm_sec to 0, because that might push the
		** time below the minimum representable time.
		** Set tm_sec to 59 instead.
		** This assumes that the minimum representable time is
		** not in the same minute that a leap second was deleted from,
		** which is a safer assumption than using 58 would be.
		*/
		if (increment_overflow(&yourtm.tm_sec, 1 - SECSPERMIN))
			return WRONG;
		saved_seconds = yourtm.tm_sec;
		yourtm.tm_sec = SECSPERMIN - 1;
	} else {
		saved_seconds = yourtm.tm_sec;
		yourtm.tm_sec = 0;
	}
	/*
	** Divide the search space in half
	** (this works whether time_t is signed or unsigned).
	*/
	bits = TYPE_BIT(time_t)-1;
	/*
	** If time_t is signed, then 0 is just above the median,
	** assuming two's complement arithmetic.
	** If time_t is unsigned, then (1 << bits) is just above the median.
	*/
	/* CONSTCOND */
	t = TYPE_SIGNED(time_t)? 0 : (((time_t)1) << bits);
	for (;;) {
a1354 47
		dir = tmcomp(&mytm, &yourtm);
		if (dir != 0) {
			if (bits-- < 0)
				return WRONG;
			if (bits < 0)
				--t;	/* may be needed if new t is minimal */
			else if (dir > 0)
				t -= ((time_t)1) << bits;
			else
				t += ((time_t)1) << bits;
			continue;
		}
		if (yourtm.tm_isdst < 0 || mytm.tm_isdst == yourtm.tm_isdst)
			break;
		/*
		** Right time, wrong type.
		** Hunt for right time, right type.
		** It's okay to guess wrong since the guess
		** gets checked.
		*/
		/*
		** The (void *) casts are the benefit of SunOS 3.3 on Sun 2's.
		*/
		sp = (const struct state *)
		    (((void *)funcp == (void *)localsub) ?
		    lclptr : gmtptr);
		for (i = sp->typecnt - 1; i >= 0; --i) {
			if (sp->ttis[i].tt_isdst != yourtm.tm_isdst)
				continue;
			for (j = sp->typecnt - 1; j >= 0; --j) {
				if (sp->ttis[j].tt_isdst == yourtm.tm_isdst)
					continue;
				newt = t + sp->ttis[j].tt_gmtoff -
				    sp->ttis[i].tt_gmtoff;
				(*funcp) (&newt, offset, &mytm);
				if (tmcomp(&mytm, &yourtm) != 0)
					continue;
				if (mytm.tm_isdst != yourtm.tm_isdst)
					continue;
				/*
				** We have a match.
				*/
				t = newt;
				goto label;
			}
		}
		return WRONG;
d1356 1
a1356 3
label:
	newt = t + saved_seconds;
	if ((newt < t) != (saved_seconds < 0))
d1358 2
a1359 2
	t = newt;
	(*funcp) (&t, offset, tmp);
a1455 3
#ifdef	TAI64_OVERRIDES_MKTIME
_real_mktime(tmp)
#else
a1456 1
#endif
@


1.15
log
@pass FSF mktime test suite over DJB-compatible
time_t range of [C000000000000000;3FFFFFFFFFFFFFFF]
@
text
@d1 1
a1 1
/**	$MirBSD: src/lib/libc/time/localtime.c,v 1.14 2004/11/22 15:33:01 tg Exp $ */
d8 9
a16 5
 * tion, including unlimited rights to use, publically perform, modi-
 * fy, merge, distribute, sell, give away or sublicence, provided the
 * above copyright notices, these terms and the disclaimer are retai-
 * ned in all redistributions, or reproduced in accompanying documen-
 * tation or other materials provided with binary redistributions.
d24 1
a24 1
 * of covered work, even if advised of the possibility of such damage.
d32 1
a32 1
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.14 2004/11/22 15:33:01 tg Exp $");
a904 7
#ifndef STD_INSPIRED
/*
** A non-static declaration of tzsetwall in a system header file
** may cause a warning about this upcoming static declaration...
*/
static
#endif /* !defined STD_INSPIRED */
d968 1
a968 1
	const long offset;
a1089 2
#ifdef STD_INSPIRED

a1098 2
#endif /* defined STD_INSPIRED */

d1107 1
a1107 1
	time_t days, y;
d1109 2
a1110 2
	int yleap, hit, i, once = 1;
	const int *ip;
d1155 4
a1158 41
	tmp->tm_hour = (int)(rem / SECSPERHOUR);
	rem = rem % SECSPERHOUR;
	tmp->tm_min = (int)(rem / SECSPERMIN);
	/*
	** A positive leap second requires a special
	** representation.  This uses "... ??:59:60" et seq.
	*/
	tmp->tm_sec = (int)(rem % SECSPERMIN) + hit;
	tmp->tm_wday = (int)((EPOCH_WDAY + days) % DAYSPERWEEK);
	if (tmp->tm_wday < 0)
		tmp->tm_wday += DAYSPERWEEK;
	y = EPOCH_YEAR;
#define LEAPS_THRU_END_OF(y)	((y) / 4 - (y) / 100 + (y) / 400)
	while (days < 0 || days >= (long)year_lengths[yleap = isleap(y)]) {
		time_t newy;

		newy = y + days / DAYSPERNYEAR;
		if (__predict_false(once)) {
			--once;
			if (days < 0)
				--newy;
		}
		if (newy == y)
			break;
		days -= (newy - y) * DAYSPERNYEAR +
		    LEAPS_THRU_END_OF(newy - 1) -
		    LEAPS_THRU_END_OF(y - 1);
		y = newy;
	}
	if (y < 1) {
		--y;
		if (!isleap(y))
			++days;
	}
	tmp->tm_year = y - TM_YEAR_BASE;
	tmp->tm_yday = (int)days;
	ip = mon_lengths[yleap];
	for (tmp->tm_mon = 0; days >= (long)ip[tmp->tm_mon]; ++(tmp->tm_mon))
		days = days - (long)ip[tmp->tm_mon];
	tmp->tm_mday = (int)(days + 1);
	tmp->tm_isdst = 0;
a1545 1
#ifdef STD_INSPIRED
a1569 1
#endif /* defined STD_INSPIRED */
@


1.14
log
@indent
@
text
@d1 1
a1 1
/**	$MirBSD: src/lib/libc/time/localtime.c,v 1.13 2004/11/22 15:32:18 tg Exp $ */
d28 1
a28 1
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.13 2004/11/22 15:32:18 tg Exp $");
d1114 3
a1116 4
	time_t days;
	long rem;
	time_t y;
	int yleap;
a1117 3
	long corr;
	int hit;
	int i;
d1179 7
a1185 2
		if (days < 0)
			--newy;
@


1.13
log
@indent, lint
@
text
@d1 1
a1 1
/**	$MirBSD: src/share/misc/licence.template,v 1.14 2004/08/15 15:29:11 tg Rel $ */
d28 1
a28 1
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.12 2004/11/22 04:26:41 tg Exp $");
d119 1
a119 1
	    (2 * (MY_TZNAME_MAX + 1)))];
@


1.12
log
@much better (still hiccups a bit with Olson's mktime() as well
as time zones, but...)
@
text
@d1 24
a24 4
/*
** This file is in the public domain, so clarified as of
** 1996-06-05 by Arthur David Olson (arthur_david_olson@@nih.gov).
*/
d26 1
a26 1
#include <sys/cdefs.h>
d28 1
a28 1
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.11 2004/11/22 03:01:50 tg Exp $");
d36 1
a36 1
/*LINTLIBRARY*/
d49 1
a49 2
#endif /* defined O_BINARY */
#ifndef O_BINARY
d51 1
a51 1
#endif /* !defined O_BINARY */
d74 1
a74 1
#endif /* !defined WILDABBR */
d76 2
a77 3
static char		wildabbr[] = "WILDABBR";

static const char	gmt[] = "UTC";
d88 1
a88 1
#endif /* !defined TZDEFDST */
d91 5
a95 5
	long		tt_gmtoff;	/* UTC offset in seconds */
	int		tt_isdst;	/* used to set tm_isdst */
	int		tt_abbrind;	/* abbreviation list index */
	int		tt_ttisstd;	/* TRUE if transition is std time */
	int		tt_ttisgmt;	/* TRUE if transition is UTC */
d99 2
a100 2
	time_t		ls_trans;	/* transition time */
	long		ls_corr;	/* correction to apply */
a102 2
#define BIGGEST(a, b)	(((a) > (b)) ? (a) : (b))

d105 1
a105 2
#endif /* defined TZNAME_MAX */
#ifndef TZNAME_MAX
d107 1
a107 1
#endif /* !defined TZNAME_MAX */
d110 11
a120 10
	int		leapcnt;
	int		timecnt;
	int		typecnt;
	int		charcnt;
	time_t		ats[TZ_MAX_TIMES];
	unsigned char	types[TZ_MAX_TIMES];
	struct ttinfo	ttis[TZ_MAX_TYPES];
	char		chars[BIGGEST(BIGGEST(TZ_MAX_CHARS + 1, sizeof gmt),
				(2 * (MY_TZNAME_MAX + 1)))];
	struct lsinfo	lsis[TZ_MAX_LEAPS];
d124 5
a128 5
	int		r_type;		/* type of rule--see below */
	int		r_day;		/* day number of rule */
	int		r_week;		/* week number of rule */
	int		r_mon;		/* month number of rule */
	long		r_time;		/* transition time of rule */
d139 26
a164 51
static long		detzcode (const char * codep);
static const char *	getzname (const char * strp);
static const char *	getnum (const char * strp, int * nump, int min,
				int max);
static const char *	getsecs (const char * strp, long * secsp);
static const char *	getoffset (const char * strp, long * offsetp);
static const char *	getrule (const char * strp, struct rule * rulep);
static void		gmtload (struct state * sp);
static void		gmtsub (const time_t * timep, long offset,
				struct tm * tmp);
static void		localsub (const time_t * timep, long offset,
				struct tm * tmp);
static int		increment_overflow (int * number, int delta);
static int		long_increment_overflow (int64_t * number, int64_t delta);
static int		long_normalize_overflow (int64_t * tensptr,
				int * unitsptr, int base);
static int		normalize_overflow (int * tensptr, int * unitsptr,
				int base);
static void		settzname (void);
static time_t		time1 (struct tm * tmp,
				void(*funcp) (const time_t *,
				long, struct tm *),
				long offset);
static time_t		time2 (struct tm *tmp,
				void(*funcp) (const time_t *,
				long, struct tm*),
				long offset, int * okayp);
static time_t		time2sub (struct tm *tmp,
				void(*funcp) (const time_t *,
				long, struct tm*),
				long offset, int * okayp, int do_norm_secs);
static void		timesub (const time_t * timep, long offset,
				const struct state * sp, struct tm * tmp);
static int		tmcomp (const struct tm * atmp,
				const struct tm * btmp);
static time_t		transtime (time_t janfirst, int year,
				const struct rule * rulep, long offset);
static int		tzload (const char * name, struct state * sp);
static int		tzparse (const char * name, struct state * sp,
				int lastditch);

time_t *		tm_getleaps (void);

#ifdef ALL_STATE
static struct state *	lclptr;
static struct state *	gmtptr;
#endif /* defined ALL_STATE */

#ifndef ALL_STATE
static struct state	lclmem;
static struct state	gmtmem;
a166 1
#endif /* State Farm */
d170 1
a170 1
#endif /* !defined TZ_STRLEN_MAX */
d172 3
a174 3
static char		lcl_TZname[TZ_STRLEN_MAX + 1];
static int		lcl_is_set;
static int		gmt_is_set;
d178 1
a178 1
char *			tzname[2] = {
d191 1
a191 10
static struct tm	tm;

#ifdef USG_COMPAT
time_t			timezone = 0;
int			daylight = 0;
#endif /* defined USG_COMPAT */

#ifdef ALTZONE
time_t			altzone = 0;
#endif /* defined ALTZONE */
d195 1
a195 1
const char * const	codep;
d197 2
a198 2
	long	result;
	int	i;
d207 1
a207 1
settzname (void)
d209 2
a210 2
	struct state * const	sp = lclptr;
	int			i;
a213 13
#ifdef USG_COMPAT
	daylight = 0;
	timezone = 0;
#endif /* defined USG_COMPAT */
#ifdef ALTZONE
	altzone = 0;
#endif /* defined ALTZONE */
#ifdef ALL_STATE
	if (sp == NULL) {
		tzname[0] = tzname[1] = gmt;
		return;
	}
#endif /* defined ALL_STATE */
d215 1
a215 1
		const struct ttinfo * const	ttisp = &sp->ttis[i];
d218 1
a218 11
			&sp->chars[ttisp->tt_abbrind];
#ifdef USG_COMPAT
		if (ttisp->tt_isdst)
			daylight = 1;
		if (i == 0 || !ttisp->tt_isdst)
			timezone = -(ttisp->tt_gmtoff);
#endif /* defined USG_COMPAT */
#ifdef ALTZONE
		if (i == 0 || ttisp->tt_isdst)
			altzone = -(ttisp->tt_gmtoff);
#endif /* defined ALTZONE */
d224 3
a226 3
		const struct ttinfo * const	ttisp =
							&sp->ttis[
								sp->types[i]];
d229 1
a229 1
			&sp->chars[ttisp->tt_abbrind];
d235 2
a236 2
const char *		name;
struct state * const	sp;
d238 3
a240 3
	const char *	p;
	int		i;
	int		fid;
d249 1
a249 1
		int	doaccess;
d257 1
a257 1
		char		fullname[FILENAME_MAX];
d267 3
a269 3
			(void) strlcpy(fullname, p, sizeof fullname);
			(void) strlcat(fullname, "/", sizeof fullname);
			(void) strlcat(fullname, name, sizeof fullname);
d283 1
a283 1
		struct tzhead *	tzhp;
d285 5
a289 5
			struct tzhead	tzhead;
			char		buf[sizeof *sp + sizeof *tzhp];
		} u;
		int		ttisstdcnt;
		int		ttisgmtcnt;
d294 6
a299 6
		ttisstdcnt = (int) detzcode(u.tzhead.tzh_ttisstdcnt);
		ttisgmtcnt = (int) detzcode(u.tzhead.tzh_ttisgmtcnt);
		sp->leapcnt = (int) detzcode(u.tzhead.tzh_leapcnt);
		sp->timecnt = (int) detzcode(u.tzhead.tzh_timecnt);
		sp->typecnt = (int) detzcode(u.tzhead.tzh_typecnt);
		sp->charcnt = (int) detzcode(u.tzhead.tzh_charcnt);
d302 14
a315 14
			sp->typecnt <= 0 || sp->typecnt > TZ_MAX_TYPES ||
			sp->timecnt < 0 || sp->timecnt > TZ_MAX_TIMES ||
			sp->charcnt < 0 || sp->charcnt > TZ_MAX_CHARS ||
			(ttisstdcnt != sp->typecnt && ttisstdcnt != 0) ||
			(ttisgmtcnt != sp->typecnt && ttisgmtcnt != 0))
				return -1;
		if (i - (p - u.buf) < sp->timecnt * 4 +	/* ats */
			sp->timecnt +			/* types */
			sp->typecnt * (4 + 2) +		/* ttinfos */
			sp->charcnt +			/* chars */
			sp->leapcnt * (4 + 4) +		/* lsinfos */
			ttisstdcnt +			/* ttisstds */
			ttisgmtcnt)			/* ttisgmts */
				return -1;
d321 1
a321 1
			sp->types[i] = (unsigned char) *p++;
d326 1
a326 1
			struct ttinfo *	ttisp;
d331 1
a331 1
			ttisp->tt_isdst = (unsigned char) *p++;
d334 1
a334 1
			ttisp->tt_abbrind = (unsigned char) *p++;
d336 2
a337 2
				ttisp->tt_abbrind > sp->charcnt)
					return -1;
d343 1
a343 1
			struct lsinfo *	lsisp;
d352 1
a352 1
			struct ttinfo *	ttisp;
d360 2
a361 2
					ttisp->tt_ttisstd != FALSE)
						return -1;
d365 1
a365 1
			struct ttinfo *	ttisp;
d373 2
a374 2
					ttisp->tt_ttisgmt != FALSE)
						return -1;
d381 3
a383 3
static const int	mon_lengths[2][MONSPERYEAR] = {
	{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
	{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
d386 1
a386 1
static const int	year_lengths[2] = {
d398 1
a398 1
const char *	strp;
d400 1
a400 1
	char	c;
d403 2
a404 2
		c != '+')
			++strp;
d417 4
a420 4
const char *	strp;
int * const		nump;
const int		min;
const int		max;
d422 2
a423 2
	char	c;
	int	num;
d450 2
a451 2
const char *	strp;
long * const		secsp;
d453 1
a453 1
	int	num;
d464 1
a464 1
	*secsp = num * (long) SECSPERHOUR;
d492 2
a493 2
const char *	strp;
long * const		offsetp;
d495 1
a495 1
	int	neg = 0;
d519 2
a520 2
const char *			strp;
struct rule * const	rulep;
d552 2
a553 1
	} else	return NULL;		/* invalid format */
d562 2
a563 1
	} else	rulep->r_time = 2 * SECSPERHOUR;	/* default = 2:00:00 */
d575 9
a583 9
const time_t				janfirst;
const int				year;
const struct rule * const	rulep;
const long				offset;
{
	int	leapyear;
	time_t	value;
	int	i;
	int		d, m1, yy0, yy1, yy2, dow;
d628 1
a628 1
			1 + yy2 + yy2 / 4 + yy1 / 4 - 2 * yy1) % 7;
d642 2
a643 2
				mon_lengths[leapyear][rulep->r_mon - 1])
					break;
d670 14
a683 14
const char *			name;
struct state * const	sp;
const int			lastditch;
{
	const char *			stdname;
	const char *			dstname;
	size_t				stdlen;
	size_t				dstlen;
	long				stdoffset;
	long				dstoffset;
	time_t *		atp;
	unsigned char *	typep;
	char *			cp;
	int			load_result;
d706 1
a706 1
		sp->leapcnt = 0;		/* so, we're off a little */
d710 1
a710 1
		dstlen = name - dstname;	/* length of DST zone name */
d717 2
a718 1
		} else	dstoffset = stdoffset - SECSPERHOUR;
d722 6
a727 6
			struct rule	start;
			struct rule	end;
			int	year;
			time_t	janfirst;
			time_t		starttime;
			time_t		endtime;
d738 1
a738 1
			sp->typecnt = 2;	/* standard time and DST */
d756 1
a756 1
					stdoffset);
d758 1
a758 1
					dstoffset);
d771 1
a771 1
					SECSPERDAY;
d774 6
a779 6
			long	theirstdoffset;
			long	theirdstoffset;
			long	theiroffset;
			int	isdst;
			int	i;
			int	j;
d791 1
a791 1
						-sp->ttis[j].tt_gmtoff;
d800 1
a800 1
						-sp->ttis[j].tt_gmtoff;
d835 1
a835 1
							theirdstoffset;
d838 1
a838 1
							theirstdoffset;
d844 2
a845 1
				else	theirstdoffset = theiroffset;
d861 1
a861 1
		sp->typecnt = 1;		/* only standard time */
d870 1
a870 1
	if ((size_t) sp->charcnt > sizeof sp->chars)
d883 1
a883 1
struct state * const	sp;
d886 1
a886 1
		(void) tzparse(gmt, sp, TRUE);
d890 1
a890 1
tzsetwall_basic (void)
d896 1
a896 10
#ifdef ALL_STATE
	if (lclptr == NULL) {
		lclptr = (struct state *) malloc(sizeof *lclptr);
		if (lclptr == NULL) {
			settzname();	/* all we can do */
			return;
		}
	}
#endif /* defined ALL_STATE */
	if (tzload((char *) NULL, lclptr) != 0)
d909 1
a909 1
tzsetwall (void)
d918 1
a918 1
tzset_basic (void)
d920 1
a920 1
	const char *	name;
a926 1

d931 1
a931 1
		(void) strlcpy(lcl_TZname, name, sizeof lcl_TZname);
a932 9
#ifdef ALL_STATE
	if (lclptr == NULL) {
		lclptr = (struct state *) malloc(sizeof *lclptr);
		if (lclptr == NULL) {
			settzname();	/* all we can do */
			return;
		}
	}
#endif /* defined ALL_STATE */
d937 1
a937 1
		lclptr->leapcnt = 0;		/* so, we're off a little */
d943 1
a943 1
		(void) strlcpy(lclptr->chars, gmt, sizeof lclptr->chars);
d946 1
a946 1
			(void) gmtload(lclptr);
d951 1
a951 1
tzset (void)
d970 8
a977 8
const time_t * const	timep;
const long		offset;
struct tm * const	tmp;
{
	struct state *		sp;
	const struct ttinfo *	ttisp;
	int			i;
	const time_t		t = *timep;
a979 6
#ifdef ALL_STATE
	if (sp == NULL) {
		gmtsub(timep, offset, tmp);
		return;
	}
#endif /* defined ALL_STATE */
d1014 2
a1015 2
const time_t * const	timep;
struct tm *p_tm;
d1026 1
a1026 1
const time_t * const	timep;
d1029 1
a1029 1
	struct tm * p_tm = (struct tm*)_THREAD_PRIVATE(localtime, tm, NULL);
d1042 3
a1044 3
const time_t * const	timep;
const long		offset;
struct tm * const	tmp;
d1049 1
a1049 5
#ifdef ALL_STATE
		gmtptr = (struct state *) malloc(sizeof *gmtptr);
		if (gmtptr != NULL)
#endif /* defined ALL_STATE */
			gmtload(gmtptr);
a1061 6
#ifdef ALL_STATE
		if (gmtptr == NULL)
			tmp->TM_ZONE = gmt;
		else	tmp->TM_ZONE = gmtptr->chars;
#endif /* defined ALL_STATE */
#ifndef ALL_STATE
a1062 1
#endif /* State Farm */
d1073 2
a1074 2
const time_t *		timep;
struct tm *		p_tm;
d1082 1
a1082 1
const time_t * const	timep;
d1085 1
a1085 1
	struct tm * p_tm = (struct tm*) _THREAD_PRIVATE(gmtime, tm, NULL);
d1097 2
a1098 2
const time_t * const	timep;
const long		offset;
d1108 14
a1121 14
const time_t * const			timep;
const long				offset;
const struct state * const	sp;
struct tm * const		tmp;
{
	const struct lsinfo *	lp;
	int64_t			days;
	long			rem;
	int64_t			y;
	int			yleap;
	const int *		ip;
	long			corr;
	int			hit;
	int			i;
a1124 4
#ifdef ALL_STATE
	i = (sp == NULL) ? 0 : sp->leapcnt;
#endif /* defined ALL_STATE */
#ifndef ALL_STATE
a1125 1
#endif /* State Farm */
d1131 1
a1131 1
					lp->ls_corr > sp->lsis[i - 1].ls_corr);
d1134 6
a1139 6
						sp->lsis[i].ls_trans ==
						sp->lsis[i - 1].ls_trans + 1 &&
						sp->lsis[i].ls_corr ==
						sp->lsis[i - 1].ls_corr + 1) {
							++hit;
							--i;
d1147 1
a1147 1
	rem = *timep % SECSPERDAY;
d1166 1
a1166 1
	tmp->tm_hour = (int) (rem / SECSPERHOUR);
d1168 1
a1168 1
	tmp->tm_min = (int) (rem / SECSPERMIN);
d1173 2
a1174 2
	tmp->tm_sec = (int) (rem % SECSPERMIN) + hit;
	tmp->tm_wday = (int) ((EPOCH_WDAY + days) % DAYSPERWEEK);
d1179 2
a1180 2
	while (days < 0 || days >= (long) year_lengths[yleap = isleap(y)]) {
		int64_t	newy;
d1186 2
a1187 2
			LEAPS_THRU_END_OF(newy - 1) -
			LEAPS_THRU_END_OF(y - 1);
d1196 1
a1196 1
	tmp->tm_yday = (int) days;
d1198 3
a1200 3
	for (tmp->tm_mon = 0; days >= (long) ip[tmp->tm_mon]; ++(tmp->tm_mon))
		days = days - (long) ip[tmp->tm_mon];
	tmp->tm_mday = (int) (days + 1);
d1209 1
a1209 1
const time_t * const	timep;
d1222 2
a1223 2
const time_t * const	timep;
char *			buf;
d1225 1
a1225 1
	struct tm	tm;
d1227 1
a1227 1
	return asctime_r(localtime_r(timep, &tm), buf);
d1250 2
a1251 2
int *	number;
int	delta;
d1253 1
a1253 1
	int	number0;
d1262 2
a1263 2
int64_t *	number;
int64_t	delta;
d1265 1
a1265 1
	long	number0;
d1274 3
a1276 3
int * const	tensptr;
int * const	unitsptr;
const int	base;
d1278 1
a1278 1
	int	tensdelta;
d1281 2
a1282 2
		(*unitsptr / base) :
		(-1 - (-1 - *unitsptr) / base);
d1289 3
a1291 3
int64_t * const	tensptr;
int * const	unitsptr;
const int	base;
d1293 1
a1293 1
	int64_t	tensdelta;
d1296 3
a1298 3
		(*unitsptr / base) :
		(-1 - (-1 - *unitsptr) / base);
	*unitsptr -= tensdelta * base;
d1304 2
a1305 2
const struct tm * const atmp;
const struct tm * const btmp;
d1307 2
a1308 2
	int	result;
	int64_t resyr = atmp->tm_year - btmp->tm_year;
d1316 4
a1319 4
		(result = (atmp->tm_mday - btmp->tm_mday)) == 0 &&
		(result = (atmp->tm_hour - btmp->tm_hour)) == 0 &&
		(result = (atmp->tm_min - btmp->tm_min)) == 0)
			result = atmp->tm_sec - btmp->tm_sec;
d1325 16
a1340 16
struct tm * const	tmp;
void (* const		funcp) (const time_t*, long, struct tm*);
const long		offset;
int * const		okayp;
const int		do_norm_secs;
{
	const struct state *	sp;
	int			dir;
	int			bits;
	int			i, j;
	int			saved_seconds;
	int64_t			li;
	int64_t				y;
	time_t				newt;
	time_t				t;
	struct tm			yourtm, mytm;
d1346 2
a1347 2
			SECSPERMIN))
				return WRONG;
d1360 1
a1360 1
	if (long_increment_overflow(&y, TM_YEAR_BASE))
d1363 1
a1363 1
		if (long_increment_overflow(&y, -1))
d1371 1
a1371 1
		if (long_increment_overflow(&y, 1))
d1374 1
a1374 1
	for ( ; ; ) {
d1381 1
a1381 1
			if (long_increment_overflow(&y, 1))
d1385 1
a1385 1
	if (long_increment_overflow(&y, -TM_YEAR_BASE))
d1389 1
a1389 1
 		return WRONG;
d1413 1
a1413 1
	bits = TYPE_BIT(time_t) - 1;
d1419 4
a1422 3
	t = TYPE_SIGNED(time_t) ? 0 : (((time_t) 1) << bits);
	for ( ; ; ) {
		(*funcp)(&t, offset, &mytm);
d1428 1
a1428 1
				--t; /* may be needed if new t is minimal */
d1430 3
a1432 2
				t -= ((time_t) 1) << bits;
			else	t += ((time_t) 1) << bits;
d1447 2
a1448 6
			(((void *) funcp == (void *) localsub) ?
			lclptr : gmtptr);
#ifdef ALL_STATE
		if (sp == NULL)
			return WRONG;
#endif /* defined ALL_STATE */
d1456 2
a1457 2
					sp->ttis[i].tt_gmtoff;
				(*funcp)(&newt, offset, &mytm);
d1476 1
a1476 1
	(*funcp)(&t, offset, tmp);
d1483 4
a1486 4
struct tm * const	tmp;
void (* const		funcp) (const time_t*, long, struct tm*);
const long		offset;
int * const		okayp;
d1488 1
a1488 1
	time_t	t;
d1501 13
a1513 13
struct tm * const	tmp;
void (* const		funcp) (const time_t *, long, struct tm *);
const long		offset;
{
	time_t			t;
	const struct state *	sp;
	int			samei, otheri;
	int			sameind, otherind;
	int			i;
	int			nseen;
	int			seen[TZ_MAX_TYPES];
	int			types[TZ_MAX_TYPES];
	int			okay;
d1540 2
a1541 6
	sp = (const struct state *) (((void *) funcp == (void *) localsub) ?
		lclptr : gmtptr);
#ifdef ALL_STATE
	if (sp == NULL)
		return WRONG;
#endif /* defined ALL_STATE */
d1558 2
a1559 2
			tmp->tm_sec += sp->ttis[otheri].tt_gmtoff -
					sp->ttis[samei].tt_gmtoff;
d1564 2
a1565 2
			tmp->tm_sec -= sp->ttis[otheri].tt_gmtoff -
					sp->ttis[samei].tt_gmtoff;
d1578 1
a1578 1
struct tm *tmp;
a1589 1

d1592 1
a1592 1
struct tm * const	tmp;
d1594 1
a1594 1
	tmp->tm_isdst = -1;	/* in case it wasn't initialized */
d1600 1
a1600 1
struct tm * const	tmp;
d1608 2
a1609 2
struct tm * const	tmp;
const long		offset;
a1613 98

#endif /* defined STD_INSPIRED */

#ifdef CMUCS

/*
** The following is supplied for compatibility with
** previous versions of the CMUCS runtime library.
*/

long
gtime(tmp)
struct tm * const	tmp;
{
	const time_t	t = mktime(tmp);

	if (t == WRONG)
		return -1;
	return t;
}

#endif /* defined CMUCS */

/*
** XXX--is the below the right way to conditionalize??
*/

#if 0
/* #ifdef STD_INSPIRED */

/*
** IEEE Std 1003.1-1988 (POSIX) legislates that 536457599
** shall correspond to "Wed Dec 31 23:59:59 UTC 1986", which
** is not the case if we are accounting for leap seconds.
** So, we provide the following conversion routines for use
** when exchanging timestamps with POSIX conforming systems.
*/

static long
leapcorr(timep)
time_t *	timep;
{
	struct state *		sp;
	struct lsinfo *	lp;
	int			i;

	sp = lclptr;
	i = sp->leapcnt;
	while (--i >= 0) {
		lp = &sp->lsis[i];
		if (*timep >= lp->ls_trans)
			return lp->ls_corr;
	}
	return 0;
}

time_t
time2posix(t)
time_t	t;
{
	tzset();
	return t - leapcorr(&t);
}

time_t
posix2time(t)
time_t	t;
{
	time_t	x;
	time_t	y;

	tzset();
	/*
	** For a positive leap second hit, the result
	** is not unique.  For a negative leap second
	** hit, the corresponding time doesn't exist,
	** so we return an adjacent second.
	*/
	x = t + leapcorr(&t);
	y = x - leapcorr(&x);
	if (y < t) {
		do {
			x++;
			y = x - leapcorr(&x);
		} while (y < t);
		if (t != y)
			return x - 1;
	} else if (y > t) {
		do {
			--x;
			y = x - leapcorr(&x);
		} while (y > t);
		if (t != y)
			return x + 1;
	}
	return x;
}

@


1.11
log
@bump tm_year to 64 bits
@
text
@d8 1
a8 1
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.10 2004/11/22 02:49:24 tg Exp $");
d1034 1
a1034 1
	const time_t			t = *timep;
d1387 1
d1389 6
a1394 2
	if ((result = (atmp->tm_year - btmp->tm_year)) == 0 &&
		(result = (atmp->tm_mon - btmp->tm_mon)) == 0 &&
d1592 3
a1594 3
	int				seen[TZ_MAX_TYPES];
	int				types[TZ_MAX_TYPES];
	int				okay;
@


1.10
log
@fix maths and a proto
@
text
@d8 1
a8 1
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.9 2004/11/22 02:48:24 tg Exp $");
d136 2
a137 2
static int		long_increment_overflow (long * number, int delta);
static int		long_normalize_overflow (long * tensptr,
d1188 1
a1188 1
	long			days;
d1190 1
a1190 1
	long			y;
d1259 1
a1259 1
		long	newy;
d1341 2
a1342 2
long *	number;
int	delta;
d1368 1
a1368 1
long * const	tensptr;
d1372 1
a1372 1
	int	tensdelta;
d1410 2
a1411 2
	long			li;
	long				y;
@


1.9
log
@ansi
@
text
@d8 1
a8 1
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.8 2004/10/31 16:48:27 tg Exp $");
d1269 5
d1658 1
a1658 1
struct tm * const	tmp;
@


1.8
log
@no time2posix() et al., thank you
we've got the tai64 fns for that
@
text
@d8 1
a8 1
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.7 2004/10/22 21:53:41 tg Exp $");
d123 40
a162 40
static long		detzcode P((const char * codep));
static const char *	getzname P((const char * strp));
static const char *	getnum P((const char * strp, int * nump, int min,
				int max));
static const char *	getsecs P((const char * strp, long * secsp));
static const char *	getoffset P((const char * strp, long * offsetp));
static const char *	getrule P((const char * strp, struct rule * rulep));
static void		gmtload P((struct state * sp));
static void		gmtsub P((const time_t * timep, long offset,
				struct tm * tmp));
static void		localsub P((const time_t * timep, long offset,
				struct tm * tmp));
static int		increment_overflow P((int * number, int delta));
static int		long_increment_overflow P((long * number, int delta));
static int		long_normalize_overflow P((long * tensptr,
				int * unitsptr, int base));
static int		normalize_overflow P((int * tensptr, int * unitsptr,
				int base));
static void		settzname P((void));
static time_t		time1 P((struct tm * tmp,
				void(*funcp) P((const time_t *,
				long, struct tm *)),
				long offset));
static time_t		time2 P((struct tm *tmp,
				void(*funcp) P((const time_t *,
				long, struct tm*)),
				long offset, int * okayp));
static time_t		time2sub P((struct tm *tmp,
				void(*funcp) P((const time_t *,
				long, struct tm*)),
				long offset, int * okayp, int do_norm_secs));
static void		timesub P((const time_t * timep, long offset,
				const struct state * sp, struct tm * tmp));
static int		tmcomp P((const struct tm * atmp,
				const struct tm * btmp));
static time_t		transtime P((time_t janfirst, int year,
				const struct rule * rulep, long offset));
static int		tzload P((const char * name, struct state * sp));
static int		tzparse P((const char * name, struct state * sp,
				int lastditch));
d164 1
a164 1
time_t *		tm_getleaps P((void));
d216 2
a217 2
	register long	result;
	register int	i;
d226 1
a226 1
settzname P((void))
d228 2
a229 2
	register struct state * const	sp = lclptr;
	register int			i;
d247 1
a247 1
		register const struct ttinfo * const	ttisp = &sp->ttis[i];
d266 1
a266 1
		register const struct ttinfo * const	ttisp =
d277 2
a278 2
register const char *		name;
register struct state * const	sp;
d280 3
a282 3
	register const char *	p;
	register int		i;
	register int		fid;
d291 1
a291 1
		register int	doaccess;
d368 1
a368 1
			register struct ttinfo *	ttisp;
d385 1
a385 1
			register struct lsinfo *	lsisp;
d394 1
a394 1
			register struct ttinfo *	ttisp;
d407 1
a407 1
			register struct ttinfo *	ttisp;
d440 1
a440 1
register const char *	strp;
d442 1
a442 1
	register char	c;
d459 1
a459 1
register const char *	strp;
d464 2
a465 2
	register char	c;
	register int	num;
d492 1
a492 1
register const char *	strp;
d534 1
a534 1
register const char *	strp;
d537 1
a537 1
	register int	neg = 0;
d562 1
a562 1
register struct rule * const	rulep;
d617 1
a617 1
register const struct rule * const	rulep;
d620 3
a622 3
	register int	leapyear;
	register time_t	value;
	register int	i;
d711 1
a711 1
register struct state * const	sp;
d720 4
a723 4
	register time_t *		atp;
	register unsigned char *	typep;
	register char *			cp;
	register int			load_result;
d763 2
a764 2
			register int	year;
			register time_t	janfirst;
d813 6
a818 6
			register long	theirstdoffset;
			register long	theirdstoffset;
			register long	theiroffset;
			register int	isdst;
			register int	i;
			register int	j;
d928 1
a928 1
tzsetwall_basic P((void))
d956 1
a956 1
tzsetwall P((void))
d965 1
a965 1
tzset_basic P((void))
d967 1
a967 1
	register const char *	name;
d1008 1
a1008 1
tzset P((void))
d1031 3
a1033 3
	register struct state *		sp;
	register const struct ttinfo *	ttisp;
	register int			i;
d1184 2
a1185 2
register const struct state * const	sp;
register struct tm * const		tmp;
d1187 9
a1195 9
	register const struct lsinfo *	lp;
	register long			days;
	register long			rem;
	register long			y;
	register int			yleap;
	register const int *		ip;
	register long			corr;
	register int			hit;
	register int			i;
d1259 1
a1259 1
		register long	newy;
d1352 1
a1352 1
	register int	tensdelta;
d1367 1
a1367 1
	register int	tensdelta;
d1378 2
a1379 2
register const struct tm * const atmp;
register const struct tm * const btmp;
d1381 1
a1381 1
	register int	result;
d1395 1
a1395 1
void (* const		funcp) P((const time_t*, long, struct tm*));
d1400 6
a1405 6
	register const struct state *	sp;
	register int			dir;
	register int			bits;
	register int			i, j;
	register int			saved_seconds;
	register long			li;
d1555 1
a1555 1
void (* const		funcp) P((const time_t*, long, struct tm*));
d1573 1
a1573 1
void (* const		funcp) P((const time_t *, long, struct tm *));
d1576 6
a1581 6
	register time_t			t;
	register const struct state *	sp;
	register int			samei, otheri;
	register int			sameind, otherind;
	register int			i;
	register int			nseen;
d1732 3
a1734 3
	register struct state *		sp;
	register struct lsinfo *	lp;
	register int			i;
@


1.7
log
@merge; fix; whitespace; bump libc level
XXX untested
@
text
@d8 1
a8 1
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.6 2004/06/23 14:47:04 tg Stab $");
d1717 2
a1718 1
#ifdef STD_INSPIRED
@


1.6
log
@* final fixes and implementation for TAI time, MJD
  (modified julian dates) and calendar conversion (in part
  courtesy of Dan Bernstein's public domain implementation
  of libtai)
* replace mktime(3) from libtz with calls to
  struct tm -> tm2mjd() -> mjd2tai() -> tai2timet() -> time_t
  (only if defined in private.h) because mktime() is not
  64-bit-time_t clean
@
text
@d7 2
a8 2
__SCCSID("@@(#)localtime.c	7.76");
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.5 2004/06/23 12:37:11 tg Exp $");
d136 3
d1071 4
d1141 4
d1190 1
a1190 1
	register int			y;
d1259 1
a1259 1
		register int	newy;
d1335 12
d1362 15
d1403 1
a1403 1
	register int			i, j ;
d1405 2
d1422 2
a1423 1
	if (normalize_overflow(&yourtm.tm_year, &yourtm.tm_mon, MONSPERYEAR))
d1426 1
a1426 1
	** Turn yourtm.tm_year into an actual year number for now.
d1429 1
a1429 1
	if (increment_overflow(&yourtm.tm_year, TM_YEAR_BASE))
d1432 1
a1432 1
		if (increment_overflow(&yourtm.tm_year, -1))
d1434 2
a1435 2
		i = yourtm.tm_year + (1 < yourtm.tm_mon);
		yourtm.tm_mday += year_lengths[isleap(i)];
d1438 3
a1440 3
		i = yourtm.tm_year + (1 < yourtm.tm_mon);
		yourtm.tm_mday -= year_lengths[isleap(i)];
		if (increment_overflow(&yourtm.tm_year, 1))
d1444 1
a1444 1
		i = mon_lengths[isleap(yourtm.tm_year)][yourtm.tm_mon];
d1450 1
a1450 1
			if (increment_overflow(&yourtm.tm_year, 1))
d1454 1
a1454 1
	if (increment_overflow(&yourtm.tm_year, -TM_YEAR_BASE))
d1456 3
d1461 1
a1461 1
	else if (yourtm.tm_year + TM_YEAR_BASE < EPOCH_YEAR) {
d1579 5
d1617 10
a1626 1
	for (samei = sp->typecnt - 1; samei >= 0; --samei) {
d1629 2
a1630 1
		for (otheri = sp->typecnt - 1; otheri >= 0; --otheri) {
@


1.5
log
@first of the new API for TAI64.
This time DJB compatible (since I discovered recently that our
new 64 bit time_t with the non-default epoch of 1970-01-01 00:00:00
was equivalent to the old attempt at tai64'ing).

MJD code to come. leap second code working already.
@
text
@d8 1
a8 1
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.4 2004/06/09 19:20:16 tg Exp $");
d1589 3
d1593 1
@


1.4
log
@expose the leap second get API together with a new
API which handles signed 64-bit TAI values (including
conversion routines to kernel time, POSIXly broken (ie,
UTC) kernel time (for NTP) and DJB TAI64 in both the
common TAI64 and exported TAI64NA format).

To use the API, define _MIROS_TAI64 before including <time.h>
@
text
@d8 1
a8 1
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.3 2004/06/09 16:56:06 tg Exp $");
d1726 3
a1728 2
time_t *
tm_getleaps(void)
d1730 1
a1730 2
	static int initialised = 0;
	static time_t list[TZ_MAX_LEAPS] = { 0 };
a1733 3
	if (initialised && list[0])
		return list;

a1734 1
	initialised = 0;
d1738 3
a1740 2
	if ((!sp.leapcnt) || (sp.lsis[0].ls_trans != 78796800))
		return NULL;
d1744 3
a1746 4
		list[i] = sp.lsis[i].ls_trans;
	list[sp.leapcnt] = 0;
	initialised = 1;
	return list;
@


1.3
log
@Add a static function to return a list of leap seconds
which are contained in the default UTC file, just like
the ntpleaps_read() function in rdate(8).
@
text
@d8 1
a8 1
__RCSID("$MirBSD: src/lib/libc/time/localtime.c,v 1.2 2004/06/09 14:49:16 tg Exp $");
d161 2
d1727 1
a1727 1
_getleaps(void)
@


1.2
log
@Use /usr/share/zoneinfo/UTC not /usr/share/zoneinfo/GMT for leap seconds
MirOSify
@
text
@d8 1
a8 1
__RCSID("$MirBSD$");
d1723 27
@


1.1
log
@Initial revision
@
text
@d6 3
a8 4
#if defined(LIBC_SCCS) && !defined(lint) && !defined(NOID)
static char elsieid[] = "@@(#)localtime.c	7.75";
static char rcsid[] = "$OpenBSD: localtime.c,v 1.22 2003/03/13 15:47:34 deraadt Exp $";
#endif /* LIBC_SCCS and not lint */
d59 1
a59 1
static const char	gmt[] = "GMT";
d331 2
a332 2
		ttisstdcnt = (int) detzcode(u.tzhead.tzh_ttisgmtcnt);
		ttisgmtcnt = (int) detzcode(u.tzhead.tzh_ttisstdcnt);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d7 2
a8 2
static char elsieid[] = "@@(#)localtime.c	7.76";
static char rcsid[] = "$OpenBSD: localtime.c,v 1.23 2003/10/06 00:17:13 millert Exp $";
d332 2
a333 2
		ttisstdcnt = (int) detzcode(u.tzhead.tzh_ttisstdcnt);
		ttisgmtcnt = (int) detzcode(u.tzhead.tzh_ttisgmtcnt);
@


1.1.1.3
log
@import some updates/fixes from openbsd
@
text
@d7 2
a8 2
static char elsieid[] = "@@(#)localtime.c	7.80";
static char rcsid[] = "$OpenBSD: localtime.c,v 1.25 2004/10/18 22:33:43 millert Exp $";
a136 3
static int		long_increment_overflow P((long * number, int delta));
static int		long_normalize_overflow P((long * tensptr,
				int * unitsptr, int base));
a1066 4
/*
** Re-entrant version of localtime.
*/

a1132 4
/*
** Re-entrant version of gmtime.
*/

d1178 1
a1178 1
	register long			y;
d1247 1
a1247 1
		register long	newy;
a1322 12
long_increment_overflow(number, delta)
long *	number;
int	delta;
{
	long	number0;

	number0 = *number;
	*number += delta;
	return (*number < number0) != (delta < 0);
}

static int
a1337 15
long_normalize_overflow(tensptr, unitsptr, base)
long * const	tensptr;
int * const	unitsptr;
const int	base;
{
	register int	tensdelta;

	tensdelta = (*unitsptr >= 0) ?
		(*unitsptr / base) :
		(-1 - (-1 - *unitsptr) / base);
	*unitsptr -= tensdelta * base;
	return long_increment_overflow(tensptr, tensdelta);
}

static int
d1364 1
a1364 1
	register int			i, j;
a1365 2
	register long			li;
	long				y;
d1381 1
a1381 2
	y = yourtm.tm_year;
	if (long_normalize_overflow(&y, &yourtm.tm_mon, MONSPERYEAR))
d1384 1
a1384 1
	** Turn y into an actual year number for now.
d1387 1
a1387 1
	if (long_increment_overflow(&y, TM_YEAR_BASE))
d1390 1
a1390 1
		if (long_increment_overflow(&y, -1))
d1392 2
a1393 2
		li = y + (1 < yourtm.tm_mon);
		yourtm.tm_mday += year_lengths[isleap(li)];
d1396 3
a1398 3
		li = y + (1 < yourtm.tm_mon);
		yourtm.tm_mday -= year_lengths[isleap(li)];
		if (long_increment_overflow(&y, 1))
d1402 1
a1402 1
		i = mon_lengths[isleap(y)][yourtm.tm_mon];
d1408 1
a1408 1
			if (long_increment_overflow(&y, 1))
d1412 1
a1412 1
	if (long_increment_overflow(&y, -TM_YEAR_BASE))
a1413 3
	yourtm.tm_year = y;
	if (yourtm.tm_year != y)
 		return WRONG;
d1416 1
a1416 1
	else if (y + TM_YEAR_BASE < EPOCH_YEAR) {
a1533 5
	register int			sameind, otherind;
	register int			i;
	register int			nseen;
	int				seen[TZ_MAX_TYPES];
	int				types[TZ_MAX_TYPES];
d1567 1
a1567 10
	for (i = 0; i < sp->typecnt; ++i)
		seen[i] = FALSE;
	nseen = 0;
	for (i = sp->timecnt - 1; i >= 0; --i)
		if (!seen[sp->types[i]]) {
			seen[sp->types[i]] = TRUE;
			types[nseen++] = sp->types[i];
		}
	for (sameind = 0; sameind < nseen; ++sameind) {
		samei = types[sameind];
d1570 1
a1570 2
		for (otherind = 0; otherind < nseen; ++otherind) {
			otheri = types[otherind];
@


